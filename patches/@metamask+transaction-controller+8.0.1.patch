diff --git a/node_modules/@metamask/transaction-controller/dist/.patch.txt b/node_modules/@metamask/transaction-controller/dist/.patch.txt
new file mode 100644
index 0000000..550de56
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/.patch.txt
@@ -0,0 +1,7 @@
+PATCH GENERATED FROM MetaMask/core branch: patch/mobile-transaction-controller-8-0-1
+This patch backports various transaction controller features from the main branch of MetaMask/core
+Steps to update patch:
+* Create a new core branch from: patch/mobile-transaction-controller-8-0-1
+* Run "yarn build" in the core monorepo
+* Run "yarn patch:tx <core-directory>" in the mobile repo
+* Once the new patch is merged, add your changes to: patch/mobile-transaction-controller-8-0-1
diff --git a/node_modules/@metamask/transaction-controller/dist/EtherscanRemoteTransactionSource.d.ts b/node_modules/@metamask/transaction-controller/dist/EtherscanRemoteTransactionSource.d.ts
index d89ef46..7637754 100644
--- a/node_modules/@metamask/transaction-controller/dist/EtherscanRemoteTransactionSource.d.ts
+++ b/node_modules/@metamask/transaction-controller/dist/EtherscanRemoteTransactionSource.d.ts
@@ -4,12 +4,11 @@ import type { RemoteTransactionSource, RemoteTransactionSourceRequest, Transacti
  */
 export declare class EtherscanRemoteTransactionSource implements RemoteTransactionSource {
     #private;
-    /**
-     * Retrieve transaction data from Etherscan.
-     *
-     * @param request - The configuration required to fetch Etherscan transaction data.
-     * @returns An array of transaction metadata.
-     */
+    constructor({ apiKey, includeTokenTransfers, }?: {
+        apiKey?: string;
+        includeTokenTransfers?: boolean;
+    });
+    isSupportedNetwork(chainId: string, _networkId: string): boolean;
     fetchTransactions(request: RemoteTransactionSourceRequest): Promise<TransactionMeta[]>;
 }
 //# sourceMappingURL=EtherscanRemoteTransactionSource.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/EtherscanRemoteTransactionSource.d.ts.map b/node_modules/@metamask/transaction-controller/dist/EtherscanRemoteTransactionSource.d.ts.map
deleted file mode 100644
index 4f8dae0..0000000
--- a/node_modules/@metamask/transaction-controller/dist/EtherscanRemoteTransactionSource.d.ts.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"EtherscanRemoteTransactionSource.d.ts","sourceRoot":"","sources":["../src/EtherscanRemoteTransactionSource.ts"],"names":[],"mappings":"AAcA,OAAO,KAAK,EACV,uBAAuB,EACvB,8BAA8B,EAC9B,eAAe,EAChB,MAAM,SAAS,CAAC;AAGjB;;GAEG;AACH,qBAAa,gCACX,YAAW,uBAAuB;;IAElC;;;;;OAKG;IACG,iBAAiB,CACrB,OAAO,EAAE,8BAA8B,GACtC,OAAO,CAAC,eAAe,EAAE,CAAC;CAqG9B"}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/EtherscanRemoteTransactionSource.js b/node_modules/@metamask/transaction-controller/dist/EtherscanRemoteTransactionSource.js
index 63fdb89..0902b41 100644
--- a/node_modules/@metamask/transaction-controller/dist/EtherscanRemoteTransactionSource.js
+++ b/node_modules/@metamask/transaction-controller/dist/EtherscanRemoteTransactionSource.js
@@ -8,38 +8,50 @@ var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, ge
         step((generator = generator.apply(thisArg, _arguments || [])).next());
     });
 };
+var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
+    if (kind === "m") throw new TypeError("Private method is not writable");
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
+    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
+};
 var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
     if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
     if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
     return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
 };
-var _EtherscanRemoteTransactionSource_instances, _EtherscanRemoteTransactionSource_normalizeTransaction, _EtherscanRemoteTransactionSource_normalizeTokenTransaction, _EtherscanRemoteTransactionSource_normalizeTransactionBase;
+var _EtherscanRemoteTransactionSource_instances, _EtherscanRemoteTransactionSource_apiKey, _EtherscanRemoteTransactionSource_includeTokenTransfers, _EtherscanRemoteTransactionSource_normalizeTransaction, _EtherscanRemoteTransactionSource_normalizeTokenTransaction, _EtherscanRemoteTransactionSource_normalizeTransactionBase;
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.EtherscanRemoteTransactionSource = void 0;
 const controller_utils_1 = require("@metamask/controller-utils");
 const ethereumjs_util_1 = require("ethereumjs-util");
 const uuid_1 = require("uuid");
+const constants_1 = require("./constants");
 const etherscan_1 = require("./etherscan");
 const types_1 = require("./types");
 /**
  * A RemoteTransactionSource that fetches transaction data from Etherscan.
  */
 class EtherscanRemoteTransactionSource {
-    constructor() {
+    constructor({ apiKey, includeTokenTransfers, } = {}) {
         _EtherscanRemoteTransactionSource_instances.add(this);
+        _EtherscanRemoteTransactionSource_apiKey.set(this, void 0);
+        _EtherscanRemoteTransactionSource_includeTokenTransfers.set(this, void 0);
+        __classPrivateFieldSet(this, _EtherscanRemoteTransactionSource_apiKey, apiKey, "f");
+        __classPrivateFieldSet(this, _EtherscanRemoteTransactionSource_includeTokenTransfers, includeTokenTransfers !== null && includeTokenTransfers !== void 0 ? includeTokenTransfers : true, "f");
+    }
+    isSupportedNetwork(chainId, _networkId) {
+        return Object.keys(constants_1.ETHERSCAN_SUPPORTED_NETWORKS).includes(chainId);
     }
-    /**
-     * Retrieve transaction data from Etherscan.
-     *
-     * @param request - The configuration required to fetch Etherscan transaction data.
-     * @returns An array of transaction metadata.
-     */
     fetchTransactions(request) {
         return __awaiter(this, void 0, void 0, function* () {
-            const [etherscanTransactions, etherscanTokenTransactions] = yield Promise.all([
-                (0, etherscan_1.fetchEtherscanTransactions)(request),
-                (0, etherscan_1.fetchEtherscanTokenTransactions)(request),
-            ]);
+            const etherscanRequest = Object.assign(Object.assign({}, request), { apiKey: __classPrivateFieldGet(this, _EtherscanRemoteTransactionSource_apiKey, "f"), chainId: request.currentChainId });
+            const transactionPromise = (0, etherscan_1.fetchEtherscanTransactions)(etherscanRequest);
+            const tokenTransactionPromise = __classPrivateFieldGet(this, _EtherscanRemoteTransactionSource_includeTokenTransfers, "f")
+                ? (0, etherscan_1.fetchEtherscanTokenTransactions)(etherscanRequest)
+                : Promise.resolve({
+                    result: [],
+                });
+            const [etherscanTransactions, etherscanTokenTransactions] = yield Promise.all([transactionPromise, tokenTransactionPromise]);
             const transactions = etherscanTransactions.result.map((tx) => __classPrivateFieldGet(this, _EtherscanRemoteTransactionSource_instances, "m", _EtherscanRemoteTransactionSource_normalizeTransaction).call(this, tx, request.currentNetworkId, request.currentChainId));
             const tokenTransactions = etherscanTokenTransactions.result.map((tx) => __classPrivateFieldGet(this, _EtherscanRemoteTransactionSource_instances, "m", _EtherscanRemoteTransactionSource_normalizeTokenTransaction).call(this, tx, request.currentNetworkId, request.currentChainId));
             return [...transactions, ...tokenTransactions];
@@ -47,7 +59,7 @@ class EtherscanRemoteTransactionSource {
     }
 }
 exports.EtherscanRemoteTransactionSource = EtherscanRemoteTransactionSource;
-_EtherscanRemoteTransactionSource_instances = new WeakSet(), _EtherscanRemoteTransactionSource_normalizeTransaction = function _EtherscanRemoteTransactionSource_normalizeTransaction(txMeta, currentNetworkId, currentChainId) {
+_EtherscanRemoteTransactionSource_apiKey = new WeakMap(), _EtherscanRemoteTransactionSource_includeTokenTransfers = new WeakMap(), _EtherscanRemoteTransactionSource_instances = new WeakSet(), _EtherscanRemoteTransactionSource_normalizeTransaction = function _EtherscanRemoteTransactionSource_normalizeTransaction(txMeta, currentNetworkId, currentChainId) {
     const base = __classPrivateFieldGet(this, _EtherscanRemoteTransactionSource_instances, "m", _EtherscanRemoteTransactionSource_normalizeTransactionBase).call(this, txMeta, currentNetworkId, currentChainId);
     return Object.assign(Object.assign(Object.assign({}, base), { transaction: Object.assign(Object.assign({}, base.transaction), { data: txMeta.input }) }), (txMeta.isError === '0'
         ? { status: types_1.TransactionStatus.confirmed }
diff --git a/node_modules/@metamask/transaction-controller/dist/EtherscanRemoteTransactionSource.js.map b/node_modules/@metamask/transaction-controller/dist/EtherscanRemoteTransactionSource.js.map
deleted file mode 100644
index ade75c0..0000000
--- a/node_modules/@metamask/transaction-controller/dist/EtherscanRemoteTransactionSource.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"EtherscanRemoteTransactionSource.js","sourceRoot":"","sources":["../src/EtherscanRemoteTransactionSource.ts"],"names":[],"mappings":"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","sourcesContent":["import { BNToHex } from '@metamask/controller-utils';\nimport type { Hex } from '@metamask/utils';\nimport { BN } from 'ethereumjs-util';\nimport { v1 as random } from 'uuid';\n\nimport type {\n  EtherscanTokenTransactionMeta,\n  EtherscanTransactionMeta,\n  EtherscanTransactionMetaBase,\n} from './etherscan';\nimport {\n  fetchEtherscanTokenTransactions,\n  fetchEtherscanTransactions,\n} from './etherscan';\nimport type {\n  RemoteTransactionSource,\n  RemoteTransactionSourceRequest,\n  TransactionMeta,\n} from './types';\nimport { TransactionStatus } from './types';\n\n/**\n * A RemoteTransactionSource that fetches transaction data from Etherscan.\n */\nexport class EtherscanRemoteTransactionSource\n  implements RemoteTransactionSource\n{\n  /**\n   * Retrieve transaction data from Etherscan.\n   *\n   * @param request - The configuration required to fetch Etherscan transaction data.\n   * @returns An array of transaction metadata.\n   */\n  async fetchTransactions(\n    request: RemoteTransactionSourceRequest,\n  ): Promise<TransactionMeta[]> {\n    const [etherscanTransactions, etherscanTokenTransactions] =\n      await Promise.all([\n        fetchEtherscanTransactions(request),\n        fetchEtherscanTokenTransactions(request),\n      ]);\n\n    const transactions = etherscanTransactions.result.map((tx) =>\n      this.#normalizeTransaction(\n        tx,\n        request.currentNetworkId,\n        request.currentChainId,\n      ),\n    );\n\n    const tokenTransactions = etherscanTokenTransactions.result.map((tx) =>\n      this.#normalizeTokenTransaction(\n        tx,\n        request.currentNetworkId,\n        request.currentChainId,\n      ),\n    );\n\n    return [...transactions, ...tokenTransactions];\n  }\n\n  #normalizeTransaction(\n    txMeta: EtherscanTransactionMeta,\n    currentNetworkId: string,\n    currentChainId: Hex,\n  ): TransactionMeta {\n    const base = this.#normalizeTransactionBase(\n      txMeta,\n      currentNetworkId,\n      currentChainId,\n    );\n\n    return {\n      ...base,\n      transaction: {\n        ...base.transaction,\n        data: txMeta.input,\n      },\n      ...(txMeta.isError === '0'\n        ? { status: TransactionStatus.confirmed }\n        : {\n            error: new Error('Transaction failed'),\n            status: TransactionStatus.failed,\n          }),\n    };\n  }\n\n  #normalizeTokenTransaction(\n    txMeta: EtherscanTokenTransactionMeta,\n    currentNetworkId: string,\n    currentChainId: Hex,\n  ): TransactionMeta {\n    const base = this.#normalizeTransactionBase(\n      txMeta,\n      currentNetworkId,\n      currentChainId,\n    );\n\n    return {\n      ...base,\n      isTransfer: true,\n      transferInformation: {\n        contractAddress: txMeta.contractAddress,\n        decimals: Number(txMeta.tokenDecimal),\n        symbol: txMeta.tokenSymbol,\n      },\n    };\n  }\n\n  #normalizeTransactionBase(\n    txMeta: EtherscanTransactionMetaBase,\n    currentNetworkId: string,\n    currentChainId: Hex,\n  ): TransactionMeta {\n    const time = parseInt(txMeta.timeStamp, 10) * 1000;\n\n    return {\n      blockNumber: txMeta.blockNumber,\n      chainId: currentChainId,\n      id: random({ msecs: time }),\n      networkID: currentNetworkId,\n      status: TransactionStatus.confirmed,\n      time,\n      transaction: {\n        from: txMeta.from,\n        gas: BNToHex(new BN(txMeta.gas)),\n        gasPrice: BNToHex(new BN(txMeta.gasPrice)),\n        gasUsed: BNToHex(new BN(txMeta.gasUsed)),\n        nonce: BNToHex(new BN(txMeta.nonce)),\n        to: txMeta.to,\n        value: BNToHex(new BN(txMeta.value)),\n      },\n      transactionHash: txMeta.hash,\n      verifiedOnBlockchain: false,\n    };\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/IncomingTransactionHelper.d.ts b/node_modules/@metamask/transaction-controller/dist/IncomingTransactionHelper.d.ts
index 37a01c8..7ee2061 100644
--- a/node_modules/@metamask/transaction-controller/dist/IncomingTransactionHelper.d.ts
+++ b/node_modules/@metamask/transaction-controller/dist/IncomingTransactionHelper.d.ts
@@ -1,23 +1,23 @@
-import type EthQuery from '@metamask/eth-query';
-import type { NetworkState } from '@metamask/network-controller';
+/// <reference types="node" />
+import type { BlockTracker, NetworkState } from '@metamask/network-controller';
+import EventEmitter from 'events';
 import type { RemoteTransactionSource, TransactionMeta } from './types';
 export declare class IncomingTransactionHelper {
     #private;
-    constructor({ getNetworkState, getEthQuery, transactionLimit, remoteTransactionSource, }: {
+    hub: EventEmitter;
+    constructor({ blockTracker, getCurrentAccount, getLastFetchedBlockNumbers, getLocalTransactions, getNetworkState, isEnabled, remoteTransactionSource, transactionLimit, updateTransactions, }: {
+        blockTracker: BlockTracker;
+        getCurrentAccount: () => string;
         getNetworkState: () => NetworkState;
-        getEthQuery: () => EthQuery;
-        transactionLimit: number;
+        getLastFetchedBlockNumbers: () => Record<string, number>;
+        getLocalTransactions?: () => TransactionMeta[];
+        isEnabled?: () => boolean;
         remoteTransactionSource: RemoteTransactionSource;
+        transactionLimit?: number;
+        updateTransactions?: boolean;
     });
-    reconcile({ address, localTransactions, fromBlock, apiKey, }: {
-        address: string;
-        localTransactions: TransactionMeta[];
-        fromBlock?: string;
-        apiKey?: string;
-    }): Promise<{
-        updateRequired: boolean;
-        transactions: TransactionMeta[];
-        latestBlockNumber?: string;
-    }>;
+    start(): void;
+    stop(): void;
+    update(latestBlockNumberHex?: string): Promise<void>;
 }
 //# sourceMappingURL=IncomingTransactionHelper.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/IncomingTransactionHelper.d.ts.map b/node_modules/@metamask/transaction-controller/dist/IncomingTransactionHelper.d.ts.map
deleted file mode 100644
index 048e002..0000000
--- a/node_modules/@metamask/transaction-controller/dist/IncomingTransactionHelper.d.ts.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"IncomingTransactionHelper.d.ts","sourceRoot":"","sources":["../src/IncomingTransactionHelper.ts"],"names":[],"mappings":"AACA,OAAO,KAAK,QAAQ,MAAM,qBAAqB,CAAC;AAChD,OAAO,KAAK,EAAE,YAAY,EAAE,MAAM,8BAA8B,CAAC;AAGjE,OAAO,KAAK,EACV,uBAAuB,EAEvB,eAAe,EAEhB,MAAM,SAAS,CAAC;AAQjB,qBAAa,yBAAyB;;gBASxB,EACV,eAAe,EACf,WAAW,EACX,gBAAgB,EAChB,uBAAuB,GACxB,EAAE;QACD,eAAe,EAAE,MAAM,YAAY,CAAC;QACpC,WAAW,EAAE,MAAM,QAAQ,CAAC;QAC5B,gBAAgB,EAAE,MAAM,CAAC;QACzB,uBAAuB,EAAE,uBAAuB,CAAC;KAClD;IAOK,SAAS,CAAC,EACd,OAAO,EACP,iBAAiB,EACjB,SAAS,EACT,MAAM,GACP,EAAE;QACD,OAAO,EAAE,MAAM,CAAC;QAChB,iBAAiB,EAAE,eAAe,EAAE,CAAC;QACrC,SAAS,CAAC,EAAE,MAAM,CAAC;QACnB,MAAM,CAAC,EAAE,MAAM,CAAC;KACjB,GAAG,OAAO,CAAC;QACV,cAAc,EAAE,OAAO,CAAC;QACxB,YAAY,EAAE,eAAe,EAAE,CAAC;QAChC,iBAAiB,CAAC,EAAE,MAAM,CAAC;KAC5B,CAAC;CAmMH"}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/IncomingTransactionHelper.js b/node_modules/@metamask/transaction-controller/dist/IncomingTransactionHelper.js
index 6a27aeb..5f34686 100644
--- a/node_modules/@metamask/transaction-controller/dist/IncomingTransactionHelper.js
+++ b/node_modules/@metamask/transaction-controller/dist/IncomingTransactionHelper.js
@@ -19,126 +19,173 @@ var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (
     if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
     return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
 };
-var _IncomingTransactionHelper_instances, _IncomingTransactionHelper_getNetworkState, _IncomingTransactionHelper_getEthQuery, _IncomingTransactionHelper_transactionLimit, _IncomingTransactionHelper_remoteTransactionSource, _IncomingTransactionHelper_updateSmartContractProperty, _IncomingTransactionHelper_getLatestBlockNumber, _IncomingTransactionHelper_isToSmartContract, _IncomingTransactionHelper_sortTransactionsByTime, _IncomingTransactionHelper_reconcileTransactions, _IncomingTransactionHelper_getNewTransactions, _IncomingTransactionHelper_getUpdatedTransactions, _IncomingTransactionHelper_isTransactionOutdated, _IncomingTransactionHelper_isStatusOutdated, _IncomingTransactionHelper_isGasDataOutdated;
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+var _IncomingTransactionHelper_instances, _IncomingTransactionHelper_blockTracker, _IncomingTransactionHelper_getCurrentAccount, _IncomingTransactionHelper_getLastFetchedBlockNumbers, _IncomingTransactionHelper_getLocalTransactions, _IncomingTransactionHelper_getNetworkState, _IncomingTransactionHelper_isEnabled, _IncomingTransactionHelper_isRunning, _IncomingTransactionHelper_mutex, _IncomingTransactionHelper_onLatestBlock, _IncomingTransactionHelper_remoteTransactionSource, _IncomingTransactionHelper_transactionLimit, _IncomingTransactionHelper_updateTransactions, _IncomingTransactionHelper_sortTransactionsByTime, _IncomingTransactionHelper_getNewTransactions, _IncomingTransactionHelper_getUpdatedTransactions, _IncomingTransactionHelper_isTransactionOutdated, _IncomingTransactionHelper_getFromBlock, _IncomingTransactionHelper_updateLastFetchedBlockNumber, _IncomingTransactionHelper_getBlockNumberKey, _IncomingTransactionHelper_canStart, _IncomingTransactionHelper_getCurrentChainId, _IncomingTransactionHelper_getCurrentNetworkId;
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.IncomingTransactionHelper = void 0;
-const controller_utils_1 = require("@metamask/controller-utils");
-const SUPPORTED_NETWORK_IDS = [
-    '1',
-    '5',
-    '11155111', // Sepolia
+const async_mutex_1 = require("async-mutex");
+const events_1 = __importDefault(require("events"));
+const UPDATE_CHECKS = [
+    (txMeta) => txMeta.status,
+    (txMeta) => txMeta.transaction.gasUsed,
 ];
 class IncomingTransactionHelper {
-    constructor({ getNetworkState, getEthQuery, transactionLimit, remoteTransactionSource, }) {
+    constructor({ blockTracker, getCurrentAccount, getLastFetchedBlockNumbers, getLocalTransactions, getNetworkState, isEnabled, remoteTransactionSource, transactionLimit, updateTransactions, }) {
         _IncomingTransactionHelper_instances.add(this);
+        _IncomingTransactionHelper_blockTracker.set(this, void 0);
+        _IncomingTransactionHelper_getCurrentAccount.set(this, void 0);
+        _IncomingTransactionHelper_getLastFetchedBlockNumbers.set(this, void 0);
+        _IncomingTransactionHelper_getLocalTransactions.set(this, void 0);
         _IncomingTransactionHelper_getNetworkState.set(this, void 0);
-        _IncomingTransactionHelper_getEthQuery.set(this, void 0);
-        _IncomingTransactionHelper_transactionLimit.set(this, void 0);
+        _IncomingTransactionHelper_isEnabled.set(this, void 0);
+        _IncomingTransactionHelper_isRunning.set(this, void 0);
+        _IncomingTransactionHelper_mutex.set(this, new async_mutex_1.Mutex());
+        _IncomingTransactionHelper_onLatestBlock.set(this, void 0);
         _IncomingTransactionHelper_remoteTransactionSource.set(this, void 0);
+        _IncomingTransactionHelper_transactionLimit.set(this, void 0);
+        _IncomingTransactionHelper_updateTransactions.set(this, void 0);
+        this.hub = new events_1.default();
+        __classPrivateFieldSet(this, _IncomingTransactionHelper_blockTracker, blockTracker, "f");
+        __classPrivateFieldSet(this, _IncomingTransactionHelper_getCurrentAccount, getCurrentAccount, "f");
+        __classPrivateFieldSet(this, _IncomingTransactionHelper_getLastFetchedBlockNumbers, getLastFetchedBlockNumbers, "f");
+        __classPrivateFieldSet(this, _IncomingTransactionHelper_getLocalTransactions, getLocalTransactions || (() => []), "f");
         __classPrivateFieldSet(this, _IncomingTransactionHelper_getNetworkState, getNetworkState, "f");
-        __classPrivateFieldSet(this, _IncomingTransactionHelper_getEthQuery, getEthQuery, "f");
-        __classPrivateFieldSet(this, _IncomingTransactionHelper_transactionLimit, transactionLimit, "f");
+        __classPrivateFieldSet(this, _IncomingTransactionHelper_isEnabled, isEnabled !== null && isEnabled !== void 0 ? isEnabled : (() => true), "f");
+        __classPrivateFieldSet(this, _IncomingTransactionHelper_isRunning, false, "f");
         __classPrivateFieldSet(this, _IncomingTransactionHelper_remoteTransactionSource, remoteTransactionSource, "f");
+        __classPrivateFieldSet(this, _IncomingTransactionHelper_transactionLimit, transactionLimit, "f");
+        __classPrivateFieldSet(this, _IncomingTransactionHelper_updateTransactions, updateTransactions !== null && updateTransactions !== void 0 ? updateTransactions : false, "f");
+        // Using a property instead of a method to provide a listener reference
+        // with the correct scope that we can remove later if stopped.
+        __classPrivateFieldSet(this, _IncomingTransactionHelper_onLatestBlock, (blockNumberHex) => __awaiter(this, void 0, void 0, function* () {
+            try {
+                yield this.update(blockNumberHex);
+            }
+            catch (error) {
+                console.error('Error while checking incoming transactions', error);
+            }
+        }), "f");
     }
-    reconcile({ address, localTransactions, fromBlock, apiKey, }) {
+    start() {
+        if (__classPrivateFieldGet(this, _IncomingTransactionHelper_isRunning, "f")) {
+            return;
+        }
+        if (!__classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_canStart).call(this)) {
+            return;
+        }
+        __classPrivateFieldGet(this, _IncomingTransactionHelper_blockTracker, "f").addListener('latest', __classPrivateFieldGet(this, _IncomingTransactionHelper_onLatestBlock, "f"));
+        __classPrivateFieldSet(this, _IncomingTransactionHelper_isRunning, true, "f");
+    }
+    stop() {
+        __classPrivateFieldGet(this, _IncomingTransactionHelper_blockTracker, "f").removeListener('latest', __classPrivateFieldGet(this, _IncomingTransactionHelper_onLatestBlock, "f"));
+        __classPrivateFieldSet(this, _IncomingTransactionHelper_isRunning, false, "f");
+    }
+    update(latestBlockNumberHex) {
         return __awaiter(this, void 0, void 0, function* () {
-            const { providerConfig, networkId: currentNetworkId } = __classPrivateFieldGet(this, _IncomingTransactionHelper_getNetworkState, "f").call(this);
-            const { chainId: currentChainId, type: networkType } = providerConfig;
-            if (currentNetworkId === null ||
-                !SUPPORTED_NETWORK_IDS.includes(currentNetworkId)) {
-                return { updateRequired: false, transactions: [] };
+            const releaseLock = yield __classPrivateFieldGet(this, _IncomingTransactionHelper_mutex, "f").acquire();
+            try {
+                if (!__classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_canStart).call(this)) {
+                    return;
+                }
+                const latestBlockNumber = parseInt(latestBlockNumberHex || (yield __classPrivateFieldGet(this, _IncomingTransactionHelper_blockTracker, "f").getLatestBlock()), 16);
+                const fromBlock = __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_getFromBlock).call(this, latestBlockNumber);
+                const address = __classPrivateFieldGet(this, _IncomingTransactionHelper_getCurrentAccount, "f").call(this);
+                const currentChainId = __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_getCurrentChainId).call(this);
+                const currentNetworkId = __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_getCurrentNetworkId).call(this);
+                let remoteTransactions = [];
+                try {
+                    remoteTransactions =
+                        yield __classPrivateFieldGet(this, _IncomingTransactionHelper_remoteTransactionSource, "f").fetchTransactions({
+                            address,
+                            currentChainId,
+                            currentNetworkId,
+                            fromBlock,
+                            limit: __classPrivateFieldGet(this, _IncomingTransactionHelper_transactionLimit, "f"),
+                        });
+                }
+                catch (error) {
+                    return;
+                }
+                if (!__classPrivateFieldGet(this, _IncomingTransactionHelper_updateTransactions, "f")) {
+                    remoteTransactions = remoteTransactions.filter((tx) => { var _a; return ((_a = tx.transaction.to) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === address.toLowerCase(); });
+                }
+                const localTransactions = !__classPrivateFieldGet(this, _IncomingTransactionHelper_updateTransactions, "f")
+                    ? []
+                    : __classPrivateFieldGet(this, _IncomingTransactionHelper_getLocalTransactions, "f").call(this);
+                const newTransactions = __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_getNewTransactions).call(this, remoteTransactions, localTransactions);
+                const updatedTransactions = __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_getUpdatedTransactions).call(this, remoteTransactions, localTransactions);
+                if (newTransactions.length > 0 || updatedTransactions.length > 0) {
+                    __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_sortTransactionsByTime).call(this, newTransactions);
+                    __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_sortTransactionsByTime).call(this, updatedTransactions);
+                    this.hub.emit('transactions', {
+                        added: newTransactions,
+                        updated: updatedTransactions,
+                    });
+                }
+                __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_updateLastFetchedBlockNumber).call(this, remoteTransactions);
+            }
+            finally {
+                releaseLock();
             }
-            const remoteTransactions = yield __classPrivateFieldGet(this, _IncomingTransactionHelper_remoteTransactionSource, "f").fetchTransactions({
-                address,
-                networkType,
-                limit: __classPrivateFieldGet(this, _IncomingTransactionHelper_transactionLimit, "f"),
-                currentChainId,
-                currentNetworkId,
-                fromBlock,
-                apiKey,
-            });
-            const [updateRequired, transactions] = __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_reconcileTransactions).call(this, localTransactions, remoteTransactions);
-            __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_sortTransactionsByTime).call(this, transactions);
-            const latestBlockNumber = __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_getLatestBlockNumber).call(this, transactions, address, currentChainId, currentNetworkId);
-            yield __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_updateSmartContractProperty).call(this, transactions);
-            return { updateRequired, transactions, latestBlockNumber };
         });
     }
 }
 exports.IncomingTransactionHelper = IncomingTransactionHelper;
-_IncomingTransactionHelper_getNetworkState = new WeakMap(), _IncomingTransactionHelper_getEthQuery = new WeakMap(), _IncomingTransactionHelper_transactionLimit = new WeakMap(), _IncomingTransactionHelper_remoteTransactionSource = new WeakMap(), _IncomingTransactionHelper_instances = new WeakSet(), _IncomingTransactionHelper_updateSmartContractProperty = function _IncomingTransactionHelper_updateSmartContractProperty(transactions) {
-    return __awaiter(this, void 0, void 0, function* () {
-        yield Promise.all(transactions.map((tx) => __awaiter(this, void 0, void 0, function* () {
-            var _a;
-            (_a = tx.toSmartContract) !== null && _a !== void 0 ? _a : (tx.toSmartContract = yield __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_isToSmartContract).call(this, tx.transaction));
-        })));
-    });
-}, _IncomingTransactionHelper_getLatestBlockNumber = function _IncomingTransactionHelper_getLatestBlockNumber(transactions, address, currentChainId, currentNetworkId) {
-    var _a;
-    let latestBlockNumber;
-    for (const tx of transactions) {
-        const onCurrentChain = tx.chainId === currentChainId ||
-            (!tx.chainId && tx.networkID === currentNetworkId);
-        const toCurrentAccount = ((_a = tx.transaction.to) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === address.toLowerCase();
+_IncomingTransactionHelper_blockTracker = new WeakMap(), _IncomingTransactionHelper_getCurrentAccount = new WeakMap(), _IncomingTransactionHelper_getLastFetchedBlockNumbers = new WeakMap(), _IncomingTransactionHelper_getLocalTransactions = new WeakMap(), _IncomingTransactionHelper_getNetworkState = new WeakMap(), _IncomingTransactionHelper_isEnabled = new WeakMap(), _IncomingTransactionHelper_isRunning = new WeakMap(), _IncomingTransactionHelper_mutex = new WeakMap(), _IncomingTransactionHelper_onLatestBlock = new WeakMap(), _IncomingTransactionHelper_remoteTransactionSource = new WeakMap(), _IncomingTransactionHelper_transactionLimit = new WeakMap(), _IncomingTransactionHelper_updateTransactions = new WeakMap(), _IncomingTransactionHelper_instances = new WeakSet(), _IncomingTransactionHelper_sortTransactionsByTime = function _IncomingTransactionHelper_sortTransactionsByTime(transactions) {
+    transactions.sort((a, b) => (a.time < b.time ? -1 : 1));
+}, _IncomingTransactionHelper_getNewTransactions = function _IncomingTransactionHelper_getNewTransactions(remoteTxs, localTxs) {
+    return remoteTxs.filter((tx) => !localTxs.some(({ transactionHash }) => transactionHash === tx.transactionHash));
+}, _IncomingTransactionHelper_getUpdatedTransactions = function _IncomingTransactionHelper_getUpdatedTransactions(remoteTxs, localTxs) {
+    return remoteTxs.filter((remoteTx) => localTxs.some((localTx) => remoteTx.transactionHash === localTx.transactionHash &&
+        __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_isTransactionOutdated).call(this, remoteTx, localTx)));
+}, _IncomingTransactionHelper_isTransactionOutdated = function _IncomingTransactionHelper_isTransactionOutdated(remoteTx, localTx) {
+    return UPDATE_CHECKS.some((getValue) => getValue(remoteTx) !== getValue(localTx));
+}, _IncomingTransactionHelper_getFromBlock = function _IncomingTransactionHelper_getFromBlock(_latestBlockNumber) {
+    const lastFetchedKey = __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_getBlockNumberKey).call(this);
+    const lastFetchedBlockNumber = __classPrivateFieldGet(this, _IncomingTransactionHelper_getLastFetchedBlockNumbers, "f").call(this)[lastFetchedKey];
+    if (lastFetchedBlockNumber) {
+        return lastFetchedBlockNumber + 1;
+    }
+    // Query entire transaction history
+    return undefined;
+}, _IncomingTransactionHelper_updateLastFetchedBlockNumber = function _IncomingTransactionHelper_updateLastFetchedBlockNumber(remoteTxs) {
+    let lastFetchedBlockNumber = -1;
+    for (const tx of remoteTxs) {
         const currentBlockNumberValue = tx.blockNumber
             ? parseInt(tx.blockNumber, 10)
             : -1;
-        const latestBlockNumberValue = latestBlockNumber
-            ? parseInt(latestBlockNumber, 10)
-            : -1;
-        if (onCurrentChain &&
-            toCurrentAccount &&
-            latestBlockNumberValue < currentBlockNumberValue) {
-            latestBlockNumber = tx.blockNumber;
-        }
+        lastFetchedBlockNumber = Math.max(lastFetchedBlockNumber, currentBlockNumberValue);
     }
-    return latestBlockNumber;
-}, _IncomingTransactionHelper_isToSmartContract = function _IncomingTransactionHelper_isToSmartContract(transaction) {
-    return __awaiter(this, void 0, void 0, function* () {
-        // Contract Deploy
-        if (!transaction.to) {
-            return false;
-        }
-        // Send
-        if (transaction.data === '0x') {
-            return false;
-        }
-        const ethQuery = __classPrivateFieldGet(this, _IncomingTransactionHelper_getEthQuery, "f").call(this);
-        const code = yield (0, controller_utils_1.query)(ethQuery, 'getCode', [transaction.to]);
-        return (0, controller_utils_1.isSmartContractCode)(code);
-    });
-}, _IncomingTransactionHelper_sortTransactionsByTime = function _IncomingTransactionHelper_sortTransactionsByTime(transactions) {
-    transactions.sort((a, b) => (a.time < b.time ? -1 : 1));
-}, _IncomingTransactionHelper_reconcileTransactions = function _IncomingTransactionHelper_reconcileTransactions(localTxs, remoteTxs) {
-    const updatedTxs = __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_getUpdatedTransactions).call(this, remoteTxs, localTxs);
-    const newTxs = __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_getNewTransactions).call(this, remoteTxs, localTxs);
-    const updatedLocalTxs = localTxs.map((tx) => {
-        const txIdx = updatedTxs.findIndex(({ transactionHash }) => transactionHash === tx.transactionHash);
-        return txIdx === -1 ? tx : updatedTxs[txIdx];
-    });
-    const updateRequired = newTxs.length > 0 || updatedTxs.length > 0;
-    const transactions = [...newTxs, ...updatedLocalTxs];
-    return [updateRequired, transactions];
-}, _IncomingTransactionHelper_getNewTransactions = function _IncomingTransactionHelper_getNewTransactions(remoteTxs, localTxs) {
-    return remoteTxs.filter((tx) => {
-        const alreadyInTransactions = localTxs.find(({ transactionHash }) => transactionHash === tx.transactionHash);
-        return !alreadyInTransactions;
-    });
-}, _IncomingTransactionHelper_getUpdatedTransactions = function _IncomingTransactionHelper_getUpdatedTransactions(remoteTxs, localTxs) {
-    return remoteTxs.filter((remoteTx) => {
-        const isTxOutdated = localTxs.find((localTx) => {
-            return (remoteTx.transactionHash === localTx.transactionHash &&
-                __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_isTransactionOutdated).call(this, remoteTx, localTx));
-        });
-        return isTxOutdated;
+    if (lastFetchedBlockNumber === -1) {
+        return;
+    }
+    const lastFetchedKey = __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_getBlockNumberKey).call(this);
+    const lastFetchedBlockNumbers = __classPrivateFieldGet(this, _IncomingTransactionHelper_getLastFetchedBlockNumbers, "f").call(this);
+    const previousValue = lastFetchedBlockNumbers[lastFetchedKey];
+    if (previousValue >= lastFetchedBlockNumber) {
+        return;
+    }
+    lastFetchedBlockNumbers[lastFetchedKey] = lastFetchedBlockNumber;
+    this.hub.emit('updatedLastFetchedBlockNumbers', {
+        lastFetchedBlockNumbers,
+        blockNumber: lastFetchedBlockNumber,
     });
-}, _IncomingTransactionHelper_isTransactionOutdated = function _IncomingTransactionHelper_isTransactionOutdated(remoteTx, localTx) {
-    const statusOutdated = __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_isStatusOutdated).call(this, remoteTx.transactionHash, localTx.transactionHash, remoteTx.status, localTx.status);
-    const gasDataOutdated = __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_isGasDataOutdated).call(this, remoteTx.transaction.gasUsed, localTx.transaction.gasUsed);
-    return statusOutdated || gasDataOutdated;
-}, _IncomingTransactionHelper_isStatusOutdated = function _IncomingTransactionHelper_isStatusOutdated(remoteTxHash, localTxHash, remoteTxStatus, localTxStatus) {
-    return remoteTxHash === localTxHash && remoteTxStatus !== localTxStatus;
-}, _IncomingTransactionHelper_isGasDataOutdated = function _IncomingTransactionHelper_isGasDataOutdated(remoteGasUsed, localGasUsed) {
-    return remoteGasUsed !== localGasUsed;
+}, _IncomingTransactionHelper_getBlockNumberKey = function _IncomingTransactionHelper_getBlockNumberKey() {
+    var _a;
+    const currentChainId = __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_getCurrentChainId).call(this);
+    const currentAccount = (_a = __classPrivateFieldGet(this, _IncomingTransactionHelper_getCurrentAccount, "f").call(this)) === null || _a === void 0 ? void 0 : _a.toLowerCase();
+    return [currentChainId, currentAccount].join('#');
+}, _IncomingTransactionHelper_canStart = function _IncomingTransactionHelper_canStart() {
+    const isEnabled = __classPrivateFieldGet(this, _IncomingTransactionHelper_isEnabled, "f").call(this);
+    const currentChainId = __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_getCurrentChainId).call(this);
+    const currentNetworkId = __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_getCurrentNetworkId).call(this);
+    const isSupportedNetwork = __classPrivateFieldGet(this, _IncomingTransactionHelper_remoteTransactionSource, "f").isSupportedNetwork(currentChainId, currentNetworkId);
+    return isEnabled && isSupportedNetwork;
+}, _IncomingTransactionHelper_getCurrentChainId = function _IncomingTransactionHelper_getCurrentChainId() {
+    return __classPrivateFieldGet(this, _IncomingTransactionHelper_getNetworkState, "f").call(this).providerConfig.chainId;
+}, _IncomingTransactionHelper_getCurrentNetworkId = function _IncomingTransactionHelper_getCurrentNetworkId() {
+    return __classPrivateFieldGet(this, _IncomingTransactionHelper_getNetworkState, "f").call(this).networkId;
 };
 //# sourceMappingURL=IncomingTransactionHelper.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/IncomingTransactionHelper.js.map b/node_modules/@metamask/transaction-controller/dist/IncomingTransactionHelper.js.map
deleted file mode 100644
index 2fc96c7..0000000
--- a/node_modules/@metamask/transaction-controller/dist/IncomingTransactionHelper.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"IncomingTransactionHelper.js","sourceRoot":"","sources":["../src/IncomingTransactionHelper.ts"],"names":[],"mappings":"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","sourcesContent":["import { isSmartContractCode, query } from '@metamask/controller-utils';\nimport type EthQuery from '@metamask/eth-query';\nimport type { NetworkState } from '@metamask/network-controller';\nimport type { Hex } from '@metamask/utils';\n\nimport type {\n  RemoteTransactionSource,\n  Transaction,\n  TransactionMeta,\n  TransactionStatus,\n} from './types';\n\nconst SUPPORTED_NETWORK_IDS = [\n  '1', // Mainnet\n  '5', // Goerli\n  '11155111', // Sepolia\n];\n\nexport class IncomingTransactionHelper {\n  #getNetworkState: () => NetworkState;\n\n  #getEthQuery: () => EthQuery;\n\n  #transactionLimit: number;\n\n  #remoteTransactionSource: RemoteTransactionSource;\n\n  constructor({\n    getNetworkState,\n    getEthQuery,\n    transactionLimit,\n    remoteTransactionSource,\n  }: {\n    getNetworkState: () => NetworkState;\n    getEthQuery: () => EthQuery;\n    transactionLimit: number;\n    remoteTransactionSource: RemoteTransactionSource;\n  }) {\n    this.#getNetworkState = getNetworkState;\n    this.#getEthQuery = getEthQuery;\n    this.#transactionLimit = transactionLimit;\n    this.#remoteTransactionSource = remoteTransactionSource;\n  }\n\n  async reconcile({\n    address,\n    localTransactions,\n    fromBlock,\n    apiKey,\n  }: {\n    address: string;\n    localTransactions: TransactionMeta[];\n    fromBlock?: string;\n    apiKey?: string;\n  }): Promise<{\n    updateRequired: boolean;\n    transactions: TransactionMeta[];\n    latestBlockNumber?: string;\n  }> {\n    const { providerConfig, networkId: currentNetworkId } =\n      this.#getNetworkState();\n    const { chainId: currentChainId, type: networkType } = providerConfig;\n\n    if (\n      currentNetworkId === null ||\n      !SUPPORTED_NETWORK_IDS.includes(currentNetworkId)\n    ) {\n      return { updateRequired: false, transactions: [] };\n    }\n\n    const remoteTransactions =\n      await this.#remoteTransactionSource.fetchTransactions({\n        address,\n        networkType,\n        limit: this.#transactionLimit,\n        currentChainId,\n        currentNetworkId,\n        fromBlock,\n        apiKey,\n      });\n\n    const [updateRequired, transactions] = this.#reconcileTransactions(\n      localTransactions,\n      remoteTransactions,\n    );\n\n    this.#sortTransactionsByTime(transactions);\n\n    const latestBlockNumber = this.#getLatestBlockNumber(\n      transactions,\n      address,\n      currentChainId,\n      currentNetworkId,\n    );\n\n    await this.#updateSmartContractProperty(transactions);\n\n    return { updateRequired, transactions, latestBlockNumber };\n  }\n\n  async #updateSmartContractProperty(transactions: TransactionMeta[]) {\n    await Promise.all(\n      transactions.map(async (tx) => {\n        tx.toSmartContract ??= await this.#isToSmartContract(tx.transaction);\n      }),\n    );\n  }\n\n  #getLatestBlockNumber(\n    transactions: TransactionMeta[],\n    address: string,\n    currentChainId: Hex,\n    currentNetworkId: string,\n  ): string | undefined {\n    let latestBlockNumber: string | undefined;\n\n    for (const tx of transactions) {\n      const onCurrentChain =\n        tx.chainId === currentChainId ||\n        (!tx.chainId && tx.networkID === currentNetworkId);\n\n      const toCurrentAccount =\n        tx.transaction.to?.toLowerCase() === address.toLowerCase();\n\n      const currentBlockNumberValue = tx.blockNumber\n        ? parseInt(tx.blockNumber, 10)\n        : -1;\n\n      const latestBlockNumberValue = latestBlockNumber\n        ? parseInt(latestBlockNumber, 10)\n        : -1;\n\n      if (\n        onCurrentChain &&\n        toCurrentAccount &&\n        latestBlockNumberValue < currentBlockNumberValue\n      ) {\n        latestBlockNumber = tx.blockNumber;\n      }\n    }\n\n    return latestBlockNumber;\n  }\n\n  async #isToSmartContract(transaction: Transaction): Promise<boolean> {\n    // Contract Deploy\n    if (!transaction.to) {\n      return false;\n    }\n\n    // Send\n    if (transaction.data === '0x') {\n      return false;\n    }\n\n    const ethQuery = this.#getEthQuery();\n    const code = await query(ethQuery, 'getCode', [transaction.to]);\n\n    return isSmartContractCode(code);\n  }\n\n  #sortTransactionsByTime(transactions: TransactionMeta[]) {\n    transactions.sort((a, b) => (a.time < b.time ? -1 : 1));\n  }\n\n  #reconcileTransactions(\n    localTxs: TransactionMeta[],\n    remoteTxs: TransactionMeta[],\n  ): [boolean, TransactionMeta[]] {\n    const updatedTxs: TransactionMeta[] = this.#getUpdatedTransactions(\n      remoteTxs,\n      localTxs,\n    );\n\n    const newTxs: TransactionMeta[] = this.#getNewTransactions(\n      remoteTxs,\n      localTxs,\n    );\n\n    const updatedLocalTxs = localTxs.map((tx: TransactionMeta) => {\n      const txIdx = updatedTxs.findIndex(\n        ({ transactionHash }) => transactionHash === tx.transactionHash,\n      );\n      return txIdx === -1 ? tx : updatedTxs[txIdx];\n    });\n\n    const updateRequired = newTxs.length > 0 || updatedTxs.length > 0;\n    const transactions = [...newTxs, ...updatedLocalTxs];\n\n    return [updateRequired, transactions];\n  }\n\n  #getNewTransactions(\n    remoteTxs: TransactionMeta[],\n    localTxs: TransactionMeta[],\n  ): TransactionMeta[] {\n    return remoteTxs.filter((tx) => {\n      const alreadyInTransactions = localTxs.find(\n        ({ transactionHash }) => transactionHash === tx.transactionHash,\n      );\n      return !alreadyInTransactions;\n    });\n  }\n\n  #getUpdatedTransactions(\n    remoteTxs: TransactionMeta[],\n    localTxs: TransactionMeta[],\n  ): TransactionMeta[] {\n    return remoteTxs.filter((remoteTx) => {\n      const isTxOutdated = localTxs.find((localTx) => {\n        return (\n          remoteTx.transactionHash === localTx.transactionHash &&\n          this.#isTransactionOutdated(remoteTx, localTx)\n        );\n      });\n      return isTxOutdated;\n    });\n  }\n\n  #isTransactionOutdated(\n    remoteTx: TransactionMeta,\n    localTx: TransactionMeta,\n  ): boolean {\n    const statusOutdated = this.#isStatusOutdated(\n      remoteTx.transactionHash,\n      localTx.transactionHash,\n      remoteTx.status,\n      localTx.status,\n    );\n\n    const gasDataOutdated = this.#isGasDataOutdated(\n      remoteTx.transaction.gasUsed,\n      localTx.transaction.gasUsed,\n    );\n\n    return statusOutdated || gasDataOutdated;\n  }\n\n  #isStatusOutdated(\n    remoteTxHash: string | undefined,\n    localTxHash: string | undefined,\n    remoteTxStatus: TransactionStatus,\n    localTxStatus: TransactionStatus,\n  ): boolean {\n    return remoteTxHash === localTxHash && remoteTxStatus !== localTxStatus;\n  }\n\n  #isGasDataOutdated(\n    remoteGasUsed: string | undefined,\n    localGasUsed: string | undefined,\n  ): boolean {\n    return remoteGasUsed !== localGasUsed;\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/TransactionController.d.ts b/node_modules/@metamask/transaction-controller/dist/TransactionController.d.ts
index 4e3d5e0..33ad1fa 100644
--- a/node_modules/@metamask/transaction-controller/dist/TransactionController.d.ts
+++ b/node_modules/@metamask/transaction-controller/dist/TransactionController.d.ts
@@ -1,13 +1,15 @@
 /// <reference types="node" />
-import { Hardfork, Common } from '@ethereumjs/common';
+import { Common } from '@ethereumjs/common';
 import type { TypedTransaction } from '@ethereumjs/tx';
 import type { AddApprovalRequest } from '@metamask/approval-controller';
 import type { BaseConfig, BaseState, RestrictedControllerMessenger } from '@metamask/base-controller';
 import { BaseController } from '@metamask/base-controller';
+import type { GasFeeState } from '@metamask/gas-fee-controller';
 import type { BlockTracker, NetworkState, Provider } from '@metamask/network-controller';
+import type { Hex } from '@metamask/utils';
 import { EventEmitter } from 'events';
-import type { Transaction, TransactionMeta, WalletDevice } from './types';
-export declare const HARDFORK = Hardfork.London;
+import type { NonceLock, Transaction as NonceTrackerTransaction } from 'nonce-tracker/dist/NonceTracker';
+import type { SecurityAlertResponse, Transaction, TransactionMeta, TransactionReceipt, WalletDevice, SubmitHistoryEntry } from './types';
 /**
  * @type Result
  * @property result - Promise resolving to a new transaction hash
@@ -17,15 +19,6 @@ export interface Result {
     result: Promise<string>;
     transactionMeta: TransactionMeta;
 }
-/**
- * @type Fetch All Options
- * @property fromBlock - String containing a specific block decimal number
- * @property etherscanApiKey - API key to be used to fetch token transactions
- */
-export interface FetchAllOptions {
-    fromBlock?: string;
-    etherscanApiKey?: string;
-}
 export interface GasPriceValue {
     gasPrice: string;
 }
@@ -69,11 +62,15 @@ export interface TransactionState extends BaseState {
     methodData: {
         [key: string]: MethodData;
     };
+    lastFetchedBlockNumbers: {
+        [key: string]: number;
+    };
+    submitHistory: SubmitHistoryEntry[];
 }
 /**
  * Multiplier used to determine a transaction's increased gas fee during cancellation
  */
-export declare const CANCEL_RATE = 1.5;
+export declare const CANCEL_RATE = 1.1;
 /**
  * Multiplier used to determine a transaction's increased gas fee during speed up
  */
@@ -101,8 +98,13 @@ export declare class TransactionController extends BaseController<TransactionCon
     private handle?;
     private readonly mutex;
     private readonly getNetworkState;
+    private readonly gasFeeFlows;
+    private readonly getGasFeeEstimates;
     private readonly messagingSystem;
     private readonly incomingTransactionHelper;
+    private readonly inProcessOfSigning;
+    private readonly publish;
+    private readonly getExternalPendingTransactions;
     private failTransaction;
     private registryLookup;
     /**
@@ -121,20 +123,44 @@ export declare class TransactionController extends BaseController<TransactionCon
      * Creates a TransactionController instance.
      *
      * @param options - The controller options.
+     * @param options.blockTracker - The block tracker used to poll for new blocks data.
+     * @param options.getGasFeeEstimates - Callback to retrieve gas fee estimates.
      * @param options.getNetworkState - Gets the state of the network controller.
+     * @param options.getSelectedAddress - Gets the address of the currently selected account.
+     * @param options.getExternalPendingTransactions - Callback to retrieve pending transactions from external sources.
+     * @param options.incomingTransactions - Configuration options for incoming transaction support.
+     * @param options.incomingTransactions.apiKey - An optional API key to use when fetching remote transaction data.
+     * @param options.incomingTransactions.includeTokenTransfers - Whether or not to include ERC20 token transfers.
+     * @param options.incomingTransactions.isEnabled - Whether or not incoming transaction retrieval is enabled.
+     * @param options.incomingTransactions.updateTransactions - Whether or not to update local transactions using remote transaction data.
+     * @param options.messenger - The controller messenger.
      * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.
      * @param options.provider - The provider used to create the underlying EthQuery instance.
-     * @param options.blockTracker - The block tracker used to poll for new blocks data.
-     * @param options.messenger - The controller messenger.
+     * @param options.hooks - The controller hooks.
+     * @param options.hooks.publish - Alternate logic to publish a transaction.
      * @param config - Initial options used to configure this controller.
      * @param state - Initial state to set on this controller.
      */
-    constructor({ getNetworkState, onNetworkStateChange, provider, blockTracker, messenger, }: {
+    constructor({ blockTracker, getGasFeeEstimates, getNetworkState, getSelectedAddress, getExternalPendingTransactions, incomingTransactions, messenger, onNetworkStateChange, provider, hooks, }: {
+        blockTracker: BlockTracker;
+        getGasFeeEstimates: () => Promise<GasFeeState>;
         getNetworkState: () => NetworkState;
+        getSelectedAddress: () => string;
+        getExternalPendingTransactions?: (address: string) => NonceTrackerTransaction[];
+        incomingTransactions: {
+            apiKey?: string;
+            includeTokenTransfers?: boolean;
+            isEnabled?: () => boolean;
+            updateTransactions?: boolean;
+        };
+        messenger: TransactionControllerMessenger;
         onNetworkStateChange: (listener: (state: NetworkState) => void) => void;
         provider: Provider;
-        blockTracker: BlockTracker;
-        messenger: TransactionControllerMessenger;
+        hooks: {
+            publish?: (transactionMeta: TransactionMeta) => Promise<{
+                transactionHash: string | undefined;
+            }>;
+        };
     }, config?: Partial<TransactionConfig>, state?: Partial<TransactionState>);
     /**
      * Starts a new polling interval.
@@ -155,11 +181,20 @@ export declare class TransactionController extends BaseController<TransactionCon
      * if not provided. If A `<tx.id>:unapproved` hub event will be emitted once added.
      *
      * @param transaction - The transaction object to add.
-     * @param origin - The domain origin to append to the generated TransactionMeta.
-     * @param deviceConfirmedOn - An enum to indicate what device the transaction was confirmed to append to the generated TransactionMeta.
+     * @param opts - Additional options to control how the transaction is added.
+     * @param opts.deviceConfirmedOn - An enum to indicate what device confirmed the transaction.
+     * @param opts.origin - The origin of the transaction request, such as a dApp hostname.
+     * @param opts.securityAlertResponse - Response from security validator.
      * @returns Object containing a promise resolving to the transaction hash if approved.
      */
-    addTransaction(transaction: Transaction, origin?: string, deviceConfirmedOn?: WalletDevice): Promise<Result>;
+    addTransaction(transaction: Transaction, { deviceConfirmedOn, origin, securityAlertResponse, }?: {
+        deviceConfirmedOn?: WalletDevice;
+        origin?: string;
+        securityAlertResponse?: SecurityAlertResponse;
+    }): Promise<Result>;
+    startIncomingTransactionPolling(): void;
+    stopIncomingTransactionPolling(): void;
+    updateIncomingTransactions(): Promise<void>;
     prepareUnsignedEthTx(txParams: Record<string, unknown>): TypedTransaction;
     /**
      * `@ethereumjs/tx` uses `@ethereumjs/common` as a configuration tool for
@@ -212,6 +247,13 @@ export declare class TransactionController extends BaseController<TransactionCon
      * @param transactionMeta - The new transaction to store in state.
      */
     updateTransaction(transactionMeta: TransactionMeta): void;
+    /**
+     * Update the security alert response for a transaction.
+     *
+     * @param transactionId - ID of the transaction.
+     * @param securityAlertResponse - The new security alert response for the transaction.
+     */
+    updateSecurityAlertResponse(transactionId: string, securityAlertResponse: SecurityAlertResponse): void;
     /**
      * Removes all transactions from state, optionally based on the current network.
      *
@@ -219,33 +261,34 @@ export declare class TransactionController extends BaseController<TransactionCon
      * current network. If `true`, all transactions are wiped.
      */
     wipeTransactions(ignoreNetwork?: boolean): void;
+    private processApproval;
     /**
-     * Get transactions from Etherscan for the given address. By default all transactions are
-     * returned, but the `fromBlock` option can be given to filter just for transactions from a
-     * specific block onward.
+     * Gets the next nonce according to the nonce-tracker.
+     * Ensure `releaseLock` is called once processing of the `nonce` value is complete.
      *
-     * @param address - The address to fetch the transactions for.
-     * @param opt - Object containing optional data, fromBlock and Etherscan API key.
-     * @returns The block number of the latest incoming transaction.
+     * @param address - The hex string address for the transaction.
+     * @returns object with the `nextNonce` `nonceDetails`, and the releaseLock.
      */
-    fetchAll(address: string, opt?: FetchAllOptions): Promise<string | void>;
-    private processApproval;
+    getNonceLock(address: string): Promise<NonceLock>;
     /**
-     * Approves a transaction and updates it's status in state. If this is not a
-     * retry transaction, a nonce will be generated. The transaction is signed
-     * using the sign configuration property, then published to the blockchain.
-     * A `<tx.id>:finished` hub event is fired after success or failure.
+     * Signs and returns the raw transaction data for provided transaction params list.
      *
-     * @param transactionID - The ID of the transaction to approve.
+     * @param listOfTxParams - The list of transaction params to approve.
+     * @param opts - Options bag.
+     * @param opts.hasNonce - Whether the transactions already have a nonce.
+     * @returns The raw transactions.
      */
-    private approveTransaction;
+    approveTransactionsWithSameNonce(listOfTxParams?: Transaction[], { hasNonce }?: {
+        hasNonce?: boolean;
+    }): Promise<string | string[]>;
     /**
-     * Cancels a transaction based on its ID by setting its status to "rejected"
-     * and emitting a `<tx.id>:finished` hub event.
+     * Adds external provided transaction to state as confirmed transaction.
      *
-     * @param transactionID - The ID of the transaction to cancel.
+     * @param transactionMeta - TransactionMeta to add transactions.
+     * @param transactionReceipt - TransactionReceipt of the external transaction.
+     * @param baseFeePerGas - Base fee per gas of the external transaction.
      */
-    private cancelTransaction;
+    confirmExternalTransaction(transactionMeta: TransactionMeta, transactionReceipt: TransactionReceipt, baseFeePerGas: Hex): Promise<void>;
     /**
      * Trim the amount of transactions that are set on the state. Checks
      * if the length of the tx history is longer then desired persistence
@@ -293,9 +336,55 @@ export declare class TransactionController extends BaseController<TransactionCon
      */
     private checkTxReceiptStatusIsFailed;
     private requestApproval;
-    private getTransaction;
     private getApprovalId;
+    /**
+     * Approves a transaction and updates it's status in state. If this is not a
+     * retry transaction, a nonce will be generated. The transaction is signed
+     * using the sign configuration property, then published to the blockchain.
+     * A `<tx.id>:finished` hub event is fired after success or failure.
+     *
+     * @param transactionID - The ID of the transaction to approve.
+     */
+    private approveTransaction;
+    private publishTransaction;
+    /**
+     * Cancels a transaction based on its ID by setting its status to "rejected"
+     * and emitting a `<tx.id>:finished` hub event.
+     *
+     * @param transactionID - The ID of the transaction to cancel.
+     */
+    private cancelTransaction;
+    private getTransaction;
     private isTransactionCompleted;
+    private onIncomingTransactions;
+    private onUpdatedLastFetchedBlockNumbers;
+    private getNonceTrackerTransactions;
+    private updateSubmitHistory;
+    private getGasFeeFlows;
+    private getNonceTrackerPendingTransactions;
+    /**
+     * Validates and adds external provided transaction to state.
+     *
+     * @param transactionMeta - Nominated external transaction to be added to state.
+     */
+    private addExternalTransaction;
+    /**
+     * Sets other txMeta statuses to dropped if the txMeta that has been confirmed has other transactions
+     * in the transactions have the same nonce.
+     *
+     * @param transactionId - Used to identify original transaction.
+     */
+    private markNonceDuplicatesDropped;
+    /**
+     * Method to set transaction status to dropped.
+     *
+     * @param transactionMeta - TransactionMeta of transaction to be marked as dropped.
+     */
+    private setTransactionStatusDropped;
+    private updatePostBalance;
+    private signExternalTransaction;
+    private onTransactionStatusChange;
+    private getChainId;
 }
 export default TransactionController;
 //# sourceMappingURL=TransactionController.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/TransactionController.d.ts.map b/node_modules/@metamask/transaction-controller/dist/TransactionController.d.ts.map
deleted file mode 100644
index 61bec0a..0000000
--- a/node_modules/@metamask/transaction-controller/dist/TransactionController.d.ts.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"TransactionController.d.ts","sourceRoot":"","sources":["../src/TransactionController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/TransactionController.js b/node_modules/@metamask/transaction-controller/dist/TransactionController.js
index b67387e..63c076b 100644
--- a/node_modules/@metamask/transaction-controller/dist/TransactionController.js
+++ b/node_modules/@metamask/transaction-controller/dist/TransactionController.js
@@ -12,7 +12,7 @@ var __importDefault = (this && this.__importDefault) || function (mod) {
     return (mod && mod.__esModule) ? mod : { "default": mod };
 };
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.TransactionController = exports.SPEED_UP_RATE = exports.CANCEL_RATE = exports.HARDFORK = void 0;
+exports.TransactionController = exports.SPEED_UP_RATE = exports.CANCEL_RATE = void 0;
 const common_1 = require("@ethereumjs/common");
 const tx_1 = require("@ethereumjs/tx");
 const base_controller_1 = require("@metamask/base-controller");
@@ -23,17 +23,24 @@ const eth_method_registry_1 = __importDefault(require("eth-method-registry"));
 const eth_rpc_errors_1 = require("eth-rpc-errors");
 const ethereumjs_util_1 = require("ethereumjs-util");
 const events_1 = require("events");
-const nonce_tracker_1 = __importDefault(require("nonce-tracker"));
+const lodash_1 = require("lodash");
+const NonceTracker_1 = require("nonce-tracker/dist/NonceTracker");
 const uuid_1 = require("uuid");
 const EtherscanRemoteTransactionSource_1 = require("./EtherscanRemoteTransactionSource");
+const external_transactions_1 = require("./external-transactions");
+const LineaGasFeeFlow_1 = require("./gas-flows/LineaGasFeeFlow");
+const GasFeePoller_1 = require("./helpers/GasFeePoller");
 const IncomingTransactionHelper_1 = require("./IncomingTransactionHelper");
+const logger_1 = require("./logger");
+const swaps_1 = require("./swaps");
 const types_1 = require("./types");
 const utils_1 = require("./utils");
-exports.HARDFORK = common_1.Hardfork.London;
+const HARDFORK = 'london';
+const SUBMIT_HISTORY_LIMIT = 100;
 /**
  * Multiplier used to determine a transaction's increased gas fee during cancellation
  */
-exports.CANCEL_RATE = 1.5;
+exports.CANCEL_RATE = 1.1;
 /**
  * Multiplier used to determine a transaction's increased gas fee during speed up
  */
@@ -50,17 +57,29 @@ class TransactionController extends base_controller_1.BaseController {
      * Creates a TransactionController instance.
      *
      * @param options - The controller options.
+     * @param options.blockTracker - The block tracker used to poll for new blocks data.
+     * @param options.getGasFeeEstimates - Callback to retrieve gas fee estimates.
      * @param options.getNetworkState - Gets the state of the network controller.
+     * @param options.getSelectedAddress - Gets the address of the currently selected account.
+     * @param options.getExternalPendingTransactions - Callback to retrieve pending transactions from external sources.
+     * @param options.incomingTransactions - Configuration options for incoming transaction support.
+     * @param options.incomingTransactions.apiKey - An optional API key to use when fetching remote transaction data.
+     * @param options.incomingTransactions.includeTokenTransfers - Whether or not to include ERC20 token transfers.
+     * @param options.incomingTransactions.isEnabled - Whether or not incoming transaction retrieval is enabled.
+     * @param options.incomingTransactions.updateTransactions - Whether or not to update local transactions using remote transaction data.
+     * @param options.messenger - The controller messenger.
      * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.
      * @param options.provider - The provider used to create the underlying EthQuery instance.
-     * @param options.blockTracker - The block tracker used to poll for new blocks data.
-     * @param options.messenger - The controller messenger.
+     * @param options.hooks - The controller hooks.
+     * @param options.hooks.publish - Alternate logic to publish a transaction.
      * @param config - Initial options used to configure this controller.
      * @param state - Initial state to set on this controller.
      */
-    constructor({ getNetworkState, onNetworkStateChange, provider, blockTracker, messenger, }, config, state) {
+    constructor({ blockTracker, getGasFeeEstimates, getNetworkState, getSelectedAddress, getExternalPendingTransactions, incomingTransactions = {}, messenger, onNetworkStateChange, provider, hooks = {}, }, config, state) {
+        var _a;
         super(config, state);
         this.mutex = new async_mutex_1.Mutex();
+        this.inProcessOfSigning = new Set();
         /**
          * EventEmitter instance used to listen to specific transactional events
          */
@@ -76,25 +95,54 @@ class TransactionController extends base_controller_1.BaseController {
         this.defaultState = {
             methodData: {},
             transactions: [],
+            lastFetchedBlockNumbers: {},
+            submitHistory: [],
         };
         this.initialize();
         this.provider = provider;
         this.messagingSystem = messenger;
+        this.getGasFeeEstimates = getGasFeeEstimates;
         this.getNetworkState = getNetworkState;
         this.ethQuery = new eth_query_1.default(provider);
         this.registry = new eth_method_registry_1.default({ provider });
-        this.nonceTracker = new nonce_tracker_1.default({
+        this.getExternalPendingTransactions =
+            getExternalPendingTransactions !== null && getExternalPendingTransactions !== void 0 ? getExternalPendingTransactions : (() => []);
+        this.publish =
+            (_a = hooks === null || hooks === void 0 ? void 0 : hooks.publish) !== null && _a !== void 0 ? _a : (() => Promise.resolve({ transactionHash: undefined }));
+        this.nonceTracker = new NonceTracker_1.NonceTracker({
             provider,
             blockTracker,
-            getPendingTransactions: (address) => (0, utils_1.getAndFormatTransactionsForNonceTracker)(address, types_1.TransactionStatus.submitted, this.state.transactions),
-            getConfirmedTransactions: (address) => (0, utils_1.getAndFormatTransactionsForNonceTracker)(address, types_1.TransactionStatus.confirmed, this.state.transactions),
+            getPendingTransactions: this.getNonceTrackerPendingTransactions.bind(this),
+            getConfirmedTransactions: this.getNonceTrackerTransactions.bind(this, types_1.TransactionStatus.confirmed),
         });
         this.incomingTransactionHelper = new IncomingTransactionHelper_1.IncomingTransactionHelper({
+            blockTracker,
+            getCurrentAccount: getSelectedAddress,
+            getLastFetchedBlockNumbers: () => this.state.lastFetchedBlockNumbers,
+            getLocalTransactions: () => this.state.transactions,
             getNetworkState,
-            getEthQuery: () => this.ethQuery,
+            isEnabled: incomingTransactions.isEnabled,
+            remoteTransactionSource: new EtherscanRemoteTransactionSource_1.EtherscanRemoteTransactionSource({
+                apiKey: incomingTransactions.apiKey,
+                includeTokenTransfers: incomingTransactions.includeTokenTransfers,
+            }),
             transactionLimit: this.config.txHistoryLimit,
-            remoteTransactionSource: new EtherscanRemoteTransactionSource_1.EtherscanRemoteTransactionSource(),
+            updateTransactions: incomingTransactions.updateTransactions,
+        });
+        this.incomingTransactionHelper.hub.on('transactions', this.onIncomingTransactions.bind(this));
+        this.incomingTransactionHelper.hub.on('updatedLastFetchedBlockNumbers', this.onUpdatedLastFetchedBlockNumbers.bind(this));
+        this.gasFeeFlows = this.getGasFeeFlows();
+        const gasFeePoller = new GasFeePoller_1.GasFeePoller({
+            gasFeeFlows: this.gasFeeFlows,
+            getChainIds: () => [this.getNetworkState().providerConfig.chainId],
+            getEthQuery: () => this.ethQuery,
+            getGasFeeControllerEstimates: this.getGasFeeEstimates,
+            getTransactions: () => this.state.transactions,
+            onStateChange: (listener) => {
+                this.subscribe(listener);
+            },
         });
+        gasFeePoller.hub.on('transaction-updated', this.updateTransaction.bind(this));
         onNetworkStateChange(() => {
             this.ethQuery = new eth_query_1.default(this.provider);
             this.registry = new eth_method_registry_1.default({ provider: this.provider });
@@ -160,15 +208,17 @@ class TransactionController extends base_controller_1.BaseController {
      * if not provided. If A `<tx.id>:unapproved` hub event will be emitted once added.
      *
      * @param transaction - The transaction object to add.
-     * @param origin - The domain origin to append to the generated TransactionMeta.
-     * @param deviceConfirmedOn - An enum to indicate what device the transaction was confirmed to append to the generated TransactionMeta.
+     * @param opts - Additional options to control how the transaction is added.
+     * @param opts.deviceConfirmedOn - An enum to indicate what device confirmed the transaction.
+     * @param opts.origin - The origin of the transaction request, such as a dApp hostname.
+     * @param opts.securityAlertResponse - Response from security validator.
      * @returns Object containing a promise resolving to the transaction hash if approved.
      */
-    addTransaction(transaction, origin, deviceConfirmedOn) {
+    addTransaction(transaction, { deviceConfirmedOn, origin, securityAlertResponse, } = {}) {
         return __awaiter(this, void 0, void 0, function* () {
             const { providerConfig, networkId } = this.getNetworkState();
             const { transactions } = this.state;
-            transaction = (0, utils_1.normalizeTransaction)(transaction);
+            transaction = (0, utils_1.normalizeTransactionParams)(transaction);
             (0, utils_1.validateTransaction)(transaction);
             const transactionMeta = {
                 id: (0, uuid_1.v1)(),
@@ -180,6 +230,7 @@ class TransactionController extends base_controller_1.BaseController {
                 transaction,
                 deviceConfirmedOn,
                 verifiedOnBlockchain: false,
+                securityAlertResponse,
             };
             try {
                 const { gas, estimateGasError } = yield this.estimateGas(transaction);
@@ -199,6 +250,17 @@ class TransactionController extends base_controller_1.BaseController {
             };
         });
     }
+    startIncomingTransactionPolling() {
+        this.incomingTransactionHelper.start();
+    }
+    stopIncomingTransactionPolling() {
+        this.incomingTransactionHelper.stop();
+    }
+    updateIncomingTransactions() {
+        return __awaiter(this, void 0, void 0, function* () {
+            yield this.incomingTransactionHelper.update();
+        });
+    }
     prepareUnsignedEthTx(txParams) {
         return tx_1.TransactionFactory.fromTxData(txParams, {
             common: this.getCommonConfiguration(),
@@ -218,14 +280,15 @@ class TransactionController extends base_controller_1.BaseController {
         const { networkId, providerConfig: { type: chain, chainId, nickname: name }, } = this.getNetworkState();
         if (chain !== controller_utils_1.RPC &&
             chain !== controller_utils_1.NetworkType['linea-goerli'] &&
+            chain !== controller_utils_1.NetworkType['linea-sepolia'] &&
             chain !== controller_utils_1.NetworkType['linea-mainnet']) {
-            return new common_1.Common({ chain, hardfork: exports.HARDFORK });
+            return new common_1.Common({ chain, hardfork: HARDFORK });
         }
         const customChainParams = {
             name,
             chainId: parseInt(chainId, 16),
             networkId: networkId === null ? NaN : parseInt(networkId, undefined),
-            defaultHardfork: exports.HARDFORK,
+            defaultHardfork: HARDFORK,
         };
         return common_1.Common.custom(customChainParams);
     }
@@ -291,7 +354,7 @@ class TransactionController extends base_controller_1.BaseController {
             const unsignedEthTx = this.prepareUnsignedEthTx(txParams);
             const signedTx = yield this.sign(unsignedEthTx, transactionMeta.transaction.from);
             const rawTransaction = (0, ethereumjs_util_1.bufferToHex)(signedTx.serialize());
-            yield (0, controller_utils_1.query)(this.ethQuery, 'sendRawTransaction', [rawTransaction]);
+            yield this.publishTransaction(rawTransaction, txParams, transactionMeta.chainId, 'cancel');
             transactionMeta.status = types_1.TransactionStatus.cancelled;
             this.hub.emit(`${transactionMeta.id}:finished`, transactionMeta);
         });
@@ -343,9 +406,7 @@ class TransactionController extends base_controller_1.BaseController {
             const unsignedEthTx = this.prepareUnsignedEthTx(txParams);
             const signedTx = yield this.sign(unsignedEthTx, transactionMeta.transaction.from);
             const rawTransaction = (0, ethereumjs_util_1.bufferToHex)(signedTx.serialize());
-            const transactionHash = yield (0, controller_utils_1.query)(this.ethQuery, 'sendRawTransaction', [
-                rawTransaction,
-            ]);
+            const transactionHash = yield this.publishTransaction(rawTransaction, txParams, transactionMeta.chainId, controller_utils_1.ORIGIN_METAMASK);
             const baseTransactionMeta = Object.assign(Object.assign({}, transactionMeta), { id: (0, uuid_1.v1)(), time: Date.now(), transactionHash });
             const newTransactionMeta = newMaxFeePerGas && newMaxPriorityFeePerGas
                 ? Object.assign(Object.assign({}, baseTransactionMeta), { transaction: Object.assign(Object.assign({}, transactionMeta.transaction), { maxFeePerGas: newMaxFeePerGas, maxPriorityFeePerGas: newMaxPriorityFeePerGas }) }) : Object.assign(Object.assign({}, baseTransactionMeta), { transaction: Object.assign(Object.assign({}, transactionMeta.transaction), { gasPrice: newGasPrice }) });
@@ -404,6 +465,8 @@ class TransactionController extends base_controller_1.BaseController {
             }
             catch (error) {
                 estimateGasError = utils_1.ESTIMATE_GAS_ERROR;
+                // Fallback to 95% of the block gasLimit.
+                gasHex = estimatedTransaction.gas;
             }
             // 4. Pad estimated gas without exceeding the most recent block gasLimit. If the network is a
             // a custom network then return the eth_estimateGas value.
@@ -463,12 +526,29 @@ class TransactionController extends base_controller_1.BaseController {
      */
     updateTransaction(transactionMeta) {
         const { transactions } = this.state;
-        transactionMeta.transaction = (0, utils_1.normalizeTransaction)(transactionMeta.transaction);
+        transactionMeta.transaction = (0, utils_1.normalizeTransactionParams)(transactionMeta.transaction);
         (0, utils_1.validateTransaction)(transactionMeta.transaction);
         const index = transactions.findIndex(({ id }) => transactionMeta.id === id);
         transactions[index] = transactionMeta;
         this.update({ transactions: this.trimTransactionsForState(transactions) });
     }
+    /**
+     * Update the security alert response for a transaction.
+     *
+     * @param transactionId - ID of the transaction.
+     * @param securityAlertResponse - The new security alert response for the transaction.
+     */
+    updateSecurityAlertResponse(transactionId, securityAlertResponse) {
+        if (!securityAlertResponse) {
+            throw new Error('updateSecurityAlertResponse: securityAlertResponse should not be null');
+        }
+        const transactionMeta = this.getTransaction(transactionId);
+        if (!transactionMeta) {
+            throw new Error(`Cannot update security alert response as no transaction metadata found`);
+        }
+        const updatedMeta = (0, lodash_1.merge)(transactionMeta, { securityAlertResponse });
+        this.updateTransaction(updatedMeta);
+    }
     /**
      * Removes all transactions from state, optionally based on the current network.
      *
@@ -493,32 +573,6 @@ class TransactionController extends base_controller_1.BaseController {
             transactions: this.trimTransactionsForState(newTransactions),
         });
     }
-    /**
-     * Get transactions from Etherscan for the given address. By default all transactions are
-     * returned, but the `fromBlock` option can be given to filter just for transactions from a
-     * specific block onward.
-     *
-     * @param address - The address to fetch the transactions for.
-     * @param opt - Object containing optional data, fromBlock and Etherscan API key.
-     * @returns The block number of the latest incoming transaction.
-     */
-    fetchAll(address, opt) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const { transactions: localTransactions } = this.state;
-            const { updateRequired, transactions, latestBlockNumber } = yield this.incomingTransactionHelper.reconcile({
-                address,
-                localTransactions,
-                fromBlock: opt === null || opt === void 0 ? void 0 : opt.fromBlock,
-                apiKey: opt === null || opt === void 0 ? void 0 : opt.etherscanApiKey,
-            });
-            if (updateRequired) {
-                this.update({
-                    transactions: this.trimTransactionsForState(transactions),
-                });
-            }
-            return latestBlockNumber;
-        });
-    }
     processApproval(transactionMeta) {
         return __awaiter(this, void 0, void 0, function* () {
             const transactionId = transactionMeta.id;
@@ -563,97 +617,110 @@ class TransactionController extends base_controller_1.BaseController {
         });
     }
     /**
-     * Approves a transaction and updates it's status in state. If this is not a
-     * retry transaction, a nonce will be generated. The transaction is signed
-     * using the sign configuration property, then published to the blockchain.
-     * A `<tx.id>:finished` hub event is fired after success or failure.
+     * Gets the next nonce according to the nonce-tracker.
+     * Ensure `releaseLock` is called once processing of the `nonce` value is complete.
      *
-     * @param transactionID - The ID of the transaction to approve.
+     * @param address - The hex string address for the transaction.
+     * @returns object with the `nextNonce` `nonceDetails`, and the releaseLock.
      */
-    approveTransaction(transactionID) {
+    getNonceLock(address) {
         return __awaiter(this, void 0, void 0, function* () {
-            const { transactions } = this.state;
-            const releaseLock = yield this.mutex.acquire();
-            const { providerConfig } = this.getNetworkState();
-            const { chainId } = providerConfig;
-            const index = transactions.findIndex(({ id }) => transactionID === id);
-            const transactionMeta = transactions[index];
-            const { transaction: { nonce, from }, } = transactionMeta;
-            let nonceLock;
+            return this.nonceTracker.getNonceLock(address);
+        });
+    }
+    /**
+     * Signs and returns the raw transaction data for provided transaction params list.
+     *
+     * @param listOfTxParams - The list of transaction params to approve.
+     * @param opts - Options bag.
+     * @param opts.hasNonce - Whether the transactions already have a nonce.
+     * @returns The raw transactions.
+     */
+    approveTransactionsWithSameNonce(listOfTxParams = [], { hasNonce } = {}) {
+        return __awaiter(this, void 0, void 0, function* () {
+            (0, logger_1.projectLogger)('Approving transactions with same nonce', {
+                transactions: listOfTxParams,
+            });
+            if (listOfTxParams.length === 0) {
+                return '';
+            }
+            const initialTx = listOfTxParams[0];
+            const common = this.getCommonConfiguration();
+            const initialTxAsEthTx = tx_1.TransactionFactory.fromTxData(initialTx, {
+                common,
+            });
+            const initialTxAsSerializedHex = (0, ethereumjs_util_1.bufferToHex)(initialTxAsEthTx.serialize());
+            if (this.inProcessOfSigning.has(initialTxAsSerializedHex)) {
+                return '';
+            }
+            this.inProcessOfSigning.add(initialTxAsSerializedHex);
+            let rawTransactions, nonceLock;
             try {
-                if (!this.sign) {
-                    releaseLock();
-                    this.failTransaction(transactionMeta, new Error('No sign method defined.'));
-                    return;
-                }
-                else if (!chainId) {
-                    releaseLock();
-                    this.failTransaction(transactionMeta, new Error('No chainId defined.'));
-                    return;
-                }
-                const { approved: status } = types_1.TransactionStatus;
-                let nonceToUse = nonce;
-                // if a nonce already exists on the transactionMeta it means this is a speedup or cancel transaction
-                // so we want to reuse that nonce and hope that it beats the previous attempt to chain. Otherwise use a new locked nonce
-                if (!nonceToUse) {
-                    nonceLock = yield this.nonceTracker.getNonceLock(from);
-                    nonceToUse = (0, ethereumjs_util_1.addHexPrefix)(nonceLock.nextNonce.toString(16));
-                }
-                transactionMeta.status = status;
-                transactionMeta.transaction.nonce = nonceToUse;
-                transactionMeta.transaction.chainId = chainId;
-                const baseTxParams = Object.assign(Object.assign({}, transactionMeta.transaction), { gasLimit: transactionMeta.transaction.gas });
-                const isEIP1559 = (0, utils_1.isEIP1559Transaction)(transactionMeta.transaction);
-                const txParams = isEIP1559
-                    ? Object.assign(Object.assign({}, baseTxParams), { maxFeePerGas: transactionMeta.transaction.maxFeePerGas, maxPriorityFeePerGas: transactionMeta.transaction.maxPriorityFeePerGas, estimatedBaseFee: transactionMeta.transaction.estimatedBaseFee, 
-                        // specify type 2 if maxFeePerGas and maxPriorityFeePerGas are set
-                        type: 2 }) : baseTxParams;
-                // delete gasPrice if maxFeePerGas and maxPriorityFeePerGas are set
-                if (isEIP1559) {
-                    delete txParams.gasPrice;
+                // TODO: we should add a check to verify that all transactions have the same from address
+                const fromAddress = initialTx.from;
+                const requiresNonce = hasNonce !== true;
+                nonceLock = requiresNonce
+                    ? yield this.nonceTracker.getNonceLock(fromAddress)
+                    : undefined;
+                const nonce = nonceLock
+                    ? (0, ethereumjs_util_1.addHexPrefix)(nonceLock.nextNonce.toString(16))
+                    : initialTx.nonce;
+                if (nonceLock) {
+                    (0, logger_1.projectLogger)('Using nonce from nonce tracker', nonce, nonceLock.nonceDetails);
                 }
-                const unsignedEthTx = this.prepareUnsignedEthTx(txParams);
-                const signedTx = yield this.sign(unsignedEthTx, from);
-                transactionMeta.status = types_1.TransactionStatus.signed;
-                this.updateTransaction(transactionMeta);
-                const rawTransaction = (0, ethereumjs_util_1.bufferToHex)(signedTx.serialize());
-                transactionMeta.rawTransaction = rawTransaction;
-                this.updateTransaction(transactionMeta);
-                const transactionHash = yield (0, controller_utils_1.query)(this.ethQuery, 'sendRawTransaction', [
-                    rawTransaction,
-                ]);
-                transactionMeta.transactionHash = transactionHash;
-                transactionMeta.status = types_1.TransactionStatus.submitted;
-                this.updateTransaction(transactionMeta);
-                this.hub.emit(`${transactionMeta.id}:finished`, transactionMeta);
+                rawTransactions = yield Promise.all(listOfTxParams.map((txParams) => {
+                    txParams.nonce = nonce;
+                    return this.signExternalTransaction(txParams);
+                }));
             }
-            catch (error) {
-                this.failTransaction(transactionMeta, error);
+            catch (err) {
+                (0, logger_1.projectLogger)('Error while signing transactions with same nonce', err);
+                // Must set transaction to submitted/failed before releasing lock
+                // continue with error chain
+                throw err;
             }
             finally {
-                // must set transaction to submitted/failed before releasing lock
-                if (nonceLock) {
-                    nonceLock.releaseLock();
-                }
-                releaseLock();
+                nonceLock === null || nonceLock === void 0 ? void 0 : nonceLock.releaseLock();
+                this.inProcessOfSigning.delete(initialTxAsSerializedHex);
             }
+            return rawTransactions;
         });
     }
     /**
-     * Cancels a transaction based on its ID by setting its status to "rejected"
-     * and emitting a `<tx.id>:finished` hub event.
+     * Adds external provided transaction to state as confirmed transaction.
      *
-     * @param transactionID - The ID of the transaction to cancel.
+     * @param transactionMeta - TransactionMeta to add transactions.
+     * @param transactionReceipt - TransactionReceipt of the external transaction.
+     * @param baseFeePerGas - Base fee per gas of the external transaction.
      */
-    cancelTransaction(transactionID) {
-        const transactionMeta = this.state.transactions.find(({ id }) => id === transactionID);
-        if (!transactionMeta) {
-            return;
-        }
-        transactionMeta.status = types_1.TransactionStatus.rejected;
-        this.hub.emit(`${transactionMeta.id}:finished`, transactionMeta);
-        const transactions = this.state.transactions.filter(({ id }) => id !== transactionID);
-        this.update({ transactions: this.trimTransactionsForState(transactions) });
+    confirmExternalTransaction(transactionMeta, transactionReceipt, baseFeePerGas) {
+        return __awaiter(this, void 0, void 0, function* () {
+            // Run validation and add external transaction to state.
+            this.addExternalTransaction(transactionMeta);
+            try {
+                const transactionId = transactionMeta.id;
+                // Make sure status is confirmed and define gasUsed as in receipt.
+                transactionMeta.status = types_1.TransactionStatus.confirmed;
+                transactionMeta.txReceipt = transactionReceipt;
+                if (baseFeePerGas) {
+                    transactionMeta.baseFeePerGas = baseFeePerGas;
+                }
+                // Update same nonce local transactions as dropped and define replacedBy properties.
+                this.markNonceDuplicatesDropped(transactionId);
+                // Update external provided transaction with updated gas values and confirmed status.
+                this.updateTransaction(transactionMeta);
+                this.onTransactionStatusChange(transactionMeta);
+                // Intentional given potential duration of process.
+                // eslint-disable-next-line @typescript-eslint/no-floating-promises
+                this.updatePostBalance(transactionMeta);
+                this.hub.emit('transaction-confirmed', {
+                    transactionMeta,
+                });
+            }
+            catch (error) {
+                console.error('Failed to confirm external transaction', error);
+            }
+        });
     }
     /**
      * Trim the amount of transactions that are set on the state. Checks
@@ -671,7 +738,9 @@ class TransactionController extends base_controller_1.BaseController {
      */
     trimTransactionsForState(transactions) {
         const nonceNetworkSet = new Set();
-        const txsToKeep = transactions.reverse().filter((tx) => {
+        const txsToKeep = transactions
+            .sort((a, b) => (a.time > b.time ? -1 : 1)) // Descending time order
+            .filter((tx) => {
             const { chainId, networkID, status, transaction, time } = tx;
             if (transaction) {
                 const key = `${transaction.nonce}-${chainId ? (0, controller_utils_1.convertHexToDecimal)(chainId) : networkID}-${new Date(time).toDateString()}`;
@@ -686,7 +755,7 @@ class TransactionController extends base_controller_1.BaseController {
             }
             return false;
         });
-        txsToKeep.reverse();
+        txsToKeep.reverse(); // Ascending time order
         return txsToKeep;
     }
     /**
@@ -758,9 +827,17 @@ class TransactionController extends base_controller_1.BaseController {
                     }
                     /* istanbul ignore next */
                     if (txObj === null || txObj === void 0 ? void 0 : txObj.blockNumber) {
-                        meta.status = types_1.TransactionStatus.confirmed;
-                        this.hub.emit(`${meta.id}:confirmed`, meta);
-                        return [meta, true];
+                        // transactions can be added to a block and still fail, so we need to check the transaction status before emitting the confirmed event
+                        const txStatusFailed = yield this.checkTxReceiptStatusIsFailed(transactionHash);
+                        if (txStatusFailed) {
+                            const error = new Error('Transaction failed. The transaction was reversed');
+                            this.failTransaction(meta, error);
+                        }
+                        else {
+                            meta.status = types_1.TransactionStatus.confirmed;
+                            this.hub.emit(`${meta.id}:confirmed`, meta);
+                            return [meta, true];
+                        }
                     }
                     return [meta, false];
                 default:
@@ -804,13 +881,122 @@ class TransactionController extends base_controller_1.BaseController {
             }, true));
         });
     }
+    getApprovalId(txMeta) {
+        return String(txMeta.id);
+    }
+    /**
+     * Approves a transaction and updates it's status in state. If this is not a
+     * retry transaction, a nonce will be generated. The transaction is signed
+     * using the sign configuration property, then published to the blockchain.
+     * A `<tx.id>:finished` hub event is fired after success or failure.
+     *
+     * @param transactionID - The ID of the transaction to approve.
+     */
+    approveTransaction(transactionID) {
+        return __awaiter(this, void 0, void 0, function* () {
+            const { transactions } = this.state;
+            const releaseLock = yield this.mutex.acquire();
+            const { providerConfig } = this.getNetworkState();
+            const { chainId: currentChainId } = providerConfig;
+            const index = transactions.findIndex(({ id }) => transactionID === id);
+            const transactionMeta = transactions[index];
+            const { transaction: { nonce, from }, } = transactionMeta;
+            let nonceLock;
+            try {
+                if (!this.sign) {
+                    releaseLock();
+                    this.failTransaction(transactionMeta, new Error('No sign method defined.'));
+                    return;
+                }
+                else if (!currentChainId) {
+                    releaseLock();
+                    this.failTransaction(transactionMeta, new Error('No chainId defined.'));
+                    return;
+                }
+                if (this.inProcessOfSigning.has(transactionID)) {
+                    (0, logger_1.projectLogger)('Skipping approval as signing in progress', transactionID);
+                    return;
+                }
+                const { approved: status } = types_1.TransactionStatus;
+                let nonceToUse = nonce;
+                // if a nonce already exists on the transactionMeta it means this is a speedup or cancel transaction
+                // so we want to reuse that nonce and hope that it beats the previous attempt to chain. Otherwise use a new locked nonce
+                if (!nonceToUse) {
+                    nonceLock = yield this.nonceTracker.getNonceLock(from);
+                    nonceToUse = (0, ethereumjs_util_1.addHexPrefix)(nonceLock.nextNonce.toString(16));
+                }
+                transactionMeta.status = status;
+                transactionMeta.transaction.nonce = nonceToUse;
+                transactionMeta.transaction.chainId = currentChainId;
+                const baseTxParams = Object.assign(Object.assign({}, transactionMeta.transaction), { gasLimit: transactionMeta.transaction.gas });
+                const isEIP1559 = (0, utils_1.isEIP1559Transaction)(transactionMeta.transaction);
+                const txParams = isEIP1559
+                    ? Object.assign(Object.assign({}, baseTxParams), { maxFeePerGas: transactionMeta.transaction.maxFeePerGas, maxPriorityFeePerGas: transactionMeta.transaction.maxPriorityFeePerGas, estimatedBaseFee: transactionMeta.transaction.estimatedBaseFee, 
+                        // specify type 2 if maxFeePerGas and maxPriorityFeePerGas are set
+                        type: 2 }) : baseTxParams;
+                // delete gasPrice if maxFeePerGas and maxPriorityFeePerGas are set
+                if (isEIP1559) {
+                    delete txParams.gasPrice;
+                }
+                const unsignedEthTx = this.prepareUnsignedEthTx(txParams);
+                this.inProcessOfSigning.add(transactionMeta.id);
+                const signedTx = yield this.sign(unsignedEthTx, from);
+                transactionMeta.status = types_1.TransactionStatus.signed;
+                this.updateTransaction(transactionMeta);
+                const rawTransaction = (0, ethereumjs_util_1.bufferToHex)(signedTx.serialize());
+                transactionMeta.rawTransaction = rawTransaction;
+                this.updateTransaction(transactionMeta);
+                let { transactionHash: hash } = yield this.publish(transactionMeta, rawTransaction);
+                if (hash === undefined) {
+                    hash = yield this.publishTransaction(rawTransaction, txParams, currentChainId, transactionMeta.origin);
+                }
+                transactionMeta.transactionHash = hash;
+                transactionMeta.status = types_1.TransactionStatus.submitted;
+                this.updateTransaction(transactionMeta);
+                this.hub.emit(`${transactionMeta.id}:finished`, transactionMeta);
+            }
+            catch (error) {
+                this.failTransaction(transactionMeta, error);
+            }
+            finally {
+                this.inProcessOfSigning.delete(transactionID);
+                // must set transaction to submitted/failed before releasing lock
+                if (nonceLock) {
+                    nonceLock.releaseLock();
+                }
+                releaseLock();
+            }
+        });
+    }
+    publishTransaction(rawTransaction, transaction, chainId, origin) {
+        return __awaiter(this, void 0, void 0, function* () {
+            const transactionHash = yield (0, controller_utils_1.query)(this.ethQuery, 'sendRawTransaction', [
+                rawTransaction,
+            ]);
+            this.updateSubmitHistory(rawTransaction, transactionHash, transaction, chainId, origin);
+            return transactionHash;
+        });
+    }
+    /**
+     * Cancels a transaction based on its ID by setting its status to "rejected"
+     * and emitting a `<tx.id>:finished` hub event.
+     *
+     * @param transactionID - The ID of the transaction to cancel.
+     */
+    cancelTransaction(transactionID) {
+        const transactionMeta = this.state.transactions.find(({ id }) => id === transactionID);
+        if (!transactionMeta) {
+            return;
+        }
+        transactionMeta.status = types_1.TransactionStatus.rejected;
+        this.hub.emit(`${transactionMeta.id}:finished`, transactionMeta);
+        const transactions = this.state.transactions.filter(({ id }) => id !== transactionID);
+        this.update({ transactions: this.trimTransactionsForState(transactions) });
+    }
     getTransaction(transactionID) {
         const { transactions } = this.state;
         return transactions.find(({ id }) => id === transactionID);
     }
-    getApprovalId(txMeta) {
-        return String(txMeta.id);
-    }
     isTransactionCompleted(transactionid) {
         const transaction = this.getTransaction(transactionid);
         if (!transaction) {
@@ -819,6 +1005,164 @@ class TransactionController extends base_controller_1.BaseController {
         const isCompleted = this.isLocalFinalState(transaction.status);
         return { meta: transaction, isCompleted };
     }
+    onIncomingTransactions({ added, updated, }) {
+        const { transactions: currentTransactions } = this.state;
+        const updatedTransactions = [
+            ...added,
+            ...currentTransactions.map((originalTransaction) => {
+                const updatedTransaction = updated.find(({ transactionHash }) => transactionHash === originalTransaction.transactionHash);
+                return updatedTransaction !== null && updatedTransaction !== void 0 ? updatedTransaction : originalTransaction;
+            }),
+        ];
+        this.update({
+            transactions: this.trimTransactionsForState(updatedTransactions),
+        });
+        this.hub.emit('incomingTransactions', { added, updated });
+    }
+    onUpdatedLastFetchedBlockNumbers({ lastFetchedBlockNumbers, blockNumber, }) {
+        this.update({ lastFetchedBlockNumbers });
+        this.hub.emit('incomingTransactionBlock', blockNumber);
+    }
+    getNonceTrackerTransactions(status, address) {
+        const { chainId: currentChainId } = this.getNetworkState().providerConfig;
+        return (0, utils_1.getAndFormatTransactionsForNonceTracker)(currentChainId, address, status, this.state.transactions);
+    }
+    updateSubmitHistory(rawTransaction, hash, transaction, chainId, origin) {
+        const { rpcUrl: networkUrl, type: networkType } = this.getNetworkState().providerConfig;
+        const submitHistoryEntry = {
+            chainId,
+            hash,
+            networkType,
+            networkUrl,
+            origin,
+            time: Date.now(),
+            transaction,
+            rawTransaction,
+        };
+        const submitHistory = [submitHistoryEntry, ...this.state.submitHistory];
+        if (submitHistory.length > SUBMIT_HISTORY_LIMIT) {
+            submitHistory.pop();
+        }
+        this.update({ submitHistory });
+    }
+    getGasFeeFlows() {
+        return [new LineaGasFeeFlow_1.LineaGasFeeFlow()];
+    }
+    getNonceTrackerPendingTransactions(address) {
+        const standardPendingTransactions = this.getNonceTrackerTransactions(types_1.TransactionStatus.submitted, address);
+        const externalPendingTransactions = this.getExternalPendingTransactions(address);
+        return [...standardPendingTransactions, ...externalPendingTransactions];
+    }
+    /**
+     * Validates and adds external provided transaction to state.
+     *
+     * @param transactionMeta - Nominated external transaction to be added to state.
+     */
+    addExternalTransaction(transactionMeta) {
+        var _a;
+        const chainId = this.getChainId();
+        const { transactions } = this.state;
+        const fromAddress = (_a = transactionMeta === null || transactionMeta === void 0 ? void 0 : transactionMeta.transaction) === null || _a === void 0 ? void 0 : _a.from;
+        const sameFromAndNetworkTransactions = transactions.filter((transaction) => transaction.transaction.from === fromAddress &&
+            transaction.chainId === chainId);
+        const confirmedTxs = sameFromAndNetworkTransactions.filter((transaction) => transaction.status === types_1.TransactionStatus.confirmed);
+        const pendingTxs = sameFromAndNetworkTransactions.filter((transaction) => transaction.status === types_1.TransactionStatus.submitted);
+        (0, external_transactions_1.validateConfirmedExternalTransaction)(transactionMeta, confirmedTxs, pendingTxs);
+        const updatedTransactions = [...transactions, transactionMeta];
+        this.update({
+            transactions: this.trimTransactionsForState(updatedTransactions),
+        });
+    }
+    /**
+     * Sets other txMeta statuses to dropped if the txMeta that has been confirmed has other transactions
+     * in the transactions have the same nonce.
+     *
+     * @param transactionId - Used to identify original transaction.
+     */
+    markNonceDuplicatesDropped(transactionId) {
+        var _a, _b;
+        const chainId = this.getChainId();
+        const transactionMeta = this.getTransaction(transactionId);
+        const nonce = (_a = transactionMeta === null || transactionMeta === void 0 ? void 0 : transactionMeta.transaction) === null || _a === void 0 ? void 0 : _a.nonce;
+        const from = (_b = transactionMeta === null || transactionMeta === void 0 ? void 0 : transactionMeta.transaction) === null || _b === void 0 ? void 0 : _b.from;
+        const sameNonceTxs = this.state.transactions.filter((transaction) => transaction.id !== transactionId &&
+            transaction.transaction.from === from &&
+            transaction.transaction.nonce === nonce &&
+            transaction.chainId === chainId &&
+            transaction.type !== types_1.TransactionType.incoming);
+        if (!sameNonceTxs.length) {
+            return;
+        }
+        // Mark all same nonce transactions as dropped and give it a replacedBy hash
+        for (const transaction of sameNonceTxs) {
+            transaction.replacedBy = transactionMeta === null || transactionMeta === void 0 ? void 0 : transactionMeta.transactionHash;
+            transaction.replacedById = transactionMeta === null || transactionMeta === void 0 ? void 0 : transactionMeta.id;
+            // Drop any transaction that wasn't previously failed (off chain failure)
+            if (transaction.status !== types_1.TransactionStatus.failed) {
+                this.setTransactionStatusDropped(transaction);
+            }
+        }
+    }
+    /**
+     * Method to set transaction status to dropped.
+     *
+     * @param transactionMeta - TransactionMeta of transaction to be marked as dropped.
+     */
+    setTransactionStatusDropped(transactionMeta) {
+        transactionMeta.status = types_1.TransactionStatus.dropped;
+        this.hub.emit('transaction-dropped', {
+            transactionMeta,
+        });
+        this.updateTransaction(transactionMeta);
+        this.onTransactionStatusChange(transactionMeta);
+    }
+    updatePostBalance(transactionMeta) {
+        return __awaiter(this, void 0, void 0, function* () {
+            try {
+                if (transactionMeta.type !== types_1.TransactionType.swap) {
+                    return;
+                }
+                const { updatedTransactionMeta, approvalTransactionMeta } = yield (0, swaps_1.updatePostTransactionBalance)(transactionMeta, {
+                    ethQuery: this.ethQuery,
+                    getTransaction: this.getTransaction.bind(this),
+                    updateTransaction: this.updateTransaction.bind(this),
+                });
+                this.hub.emit('post-transaction-balance-updated', {
+                    transactionMeta: updatedTransactionMeta,
+                    approvalTransactionMeta,
+                });
+            }
+            catch (error) {
+                console.error('Error while updating post transaction balance', error);
+            }
+        });
+    }
+    signExternalTransaction(transactionParams) {
+        return __awaiter(this, void 0, void 0, function* () {
+            if (!this.sign) {
+                throw new Error('No sign method defined.');
+            }
+            const normalizedTransactionParams = (0, utils_1.normalizeTransactionParams)(transactionParams);
+            const chainId = this.getChainId();
+            const type = (0, utils_1.isEIP1559Transaction)(normalizedTransactionParams)
+                ? types_1.TransactionEnvelopeType.feeMarket
+                : types_1.TransactionEnvelopeType.legacy;
+            const updatedTransactionParams = Object.assign(Object.assign({}, normalizedTransactionParams), { type, gasLimit: normalizedTransactionParams.gas, chainId });
+            const { from } = updatedTransactionParams;
+            const common = this.getCommonConfiguration();
+            const unsignedTransaction = tx_1.TransactionFactory.fromTxData(updatedTransactionParams, { common });
+            const signedTransaction = yield this.sign(unsignedTransaction, from);
+            const rawTransaction = (0, ethereumjs_util_1.bufferToHex)(signedTransaction.serialize());
+            return rawTransaction;
+        });
+    }
+    onTransactionStatusChange(transactionMeta) {
+        this.hub.emit('transaction-status-update', { transactionMeta });
+    }
+    getChainId() {
+        const { providerConfig } = this.getNetworkState();
+        return providerConfig.chainId;
+    }
 }
 exports.TransactionController = TransactionController;
 exports.default = TransactionController;
diff --git a/node_modules/@metamask/transaction-controller/dist/TransactionController.js.map b/node_modules/@metamask/transaction-controller/dist/TransactionController.js.map
deleted file mode 100644
index 73c9b24..0000000
--- a/node_modules/@metamask/transaction-controller/dist/TransactionController.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"TransactionController.js","sourceRoot":"","sources":["../src/TransactionController.ts"],"names":[],"mappings":"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","sourcesContent":["import { Hardfork, Common, type ChainConfig } from '@ethereumjs/common';\nimport type { TypedTransaction } from '@ethereumjs/tx';\nimport { TransactionFactory } from '@ethereumjs/tx';\nimport type {\n  AcceptResultCallbacks,\n  AddApprovalRequest,\n  AddResult,\n} from '@metamask/approval-controller';\nimport type {\n  BaseConfig,\n  BaseState,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport {\n  BNToHex,\n  fractionBN,\n  hexToBN,\n  safelyExecute,\n  query,\n  NetworkType,\n  RPC,\n  ApprovalType,\n  ORIGIN_METAMASK,\n  convertHexToDecimal,\n} from '@metamask/controller-utils';\nimport EthQuery from '@metamask/eth-query';\nimport type {\n  BlockTracker,\n  NetworkState,\n  Provider,\n} from '@metamask/network-controller';\nimport { Mutex } from 'async-mutex';\nimport MethodRegistry from 'eth-method-registry';\nimport { errorCodes, ethErrors } from 'eth-rpc-errors';\nimport { addHexPrefix, bufferToHex } from 'ethereumjs-util';\nimport { EventEmitter } from 'events';\nimport NonceTracker from 'nonce-tracker';\nimport { v1 as random } from 'uuid';\n\nimport { EtherscanRemoteTransactionSource } from './EtherscanRemoteTransactionSource';\nimport { IncomingTransactionHelper } from './IncomingTransactionHelper';\nimport type { Transaction, TransactionMeta, WalletDevice } from './types';\nimport { TransactionStatus } from './types';\nimport {\n  getAndFormatTransactionsForNonceTracker,\n  normalizeTransaction,\n  validateTransaction,\n  getIncreasedPriceFromExisting,\n  isEIP1559Transaction,\n  isGasPriceValue,\n  isFeeMarketEIP1559Values,\n  validateGasValues,\n  validateMinimumIncrease,\n  ESTIMATE_GAS_ERROR,\n} from './utils';\n\nexport const HARDFORK = Hardfork.London;\n\n/**\n * @type Result\n * @property result - Promise resolving to a new transaction hash\n * @property transactionMeta - Meta information about this new transaction\n */\nexport interface Result {\n  result: Promise<string>;\n  transactionMeta: TransactionMeta;\n}\n\n/**\n * @type Fetch All Options\n * @property fromBlock - String containing a specific block decimal number\n * @property etherscanApiKey - API key to be used to fetch token transactions\n */\nexport interface FetchAllOptions {\n  fromBlock?: string;\n  etherscanApiKey?: string;\n}\n\nexport interface GasPriceValue {\n  gasPrice: string;\n}\n\nexport interface FeeMarketEIP1559Values {\n  maxFeePerGas: string;\n  maxPriorityFeePerGas: string;\n}\n\n/**\n * @type TransactionConfig\n *\n * Transaction controller configuration\n * @property interval - Polling interval used to fetch new currency rate\n * @property provider - Provider used to create a new underlying EthQuery instance\n * @property sign - Method used to sign transactions\n */\nexport interface TransactionConfig extends BaseConfig {\n  interval: number;\n  sign?: (transaction: Transaction, from: string) => Promise<any>;\n  txHistoryLimit: number;\n}\n\n/**\n * @type MethodData\n *\n * Method data registry object\n * @property registryMethod - Registry method raw string\n * @property parsedRegistryMethod - Registry method object, containing name and method arguments\n */\nexport interface MethodData {\n  registryMethod: string;\n  parsedRegistryMethod: Record<string, unknown>;\n}\n\n/**\n * @type TransactionState\n *\n * Transaction controller state\n * @property transactions - A list of TransactionMeta objects\n * @property methodData - Object containing all known method data information\n */\nexport interface TransactionState extends BaseState {\n  transactions: TransactionMeta[];\n  methodData: { [key: string]: MethodData };\n}\n\n/**\n * Multiplier used to determine a transaction's increased gas fee during cancellation\n */\nexport const CANCEL_RATE = 1.5;\n\n/**\n * Multiplier used to determine a transaction's increased gas fee during speed up\n */\nexport const SPEED_UP_RATE = 1.1;\n\n/**\n * The name of the {@link TransactionController}.\n */\nconst controllerName = 'TransactionController';\n\n/**\n * The external actions available to the {@link TransactionController}.\n */\ntype AllowedActions = AddApprovalRequest;\n\n/**\n * The messenger of the {@link TransactionController}.\n */\nexport type TransactionControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  AllowedActions,\n  never,\n  AllowedActions['type'],\n  never\n>;\n\n/**\n * Controller responsible for submitting and managing transactions.\n */\nexport class TransactionController extends BaseController<\n  TransactionConfig,\n  TransactionState\n> {\n  private ethQuery: EthQuery;\n\n  private readonly nonceTracker: NonceTracker;\n\n  private registry: any;\n\n  private readonly provider: Provider;\n\n  private handle?: ReturnType<typeof setTimeout>;\n\n  private readonly mutex = new Mutex();\n\n  private readonly getNetworkState: () => NetworkState;\n\n  private readonly messagingSystem: TransactionControllerMessenger;\n\n  private readonly incomingTransactionHelper: IncomingTransactionHelper;\n\n  private failTransaction(transactionMeta: TransactionMeta, error: Error) {\n    const newTransactionMeta = {\n      ...transactionMeta,\n      error,\n      status: TransactionStatus.failed,\n    };\n    this.updateTransaction(newTransactionMeta);\n    this.hub.emit(`${transactionMeta.id}:finished`, newTransactionMeta);\n  }\n\n  private async registryLookup(fourBytePrefix: string): Promise<MethodData> {\n    const registryMethod = await this.registry.lookup(fourBytePrefix);\n    const parsedRegistryMethod = this.registry.parse(registryMethod);\n    return { registryMethod, parsedRegistryMethod };\n  }\n\n  /**\n   * EventEmitter instance used to listen to specific transactional events\n   */\n  hub = new EventEmitter();\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'TransactionController';\n\n  /**\n   * Method used to sign transactions\n   */\n  sign?: (\n    transaction: TypedTransaction,\n    from: string,\n  ) => Promise<TypedTransaction>;\n\n  /**\n   * Creates a TransactionController instance.\n   *\n   * @param options - The controller options.\n   * @param options.getNetworkState - Gets the state of the network controller.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param options.provider - The provider used to create the underlying EthQuery instance.\n   * @param options.blockTracker - The block tracker used to poll for new blocks data.\n   * @param options.messenger - The controller messenger.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      getNetworkState,\n      onNetworkStateChange,\n      provider,\n      blockTracker,\n      messenger,\n    }: {\n      getNetworkState: () => NetworkState;\n      onNetworkStateChange: (listener: (state: NetworkState) => void) => void;\n      provider: Provider;\n      blockTracker: BlockTracker;\n      messenger: TransactionControllerMessenger;\n    },\n    config?: Partial<TransactionConfig>,\n    state?: Partial<TransactionState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      interval: 15000,\n      txHistoryLimit: 40,\n    };\n\n    this.defaultState = {\n      methodData: {},\n      transactions: [],\n    };\n    this.initialize();\n    this.provider = provider;\n    this.messagingSystem = messenger;\n    this.getNetworkState = getNetworkState;\n    this.ethQuery = new EthQuery(provider);\n    this.registry = new MethodRegistry({ provider });\n    this.nonceTracker = new NonceTracker({\n      provider,\n      blockTracker,\n      getPendingTransactions: (address) =>\n        getAndFormatTransactionsForNonceTracker(\n          address,\n          TransactionStatus.submitted,\n          this.state.transactions,\n        ),\n      getConfirmedTransactions: (address) =>\n        getAndFormatTransactionsForNonceTracker(\n          address,\n          TransactionStatus.confirmed,\n          this.state.transactions,\n        ),\n    });\n    this.incomingTransactionHelper = new IncomingTransactionHelper({\n      getNetworkState,\n      getEthQuery: () => this.ethQuery,\n      transactionLimit: this.config.txHistoryLimit,\n      remoteTransactionSource: new EtherscanRemoteTransactionSource(),\n    });\n\n    onNetworkStateChange(() => {\n      this.ethQuery = new EthQuery(this.provider);\n      this.registry = new MethodRegistry({ provider: this.provider });\n    });\n    this.poll();\n  }\n\n  /**\n   * Starts a new polling interval.\n   *\n   * @param interval - The polling interval used to fetch new transaction statuses.\n   */\n  async poll(interval?: number): Promise<void> {\n    interval && this.configure({ interval }, false, false);\n    this.handle && clearTimeout(this.handle);\n    await safelyExecute(() => this.queryTransactionStatuses());\n    this.handle = setTimeout(() => {\n      this.poll(this.config.interval);\n    }, this.config.interval);\n  }\n\n  /**\n   * Handle new method data request.\n   *\n   * @param fourBytePrefix - The method prefix.\n   * @returns The method data object corresponding to the given signature prefix.\n   */\n  async handleMethodData(fourBytePrefix: string): Promise<MethodData> {\n    const releaseLock = await this.mutex.acquire();\n    try {\n      const { methodData } = this.state;\n      const knownMethod = Object.keys(methodData).find(\n        (knownFourBytePrefix) => fourBytePrefix === knownFourBytePrefix,\n      );\n      if (knownMethod) {\n        return methodData[fourBytePrefix];\n      }\n      const registry = await this.registryLookup(fourBytePrefix);\n      this.update({\n        methodData: { ...methodData, ...{ [fourBytePrefix]: registry } },\n      });\n      return registry;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Add a new unapproved transaction to state. Parameters will be validated, a\n   * unique transaction id will be generated, and gas and gasPrice will be calculated\n   * if not provided. If A `<tx.id>:unapproved` hub event will be emitted once added.\n   *\n   * @param transaction - The transaction object to add.\n   * @param origin - The domain origin to append to the generated TransactionMeta.\n   * @param deviceConfirmedOn - An enum to indicate what device the transaction was confirmed to append to the generated TransactionMeta.\n   * @returns Object containing a promise resolving to the transaction hash if approved.\n   */\n  async addTransaction(\n    transaction: Transaction,\n    origin?: string,\n    deviceConfirmedOn?: WalletDevice,\n  ): Promise<Result> {\n    const { providerConfig, networkId } = this.getNetworkState();\n    const { transactions } = this.state;\n    transaction = normalizeTransaction(transaction);\n    validateTransaction(transaction);\n\n    const transactionMeta: TransactionMeta = {\n      id: random(),\n      networkID: networkId ?? undefined,\n      chainId: providerConfig.chainId,\n      origin,\n      status: TransactionStatus.unapproved as TransactionStatus.unapproved,\n      time: Date.now(),\n      transaction,\n      deviceConfirmedOn,\n      verifiedOnBlockchain: false,\n    };\n\n    try {\n      const { gas, estimateGasError } = await this.estimateGas(transaction);\n      transaction.gas = gas;\n      transaction.estimateGasError = estimateGasError;\n    } catch (error: any) {\n      this.failTransaction(transactionMeta, error);\n      return Promise.reject(error);\n    }\n\n    transactions.push(transactionMeta);\n    this.update({ transactions: this.trimTransactionsForState(transactions) });\n    this.hub.emit(`unapprovedTransaction`, transactionMeta);\n\n    return {\n      result: this.processApproval(transactionMeta),\n      transactionMeta,\n    };\n  }\n\n  prepareUnsignedEthTx(txParams: Record<string, unknown>): TypedTransaction {\n    return TransactionFactory.fromTxData(txParams, {\n      common: this.getCommonConfiguration(),\n      freeze: false,\n    });\n  }\n\n  /**\n   * `@ethereumjs/tx` uses `@ethereumjs/common` as a configuration tool for\n   * specifying which chain, network, hardfork and EIPs to support for\n   * a transaction. By referencing this configuration, and analyzing the fields\n   * specified in txParams, @ethereumjs/tx is able to determine which EIP-2718\n   * transaction type to use.\n   *\n   * @returns {Common} common configuration object\n   */\n\n  getCommonConfiguration(): Common {\n    const {\n      networkId,\n      providerConfig: { type: chain, chainId, nickname: name },\n    } = this.getNetworkState();\n\n    if (\n      chain !== RPC &&\n      chain !== NetworkType['linea-goerli'] &&\n      chain !== NetworkType['linea-mainnet']\n    ) {\n      return new Common({ chain, hardfork: HARDFORK });\n    }\n\n    const customChainParams: Partial<ChainConfig> = {\n      name,\n      chainId: parseInt(chainId, 16),\n      networkId: networkId === null ? NaN : parseInt(networkId, undefined),\n      defaultHardfork: HARDFORK,\n    };\n\n    return Common.custom(customChainParams);\n  }\n\n  /**\n   * Attempts to cancel a transaction based on its ID by setting its status to \"rejected\"\n   * and emitting a `<tx.id>:finished` hub event.\n   *\n   * @param transactionID - The ID of the transaction to cancel.\n   * @param gasValues - The gas values to use for the cancellation transaction.\n   */\n  async stopTransaction(\n    transactionID: string,\n    gasValues?: GasPriceValue | FeeMarketEIP1559Values,\n  ) {\n    if (gasValues) {\n      validateGasValues(gasValues);\n    }\n    const transactionMeta = this.state.transactions.find(\n      ({ id }) => id === transactionID,\n    );\n    if (!transactionMeta) {\n      return;\n    }\n\n    if (!this.sign) {\n      throw new Error('No sign method defined.');\n    }\n\n    // gasPrice (legacy non EIP1559)\n    const minGasPrice = getIncreasedPriceFromExisting(\n      transactionMeta.transaction.gasPrice,\n      CANCEL_RATE,\n    );\n\n    const gasPriceFromValues = isGasPriceValue(gasValues) && gasValues.gasPrice;\n\n    const newGasPrice =\n      (gasPriceFromValues &&\n        validateMinimumIncrease(gasPriceFromValues, minGasPrice)) ||\n      minGasPrice;\n\n    // maxFeePerGas (EIP1559)\n    const existingMaxFeePerGas = transactionMeta.transaction?.maxFeePerGas;\n    const minMaxFeePerGas = getIncreasedPriceFromExisting(\n      existingMaxFeePerGas,\n      CANCEL_RATE,\n    );\n    const maxFeePerGasValues =\n      isFeeMarketEIP1559Values(gasValues) && gasValues.maxFeePerGas;\n    const newMaxFeePerGas =\n      (maxFeePerGasValues &&\n        validateMinimumIncrease(maxFeePerGasValues, minMaxFeePerGas)) ||\n      (existingMaxFeePerGas && minMaxFeePerGas);\n\n    // maxPriorityFeePerGas (EIP1559)\n    const existingMaxPriorityFeePerGas =\n      transactionMeta.transaction?.maxPriorityFeePerGas;\n    const minMaxPriorityFeePerGas = getIncreasedPriceFromExisting(\n      existingMaxPriorityFeePerGas,\n      CANCEL_RATE,\n    );\n    const maxPriorityFeePerGasValues =\n      isFeeMarketEIP1559Values(gasValues) && gasValues.maxPriorityFeePerGas;\n    const newMaxPriorityFeePerGas =\n      (maxPriorityFeePerGasValues &&\n        validateMinimumIncrease(\n          maxPriorityFeePerGasValues,\n          minMaxPriorityFeePerGas,\n        )) ||\n      (existingMaxPriorityFeePerGas && minMaxPriorityFeePerGas);\n\n    const txParams =\n      newMaxFeePerGas && newMaxPriorityFeePerGas\n        ? {\n            from: transactionMeta.transaction.from,\n            gasLimit: transactionMeta.transaction.gas,\n            maxFeePerGas: newMaxFeePerGas,\n            maxPriorityFeePerGas: newMaxPriorityFeePerGas,\n            type: 2,\n            nonce: transactionMeta.transaction.nonce,\n            to: transactionMeta.transaction.from,\n            value: '0x0',\n          }\n        : {\n            from: transactionMeta.transaction.from,\n            gasLimit: transactionMeta.transaction.gas,\n            gasPrice: newGasPrice,\n            nonce: transactionMeta.transaction.nonce,\n            to: transactionMeta.transaction.from,\n            value: '0x0',\n          };\n\n    const unsignedEthTx = this.prepareUnsignedEthTx(txParams);\n\n    const signedTx = await this.sign(\n      unsignedEthTx,\n      transactionMeta.transaction.from,\n    );\n    const rawTransaction = bufferToHex(signedTx.serialize());\n    await query(this.ethQuery, 'sendRawTransaction', [rawTransaction]);\n    transactionMeta.status = TransactionStatus.cancelled;\n    this.hub.emit(`${transactionMeta.id}:finished`, transactionMeta);\n  }\n\n  /**\n   * Attempts to speed up a transaction increasing transaction gasPrice by ten percent.\n   *\n   * @param transactionID - The ID of the transaction to speed up.\n   * @param gasValues - The gas values to use for the speed up transation.\n   */\n  async speedUpTransaction(\n    transactionID: string,\n    gasValues?: GasPriceValue | FeeMarketEIP1559Values,\n  ) {\n    if (gasValues) {\n      validateGasValues(gasValues);\n    }\n    const transactionMeta = this.state.transactions.find(\n      ({ id }) => id === transactionID,\n    );\n    /* istanbul ignore next */\n    if (!transactionMeta) {\n      return;\n    }\n\n    /* istanbul ignore next */\n    if (!this.sign) {\n      throw new Error('No sign method defined.');\n    }\n\n    const { transactions } = this.state;\n\n    // gasPrice (legacy non EIP1559)\n    const minGasPrice = getIncreasedPriceFromExisting(\n      transactionMeta.transaction.gasPrice,\n      SPEED_UP_RATE,\n    );\n\n    const gasPriceFromValues = isGasPriceValue(gasValues) && gasValues.gasPrice;\n\n    const newGasPrice =\n      (gasPriceFromValues &&\n        validateMinimumIncrease(gasPriceFromValues, minGasPrice)) ||\n      minGasPrice;\n\n    // maxFeePerGas (EIP1559)\n    const existingMaxFeePerGas = transactionMeta.transaction?.maxFeePerGas;\n    const minMaxFeePerGas = getIncreasedPriceFromExisting(\n      existingMaxFeePerGas,\n      SPEED_UP_RATE,\n    );\n    const maxFeePerGasValues =\n      isFeeMarketEIP1559Values(gasValues) && gasValues.maxFeePerGas;\n    const newMaxFeePerGas =\n      (maxFeePerGasValues &&\n        validateMinimumIncrease(maxFeePerGasValues, minMaxFeePerGas)) ||\n      (existingMaxFeePerGas && minMaxFeePerGas);\n\n    // maxPriorityFeePerGas (EIP1559)\n    const existingMaxPriorityFeePerGas =\n      transactionMeta.transaction?.maxPriorityFeePerGas;\n    const minMaxPriorityFeePerGas = getIncreasedPriceFromExisting(\n      existingMaxPriorityFeePerGas,\n      SPEED_UP_RATE,\n    );\n    const maxPriorityFeePerGasValues =\n      isFeeMarketEIP1559Values(gasValues) && gasValues.maxPriorityFeePerGas;\n    const newMaxPriorityFeePerGas =\n      (maxPriorityFeePerGasValues &&\n        validateMinimumIncrease(\n          maxPriorityFeePerGasValues,\n          minMaxPriorityFeePerGas,\n        )) ||\n      (existingMaxPriorityFeePerGas && minMaxPriorityFeePerGas);\n\n    const txParams =\n      newMaxFeePerGas && newMaxPriorityFeePerGas\n        ? {\n            ...transactionMeta.transaction,\n            gasLimit: transactionMeta.transaction.gas,\n            maxFeePerGas: newMaxFeePerGas,\n            maxPriorityFeePerGas: newMaxPriorityFeePerGas,\n            type: 2,\n          }\n        : {\n            ...transactionMeta.transaction,\n            gasLimit: transactionMeta.transaction.gas,\n            gasPrice: newGasPrice,\n          };\n\n    const unsignedEthTx = this.prepareUnsignedEthTx(txParams);\n\n    const signedTx = await this.sign(\n      unsignedEthTx,\n      transactionMeta.transaction.from,\n    );\n    const rawTransaction = bufferToHex(signedTx.serialize());\n    const transactionHash = await query(this.ethQuery, 'sendRawTransaction', [\n      rawTransaction,\n    ]);\n    const baseTransactionMeta = {\n      ...transactionMeta,\n      id: random(),\n      time: Date.now(),\n      transactionHash,\n    };\n    const newTransactionMeta =\n      newMaxFeePerGas && newMaxPriorityFeePerGas\n        ? {\n            ...baseTransactionMeta,\n            transaction: {\n              ...transactionMeta.transaction,\n              maxFeePerGas: newMaxFeePerGas,\n              maxPriorityFeePerGas: newMaxPriorityFeePerGas,\n            },\n          }\n        : {\n            ...baseTransactionMeta,\n            transaction: {\n              ...transactionMeta.transaction,\n              gasPrice: newGasPrice,\n            },\n          };\n    transactions.push(newTransactionMeta);\n    this.update({ transactions: this.trimTransactionsForState(transactions) });\n    this.hub.emit(`${transactionMeta.id}:speedup`, newTransactionMeta);\n  }\n\n  /**\n   * Estimates required gas for a given transaction.\n   *\n   * @param transaction - The transaction to estimate gas for.\n   * @returns The gas and gas price.\n   */\n  async estimateGas(transaction: Transaction) {\n    const estimatedTransaction = { ...transaction };\n    const {\n      gas,\n      gasPrice: providedGasPrice,\n      to,\n      value,\n      data,\n    } = estimatedTransaction;\n    const gasPrice =\n      typeof providedGasPrice === 'undefined'\n        ? await query(this.ethQuery, 'gasPrice')\n        : providedGasPrice;\n    const { providerConfig } = this.getNetworkState();\n    const isCustomNetwork = providerConfig.type === NetworkType.rpc;\n    // 1. If gas is already defined on the transaction, use it\n    if (typeof gas !== 'undefined') {\n      return { gas, gasPrice };\n    }\n    const { gasLimit } = await query(this.ethQuery, 'getBlockByNumber', [\n      'latest',\n      false,\n    ]);\n\n    // 2. If to is not defined or this is not a contract address, and there is no data use 0x5208 / 21000.\n    // If the newtwork is a custom network then bypass this check and fetch 'estimateGas'.\n    /* istanbul ignore next */\n    const code = to ? await query(this.ethQuery, 'getCode', [to]) : undefined;\n    /* istanbul ignore next */\n    if (\n      !isCustomNetwork &&\n      (!to || (to && !data && (!code || code === '0x')))\n    ) {\n      return { gas: '0x5208', gasPrice };\n    }\n\n    // if data, should be hex string format\n    estimatedTransaction.data = !data\n      ? data\n      : /* istanbul ignore next */ addHexPrefix(data);\n\n    // 3. If this is a contract address, safely estimate gas using RPC\n    estimatedTransaction.value =\n      typeof value === 'undefined' ? '0x0' : /* istanbul ignore next */ value;\n    const gasLimitBN = hexToBN(gasLimit);\n    estimatedTransaction.gas = BNToHex(fractionBN(gasLimitBN, 19, 20));\n\n    let gasHex;\n    let estimateGasError;\n    try {\n      gasHex = await query(this.ethQuery, 'estimateGas', [\n        estimatedTransaction,\n      ]);\n    } catch (error) {\n      estimateGasError = ESTIMATE_GAS_ERROR;\n    }\n    // 4. Pad estimated gas without exceeding the most recent block gasLimit. If the network is a\n    // a custom network then return the eth_estimateGas value.\n    const gasBN = hexToBN(gasHex);\n    const maxGasBN = gasLimitBN.muln(0.9);\n    const paddedGasBN = gasBN.muln(1.5);\n    /* istanbul ignore next */\n    if (gasBN.gt(maxGasBN) || isCustomNetwork) {\n      return { gas: addHexPrefix(gasHex), gasPrice, estimateGasError };\n    }\n\n    /* istanbul ignore next */\n    if (paddedGasBN.lt(maxGasBN)) {\n      return {\n        gas: addHexPrefix(BNToHex(paddedGasBN)),\n        gasPrice,\n        estimateGasError,\n      };\n    }\n    return { gas: addHexPrefix(BNToHex(maxGasBN)), gasPrice, estimateGasError };\n  }\n\n  /**\n   * Check the status of submitted transactions on the network to determine whether they have\n   * been included in a block. Any that have been included in a block are marked as confirmed.\n   */\n  async queryTransactionStatuses() {\n    const { transactions } = this.state;\n    const { providerConfig, networkId: currentNetworkID } =\n      this.getNetworkState();\n    const { chainId: currentChainId } = providerConfig;\n    let gotUpdates = false;\n    await safelyExecute(() =>\n      Promise.all(\n        transactions.map(async (meta, index) => {\n          // Using fallback to networkID only when there is no chainId present.\n          // Should be removed when networkID is completely removed.\n          const txBelongsToCurrentChain =\n            meta.chainId === currentChainId ||\n            (!meta.chainId && meta.networkID === currentNetworkID);\n\n          if (!meta.verifiedOnBlockchain && txBelongsToCurrentChain) {\n            const [reconciledTx, updateRequired] =\n              await this.blockchainTransactionStateReconciler(meta);\n            if (updateRequired) {\n              transactions[index] = reconciledTx;\n              gotUpdates = updateRequired;\n            }\n          }\n        }),\n      ),\n    );\n\n    /* istanbul ignore else */\n    if (gotUpdates) {\n      this.update({\n        transactions: this.trimTransactionsForState(transactions),\n      });\n    }\n  }\n\n  /**\n   * Updates an existing transaction in state.\n   *\n   * @param transactionMeta - The new transaction to store in state.\n   */\n  updateTransaction(transactionMeta: TransactionMeta) {\n    const { transactions } = this.state;\n    transactionMeta.transaction = normalizeTransaction(\n      transactionMeta.transaction,\n    );\n    validateTransaction(transactionMeta.transaction);\n    const index = transactions.findIndex(({ id }) => transactionMeta.id === id);\n    transactions[index] = transactionMeta;\n    this.update({ transactions: this.trimTransactionsForState(transactions) });\n  }\n\n  /**\n   * Removes all transactions from state, optionally based on the current network.\n   *\n   * @param ignoreNetwork - Determines whether to wipe all transactions, or just those on the\n   * current network. If `true`, all transactions are wiped.\n   */\n  wipeTransactions(ignoreNetwork?: boolean) {\n    /* istanbul ignore next */\n    if (ignoreNetwork) {\n      this.update({ transactions: [] });\n      return;\n    }\n    const { providerConfig, networkId: currentNetworkID } =\n      this.getNetworkState();\n    const { chainId: currentChainId } = providerConfig;\n    const newTransactions = this.state.transactions.filter(\n      ({ networkID, chainId }) => {\n        // Using fallback to networkID only when there is no chainId present. Should be removed when networkID is completely removed.\n        const isCurrentNetwork =\n          chainId === currentChainId ||\n          (!chainId && networkID === currentNetworkID);\n        return !isCurrentNetwork;\n      },\n    );\n\n    this.update({\n      transactions: this.trimTransactionsForState(newTransactions),\n    });\n  }\n\n  /**\n   * Get transactions from Etherscan for the given address. By default all transactions are\n   * returned, but the `fromBlock` option can be given to filter just for transactions from a\n   * specific block onward.\n   *\n   * @param address - The address to fetch the transactions for.\n   * @param opt - Object containing optional data, fromBlock and Etherscan API key.\n   * @returns The block number of the latest incoming transaction.\n   */\n  async fetchAll(\n    address: string,\n    opt?: FetchAllOptions,\n  ): Promise<string | void> {\n    const { transactions: localTransactions } = this.state;\n\n    const { updateRequired, transactions, latestBlockNumber } =\n      await this.incomingTransactionHelper.reconcile({\n        address,\n        localTransactions,\n        fromBlock: opt?.fromBlock,\n        apiKey: opt?.etherscanApiKey,\n      });\n\n    if (updateRequired) {\n      this.update({\n        transactions: this.trimTransactionsForState(transactions),\n      });\n    }\n\n    return latestBlockNumber;\n  }\n\n  private async processApproval(\n    transactionMeta: TransactionMeta,\n  ): Promise<string> {\n    const transactionId = transactionMeta.id;\n    let resultCallbacks: AcceptResultCallbacks | undefined;\n\n    try {\n      const acceptResult = await this.requestApproval(transactionMeta);\n      resultCallbacks = acceptResult.resultCallbacks;\n\n      const { meta, isCompleted } = this.isTransactionCompleted(transactionId);\n\n      if (meta && !isCompleted) {\n        await this.approveTransaction(transactionId);\n      }\n    } catch (error: any) {\n      const { meta, isCompleted } = this.isTransactionCompleted(transactionId);\n\n      if (meta && !isCompleted) {\n        if (error.code === errorCodes.provider.userRejectedRequest) {\n          this.cancelTransaction(transactionId);\n\n          throw ethErrors.provider.userRejectedRequest(\n            'User rejected the transaction',\n          );\n        } else {\n          this.failTransaction(meta, error);\n        }\n      }\n    }\n\n    const finalMeta = this.getTransaction(transactionId);\n\n    switch (finalMeta?.status) {\n      case TransactionStatus.failed:\n        resultCallbacks?.error(finalMeta.error);\n        throw ethErrors.rpc.internal(finalMeta.error.message);\n\n      case TransactionStatus.cancelled:\n        const cancelError = ethErrors.rpc.internal(\n          'User cancelled the transaction',\n        );\n\n        resultCallbacks?.error(cancelError);\n        throw cancelError;\n\n      case TransactionStatus.submitted:\n        resultCallbacks?.success();\n        return finalMeta.transactionHash as string;\n\n      default:\n        const internalError = ethErrors.rpc.internal(\n          `MetaMask Tx Signature: Unknown problem: ${JSON.stringify(\n            finalMeta || transactionId,\n          )}`,\n        );\n\n        resultCallbacks?.error(internalError);\n        throw internalError;\n    }\n  }\n\n  /**\n   * Approves a transaction and updates it's status in state. If this is not a\n   * retry transaction, a nonce will be generated. The transaction is signed\n   * using the sign configuration property, then published to the blockchain.\n   * A `<tx.id>:finished` hub event is fired after success or failure.\n   *\n   * @param transactionID - The ID of the transaction to approve.\n   */\n  private async approveTransaction(transactionID: string) {\n    const { transactions } = this.state;\n    const releaseLock = await this.mutex.acquire();\n    const { providerConfig } = this.getNetworkState();\n    const { chainId } = providerConfig;\n    const index = transactions.findIndex(({ id }) => transactionID === id);\n    const transactionMeta = transactions[index];\n    const {\n      transaction: { nonce, from },\n    } = transactionMeta;\n    let nonceLock;\n    try {\n      if (!this.sign) {\n        releaseLock();\n        this.failTransaction(\n          transactionMeta,\n          new Error('No sign method defined.'),\n        );\n        return;\n      } else if (!chainId) {\n        releaseLock();\n        this.failTransaction(transactionMeta, new Error('No chainId defined.'));\n        return;\n      }\n\n      const { approved: status } = TransactionStatus;\n      let nonceToUse = nonce;\n      // if a nonce already exists on the transactionMeta it means this is a speedup or cancel transaction\n      // so we want to reuse that nonce and hope that it beats the previous attempt to chain. Otherwise use a new locked nonce\n      if (!nonceToUse) {\n        nonceLock = await this.nonceTracker.getNonceLock(from);\n        nonceToUse = addHexPrefix(nonceLock.nextNonce.toString(16));\n      }\n\n      transactionMeta.status = status;\n      transactionMeta.transaction.nonce = nonceToUse;\n      transactionMeta.transaction.chainId = chainId;\n\n      const baseTxParams = {\n        ...transactionMeta.transaction,\n        gasLimit: transactionMeta.transaction.gas,\n      };\n\n      const isEIP1559 = isEIP1559Transaction(transactionMeta.transaction);\n\n      const txParams = isEIP1559\n        ? {\n            ...baseTxParams,\n            maxFeePerGas: transactionMeta.transaction.maxFeePerGas,\n            maxPriorityFeePerGas:\n              transactionMeta.transaction.maxPriorityFeePerGas,\n            estimatedBaseFee: transactionMeta.transaction.estimatedBaseFee,\n            // specify type 2 if maxFeePerGas and maxPriorityFeePerGas are set\n            type: 2,\n          }\n        : baseTxParams;\n\n      // delete gasPrice if maxFeePerGas and maxPriorityFeePerGas are set\n      if (isEIP1559) {\n        delete txParams.gasPrice;\n      }\n\n      const unsignedEthTx = this.prepareUnsignedEthTx(txParams);\n      const signedTx = await this.sign(unsignedEthTx, from);\n      transactionMeta.status = TransactionStatus.signed;\n      this.updateTransaction(transactionMeta);\n      const rawTransaction = bufferToHex(signedTx.serialize());\n\n      transactionMeta.rawTransaction = rawTransaction;\n      this.updateTransaction(transactionMeta);\n      const transactionHash = await query(this.ethQuery, 'sendRawTransaction', [\n        rawTransaction,\n      ]);\n      transactionMeta.transactionHash = transactionHash;\n      transactionMeta.status = TransactionStatus.submitted;\n      this.updateTransaction(transactionMeta);\n      this.hub.emit(`${transactionMeta.id}:finished`, transactionMeta);\n    } catch (error: any) {\n      this.failTransaction(transactionMeta, error);\n    } finally {\n      // must set transaction to submitted/failed before releasing lock\n      if (nonceLock) {\n        nonceLock.releaseLock();\n      }\n      releaseLock();\n    }\n  }\n\n  /**\n   * Cancels a transaction based on its ID by setting its status to \"rejected\"\n   * and emitting a `<tx.id>:finished` hub event.\n   *\n   * @param transactionID - The ID of the transaction to cancel.\n   */\n  private cancelTransaction(transactionID: string) {\n    const transactionMeta = this.state.transactions.find(\n      ({ id }) => id === transactionID,\n    );\n    if (!transactionMeta) {\n      return;\n    }\n    transactionMeta.status = TransactionStatus.rejected;\n    this.hub.emit(`${transactionMeta.id}:finished`, transactionMeta);\n    const transactions = this.state.transactions.filter(\n      ({ id }) => id !== transactionID,\n    );\n    this.update({ transactions: this.trimTransactionsForState(transactions) });\n  }\n\n  /**\n   * Trim the amount of transactions that are set on the state. Checks\n   * if the length of the tx history is longer then desired persistence\n   * limit and then if it is removes the oldest confirmed or rejected tx.\n   * Pending or unapproved transactions will not be removed by this\n   * operation. For safety of presenting a fully functional transaction UI\n   * representation, this function will not break apart transactions with the\n   * same nonce, created on the same day, per network. Not accounting for transactions of the same\n   * nonce, same day and network combo can result in confusing or broken experiences\n   * in the UI. The transactions are then updated using the BaseController update.\n   *\n   * @param transactions - The transactions to be applied to the state.\n   * @returns The trimmed list of transactions.\n   */\n  private trimTransactionsForState(\n    transactions: TransactionMeta[],\n  ): TransactionMeta[] {\n    const nonceNetworkSet = new Set();\n    const txsToKeep = transactions.reverse().filter((tx) => {\n      const { chainId, networkID, status, transaction, time } = tx;\n      if (transaction) {\n        const key = `${transaction.nonce}-${\n          chainId ? convertHexToDecimal(chainId) : networkID\n        }-${new Date(time).toDateString()}`;\n        if (nonceNetworkSet.has(key)) {\n          return true;\n        } else if (\n          nonceNetworkSet.size < this.config.txHistoryLimit ||\n          !this.isFinalState(status)\n        ) {\n          nonceNetworkSet.add(key);\n          return true;\n        }\n      }\n      return false;\n    });\n    txsToKeep.reverse();\n    return txsToKeep;\n  }\n\n  /**\n   * Determines if the transaction is in a final state.\n   *\n   * @param status - The transaction status.\n   * @returns Whether the transaction is in a final state.\n   */\n  private isFinalState(status: TransactionStatus): boolean {\n    return (\n      status === TransactionStatus.rejected ||\n      status === TransactionStatus.confirmed ||\n      status === TransactionStatus.failed ||\n      status === TransactionStatus.cancelled\n    );\n  }\n\n  /**\n   * Whether the transaction has at least completed all local processing.\n   *\n   * @param status - The transaction status.\n   * @returns Whether the transaction is in a final state.\n   */\n  private isLocalFinalState(status: TransactionStatus): boolean {\n    return [\n      TransactionStatus.cancelled,\n      TransactionStatus.confirmed,\n      TransactionStatus.failed,\n      TransactionStatus.rejected,\n      TransactionStatus.submitted,\n    ].includes(status);\n  }\n\n  /**\n   * Method to verify the state of a transaction using the Blockchain as a source of truth.\n   *\n   * @param meta - The local transaction to verify on the blockchain.\n   * @returns A tuple containing the updated transaction, and whether or not an update was required.\n   */\n  private async blockchainTransactionStateReconciler(\n    meta: TransactionMeta,\n  ): Promise<[TransactionMeta, boolean]> {\n    const { status, transactionHash } = meta;\n    switch (status) {\n      case TransactionStatus.confirmed:\n        const txReceipt = await query(this.ethQuery, 'getTransactionReceipt', [\n          transactionHash,\n        ]);\n\n        if (!txReceipt) {\n          return [meta, false];\n        }\n\n        meta.verifiedOnBlockchain = true;\n        meta.transaction.gasUsed = txReceipt.gasUsed;\n\n        // According to the Web3 docs:\n        // TRUE if the transaction was successful, FALSE if the EVM reverted the transaction.\n        if (Number(txReceipt.status) === 0) {\n          const error: Error = new Error(\n            'Transaction failed. The transaction was reversed',\n          );\n          this.failTransaction(meta, error);\n          return [meta, false];\n        }\n\n        return [meta, true];\n      case TransactionStatus.submitted:\n        const txObj = await query(this.ethQuery, 'getTransactionByHash', [\n          transactionHash,\n        ]);\n\n        if (!txObj) {\n          const receiptShowsFailedStatus =\n            await this.checkTxReceiptStatusIsFailed(transactionHash);\n\n          // Case the txObj is evaluated as false, a second check will\n          // determine if the tx failed or it is pending or confirmed\n          if (receiptShowsFailedStatus) {\n            const error: Error = new Error(\n              'Transaction failed. The transaction was dropped or replaced by a new one',\n            );\n            this.failTransaction(meta, error);\n          }\n        }\n\n        /* istanbul ignore next */\n        if (txObj?.blockNumber) {\n          meta.status = TransactionStatus.confirmed;\n          this.hub.emit(`${meta.id}:confirmed`, meta);\n          return [meta, true];\n        }\n\n        return [meta, false];\n      default:\n        return [meta, false];\n    }\n  }\n\n  /**\n   * Method to check if a tx has failed according to their receipt\n   * According to the Web3 docs:\n   * TRUE if the transaction was successful, FALSE if the EVM reverted the transaction.\n   * The receipt is not available for pending transactions and returns null.\n   *\n   * @param txHash - The transaction hash.\n   * @returns Whether the transaction has failed.\n   */\n  private async checkTxReceiptStatusIsFailed(\n    txHash: string | undefined,\n  ): Promise<boolean> {\n    const txReceipt = await query(this.ethQuery, 'getTransactionReceipt', [\n      txHash,\n    ]);\n    if (!txReceipt) {\n      // Transaction is pending\n      return false;\n    }\n    return Number(txReceipt.status) === 0;\n  }\n\n  private async requestApproval(txMeta: TransactionMeta): Promise<AddResult> {\n    const id = this.getApprovalId(txMeta);\n    const { origin } = txMeta;\n    const type = ApprovalType.Transaction;\n    const requestData = { txId: txMeta.id };\n\n    return (await this.messagingSystem.call(\n      'ApprovalController:addRequest',\n      {\n        id,\n        origin: origin || ORIGIN_METAMASK,\n        type,\n        requestData,\n        expectsResult: true,\n      },\n      true,\n    )) as Promise<AddResult>;\n  }\n\n  private getTransaction(transactionID: string): TransactionMeta | undefined {\n    const { transactions } = this.state;\n    return transactions.find(({ id }) => id === transactionID);\n  }\n\n  private getApprovalId(txMeta: TransactionMeta) {\n    return String(txMeta.id);\n  }\n\n  private isTransactionCompleted(transactionid: string): {\n    meta?: TransactionMeta;\n    isCompleted: boolean;\n  } {\n    const transaction = this.getTransaction(transactionid);\n\n    if (!transaction) {\n      return { meta: undefined, isCompleted: false };\n    }\n\n    const isCompleted = this.isLocalFinalState(transaction.status);\n\n    return { meta: transaction, isCompleted };\n  }\n}\n\nexport default TransactionController;\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/constants.d.ts b/node_modules/@metamask/transaction-controller/dist/constants.d.ts
new file mode 100644
index 0000000..3c28714
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/constants.d.ts
@@ -0,0 +1,127 @@
+export declare const CHAIN_IDS: {
+    readonly MAINNET: "0x1";
+    readonly GOERLI: "0x5";
+    readonly BSC: "0x38";
+    readonly BSC_TESTNET: "0x61";
+    readonly OPTIMISM: "0xa";
+    readonly OPTIMISM_SEPOLIA: "0xaa37dc";
+    readonly POLYGON: "0x89";
+    readonly POLYGON_TESTNET: "0x13881";
+    readonly AVALANCHE: "0xa86a";
+    readonly AVALANCHE_TESTNET: "0xa869";
+    readonly FANTOM: "0xfa";
+    readonly FANTOM_TESTNET: "0xfa2";
+    readonly SEPOLIA: "0xaa36a7";
+    readonly LINEA_GOERLI: "0xe704";
+    readonly LINEA_MAINNET: "0xe708";
+    readonly MOONBEAM: "0x504";
+    readonly MOONBEAM_TESTNET: "0x507";
+    readonly MOONRIVER: "0x505";
+    readonly GNOSIS: "0x64";
+    readonly ARBITRUM: "0xa4b1";
+    readonly ZKSYNC_ERA: "0x144";
+    readonly LINEA_SEPOLIA: "0xe705";
+};
+export declare const ETHERSCAN_SUPPORTED_NETWORKS: {
+    "0x5": {
+        domain: string;
+        subdomain: string;
+        networkId: string;
+    };
+    "0x1": {
+        domain: string;
+        subdomain: string;
+        networkId: string;
+    };
+    "0xaa36a7": {
+        domain: string;
+        subdomain: string;
+        networkId: string;
+    };
+    "0xe704": {
+        domain: string;
+        subdomain: string;
+        networkId: string;
+    };
+    "0xe708": {
+        domain: string;
+        subdomain: string;
+        networkId: string;
+    };
+    "0x38": {
+        domain: string;
+        subdomain: string;
+        networkId: string;
+    };
+    "0x61": {
+        domain: string;
+        subdomain: string;
+        networkId: string;
+    };
+    "0xa": {
+        domain: string;
+        subdomain: string;
+        networkId: string;
+    };
+    "0xaa37dc": {
+        domain: string;
+        subdomain: string;
+        networkId: string;
+    };
+    "0x89": {
+        domain: string;
+        subdomain: string;
+        networkId: string;
+    };
+    "0x13881": {
+        domain: string;
+        subdomain: string;
+        networkId: string;
+    };
+    "0xa86a": {
+        domain: string;
+        subdomain: string;
+        networkId: string;
+    };
+    "0xa869": {
+        domain: string;
+        subdomain: string;
+        networkId: string;
+    };
+    "0xfa": {
+        domain: string;
+        subdomain: string;
+        networkId: string;
+    };
+    "0xfa2": {
+        domain: string;
+        subdomain: string;
+        networkId: string;
+    };
+    "0x504": {
+        domain: string;
+        subdomain: string;
+        networkId: string;
+    };
+    "0x507": {
+        domain: string;
+        subdomain: string;
+        networkId: string;
+    };
+    "0x505": {
+        domain: string;
+        subdomain: string;
+        networkId: string;
+    };
+    "0xe705": {
+        domain: string;
+        subdomain: string;
+        networkId: string;
+    };
+    "0x64": {
+        domain: string;
+        subdomain: string;
+        networkId: string;
+    };
+};
+//# sourceMappingURL=constants.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/constants.js b/node_modules/@metamask/transaction-controller/dist/constants.js
new file mode 100644
index 0000000..062d0f3
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/constants.js
@@ -0,0 +1,132 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.ETHERSCAN_SUPPORTED_NETWORKS = exports.CHAIN_IDS = void 0;
+exports.CHAIN_IDS = {
+    MAINNET: '0x1',
+    GOERLI: '0x5',
+    BSC: '0x38',
+    BSC_TESTNET: '0x61',
+    OPTIMISM: '0xa',
+    OPTIMISM_SEPOLIA: '0xaa37dc',
+    POLYGON: '0x89',
+    POLYGON_TESTNET: '0x13881',
+    AVALANCHE: '0xa86a',
+    AVALANCHE_TESTNET: '0xa869',
+    FANTOM: '0xfa',
+    FANTOM_TESTNET: '0xfa2',
+    SEPOLIA: '0xaa36a7',
+    LINEA_GOERLI: '0xe704',
+    LINEA_MAINNET: '0xe708',
+    MOONBEAM: '0x504',
+    MOONBEAM_TESTNET: '0x507',
+    MOONRIVER: '0x505',
+    GNOSIS: '0x64',
+    ARBITRUM: '0xa4b1',
+    ZKSYNC_ERA: '0x144',
+    LINEA_SEPOLIA: '0xe705',
+};
+const DEFAULT_ETHERSCAN_DOMAIN = 'etherscan.io';
+const DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX = 'api';
+exports.ETHERSCAN_SUPPORTED_NETWORKS = {
+    [exports.CHAIN_IDS.GOERLI]: {
+        domain: DEFAULT_ETHERSCAN_DOMAIN,
+        subdomain: `${DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX}-goerli`,
+        networkId: parseInt(exports.CHAIN_IDS.GOERLI, 16).toString(),
+    },
+    [exports.CHAIN_IDS.MAINNET]: {
+        domain: DEFAULT_ETHERSCAN_DOMAIN,
+        subdomain: DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX,
+        networkId: parseInt(exports.CHAIN_IDS.MAINNET, 16).toString(),
+    },
+    [exports.CHAIN_IDS.SEPOLIA]: {
+        domain: DEFAULT_ETHERSCAN_DOMAIN,
+        subdomain: `${DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX}-sepolia`,
+        networkId: parseInt(exports.CHAIN_IDS.SEPOLIA, 16).toString(),
+    },
+    [exports.CHAIN_IDS.LINEA_GOERLI]: {
+        domain: 'lineascan.build',
+        subdomain: 'goerli',
+        networkId: parseInt(exports.CHAIN_IDS.LINEA_GOERLI, 16).toString(),
+    },
+    [exports.CHAIN_IDS.LINEA_MAINNET]: {
+        domain: 'lineascan.build',
+        subdomain: DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX,
+        networkId: parseInt(exports.CHAIN_IDS.LINEA_MAINNET, 16).toString(),
+    },
+    [exports.CHAIN_IDS.BSC]: {
+        domain: 'bscscan.com',
+        subdomain: DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX,
+        networkId: parseInt(exports.CHAIN_IDS.BSC, 16).toString(),
+    },
+    [exports.CHAIN_IDS.BSC_TESTNET]: {
+        domain: 'bscscan.com',
+        subdomain: `${DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX}-testnet`,
+        networkId: parseInt(exports.CHAIN_IDS.BSC_TESTNET, 16).toString(),
+    },
+    [exports.CHAIN_IDS.OPTIMISM]: {
+        domain: DEFAULT_ETHERSCAN_DOMAIN,
+        subdomain: `${DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX}-optimistic`,
+        networkId: parseInt(exports.CHAIN_IDS.OPTIMISM, 16).toString(),
+    },
+    [exports.CHAIN_IDS.OPTIMISM_SEPOLIA]: {
+        domain: DEFAULT_ETHERSCAN_DOMAIN,
+        subdomain: `${DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX}-sepolia-optimistic`,
+        networkId: parseInt(exports.CHAIN_IDS.OPTIMISM_SEPOLIA, 16).toString(),
+    },
+    [exports.CHAIN_IDS.POLYGON]: {
+        domain: 'polygonscan.com',
+        subdomain: DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX,
+        networkId: parseInt(exports.CHAIN_IDS.POLYGON, 16).toString(),
+    },
+    [exports.CHAIN_IDS.POLYGON_TESTNET]: {
+        domain: 'polygonscan.com',
+        subdomain: `${DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX}-mumbai`,
+        networkId: parseInt(exports.CHAIN_IDS.POLYGON_TESTNET, 16).toString(),
+    },
+    [exports.CHAIN_IDS.AVALANCHE]: {
+        domain: 'snowtrace.io',
+        subdomain: DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX,
+        networkId: parseInt(exports.CHAIN_IDS.AVALANCHE, 16).toString(),
+    },
+    [exports.CHAIN_IDS.AVALANCHE_TESTNET]: {
+        domain: 'snowtrace.io',
+        subdomain: `${DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX}-testnet`,
+        networkId: parseInt(exports.CHAIN_IDS.AVALANCHE_TESTNET, 16).toString(),
+    },
+    [exports.CHAIN_IDS.FANTOM]: {
+        domain: 'ftmscan.com',
+        subdomain: DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX,
+        networkId: parseInt(exports.CHAIN_IDS.FANTOM, 16).toString(),
+    },
+    [exports.CHAIN_IDS.FANTOM_TESTNET]: {
+        domain: 'ftmscan.com',
+        subdomain: `${DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX}-testnet`,
+        networkId: parseInt(exports.CHAIN_IDS.FANTOM_TESTNET, 16).toString(),
+    },
+    [exports.CHAIN_IDS.MOONBEAM]: {
+        domain: 'moonscan.io',
+        subdomain: `${DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX}-moonbeam`,
+        networkId: parseInt(exports.CHAIN_IDS.MOONBEAM, 16).toString(),
+    },
+    [exports.CHAIN_IDS.MOONBEAM_TESTNET]: {
+        domain: 'moonscan.io',
+        subdomain: `${DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX}-moonbase`,
+        networkId: parseInt(exports.CHAIN_IDS.MOONBEAM_TESTNET, 16).toString(),
+    },
+    [exports.CHAIN_IDS.MOONRIVER]: {
+        domain: 'moonscan.io',
+        subdomain: `${DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX}-moonriver`,
+        networkId: parseInt(exports.CHAIN_IDS.MOONRIVER, 16).toString(),
+    },
+    [exports.CHAIN_IDS.LINEA_SEPOLIA]: {
+        domain: 'lineascan.build',
+        subdomain: 'sepolia',
+        networkId: parseInt(exports.CHAIN_IDS.LINEA_SEPOLIA, 16).toString(),
+    },
+    [exports.CHAIN_IDS.GNOSIS]: {
+        domain: 'gnosisscan.io',
+        subdomain: `${DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX}-gnosis`,
+        networkId: parseInt(exports.CHAIN_IDS.GNOSIS, 16).toString(),
+    },
+};
+//# sourceMappingURL=constants.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/etherscan.d.ts b/node_modules/@metamask/transaction-controller/dist/etherscan.d.ts
index 3605f99..a49d68f 100644
--- a/node_modules/@metamask/transaction-controller/dist/etherscan.d.ts
+++ b/node_modules/@metamask/transaction-controller/dist/etherscan.d.ts
@@ -1,4 +1,3 @@
-import { NetworkType } from '@metamask/controller-utils';
 export interface EtherscanTransactionMetaBase {
     blockNumber: string;
     blockHash: string;
@@ -29,38 +28,37 @@ export interface EtherscanTokenTransactionMeta extends EtherscanTransactionMetaB
     tokenSymbol: string;
 }
 export interface EtherscanTransactionResponse<T extends EtherscanTransactionMetaBase> {
-    status: '0' | '1';
     result: T[];
 }
 export interface EtherscanTransactionRequest {
     address: string;
-    networkType: NetworkType;
-    limit: number;
-    fromBlock?: string;
     apiKey?: string;
+    chainId: string;
+    fromBlock?: number;
+    limit?: number;
 }
 /**
  * Retrieves transaction data from Etherscan.
  *
  * @param request - Configuration required to fetch transactions.
  * @param request.address - Address to retrieve transactions for.
- * @param request.networkType - Current network type used to determine the Etherscan subdomain.
- * @param request.limit - Maximum number of transactions to retrieve.
  * @param request.apiKey - Etherscan API key.
+ * @param request.chainId - Current chain ID used to determine subdomain and domain.
  * @param request.fromBlock - Block number to start fetching transactions from.
+ * @param request.limit - Number of transactions to retrieve.
  * @returns An Etherscan response object containing the request status and an array of token transaction data.
  */
-export declare function fetchEtherscanTransactions({ address, networkType, limit, apiKey, fromBlock, }: EtherscanTransactionRequest): Promise<EtherscanTransactionResponse<EtherscanTransactionMeta>>;
+export declare function fetchEtherscanTransactions({ address, apiKey, chainId, fromBlock, limit, }: EtherscanTransactionRequest): Promise<EtherscanTransactionResponse<EtherscanTransactionMeta>>;
 /**
  * Retrieves token transaction data from Etherscan.
  *
  * @param request - Configuration required to fetch token transactions.
  * @param request.address - Address to retrieve token transactions for.
- * @param request.networkType - Current network type used to determine the Etherscan subdomain.
- * @param request.limit - Maximum number of token transactions to retrieve.
  * @param request.apiKey - Etherscan API key.
+ * @param request.chainId - Current chain ID used to determine subdomain and domain.
  * @param request.fromBlock - Block number to start fetching token transactions from.
+ * @param request.limit - Number of token transactions to retrieve.
  * @returns An Etherscan response object containing the request status and an array of token transaction data.
  */
-export declare function fetchEtherscanTokenTransactions({ address, networkType, limit, apiKey, fromBlock, }: EtherscanTransactionRequest): Promise<EtherscanTransactionResponse<EtherscanTokenTransactionMeta>>;
+export declare function fetchEtherscanTokenTransactions({ address, apiKey, chainId, fromBlock, limit, }: EtherscanTransactionRequest): Promise<EtherscanTransactionResponse<EtherscanTokenTransactionMeta>>;
 //# sourceMappingURL=etherscan.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/etherscan.d.ts.map b/node_modules/@metamask/transaction-controller/dist/etherscan.d.ts.map
deleted file mode 100644
index b947cbc..0000000
--- a/node_modules/@metamask/transaction-controller/dist/etherscan.d.ts.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"etherscan.d.ts","sourceRoot":"","sources":["../src/etherscan.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,WAAW,EAAe,MAAM,4BAA4B,CAAC;AAEtE,MAAM,WAAW,4BAA4B;IAC3C,WAAW,EAAE,MAAM,CAAC;IACpB,SAAS,EAAE,MAAM,CAAC;IAClB,aAAa,EAAE,MAAM,CAAC;IACtB,eAAe,EAAE,MAAM,CAAC;IACxB,iBAAiB,EAAE,MAAM,CAAC;IAC1B,IAAI,EAAE,MAAM,CAAC;IACb,GAAG,EAAE,MAAM,CAAC;IACZ,QAAQ,EAAE,MAAM,CAAC;IACjB,OAAO,EAAE,MAAM,CAAC;IAChB,IAAI,EAAE,MAAM,CAAC;IACb,KAAK,EAAE,MAAM,CAAC;IACd,SAAS,EAAE,MAAM,CAAC;IAClB,EAAE,EAAE,MAAM,CAAC;IACX,gBAAgB,EAAE,MAAM,CAAC;IACzB,KAAK,EAAE,MAAM,CAAC;CACf;AAED,MAAM,WAAW,wBAAyB,SAAQ,4BAA4B;IAC5E,YAAY,EAAE,MAAM,CAAC;IACrB,KAAK,EAAE,MAAM,CAAC;IACd,OAAO,EAAE,MAAM,CAAC;IAChB,QAAQ,EAAE,MAAM,CAAC;IACjB,gBAAgB,EAAE,MAAM,CAAC;CAC1B;AAED,MAAM,WAAW,6BACf,SAAQ,4BAA4B;IACpC,YAAY,EAAE,MAAM,CAAC;IACrB,SAAS,EAAE,MAAM,CAAC;IAClB,WAAW,EAAE,MAAM,CAAC;CACrB;AAED,MAAM,WAAW,4BAA4B,CAC3C,CAAC,SAAS,4BAA4B;IAEtC,MAAM,EAAE,GAAG,GAAG,GAAG,CAAC;IAClB,MAAM,EAAE,CAAC,EAAE,CAAC;CACb;AAED,MAAM,WAAW,2BAA2B;IAC1C,OAAO,EAAE,MAAM,CAAC;IAChB,WAAW,EAAE,WAAW,CAAC;IACzB,KAAK,EAAE,MAAM,CAAC;IACd,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,MAAM,CAAC,EAAE,MAAM,CAAC;CACjB;AAED;;;;;;;;;;GAUG;AACH,wBAAsB,0BAA0B,CAAC,EAC/C,OAAO,EACP,WAAW,EACX,KAAK,EACL,MAAM,EACN,SAAS,GACV,EAAE,2BAA2B,GAAG,OAAO,CACtC,4BAA4B,CAAC,wBAAwB,CAAC,CACvD,CAQA;AAED;;;;;;;;;;GAUG;AACH,wBAAsB,+BAA+B,CAAC,EACpD,OAAO,EACP,WAAW,EACX,KAAK,EACL,MAAM,EACN,SAAS,GACV,EAAE,2BAA2B,GAAG,OAAO,CACtC,4BAA4B,CAAC,6BAA6B,CAAC,CAC5D,CAQA"}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/etherscan.js b/node_modules/@metamask/transaction-controller/dist/etherscan.js
index 4e1cade..0757847 100644
--- a/node_modules/@metamask/transaction-controller/dist/etherscan.js
+++ b/node_modules/@metamask/transaction-controller/dist/etherscan.js
@@ -11,25 +11,26 @@ var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, ge
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.fetchEtherscanTokenTransactions = exports.fetchEtherscanTransactions = void 0;
 const controller_utils_1 = require("@metamask/controller-utils");
+const constants_1 = require("./constants");
 /**
  * Retrieves transaction data from Etherscan.
  *
  * @param request - Configuration required to fetch transactions.
  * @param request.address - Address to retrieve transactions for.
- * @param request.networkType - Current network type used to determine the Etherscan subdomain.
- * @param request.limit - Maximum number of transactions to retrieve.
  * @param request.apiKey - Etherscan API key.
+ * @param request.chainId - Current chain ID used to determine subdomain and domain.
  * @param request.fromBlock - Block number to start fetching transactions from.
+ * @param request.limit - Number of transactions to retrieve.
  * @returns An Etherscan response object containing the request status and an array of token transaction data.
  */
-function fetchEtherscanTransactions({ address, networkType, limit, apiKey, fromBlock, }) {
+function fetchEtherscanTransactions({ address, apiKey, chainId, fromBlock, limit, }) {
     return __awaiter(this, void 0, void 0, function* () {
         return yield fetchTransactions('txlist', {
             address,
-            networkType,
-            limit,
-            fromBlock,
             apiKey,
+            chainId,
+            fromBlock,
+            limit,
         });
     });
 }
@@ -39,20 +40,20 @@ exports.fetchEtherscanTransactions = fetchEtherscanTransactions;
  *
  * @param request - Configuration required to fetch token transactions.
  * @param request.address - Address to retrieve token transactions for.
- * @param request.networkType - Current network type used to determine the Etherscan subdomain.
- * @param request.limit - Maximum number of token transactions to retrieve.
  * @param request.apiKey - Etherscan API key.
+ * @param request.chainId - Current chain ID used to determine subdomain and domain.
  * @param request.fromBlock - Block number to start fetching token transactions from.
+ * @param request.limit - Number of token transactions to retrieve.
  * @returns An Etherscan response object containing the request status and an array of token transaction data.
  */
-function fetchEtherscanTokenTransactions({ address, networkType, limit, apiKey, fromBlock, }) {
+function fetchEtherscanTokenTransactions({ address, apiKey, chainId, fromBlock, limit, }) {
     return __awaiter(this, void 0, void 0, function* () {
         return yield fetchTransactions('tokentx', {
             address,
-            networkType,
-            limit,
-            fromBlock,
             apiKey,
+            chainId,
+            fromBlock,
+            limit,
         });
     });
 }
@@ -63,44 +64,47 @@ exports.fetchEtherscanTokenTransactions = fetchEtherscanTokenTransactions;
  * @param action - The Etherscan endpoint to use.
  * @param options - Options bag.
  * @param options.address - Address to retrieve transactions for.
- * @param options.networkType - Current network type used to determine the Etherscan subdomain.
- * @param options.limit - Maximum number of transactions to retrieve.
  * @param options.apiKey - Etherscan API key.
+ * @param options.chainId - Current chain ID used to determine subdomain and domain.
  * @param options.fromBlock - Block number to start fetching transactions from.
+ * @param options.limit - Number of transactions to retrieve.
  * @returns An object containing the request status and an array of transaction data.
  */
-function fetchTransactions(action, { address, networkType, limit, apiKey, fromBlock, }) {
+function fetchTransactions(action, { address, apiKey, chainId, limit, }) {
     return __awaiter(this, void 0, void 0, function* () {
         const urlParams = {
             module: 'account',
             address,
-            startBlock: fromBlock,
+            // Not previously used in mobile due to bug, temporarily disabled to match existing behaviour.
+            startBlock: undefined,
             apikey: apiKey,
-            offset: limit.toString(),
-            order: 'desc',
+            offset: limit === null || limit === void 0 ? void 0 : limit.toString(),
+            sort: 'desc',
         };
-        const etherscanTxUrl = getEtherscanApiUrl(networkType, Object.assign(Object.assign({}, urlParams), { action }));
+        const etherscanTxUrl = getEtherscanApiUrl(chainId, Object.assign(Object.assign({}, urlParams), { action }));
         const response = (yield (0, controller_utils_1.handleFetch)(etherscanTxUrl));
-        if (response.status === '0' || response.result.length <= 0) {
-            return { status: response.status, result: [] };
+        let result = response.result;
+        if (response.status === '0') {
+            result = [];
         }
-        return response;
+        return { result };
     });
 }
 /**
  * Return a URL that can be used to fetch data from Etherscan.
  *
- * @param networkType - Network type of desired network.
+ * @param chainId - Current chain ID used to determine subdomain and domain.
  * @param urlParams - The parameters used to construct the URL.
  * @returns URL to access Etherscan data.
  */
-function getEtherscanApiUrl(networkType, urlParams) {
-    let etherscanSubdomain = 'api';
-    if (networkType !== controller_utils_1.NetworkType.mainnet) {
-        etherscanSubdomain = `api-${networkType}`;
+function getEtherscanApiUrl(chainId, urlParams) {
+    const networkInfo = constants_1.ETHERSCAN_SUPPORTED_NETWORKS[chainId];
+    if (!networkInfo) {
+        throw new Error(`Etherscan does not support chain with ID: ${chainId}`);
     }
-    const apiUrl = `https://${etherscanSubdomain}.etherscan.io`;
+    const apiUrl = `https://${networkInfo.subdomain}.${networkInfo.domain}`;
     let url = `${apiUrl}/api?`;
+    // eslint-disable-next-line guard-for-in
     for (const paramKey in urlParams) {
         const value = urlParams[paramKey];
         if (!value) {
diff --git a/node_modules/@metamask/transaction-controller/dist/etherscan.js.map b/node_modules/@metamask/transaction-controller/dist/etherscan.js.map
deleted file mode 100644
index a9710c0..0000000
--- a/node_modules/@metamask/transaction-controller/dist/etherscan.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"etherscan.js","sourceRoot":"","sources":["../src/etherscan.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,iEAAsE;AAkDtE;;;;;;;;;;GAUG;AACH,SAAsB,0BAA0B,CAAC,EAC/C,OAAO,EACP,WAAW,EACX,KAAK,EACL,MAAM,EACN,SAAS,GACmB;;QAG5B,OAAO,MAAM,iBAAiB,CAAC,QAAQ,EAAE;YACvC,OAAO;YACP,WAAW;YACX,KAAK;YACL,SAAS;YACT,MAAM;SACP,CAAC,CAAC;IACL,CAAC;CAAA;AAhBD,gEAgBC;AAED;;;;;;;;;;GAUG;AACH,SAAsB,+BAA+B,CAAC,EACpD,OAAO,EACP,WAAW,EACX,KAAK,EACL,MAAM,EACN,SAAS,GACmB;;QAG5B,OAAO,MAAM,iBAAiB,CAAC,SAAS,EAAE;YACxC,OAAO;YACP,WAAW;YACX,KAAK;YACL,SAAS;YACT,MAAM;SACP,CAAC,CAAC;IACL,CAAC;CAAA;AAhBD,0EAgBC;AAED;;;;;;;;;;;GAWG;AACH,SAAe,iBAAiB,CAC9B,MAAc,EACd,EACE,OAAO,EACP,WAAW,EACX,KAAK,EACL,MAAM,EACN,SAAS,GAOV;;QAED,MAAM,SAAS,GAAG;YAChB,MAAM,EAAE,SAAS;YACjB,OAAO;YACP,UAAU,EAAE,SAAS;YACrB,MAAM,EAAE,MAAM;YACd,MAAM,EAAE,KAAK,CAAC,QAAQ,EAAE;YACxB,KAAK,EAAE,MAAM;SACd,CAAC;QAEF,MAAM,cAAc,GAAG,kBAAkB,CAAC,WAAW,kCAChD,SAAS,KACZ,MAAM,IACN,CAAC;QAEH,MAAM,QAAQ,GAAG,CAAC,MAAM,IAAA,8BAAW,EACjC,cAAc,CACf,CAAoC,CAAC;QAEtC,IAAI,QAAQ,CAAC,MAAM,KAAK,GAAG,IAAI,QAAQ,CAAC,MAAM,CAAC,MAAM,IAAI,CAAC,EAAE;YAC1D,OAAO,EAAE,MAAM,EAAE,QAAQ,CAAC,MAAM,EAAE,MAAM,EAAE,EAAE,EAAE,CAAC;SAChD;QAED,OAAO,QAAQ,CAAC;IAClB,CAAC;CAAA;AAED;;;;;;GAMG;AACH,SAAS,kBAAkB,CACzB,WAAmB,EACnB,SAA6C;IAE7C,IAAI,kBAAkB,GAAG,KAAK,CAAC;IAE/B,IAAI,WAAW,KAAK,8BAAW,CAAC,OAAO,EAAE;QACvC,kBAAkB,GAAG,OAAO,WAAW,EAAE,CAAC;KAC3C;IAED,MAAM,MAAM,GAAG,WAAW,kBAAkB,eAAe,CAAC;IAC5D,IAAI,GAAG,GAAG,GAAG,MAAM,OAAO,CAAC;IAE3B,KAAK,MAAM,QAAQ,IAAI,SAAS,EAAE;QAChC,MAAM,KAAK,GAAG,SAAS,CAAC,QAAQ,CAAC,CAAC;QAElC,IAAI,CAAC,KAAK,EAAE;YACV,SAAS;SACV;QAED,GAAG,IAAI,GAAG,QAAQ,IAAI,KAAK,GAAG,CAAC;KAChC;IAED,GAAG,IAAI,mBAAmB,CAAC;IAE3B,OAAO,GAAG,CAAC;AACb,CAAC","sourcesContent":["import { NetworkType, handleFetch } from '@metamask/controller-utils';\n\nexport interface EtherscanTransactionMetaBase {\n  blockNumber: string;\n  blockHash: string;\n  confirmations: string;\n  contractAddress: string;\n  cumulativeGasUsed: string;\n  from: string;\n  gas: string;\n  gasPrice: string;\n  gasUsed: string;\n  hash: string;\n  nonce: string;\n  timeStamp: string;\n  to: string;\n  transactionIndex: string;\n  value: string;\n}\n\nexport interface EtherscanTransactionMeta extends EtherscanTransactionMetaBase {\n  functionName: string;\n  input: string;\n  isError: string;\n  methodId: string;\n  txreceipt_status: string;\n}\n\nexport interface EtherscanTokenTransactionMeta\n  extends EtherscanTransactionMetaBase {\n  tokenDecimal: string;\n  tokenName: string;\n  tokenSymbol: string;\n}\n\nexport interface EtherscanTransactionResponse<\n  T extends EtherscanTransactionMetaBase,\n> {\n  status: '0' | '1';\n  result: T[];\n}\n\nexport interface EtherscanTransactionRequest {\n  address: string;\n  networkType: NetworkType;\n  limit: number;\n  fromBlock?: string;\n  apiKey?: string;\n}\n\n/**\n * Retrieves transaction data from Etherscan.\n *\n * @param request - Configuration required to fetch transactions.\n * @param request.address - Address to retrieve transactions for.\n * @param request.networkType - Current network type used to determine the Etherscan subdomain.\n * @param request.limit - Maximum number of transactions to retrieve.\n * @param request.apiKey - Etherscan API key.\n * @param request.fromBlock - Block number to start fetching transactions from.\n * @returns An Etherscan response object containing the request status and an array of token transaction data.\n */\nexport async function fetchEtherscanTransactions({\n  address,\n  networkType,\n  limit,\n  apiKey,\n  fromBlock,\n}: EtherscanTransactionRequest): Promise<\n  EtherscanTransactionResponse<EtherscanTransactionMeta>\n> {\n  return await fetchTransactions('txlist', {\n    address,\n    networkType,\n    limit,\n    fromBlock,\n    apiKey,\n  });\n}\n\n/**\n * Retrieves token transaction data from Etherscan.\n *\n * @param request - Configuration required to fetch token transactions.\n * @param request.address - Address to retrieve token transactions for.\n * @param request.networkType - Current network type used to determine the Etherscan subdomain.\n * @param request.limit - Maximum number of token transactions to retrieve.\n * @param request.apiKey - Etherscan API key.\n * @param request.fromBlock - Block number to start fetching token transactions from.\n * @returns An Etherscan response object containing the request status and an array of token transaction data.\n */\nexport async function fetchEtherscanTokenTransactions({\n  address,\n  networkType,\n  limit,\n  apiKey,\n  fromBlock,\n}: EtherscanTransactionRequest): Promise<\n  EtherscanTransactionResponse<EtherscanTokenTransactionMeta>\n> {\n  return await fetchTransactions('tokentx', {\n    address,\n    networkType,\n    limit,\n    fromBlock,\n    apiKey,\n  });\n}\n\n/**\n * Retrieves transaction data from Etherscan from a specific endpoint.\n *\n * @param action - The Etherscan endpoint to use.\n * @param options - Options bag.\n * @param options.address - Address to retrieve transactions for.\n * @param options.networkType - Current network type used to determine the Etherscan subdomain.\n * @param options.limit - Maximum number of transactions to retrieve.\n * @param options.apiKey - Etherscan API key.\n * @param options.fromBlock - Block number to start fetching transactions from.\n * @returns An object containing the request status and an array of transaction data.\n */\nasync function fetchTransactions<T extends EtherscanTransactionMetaBase>(\n  action: string,\n  {\n    address,\n    networkType,\n    limit,\n    apiKey,\n    fromBlock,\n  }: {\n    address: string;\n    networkType: NetworkType;\n    limit: number;\n    fromBlock?: string;\n    apiKey?: string;\n  },\n): Promise<EtherscanTransactionResponse<T>> {\n  const urlParams = {\n    module: 'account',\n    address,\n    startBlock: fromBlock,\n    apikey: apiKey,\n    offset: limit.toString(),\n    order: 'desc',\n  };\n\n  const etherscanTxUrl = getEtherscanApiUrl(networkType, {\n    ...urlParams,\n    action,\n  });\n\n  const response = (await handleFetch(\n    etherscanTxUrl,\n  )) as EtherscanTransactionResponse<T>;\n\n  if (response.status === '0' || response.result.length <= 0) {\n    return { status: response.status, result: [] };\n  }\n\n  return response;\n}\n\n/**\n * Return a URL that can be used to fetch data from Etherscan.\n *\n * @param networkType - Network type of desired network.\n * @param urlParams - The parameters used to construct the URL.\n * @returns URL to access Etherscan data.\n */\nfunction getEtherscanApiUrl(\n  networkType: string,\n  urlParams: Record<string, string | undefined>,\n): string {\n  let etherscanSubdomain = 'api';\n\n  if (networkType !== NetworkType.mainnet) {\n    etherscanSubdomain = `api-${networkType}`;\n  }\n\n  const apiUrl = `https://${etherscanSubdomain}.etherscan.io`;\n  let url = `${apiUrl}/api?`;\n\n  for (const paramKey in urlParams) {\n    const value = urlParams[paramKey];\n\n    if (!value) {\n      continue;\n    }\n\n    url += `${paramKey}=${value}&`;\n  }\n\n  url += 'tag=latest&page=1';\n\n  return url;\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/external-transactions.d.ts b/node_modules/@metamask/transaction-controller/dist/external-transactions.d.ts
new file mode 100644
index 0000000..93a84da
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/external-transactions.d.ts
@@ -0,0 +1,10 @@
+import type { TransactionMeta } from './types';
+/**
+ * Validates the external provided transaction meta.
+ *
+ * @param transactionMeta - The transaction meta to validate.
+ * @param confirmedTxs - The confirmed transactions in controller state.
+ * @param pendingTxs - The submitted transactions in controller state.
+ */
+export declare function validateConfirmedExternalTransaction(transactionMeta?: TransactionMeta, confirmedTxs?: TransactionMeta[], pendingTxs?: TransactionMeta[]): void;
+//# sourceMappingURL=external-transactions.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/external-transactions.js b/node_modules/@metamask/transaction-controller/dist/external-transactions.js
new file mode 100644
index 0000000..2736d7f
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/external-transactions.js
@@ -0,0 +1,35 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.validateConfirmedExternalTransaction = void 0;
+// These utility functions are exclusively used by `confirmExternalTransaction` method in controller
+const types_1 = require("./types");
+/**
+ * Validates the external provided transaction meta.
+ *
+ * @param transactionMeta - The transaction meta to validate.
+ * @param confirmedTxs - The confirmed transactions in controller state.
+ * @param pendingTxs - The submitted transactions in controller state.
+ */
+function validateConfirmedExternalTransaction(transactionMeta, confirmedTxs, pendingTxs) {
+    if (!transactionMeta || !transactionMeta.transaction) {
+        throw new Error('"transactionMeta" or "transactionMeta.transaction" is missing');
+    }
+    if (transactionMeta.status !== types_1.TransactionStatus.confirmed) {
+        throw new Error('External transaction status should be "confirmed"');
+    }
+    const externalTxNonce = transactionMeta.transaction.nonce;
+    if (pendingTxs && pendingTxs.length > 0) {
+        const foundPendingTxByNonce = pendingTxs.find((tx) => { var _a; return ((_a = tx.transaction) === null || _a === void 0 ? void 0 : _a.nonce) === externalTxNonce; });
+        if (foundPendingTxByNonce) {
+            throw new Error('External transaction nonce should not be in pending txs');
+        }
+    }
+    if (confirmedTxs && confirmedTxs.length > 0) {
+        const foundConfirmedTxByNonce = confirmedTxs.find((tx) => { var _a; return ((_a = tx.transaction) === null || _a === void 0 ? void 0 : _a.nonce) === externalTxNonce; });
+        if (foundConfirmedTxByNonce) {
+            throw new Error('External transaction nonce should not be in confirmed txs');
+        }
+    }
+}
+exports.validateConfirmedExternalTransaction = validateConfirmedExternalTransaction;
+//# sourceMappingURL=external-transactions.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/gas-flows/DefaultGasFeeFlow.d.ts b/node_modules/@metamask/transaction-controller/dist/gas-flows/DefaultGasFeeFlow.d.ts
new file mode 100644
index 0000000..325802b
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/gas-flows/DefaultGasFeeFlow.d.ts
@@ -0,0 +1,10 @@
+import type { GasFeeFlow, GasFeeFlowRequest, GasFeeFlowResponse, TransactionMeta } from '../types';
+/**
+ * The standard implementation of a gas fee flow that obtains gas fee estimates using only the GasFeeController.
+ */
+export declare class DefaultGasFeeFlow implements GasFeeFlow {
+    #private;
+    matchesTransaction(_transactionMeta: TransactionMeta): boolean;
+    getGasFees(request: GasFeeFlowRequest): Promise<GasFeeFlowResponse>;
+}
+//# sourceMappingURL=DefaultGasFeeFlow.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/gas-flows/DefaultGasFeeFlow.d.ts.map b/node_modules/@metamask/transaction-controller/dist/gas-flows/DefaultGasFeeFlow.d.ts.map
new file mode 100644
index 0000000..7ed6d78
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/gas-flows/DefaultGasFeeFlow.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"DefaultGasFeeFlow.d.ts","sourceRoot":"","sources":["../../src/gas-flows/DefaultGasFeeFlow.ts"],"names":[],"mappings":"AAUA,OAAO,KAAK,EAGV,UAAU,EACV,iBAAiB,EACjB,kBAAkB,EAClB,eAAe,EAChB,MAAM,UAAU,CAAC;AAiBlB;;GAEG;AACH,qBAAa,iBAAkB,YAAW,UAAU;;IAClD,kBAAkB,CAAC,gBAAgB,EAAE,eAAe,GAAG,OAAO;IAIxD,UAAU,CAAC,OAAO,EAAE,iBAAiB,GAAG,OAAO,CAAC,kBAAkB,CAAC;CA4E1E"}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/gas-flows/DefaultGasFeeFlow.js b/node_modules/@metamask/transaction-controller/dist/gas-flows/DefaultGasFeeFlow.js
new file mode 100644
index 0000000..24ecb29
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/gas-flows/DefaultGasFeeFlow.js
@@ -0,0 +1,79 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
+    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
+};
+var _DefaultGasFeeFlow_instances, _DefaultGasFeeFlow_getEstimateLevel, _DefaultGasFeeFlow_getFeeMarketLevel, _DefaultGasFeeFlow_getLegacyLevel, _DefaultGasFeeFlow_gweiDecimalToWeiHex;
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.DefaultGasFeeFlow = void 0;
+const controller_utils_1 = require("@metamask/controller-utils");
+const gas_fee_controller_1 = require("@metamask/gas-fee-controller");
+const utils_1 = require("@metamask/utils");
+const logger_1 = require("../logger");
+const types_1 = require("../types");
+const log = (0, utils_1.createModuleLogger)(logger_1.projectLogger, 'default-gas-fee-flow');
+/**
+ * The standard implementation of a gas fee flow that obtains gas fee estimates using only the GasFeeController.
+ */
+class DefaultGasFeeFlow {
+    constructor() {
+        _DefaultGasFeeFlow_instances.add(this);
+    }
+    matchesTransaction(_transactionMeta) {
+        return true;
+    }
+    getGasFees(request) {
+        return __awaiter(this, void 0, void 0, function* () {
+            const { getGasFeeControllerEstimates } = request;
+            const { gasEstimateType, gasFeeEstimates } = yield getGasFeeControllerEstimates();
+            if (gasEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.FEE_MARKET) {
+                log('Using fee market estimates', gasFeeEstimates);
+            }
+            else if (gasEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.LEGACY) {
+                log('Using legacy estimates', gasFeeEstimates);
+            }
+            else {
+                throw new Error(`'No gas fee estimates available`);
+            }
+            const estimates = Object.values(types_1.GasFeeEstimateLevel).reduce((result, level) => (Object.assign(Object.assign({}, result), { [level]: __classPrivateFieldGet(this, _DefaultGasFeeFlow_instances, "m", _DefaultGasFeeFlow_getEstimateLevel).call(this, {
+                    gasEstimateType,
+                    gasFeeEstimates,
+                    level,
+                }) })), {});
+            return { estimates };
+        });
+    }
+}
+exports.DefaultGasFeeFlow = DefaultGasFeeFlow;
+_DefaultGasFeeFlow_instances = new WeakSet(), _DefaultGasFeeFlow_getEstimateLevel = function _DefaultGasFeeFlow_getEstimateLevel({ gasEstimateType, gasFeeEstimates, level, }) {
+    if (gasEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.FEE_MARKET) {
+        return __classPrivateFieldGet(this, _DefaultGasFeeFlow_instances, "m", _DefaultGasFeeFlow_getFeeMarketLevel).call(this, gasFeeEstimates, level);
+    }
+    return __classPrivateFieldGet(this, _DefaultGasFeeFlow_instances, "m", _DefaultGasFeeFlow_getLegacyLevel).call(this, gasFeeEstimates, level);
+}, _DefaultGasFeeFlow_getFeeMarketLevel = function _DefaultGasFeeFlow_getFeeMarketLevel(gasFeeEstimates, level) {
+    const maxFeePerGas = __classPrivateFieldGet(this, _DefaultGasFeeFlow_instances, "m", _DefaultGasFeeFlow_gweiDecimalToWeiHex).call(this, gasFeeEstimates[level].suggestedMaxFeePerGas);
+    const maxPriorityFeePerGas = __classPrivateFieldGet(this, _DefaultGasFeeFlow_instances, "m", _DefaultGasFeeFlow_gweiDecimalToWeiHex).call(this, gasFeeEstimates[level].suggestedMaxPriorityFeePerGas);
+    return {
+        maxFeePerGas,
+        maxPriorityFeePerGas,
+    };
+}, _DefaultGasFeeFlow_getLegacyLevel = function _DefaultGasFeeFlow_getLegacyLevel(gasFeeEstimates, level) {
+    const gasPrice = __classPrivateFieldGet(this, _DefaultGasFeeFlow_instances, "m", _DefaultGasFeeFlow_gweiDecimalToWeiHex).call(this, gasFeeEstimates[level]);
+    return {
+        maxFeePerGas: gasPrice,
+        maxPriorityFeePerGas: gasPrice,
+    };
+}, _DefaultGasFeeFlow_gweiDecimalToWeiHex = function _DefaultGasFeeFlow_gweiDecimalToWeiHex(gweiDecimal) {
+    return (0, controller_utils_1.toHex)((0, controller_utils_1.gweiDecToWEIBN)(gweiDecimal));
+};
+//# sourceMappingURL=DefaultGasFeeFlow.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/gas-flows/DefaultGasFeeFlow.js.map b/node_modules/@metamask/transaction-controller/dist/gas-flows/DefaultGasFeeFlow.js.map
new file mode 100644
index 0000000..436f84f
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/gas-flows/DefaultGasFeeFlow.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"DefaultGasFeeFlow.js","sourceRoot":"","sources":["../../src/gas-flows/DefaultGasFeeFlow.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA,iEAAmE;AAKnE,qEAAkE;AAElE,2CAAqD;AAErD,sCAA0C;AAS1C,oCAA+C;AAE/C,MAAM,GAAG,GAAG,IAAA,0BAAkB,EAAC,sBAAa,EAAE,sBAAsB,CAAC,CAAC;AActE;;GAEG;AACH,MAAa,iBAAiB;IAA9B;;IAiFA,CAAC;IAhFC,kBAAkB,CAAC,gBAAiC;QAClD,OAAO,IAAI,CAAC;IACd,CAAC;IAEK,UAAU,CAAC,OAA0B;;YACzC,MAAM,EAAE,4BAA4B,EAAE,GAAG,OAAO,CAAC;YAEjD,MAAM,EAAE,eAAe,EAAE,eAAe,EAAE,GACxC,MAAM,4BAA4B,EAAE,CAAC;YAEvC,IAAI,eAAe,KAAK,uCAAkB,CAAC,UAAU,EAAE;gBACrD,GAAG,CAAC,4BAA4B,EAAE,eAAe,CAAC,CAAC;aACpD;iBAAM,IAAI,eAAe,KAAK,uCAAkB,CAAC,MAAM,EAAE;gBACxD,GAAG,CAAC,wBAAwB,EAAE,eAAe,CAAC,CAAC;aAChD;iBAAM;gBACL,MAAM,IAAI,KAAK,CAAC,iCAAiC,CAAC,CAAC;aACpD;YAED,MAAM,SAAS,GAAG,MAAM,CAAC,MAAM,CAAC,2BAAmB,CAAC,CAAC,MAAM,CACzD,CAAC,MAAM,EAAE,KAAK,EAAE,EAAE,CAAC,iCACd,MAAM,KACT,CAAC,KAAK,CAAC,EAAE,uBAAA,IAAI,yEAAkB,MAAtB,IAAI,EAAmB;oBAC9B,eAAe;oBACf,eAAe;oBACf,KAAK;iBAC8D,CAAC,IACtE,EACF,EAAqB,CACtB,CAAC;YAEF,OAAO,EAAE,SAAS,EAAE,CAAC;QACvB,CAAC;KAAA;CAiDF;AAjFD,8CAiFC;iIA/CmB,EAChB,eAAe,EACf,eAAe,EACf,KAAK,GAG0B;IAC/B,IAAI,eAAe,KAAK,uCAAkB,CAAC,UAAU,EAAE;QACrD,OAAO,uBAAA,IAAI,0EAAmB,MAAvB,IAAI,EAAoB,eAAe,EAAE,KAAK,CAAC,CAAC;KACxD;IAED,OAAO,uBAAA,IAAI,uEAAgB,MAApB,IAAI,EAAiB,eAAe,EAAE,KAAK,CAAC,CAAC;AACtD,CAAC,uFAGC,eAA0C,EAC1C,KAA0B;IAE1B,MAAM,YAAY,GAAG,uBAAA,IAAI,4EAAqB,MAAzB,IAAI,EACvB,eAAe,CAAC,KAAK,CAAC,CAAC,qBAAqB,CAC7C,CAAC;IAEF,MAAM,oBAAoB,GAAG,uBAAA,IAAI,4EAAqB,MAAzB,IAAI,EAC/B,eAAe,CAAC,KAAK,CAAC,CAAC,6BAA6B,CACrD,CAAC;IAEF,OAAO;QACL,YAAY;QACZ,oBAAoB;KACrB,CAAC;AACJ,CAAC,iFAGC,eAAuC,EACvC,KAA0B;IAE1B,MAAM,QAAQ,GAAG,uBAAA,IAAI,4EAAqB,MAAzB,IAAI,EAAsB,eAAe,CAAC,KAAK,CAAC,CAAC,CAAC;IAEnE,OAAO;QACL,YAAY,EAAE,QAAQ;QACtB,oBAAoB,EAAE,QAAQ;KAC/B,CAAC;AACJ,CAAC,2FAEoB,WAAmB;IACtC,OAAO,IAAA,wBAAK,EAAC,IAAA,iCAAc,EAAC,WAAW,CAAC,CAAC,CAAC;AAC5C,CAAC","sourcesContent":["import { gweiDecToWEIBN, toHex } from '@metamask/controller-utils';\nimport type {\n  LegacyGasPriceEstimate,\n  GasFeeEstimates as FeeMarketGasPriceEstimate,\n} from '@metamask/gas-fee-controller';\nimport { GAS_ESTIMATE_TYPES } from '@metamask/gas-fee-controller';\nimport type { Hex } from '@metamask/utils';\nimport { createModuleLogger } from '@metamask/utils';\n\nimport { projectLogger } from '../logger';\nimport type {\n  GasFeeEstimates,\n  GasFeeEstimatesForLevel,\n  GasFeeFlow,\n  GasFeeFlowRequest,\n  GasFeeFlowResponse,\n  TransactionMeta,\n} from '../types';\nimport { GasFeeEstimateLevel } from '../types';\n\nconst log = createModuleLogger(projectLogger, 'default-gas-fee-flow');\n\ntype FeeMarketGetEstimateLevelRequest = {\n  gasEstimateType: 'fee-market';\n  gasFeeEstimates: FeeMarketGasPriceEstimate;\n  level: GasFeeEstimateLevel;\n};\n\ntype LegacyGetEstimateLevelRequest = {\n  gasEstimateType: 'legacy';\n  gasFeeEstimates: LegacyGasPriceEstimate;\n  level: GasFeeEstimateLevel;\n};\n\n/**\n * The standard implementation of a gas fee flow that obtains gas fee estimates using only the GasFeeController.\n */\nexport class DefaultGasFeeFlow implements GasFeeFlow {\n  matchesTransaction(_transactionMeta: TransactionMeta): boolean {\n    return true;\n  }\n\n  async getGasFees(request: GasFeeFlowRequest): Promise<GasFeeFlowResponse> {\n    const { getGasFeeControllerEstimates } = request;\n\n    const { gasEstimateType, gasFeeEstimates } =\n      await getGasFeeControllerEstimates();\n\n    if (gasEstimateType === GAS_ESTIMATE_TYPES.FEE_MARKET) {\n      log('Using fee market estimates', gasFeeEstimates);\n    } else if (gasEstimateType === GAS_ESTIMATE_TYPES.LEGACY) {\n      log('Using legacy estimates', gasFeeEstimates);\n    } else {\n      throw new Error(`'No gas fee estimates available`);\n    }\n\n    const estimates = Object.values(GasFeeEstimateLevel).reduce(\n      (result, level) => ({\n        ...result,\n        [level]: this.#getEstimateLevel({\n          gasEstimateType,\n          gasFeeEstimates,\n          level,\n        } as FeeMarketGetEstimateLevelRequest | LegacyGetEstimateLevelRequest),\n      }),\n      {} as GasFeeEstimates,\n    );\n\n    return { estimates };\n  }\n\n  #getEstimateLevel({\n    gasEstimateType,\n    gasFeeEstimates,\n    level,\n  }:\n    | FeeMarketGetEstimateLevelRequest\n    | LegacyGetEstimateLevelRequest): GasFeeEstimatesForLevel {\n    if (gasEstimateType === GAS_ESTIMATE_TYPES.FEE_MARKET) {\n      return this.#getFeeMarketLevel(gasFeeEstimates, level);\n    }\n\n    return this.#getLegacyLevel(gasFeeEstimates, level);\n  }\n\n  #getFeeMarketLevel(\n    gasFeeEstimates: FeeMarketGasPriceEstimate,\n    level: GasFeeEstimateLevel,\n  ): GasFeeEstimatesForLevel {\n    const maxFeePerGas = this.#gweiDecimalToWeiHex(\n      gasFeeEstimates[level].suggestedMaxFeePerGas,\n    );\n\n    const maxPriorityFeePerGas = this.#gweiDecimalToWeiHex(\n      gasFeeEstimates[level].suggestedMaxPriorityFeePerGas,\n    );\n\n    return {\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n    };\n  }\n\n  #getLegacyLevel(\n    gasFeeEstimates: LegacyGasPriceEstimate,\n    level: GasFeeEstimateLevel,\n  ): GasFeeEstimatesForLevel {\n    const gasPrice = this.#gweiDecimalToWeiHex(gasFeeEstimates[level]);\n\n    return {\n      maxFeePerGas: gasPrice,\n      maxPriorityFeePerGas: gasPrice,\n    };\n  }\n\n  #gweiDecimalToWeiHex(gweiDecimal: string): Hex {\n    return toHex(gweiDecToWEIBN(gweiDecimal));\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/gas-flows/LineaGasFeeFlow.d.ts b/node_modules/@metamask/transaction-controller/dist/gas-flows/LineaGasFeeFlow.d.ts
new file mode 100644
index 0000000..ce728db
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/gas-flows/LineaGasFeeFlow.d.ts
@@ -0,0 +1,12 @@
+import type { GasFeeFlow, GasFeeFlowRequest, GasFeeFlowResponse, TransactionMeta } from '../types';
+/**
+ * Implementation of a gas fee flow specific to Linea networks that obtains gas fee estimates using:
+ * - The `linea_estimateGas` RPC method to obtain the base fee and lowest priority fee.
+ * - Static multipliers to increase the base and priority fees.
+ */
+export declare class LineaGasFeeFlow implements GasFeeFlow {
+    #private;
+    matchesTransaction(transactionMeta: TransactionMeta): boolean;
+    getGasFees(request: GasFeeFlowRequest): Promise<GasFeeFlowResponse>;
+}
+//# sourceMappingURL=LineaGasFeeFlow.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/gas-flows/LineaGasFeeFlow.d.ts.map b/node_modules/@metamask/transaction-controller/dist/gas-flows/LineaGasFeeFlow.d.ts.map
new file mode 100644
index 0000000..dec2fb5
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/gas-flows/LineaGasFeeFlow.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"LineaGasFeeFlow.d.ts","sourceRoot":"","sources":["../../src/gas-flows/LineaGasFeeFlow.ts"],"names":[],"mappings":"AAMA,OAAO,KAAK,EAEV,UAAU,EACV,iBAAiB,EACjB,kBAAkB,EAClB,eAAe,EAChB,MAAM,UAAU,CAAC;AAgClB;;;;GAIG;AACH,qBAAa,eAAgB,YAAW,UAAU;;IAChD,kBAAkB,CAAC,eAAe,EAAE,eAAe,GAAG,OAAO;IAIvD,UAAU,CAAC,OAAO,EAAE,iBAAiB,GAAG,OAAO,CAAC,kBAAkB,CAAC;CAqG1E"}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/gas-flows/LineaGasFeeFlow.js b/node_modules/@metamask/transaction-controller/dist/gas-flows/LineaGasFeeFlow.js
new file mode 100644
index 0000000..4b3ad42
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/gas-flows/LineaGasFeeFlow.js
@@ -0,0 +1,112 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
+    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
+};
+var _LineaGasFeeFlow_instances, _LineaGasFeeFlow_getLineaGasFees, _LineaGasFeeFlow_getLineaResponse, _LineaGasFeeFlow_getValuesFromMultipliers, _LineaGasFeeFlow_getMaxFees, _LineaGasFeeFlow_feesToString;
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.LineaGasFeeFlow = void 0;
+const controller_utils_1 = require("@metamask/controller-utils");
+const utils_1 = require("@metamask/utils");
+const DefaultGasFeeFlow_1 = require("./DefaultGasFeeFlow");
+const logger_1 = require("../logger");
+const types_1 = require("../types");
+const log = (0, utils_1.createModuleLogger)(logger_1.projectLogger, 'linea-gas-fee-flow');
+const LINEA_CHAIN_IDS = [
+    controller_utils_1.ChainId['linea-mainnet'],
+    controller_utils_1.ChainId['linea-goerli'],
+    controller_utils_1.ChainId['linea-sepolia'],
+];
+const BASE_FEE_MULTIPLIERS = {
+    low: 1,
+    medium: 1.35,
+    high: 1.7,
+};
+const PRIORITY_FEE_MULTIPLIERS = {
+    low: 1,
+    medium: 1.05,
+    high: 1.1,
+};
+/**
+ * Implementation of a gas fee flow specific to Linea networks that obtains gas fee estimates using:
+ * - The `linea_estimateGas` RPC method to obtain the base fee and lowest priority fee.
+ * - Static multipliers to increase the base and priority fees.
+ */
+class LineaGasFeeFlow {
+    constructor() {
+        _LineaGasFeeFlow_instances.add(this);
+    }
+    matchesTransaction(transactionMeta) {
+        return LINEA_CHAIN_IDS.includes(transactionMeta.chainId);
+    }
+    getGasFees(request) {
+        return __awaiter(this, void 0, void 0, function* () {
+            try {
+                return yield __classPrivateFieldGet(this, _LineaGasFeeFlow_instances, "m", _LineaGasFeeFlow_getLineaGasFees).call(this, request);
+            }
+            catch (error) {
+                log('Using default flow as fallback due to error', error);
+                return new DefaultGasFeeFlow_1.DefaultGasFeeFlow().getGasFees(request);
+            }
+        });
+    }
+}
+exports.LineaGasFeeFlow = LineaGasFeeFlow;
+_LineaGasFeeFlow_instances = new WeakSet(), _LineaGasFeeFlow_getLineaGasFees = function _LineaGasFeeFlow_getLineaGasFees(request) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const { ethQuery, transactionMeta } = request;
+        const lineaResponse = yield __classPrivateFieldGet(this, _LineaGasFeeFlow_instances, "m", _LineaGasFeeFlow_getLineaResponse).call(this, transactionMeta, ethQuery);
+        log('Received Linea response', lineaResponse);
+        const baseFees = __classPrivateFieldGet(this, _LineaGasFeeFlow_instances, "m", _LineaGasFeeFlow_getValuesFromMultipliers).call(this, lineaResponse.baseFeePerGas, BASE_FEE_MULTIPLIERS);
+        log('Generated base fees', __classPrivateFieldGet(this, _LineaGasFeeFlow_instances, "m", _LineaGasFeeFlow_feesToString).call(this, baseFees));
+        const priorityFees = __classPrivateFieldGet(this, _LineaGasFeeFlow_instances, "m", _LineaGasFeeFlow_getValuesFromMultipliers).call(this, lineaResponse.priorityFeePerGas, PRIORITY_FEE_MULTIPLIERS);
+        log('Generated priority fees', __classPrivateFieldGet(this, _LineaGasFeeFlow_instances, "m", _LineaGasFeeFlow_feesToString).call(this, priorityFees));
+        const maxFees = __classPrivateFieldGet(this, _LineaGasFeeFlow_instances, "m", _LineaGasFeeFlow_getMaxFees).call(this, baseFees, priorityFees);
+        log('Generated max fees', __classPrivateFieldGet(this, _LineaGasFeeFlow_instances, "m", _LineaGasFeeFlow_feesToString).call(this, maxFees));
+        const estimates = Object.values(types_1.GasFeeEstimateLevel).reduce((result, level) => (Object.assign(Object.assign({}, result), { [level]: {
+                maxFeePerGas: (0, controller_utils_1.toHex)(maxFees[level]),
+                maxPriorityFeePerGas: (0, controller_utils_1.toHex)(priorityFees[level]),
+            } })), {});
+        return { estimates };
+    });
+}, _LineaGasFeeFlow_getLineaResponse = function _LineaGasFeeFlow_getLineaResponse(transactionMeta, ethQuery) {
+    return (0, controller_utils_1.query)(ethQuery, 'linea_estimateGas', [
+        {
+            from: transactionMeta.transaction.from,
+            to: transactionMeta.transaction.to,
+            value: transactionMeta.transaction.value,
+            input: transactionMeta.transaction.data,
+            // Required in request but no impact on response.
+            gasPrice: '0x100000000',
+        },
+    ]);
+}, _LineaGasFeeFlow_getValuesFromMultipliers = function _LineaGasFeeFlow_getValuesFromMultipliers(value, multipliers) {
+    const base = (0, controller_utils_1.hexToBN)(value);
+    const low = base.muln(multipliers.low);
+    const medium = base.muln(multipliers.medium);
+    const high = base.muln(multipliers.high);
+    return {
+        low,
+        medium,
+        high,
+    };
+}, _LineaGasFeeFlow_getMaxFees = function _LineaGasFeeFlow_getMaxFees(baseFees, priorityFees) {
+    return {
+        low: baseFees.low.add(priorityFees.low),
+        medium: baseFees.medium.add(priorityFees.medium),
+        high: baseFees.high.add(priorityFees.high),
+    };
+}, _LineaGasFeeFlow_feesToString = function _LineaGasFeeFlow_feesToString(fees) {
+    return Object.values(types_1.GasFeeEstimateLevel).map((level) => fees[level].toString(10));
+};
+//# sourceMappingURL=LineaGasFeeFlow.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/gas-flows/LineaGasFeeFlow.js.map b/node_modules/@metamask/transaction-controller/dist/gas-flows/LineaGasFeeFlow.js.map
new file mode 100644
index 0000000..55967a3
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/gas-flows/LineaGasFeeFlow.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"LineaGasFeeFlow.js","sourceRoot":"","sources":["../../src/gas-flows/LineaGasFeeFlow.ts"],"names":[],"mappings":"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","sourcesContent":["import { ChainId, hexToBN, query, toHex } from '@metamask/controller-utils';\nimport { createModuleLogger, type Hex } from '@metamask/utils';\nimport type { BN } from 'ethereumjs-util';\n\nimport { DefaultGasFeeFlow } from './DefaultGasFeeFlow';\nimport { projectLogger } from '../logger';\nimport type {\n  GasFeeEstimates,\n  GasFeeFlow,\n  GasFeeFlowRequest,\n  GasFeeFlowResponse,\n  TransactionMeta,\n} from '../types';\nimport { GasFeeEstimateLevel } from '../types';\n\ntype LineaEstimateGasResponse = {\n  baseFeePerGas: Hex;\n  priorityFeePerGas: Hex;\n};\n\ntype FeesByLevel = {\n  [key in GasFeeEstimateLevel]: BN;\n};\n\nconst log = createModuleLogger(projectLogger, 'linea-gas-fee-flow');\n\nconst LINEA_CHAIN_IDS: Hex[] = [\n  ChainId['linea-mainnet'],\n  ChainId['linea-goerli'],\n  ChainId['linea-sepolia'],\n];\n\nconst BASE_FEE_MULTIPLIERS = {\n  low: 1,\n  medium: 1.35,\n  high: 1.7,\n};\n\nconst PRIORITY_FEE_MULTIPLIERS = {\n  low: 1,\n  medium: 1.05,\n  high: 1.1,\n};\n\n/**\n * Implementation of a gas fee flow specific to Linea networks that obtains gas fee estimates using:\n * - The `linea_estimateGas` RPC method to obtain the base fee and lowest priority fee.\n * - Static multipliers to increase the base and priority fees.\n */\nexport class LineaGasFeeFlow implements GasFeeFlow {\n  matchesTransaction(transactionMeta: TransactionMeta): boolean {\n    return LINEA_CHAIN_IDS.includes(transactionMeta.chainId as Hex);\n  }\n\n  async getGasFees(request: GasFeeFlowRequest): Promise<GasFeeFlowResponse> {\n    try {\n      return await this.#getLineaGasFees(request);\n    } catch (error) {\n      log('Using default flow as fallback due to error', error);\n      return new DefaultGasFeeFlow().getGasFees(request);\n    }\n  }\n\n  async #getLineaGasFees(\n    request: GasFeeFlowRequest,\n  ): Promise<GasFeeFlowResponse> {\n    const { ethQuery, transactionMeta } = request;\n\n    const lineaResponse = await this.#getLineaResponse(\n      transactionMeta,\n      ethQuery,\n    );\n\n    log('Received Linea response', lineaResponse);\n\n    const baseFees = this.#getValuesFromMultipliers(\n      lineaResponse.baseFeePerGas,\n      BASE_FEE_MULTIPLIERS,\n    );\n\n    log('Generated base fees', this.#feesToString(baseFees));\n\n    const priorityFees = this.#getValuesFromMultipliers(\n      lineaResponse.priorityFeePerGas,\n      PRIORITY_FEE_MULTIPLIERS,\n    );\n\n    log('Generated priority fees', this.#feesToString(priorityFees));\n\n    const maxFees = this.#getMaxFees(baseFees, priorityFees);\n\n    log('Generated max fees', this.#feesToString(maxFees));\n\n    const estimates = Object.values(GasFeeEstimateLevel).reduce(\n      (result, level) => ({\n        ...result,\n        [level]: {\n          maxFeePerGas: toHex(maxFees[level]),\n          maxPriorityFeePerGas: toHex(priorityFees[level]),\n        },\n      }),\n      {} as GasFeeEstimates,\n    );\n\n    return { estimates };\n  }\n\n  #getLineaResponse(\n    transactionMeta: TransactionMeta,\n    ethQuery: any,\n  ): Promise<LineaEstimateGasResponse> {\n    return query(ethQuery, 'linea_estimateGas', [\n      {\n        from: transactionMeta.transaction.from,\n        to: transactionMeta.transaction.to,\n        value: transactionMeta.transaction.value,\n        input: transactionMeta.transaction.data,\n        // Required in request but no impact on response.\n        gasPrice: '0x100000000',\n      },\n    ]);\n  }\n\n  #getValuesFromMultipliers(\n    value: Hex,\n    multipliers: { low: number; medium: number; high: number },\n  ): FeesByLevel {\n    const base = hexToBN(value);\n    const low = base.muln(multipliers.low);\n    const medium = base.muln(multipliers.medium);\n    const high = base.muln(multipliers.high);\n\n    return {\n      low,\n      medium,\n      high,\n    };\n  }\n\n  #getMaxFees(\n    baseFees: Record<GasFeeEstimateLevel, BN>,\n    priorityFees: Record<GasFeeEstimateLevel, BN>,\n  ): FeesByLevel {\n    return {\n      low: baseFees.low.add(priorityFees.low),\n      medium: baseFees.medium.add(priorityFees.medium),\n      high: baseFees.high.add(priorityFees.high),\n    };\n  }\n\n  #feesToString(fees: FeesByLevel) {\n    return Object.values(GasFeeEstimateLevel).map((level) =>\n      fees[level].toString(10),\n    );\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/helpers/GasFeePoller.d.ts b/node_modules/@metamask/transaction-controller/dist/helpers/GasFeePoller.d.ts
new file mode 100644
index 0000000..e7eb32d
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/helpers/GasFeePoller.d.ts
@@ -0,0 +1,31 @@
+/// <reference types="node" />
+import type { GasFeeState } from '@metamask/gas-fee-controller';
+import EventEmitter from 'events';
+import type { GasFeeFlow, TransactionMeta } from '../types';
+/**
+ * Automatically polls and updates suggested gas fees on unapproved transactions.
+ */
+export declare class GasFeePoller {
+    #private;
+    hub: EventEmitter;
+    /**
+     * Constructs a new instance of the GasFeePoller.
+     *
+     * @param options - The options for this instance.
+     * @param options.gasFeeFlows - The gas fee flows to use to obtain suitable gas fees.
+     * @param options.getChainIds - Callback to specify the chain IDs to monitor.
+     * @param options.getEthQuery - Callback to obtain an EthQuery instance.
+     * @param options.getGasFeeControllerEstimates - Callback to obtain the default fee estimates.
+     * @param options.getTransactions - Callback to obtain the transaction data.
+     * @param options.onStateChange - Callback to register a listener for controller state changes.
+     */
+    constructor({ gasFeeFlows, getChainIds, getEthQuery, getGasFeeControllerEstimates, getTransactions, onStateChange, }: {
+        gasFeeFlows: GasFeeFlow[];
+        getChainIds: () => string[];
+        getEthQuery: () => any;
+        getGasFeeControllerEstimates: () => Promise<GasFeeState>;
+        getTransactions: () => TransactionMeta[];
+        onStateChange: (listener: () => void) => void;
+    });
+}
+//# sourceMappingURL=GasFeePoller.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/helpers/GasFeePoller.d.ts.map b/node_modules/@metamask/transaction-controller/dist/helpers/GasFeePoller.d.ts.map
new file mode 100644
index 0000000..f6a5ea5
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/helpers/GasFeePoller.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"GasFeePoller.d.ts","sourceRoot":"","sources":["../../src/helpers/GasFeePoller.ts"],"names":[],"mappings":";AAAA,OAAO,KAAK,EAAE,WAAW,EAAE,MAAM,8BAA8B,CAAC;AAEhE,OAAO,YAAY,MAAM,QAAQ,CAAC;AAIlC,OAAO,KAAK,EAAE,UAAU,EAAqB,eAAe,EAAE,MAAM,UAAU,CAAC;AAO/E;;GAEG;AACH,qBAAa,YAAY;;IACvB,GAAG,EAAE,YAAY,CAAsB;IAgBvC;;;;;;;;;;OAUG;gBACS,EACV,WAAW,EACX,WAAW,EACX,WAAW,EACX,4BAA4B,EAC5B,eAAe,EACf,aAAa,GACd,EAAE;QACD,WAAW,EAAE,UAAU,EAAE,CAAC;QAC1B,WAAW,EAAE,MAAM,MAAM,EAAE,CAAC;QAC5B,WAAW,EAAE,MAAM,GAAG,CAAC;QACvB,4BAA4B,EAAE,MAAM,OAAO,CAAC,WAAW,CAAC,CAAC;QACzD,eAAe,EAAE,MAAM,eAAe,EAAE,CAAC;QACzC,aAAa,EAAE,CAAC,QAAQ,EAAE,MAAM,IAAI,KAAK,IAAI,CAAC;KAC/C;CA+HF"}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/helpers/GasFeePoller.js b/node_modules/@metamask/transaction-controller/dist/helpers/GasFeePoller.js
new file mode 100644
index 0000000..6f287b5
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/helpers/GasFeePoller.js
@@ -0,0 +1,147 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
+    if (kind === "m") throw new TypeError("Private method is not writable");
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
+    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
+};
+var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
+    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
+};
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+var _GasFeePoller_instances, _GasFeePoller_gasFeeFlows, _GasFeePoller_getChainIds, _GasFeePoller_getEthQuery, _GasFeePoller_getGasFeeControllerEstimates, _GasFeePoller_getTransactions, _GasFeePoller_timeout, _GasFeePoller_running, _GasFeePoller_start, _GasFeePoller_stop, _GasFeePoller_onTimeout, _GasFeePoller_updateUnapprovedTransactions, _GasFeePoller_updateTransactionSuggestedFees, _GasFeePoller_getUnapprovedTransactions;
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.GasFeePoller = void 0;
+const utils_1 = require("@metamask/utils");
+const events_1 = __importDefault(require("events"));
+const logger_1 = require("../logger");
+const types_1 = require("../types");
+const gas_flow_1 = require("../utils/gas-flow");
+const log = (0, utils_1.createModuleLogger)(logger_1.projectLogger, 'gas-fee-poller');
+const INTERVAL_MILLISECONDS = 10000;
+/**
+ * Automatically polls and updates suggested gas fees on unapproved transactions.
+ */
+class GasFeePoller {
+    /**
+     * Constructs a new instance of the GasFeePoller.
+     *
+     * @param options - The options for this instance.
+     * @param options.gasFeeFlows - The gas fee flows to use to obtain suitable gas fees.
+     * @param options.getChainIds - Callback to specify the chain IDs to monitor.
+     * @param options.getEthQuery - Callback to obtain an EthQuery instance.
+     * @param options.getGasFeeControllerEstimates - Callback to obtain the default fee estimates.
+     * @param options.getTransactions - Callback to obtain the transaction data.
+     * @param options.onStateChange - Callback to register a listener for controller state changes.
+     */
+    constructor({ gasFeeFlows, getChainIds, getEthQuery, getGasFeeControllerEstimates, getTransactions, onStateChange, }) {
+        _GasFeePoller_instances.add(this);
+        this.hub = new events_1.default();
+        _GasFeePoller_gasFeeFlows.set(this, void 0);
+        _GasFeePoller_getChainIds.set(this, void 0);
+        _GasFeePoller_getEthQuery.set(this, void 0);
+        _GasFeePoller_getGasFeeControllerEstimates.set(this, void 0);
+        _GasFeePoller_getTransactions.set(this, void 0);
+        _GasFeePoller_timeout.set(this, void 0);
+        _GasFeePoller_running.set(this, false);
+        __classPrivateFieldSet(this, _GasFeePoller_gasFeeFlows, gasFeeFlows, "f");
+        __classPrivateFieldSet(this, _GasFeePoller_getChainIds, getChainIds, "f");
+        __classPrivateFieldSet(this, _GasFeePoller_getEthQuery, getEthQuery, "f");
+        __classPrivateFieldSet(this, _GasFeePoller_getGasFeeControllerEstimates, getGasFeeControllerEstimates, "f");
+        __classPrivateFieldSet(this, _GasFeePoller_getTransactions, getTransactions, "f");
+        onStateChange(() => {
+            const unapprovedTransactions = __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_getUnapprovedTransactions).call(this);
+            if (unapprovedTransactions.length) {
+                __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_start).call(this);
+            }
+            else {
+                __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_stop).call(this);
+            }
+        });
+    }
+}
+exports.GasFeePoller = GasFeePoller;
+_GasFeePoller_gasFeeFlows = new WeakMap(), _GasFeePoller_getChainIds = new WeakMap(), _GasFeePoller_getEthQuery = new WeakMap(), _GasFeePoller_getGasFeeControllerEstimates = new WeakMap(), _GasFeePoller_getTransactions = new WeakMap(), _GasFeePoller_timeout = new WeakMap(), _GasFeePoller_running = new WeakMap(), _GasFeePoller_instances = new WeakSet(), _GasFeePoller_start = function _GasFeePoller_start() {
+    if (__classPrivateFieldGet(this, _GasFeePoller_running, "f")) {
+        return;
+    }
+    // Intentionally not awaiting since this starts the timeout chain.
+    // eslint-disable-next-line @typescript-eslint/no-floating-promises
+    __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_onTimeout).call(this);
+    __classPrivateFieldSet(this, _GasFeePoller_running, true, "f");
+    log('Started polling');
+}, _GasFeePoller_stop = function _GasFeePoller_stop() {
+    if (!__classPrivateFieldGet(this, _GasFeePoller_running, "f")) {
+        return;
+    }
+    clearTimeout(__classPrivateFieldGet(this, _GasFeePoller_timeout, "f"));
+    __classPrivateFieldSet(this, _GasFeePoller_timeout, undefined, "f");
+    __classPrivateFieldSet(this, _GasFeePoller_running, false, "f");
+    log('Stopped polling');
+}, _GasFeePoller_onTimeout = function _GasFeePoller_onTimeout() {
+    return __awaiter(this, void 0, void 0, function* () {
+        yield __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_updateUnapprovedTransactions).call(this);
+        // eslint-disable-next-line @typescript-eslint/no-misused-promises
+        __classPrivateFieldSet(this, _GasFeePoller_timeout, setTimeout(() => __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_onTimeout).call(this), INTERVAL_MILLISECONDS), "f");
+    });
+}, _GasFeePoller_updateUnapprovedTransactions = function _GasFeePoller_updateUnapprovedTransactions() {
+    return __awaiter(this, void 0, void 0, function* () {
+        const unapprovedTransactions = __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_getUnapprovedTransactions).call(this);
+        log('Found unapproved transactions', {
+            count: unapprovedTransactions.length,
+        });
+        const ethQuery = __classPrivateFieldGet(this, _GasFeePoller_getEthQuery, "f").call(this);
+        yield Promise.all(unapprovedTransactions.map((tx) => __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_updateTransactionSuggestedFees).call(this, tx, ethQuery)));
+    });
+}, _GasFeePoller_updateTransactionSuggestedFees = function _GasFeePoller_updateTransactionSuggestedFees(transactionMeta, ethQuery) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const gasFeeFlow = (0, gas_flow_1.getGasFeeFlow)(transactionMeta, __classPrivateFieldGet(this, _GasFeePoller_gasFeeFlows, "f"));
+        if (!gasFeeFlow) {
+            log('No gas fee flow found', transactionMeta.id);
+        }
+        else {
+            log('Found gas fee flow', gasFeeFlow.constructor.name, transactionMeta.id);
+        }
+        const request = {
+            ethQuery,
+            getGasFeeControllerEstimates: __classPrivateFieldGet(this, _GasFeePoller_getGasFeeControllerEstimates, "f"),
+            transactionMeta,
+        };
+        if (gasFeeFlow) {
+            try {
+                const response = yield gasFeeFlow.getGasFees(request);
+                transactionMeta.gasFeeEstimates = response.estimates;
+            }
+            catch (error) {
+                log('Failed to get suggested gas fees', transactionMeta.id, error);
+            }
+        }
+        if (!gasFeeFlow && transactionMeta.gasFeeEstimatesLoaded) {
+            return;
+        }
+        transactionMeta.gasFeeEstimatesLoaded = true;
+        this.hub.emit('transaction-updated', transactionMeta, 'GasFeePoller - Suggested gas fees updated');
+        log('Updated suggested gas fees', {
+            gasFeeEstimates: transactionMeta.gasFeeEstimates,
+            transaction: transactionMeta.id,
+        });
+    });
+}, _GasFeePoller_getUnapprovedTransactions = function _GasFeePoller_getUnapprovedTransactions() {
+    const chainIds = __classPrivateFieldGet(this, _GasFeePoller_getChainIds, "f").call(this);
+    return __classPrivateFieldGet(this, _GasFeePoller_getTransactions, "f").call(this).filter((tx) => chainIds.includes(tx.chainId) &&
+        tx.status === types_1.TransactionStatus.unapproved);
+};
+//# sourceMappingURL=GasFeePoller.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/helpers/GasFeePoller.js.map b/node_modules/@metamask/transaction-controller/dist/helpers/GasFeePoller.js.map
new file mode 100644
index 0000000..1b85190
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/helpers/GasFeePoller.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"GasFeePoller.js","sourceRoot":"","sources":["../../src/helpers/GasFeePoller.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,2CAAqD;AACrD,oDAAkC;AAElC,sCAA0C;AAC1C,oCAA6C;AAE7C,gDAAkD;AAElD,MAAM,GAAG,GAAG,IAAA,0BAAkB,EAAC,sBAAa,EAAE,gBAAgB,CAAC,CAAC;AAEhE,MAAM,qBAAqB,GAAG,KAAK,CAAC;AAEpC;;GAEG;AACH,MAAa,YAAY;IAiBvB;;;;;;;;;;OAUG;IACH,YAAY,EACV,WAAW,EACX,WAAW,EACX,WAAW,EACX,4BAA4B,EAC5B,eAAe,EACf,aAAa,GAQd;;QAzCD,QAAG,GAAiB,IAAI,gBAAY,EAAE,CAAC;QAEvC,4CAA2B;QAE3B,4CAA6B;QAE7B,4CAAwB;QAExB,6DAA0D;QAE1D,gDAA0C;QAE1C,wCAAc;QAEd,gCAAW,KAAK,EAAC;QA4Bf,uBAAA,IAAI,6BAAgB,WAAW,MAAA,CAAC;QAChC,uBAAA,IAAI,6BAAgB,WAAW,MAAA,CAAC;QAChC,uBAAA,IAAI,6BAAgB,WAAW,MAAA,CAAC;QAChC,uBAAA,IAAI,8CAAiC,4BAA4B,MAAA,CAAC;QAClE,uBAAA,IAAI,iCAAoB,eAAe,MAAA,CAAC;QAExC,aAAa,CAAC,GAAG,EAAE;YACjB,MAAM,sBAAsB,GAAG,uBAAA,IAAI,wEAA2B,MAA/B,IAAI,CAA6B,CAAC;YAEjE,IAAI,sBAAsB,CAAC,MAAM,EAAE;gBACjC,uBAAA,IAAI,oDAAO,MAAX,IAAI,CAAS,CAAC;aACf;iBAAM;gBACL,uBAAA,IAAI,mDAAM,MAAV,IAAI,CAAQ,CAAC;aACd;QACH,CAAC,CAAC,CAAC;IACL,CAAC;CA+GF;AAzKD,oCAyKC;;IA5GG,IAAI,uBAAA,IAAI,6BAAS,EAAE;QACjB,OAAO;KACR;IAED,kEAAkE;IAClE,mEAAmE;IACnE,uBAAA,IAAI,wDAAW,MAAf,IAAI,CAAa,CAAC;IAElB,uBAAA,IAAI,yBAAY,IAAI,MAAA,CAAC;IAErB,GAAG,CAAC,iBAAiB,CAAC,CAAC;AACzB,CAAC;IAGC,IAAI,CAAC,uBAAA,IAAI,6BAAS,EAAE;QAClB,OAAO;KACR;IAED,YAAY,CAAC,uBAAA,IAAI,6BAAS,CAAC,CAAC;IAE5B,uBAAA,IAAI,yBAAY,SAAS,MAAA,CAAC;IAC1B,uBAAA,IAAI,yBAAY,KAAK,MAAA,CAAC;IAEtB,GAAG,CAAC,iBAAiB,CAAC,CAAC;AACzB,CAAC;;QAGC,MAAM,uBAAA,IAAI,2EAA8B,MAAlC,IAAI,CAAgC,CAAC;QAE3C,kEAAkE;QAClE,uBAAA,IAAI,yBAAY,UAAU,CAAC,GAAG,EAAE,CAAC,uBAAA,IAAI,wDAAW,MAAf,IAAI,CAAa,EAAE,qBAAqB,CAAC,MAAA,CAAC;IAC7E,CAAC;;;QAGC,MAAM,sBAAsB,GAAG,uBAAA,IAAI,wEAA2B,MAA/B,IAAI,CAA6B,CAAC;QAEjE,GAAG,CAAC,+BAA+B,EAAE;YACnC,KAAK,EAAE,sBAAsB,CAAC,MAAM;SACrC,CAAC,CAAC;QAEH,MAAM,QAAQ,GAAG,uBAAA,IAAI,iCAAa,MAAjB,IAAI,CAAe,CAAC;QAErC,MAAM,OAAO,CAAC,GAAG,CACf,sBAAsB,CAAC,GAAG,CAAC,CAAC,EAAE,EAAE,EAAE,CAChC,uBAAA,IAAI,6EAAgC,MAApC,IAAI,EAAiC,EAAE,EAAE,QAAQ,CAAC,CACnD,CACF,CAAC;IACJ,CAAC;wGAGC,eAAgC,EAChC,QAAa;;QAEb,MAAM,UAAU,GAAG,IAAA,wBAAa,EAAC,eAAe,EAAE,uBAAA,IAAI,iCAAa,CAAC,CAAC;QAErE,IAAI,CAAC,UAAU,EAAE;YACf,GAAG,CAAC,uBAAuB,EAAE,eAAe,CAAC,EAAE,CAAC,CAAC;SAClD;aAAM;YACL,GAAG,CACD,oBAAoB,EACpB,UAAU,CAAC,WAAW,CAAC,IAAI,EAC3B,eAAe,CAAC,EAAE,CACnB,CAAC;SACH;QAED,MAAM,OAAO,GAAsB;YACjC,QAAQ;YACR,4BAA4B,EAAE,uBAAA,IAAI,kDAA8B;YAChE,eAAe;SAChB,CAAC;QAEF,IAAI,UAAU,EAAE;YACd,IAAI;gBACF,MAAM,QAAQ,GAAG,MAAM,UAAU,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;gBAEtD,eAAe,CAAC,eAAe,GAAG,QAAQ,CAAC,SAAS,CAAC;aACtD;YAAC,OAAO,KAAK,EAAE;gBACd,GAAG,CAAC,kCAAkC,EAAE,eAAe,CAAC,EAAE,EAAE,KAAK,CAAC,CAAC;aACpE;SACF;QAED,IAAI,CAAC,UAAU,IAAI,eAAe,CAAC,qBAAqB,EAAE;YACxD,OAAO;SACR;QAED,eAAe,CAAC,qBAAqB,GAAG,IAAI,CAAC;QAE7C,IAAI,CAAC,GAAG,CAAC,IAAI,CACX,qBAAqB,EACrB,eAAe,EACf,2CAA2C,CAC5C,CAAC;QAEF,GAAG,CAAC,4BAA4B,EAAE;YAChC,eAAe,EAAE,eAAe,CAAC,eAAe;YAChD,WAAW,EAAE,eAAe,CAAC,EAAE;SAChC,CAAC,CAAC;IACL,CAAC;;IAGC,MAAM,QAAQ,GAAG,uBAAA,IAAI,iCAAa,MAAjB,IAAI,CAAe,CAAC;IAErC,OAAO,uBAAA,IAAI,qCAAiB,MAArB,IAAI,CAAmB,CAAC,MAAM,CACnC,CAAC,EAAE,EAAE,EAAE,CACL,QAAQ,CAAC,QAAQ,CAAC,EAAE,CAAC,OAAiB,CAAC;QACvC,EAAE,CAAC,MAAM,KAAK,yBAAiB,CAAC,UAAU,CAC7C,CAAC;AACJ,CAAC","sourcesContent":["import type { GasFeeState } from '@metamask/gas-fee-controller';\nimport { createModuleLogger } from '@metamask/utils';\nimport EventEmitter from 'events';\n\nimport { projectLogger } from '../logger';\nimport { TransactionStatus } from '../types';\nimport type { GasFeeFlow, GasFeeFlowRequest, TransactionMeta } from '../types';\nimport { getGasFeeFlow } from '../utils/gas-flow';\n\nconst log = createModuleLogger(projectLogger, 'gas-fee-poller');\n\nconst INTERVAL_MILLISECONDS = 10000;\n\n/**\n * Automatically polls and updates suggested gas fees on unapproved transactions.\n */\nexport class GasFeePoller {\n  hub: EventEmitter = new EventEmitter();\n\n  #gasFeeFlows: GasFeeFlow[];\n\n  #getChainIds: () => string[];\n\n  #getEthQuery: () => any;\n\n  #getGasFeeControllerEstimates: () => Promise<GasFeeState>;\n\n  #getTransactions: () => TransactionMeta[];\n\n  #timeout: any;\n\n  #running = false;\n\n  /**\n   * Constructs a new instance of the GasFeePoller.\n   *\n   * @param options - The options for this instance.\n   * @param options.gasFeeFlows - The gas fee flows to use to obtain suitable gas fees.\n   * @param options.getChainIds - Callback to specify the chain IDs to monitor.\n   * @param options.getEthQuery - Callback to obtain an EthQuery instance.\n   * @param options.getGasFeeControllerEstimates - Callback to obtain the default fee estimates.\n   * @param options.getTransactions - Callback to obtain the transaction data.\n   * @param options.onStateChange - Callback to register a listener for controller state changes.\n   */\n  constructor({\n    gasFeeFlows,\n    getChainIds,\n    getEthQuery,\n    getGasFeeControllerEstimates,\n    getTransactions,\n    onStateChange,\n  }: {\n    gasFeeFlows: GasFeeFlow[];\n    getChainIds: () => string[];\n    getEthQuery: () => any;\n    getGasFeeControllerEstimates: () => Promise<GasFeeState>;\n    getTransactions: () => TransactionMeta[];\n    onStateChange: (listener: () => void) => void;\n  }) {\n    this.#gasFeeFlows = gasFeeFlows;\n    this.#getChainIds = getChainIds;\n    this.#getEthQuery = getEthQuery;\n    this.#getGasFeeControllerEstimates = getGasFeeControllerEstimates;\n    this.#getTransactions = getTransactions;\n\n    onStateChange(() => {\n      const unapprovedTransactions = this.#getUnapprovedTransactions();\n\n      if (unapprovedTransactions.length) {\n        this.#start();\n      } else {\n        this.#stop();\n      }\n    });\n  }\n\n  #start() {\n    if (this.#running) {\n      return;\n    }\n\n    // Intentionally not awaiting since this starts the timeout chain.\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this.#onTimeout();\n\n    this.#running = true;\n\n    log('Started polling');\n  }\n\n  #stop() {\n    if (!this.#running) {\n      return;\n    }\n\n    clearTimeout(this.#timeout);\n\n    this.#timeout = undefined;\n    this.#running = false;\n\n    log('Stopped polling');\n  }\n\n  async #onTimeout() {\n    await this.#updateUnapprovedTransactions();\n\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    this.#timeout = setTimeout(() => this.#onTimeout(), INTERVAL_MILLISECONDS);\n  }\n\n  async #updateUnapprovedTransactions() {\n    const unapprovedTransactions = this.#getUnapprovedTransactions();\n\n    log('Found unapproved transactions', {\n      count: unapprovedTransactions.length,\n    });\n\n    const ethQuery = this.#getEthQuery();\n\n    await Promise.all(\n      unapprovedTransactions.map((tx) =>\n        this.#updateTransactionSuggestedFees(tx, ethQuery),\n      ),\n    );\n  }\n\n  async #updateTransactionSuggestedFees(\n    transactionMeta: TransactionMeta,\n    ethQuery: any,\n  ) {\n    const gasFeeFlow = getGasFeeFlow(transactionMeta, this.#gasFeeFlows);\n\n    if (!gasFeeFlow) {\n      log('No gas fee flow found', transactionMeta.id);\n    } else {\n      log(\n        'Found gas fee flow',\n        gasFeeFlow.constructor.name,\n        transactionMeta.id,\n      );\n    }\n\n    const request: GasFeeFlowRequest = {\n      ethQuery,\n      getGasFeeControllerEstimates: this.#getGasFeeControllerEstimates,\n      transactionMeta,\n    };\n\n    if (gasFeeFlow) {\n      try {\n        const response = await gasFeeFlow.getGasFees(request);\n\n        transactionMeta.gasFeeEstimates = response.estimates;\n      } catch (error) {\n        log('Failed to get suggested gas fees', transactionMeta.id, error);\n      }\n    }\n\n    if (!gasFeeFlow && transactionMeta.gasFeeEstimatesLoaded) {\n      return;\n    }\n\n    transactionMeta.gasFeeEstimatesLoaded = true;\n\n    this.hub.emit(\n      'transaction-updated',\n      transactionMeta,\n      'GasFeePoller - Suggested gas fees updated',\n    );\n\n    log('Updated suggested gas fees', {\n      gasFeeEstimates: transactionMeta.gasFeeEstimates,\n      transaction: transactionMeta.id,\n    });\n  }\n\n  #getUnapprovedTransactions() {\n    const chainIds = this.#getChainIds();\n\n    return this.#getTransactions().filter(\n      (tx) =>\n        chainIds.includes(tx.chainId as string) &&\n        tx.status === TransactionStatus.unapproved,\n    );\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/index.d.ts b/node_modules/@metamask/transaction-controller/dist/index.d.ts
index 9998101..b7c9355 100644
--- a/node_modules/@metamask/transaction-controller/dist/index.d.ts
+++ b/node_modules/@metamask/transaction-controller/dist/index.d.ts
@@ -1,5 +1,5 @@
 export * from './TransactionController';
-export type { EtherscanTransactionMeta } from './etherscan';
-export { isEIP1559Transaction } from './utils';
+export { isEIP1559Transaction, normalizeTransactionParams } from './utils';
 export * from './types';
+export { mergeGasFeeEstimates, getGasFeeFlow } from './utils/gas-flow';
 //# sourceMappingURL=index.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/index.d.ts.map b/node_modules/@metamask/transaction-controller/dist/index.d.ts.map
deleted file mode 100644
index 6b85676..0000000
--- a/node_modules/@metamask/transaction-controller/dist/index.d.ts.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"AAAA,cAAc,yBAAyB,CAAC;AACxC,YAAY,EAAE,wBAAwB,EAAE,MAAM,aAAa,CAAC;AAC5D,OAAO,EAAE,oBAAoB,EAAE,MAAM,SAAS,CAAC;AAC/C,cAAc,SAAS,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/index.js b/node_modules/@metamask/transaction-controller/dist/index.js
index 602f51c..0818eb8 100644
--- a/node_modules/@metamask/transaction-controller/dist/index.js
+++ b/node_modules/@metamask/transaction-controller/dist/index.js
@@ -14,9 +14,13 @@ var __exportStar = (this && this.__exportStar) || function(m, exports) {
     for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
 };
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.isEIP1559Transaction = void 0;
+exports.getGasFeeFlow = exports.mergeGasFeeEstimates = exports.normalizeTransactionParams = exports.isEIP1559Transaction = void 0;
 __exportStar(require("./TransactionController"), exports);
 var utils_1 = require("./utils");
 Object.defineProperty(exports, "isEIP1559Transaction", { enumerable: true, get: function () { return utils_1.isEIP1559Transaction; } });
+Object.defineProperty(exports, "normalizeTransactionParams", { enumerable: true, get: function () { return utils_1.normalizeTransactionParams; } });
 __exportStar(require("./types"), exports);
+var gas_flow_1 = require("./utils/gas-flow");
+Object.defineProperty(exports, "mergeGasFeeEstimates", { enumerable: true, get: function () { return gas_flow_1.mergeGasFeeEstimates; } });
+Object.defineProperty(exports, "getGasFeeFlow", { enumerable: true, get: function () { return gas_flow_1.getGasFeeFlow; } });
 //# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/index.js.map b/node_modules/@metamask/transaction-controller/dist/index.js.map
deleted file mode 100644
index c4fa911..0000000
--- a/node_modules/@metamask/transaction-controller/dist/index.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAAA,0DAAwC;AAExC,iCAA+C;AAAtC,6GAAA,oBAAoB,OAAA;AAC7B,0CAAwB","sourcesContent":["export * from './TransactionController';\nexport type { EtherscanTransactionMeta } from './etherscan';\nexport { isEIP1559Transaction } from './utils';\nexport * from './types';\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/logger.d.ts b/node_modules/@metamask/transaction-controller/dist/logger.d.ts
new file mode 100644
index 0000000..43ad63f
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/logger.d.ts
@@ -0,0 +1,6 @@
+/// <reference types="debug" />
+import { createModuleLogger } from '@metamask/utils';
+export declare const projectLogger: import("debug").Debugger;
+export declare const incomingTransactionsLogger: import("debug").Debugger;
+export { createModuleLogger };
+//# sourceMappingURL=logger.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/logger.js b/node_modules/@metamask/transaction-controller/dist/logger.js
new file mode 100644
index 0000000..bb55b17
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/logger.js
@@ -0,0 +1,9 @@
+"use strict";
+/* istanbul ignore file */
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.createModuleLogger = exports.incomingTransactionsLogger = exports.projectLogger = void 0;
+const utils_1 = require("@metamask/utils");
+Object.defineProperty(exports, "createModuleLogger", { enumerable: true, get: function () { return utils_1.createModuleLogger; } });
+exports.projectLogger = (0, utils_1.createProjectLogger)('transaction-controller');
+exports.incomingTransactionsLogger = (0, utils_1.createModuleLogger)(exports.projectLogger, 'incoming-transactions');
+//# sourceMappingURL=logger.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/swaps.d.ts b/node_modules/@metamask/transaction-controller/dist/swaps.d.ts
new file mode 100644
index 0000000..90ca29c
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/swaps.d.ts
@@ -0,0 +1,59 @@
+import type { TransactionMeta } from './types';
+import { TransactionType } from './types';
+/**
+ * Interval in milliseconds between checks of post transaction balance
+ */
+export declare const UPDATE_POST_TX_BALANCE_TIMEOUT = 5000;
+/**
+ * Retry attempts for checking post transaction balance
+ */
+export declare const UPDATE_POST_TX_BALANCE_ATTEMPTS = 6;
+/**
+ * An address that the metaswap-api recognizes as the default token for the current network, in place of the token address that ERC-20 tokens have
+ */
+export declare const DEFAULT_TOKEN_ADDRESS = "0x0000000000000000000000000000000000000000";
+interface SwapsTokenObject {
+    /**
+     * The name for the network
+     */
+    name: string;
+    /**
+     * An address that the metaswap-api recognizes as the default token
+     */
+    address: string;
+    /**
+     * Number of digits after decimal point
+     */
+    decimals: number;
+}
+export declare const SWAPS_CHAINID_DEFAULT_TOKEN_MAP: {
+    readonly "0x1": SwapsTokenObject;
+    readonly "0x539": SwapsTokenObject;
+    readonly "0x38": SwapsTokenObject;
+    readonly "0x89": SwapsTokenObject;
+    readonly "0x5": SwapsTokenObject;
+    readonly "0xa86a": SwapsTokenObject;
+    readonly "0xa": SwapsTokenObject;
+    readonly "0xa4b1": SwapsTokenObject;
+    readonly "0x144": SwapsTokenObject;
+};
+export declare const SWAP_TRANSACTION_TYPES: TransactionType[];
+/**
+ * Attempts to update the post transaction balance of the provided transaction
+ *
+ * @param transactionMeta - Transaction meta object to update
+ * @param updatePostTransactionBalanceRequest - Dependency bag
+ * @param updatePostTransactionBalanceRequest.ethQuery - EthQuery object
+ * @param updatePostTransactionBalanceRequest.getTransaction - Reading function for the latest transaction state
+ * @param updatePostTransactionBalanceRequest.updateTransaction - Updating transaction function
+ */
+export declare function updatePostTransactionBalance(transactionMeta: TransactionMeta, { ethQuery, getTransaction, updateTransaction, }: {
+    ethQuery: any;
+    getTransaction: (transactionId: string) => TransactionMeta | undefined;
+    updateTransaction: (transactionMeta: TransactionMeta, note: string) => void;
+}): Promise<{
+    updatedTransactionMeta: TransactionMeta;
+    approvalTransactionMeta?: TransactionMeta;
+}>;
+export {};
+//# sourceMappingURL=swaps.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/swaps.js b/node_modules/@metamask/transaction-controller/dist/swaps.js
new file mode 100644
index 0000000..8842a7f
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/swaps.js
@@ -0,0 +1,153 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.updatePostTransactionBalance = exports.SWAP_TRANSACTION_TYPES = exports.SWAPS_CHAINID_DEFAULT_TOKEN_MAP = exports.DEFAULT_TOKEN_ADDRESS = exports.UPDATE_POST_TX_BALANCE_ATTEMPTS = exports.UPDATE_POST_TX_BALANCE_TIMEOUT = void 0;
+/* eslint-disable jsdoc/require-returns */
+const controller_utils_1 = require("@metamask/controller-utils");
+const constants_1 = require("./constants");
+const logger_1 = require("./logger");
+const types_1 = require("./types");
+const log = (0, logger_1.createModuleLogger)(logger_1.projectLogger, 'swaps');
+/**
+ * Interval in milliseconds between checks of post transaction balance
+ */
+exports.UPDATE_POST_TX_BALANCE_TIMEOUT = 5000;
+/**
+ * Retry attempts for checking post transaction balance
+ */
+exports.UPDATE_POST_TX_BALANCE_ATTEMPTS = 6;
+const SWAPS_TESTNET_CHAIN_ID = '0x539';
+/**
+ * An address that the metaswap-api recognizes as the default token for the current network, in place of the token address that ERC-20 tokens have
+ */
+exports.DEFAULT_TOKEN_ADDRESS = '0x0000000000000000000000000000000000000000';
+const ETH_SWAPS_TOKEN_OBJECT = {
+    name: 'Ether',
+    address: exports.DEFAULT_TOKEN_ADDRESS,
+    decimals: 18,
+};
+const BNB_SWAPS_TOKEN_OBJECT = {
+    name: 'Binance Coin',
+    address: exports.DEFAULT_TOKEN_ADDRESS,
+    decimals: 18,
+};
+const MATIC_SWAPS_TOKEN_OBJECT = {
+    name: 'Matic',
+    address: exports.DEFAULT_TOKEN_ADDRESS,
+    decimals: 18,
+};
+const AVAX_SWAPS_TOKEN_OBJECT = {
+    name: 'Avalanche',
+    address: exports.DEFAULT_TOKEN_ADDRESS,
+    decimals: 18,
+};
+const TEST_ETH_SWAPS_TOKEN_OBJECT = {
+    name: 'Test Ether',
+    address: exports.DEFAULT_TOKEN_ADDRESS,
+    decimals: 18,
+};
+const GOERLI_SWAPS_TOKEN_OBJECT = {
+    name: 'Ether',
+    address: exports.DEFAULT_TOKEN_ADDRESS,
+    decimals: 18,
+};
+const ARBITRUM_SWAPS_TOKEN_OBJECT = Object.assign({}, ETH_SWAPS_TOKEN_OBJECT);
+const OPTIMISM_SWAPS_TOKEN_OBJECT = Object.assign({}, ETH_SWAPS_TOKEN_OBJECT);
+const ZKSYNC_ERA_SWAPS_TOKEN_OBJECT = Object.assign({}, ETH_SWAPS_TOKEN_OBJECT);
+exports.SWAPS_CHAINID_DEFAULT_TOKEN_MAP = {
+    [constants_1.CHAIN_IDS.MAINNET]: ETH_SWAPS_TOKEN_OBJECT,
+    [SWAPS_TESTNET_CHAIN_ID]: TEST_ETH_SWAPS_TOKEN_OBJECT,
+    [constants_1.CHAIN_IDS.BSC]: BNB_SWAPS_TOKEN_OBJECT,
+    [constants_1.CHAIN_IDS.POLYGON]: MATIC_SWAPS_TOKEN_OBJECT,
+    [constants_1.CHAIN_IDS.GOERLI]: GOERLI_SWAPS_TOKEN_OBJECT,
+    [constants_1.CHAIN_IDS.AVALANCHE]: AVAX_SWAPS_TOKEN_OBJECT,
+    [constants_1.CHAIN_IDS.OPTIMISM]: OPTIMISM_SWAPS_TOKEN_OBJECT,
+    [constants_1.CHAIN_IDS.ARBITRUM]: ARBITRUM_SWAPS_TOKEN_OBJECT,
+    [constants_1.CHAIN_IDS.ZKSYNC_ERA]: ZKSYNC_ERA_SWAPS_TOKEN_OBJECT,
+};
+exports.SWAP_TRANSACTION_TYPES = [
+    types_1.TransactionType.swap,
+    types_1.TransactionType.swapApproval,
+];
+/**
+ * Attempts to update the post transaction balance of the provided transaction
+ *
+ * @param transactionMeta - Transaction meta object to update
+ * @param updatePostTransactionBalanceRequest - Dependency bag
+ * @param updatePostTransactionBalanceRequest.ethQuery - EthQuery object
+ * @param updatePostTransactionBalanceRequest.getTransaction - Reading function for the latest transaction state
+ * @param updatePostTransactionBalanceRequest.updateTransaction - Updating transaction function
+ */
+function updatePostTransactionBalance(transactionMeta, { ethQuery, getTransaction, updateTransaction, }) {
+    return __awaiter(this, void 0, void 0, function* () {
+        console.log('Updating post transaction balance', transactionMeta.id);
+        const transactionId = transactionMeta.id;
+        let latestTransactionMeta, approvalTransactionMeta;
+        for (let i = 0; i < exports.UPDATE_POST_TX_BALANCE_ATTEMPTS; i++) {
+            console.log('Querying balance', { attempt: i });
+            const postTransactionBalance = yield (0, controller_utils_1.query)(ethQuery, 'getBalance', [
+                transactionMeta.transaction.from,
+            ]);
+            latestTransactionMeta = getTransaction(transactionId);
+            approvalTransactionMeta = latestTransactionMeta.approvalTxId
+                ? getTransaction(latestTransactionMeta.approvalTxId)
+                : undefined;
+            latestTransactionMeta.postTxBalance = postTransactionBalance.toString(16);
+            const isDefaultTokenAddress = isSwapsDefaultTokenAddress(transactionMeta.destinationTokenAddress, transactionMeta.chainId);
+            if (!isDefaultTokenAddress ||
+                transactionMeta.preTxBalance !== latestTransactionMeta.postTxBalance) {
+                log('Finishing post balance update', {
+                    isDefaultTokenAddress,
+                    preTxBalance: transactionMeta.preTxBalance,
+                    postTxBalance: latestTransactionMeta.postTxBalance,
+                });
+                break;
+            }
+            log('Waiting for balance to update', {
+                delay: exports.UPDATE_POST_TX_BALANCE_TIMEOUT,
+            });
+            yield sleep(exports.UPDATE_POST_TX_BALANCE_TIMEOUT);
+        }
+        updateTransaction(latestTransactionMeta, 'TransactionController#updatePostTransactionBalance - Add post transaction balance');
+        log('Completed post balance update', latestTransactionMeta === null || latestTransactionMeta === void 0 ? void 0 : latestTransactionMeta.postTxBalance);
+        return {
+            updatedTransactionMeta: latestTransactionMeta,
+            approvalTransactionMeta,
+        };
+    });
+}
+exports.updatePostTransactionBalance = updatePostTransactionBalance;
+/**
+ * Checks whether the provided address is strictly equal to the address for
+ * the default swaps token of the provided chain.
+ *
+ * @param address - The string to compare to the default token address
+ * @param chainId - The hex encoded chain ID of the default swaps token to check
+ * @returns Whether the address is the provided chain's default token address
+ */
+function isSwapsDefaultTokenAddress(address, chainId) {
+    var _a;
+    if (!address || !chainId) {
+        return false;
+    }
+    return (address ===
+        ((_a = exports.SWAPS_CHAINID_DEFAULT_TOKEN_MAP[chainId]) === null || _a === void 0 ? void 0 : _a.address));
+}
+/**
+ * Sleeps for the provided number of milliseconds
+ *
+ * @param ms - Number of milliseconds to sleep
+ * @returns Promise that resolves after the provided number of milliseconds
+ */
+function sleep(ms) {
+    return new Promise((resolve) => setTimeout(resolve, ms));
+}
+//# sourceMappingURL=swaps.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/types.d.ts b/node_modules/@metamask/transaction-controller/dist/types.d.ts
index 924bc33..e92ae23 100644
--- a/node_modules/@metamask/transaction-controller/dist/types.d.ts
+++ b/node_modules/@metamask/transaction-controller/dist/types.d.ts
@@ -1,4 +1,4 @@
-import type { NetworkType } from '@metamask/controller-utils';
+import type { GasFeeState } from '@metamask/gas-fee-controller';
 import type { Hex } from '@metamask/utils';
 /**
  * @type TransactionMeta
@@ -32,7 +32,7 @@ declare type TransactionMetaBase = {
     };
     id: string;
     networkID?: string;
-    chainId?: Hex;
+    chainId: Hex;
     origin?: string;
     rawTransaction?: string;
     time: number;
@@ -42,6 +42,73 @@ declare type TransactionMetaBase = {
     blockNumber?: string;
     deviceConfirmedOn?: WalletDevice;
     verifiedOnBlockchain?: boolean;
+    /** Alternate EIP-1559 gas fee estimates for multiple priority levels. */
+    gasFeeEstimates?: GasFeeEstimates;
+    /** Whether the gas fee estimates have been checked at least once. */
+    gasFeeEstimatesLoaded?: boolean;
+    /**
+     * Response from security validator.
+     */
+    securityAlertResponse?: SecurityAlertResponse;
+    txReceipt?: TransactionReceipt;
+    type?: TransactionType;
+    replacedBy?: string;
+    replacedById?: string;
+    /**
+     * ID of the transaction that approved the swap token transfer.
+     */
+    approvalTxId?: string;
+    /**
+     * Account transaction balance after swap.
+     */
+    postTxBalance?: string;
+    /**
+     * Account transaction balance before swap.
+     */
+    preTxBalance?: string;
+    /**
+     * The address of the token being received of swap transaction.
+     */
+    destinationTokenAddress?: string;
+    /**
+     * If the gas estimation fails, an object containing error and block information.
+     */
+    simulationFails?: {
+        reason?: string;
+        errorKey?: string;
+        debug: {
+            blockNumber?: string;
+            blockGasLimit?: string;
+        };
+    };
+    /**
+     * The symbol of the token being swapped.
+     */
+    sourceTokenSymbol?: string;
+    /**
+     * The decimals of the token being received of swap transaction.
+     */
+    destinationTokenDecimals?: number;
+    /**
+     * The symbol of the token being received with swap.
+     */
+    destinationTokenSymbol?: string;
+    /**
+     * The metadata of the swap transaction.
+     */
+    swapMetaData?: Record<string, any>;
+    /**
+     * The value of the token being swapped.
+     */
+    swapTokenValue?: string;
+    /**
+     * Estimated base fee for this transaction.
+     */
+    estimatedBaseFee?: string;
+    /**
+     * Base fee of the block as a hex value, introduced in EIP-1559.
+     */
+    baseFeePerGas?: Hex;
 };
 /**
  * The status of the transaction. Each status represents the state of the transaction internally
@@ -50,8 +117,10 @@ declare type TransactionMetaBase = {
  */
 export declare enum TransactionStatus {
     approved = "approved",
+    /** @deprecated Determined by the clients using the transaction type. No longer used. */
     cancelled = "cancelled",
     confirmed = "confirmed",
+    dropped = "dropped",
     failed = "failed",
     rejected = "rejected",
     signed = "signed",
@@ -94,6 +163,7 @@ export interface Transaction {
     maxPriorityFeePerGas?: string;
     estimatedBaseFee?: string;
     estimateGasError?: string;
+    type?: string;
 }
 /**
  * The configuration required to fetch transaction data from a RemoteTransactionSource.
@@ -118,22 +188,278 @@ export interface RemoteTransactionSourceRequest {
     /**
      * Block number to start fetching transactions from.
      */
-    fromBlock?: string;
+    fromBlock?: number;
     /**
      * Maximum number of transactions to retrieve.
      */
-    limit: number;
-    /**
-     * The type of the current network.
-     */
-    networkType: NetworkType;
+    limit?: number;
 }
 /**
  * An object capable of fetching transaction data from a remote source.
  * Used by the IncomingTransactionHelper to retrieve remote transaction data.
  */
 export interface RemoteTransactionSource {
+    isSupportedNetwork: (chainId: string, networkId: string) => boolean;
     fetchTransactions: (request: RemoteTransactionSourceRequest) => Promise<TransactionMeta[]>;
 }
+export declare type SecurityAlertResponse = {
+    reason: string;
+    features?: string[];
+    result_type: string;
+    providerRequestsCount?: Record<string, number>;
+};
+/**
+ * Data concerning a successfully submitted transaction.
+ * Used for debugging purposes.
+ */
+export declare type SubmitHistoryEntry = {
+    /** The chain ID of the transaction as a hexadecimal string. */
+    chainId?: Hex;
+    /** The hash of the transaction returned from the RPC provider. */
+    hash: string;
+    /** True if the entry was generated using the migration and existing transaction metadata. */
+    migration?: boolean;
+    /** The type of the network where the transaction was submitted. */
+    networkType?: string;
+    /**
+     * The URL of the network the transaction was submitted to.
+     * A single network URL if it was recorded when submitted.
+     * An array of potential network URLs if it cannot be confirmed since the migration was used.
+     */
+    networkUrl?: string | string[];
+    /** The origin of the transaction. */
+    origin?: string;
+    /** The raw transaction data that was submitted. */
+    rawTransaction: string;
+    /** When the transaction was submitted. */
+    time: number;
+    /** The transaction parameters that were submitted. */
+    transaction: Record<string, unknown>;
+};
+/** Gas fee estimates for a specific priority level. */
+export declare type GasFeeEstimatesForLevel = {
+    /** Maximum amount to pay per gas. */
+    maxFeePerGas: Hex;
+    /** Maximum amount per gas to give to the validator as an incentive. */
+    maxPriorityFeePerGas: Hex;
+};
+/** Alternate priority levels for which values are provided in gas fee estimates. */
+export declare enum GasFeeEstimateLevel {
+    low = "low",
+    medium = "medium",
+    high = "high"
+}
+/** Gas fee estimates for a transaction. */
+export declare type GasFeeEstimates = {
+    /** The gas fee estimate for a low priority transaction. */
+    [GasFeeEstimateLevel.low]: GasFeeEstimatesForLevel;
+    /** The gas fee estimate for a medium priority transaction. */
+    [GasFeeEstimateLevel.medium]: GasFeeEstimatesForLevel;
+    /** The gas fee estimate for a high priority transaction. */
+    [GasFeeEstimateLevel.high]: GasFeeEstimatesForLevel;
+};
+/** Request to a gas fee flow to obtain gas fee estimates. */
+export declare type GasFeeFlowRequest = {
+    /** An EthQuery instance to enable queries to the associated RPC provider. */
+    ethQuery: any;
+    /** Callback to get the GasFeeController estimates. */
+    getGasFeeControllerEstimates: () => Promise<GasFeeState>;
+    /** The metadata of the transaction to obtain estimates for. */
+    transactionMeta: TransactionMeta;
+};
+/** Response from a gas fee flow containing gas fee estimates. */
+export declare type GasFeeFlowResponse = {
+    /** The gas fee estimates for the transaction. */
+    estimates: GasFeeEstimates;
+};
+/** A method of obtaining gas fee estimates for a specific transaction. */
+export declare type GasFeeFlow = {
+    /**
+     * Determine if the gas fee flow supports the specified transaction.
+     *
+     * @param transactionMeta - The transaction metadata.
+     * @returns Whether the gas fee flow supports the transaction.
+     */
+    matchesTransaction(transactionMeta: TransactionMeta): boolean;
+    /**
+     * Get gas fee estimates for a specific transaction.
+     *
+     * @param request - The gas fee flow request.
+     * @returns The gas fee flow response containing the gas fee estimates.
+     */
+    getGasFees: (request: GasFeeFlowRequest) => Promise<GasFeeFlowResponse>;
+};
+/**
+ * Standard data concerning a transaction processed by the blockchain.
+ */
+export interface TransactionReceipt {
+    /**
+     * The block hash of the block that this transaction was included in.
+     */
+    blockHash?: string;
+    /**
+     * The block number of the block that this transaction was included in.
+     */
+    blockNumber?: string;
+    /**
+     * Effective gas price the transaction was charged at.
+     */
+    effectiveGasPrice?: string;
+    /**
+     * Gas used in the transaction.
+     */
+    gasUsed?: string;
+    /**
+     * Total used gas in hex.
+     */
+    l1Fee?: string;
+    /**
+     * All the logs emitted by this transaction.
+     */
+    logs?: Log[];
+    /**
+     * The status of the transaction.
+     */
+    status?: string;
+    /**
+     * The hexadecimal index of this transaction in the list of transactions included in the block this transaction was mined in.
+     */
+    transactionIndex?: string;
+}
+/**
+ * Represents an event that has been included in a transaction using the EVM `LOG` opcode.
+ */
+export interface Log {
+    /**
+     * Address of the contract that generated log.
+     */
+    address?: string;
+    /**
+     * List of topics for log.
+     */
+    topics?: string;
+}
+/**
+ * The type of the transaction.
+ */
+export declare enum TransactionType {
+    /**
+     * A transaction sending a network's native asset to a recipient.
+     */
+    cancel = "cancel",
+    /**
+     * A transaction that is interacting with a smart contract's methods that we
+     * have not treated as a special case, such as approve, transfer, and
+     * transferfrom.
+     */
+    contractInteraction = "contractInteraction",
+    /**
+     * A transaction that deployed a smart contract.
+     */
+    deployContract = "contractDeployment",
+    /**
+     * A transaction for Ethereum decryption.
+     */
+    ethDecrypt = "eth_decrypt",
+    /**
+     * A transaction for getting an encryption public key.
+     */
+    ethGetEncryptionPublicKey = "eth_getEncryptionPublicKey",
+    /**
+     * An incoming (deposit) transaction.
+     */
+    incoming = "incoming",
+    /**
+     * A transaction for personal sign.
+     */
+    personalSign = "personal_sign",
+    /**
+     * When a transaction is failed it can be retried by
+     * resubmitting the same transaction with a higher gas fee. This type is also used
+     * to speed up pending transactions. This is accomplished by creating a new tx with
+     * the same nonce and higher gas fees.
+     */
+    retry = "retry",
+    /**
+     * A transaction sending a network's native asset to a recipient.
+     */
+    simpleSend = "simpleSend",
+    /**
+     * A transaction that is signing a message.
+     */
+    sign = "eth_sign",
+    /**
+     * A transaction that is signing typed data.
+     */
+    signTypedData = "eth_signTypedData",
+    /**
+     * A transaction sending a network's native asset to a recipient.
+     */
+    smart = "smart",
+    /**
+     * A transaction swapping one token for another through MetaMask Swaps.
+     */
+    swap = "swap",
+    /**
+     * Similar to the approve type, a swap approval is a special case of ERC20
+     * approve method that requests an allowance of the token to spend on behalf
+     * of the user for the MetaMask Swaps contract. The first swap for any token
+     * will have an accompanying swapApproval transaction.
+     */
+    swapApproval = "swapApproval",
+    /**
+     * A token transaction requesting an allowance of the token to spend on
+     * behalf of the user.
+     */
+    tokenMethodApprove = "approve",
+    /**
+     * A token transaction transferring tokens from an account that the sender
+     * has an allowance of. The method is prefixed with safe because when calling
+     * this method the contract checks to ensure that the receiver is an address
+     * capable of handling the token being sent.
+     */
+    tokenMethodSafeTransferFrom = "safetransferfrom",
+    /**
+     * A token transaction where the user is sending tokens that they own to
+     * another address.
+     */
+    tokenMethodTransfer = "transfer",
+    /**
+     * A token transaction transferring tokens from an account that the sender
+     * has an allowance of. For more information on allowances, see the approve
+     * type.
+     */
+    tokenMethodTransferFrom = "transferfrom",
+    /**
+     * A token transaction requesting an allowance of all of a user's tokens to
+     * spend on behalf of the user.
+     */
+    tokenMethodSetApprovalForAll = "setapprovalforall"
+}
+/**
+ * Specifies the shape of the base transaction parameters.
+ * Added in EIP-2718.
+ */
+export declare enum TransactionEnvelopeType {
+    /**
+     * A legacy transaction, the very first type.
+     */
+    legacy = "0x0",
+    /**
+     * EIP-2930 defined the access list transaction type that allowed for
+     * specifying the state that a transaction would act upon in advance and
+     * theoretically save on gas fees.
+     */
+    accessList = "0x1",
+    /**
+     * The type introduced comes from EIP-1559, Fee Market describes the addition
+     * of a baseFee to blocks that will be burned instead of distributed to
+     * miners. Transactions of this type have both a maxFeePerGas (maximum total
+     * amount in gwei per gas to spend on the transaction) which is inclusive of
+     * the maxPriorityFeePerGas (maximum amount of gwei per gas from the
+     * transaction fee to distribute to miner).
+     */
+    feeMarket = "0x2"
+}
 export {};
 //# sourceMappingURL=types.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/types.d.ts.map b/node_modules/@metamask/transaction-controller/dist/types.d.ts.map
deleted file mode 100644
index 19ac8ab..0000000
--- a/node_modules/@metamask/transaction-controller/dist/types.d.ts.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"types.d.ts","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,WAAW,EAAE,MAAM,4BAA4B,CAAC;AAC9D,OAAO,KAAK,EAAE,GAAG,EAAE,MAAM,iBAAiB,CAAC;AAE3C;;;;;;;;;;;;;;;;GAgBG;AACH,oBAAY,eAAe,GACvB,CAAC;IACC,MAAM,EAAE,OAAO,CAAC,iBAAiB,EAAE,iBAAiB,CAAC,MAAM,CAAC,CAAC;CAC9D,GAAG,mBAAmB,CAAC,GACxB,CAAC;IAAE,MAAM,EAAE,iBAAiB,CAAC,MAAM,CAAC;IAAC,KAAK,EAAE,KAAK,CAAA;CAAE,GAAG,mBAAmB,CAAC,CAAC;AAE/E,aAAK,mBAAmB,GAAG;IACzB,UAAU,CAAC,EAAE,OAAO,CAAC;IACrB,mBAAmB,CAAC,EAAE;QACpB,MAAM,EAAE,MAAM,CAAC;QACf,eAAe,EAAE,MAAM,CAAC;QACxB,QAAQ,EAAE,MAAM,CAAC;KAClB,CAAC;IACF,EAAE,EAAE,MAAM,CAAC;IACX,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,OAAO,CAAC,EAAE,GAAG,CAAC;IACd,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,cAAc,CAAC,EAAE,MAAM,CAAC;IACxB,IAAI,EAAE,MAAM,CAAC;IACb,eAAe,CAAC,EAAE,OAAO,CAAC;IAC1B,WAAW,EAAE,WAAW,CAAC;IACzB,eAAe,CAAC,EAAE,MAAM,CAAC;IACzB,WAAW,CAAC,EAAE,MAAM,CAAC;IACrB,iBAAiB,CAAC,EAAE,YAAY,CAAC;IACjC,oBAAoB,CAAC,EAAE,OAAO,CAAC;CAChC,CAAC;AAEF;;;;GAIG;AACH,oBAAY,iBAAiB;IAC3B,QAAQ,aAAa;IACrB,SAAS,cAAc;IACvB,SAAS,cAAc;IACvB,MAAM,WAAW;IACjB,QAAQ,aAAa;IACrB,MAAM,WAAW;IACjB,SAAS,cAAc;IACvB,UAAU,eAAe;CAC1B;AAED;;GAEG;AACH,oBAAY,YAAY;IACtB,SAAS,oBAAoB;IAC7B,YAAY,uBAAuB;IACnC,KAAK,iBAAiB;CACvB;AAED;;;;;;;;;;;;;GAaG;AACH,MAAM,WAAW,WAAW;IAC1B,OAAO,CAAC,EAAE,GAAG,CAAC;IACd,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,IAAI,EAAE,MAAM,CAAC;IACb,GAAG,CAAC,EAAE,MAAM,CAAC;IACb,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,EAAE,CAAC,EAAE,MAAM,CAAC;IACZ,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,YAAY,CAAC,EAAE,MAAM,CAAC;IACtB,oBAAoB,CAAC,EAAE,MAAM,CAAC;IAC9B,gBAAgB,CAAC,EAAE,MAAM,CAAC;IAC1B,gBAAgB,CAAC,EAAE,MAAM,CAAC;CAC3B;AAED;;GAEG;AACH,MAAM,WAAW,8BAA8B;IAC7C;;OAEG;IACH,OAAO,EAAE,MAAM,CAAC;IAEhB;;OAEG;IACH,MAAM,CAAC,EAAE,MAAM,CAAC;IAEhB;;OAEG;IACH,cAAc,EAAE,GAAG,CAAC;IAEpB;;OAEG;IACH,gBAAgB,EAAE,MAAM,CAAC;IAEzB;;OAEG;IACH,SAAS,CAAC,EAAE,MAAM,CAAC;IAEnB;;OAEG;IACH,KAAK,EAAE,MAAM,CAAC;IAEd;;OAEG;IACH,WAAW,EAAE,WAAW,CAAC;CAC1B;AAED;;;GAGG;AACH,MAAM,WAAW,uBAAuB;IACtC,iBAAiB,EAAE,CACjB,OAAO,EAAE,8BAA8B,KACpC,OAAO,CAAC,eAAe,EAAE,CAAC,CAAC;CACjC"}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/types.js b/node_modules/@metamask/transaction-controller/dist/types.js
index 1cddb49..4dd6a9e 100644
--- a/node_modules/@metamask/transaction-controller/dist/types.js
+++ b/node_modules/@metamask/transaction-controller/dist/types.js
@@ -1,6 +1,6 @@
 "use strict";
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.WalletDevice = exports.TransactionStatus = void 0;
+exports.TransactionEnvelopeType = exports.TransactionType = exports.GasFeeEstimateLevel = exports.WalletDevice = exports.TransactionStatus = void 0;
 /**
  * The status of the transaction. Each status represents the state of the transaction internally
  * in the wallet. Some of these correspond with the state of the transaction on the network, but
@@ -9,8 +9,10 @@ exports.WalletDevice = exports.TransactionStatus = void 0;
 var TransactionStatus;
 (function (TransactionStatus) {
     TransactionStatus["approved"] = "approved";
+    /** @deprecated Determined by the clients using the transaction type. No longer used. */
     TransactionStatus["cancelled"] = "cancelled";
     TransactionStatus["confirmed"] = "confirmed";
+    TransactionStatus["dropped"] = "dropped";
     TransactionStatus["failed"] = "failed";
     TransactionStatus["rejected"] = "rejected";
     TransactionStatus["signed"] = "signed";
@@ -26,4 +28,135 @@ var WalletDevice;
     WalletDevice["MM_EXTENSION"] = "metamask_extension";
     WalletDevice["OTHER"] = "other_device";
 })(WalletDevice = exports.WalletDevice || (exports.WalletDevice = {}));
+/** Alternate priority levels for which values are provided in gas fee estimates. */
+var GasFeeEstimateLevel;
+(function (GasFeeEstimateLevel) {
+    GasFeeEstimateLevel["low"] = "low";
+    GasFeeEstimateLevel["medium"] = "medium";
+    GasFeeEstimateLevel["high"] = "high";
+})(GasFeeEstimateLevel = exports.GasFeeEstimateLevel || (exports.GasFeeEstimateLevel = {}));
+/**
+ * The type of the transaction.
+ */
+var TransactionType;
+(function (TransactionType) {
+    /**
+     * A transaction sending a network's native asset to a recipient.
+     */
+    TransactionType["cancel"] = "cancel";
+    /**
+     * A transaction that is interacting with a smart contract's methods that we
+     * have not treated as a special case, such as approve, transfer, and
+     * transferfrom.
+     */
+    TransactionType["contractInteraction"] = "contractInteraction";
+    /**
+     * A transaction that deployed a smart contract.
+     */
+    TransactionType["deployContract"] = "contractDeployment";
+    /**
+     * A transaction for Ethereum decryption.
+     */
+    TransactionType["ethDecrypt"] = "eth_decrypt";
+    /**
+     * A transaction for getting an encryption public key.
+     */
+    TransactionType["ethGetEncryptionPublicKey"] = "eth_getEncryptionPublicKey";
+    /**
+     * An incoming (deposit) transaction.
+     */
+    TransactionType["incoming"] = "incoming";
+    /**
+     * A transaction for personal sign.
+     */
+    TransactionType["personalSign"] = "personal_sign";
+    /**
+     * When a transaction is failed it can be retried by
+     * resubmitting the same transaction with a higher gas fee. This type is also used
+     * to speed up pending transactions. This is accomplished by creating a new tx with
+     * the same nonce and higher gas fees.
+     */
+    TransactionType["retry"] = "retry";
+    /**
+     * A transaction sending a network's native asset to a recipient.
+     */
+    TransactionType["simpleSend"] = "simpleSend";
+    /**
+     * A transaction that is signing a message.
+     */
+    TransactionType["sign"] = "eth_sign";
+    /**
+     * A transaction that is signing typed data.
+     */
+    TransactionType["signTypedData"] = "eth_signTypedData";
+    /**
+     * A transaction sending a network's native asset to a recipient.
+     */
+    TransactionType["smart"] = "smart";
+    /**
+     * A transaction swapping one token for another through MetaMask Swaps.
+     */
+    TransactionType["swap"] = "swap";
+    /**
+     * Similar to the approve type, a swap approval is a special case of ERC20
+     * approve method that requests an allowance of the token to spend on behalf
+     * of the user for the MetaMask Swaps contract. The first swap for any token
+     * will have an accompanying swapApproval transaction.
+     */
+    TransactionType["swapApproval"] = "swapApproval";
+    /**
+     * A token transaction requesting an allowance of the token to spend on
+     * behalf of the user.
+     */
+    TransactionType["tokenMethodApprove"] = "approve";
+    /**
+     * A token transaction transferring tokens from an account that the sender
+     * has an allowance of. The method is prefixed with safe because when calling
+     * this method the contract checks to ensure that the receiver is an address
+     * capable of handling the token being sent.
+     */
+    TransactionType["tokenMethodSafeTransferFrom"] = "safetransferfrom";
+    /**
+     * A token transaction where the user is sending tokens that they own to
+     * another address.
+     */
+    TransactionType["tokenMethodTransfer"] = "transfer";
+    /**
+     * A token transaction transferring tokens from an account that the sender
+     * has an allowance of. For more information on allowances, see the approve
+     * type.
+     */
+    TransactionType["tokenMethodTransferFrom"] = "transferfrom";
+    /**
+     * A token transaction requesting an allowance of all of a user's tokens to
+     * spend on behalf of the user.
+     */
+    TransactionType["tokenMethodSetApprovalForAll"] = "setapprovalforall";
+})(TransactionType = exports.TransactionType || (exports.TransactionType = {}));
+/**
+ * Specifies the shape of the base transaction parameters.
+ * Added in EIP-2718.
+ */
+var TransactionEnvelopeType;
+(function (TransactionEnvelopeType) {
+    /**
+     * A legacy transaction, the very first type.
+     */
+    TransactionEnvelopeType["legacy"] = "0x0";
+    /**
+     * EIP-2930 defined the access list transaction type that allowed for
+     * specifying the state that a transaction would act upon in advance and
+     * theoretically save on gas fees.
+     */
+    TransactionEnvelopeType["accessList"] = "0x1";
+    /**
+     * The type introduced comes from EIP-1559, Fee Market describes the addition
+     * of a baseFee to blocks that will be burned instead of distributed to
+     * miners. Transactions of this type have both a maxFeePerGas (maximum total
+     * amount in gwei per gas to spend on the transaction) which is inclusive of
+     * the maxPriorityFeePerGas (maximum amount of gwei per gas from the
+     * transaction fee to distribute to miner).
+     */
+    TransactionEnvelopeType["feeMarket"] = "0x2";
+})(TransactionEnvelopeType = exports.TransactionEnvelopeType || (exports.TransactionEnvelopeType = {}));
 //# sourceMappingURL=types.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/types.js.map b/node_modules/@metamask/transaction-controller/dist/types.js.map
deleted file mode 100644
index 83f50bc..0000000
--- a/node_modules/@metamask/transaction-controller/dist/types.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"types.js","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":";;;AA+CA;;;;GAIG;AACH,IAAY,iBASX;AATD,WAAY,iBAAiB;IAC3B,0CAAqB,CAAA;IACrB,4CAAuB,CAAA;IACvB,4CAAuB,CAAA;IACvB,sCAAiB,CAAA;IACjB,0CAAqB,CAAA;IACrB,sCAAiB,CAAA;IACjB,4CAAuB,CAAA;IACvB,8CAAyB,CAAA;AAC3B,CAAC,EATW,iBAAiB,GAAjB,yBAAiB,KAAjB,yBAAiB,QAS5B;AAED;;GAEG;AACH,IAAY,YAIX;AAJD,WAAY,YAAY;IACtB,6CAA6B,CAAA;IAC7B,mDAAmC,CAAA;IACnC,sCAAsB,CAAA;AACxB,CAAC,EAJW,YAAY,GAAZ,oBAAY,KAAZ,oBAAY,QAIvB","sourcesContent":["import type { NetworkType } from '@metamask/controller-utils';\nimport type { Hex } from '@metamask/utils';\n\n/**\n * @type TransactionMeta\n *\n * TransactionMeta representation\n * @property error - Synthesized error information for failed transactions\n * @property id - Generated UUID associated with this transaction\n * @property networkID - Network code as per EIP-155 for this transaction\n * @property origin - Origin this transaction was sent from\n * @property deviceConfirmedOn - string to indicate what device the transaction was confirmed\n * @property rawTransaction - Hex representation of the underlying transaction\n * @property status - String status of this transaction\n * @property time - Timestamp associated with this transaction\n * @property toSmartContract - Whether transaction recipient is a smart contract\n * @property transaction - Underlying Transaction object\n * @property transactionHash - Hash of a successful transaction\n * @property blockNumber - Number of the block where the transaction has been included\n */\nexport type TransactionMeta =\n  | ({\n      status: Exclude<TransactionStatus, TransactionStatus.failed>;\n    } & TransactionMetaBase)\n  | ({ status: TransactionStatus.failed; error: Error } & TransactionMetaBase);\n\ntype TransactionMetaBase = {\n  isTransfer?: boolean;\n  transferInformation?: {\n    symbol: string;\n    contractAddress: string;\n    decimals: number;\n  };\n  id: string;\n  networkID?: string;\n  chainId?: Hex;\n  origin?: string;\n  rawTransaction?: string;\n  time: number;\n  toSmartContract?: boolean;\n  transaction: Transaction;\n  transactionHash?: string;\n  blockNumber?: string;\n  deviceConfirmedOn?: WalletDevice;\n  verifiedOnBlockchain?: boolean;\n};\n\n/**\n * The status of the transaction. Each status represents the state of the transaction internally\n * in the wallet. Some of these correspond with the state of the transaction on the network, but\n * some are wallet-specific.\n */\nexport enum TransactionStatus {\n  approved = 'approved',\n  cancelled = 'cancelled',\n  confirmed = 'confirmed',\n  failed = 'failed',\n  rejected = 'rejected',\n  signed = 'signed',\n  submitted = 'submitted',\n  unapproved = 'unapproved',\n}\n\n/**\n * Options for wallet device.\n */\nexport enum WalletDevice {\n  MM_MOBILE = 'metamask_mobile',\n  MM_EXTENSION = 'metamask_extension',\n  OTHER = 'other_device',\n}\n\n/**\n * @type Transaction\n *\n * Transaction representation\n * @property chainId - Network ID as per EIP-155\n * @property data - Data to pass with this transaction\n * @property from - Address to send this transaction from\n * @property gas - Gas to send with this transaction\n * @property gasPrice - Price of gas with this transaction\n * @property gasUsed - Gas used in the transaction\n * @property nonce - Unique number to prevent replay attacks\n * @property to - Address to send this transaction to\n * @property value - Value associated with this transaction\n */\nexport interface Transaction {\n  chainId?: Hex;\n  data?: string;\n  from: string;\n  gas?: string;\n  gasPrice?: string;\n  gasUsed?: string;\n  nonce?: string;\n  to?: string;\n  value?: string;\n  maxFeePerGas?: string;\n  maxPriorityFeePerGas?: string;\n  estimatedBaseFee?: string;\n  estimateGasError?: string;\n}\n\n/**\n * The configuration required to fetch transaction data from a RemoteTransactionSource.\n */\nexport interface RemoteTransactionSourceRequest {\n  /**\n   * The address of the account to fetch transactions for.\n   */\n  address: string;\n\n  /**\n   * API key if required by the remote source.\n   */\n  apiKey?: string;\n\n  /**\n   * The chainId of the current network.\n   */\n  currentChainId: Hex;\n\n  /**\n   * The networkId of the current network.\n   */\n  currentNetworkId: string;\n\n  /**\n   * Block number to start fetching transactions from.\n   */\n  fromBlock?: string;\n\n  /**\n   * Maximum number of transactions to retrieve.\n   */\n  limit: number;\n\n  /**\n   * The type of the current network.\n   */\n  networkType: NetworkType;\n}\n\n/**\n * An object capable of fetching transaction data from a remote source.\n * Used by the IncomingTransactionHelper to retrieve remote transaction data.\n */\nexport interface RemoteTransactionSource {\n  fetchTransactions: (\n    request: RemoteTransactionSourceRequest,\n  ) => Promise<TransactionMeta[]>;\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils.d.ts b/node_modules/@metamask/transaction-controller/dist/utils.d.ts
index f9a1c07..15b0901 100644
--- a/node_modules/@metamask/transaction-controller/dist/utils.d.ts
+++ b/node_modules/@metamask/transaction-controller/dist/utils.d.ts
@@ -8,7 +8,7 @@ export declare const ESTIMATE_GAS_ERROR = "eth_estimateGas rpc method error";
  * @param transaction - Transaction object to normalize.
  * @returns Normalized Transaction object.
  */
-export declare function normalizeTransaction(transaction: Transaction): Transaction;
+export declare function normalizeTransactionParams(transaction: Transaction): Transaction;
 /**
  * Validates a Transaction object for required properties and throws in
  * the event of any validation error.
@@ -41,10 +41,19 @@ export declare function validateMinimumIncrease(proposed: string, min: string):
 /**
  * Helper function to filter and format transactions for the nonce tracker.
  *
+ * @param currentChainId - Chain ID of the current network.
  * @param fromAddress - Address of the account from which the transactions to filter from are sent.
  * @param transactionStatus - Status of the transactions for which to filter.
  * @param transactions - Array of transactionMeta objects that have been prefiltered.
  * @returns Array of transactions formatted for the nonce tracker.
  */
-export declare function getAndFormatTransactionsForNonceTracker(fromAddress: string, transactionStatus: TransactionStatus, transactions: TransactionMeta[]): NonceTrackerTransaction[];
+export declare function getAndFormatTransactionsForNonceTracker(currentChainId: string, fromAddress: string, transactionStatus: TransactionStatus, transactions: TransactionMeta[]): NonceTrackerTransaction[];
+/**
+ * Ensure a hex string is of even length by adding a leading 0 if necessary.
+ * Any existing `0x` prefix is preserved but is not added if missing.
+ *
+ * @param hex - The hex string to ensure is even.
+ * @returns The hex string with an even length.
+ */
+export declare function padHexToEvenLength(hex: string): string;
 //# sourceMappingURL=utils.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils.d.ts.map b/node_modules/@metamask/transaction-controller/dist/utils.d.ts.map
deleted file mode 100644
index 2c9dc99..0000000
--- a/node_modules/@metamask/transaction-controller/dist/utils.d.ts.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"utils.d.ts","sourceRoot":"","sources":["../src/utils.ts"],"names":[],"mappings":"AAKA,OAAO,KAAK,EAAE,WAAW,IAAI,uBAAuB,EAAE,MAAM,iCAAiC,CAAC;AAE9F,OAAO,KAAK,EACV,aAAa,EACb,sBAAsB,EACvB,MAAM,yBAAyB,CAAC;AACjC,OAAO,KAAK,EAAE,WAAW,EAAE,eAAe,EAAE,iBAAiB,EAAE,MAAM,SAAS,CAAC;AAE/E,eAAO,MAAM,kBAAkB,qCAAqC,CAAC;AAiBrE;;;;;GAKG;AACH,wBAAgB,oBAAoB,CAAC,WAAW,EAAE,WAAW,eAS5D;AAED;;;;;GAKG;AACH,wBAAgB,mBAAmB,CAAC,WAAW,EAAE,WAAW,QAmD3D;AAED;;;;;;GAMG;AACH,eAAO,MAAM,oBAAoB,gBAAiB,WAAW,KAAG,OAO/D,CAAC;AAEF,eAAO,MAAM,iBAAiB,cACjB,aAAa,GAAG,sBAAsB,SAUlD,CAAC;AAEF,eAAO,MAAM,wBAAwB,yGAIsC,CAAC;AAE5E,eAAO,MAAM,eAAe,gGAG0B,CAAC;AAEvD,eAAO,MAAM,oBAAoB,UAAW,MAAM,QAAQ,MAAM,KAAG,MACF,CAAC;AAElE,eAAO,MAAM,6BAA6B,UACjC,MAAM,GAAG,SAAS,QACnB,MAAM,KACX,MAEF,CAAC;AAEF;;;;;;;GAOG;AACH,wBAAgB,uBAAuB,CAAC,QAAQ,EAAE,MAAM,EAAE,GAAG,EAAE,MAAM,UAQpE;AAED;;;;;;;GAOG;AACH,wBAAgB,uCAAuC,CACrD,WAAW,EAAE,MAAM,EACnB,iBAAiB,EAAE,iBAAiB,EACpC,YAAY,EAAE,eAAe,EAAE,GAC9B,uBAAuB,EAAE,CAsB3B"}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils.js b/node_modules/@metamask/transaction-controller/dist/utils.js
index 387a364..9d71811 100644
--- a/node_modules/@metamask/transaction-controller/dist/utils.js
+++ b/node_modules/@metamask/transaction-controller/dist/utils.js
@@ -1,11 +1,11 @@
 "use strict";
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.getAndFormatTransactionsForNonceTracker = exports.validateMinimumIncrease = exports.getIncreasedPriceFromExisting = exports.getIncreasedPriceHex = exports.isGasPriceValue = exports.isFeeMarketEIP1559Values = exports.validateGasValues = exports.isEIP1559Transaction = exports.validateTransaction = exports.normalizeTransaction = exports.ESTIMATE_GAS_ERROR = void 0;
+exports.padHexToEvenLength = exports.getAndFormatTransactionsForNonceTracker = exports.validateMinimumIncrease = exports.getIncreasedPriceFromExisting = exports.getIncreasedPriceHex = exports.isGasPriceValue = exports.isFeeMarketEIP1559Values = exports.validateGasValues = exports.isEIP1559Transaction = exports.validateTransaction = exports.normalizeTransactionParams = exports.ESTIMATE_GAS_ERROR = void 0;
 const controller_utils_1 = require("@metamask/controller-utils");
 const ethereumjs_util_1 = require("ethereumjs-util");
 exports.ESTIMATE_GAS_ERROR = 'eth_estimateGas rpc method error';
 const NORMALIZERS = {
-    data: (data) => (0, ethereumjs_util_1.addHexPrefix)(data),
+    data: (data) => (0, ethereumjs_util_1.addHexPrefix)(padHexToEvenLength(data)),
     from: (from) => (0, ethereumjs_util_1.addHexPrefix)(from).toLowerCase(),
     gas: (gas) => (0, ethereumjs_util_1.addHexPrefix)(gas),
     gasPrice: (gasPrice) => (0, ethereumjs_util_1.addHexPrefix)(gasPrice),
@@ -15,6 +15,7 @@ const NORMALIZERS = {
     maxFeePerGas: (maxFeePerGas) => (0, ethereumjs_util_1.addHexPrefix)(maxFeePerGas),
     maxPriorityFeePerGas: (maxPriorityFeePerGas) => (0, ethereumjs_util_1.addHexPrefix)(maxPriorityFeePerGas),
     estimatedBaseFee: (maxPriorityFeePerGas) => (0, ethereumjs_util_1.addHexPrefix)(maxPriorityFeePerGas),
+    type: (type) => (type === '0x0' ? '0x0' : undefined),
 };
 /**
  * Normalizes properties on a Transaction object.
@@ -22,7 +23,7 @@ const NORMALIZERS = {
  * @param transaction - Transaction object to normalize.
  * @returns Normalized Transaction object.
  */
-function normalizeTransaction(transaction) {
+function normalizeTransactionParams(transaction) {
     const normalizedTransaction = { from: '' };
     let key;
     for (key in NORMALIZERS) {
@@ -32,7 +33,7 @@ function normalizeTransaction(transaction) {
     }
     return normalizedTransaction;
 }
-exports.normalizeTransaction = normalizeTransaction;
+exports.normalizeTransactionParams = normalizeTransactionParams;
 /**
  * Validates a Transaction object for required properties and throws in
  * the event of any validation error.
@@ -130,14 +131,17 @@ exports.validateMinimumIncrease = validateMinimumIncrease;
 /**
  * Helper function to filter and format transactions for the nonce tracker.
  *
+ * @param currentChainId - Chain ID of the current network.
  * @param fromAddress - Address of the account from which the transactions to filter from are sent.
  * @param transactionStatus - Status of the transactions for which to filter.
  * @param transactions - Array of transactionMeta objects that have been prefiltered.
  * @returns Array of transactions formatted for the nonce tracker.
  */
-function getAndFormatTransactionsForNonceTracker(fromAddress, transactionStatus, transactions) {
+function getAndFormatTransactionsForNonceTracker(currentChainId, fromAddress, transactionStatus, transactions) {
     return transactions
-        .filter(({ status, transaction: { from } }) => status === transactionStatus &&
+        .filter(({ chainId, isTransfer, status, transaction: { from } }) => !isTransfer &&
+        chainId === currentChainId &&
+        status === transactionStatus &&
         from.toLowerCase() === fromAddress.toLowerCase())
         .map(({ status, transaction: { from, gas, value, nonce } }) => {
         // the only value we care about is the nonce
@@ -156,4 +160,18 @@ function getAndFormatTransactionsForNonceTracker(fromAddress, transactionStatus,
     });
 }
 exports.getAndFormatTransactionsForNonceTracker = getAndFormatTransactionsForNonceTracker;
+/**
+ * Ensure a hex string is of even length by adding a leading 0 if necessary.
+ * Any existing `0x` prefix is preserved but is not added if missing.
+ *
+ * @param hex - The hex string to ensure is even.
+ * @returns The hex string with an even length.
+ */
+function padHexToEvenLength(hex) {
+    const prefix = hex.toLowerCase().startsWith('0x') ? hex.slice(0, 2) : '';
+    const data = prefix ? hex.slice(2) : hex;
+    const evenData = data.length % 2 === 0 ? data : `0${data}`;
+    return prefix + evenData;
+}
+exports.padHexToEvenLength = padHexToEvenLength;
 //# sourceMappingURL=utils.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils.js.map b/node_modules/@metamask/transaction-controller/dist/utils.js.map
deleted file mode 100644
index a1f7e90..0000000
--- a/node_modules/@metamask/transaction-controller/dist/utils.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"utils.js","sourceRoot":"","sources":["../src/utils.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  convertHexToDecimal,\n  isValidHexAddress,\n} from '@metamask/controller-utils';\nimport { addHexPrefix, isHexString } from 'ethereumjs-util';\nimport type { Transaction as NonceTrackerTransaction } from 'nonce-tracker/dist/NonceTracker';\n\nimport type {\n  GasPriceValue,\n  FeeMarketEIP1559Values,\n} from './TransactionController';\nimport type { Transaction, TransactionMeta, TransactionStatus } from './types';\n\nexport const ESTIMATE_GAS_ERROR = 'eth_estimateGas rpc method error';\n\nconst NORMALIZERS: { [param in keyof Transaction]: any } = {\n  data: (data: string) => addHexPrefix(data),\n  from: (from: string) => addHexPrefix(from).toLowerCase(),\n  gas: (gas: string) => addHexPrefix(gas),\n  gasPrice: (gasPrice: string) => addHexPrefix(gasPrice),\n  nonce: (nonce: string) => addHexPrefix(nonce),\n  to: (to: string) => addHexPrefix(to).toLowerCase(),\n  value: (value: string) => addHexPrefix(value),\n  maxFeePerGas: (maxFeePerGas: string) => addHexPrefix(maxFeePerGas),\n  maxPriorityFeePerGas: (maxPriorityFeePerGas: string) =>\n    addHexPrefix(maxPriorityFeePerGas),\n  estimatedBaseFee: (maxPriorityFeePerGas: string) =>\n    addHexPrefix(maxPriorityFeePerGas),\n};\n\n/**\n * Normalizes properties on a Transaction object.\n *\n * @param transaction - Transaction object to normalize.\n * @returns Normalized Transaction object.\n */\nexport function normalizeTransaction(transaction: Transaction) {\n  const normalizedTransaction: Transaction = { from: '' };\n  let key: keyof Transaction;\n  for (key in NORMALIZERS) {\n    if (transaction[key as keyof Transaction]) {\n      normalizedTransaction[key] = NORMALIZERS[key](transaction[key]) as never;\n    }\n  }\n  return normalizedTransaction;\n}\n\n/**\n * Validates a Transaction object for required properties and throws in\n * the event of any validation error.\n *\n * @param transaction - Transaction object to validate.\n */\nexport function validateTransaction(transaction: Transaction) {\n  if (\n    !transaction.from ||\n    typeof transaction.from !== 'string' ||\n    !isValidHexAddress(transaction.from)\n  ) {\n    throw new Error(\n      `Invalid \"from\" address: ${transaction.from} must be a valid string.`,\n    );\n  }\n\n  if (transaction.to === '0x' || transaction.to === undefined) {\n    if (transaction.data) {\n      delete transaction.to;\n    } else {\n      throw new Error(\n        `Invalid \"to\" address: ${transaction.to} must be a valid string.`,\n      );\n    }\n  } else if (\n    transaction.to !== undefined &&\n    !isValidHexAddress(transaction.to)\n  ) {\n    throw new Error(\n      `Invalid \"to\" address: ${transaction.to} must be a valid string.`,\n    );\n  }\n\n  if (transaction.value !== undefined) {\n    const value = transaction.value.toString();\n    if (value.includes('-')) {\n      throw new Error(`Invalid \"value\": ${value} is not a positive number.`);\n    }\n\n    if (value.includes('.')) {\n      throw new Error(\n        `Invalid \"value\": ${value} number must be denominated in wei.`,\n      );\n    }\n    const intValue = parseInt(transaction.value, 10);\n    const isValid =\n      Number.isFinite(intValue) &&\n      !Number.isNaN(intValue) &&\n      !isNaN(Number(value)) &&\n      Number.isSafeInteger(intValue);\n    if (!isValid) {\n      throw new Error(\n        `Invalid \"value\": ${value} number must be a valid number.`,\n      );\n    }\n  }\n}\n\n/**\n * Checks if a transaction is EIP-1559 by checking for the existence of\n * maxFeePerGas and maxPriorityFeePerGas within its parameters.\n *\n * @param transaction - Transaction object to add.\n * @returns Boolean that is true if the transaction is EIP-1559 (has maxFeePerGas and maxPriorityFeePerGas), otherwise returns false.\n */\nexport const isEIP1559Transaction = (transaction: Transaction): boolean => {\n  const hasOwnProp = (obj: Transaction, key: string) =>\n    Object.prototype.hasOwnProperty.call(obj, key);\n  return (\n    hasOwnProp(transaction, 'maxFeePerGas') &&\n    hasOwnProp(transaction, 'maxPriorityFeePerGas')\n  );\n};\n\nexport const validateGasValues = (\n  gasValues: GasPriceValue | FeeMarketEIP1559Values,\n) => {\n  Object.keys(gasValues).forEach((key) => {\n    const value = (gasValues as any)[key];\n    if (typeof value !== 'string' || !isHexString(value)) {\n      throw new TypeError(\n        `expected hex string for ${key} but received: ${value}`,\n      );\n    }\n  });\n};\n\nexport const isFeeMarketEIP1559Values = (\n  gasValues?: GasPriceValue | FeeMarketEIP1559Values,\n): gasValues is FeeMarketEIP1559Values =>\n  (gasValues as FeeMarketEIP1559Values)?.maxFeePerGas !== undefined ||\n  (gasValues as FeeMarketEIP1559Values)?.maxPriorityFeePerGas !== undefined;\n\nexport const isGasPriceValue = (\n  gasValues?: GasPriceValue | FeeMarketEIP1559Values,\n): gasValues is GasPriceValue =>\n  (gasValues as GasPriceValue)?.gasPrice !== undefined;\n\nexport const getIncreasedPriceHex = (value: number, rate: number): string =>\n  addHexPrefix(`${parseInt(`${value * rate}`, 10).toString(16)}`);\n\nexport const getIncreasedPriceFromExisting = (\n  value: string | undefined,\n  rate: number,\n): string => {\n  return getIncreasedPriceHex(convertHexToDecimal(value), rate);\n};\n\n/**\n * Validates that the proposed value is greater than or equal to the minimum value.\n *\n * @param proposed - The proposed value.\n * @param min - The minimum value.\n * @returns The proposed value.\n * @throws Will throw if the proposed value is too low.\n */\nexport function validateMinimumIncrease(proposed: string, min: string) {\n  const proposedDecimal = convertHexToDecimal(proposed);\n  const minDecimal = convertHexToDecimal(min);\n  if (proposedDecimal >= minDecimal) {\n    return proposed;\n  }\n  const errorMsg = `The proposed value: ${proposedDecimal} should meet or exceed the minimum value: ${minDecimal}`;\n  throw new Error(errorMsg);\n}\n\n/**\n * Helper function to filter and format transactions for the nonce tracker.\n *\n * @param fromAddress - Address of the account from which the transactions to filter from are sent.\n * @param transactionStatus - Status of the transactions for which to filter.\n * @param transactions - Array of transactionMeta objects that have been prefiltered.\n * @returns Array of transactions formatted for the nonce tracker.\n */\nexport function getAndFormatTransactionsForNonceTracker(\n  fromAddress: string,\n  transactionStatus: TransactionStatus,\n  transactions: TransactionMeta[],\n): NonceTrackerTransaction[] {\n  return transactions\n    .filter(\n      ({ status, transaction: { from } }) =>\n        status === transactionStatus &&\n        from.toLowerCase() === fromAddress.toLowerCase(),\n    )\n    .map(({ status, transaction: { from, gas, value, nonce } }) => {\n      // the only value we care about is the nonce\n      // but we need to return the other values to satisfy the type\n      // TODO: refactor nonceTracker to not require this\n      return {\n        status,\n        history: [{}],\n        txParams: {\n          from: from ?? '',\n          gas: gas ?? '',\n          value: value ?? '',\n          nonce: nonce ?? '',\n        },\n      };\n    });\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/gas-flow.d.ts b/node_modules/@metamask/transaction-controller/dist/utils/gas-flow.d.ts
new file mode 100644
index 0000000..02539b9
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/gas-flow.d.ts
@@ -0,0 +1,32 @@
+import { type GasFeeEstimates, type GasFeeState, type LegacyGasPriceEstimate } from '@metamask/gas-fee-controller';
+import { type GasFeeEstimates as TransactionGasFeeEstimates, type GasFeeFlow, type TransactionMeta } from '../types';
+/**
+ * Returns the first gas fee flow that matches the transaction.
+ *
+ * @param transactionMeta - The transaction metadata to find a gas fee flow for.
+ * @param gasFeeFlows - The gas fee flows to search.
+ * @returns The first gas fee flow that matches the transaction, or undefined if none match.
+ */
+export declare function getGasFeeFlow(transactionMeta: TransactionMeta, gasFeeFlows: GasFeeFlow[]): GasFeeFlow | undefined;
+declare type FeeMarketMergeGasFeeEstimatesRequest = {
+    gasFeeControllerEstimateType: 'fee-market';
+    gasFeeControllerEstimates: GasFeeEstimates;
+    transactionGasFeeEstimates: TransactionGasFeeEstimates;
+};
+declare type LegacyMergeGasFeeEstimatesRequest = {
+    gasFeeControllerEstimateType: 'legacy';
+    gasFeeControllerEstimates: LegacyGasPriceEstimate;
+    transactionGasFeeEstimates: TransactionGasFeeEstimates;
+};
+/**
+ * Merge the gas fee estimates from the gas fee controller with the gas fee estimates from a transaction.
+ *
+ * @param request - Data required to merge gas fee estimates.
+ * @param request.gasFeeControllerEstimateType - Gas fee estimate type from the gas fee controller.
+ * @param request.gasFeeControllerEstimates - Gas fee estimates from the GasFeeController.
+ * @param request.transactionGasFeeEstimates - Gas fee estimates from the transaction.
+ * @returns The merged gas fee estimates.
+ */
+export declare function mergeGasFeeEstimates({ gasFeeControllerEstimateType, gasFeeControllerEstimates, transactionGasFeeEstimates, }: FeeMarketMergeGasFeeEstimatesRequest | LegacyMergeGasFeeEstimatesRequest): GasFeeState['gasFeeEstimates'];
+export {};
+//# sourceMappingURL=gas-flow.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/gas-flow.d.ts.map b/node_modules/@metamask/transaction-controller/dist/utils/gas-flow.d.ts.map
new file mode 100644
index 0000000..1eee187
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/gas-flow.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"gas-flow.d.ts","sourceRoot":"","sources":["../../src/utils/gas-flow.ts"],"names":[],"mappings":"AACA,OAAO,EAGL,KAAK,eAAe,EACpB,KAAK,WAAW,EAChB,KAAK,sBAAsB,EAC5B,MAAM,8BAA8B,CAAC;AAEtC,OAAO,EACL,KAAK,eAAe,IAAI,0BAA0B,EAClD,KAAK,UAAU,EACf,KAAK,eAAe,EAGrB,MAAM,UAAU,CAAC;AAElB;;;;;;GAMG;AACH,wBAAgB,aAAa,CAC3B,eAAe,EAAE,eAAe,EAChC,WAAW,EAAE,UAAU,EAAE,GACxB,UAAU,GAAG,SAAS,CAIxB;AAED,aAAK,oCAAoC,GAAG;IAC1C,4BAA4B,EAAE,YAAY,CAAC;IAC3C,yBAAyB,EAAE,eAAe,CAAC;IAC3C,0BAA0B,EAAE,0BAA0B,CAAC;CACxD,CAAC;AAEF,aAAK,iCAAiC,GAAG;IACvC,4BAA4B,EAAE,QAAQ,CAAC;IACvC,yBAAyB,EAAE,sBAAsB,CAAC;IAClD,0BAA0B,EAAE,0BAA0B,CAAC;CACxD,CAAC;AAEF;;;;;;;;GAQG;AACH,wBAAgB,oBAAoB,CAAC,EACnC,4BAA4B,EAC5B,yBAAyB,EACzB,0BAA0B,GAC3B,EACG,oCAAoC,GACpC,iCAAiC,GAAG,WAAW,CAAC,iBAAiB,CAAC,CAyBrE"}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/gas-flow.js b/node_modules/@metamask/transaction-controller/dist/utils/gas-flow.js
new file mode 100644
index 0000000..7f4e8a9
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/gas-flow.js
@@ -0,0 +1,56 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.mergeGasFeeEstimates = exports.getGasFeeFlow = void 0;
+const controller_utils_1 = require("@metamask/controller-utils");
+const gas_fee_controller_1 = require("@metamask/gas-fee-controller");
+const types_1 = require("../types");
+/**
+ * Returns the first gas fee flow that matches the transaction.
+ *
+ * @param transactionMeta - The transaction metadata to find a gas fee flow for.
+ * @param gasFeeFlows - The gas fee flows to search.
+ * @returns The first gas fee flow that matches the transaction, or undefined if none match.
+ */
+function getGasFeeFlow(transactionMeta, gasFeeFlows) {
+    return gasFeeFlows.find((gasFeeFlow) => gasFeeFlow.matchesTransaction(transactionMeta));
+}
+exports.getGasFeeFlow = getGasFeeFlow;
+/**
+ * Merge the gas fee estimates from the gas fee controller with the gas fee estimates from a transaction.
+ *
+ * @param request - Data required to merge gas fee estimates.
+ * @param request.gasFeeControllerEstimateType - Gas fee estimate type from the gas fee controller.
+ * @param request.gasFeeControllerEstimates - Gas fee estimates from the GasFeeController.
+ * @param request.transactionGasFeeEstimates - Gas fee estimates from the transaction.
+ * @returns The merged gas fee estimates.
+ */
+function mergeGasFeeEstimates({ gasFeeControllerEstimateType, gasFeeControllerEstimates, transactionGasFeeEstimates, }) {
+    if (gasFeeControllerEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.FEE_MARKET) {
+        return Object.values(types_1.GasFeeEstimateLevel).reduce((result, level) => (Object.assign(Object.assign({}, result), { [level]: mergeFeeMarketEstimate(gasFeeControllerEstimates[level], transactionGasFeeEstimates[level]) })), Object.assign({}, gasFeeControllerEstimates));
+    }
+    if (gasFeeControllerEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.LEGACY) {
+        return Object.values(types_1.GasFeeEstimateLevel).reduce((result, level) => (Object.assign(Object.assign({}, result), { [level]: getLegacyEstimate(transactionGasFeeEstimates[level]) })), {});
+    }
+    return gasFeeControllerEstimates;
+}
+exports.mergeGasFeeEstimates = mergeGasFeeEstimates;
+/**
+ * Merge a specific priority level of EIP-1559 gas fee estimates.
+ *
+ * @param gasFeeControllerEstimate - The gas fee estimate from the gas fee controller.
+ * @param transactionGasFeeEstimate - The gas fee estimate from the transaction.
+ * @returns The merged gas fee estimate.
+ */
+function mergeFeeMarketEstimate(gasFeeControllerEstimate, transactionGasFeeEstimate) {
+    return Object.assign(Object.assign({}, gasFeeControllerEstimate), { suggestedMaxFeePerGas: (0, controller_utils_1.weiHexToGweiDec)(transactionGasFeeEstimate.maxFeePerGas), suggestedMaxPriorityFeePerGas: (0, controller_utils_1.weiHexToGweiDec)(transactionGasFeeEstimate.maxPriorityFeePerGas) });
+}
+/**
+ * Generate a specific priority level for a legacy gas fee estimate.
+ *
+ * @param transactionGasFeeEstimate - The gas fee estimate from the transaction.
+ * @returns The legacy gas fee estimate.
+ */
+function getLegacyEstimate(transactionGasFeeEstimate) {
+    return (0, controller_utils_1.weiHexToGweiDec)(transactionGasFeeEstimate.maxFeePerGas);
+}
+//# sourceMappingURL=gas-flow.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/gas-flow.js.map b/node_modules/@metamask/transaction-controller/dist/utils/gas-flow.js.map
new file mode 100644
index 0000000..461ba2c
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/gas-flow.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"gas-flow.js","sourceRoot":"","sources":["../../src/utils/gas-flow.ts"],"names":[],"mappings":";;;AAAA,iEAA6D;AAC7D,qEAMsC;AAEtC,oCAMkB;AAElB;;;;;;GAMG;AACH,SAAgB,aAAa,CAC3B,eAAgC,EAChC,WAAyB;IAEzB,OAAO,WAAW,CAAC,IAAI,CAAC,CAAC,UAAU,EAAE,EAAE,CACrC,UAAU,CAAC,kBAAkB,CAAC,eAAe,CAAC,CAC/C,CAAC;AACJ,CAAC;AAPD,sCAOC;AAcD;;;;;;;;GAQG;AACH,SAAgB,oBAAoB,CAAC,EACnC,4BAA4B,EAC5B,yBAAyB,EACzB,0BAA0B,GAGS;IACnC,IAAI,4BAA4B,KAAK,uCAAkB,CAAC,UAAU,EAAE;QAClE,OAAO,MAAM,CAAC,MAAM,CAAC,2BAAmB,CAAC,CAAC,MAAM,CAC9C,CAAC,MAAM,EAAE,KAAK,EAAE,EAAE,CAAC,iCACd,MAAM,KACT,CAAC,KAAK,CAAC,EAAE,sBAAsB,CAC7B,yBAAyB,CAAC,KAAK,CAAC,EAChC,0BAA0B,CAAC,KAAK,CAAC,CAClC,IACD,EACF,kBAAK,yBAAyB,CAAqB,CACpD,CAAC;KACH;IAED,IAAI,4BAA4B,KAAK,uCAAkB,CAAC,MAAM,EAAE;QAC9D,OAAO,MAAM,CAAC,MAAM,CAAC,2BAAmB,CAAC,CAAC,MAAM,CAC9C,CAAC,MAAM,EAAE,KAAK,EAAE,EAAE,CAAC,iCACd,MAAM,KACT,CAAC,KAAK,CAAC,EAAE,iBAAiB,CAAC,0BAA0B,CAAC,KAAK,CAAC,CAAC,IAC7D,EACF,EAA4B,CAC7B,CAAC;KACH;IAED,OAAO,yBAAyB,CAAC;AACnC,CAAC;AA/BD,oDA+BC;AAED;;;;;;GAMG;AACH,SAAS,sBAAsB,CAC7B,wBAAuC,EACvC,yBAAkD;IAElD,uCACK,wBAAwB,KAC3B,qBAAqB,EAAE,IAAA,kCAAe,EACpC,yBAAyB,CAAC,YAAY,CACvC,EACD,6BAA6B,EAAE,IAAA,kCAAe,EAC5C,yBAAyB,CAAC,oBAAoB,CAC/C,IACD;AACJ,CAAC;AAED;;;;;GAKG;AACH,SAAS,iBAAiB,CACxB,yBAAkD;IAElD,OAAO,IAAA,kCAAe,EAAC,yBAAyB,CAAC,YAAY,CAAC,CAAC;AACjE,CAAC","sourcesContent":["import { weiHexToGweiDec } from '@metamask/controller-utils';\nimport {\n  GAS_ESTIMATE_TYPES,\n  type Eip1559GasFee,\n  type GasFeeEstimates,\n  type GasFeeState,\n  type LegacyGasPriceEstimate,\n} from '@metamask/gas-fee-controller';\n\nimport {\n  type GasFeeEstimates as TransactionGasFeeEstimates,\n  type GasFeeFlow,\n  type TransactionMeta,\n  type GasFeeEstimatesForLevel,\n  GasFeeEstimateLevel,\n} from '../types';\n\n/**\n * Returns the first gas fee flow that matches the transaction.\n *\n * @param transactionMeta - The transaction metadata to find a gas fee flow for.\n * @param gasFeeFlows - The gas fee flows to search.\n * @returns The first gas fee flow that matches the transaction, or undefined if none match.\n */\nexport function getGasFeeFlow(\n  transactionMeta: TransactionMeta,\n  gasFeeFlows: GasFeeFlow[],\n): GasFeeFlow | undefined {\n  return gasFeeFlows.find((gasFeeFlow) =>\n    gasFeeFlow.matchesTransaction(transactionMeta),\n  );\n}\n\ntype FeeMarketMergeGasFeeEstimatesRequest = {\n  gasFeeControllerEstimateType: 'fee-market';\n  gasFeeControllerEstimates: GasFeeEstimates;\n  transactionGasFeeEstimates: TransactionGasFeeEstimates;\n};\n\ntype LegacyMergeGasFeeEstimatesRequest = {\n  gasFeeControllerEstimateType: 'legacy';\n  gasFeeControllerEstimates: LegacyGasPriceEstimate;\n  transactionGasFeeEstimates: TransactionGasFeeEstimates;\n};\n\n/**\n * Merge the gas fee estimates from the gas fee controller with the gas fee estimates from a transaction.\n *\n * @param request - Data required to merge gas fee estimates.\n * @param request.gasFeeControllerEstimateType - Gas fee estimate type from the gas fee controller.\n * @param request.gasFeeControllerEstimates - Gas fee estimates from the GasFeeController.\n * @param request.transactionGasFeeEstimates - Gas fee estimates from the transaction.\n * @returns The merged gas fee estimates.\n */\nexport function mergeGasFeeEstimates({\n  gasFeeControllerEstimateType,\n  gasFeeControllerEstimates,\n  transactionGasFeeEstimates,\n}:\n  | FeeMarketMergeGasFeeEstimatesRequest\n  | LegacyMergeGasFeeEstimatesRequest): GasFeeState['gasFeeEstimates'] {\n  if (gasFeeControllerEstimateType === GAS_ESTIMATE_TYPES.FEE_MARKET) {\n    return Object.values(GasFeeEstimateLevel).reduce(\n      (result, level) => ({\n        ...result,\n        [level]: mergeFeeMarketEstimate(\n          gasFeeControllerEstimates[level],\n          transactionGasFeeEstimates[level],\n        ),\n      }),\n      { ...gasFeeControllerEstimates } as GasFeeEstimates,\n    );\n  }\n\n  if (gasFeeControllerEstimateType === GAS_ESTIMATE_TYPES.LEGACY) {\n    return Object.values(GasFeeEstimateLevel).reduce(\n      (result, level) => ({\n        ...result,\n        [level]: getLegacyEstimate(transactionGasFeeEstimates[level]),\n      }),\n      {} as LegacyGasPriceEstimate,\n    );\n  }\n\n  return gasFeeControllerEstimates;\n}\n\n/**\n * Merge a specific priority level of EIP-1559 gas fee estimates.\n *\n * @param gasFeeControllerEstimate - The gas fee estimate from the gas fee controller.\n * @param transactionGasFeeEstimate - The gas fee estimate from the transaction.\n * @returns The merged gas fee estimate.\n */\nfunction mergeFeeMarketEstimate(\n  gasFeeControllerEstimate: Eip1559GasFee,\n  transactionGasFeeEstimate: GasFeeEstimatesForLevel,\n): Eip1559GasFee {\n  return {\n    ...gasFeeControllerEstimate,\n    suggestedMaxFeePerGas: weiHexToGweiDec(\n      transactionGasFeeEstimate.maxFeePerGas,\n    ),\n    suggestedMaxPriorityFeePerGas: weiHexToGweiDec(\n      transactionGasFeeEstimate.maxPriorityFeePerGas,\n    ),\n  };\n}\n\n/**\n * Generate a specific priority level for a legacy gas fee estimate.\n *\n * @param transactionGasFeeEstimate - The gas fee estimate from the transaction.\n * @returns The legacy gas fee estimate.\n */\nfunction getLegacyEstimate(\n  transactionGasFeeEstimate: GasFeeEstimatesForLevel,\n): string {\n  return weiHexToGweiDec(transactionGasFeeEstimate.maxFeePerGas);\n}\n"]}
\ No newline at end of file