diff --git a/node_modules/@metamask/assets-controllers/dist/.patch.txt b/node_modules/@metamask/assets-controllers/dist/.patch.txt
new file mode 100644
index 0000000..b867ea9
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/.patch.txt
@@ -0,0 +1,14 @@
+PATCH GENERATED FROM MetaMask/core branch: patch/mobile-assets-controllers-26
+This patch backports various assets controllers features from the main branch of MetaMask/core
+Steps to update patch:
+* Create a new core branch from: patch/mobile-assets-controllers-26
+* Run "yarn build" in the core monorepo
+* Run "yarn patch:assets <core-directory>" in the mobile repo
+* If you have changes also add them to the branch: patch/mobile-assets-controllers-26
+* Steps to update the assets-controllers version
+* Create a new core branch from the next assets-controllers version
+* Merge the branch patch/mobile-assets-controllers-26
+* Solve the conflicts and review changes accordingly the changelog
+* Run "yarn build" in the core monorepo
+* Run "yarn patch:assets <core-directory>" in the mobile repo
+* If you have changes also add them to the branch: patch/mobile-assets-controllers-26
diff --git a/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.js b/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.js
index ee99eb2..a447b70 100644
--- a/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.js
+++ b/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.js
@@ -69,8 +69,12 @@ class AccountTrackerController extends polling_controller_1.StaticIntervalPollin
                     : [this.getSelectedAddress()];
                 const accountsForChain = Object.assign({}, accountsByChainId[chainId]);
                 for (const address of accountsToUpdate) {
+                    /**
+                     * IMPORTANT NOTE ABOUT THIS PATCH
+                     * This patch can be removed once Assets Controller is updated to v^27
+                     */
                     accountsForChain[address] = {
-                        balance: (0, controller_utils_1.BNToHex)(yield this.getBalanceFromChain(address, ethQuery)),
+                        balance: yield this.getBalanceFromChain(address, ethQuery),
                     };
                 }
                 this.update(Object.assign(Object.assign({}, (chainId === this.getCurrentChainId() && {
@@ -78,8 +82,12 @@ class AccountTrackerController extends polling_controller_1.StaticIntervalPollin
                 })), { accountsByChainId: Object.assign(Object.assign({}, this.state.accountsByChainId), { [chainId]: accountsForChain }) }));
             }
             catch (err) {
-                releaseLock();
                 throw err;
+            } finally {
+                /**
+                 * This change is not present on the core repo
+                 */
+                releaseLock();
             }
         });
         this.defaultConfig = {
diff --git a/node_modules/@metamask/assets-controllers/dist/NftController.d.ts b/node_modules/@metamask/assets-controllers/dist/NftController.d.ts
index 45e07b8..096baf1 100644
--- a/node_modules/@metamask/assets-controllers/dist/NftController.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/NftController.d.ts
@@ -8,7 +8,7 @@ import type { Hex } from '@metamask/utils';
 import { EventEmitter } from 'events';
 import type { AssetsContractController } from './AssetsContractController';
 import { Source } from './constants';
-import type { ApiNftCreator, ApiNftLastSale } from './NftDetectionController';
+import type { Collection, Attributes, LastSale } from './NftDetectionController';
 declare type NFTStandardType = 'ERC721' | 'ERC1155';
 declare type SuggestedNftMeta = {
     asset: {
@@ -21,75 +21,6 @@ declare type SuggestedNftMeta = {
     interactingAddress: string;
     origin: string;
 };
-export declare enum OpenSeaV2ChainIds {
-    ethereum = "ethereum"
-}
-export declare type OpenSeaV2GetNftResponse = {
-    nft: OpenSeaV2DetailedNft;
-};
-export declare type OpenSeaV2Nft = {
-    identifier: string;
-    collection: string;
-    contract: string;
-    token_standard: string;
-    name: string;
-    description: string;
-    image_url?: string;
-    metadata_url?: string;
-    updated_at: string;
-    is_disabled: boolean;
-    is_nsfw: boolean;
-};
-export declare type OpenSeaV2DetailedNft = OpenSeaV2Nft & {
-    animation_url?: string;
-    is_suspicious: boolean;
-    creator: string;
-    traits: {
-        trait_type: string;
-        display_type?: string;
-        max_value: string;
-        trait_count?: number;
-        value: number | string;
-    }[];
-    owners: {
-        address: string;
-        quantity: number;
-    }[];
-    rarity: {
-        rank: number;
-    };
-};
-export declare type OpenSeaV2ListNftsResponse = {
-    nfts: OpenSeaV2Nft[];
-    next?: string;
-};
-export declare type OpenSeaV2Contract = {
-    address: string;
-    chain: string;
-    collection: string;
-    contract_standard: string;
-    name: string;
-    total_supply?: number;
-};
-export declare type OpenSeaV2Collection = {
-    collection: string;
-    name: string;
-    description?: string;
-    image_url?: string;
-    owner: string;
-    category: string;
-    is_disabled: boolean;
-    is_nsfw: boolean;
-    trait_offers_enabled: boolean;
-    opensea_url: string;
-    project_url?: string;
-    wiki_url?: string;
-    discord_url?: string;
-    telegram_url?: string;
-    twitter_username?: string;
-    instagram_username?: string;
-    total_supply?: number;
-};
 /**
  * @type Nft
  *
@@ -116,6 +47,10 @@ export interface Nft extends NftMetadata {
     address: string;
     isCurrentlyOwned?: boolean;
 }
+export declare type NftUpdate = {
+    nft: Nft;
+    newMetadata: NftMetadata;
+};
 /**
  * @type NftContract
  *
@@ -175,10 +110,15 @@ export interface NftMetadata {
     animation?: string;
     animationOriginal?: string;
     externalLink?: string;
-    creator?: ApiNftCreator;
-    lastSale?: ApiNftLastSale;
+    creator?: string;
     transactionId?: string;
     tokenURI?: string | null;
+    error?: string;
+    collection?: Collection;
+    address?: string;
+    attributes?: Attributes;
+    lastSale?: LastSale;
+    rarityRank?: string;
 }
 /**
  * @type NftConfig
@@ -190,7 +130,7 @@ export interface NftConfig extends BaseConfig {
     selectedAddress: string;
     chainId: Hex;
     ipfsGateway: string;
-    openSeaEnabled: boolean;
+    displayNftMedia: boolean;
     useIPFSSubdomains: boolean;
     isIpfsGatewayEnabled: boolean;
 }
@@ -232,18 +172,17 @@ declare type AllowedActions = AddApprovalRequest;
  */
 export declare type NftControllerMessenger = RestrictedControllerMessenger<typeof controllerName, AllowedActions, never, AllowedActions['type'], never>;
 export declare const getDefaultNftState: () => NftState;
+/**
+ * Changes regarding displayNftMedia, TokenURI and error nft metadata property are not on the core repo and needed to be refactor to be removed from the patch
+ * updateNftMetadata changes will be introduced on latest versions of changes of assets controllers, v^30 or next
+ */
 /**
  * Controller that stores assets and exposes convenience methods
  */
 export declare class NftController extends BaseControllerV1<NftConfig, NftState> {
     private readonly mutex;
     private readonly messagingSystem;
-    getNftApi({ contractAddress, tokenId, }: {
-        contractAddress: string;
-        tokenId: string;
-    }): string;
-    private getNftContractInformationApi;
-    private getNftCollectionInformationApi;
+    getNftApi(): string;
     /**
      * Helper method to update nested state for allNfts and allNftContracts.
      *
@@ -255,7 +194,7 @@ export declare class NftController extends BaseControllerV1<NftConfig, NftState>
      */
     private updateNestedNftState;
     /**
-     * Request individual NFT information from OpenSea API.
+     * Request individual NFT information from NFT API.
      *
      * @param contractAddress - Hex address of the NFT contract.
      * @param tokenId - The NFT identifier.
@@ -289,13 +228,6 @@ export declare class NftController extends BaseControllerV1<NftConfig, NftState>
      * @returns Promise resolving to the current NFT name and image.
      */
     private getNftInformation;
-    /**
-     * Request NFT contract information from OpenSea API.
-     *
-     * @param contractAddress - Hex address of the NFT contract.
-     * @returns Promise resolving to the current NFT name and image.
-     */
-    private getNftContractInformationFromApi;
     /**
      * Request NFT contract information from the contract itself.
      *
@@ -305,9 +237,10 @@ export declare class NftController extends BaseControllerV1<NftConfig, NftState>
      */
     private getNftContractInformationFromContract;
     /**
-     * Request NFT contract information from OpenSea API.
+     * Request NFT contract information from Blockchain and aggregate with received data from NFTMetadata.
      *
      * @param contractAddress - Hex address of the NFT contract.
+     * @param nftMetadataFromApi - Received NFT information to be aggregated with blockchain contract information.
      * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
      * @returns Promise resolving to the NFT contract name, image and description.
      */
@@ -331,6 +264,7 @@ export declare class NftController extends BaseControllerV1<NftConfig, NftState>
      * @param options - options.
      * @param options.tokenAddress - Hex address of the NFT contract.
      * @param options.userAddress - The address of the account where the NFT is being added.
+     * @param options.nftMetadata - The retrieved NFTMetadata from API.
      * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
      * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.
      * @returns Promise resolving to the current NFT contracts list.
@@ -356,6 +290,19 @@ export declare class NftController extends BaseControllerV1<NftConfig, NftState>
      * @param options.userAddress - The address of the account where the NFT is being removed.
      */
     private removeIndividualNft;
+    /**
+     * Refetches NFT metadata and updates the state
+     *
+     * @param options - Options for refetching NFT metadata
+     * @param options.nfts - nfts to update metadata for.
+     * @param options.userAddress - The current user address
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     */
+    updateNftMetadata({ nfts, userAddress, networkClientId, }: {
+        nfts: Nft[];
+        userAddress?: string;
+        networkClientId?: NetworkClientId;
+    }): Promise<void>;
     /**
      * Removes an NFT contract to the stored NFT contracts list.
      *
@@ -423,9 +370,10 @@ export declare class NftController extends BaseControllerV1<NftConfig, NftState>
             tokenId: string;
             standard: string | null;
             source: string;
+            tokenURI?: string | null;
         }) => void;
         messenger: NftControllerMessenger;
-    }, config?: Partial<BaseConfig>, state?: Partial<NftState>);
+    }, config?: Partial<NftConfig>, state?: Partial<NftState>);
     private validateWatchNft;
     private getCorrectChainId;
     /**
diff --git a/node_modules/@metamask/assets-controllers/dist/NftController.js b/node_modules/@metamask/assets-controllers/dist/NftController.js
index 0873ccd..e06d80c 100644
--- a/node_modules/@metamask/assets-controllers/dist/NftController.js
+++ b/node_modules/@metamask/assets-controllers/dist/NftController.js
@@ -12,7 +12,7 @@ var __importDefault = (this && this.__importDefault) || function (mod) {
     return (mod && mod.__esModule) ? mod : { "default": mod };
 };
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.NftController = exports.getDefaultNftState = exports.OpenSeaV2ChainIds = void 0;
+exports.NftController = exports.getDefaultNftState = void 0;
 const address_1 = require("@ethersproject/address");
 const base_controller_1 = require("@metamask/base-controller");
 const controller_utils_1 = require("@metamask/controller-utils");
@@ -24,10 +24,6 @@ const events_1 = require("events");
 const uuid_1 = require("uuid");
 const assetsUtil_1 = require("./assetsUtil");
 const constants_1 = require("./constants");
-var OpenSeaV2ChainIds;
-(function (OpenSeaV2ChainIds) {
-    OpenSeaV2ChainIds["ethereum"] = "ethereum";
-})(OpenSeaV2ChainIds = exports.OpenSeaV2ChainIds || (exports.OpenSeaV2ChainIds = {}));
 const ALL_NFTS_STATE_KEY = 'allNfts';
 const ALL_NFTS_CONTRACTS_STATE_KEY = 'allNftContracts';
 /**
@@ -42,6 +38,10 @@ const getDefaultNftState = () => {
     };
 };
 exports.getDefaultNftState = getDefaultNftState;
+/**
+ * Changes regarding displayNftMedia, TokenURI and error nft metadata property are not on the core repo and needed to be refactor to be removed from the patch
+ * updateNftMetadata changes will be introduced on latest versions of changes of assets controllers, v^30 or next
+ */
 /**
  * Controller that stores assets and exposes convenience methods
  */
@@ -81,7 +81,7 @@ class NftController extends base_controller_1.BaseControllerV1 {
             selectedAddress: '',
             chainId: initialChainId,
             ipfsGateway: controller_utils_1.IPFS_DEFAULT_GATEWAY_URL,
-            openSeaEnabled: false,
+            displayNftMedia: false,
             useIPFSSubdomains: true,
             isIpfsGatewayEnabled: true,
         };
@@ -96,11 +96,11 @@ class NftController extends base_controller_1.BaseControllerV1 {
         this.getNetworkClientById = getNetworkClientById;
         this.onNftAdded = onNftAdded;
         this.messagingSystem = messenger;
-        onPreferencesStateChange(({ selectedAddress, ipfsGateway, openSeaEnabled, isIpfsGatewayEnabled, }) => {
+        onPreferencesStateChange(({ selectedAddress, ipfsGateway, displayNftMedia, isIpfsGatewayEnabled, }) => {
             this.configure({
                 selectedAddress,
                 ipfsGateway,
-                openSeaEnabled,
+                displayNftMedia,
                 isIpfsGatewayEnabled,
             });
         });
@@ -109,14 +109,8 @@ class NftController extends base_controller_1.BaseControllerV1 {
             this.configure({ chainId });
         });
     }
-    getNftApi({ contractAddress, tokenId, }) {
-        return `${controller_utils_1.OPENSEA_PROXY_URL}/chain/${OpenSeaV2ChainIds.ethereum}/contract/${contractAddress}/nfts/${tokenId}`;
-    }
-    getNftContractInformationApi({ contractAddress, }) {
-        return `${controller_utils_1.OPENSEA_PROXY_URL}/chain/${OpenSeaV2ChainIds.ethereum}/contract/${contractAddress}`;
-    }
-    getNftCollectionInformationApi({ collectionSlug, }) {
-        return `${controller_utils_1.OPENSEA_PROXY_URL}/collections/${collectionSlug}`;
+    getNftApi() {
+        return `${controller_utils_1.NFT_API_BASE_URL}/tokens`;
     }
     /**
      * Helper method to update nested state for allNfts and allNftContracts.
@@ -137,38 +131,49 @@ class NftController extends base_controller_1.BaseControllerV1 {
         });
     }
     /**
-     * Request individual NFT information from OpenSea API.
+     * Request individual NFT information from NFT API.
      *
      * @param contractAddress - Hex address of the NFT contract.
      * @param tokenId - The NFT identifier.
      * @returns Promise resolving to the current NFT name and image.
      */
     getNftInformationFromApi(contractAddress, tokenId) {
+        var _a, _b, _c, _d;
         return __awaiter(this, void 0, void 0, function* () {
             // TODO Parameterize this by chainId for non-mainnet token detection
-            // Attempt to fetch the data with the proxy
+            // Attempt to fetch the data with the nft-api
+            const urlParams = new URLSearchParams({
+                chainIds: '1',
+                tokens: `${contractAddress}:${tokenId}`,
+                includeTopBid: 'true',
+                includeAttributes: 'true',
+                includeLastSale: 'true',
+            }).toString();
             const nftInformation = yield (0, controller_utils_1.fetchWithErrorHandling)({
-                url: this.getNftApi({
-                    contractAddress,
-                    tokenId,
-                }),
+                url: `${this.getNftApi()}?${urlParams}`,
+                options: {
+                    headers: {
+                        Version: '1',
+                    },
+                },
             });
             // if we were still unable to fetch the data we return out the default/null of `NftMetadata`
-            if (!(nftInformation === null || nftInformation === void 0 ? void 0 : nftInformation.nft)) {
+            if (!((_b = (_a = nftInformation === null || nftInformation === void 0 ? void 0 : nftInformation.tokens) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.token)) {
                 return {
                     name: null,
                     description: null,
                     image: null,
                     standard: null,
+                    error: 'Opensea import error',
                 };
             }
             // if we've reached this point, we have successfully fetched some data for nftInformation
             // now we reconfigure the data to conform to the `NftMetadata` type for storage.
-            const { num_sales, background_color, image_url, image_preview_url, image_thumbnail_url, image_original_url, animation_url, animation_original_url, name, description, external_link, creator, last_sale, asset_contract: { schema_name }, } = (0, assetsUtil_1.mapOpenSeaDetailedNftV2ToV1)(nftInformation.nft);
+            const { image, metadata: { imageOriginal } = {}, name, description, collection, kind, rarityRank, rarity, attributes, lastSale, imageSmall, } = nftInformation.tokens[0].token;
             /* istanbul ignore next */
-            const nftMetadata = Object.assign({}, { name: name || null }, { description: description || null }, { image: image_url || null }, creator && { creator }, num_sales && { numberOfSales: num_sales }, background_color && { backgroundColor: background_color }, image_preview_url && { imagePreview: image_preview_url }, image_thumbnail_url && { imageThumbnail: image_thumbnail_url }, image_original_url && { imageOriginal: image_original_url }, animation_url && { animation: animation_url }, animation_original_url && {
-                animationOriginal: animation_original_url,
-            }, external_link && { externalLink: external_link }, last_sale && { lastSale: last_sale }, schema_name && { standard: schema_name });
+            const nftMetadata = Object.assign({}, { name: name || null }, { description: description || null }, { image: image || null }, (collection === null || collection === void 0 ? void 0 : collection.creator) && { creator: collection.creator }, imageOriginal && { imageOriginal }, imageSmall && { imageThumbnail: imageSmall }, kind && { standard: kind.toUpperCase() }, lastSale && { lastSale }, attributes && { attributes }, ((_c = nftInformation.tokens[0].market) === null || _c === void 0 ? void 0 : _c.topBid) && {
+                topBid: (_d = nftInformation.tokens[0].market) === null || _d === void 0 ? void 0 : _d.topBid,
+            }, rarityRank && { rarityRank }, rarity && { rarity }, collection && { collection });
             return nftMetadata;
         });
     }
@@ -182,10 +187,20 @@ class NftController extends base_controller_1.BaseControllerV1 {
      */
     getNftInformationFromTokenURI(contractAddress, tokenId, networkClientId) {
         return __awaiter(this, void 0, void 0, function* () {
-            const { ipfsGateway, useIPFSSubdomains, isIpfsGatewayEnabled } = this.config;
+            const { ipfsGateway, useIPFSSubdomains, isIpfsGatewayEnabled, displayNftMedia, } = this.config;
             const result = yield this.getNftURIAndStandard(contractAddress, tokenId, networkClientId);
             let tokenURI = result[0];
             const standard = result[1];
+            if (!displayNftMedia && !isIpfsGatewayEnabled) {
+                return {
+                    image: null,
+                    name: null,
+                    description: null,
+                    standard: standard || null,
+                    favorite: false,
+                    tokenURI,
+                };
+            }
             const hasIpfsTokenURI = tokenURI.startsWith('ipfs://');
             if (hasIpfsTokenURI && !isIpfsGatewayEnabled) {
                 return {
@@ -197,8 +212,7 @@ class NftController extends base_controller_1.BaseControllerV1 {
                     tokenURI: tokenURI !== null && tokenURI !== void 0 ? tokenURI : null,
                 };
             }
-            const isDisplayNFTMediaToggleEnabled = this.config.openSeaEnabled;
-            if (!hasIpfsTokenURI && !isDisplayNFTMediaToggleEnabled) {
+            if (!hasIpfsTokenURI && !displayNftMedia) {
                 return {
                     image: null,
                     name: null,
@@ -234,6 +248,7 @@ class NftController extends base_controller_1.BaseControllerV1 {
                     standard: standard || null,
                     favorite: false,
                     tokenURI: tokenURI !== null && tokenURI !== void 0 ? tokenURI : null,
+                    error: 'URI import error',
                 };
             }
         });
@@ -287,60 +302,29 @@ class NftController extends base_controller_1.BaseControllerV1 {
      * @returns Promise resolving to the current NFT name and image.
      */
     getNftInformation(contractAddress, tokenId, networkClientId) {
-        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
+        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
         return __awaiter(this, void 0, void 0, function* () {
             const chainId = this.getCorrectChainId({
                 networkClientId,
             });
-            const [blockchainMetadata, openSeaMetadata] = yield Promise.all([
+            const [blockchainMetadata, nftApiMetadata] = yield Promise.all([
                 (0, controller_utils_1.safelyExecute)(() => this.getNftInformationFromTokenURI(contractAddress, tokenId, networkClientId)),
-                this.config.openSeaEnabled && chainId === '0x1'
+                this.config.displayNftMedia && chainId === '0x1'
                     ? (0, controller_utils_1.safelyExecute)(() => this.getNftInformationFromApi(contractAddress, tokenId))
                     : undefined,
             ]);
-            return Object.assign(Object.assign({}, openSeaMetadata), { name: (_b = (_a = blockchainMetadata === null || blockchainMetadata === void 0 ? void 0 : blockchainMetadata.name) !== null && _a !== void 0 ? _a : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.name) !== null && _b !== void 0 ? _b : null, description: (_d = (_c = blockchainMetadata === null || blockchainMetadata === void 0 ? void 0 : blockchainMetadata.description) !== null && _c !== void 0 ? _c : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.description) !== null && _d !== void 0 ? _d : null, image: (_f = (_e = blockchainMetadata === null || blockchainMetadata === void 0 ? void 0 : blockchainMetadata.image) !== null && _e !== void 0 ? _e : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.image) !== null && _f !== void 0 ? _f : null, standard: (_h = (_g = blockchainMetadata === null || blockchainMetadata === void 0 ? void 0 : blockchainMetadata.standard) !== null && _g !== void 0 ? _g : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.standard) !== null && _h !== void 0 ? _h : null, tokenURI: (_j = blockchainMetadata === null || blockchainMetadata === void 0 ? void 0 : blockchainMetadata.tokenURI) !== null && _j !== void 0 ? _j : null });
-        });
-    }
-    /**
-     * Request NFT contract information from OpenSea API.
-     *
-     * @param contractAddress - Hex address of the NFT contract.
-     * @returns Promise resolving to the current NFT name and image.
-     */
-    getNftContractInformationFromApi(contractAddress) {
-        return __awaiter(this, void 0, void 0, function* () {
-            /* istanbul ignore if */
-            const apiNftContractObject = yield (0, controller_utils_1.fetchWithErrorHandling)({
-                url: this.getNftContractInformationApi({
-                    contractAddress,
-                }),
-            });
-            // If we successfully fetched the contract
-            if (apiNftContractObject) {
-                // Then fetch some additional details from the collection
-                const collection = yield (0, controller_utils_1.fetchWithErrorHandling)({
-                    url: this.getNftCollectionInformationApi({
-                        collectionSlug: apiNftContractObject.collection,
-                    }),
-                });
-                return (0, assetsUtil_1.mapOpenSeaContractV2ToV1)(apiNftContractObject, collection);
-            }
-            // If we've reached this point we were unable to fetch data from either the proxy or opensea so we return
-            // the default/null of ApiNftContract
-            return {
-                address: contractAddress,
-                asset_contract_type: null,
-                created_date: null,
-                schema_name: null,
-                symbol: null,
-                total_supply: null,
-                description: null,
-                external_link: null,
-                collection: {
+            if ((blockchainMetadata === null || blockchainMetadata === void 0 ? void 0 : blockchainMetadata.error) && (nftApiMetadata === null || nftApiMetadata === void 0 ? void 0 : nftApiMetadata.error)) {
+                return {
+                    image: null,
                     name: null,
-                    image_url: null,
-                },
-            };
+                    description: null,
+                    standard: (_a = blockchainMetadata.standard) !== null && _a !== void 0 ? _a : null,
+                    favorite: false,
+                    tokenURI: (_b = blockchainMetadata.tokenURI) !== null && _b !== void 0 ? _b : null,
+                    error: 'Both import failed',
+                };
+            }
+            return Object.assign(Object.assign({}, nftApiMetadata), { name: (_d = (_c = blockchainMetadata === null || blockchainMetadata === void 0 ? void 0 : blockchainMetadata.name) !== null && _c !== void 0 ? _c : nftApiMetadata === null || nftApiMetadata === void 0 ? void 0 : nftApiMetadata.name) !== null && _d !== void 0 ? _d : null, description: (_f = (_e = blockchainMetadata === null || blockchainMetadata === void 0 ? void 0 : blockchainMetadata.description) !== null && _e !== void 0 ? _e : nftApiMetadata === null || nftApiMetadata === void 0 ? void 0 : nftApiMetadata.description) !== null && _f !== void 0 ? _f : null, image: (_h = (_g = blockchainMetadata === null || blockchainMetadata === void 0 ? void 0 : blockchainMetadata.image) !== null && _g !== void 0 ? _g : nftApiMetadata === null || nftApiMetadata === void 0 ? void 0 : nftApiMetadata.image) !== null && _h !== void 0 ? _h : null, standard: (_k = (_j = blockchainMetadata === null || blockchainMetadata === void 0 ? void 0 : blockchainMetadata.standard) !== null && _j !== void 0 ? _j : nftApiMetadata === null || nftApiMetadata === void 0 ? void 0 : nftApiMetadata.standard) !== null && _k !== void 0 ? _k : null, tokenURI: (_l = blockchainMetadata === null || blockchainMetadata === void 0 ? void 0 : blockchainMetadata.tokenURI) !== null && _l !== void 0 ? _l : null });
         });
     }
     /**
@@ -364,25 +348,20 @@ class NftController extends base_controller_1.BaseControllerV1 {
         });
     }
     /**
-     * Request NFT contract information from OpenSea API.
+     * Request NFT contract information from Blockchain and aggregate with received data from NFTMetadata.
      *
      * @param contractAddress - Hex address of the NFT contract.
+     * @param nftMetadataFromApi - Received NFT information to be aggregated with blockchain contract information.
      * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
      * @returns Promise resolving to the NFT contract name, image and description.
      */
-    getNftContractInformation(contractAddress, networkClientId) {
+    getNftContractInformation(contractAddress, nftMetadataFromApi, networkClientId) {
+        var _a, _b, _c, _d, _e, _f, _g;
         return __awaiter(this, void 0, void 0, function* () {
-            const chainId = this.getCorrectChainId({
-                networkClientId,
-            });
-            const [blockchainContractData, openSeaContractData] = yield Promise.all([
-                (0, controller_utils_1.safelyExecute)(() => this.getNftContractInformationFromContract(contractAddress, networkClientId)),
-                this.config.openSeaEnabled && chainId === '0x1'
-                    ? (0, controller_utils_1.safelyExecute)(() => this.getNftContractInformationFromApi(contractAddress))
-                    : undefined,
-            ]);
-            if (blockchainContractData || openSeaContractData) {
-                return Object.assign(Object.assign(Object.assign({ address: contractAddress }, openSeaContractData), blockchainContractData), { collection: Object.assign(Object.assign({ name: null, image_url: null }, openSeaContractData === null || openSeaContractData === void 0 ? void 0 : openSeaContractData.collection), blockchainContractData === null || blockchainContractData === void 0 ? void 0 : blockchainContractData.collection) });
+            const blockchainContractData = yield (0, controller_utils_1.safelyExecute)(() => this.getNftContractInformationFromContract(contractAddress, networkClientId));
+            if (blockchainContractData ||
+                !Object.values(nftMetadataFromApi).every((value) => value === null)) {
+                return Object.assign(Object.assign({ address: contractAddress }, blockchainContractData), { schema_name: (_a = nftMetadataFromApi === null || nftMetadataFromApi === void 0 ? void 0 : nftMetadataFromApi.standard) !== null && _a !== void 0 ? _a : null, collection: Object.assign(Object.assign({ name: null, image_url: (_e = (_c = (_b = nftMetadataFromApi === null || nftMetadataFromApi === void 0 ? void 0 : nftMetadataFromApi.collection) === null || _b === void 0 ? void 0 : _b.image) !== null && _c !== void 0 ? _c : (_d = nftMetadataFromApi === null || nftMetadataFromApi === void 0 ? void 0 : nftMetadataFromApi.collection) === null || _d === void 0 ? void 0 : _d.imageUrl) !== null && _e !== void 0 ? _e : null, tokenCount: (_g = (_f = nftMetadataFromApi === null || nftMetadataFromApi === void 0 ? void 0 : nftMetadataFromApi.collection) === null || _f === void 0 ? void 0 : _f.tokenCount) !== null && _g !== void 0 ? _g : null }, nftMetadataFromApi === null || nftMetadataFromApi === void 0 ? void 0 : nftMetadataFromApi.collection), blockchainContractData === null || blockchainContractData === void 0 ? void 0 : blockchainContractData.collection) });
             }
             /* istanbul ignore next */
             return {
@@ -449,6 +428,7 @@ class NftController extends base_controller_1.BaseControllerV1 {
                         tokenId: tokenId.toString(),
                         standard: nftMetadata.standard,
                         source,
+                        tokenURI: nftMetadata.tokenURI,
                     });
                 }
                 return newNfts;
@@ -464,11 +444,12 @@ class NftController extends base_controller_1.BaseControllerV1 {
      * @param options - options.
      * @param options.tokenAddress - Hex address of the NFT contract.
      * @param options.userAddress - The address of the account where the NFT is being added.
+     * @param options.nftMetadata - The retrieved NFTMetadata from API.
      * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
      * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.
      * @returns Promise resolving to the current NFT contracts list.
      */
-    addNftContract({ tokenAddress, userAddress, networkClientId, source, }) {
+    addNftContract({ tokenAddress, userAddress, networkClientId, source, nftMetadata, }) {
         var _a;
         return __awaiter(this, void 0, void 0, function* () {
             const releaseLock = yield this.mutex.acquire();
@@ -485,8 +466,9 @@ class NftController extends base_controller_1.BaseControllerV1 {
                 }
                 // this doesn't work currently for detection if the user switches networks while the detection is processing
                 // will be fixed once detection uses networkClientIds
-                const contractInformation = yield this.getNftContractInformation(tokenAddress, networkClientId);
-                const { asset_contract_type, created_date, schema_name, symbol, total_supply, description, external_link, collection: { name, image_url }, } = contractInformation;
+                // get name and symbol if ERC721 then put together the metadata
+                const contractInformation = yield this.getNftContractInformation(tokenAddress, nftMetadata, networkClientId);
+                const { asset_contract_type, created_date, symbol, description, external_link, schema_name, collection: { name, image_url, tokenCount }, } = contractInformation;
                 // If the nft is auto-detected we want some valid metadata to be present
                 if (source === constants_1.Source.Detected &&
                     'address' in contractInformation &&
@@ -501,8 +483,8 @@ class NftController extends base_controller_1.BaseControllerV1 {
                     return nftContracts;
                 }
                 /* istanbul ignore next */
-                const newEntry = Object.assign({}, { address: tokenAddress }, description && { description }, name && { name }, image_url && { logo: image_url }, symbol && { symbol }, total_supply !== null &&
-                    typeof total_supply !== 'undefined' && { totalSupply: total_supply }, asset_contract_type && { assetContractType: asset_contract_type }, created_date && { createdDate: created_date }, schema_name && { schemaName: schema_name }, external_link && { externalLink: external_link });
+                const newEntry = Object.assign({}, { address: tokenAddress }, description && { description }, name && { name }, image_url && { logo: image_url }, symbol && { symbol }, tokenCount !== null &&
+                    typeof tokenCount !== 'undefined' && { totalSupply: tokenCount }, asset_contract_type && { assetContractType: asset_contract_type }, created_date && { createdDate: created_date }, schema_name && { schemaName: schema_name }, external_link && { externalLink: external_link });
                 const newNftContracts = [...nftContracts, newEntry];
                 this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY, {
                     chainId,
@@ -568,6 +550,49 @@ class NftController extends base_controller_1.BaseControllerV1 {
             chainId,
         });
     }
+    /**
+     * Refetches NFT metadata and updates the state
+     *
+     * @param options - Options for refetching NFT metadata
+     * @param options.nfts - nfts to update metadata for.
+     * @param options.userAddress - The current user address
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     */
+    updateNftMetadata({ nfts, userAddress = this.config.selectedAddress, networkClientId, }) {
+        var _a;
+        return __awaiter(this, void 0, void 0, function* () {
+            const chainId = this.getCorrectChainId({ networkClientId });
+            const nftsWithChecksumAdr = nfts.map((nft) => {
+                return Object.assign(Object.assign({}, nft), { address: (0, controller_utils_1.toChecksumHexAddress)(nft.address) });
+            });
+            const nftMetadataResults = yield Promise.allSettled(nftsWithChecksumAdr.map((nft) => __awaiter(this, void 0, void 0, function* () {
+                const resMetadata = yield this.getNftInformation(nft.address, nft.tokenId, networkClientId);
+                return {
+                    nft,
+                    newMetadata: resMetadata,
+                };
+            })));
+            const successfulNewFetchedNfts = nftMetadataResults.filter((result) => result.status === 'fulfilled');
+            // We want to avoid updating the state if the state and fetched nft info are the same
+            const nftsWithDifferentMetadata = [];
+            const { allNfts } = this.state;
+            const stateNfts = ((_a = allNfts[userAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
+            successfulNewFetchedNfts.forEach((singleNft) => {
+                const existingEntry = stateNfts.find((nft) => nft.address.toLowerCase() ===
+                    singleNft.value.nft.address.toLowerCase() &&
+                    nft.tokenId === singleNft.value.nft.tokenId);
+                if (existingEntry) {
+                    const differentMetadata = (0, assetsUtil_1.compareNftMetadata)(singleNft.value.newMetadata, existingEntry);
+                    if (differentMetadata) {
+                        nftsWithDifferentMetadata.push(singleNft);
+                    }
+                }
+            });
+            if (nftsWithDifferentMetadata.length !== 0) {
+                nftsWithDifferentMetadata.forEach((elm) => this.updateNft(elm.value.nft, elm.value.newMetadata, userAddress, chainId));
+            }
+        });
+    }
     /**
      * Removes an NFT contract to the stored NFT contracts list.
      *
@@ -763,15 +788,16 @@ class NftController extends base_controller_1.BaseControllerV1 {
         return __awaiter(this, void 0, void 0, function* () {
             tokenAddress = (0, controller_utils_1.toChecksumHexAddress)(tokenAddress);
             const chainId = this.getCorrectChainId({ networkClientId });
+            nftMetadata =
+                nftMetadata ||
+                    (yield this.getNftInformation(tokenAddress, tokenId, networkClientId));
             const newNftContracts = yield this.addNftContract({
                 tokenAddress,
                 userAddress,
                 networkClientId,
                 source,
+                nftMetadata,
             });
-            nftMetadata =
-                nftMetadata ||
-                    (yield this.getNftInformation(tokenAddress, tokenId, networkClientId));
             // If NFT contract was not added, do not add individual NFT
             const nftContract = newNftContracts.find((contract) => contract.address.toLowerCase() === tokenAddress.toLowerCase());
             // If NFT contract information, add individual NFT
diff --git a/node_modules/@metamask/assets-controllers/dist/NftDetectionController.d.ts b/node_modules/@metamask/assets-controllers/dist/NftDetectionController.d.ts
index d5c60db..adef299 100644
--- a/node_modules/@metamask/assets-controllers/dist/NftDetectionController.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/NftDetectionController.d.ts
@@ -3,6 +3,7 @@ import type { NetworkClientId, NetworkController, NetworkState, NetworkClient }
 import { StaticIntervalPollingControllerV1 } from '@metamask/polling-controller';
 import type { PreferencesState } from '@metamask/preferences-controller';
 import type { Hex } from '@metamask/utils';
+import { Source } from './constants';
 import { type NftController, type NftState } from './NftController';
 /**
  * @type ApiNft
@@ -67,6 +68,7 @@ export interface ApiNftContract {
     collection: {
         name: string | null;
         image_url?: string | null;
+        tokenCount?: string | null;
     };
 }
 /**
@@ -113,6 +115,188 @@ export interface NftDetectionConfig extends BaseConfig {
     chainId: Hex;
     selectedAddress: string;
 }
+export declare type ReservoirResponse = {
+    tokens: TokensResponse[];
+    continuation?: string;
+};
+export declare type TokensResponse = {
+    token: TokenResponse;
+    ownership: Ownership;
+    market?: Market;
+    blockaidResult?: Blockaid;
+};
+export declare enum BlockaidResultType {
+    Benign = "Benign",
+    Spam = "Spam",
+    Warning = "Warning",
+    Malicious = "Malicious"
+}
+export declare type Blockaid = {
+    contract: string;
+    chainId: number;
+    result_type: BlockaidResultType;
+    malicious_score: string;
+    attack_types: object;
+};
+export declare type Market = {
+    floorAsk?: FloorAsk;
+    topBid?: TopBid;
+};
+export declare type TokenResponse = {
+    chainId: number;
+    contract: string;
+    tokenId: string;
+    kind?: string;
+    name?: string;
+    image?: string;
+    imageSmall?: string;
+    imageLarge?: string;
+    metadata?: Metadata;
+    description?: string;
+    supply?: number;
+    remainingSupply?: number;
+    rarityScore?: number;
+    rarity?: number;
+    rarityRank?: number;
+    media?: string;
+    isFlagged?: boolean;
+    isSpam?: boolean;
+    isNsfw?: boolean;
+    metadataDisabled?: boolean;
+    lastFlagUpdate?: string;
+    lastFlagChange?: string;
+    collection?: Collection;
+    lastSale?: LastSale;
+    topBid?: TopBid;
+    lastAppraisalValue?: number;
+    attributes?: Attributes[];
+};
+export declare type TopBid = {
+    id?: string;
+    price?: Price;
+    source?: {
+        id?: string;
+        domain?: string;
+        name?: string;
+        icon?: string;
+        url?: string;
+    };
+};
+export declare type LastSale = {
+    saleId?: string;
+    token?: {
+        contract?: string;
+        tokenId?: string;
+        name?: string;
+        image?: string;
+        collection?: {
+            id?: string;
+            name?: string;
+        };
+    };
+    orderSource?: string;
+    orderSide?: 'ask' | 'bid';
+    orderKind?: string;
+    orderId?: string;
+    from?: string;
+    to?: string;
+    amount?: string;
+    fillSource?: string;
+    block?: number;
+    txHash?: string;
+    logIndex?: number;
+    batchIndex?: number;
+    timestamp?: number;
+    price?: Price;
+    washTradingScore?: number;
+    royaltyFeeBps?: number;
+    marketplaceFeeBps?: number;
+    paidFullRoyalty?: boolean;
+    feeBreakdown?: FeeBreakdown[];
+    isDeleted?: boolean;
+    createdAt?: string;
+    updatedAt?: string;
+};
+export declare type FeeBreakdown = {
+    kind?: string;
+    bps?: number;
+    recipient?: string;
+    source?: string;
+    rawAmount?: string;
+};
+export declare type Attributes = {
+    key?: string;
+    kind?: string;
+    value: string;
+    tokenCount?: number;
+    onSaleCount?: number;
+    floorAskPrice?: Price | null;
+    topBidValue?: number | null;
+    createdAt?: string;
+};
+export declare type Collection = {
+    id?: string;
+    name?: string;
+    slug?: string;
+    symbol?: string;
+    imageUrl?: string;
+    image?: string;
+    isSpam?: boolean;
+    isNsfw?: boolean;
+    creator?: string;
+    tokenCount?: string;
+    metadataDisabled?: boolean;
+    openseaVerificationStatus?: string;
+    floorAskPrice?: Price;
+    royaltiesBps?: number;
+    royalties?: Royalties[];
+};
+export declare type Royalties = {
+    bps?: number;
+    recipient?: string;
+};
+export declare type Ownership = {
+    tokenCount?: string;
+    onSaleCount?: string;
+    floorAsk?: FloorAsk;
+    acquiredAt?: string;
+};
+export declare type FloorAsk = {
+    id?: string;
+    price?: Price;
+    maker?: string;
+    kind?: string;
+    validFrom?: number;
+    validUntil?: number;
+    source?: Source;
+    rawData?: Metadata;
+    isNativeOffChainCancellable?: boolean;
+};
+export declare type Price = {
+    currency?: {
+        contract?: string;
+        name?: string;
+        symbol?: string;
+        decimals?: number;
+        chainId?: number;
+    };
+    amount?: {
+        raw?: string;
+        decimal?: number;
+        usd?: number;
+        native?: number;
+    };
+    netAmount?: {
+        raw?: string;
+        decimal?: number;
+        usd?: number;
+        native?: number;
+    };
+};
+export declare type Metadata = {
+    imageOriginal?: string;
+    tokenURI?: string;
+};
 /**
  * Controller that passively polls on a set interval for NFT auto detection
  */
diff --git a/node_modules/@metamask/assets-controllers/dist/NftDetectionController.js b/node_modules/@metamask/assets-controllers/dist/NftDetectionController.js
index 24373e3..2eb0892 100644
--- a/node_modules/@metamask/assets-controllers/dist/NftDetectionController.js
+++ b/node_modules/@metamask/assets-controllers/dist/NftDetectionController.js
@@ -9,13 +9,18 @@ var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, ge
     });
 };
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.NftDetectionController = void 0;
+exports.NftDetectionController = exports.BlockaidResultType = void 0;
 const controller_utils_1 = require("@metamask/controller-utils");
 const polling_controller_1 = require("@metamask/polling-controller");
-const assetsUtil_1 = require("./assetsUtil");
 const constants_1 = require("./constants");
-const NftController_1 = require("./NftController");
 const DEFAULT_INTERVAL = 180000;
+var BlockaidResultType;
+(function (BlockaidResultType) {
+    BlockaidResultType["Benign"] = "Benign";
+    BlockaidResultType["Spam"] = "Spam";
+    BlockaidResultType["Warning"] = "Warning";
+    BlockaidResultType["Malicious"] = "Malicious";
+})(BlockaidResultType = exports.BlockaidResultType || (exports.BlockaidResultType = {}));
 /**
  * Controller that passively polls on a set interval for NFT auto detection
  */
@@ -84,7 +89,7 @@ class NftDetectionController extends polling_controller_1.StaticIntervalPollingC
         this.setIntervalLength(this.config.interval);
     }
     getOwnerNftApi({ address, next, }) {
-        return `${controller_utils_1.OPENSEA_PROXY_URL}/chain/${NftController_1.OpenSeaV2ChainIds.ethereum}/account/${address}/nfts?limit=200&next=${next !== null && next !== void 0 ? next : ''}`;
+        return `${controller_utils_1.NFT_API_BASE_URL}/users/${address}/tokens?chainIds=1&limit=200&includeTopBid=true&continuation=${next !== null && next !== void 0 ? next : ''}`;
     }
     getOwnerNfts(address) {
         return __awaiter(this, void 0, void 0, function* () {
@@ -94,27 +99,25 @@ class NftDetectionController extends polling_controller_1.StaticIntervalPollingC
             do {
                 nftApiResponse = yield (0, controller_utils_1.fetchWithErrorHandling)({
                     url: this.getOwnerNftApi({ address, next }),
+                    options: {
+                        headers: {
+                            Version: '1',
+                        },
+                    },
                     timeout: 15000,
                 });
                 if (!nftApiResponse) {
                     return nfts;
                 }
-                const newNfts = yield Promise.all(nftApiResponse.nfts.map((nftV2) => __awaiter(this, void 0, void 0, function* () {
+                const newNfts = nftApiResponse.tokens.filter((elm) => {
                     var _a, _b;
-                    const nftV1 = (0, assetsUtil_1.mapOpenSeaNftV2ToV1)(nftV2);
-                    // If the image hasn't been processed into OpenSea's CDN, the image_url will be null.
-                    // Try fetching the NFT individually, which returns the original image url from metadata if available.
-                    if (!nftV1.image_url && nftV2.metadata_url) {
-                        const nftDetails = yield (0, controller_utils_1.safelyExecute)(() => (0, controller_utils_1.timeoutFetch)(this.getNftApi({
-                            contractAddress: nftV2.contract,
-                            tokenId: nftV2.identifier,
-                        }), undefined, 1000).then((r) => r.json()));
-                        nftV1.image_original_url = (_b = (_a = nftDetails === null || nftDetails === void 0 ? void 0 : nftDetails.nft) === null || _a === void 0 ? void 0 : _a.image_url) !== null && _b !== void 0 ? _b : null;
-                    }
-                    return nftV1;
-                })));
+                    return elm.token.isSpam === false &&
+                        (((_a = elm.blockaidResult) === null || _a === void 0 ? void 0 : _a.result_type)
+                            ? ((_b = elm.blockaidResult) === null || _b === void 0 ? void 0 : _b.result_type) === BlockaidResultType.Benign
+                            : true);
+                });
                 nfts = [...nfts, ...newNfts];
-            } while ((next = nftApiResponse.next));
+            } while ((next = nftApiResponse.continuation));
             return nfts;
         });
     }
@@ -180,24 +183,22 @@ class NftDetectionController extends polling_controller_1.StaticIntervalPollingC
             }
             const apiNfts = yield this.getOwnerNfts(userAddress);
             const addNftPromises = apiNfts.map((nft) => __awaiter(this, void 0, void 0, function* () {
-                const { token_id, num_sales, background_color, image_url, image_preview_url, image_thumbnail_url, image_original_url, animation_url, animation_original_url, name, description, external_link, creator, asset_contract: { address, schema_name }, last_sale, } = nft;
+                const { tokenId: token_id, contract, kind, image: image_url, imageSmall: image_thumbnail_url, metadata: { imageOriginal: image_original_url } = {}, name, description, attributes, topBid, lastSale, rarityRank, rarityScore, collection, } = nft.token;
                 let ignored;
                 /* istanbul ignore else */
                 const { ignoredNfts } = this.getNftState();
                 if (ignoredNfts.length) {
                     ignored = ignoredNfts.find((c) => {
                         /* istanbul ignore next */
-                        return (c.address === (0, controller_utils_1.toChecksumHexAddress)(address) &&
+                        return (c.address === (0, controller_utils_1.toChecksumHexAddress)(contract) &&
                             c.tokenId === token_id);
                     });
                 }
                 /* istanbul ignore else */
                 if (!ignored) {
                     /* istanbul ignore next */
-                    const nftMetadata = Object.assign({}, { name }, creator && { creator }, description && { description }, image_url && { image: image_url }, num_sales && { numberOfSales: num_sales }, background_color && { backgroundColor: background_color }, image_preview_url && { imagePreview: image_preview_url }, image_thumbnail_url && { imageThumbnail: image_thumbnail_url }, image_original_url && { imageOriginal: image_original_url }, animation_url && { animation: animation_url }, animation_original_url && {
-                        animationOriginal: animation_original_url,
-                    }, schema_name && { standard: schema_name }, external_link && { externalLink: external_link }, last_sale && { lastSale: last_sale });
-                    yield this.addNft(address, token_id, {
+                    const nftMetadata = Object.assign({}, { name }, description && { description }, image_url && { image: image_url }, image_thumbnail_url && { imageThumbnail: image_thumbnail_url }, image_original_url && { imageOriginal: image_original_url }, kind && { standard: kind.toUpperCase() }, lastSale && { lastSale }, attributes && { attributes }, topBid && { topBid }, rarityRank && { rarityRank }, rarityScore && { rarityScore }, collection && { collection });
+                    yield this.addNft(contract, token_id, {
                         nftMetadata,
                         userAddress,
                         source: constants_1.Source.Detected,
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.d.ts b/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.d.ts
index 796f2be..86d635f 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.d.ts
@@ -2,7 +2,7 @@ import { type RestrictedControllerMessenger, type ControllerGetStateAction, type
 import type { PreferencesControllerGetStateAction } from '@metamask/preferences-controller';
 import type { AssetsContractController } from './AssetsContractController';
 import type { Token } from './TokenRatesController';
-import type { TokensControllerStateChangeEvent } from './TokensController';
+import type { TokensControllerStateChangeEvent, TokensState } from './TokensController';
 declare const controllerName = "TokenBalancesController";
 /**
  * Token balances controller options
@@ -15,6 +15,7 @@ declare type TokenBalancesControllerOptions = {
     interval?: number;
     tokens?: Token[];
     disabled?: boolean;
+    onTokensStateChange: (listener: (tokensState: TokensState) => void) => void;
     getERC20BalanceOf: AssetsContractController['getERC20BalanceOf'];
     messenger: TokenBalancesControllerMessenger;
     state?: Partial<TokenBalancesControllerState>;
@@ -56,11 +57,12 @@ export declare class TokenBalancesController extends BaseController<typeof contr
      * @param options.interval - Polling interval used to fetch new token balances.
      * @param options.tokens - List of tokens to track balances for.
      * @param options.disabled - If set to true, all tracked tokens contract balances updates are blocked.
+     * @param options.onTokensStateChange - Allows subscribing to token controller state changes.
      * @param options.getERC20BalanceOf - Gets the balance of the given account at the given contract address.
      * @param options.state - Initial state to set on this controller.
      * @param options.messenger - The controller restricted messenger.
      */
-    constructor({ interval, tokens, disabled, getERC20BalanceOf, messenger, state, }: TokenBalancesControllerOptions);
+    constructor({ interval, tokens, disabled, onTokensStateChange, getERC20BalanceOf, messenger, state, }: TokenBalancesControllerOptions);
     /**
      * Allows controller to update tracked tokens contract balances.
      */
@@ -79,6 +81,11 @@ export declare class TokenBalancesController extends BaseController<typeof contr
      * Updates balances for all tokens.
      */
     updateBalances(): Promise<void>;
+    /**
+     * THIS FUNCTIONS IS CURRENTLY PATCHED AND STILL NEEDS TO BE IMPLEMENTED ON THE CORE REPO
+     * Resets to the default state
+     */
+    reset(): void;
 }
 export default TokenBalancesController;
 //# sourceMappingURL=TokenBalancesController.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.js b/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.js
index 7d09db2..fa7866f 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.js
+++ b/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.js
@@ -52,11 +52,12 @@ class TokenBalancesController extends base_controller_1.BaseController {
      * @param options.interval - Polling interval used to fetch new token balances.
      * @param options.tokens - List of tokens to track balances for.
      * @param options.disabled - If set to true, all tracked tokens contract balances updates are blocked.
+     * @param options.onTokensStateChange - Allows subscribing to token controller state changes.
      * @param options.getERC20BalanceOf - Gets the balance of the given account at the given contract address.
      * @param options.state - Initial state to set on this controller.
      * @param options.messenger - The controller restricted messenger.
      */
-    constructor({ interval = DEFAULT_INTERVAL, tokens = [], disabled = false, getERC20BalanceOf, messenger, state = {}, }) {
+    constructor({ interval = DEFAULT_INTERVAL, tokens = [], disabled = false, onTokensStateChange, getERC20BalanceOf, messenger, state = {}, }) {
         super({
             name: controllerName,
             metadata,
@@ -71,10 +72,10 @@ class TokenBalancesController extends base_controller_1.BaseController {
         __classPrivateFieldSet(this, _TokenBalancesController_disabled, disabled, "f");
         __classPrivateFieldSet(this, _TokenBalancesController_interval, interval, "f");
         __classPrivateFieldSet(this, _TokenBalancesController_tokens, tokens, "f");
-        this.messagingSystem.subscribe('TokensController:stateChange', ({ tokens: newTokens, detectedTokens }) => {
+        onTokensStateChange(({ tokens: newTokens, detectedTokens }) => __awaiter(this, void 0, void 0, function* () {
             __classPrivateFieldSet(this, _TokenBalancesController_tokens, [...newTokens, ...detectedTokens], "f");
-            this.updateBalances();
-        });
+            yield this.updateBalances();
+        }));
         __classPrivateFieldSet(this, _TokenBalancesController_getERC20BalanceOf, getERC20BalanceOf, "f");
         this.poll();
     }
@@ -135,6 +136,15 @@ class TokenBalancesController extends base_controller_1.BaseController {
             });
         });
     }
+    /**
+     * THIS FUNCTIONS IS CURRENTLY PATCHED AND STILL NEEDS TO BE IMPLEMENTED ON THE CORE REPO
+     * Resets to the default state
+     */
+    reset() {
+        this.update((state) => {
+            state.contractBalances = {};
+        });
+    }
 }
 exports.TokenBalancesController = TokenBalancesController;
 _TokenBalancesController_handle = new WeakMap(), _TokenBalancesController_getERC20BalanceOf = new WeakMap(), _TokenBalancesController_interval = new WeakMap(), _TokenBalancesController_tokens = new WeakMap(), _TokenBalancesController_disabled = new WeakMap();
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.d.ts b/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.d.ts
index 528f665..87859b7 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.d.ts
@@ -6,7 +6,7 @@ import { StaticIntervalPollingController } from '@metamask/polling-controller';
 import type { PreferencesControllerGetStateAction, PreferencesControllerStateChangeEvent } from '@metamask/preferences-controller';
 import type { AssetsContractController } from './AssetsContractController';
 import type { GetTokenListState, TokenListMap, TokenListStateChange } from './TokenListController';
-import type { TokensControllerAddDetectedTokensAction, TokensControllerGetStateAction } from './TokensController';
+import type { TokensControllerAddDetectedTokensAction, TokensControllerGetStateAction, TokensState } from './TokensController';
 /**
  * Compare 2 given strings and return boolean
  * eg: "foo" and "FOO" => true
@@ -54,11 +54,12 @@ export declare class TokenDetectionController extends StaticIntervalPollingContr
      * @param options.getBalancesInSingleCall - Gets the balances of a list of tokens for the given address.
      * @param options.trackMetaMetricsEvent - Sets options for MetaMetrics event tracking.
      */
-    constructor({ selectedAddress, interval, disabled, getBalancesInSingleCall, trackMetaMetricsEvent, messenger, }: {
+    constructor({ selectedAddress, interval, disabled, getBalancesInSingleCall, getTokensState, trackMetaMetricsEvent, messenger, }: {
         selectedAddress?: string;
         interval?: number;
         disabled?: boolean;
         getBalancesInSingleCall: AssetsContractController['getBalancesInSingleCall'];
+        getTokensState: () => TokensState;
         trackMetaMetricsEvent: (options: {
             event: string;
             category: string;
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.js b/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.js
index 9aa0914..d91cd80 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.js
+++ b/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.js
@@ -33,7 +33,7 @@ var __rest = (this && this.__rest) || function (s, e) {
 var __importDefault = (this && this.__importDefault) || function (mod) {
     return (mod && mod.__esModule) ? mod : { "default": mod };
 };
-var _TokenDetectionController_instances, _TokenDetectionController_intervalId, _TokenDetectionController_selectedAddress, _TokenDetectionController_networkClientId, _TokenDetectionController_tokenList, _TokenDetectionController_disabled, _TokenDetectionController_isUnlocked, _TokenDetectionController_isDetectionEnabledFromPreferences, _TokenDetectionController_isDetectionEnabledForNetwork, _TokenDetectionController_getBalancesInSingleCall, _TokenDetectionController_trackMetaMetricsEvent, _TokenDetectionController_registerEventListeners, _TokenDetectionController_stopPolling, _TokenDetectionController_startPolling, _TokenDetectionController_getCorrectChainIdAndNetworkClientId, _TokenDetectionController_restartTokenDetection, _TokenDetectionController_getSlicesOfTokensToDetect, _TokenDetectionController_addDetectedTokens;
+var _TokenDetectionController_instances, _TokenDetectionController_intervalId, _TokenDetectionController_selectedAddress, _TokenDetectionController_networkClientId, _TokenDetectionController_tokenList, _TokenDetectionController_disabled, _TokenDetectionController_isUnlocked, _TokenDetectionController_isDetectionEnabledFromPreferences, _TokenDetectionController_isDetectionEnabledForNetwork, _TokenDetectionController_getBalancesInSingleCall, _TokenDetectionController_getTokensState, _TokenDetectionController_trackMetaMetricsEvent, _TokenDetectionController_registerEventListeners, _TokenDetectionController_stopPolling, _TokenDetectionController_startPolling, _TokenDetectionController_getCorrectChainIdAndNetworkClientId, _TokenDetectionController_restartTokenDetection, _TokenDetectionController_getSlicesOfTokensToDetect, _TokenDetectionController_addDetectedTokens;
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.TokenDetectionController = exports.controllerName = exports.STATIC_MAINNET_TOKEN_LIST = exports.isEqualCaseInsensitive = void 0;
 const contract_metadata_1 = __importDefault(require("@metamask/contract-metadata"));
@@ -63,6 +63,12 @@ exports.STATIC_MAINNET_TOKEN_LIST = Object.entries(contract_metadata_1.default).
     return Object.assign(Object.assign({}, acc), { [base.toLowerCase()]: Object.assign(Object.assign({}, tokenMetadata), { address: base.toLowerCase(), iconUrl: `images/contract/${logo}`, aggregators: [] }) });
 }, {});
 exports.controllerName = 'TokenDetectionController';
+
+/**
+ * **IMPORTANT NOTE ABOUT THIS PATCH**
+ * TokenDetectionController patch can be removed once Tokens Controller extends Base Controller v2
+ */
+
 /**
  * Controller that passively polls on a set interval for Tokens auto detection
  * @property intervalId - Polling interval used to fetch new token rates
@@ -85,7 +91,7 @@ class TokenDetectionController extends polling_controller_1.StaticIntervalPollin
      * @param options.getBalancesInSingleCall - Gets the balances of a list of tokens for the given address.
      * @param options.trackMetaMetricsEvent - Sets options for MetaMetrics event tracking.
      */
-    constructor({ selectedAddress, interval = DEFAULT_INTERVAL, disabled = true, getBalancesInSingleCall, trackMetaMetricsEvent, messenger, }) {
+    constructor({ selectedAddress, interval = DEFAULT_INTERVAL, disabled = true, getBalancesInSingleCall, getTokensState, trackMetaMetricsEvent, messenger, }) {
         super({
             name: exports.controllerName,
             messenger,
@@ -102,6 +108,7 @@ class TokenDetectionController extends polling_controller_1.StaticIntervalPollin
         _TokenDetectionController_isDetectionEnabledFromPreferences.set(this, void 0);
         _TokenDetectionController_isDetectionEnabledForNetwork.set(this, void 0);
         _TokenDetectionController_getBalancesInSingleCall.set(this, void 0);
+        _TokenDetectionController_getTokensState.set(this, void 0);
         _TokenDetectionController_trackMetaMetricsEvent.set(this, void 0);
         __classPrivateFieldSet(this, _TokenDetectionController_disabled, disabled, "f");
         this.setIntervalLength(interval);
@@ -113,6 +120,7 @@ class TokenDetectionController extends polling_controller_1.StaticIntervalPollin
         __classPrivateFieldSet(this, _TokenDetectionController_isDetectionEnabledFromPreferences, defaultUseTokenDetection, "f");
         __classPrivateFieldSet(this, _TokenDetectionController_isDetectionEnabledForNetwork, (0, assetsUtil_1.isTokenDetectionSupportedForNetwork)(chainId), "f");
         __classPrivateFieldSet(this, _TokenDetectionController_getBalancesInSingleCall, getBalancesInSingleCall, "f");
+        __classPrivateFieldSet(this, _TokenDetectionController_getTokensState, getTokensState, "f");
         __classPrivateFieldSet(this, _TokenDetectionController_trackMetaMetricsEvent, trackMetaMetricsEvent, "f");
         const { isUnlocked } = this.messagingSystem.call('KeyringController:getState');
         __classPrivateFieldSet(this, _TokenDetectionController_isUnlocked, isUnlocked, "f");
@@ -210,7 +218,7 @@ class TokenDetectionController extends polling_controller_1.StaticIntervalPollin
     }
 }
 exports.TokenDetectionController = TokenDetectionController;
-_TokenDetectionController_intervalId = new WeakMap(), _TokenDetectionController_selectedAddress = new WeakMap(), _TokenDetectionController_networkClientId = new WeakMap(), _TokenDetectionController_tokenList = new WeakMap(), _TokenDetectionController_disabled = new WeakMap(), _TokenDetectionController_isUnlocked = new WeakMap(), _TokenDetectionController_isDetectionEnabledFromPreferences = new WeakMap(), _TokenDetectionController_isDetectionEnabledForNetwork = new WeakMap(), _TokenDetectionController_getBalancesInSingleCall = new WeakMap(), _TokenDetectionController_trackMetaMetricsEvent = new WeakMap(), _TokenDetectionController_instances = new WeakSet(), _TokenDetectionController_registerEventListeners = function _TokenDetectionController_registerEventListeners() {
+_TokenDetectionController_intervalId = new WeakMap(), _TokenDetectionController_selectedAddress = new WeakMap(), _TokenDetectionController_networkClientId = new WeakMap(), _TokenDetectionController_tokenList = new WeakMap(), _TokenDetectionController_disabled = new WeakMap(), _TokenDetectionController_isUnlocked = new WeakMap(), _TokenDetectionController_isDetectionEnabledFromPreferences = new WeakMap(), _TokenDetectionController_isDetectionEnabledForNetwork = new WeakMap(), _TokenDetectionController_getBalancesInSingleCall = new WeakMap(), _TokenDetectionController_getTokensState = new WeakMap(), _TokenDetectionController_trackMetaMetricsEvent = new WeakMap(), _TokenDetectionController_instances = new WeakSet(), _TokenDetectionController_registerEventListeners = function _TokenDetectionController_registerEventListeners() {
     this.messagingSystem.subscribe('KeyringController:unlock', () => __awaiter(this, void 0, void 0, function* () {
         __classPrivateFieldSet(this, _TokenDetectionController_isUnlocked, true, "f");
         yield __classPrivateFieldGet(this, _TokenDetectionController_instances, "m", _TokenDetectionController_restartTokenDetection).call(this);
@@ -298,7 +306,7 @@ _TokenDetectionController_intervalId = new WeakMap(), _TokenDetectionController_
         this.setIntervalLength(DEFAULT_INTERVAL);
     });
 }, _TokenDetectionController_getSlicesOfTokensToDetect = function _TokenDetectionController_getSlicesOfTokensToDetect({ chainId, selectedAddress, }) {
-    const { allTokens, allDetectedTokens, allIgnoredTokens } = this.messagingSystem.call('TokensController:getState');
+    const { allTokens, allDetectedTokens, allIgnoredTokens } = __classPrivateFieldGet(this, _TokenDetectionController_getTokensState, "f").call(this);
     const [tokensAddresses, detectedTokensAddresses, ignoredTokensAddresses] = [
         allTokens,
         allDetectedTokens,
diff --git a/node_modules/@metamask/assets-controllers/dist/assetsUtil.d.ts b/node_modules/@metamask/assets-controllers/dist/assetsUtil.d.ts
index 85c8569..aa14bc1 100644
--- a/node_modules/@metamask/assets-controllers/dist/assetsUtil.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/assetsUtil.d.ts
@@ -1,8 +1,7 @@
 import type { BigNumber } from '@ethersproject/bignumber';
 import type { Hex } from '@metamask/utils';
 import BN from 'bn.js';
-import type { Nft, NftMetadata, OpenSeaV2Collection, OpenSeaV2Contract, OpenSeaV2DetailedNft, OpenSeaV2Nft } from './NftController';
-import type { ApiNft, ApiNftContract } from './NftDetectionController';
+import type { Nft, NftMetadata } from './NftController';
 import type { AbstractTokenPricesService } from './token-prices-service';
 import { type ContractExchangeRates } from './TokenRatesController';
 /**
@@ -145,25 +144,6 @@ export declare function reduceInBatchesSerially<Value, Result extends Record<Pro
     eachBatch: (workingResult: Partial<Result>, batch: Value[], index: number) => Partial<Result> | Promise<Partial<Result>>;
     initialResult: Partial<Result>;
 }): Promise<Result>;
-/**
- * Maps an OpenSea V2 NFT to the V1 schema.
- * @param nft - The V2 NFT to map.
- * @returns The NFT in the V1 schema.
- */
-export declare function mapOpenSeaNftV2ToV1(nft: OpenSeaV2Nft): ApiNft;
-/**
- * Maps an OpenSea V2 detailed NFT to the V1 schema.
- * @param nft - The V2 detailed NFT to map.
- * @returns The NFT in the V1 schema.
- */
-export declare function mapOpenSeaDetailedNftV2ToV1(nft: OpenSeaV2DetailedNft): ApiNft;
-/**
- * Maps an OpenSea V2 contract to the V1 schema.
- * @param contract - The v2 contract data.
- * @param collection - The v2 collection data.
- * @returns The contract in the v1 schema.
- */
-export declare function mapOpenSeaContractV2ToV1(contract: OpenSeaV2Contract, collection?: OpenSeaV2Collection): ApiNftContract;
 /**
  * Retrieves token prices for a set of contract addresses in a specific currency and chainId.
  *
diff --git a/node_modules/@metamask/assets-controllers/dist/assetsUtil.js b/node_modules/@metamask/assets-controllers/dist/assetsUtil.js
index 2768926..1e81cde 100644
--- a/node_modules/@metamask/assets-controllers/dist/assetsUtil.js
+++ b/node_modules/@metamask/assets-controllers/dist/assetsUtil.js
@@ -12,7 +12,7 @@ var __importDefault = (this && this.__importDefault) || function (mod) {
     return (mod && mod.__esModule) ? mod : { "default": mod };
 };
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.fetchTokenContractExchangeRates = exports.mapOpenSeaContractV2ToV1 = exports.mapOpenSeaDetailedNftV2ToV1 = exports.mapOpenSeaNftV2ToV1 = exports.reduceInBatchesSerially = exports.divideIntoBatches = exports.ethersBigNumberToBN = exports.addUrlProtocolPrefix = exports.getFormattedIpfsUrl = exports.getIpfsCIDv1AndPath = exports.removeIpfsProtocolPrefix = exports.isTokenListSupportedForNetwork = exports.isTokenDetectionSupportedForNetwork = exports.SupportedTokenDetectionNetworks = exports.formatIconUrlWithProxy = exports.formatAggregatorNames = exports.compareNftMetadata = exports.TOKEN_PRICES_BATCH_SIZE = void 0;
+exports.fetchTokenContractExchangeRates = exports.reduceInBatchesSerially = exports.divideIntoBatches = exports.ethersBigNumberToBN = exports.addUrlProtocolPrefix = exports.getFormattedIpfsUrl = exports.getIpfsCIDv1AndPath = exports.removeIpfsProtocolPrefix = exports.isTokenListSupportedForNetwork = exports.isTokenDetectionSupportedForNetwork = exports.SupportedTokenDetectionNetworks = exports.formatIconUrlWithProxy = exports.formatAggregatorNames = exports.compareNftMetadata = exports.TOKEN_PRICES_BATCH_SIZE = void 0;
 const controller_utils_1 = require("@metamask/controller-utils");
 const utils_1 = require("@metamask/utils");
 const bn_js_1 = __importDefault(require("bn.js"));
@@ -268,84 +268,6 @@ function reduceInBatchesSerially({ values, batchSize, eachBatch, initialResult,
     });
 }
 exports.reduceInBatchesSerially = reduceInBatchesSerially;
-/**
- * Maps an OpenSea V2 NFT to the V1 schema.
- * @param nft - The V2 NFT to map.
- * @returns The NFT in the V1 schema.
- */
-function mapOpenSeaNftV2ToV1(nft) {
-    var _a;
-    return {
-        token_id: nft.identifier,
-        num_sales: null,
-        background_color: null,
-        image_url: (_a = nft.image_url) !== null && _a !== void 0 ? _a : null,
-        image_preview_url: null,
-        image_thumbnail_url: null,
-        image_original_url: null,
-        animation_url: null,
-        animation_original_url: null,
-        name: nft.name,
-        description: nft.description,
-        external_link: null,
-        asset_contract: {
-            address: nft.contract,
-            asset_contract_type: null,
-            created_date: null,
-            schema_name: nft.token_standard.toUpperCase(),
-            symbol: null,
-            total_supply: null,
-            description: nft.description,
-            external_link: null,
-            collection: {
-                name: nft.collection,
-                image_url: null,
-            },
-        },
-        creator: {
-            user: { username: '' },
-            profile_img_url: '',
-            address: '',
-        },
-        last_sale: null,
-    };
-}
-exports.mapOpenSeaNftV2ToV1 = mapOpenSeaNftV2ToV1;
-/**
- * Maps an OpenSea V2 detailed NFT to the V1 schema.
- * @param nft - The V2 detailed NFT to map.
- * @returns The NFT in the V1 schema.
- */
-function mapOpenSeaDetailedNftV2ToV1(nft) {
-    var _a;
-    const mapped = mapOpenSeaNftV2ToV1(nft);
-    return Object.assign(Object.assign({}, mapped), { animation_url: (_a = nft.animation_url) !== null && _a !== void 0 ? _a : null, creator: Object.assign(Object.assign({}, mapped.creator), { address: nft.creator }) });
-}
-exports.mapOpenSeaDetailedNftV2ToV1 = mapOpenSeaDetailedNftV2ToV1;
-/**
- * Maps an OpenSea V2 contract to the V1 schema.
- * @param contract - The v2 contract data.
- * @param collection - The v2 collection data.
- * @returns The contract in the v1 schema.
- */
-function mapOpenSeaContractV2ToV1(contract, collection) {
-    var _a, _b, _c, _d, _e, _f, _g;
-    return {
-        address: contract.address,
-        asset_contract_type: null,
-        created_date: null,
-        schema_name: contract.contract_standard.toUpperCase(),
-        symbol: null,
-        total_supply: (_d = (_b = (_a = collection === null || collection === void 0 ? void 0 : collection.total_supply) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : (_c = contract.total_supply) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : null,
-        description: (_e = collection === null || collection === void 0 ? void 0 : collection.description) !== null && _e !== void 0 ? _e : null,
-        external_link: (_f = collection === null || collection === void 0 ? void 0 : collection.project_url) !== null && _f !== void 0 ? _f : null,
-        collection: {
-            name: (_g = collection === null || collection === void 0 ? void 0 : collection.name) !== null && _g !== void 0 ? _g : contract.name,
-            image_url: collection === null || collection === void 0 ? void 0 : collection.image_url,
-        },
-    };
-}
-exports.mapOpenSeaContractV2ToV1 = mapOpenSeaContractV2ToV1;
 /**
  * Retrieves token prices for a set of contract addresses in a specific currency and chainId.
  *
diff --git a/node_modules/@metamask/assets-controllers/dist/index.d.ts b/node_modules/@metamask/assets-controllers/dist/index.d.ts
index 9c19787..489b198 100644
--- a/node_modules/@metamask/assets-controllers/dist/index.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/index.d.ts
@@ -3,7 +3,7 @@ export * from './AssetsContractController';
 export * from './CurrencyRateController';
 export * from './NftController';
 export * from './NftDetectionController';
-export type { TokenBalancesControllerMessenger, TokenBalancesControllerActions, TokenBalancesControllerGetStateAction, TokenBalancesControllerEvents, TokenBalancesControllerStateChangeEvent, } from './TokenBalancesController';
+export type { TokenBalancesControllerMessenger, TokenBalancesControllerActions, TokenBalancesControllerGetStateAction, TokenBalancesControllerEvents, TokenBalancesControllerStateChangeEvent, TokenBalancesControllerState, } from './TokenBalancesController';
 export { TokenBalancesController } from './TokenBalancesController';
 export type { TokenDetectionControllerMessenger, TokenDetectionControllerActions, TokenDetectionControllerGetStateAction, TokenDetectionControllerEvents, TokenDetectionControllerStateChangeEvent, } from './TokenDetectionController';
 export { TokenDetectionController } from './TokenDetectionController';
