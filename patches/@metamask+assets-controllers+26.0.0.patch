diff --git a/node_modules/@metamask/assets-controllers/dist/.patch.txt b/node_modules/@metamask/assets-controllers/dist/.patch.txt
new file mode 100644
index 0000000..e78640f
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/.patch.txt
@@ -0,0 +1,14 @@
+PATCH GENERATED FROM MetaMask/core branch: patch/mobile-assets-controllers-v-18-0-0
+This patch backports various assets controllers features from the main branch of MetaMask/core
+Steps to update patch:
+* Create a new core branch from: patch/mobile-assets-controllers-v-18-0-0
+* Run "yarn build" in the core monorepo
+* Run "yarn patch:assets <core-directory>" in the mobile repo
+* If you have changes also add them to the branch: patch/mobile-assets-controllers-v-18-0-0
+* Steps to update the assets-controllers version
+* Create a new core branch from the next assets-controllers version
+* Merge the branch patch/mobile-assets-controllers-v-18-0-0
+* Solve the conflicts and review changes accordingly the changelog
+* Run "yarn build" in the core monorepo
+* Run "yarn patch:assets <core-directory>" in the mobile repo
+* If you have changes also add them to the branch: patch/mobile-assets-controllers-v-18-0-0
diff --git a/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.js b/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.js
index ee99eb2..a447b70 100644
--- a/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.js
+++ b/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.js
@@ -69,8 +69,12 @@ class AccountTrackerController extends polling_controller_1.StaticIntervalPollin
                     : [this.getSelectedAddress()];
                 const accountsForChain = Object.assign({}, accountsByChainId[chainId]);
                 for (const address of accountsToUpdate) {
+                    /**
+                     * IMPORTANT NOTE ABOUT THIS PATCH
+                     * This patch can be removed once Assets Controller is updated to v^27
+                     */
                     accountsForChain[address] = {
-                        balance: (0, controller_utils_1.BNToHex)(yield this.getBalanceFromChain(address, ethQuery)),
+                        balance: yield this.getBalanceFromChain(address, ethQuery),
                     };
                 }
                 this.update(Object.assign(Object.assign({}, (chainId === this.getCurrentChainId() && {
@@ -78,8 +82,12 @@ class AccountTrackerController extends polling_controller_1.StaticIntervalPollin
                 })), { accountsByChainId: Object.assign(Object.assign({}, this.state.accountsByChainId), { [chainId]: accountsForChain }) }));
             }
             catch (err) {
-                releaseLock();
                 throw err;
+            } finally {
+                /**
+                 * This change is not present on the core repo
+                 */
+                releaseLock();
             }
         });
         this.defaultConfig = {
diff --git a/node_modules/@metamask/assets-controllers/dist/NftController.d.ts b/node_modules/@metamask/assets-controllers/dist/NftController.d.ts
index 45e07b8..80619dd 100644
--- a/node_modules/@metamask/assets-controllers/dist/NftController.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/NftController.d.ts
@@ -116,6 +116,10 @@ export interface Nft extends NftMetadata {
     address: string;
     isCurrentlyOwned?: boolean;
 }
+export declare type NftUpdate = {
+    nft: Nft;
+    newMetadata: NftMetadata;
+};
 /**
  * @type NftContract
  *
@@ -190,7 +194,7 @@ export interface NftConfig extends BaseConfig {
     selectedAddress: string;
     chainId: Hex;
     ipfsGateway: string;
-    openSeaEnabled: boolean;
+    displayNftMedia: boolean;
     useIPFSSubdomains: boolean;
     isIpfsGatewayEnabled: boolean;
 }
@@ -356,6 +360,19 @@ export declare class NftController extends BaseControllerV1<NftConfig, NftState>
      * @param options.userAddress - The address of the account where the NFT is being removed.
      */
     private removeIndividualNft;
+    /**
+     * Refetches NFT metadata and updates the state
+     *
+     * @param options - Options for refetching NFT metadata
+     * @param options.nfts - nfts to update metadata for.
+     * @param options.userAddress - The current user address
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     */
+    updateNftMetadata({ nfts, userAddress, networkClientId, }: {
+        nfts: Nft[];
+        userAddress?: string;
+        networkClientId?: NetworkClientId;
+    }): Promise<void>;
     /**
      * Removes an NFT contract to the stored NFT contracts list.
      *
diff --git a/node_modules/@metamask/assets-controllers/dist/NftController.js b/node_modules/@metamask/assets-controllers/dist/NftController.js
index 0873ccd..868a517 100644
--- a/node_modules/@metamask/assets-controllers/dist/NftController.js
+++ b/node_modules/@metamask/assets-controllers/dist/NftController.js
@@ -81,7 +81,7 @@ class NftController extends base_controller_1.BaseControllerV1 {
             selectedAddress: '',
             chainId: initialChainId,
             ipfsGateway: controller_utils_1.IPFS_DEFAULT_GATEWAY_URL,
-            openSeaEnabled: false,
+            displayNftMedia: false,
             useIPFSSubdomains: true,
             isIpfsGatewayEnabled: true,
         };
@@ -96,11 +96,11 @@ class NftController extends base_controller_1.BaseControllerV1 {
         this.getNetworkClientById = getNetworkClientById;
         this.onNftAdded = onNftAdded;
         this.messagingSystem = messenger;
-        onPreferencesStateChange(({ selectedAddress, ipfsGateway, openSeaEnabled, isIpfsGatewayEnabled, }) => {
+        onPreferencesStateChange(({ selectedAddress, ipfsGateway, displayNftMedia, isIpfsGatewayEnabled, }) => {
             this.configure({
                 selectedAddress,
                 ipfsGateway,
-                openSeaEnabled,
+                displayNftMedia,
                 isIpfsGatewayEnabled,
             });
         });
@@ -197,7 +197,7 @@ class NftController extends base_controller_1.BaseControllerV1 {
                     tokenURI: tokenURI !== null && tokenURI !== void 0 ? tokenURI : null,
                 };
             }
-            const isDisplayNFTMediaToggleEnabled = this.config.openSeaEnabled;
+            const isDisplayNFTMediaToggleEnabled = this.config.displayNftMedia;
             if (!hasIpfsTokenURI && !isDisplayNFTMediaToggleEnabled) {
                 return {
                     image: null,
@@ -294,7 +294,7 @@ class NftController extends base_controller_1.BaseControllerV1 {
             });
             const [blockchainMetadata, openSeaMetadata] = yield Promise.all([
                 (0, controller_utils_1.safelyExecute)(() => this.getNftInformationFromTokenURI(contractAddress, tokenId, networkClientId)),
-                this.config.openSeaEnabled && chainId === '0x1'
+                this.config.displayNftMedia && chainId === '0x1'
                     ? (0, controller_utils_1.safelyExecute)(() => this.getNftInformationFromApi(contractAddress, tokenId))
                     : undefined,
             ]);
@@ -377,7 +377,7 @@ class NftController extends base_controller_1.BaseControllerV1 {
             });
             const [blockchainContractData, openSeaContractData] = yield Promise.all([
                 (0, controller_utils_1.safelyExecute)(() => this.getNftContractInformationFromContract(contractAddress, networkClientId)),
-                this.config.openSeaEnabled && chainId === '0x1'
+                this.config.displayNftMedia && chainId === '0x1'
                     ? (0, controller_utils_1.safelyExecute)(() => this.getNftContractInformationFromApi(contractAddress))
                     : undefined,
             ]);
@@ -568,6 +568,49 @@ class NftController extends base_controller_1.BaseControllerV1 {
             chainId,
         });
     }
+    /**
+     * Refetches NFT metadata and updates the state
+     *
+     * @param options - Options for refetching NFT metadata
+     * @param options.nfts - nfts to update metadata for.
+     * @param options.userAddress - The current user address
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     */
+    updateNftMetadata({ nfts, userAddress = this.config.selectedAddress, networkClientId, }) {
+        var _a;
+        return __awaiter(this, void 0, void 0, function* () {
+            const chainId = this.getCorrectChainId({ networkClientId });
+            const nftsWithChecksumAdr = nfts.map((nft) => {
+                return Object.assign(Object.assign({}, nft), { address: (0, controller_utils_1.toChecksumHexAddress)(nft.address) });
+            });
+            const nftMetadataResults = yield Promise.allSettled(nftsWithChecksumAdr.map((nft) => __awaiter(this, void 0, void 0, function* () {
+                const resMetadata = yield this.getNftInformation(nft.address, nft.tokenId, networkClientId);
+                return {
+                    nft,
+                    newMetadata: resMetadata,
+                };
+            })));
+            const successfulNewFetchedNfts = nftMetadataResults.filter((result) => result.status === 'fulfilled');
+            // We want to avoid updating the state if the state and fetched nft info are the same
+            const nftsWithDifferentMetadata = [];
+            const { allNfts } = this.state;
+            const stateNfts = ((_a = allNfts[userAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
+            successfulNewFetchedNfts.forEach((singleNft) => {
+                const existingEntry = stateNfts.find((nft) => nft.address.toLowerCase() ===
+                    singleNft.value.nft.address.toLowerCase() &&
+                    nft.tokenId === singleNft.value.nft.tokenId);
+                if (existingEntry) {
+                    const differentMetadata = (0, assetsUtil_1.compareNftMetadata)(singleNft.value.newMetadata, existingEntry);
+                    if (differentMetadata) {
+                        nftsWithDifferentMetadata.push(singleNft);
+                    }
+                }
+            });
+            if (nftsWithDifferentMetadata.length !== 0) {
+                nftsWithDifferentMetadata.forEach((elm) => this.updateNft(elm.value.nft, elm.value.newMetadata, userAddress, chainId));
+            }
+        });
+    }
     /**
      * Removes an NFT contract to the stored NFT contracts list.
      *
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.d.ts b/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.d.ts
index 796f2be..86d635f 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.d.ts
@@ -2,7 +2,7 @@ import { type RestrictedControllerMessenger, type ControllerGetStateAction, type
 import type { PreferencesControllerGetStateAction } from '@metamask/preferences-controller';
 import type { AssetsContractController } from './AssetsContractController';
 import type { Token } from './TokenRatesController';
-import type { TokensControllerStateChangeEvent } from './TokensController';
+import type { TokensControllerStateChangeEvent, TokensState } from './TokensController';
 declare const controllerName = "TokenBalancesController";
 /**
  * Token balances controller options
@@ -15,6 +15,7 @@ declare type TokenBalancesControllerOptions = {
     interval?: number;
     tokens?: Token[];
     disabled?: boolean;
+    onTokensStateChange: (listener: (tokensState: TokensState) => void) => void;
     getERC20BalanceOf: AssetsContractController['getERC20BalanceOf'];
     messenger: TokenBalancesControllerMessenger;
     state?: Partial<TokenBalancesControllerState>;
@@ -56,11 +57,12 @@ export declare class TokenBalancesController extends BaseController<typeof contr
      * @param options.interval - Polling interval used to fetch new token balances.
      * @param options.tokens - List of tokens to track balances for.
      * @param options.disabled - If set to true, all tracked tokens contract balances updates are blocked.
+     * @param options.onTokensStateChange - Allows subscribing to token controller state changes.
      * @param options.getERC20BalanceOf - Gets the balance of the given account at the given contract address.
      * @param options.state - Initial state to set on this controller.
      * @param options.messenger - The controller restricted messenger.
      */
-    constructor({ interval, tokens, disabled, getERC20BalanceOf, messenger, state, }: TokenBalancesControllerOptions);
+    constructor({ interval, tokens, disabled, onTokensStateChange, getERC20BalanceOf, messenger, state, }: TokenBalancesControllerOptions);
     /**
      * Allows controller to update tracked tokens contract balances.
      */
@@ -79,6 +81,11 @@ export declare class TokenBalancesController extends BaseController<typeof contr
      * Updates balances for all tokens.
      */
     updateBalances(): Promise<void>;
+    /**
+     * THIS FUNCTIONS IS CURRENTLY PATCHED AND STILL NEEDS TO BE IMPLEMENTED ON THE CORE REPO
+     * Resets to the default state
+     */
+    reset(): void;
 }
 export default TokenBalancesController;
 //# sourceMappingURL=TokenBalancesController.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.js b/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.js
index 7d09db2..fa7866f 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.js
+++ b/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.js
@@ -52,11 +52,12 @@ class TokenBalancesController extends base_controller_1.BaseController {
      * @param options.interval - Polling interval used to fetch new token balances.
      * @param options.tokens - List of tokens to track balances for.
      * @param options.disabled - If set to true, all tracked tokens contract balances updates are blocked.
+     * @param options.onTokensStateChange - Allows subscribing to token controller state changes.
      * @param options.getERC20BalanceOf - Gets the balance of the given account at the given contract address.
      * @param options.state - Initial state to set on this controller.
      * @param options.messenger - The controller restricted messenger.
      */
-    constructor({ interval = DEFAULT_INTERVAL, tokens = [], disabled = false, getERC20BalanceOf, messenger, state = {}, }) {
+    constructor({ interval = DEFAULT_INTERVAL, tokens = [], disabled = false, onTokensStateChange, getERC20BalanceOf, messenger, state = {}, }) {
         super({
             name: controllerName,
             metadata,
@@ -71,10 +72,10 @@ class TokenBalancesController extends base_controller_1.BaseController {
         __classPrivateFieldSet(this, _TokenBalancesController_disabled, disabled, "f");
         __classPrivateFieldSet(this, _TokenBalancesController_interval, interval, "f");
         __classPrivateFieldSet(this, _TokenBalancesController_tokens, tokens, "f");
-        this.messagingSystem.subscribe('TokensController:stateChange', ({ tokens: newTokens, detectedTokens }) => {
+        onTokensStateChange(({ tokens: newTokens, detectedTokens }) => __awaiter(this, void 0, void 0, function* () {
             __classPrivateFieldSet(this, _TokenBalancesController_tokens, [...newTokens, ...detectedTokens], "f");
-            this.updateBalances();
-        });
+            yield this.updateBalances();
+        }));
         __classPrivateFieldSet(this, _TokenBalancesController_getERC20BalanceOf, getERC20BalanceOf, "f");
         this.poll();
     }
@@ -135,6 +136,15 @@ class TokenBalancesController extends base_controller_1.BaseController {
             });
         });
     }
+    /**
+     * THIS FUNCTIONS IS CURRENTLY PATCHED AND STILL NEEDS TO BE IMPLEMENTED ON THE CORE REPO
+     * Resets to the default state
+     */
+    reset() {
+        this.update((state) => {
+            state.contractBalances = {};
+        });
+    }
 }
 exports.TokenBalancesController = TokenBalancesController;
 _TokenBalancesController_handle = new WeakMap(), _TokenBalancesController_getERC20BalanceOf = new WeakMap(), _TokenBalancesController_interval = new WeakMap(), _TokenBalancesController_tokens = new WeakMap(), _TokenBalancesController_disabled = new WeakMap();
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.d.ts b/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.d.ts
index 528f665..87859b7 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.d.ts
@@ -6,7 +6,7 @@ import { StaticIntervalPollingController } from '@metamask/polling-controller';
 import type { PreferencesControllerGetStateAction, PreferencesControllerStateChangeEvent } from '@metamask/preferences-controller';
 import type { AssetsContractController } from './AssetsContractController';
 import type { GetTokenListState, TokenListMap, TokenListStateChange } from './TokenListController';
-import type { TokensControllerAddDetectedTokensAction, TokensControllerGetStateAction } from './TokensController';
+import type { TokensControllerAddDetectedTokensAction, TokensControllerGetStateAction, TokensState } from './TokensController';
 /**
  * Compare 2 given strings and return boolean
  * eg: "foo" and "FOO" => true
@@ -54,11 +54,12 @@ export declare class TokenDetectionController extends StaticIntervalPollingContr
      * @param options.getBalancesInSingleCall - Gets the balances of a list of tokens for the given address.
      * @param options.trackMetaMetricsEvent - Sets options for MetaMetrics event tracking.
      */
-    constructor({ selectedAddress, interval, disabled, getBalancesInSingleCall, trackMetaMetricsEvent, messenger, }: {
+    constructor({ selectedAddress, interval, disabled, getBalancesInSingleCall, getTokensState, trackMetaMetricsEvent, messenger, }: {
         selectedAddress?: string;
         interval?: number;
         disabled?: boolean;
         getBalancesInSingleCall: AssetsContractController['getBalancesInSingleCall'];
+        getTokensState: () => TokensState;
         trackMetaMetricsEvent: (options: {
             event: string;
             category: string;
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.js b/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.js
index 9aa0914..d91cd80 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.js
+++ b/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.js
@@ -33,7 +33,7 @@ var __rest = (this && this.__rest) || function (s, e) {
 var __importDefault = (this && this.__importDefault) || function (mod) {
     return (mod && mod.__esModule) ? mod : { "default": mod };
 };
-var _TokenDetectionController_instances, _TokenDetectionController_intervalId, _TokenDetectionController_selectedAddress, _TokenDetectionController_networkClientId, _TokenDetectionController_tokenList, _TokenDetectionController_disabled, _TokenDetectionController_isUnlocked, _TokenDetectionController_isDetectionEnabledFromPreferences, _TokenDetectionController_isDetectionEnabledForNetwork, _TokenDetectionController_getBalancesInSingleCall, _TokenDetectionController_trackMetaMetricsEvent, _TokenDetectionController_registerEventListeners, _TokenDetectionController_stopPolling, _TokenDetectionController_startPolling, _TokenDetectionController_getCorrectChainIdAndNetworkClientId, _TokenDetectionController_restartTokenDetection, _TokenDetectionController_getSlicesOfTokensToDetect, _TokenDetectionController_addDetectedTokens;
+var _TokenDetectionController_instances, _TokenDetectionController_intervalId, _TokenDetectionController_selectedAddress, _TokenDetectionController_networkClientId, _TokenDetectionController_tokenList, _TokenDetectionController_disabled, _TokenDetectionController_isUnlocked, _TokenDetectionController_isDetectionEnabledFromPreferences, _TokenDetectionController_isDetectionEnabledForNetwork, _TokenDetectionController_getBalancesInSingleCall, _TokenDetectionController_getTokensState, _TokenDetectionController_trackMetaMetricsEvent, _TokenDetectionController_registerEventListeners, _TokenDetectionController_stopPolling, _TokenDetectionController_startPolling, _TokenDetectionController_getCorrectChainIdAndNetworkClientId, _TokenDetectionController_restartTokenDetection, _TokenDetectionController_getSlicesOfTokensToDetect, _TokenDetectionController_addDetectedTokens;
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.TokenDetectionController = exports.controllerName = exports.STATIC_MAINNET_TOKEN_LIST = exports.isEqualCaseInsensitive = void 0;
 const contract_metadata_1 = __importDefault(require("@metamask/contract-metadata"));
@@ -63,6 +63,12 @@ exports.STATIC_MAINNET_TOKEN_LIST = Object.entries(contract_metadata_1.default).
     return Object.assign(Object.assign({}, acc), { [base.toLowerCase()]: Object.assign(Object.assign({}, tokenMetadata), { address: base.toLowerCase(), iconUrl: `images/contract/${logo}`, aggregators: [] }) });
 }, {});
 exports.controllerName = 'TokenDetectionController';
+
+/**
+ * **IMPORTANT NOTE ABOUT THIS PATCH**
+ * TokenDetectionController patch can be removed once Tokens Controller extends Base Controller v2
+ */
+
 /**
  * Controller that passively polls on a set interval for Tokens auto detection
  * @property intervalId - Polling interval used to fetch new token rates
@@ -85,7 +91,7 @@ class TokenDetectionController extends polling_controller_1.StaticIntervalPollin
      * @param options.getBalancesInSingleCall - Gets the balances of a list of tokens for the given address.
      * @param options.trackMetaMetricsEvent - Sets options for MetaMetrics event tracking.
      */
-    constructor({ selectedAddress, interval = DEFAULT_INTERVAL, disabled = true, getBalancesInSingleCall, trackMetaMetricsEvent, messenger, }) {
+    constructor({ selectedAddress, interval = DEFAULT_INTERVAL, disabled = true, getBalancesInSingleCall, getTokensState, trackMetaMetricsEvent, messenger, }) {
         super({
             name: exports.controllerName,
             messenger,
@@ -102,6 +108,7 @@ class TokenDetectionController extends polling_controller_1.StaticIntervalPollin
         _TokenDetectionController_isDetectionEnabledFromPreferences.set(this, void 0);
         _TokenDetectionController_isDetectionEnabledForNetwork.set(this, void 0);
         _TokenDetectionController_getBalancesInSingleCall.set(this, void 0);
+        _TokenDetectionController_getTokensState.set(this, void 0);
         _TokenDetectionController_trackMetaMetricsEvent.set(this, void 0);
         __classPrivateFieldSet(this, _TokenDetectionController_disabled, disabled, "f");
         this.setIntervalLength(interval);
@@ -113,6 +120,7 @@ class TokenDetectionController extends polling_controller_1.StaticIntervalPollin
         __classPrivateFieldSet(this, _TokenDetectionController_isDetectionEnabledFromPreferences, defaultUseTokenDetection, "f");
         __classPrivateFieldSet(this, _TokenDetectionController_isDetectionEnabledForNetwork, (0, assetsUtil_1.isTokenDetectionSupportedForNetwork)(chainId), "f");
         __classPrivateFieldSet(this, _TokenDetectionController_getBalancesInSingleCall, getBalancesInSingleCall, "f");
+        __classPrivateFieldSet(this, _TokenDetectionController_getTokensState, getTokensState, "f");
         __classPrivateFieldSet(this, _TokenDetectionController_trackMetaMetricsEvent, trackMetaMetricsEvent, "f");
         const { isUnlocked } = this.messagingSystem.call('KeyringController:getState');
         __classPrivateFieldSet(this, _TokenDetectionController_isUnlocked, isUnlocked, "f");
@@ -210,7 +218,7 @@ class TokenDetectionController extends polling_controller_1.StaticIntervalPollin
     }
 }
 exports.TokenDetectionController = TokenDetectionController;
-_TokenDetectionController_intervalId = new WeakMap(), _TokenDetectionController_selectedAddress = new WeakMap(), _TokenDetectionController_networkClientId = new WeakMap(), _TokenDetectionController_tokenList = new WeakMap(), _TokenDetectionController_disabled = new WeakMap(), _TokenDetectionController_isUnlocked = new WeakMap(), _TokenDetectionController_isDetectionEnabledFromPreferences = new WeakMap(), _TokenDetectionController_isDetectionEnabledForNetwork = new WeakMap(), _TokenDetectionController_getBalancesInSingleCall = new WeakMap(), _TokenDetectionController_trackMetaMetricsEvent = new WeakMap(), _TokenDetectionController_instances = new WeakSet(), _TokenDetectionController_registerEventListeners = function _TokenDetectionController_registerEventListeners() {
+_TokenDetectionController_intervalId = new WeakMap(), _TokenDetectionController_selectedAddress = new WeakMap(), _TokenDetectionController_networkClientId = new WeakMap(), _TokenDetectionController_tokenList = new WeakMap(), _TokenDetectionController_disabled = new WeakMap(), _TokenDetectionController_isUnlocked = new WeakMap(), _TokenDetectionController_isDetectionEnabledFromPreferences = new WeakMap(), _TokenDetectionController_isDetectionEnabledForNetwork = new WeakMap(), _TokenDetectionController_getBalancesInSingleCall = new WeakMap(), _TokenDetectionController_getTokensState = new WeakMap(), _TokenDetectionController_trackMetaMetricsEvent = new WeakMap(), _TokenDetectionController_instances = new WeakSet(), _TokenDetectionController_registerEventListeners = function _TokenDetectionController_registerEventListeners() {
     this.messagingSystem.subscribe('KeyringController:unlock', () => __awaiter(this, void 0, void 0, function* () {
         __classPrivateFieldSet(this, _TokenDetectionController_isUnlocked, true, "f");
         yield __classPrivateFieldGet(this, _TokenDetectionController_instances, "m", _TokenDetectionController_restartTokenDetection).call(this);
@@ -298,7 +306,7 @@ _TokenDetectionController_intervalId = new WeakMap(), _TokenDetectionController_
         this.setIntervalLength(DEFAULT_INTERVAL);
     });
 }, _TokenDetectionController_getSlicesOfTokensToDetect = function _TokenDetectionController_getSlicesOfTokensToDetect({ chainId, selectedAddress, }) {
-    const { allTokens, allDetectedTokens, allIgnoredTokens } = this.messagingSystem.call('TokensController:getState');
+    const { allTokens, allDetectedTokens, allIgnoredTokens } = __classPrivateFieldGet(this, _TokenDetectionController_getTokensState, "f").call(this);
     const [tokensAddresses, detectedTokensAddresses, ignoredTokensAddresses] = [
         allTokens,
         allDetectedTokens,
