diff --git a/node_modules/@metamask/network-controller/dist/NetworkController.cjs b/node_modules/@metamask/network-controller/dist/NetworkController.cjs
index ca0fdc1..6c52629 100644
--- a/node_modules/@metamask/network-controller/dist/NetworkController.cjs
+++ b/node_modules/@metamask/network-controller/dist/NetworkController.cjs
@@ -45,6 +45,7 @@ const eth_query_1 = __importDefault(require("@metamask/eth-query"));
 const rpc_errors_1 = require("@metamask/rpc-errors");
 const swappable_obj_proxy_1 = require("@metamask/swappable-obj-proxy");
 const utils_1 = require("@metamask/utils");
+const immer_1 = require("immer");
 const fast_deep_equal_1 = __importDefault(require("fast-deep-equal"));
 const lodash_1 = require("lodash");
 const reselect_1 = require("reselect");
@@ -286,7 +287,7 @@ function deriveInfuraNetworkNameFromRpcEndpointUrl(rpcEndpointUrl) {
  * @param state - The NetworkController state to verify.
  * @throws if the state is invalid in some way.
  */
-function validateNetworkControllerState(state) {
+function validateInitialState(state) {
     const networkConfigurationEntries = Object.entries(state.networkConfigurationsByChainId);
     const networkClientIds = getAvailableNetworkClientIds(getNetworkConfigurations(state));
     if (networkConfigurationEntries.length === 0) {
@@ -310,12 +311,27 @@ function validateNetworkControllerState(state) {
     if ([...new Set(networkClientIds)].length < networkClientIds.length) {
         throw new Error('NetworkController state has invalid `networkConfigurationsByChainId`: Every RPC endpoint across all network configurations must have a unique `networkClientId`');
     }
-    if (!networkClientIds.includes(state.selectedNetworkClientId)) {
-        throw new Error(
-        // This ESLint rule mistakenly produces an error.
-        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
-        `NetworkController state is invalid: \`selectedNetworkClientId\` '${state.selectedNetworkClientId}' does not refer to an RPC endpoint within a network configuration`);
-    }
+}
+/**
+ * Checks that the given initial NetworkController state is internally
+ * consistent similar to `validateInitialState`, but if an anomaly is detected,
+ * it does its best to correct the state and logs an error to Sentry.
+ *
+ * @param state - The NetworkController state to verify.
+ * @param captureException - The function that logs an error to Sentry.
+ * @returns The corrected state.
+ */
+function correctInitialState(state, captureException) {
+    const networkConfigurationsSortedByChainId = getNetworkConfigurations(state).sort((a, b) => a.chainId.localeCompare(b.chainId));
+    const networkClientIds = getAvailableNetworkClientIds(networkConfigurationsSortedByChainId);
+    return (0, immer_1.produce)(state, (newState) => {
+        if (!networkClientIds.includes(state.selectedNetworkClientId)) {
+            const firstNetworkConfiguration = networkConfigurationsSortedByChainId[0];
+            const newSelectedNetworkClientId = firstNetworkConfiguration.rpcEndpoints[firstNetworkConfiguration.defaultRpcEndpointIndex].networkClientId;
+            captureException(new Error(`\`selectedNetworkClientId\` '${state.selectedNetworkClientId}' does not refer to an RPC endpoint within a network configuration; correcting to '${newSelectedNetworkClientId}'`));
+            newState.selectedNetworkClientId = newSelectedNetworkClientId;
+        }
+    });
 }
 /**
  * Transforms a map of chain ID to network configuration to a map of network
@@ -342,12 +358,13 @@ class NetworkController extends base_controller_1.BaseController {
      * @param options - The options; see {@link NetworkControllerOptions}.
      */
     constructor(options) {
-        const { messenger, state, infuraProjectId, log, getRpcServiceOptions, additionalDefaultNetworks, } = options;
+        const { messenger, state, infuraProjectId, log, getRpcServiceOptions, additionalDefaultNetworks, captureException, } = options;
         const initialState = {
             ...getDefaultNetworkControllerState(additionalDefaultNetworks),
             ...state,
         };
-        validateNetworkControllerState(initialState);
+        validateInitialState(initialState);
+        const correctedInitialState = correctInitialState(initialState, captureException);
         if (!infuraProjectId || typeof infuraProjectId !== 'string') {
             throw new Error('Invalid Infura project ID');
         }
@@ -368,7 +385,7 @@ class NetworkController extends base_controller_1.BaseController {
                 },
             },
             messenger,
-            state: initialState,
+            state: correctedInitialState,
         });
         _NetworkController_instances.add(this);
         _NetworkController_ethQuery.set(this, void 0);
diff --git a/node_modules/@metamask/network-controller/dist/NetworkController.mjs b/node_modules/@metamask/network-controller/dist/NetworkController.mjs
index 0efca67..ff13585 100644
--- a/node_modules/@metamask/network-controller/dist/NetworkController.mjs
+++ b/node_modules/@metamask/network-controller/dist/NetworkController.mjs
@@ -25,6 +25,7 @@ import { createEventEmitterProxy } from "@metamask/swappable-obj-proxy";
 import { hasProperty, isPlainObject, isStrictHexString } from "@metamask/utils";
 import $deepEqual from "fast-deep-equal";
 const deepEqual = $importDefault($deepEqual);
+import { produce } from "immer";
 import $lodash from "lodash";
 const { cloneDeep } = $lodash;
 import { createSelector } from "reselect";
@@ -262,7 +263,7 @@ function deriveInfuraNetworkNameFromRpcEndpointUrl(rpcEndpointUrl) {
  * @param state - The NetworkController state to verify.
  * @throws if the state is invalid in some way.
  */
-function validateNetworkControllerState(state) {
+function validateInitialState(state) {
     const networkConfigurationEntries = Object.entries(state.networkConfigurationsByChainId);
     const networkClientIds = getAvailableNetworkClientIds(getNetworkConfigurations(state));
     if (networkConfigurationEntries.length === 0) {
@@ -286,12 +287,27 @@ function validateNetworkControllerState(state) {
     if ([...new Set(networkClientIds)].length < networkClientIds.length) {
         throw new Error('NetworkController state has invalid `networkConfigurationsByChainId`: Every RPC endpoint across all network configurations must have a unique `networkClientId`');
     }
-    if (!networkClientIds.includes(state.selectedNetworkClientId)) {
-        throw new Error(
-        // This ESLint rule mistakenly produces an error.
-        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
-        `NetworkController state is invalid: \`selectedNetworkClientId\` '${state.selectedNetworkClientId}' does not refer to an RPC endpoint within a network configuration`);
-    }
+}
+/**
+ * Checks that the given initial NetworkController state is internally
+ * consistent similar to `validateInitialState`, but if an anomaly is detected,
+ * it does its best to correct the state and logs an error to Sentry.
+ *
+ * @param state - The NetworkController state to verify.
+ * @param captureException - The function that logs an error to Sentry.
+ * @returns The corrected state.
+ */
+function correctInitialState(state, captureException) {
+    const networkConfigurationsSortedByChainId = getNetworkConfigurations(state).sort((a, b) => a.chainId.localeCompare(b.chainId));
+    const networkClientIds = getAvailableNetworkClientIds(networkConfigurationsSortedByChainId);
+    return produce(state, (newState) => {
+        if (!networkClientIds.includes(state.selectedNetworkClientId)) {
+            const firstNetworkConfiguration = networkConfigurationsSortedByChainId[0];
+            const newSelectedNetworkClientId = firstNetworkConfiguration.rpcEndpoints[firstNetworkConfiguration.defaultRpcEndpointIndex].networkClientId;
+            captureException(new Error(`\`selectedNetworkClientId\` '${state.selectedNetworkClientId}' does not refer to an RPC endpoint within a network configuration; correcting to '${newSelectedNetworkClientId}'`));
+            newState.selectedNetworkClientId = newSelectedNetworkClientId;
+        }
+    });
 }
 /**
  * Transforms a map of chain ID to network configuration to a map of network
@@ -318,12 +334,13 @@ export class NetworkController extends BaseController {
      * @param options - The options; see {@link NetworkControllerOptions}.
      */
     constructor(options) {
-        const { messenger, state, infuraProjectId, log, getRpcServiceOptions, additionalDefaultNetworks, } = options;
+        const { messenger, state, infuraProjectId, log, getRpcServiceOptions, additionalDefaultNetworks, captureException, } = options;
         const initialState = {
             ...getDefaultNetworkControllerState(additionalDefaultNetworks),
             ...state,
         };
-        validateNetworkControllerState(initialState);
+        validateInitialState(initialState);
+        const correctedInitialState = correctInitialState(initialState, captureException);
         if (!infuraProjectId || typeof infuraProjectId !== 'string') {
             throw new Error('Invalid Infura project ID');
         }
@@ -344,7 +361,7 @@ export class NetworkController extends BaseController {
                 },
             },
             messenger,
-            state: initialState,
+            state: correctedInitialState,
         });
         _NetworkController_instances.add(this);
         _NetworkController_ethQuery.set(this, void 0);
