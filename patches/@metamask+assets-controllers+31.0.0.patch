diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-4AC3X2U5.js b/node_modules/@metamask/assets-controllers/dist/chunk-4AC3X2U5.js
index bb55790..5905cea 100644
--- a/node_modules/@metamask/assets-controllers/dist/chunk-4AC3X2U5.js
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-4AC3X2U5.js
@@ -605,9 +605,14 @@ _selectedAddress = new WeakMap();
 _provider = new WeakMap();
 _abortController = new WeakMap();
 _onNetworkDidChange = new WeakSet();
-onNetworkDidChange_fn = function({ providerConfig }) {
+onNetworkDidChange_fn = function({ selectedNetworkClientId }) {
   const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
-  const { chainId } = providerConfig;
+  // This wont be needed in v32
+  const selectedNetworkClient = this.messagingSystem.call(
+      'NetworkController:getNetworkClientById',
+       selectedNetworkClientId,
+  );
+  const { chainId } = selectedNetworkClient.configuration;
   _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _abortController).abort();
   _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _abortController, new AbortController());
   _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _chainId, chainId);
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-CGLUTXI7.js b/node_modules/@metamask/assets-controllers/dist/chunk-CGLUTXI7.js
index 7cc44fa..eaa14b7 100644
--- a/node_modules/@metamask/assets-controllers/dist/chunk-CGLUTXI7.js
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-CGLUTXI7.js
@@ -17,7 +17,10 @@ var _basecontroller = require('@metamask/base-controller');
 
 
 
-
+/**
+ * Changes regarding displayNftMedia, TokenURI and error nft metadata property are not on the core repo and needed to be refactor to be removed from the patch
+ * updateNftMetadata changes will be introduced on latest versions of changes of assets controllers, v^30 or next
+ */
 
 
 
@@ -44,7 +47,7 @@ var getDefaultNftControllerState = () => ({
   allNfts: {},
   ignoredNfts: []
 });
-var _mutex, _selectedAddress, _chainId, _ipfsGateway, _openSeaEnabled, _useIpfsSubdomains, _isIpfsGatewayEnabled, _getERC721AssetName, _getERC721AssetSymbol, _getERC721TokenURI, _getERC721OwnerOf, _getERC1155BalanceOf, _getERC1155TokenURI, _onNftAdded, _onNetworkControllerNetworkDidChange, onNetworkControllerNetworkDidChange_fn, _onPreferencesControllerStateChange, onPreferencesControllerStateChange_fn, _updateNestedNftState, updateNestedNftState_fn, _getNftInformationFromApi, getNftInformationFromApi_fn, _getNftInformationFromTokenURI, getNftInformationFromTokenURI_fn, _getNftURIAndStandard, getNftURIAndStandard_fn, _getNftInformation, getNftInformation_fn, _getNftContractInformationFromContract, getNftContractInformationFromContract_fn, _getNftContractInformation, getNftContractInformation_fn, _addIndividualNft, addIndividualNft_fn, _addNftContract, addNftContract_fn, _removeAndIgnoreIndividualNft, removeAndIgnoreIndividualNft_fn, _removeIndividualNft, removeIndividualNft_fn, _removeNftContract, removeNftContract_fn, _validateWatchNft, validateWatchNft_fn, _getCorrectChainId, getCorrectChainId_fn;
+var _mutex, _selectedAddress, _chainId, _ipfsGateway, _displayNftMedia, _useIpfsSubdomains, _isIpfsGatewayEnabled, _getERC721AssetName, _getERC721AssetSymbol, _getERC721TokenURI, _getERC721OwnerOf, _getERC1155BalanceOf, _getERC1155TokenURI, _onNftAdded, _onNetworkControllerNetworkDidChange, onNetworkControllerNetworkDidChange_fn, _onPreferencesControllerStateChange, onPreferencesControllerStateChange_fn, _updateNestedNftState, updateNestedNftState_fn, _getNftInformationFromApi, getNftInformationFromApi_fn, _getNftInformationFromTokenURI, getNftInformationFromTokenURI_fn, _getNftURIAndStandard, getNftURIAndStandard_fn, _getNftInformation, getNftInformation_fn, _getNftContractInformationFromContract, getNftContractInformationFromContract_fn, _getNftContractInformation, getNftContractInformation_fn, _addIndividualNft, addIndividualNft_fn, _addNftContract, addNftContract_fn, _removeAndIgnoreIndividualNft, removeAndIgnoreIndividualNft_fn, _removeIndividualNft, removeIndividualNft_fn, _removeNftContract, removeNftContract_fn, _validateWatchNft, validateWatchNft_fn, _getCorrectChainId, getCorrectChainId_fn;
 var NftController = class extends _basecontroller.BaseController {
   /**
    * Creates an NftController instance.
@@ -53,7 +56,7 @@ var NftController = class extends _basecontroller.BaseController {
    * @param options.chainId - The chain ID of the current network.
    * @param options.selectedAddress - The currently selected address.
    * @param options.ipfsGateway - The configured IPFS gateway.
-   * @param options.openSeaEnabled - Controls whether the OpenSea API is used.
+   * @param options.displayNftMedia - Controls whether the OpenSea API is used.
    * @param options.useIpfsSubdomains - Controls whether IPFS subdomains are used.
    * @param options.isIpfsGatewayEnabled - Controls whether IPFS is enabled or not.
    * @param options.getERC721AssetName - Gets the name of the asset at the given address.
@@ -71,7 +74,7 @@ var NftController = class extends _basecontroller.BaseController {
     chainId: initialChainId,
     selectedAddress = "",
     ipfsGateway = _controllerutils.IPFS_DEFAULT_GATEWAY_URL,
-    openSeaEnabled = false,
+    displayNftMedia = false,
     useIpfsSubdomains = true,
     isIpfsGatewayEnabled = true,
     getERC721AssetName,
@@ -104,7 +107,7 @@ var NftController = class extends _basecontroller.BaseController {
      * @param preferencesState - The new state of the preference controller.
      * @param preferencesState.selectedAddress - The current selected address.
      * @param preferencesState.ipfsGateway - The configured IPFS gateway.
-     * @param preferencesState.openSeaEnabled - Controls whether the OpenSea API is used.
+     * @param preferencesState.displayNftMedia - Controls whether the OpenSea API is used.
      * @param preferencesState.isIpfsGatewayEnabled - Controls whether IPFS is enabled or not.
      */
     _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _onPreferencesControllerStateChange);
@@ -233,7 +236,7 @@ var NftController = class extends _basecontroller.BaseController {
     _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _selectedAddress, void 0);
     _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _chainId, void 0);
     _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _ipfsGateway, void 0);
-    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _openSeaEnabled, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _displayNftMedia, void 0);
     _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _useIpfsSubdomains, void 0);
     _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _isIpfsGatewayEnabled, void 0);
     _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getERC721AssetName, void 0);
@@ -246,7 +249,7 @@ var NftController = class extends _basecontroller.BaseController {
     _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _selectedAddress, selectedAddress);
     _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _chainId, initialChainId);
     _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _ipfsGateway, ipfsGateway);
-    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _openSeaEnabled, openSeaEnabled);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _displayNftMedia, displayNftMedia);
     _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _useIpfsSubdomains, useIpfsSubdomains);
     _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _isIpfsGatewayEnabled, isIpfsGatewayEnabled);
     _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _getERC721AssetName, getERC721AssetName);
@@ -430,43 +433,48 @@ var NftController = class extends _basecontroller.BaseController {
     userAddress = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _selectedAddress),
     networkClientId
   }) {
-    const chainId = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getCorrectChainId, getCorrectChainId_fn).call(this, { networkClientId });
-    const nftsWithChecksumAdr = nfts.map((nft) => {
-      return {
-        ...nft,
-        address: _controllerutils.toChecksumHexAddress.call(void 0, nft.address)
-      };
-    });
-    const nftMetadataResults = await Promise.all(
-      nftsWithChecksumAdr.map(async (nft) => {
-        const resMetadata = await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getNftInformation, getNftInformation_fn).call(this, nft.address, nft.tokenId, networkClientId);
+    const releaseLock = await _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _mutex).acquire();
+    try{
+      const chainId = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getCorrectChainId, getCorrectChainId_fn).call(this, { networkClientId });
+      const nftsWithChecksumAdr = nfts.map((nft) => {
         return {
-          nft,
-          newMetadata: resMetadata
+          ...nft,
+          address: _controllerutils.toChecksumHexAddress.call(void 0, nft.address)
         };
-      })
-    );
-    const nftsWithDifferentMetadata = [];
-    const { allNfts } = this.state;
-    const stateNfts = allNfts[userAddress]?.[chainId] || [];
-    nftMetadataResults.forEach((singleNft) => {
-      const existingEntry = stateNfts.find(
-        (nft) => nft.address.toLowerCase() === singleNft.nft.address.toLowerCase() && nft.tokenId === singleNft.nft.tokenId
+      });
+      const nftMetadataResults = await Promise.all(
+        nftsWithChecksumAdr.map(async (nft) => {
+          const resMetadata = await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getNftInformation, getNftInformation_fn).call(this, nft.address, nft.tokenId, networkClientId);
+          return {
+            nft,
+            newMetadata: resMetadata
+          };
+        })
       );
-      if (existingEntry) {
-        const differentMetadata = _chunkNEXY7SE2js.compareNftMetadata.call(void 0, 
-          singleNft.newMetadata,
-          existingEntry
+      const nftsWithDifferentMetadata = [];
+      const { allNfts } = this.state;
+      const stateNfts = allNfts[userAddress]?.[chainId] || [];
+      nftMetadataResults.forEach((singleNft) => {
+        const existingEntry = stateNfts.find(
+          (nft) => nft.address.toLowerCase() === singleNft.nft.address.toLowerCase() && nft.tokenId === singleNft.nft.tokenId
         );
-        if (differentMetadata) {
-          nftsWithDifferentMetadata.push(singleNft);
+        if (existingEntry) {
+          const differentMetadata = _chunkNEXY7SE2js.compareNftMetadata.call(void 0, 
+            singleNft.newMetadata,
+            existingEntry
+          );
+          if (differentMetadata) {
+            nftsWithDifferentMetadata.push(singleNft);
+          }
         }
+      });
+      if (nftsWithDifferentMetadata.length !== 0) {
+        nftsWithDifferentMetadata.forEach(
+          (elm) => this.updateNft(elm.nft, elm.newMetadata, userAddress, chainId)
+        );
       }
-    });
-    if (nftsWithDifferentMetadata.length !== 0) {
-      nftsWithDifferentMetadata.forEach(
-        (elm) => this.updateNft(elm.nft, elm.newMetadata, userAddress, chainId)
-      );
+    } finally {
+      releaseLock();
     }
   }
   /**
@@ -771,7 +779,7 @@ _mutex = new WeakMap();
 _selectedAddress = new WeakMap();
 _chainId = new WeakMap();
 _ipfsGateway = new WeakMap();
-_openSeaEnabled = new WeakMap();
+_displayNftMedia = new WeakMap();
 _useIpfsSubdomains = new WeakMap();
 _isIpfsGatewayEnabled = new WeakMap();
 _getERC721AssetName = new WeakMap();
@@ -797,14 +805,14 @@ _onPreferencesControllerStateChange = new WeakSet();
 onPreferencesControllerStateChange_fn = async function({
   selectedAddress,
   ipfsGateway,
-  openSeaEnabled,
+  displayNftMedia,
   isIpfsGatewayEnabled
 }) {
   _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _selectedAddress, selectedAddress);
   _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _ipfsGateway, ipfsGateway);
-  _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _openSeaEnabled, openSeaEnabled);
+  _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _displayNftMedia, displayNftMedia);
   _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _isIpfsGatewayEnabled, isIpfsGatewayEnabled);
-  const needsUpdateNftMetadata = isIpfsGatewayEnabled && ipfsGateway !== "" || openSeaEnabled;
+  const needsUpdateNftMetadata = isIpfsGatewayEnabled && ipfsGateway !== "" || displayNftMedia;
   if (needsUpdateNftMetadata) {
     const nfts = this.state.allNfts[selectedAddress]?.[_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _chainId)] ?? [];
     const nftsToUpdate = nfts.filter(
@@ -850,12 +858,25 @@ getNftInformationFromApi_fn = async function(contractAddress, tokenId) {
       }
     }
   });
+  const getCollectionParams = new URLSearchParams({
+    chainId: "1",
+    id: `${nftInformation?.tokens[0]?.token?.collection?.id}`
+  }).toString();
+  const collectionInformation = await _controllerutils.fetchWithErrorHandling.call(void 0, {
+    url: `${_controllerutils.NFT_API_BASE_URL}/collections?${getCollectionParams}`,
+    options: {
+      headers: {
+        Version: '1'
+      }
+    }
+  });
   if (!nftInformation?.tokens?.[0]?.token) {
     return {
       name: null,
       description: null,
       image: null,
-      standard: null
+      standard: null,
+      error: 'Opensea import error',
     };
   }
   const {
@@ -887,7 +908,16 @@ getNftInformationFromApi_fn = async function(contractAddress, tokenId) {
     },
     rarityRank && { rarityRank },
     rarity && { rarity },
-    collection && { collection }
+    (collection || collectionInformation) && {
+      collection: {
+        ...collection || {},
+        creator: collection?.creator || collectionInformation?.collections[0].creator,
+        openseaVerificationStatus: collectionInformation?.collections[0].openseaVerificationStatus,
+        contractDeployedAt: collectionInformation?.collections[0].contractDeployedAt,
+        ownerCount: collectionInformation?.collections[0].ownerCount,
+        topBid: collectionInformation?.collections[0].topBid
+      }
+    }
   );
   return nftMetadata;
 };
@@ -896,6 +926,17 @@ getNftInformationFromTokenURI_fn = async function(contractAddress, tokenId, netw
   const result = await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getNftURIAndStandard, getNftURIAndStandard_fn).call(this, contractAddress, tokenId, networkClientId);
   let tokenURI = result[0];
   const standard = result[1];
+  if (!_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _displayNftMedia) && !_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _isIpfsGatewayEnabled)) {
+    return {
+        image: null,
+        name: null,
+        description: null,
+        standard: standard || null,
+        favorite: false,
+        tokenURI,
+      };
+    }
+
   const hasIpfsTokenURI = tokenURI.startsWith("ipfs://");
   if (hasIpfsTokenURI && !_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _isIpfsGatewayEnabled)) {
     return {
@@ -907,7 +948,7 @@ getNftInformationFromTokenURI_fn = async function(contractAddress, tokenId, netw
       tokenURI: tokenURI ?? null
     };
   }
-  const isDisplayNFTMediaToggleEnabled = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _openSeaEnabled);
+  const isDisplayNFTMediaToggleEnabled = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _displayNftMedia);
   if (!hasIpfsTokenURI && !isDisplayNFTMediaToggleEnabled) {
     return {
       image: null,
@@ -915,7 +956,8 @@ getNftInformationFromTokenURI_fn = async function(contractAddress, tokenId, netw
       description: null,
       standard: standard || null,
       favorite: false,
-      tokenURI: tokenURI ?? null
+      tokenURI: tokenURI ?? null,
+      error: 'URI import error',
     };
   }
   if (hasIpfsTokenURI) {
@@ -925,6 +967,16 @@ getNftInformationFromTokenURI_fn = async function(contractAddress, tokenId, netw
       _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _useIpfsSubdomains)
     );
   }
+  if (tokenURI.startsWith("data:image/")) {
+    return {
+      image: tokenURI,
+      name: null,
+      description: null,
+      standard: standard || null,
+      favorite: false,
+      tokenURI: tokenURI ?? null
+    };
+  }
   try {
     const object = await _controllerutils.handleFetch.call(void 0, tokenURI);
     const image = Object.prototype.hasOwnProperty.call(object, "image") ? "image" : (
@@ -946,7 +998,8 @@ getNftInformationFromTokenURI_fn = async function(contractAddress, tokenId, netw
       description: null,
       standard: standard || null,
       favorite: false,
-      tokenURI: tokenURI ?? null
+      tokenURI: tokenURI ?? null,
+      error: 'URI import error',
     };
   }
 };
@@ -977,15 +1030,26 @@ getNftInformation_fn = async function(contractAddress, tokenId, networkClientId)
     _controllerutils.safelyExecute.call(void 0, 
       () => _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getNftInformationFromTokenURI, getNftInformationFromTokenURI_fn).call(this, contractAddress, tokenId, networkClientId)
     ),
-    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _openSeaEnabled) && chainId === "0x1" ? _controllerutils.safelyExecute.call(void 0, 
+    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _displayNftMedia) && chainId === "0x1" ? _controllerutils.safelyExecute.call(void 0, 
       () => _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getNftInformationFromApi, getNftInformationFromApi_fn).call(this, contractAddress, tokenId)
     ) : void 0
   ]);
+  if (blockchainMetadata?.error && nftApiMetadata?.error) {
+      return {
+        image: null,
+        name: null,
+        description: null,
+        standard: blockchainMetadata.standard ?? null,
+        favorite: false,
+        tokenURI: blockchainMetadata.tokenURI ?? null,
+        error: 'Both import failed',
+      };
+  }
   return {
     ...nftApiMetadata,
     name: blockchainMetadata?.name ?? nftApiMetadata?.name ?? null,
     description: blockchainMetadata?.description ?? nftApiMetadata?.description ?? null,
-    image: blockchainMetadata?.image ?? nftApiMetadata?.image ?? null,
+    image: nftApiMetadata?.image ?? blockchainMetadata?.image ?? null,
     standard: blockchainMetadata?.standard ?? nftApiMetadata?.standard ?? null,
     tokenURI: blockchainMetadata?.tokenURI ?? null
   };
@@ -1048,7 +1112,8 @@ addIndividualNft_fn = async function(tokenAddress, tokenId, nftMetadata, nftCont
         nftMetadata,
         existingEntry
       );
-      if (!differentMetadata && existingEntry.isCurrentlyOwned) {
+      const hasNewFields = _chunkNEXY7SE2js.hasNewCollectionFields(nftMetadata, existingEntry);
+      if (!differentMetadata && existingEntry.isCurrentlyOwned && !hasNewFields) {
         return;
       }
       const indexToUpdate = nfts.findIndex(
@@ -1080,7 +1145,8 @@ addIndividualNft_fn = async function(tokenAddress, tokenId, nftMetadata, nftCont
         symbol: nftContract.symbol,
         tokenId: tokenId.toString(),
         standard: nftMetadata.standard,
-        source
+        source,
+        tokenURI: nftMetadata.tokenURI,
       });
     }
   } finally {
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-ELSMS5S7.js b/node_modules/@metamask/assets-controllers/dist/chunk-ELSMS5S7.js
index 45254ad..cd5f3a1 100644
--- a/node_modules/@metamask/assets-controllers/dist/chunk-ELSMS5S7.js
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-ELSMS5S7.js
@@ -87,6 +87,7 @@ var CurrencyRateController = class extends _pollingcontroller.StaticIntervalPoll
     const nativeCurrencyForExchangeRate = Object.values(
       _controllerutils.TESTNET_TICKER_SYMBOLS
     ).includes(nativeCurrency) ? _controllerutils.FALL_BACK_VS_CURRENCY : nativeCurrency;
+    let shouldUpdateState = true;
     try {
       if (currentCurrency && nativeCurrency && // if either currency is an empty string we can skip the comparison
       // because it will result in an error from the api and ultimately
@@ -103,23 +104,27 @@ var CurrencyRateController = class extends _pollingcontroller.StaticIntervalPoll
       }
     } catch (error) {
       if (!(error instanceof Error && error.message.includes("market does not exist for this coin pair"))) {
+        // Don't update state on transient / unexpected errors
+        shouldUpdateState = false;
         throw error;
       }
     } finally {
       try {
-        this.update(() => {
-          return {
-            currencyRates: {
-              ...currencyRates,
-              [nativeCurrency]: {
-                conversionDate,
-                conversionRate,
-                usdConversionRate
-              }
-            },
-            currentCurrency
-          };
-        });
+        if (shouldUpdateState) {
+          this.update(() => {
+            return {
+              currencyRates: {
+                ...currencyRates,
+                [nativeCurrency]: {
+                  conversionDate,
+                  conversionRate,
+                  usdConversionRate
+                }
+              },
+              currentCurrency
+            };
+          })
+        }
       } finally {
         releaseLock();
       }
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-GU53EI7A.js b/node_modules/@metamask/assets-controllers/dist/chunk-GU53EI7A.js
index 33b048f..8815b95 100644
--- a/node_modules/@metamask/assets-controllers/dist/chunk-GU53EI7A.js
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-GU53EI7A.js
@@ -61,7 +61,7 @@ var AccountTrackerController = class extends _pollingcontroller.StaticIntervalPo
         this.syncAccounts(chainId);
         const { accounts, accountsByChainId } = this.state;
         const isMultiAccountBalancesEnabled = this.getMultiAccountBalancesEnabled();
-        const accountsToUpdate = isMultiAccountBalancesEnabled ? Object.keys(accounts) : [this.getSelectedAddress()];
+        const accountsToUpdate = isMultiAccountBalancesEnabled ? Object.keys(accounts) : [_controllerutils.toChecksumHexAddress.call(void 0, this.getSelectedAddress())];
         const accountsForChain = { ...accountsByChainId[chainId] };
         for (const address of accountsToUpdate) {
           const balance = await this.getBalanceFromChain(address, ethQuery);
@@ -80,9 +80,11 @@ var AccountTrackerController = class extends _pollingcontroller.StaticIntervalPo
             [chainId]: accountsForChain
           }
         });
-      } catch (err) {
+      } finally {
+          /**
+            * This change is not present on the core repo
+          */
         releaseLock();
-        throw err;
       }
     };
     this.defaultConfig = {
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-HDI4L2DD.js b/node_modules/@metamask/assets-controllers/dist/chunk-HDI4L2DD.js
index 76e3362..f733c85 100644
--- a/node_modules/@metamask/assets-controllers/dist/chunk-HDI4L2DD.js
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-HDI4L2DD.js
@@ -165,7 +165,9 @@ var TokenDetectionController = class extends _pollingcontroller.StaticIntervalPo
     if (!this.isActive) {
       return;
     }
-    const addressAgainstWhichToDetect = selectedAddress ?? _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _selectedAddress);
+    const currentAddress = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _selectedAddress);
+    const currentAddressChecksum = _controllerutils.toChecksumHexAddress.call(void 0, currentAddress)
+    const addressAgainstWhichToDetect = _controllerutils.toChecksumHexAddress.call(void 0, selectedAddress) ?? currentAddressChecksum;
     const { chainId, networkClientId: selectedNetworkClientId } = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getCorrectChainIdAndNetworkClientId, getCorrectChainIdAndNetworkClientId_fn).call(this, networkClientId);
     const chainIdAgainstWhichToDetect = chainId;
     const networkClientIdAgainstWhichToDetect = selectedNetworkClientId;
@@ -224,12 +226,10 @@ registerEventListeners_fn = function() {
   );
   this.messagingSystem.subscribe(
     "PreferencesController:stateChange",
-    async ({ selectedAddress: newSelectedAddress, useTokenDetection }) => {
-      const isSelectedAddressChanged = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _selectedAddress) !== newSelectedAddress;
+    async ({ useTokenDetection }) => {
       const isDetectionChangedFromPreferences = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _isDetectionEnabledFromPreferences) !== useTokenDetection;
-      _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _selectedAddress, newSelectedAddress);
       _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _isDetectionEnabledFromPreferences, useTokenDetection);
-      if (isSelectedAddressChanged || isDetectionChangedFromPreferences) {
+      if (isDetectionChangedFromPreferences) {
         await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _restartTokenDetection, restartTokenDetection_fn).call(this, {
           selectedAddress: _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _selectedAddress)
         });
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-IBK6AXPP.js b/node_modules/@metamask/assets-controllers/dist/chunk-IBK6AXPP.js
index f7509a1..52bc67e 100644
--- a/node_modules/@metamask/assets-controllers/dist/chunk-IBK6AXPP.js
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-IBK6AXPP.js
@@ -19,7 +19,7 @@ function getDefaultTokenBalancesState() {
     contractBalances: {}
   };
 }
-var _handle, _getERC20BalanceOf, _interval, _tokens, _disabled;
+var _handle, _getERC20BalanceOf, _interval, _tokens, _disabled, _updateInProgress;
 var TokenBalancesController = class extends _basecontroller.BaseController {
   /**
    * Construct a Token Balances Controller.
@@ -54,9 +54,11 @@ var TokenBalancesController = class extends _basecontroller.BaseController {
     _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _interval, void 0);
     _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _tokens, void 0);
     _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _disabled, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _updateInProgress, void 0);
     _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _disabled, disabled);
     _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _interval, interval);
     _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _tokens, tokens);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _updateInProgress, false);
     this.messagingSystem.subscribe(
       "TokensController:stateChange",
       ({ tokens: newTokens, detectedTokens }) => {
@@ -79,6 +81,16 @@ var TokenBalancesController = class extends _basecontroller.BaseController {
   disable() {
     _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _disabled, true);
   }
+
+/**
+  * THIS FUNCTIONS IS CURRENTLY PATCHED AND STILL NEEDS TO BE IMPLEMENTED ON THE CORE REPO
+  * Resets to the default state
+  */
+  reset() {
+      this.update((state) => {
+        state.contractBalances = {};
+      });
+   }
   /**
    * Starts a new polling interval.
    *
@@ -100,27 +112,34 @@ var TokenBalancesController = class extends _basecontroller.BaseController {
    * Updates balances for all tokens.
    */
   async updateBalances() {
-    if (_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _disabled)) {
+    if (_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _disabled) || _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _updateInProgress)) {
       return;
     }
     const { selectedAddress } = this.messagingSystem.call(
       "PreferencesController:getState"
     );
     const newContractBalances = {};
-    for (const token of _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _tokens)) {
-      const { address } = token;
-      try {
-        const balance = await _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _getERC20BalanceOf).call(this, address, selectedAddress);
-        newContractBalances[address] = _controllerutils.toHex.call(void 0, balance);
-        token.hasBalanceError = false;
-      } catch (error) {
-        newContractBalances[address] = _controllerutils.toHex.call(void 0, 0);
-        token.hasBalanceError = true;
-      }
-    }
+    const balancePromises = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _tokens).map((token) => {
+        const { address } = token;
+        return _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _getERC20BalanceOf).call(this, address, selectedAddress).then((balance) => {
+          newContractBalances[address] = _controllerutils.toHex.call(void 0, balance);
+          token = {
+            ...token,
+            hasBalanceError: false
+          };
+        }).catch((error) => {
+          newContractBalances[address] = _controllerutils.toHex.call(void 0, 0);
+          token = {
+            ...token,
+            hasBalanceError: true
+          };
+        });
+      });
+    await Promise.all(balancePromises);
     this.update((state) => {
       state.contractBalances = newContractBalances;
     });
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _updateInProgress, false);
   }
 };
 _handle = new WeakMap();
@@ -128,6 +147,7 @@ _getERC20BalanceOf = new WeakMap();
 _interval = new WeakMap();
 _tokens = new WeakMap();
 _disabled = new WeakMap();
+_updateInProgress = new WeakMap();
 var TokenBalancesController_default = TokenBalancesController;
 
 
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-QFDTOEYR.js b/node_modules/@metamask/assets-controllers/dist/chunk-QFDTOEYR.js
index 5335fa5..ae37683 100644
--- a/node_modules/@metamask/assets-controllers/dist/chunk-QFDTOEYR.js
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-QFDTOEYR.js
@@ -7,6 +7,8 @@ var _chunkZ4BLTVTBjs = require('./chunk-Z4BLTVTB.js');
 
 // src/NftDetectionController.ts
 
+var utils_1 = require('@metamask/utils');
+var _chunkR4HATJKUjs = require('./chunk-NEXY7SE2.js');
 
 
 
@@ -14,6 +16,7 @@ var _chunkZ4BLTVTBjs = require('./chunk-Z4BLTVTB.js');
 
 
 var _controllerutils = require('@metamask/controller-utils');
+var supportedNftDetectionNetworks = [_controllerutils.ChainId.mainnet];
 var _pollingcontroller = require('@metamask/polling-controller');
 var DEFAULT_INTERVAL = 18e4;
 var controllerName = "NftDetectionController";
@@ -24,7 +27,9 @@ var BlockaidResultType = /* @__PURE__ */ ((BlockaidResultType2) => {
   BlockaidResultType2["Malicious"] = "Malicious";
   return BlockaidResultType2;
 })(BlockaidResultType || {});
-var _intervalId, _interval, _disabled, _addNft, _getNftState, _stopPolling, stopPolling_fn, _startPolling, startPolling_fn, _onPreferencesControllerStateChange, onPreferencesControllerStateChange_fn, _getOwnerNftApi, getOwnerNftApi_fn, _getOwnerNfts, getOwnerNfts_fn;
+// This patch wont be needed in v35
+var MAX_GET_COLLECTION_BATCH_SIZE = 20;
+var _intervalId, _interval, _disabled, _addNft, _getNftState, _stopPolling, stopPolling_fn, _startPolling, startPolling_fn, _onPreferencesControllerStateChange, onPreferencesControllerStateChange_fn, _getOwnerNftApi, getOwnerNftApi_fn, _getOwnerNfts, getOwnerNfts_fn, _inProcessNftFetchingUpdates;
 var NftDetectionController = class extends _pollingcontroller.StaticIntervalPollingController {
   /**
    * The controller options
@@ -68,8 +73,10 @@ var NftDetectionController = class extends _pollingcontroller.StaticIntervalPoll
     _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _disabled, void 0);
     _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _addNft, void 0);
     _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getNftState, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _inProcessNftFetchingUpdates, void 0);
     _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _interval, interval);
     _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _disabled, disabled);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _inProcessNftFetchingUpdates, {});
     _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _getNftState, getNftState);
     _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _addNft, addNft);
     this.messagingSystem.subscribe(
@@ -126,62 +133,154 @@ var NftDetectionController = class extends _pollingcontroller.StaticIntervalPoll
    */
   async detectNfts(options) {
     const userAddress = options?.userAddress ?? this.messagingSystem.call("PreferencesController:getState").selectedAddress;
-    if (!this.isMainnet() || _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _disabled)) {
+    const { selectedNetworkClientId } = this.messagingSystem.call(
+      "NetworkController:getState"
+    );
+    const {
+      configuration: { chainId }
+    } = this.messagingSystem.call(
+      "NetworkController:getNetworkClientById",
+      selectedNetworkClientId
+    );
+    if (!supportedNftDetectionNetworks.includes(chainId) || _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _disabled)) {
       return;
     }
     if (!userAddress) {
       return;
     }
-    const apiNfts = await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getOwnerNfts, getOwnerNfts_fn).call(this, userAddress);
-    const addNftPromises = apiNfts.map(async (nft) => {
-      const {
-        tokenId: token_id,
-        contract,
-        kind,
-        image: image_url,
-        imageSmall: image_thumbnail_url,
-        metadata: { imageOriginal: image_original_url } = {},
-        name,
-        description,
-        attributes,
-        topBid,
-        lastSale,
-        rarityRank,
-        rarityScore,
-        collection
-      } = nft.token;
-      let ignored;
-      const { ignoredNfts } = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _getNftState).call(this);
-      if (ignoredNfts.length > 0) {
-        ignored = ignoredNfts.find((c) => {
-          return c.address === _controllerutils.toChecksumHexAddress.call(void 0, contract) && c.tokenId === token_id;
-        });
-      }
-      if (!ignored) {
-        const nftMetadata = Object.assign(
-          {},
-          { name },
-          description && { description },
-          image_url && { image: image_url },
-          image_thumbnail_url && { imageThumbnail: image_thumbnail_url },
-          image_original_url && { imageOriginal: image_original_url },
-          kind && { standard: kind.toUpperCase() },
-          lastSale && { lastSale },
-          attributes && { attributes },
-          topBid && { topBid },
-          rarityRank && { rarityRank },
-          rarityScore && { rarityScore },
-          collection && { collection }
+
+    const updateKey = `${chainId}:${userAddress}`;
+    if (updateKey in _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _inProcessNftFetchingUpdates)) {
+      await _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _inProcessNftFetchingUpdates)[updateKey];
+      return;
+    }
+    const {
+      promise: inProgressUpdate,
+      resolve: updateSucceeded,
+      reject: updateFailed
+    } = utils_1.createDeferredPromise.call(void 0, { suppressUnhandledRejection: true });
+    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _inProcessNftFetchingUpdates)[updateKey] = inProgressUpdate;
+    let next;
+    let apiNfts = [];
+    let resultNftApi;
+
+    try {
+      do {
+        resultNftApi = await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getOwnerNfts, getOwnerNfts_fn).call(this, userAddress, chainId, next);
+        apiNfts = resultNftApi.tokens.filter(
+          (elm) => elm.token.isSpam === false && (elm.blockaidResult?.result_type ? elm.blockaidResult?.result_type === "Benign" /* Benign */ : true)
         );
-        await _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _addNft).call(this, contract, token_id, {
-          nftMetadata,
-          userAddress,
-          source: "detected" /* Detected */,
-          networkClientId: options?.networkClientId
+        const collections = apiNfts.reduce((acc, currValue) => {
+          if (!acc.includes(currValue.token.contract) && currValue.token.contract === currValue?.token?.collection?.id) {
+            acc.push(currValue.token.contract);
+          }
+          return acc;
+        }, []);
+        if (collections.length !== 0) {
+          const collectionResponse = await _chunkR4HATJKUjs.reduceInBatchesSerially.call(void 0, {
+            values: collections,
+            batchSize: MAX_GET_COLLECTION_BATCH_SIZE,
+            eachBatch: async (allResponses, batch) => {
+              const params = new URLSearchParams(
+                batch.map((s) => ["contract", s])
+              );
+              params.append("chainId", "1");
+              const collectionResponseForBatch = await _controllerutils.fetchWithErrorHandling.call(void 0, 
+                {
+                  url: `${_controllerutils.NFT_API_BASE_URL}/collections?${params.toString()}`,
+                  options: {
+                    headers: {
+                      Version: '1'
+                    }
+                  },
+                  timeout: 15000
+                }
+              );
+              return {
+                ...allResponses,
+                ...collectionResponseForBatch
+              };
+            },
+            initialResult: {}
+          });
+          if (collectionResponse.collections?.length) {
+            apiNfts.forEach((singleNFT) => {
+              const found = collectionResponse.collections.find(
+                (elm) => elm.id?.toLowerCase() === singleNFT.token.contract.toLowerCase()
+              );
+              if (found) {
+                singleNFT.token = {
+                  ...singleNFT.token,
+                  collection: {
+                    ...singleNFT.token.collection ?? {},
+                    creator: found?.creator,
+                    openseaVerificationStatus: found?.openseaVerificationStatus,
+                    contractDeployedAt: found.contractDeployedAt,
+                    ownerCount: found.ownerCount,
+                    topBid: found.topBid
+                  }
+                };
+              }
+            });
+          }
+        }
+        const addNftPromises = apiNfts.map(async (nft) => {
+          const {
+            tokenId,
+            contract,
+            kind,
+            image: imageUrl,
+            imageSmall: imageThumbnailUrl,
+            metadata: { imageOriginal: imageOriginalUrl } = {},
+            name,
+            description,
+            attributes,
+            topBid,
+            lastSale,
+            rarityRank,
+            rarityScore,
+            collection
+          } = nft.token;
+          let ignored;
+          const { ignoredNfts } = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _getNftState).call(this);
+          if (ignoredNfts.length) {
+            ignored = ignoredNfts.find((c) => {
+              return c.address === _controllerutils.toChecksumHexAddress.call(void 0, contract) && c.tokenId === tokenId;
+            });
+          }
+          if (!ignored) {
+            const nftMetadata = Object.assign(
+              {},
+              { name },
+              description && { description },
+              imageUrl && { image: imageUrl },
+              imageThumbnailUrl && { imageThumbnail: imageThumbnailUrl },
+              imageOriginalUrl && { imageOriginal: imageOriginalUrl },
+              kind && { standard: kind.toUpperCase() },
+              lastSale && { lastSale },
+              attributes && { attributes },
+              topBid && { topBid },
+              rarityRank && { rarityRank },
+              rarityScore && { rarityScore },
+              collection && { collection }
+            );
+            await _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _addNft).call(this, contract, tokenId, {
+              nftMetadata,
+              userAddress,
+              source: "detected" /* Detected */,
+              networkClientId: options?.networkClientId
+            });
+          }
         });
-      }
-    });
-    await Promise.all(addNftPromises);
+        await Promise.all(addNftPromises);
+      } while (next = resultNftApi.continuation);
+      updateSucceeded();
+    } catch (error) {
+      updateFailed(error);
+      throw error;
+    } finally {
+      delete _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _inProcessNftFetchingUpdates)[updateKey];
+    }
   }
 };
 _intervalId = new WeakMap();
@@ -190,6 +289,7 @@ _disabled = new WeakMap();
 _addNft = new WeakMap();
 _getNftState = new WeakMap();
 _stopPolling = new WeakSet();
+_inProcessNftFetchingUpdates = new WeakMap();
 stopPolling_fn = function() {
   if (_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _intervalId)) {
     clearInterval(_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _intervalId));
@@ -207,41 +307,26 @@ _onPreferencesControllerStateChange = new WeakSet();
 onPreferencesControllerStateChange_fn = function({ useNftDetection }) {
   if (!useNftDetection !== _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _disabled)) {
     _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _disabled, !useNftDetection);
-    if (useNftDetection) {
-      this.start();
-    } else {
-      this.stop();
-    }
   }
 };
 _getOwnerNftApi = new WeakSet();
-getOwnerNftApi_fn = function({ address, next }) {
-  return `${_controllerutils.NFT_API_BASE_URL}/users/${address}/tokens?chainIds=1&limit=50&includeTopBid=true&continuation=${next ?? ""}`;
+getOwnerNftApi_fn = function({ chainId, address, next }) {
+  return `${_controllerutils.NFT_API_BASE_URL}/users/${address}/tokens?chainIds=${chainId}&limit=50&includeTopBid=true&continuation=${next ?? ""}`;
 };
 _getOwnerNfts = new WeakSet();
-getOwnerNfts_fn = async function(address) {
-  let nftApiResponse;
-  let nfts = [];
-  let next;
-  do {
-    nftApiResponse = await _controllerutils.fetchWithErrorHandling.call(void 0, {
-      url: _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getOwnerNftApi, getOwnerNftApi_fn).call(this, { address, next }),
-      options: {
-        headers: {
-          Version: _controllerutils.NFT_API_VERSION
-        }
-      },
-      timeout: _controllerutils.NFT_API_TIMEOUT
-    });
-    if (!nftApiResponse) {
-      return nfts;
+getOwnerNfts_fn = async function(address, chainId, cursor) {
+  const convertedChainId = _controllerutils.convertHexToDecimal.call(void 0, chainId).toString();
+  const url = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getOwnerNftApi, getOwnerNftApi_fn).call(this, {
+    chainId: convertedChainId,
+    address,
+    next: cursor
+  });
+  const nftApiResponse = await _controllerutils.handleFetch.call(void 0, url, {
+    headers: {
+      Version: '1'
     }
-    const newNfts = nftApiResponse.tokens?.filter(
-      (elm) => elm.token.isSpam === false && (elm.blockaidResult?.result_type ? elm.blockaidResult?.result_type === "Benign" /* Benign */ : true)
-    ) ?? [];
-    nfts = [...nfts, ...newNfts];
-  } while (next = nftApiResponse.continuation);
-  return nfts;
+  });
+  return nftApiResponse;
 };
 var NftDetectionController_default = NftDetectionController;
 
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-UEDNQBJN.js b/node_modules/@metamask/assets-controllers/dist/chunk-UEDNQBJN.js
index 80cecfb..f625ec2 100644
--- a/node_modules/@metamask/assets-controllers/dist/chunk-UEDNQBJN.js
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-UEDNQBJN.js
@@ -378,9 +378,10 @@ fetchAndMapExchangeRatesForSupportedNativeCurrency_fn = async function({
   }
   return Object.entries(contractNativeInformations).reduce(
     (obj, [tokenAddress, token]) => {
+      // This wont be needed in v33
       obj = {
         ...obj,
-        [tokenAddress.toLowerCase()]: { ...token }
+        [tokenAddress]: { ...token }
       };
       return obj;
     },
@@ -416,7 +417,7 @@ fetchAndMapExchangeRatesForUnsupportedNativeCurrency_fn = async function({
       ...acc,
       [tokenAddress]: {
         ...token,
-        value: token.value ? token.value * fallbackCurrencyToNativeCurrencyConversionRate : void 0
+        price: token.price ? token.price * fallbackCurrencyToNativeCurrencyConversionRate : void 0
       }
     };
     return acc;
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-Z6TBQQE5.js b/node_modules/@metamask/assets-controllers/dist/chunk-Z6TBQQE5.js
index 2f1b66f..8436bd9 100644
--- a/node_modules/@metamask/assets-controllers/dist/chunk-Z6TBQQE5.js
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-Z6TBQQE5.js
@@ -295,13 +295,11 @@ var CodefiTokenPricesServiceV2 = class {
       (obj, tokenAddress) => {
         const lowercasedTokenAddress = tokenAddress.toLowerCase();
         const marketData = addressCryptoDataMap[lowercasedTokenAddress];
-        if (marketData === void 0) {
+        if (!marketData) {
           return obj;
         }
-        const { price } = marketData;
         const token = {
           tokenAddress,
-          value: price,
           currency,
           ...marketData
         };
diff --git a/node_modules/@metamask/assets-controllers/dist/types/NftController.d.ts b/node_modules/@metamask/assets-controllers/dist/types/NftController.d.ts
index bbf4f12..1da217a 100644
--- a/node_modules/@metamask/assets-controllers/dist/types/NftController.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/types/NftController.d.ts
@@ -6,7 +6,7 @@ import type { PreferencesControllerStateChangeEvent } from '@metamask/preference
 import type { Hex } from '@metamask/utils';
 import type { AssetsContractController } from './AssetsContractController';
 import { Source } from './constants';
-import type { Collection, Attributes, LastSale } from './NftDetectionController';
+import type { Collection, Attributes, LastSale, TopBid } from './NftDetectionController';
 type NFTStandardType = 'ERC721' | 'ERC1155';
 type SuggestedNftMeta = {
     asset: {
@@ -107,11 +107,13 @@ export type NftMetadata = {
     creator?: string;
     transactionId?: string;
     tokenURI?: string | null;
+    error?: string;
     collection?: Collection;
     address?: string;
-    attributes?: Attributes;
+    attributes?: Attributes[];
     lastSale?: LastSale;
     rarityRank?: string;
+    topBid?: TopBid;
 };
 /**
  * @type NftControllerState
diff --git a/node_modules/@metamask/assets-controllers/dist/types/NftDetectionController.d.ts b/node_modules/@metamask/assets-controllers/dist/types/NftDetectionController.d.ts
index 758a85e..a4a4b72 100644
--- a/node_modules/@metamask/assets-controllers/dist/types/NftDetectionController.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/types/NftDetectionController.d.ts
@@ -225,7 +225,39 @@ export type Attributes = {
     topBidValue?: number | null;
     createdAt?: string;
 };
-export type Collection = {
+export type GetCollectionsResponse = {
+    collections: CollectionResponse[];
+};
+export type CollectionResponse = {
+    id?: string;
+    openseaVerificationStatus?: string;
+    contractDeployedAt?: string;
+    creator?: string;
+    ownerCount?: string;
+    topBid?: TopBid & {
+        sourceDomain?: string;
+    };
+};
+export type FloorAskCollection = {
+    id?: string;
+    price?: Price;
+    maker?: string;
+    kind?: string;
+    validFrom?: number;
+    validUntil?: number;
+    source?: SourceCollection;
+    rawData?: Metadata;
+    isNativeOffChainCancellable?: boolean;
+};
+  
+export type SourceCollection = {
+    id: string;
+    domain: string;
+    name: string;
+    icon: string;
+    url: string;
+};
+export type TokenCollection = {
     id?: string;
     name?: string;
     slug?: string;
@@ -241,7 +273,9 @@ export type Collection = {
     floorAskPrice?: Price;
     royaltiesBps?: number;
     royalties?: Royalties[];
+    floorAsk?: FloorAskCollection;
 };
+export type Collection = TokenCollection & CollectionResponse;
 export type Royalties = {
     bps?: number;
     recipient?: string;
diff --git a/node_modules/@metamask/assets-controllers/dist/types/TokenBalancesController.d.ts b/node_modules/@metamask/assets-controllers/dist/types/TokenBalancesController.d.ts
index 52bb3ac..b291078 100644
--- a/node_modules/@metamask/assets-controllers/dist/types/TokenBalancesController.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/types/TokenBalancesController.d.ts
@@ -79,6 +79,11 @@ export declare class TokenBalancesController extends BaseController<typeof contr
      * Updates balances for all tokens.
      */
     updateBalances(): Promise<void>;
+    /**
+     * THIS FUNCTIONS IS CURRENTLY PATCHED AND STILL NEEDS TO BE IMPLEMENTED ON THE CORE REPO
+     * Resets to the default state
+     */
+    reset(): void;
 }
 export default TokenBalancesController;
 //# sourceMappingURL=TokenBalancesController.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/index.d.ts b/node_modules/@metamask/assets-controllers/dist/types/index.d.ts
index bf96db8..f6eb1ea 100644
--- a/node_modules/@metamask/assets-controllers/dist/types/index.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/types/index.d.ts
@@ -5,7 +5,7 @@ export type { NftControllerState, NftControllerMessenger, NftControllerActions,
 export { getDefaultNftControllerState, NftController } from './NftController';
 export type { NftDetectionControllerMessenger, ApiNft, ApiNftContract, ApiNftLastSale, ApiNftCreator, ReservoirResponse, TokensResponse, BlockaidResultType, Blockaid, Market, TokenResponse, TopBid, LastSale, FeeBreakdown, Attributes, Collection, Royalties, Ownership, FloorAsk, Price, Metadata, } from './NftDetectionController';
 export { NftDetectionController } from './NftDetectionController';
-export type { TokenBalancesControllerMessenger, TokenBalancesControllerActions, TokenBalancesControllerGetStateAction, TokenBalancesControllerEvents, TokenBalancesControllerStateChangeEvent, } from './TokenBalancesController';
+export type { TokenBalancesControllerMessenger, TokenBalancesControllerActions, TokenBalancesControllerGetStateAction, TokenBalancesControllerEvents, TokenBalancesControllerStateChangeEvent, TokenBalancesControllerState, } from './TokenBalancesController';
 export { TokenBalancesController } from './TokenBalancesController';
 export type { TokenDetectionControllerMessenger, TokenDetectionControllerActions, TokenDetectionControllerGetStateAction, TokenDetectionControllerEvents, TokenDetectionControllerStateChangeEvent, } from './TokenDetectionController';
 export { TokenDetectionController } from './TokenDetectionController';
