diff --git a/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.js b/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.js
index 130e3dc..137f2f7 100644
--- a/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.js
+++ b/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.js
@@ -30,7 +30,7 @@ class AccountTrackerController extends base_controller_1.BaseController {
      * @param config - Initial options used to configure this controller.
      * @param state - Initial state to set on this controller.
      */
-    constructor({ onPreferencesStateChange, getIdentities, }, config, state) {
+    constructor({ onPreferencesStateChange, getIdentities, getSelectedAddress, getMultiAccountBalancesEnabled, }, config, state) {
         super(config, state);
         this.mutex = new async_mutex_1.Mutex();
         /**
@@ -38,16 +38,28 @@ class AccountTrackerController extends base_controller_1.BaseController {
          */
         this.name = 'AccountTrackerController';
         /**
-         * Refreshes all accounts in the current keychain.
+         * Refreshes the balances of the accounts depending on the multi-account setting.
+         * If multi-account is disabled, only updates the selected account balance.
+         * If multi-account is enabled, updates balances for all accounts.
+         *
+         * @async
          */
         this.refresh = () => __awaiter(this, void 0, void 0, function* () {
             this.syncAccounts();
             const accounts = Object.assign({}, this.state.accounts);
+            const isMultiAccountBalancesEnabled = this.getMultiAccountBalancesEnabled();
+            if (!isMultiAccountBalancesEnabled) {
+                const selectedAddress = this.getSelectedAddress();
+                const balance = yield this.getBalanceFromChain(selectedAddress);
+                if (!balance) return;
+                accounts[selectedAddress] = { balance: (0, controller_utils_1.BNToHex)(balance) };
+                this.update({ accounts });
+                return;
+            }
             for (const address in accounts) {
-                yield (0, controller_utils_1.safelyExecuteWithTimeout)(() => __awaiter(this, void 0, void 0, function* () {
-                    const balance = yield (0, controller_utils_1.query)(this.ethQuery, 'getBalance', [address]);
-                    accounts[address] = { balance: (0, controller_utils_1.BNToHex)(balance) };
-                }));
+                const balance = yield this.getBalanceFromChain(address);
+                if (!balance) continue;
+                accounts[address] = { balance: (0, controller_utils_1.BNToHex)(balance) };
             }
             this.update({ accounts });
         });
@@ -57,6 +69,8 @@ class AccountTrackerController extends base_controller_1.BaseController {
         this.defaultState = { accounts: {} };
         this.initialize();
         this.getIdentities = getIdentities;
+        this.getSelectedAddress = getSelectedAddress;
+        this.getMultiAccountBalancesEnabled = getMultiAccountBalancesEnabled;
         onPreferencesStateChange(() => {
             this.refresh();
         });
@@ -106,6 +120,22 @@ class AccountTrackerController extends base_controller_1.BaseController {
             }, this.config.interval);
         });
     }
+    /**
+     * Fetches the balance of a given address from the blockchain.
+     *
+     * @async
+     * @param {string} address - The account address to fetch the balance for.
+     * @returns {Promise<string>} - A promise that resolves to the balance in a hex string format.
+     */
+    getBalanceFromChain(address) {
+        return __awaiter(this, void 0, void 0, function* () {
+            let balance;
+            yield (0, controller_utils_1.safelyExecuteWithTimeout)(() => __awaiter(this, void 0, void 0, function* () {
+                balance = yield (0, controller_utils_1.query)(this.ethQuery, 'getBalance', [address]);
+            }));
+            return balance;
+        });
+    }
     /**
      * Sync accounts balances with some additional addresses.
      *
diff --git a/node_modules/@metamask/assets-controllers/dist/AssetsContractController.js b/node_modules/@metamask/assets-controllers/dist/AssetsContractController.js
index 332c87d..b634fde 100644
--- a/node_modules/@metamask/assets-controllers/dist/AssetsContractController.js
+++ b/node_modules/@metamask/assets-controllers/dist/AssetsContractController.js
@@ -33,6 +33,7 @@ exports.SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID = {
     [assetsUtil_1.SupportedTokenDetectionNetworks.bsc]: '0x2352c63A83f9Fd126af8676146721Fa00924d7e4',
     [assetsUtil_1.SupportedTokenDetectionNetworks.polygon]: '0x2352c63A83f9Fd126af8676146721Fa00924d7e4',
     [assetsUtil_1.SupportedTokenDetectionNetworks.avax]: '0xD023D153a0DFa485130ECFdE2FAA7e612EF94818',
+    [assetsUtil_1.SupportedTokenDetectionNetworks.aurora]: '0x1286415D333855237f89Df27D388127181448538',
 };
 exports.MISSING_PROVIDER_ERROR = 'AssetsContractController failed to set the provider correctly. A provider must be set for this method to be available';
 /**
@@ -116,6 +117,20 @@ class AssetsContractController extends base_controller_1.BaseController {
             return yield this.erc20Standard.getTokenDecimals(address);
         });
     }
+     /**
+   * Query for the decimals for a given ERC20 asset.
+   *
+   * @param address - ERC20 asset contract address.
+   * @returns Promise resolving to the 'decimals'.
+   */
+   getERC20TokenName(address) {
+    return __awaiter(this, void 0, void 0, function* () {
+        if (this.erc20Standard === undefined) {
+            throw new Error(MISSING_PROVIDER_ERROR);
+        }
+        return yield this.erc20Standard.getTokenName(address);
+    });
+  }
     /**
      * Enumerate assets assigned to an owner.
      *
diff --git a/node_modules/@metamask/assets-controllers/dist/NftController.js b/node_modules/@metamask/assets-controllers/dist/NftController.js
index 83210c8..6cd15aa 100644
--- a/node_modules/@metamask/assets-controllers/dist/NftController.js
+++ b/node_modules/@metamask/assets-controllers/dist/NftController.js
@@ -127,21 +127,7 @@ class NftController extends base_controller_1.BaseController {
                     useProxy: true,
                 }),
             });
-            // if an openSeaApiKey is set we should attempt to refetch calling directly to OpenSea
-            if (!nftInformation && this.openSeaApiKey) {
-                nftInformation = yield (0, controller_utils_1.fetchWithErrorHandling)({
-                    url: this.getNftApi({
-                        contractAddress,
-                        tokenId,
-                        useProxy: false,
-                    }),
-                    options: {
-                        headers: { 'X-API-KEY': this.openSeaApiKey },
-                    },
-                    // catch 403 errors (in case API key is down we don't want to blow up)
-                    errorCodesToCatch: [403],
-                });
-            }
+        
             // if we were still unable to fetch the data we return out the default/null of `NftMetadata`
             if (!nftInformation) {
                 return {
diff --git a/node_modules/@metamask/assets-controllers/dist/NftDetectionController.js b/node_modules/@metamask/assets-controllers/dist/NftDetectionController.js
index 38ddb4a..7045f80 100644
--- a/node_modules/@metamask/assets-controllers/dist/NftDetectionController.js
+++ b/node_modules/@metamask/assets-controllers/dist/NftDetectionController.js
@@ -94,19 +94,6 @@ class NftDetectionController extends base_controller_1.BaseController {
                     url: this.getOwnerNftApi({ address, offset, useProxy: true }),
                     timeout: 15000,
                 });
-                if (openSeaApiKey && !nftApiResponse) {
-                    nftApiResponse = yield (0, controller_utils_1.fetchWithErrorHandling)({
-                        url: this.getOwnerNftApi({
-                            address,
-                            offset,
-                            useProxy: false,
-                        }),
-                        options: { headers: { 'X-API-KEY': openSeaApiKey } },
-                        timeout: 15000,
-                        // catch 403 errors (in case API key is down we don't want to blow up)
-                        errorCodesToCatch: [403],
-                    });
-                }
                 if (!nftApiResponse) {
                     return nfts;
                 }
diff --git a/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.js b/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.js
index 9ddbc28..b8fb35a 100644
--- a/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.js
+++ b/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.js
@@ -13,7 +13,13 @@ exports.ERC20Standard = void 0;
 const contracts_1 = require("@ethersproject/contracts");
 const metamask_eth_abis_1 = require("@metamask/metamask-eth-abis");
 const ethereumjs_util_1 = require("ethereumjs-util");
-const abi_utils_1 = require("@metamask/abi-utils");
+
+// Revert to use @ethersproject/abi to fix BigInt compatibility issue
+// Issue reported here - https://github.com/MetaMask/metamask-mobile/issues/6307
+// TODO - Remove patch once app is upgraded to React Native 0.71.6
+// const abi_utils_1 = require("@metamask/abi-utils");
+const ethers_project_abi = require('@ethersproject/abi');
+
 const controller_utils_1 = require("@metamask/controller-utils");
 const utils_1 = require("@metamask/utils");
 const assetsUtil_1 = require("../assetsUtil");
@@ -57,6 +63,27 @@ class ERC20Standard {
             }
         });
     }
+    /**
+     * Query for the name for a given ERC20 asset.
+     *
+     * @param address - ERC20 asset contract string.
+     * @returns Promise resolving to the 'name'.
+     */
+    getTokenName(address){
+        return __awaiter(this, void 0, void 0, function* () {
+            const contract = new contracts_1.Contract(address, metamask_eth_abis_1.abiERC20, this.provider);
+            try {
+                const name = yield contract.name();
+                return name.toString();
+            } catch (err) {
+            // Mirror previous implementation
+            if (err.message.includes('call revert exception')) {
+                throw new Error('Failed to parse token name');
+            }
+            throw err;
+            }
+        });
+    }
     /**
      * Query for symbol for a given ERC20 asset.
      *
@@ -68,10 +95,16 @@ class ERC20Standard {
             // Signature for calling `symbol()`
             const payload = { to: address, data: '0x95d89b41' };
             const result = yield this.provider.call(payload);
-            (0, utils_1.assertIsStrictHexString)(result);
+
+            // TODO - Remove patch once app is upgraded to RN 0.71.6
+            // (0, utils_1.assertIsStrictHexString)(result);
+
             // Parse as string - treat empty string as failure
             try {
-                const decoded = (0, abi_utils_1.decodeSingle)('string', result);
+                // TODO - Remove patch once app is upgraded to React Native 0.71.6
+                const decoded = ethers_project_abi.abiCoder.decode(['string'], result)[0];
+                // const decoded = (0, abi_utils_1.decodeSingle)('string', result);
+                
                 if ((decoded === null || decoded === void 0 ? void 0 : decoded.length) > 0) {
                     return decoded;
                 }
@@ -83,7 +116,8 @@ class ERC20Standard {
             try {
                 const utf8 = (0, ethereumjs_util_1.toUtf8)(result);
                 if (utf8.length > 0) {
-                    return utf8;
+                    // This utf8 returns unicode characters, wee need to replace it
+                    return utf8.replace(/[\u0000\u0003\u0020]/g, '');
                 }
             }
             catch (_b) {
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.js b/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.js
index 4ed4990..da18116 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.js
+++ b/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.js
@@ -34,7 +34,7 @@ class TokenDetectionController extends base_controller_1.BaseController {
      * @param config - Initial options used to configure this controller.
      * @param state - Initial state to set on this controller.
      */
-    constructor({ onPreferencesStateChange, onNetworkStateChange, onTokenListStateChange, getBalancesInSingleCall, addDetectedTokens, getTokenListState, getTokensState, getNetworkState, getPreferencesState, }, config, state) {
+    constructor({ onPreferencesStateChange, onNetworkStateChange, onTokenListStateChange, getBalancesInSingleCall, addDetectedTokens, updateTokensName, getTokenListState, getTokensState, getNetworkState, getPreferencesState, }, config, state) {
         const { providerConfig: { chainId: defaultChainId }, } = getNetworkState();
         const { useTokenDetection: defaultUseTokenDetection } = getPreferencesState();
         super(config, state);
@@ -45,6 +45,7 @@ class TokenDetectionController extends base_controller_1.BaseController {
         this.defaultConfig = Object.assign({ interval: DEFAULT_INTERVAL, selectedAddress: '', disabled: true, chainId: defaultChainId, isDetectionEnabledFromPreferences: defaultUseTokenDetection, isDetectionEnabledForNetwork: (0, assetsUtil_1.isTokenDetectionSupportedForNetwork)(defaultChainId) }, config);
         this.initialize();
         this.getTokensState = getTokensState;
+        this.updateTokensName = updateTokensName;
         this.getTokenListState = getTokenListState;
         this.addDetectedTokens = addDetectedTokens;
         this.getBalancesInSingleCall = getBalancesInSingleCall;
@@ -128,16 +129,24 @@ class TokenDetectionController extends base_controller_1.BaseController {
                 return;
             }
             const { tokens } = this.getTokensState();
+            
             const { selectedAddress, chainId } = this.config;
             const tokensAddresses = tokens.map(
             /* istanbul ignore next*/ (token) => token.address.toLowerCase());
             const { tokenList } = this.getTokenListState();
+         
+            if (tokens.length && !tokens[0].name) {
+                this.updateTokensName(tokenList);
+            }
+
             const tokensToDetect = [];
             for (const address in tokenList) {
                 if (!tokensAddresses.includes(address)) {
                     tokensToDetect.push(address);
                 }
             }
+
+
             const sliceOfTokensToDetect = [];
             sliceOfTokensToDetect[0] = tokensToDetect.slice(0, 1000);
             sliceOfTokensToDetect[1] = tokensToDetect.slice(1000, tokensToDetect.length - 1);
@@ -161,7 +170,7 @@ class TokenDetectionController extends base_controller_1.BaseController {
                         }
                         const caseInsensitiveTokenKey = Object.keys(tokenList).find((i) => i.toLowerCase() === tokenAddress.toLowerCase()) || '';
                         if (ignored === undefined) {
-                            const { decimals, symbol, aggregators, iconUrl } = tokenList[caseInsensitiveTokenKey];
+                            const { decimals, symbol, aggregators, iconUrl, name } = tokenList[caseInsensitiveTokenKey];
                             tokensToAdd.push({
                                 address: tokenAddress,
                                 decimals,
@@ -169,6 +178,7 @@ class TokenDetectionController extends base_controller_1.BaseController {
                                 aggregators,
                                 image: iconUrl,
                                 isERC721: false,
+                                name
                             });
                         }
                     }
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenRatesController.js b/node_modules/@metamask/assets-controllers/dist/TokenRatesController.js
index e3f81e9..c3a13ac 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenRatesController.js
+++ b/node_modules/@metamask/assets-controllers/dist/TokenRatesController.js
@@ -77,6 +77,7 @@ class TokenRatesController extends base_controller_1.BaseController {
             chainId: '',
             tokens: [],
             threshold: 6 * 60 * 60 * 1000,
+            previousNativeCurrency: '',
         };
         this.defaultState = {
             contractExchangeRates: {},
@@ -93,7 +94,6 @@ class TokenRatesController extends base_controller_1.BaseController {
         });
         onNetworkStateChange(({ providerConfig }) => {
             const { chainId } = providerConfig;
-            this.update({ contractExchangeRates: {} });
             this.configure({ chainId });
         });
         this.poll();
@@ -107,7 +107,7 @@ class TokenRatesController extends base_controller_1.BaseController {
         return __awaiter(this, void 0, void 0, function* () {
             interval && this.configure({ interval }, false, false);
             this.handle && clearTimeout(this.handle);
-            yield (0, controller_utils_1.safelyExecute)(() => this.updateExchangeRates());
+            yield (0, controller_utils_1.safelyExecute)(() => this.updateExchangeRates(true));
             this.handle = setTimeout(() => {
                 this.poll(this.config.interval);
             }, this.config.interval);
@@ -202,7 +202,7 @@ class TokenRatesController extends base_controller_1.BaseController {
     /**
      * Updates exchange rates for all tokens.
      */
-    updateExchangeRates() {
+    updateExchangeRates(forceFetch = false) {
         return __awaiter(this, void 0, void 0, function* () {
             if (this.tokenList.length === 0 || this.disabled) {
                 return;
@@ -214,10 +214,17 @@ class TokenRatesController extends base_controller_1.BaseController {
                     const address = (0, controller_utils_1.toChecksumHexAddress)(token.address);
                     newContractExchangeRates[address] = undefined;
                 });
-            }
-            else {
+            } else {
                 const { nativeCurrency } = this.config;
-                newContractExchangeRates = yield this.fetchAndMapExchangeRates(nativeCurrency, slug);
+                // Only fetch if native curency is different or when forced (used in polling)
+                if (this.config.previousNativeCurrency !== nativeCurrency || forceFetch) {
+                    newContractExchangeRates = yield this.fetchAndMapExchangeRates(
+                        nativeCurrency,
+                        slug
+                    );
+                } else {
+                    newContractExchangeRates = this.state.contractExchangeRates;
+                }
             }
             this.update({ contractExchangeRates: newContractExchangeRates });
         });
@@ -236,7 +243,12 @@ class TokenRatesController extends base_controller_1.BaseController {
      */
     fetchAndMapExchangeRates(nativeCurrency, slug) {
         return __awaiter(this, void 0, void 0, function* () {
+            // Clear exchange rates before fetching new ones.
+            this.update({ contractExchangeRates: {} });
+            // Set new native currency to prevent this method from being called multiple times
+            this.configure({ previousNativeCurrency: nativeCurrency });
             const contractExchangeRates = {};
+            try{
             // check if native currency is supported as a vs_currency by the API
             const nativeCurrencySupported = yield this.checkIsSupportedVsCurrency(nativeCurrency);
             if (nativeCurrencySupported) {
@@ -254,7 +266,7 @@ class TokenRatesController extends base_controller_1.BaseController {
                 // in token/fallback-currency format and convert them to expected token/nativeCurrency format.
                 let tokenExchangeRates;
                 let vsCurrencyToNativeCurrencyConversionRate = 0;
-                try {
+                
                     [
                         tokenExchangeRates,
                         { conversionRate: vsCurrencyToNativeCurrencyConversionRate },
@@ -262,21 +274,24 @@ class TokenRatesController extends base_controller_1.BaseController {
                         this.fetchExchangeRate(slug, controller_utils_1.FALL_BACK_VS_CURRENCY),
                         (0, crypto_compare_1.fetchExchangeRate)(nativeCurrency, controller_utils_1.FALL_BACK_VS_CURRENCY, false),
                     ]);
-                }
-                catch (error) {
-                    if (error instanceof Error &&
-                        error.message.includes('market does not exist for this coin pair')) {
-                        return {};
+
+                    for (const [tokenAddress, conversion] of Object.entries(tokenExchangeRates)) {
+                        const tokenToVsCurrencyConversionRate = conversion[controller_utils_1.FALL_BACK_VS_CURRENCY.toLowerCase()];
+                        contractExchangeRates[(0, controller_utils_1.toChecksumHexAddress)(tokenAddress)] =
+                            tokenToVsCurrencyConversionRate *
+                                vsCurrencyToNativeCurrencyConversionRate;
                     }
-                    throw error;
                 }
-                for (const [tokenAddress, conversion] of Object.entries(tokenExchangeRates)) {
-                    const tokenToVsCurrencyConversionRate = conversion[controller_utils_1.FALL_BACK_VS_CURRENCY.toLowerCase()];
-                    contractExchangeRates[(0, controller_utils_1.toChecksumHexAddress)(tokenAddress)] =
-                        tokenToVsCurrencyConversionRate *
-                            vsCurrencyToNativeCurrencyConversionRate;
+            } catch (error) {
+                // If there is an error catched we clean the state
+                this.update({ contractExchangeRates: {} });
+                if (error instanceof Error &&
+                    error.message.includes('market does not exist for this coin pair')) {
+                    return {};
                 }
+                throw error;
             }
+
             return contractExchangeRates;
         });
     }
diff --git a/node_modules/@metamask/assets-controllers/dist/TokensController.js b/node_modules/@metamask/assets-controllers/dist/TokensController.js
index 8c02fe6..162376f 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokensController.js
+++ b/node_modules/@metamask/assets-controllers/dist/TokensController.js
@@ -25,13 +25,6 @@ const base_controller_1 = require("@metamask/base-controller");
 const controller_utils_1 = require("@metamask/controller-utils");
 const assetsUtil_1 = require("./assetsUtil");
 const token_service_1 = require("./token-service");
-var SuggestedAssetStatus;
-(function (SuggestedAssetStatus) {
-    SuggestedAssetStatus["accepted"] = "accepted";
-    SuggestedAssetStatus["failed"] = "failed";
-    SuggestedAssetStatus["pending"] = "pending";
-    SuggestedAssetStatus["rejected"] = "rejected";
-})(SuggestedAssetStatus || (SuggestedAssetStatus = {}));
 /**
  * Controller that stores assets and exposes convenience methods
  */
@@ -44,8 +37,10 @@ class TokensController extends base_controller_1.BaseController {
      * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.
      * @param options.config - Initial options used to configure this controller.
      * @param options.state - Initial state to set on this controller.
+     * @param options.messenger - The controller messenger. (Note for patch removal: This new parameter is already merged into core)
+     * @param options.getERC20TokenName - Allows fetch an ERC-20 token anme
      */
-    constructor({ onPreferencesStateChange, onNetworkStateChange, config, state, }) {
+    constructor({ onPreferencesStateChange, onNetworkStateChange, config, state, messenger, getERC20TokenName}) {
         super(config, state);
         this.mutex = new async_mutex_1.Mutex();
         /**
@@ -57,9 +52,11 @@ class TokensController extends base_controller_1.BaseController {
          */
         this.name = 'TokensController';
         this.defaultConfig = Object.assign({ networkType: controller_utils_1.MAINNET, selectedAddress: '', chainId: '', provider: undefined }, config);
-        this.defaultState = Object.assign({ tokens: [], ignoredTokens: [], detectedTokens: [], allTokens: {}, allIgnoredTokens: {}, allDetectedTokens: {}, suggestedAssets: [] }, state);
+        this.defaultState = Object.assign({ tokens: [], ignoredTokens: [], detectedTokens: [], allTokens: {}, allIgnoredTokens: {}, allDetectedTokens: {} }, state);
         this.initialize();
         this.abortController = new abort_controller_1.AbortController();
+        this.messagingSystem = messenger;
+        this.getERC20TokenName = getERC20TokenName;
         onPreferencesStateChange(({ selectedAddress }) => {
             var _a, _b, _c;
             const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
@@ -87,10 +84,6 @@ class TokensController extends base_controller_1.BaseController {
             });
         });
     }
-    failSuggestedAsset(suggestedAssetMeta, error) {
-        const failedSuggestedAssetMeta = Object.assign(Object.assign({}, suggestedAssetMeta), { status: SuggestedAssetStatus.failed, error });
-        this.hub.emit(`${suggestedAssetMeta.id}:finished`, failedSuggestedAssetMeta);
-    }
     /**
      * Fetch metadata for a token.
      *
@@ -122,10 +115,11 @@ class TokensController extends base_controller_1.BaseController {
      * @param address - Hex address of the token contract.
      * @param symbol - Symbol of the token.
      * @param decimals - Number of decimals the token uses.
+     * @param name - Name of the token.
      * @param image - Image of the token.
      * @returns Current token list.
      */
-    addToken(address, symbol, decimals, image) {
+    addToken(address, symbol, decimals, image, name) {
         return __awaiter(this, void 0, void 0, function* () {
             const currentChainId = this.config.chainId;
             const releaseLock = yield this.mutex.acquire();
@@ -151,6 +145,7 @@ class TokensController extends base_controller_1.BaseController {
                         }),
                     isERC721,
                     aggregators: (0, assetsUtil_1.formatAggregatorNames)((tokenMetadata === null || tokenMetadata === void 0 ? void 0 : tokenMetadata.aggregators) || []),
+                    name
                 };
                 const previousEntry = newTokens.find((token) => token.address.toLowerCase() === address.toLowerCase());
                 if (previousEntry) {
@@ -182,6 +177,79 @@ class TokensController extends base_controller_1.BaseController {
             }
         });
     }
+
+
+     /**
+     * Adds a token to the stored token list for a specific wallet.
+     * TODO - Should consolidate this with addToken method since much of the logic is similar.
+     *
+     * @param params - Params used for adding token to an account address.
+     * @param params.accountAddress - Account address to add the token to.
+     * @param params.token - Token to add.
+     * @param params.token.address - Hex address of the token contract.
+     * @param params.token.symbol - Symbol of the token.
+     * @param params.token.decimals - Number of decimals the token uses.
+     * @param params.token.image - Image of the token.
+     * @returns Current token list.
+     */
+    addTokenToAccount({ accountAddress, token: { address, symbol, decimals, image } }) {
+            return __awaiter(this, void 0, void 0, function* () {
+                const currentChainId = this.config.chainId;
+                const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
+                const releaseLock = yield this.mutex.acquire();
+                try {
+                    address = (0, controller_utils_1.toChecksumHexAddress)(address);
+                    const tokens = allTokens[currentChainId]?.[accountAddress] || [];
+                    const ignoredTokens = allIgnoredTokens[currentChainId]?.[accountAddress] || [];
+                    const detectedTokens = allDetectedTokens[currentChainId]?.[accountAddress] || [];
+                    const newTokens = [...tokens];
+                    const [isERC721, tokenMetadata] = yield Promise.all([
+                        this._detectIsERC721(address),
+                        this.fetchTokenMetadata(address),
+                    ]);
+                    if (currentChainId !== this.config.chainId) {
+                        throw new Error('TokensController Error: Switched networks while adding token');
+                    }
+                    const newEntry = {
+                        address,
+                        symbol,
+                        decimals,
+                        image: image ||
+                            (0, assetsUtil_1.formatIconUrlWithProxy)({
+                                chainId: this.config.chainId,
+                                tokenAddress: address,
+                            }),
+                        isERC721,
+                        aggregators: (0, assetsUtil_1.formatAggregatorNames)((tokenMetadata === null || tokenMetadata === void 0 ? void 0 : tokenMetadata.aggregators) || []),
+                    };
+                    const previousEntry = newTokens.find((token) => token.address.toLowerCase() === address.toLowerCase());
+                    if (previousEntry) {
+                        const previousIndex = newTokens.indexOf(previousEntry);
+                        newTokens[previousIndex] = newEntry;
+                    }
+                    else {
+                        newTokens.push(newEntry);
+                    }
+                    const newIgnoredTokens = ignoredTokens.filter((tokenAddress) => tokenAddress.toLowerCase() !== address.toLowerCase());
+                    const newDetectedTokens = detectedTokens.filter((token) => token.address.toLowerCase() !== address.toLowerCase());
+                    const { newAllTokens, newAllIgnoredTokens, newAllDetectedTokens } = this._getNewAllTokensState({
+                        newTokens,
+                        newIgnoredTokens,
+                        newDetectedTokens,
+                        detectionAddress: accountAddress,
+                    });
+                    this.update({
+                        allTokens: newAllTokens,
+                        allIgnoredTokens: newAllIgnoredTokens,
+                        allDetectedTokens: newAllDetectedTokens,
+                    });
+                    return newTokens;
+                }
+                finally {
+                    releaseLock();
+                }
+            });
+        }
     /**
      * Add a batch of tokens.
      *
@@ -199,7 +267,7 @@ class TokensController extends base_controller_1.BaseController {
             }, {});
             try {
                 tokensToImport.forEach((tokenToAdd) => {
-                    const { address, symbol, decimals, image, aggregators } = tokenToAdd;
+                    const { address, symbol, decimals, image, aggregators, name } = tokenToAdd;
                     const checksumAddress = (0, controller_utils_1.toChecksumHexAddress)(address);
                     const formattedToken = {
                         address: checksumAddress,
@@ -207,6 +275,7 @@ class TokensController extends base_controller_1.BaseController {
                         decimals,
                         image,
                         aggregators,
+                        name
                     };
                     newTokensMap[address] = formattedToken;
                     importedTokensMap[address.toLowerCase()] = true;
@@ -282,7 +351,7 @@ class TokensController extends base_controller_1.BaseController {
             let newDetectedTokens = [...detectedTokens];
             try {
                 incomingDetectedTokens.forEach((tokenToAdd) => {
-                    const { address, symbol, decimals, image, aggregators, isERC721 } = tokenToAdd;
+                    const { address, symbol, decimals, image, aggregators, isERC721, name } = tokenToAdd;
                     const checksumAddress = (0, controller_utils_1.toChecksumHexAddress)(address);
                     const newEntry = {
                         address: checksumAddress,
@@ -291,6 +360,7 @@ class TokensController extends base_controller_1.BaseController {
                         image,
                         isERC721,
                         aggregators,
+                        name
                     };
                     const previousImportedEntry = newTokens.find((token) => token.address.toLowerCase() === checksumAddress.toLowerCase());
                     if (previousImportedEntry) {
@@ -357,6 +427,22 @@ class TokensController extends base_controller_1.BaseController {
             return tokens[tokenIndex];
         });
     }
+
+    /**
+     * This is a function that updates the tokens name for the tokens name if it is not defined
+     * @param tokenList - Represents the fetched token list from service API 
+     */
+    async updateTokensName(tokenList) {
+        const { tokens } = this.state;
+    
+        const newTokens = tokens.map((token) => {
+            const newToken = tokenList[token.address.toLowerCase()];
+          return (!token.name && newToken?.name) ? { ...token, name: newToken.name } : {...token};
+        });
+    
+        this.update({ tokens: newTokens });
+    }
+
     /**
      * Detects whether or not a token is ERC-721 compatible.
      *
@@ -396,107 +482,46 @@ class TokensController extends base_controller_1.BaseController {
     _generateRandomId() {
         return (0, uuid_1.v1)();
     }
+    // THIS PATCHED METHOD HAS ALREADY BEEN RELEASED IN VERSION 8.0.0 of @metamask/assets-controllers
     /**
-     * Adds a new suggestedAsset to state. Parameters will be validated according to
-     * asset type being watched. A `<suggestedAssetMeta.id>:pending` hub event will be emitted once added.
+     * Adds a new suggestedAsset to the list of watched assets.
+     * Parameters will be validated according to the asset type being watched.
      *
      * @param asset - The asset to be watched. For now only ERC20 tokens are accepted.
      * @param type - The asset type.
+     * @param interactingAddress - The account that is interacting with the Dapp.
      * @returns Object containing a Promise resolving to the suggestedAsset address if accepted.
      */
-    watchAsset(asset, type) {
+    watchAsset(asset, type, interactingAddress) {
         return __awaiter(this, void 0, void 0, function* () {
+            if (type !== controller_utils_1.ERC20) {
+                throw new Error(`Asset of type ${type} not supported`);
+            }
+            const { selectedAddress } = this.config;
+            const isAddingOnWalletAccount = interactingAddress ? interactingAddress === selectedAddress : true;
             const suggestedAssetMeta = {
                 asset,
                 id: this._generateRandomId(),
-                status: SuggestedAssetStatus.pending,
                 time: Date.now(),
                 type,
+                interactingAddress: interactingAddress || selectedAddress,
             };
-            try {
-                switch (type) {
-                    case 'ERC20':
-                        (0, assetsUtil_1.validateTokenToWatch)(asset);
-                        break;
-                    default:
-                        throw new Error(`Asset of type ${type} not supported`);
+            (0, assetsUtil_1.validateTokenToWatch)(asset);
+            yield this._requestApproval(suggestedAssetMeta);
+            const { address, symbol, decimals, image } = suggestedAssetMeta.asset;
+            if (isAddingOnWalletAccount) {
+                let name;
+                try{
+                    name = yield this.getERC20TokenName(address);
+                }catch(error){
+                    name = null;
                 }
+                yield this.addToken(address, symbol, decimals, image, name);
+            } else {
+                yield this.addTokenToAccount({ accountAddress: interactingAddress, token: { address, symbol, decimals, image } });
             }
-            catch (error) {
-                this.failSuggestedAsset(suggestedAssetMeta, error);
-                return Promise.reject(error);
-            }
-            const result = new Promise((resolve, reject) => {
-                this.hub.once(`${suggestedAssetMeta.id}:finished`, (meta) => {
-                    switch (meta.status) {
-                        case SuggestedAssetStatus.accepted:
-                            return resolve(meta.asset.address);
-                        case SuggestedAssetStatus.rejected:
-                            return reject(new Error('User rejected to watch the asset.'));
-                        case SuggestedAssetStatus.failed:
-                            return reject(new Error(meta.error.message));
-                        /* istanbul ignore next */
-                        default:
-                            return reject(new Error(`Unknown status: ${meta.status}`));
-                    }
-                });
-            });
-            const { suggestedAssets } = this.state;
-            suggestedAssets.push(suggestedAssetMeta);
-            this.update({ suggestedAssets: [...suggestedAssets] });
-            this.hub.emit('pendingSuggestedAsset', suggestedAssetMeta);
-            return { result, suggestedAssetMeta };
-        });
-    }
-    /**
-     * Accepts to watch an asset and updates it's status and deletes the suggestedAsset from state,
-     * adding the asset to corresponding asset state. In this case ERC20 tokens.
-     * A `<suggestedAssetMeta.id>:finished` hub event is fired after accepted or failure.
-     *
-     * @param suggestedAssetID - The ID of the suggestedAsset to accept.
-     */
-    acceptWatchAsset(suggestedAssetID) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const { suggestedAssets } = this.state;
-            const index = suggestedAssets.findIndex(({ id }) => suggestedAssetID === id);
-            const suggestedAssetMeta = suggestedAssets[index];
-            try {
-                switch (suggestedAssetMeta.type) {
-                    case 'ERC20':
-                        const { address, symbol, decimals, image } = suggestedAssetMeta.asset;
-                        yield this.addToken(address, symbol, decimals, image);
-                        suggestedAssetMeta.status = SuggestedAssetStatus.accepted;
-                        this.hub.emit(`${suggestedAssetMeta.id}:finished`, suggestedAssetMeta);
-                        break;
-                    default:
-                        throw new Error(`Asset of type ${suggestedAssetMeta.type} not supported`);
-                }
-            }
-            catch (error) {
-                this.failSuggestedAsset(suggestedAssetMeta, error);
-            }
-            const newSuggestedAssets = suggestedAssets.filter(({ id }) => id !== suggestedAssetID);
-            this.update({ suggestedAssets: [...newSuggestedAssets] });
         });
     }
-    /**
-     * Rejects a watchAsset request based on its ID by setting its status to "rejected"
-     * and emitting a `<suggestedAssetMeta.id>:finished` hub event.
-     *
-     * @param suggestedAssetID - The ID of the suggestedAsset to accept.
-     */
-    rejectWatchAsset(suggestedAssetID) {
-        const { suggestedAssets } = this.state;
-        const index = suggestedAssets.findIndex(({ id }) => suggestedAssetID === id);
-        const suggestedAssetMeta = suggestedAssets[index];
-        if (!suggestedAssetMeta) {
-            return;
-        }
-        suggestedAssetMeta.status = SuggestedAssetStatus.rejected;
-        this.hub.emit(`${suggestedAssetMeta.id}:finished`, suggestedAssetMeta);
-        const newSuggestedAssets = suggestedAssets.filter(({ id }) => id !== suggestedAssetID);
-        this.update({ suggestedAssets: [...newSuggestedAssets] });
-    }
     /**
      * Takes a new tokens and ignoredTokens array for the current network/account combination
      * and returns new allTokens and allIgnoredTokens state to update to.
@@ -553,6 +578,26 @@ class TokensController extends base_controller_1.BaseController {
     clearIgnoredTokens() {
         this.update({ ignoredTokens: [], allIgnoredTokens: {} });
     }
+    // THIS PATCHED METHOD HAS ALREADY BEEN RELEASED IN VERSION 8.0.0 of @metamask/assets-controllers
+    _requestApproval(suggestedAssetMeta) {
+        return __awaiter(this, void 0, void 0, function* () {
+            return this.messagingSystem.call('ApprovalController:addRequest', {
+                id: suggestedAssetMeta.id,
+                origin: 'metamask',
+                type: 'wallet_watchAsset',
+                requestData: {
+                    id: suggestedAssetMeta.id,
+                    interactingAddress: suggestedAssetMeta.interactingAddress,
+                    asset: {
+                        address: suggestedAssetMeta.asset.address,
+                        decimals: suggestedAssetMeta.asset.decimals,
+                        symbol: suggestedAssetMeta.asset.symbol,
+                        image: suggestedAssetMeta.asset.image || null,
+                    },
+                },
+            }, true);
+        });
+    }
 }
 exports.TokensController = TokensController;
 exports.default = TokensController;
diff --git a/node_modules/@metamask/assets-controllers/dist/assetsUtil.d.ts b/node_modules/@metamask/assets-controllers/dist/assetsUtil.d.ts
index a58b709..20667c0 100644
--- a/node_modules/@metamask/assets-controllers/dist/assetsUtil.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/assetsUtil.d.ts
@@ -45,7 +45,8 @@ export declare enum SupportedTokenDetectionNetworks {
     mainnet = "1",
     bsc = "56",
     polygon = "137",
-    avax = "43114"
+    avax = "43114",
+    aurora = "1313161554"
 }
 /**
  * Check if token detection is enabled for certain networks.
diff --git a/node_modules/@metamask/assets-controllers/dist/assetsUtil.js b/node_modules/@metamask/assets-controllers/dist/assetsUtil.js
index 4b54e82..2322286 100644
--- a/node_modules/@metamask/assets-controllers/dist/assetsUtil.js
+++ b/node_modules/@metamask/assets-controllers/dist/assetsUtil.js
@@ -120,6 +120,7 @@ var SupportedTokenDetectionNetworks;
     SupportedTokenDetectionNetworks["bsc"] = "56";
     SupportedTokenDetectionNetworks["polygon"] = "137";
     SupportedTokenDetectionNetworks["avax"] = "43114";
+    SupportedTokenDetectionNetworks["aurora"] = "1313161554";
 })(SupportedTokenDetectionNetworks = exports.SupportedTokenDetectionNetworks || (exports.SupportedTokenDetectionNetworks = {}));
 /**
  * Check if token detection is enabled for certain networks.
