diff --git a/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.js b/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.js
index 10dc83c..80490b7 100644
--- a/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.js
+++ b/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.js
@@ -31,7 +31,7 @@ class AccountTrackerController extends base_controller_1.BaseController {
      * @param config - Initial options used to configure this controller.
      * @param state - Initial state to set on this controller.
      */
-    constructor({ onPreferencesStateChange, getIdentities, }, config, state) {
+    constructor({ onPreferencesStateChange, getIdentities, getSelectedAddress, getMultiAccountBalancesEnabled }, config, state) {
         super(config, state);
         this.mutex = new async_mutex_1.Mutex();
         /**
@@ -39,17 +39,28 @@ class AccountTrackerController extends base_controller_1.BaseController {
          */
         this.name = 'AccountTrackerController';
         /**
-         * Refreshes all accounts in the current keychain.
-         */
+         * Refreshes the balances of the accounts depending on the multi-account setting.
+         * If multi-account is disabled, only updates the selected account balance.
+         * If multi-account is enabled, updates balances for all accounts.
+         *
+         * @async
+        */
         this.refresh = () => __awaiter(this, void 0, void 0, function* () {
             this.syncAccounts();
             const accounts = Object.assign({}, this.state.accounts);
+            const isMultiAccountBalancesEnabled = this.getMultiAccountBalancesEnabled();
+            if (!isMultiAccountBalancesEnabled) {
+                const selectedAddress = this.getSelectedAddress();
+                const balance = yield this.getBalanceFromChain(selectedAddress);
+                if (!balance) return;
+                accounts[selectedAddress] = { balance: (0, controller_utils_1.BNToHex)(balance) };
+                this.update({ accounts });
+                return;
+            }
             for (const address in accounts) {
-                yield (0, controller_utils_1.safelyExecuteWithTimeout)(() => __awaiter(this, void 0, void 0, function* () {
-                    (0, utils_1.assert)(this.ethQuery, 'Provider not set.');
-                    const balance = yield (0, controller_utils_1.query)(this.ethQuery, 'getBalance', [address]);
-                    accounts[address] = { balance: (0, controller_utils_1.BNToHex)(balance) };
-                }));
+                const balance = yield this.getBalanceFromChain(address);
+                if (!balance) continue;
+                accounts[address] = { balance: (0, controller_utils_1.BNToHex)(balance) };
             }
             this.update({ accounts });
         });
@@ -59,6 +70,8 @@ class AccountTrackerController extends base_controller_1.BaseController {
         this.defaultState = { accounts: {} };
         this.initialize();
         this.getIdentities = getIdentities;
+        this.getSelectedAddress = getSelectedAddress;
+        this.getMultiAccountBalancesEnabled = getMultiAccountBalancesEnabled;
         onPreferencesStateChange(() => {
             this.refresh();
         });
@@ -135,6 +148,23 @@ class AccountTrackerController extends base_controller_1.BaseController {
             });
         });
     }
+
+    /**
+     * Fetches the balance of a given address from the blockchain.
+     *
+     * @async
+     * @param {string} address - The account address to fetch the balance for.
+     * @returns {Promise<string>} - A promise that resolves to the balance in a hex string format.
+     */
+    getBalanceFromChain(address) {
+        return __awaiter(this, void 0, void 0, function* () {
+            let balance;
+            yield (0, controller_utils_1.safelyExecuteWithTimeout)(() => __awaiter(this, void 0, void 0, function* () {
+                balance = yield (0, controller_utils_1.query)(this.ethQuery, 'getBalance', [address]);
+            }));
+            return balance;
+        });
+    }
 }
 exports.AccountTrackerController = AccountTrackerController;
 exports.default = AccountTrackerController;
diff --git a/node_modules/@metamask/assets-controllers/dist/AssetsContractController.js b/node_modules/@metamask/assets-controllers/dist/AssetsContractController.js
index 422660e..d8ee906 100644
--- a/node_modules/@metamask/assets-controllers/dist/AssetsContractController.js
+++ b/node_modules/@metamask/assets-controllers/dist/AssetsContractController.js
@@ -132,6 +132,21 @@ class AssetsContractController extends base_controller_1.BaseController {
         }
         return this.erc721Standard.getNftTokenId(address, selectedAddress, index);
     }
+
+    /**
+    * Query for the decimals for a given ERC20 asset.
+    *
+    * @param address - ERC20 asset contract address.
+    * @returns Promise resolving to the 'decimals'.
+    */
+   getERC20TokenName(address) {
+    return __awaiter(this, void 0, void 0, function* () {
+        if (this.erc20Standard === undefined) {
+            throw new Error(MISSING_PROVIDER_ERROR);
+        }
+        return yield this.erc20Standard.getTokenName(address);
+    });
+    }
     /**
      * Enumerate assets assigned to an owner.
      *
diff --git a/node_modules/@metamask/assets-controllers/dist/NftController.js b/node_modules/@metamask/assets-controllers/dist/NftController.js
index 5f414e4..b013150 100644
--- a/node_modules/@metamask/assets-controllers/dist/NftController.js
+++ b/node_modules/@metamask/assets-controllers/dist/NftController.js
@@ -55,8 +55,9 @@ class NftController extends base_controller_1.BaseController {
             selectedAddress: '',
             chainId: initialChainId,
             ipfsGateway: controller_utils_1.IPFS_DEFAULT_GATEWAY_URL,
-            openSeaEnabled: false,
+            displayNftMedia: true,
             useIPFSSubdomains: true,
+            isIpfsGatewayEnabled: true,
         };
         this.defaultState = {
             allNftContracts: {},
@@ -71,23 +72,19 @@ class NftController extends base_controller_1.BaseController {
         this.getERC1155BalanceOf = getERC1155BalanceOf;
         this.getERC1155TokenURI = getERC1155TokenURI;
         this.onNftAdded = onNftAdded;
-        onPreferencesStateChange(({ selectedAddress, ipfsGateway, openSeaEnabled }) => {
-            this.configure({ selectedAddress, ipfsGateway, openSeaEnabled });
+        onPreferencesStateChange(({ selectedAddress, ipfsGateway, displayNftMedia, isIpfsGatewayEnabled }) => {
+            this.configure({ selectedAddress, ipfsGateway, displayNftMedia, isIpfsGatewayEnabled });
         });
         onNetworkStateChange(({ providerConfig }) => {
             const { chainId } = providerConfig;
             this.configure({ chainId });
         });
     }
-    getNftApi({ contractAddress, tokenId, useProxy, }) {
-        return useProxy
-            ? `${controller_utils_1.OPENSEA_PROXY_URL}/asset/${contractAddress}/${tokenId}`
-            : `${controller_utils_1.OPENSEA_API_URL}/asset/${contractAddress}/${tokenId}`;
+    getNftApi({ contractAddress, tokenId }) {
+        return `${controller_utils_1.OPENSEA_PROXY_URL}/asset/${contractAddress}/${tokenId}`;
     }
-    getNftContractInformationApi({ contractAddress, useProxy, }) {
-        return useProxy
-            ? `${controller_utils_1.OPENSEA_PROXY_URL}/asset_contract/${contractAddress}`
-            : `${controller_utils_1.OPENSEA_API_URL}/asset_contract/${contractAddress}`;
+    getNftContractInformationApi({ contractAddress }) {
+        return  `${controller_utils_1.OPENSEA_PROXY_URL}/asset_contract/${contractAddress}`;
     }
     /**
      * Helper method to update nested state for allNfts and allNftContracts.
@@ -120,28 +117,13 @@ class NftController extends base_controller_1.BaseController {
     getNftInformationFromApi(contractAddress, tokenId) {
         return __awaiter(this, void 0, void 0, function* () {
             // Attempt to fetch the data with the proxy
+            try{
             let nftInformation = yield (0, controller_utils_1.fetchWithErrorHandling)({
                 url: this.getNftApi({
                     contractAddress,
                     tokenId,
-                    useProxy: true,
                 }),
             });
-            // if an openSeaApiKey is set we should attempt to refetch calling directly to OpenSea
-            if (!nftInformation && this.openSeaApiKey) {
-                nftInformation = yield (0, controller_utils_1.fetchWithErrorHandling)({
-                    url: this.getNftApi({
-                        contractAddress,
-                        tokenId,
-                        useProxy: false,
-                    }),
-                    options: {
-                        headers: { 'X-API-KEY': this.openSeaApiKey },
-                    },
-                    // catch 403 errors (in case API key is down we don't want to blow up)
-                    errorCodesToCatch: [403],
-                });
-            }
             // if we were still unable to fetch the data we return out the default/null of `NftMetadata`
             if (!nftInformation) {
                 return {
@@ -159,6 +141,15 @@ class NftController extends base_controller_1.BaseController {
                 animationOriginal: animation_original_url,
             }, external_link && { externalLink: external_link }, last_sale && { lastSale: last_sale }, schema_name && { standard: schema_name });
             return nftMetadata;
+            }catch(error){
+                return {
+                    name: null,
+                    description: null,
+                    image: null,
+                    standard: null,
+                    error: 'Opensea import error'
+                };
+            }
         });
     }
     /**
@@ -170,12 +161,46 @@ class NftController extends base_controller_1.BaseController {
      */
     getNftInformationFromTokenURI(contractAddress, tokenId) {
         return __awaiter(this, void 0, void 0, function* () {
-            const { ipfsGateway, useIPFSSubdomains } = this.config;
+            const { ipfsGateway, useIPFSSubdomains, isIpfsGatewayEnabled, displayNftMedia } = this.config;
             const result = yield this.getNftURIAndStandard(contractAddress, tokenId);
             let tokenURI = result[0];
             const standard = result[1];
-            if (tokenURI.startsWith('ipfs://')) {
-                tokenURI = (0, assetsUtil_1.getFormattedIpfsUrl)(ipfsGateway, tokenURI, useIPFSSubdomains);
+            if(!displayNftMedia && !isIpfsGatewayEnabled){
+                return {
+                    image: null,
+                    name: null,
+                    description: null,
+                    standard: standard || null,
+                    favorite: false,
+                    tokenURI
+                };
+            }
+
+            const hasIpfsTokenURI = tokenURI.startsWith('ipfs://');
+
+            if (hasIpfsTokenURI && !isIpfsGatewayEnabled) {
+                return {
+                    image: null,
+                    name: null,
+                    description: null,
+                    standard: standard || null,
+                    favorite: false,
+                    tokenURI: tokenURI ?? null,
+                };
+            }
+            if (hasIpfsTokenURI) {
+                tokenURI = assetsUtil_1.getFormattedIpfsUrl(ipfsGateway, tokenURI, useIPFSSubdomains);
+            }
+
+            if(!hasIpfsTokenURI && !displayNftMedia){
+                return {
+                    image: null,
+                    name: null,
+                    description: null,
+                    standard: standard || null,
+                    favorite: false,
+                    tokenURI: tokenURI ?? null,
+                };
             }
             try {
                 const object = yield (0, controller_utils_1.handleFetch)(tokenURI);
@@ -189,6 +214,7 @@ class NftController extends base_controller_1.BaseController {
                     description: object.description,
                     standard,
                     favorite: false,
+                    tokenURI
                 };
             }
             catch (_a) {
@@ -198,6 +224,8 @@ class NftController extends base_controller_1.BaseController {
                     description: null,
                     standard: standard || null,
                     favorite: false,
+                    tokenURI: tokenURI ?? null,
+                    error: 'URI import error'
                 };
             }
         });
@@ -255,12 +283,24 @@ class NftController extends base_controller_1.BaseController {
                 return yield this.getNftInformationFromTokenURI(contractAddress, tokenId);
             }));
             let openSeaMetadata;
-            if (this.config.openSeaEnabled) {
+            if (this.config.displayNftMedia) {
                 openSeaMetadata = yield (0, controller_utils_1.safelyExecute)(() => __awaiter(this, void 0, void 0, function* () {
                     return yield this.getNftInformationFromApi(contractAddress, tokenId);
                 }));
             }
-            return Object.assign(Object.assign({}, openSeaMetadata), { name: (_b = (_a = blockchainMetadata.name) !== null && _a !== void 0 ? _a : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.name) !== null && _b !== void 0 ? _b : null, description: (_d = (_c = blockchainMetadata.description) !== null && _c !== void 0 ? _c : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.description) !== null && _d !== void 0 ? _d : null, image: (_f = (_e = blockchainMetadata.image) !== null && _e !== void 0 ? _e : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.image) !== null && _f !== void 0 ? _f : null, standard: (_h = (_g = blockchainMetadata.standard) !== null && _g !== void 0 ? _g : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.standard) !== null && _h !== void 0 ? _h : null });
+            if(blockchainMetadata.error && openSeaMetadata.error){
+                return {
+                    image: null,
+                    name: null,
+                    description: null,
+                    standard: blockchainMetadata.standard ?? null,
+                    favorite: false,
+                    tokenURI: blockchainMetadata.tokenURI ?? null,
+                    error: 'Both import failed'
+                }
+            }
+          
+            return Object.assign(Object.assign({}, openSeaMetadata), { tokenURI: (_b = (_a = blockchainMetadata.tokenURI) !== null && _a !== void 0 ? _a : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.tokenURI) !== null && _b !== void 0 ? _b : null,error: (_b = (_a = blockchainMetadata.error) !== null && _a !== void 0 ? _a : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.error) !== null && _b !== void 0 ? _b : null, name: (_b = (_a = blockchainMetadata.name) !== null && _a !== void 0 ? _a : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.name) !== null && _b !== void 0 ? _b : null, description: (_d = (_c = blockchainMetadata.description) !== null && _c !== void 0 ? _c : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.description) !== null && _d !== void 0 ? _d : null, image: (_f = (_e = blockchainMetadata.image) !== null && _e !== void 0 ? _e : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.image) !== null && _f !== void 0 ? _f : null, standard: (_h = (_g = blockchainMetadata.standard) !== null && _g !== void 0 ? _g : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.standard) !== null && _h !== void 0 ? _h : null });
         });
     }
     /**
@@ -272,34 +312,15 @@ class NftController extends base_controller_1.BaseController {
     getNftContractInformationFromApi(contractAddress) {
         return __awaiter(this, void 0, void 0, function* () {
             /* istanbul ignore if */
-            let apiNftContractObject = yield (0, controller_utils_1.fetchWithErrorHandling)({
+            const apiNftContractObject = yield (0, controller_utils_1.fetchWithErrorHandling)({
                 url: this.getNftContractInformationApi({
                     contractAddress,
-                    useProxy: true,
                 }),
             });
             // if we successfully fetched return the fetched data immediately
             if (apiNftContractObject) {
                 return apiNftContractObject;
             }
-            // if we were unsuccessful in fetching from the API and an OpenSea API key is present
-            // attempt to refetch directly against the OpenSea API and if successful return the data immediately
-            if (this.openSeaApiKey) {
-                apiNftContractObject = yield (0, controller_utils_1.fetchWithErrorHandling)({
-                    url: this.getNftContractInformationApi({
-                        contractAddress,
-                        useProxy: false,
-                    }),
-                    options: {
-                        headers: { 'X-API-KEY': this.openSeaApiKey },
-                    },
-                    // catch 403 errors (in case API key is down we don't want to blow up)
-                    errorCodesToCatch: [403],
-                });
-                if (apiNftContractObject) {
-                    return apiNftContractObject;
-                }
-            }
             // If we've reached this point we were unable to fetch data from either the proxy or opensea so we return
             // the default/null of ApiNftContract
             return {
@@ -347,7 +368,7 @@ class NftController extends base_controller_1.BaseController {
                 return yield this.getNftContractInformationFromContract(contractAddress);
             }));
             let openSeaContractData;
-            if (this.config.openSeaEnabled) {
+            if (this.config.displayNftMedia) {
                 openSeaContractData = yield (0, controller_utils_1.safelyExecute)(() => __awaiter(this, void 0, void 0, function* () {
                     return yield this.getNftContractInformationFromApi(contractAddress);
                 }));
@@ -428,6 +449,7 @@ class NftController extends base_controller_1.BaseController {
                         tokenId: tokenId.toString(),
                         standard: nftMetadata.standard,
                         source: detection ? 'detected' : 'custom',
+                        tokenURI: nftMetadata.tokenURI
                     });
                 }
                 return newNfts;
diff --git a/node_modules/@metamask/assets-controllers/dist/NftDetectionController.js b/node_modules/@metamask/assets-controllers/dist/NftDetectionController.js
index 0762f57..d1669cb 100644
--- a/node_modules/@metamask/assets-controllers/dist/NftDetectionController.js
+++ b/node_modules/@metamask/assets-controllers/dist/NftDetectionController.js
@@ -74,10 +74,8 @@ class NftDetectionController extends base_controller_1.BaseController {
         this.getOpenSeaApiKey = getOpenSeaApiKey;
         this.addNft = addNft;
     }
-    getOwnerNftApi({ address, offset, useProxy, }) {
-        return useProxy
-            ? `${controller_utils_1.OPENSEA_PROXY_URL}/assets?owner=${address}&offset=${offset}&limit=50`
-            : `${controller_utils_1.OPENSEA_API_URL}/assets?owner=${address}&offset=${offset}&limit=50`;
+    getOwnerNftApi({ address, offset, }) {
+        return `${controller_utils_1.OPENSEA_PROXY_URL}/assets?owner=${address}&offset=${offset}&limit=50`;
     }
     getOwnerNfts(address) {
         var _a;
@@ -90,22 +88,9 @@ class NftDetectionController extends base_controller_1.BaseController {
             /* istanbul ignore if */
             do {
                 nftApiResponse = yield (0, controller_utils_1.fetchWithErrorHandling)({
-                    url: this.getOwnerNftApi({ address, offset, useProxy: true }),
+                    url: this.getOwnerNftApi({ address, offset}),
                     timeout: 15000,
                 });
-                if (openSeaApiKey && !nftApiResponse) {
-                    nftApiResponse = yield (0, controller_utils_1.fetchWithErrorHandling)({
-                        url: this.getOwnerNftApi({
-                            address,
-                            offset,
-                            useProxy: false,
-                        }),
-                        options: { headers: { 'X-API-KEY': openSeaApiKey } },
-                        timeout: 15000,
-                        // catch 403 errors (in case API key is down we don't want to blow up)
-                        errorCodesToCatch: [403],
-                    });
-                }
                 if (!nftApiResponse) {
                     return nfts;
                 }
diff --git a/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.js b/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.js
index 9ddbc28..58421d3 100644
--- a/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.js
+++ b/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.js
@@ -57,6 +57,27 @@ class ERC20Standard {
             }
         });
     }
+    /**
+     * Query for the name for a given ERC20 asset.
+     *
+     * @param address - ERC20 asset contract string.
+     * @returns Promise resolving to the 'name'.
+     */
+    getTokenName(address){
+        return __awaiter(this, void 0, void 0, function* () {
+            const contract = new contracts_1.Contract(address, metamask_eth_abis_1.abiERC20, this.provider);
+            try {
+                const name = yield contract.name();
+                return name.toString();
+            } catch (err) {
+            // Mirror previous implementation
+            if (err.message.includes('call revert exception')) {
+                throw new Error('Failed to parse token name');
+            }
+            throw err;
+            }
+        });
+    }
     /**
      * Query for symbol for a given ERC20 asset.
      *
@@ -83,7 +104,8 @@ class ERC20Standard {
             try {
                 const utf8 = (0, ethereumjs_util_1.toUtf8)(result);
                 if (utf8.length > 0) {
-                    return utf8;
+                    // This utf8 returns unicode characters, wee need to replace it
+                    return utf8.replace(/[\u0000\u0003\u0020]/g, '');
                 }
             }
             catch (_b) {
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.js b/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.js
index 4ed4990..f55e29f 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.js
+++ b/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.js
@@ -34,7 +34,7 @@ class TokenDetectionController extends base_controller_1.BaseController {
      * @param config - Initial options used to configure this controller.
      * @param state - Initial state to set on this controller.
      */
-    constructor({ onPreferencesStateChange, onNetworkStateChange, onTokenListStateChange, getBalancesInSingleCall, addDetectedTokens, getTokenListState, getTokensState, getNetworkState, getPreferencesState, }, config, state) {
+    constructor({ onPreferencesStateChange, onNetworkStateChange, onTokenListStateChange, getBalancesInSingleCall, addDetectedTokens, updateTokensName, getTokenListState, getTokensState, getNetworkState, getPreferencesState, }, config, state) {
         const { providerConfig: { chainId: defaultChainId }, } = getNetworkState();
         const { useTokenDetection: defaultUseTokenDetection } = getPreferencesState();
         super(config, state);
@@ -45,6 +45,7 @@ class TokenDetectionController extends base_controller_1.BaseController {
         this.defaultConfig = Object.assign({ interval: DEFAULT_INTERVAL, selectedAddress: '', disabled: true, chainId: defaultChainId, isDetectionEnabledFromPreferences: defaultUseTokenDetection, isDetectionEnabledForNetwork: (0, assetsUtil_1.isTokenDetectionSupportedForNetwork)(defaultChainId) }, config);
         this.initialize();
         this.getTokensState = getTokensState;
+        this.updateTokensName = updateTokensName;
         this.getTokenListState = getTokenListState;
         this.addDetectedTokens = addDetectedTokens;
         this.getBalancesInSingleCall = getBalancesInSingleCall;
@@ -132,6 +133,9 @@ class TokenDetectionController extends base_controller_1.BaseController {
             const tokensAddresses = tokens.map(
             /* istanbul ignore next*/ (token) => token.address.toLowerCase());
             const { tokenList } = this.getTokenListState();
+            if (tokens.length && !tokens[0].name) {
+                this.updateTokensName(tokenList);
+            }
             const tokensToDetect = [];
             for (const address in tokenList) {
                 if (!tokensAddresses.includes(address)) {
@@ -161,7 +165,7 @@ class TokenDetectionController extends base_controller_1.BaseController {
                         }
                         const caseInsensitiveTokenKey = Object.keys(tokenList).find((i) => i.toLowerCase() === tokenAddress.toLowerCase()) || '';
                         if (ignored === undefined) {
-                            const { decimals, symbol, aggregators, iconUrl } = tokenList[caseInsensitiveTokenKey];
+                            const { decimals, symbol, aggregators, iconUrl, name } = tokenList[caseInsensitiveTokenKey];
                             tokensToAdd.push({
                                 address: tokenAddress,
                                 decimals,
@@ -169,6 +173,7 @@ class TokenDetectionController extends base_controller_1.BaseController {
                                 aggregators,
                                 image: iconUrl,
                                 isERC721: false,
+                                name
                             });
                         }
                     }
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenRatesController.js b/node_modules/@metamask/assets-controllers/dist/TokenRatesController.js
index 4e60e4d..3dbf20f 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenRatesController.js
+++ b/node_modules/@metamask/assets-controllers/dist/TokenRatesController.js
@@ -8,11 +8,32 @@ var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, ge
         step((generator = generator.apply(thisArg, _arguments || [])).next());
     });
 };
+var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
+    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
+};
+var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
+    if (kind === "m") throw new TypeError("Private method is not writable");
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
+    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
+};
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+var _TokenRatesController_instances, _TokenRatesController_pollState, _TokenRatesController_updateTokenList, _TokenRatesController_stopPoll, _TokenRatesController_poll;
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.TokenRatesController = void 0;
 const base_controller_1 = require("@metamask/base-controller");
 const controller_utils_1 = require("@metamask/controller-utils");
+const fast_deep_equal_1 = __importDefault(require("fast-deep-equal"));
 const crypto_compare_1 = require("./crypto-compare");
+var PollState;
+(function (PollState) {
+    PollState["Active"] = "Active";
+    PollState["Inactive"] = "Inactive";
+})(PollState || (PollState = {}));
 const CoinGeckoApi = {
     BASE_URL: 'https://api.coingecko.com/api/v3',
     getTokenPriceURL(chainSlug, query) {
@@ -37,7 +58,7 @@ function findChainSlug(chainId, data) {
     if (!data) {
         return null;
     }
-    const chain = (_a = data.find(({ chain_identifier }) => chain_identifier !== null && (0, controller_utils_1.toHex)(chain_identifier) === chainId)) !== null && _a !== void 0 ? _a : null;
+    const chain = (_a = data.find(({ chain_identifier }) => chain_identifier !== null && String(chain_identifier) === chainId)) !== null && _a !== void 0 ? _a : null;
     return (chain === null || chain === void 0 ? void 0 : chain.id) || null;
 }
 /**
@@ -50,33 +71,41 @@ class TokenRatesController extends base_controller_1.BaseController {
      *
      * @param options - The controller options.
      * @param options.chainId - The chain ID of the current network.
+     * @param options.ticker - The ticker for the current network.
+     * @param options.selectedAddress - The current selected address.
+     * @param options.coinGeckoHeader - Ccoingecko identifier.
+     * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.
      * @param options.onTokensStateChange - Allows subscribing to token controller state changes.
-     * @param options.onCurrencyRateStateChange - Allows subscribing to currency rate controller state changes.
      * @param options.onNetworkStateChange - Allows subscribing to network state changes.
      * @param config - Initial options used to configure this controller.
      * @param state - Initial state to set on this controller.
      */
-    constructor({ chainId: initialChainId, onTokensStateChange, onCurrencyRateStateChange, onNetworkStateChange, }, config, state) {
+    constructor({ chainId: initialChainId, ticker: initialTicker, selectedAddress: initialSelectedAddress, coinGeckoHeader, onPreferencesStateChange, onTokensStateChange, onNetworkStateChange, }, config, state) {
         super(config, state);
+        _TokenRatesController_instances.add(this);
         this.tokenList = [];
-        this.supportedChains = {
-            timestamp: 0,
-            data: null,
-        };
         this.supportedVsCurrencies = {
             timestamp: 0,
             data: [],
         };
+        this.supportedChains = {
+            timestamp: 0,
+            data: null,
+        };
+        _TokenRatesController_pollState.set(this, PollState.Inactive);
         /**
          * Name of this controller used during composition
          */
         this.name = 'TokenRatesController';
+        this.coinGeckoHeader = coinGeckoHeader;
         this.defaultConfig = {
             disabled: false,
-            interval: 3 * 60 * 1000,
-            nativeCurrency: 'eth',
+            interval: 30 * 60 * 1000,
+            nativeCurrency: initialTicker,
             chainId: initialChainId,
-            tokens: [],
+            selectedAddress: initialSelectedAddress,
+            allTokens: {},
+            allDetectedTokens: {},
             threshold: 6 * 60 * 60 * 1000,
         };
         this.defaultState = {
@@ -86,60 +115,56 @@ class TokenRatesController extends base_controller_1.BaseController {
         if (config === null || config === void 0 ? void 0 : config.disabled) {
             this.configure({ disabled: true }, false, false);
         }
-        onTokensStateChange(({ tokens, detectedTokens }) => {
-            this.configure({ tokens: [...tokens, ...detectedTokens] });
-        });
-        onCurrencyRateStateChange((currencyRateState) => {
-            this.configure({ nativeCurrency: currencyRateState.nativeCurrency });
-        });
-        onNetworkStateChange(({ providerConfig }) => {
-            const { chainId } = providerConfig;
-            this.update({ contractExchangeRates: {} });
-            this.configure({ chainId });
-        });
-        this.poll();
+        __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_updateTokenList).call(this);
+        onPreferencesStateChange(({ selectedAddress }) => __awaiter(this, void 0, void 0, function* () {
+            if (this.config.selectedAddress !== selectedAddress) {
+                this.configure({ selectedAddress });
+                const isEqual = __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_updateTokenList).call(this);
+                if (__classPrivateFieldGet(this, _TokenRatesController_pollState, "f") === PollState.Active && !isEqual) {
+                    yield this.updateExchangeRates();
+                }
+            }
+        }));
+        onTokensStateChange(({ allTokens, allDetectedTokens }) => __awaiter(this, void 0, void 0, function* () {
+            // These two state properties are assumed to be immutable
+            if (this.config.allTokens !== allTokens ||
+                this.config.allDetectedTokens !== allDetectedTokens) {
+                this.configure({ allTokens, allDetectedTokens });
+                const isEqual = __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_updateTokenList).call(this);
+                if (__classPrivateFieldGet(this, _TokenRatesController_pollState, "f") === PollState.Active && !isEqual) {
+                    yield this.updateExchangeRates();
+                }
+            }
+        }));
+        onNetworkStateChange(({ providerConfig }) => __awaiter(this, void 0, void 0, function* () {
+            const { chainId, ticker } = providerConfig;
+            if (this.config.chainId !== chainId ||
+                this.config.nativeCurrency !== ticker) {
+                this.update({ contractExchangeRates: {} });
+                this.configure({ chainId, nativeCurrency: ticker || 'ETH' });
+                const isEqual = __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_updateTokenList).call(this);
+                if (__classPrivateFieldGet(this, _TokenRatesController_pollState, "f") === PollState.Active && !isEqual) {
+                    yield this.updateExchangeRates();
+                }
+            }
+        }));
     }
     /**
-     * Sets a new polling interval.
-     *
-     * @param interval - Polling interval used to fetch new token rates.
+     * Start (or restart) polling.
      */
-    poll(interval) {
+    start() {
         return __awaiter(this, void 0, void 0, function* () {
-            interval && this.configure({ interval }, false, false);
-            this.handle && clearTimeout(this.handle);
-            yield (0, controller_utils_1.safelyExecute)(() => this.updateExchangeRates());
-            this.handle = setTimeout(() => {
-                this.poll(this.config.interval);
-            }, this.config.interval);
+            __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_stopPoll).call(this);
+            __classPrivateFieldSet(this, _TokenRatesController_pollState, PollState.Active, "f");
+            yield __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_poll).call(this);
         });
     }
     /**
-     * Sets a new chainId.
-     *
-     * TODO: Replace this with a method.
-     *
-     * @param _chainId - The current chain ID.
-     */
-    set chainId(_chainId) {
-        !this.disabled && (0, controller_utils_1.safelyExecute)(() => this.updateExchangeRates());
-    }
-    get chainId() {
-        throw new Error('Property only used for setting');
-    }
-    /**
-     * Sets a new token list to track prices.
-     *
-     * TODO: Replace this with a method.
-     *
-     * @param tokens - List of tokens to track exchange rates for.
+     * Stop polling.
      */
-    set tokens(tokens) {
-        this.tokenList = tokens;
-        !this.disabled && (0, controller_utils_1.safelyExecute)(() => this.updateExchangeRates());
-    }
-    get tokens() {
-        throw new Error('Property only used for setting');
+    stop() {
+        __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_stopPoll).call(this);
+        __classPrivateFieldSet(this, _TokenRatesController_pollState, PollState.Inactive, "f");
     }
     /**
      * Fetches a pairs of token address and native currency.
@@ -150,9 +175,28 @@ class TokenRatesController extends base_controller_1.BaseController {
      */
     fetchExchangeRate(chainSlug, vsCurrency) {
         return __awaiter(this, void 0, void 0, function* () {
-            const tokenPairs = this.tokenList.map((token) => token.address).join(',');
-            const query = `contract_addresses=${tokenPairs}&vs_currencies=${vsCurrency.toLowerCase()}`;
-            return (0, controller_utils_1.handleFetch)(CoinGeckoApi.getTokenPriceURL(chainSlug, query));
+            const tokenPairs = this.tokenList;
+            const tokenPairsChunks = (chunkSize) => tokenPairs.reduce((resultArray, item, index) => {
+                const chunkIndex = Math.floor(index / chunkSize);
+                if (!resultArray[chunkIndex]) {
+                    resultArray[chunkIndex] = [];
+                }
+                resultArray[chunkIndex].push(item);
+                return resultArray;
+            }, []);
+            const tokensPairsChunks = tokenPairsChunks(20);
+            const results = [];
+            for (const tokenPairsChunk of tokensPairsChunks) {
+                const query = `contract_addresses=${tokenPairsChunk.join(',')}&vs_currencies=${vsCurrency.toLowerCase()}`;
+                const result = yield (0, controller_utils_1.handleFetch)(CoinGeckoApi.getTokenPriceURL(chainSlug, query), {
+                    headers: {
+                        'Content-Type': 'application/json',
+                        'X-Requested-With': this.coinGeckoHeader,
+                    },
+                });
+                results.push(result);
+            }
+            return results;
         });
     }
     /**
@@ -211,8 +255,8 @@ class TokenRatesController extends base_controller_1.BaseController {
             const slug = yield this.getChainSlug();
             let newContractExchangeRates = {};
             if (!slug) {
-                this.tokenList.forEach((token) => {
-                    const address = (0, controller_utils_1.toChecksumHexAddress)(token.address);
+                this.tokenList.forEach((tokenAddress) => {
+                    const address = (0, controller_utils_1.toChecksumHexAddress)(tokenAddress);
                     newContractExchangeRates[address] = undefined;
                 });
             }
@@ -238,14 +282,18 @@ class TokenRatesController extends base_controller_1.BaseController {
     fetchAndMapExchangeRates(nativeCurrency, slug) {
         return __awaiter(this, void 0, void 0, function* () {
             const contractExchangeRates = {};
+            if (this.tokenList.length === 0) {
+                return contractExchangeRates;
+            }
             // check if native currency is supported as a vs_currency by the API
             const nativeCurrencySupported = yield this.checkIsSupportedVsCurrency(nativeCurrency);
             if (nativeCurrencySupported) {
                 // If it is we can do a simple fetch against the CoinGecko API
-                const prices = yield this.fetchExchangeRate(slug, nativeCurrency);
-                this.tokenList.forEach((token) => {
-                    const price = prices[token.address.toLowerCase()];
-                    contractExchangeRates[(0, controller_utils_1.toChecksumHexAddress)(token.address)] = price
+                const res = yield this.fetchExchangeRate(slug, nativeCurrency);
+                const prices = Object.assign({}, ...res);
+                this.tokenList.forEach((tokenAddress) => {
+                    const price = prices[tokenAddress.toLowerCase()];
+                    contractExchangeRates[(0, controller_utils_1.toChecksumHexAddress)(tokenAddress)] = price
                         ? price[nativeCurrency.toLowerCase()]
                         : 0;
                 });
@@ -253,11 +301,11 @@ class TokenRatesController extends base_controller_1.BaseController {
             else {
                 // if native currency is not supported we need to use a fallback vsCurrency, get the exchange rates
                 // in token/fallback-currency format and convert them to expected token/nativeCurrency format.
-                let tokenExchangeRates;
+                let tokenExchangeRatesResponse;
                 let vsCurrencyToNativeCurrencyConversionRate = 0;
                 try {
                     [
-                        tokenExchangeRates,
+                        tokenExchangeRatesResponse,
                         { conversionRate: vsCurrencyToNativeCurrencyConversionRate },
                     ] = yield Promise.all([
                         this.fetchExchangeRate(slug, controller_utils_1.FALL_BACK_VS_CURRENCY),
@@ -271,8 +319,10 @@ class TokenRatesController extends base_controller_1.BaseController {
                     }
                     throw error;
                 }
+                const tokenExchangeRates = Object.assign({}, ...tokenExchangeRatesResponse);
                 for (const [tokenAddress, conversion] of Object.entries(tokenExchangeRates)) {
-                    const tokenToVsCurrencyConversionRate = conversion[controller_utils_1.FALL_BACK_VS_CURRENCY.toLowerCase()];
+                    const conversionTyped = conversion;
+                    const tokenToVsCurrencyConversionRate = conversionTyped[controller_utils_1.FALL_BACK_VS_CURRENCY.toLowerCase()];
                     contractExchangeRates[(0, controller_utils_1.toChecksumHexAddress)(tokenAddress)] =
                         tokenToVsCurrencyConversionRate *
                             vsCurrencyToNativeCurrencyConversionRate;
@@ -283,5 +333,29 @@ class TokenRatesController extends base_controller_1.BaseController {
     }
 }
 exports.TokenRatesController = TokenRatesController;
+_TokenRatesController_pollState = new WeakMap(), _TokenRatesController_instances = new WeakSet(), _TokenRatesController_updateTokenList = function _TokenRatesController_updateTokenList() {
+    var _a, _b;
+    const { allTokens, allDetectedTokens } = this.config;
+    const oldTokenList = this.tokenList;
+    const tokens = ((_a = allTokens[this.config.chainId]) === null || _a === void 0 ? void 0 : _a[this.config.selectedAddress]) || [];
+    const detectedTokens = ((_b = allDetectedTokens[this.config.chainId]) === null || _b === void 0 ? void 0 : _b[this.config.selectedAddress]) ||
+        [];
+    const newTokenList = [...tokens, ...detectedTokens].map((token) => token.address);
+    this.tokenList = newTokenList;
+    return (0, fast_deep_equal_1.default)(oldTokenList, newTokenList);
+}, _TokenRatesController_stopPoll = function _TokenRatesController_stopPoll() {
+    if (this.handle) {
+        clearTimeout(this.handle);
+    }
+}, _TokenRatesController_poll = function _TokenRatesController_poll() {
+    return __awaiter(this, void 0, void 0, function* () {
+        yield (0, controller_utils_1.safelyExecute)(() => this.updateExchangeRates());
+        // Poll using recursive `setTimeout` instead of `setInterval` so that
+        // requests don't stack if they take longer than the polling interval
+        this.handle = setTimeout(() => {
+            __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_poll).call(this);
+        }, this.config.interval);
+    });
+};
 exports.default = TokenRatesController;
 //# sourceMappingURL=TokenRatesController.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/TokensController.js b/node_modules/@metamask/assets-controllers/dist/TokensController.js
index e630b79..21911c9 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokensController.js
+++ b/node_modules/@metamask/assets-controllers/dist/TokensController.js
@@ -43,8 +43,9 @@ class TokensController extends base_controller_1.BaseController {
      * @param options.config - Initial options used to configure this controller.
      * @param options.state - Initial state to set on this controller.
      * @param options.messenger - The controller messenger.
+     * @param options.getERC20TokenName - Allows fetch an ERC-20 token name
      */
-    constructor({ chainId: initialChainId, onPreferencesStateChange, onNetworkStateChange, config, state, messenger, }) {
+    constructor({ chainId: initialChainId, onPreferencesStateChange, onNetworkStateChange, config, state, messenger, getERC20TokenName }) {
         super(config, state);
         this.mutex = new async_mutex_1.Mutex();
         /**
@@ -60,6 +61,7 @@ class TokensController extends base_controller_1.BaseController {
         this.initialize();
         this.abortController = new abort_controller_1.AbortController();
         this.messagingSystem = messenger;
+        this.getERC20TokenName = getERC20TokenName;
         onPreferencesStateChange(({ selectedAddress }) => {
             var _a, _b, _c;
             const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
@@ -118,11 +120,13 @@ class TokensController extends base_controller_1.BaseController {
      * @param address - Hex address of the token contract.
      * @param symbol - Symbol of the token.
      * @param decimals - Number of decimals the token uses.
-     * @param image - Image of the token.
-     * @param interactingAddress - The address of the account to add a token to.
+     * @param options - Object containing name and image of the token
+     * @param options.name - Name of the token
+     * @param options.image - Image of the token
+     * @param options.interactingAddress - The address of the account to add a token to.
      * @returns Current token list.
      */
-    addToken(address, symbol, decimals, image, interactingAddress) {
+    addToken(address, symbol, decimals, { name, image, interactingAddress }) {
         var _a, _b, _c;
         return __awaiter(this, void 0, void 0, function* () {
             const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
@@ -154,6 +158,7 @@ class TokensController extends base_controller_1.BaseController {
                         }),
                     isERC721,
                     aggregators: (0, assetsUtil_1.formatAggregatorNames)((tokenMetadata === null || tokenMetadata === void 0 ? void 0 : tokenMetadata.aggregators) || []),
+                    name
                 };
                 const previousEntry = newTokens.find((token) => token.address.toLowerCase() === address.toLowerCase());
                 if (previousEntry) {
@@ -205,7 +210,7 @@ class TokensController extends base_controller_1.BaseController {
             }, {});
             try {
                 tokensToImport.forEach((tokenToAdd) => {
-                    const { address, symbol, decimals, image, aggregators } = tokenToAdd;
+                    const { address, symbol, decimals, image, aggregators, name } = tokenToAdd;
                     const checksumAddress = (0, controller_utils_1.toChecksumHexAddress)(address);
                     const formattedToken = {
                         address: checksumAddress,
@@ -213,6 +218,7 @@ class TokensController extends base_controller_1.BaseController {
                         decimals,
                         image,
                         aggregators,
+                        name
                     };
                     newTokensMap[address] = formattedToken;
                     importedTokensMap[address.toLowerCase()] = true;
@@ -288,7 +294,7 @@ class TokensController extends base_controller_1.BaseController {
             let newDetectedTokens = [...detectedTokens];
             try {
                 incomingDetectedTokens.forEach((tokenToAdd) => {
-                    const { address, symbol, decimals, image, aggregators, isERC721 } = tokenToAdd;
+                    const { address, symbol, decimals, image, aggregators, isERC721, name } = tokenToAdd;
                     const checksumAddress = (0, controller_utils_1.toChecksumHexAddress)(address);
                     const newEntry = {
                         address: checksumAddress,
@@ -297,6 +303,7 @@ class TokensController extends base_controller_1.BaseController {
                         image,
                         isERC721,
                         aggregators,
+                        name
                     };
                     const previousImportedEntry = newTokens.find((token) => token.address.toLowerCase() === checksumAddress.toLowerCase());
                     if (previousImportedEntry) {
@@ -363,6 +370,20 @@ class TokensController extends base_controller_1.BaseController {
             return tokens[tokenIndex];
         });
     }
+    /**
+     * This is a function that updates the tokens name for the tokens name if it is not defined
+     * @param tokenList - Represents the fetched token list from service API
+     */
+    async updateTokensName(tokenList) {
+        const { tokens } = this.state;
+
+        const newTokens = tokens.map((token) => {
+            const newToken = tokenList[token.address.toLowerCase()];
+          return (!token.name && newToken?.name) ? { ...token, name: newToken.name } : {...token};
+        });
+
+        this.update({ tokens: newTokens });
+    }
     /**
      * Detects whether or not a token is ERC-721 compatible.
      *
@@ -426,7 +447,17 @@ class TokensController extends base_controller_1.BaseController {
             };
             (0, assetsUtil_1.validateTokenToWatch)(asset);
             yield this._requestApproval(suggestedAssetMeta);
-            yield this.addToken(asset.address, asset.symbol, asset.decimals, asset.image, suggestedAssetMeta.interactingAddress);
+            let name;
+            try{
+                name = yield this.getERC20TokenName(address);
+            }catch(error){
+                name = undefined;
+            }
+            yield this.addToken(asset.address, asset.symbol, asset.decimals, {
+                name,
+                image: asset.image,
+                interactingAddress: suggestedAssetMeta.interactingAddress,
+            });      
         });
     }
     /**
