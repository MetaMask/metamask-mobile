diff --git a/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.js b/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.js
index 10dc83c..4a31cc7 100644
--- a/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.js
+++ b/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.js
@@ -31,7 +31,7 @@ class AccountTrackerController extends base_controller_1.BaseController {
      * @param config - Initial options used to configure this controller.
      * @param state - Initial state to set on this controller.
      */
-    constructor({ onPreferencesStateChange, getIdentities, }, config, state) {
+    constructor({ onPreferencesStateChange, getIdentities,  getSelectedAddress, getMultiAccountBalancesEnabled, }, config, state) {
         super(config, state);
         this.mutex = new async_mutex_1.Mutex();
         /**
@@ -39,17 +39,28 @@ class AccountTrackerController extends base_controller_1.BaseController {
          */
         this.name = 'AccountTrackerController';
         /**
-         * Refreshes all accounts in the current keychain.
+         * Refreshes the balances of the accounts depending on the multi-account setting.
+         * If multi-account is disabled, only updates the selected account balance.
+         * If multi-account is enabled, updates balances for all accounts.
+         *
+         * @async
          */
         this.refresh = () => __awaiter(this, void 0, void 0, function* () {
             this.syncAccounts();
             const accounts = Object.assign({}, this.state.accounts);
+            const isMultiAccountBalancesEnabled = this.getMultiAccountBalancesEnabled()
+            if (!isMultiAccountBalancesEnabled) {
+                const selectedAddress = this.getSelectedAddress();
+                const balance = yield this.getBalanceFromChain(selectedAddress);
+                if (!balance) return;
+                accounts[selectedAddress] = { balance: (0, controller_utils_1.BNToHex)(balance) };
+                this.update({ accounts });
+                return;
+            }
             for (const address in accounts) {
-                yield (0, controller_utils_1.safelyExecuteWithTimeout)(() => __awaiter(this, void 0, void 0, function* () {
-                    (0, utils_1.assert)(this.ethQuery, 'Provider not set.');
-                    const balance = yield (0, controller_utils_1.query)(this.ethQuery, 'getBalance', [address]);
-                    accounts[address] = { balance: (0, controller_utils_1.BNToHex)(balance) };
-                }));
+                const balance = yield this.getBalanceFromChain(address);
+                if (!balance) continue;
+                accounts[address] = { balance: (0, controller_utils_1.BNToHex)(balance) };
             }
             this.update({ accounts });
         });
@@ -59,6 +70,8 @@ class AccountTrackerController extends base_controller_1.BaseController {
         this.defaultState = { accounts: {} };
         this.initialize();
         this.getIdentities = getIdentities;
+        this.getSelectedAddress = getSelectedAddress;
+        this.getMultiAccountBalancesEnabled = getMultiAccountBalancesEnabled;
         onPreferencesStateChange(() => {
             this.refresh();
         });
@@ -108,6 +121,22 @@ class AccountTrackerController extends base_controller_1.BaseController {
             }, this.config.interval);
         });
     }
+    /**
+     * Fetches the balance of a given address from the blockchain.
+     *
+     * @async
+     * @param {string} address - The account address to fetch the balance for.
+     * @returns {Promise<string>} - A promise that resolves to the balance in a hex string format.
+     */
+    getBalanceFromChain(address) {
+        return __awaiter(this, void 0, void 0, function* () {
+            let balance;
+            yield (0, controller_utils_1.safelyExecuteWithTimeout)(() => __awaiter(this, void 0, void 0, function* () {
+                balance = yield (0, controller_utils_1.query)(this.ethQuery, 'getBalance', [address]);
+            }));
+            return balance;
+        });
+    }
     /**
      * Sync accounts balances with some additional addresses.
      *
diff --git a/node_modules/@metamask/assets-controllers/dist/AssetsContractController.js b/node_modules/@metamask/assets-controllers/dist/AssetsContractController.js
index 422660e..8be8064 100644
--- a/node_modules/@metamask/assets-controllers/dist/AssetsContractController.js
+++ b/node_modules/@metamask/assets-controllers/dist/AssetsContractController.js
@@ -34,6 +34,8 @@ exports.SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID = {
     [assetsUtil_1.SupportedTokenDetectionNetworks.polygon]: '0x2352c63A83f9Fd126af8676146721Fa00924d7e4',
     [assetsUtil_1.SupportedTokenDetectionNetworks.avax]: '0xD023D153a0DFa485130ECFdE2FAA7e612EF94818',
     [assetsUtil_1.SupportedTokenDetectionNetworks.aurora]: '0x1286415D333855237f89Df27D388127181448538',
+    [assetsUtil_1.SupportedTokenDetectionNetworks.linea_goerli]: '0x10dAd7Ca3921471f616db788D9300DC97Db01783',
+    [assetsUtil_1.SupportedTokenDetectionNetworks.linea_mainnet]: '0xF62e6a41561b3650a69Bb03199C735e3E3328c0D',
 };
 exports.MISSING_PROVIDER_ERROR = 'AssetsContractController failed to set the provider correctly. A provider must be set for this method to be available';
 /**
@@ -118,6 +120,20 @@ class AssetsContractController extends base_controller_1.BaseController {
             return yield this.erc20Standard.getTokenDecimals(address);
         });
     }
+    /**
+     * Query for the decimals for a given ERC20 asset.
+     *
+     * @param address - ERC20 asset contract address.
+     * @returns Promise resolving to the 'decimals'.
+     */
+    getERC20TokenName(address) {
+        return __awaiter(this, void 0, void 0, function* () {
+            if (this.erc20Standard === undefined) {
+                throw new Error(MISSING_PROVIDER_ERROR);
+            }
+            return yield this.erc20Standard.getTokenName(address);
+        });
+    }
     /**
      * Enumerate assets assigned to an owner.
      *
diff --git a/node_modules/@metamask/assets-controllers/dist/NftController.d.ts b/node_modules/@metamask/assets-controllers/dist/NftController.d.ts
index 360c8b7..f10bad0 100644
--- a/node_modules/@metamask/assets-controllers/dist/NftController.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/NftController.d.ts
@@ -59,6 +59,74 @@ export interface NftContract {
     schemaName?: string;
     externalLink?: string;
 }
+export declare enum OpenSeaV2ChainIds {
+    ethereum = "ethereum"
+}
+export declare type OpenSeaV2GetNftResponse = {
+    nft: OpenSeaV2DetailedNft;
+};
+export declare type OpenSeaV2Nft = {
+    identifier: string;
+    collection: string;
+    contract: string;
+    token_standard: string;
+    name: string;
+    description: string;
+    image_url?: string;
+    metadata_url?: string;
+    updated_at: string;
+    is_disabled: boolean;
+    is_nsfw: boolean;
+};
+export declare type OpenSeaV2DetailedNft = OpenSeaV2Nft & {
+    animation_url?: string;
+    is_suspicious: boolean;
+    creator: string;
+    traits: {
+        trait_type: string;
+        display_type?: string;
+        max_value: string;
+        trait_count?: number;
+        value: number | string;
+    }[];
+    owners: {
+        address: string;
+        quantity: number;
+    }[];
+    rarity: {
+        rank: number;
+    };
+};
+export declare type OpenSeaV2ListNftsResponse = {
+    nfts: OpenSeaV2Nft[];
+    next?: string;
+};
+export declare type OpenSeaV2Contract = {
+    address: string;
+    chain: string;
+    collection: string;
+    contract_standard: string;
+    name: string;
+    supply: number;
+};
+export declare type OpenSeaV2Collection = {
+    collection: string;
+    name: string;
+    description?: string;
+    image_url?: string;
+    owner: string;
+    category: string;
+    is_disabled: boolean;
+    is_nsfw: boolean;
+    trait_offers_enabled: boolean;
+    opensea_url: string;
+    project_url?: string;
+    wiki_url?: string;
+    discord_url?: string;
+    telegram_url?: string;
+    twitter_username?: string;
+    instagram_username?: string;
+};
 /**
  * @type NftMetadata
  *
@@ -94,6 +162,8 @@ export interface NftMetadata {
     creator?: ApiNftCreator;
     lastSale?: ApiNftLastSale;
     transactionId?: string;
+    tokenURI?: string;
+    error?: string;
 }
 interface AccountParams {
     userAddress: string;
@@ -109,7 +179,8 @@ export interface NftConfig extends BaseConfig {
     selectedAddress: string;
     chainId: Hex;
     ipfsGateway: string;
-    openSeaEnabled: boolean;
+    isIpfsGatewayEnabled: boolean;
+    displayNftMedia: boolean;
     useIPFSSubdomains: boolean;
 }
 /**
@@ -138,8 +209,9 @@ export interface NftState extends BaseState {
  */
 export declare class NftController extends BaseController<NftConfig, NftState> {
     private mutex;
-    private getNftApi;
+    public getNftApi;
     private getNftContractInformationApi;
+    private getNftCollectionInformationApi;
     /**
      * Helper method to update nested state for allNfts and allNftContracts.
      *
diff --git a/node_modules/@metamask/assets-controllers/dist/NftController.d.ts.map b/node_modules/@metamask/assets-controllers/dist/NftController.d.ts.map
index f41b2aa..2b368b9 100644
--- a/node_modules/@metamask/assets-controllers/dist/NftController.d.ts.map
+++ b/node_modules/@metamask/assets-controllers/dist/NftController.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"NftController.d.ts","sourceRoot":"","sources":["../src/NftController.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,YAAY,EAAE,MAAM,QAAQ,CAAC;AAGtC,OAAO,KAAK,EAAE,GAAG,EAAE,MAAM,iBAAiB,CAAC;AAC3C,OAAO,EACL,cAAc,EACd,UAAU,EACV,SAAS,EACV,MAAM,2BAA2B,CAAC;AACnC,OAAO,KAAK,EAAE,gBAAgB,EAAE,MAAM,kCAAkC,CAAC;AACzE,OAAO,KAAK,EAAE,YAAY,EAAE,MAAM,8BAA8B,CAAC;AAajE,OAAO,KAAK,EAEV,aAAa,EAEb,cAAc,EACf,MAAM,0BAA0B,CAAC;AAClC,OAAO,KAAK,EAAE,wBAAwB,EAAE,MAAM,4BAA4B,CAAC;AAG3E;;;;;;;;;;;;;;;;;;;;GAoBG;AACH,MAAM,WAAW,GAAI,SAAQ,WAAW;IACtC,OAAO,EAAE,MAAM,CAAC;IAChB,OAAO,EAAE,MAAM,CAAC;IAChB,gBAAgB,CAAC,EAAE,OAAO,CAAC;CAC5B;AAED;;;;;;;;;;;;;;GAcG;AACH,MAAM,WAAW,WAAW;IAC1B,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,OAAO,EAAE,MAAM,CAAC;IAChB,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,WAAW,CAAC,EAAE,MAAM,CAAC;IACrB,WAAW,CAAC,EAAE,MAAM,CAAC;IACrB,iBAAiB,CAAC,EAAE,MAAM,CAAC;IAC3B,WAAW,CAAC,EAAE,MAAM,CAAC;IACrB,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,YAAY,CAAC,EAAE,MAAM,CAAC;CACvB;AAED;;;;;;;;;;;;;;;;;GAiBG;AACH,MAAM,WAAW,WAAW;IAC1B,IAAI,EAAE,MAAM,GAAG,IAAI,CAAC;IACpB,WAAW,EAAE,MAAM,GAAG,IAAI,CAAC;IAC3B,KAAK,EAAE,MAAM,GAAG,IAAI,CAAC;IACrB,QAAQ,EAAE,MAAM,GAAG,IAAI,CAAC;IACxB,QAAQ,CAAC,EAAE,OAAO,CAAC;IACnB,aAAa,CAAC,EAAE,MAAM,CAAC;IACvB,eAAe,CAAC,EAAE,MAAM,CAAC;IACzB,YAAY,CAAC,EAAE,MAAM,CAAC;IACtB,cAAc,CAAC,EAAE,MAAM,CAAC;IACxB,aAAa,CAAC,EAAE,MAAM,CAAC;IACvB,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,iBAAiB,CAAC,EAAE,MAAM,CAAC;IAC3B,YAAY,CAAC,EAAE,MAAM,CAAC;IACtB,OAAO,CAAC,EAAE,aAAa,CAAC;IACxB,QAAQ,CAAC,EAAE,cAAc,CAAC;IAC1B,aAAa,CAAC,EAAE,MAAM,CAAC;CACxB;AAED,UAAU,aAAa;IACrB,WAAW,EAAE,MAAM,CAAC;IACpB,OAAO,EAAE,GAAG,CAAC;CACd;AAED;;;;;GAKG;AACH,MAAM,WAAW,SAAU,SAAQ,UAAU;IAC3C,eAAe,EAAE,MAAM,CAAC;IACxB,OAAO,EAAE,GAAG,CAAC;IACb,WAAW,EAAE,MAAM,CAAC;IACpB,cAAc,EAAE,OAAO,CAAC;IACxB,iBAAiB,EAAE,OAAO,CAAC;CAC5B;AAED;;;;;;;GAOG;AACH,MAAM,WAAW,QAAS,SAAQ,SAAS;IACzC,eAAe,EAAE;QACf,CAAC,GAAG,EAAE,MAAM,GAAG;YAAE,CAAC,OAAO,EAAE,GAAG,GAAG,WAAW,EAAE,CAAA;SAAE,CAAC;KAClD,CAAC;IACF,OAAO,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG;YAAE,CAAC,OAAO,EAAE,GAAG,GAAG,GAAG,EAAE,CAAA;SAAE,CAAA;KAAE,CAAC;IACtD,WAAW,EAAE,GAAG,EAAE,CAAC;CACpB;AAKD;;GAEG;AACH,qBAAa,aAAc,SAAQ,cAAc,CAAC,SAAS,EAAE,QAAQ,CAAC;IACpE,OAAO,CAAC,KAAK,CAAe;IAE5B,OAAO,CAAC,SAAS;IAcjB,OAAO,CAAC,4BAA4B;IAYpC;;;;;;;;OAQG;IACH,OAAO,CAAC,oBAAoB;IAyB5B;;;;;;OAMG;YACW,wBAAwB;IAkFtC;;;;;;OAMG;YACW,6BAA6B;IAsC3C;;;;;;OAMG;YACW,oBAAoB;IAqClC;;;;;;OAMG;YACW,iBAAiB;IAyB/B;;;;;OAKG;YACW,gCAAgC;IAuD9C;;;;;OAKG;YACW,qCAAqC;IAgBnD;;;;;OAKG;YACW,yBAAyB;IA8CvC;;;;;;;;;OASG;YACW,gBAAgB;IAiF9B;;;;;;OAMG;YACW,cAAc;IA2E5B;;;;;OAKG;IACH,OAAO,CAAC,4BAA4B;IA2BpC;;;;;OAKG;IACH,OAAO,CAAC,mBAAmB;IAe3B;;;;;OAKG;IACH,OAAO,CAAC,iBAAiB;IAezB;;OAEG;IACH,GAAG,eAAsB;IAEzB;;OAEG;IACH,aAAa,CAAC,EAAE,MAAM,CAAC;IAEvB;;OAEG;IACM,IAAI,SAAmB;IAEhC,OAAO,CAAC,kBAAkB,CAAiD;IAE3E,OAAO,CAAC,oBAAoB,CAAmD;IAE/E,OAAO,CAAC,iBAAiB,CAAgD;IAEzE,OAAO,CAAC,gBAAgB,CAA+C;IAEvE,OAAO,CAAC,mBAAmB,CAAkD;IAE7E,OAAO,CAAC,kBAAkB,CAAiD;IAE3E,OAAO,CAAC,UAAU,CAAC,CAMR;IAEX;;;;;;;;;;;;;;;;;OAiBG;gBAED,EACE,OAAO,EAAE,cAAc,EACvB,wBAAwB,EACxB,oBAAoB,EACpB,kBAAkB,EAClB,oBAAoB,EACpB,iBAAiB,EACjB,gBAAgB,EAChB,mBAAmB,EACnB,kBAAkB,EAClB,UAAU,GACX,EAAE;QACD,OAAO,EAAE,GAAG,CAAC;QACb,wBAAwB,EAAE,CACxB,QAAQ,EAAE,CAAC,gBAAgB,EAAE,gBAAgB,KAAK,IAAI,KACnD,IAAI,CAAC;QACV,oBAAoB,EAAE,CACpB,QAAQ,EAAE,CAAC,YAAY,EAAE,YAAY,KAAK,IAAI,KAC3C,IAAI,CAAC;QACV,kBAAkB,EAAE,wBAAwB,CAAC,oBAAoB,CAAC,CAAC;QACnE,oBAAoB,EAAE,wBAAwB,CAAC,sBAAsB,CAAC,CAAC;QACvE,iBAAiB,EAAE,wBAAwB,CAAC,mBAAmB,CAAC,CAAC;QACjE,gBAAgB,EAAE,wBAAwB,CAAC,kBAAkB,CAAC,CAAC;QAC/D,mBAAmB,EAAE,wBAAwB,CAAC,qBAAqB,CAAC,CAAC;QACrE,kBAAkB,EAAE,wBAAwB,CAAC,oBAAoB,CAAC,CAAC;QACnE,UAAU,CAAC,EAAE,CAAC,IAAI,EAAE;YAClB,OAAO,EAAE,MAAM,CAAC;YAChB,MAAM,EAAE,MAAM,GAAG,SAAS,CAAC;YAC3B,OAAO,EAAE,MAAM,CAAC;YAChB,QAAQ,EAAE,MAAM,GAAG,IAAI,CAAC;YACxB,MAAM,EAAE,MAAM,CAAC;SAChB,KAAK,IAAI,CAAC;KACZ,EACD,MAAM,CAAC,EAAE,OAAO,CAAC,UAAU,CAAC,EAC5B,KAAK,CAAC,EAAE,OAAO,CAAC,QAAQ,CAAC;IAqC3B;;;;OAIG;IACH,SAAS,CAAC,aAAa,EAAE,MAAM;IAI/B;;;;;;;OAOG;IACG,UAAU,CACd,YAAY,EAAE,MAAM,EACpB,UAAU,EAAE,MAAM,EAClB,KAAK,EAAE,MAAM,GACZ,OAAO,CAAC,OAAO,CAAC;IA4BnB;;;;;;OAMG;IACG,qBAAqB,CAAC,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM;IAQ5D;;;;;;;;OAQG;IACG,MAAM,CACV,OAAO,EAAE,MAAM,EACf,OAAO,EAAE,MAAM,EACf,WAAW,CAAC,EAAE,WAAW,EACzB,SAAS,CAAC,EAAE,aAAa;IAwB3B;;;;;OAKG;IACH,SAAS,CAAC,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM;IAc1C;;;;;OAKG;IACH,kBAAkB,CAAC,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM;IAcnD;;OAEG;IACH,gBAAgB;IAIhB;;;;;;;;;;OAUG;IACG,sCAAsC,CAC1C,GAAG,EAAE,GAAG,EACR,KAAK,EAAE,OAAO,EACd,EAAE,WAAW,EAAE,OAAO,EAAE;;;KAGvB;IAyCH;;;OAGG;IACG,oCAAoC;IAe1C;;;;;;OAMG;IACH,uBAAuB,CAAC,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,EAAE,QAAQ,EAAE,OAAO;IAuB3E;;;;;;;;OAQG;IACH,0BAA0B,CACxB,OAAO,EAAE,MAAM,EACf,OAAO,EAAE,MAAM,EACf,eAAe,EAAE,MAAM,EACvB,OAAO,EAAE,GAAG,GACX;QAAE,GAAG,EAAE,GAAG,CAAC;QAAC,KAAK,EAAE,MAAM,CAAA;KAAE,GAAG,IAAI;IAiBrC;;;;;;;OAOG;IACH,SAAS,CACP,GAAG,EAAE,GAAG,EACR,OAAO,EAAE,OAAO,CAAC,GAAG,CAAC,EACrB,eAAe,EAAE,MAAM,EACvB,OAAO,EAAE,GAAG;IA6Bd;;;;;;;OAOG;IACH,wCAAwC,CACtC,aAAa,EAAE,MAAM,EACrB,eAAe,EAAE,MAAM,EACvB,OAAO,EAAE,GAAG,GACX,OAAO;CAwBX;AAED,eAAe,aAAa,CAAC"}
\ No newline at end of file
+{"version":3,"file":"NftController.d.ts","sourceRoot":"","sources":["../src/NftController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/NftController.js b/node_modules/@metamask/assets-controllers/dist/NftController.js
index 5f414e4..0d0ed41 100644
--- a/node_modules/@metamask/assets-controllers/dist/NftController.js
+++ b/node_modules/@metamask/assets-controllers/dist/NftController.js
@@ -9,13 +9,17 @@ var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, ge
     });
 };
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.NftController = void 0;
+exports.NftController = exports.OpenSeaV2ChainIds = void 0;
 const events_1 = require("events");
 const ethereumjs_util_1 = require("ethereumjs-util");
 const async_mutex_1 = require("async-mutex");
 const base_controller_1 = require("@metamask/base-controller");
 const controller_utils_1 = require("@metamask/controller-utils");
 const assetsUtil_1 = require("./assetsUtil");
+var OpenSeaV2ChainIds;
+(function (OpenSeaV2ChainIds) {
+    OpenSeaV2ChainIds["ethereum"] = "ethereum";
+})(OpenSeaV2ChainIds = exports.OpenSeaV2ChainIds || (exports.OpenSeaV2ChainIds = {}));
 const ALL_NFTS_STATE_KEY = 'allNfts';
 const ALL_NFTS_CONTRACTS_STATE_KEY = 'allNftContracts';
 /**
@@ -55,8 +59,9 @@ class NftController extends base_controller_1.BaseController {
             selectedAddress: '',
             chainId: initialChainId,
             ipfsGateway: controller_utils_1.IPFS_DEFAULT_GATEWAY_URL,
-            openSeaEnabled: false,
+            displayNftMedia: true,
             useIPFSSubdomains: true,
+            isIpfsGatewayEnabled: true,
         };
         this.defaultState = {
             allNftContracts: {},
@@ -71,23 +76,27 @@ class NftController extends base_controller_1.BaseController {
         this.getERC1155BalanceOf = getERC1155BalanceOf;
         this.getERC1155TokenURI = getERC1155TokenURI;
         this.onNftAdded = onNftAdded;
-        onPreferencesStateChange(({ selectedAddress, ipfsGateway, openSeaEnabled }) => {
-            this.configure({ selectedAddress, ipfsGateway, openSeaEnabled });
+        onPreferencesStateChange(({ selectedAddress, ipfsGateway, displayNftMedia, isIpfsGatewayEnabled, }) => {
+            this.configure({
+                selectedAddress,
+                ipfsGateway,
+                displayNftMedia,
+                isIpfsGatewayEnabled,
+            });
         });
         onNetworkStateChange(({ providerConfig }) => {
             const { chainId } = providerConfig;
             this.configure({ chainId });
         });
     }
-    getNftApi({ contractAddress, tokenId, useProxy, }) {
-        return useProxy
-            ? `${controller_utils_1.OPENSEA_PROXY_URL}/asset/${contractAddress}/${tokenId}`
-            : `${controller_utils_1.OPENSEA_API_URL}/asset/${contractAddress}/${tokenId}`;
+    getNftApi({ contractAddress, tokenId, }) {
+        return `${controller_utils_1.OPENSEA_PROXY_URL}/chain/${OpenSeaV2ChainIds.ethereum}/contract/${contractAddress}/nfts/${tokenId}`;
+    }
+    getNftContractInformationApi({ contractAddress, }) {
+        return `${controller_utils_1.OPENSEA_PROXY_URL}/chain/${OpenSeaV2ChainIds.ethereum}/contract/${contractAddress}`;
     }
-    getNftContractInformationApi({ contractAddress, useProxy, }) {
-        return useProxy
-            ? `${controller_utils_1.OPENSEA_PROXY_URL}/asset_contract/${contractAddress}`
-            : `${controller_utils_1.OPENSEA_API_URL}/asset_contract/${contractAddress}`;
+    getNftCollectionInformationApi({ collectionSlug, }) {
+        return `${controller_utils_1.OPENSEA_PROXY_URL}/collections/${collectionSlug}`;
     }
     /**
      * Helper method to update nested state for allNfts and allNftContracts.
@@ -119,46 +128,41 @@ class NftController extends base_controller_1.BaseController {
      */
     getNftInformationFromApi(contractAddress, tokenId) {
         return __awaiter(this, void 0, void 0, function* () {
-            // Attempt to fetch the data with the proxy
-            let nftInformation = yield (0, controller_utils_1.fetchWithErrorHandling)({
-                url: this.getNftApi({
-                    contractAddress,
-                    tokenId,
-                    useProxy: true,
-                }),
-            });
-            // if an openSeaApiKey is set we should attempt to refetch calling directly to OpenSea
-            if (!nftInformation && this.openSeaApiKey) {
-                nftInformation = yield (0, controller_utils_1.fetchWithErrorHandling)({
+            try {
+                // Attempt to fetch the data with the proxy
+                const nftInformation = yield (0, controller_utils_1.fetchWithErrorHandling)({
                     url: this.getNftApi({
                         contractAddress,
                         tokenId,
-                        useProxy: false,
                     }),
-                    options: {
-                        headers: { 'X-API-KEY': this.openSeaApiKey },
-                    },
-                    // catch 403 errors (in case API key is down we don't want to blow up)
-                    errorCodesToCatch: [403],
                 });
+                // if we were still unable to fetch the data we return out the default/null of `NftMetadata`
+                if (!(nftInformation === null || nftInformation === void 0 ? void 0 : nftInformation.nft)) {
+                    return {
+                        name: null,
+                        description: null,
+                        image: null,
+                        standard: null,
+                    };
+                }
+                // if we've reached this point, we have successfully fetched some data for nftInformation
+                // now we reconfigure the data to conform to the `NftMetadata` type for storage.
+                const { num_sales, background_color, image_url, image_preview_url, image_thumbnail_url, image_original_url, animation_url, animation_original_url, name, description, external_link, creator, last_sale, asset_contract: { schema_name }, } = (0, assetsUtil_1.mapOpenSeaDetailedNftV2ToV1)(nftInformation.nft);
+                /* istanbul ignore next */
+                const nftMetadata = Object.assign({}, { name: name || null }, { description: description || null }, { image: image_url || null }, creator && { creator }, num_sales && { numberOfSales: num_sales }, background_color && { backgroundColor: background_color }, image_preview_url && { imagePreview: image_preview_url }, image_thumbnail_url && { imageThumbnail: image_thumbnail_url }, image_original_url && { imageOriginal: image_original_url }, animation_url && { animation: animation_url }, animation_original_url && {
+                    animationOriginal: animation_original_url,
+                }, external_link && { externalLink: external_link }, last_sale && { lastSale: last_sale }, schema_name && { standard: schema_name });
+                return nftMetadata;
             }
-            // if we were still unable to fetch the data we return out the default/null of `NftMetadata`
-            if (!nftInformation) {
+            catch (error) {
                 return {
                     name: null,
                     description: null,
                     image: null,
                     standard: null,
+                    error: 'Opensea import error',
                 };
             }
-            // if we've reached this point, we have successfully fetched some data for nftInformation
-            // now we reconfigure the data to conform to the `NftMetadata` type for storage.
-            const { num_sales, background_color, image_url, image_preview_url, image_thumbnail_url, image_original_url, animation_url, animation_original_url, name, description, external_link, creator, last_sale, asset_contract: { schema_name }, } = nftInformation;
-            /* istanbul ignore next */
-            const nftMetadata = Object.assign({}, { name: name || null }, { description: description || null }, { image: image_url || null }, creator && { creator }, num_sales && { numberOfSales: num_sales }, background_color && { backgroundColor: background_color }, image_preview_url && { imagePreview: image_preview_url }, image_thumbnail_url && { imageThumbnail: image_thumbnail_url }, image_original_url && { imageOriginal: image_original_url }, animation_url && { animation: animation_url }, animation_original_url && {
-                animationOriginal: animation_original_url,
-            }, external_link && { externalLink: external_link }, last_sale && { lastSale: last_sale }, schema_name && { standard: schema_name });
-            return nftMetadata;
         });
     }
     /**
@@ -170,13 +174,44 @@ class NftController extends base_controller_1.BaseController {
      */
     getNftInformationFromTokenURI(contractAddress, tokenId) {
         return __awaiter(this, void 0, void 0, function* () {
-            const { ipfsGateway, useIPFSSubdomains } = this.config;
+            const { ipfsGateway, useIPFSSubdomains, isIpfsGatewayEnabled, displayNftMedia, } = this.config;
             const result = yield this.getNftURIAndStandard(contractAddress, tokenId);
             let tokenURI = result[0];
             const standard = result[1];
-            if (tokenURI.startsWith('ipfs://')) {
+            if (!displayNftMedia && !isIpfsGatewayEnabled) {
+                return {
+                    image: null,
+                    name: null,
+                    description: null,
+                    standard: standard || null,
+                    favorite: false,
+                    tokenURI,
+                };
+            }
+            const hasIpfsTokenURI = tokenURI.startsWith('ipfs://');
+            if (hasIpfsTokenURI && !isIpfsGatewayEnabled) {
+                return {
+                    image: null,
+                    name: null,
+                    description: null,
+                    standard: standard || null,
+                    favorite: false,
+                    tokenURI: tokenURI !== null && tokenURI !== void 0 ? tokenURI : null,
+                };
+            }
+            if (hasIpfsTokenURI) {
                 tokenURI = (0, assetsUtil_1.getFormattedIpfsUrl)(ipfsGateway, tokenURI, useIPFSSubdomains);
             }
+            if (!hasIpfsTokenURI && !displayNftMedia) {
+                return {
+                    image: null,
+                    name: null,
+                    description: null,
+                    standard: standard || null,
+                    favorite: false,
+                    tokenURI: tokenURI !== null && tokenURI !== void 0 ? tokenURI : null,
+                };
+            }
             try {
                 const object = yield (0, controller_utils_1.handleFetch)(tokenURI);
                 // TODO: Check image_url existence. This is not part of EIP721 nor EIP1155
@@ -189,6 +224,7 @@ class NftController extends base_controller_1.BaseController {
                     description: object.description,
                     standard,
                     favorite: false,
+                    tokenURI,
                 };
             }
             catch (_a) {
@@ -198,6 +234,8 @@ class NftController extends base_controller_1.BaseController {
                     description: null,
                     standard: standard || null,
                     favorite: false,
+                    tokenURI: tokenURI !== null && tokenURI !== void 0 ? tokenURI : null,
+                    error: 'URI import error',
                 };
             }
         });
@@ -249,18 +287,29 @@ class NftController extends base_controller_1.BaseController {
      * @returns Promise resolving to the current NFT name and image.
      */
     getNftInformation(contractAddress, tokenId) {
-        var _a, _b, _c, _d, _e, _f, _g, _h;
+        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
         return __awaiter(this, void 0, void 0, function* () {
             const blockchainMetadata = yield (0, controller_utils_1.safelyExecute)(() => __awaiter(this, void 0, void 0, function* () {
                 return yield this.getNftInformationFromTokenURI(contractAddress, tokenId);
             }));
             let openSeaMetadata;
-            if (this.config.openSeaEnabled) {
+            if (this.config.displayNftMedia) {
                 openSeaMetadata = yield (0, controller_utils_1.safelyExecute)(() => __awaiter(this, void 0, void 0, function* () {
                     return yield this.getNftInformationFromApi(contractAddress, tokenId);
                 }));
             }
-            return Object.assign(Object.assign({}, openSeaMetadata), { name: (_b = (_a = blockchainMetadata.name) !== null && _a !== void 0 ? _a : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.name) !== null && _b !== void 0 ? _b : null, description: (_d = (_c = blockchainMetadata.description) !== null && _c !== void 0 ? _c : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.description) !== null && _d !== void 0 ? _d : null, image: (_f = (_e = blockchainMetadata.image) !== null && _e !== void 0 ? _e : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.image) !== null && _f !== void 0 ? _f : null, standard: (_h = (_g = blockchainMetadata.standard) !== null && _g !== void 0 ? _g : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.standard) !== null && _h !== void 0 ? _h : null });
+            if (blockchainMetadata.error && openSeaMetadata.error) {
+                return {
+                    image: null,
+                    name: null,
+                    description: null,
+                    standard: (_a = blockchainMetadata.standard) !== null && _a !== void 0 ? _a : null,
+                    favorite: false,
+                    tokenURI: (_b = blockchainMetadata.tokenURI) !== null && _b !== void 0 ? _b : null,
+                    error: 'Both import failed',
+                };
+            }
+            return Object.assign(Object.assign({}, openSeaMetadata), { tokenURI: (_d = (_c = blockchainMetadata.tokenURI) !== null && _c !== void 0 ? _c : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.tokenURI) !== null && _d !== void 0 ? _d : null, name: (_f = (_e = blockchainMetadata.name) !== null && _e !== void 0 ? _e : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.name) !== null && _f !== void 0 ? _f : null, description: (_h = (_g = blockchainMetadata.description) !== null && _g !== void 0 ? _g : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.description) !== null && _h !== void 0 ? _h : null, image: (_k = (_j = blockchainMetadata.image) !== null && _j !== void 0 ? _j : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.image) !== null && _k !== void 0 ? _k : null, standard: (_m = (_l = blockchainMetadata.standard) !== null && _l !== void 0 ? _l : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.standard) !== null && _m !== void 0 ? _m : null });
         });
     }
     /**
@@ -272,32 +321,22 @@ class NftController extends base_controller_1.BaseController {
     getNftContractInformationFromApi(contractAddress) {
         return __awaiter(this, void 0, void 0, function* () {
             /* istanbul ignore if */
-            let apiNftContractObject = yield (0, controller_utils_1.fetchWithErrorHandling)({
+            const apiNftContractObject = yield (0, controller_utils_1.fetchWithErrorHandling)({
                 url: this.getNftContractInformationApi({
                     contractAddress,
-                    useProxy: true,
                 }),
             });
             // if we successfully fetched return the fetched data immediately
             if (apiNftContractObject) {
-                return apiNftContractObject;
-            }
-            // if we were unsuccessful in fetching from the API and an OpenSea API key is present
-            // attempt to refetch directly against the OpenSea API and if successful return the data immediately
-            if (this.openSeaApiKey) {
-                apiNftContractObject = yield (0, controller_utils_1.fetchWithErrorHandling)({
-                    url: this.getNftContractInformationApi({
-                        contractAddress,
-                        useProxy: false,
-                    }),
-                    options: {
-                        headers: { 'X-API-KEY': this.openSeaApiKey },
-                    },
-                    // catch 403 errors (in case API key is down we don't want to blow up)
-                    errorCodesToCatch: [403],
-                });
+                // If we successfully fetched the contract
                 if (apiNftContractObject) {
-                    return apiNftContractObject;
+                    // Then fetch some additional details from the collection
+                    const collection = yield (0, controller_utils_1.fetchWithErrorHandling)({
+                        url: this.getNftCollectionInformationApi({
+                            collectionSlug: apiNftContractObject.collection,
+                        }),
+                    });
+                    return (0, assetsUtil_1.mapOpenSeaContractV2ToV1)(apiNftContractObject, collection);
                 }
             }
             // If we've reached this point we were unable to fetch data from either the proxy or opensea so we return
@@ -347,7 +386,7 @@ class NftController extends base_controller_1.BaseController {
                 return yield this.getNftContractInformationFromContract(contractAddress);
             }));
             let openSeaContractData;
-            if (this.config.openSeaEnabled) {
+            if (this.config.displayNftMedia) {
                 openSeaContractData = yield (0, controller_utils_1.safelyExecute)(() => __awaiter(this, void 0, void 0, function* () {
                     return yield this.getNftContractInformationFromApi(contractAddress);
                 }));
@@ -428,6 +467,7 @@ class NftController extends base_controller_1.BaseController {
                         tokenId: tokenId.toString(),
                         standard: nftMetadata.standard,
                         source: detection ? 'detected' : 'custom',
+                        tokenURI: nftMetadata.tokenURI,
                     });
                 }
                 return newNfts;
diff --git a/node_modules/@metamask/assets-controllers/dist/NftController.js.map b/node_modules/@metamask/assets-controllers/dist/NftController.js.map
index bf63a07..5e7e6e1 100644
--- a/node_modules/@metamask/assets-controllers/dist/NftController.js.map
+++ b/node_modules/@metamask/assets-controllers/dist/NftController.js.map
@@ -1 +1 @@
-{"version":3,"file":"NftController.js","sourceRoot":"","sources":["../src/NftController.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from 'events';\nimport { BN, stripHexPrefix } from 'ethereumjs-util';\nimport { Mutex } from 'async-mutex';\nimport type { Hex } from '@metamask/utils';\nimport {\n  BaseController,\n  BaseConfig,\n  BaseState,\n} from '@metamask/base-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport type { NetworkState } from '@metamask/network-controller';\nimport {\n  safelyExecute,\n  handleFetch,\n  toChecksumHexAddress,\n  BNToHex,\n  fetchWithErrorHandling,\n  IPFS_DEFAULT_GATEWAY_URL,\n  ERC721,\n  ERC1155,\n  OPENSEA_API_URL,\n  OPENSEA_PROXY_URL,\n} from '@metamask/controller-utils';\nimport type {\n  ApiNft,\n  ApiNftCreator,\n  ApiNftContract,\n  ApiNftLastSale,\n} from './NftDetectionController';\nimport type { AssetsContractController } from './AssetsContractController';\nimport { compareNftMetadata, getFormattedIpfsUrl } from './assetsUtil';\n\n/**\n * @type Nft\n *\n * NFT representation\n * @property address - Hex address of a ERC721 contract\n * @property description - The NFT description\n * @property image - URI of custom NFT image associated with this tokenId\n * @property name - Name associated with this tokenId and contract address\n * @property tokenId - The NFT identifier\n * @property numberOfSales - Number of sales\n * @property backgroundColor - The background color to be displayed with the item\n * @property imagePreview - URI of a smaller image associated with this NFT\n * @property imageThumbnail - URI of a thumbnail image associated with this NFT\n * @property imageOriginal - URI of the original image associated with this NFT\n * @property animation - URI of a animation associated with this NFT\n * @property animationOriginal - URI of the original animation associated with this NFT\n * @property externalLink - External link containing additional information\n * @property creator - The NFT owner information object\n * @property isCurrentlyOwned - Boolean indicating whether the address/chainId combination where it's currently stored currently owns this NFT\n * @property transactionId - Transaction Id associated with the NFT\n */\nexport interface Nft extends NftMetadata {\n  tokenId: string;\n  address: string;\n  isCurrentlyOwned?: boolean;\n}\n\n/**\n * @type NftContract\n *\n * NFT contract information representation\n * @property name - Contract name\n * @property logo - Contract logo\n * @property address - Contract address\n * @property symbol - Contract symbol\n * @property description - Contract description\n * @property totalSupply - Total supply of NFTs\n * @property assetContractType - The NFT type, it could be `semi-fungible` or `non-fungible`\n * @property createdDate - Creation date\n * @property schemaName - The schema followed by the contract, it could be `ERC721` or `ERC1155`\n * @property externalLink - External link containing additional information\n */\nexport interface NftContract {\n  name?: string;\n  logo?: string;\n  address: string;\n  symbol?: string;\n  description?: string;\n  totalSupply?: string;\n  assetContractType?: string;\n  createdDate?: string;\n  schemaName?: string;\n  externalLink?: string;\n}\n\n/**\n * @type NftMetadata\n *\n * NFT custom information\n * @property name - NFT custom name\n * @property description - The NFT description\n * @property numberOfSales - Number of sales\n * @property backgroundColor - The background color to be displayed with the item\n * @property image - Image custom image URI\n * @property imagePreview - URI of a smaller image associated with this NFT\n * @property imageThumbnail - URI of a thumbnail image associated with this NFT\n * @property imageOriginal - URI of the original image associated with this NFT\n * @property animation - URI of a animation associated with this NFT\n * @property animationOriginal - URI of the original animation associated with this NFT\n * @property externalLink - External link containing additional information\n * @property creator - The NFT owner information object\n * @property standard - NFT standard name for the NFT, e.g., ERC-721 or ERC-1155\n */\nexport interface NftMetadata {\n  name: string | null;\n  description: string | null;\n  image: string | null;\n  standard: string | null;\n  favorite?: boolean;\n  numberOfSales?: number;\n  backgroundColor?: string;\n  imagePreview?: string;\n  imageThumbnail?: string;\n  imageOriginal?: string;\n  animation?: string;\n  animationOriginal?: string;\n  externalLink?: string;\n  creator?: ApiNftCreator;\n  lastSale?: ApiNftLastSale;\n  transactionId?: string;\n}\n\ninterface AccountParams {\n  userAddress: string;\n  chainId: Hex;\n}\n\n/**\n * @type NftConfig\n *\n * NFT controller configuration\n * @property selectedAddress - Vault selected address\n */\nexport interface NftConfig extends BaseConfig {\n  selectedAddress: string;\n  chainId: Hex;\n  ipfsGateway: string;\n  openSeaEnabled: boolean;\n  useIPFSSubdomains: boolean;\n}\n\n/**\n * @type NftState\n *\n * NFT controller state\n * @property allNftContracts - Object containing NFT contract information\n * @property allNfts - Object containing NFTs per account and network\n * @property ignoredNfts - List of NFTs that should be ignored\n */\nexport interface NftState extends BaseState {\n  allNftContracts: {\n    [key: string]: { [chainId: Hex]: NftContract[] };\n  };\n  allNfts: { [key: string]: { [chainId: Hex]: Nft[] } };\n  ignoredNfts: Nft[];\n}\n\nconst ALL_NFTS_STATE_KEY = 'allNfts';\nconst ALL_NFTS_CONTRACTS_STATE_KEY = 'allNftContracts';\n\n/**\n * Controller that stores assets and exposes convenience methods\n */\nexport class NftController extends BaseController<NftConfig, NftState> {\n  private mutex = new Mutex();\n\n  private getNftApi({\n    contractAddress,\n    tokenId,\n    useProxy,\n  }: {\n    contractAddress: string;\n    tokenId: string;\n    useProxy: boolean;\n  }) {\n    return useProxy\n      ? `${OPENSEA_PROXY_URL}/asset/${contractAddress}/${tokenId}`\n      : `${OPENSEA_API_URL}/asset/${contractAddress}/${tokenId}`;\n  }\n\n  private getNftContractInformationApi({\n    contractAddress,\n    useProxy,\n  }: {\n    contractAddress: string;\n    useProxy: boolean;\n  }) {\n    return useProxy\n      ? `${OPENSEA_PROXY_URL}/asset_contract/${contractAddress}`\n      : `${OPENSEA_API_URL}/asset_contract/${contractAddress}`;\n  }\n\n  /**\n   * Helper method to update nested state for allNfts and allNftContracts.\n   *\n   * @param newCollection - the modified piece of state to update in the controller's store\n   * @param baseStateKey - The root key in the store to update.\n   * @param passedConfig - An object containing the selectedAddress and chainId that are passed through the auto-detection flow.\n   * @param passedConfig.userAddress - the address passed through the NFT detection flow to ensure detected assets are stored to the correct account\n   * @param passedConfig.chainId - the chainId passed through the NFT detection flow to ensure detected assets are stored to the correct account\n   */\n  private updateNestedNftState(\n    newCollection: Nft[] | NftContract[],\n    baseStateKey: 'allNfts' | 'allNftContracts',\n    { userAddress, chainId } = {\n      userAddress: this.config.selectedAddress,\n      chainId: this.config.chainId,\n    },\n  ) {\n    const { [baseStateKey]: oldState } = this.state;\n\n    const addressState = oldState[userAddress];\n    const newAddressState = {\n      ...addressState,\n      ...{ [chainId]: newCollection },\n    };\n    const newState = {\n      ...oldState,\n      ...{ [userAddress]: newAddressState },\n    };\n\n    this.update({\n      [baseStateKey]: newState,\n    });\n  }\n\n  /**\n   * Request individual NFT information from OpenSea API.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftInformationFromApi(\n    contractAddress: string,\n    tokenId: string,\n  ): Promise<NftMetadata> {\n    // Attempt to fetch the data with the proxy\n    let nftInformation: ApiNft | undefined = await fetchWithErrorHandling({\n      url: this.getNftApi({\n        contractAddress,\n        tokenId,\n        useProxy: true,\n      }),\n    });\n\n    // if an openSeaApiKey is set we should attempt to refetch calling directly to OpenSea\n    if (!nftInformation && this.openSeaApiKey) {\n      nftInformation = await fetchWithErrorHandling({\n        url: this.getNftApi({\n          contractAddress,\n          tokenId,\n          useProxy: false,\n        }),\n        options: {\n          headers: { 'X-API-KEY': this.openSeaApiKey },\n        },\n        // catch 403 errors (in case API key is down we don't want to blow up)\n        errorCodesToCatch: [403],\n      });\n    }\n\n    // if we were still unable to fetch the data we return out the default/null of `NftMetadata`\n    if (!nftInformation) {\n      return {\n        name: null,\n        description: null,\n        image: null,\n        standard: null,\n      };\n    }\n\n    // if we've reached this point, we have successfully fetched some data for nftInformation\n    // now we reconfigure the data to conform to the `NftMetadata` type for storage.\n    const {\n      num_sales,\n      background_color,\n      image_url,\n      image_preview_url,\n      image_thumbnail_url,\n      image_original_url,\n      animation_url,\n      animation_original_url,\n      name,\n      description,\n      external_link,\n      creator,\n      last_sale,\n      asset_contract: { schema_name },\n    } = nftInformation;\n\n    /* istanbul ignore next */\n    const nftMetadata: NftMetadata = Object.assign(\n      {},\n      { name: name || null },\n      { description: description || null },\n      { image: image_url || null },\n      creator && { creator },\n      num_sales && { numberOfSales: num_sales },\n      background_color && { backgroundColor: background_color },\n      image_preview_url && { imagePreview: image_preview_url },\n      image_thumbnail_url && { imageThumbnail: image_thumbnail_url },\n      image_original_url && { imageOriginal: image_original_url },\n      animation_url && { animation: animation_url },\n      animation_original_url && {\n        animationOriginal: animation_original_url,\n      },\n      external_link && { externalLink: external_link },\n      last_sale && { lastSale: last_sale },\n      schema_name && { standard: schema_name },\n    );\n\n    return nftMetadata;\n  }\n\n  /**\n   * Request individual NFT information from contracts that follows Metadata Interface.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftInformationFromTokenURI(\n    contractAddress: string,\n    tokenId: string,\n  ): Promise<NftMetadata> {\n    const { ipfsGateway, useIPFSSubdomains } = this.config;\n    const result = await this.getNftURIAndStandard(contractAddress, tokenId);\n    let tokenURI = result[0];\n    const standard = result[1];\n\n    if (tokenURI.startsWith('ipfs://')) {\n      tokenURI = getFormattedIpfsUrl(ipfsGateway, tokenURI, useIPFSSubdomains);\n    }\n\n    try {\n      const object = await handleFetch(tokenURI);\n      // TODO: Check image_url existence. This is not part of EIP721 nor EIP1155\n      const image = Object.prototype.hasOwnProperty.call(object, 'image')\n        ? 'image'\n        : /* istanbul ignore next */ 'image_url';\n\n      return {\n        image: object[image],\n        name: object.name,\n        description: object.description,\n        standard,\n        favorite: false,\n      };\n    } catch {\n      return {\n        image: null,\n        name: null,\n        description: null,\n        standard: standard || null,\n        favorite: false,\n      };\n    }\n  }\n\n  /**\n   * Retrieve NFT uri with  metadata. TODO Update method to use IPFS.\n   *\n   * @param contractAddress - NFT contract address.\n   * @param tokenId - NFT token id.\n   * @returns Promise resolving NFT uri and token standard.\n   */\n  private async getNftURIAndStandard(\n    contractAddress: string,\n    tokenId: string,\n  ): Promise<[string, string]> {\n    // try ERC721 uri\n    try {\n      const uri = await this.getERC721TokenURI(contractAddress, tokenId);\n      return [uri, ERC721];\n    } catch {\n      // Ignore error\n    }\n\n    // try ERC1155 uri\n    try {\n      const tokenURI = await this.getERC1155TokenURI(contractAddress, tokenId);\n\n      /**\n       * According to EIP1155 the URI value allows for ID substitution\n       * in case the string `{id}` exists.\n       * https://eips.ethereum.org/EIPS/eip-1155#metadata\n       */\n\n      if (!tokenURI.includes('{id}')) {\n        return [tokenURI, ERC1155];\n      }\n\n      const hexTokenId = stripHexPrefix(BNToHex(new BN(tokenId)))\n        .padStart(64, '0')\n        .toLowerCase();\n      return [tokenURI.replace('{id}', hexTokenId), ERC1155];\n    } catch {\n      // Ignore error\n    }\n\n    return ['', ''];\n  }\n\n  /**\n   * Request individual NFT information (name, image url and description).\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftInformation(\n    contractAddress: string,\n    tokenId: string,\n  ): Promise<NftMetadata> {\n    const blockchainMetadata = await safelyExecute(async () => {\n      return await this.getNftInformationFromTokenURI(contractAddress, tokenId);\n    });\n\n    let openSeaMetadata;\n    if (this.config.openSeaEnabled) {\n      openSeaMetadata = await safelyExecute(async () => {\n        return await this.getNftInformationFromApi(contractAddress, tokenId);\n      });\n    }\n    return {\n      ...openSeaMetadata,\n      name: blockchainMetadata.name ?? openSeaMetadata?.name ?? null,\n      description:\n        blockchainMetadata.description ?? openSeaMetadata?.description ?? null,\n      image: blockchainMetadata.image ?? openSeaMetadata?.image ?? null,\n      standard:\n        blockchainMetadata.standard ?? openSeaMetadata?.standard ?? null,\n    };\n  }\n\n  /**\n   * Request NFT contract information from OpenSea API.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftContractInformationFromApi(\n    contractAddress: string,\n  ): Promise<ApiNftContract> {\n    /* istanbul ignore if */\n    let apiNftContractObject: ApiNftContract | undefined =\n      await fetchWithErrorHandling({\n        url: this.getNftContractInformationApi({\n          contractAddress,\n          useProxy: true,\n        }),\n      });\n\n    // if we successfully fetched return the fetched data immediately\n    if (apiNftContractObject) {\n      return apiNftContractObject;\n    }\n\n    // if we were unsuccessful in fetching from the API and an OpenSea API key is present\n    // attempt to refetch directly against the OpenSea API and if successful return the data immediately\n    if (this.openSeaApiKey) {\n      apiNftContractObject = await fetchWithErrorHandling({\n        url: this.getNftContractInformationApi({\n          contractAddress,\n          useProxy: false,\n        }),\n        options: {\n          headers: { 'X-API-KEY': this.openSeaApiKey },\n        },\n        // catch 403 errors (in case API key is down we don't want to blow up)\n        errorCodesToCatch: [403],\n      });\n\n      if (apiNftContractObject) {\n        return apiNftContractObject;\n      }\n    }\n\n    // If we've reached this point we were unable to fetch data from either the proxy or opensea so we return\n    // the default/null of ApiNftContract\n    return {\n      address: contractAddress,\n      asset_contract_type: null,\n      created_date: null,\n      schema_name: null,\n      symbol: null,\n      total_supply: null,\n      description: null,\n      external_link: null,\n      collection: {\n        name: null,\n        image_url: null,\n      },\n    };\n  }\n\n  /**\n   * Request NFT contract information from the contract itself.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftContractInformationFromContract(\n    contractAddress: string,\n  ): Promise<\n    Partial<ApiNftContract> &\n      Pick<ApiNftContract, 'address'> &\n      Pick<ApiNftContract, 'collection'>\n  > {\n    const name = await this.getERC721AssetName(contractAddress);\n    const symbol = await this.getERC721AssetSymbol(contractAddress);\n    return {\n      collection: { name },\n      symbol,\n      address: contractAddress,\n    };\n  }\n\n  /**\n   * Request NFT contract information from OpenSea API.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @returns Promise resolving to the NFT contract name, image and description.\n   */\n  private async getNftContractInformation(\n    contractAddress: string,\n  ): Promise<\n    Partial<ApiNftContract> &\n      Pick<ApiNftContract, 'address'> &\n      Pick<ApiNftContract, 'collection'>\n  > {\n    const blockchainContractData: Partial<ApiNftContract> &\n      Pick<ApiNftContract, 'address'> &\n      Pick<ApiNftContract, 'collection'> = await safelyExecute(async () => {\n      return await this.getNftContractInformationFromContract(contractAddress);\n    });\n\n    let openSeaContractData: Partial<ApiNftContract> | undefined;\n    if (this.config.openSeaEnabled) {\n      openSeaContractData = await safelyExecute(async () => {\n        return await this.getNftContractInformationFromApi(contractAddress);\n      });\n    }\n\n    if (blockchainContractData || openSeaContractData) {\n      return {\n        ...openSeaContractData,\n        ...blockchainContractData,\n        collection: {\n          image_url: null,\n          ...openSeaContractData?.collection,\n          ...blockchainContractData?.collection,\n        },\n      };\n    }\n\n    /* istanbul ignore next */\n    return {\n      address: contractAddress,\n      asset_contract_type: null,\n      created_date: null,\n      schema_name: null,\n      symbol: null,\n      total_supply: null,\n      description: null,\n      external_link: null,\n      collection: { name: null, image_url: null },\n    };\n  }\n\n  /**\n   * Adds an individual NFT to the stored NFT list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param nftMetadata - NFT optional information (name, image and description).\n   * @param nftContract - An object containing contract data of the NFT being added.\n   * @param detection - The chain ID and address of the currently selected network and account at the moment the NFT was detected.\n   * @returns Promise resolving to the current NFT list.\n   */\n  private async addIndividualNft(\n    address: string,\n    tokenId: string,\n    nftMetadata: NftMetadata,\n    nftContract: NftContract,\n    detection?: AccountParams,\n  ): Promise<Nft[]> {\n    // TODO: Remove unused return\n    const releaseLock = await this.mutex.acquire();\n    try {\n      address = toChecksumHexAddress(address);\n      const { allNfts } = this.state;\n      let chainId, selectedAddress;\n\n      if (detection) {\n        chainId = detection.chainId;\n        selectedAddress = detection.userAddress;\n      } else {\n        chainId = this.config.chainId;\n        selectedAddress = this.config.selectedAddress;\n      }\n\n      const nfts = allNfts[selectedAddress]?.[chainId] || [];\n\n      const existingEntry: Nft | undefined = nfts.find(\n        (nft) =>\n          nft.address.toLowerCase() === address.toLowerCase() &&\n          nft.tokenId === tokenId,\n      );\n\n      if (existingEntry) {\n        const differentMetadata = compareNftMetadata(\n          nftMetadata,\n          existingEntry,\n        );\n        if (differentMetadata || !existingEntry.isCurrentlyOwned) {\n          // TODO: Switch to indexToUpdate\n          const indexToRemove = nfts.findIndex(\n            (nft) =>\n              nft.address.toLowerCase() === address.toLowerCase() &&\n              nft.tokenId === tokenId,\n          );\n          /* istanbul ignore next */\n          if (indexToRemove !== -1) {\n            nfts.splice(indexToRemove, 1);\n          }\n        } else {\n          return nfts;\n        }\n      }\n\n      const newEntry: Nft = {\n        address,\n        tokenId,\n        favorite: existingEntry?.favorite || false,\n        isCurrentlyOwned: true,\n        ...nftMetadata,\n      };\n\n      const newNfts = [...nfts, newEntry];\n      this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n        chainId,\n        userAddress: selectedAddress,\n      });\n\n      if (this.onNftAdded) {\n        this.onNftAdded({\n          address,\n          symbol: nftContract.symbol,\n          tokenId: tokenId.toString(),\n          standard: nftMetadata.standard,\n          source: detection ? 'detected' : 'custom',\n        });\n      }\n\n      return newNfts;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Adds an NFT contract to the stored NFT contracts list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param detection - The chain ID and address of the currently selected network and account at the moment the NFT was detected.\n   * @returns Promise resolving to the current NFT contracts list.\n   */\n  private async addNftContract(\n    address: string,\n    detection?: AccountParams,\n  ): Promise<NftContract[]> {\n    const releaseLock = await this.mutex.acquire();\n    try {\n      address = toChecksumHexAddress(address);\n      const { allNftContracts } = this.state;\n\n      let chainId, selectedAddress;\n      if (detection) {\n        chainId = detection.chainId;\n        selectedAddress = detection.userAddress;\n      } else {\n        chainId = this.config.chainId;\n        selectedAddress = this.config.selectedAddress;\n      }\n\n      const nftContracts = allNftContracts[selectedAddress]?.[chainId] || [];\n\n      const existingEntry = nftContracts.find(\n        (nftContract) =>\n          nftContract.address.toLowerCase() === address.toLowerCase(),\n      );\n      if (existingEntry) {\n        return nftContracts;\n      }\n      const contractInformation = await this.getNftContractInformation(address);\n\n      const {\n        asset_contract_type,\n        created_date,\n        schema_name,\n        symbol,\n        total_supply,\n        description,\n        external_link,\n        collection: { name, image_url },\n      } = contractInformation;\n      // If being auto-detected opensea information is expected\n      // Otherwise at least name from the contract is needed\n      if (\n        (detection && !name) ||\n        Object.keys(contractInformation).length === 0\n      ) {\n        return nftContracts;\n      }\n\n      /* istanbul ignore next */\n      const newEntry: NftContract = Object.assign(\n        {},\n        { address },\n        description && { description },\n        name && { name },\n        image_url && { logo: image_url },\n        symbol && { symbol },\n        total_supply !== null &&\n          typeof total_supply !== 'undefined' && { totalSupply: total_supply },\n        asset_contract_type && { assetContractType: asset_contract_type },\n        created_date && { createdDate: created_date },\n        schema_name && { schemaName: schema_name },\n        external_link && { externalLink: external_link },\n      );\n      const newNftContracts = [...nftContracts, newEntry];\n      this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY, {\n        chainId,\n        userAddress: selectedAddress,\n      });\n\n      return newNftContracts;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Removes an individual NFT from the stored token list and saves it in ignored NFTs list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   */\n  private removeAndIgnoreIndividualNft(address: string, tokenId: string) {\n    address = toChecksumHexAddress(address);\n    const { allNfts, ignoredNfts } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const newIgnoredNfts = [...ignoredNfts];\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const newNfts = nfts.filter((nft) => {\n      if (\n        nft.address.toLowerCase() === address.toLowerCase() &&\n        nft.tokenId === tokenId\n      ) {\n        const alreadyIgnored = newIgnoredNfts.find(\n          (c) => c.address === address && c.tokenId === tokenId,\n        );\n        !alreadyIgnored && newIgnoredNfts.push(nft);\n        return false;\n      }\n      return true;\n    });\n\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY);\n\n    this.update({\n      ignoredNfts: newIgnoredNfts,\n    });\n  }\n\n  /**\n   * Removes an individual NFT from the stored token list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   */\n  private removeIndividualNft(address: string, tokenId: string) {\n    address = toChecksumHexAddress(address);\n    const { allNfts } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const newNfts = nfts.filter(\n      (nft) =>\n        !(\n          nft.address.toLowerCase() === address.toLowerCase() &&\n          nft.tokenId === tokenId\n        ),\n    );\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY);\n  }\n\n  /**\n   * Removes an NFT contract to the stored NFT contracts list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @returns Promise resolving to the current NFT contracts list.\n   */\n  private removeNftContract(address: string): NftContract[] {\n    address = toChecksumHexAddress(address);\n    const { allNftContracts } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const nftContracts = allNftContracts[selectedAddress]?.[chainId] || [];\n\n    const newNftContracts = nftContracts.filter(\n      (nftContract) =>\n        !(nftContract.address.toLowerCase() === address.toLowerCase()),\n    );\n    this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY);\n\n    return newNftContracts;\n  }\n\n  /**\n   * EventEmitter instance used to listen to specific EIP747 events\n   */\n  hub = new EventEmitter();\n\n  /**\n   * Optional API key to use with opensea\n   */\n  openSeaApiKey?: string;\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'NftController';\n\n  private getERC721AssetName: AssetsContractController['getERC721AssetName'];\n\n  private getERC721AssetSymbol: AssetsContractController['getERC721AssetSymbol'];\n\n  private getERC721TokenURI: AssetsContractController['getERC721TokenURI'];\n\n  private getERC721OwnerOf: AssetsContractController['getERC721OwnerOf'];\n\n  private getERC1155BalanceOf: AssetsContractController['getERC1155BalanceOf'];\n\n  private getERC1155TokenURI: AssetsContractController['getERC1155TokenURI'];\n\n  private onNftAdded?: (data: {\n    address: string;\n    symbol: string | undefined;\n    tokenId: string;\n    standard: string | null;\n    source: string;\n  }) => void;\n\n  /**\n   * Creates an NftController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param options.getERC721AssetName - Gets the name of the asset at the given address.\n   * @param options.getERC721AssetSymbol - Gets the symbol of the asset at the given address.\n   * @param options.getERC721TokenURI - Gets the URI of the ERC721 token at the given address, with the given ID.\n   * @param options.getERC721OwnerOf - Get the owner of a ERC-721 NFT.\n   * @param options.getERC1155BalanceOf - Gets balance of a ERC-1155 NFT.\n   * @param options.getERC1155TokenURI - Gets the URI of the ERC1155 token at the given address, with the given ID.\n   * @param options.onNftAdded - Callback that is called when an NFT is added. Currently used pass data\n   * for tracking the NFT added event.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      chainId: initialChainId,\n      onPreferencesStateChange,\n      onNetworkStateChange,\n      getERC721AssetName,\n      getERC721AssetSymbol,\n      getERC721TokenURI,\n      getERC721OwnerOf,\n      getERC1155BalanceOf,\n      getERC1155TokenURI,\n      onNftAdded,\n    }: {\n      chainId: Hex;\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      getERC721AssetName: AssetsContractController['getERC721AssetName'];\n      getERC721AssetSymbol: AssetsContractController['getERC721AssetSymbol'];\n      getERC721TokenURI: AssetsContractController['getERC721TokenURI'];\n      getERC721OwnerOf: AssetsContractController['getERC721OwnerOf'];\n      getERC1155BalanceOf: AssetsContractController['getERC1155BalanceOf'];\n      getERC1155TokenURI: AssetsContractController['getERC1155TokenURI'];\n      onNftAdded?: (data: {\n        address: string;\n        symbol: string | undefined;\n        tokenId: string;\n        standard: string | null;\n        source: string;\n      }) => void;\n    },\n    config?: Partial<BaseConfig>,\n    state?: Partial<NftState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      selectedAddress: '',\n      chainId: initialChainId,\n      ipfsGateway: IPFS_DEFAULT_GATEWAY_URL,\n      openSeaEnabled: false,\n      useIPFSSubdomains: true,\n    };\n\n    this.defaultState = {\n      allNftContracts: {},\n      allNfts: {},\n      ignoredNfts: [],\n    };\n    this.initialize();\n    this.getERC721AssetName = getERC721AssetName;\n    this.getERC721AssetSymbol = getERC721AssetSymbol;\n    this.getERC721TokenURI = getERC721TokenURI;\n    this.getERC721OwnerOf = getERC721OwnerOf;\n    this.getERC1155BalanceOf = getERC1155BalanceOf;\n    this.getERC1155TokenURI = getERC1155TokenURI;\n    this.onNftAdded = onNftAdded;\n\n    onPreferencesStateChange(\n      ({ selectedAddress, ipfsGateway, openSeaEnabled }) => {\n        this.configure({ selectedAddress, ipfsGateway, openSeaEnabled });\n      },\n    );\n\n    onNetworkStateChange(({ providerConfig }) => {\n      const { chainId } = providerConfig;\n      this.configure({ chainId });\n    });\n  }\n\n  /**\n   * Sets an OpenSea API key to retrieve NFT information.\n   *\n   * @param openSeaApiKey - OpenSea API key.\n   */\n  setApiKey(openSeaApiKey: string) {\n    this.openSeaApiKey = openSeaApiKey;\n  }\n\n  /**\n   * Checks the ownership of a ERC-721 or ERC-1155 NFT for a given address.\n   *\n   * @param ownerAddress - User public address.\n   * @param nftAddress - NFT contract address.\n   * @param nftId - NFT token ID.\n   * @returns Promise resolving the NFT ownership.\n   */\n  async isNftOwner(\n    ownerAddress: string,\n    nftAddress: string,\n    nftId: string,\n  ): Promise<boolean> {\n    // Checks the ownership for ERC-721.\n    try {\n      const owner = await this.getERC721OwnerOf(nftAddress, nftId);\n      return ownerAddress.toLowerCase() === owner.toLowerCase();\n      // eslint-disable-next-line no-empty\n    } catch {\n      // Ignore ERC-721 contract error\n    }\n\n    // Checks the ownership for ERC-1155.\n    try {\n      const balance = await this.getERC1155BalanceOf(\n        ownerAddress,\n        nftAddress,\n        nftId,\n      );\n      return !balance.isZero();\n      // eslint-disable-next-line no-empty\n    } catch {\n      // Ignore ERC-1155 contract error\n    }\n\n    throw new Error(\n      'Unable to verify ownership. Probably because the standard is not supported or the chain is incorrect.',\n    );\n  }\n\n  /**\n   * Verifies currently selected address owns entered NFT address/tokenId combo and\n   * adds the NFT and respective NFT contract to the stored NFT and NFT contracts lists.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   */\n  async addNftVerifyOwnership(address: string, tokenId: string) {\n    const { selectedAddress } = this.config;\n    if (!(await this.isNftOwner(selectedAddress, address, tokenId))) {\n      throw new Error('This NFT is not owned by the user');\n    }\n    await this.addNft(address, tokenId);\n  }\n\n  /**\n   * Adds an NFT and respective NFT contract to the stored NFT and NFT contracts lists.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param nftMetadata - NFT optional metadata.\n   * @param detection - The chain ID and address of the currently selected network and account at the moment the NFT was detected.\n   * @returns Promise resolving to the current NFT list.\n   */\n  async addNft(\n    address: string,\n    tokenId: string,\n    nftMetadata?: NftMetadata,\n    detection?: AccountParams,\n  ) {\n    address = toChecksumHexAddress(address);\n    const newNftContracts = await this.addNftContract(address, detection);\n    nftMetadata =\n      nftMetadata || (await this.getNftInformation(address, tokenId));\n\n    // If NFT contract was not added, do not add individual NFT\n    const nftContract = newNftContracts.find(\n      (contract) => contract.address.toLowerCase() === address.toLowerCase(),\n    );\n\n    // If NFT contract information, add individual NFT\n    if (nftContract) {\n      await this.addIndividualNft(\n        address,\n        tokenId,\n        nftMetadata,\n        nftContract,\n        detection,\n      );\n    }\n  }\n\n  /**\n   * Removes an NFT from the stored token list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   */\n  removeNft(address: string, tokenId: string) {\n    address = toChecksumHexAddress(address);\n    this.removeIndividualNft(address, tokenId);\n    const { allNfts } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const remainingNft = nfts.find(\n      (nft) => nft.address.toLowerCase() === address.toLowerCase(),\n    );\n    if (!remainingNft) {\n      this.removeNftContract(address);\n    }\n  }\n\n  /**\n   * Removes an NFT from the stored token list and saves it in ignored NFTs list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   */\n  removeAndIgnoreNft(address: string, tokenId: string) {\n    address = toChecksumHexAddress(address);\n    this.removeAndIgnoreIndividualNft(address, tokenId);\n    const { allNfts } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const remainingNft = nfts.find(\n      (nft) => nft.address.toLowerCase() === address.toLowerCase(),\n    );\n    if (!remainingNft) {\n      this.removeNftContract(address);\n    }\n  }\n\n  /**\n   * Removes all NFTs from the ignored list.\n   */\n  clearIgnoredNfts() {\n    this.update({ ignoredNfts: [] });\n  }\n\n  /**\n   * Checks whether input NFT is still owned by the user\n   * And updates the isCurrentlyOwned value on the NFT object accordingly.\n   *\n   * @param nft - The NFT object to check and update.\n   * @param batch - A boolean indicating whether this method is being called as part of a batch or single update.\n   * @param accountParams - The userAddress and chainId to check ownership against\n   * @param accountParams.userAddress - the address passed through the confirmed transaction flow to ensure detected assets are stored to the correct account\n   * @param accountParams.chainId - the chainId passed through the confirmed transaction flow to ensure detected assets are stored to the correct account\n   * @returns the NFT with the updated isCurrentlyOwned value\n   */\n  async checkAndUpdateSingleNftOwnershipStatus(\n    nft: Nft,\n    batch: boolean,\n    { userAddress, chainId } = {\n      userAddress: this.config.selectedAddress,\n      chainId: this.config.chainId,\n    },\n  ) {\n    const { address, tokenId } = nft;\n    let isOwned = nft.isCurrentlyOwned;\n    try {\n      isOwned = await this.isNftOwner(userAddress, address, tokenId);\n    } catch (error) {\n      if (\n        !(\n          error instanceof Error &&\n          error.message.includes('Unable to verify ownership')\n        )\n      ) {\n        throw error;\n      }\n    }\n\n    nft.isCurrentlyOwned = isOwned;\n\n    if (batch === true) {\n      return nft;\n    }\n\n    // if this is not part of a batched update we update this one NFT in state\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const nftToUpdate = nfts.find(\n      (item) =>\n        item.tokenId === tokenId &&\n        item.address.toLowerCase() === address.toLowerCase(),\n    );\n    if (nftToUpdate) {\n      nftToUpdate.isCurrentlyOwned = isOwned;\n      this.updateNestedNftState(nfts, ALL_NFTS_STATE_KEY, {\n        userAddress,\n        chainId,\n      });\n    }\n    return nft;\n  }\n\n  /**\n   * Checks whether NFTs associated with current selectedAddress/chainId combination are still owned by the user\n   * And updates the isCurrentlyOwned value on each accordingly.\n   */\n  async checkAndUpdateAllNftsOwnershipStatus() {\n    const { allNfts } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const updatedNfts = await Promise.all(\n      nfts.map(async (nft) => {\n        return (\n          (await this.checkAndUpdateSingleNftOwnershipStatus(nft, true)) ?? nft\n        );\n      }),\n    );\n\n    this.updateNestedNftState(updatedNfts, ALL_NFTS_STATE_KEY);\n  }\n\n  /**\n   * Update NFT favorite status.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Hex address of the NFT contract.\n   * @param favorite - NFT new favorite status.\n   */\n  updateNftFavoriteStatus(address: string, tokenId: string, favorite: boolean) {\n    const { allNfts } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const index: number = nfts.findIndex(\n      (nft) => nft.address === address && nft.tokenId === tokenId,\n    );\n\n    if (index === -1) {\n      return;\n    }\n\n    const updatedNft: Nft = {\n      ...nfts[index],\n      favorite,\n    };\n\n    // Update Nfts array\n    nfts[index] = updatedNft;\n\n    this.updateNestedNftState(nfts, ALL_NFTS_STATE_KEY);\n  }\n\n  /**\n   * Returns an NFT by the address and token id.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Number that represents the id of the token.\n   * @param selectedAddress - Hex address of the user account.\n   * @param chainId - Id of the current network.\n   * @returns Object containing the NFT and its position in the array\n   */\n  findNftByAddressAndTokenId(\n    address: string,\n    tokenId: string,\n    selectedAddress: string,\n    chainId: Hex,\n  ): { nft: Nft; index: number } | null {\n    const { allNfts } = this.state;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n\n    const index: number = nfts.findIndex(\n      (nft) =>\n        nft.address.toLowerCase() === address.toLowerCase() &&\n        nft.tokenId === tokenId,\n    );\n\n    if (index === -1) {\n      return null;\n    }\n\n    return { nft: nfts[index], index };\n  }\n\n  /**\n   * Update NFT data.\n   *\n   * @param nft - NFT object to find the right NFT to updates.\n   * @param updates - NFT partial object to update properties of the NFT.\n   * @param selectedAddress - Hex address of the user account.\n   * @param chainId - Id of the current network.\n   */\n  updateNft(\n    nft: Nft,\n    updates: Partial<Nft>,\n    selectedAddress: string,\n    chainId: Hex,\n  ) {\n    const { allNfts } = this.state;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const nftInfo = this.findNftByAddressAndTokenId(\n      nft.address,\n      nft.tokenId,\n      selectedAddress,\n      chainId,\n    );\n\n    if (!nftInfo) {\n      return;\n    }\n\n    const updatedNft: Nft = {\n      ...nft,\n      ...updates,\n    };\n\n    const newNfts = [\n      ...nfts.slice(0, nftInfo.index),\n      updatedNft,\n      ...nfts.slice(nftInfo.index + 1),\n    ];\n\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY);\n  }\n\n  /**\n   * Resets the transaction status of an NFT.\n   *\n   * @param transactionId - NFT transaction id.\n   * @param selectedAddress - Hex address of the user account.\n   * @param chainId - Id of the current network.\n   * @returns a boolean indicating if the reset was well succeded or not\n   */\n  resetNftTransactionStatusByTransactionId(\n    transactionId: string,\n    selectedAddress: string,\n    chainId: Hex,\n  ): boolean {\n    const { allNfts } = this.state;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const index: number = nfts.findIndex(\n      (nft) => nft.transactionId === transactionId,\n    );\n\n    if (index === -1) {\n      return false;\n    }\n    const updatedNft: Nft = {\n      ...nfts[index],\n      transactionId: undefined,\n    };\n\n    const newNfts = [\n      ...nfts.slice(0, index),\n      updatedNft,\n      ...nfts.slice(index + 1),\n    ];\n\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY);\n    return true;\n  }\n}\n\nexport default NftController;\n"]}
\ No newline at end of file
+{"version":3,"file":"NftController.js","sourceRoot":"","sources":["../src/NftController.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from 'events';\nimport { BN, stripHexPrefix } from 'ethereumjs-util';\nimport { Mutex } from 'async-mutex';\nimport type { Hex } from '@metamask/utils';\nimport {\n  BaseController,\n  BaseConfig,\n  BaseState,\n} from '@metamask/base-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport type { NetworkState } from '@metamask/network-controller';\nimport {\n  safelyExecute,\n  handleFetch,\n  toChecksumHexAddress,\n  BNToHex,\n  fetchWithErrorHandling,\n  IPFS_DEFAULT_GATEWAY_URL,\n  ERC721,\n  ERC1155,\n  OPENSEA_PROXY_URL,\n} from '@metamask/controller-utils';\nimport type {\n  ApiNftCreator,\n  ApiNftContract,\n  ApiNftLastSale,\n} from './NftDetectionController';\nimport type { AssetsContractController } from './AssetsContractController';\nimport {\n  compareNftMetadata,\n  getFormattedIpfsUrl,\n  mapOpenSeaContractV2ToV1,\n  mapOpenSeaDetailedNftV2ToV1,\n} from './assetsUtil';\n\n/**\n * @type Nft\n *\n * NFT representation\n * @property address - Hex address of a ERC721 contract\n * @property description - The NFT description\n * @property image - URI of custom NFT image associated with this tokenId\n * @property name - Name associated with this tokenId and contract address\n * @property tokenId - The NFT identifier\n * @property numberOfSales - Number of sales\n * @property backgroundColor - The background color to be displayed with the item\n * @property imagePreview - URI of a smaller image associated with this NFT\n * @property imageThumbnail - URI of a thumbnail image associated with this NFT\n * @property imageOriginal - URI of the original image associated with this NFT\n * @property animation - URI of a animation associated with this NFT\n * @property animationOriginal - URI of the original animation associated with this NFT\n * @property externalLink - External link containing additional information\n * @property creator - The NFT owner information object\n * @property isCurrentlyOwned - Boolean indicating whether the address/chainId combination where it's currently stored currently owns this NFT\n * @property transactionId - Transaction Id associated with the NFT\n */\nexport interface Nft extends NftMetadata {\n  tokenId: string;\n  address: string;\n  isCurrentlyOwned?: boolean;\n}\n\n/**\n * @type NftContract\n *\n * NFT contract information representation\n * @property name - Contract name\n * @property logo - Contract logo\n * @property address - Contract address\n * @property symbol - Contract symbol\n * @property description - Contract description\n * @property totalSupply - Total supply of NFTs\n * @property assetContractType - The NFT type, it could be `semi-fungible` or `non-fungible`\n * @property createdDate - Creation date\n * @property schemaName - The schema followed by the contract, it could be `ERC721` or `ERC1155`\n * @property externalLink - External link containing additional information\n */\nexport interface NftContract {\n  name?: string;\n  logo?: string;\n  address: string;\n  symbol?: string;\n  description?: string;\n  totalSupply?: string;\n  assetContractType?: string;\n  createdDate?: string;\n  schemaName?: string;\n  externalLink?: string;\n}\n\nexport enum OpenSeaV2ChainIds {\n  ethereum = 'ethereum',\n}\n\nexport type OpenSeaV2GetNftResponse = { nft: OpenSeaV2DetailedNft };\n\nexport type OpenSeaV2Nft = {\n  identifier: string;\n  collection: string;\n  contract: string;\n  token_standard: string;\n  name: string;\n  description: string;\n  image_url?: string;\n  metadata_url?: string;\n  updated_at: string;\n  is_disabled: boolean;\n  is_nsfw: boolean;\n};\n\nexport type OpenSeaV2DetailedNft = OpenSeaV2Nft & {\n  animation_url?: string;\n  is_suspicious: boolean;\n  creator: string;\n  traits: {\n    trait_type: string;\n    display_type?: string;\n    max_value: string;\n    trait_count?: number;\n    value: number | string;\n  }[];\n  owners: {\n    address: string;\n    quantity: number;\n  }[];\n  rarity: { rank: number };\n};\n\nexport type OpenSeaV2ListNftsResponse = {\n  nfts: OpenSeaV2Nft[];\n  next?: string;\n};\n\nexport type OpenSeaV2Contract = {\n  address: string;\n  chain: string;\n  collection: string;\n  contract_standard: string;\n  name: string;\n  supply: number;\n};\n\nexport type OpenSeaV2Collection = {\n  collection: string;\n  name: string;\n  description?: string;\n  image_url?: string;\n  owner: string;\n  category: string;\n  is_disabled: boolean;\n  is_nsfw: boolean;\n  trait_offers_enabled: boolean;\n  opensea_url: string;\n  project_url?: string;\n  wiki_url?: string;\n  discord_url?: string;\n  telegram_url?: string;\n  twitter_username?: string;\n  instagram_username?: string;\n};\n\n/**\n * @type NftMetadata\n *\n * NFT custom information\n * @property name - NFT custom name\n * @property description - The NFT description\n * @property numberOfSales - Number of sales\n * @property backgroundColor - The background color to be displayed with the item\n * @property image - Image custom image URI\n * @property imagePreview - URI of a smaller image associated with this NFT\n * @property imageThumbnail - URI of a thumbnail image associated with this NFT\n * @property imageOriginal - URI of the original image associated with this NFT\n * @property animation - URI of a animation associated with this NFT\n * @property animationOriginal - URI of the original animation associated with this NFT\n * @property externalLink - External link containing additional information\n * @property creator - The NFT owner information object\n * @property standard - NFT standard name for the NFT, e.g., ERC-721 or ERC-1155\n */\nexport interface NftMetadata {\n  name: string | null;\n  description: string | null;\n  image: string | null;\n  standard: string | null;\n  favorite?: boolean;\n  numberOfSales?: number;\n  backgroundColor?: string;\n  imagePreview?: string;\n  imageThumbnail?: string;\n  imageOriginal?: string;\n  animation?: string;\n  animationOriginal?: string;\n  externalLink?: string;\n  creator?: ApiNftCreator;\n  lastSale?: ApiNftLastSale;\n  transactionId?: string;\n  tokenURI?: string;\n  error?: string;\n}\n\ninterface AccountParams {\n  userAddress: string;\n  chainId: Hex;\n}\n\n/**\n * @type NftConfig\n *\n * NFT controller configuration\n * @property selectedAddress - Vault selected address\n */\nexport interface NftConfig extends BaseConfig {\n  selectedAddress: string;\n  chainId: Hex;\n  ipfsGateway: string;\n  isIpfsGatewayEnabled: boolean;\n  displayNftMedia: boolean;\n  useIPFSSubdomains: boolean;\n}\n\n/**\n * @type NftState\n *\n * NFT controller state\n * @property allNftContracts - Object containing NFT contract information\n * @property allNfts - Object containing NFTs per account and network\n * @property ignoredNfts - List of NFTs that should be ignored\n */\nexport interface NftState extends BaseState {\n  allNftContracts: {\n    [key: string]: { [chainId: Hex]: NftContract[] };\n  };\n  allNfts: { [key: string]: { [chainId: Hex]: Nft[] } };\n  ignoredNfts: Nft[];\n}\n\nconst ALL_NFTS_STATE_KEY = 'allNfts';\nconst ALL_NFTS_CONTRACTS_STATE_KEY = 'allNftContracts';\n\n/**\n * Controller that stores assets and exposes convenience methods\n */\nexport class NftController extends BaseController<NftConfig, NftState> {\n  private mutex = new Mutex();\n\n  private getNftApi({\n    contractAddress,\n    tokenId,\n  }: {\n    contractAddress: string;\n    tokenId: string;\n  }) {\n    return `${OPENSEA_PROXY_URL}/chain/${OpenSeaV2ChainIds.ethereum}/contract/${contractAddress}/nfts/${tokenId}`;\n  }\n\n  private getNftContractInformationApi({\n    contractAddress,\n  }: {\n    contractAddress: string;\n  }) {\n    return `${OPENSEA_PROXY_URL}/chain/${OpenSeaV2ChainIds.ethereum}/contract/${contractAddress}`;\n  }\n\n  private getNftCollectionInformationApi({\n    collectionSlug,\n  }: {\n    collectionSlug: string;\n  }) {\n    return `${OPENSEA_PROXY_URL}/collections/${collectionSlug}`;\n  }\n\n  /**\n   * Helper method to update nested state for allNfts and allNftContracts.\n   *\n   * @param newCollection - the modified piece of state to update in the controller's store\n   * @param baseStateKey - The root key in the store to update.\n   * @param passedConfig - An object containing the selectedAddress and chainId that are passed through the auto-detection flow.\n   * @param passedConfig.userAddress - the address passed through the NFT detection flow to ensure detected assets are stored to the correct account\n   * @param passedConfig.chainId - the chainId passed through the NFT detection flow to ensure detected assets are stored to the correct account\n   */\n  private updateNestedNftState(\n    newCollection: Nft[] | NftContract[],\n    baseStateKey: 'allNfts' | 'allNftContracts',\n    { userAddress, chainId } = {\n      userAddress: this.config.selectedAddress,\n      chainId: this.config.chainId,\n    },\n  ) {\n    const { [baseStateKey]: oldState } = this.state;\n\n    const addressState = oldState[userAddress];\n    const newAddressState = {\n      ...addressState,\n      ...{ [chainId]: newCollection },\n    };\n    const newState = {\n      ...oldState,\n      ...{ [userAddress]: newAddressState },\n    };\n\n    this.update({\n      [baseStateKey]: newState,\n    });\n  }\n\n  /**\n   * Request individual NFT information from OpenSea API.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftInformationFromApi(\n    contractAddress: string,\n    tokenId: string,\n  ): Promise<NftMetadata> {\n    try {\n      // Attempt to fetch the data with the proxy\n      const nftInformation: { nft: OpenSeaV2DetailedNft } | undefined =\n        await fetchWithErrorHandling({\n          url: this.getNftApi({\n            contractAddress,\n            tokenId,\n          }),\n        });\n\n      // if we were still unable to fetch the data we return out the default/null of `NftMetadata`\n      if (!nftInformation?.nft) {\n        return {\n          name: null,\n          description: null,\n          image: null,\n          standard: null,\n        };\n      }\n\n      // if we've reached this point, we have successfully fetched some data for nftInformation\n      // now we reconfigure the data to conform to the `NftMetadata` type for storage.\n      const {\n        num_sales,\n        background_color,\n        image_url,\n        image_preview_url,\n        image_thumbnail_url,\n        image_original_url,\n        animation_url,\n        animation_original_url,\n        name,\n        description,\n        external_link,\n        creator,\n        last_sale,\n        asset_contract: { schema_name },\n      } = mapOpenSeaDetailedNftV2ToV1(nftInformation.nft);\n\n      /* istanbul ignore next */\n      const nftMetadata: NftMetadata = Object.assign(\n        {},\n        { name: name || null },\n        { description: description || null },\n        { image: image_url || null },\n        creator && { creator },\n        num_sales && { numberOfSales: num_sales },\n        background_color && { backgroundColor: background_color },\n        image_preview_url && { imagePreview: image_preview_url },\n        image_thumbnail_url && { imageThumbnail: image_thumbnail_url },\n        image_original_url && { imageOriginal: image_original_url },\n        animation_url && { animation: animation_url },\n        animation_original_url && {\n          animationOriginal: animation_original_url,\n        },\n        external_link && { externalLink: external_link },\n        last_sale && { lastSale: last_sale },\n        schema_name && { standard: schema_name },\n      );\n\n      return nftMetadata;\n    } catch (error) {\n      return {\n        name: null,\n        description: null,\n        image: null,\n        standard: null,\n        error: 'Opensea import error',\n      };\n    }\n  }\n\n  /**\n   * Request individual NFT information from contracts that follows Metadata Interface.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftInformationFromTokenURI(\n    contractAddress: string,\n    tokenId: string,\n  ): Promise<NftMetadata> {\n    const {\n      ipfsGateway,\n      useIPFSSubdomains,\n      isIpfsGatewayEnabled,\n      displayNftMedia,\n    } = this.config;\n    const result = await this.getNftURIAndStandard(contractAddress, tokenId);\n    let tokenURI = result[0];\n    const standard = result[1];\n\n    if (!displayNftMedia && !isIpfsGatewayEnabled) {\n      return {\n        image: null,\n        name: null,\n        description: null,\n        standard: standard || null,\n        favorite: false,\n        tokenURI,\n      };\n    }\n\n    const hasIpfsTokenURI = tokenURI.startsWith('ipfs://');\n\n    if (hasIpfsTokenURI && !isIpfsGatewayEnabled) {\n      return {\n        image: null,\n        name: null,\n        description: null,\n        standard: standard || null,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    }\n    if (hasIpfsTokenURI) {\n      tokenURI = getFormattedIpfsUrl(ipfsGateway, tokenURI, useIPFSSubdomains);\n    }\n\n    if (!hasIpfsTokenURI && !displayNftMedia) {\n      return {\n        image: null,\n        name: null,\n        description: null,\n        standard: standard || null,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    }\n\n    try {\n      const object = await handleFetch(tokenURI);\n      // TODO: Check image_url existence. This is not part of EIP721 nor EIP1155\n      const image = Object.prototype.hasOwnProperty.call(object, 'image')\n        ? 'image'\n        : /* istanbul ignore next */ 'image_url';\n\n      return {\n        image: object[image],\n        name: object.name,\n        description: object.description,\n        standard,\n        favorite: false,\n        tokenURI,\n      };\n    } catch {\n      return {\n        image: null,\n        name: null,\n        description: null,\n        standard: standard || null,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n        error: 'URI import error',\n      };\n    }\n  }\n\n  /**\n   * Retrieve NFT uri with  metadata. TODO Update method to use IPFS.\n   *\n   * @param contractAddress - NFT contract address.\n   * @param tokenId - NFT token id.\n   * @returns Promise resolving NFT uri and token standard.\n   */\n  private async getNftURIAndStandard(\n    contractAddress: string,\n    tokenId: string,\n  ): Promise<[string, string]> {\n    // try ERC721 uri\n    try {\n      const uri = await this.getERC721TokenURI(contractAddress, tokenId);\n      return [uri, ERC721];\n    } catch {\n      // Ignore error\n    }\n\n    // try ERC1155 uri\n    try {\n      const tokenURI = await this.getERC1155TokenURI(contractAddress, tokenId);\n\n      /**\n       * According to EIP1155 the URI value allows for ID substitution\n       * in case the string `{id}` exists.\n       * https://eips.ethereum.org/EIPS/eip-1155#metadata\n       */\n\n      if (!tokenURI.includes('{id}')) {\n        return [tokenURI, ERC1155];\n      }\n\n      const hexTokenId = stripHexPrefix(BNToHex(new BN(tokenId)))\n        .padStart(64, '0')\n        .toLowerCase();\n      return [tokenURI.replace('{id}', hexTokenId), ERC1155];\n    } catch {\n      // Ignore error\n    }\n\n    return ['', ''];\n  }\n\n  /**\n   * Request individual NFT information (name, image url and description).\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftInformation(\n    contractAddress: string,\n    tokenId: string,\n  ): Promise<NftMetadata> {\n    const blockchainMetadata = await safelyExecute(async () => {\n      return await this.getNftInformationFromTokenURI(contractAddress, tokenId);\n    });\n\n    let openSeaMetadata;\n    if (this.config.displayNftMedia) {\n      openSeaMetadata = await safelyExecute(async () => {\n        return await this.getNftInformationFromApi(contractAddress, tokenId);\n      });\n    }\n\n    if (blockchainMetadata.error && openSeaMetadata.error) {\n      return {\n        image: null,\n        name: null,\n        description: null,\n        standard: blockchainMetadata.standard ?? null,\n        favorite: false,\n        tokenURI: blockchainMetadata.tokenURI ?? null,\n        error: 'Both import failed',\n      };\n    }\n\n    return {\n      ...openSeaMetadata,\n      tokenURI:\n        blockchainMetadata.tokenURI ?? openSeaMetadata?.tokenURI ?? null,\n      name: blockchainMetadata.name ?? openSeaMetadata?.name ?? null,\n      description:\n        blockchainMetadata.description ?? openSeaMetadata?.description ?? null,\n      image: blockchainMetadata.image ?? openSeaMetadata?.image ?? null,\n      standard:\n        blockchainMetadata.standard ?? openSeaMetadata?.standard ?? null,\n    };\n  }\n\n  /**\n   * Request NFT contract information from OpenSea API.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftContractInformationFromApi(\n    contractAddress: string,\n  ): Promise<ApiNftContract> {\n    /* istanbul ignore if */\n    const apiNftContractObject: OpenSeaV2Contract | undefined =\n      await fetchWithErrorHandling({\n        url: this.getNftContractInformationApi({\n          contractAddress,\n        }),\n      });\n\n    // if we successfully fetched return the fetched data immediately\n    if (apiNftContractObject) {\n      // If we successfully fetched the contract\n      if (apiNftContractObject) {\n        // Then fetch some additional details from the collection\n        const collection: OpenSeaV2Collection | undefined =\n          await fetchWithErrorHandling({\n            url: this.getNftCollectionInformationApi({\n              collectionSlug: apiNftContractObject.collection,\n            }),\n          });\n\n        return mapOpenSeaContractV2ToV1(apiNftContractObject, collection);\n      }\n    }\n\n    // If we've reached this point we were unable to fetch data from either the proxy or opensea so we return\n    // the default/null of ApiNftContract\n    return {\n      address: contractAddress,\n      asset_contract_type: null,\n      created_date: null,\n      schema_name: null,\n      symbol: null,\n      total_supply: null,\n      description: null,\n      external_link: null,\n      collection: {\n        name: null,\n        image_url: null,\n      },\n    };\n  }\n\n  /**\n   * Request NFT contract information from the contract itself.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftContractInformationFromContract(\n    contractAddress: string,\n  ): Promise<\n    Partial<ApiNftContract> &\n      Pick<ApiNftContract, 'address'> &\n      Pick<ApiNftContract, 'collection'>\n  > {\n    const name = await this.getERC721AssetName(contractAddress);\n    const symbol = await this.getERC721AssetSymbol(contractAddress);\n    return {\n      collection: { name },\n      symbol,\n      address: contractAddress,\n    };\n  }\n\n  /**\n   * Request NFT contract information from OpenSea API.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @returns Promise resolving to the NFT contract name, image and description.\n   */\n  private async getNftContractInformation(\n    contractAddress: string,\n  ): Promise<\n    Partial<ApiNftContract> &\n      Pick<ApiNftContract, 'address'> &\n      Pick<ApiNftContract, 'collection'>\n  > {\n    const blockchainContractData: Partial<ApiNftContract> &\n      Pick<ApiNftContract, 'address'> &\n      Pick<ApiNftContract, 'collection'> = await safelyExecute(async () => {\n      return await this.getNftContractInformationFromContract(contractAddress);\n    });\n\n    let openSeaContractData: Partial<ApiNftContract> | undefined;\n    if (this.config.displayNftMedia) {\n      openSeaContractData = await safelyExecute(async () => {\n        return await this.getNftContractInformationFromApi(contractAddress);\n      });\n    }\n\n    if (blockchainContractData || openSeaContractData) {\n      return {\n        ...openSeaContractData,\n        ...blockchainContractData,\n        collection: {\n          image_url: null,\n          ...openSeaContractData?.collection,\n          ...blockchainContractData?.collection,\n        },\n      };\n    }\n\n    /* istanbul ignore next */\n    return {\n      address: contractAddress,\n      asset_contract_type: null,\n      created_date: null,\n      schema_name: null,\n      symbol: null,\n      total_supply: null,\n      description: null,\n      external_link: null,\n      collection: { name: null, image_url: null },\n    };\n  }\n\n  /**\n   * Adds an individual NFT to the stored NFT list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param nftMetadata - NFT optional information (name, image and description).\n   * @param nftContract - An object containing contract data of the NFT being added.\n   * @param detection - The chain ID and address of the currently selected network and account at the moment the NFT was detected.\n   * @returns Promise resolving to the current NFT list.\n   */\n  private async addIndividualNft(\n    address: string,\n    tokenId: string,\n    nftMetadata: NftMetadata,\n    nftContract: NftContract,\n    detection?: AccountParams,\n  ): Promise<Nft[]> {\n    // TODO: Remove unused return\n    const releaseLock = await this.mutex.acquire();\n    try {\n      address = toChecksumHexAddress(address);\n      const { allNfts } = this.state;\n      let chainId, selectedAddress;\n\n      if (detection) {\n        chainId = detection.chainId;\n        selectedAddress = detection.userAddress;\n      } else {\n        chainId = this.config.chainId;\n        selectedAddress = this.config.selectedAddress;\n      }\n\n      const nfts = allNfts[selectedAddress]?.[chainId] || [];\n\n      const existingEntry: Nft | undefined = nfts.find(\n        (nft) =>\n          nft.address.toLowerCase() === address.toLowerCase() &&\n          nft.tokenId === tokenId,\n      );\n\n      if (existingEntry) {\n        const differentMetadata = compareNftMetadata(\n          nftMetadata,\n          existingEntry,\n        );\n        if (differentMetadata || !existingEntry.isCurrentlyOwned) {\n          // TODO: Switch to indexToUpdate\n          const indexToRemove = nfts.findIndex(\n            (nft) =>\n              nft.address.toLowerCase() === address.toLowerCase() &&\n              nft.tokenId === tokenId,\n          );\n          /* istanbul ignore next */\n          if (indexToRemove !== -1) {\n            nfts.splice(indexToRemove, 1);\n          }\n        } else {\n          return nfts;\n        }\n      }\n\n      const newEntry: Nft = {\n        address,\n        tokenId,\n        favorite: existingEntry?.favorite || false,\n        isCurrentlyOwned: true,\n        ...nftMetadata,\n      };\n\n      const newNfts = [...nfts, newEntry];\n      this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n        chainId,\n        userAddress: selectedAddress,\n      });\n\n      if (this.onNftAdded) {\n        this.onNftAdded({\n          address,\n          symbol: nftContract.symbol,\n          tokenId: tokenId.toString(),\n          standard: nftMetadata.standard,\n          source: detection ? 'detected' : 'custom',\n          tokenURI: nftMetadata.tokenURI,\n        });\n      }\n\n      return newNfts;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Adds an NFT contract to the stored NFT contracts list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param detection - The chain ID and address of the currently selected network and account at the moment the NFT was detected.\n   * @returns Promise resolving to the current NFT contracts list.\n   */\n  private async addNftContract(\n    address: string,\n    detection?: AccountParams,\n  ): Promise<NftContract[]> {\n    const releaseLock = await this.mutex.acquire();\n    try {\n      address = toChecksumHexAddress(address);\n      const { allNftContracts } = this.state;\n\n      let chainId, selectedAddress;\n      if (detection) {\n        chainId = detection.chainId;\n        selectedAddress = detection.userAddress;\n      } else {\n        chainId = this.config.chainId;\n        selectedAddress = this.config.selectedAddress;\n      }\n\n      const nftContracts = allNftContracts[selectedAddress]?.[chainId] || [];\n\n      const existingEntry = nftContracts.find(\n        (nftContract) =>\n          nftContract.address.toLowerCase() === address.toLowerCase(),\n      );\n      if (existingEntry) {\n        return nftContracts;\n      }\n      const contractInformation = await this.getNftContractInformation(address);\n\n      const {\n        asset_contract_type,\n        created_date,\n        schema_name,\n        symbol,\n        total_supply,\n        description,\n        external_link,\n        collection: { name, image_url },\n      } = contractInformation;\n      // If being auto-detected opensea information is expected\n      // Otherwise at least name from the contract is needed\n      if (\n        (detection && !name) ||\n        Object.keys(contractInformation).length === 0\n      ) {\n        return nftContracts;\n      }\n\n      /* istanbul ignore next */\n      const newEntry: NftContract = Object.assign(\n        {},\n        { address },\n        description && { description },\n        name && { name },\n        image_url && { logo: image_url },\n        symbol && { symbol },\n        total_supply !== null &&\n          typeof total_supply !== 'undefined' && { totalSupply: total_supply },\n        asset_contract_type && { assetContractType: asset_contract_type },\n        created_date && { createdDate: created_date },\n        schema_name && { schemaName: schema_name },\n        external_link && { externalLink: external_link },\n      );\n      const newNftContracts = [...nftContracts, newEntry];\n      this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY, {\n        chainId,\n        userAddress: selectedAddress,\n      });\n\n      return newNftContracts;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Removes an individual NFT from the stored token list and saves it in ignored NFTs list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   */\n  private removeAndIgnoreIndividualNft(address: string, tokenId: string) {\n    address = toChecksumHexAddress(address);\n    const { allNfts, ignoredNfts } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const newIgnoredNfts = [...ignoredNfts];\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const newNfts = nfts.filter((nft) => {\n      if (\n        nft.address.toLowerCase() === address.toLowerCase() &&\n        nft.tokenId === tokenId\n      ) {\n        const alreadyIgnored = newIgnoredNfts.find(\n          (c) => c.address === address && c.tokenId === tokenId,\n        );\n        !alreadyIgnored && newIgnoredNfts.push(nft);\n        return false;\n      }\n      return true;\n    });\n\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY);\n\n    this.update({\n      ignoredNfts: newIgnoredNfts,\n    });\n  }\n\n  /**\n   * Removes an individual NFT from the stored token list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   */\n  private removeIndividualNft(address: string, tokenId: string) {\n    address = toChecksumHexAddress(address);\n    const { allNfts } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const newNfts = nfts.filter(\n      (nft) =>\n        !(\n          nft.address.toLowerCase() === address.toLowerCase() &&\n          nft.tokenId === tokenId\n        ),\n    );\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY);\n  }\n\n  /**\n   * Removes an NFT contract to the stored NFT contracts list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @returns Promise resolving to the current NFT contracts list.\n   */\n  private removeNftContract(address: string): NftContract[] {\n    address = toChecksumHexAddress(address);\n    const { allNftContracts } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const nftContracts = allNftContracts[selectedAddress]?.[chainId] || [];\n\n    const newNftContracts = nftContracts.filter(\n      (nftContract) =>\n        !(nftContract.address.toLowerCase() === address.toLowerCase()),\n    );\n    this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY);\n\n    return newNftContracts;\n  }\n\n  /**\n   * EventEmitter instance used to listen to specific EIP747 events\n   */\n  hub = new EventEmitter();\n\n  /**\n   * Optional API key to use with opensea\n   */\n  openSeaApiKey?: string;\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'NftController';\n\n  private getERC721AssetName: AssetsContractController['getERC721AssetName'];\n\n  private getERC721AssetSymbol: AssetsContractController['getERC721AssetSymbol'];\n\n  private getERC721TokenURI: AssetsContractController['getERC721TokenURI'];\n\n  private getERC721OwnerOf: AssetsContractController['getERC721OwnerOf'];\n\n  private getERC1155BalanceOf: AssetsContractController['getERC1155BalanceOf'];\n\n  private getERC1155TokenURI: AssetsContractController['getERC1155TokenURI'];\n\n  private onNftAdded?: (data: {\n    address: string;\n    symbol: string | undefined;\n    tokenId: string;\n    standard: string | null;\n    source: string;\n    tokenURI?: string;\n  }) => void;\n\n  /**\n   * Creates an NftController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param options.getERC721AssetName - Gets the name of the asset at the given address.\n   * @param options.getERC721AssetSymbol - Gets the symbol of the asset at the given address.\n   * @param options.getERC721TokenURI - Gets the URI of the ERC721 token at the given address, with the given ID.\n   * @param options.getERC721OwnerOf - Get the owner of a ERC-721 NFT.\n   * @param options.getERC1155BalanceOf - Gets balance of a ERC-1155 NFT.\n   * @param options.getERC1155TokenURI - Gets the URI of the ERC1155 token at the given address, with the given ID.\n   * @param options.onNftAdded - Callback that is called when an NFT is added. Currently used pass data\n   * for tracking the NFT added event.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      chainId: initialChainId,\n      onPreferencesStateChange,\n      onNetworkStateChange,\n      getERC721AssetName,\n      getERC721AssetSymbol,\n      getERC721TokenURI,\n      getERC721OwnerOf,\n      getERC1155BalanceOf,\n      getERC1155TokenURI,\n      onNftAdded,\n    }: {\n      chainId: Hex;\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      getERC721AssetName: AssetsContractController['getERC721AssetName'];\n      getERC721AssetSymbol: AssetsContractController['getERC721AssetSymbol'];\n      getERC721TokenURI: AssetsContractController['getERC721TokenURI'];\n      getERC721OwnerOf: AssetsContractController['getERC721OwnerOf'];\n      getERC1155BalanceOf: AssetsContractController['getERC1155BalanceOf'];\n      getERC1155TokenURI: AssetsContractController['getERC1155TokenURI'];\n      onNftAdded?: (data: {\n        address: string;\n        symbol: string | undefined;\n        tokenId: string;\n        standard: string | null;\n        source: string;\n      }) => void;\n    },\n    config?: Partial<BaseConfig>,\n    state?: Partial<NftState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      selectedAddress: '',\n      chainId: initialChainId,\n      ipfsGateway: IPFS_DEFAULT_GATEWAY_URL,\n      displayNftMedia: true,\n      useIPFSSubdomains: true,\n      isIpfsGatewayEnabled: true,\n    };\n\n    this.defaultState = {\n      allNftContracts: {},\n      allNfts: {},\n      ignoredNfts: [],\n    };\n    this.initialize();\n    this.getERC721AssetName = getERC721AssetName;\n    this.getERC721AssetSymbol = getERC721AssetSymbol;\n    this.getERC721TokenURI = getERC721TokenURI;\n    this.getERC721OwnerOf = getERC721OwnerOf;\n    this.getERC1155BalanceOf = getERC1155BalanceOf;\n    this.getERC1155TokenURI = getERC1155TokenURI;\n    this.onNftAdded = onNftAdded;\n\n    onPreferencesStateChange(\n      ({\n        selectedAddress,\n        ipfsGateway,\n        displayNftMedia,\n        isIpfsGatewayEnabled,\n      }) => {\n        this.configure({\n          selectedAddress,\n          ipfsGateway,\n          displayNftMedia,\n          isIpfsGatewayEnabled,\n        });\n      },\n    );\n\n    onNetworkStateChange(({ providerConfig }) => {\n      const { chainId } = providerConfig;\n      this.configure({ chainId });\n    });\n  }\n\n  /**\n   * Sets an OpenSea API key to retrieve NFT information.\n   *\n   * @param openSeaApiKey - OpenSea API key.\n   */\n  setApiKey(openSeaApiKey: string) {\n    this.openSeaApiKey = openSeaApiKey;\n  }\n\n  /**\n   * Checks the ownership of a ERC-721 or ERC-1155 NFT for a given address.\n   *\n   * @param ownerAddress - User public address.\n   * @param nftAddress - NFT contract address.\n   * @param nftId - NFT token ID.\n   * @returns Promise resolving the NFT ownership.\n   */\n  async isNftOwner(\n    ownerAddress: string,\n    nftAddress: string,\n    nftId: string,\n  ): Promise<boolean> {\n    // Checks the ownership for ERC-721.\n    try {\n      const owner = await this.getERC721OwnerOf(nftAddress, nftId);\n      return ownerAddress.toLowerCase() === owner.toLowerCase();\n      // eslint-disable-next-line no-empty\n    } catch {\n      // Ignore ERC-721 contract error\n    }\n\n    // Checks the ownership for ERC-1155.\n    try {\n      const balance = await this.getERC1155BalanceOf(\n        ownerAddress,\n        nftAddress,\n        nftId,\n      );\n      return !balance.isZero();\n      // eslint-disable-next-line no-empty\n    } catch {\n      // Ignore ERC-1155 contract error\n    }\n\n    throw new Error(\n      'Unable to verify ownership. Probably because the standard is not supported or the chain is incorrect.',\n    );\n  }\n\n  /**\n   * Verifies currently selected address owns entered NFT address/tokenId combo and\n   * adds the NFT and respective NFT contract to the stored NFT and NFT contracts lists.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   */\n  async addNftVerifyOwnership(address: string, tokenId: string) {\n    const { selectedAddress } = this.config;\n    if (!(await this.isNftOwner(selectedAddress, address, tokenId))) {\n      throw new Error('This NFT is not owned by the user');\n    }\n    await this.addNft(address, tokenId);\n  }\n\n  /**\n   * Adds an NFT and respective NFT contract to the stored NFT and NFT contracts lists.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param nftMetadata - NFT optional metadata.\n   * @param detection - The chain ID and address of the currently selected network and account at the moment the NFT was detected.\n   * @returns Promise resolving to the current NFT list.\n   */\n  async addNft(\n    address: string,\n    tokenId: string,\n    nftMetadata?: NftMetadata,\n    detection?: AccountParams,\n  ) {\n    address = toChecksumHexAddress(address);\n    const newNftContracts = await this.addNftContract(address, detection);\n    nftMetadata =\n      nftMetadata || (await this.getNftInformation(address, tokenId));\n\n    // If NFT contract was not added, do not add individual NFT\n    const nftContract = newNftContracts.find(\n      (contract) => contract.address.toLowerCase() === address.toLowerCase(),\n    );\n\n    // If NFT contract information, add individual NFT\n    if (nftContract) {\n      await this.addIndividualNft(\n        address,\n        tokenId,\n        nftMetadata,\n        nftContract,\n        detection,\n      );\n    }\n  }\n\n  /**\n   * Removes an NFT from the stored token list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   */\n  removeNft(address: string, tokenId: string) {\n    address = toChecksumHexAddress(address);\n    this.removeIndividualNft(address, tokenId);\n    const { allNfts } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const remainingNft = nfts.find(\n      (nft) => nft.address.toLowerCase() === address.toLowerCase(),\n    );\n    if (!remainingNft) {\n      this.removeNftContract(address);\n    }\n  }\n\n  /**\n   * Removes an NFT from the stored token list and saves it in ignored NFTs list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   */\n  removeAndIgnoreNft(address: string, tokenId: string) {\n    address = toChecksumHexAddress(address);\n    this.removeAndIgnoreIndividualNft(address, tokenId);\n    const { allNfts } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const remainingNft = nfts.find(\n      (nft) => nft.address.toLowerCase() === address.toLowerCase(),\n    );\n    if (!remainingNft) {\n      this.removeNftContract(address);\n    }\n  }\n\n  /**\n   * Removes all NFTs from the ignored list.\n   */\n  clearIgnoredNfts() {\n    this.update({ ignoredNfts: [] });\n  }\n\n  /**\n   * Checks whether input NFT is still owned by the user\n   * And updates the isCurrentlyOwned value on the NFT object accordingly.\n   *\n   * @param nft - The NFT object to check and update.\n   * @param batch - A boolean indicating whether this method is being called as part of a batch or single update.\n   * @param accountParams - The userAddress and chainId to check ownership against\n   * @param accountParams.userAddress - the address passed through the confirmed transaction flow to ensure detected assets are stored to the correct account\n   * @param accountParams.chainId - the chainId passed through the confirmed transaction flow to ensure detected assets are stored to the correct account\n   * @returns the NFT with the updated isCurrentlyOwned value\n   */\n  async checkAndUpdateSingleNftOwnershipStatus(\n    nft: Nft,\n    batch: boolean,\n    { userAddress, chainId } = {\n      userAddress: this.config.selectedAddress,\n      chainId: this.config.chainId,\n    },\n  ) {\n    const { address, tokenId } = nft;\n    let isOwned = nft.isCurrentlyOwned;\n    try {\n      isOwned = await this.isNftOwner(userAddress, address, tokenId);\n    } catch (error) {\n      if (\n        !(\n          error instanceof Error &&\n          error.message.includes('Unable to verify ownership')\n        )\n      ) {\n        throw error;\n      }\n    }\n\n    nft.isCurrentlyOwned = isOwned;\n\n    if (batch === true) {\n      return nft;\n    }\n\n    // if this is not part of a batched update we update this one NFT in state\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const nftToUpdate = nfts.find(\n      (item) =>\n        item.tokenId === tokenId &&\n        item.address.toLowerCase() === address.toLowerCase(),\n    );\n    if (nftToUpdate) {\n      nftToUpdate.isCurrentlyOwned = isOwned;\n      this.updateNestedNftState(nfts, ALL_NFTS_STATE_KEY, {\n        userAddress,\n        chainId,\n      });\n    }\n    return nft;\n  }\n\n  /**\n   * Checks whether NFTs associated with current selectedAddress/chainId combination are still owned by the user\n   * And updates the isCurrentlyOwned value on each accordingly.\n   */\n  async checkAndUpdateAllNftsOwnershipStatus() {\n    const { allNfts } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const updatedNfts = await Promise.all(\n      nfts.map(async (nft) => {\n        return (\n          (await this.checkAndUpdateSingleNftOwnershipStatus(nft, true)) ?? nft\n        );\n      }),\n    );\n\n    this.updateNestedNftState(updatedNfts, ALL_NFTS_STATE_KEY);\n  }\n\n  /**\n   * Update NFT favorite status.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Hex address of the NFT contract.\n   * @param favorite - NFT new favorite status.\n   */\n  updateNftFavoriteStatus(address: string, tokenId: string, favorite: boolean) {\n    const { allNfts } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const index: number = nfts.findIndex(\n      (nft) => nft.address === address && nft.tokenId === tokenId,\n    );\n\n    if (index === -1) {\n      return;\n    }\n\n    const updatedNft: Nft = {\n      ...nfts[index],\n      favorite,\n    };\n\n    // Update Nfts array\n    nfts[index] = updatedNft;\n\n    this.updateNestedNftState(nfts, ALL_NFTS_STATE_KEY);\n  }\n\n  /**\n   * Returns an NFT by the address and token id.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Number that represents the id of the token.\n   * @param selectedAddress - Hex address of the user account.\n   * @param chainId - Id of the current network.\n   * @returns Object containing the NFT and its position in the array\n   */\n  findNftByAddressAndTokenId(\n    address: string,\n    tokenId: string,\n    selectedAddress: string,\n    chainId: Hex,\n  ): { nft: Nft; index: number } | null {\n    const { allNfts } = this.state;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n\n    const index: number = nfts.findIndex(\n      (nft) =>\n        nft.address.toLowerCase() === address.toLowerCase() &&\n        nft.tokenId === tokenId,\n    );\n\n    if (index === -1) {\n      return null;\n    }\n\n    return { nft: nfts[index], index };\n  }\n\n  /**\n   * Update NFT data.\n   *\n   * @param nft - NFT object to find the right NFT to updates.\n   * @param updates - NFT partial object to update properties of the NFT.\n   * @param selectedAddress - Hex address of the user account.\n   * @param chainId - Id of the current network.\n   */\n  updateNft(\n    nft: Nft,\n    updates: Partial<Nft>,\n    selectedAddress: string,\n    chainId: Hex,\n  ) {\n    const { allNfts } = this.state;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const nftInfo = this.findNftByAddressAndTokenId(\n      nft.address,\n      nft.tokenId,\n      selectedAddress,\n      chainId,\n    );\n\n    if (!nftInfo) {\n      return;\n    }\n\n    const updatedNft: Nft = {\n      ...nft,\n      ...updates,\n    };\n\n    const newNfts = [\n      ...nfts.slice(0, nftInfo.index),\n      updatedNft,\n      ...nfts.slice(nftInfo.index + 1),\n    ];\n\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY);\n  }\n\n  /**\n   * Resets the transaction status of an NFT.\n   *\n   * @param transactionId - NFT transaction id.\n   * @param selectedAddress - Hex address of the user account.\n   * @param chainId - Id of the current network.\n   * @returns a boolean indicating if the reset was well succeded or not\n   */\n  resetNftTransactionStatusByTransactionId(\n    transactionId: string,\n    selectedAddress: string,\n    chainId: Hex,\n  ): boolean {\n    const { allNfts } = this.state;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const index: number = nfts.findIndex(\n      (nft) => nft.transactionId === transactionId,\n    );\n\n    if (index === -1) {\n      return false;\n    }\n    const updatedNft: Nft = {\n      ...nfts[index],\n      transactionId: undefined,\n    };\n\n    const newNfts = [\n      ...nfts.slice(0, index),\n      updatedNft,\n      ...nfts.slice(index + 1),\n    ];\n\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY);\n    return true;\n  }\n}\n\nexport default NftController;\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/NftDetectionController.d.ts b/node_modules/@metamask/assets-controllers/dist/NftDetectionController.d.ts
index 34d0107..881a358 100644
--- a/node_modules/@metamask/assets-controllers/dist/NftDetectionController.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/NftDetectionController.d.ts
@@ -126,6 +126,7 @@ export declare class NftDetectionController extends BaseController<NftDetectionC
     name: string;
     private getOpenSeaApiKey;
     private addNft;
+    private getNftApi;
     private getNftState;
     /**
      * Creates an NftDetectionController instance.
@@ -137,17 +138,19 @@ export declare class NftDetectionController extends BaseController<NftDetectionC
      * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.
      * @param options.getOpenSeaApiKey - Gets the OpenSea API key, if one is set.
      * @param options.addNft - Add an NFT.
+     * @param options.getNftApi - Gets the URL to fetch an NFT from OpenSea.
      * @param options.getNftState - Gets the current state of the Assets controller.
      * @param config - Initial options used to configure this controller.
      * @param state - Initial state to set on this controller.
      */
-    constructor({ chainId: initialChainId, onPreferencesStateChange, onNetworkStateChange, getOpenSeaApiKey, addNft, getNftState, }: {
+    constructor({ chainId: initialChainId, onPreferencesStateChange, onNetworkStateChange, getOpenSeaApiKey, addNft, getNftApi, getNftState, }: {
         chainId: Hex;
         onNftsStateChange: (listener: (nftsState: NftState) => void) => void;
         onPreferencesStateChange: (listener: (preferencesState: PreferencesState) => void) => void;
         onNetworkStateChange: (listener: (networkState: NetworkState) => void) => void;
         getOpenSeaApiKey: () => string | undefined;
         addNft: NftController['addNft'];
+        getNftApi: NftController['getNftApi'];
         getNftState: () => NftState;
     }, config?: Partial<NftDetectionConfig>, state?: Partial<BaseState>);
     /**
diff --git a/node_modules/@metamask/assets-controllers/dist/NftDetectionController.js b/node_modules/@metamask/assets-controllers/dist/NftDetectionController.js
index 0762f57..2f2cbdb 100644
--- a/node_modules/@metamask/assets-controllers/dist/NftDetectionController.js
+++ b/node_modules/@metamask/assets-controllers/dist/NftDetectionController.js
@@ -12,6 +12,8 @@ Object.defineProperty(exports, "__esModule", { value: true });
 exports.NftDetectionController = void 0;
 const base_controller_1 = require("@metamask/base-controller");
 const controller_utils_1 = require("@metamask/controller-utils");
+const assetsUtil_1 = require("./assetsUtil");
+const NftController_1 = require("./NftController");
 const DEFAULT_INTERVAL = 180000;
 /**
  * Controller that passively polls on a set interval for NFT auto detection
@@ -27,11 +29,12 @@ class NftDetectionController extends base_controller_1.BaseController {
      * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.
      * @param options.getOpenSeaApiKey - Gets the OpenSea API key, if one is set.
      * @param options.addNft - Add an NFT.
+     * @param options.getNftApi - Gets the URL to fetch an NFT from OpenSea.
      * @param options.getNftState - Gets the current state of the Assets controller.
      * @param config - Initial options used to configure this controller.
      * @param state - Initial state to set on this controller.
      */
-    constructor({ chainId: initialChainId, onPreferencesStateChange, onNetworkStateChange, getOpenSeaApiKey, addNft, getNftState, }, config, state) {
+    constructor({ chainId: initialChainId, onPreferencesStateChange, onNetworkStateChange, getOpenSeaApiKey, addNft, getNftApi, getNftState, }, config, state) {
         super(config, state);
         /**
          * Name of this controller used during composition
@@ -73,47 +76,40 @@ class NftDetectionController extends base_controller_1.BaseController {
         });
         this.getOpenSeaApiKey = getOpenSeaApiKey;
         this.addNft = addNft;
+        this.getNftApi = getNftApi;
     }
-    getOwnerNftApi({ address, offset, useProxy, }) {
-        return useProxy
-            ? `${controller_utils_1.OPENSEA_PROXY_URL}/assets?owner=${address}&offset=${offset}&limit=50`
-            : `${controller_utils_1.OPENSEA_API_URL}/assets?owner=${address}&offset=${offset}&limit=50`;
+    getOwnerNftApi({ address, next, }) {
+        return `${controller_utils_1.OPENSEA_PROXY_URL}/chain/${NftController_1.OpenSeaV2ChainIds.ethereum}/account/${address}/nfts?limit=200&next=${next !== null && next !== void 0 ? next : ''}`;
     }
     getOwnerNfts(address) {
-        var _a;
         return __awaiter(this, void 0, void 0, function* () {
             let nftApiResponse;
             let nfts = [];
-            const openSeaApiKey = this.getOpenSeaApiKey();
-            let offset = 0;
-            let pagingFinish = false;
-            /* istanbul ignore if */
+            let next;
             do {
                 nftApiResponse = yield (0, controller_utils_1.fetchWithErrorHandling)({
-                    url: this.getOwnerNftApi({ address, offset, useProxy: true }),
+                    url: this.getOwnerNftApi({ address, next }),
                     timeout: 15000,
                 });
-                if (openSeaApiKey && !nftApiResponse) {
-                    nftApiResponse = yield (0, controller_utils_1.fetchWithErrorHandling)({
-                        url: this.getOwnerNftApi({
-                            address,
-                            offset,
-                            useProxy: false,
-                        }),
-                        options: { headers: { 'X-API-KEY': openSeaApiKey } },
-                        timeout: 15000,
-                        // catch 403 errors (in case API key is down we don't want to blow up)
-                        errorCodesToCatch: [403],
-                    });
-                }
                 if (!nftApiResponse) {
                     return nfts;
                 }
-                ((_a = nftApiResponse === null || nftApiResponse === void 0 ? void 0 : nftApiResponse.assets) === null || _a === void 0 ? void 0 : _a.length) !== 0
-                    ? (nfts = [...nfts, ...nftApiResponse.assets])
-                    : (pagingFinish = true);
-                offset += 50;
-            } while (!pagingFinish);
+                    const newNfts = yield Promise.all(nftApiResponse.nfts.map((nftV2) => __awaiter(this, void 0, void 0, function* () {
+                    var _a, _b;
+                    const nftV1 = (0, assetsUtil_1.mapOpenSeaNftV2ToV1)(nftV2);
+                    // If the image hasn't been processed into OpenSea's CDN, the image_url will be null.
+                    // Try fetching the NFT individually, which returns the original image url from metadata if available.
+                    if (!nftV1.image_url && nftV2.metadata_url) {
+                        const nftDetails = yield (0, controller_utils_1.safelyExecute)(() => (0, controller_utils_1.timeoutFetch)(this.getNftApi({
+                            contractAddress: nftV2.contract,
+                            tokenId: nftV2.identifier,
+                        }), undefined, 1000).then((r) => r.json()));
+                        nftV1.image_original_url = (_b = (_a = nftDetails === null || nftDetails === void 0 ? void 0 : nftDetails.nft) === null || _a === void 0 ? void 0 : _a.image_url) !== null && _b !== void 0 ? _b : null;
+                    }
+                    return nftV1;
+                })));
+                nfts = [...nfts, ...newNfts];
+            } while ((next = nftApiResponse.next));
             return nfts;
         });
     }
diff --git a/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.js b/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.js
index 9ddbc28..58421d3 100644
--- a/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.js
+++ b/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.js
@@ -57,6 +57,27 @@ class ERC20Standard {
             }
         });
     }
+    /**
+     * Query for the name for a given ERC20 asset.
+     *
+     * @param address - ERC20 asset contract string.
+     * @returns Promise resolving to the 'name'.
+     */
+    getTokenName(address){
+        return __awaiter(this, void 0, void 0, function* () {
+            const contract = new contracts_1.Contract(address, metamask_eth_abis_1.abiERC20, this.provider);
+            try {
+                const name = yield contract.name();
+                return name.toString();
+            } catch (err) {
+            // Mirror previous implementation
+            if (err.message.includes('call revert exception')) {
+                throw new Error('Failed to parse token name');
+            }
+            throw err;
+            }
+        });
+    }
     /**
      * Query for symbol for a given ERC20 asset.
      *
@@ -83,7 +104,8 @@ class ERC20Standard {
             try {
                 const utf8 = (0, ethereumjs_util_1.toUtf8)(result);
                 if (utf8.length > 0) {
-                    return utf8;
+                    // This utf8 returns unicode characters, wee need to replace it
+                    return utf8.replace(/[\u0000\u0003\u0020]/g, '');
                 }
             }
             catch (_b) {
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.js b/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.js
index 4ed4990..9af95c1 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.js
+++ b/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.js
@@ -34,7 +34,7 @@ class TokenDetectionController extends base_controller_1.BaseController {
      * @param config - Initial options used to configure this controller.
      * @param state - Initial state to set on this controller.
      */
-    constructor({ onPreferencesStateChange, onNetworkStateChange, onTokenListStateChange, getBalancesInSingleCall, addDetectedTokens, getTokenListState, getTokensState, getNetworkState, getPreferencesState, }, config, state) {
+    constructor({ onPreferencesStateChange, onNetworkStateChange, onTokenListStateChange, getBalancesInSingleCall, addDetectedTokens, updateTokensName, getTokenListState, getTokensState, getNetworkState, getPreferencesState, }, config, state) {
         const { providerConfig: { chainId: defaultChainId }, } = getNetworkState();
         const { useTokenDetection: defaultUseTokenDetection } = getPreferencesState();
         super(config, state);
@@ -47,6 +47,7 @@ class TokenDetectionController extends base_controller_1.BaseController {
         this.getTokensState = getTokensState;
         this.getTokenListState = getTokenListState;
         this.addDetectedTokens = addDetectedTokens;
+        this.updateTokensName = updateTokensName;
         this.getBalancesInSingleCall = getBalancesInSingleCall;
         onTokenListStateChange(({ tokenList }) => {
             const hasTokens = Object.keys(tokenList).length;
@@ -132,7 +133,12 @@ class TokenDetectionController extends base_controller_1.BaseController {
             const tokensAddresses = tokens.map(
             /* istanbul ignore next*/ (token) => token.address.toLowerCase());
             const { tokenList } = this.getTokenListState();
-            const tokensToDetect = [];
+
+            if (tokens.length && !tokens[0].name) {
+                this.updateTokensName(tokenList);
+            }
+            
+                const tokensToDetect = [];
             for (const address in tokenList) {
                 if (!tokensAddresses.includes(address)) {
                     tokensToDetect.push(address);
@@ -161,7 +167,7 @@ class TokenDetectionController extends base_controller_1.BaseController {
                         }
                         const caseInsensitiveTokenKey = Object.keys(tokenList).find((i) => i.toLowerCase() === tokenAddress.toLowerCase()) || '';
                         if (ignored === undefined) {
-                            const { decimals, symbol, aggregators, iconUrl } = tokenList[caseInsensitiveTokenKey];
+                            const { decimals, symbol, aggregators, iconUrl, name } = tokenList[caseInsensitiveTokenKey];
                             tokensToAdd.push({
                                 address: tokenAddress,
                                 decimals,
@@ -169,6 +175,7 @@ class TokenDetectionController extends base_controller_1.BaseController {
                                 aggregators,
                                 image: iconUrl,
                                 isERC721: false,
+                                name
                             });
                         }
                     }
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenRatesController.d.ts b/node_modules/@metamask/assets-controllers/dist/TokenRatesController.d.ts
index 480ecaf..15aafd7 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenRatesController.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/TokenRatesController.d.ts
@@ -1,29 +1,9 @@
-import type { Hex } from '@metamask/utils';
-import { BaseController, BaseConfig, BaseState } from '@metamask/base-controller';
+import { BaseController } from '@metamask/base-controller';
+import type { BaseConfig, BaseState } from '@metamask/base-controller';
 import type { NetworkState } from '@metamask/network-controller';
+import type { PreferencesState } from '@metamask/preferences-controller';
+import type { AbstractTokenPricesService } from './token-prices-service/abstract-token-prices-service';
 import type { TokensState } from './TokensController';
-import type { CurrencyRateState } from './CurrencyRateController';
-/**
- * @type CoinGeckoResponse
- *
- * CoinGecko API response representation
- */
-export interface CoinGeckoResponse {
-    [address: string]: {
-        [currency: string]: number;
-    };
-}
-/**
- * @type CoinGeckoPlatform
- *
- * CoinGecko supported platform API representation
- */
-export interface CoinGeckoPlatform {
-    id: string;
-    chain_identifier: null | number;
-    name: string;
-    shortname: string;
-}
 /**
  * @type Token
  *
@@ -41,6 +21,7 @@ export interface Token {
     image?: string;
     balanceError?: unknown;
     isERC721?: boolean;
+    name?: string;
 }
 /**
  * @type TokenRatesConfig
@@ -55,8 +36,18 @@ export interface Token {
 export interface TokenRatesConfig extends BaseConfig {
     interval: number;
     nativeCurrency: string;
-    chainId: Hex;
-    tokens: Token[];
+    chainId: string;
+    selectedAddress: string;
+    allTokens: {
+        [chainId: string]: {
+            [key: string]: Token[];
+        };
+    };
+    allDetectedTokens: {
+        [chainId: string]: {
+            [key: string]: Token[];
+        };
+    };
     threshold: number;
 }
 interface ContractExchangeRates {
@@ -66,21 +57,20 @@ interface ContractExchangeRates {
  * @type TokenRatesState
  *
  * Token rates controller state
- * @property contractExchangeRates - Hash of token contract addresses to exchange rates
- * @property supportedChains - Cached chain data
+ * @property contractExchangeRates - Hash of token contract addresses to exchange rates (single globally selected chain, will be deprecated soon)
+ * @property contractExchangeRatesByChainId - Hash of token contract addresses to exchange rates keyed by chain ID and native currency (ticker)
  */
 export interface TokenRatesState extends BaseState {
     contractExchangeRates: ContractExchangeRates;
+    contractExchangeRatesByChainId: Record<string, Record<string, ContractExchangeRates>>;
 }
 /**
  * Controller that passively polls on a set interval for token-to-fiat exchange rates
  * for tokens stored in the TokensController
  */
 export declare class TokenRatesController extends BaseController<TokenRatesConfig, TokenRatesState> {
+    #private;
     private handle?;
-    private tokenList;
-    private supportedChains;
-    private supportedVsCurrencies;
     /**
      * Name of this controller used during composition
      */
@@ -89,83 +79,41 @@ export declare class TokenRatesController extends BaseController<TokenRatesConfi
      * Creates a TokenRatesController instance.
      *
      * @param options - The controller options.
+     * @param options.interval - The polling interval in ms
+     * @param options.threshold - The duration in ms before metadata fetched from CoinGecko is considered stale
      * @param options.chainId - The chain ID of the current network.
+     * @param options.ticker - The ticker for the current network.
+     * @param options.selectedAddress - The current selected address.
+     * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.
      * @param options.onTokensStateChange - Allows subscribing to token controller state changes.
-     * @param options.onCurrencyRateStateChange - Allows subscribing to currency rate controller state changes.
      * @param options.onNetworkStateChange - Allows subscribing to network state changes.
+     * @param options.tokenPricesService - An object in charge of retrieving token prices.
      * @param config - Initial options used to configure this controller.
      * @param state - Initial state to set on this controller.
      */
-    constructor({ chainId: initialChainId, onTokensStateChange, onCurrencyRateStateChange, onNetworkStateChange, }: {
-        chainId: Hex;
+    constructor({ interval, threshold, chainId: initialChainId, ticker: initialTicker, selectedAddress: initialSelectedAddress, onPreferencesStateChange, onTokensStateChange, onNetworkStateChange, tokenPricesService, }: {
+        interval?: number;
+        threshold?: number;
+        chainId: string;
+        ticker: string;
+        selectedAddress: string;
+        onPreferencesStateChange: (listener: (preferencesState: PreferencesState) => void) => void;
         onTokensStateChange: (listener: (tokensState: TokensState) => void) => void;
-        onCurrencyRateStateChange: (listener: (currencyRateState: CurrencyRateState) => void) => void;
         onNetworkStateChange: (listener: (networkState: NetworkState) => void) => void;
+        tokenPricesService: AbstractTokenPricesService;
     }, config?: Partial<TokenRatesConfig>, state?: Partial<TokenRatesState>);
     /**
-     * Sets a new polling interval.
-     *
-     * @param interval - Polling interval used to fetch new token rates.
+     * Start (or restart) polling.
      */
-    poll(interval?: number): Promise<void>;
+    start(): Promise<void>;
     /**
-     * Sets a new chainId.
-     *
-     * TODO: Replace this with a method.
-     *
-     * @param _chainId - The current chain ID.
+     * Stop polling.
      */
-    set chainId(_chainId: Hex);
-    get chainId(): Hex;
-    /**
-     * Sets a new token list to track prices.
-     *
-     * TODO: Replace this with a method.
-     *
-     * @param tokens - List of tokens to track exchange rates for.
-     */
-    set tokens(tokens: Token[]);
-    get tokens(): Token[];
-    /**
-     * Fetches a pairs of token address and native currency.
-     *
-     * @param chainSlug - Chain string identifier.
-     * @param vsCurrency - Query according to tokens in tokenList and native currency.
-     * @returns The exchange rates for the given pairs.
-     */
-    fetchExchangeRate(chainSlug: string, vsCurrency: string): Promise<CoinGeckoResponse>;
-    /**
-     * Checks if the current native currency is a supported vs currency to use
-     * to query for token exchange rates.
-     *
-     * @param nativeCurrency - The native currency of the currently active network.
-     * @returns A boolean indicating whether it's a supported vsCurrency.
-     */
-    private checkIsSupportedVsCurrency;
-    /**
-     * Gets current chain ID slug from cached supported platforms CoinGecko API response.
-     * If cached supported platforms response is stale, fetches and updates it.
-     *
-     * @returns The CoinGecko slug for the current chain ID.
-     */
-    getChainSlug(): Promise<string | null>;
+    stop(): void;
     /**
      * Updates exchange rates for all tokens.
      */
     updateExchangeRates(): Promise<void>;
-    /**
-     * Checks if the active network's native currency is supported by the coingecko API.
-     * If supported, it fetches and maps contractExchange rates to a format to be consumed by the UI.
-     * If not supported, it fetches contractExchange rates and maps them from token/fallback-currency
-     * to token/nativeCurrency.
-     *
-     * @param nativeCurrency - The native currency of the currently active network.
-     * @param slug - The unique slug used to id the chain by the coingecko api
-     * should be used to query token exchange rates.
-     * @returns An object with conversion rates for each token
-     * related to the network's native currency.
-     */
-    fetchAndMapExchangeRates(nativeCurrency: string, slug: string): Promise<ContractExchangeRates>;
 }
 export default TokenRatesController;
 //# sourceMappingURL=TokenRatesController.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenRatesController.js b/node_modules/@metamask/assets-controllers/dist/TokenRatesController.js
index 4e60e4d..c529162 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenRatesController.js
+++ b/node_modules/@metamask/assets-controllers/dist/TokenRatesController.js
@@ -8,280 +8,321 @@ var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, ge
         step((generator = generator.apply(thisArg, _arguments || [])).next());
     });
 };
+var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
+    if (kind === "m") throw new TypeError("Private method is not writable");
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
+    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
+};
+var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
+    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
+};
+var _TokenRatesController_instances, _TokenRatesController_pollState, _TokenRatesController_tokenPricesService, _TokenRatesController_inProcessExchangeRateUpdates, _TokenRatesController_getTokenAddresses, _TokenRatesController_stopPoll, _TokenRatesController_poll, _TokenRatesController_fetchAndMapExchangeRates, _TokenRatesController_fetchAndMapExchangeRatesForSupportedNativeCurrency, _TokenRatesController_fetchAndMapExchangeRatesForUnsupportedNativeCurrency;
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.TokenRatesController = void 0;
 const base_controller_1 = require("@metamask/base-controller");
 const controller_utils_1 = require("@metamask/controller-utils");
+const lodash_1 = require("lodash");
+const assetsUtil_1 = require("./assetsUtil");
 const crypto_compare_1 = require("./crypto-compare");
-const CoinGeckoApi = {
-    BASE_URL: 'https://api.coingecko.com/api/v3',
-    getTokenPriceURL(chainSlug, query) {
-        return `${this.BASE_URL}/simple/token_price/${chainSlug}?${query}`;
-    },
-    getPlatformsURL() {
-        return `${this.BASE_URL}/asset_platforms`;
-    },
-    getSupportedVsCurrencies() {
-        return `${this.BASE_URL}/simple/supported_vs_currencies`;
-    },
-};
+var PollState;
+(function (PollState) {
+    PollState["Active"] = "Active";
+    PollState["Inactive"] = "Inactive";
+})(PollState || (PollState = {}));
 /**
- * Finds the chain slug in the data array given a chainId.
+ * The maximum number of token addresses that should be sent to the Price API in
+ * a single request.
+ */
+const TOKEN_PRICES_BATCH_SIZE = 30;
+/**
+ * Uses the CryptoCompare API to fetch the exchange rate between one currency
+ * and another, i.e., the multiplier to apply the amount of one currency in
+ * order to convert it to another.
  *
- * @param chainId - The current chain ID.
- * @param data - A list platforms supported by the CoinGecko API.
- * @returns The CoinGecko slug for the given chain ID, or `null` if the slug was not found.
+ * @param args - The arguments to this function.
+ * @param args.from - The currency to convert from.
+ * @param args.to - The currency to convert to.
+ * @returns The exchange rate between `fromCurrency` to `toCurrency` if one
+ * exists, or null if one does not.
  */
-function findChainSlug(chainId, data) {
-    var _a;
-    if (!data) {
-        return null;
-    }
-    const chain = (_a = data.find(({ chain_identifier }) => chain_identifier !== null && (0, controller_utils_1.toHex)(chain_identifier) === chainId)) !== null && _a !== void 0 ? _a : null;
-    return (chain === null || chain === void 0 ? void 0 : chain.id) || null;
+function getCurrencyConversionRate({ from, to, }) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const includeUSDRate = false;
+        try {
+            const result = yield (0, crypto_compare_1.fetchExchangeRate)(to, from, includeUSDRate);
+            return result.conversionRate;
+        }
+        catch (error) {
+            if (error instanceof Error &&
+                error.message.includes('market does not exist for this coin pair')) {
+                return null;
+            }
+            throw error;
+        }
+    });
 }
 /**
  * Controller that passively polls on a set interval for token-to-fiat exchange rates
  * for tokens stored in the TokensController
  */
+// This is using BaseController on BaseController v3, which relates to BaseController V1
+// When rebase this patch doesn't forget about change this to `BaseController` instead of `BaseControllerV1`
 class TokenRatesController extends base_controller_1.BaseController {
     /**
      * Creates a TokenRatesController instance.
      *
      * @param options - The controller options.
+     * @param options.interval - The polling interval in ms
+     * @param options.threshold - The duration in ms before metadata fetched from CoinGecko is considered stale
      * @param options.chainId - The chain ID of the current network.
+     * @param options.ticker - The ticker for the current network.
+     * @param options.selectedAddress - The current selected address.
+     * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.
      * @param options.onTokensStateChange - Allows subscribing to token controller state changes.
-     * @param options.onCurrencyRateStateChange - Allows subscribing to currency rate controller state changes.
      * @param options.onNetworkStateChange - Allows subscribing to network state changes.
+     * @param options.tokenPricesService - An object in charge of retrieving token prices.
      * @param config - Initial options used to configure this controller.
      * @param state - Initial state to set on this controller.
      */
-    constructor({ chainId: initialChainId, onTokensStateChange, onCurrencyRateStateChange, onNetworkStateChange, }, config, state) {
+    constructor({ interval = 3 * 60 * 1000, threshold = 6 * 60 * 60 * 1000, chainId: initialChainId, ticker: initialTicker, selectedAddress: initialSelectedAddress, onPreferencesStateChange, onTokensStateChange, onNetworkStateChange, tokenPricesService, }, config, state) {
         super(config, state);
-        this.tokenList = [];
-        this.supportedChains = {
-            timestamp: 0,
-            data: null,
-        };
-        this.supportedVsCurrencies = {
-            timestamp: 0,
-            data: [],
-        };
+        _TokenRatesController_instances.add(this);
+        _TokenRatesController_pollState.set(this, PollState.Inactive);
+        _TokenRatesController_tokenPricesService.set(this, void 0);
+        _TokenRatesController_inProcessExchangeRateUpdates.set(this, {});
         /**
          * Name of this controller used during composition
          */
         this.name = 'TokenRatesController';
         this.defaultConfig = {
+            interval,
+            threshold,
             disabled: false,
-            interval: 3 * 60 * 1000,
-            nativeCurrency: 'eth',
+            nativeCurrency: initialTicker,
             chainId: initialChainId,
-            tokens: [],
-            threshold: 6 * 60 * 60 * 1000,
+            selectedAddress: initialSelectedAddress,
+            allTokens: {},
+            allDetectedTokens: {},
         };
         this.defaultState = {
             contractExchangeRates: {},
+            contractExchangeRatesByChainId: {},
         };
         this.initialize();
+        __classPrivateFieldSet(this, _TokenRatesController_tokenPricesService, tokenPricesService, "f");
         if (config === null || config === void 0 ? void 0 : config.disabled) {
             this.configure({ disabled: true }, false, false);
         }
-        onTokensStateChange(({ tokens, detectedTokens }) => {
-            this.configure({ tokens: [...tokens, ...detectedTokens] });
-        });
-        onCurrencyRateStateChange((currencyRateState) => {
-            this.configure({ nativeCurrency: currencyRateState.nativeCurrency });
-        });
-        onNetworkStateChange(({ providerConfig }) => {
-            const { chainId } = providerConfig;
-            this.update({ contractExchangeRates: {} });
-            this.configure({ chainId });
-        });
-        this.poll();
-    }
-    /**
-     * Sets a new polling interval.
-     *
-     * @param interval - Polling interval used to fetch new token rates.
-     */
-    poll(interval) {
-        return __awaiter(this, void 0, void 0, function* () {
-            interval && this.configure({ interval }, false, false);
-            this.handle && clearTimeout(this.handle);
-            yield (0, controller_utils_1.safelyExecute)(() => this.updateExchangeRates());
-            this.handle = setTimeout(() => {
-                this.poll(this.config.interval);
-            }, this.config.interval);
-        });
-    }
-    /**
-     * Sets a new chainId.
-     *
-     * TODO: Replace this with a method.
-     *
-     * @param _chainId - The current chain ID.
-     */
-    set chainId(_chainId) {
-        !this.disabled && (0, controller_utils_1.safelyExecute)(() => this.updateExchangeRates());
-    }
-    get chainId() {
-        throw new Error('Property only used for setting');
-    }
-    /**
-     * Sets a new token list to track prices.
-     *
-     * TODO: Replace this with a method.
-     *
-     * @param tokens - List of tokens to track exchange rates for.
-     */
-    set tokens(tokens) {
-        this.tokenList = tokens;
-        !this.disabled && (0, controller_utils_1.safelyExecute)(() => this.updateExchangeRates());
-    }
-    get tokens() {
-        throw new Error('Property only used for setting');
-    }
-    /**
-     * Fetches a pairs of token address and native currency.
-     *
-     * @param chainSlug - Chain string identifier.
-     * @param vsCurrency - Query according to tokens in tokenList and native currency.
-     * @returns The exchange rates for the given pairs.
-     */
-    fetchExchangeRate(chainSlug, vsCurrency) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const tokenPairs = this.tokenList.map((token) => token.address).join(',');
-            const query = `contract_addresses=${tokenPairs}&vs_currencies=${vsCurrency.toLowerCase()}`;
-            return (0, controller_utils_1.handleFetch)(CoinGeckoApi.getTokenPriceURL(chainSlug, query));
-        });
+        onPreferencesStateChange(({ selectedAddress }) => __awaiter(this, void 0, void 0, function* () {
+            if (this.config.selectedAddress !== selectedAddress) {
+                this.configure({ selectedAddress });
+                if (__classPrivateFieldGet(this, _TokenRatesController_pollState, "f") === PollState.Active) {
+                    yield this.updateExchangeRates();
+                }
+            }
+        }));
+        onTokensStateChange(({ allTokens, allDetectedTokens }) => __awaiter(this, void 0, void 0, function* () {
+            const previousTokenAddresses = __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_getTokenAddresses).call(this, this.config.chainId);
+            this.configure({ allTokens, allDetectedTokens });
+            const newTokenAddresses = __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_getTokenAddresses).call(this, this.config.chainId);
+            if (!(0, lodash_1.isEqual)(previousTokenAddresses, newTokenAddresses) &&
+                __classPrivateFieldGet(this, _TokenRatesController_pollState, "f") === PollState.Active) {
+                yield this.updateExchangeRates();
+            }
+        }));
+        onNetworkStateChange(({ providerConfig }) => __awaiter(this, void 0, void 0, function* () {
+            const { chainId, ticker } = providerConfig;
+            if (this.config.chainId !== chainId ||
+                this.config.nativeCurrency !== ticker) {
+                this.update({ contractExchangeRates: {} });
+                this.configure({ chainId, nativeCurrency: ticker || 'ETH' });
+                if (__classPrivateFieldGet(this, _TokenRatesController_pollState, "f") === PollState.Active) {
+                    yield this.updateExchangeRates();
+                }
+            }
+        }));
     }
     /**
-     * Checks if the current native currency is a supported vs currency to use
-     * to query for token exchange rates.
-     *
-     * @param nativeCurrency - The native currency of the currently active network.
-     * @returns A boolean indicating whether it's a supported vsCurrency.
+     * Start (or restart) polling.
      */
-    checkIsSupportedVsCurrency(nativeCurrency) {
+    start() {
         return __awaiter(this, void 0, void 0, function* () {
-            const { threshold } = this.config;
-            const { timestamp, data } = this.supportedVsCurrencies;
-            const now = Date.now();
-            if (now - timestamp > threshold) {
-                const currencies = yield (0, controller_utils_1.handleFetch)(CoinGeckoApi.getSupportedVsCurrencies());
-                this.supportedVsCurrencies = {
-                    data: currencies,
-                    timestamp: Date.now(),
-                };
-                return currencies.includes(nativeCurrency.toLowerCase());
-            }
-            return data.includes(nativeCurrency.toLowerCase());
+            __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_stopPoll).call(this);
+            __classPrivateFieldSet(this, _TokenRatesController_pollState, PollState.Active, "f");
+            yield __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_poll).call(this);
         });
     }
     /**
-     * Gets current chain ID slug from cached supported platforms CoinGecko API response.
-     * If cached supported platforms response is stale, fetches and updates it.
-     *
-     * @returns The CoinGecko slug for the current chain ID.
+     * Stop polling.
      */
-    getChainSlug() {
-        return __awaiter(this, void 0, void 0, function* () {
-            const { threshold, chainId } = this.config;
-            const { data, timestamp } = this.supportedChains;
-            const now = Date.now();
-            if (now - timestamp > threshold) {
-                const platforms = yield (0, controller_utils_1.handleFetch)(CoinGeckoApi.getPlatformsURL());
-                this.supportedChains = {
-                    data: platforms,
-                    timestamp: Date.now(),
-                };
-                return findChainSlug(chainId, platforms);
-            }
-            return findChainSlug(chainId, data);
-        });
+    stop() {
+        __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_stopPoll).call(this);
+        __classPrivateFieldSet(this, _TokenRatesController_pollState, PollState.Inactive, "f");
     }
     /**
      * Updates exchange rates for all tokens.
      */
     updateExchangeRates() {
+        var _a;
         return __awaiter(this, void 0, void 0, function* () {
-            if (this.tokenList.length === 0 || this.disabled) {
+            const { chainId, nativeCurrency } = this.config;
+            if (this.disabled) {
                 return;
             }
-            const slug = yield this.getChainSlug();
-            let newContractExchangeRates = {};
-            if (!slug) {
-                this.tokenList.forEach((token) => {
-                    const address = (0, controller_utils_1.toChecksumHexAddress)(token.address);
-                    newContractExchangeRates[address] = undefined;
-                });
+            const tokenAddresses = __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_getTokenAddresses).call(this, chainId);
+            if (tokenAddresses.length === 0) {
+                return;
             }
-            else {
-                const { nativeCurrency } = this.config;
-                newContractExchangeRates = yield this.fetchAndMapExchangeRates(nativeCurrency, slug);
+            const updateKey = `${chainId}:${nativeCurrency}`;
+            if (updateKey in __classPrivateFieldGet(this, _TokenRatesController_inProcessExchangeRateUpdates, "f")) {
+                // This prevents redundant updates
+                // This promise is resolved after the in-progress update has finished,
+                // and state has been updated.
+                yield __classPrivateFieldGet(this, _TokenRatesController_inProcessExchangeRateUpdates, "f")[updateKey];
+                return;
             }
-            this.update({ contractExchangeRates: newContractExchangeRates });
-        });
-    }
-    /**
-     * Checks if the active network's native currency is supported by the coingecko API.
-     * If supported, it fetches and maps contractExchange rates to a format to be consumed by the UI.
-     * If not supported, it fetches contractExchange rates and maps them from token/fallback-currency
-     * to token/nativeCurrency.
-     *
-     * @param nativeCurrency - The native currency of the currently active network.
-     * @param slug - The unique slug used to id the chain by the coingecko api
-     * should be used to query token exchange rates.
-     * @returns An object with conversion rates for each token
-     * related to the network's native currency.
-     */
-    fetchAndMapExchangeRates(nativeCurrency, slug) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const contractExchangeRates = {};
-            // check if native currency is supported as a vs_currency by the API
-            const nativeCurrencySupported = yield this.checkIsSupportedVsCurrency(nativeCurrency);
-            if (nativeCurrencySupported) {
-                // If it is we can do a simple fetch against the CoinGecko API
-                const prices = yield this.fetchExchangeRate(slug, nativeCurrency);
-                this.tokenList.forEach((token) => {
-                    const price = prices[token.address.toLowerCase()];
-                    contractExchangeRates[(0, controller_utils_1.toChecksumHexAddress)(token.address)] = price
-                        ? price[nativeCurrency.toLowerCase()]
-                        : 0;
+            const { promise: inProgressUpdate, resolve: updateSucceeded, reject: updateFailed, } = createDeferredPromise({ suppressUnhandledRejection: true });
+            __classPrivateFieldGet(this, _TokenRatesController_inProcessExchangeRateUpdates, "f")[updateKey] = inProgressUpdate;
+            try {
+                const newContractExchangeRates = yield __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_fetchAndMapExchangeRates).call(this, {
+                    tokenAddresses,
+                    chainId,
+                    nativeCurrency,
+                });
+                const existingContractExchangeRates = this.state.contractExchangeRates;
+                const updatedContractExchangeRates = chainId === this.config.chainId &&
+                    nativeCurrency === this.config.nativeCurrency
+                    ? newContractExchangeRates
+                    : existingContractExchangeRates;
+                const existingContractExchangeRatesForChainId = (_a = this.state.contractExchangeRatesByChainId[chainId]) !== null && _a !== void 0 ? _a : {};
+                const updatedContractExchangeRatesForChainId = Object.assign(Object.assign({}, this.state.contractExchangeRatesByChainId), { [chainId]: Object.assign(Object.assign({}, existingContractExchangeRatesForChainId), { [nativeCurrency]: Object.assign(Object.assign({}, existingContractExchangeRatesForChainId[nativeCurrency]), newContractExchangeRates) }) });
+                this.update({
+                    contractExchangeRates: updatedContractExchangeRates,
+                    contractExchangeRatesByChainId: updatedContractExchangeRatesForChainId,
                 });
+                updateSucceeded();
             }
-            else {
-                // if native currency is not supported we need to use a fallback vsCurrency, get the exchange rates
-                // in token/fallback-currency format and convert them to expected token/nativeCurrency format.
-                let tokenExchangeRates;
-                let vsCurrencyToNativeCurrencyConversionRate = 0;
-                try {
-                    [
-                        tokenExchangeRates,
-                        { conversionRate: vsCurrencyToNativeCurrencyConversionRate },
-                    ] = yield Promise.all([
-                        this.fetchExchangeRate(slug, controller_utils_1.FALL_BACK_VS_CURRENCY),
-                        (0, crypto_compare_1.fetchExchangeRate)(nativeCurrency, controller_utils_1.FALL_BACK_VS_CURRENCY, false),
-                    ]);
-                }
-                catch (error) {
-                    if (error instanceof Error &&
-                        error.message.includes('market does not exist for this coin pair')) {
-                        return {};
-                    }
-                    throw error;
-                }
-                for (const [tokenAddress, conversion] of Object.entries(tokenExchangeRates)) {
-                    const tokenToVsCurrencyConversionRate = conversion[controller_utils_1.FALL_BACK_VS_CURRENCY.toLowerCase()];
-                    contractExchangeRates[(0, controller_utils_1.toChecksumHexAddress)(tokenAddress)] =
-                        tokenToVsCurrencyConversionRate *
-                            vsCurrencyToNativeCurrencyConversionRate;
-                }
+            catch (error) {
+                updateFailed(error);
+                throw error;
+            }
+            finally {
+                delete __classPrivateFieldGet(this, _TokenRatesController_inProcessExchangeRateUpdates, "f")[updateKey];
             }
-            return contractExchangeRates;
         });
     }
 }
 exports.TokenRatesController = TokenRatesController;
+_TokenRatesController_pollState = new WeakMap(), _TokenRatesController_tokenPricesService = new WeakMap(), _TokenRatesController_inProcessExchangeRateUpdates = new WeakMap(), _TokenRatesController_instances = new WeakSet(), _TokenRatesController_getTokenAddresses = function _TokenRatesController_getTokenAddresses(chainId) {
+    var _a, _b;
+    const { allTokens, allDetectedTokens } = this.config;
+    const tokens = ((_a = allTokens[chainId]) === null || _a === void 0 ? void 0 : _a[this.config.selectedAddress]) || [];
+    const detectedTokens = ((_b = allDetectedTokens[chainId]) === null || _b === void 0 ? void 0 : _b[this.config.selectedAddress]) || [];
+    return [
+        ...new Set([...tokens, ...detectedTokens].map((token) => (0, controller_utils_1.toHex)((0, controller_utils_1.toChecksumHexAddress)(token.address)))),
+    ].sort();
+}, _TokenRatesController_stopPoll = function _TokenRatesController_stopPoll() {
+    if (this.handle) {
+        clearTimeout(this.handle);
+    }
+}, _TokenRatesController_poll = function _TokenRatesController_poll() {
+    return __awaiter(this, void 0, void 0, function* () {
+        yield (0, controller_utils_1.safelyExecute)(() => this.updateExchangeRates());
+        // Poll using recursive `setTimeout` instead of `setInterval` so that
+        // requests don't stack if they take longer than the polling interval
+        this.handle = setTimeout(() => {
+            __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_poll).call(this);
+        }, this.config.interval);
+    });
+}, _TokenRatesController_fetchAndMapExchangeRates = function _TokenRatesController_fetchAndMapExchangeRates({ tokenAddresses, chainId, nativeCurrency, }) {
+    return __awaiter(this, void 0, void 0, function* () {
+        if (!__classPrivateFieldGet(this, _TokenRatesController_tokenPricesService, "f").validateChainIdSupported(chainId)) {
+            return tokenAddresses.reduce((obj, tokenAddress) => {
+                return Object.assign(Object.assign({}, obj), { [tokenAddress]: undefined });
+            }, {});
+        }
+        if (__classPrivateFieldGet(this, _TokenRatesController_tokenPricesService, "f").validateCurrencySupported(nativeCurrency)) {
+            return yield __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_fetchAndMapExchangeRatesForSupportedNativeCurrency).call(this, {
+                tokenAddresses,
+                chainId,
+                nativeCurrency,
+            });
+        }
+        return yield __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_fetchAndMapExchangeRatesForUnsupportedNativeCurrency).call(this, {
+            tokenAddresses,
+            nativeCurrency,
+        });
+    });
+}, _TokenRatesController_fetchAndMapExchangeRatesForSupportedNativeCurrency = function _TokenRatesController_fetchAndMapExchangeRatesForSupportedNativeCurrency({ tokenAddresses, chainId, nativeCurrency, }) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const tokenPricesByTokenAddress = yield (0, assetsUtil_1.reduceInBatchesSerially)({
+            values: [...tokenAddresses].sort(),
+            batchSize: TOKEN_PRICES_BATCH_SIZE,
+            eachBatch: (allTokenPricesByTokenAddress, batch) => __awaiter(this, void 0, void 0, function* () {
+                const tokenPricesByTokenAddressForBatch = yield __classPrivateFieldGet(this, _TokenRatesController_tokenPricesService, "f").fetchTokenPrices({
+                    tokenAddresses: batch,
+                    chainId,
+                    currency: nativeCurrency,
+                });
+                return Object.assign(Object.assign({}, allTokenPricesByTokenAddress), tokenPricesByTokenAddressForBatch);
+            }),
+            initialResult: {},
+        });
+        return Object.entries(tokenPricesByTokenAddress).reduce((obj, [tokenAddress, tokenPrice]) => {
+            return Object.assign(Object.assign({}, obj), { [tokenAddress]: tokenPrice.value });
+        }, {});
+    });
+}, _TokenRatesController_fetchAndMapExchangeRatesForUnsupportedNativeCurrency = function _TokenRatesController_fetchAndMapExchangeRatesForUnsupportedNativeCurrency({ tokenAddresses, nativeCurrency, }) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const [contractExchangeRates, fallbackCurrencyToNativeCurrencyConversionRate,] = yield Promise.all([
+            __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_fetchAndMapExchangeRatesForSupportedNativeCurrency).call(this, {
+                tokenAddresses,
+                chainId:  this.config.chainId,
+                nativeCurrency: controller_utils_1.FALL_BACK_VS_CURRENCY,
+            }),
+            getCurrencyConversionRate({
+                from: controller_utils_1.FALL_BACK_VS_CURRENCY,
+                to: nativeCurrency,
+            }),
+        ]);
+        if (fallbackCurrencyToNativeCurrencyConversionRate === null) {
+            return {};
+        }
+        return Object.entries(contractExchangeRates).reduce((obj, [tokenAddress, tokenValue]) => {
+            return Object.assign(Object.assign({}, obj), { [tokenAddress]: tokenValue
+                    ? tokenValue * fallbackCurrencyToNativeCurrencyConversionRate
+                    : undefined });
+        }, {});
+    });
+};
+/**
+ * Create a defered Promise.
+ *
+ * TODO: Migrate this to utils
+ *
+ * @param args - The arguments.
+ * @param args.suppressUnhandledRejection - This option adds an empty error handler
+ * to the Promise to suppress the UnhandledPromiseRejection error. This can be
+ * useful if the deferred Promise is sometimes intentionally not used.
+ * @returns A deferred Promise.
+ */
+function createDeferredPromise({ suppressUnhandledRejection = false, }) {
+    let resolve;
+    let reject;
+    const promise = new Promise((innerResolve, innerReject) => {
+        resolve = innerResolve;
+        reject = innerReject;
+    });
+    if (suppressUnhandledRejection) {
+        promise.catch((_error) => {
+            // This handler is used to suppress the UnhandledPromiseRejection error
+        });
+    }
+    // @ts-expect-error We know that these are assigned, but TypeScript doesn't
+    return { promise, resolve, reject };
+}
 exports.default = TokenRatesController;
 //# sourceMappingURL=TokenRatesController.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/TokensController.js b/node_modules/@metamask/assets-controllers/dist/TokensController.js
index e630b79..0d67362 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokensController.js
+++ b/node_modules/@metamask/assets-controllers/dist/TokensController.js
@@ -43,8 +43,9 @@ class TokensController extends base_controller_1.BaseController {
      * @param options.config - Initial options used to configure this controller.
      * @param options.state - Initial state to set on this controller.
      * @param options.messenger - The controller messenger.
+     * @param options.getERC20TokenName - Allows fetch an ERC-20 token name
      */
-    constructor({ chainId: initialChainId, onPreferencesStateChange, onNetworkStateChange, config, state, messenger, }) {
+    constructor({ chainId: initialChainId, onPreferencesStateChange, onNetworkStateChange, config, state, messenger, getERC20TokenName}) {
         super(config, state);
         this.mutex = new async_mutex_1.Mutex();
         /**
@@ -60,6 +61,7 @@ class TokensController extends base_controller_1.BaseController {
         this.initialize();
         this.abortController = new abort_controller_1.AbortController();
         this.messagingSystem = messenger;
+        this.getERC20TokenName = getERC20TokenName;
         onPreferencesStateChange(({ selectedAddress }) => {
             var _a, _b, _c;
             const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
@@ -118,11 +120,13 @@ class TokensController extends base_controller_1.BaseController {
      * @param address - Hex address of the token contract.
      * @param symbol - Symbol of the token.
      * @param decimals - Number of decimals the token uses.
-     * @param image - Image of the token.
-     * @param interactingAddress - The address of the account to add a token to.
+     * @param options - Object containing name and image of the token
+     * @param options.name - Name of the token
+     * @param options.image - Image of the token
+     * @param options.interactingAddress - The address of the account to add a token to.
      * @returns Current token list.
      */
-    addToken(address, symbol, decimals, image, interactingAddress) {
+    addToken(address, symbol, decimals, { name, image, interactingAddress }) {
         var _a, _b, _c;
         return __awaiter(this, void 0, void 0, function* () {
             const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
@@ -154,6 +158,7 @@ class TokensController extends base_controller_1.BaseController {
                         }),
                     isERC721,
                     aggregators: (0, assetsUtil_1.formatAggregatorNames)((tokenMetadata === null || tokenMetadata === void 0 ? void 0 : tokenMetadata.aggregators) || []),
+                    name
                 };
                 const previousEntry = newTokens.find((token) => token.address.toLowerCase() === address.toLowerCase());
                 if (previousEntry) {
@@ -205,7 +210,7 @@ class TokensController extends base_controller_1.BaseController {
             }, {});
             try {
                 tokensToImport.forEach((tokenToAdd) => {
-                    const { address, symbol, decimals, image, aggregators } = tokenToAdd;
+                    const { address, symbol, decimals, image, aggregators, name } = tokenToAdd;
                     const checksumAddress = (0, controller_utils_1.toChecksumHexAddress)(address);
                     const formattedToken = {
                         address: checksumAddress,
@@ -213,6 +218,7 @@ class TokensController extends base_controller_1.BaseController {
                         decimals,
                         image,
                         aggregators,
+                        name
                     };
                     newTokensMap[address] = formattedToken;
                     importedTokensMap[address.toLowerCase()] = true;
@@ -288,7 +294,7 @@ class TokensController extends base_controller_1.BaseController {
             let newDetectedTokens = [...detectedTokens];
             try {
                 incomingDetectedTokens.forEach((tokenToAdd) => {
-                    const { address, symbol, decimals, image, aggregators, isERC721 } = tokenToAdd;
+                    const { address, symbol, decimals, image, aggregators, isERC721, name } = tokenToAdd;
                     const checksumAddress = (0, controller_utils_1.toChecksumHexAddress)(address);
                     const newEntry = {
                         address: checksumAddress,
@@ -297,6 +303,7 @@ class TokensController extends base_controller_1.BaseController {
                         image,
                         isERC721,
                         aggregators,
+                        name
                     };
                     const previousImportedEntry = newTokens.find((token) => token.address.toLowerCase() === checksumAddress.toLowerCase());
                     if (previousImportedEntry) {
@@ -363,6 +370,22 @@ class TokensController extends base_controller_1.BaseController {
             return tokens[tokenIndex];
         });
     }
+
+    /**
+     * This is a function that updates the tokens name for the tokens name if it is not defined
+     * @param tokenList - Represents the fetched token list from service API
+     */
+    async updateTokensName(tokenList) {
+        const { tokens } = this.state;
+
+        const newTokens = tokens.map((token) => {
+            const newToken = tokenList[token.address.toLowerCase()];
+          return (!token.name && newToken?.name) ? { ...token, name: newToken.name } : {...token};
+        });
+
+        this.update({ tokens: newTokens });
+    }
+
     /**
      * Detects whether or not a token is ERC-721 compatible.
      *
@@ -426,7 +449,17 @@ class TokensController extends base_controller_1.BaseController {
             };
             (0, assetsUtil_1.validateTokenToWatch)(asset);
             yield this._requestApproval(suggestedAssetMeta);
-            yield this.addToken(asset.address, asset.symbol, asset.decimals, asset.image, suggestedAssetMeta.interactingAddress);
+            let name;
+            try{
+                name = yield this.getERC20TokenName(asset.address);
+            } catch (error) {
+                name = undefined;
+            }
+            yield this.addToken(asset.address, asset.symbol, asset.decimals, {
+                name,
+                image: asset.image,
+                interactingAddress: suggestedAssetMeta.interactingAddress,
+              });
         });
     }
     /**
diff --git a/node_modules/@metamask/assets-controllers/dist/assetsUtil.js b/node_modules/@metamask/assets-controllers/dist/assetsUtil.js
index ef7b7e3..8ba8475 100644
--- a/node_modules/@metamask/assets-controllers/dist/assetsUtil.js
+++ b/node_modules/@metamask/assets-controllers/dist/assetsUtil.js
@@ -121,6 +121,8 @@ var SupportedTokenDetectionNetworks;
     SupportedTokenDetectionNetworks["polygon"] = "0x89";
     SupportedTokenDetectionNetworks["avax"] = "0xa86a";
     SupportedTokenDetectionNetworks["aurora"] = "0x4e454152";
+    SupportedTokenDetectionNetworks["linea_goerli"] = "0xe704";
+    SupportedTokenDetectionNetworks["linea_mainnet"] = "0xe708";
 })(SupportedTokenDetectionNetworks = exports.SupportedTokenDetectionNetworks || (exports.SupportedTokenDetectionNetworks = {}));
 /**
  * Check if token detection is enabled for certain networks.
@@ -224,4 +226,128 @@ function ethersBigNumberToBN(bigNumber) {
     return new ethereumjs_util_1.BN((0, ethereumjs_util_1.stripHexPrefix)(bigNumber.toHexString()), 'hex');
 }
 exports.ethersBigNumberToBN = ethersBigNumberToBN;
+/**
+ * Partitions a list of values into groups that are at most `batchSize` in
+ * length.
+ *
+ * @param values - The list of values.
+ * @param args - The remaining arguments.
+ * @param args.batchSize - The desired maximum number of values per batch.
+ * @returns The list of batches.
+ */
+function divideIntoBatches(values, { batchSize }) {
+    const batches = [];
+    for (let i = 0; i < values.length; i += batchSize) {
+        batches.push(values.slice(i, i + batchSize));
+    }
+    return batches;
+}
+exports.divideIntoBatches = divideIntoBatches;
+/**
+ * Constructs an object from processing batches of the given values
+ * sequentially.
+ *
+ * @param args - The arguments to this function.
+ * @param args.values - A list of values to iterate over.
+ * @param args.batchSize - The maximum number of values in each batch.
+ * @param args.eachBatch - A function to call for each batch. This function is
+ * similar to the function that `Array.prototype.reduce` takes, in that it
+ * receives the object that is being built, each batch in the list of batches
+ * and the index, and should return an updated version of the object.
+ * @param args.initialResult - The initial value of the final data structure,
+ * i.e., the value that will be fed into the first call of `eachBatch`.
+ * @returns The built object.
+ */
+function reduceInBatchesSerially({ values, batchSize, eachBatch, initialResult, }) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const batches = divideIntoBatches(values, { batchSize });
+        let workingResult = initialResult;
+        for (const [index, batch] of batches.entries()) {
+            workingResult = yield eachBatch(workingResult, batch, index);
+        }
+        // There's no way around this — we have to assume that in the end, the result
+        // matches the intended type.
+        const finalResult = workingResult;
+        return finalResult;
+    });
+}
+exports.reduceInBatchesSerially = reduceInBatchesSerially;
+/**
+ * Maps an OpenSea V2 NFT to the V1 schema.
+ * @param nft - The V2 NFT to map.
+ * @returns The NFT in the V1 schema.
+ */
+function mapOpenSeaNftV2ToV1(nft) {
+    var _a;
+    return {
+        token_id: nft.identifier,
+        num_sales: null,
+        background_color: null,
+        image_url: (_a = nft.image_url) !== null && _a !== void 0 ? _a : null,
+        image_preview_url: null,
+        image_thumbnail_url: null,
+        image_original_url: null,
+        animation_url: null,
+        animation_original_url: null,
+        name: nft.name,
+        description: nft.description,
+        external_link: null,
+        asset_contract: {
+            address: nft.contract,
+            asset_contract_type: null,
+            created_date: null,
+            schema_name: nft.token_standard.toUpperCase(),
+            symbol: null,
+            total_supply: null,
+            description: nft.description,
+            external_link: null,
+            collection: {
+                name: nft.collection,
+                image_url: null,
+            },
+        },
+        creator: {
+            user: { username: '' },
+            profile_img_url: '',
+            address: '',
+        },
+        last_sale: null,
+    };
+}
+exports.mapOpenSeaNftV2ToV1 = mapOpenSeaNftV2ToV1;
+/**
+ * Maps an OpenSea V2 detailed NFT to the V1 schema.
+ * @param nft - The V2 detailed NFT to map.
+ * @returns The NFT in the V1 schema.
+ */
+function mapOpenSeaDetailedNftV2ToV1(nft) {
+    var _a;
+    const mapped = mapOpenSeaNftV2ToV1(nft);
+    return Object.assign(Object.assign({}, mapped), { animation_url: (_a = nft.animation_url) !== null && _a !== void 0 ? _a : null, creator: Object.assign(Object.assign({}, mapped.creator), { address: nft.creator }) });
+}
+exports.mapOpenSeaDetailedNftV2ToV1 = mapOpenSeaDetailedNftV2ToV1;
+/**
+ * Maps an OpenSea V2 contract to the V1 schema.
+ * @param contract - The v2 contract data.
+ * @param collection - The v2 collection data.
+ * @returns The contract in the v1 schema.
+ */
+function mapOpenSeaContractV2ToV1(contract, collection) {
+    var _a, _b, _c, _d, _e, _f, _g;
+    return {
+        address: contract.address,
+        asset_contract_type: null,
+        created_date: null,
+        schema_name: contract.contract_standard.toUpperCase(),
+        symbol: null,
+        total_supply: (_d = (_b = (_a = collection === null || collection === void 0 ? void 0 : collection.total_supply) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : (_c = contract.total_supply) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : null,
+        description: (_e = collection === null || collection === void 0 ? void 0 : collection.description) !== null && _e !== void 0 ? _e : null,
+        external_link: (_f = collection === null || collection === void 0 ? void 0 : collection.project_url) !== null && _f !== void 0 ? _f : null,
+        collection: {
+            name: (_g = collection === null || collection === void 0 ? void 0 : collection.name) !== null && _g !== void 0 ? _g : contract.name,
+            image_url: collection === null || collection === void 0 ? void 0 : collection.image_url,
+        },
+    };
+}
+exports.mapOpenSeaContractV2ToV1 = mapOpenSeaContractV2ToV1;
 //# sourceMappingURL=assetsUtil.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/index.d.ts b/node_modules/@metamask/assets-controllers/dist/index.d.ts
index 9526321..5f08fce 100644
--- a/node_modules/@metamask/assets-controllers/dist/index.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/index.d.ts
@@ -9,4 +9,5 @@ export * from './TokenListController';
 export * from './TokenRatesController';
 export * from './TokensController';
 export { isTokenDetectionSupportedForNetwork, formatIconUrlWithProxy, getFormattedIpfsUrl, } from './assetsUtil';
+export { CodefiTokenPricesServiceV2 } from './token-prices-service';
 //# sourceMappingURL=index.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/index.js b/node_modules/@metamask/assets-controllers/dist/index.js
index d4d8682..96d7224 100644
--- a/node_modules/@metamask/assets-controllers/dist/index.js
+++ b/node_modules/@metamask/assets-controllers/dist/index.js
@@ -29,4 +29,6 @@ var assetsUtil_1 = require("./assetsUtil");
 Object.defineProperty(exports, "isTokenDetectionSupportedForNetwork", { enumerable: true, get: function () { return assetsUtil_1.isTokenDetectionSupportedForNetwork; } });
 Object.defineProperty(exports, "formatIconUrlWithProxy", { enumerable: true, get: function () { return assetsUtil_1.formatIconUrlWithProxy; } });
 Object.defineProperty(exports, "getFormattedIpfsUrl", { enumerable: true, get: function () { return assetsUtil_1.getFormattedIpfsUrl; } });
+var token_prices_service_1 = require("./token-prices-service");
+Object.defineProperty(exports, "CodefiTokenPricesServiceV2", { enumerable: true, get: function () { return token_prices_service_1.CodefiTokenPricesServiceV2; } });
 //# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/index.js.map b/node_modules/@metamask/assets-controllers/dist/index.js.map
index ea0eaab..e528b48 100644
--- a/node_modules/@metamask/assets-controllers/dist/index.js.map
+++ b/node_modules/@metamask/assets-controllers/dist/index.js.map
@@ -1 +1 @@
-{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAAA,6DAA2C;AAC3C,6DAA2C;AAC3C,2DAAyC;AACzC,kDAAgC;AAChC,2DAAyC;AACzC,4DAA0C;AAC1C,6DAA2C;AAC3C,wDAAsC;AACtC,yDAAuC;AACvC,qDAAmC;AACnC,2CAIsB;AAHpB,iIAAA,mCAAmC,OAAA;AACnC,oHAAA,sBAAsB,OAAA;AACtB,iHAAA,mBAAmB,OAAA","sourcesContent":["export * from './AccountTrackerController';\nexport * from './AssetsContractController';\nexport * from './CurrencyRateController';\nexport * from './NftController';\nexport * from './NftDetectionController';\nexport * from './TokenBalancesController';\nexport * from './TokenDetectionController';\nexport * from './TokenListController';\nexport * from './TokenRatesController';\nexport * from './TokensController';\nexport {\n  isTokenDetectionSupportedForNetwork,\n  formatIconUrlWithProxy,\n  getFormattedIpfsUrl,\n} from './assetsUtil';\n"]}
\ No newline at end of file
+{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAAA,6DAA2C;AAC3C,6DAA2C;AAC3C,2DAAyC;AACzC,kDAAgC;AAChC,2DAAyC;AACzC,4DAA0C;AAC1C,6DAA2C;AAC3C,wDAAsC;AACtC,yDAAuC;AACvC,qDAAmC;AACnC,2CAIsB;AAHpB,iIAAA,mCAAmC,OAAA;AACnC,oHAAA,sBAAsB,OAAA;AACtB,iHAAA,mBAAmB,OAAA","sourcesContent":["export * from './AccountTrackerController';\nexport * from './AssetsContractController';\nexport * from './CurrencyRateController';\nexport * from './NftController';\nexport * from './NftDetectionController';\nexport * from './TokenBalancesController';\nexport * from './TokenDetectionController';\nexport * from './TokenListController';\nexport * from './TokenRatesController';\nexport * from './TokensController';\nexport {\n  isTokenDetectionSupportedForNetwork,\n  formatIconUrlWithProxy,\n  getFormattedIpfsUrl,\n} from './assetsUtil';\nexport { CodefiTokenPricesServiceV2 } from './token-prices-service';\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-prices-service/abstract-token-prices-service.d.ts b/node_modules/@metamask/assets-controllers/dist/token-prices-service/abstract-token-prices-service.d.ts
new file mode 100644
index 0000000..db39f97
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/token-prices-service/abstract-token-prices-service.d.ts
@@ -0,0 +1,62 @@
+import type { Hex } from '@metamask/utils';
+/**
+ * Represents the price of a token in a currency.
+ */
+export declare type TokenPrice<TokenAddress extends Hex, Currency extends string> = {
+    tokenAddress: TokenAddress;
+    value: number;
+    currency: Currency;
+};
+/**
+ * A map of token address to its price.
+ */
+export declare type TokenPricesByTokenAddress<TokenAddress extends Hex, Currency extends string> = {
+    [A in TokenAddress]: TokenPrice<A, Currency>;
+};
+/**
+ * An ideal token prices service. All implementations must confirm to this
+ * interface.
+ *
+ * @template ChainId - A type union of valid arguments for the `chainId`
+ * argument to `fetchTokenPrices`.
+ * @template TokenAddress - A type union of all token addresses. The reason this
+ * type parameter exists is so that we can guarantee that same addresses that
+ * `fetchTokenPrices` receives are the same addresses that shown up in the
+ * return value.
+ * @template Currency - A type union of valid arguments for the `currency`
+ * argument to `fetchTokenPrices`.
+ */
+export declare type AbstractTokenPricesService<ChainId extends string = string, TokenAddress extends Hex = Hex, Currency extends string = string> = {
+    /**
+     * Retrieves prices in the given currency for the tokens identified by the
+     * given addresses which are expected to live on the given chain.
+     *
+     * @param args - The arguments to this function.
+     * @param args.chainId - An EIP-155 chain ID.
+     * @param args.tokenAddresses - Addresses for tokens that live on the chain.
+     * @param args.currency - The desired currency of the token prices.
+     * @returns The prices for the requested tokens.
+     */
+    fetchTokenPrices({ chainId, tokenAddresses, currency, }: {
+        chainId: ChainId;
+        tokenAddresses: TokenAddress[];
+        currency: Currency;
+    }): Promise<TokenPricesByTokenAddress<TokenAddress, Currency>>;
+    /**
+     * Type guard for whether the API can return token prices for the given chain
+     * ID.
+     *
+     * @param chainId - The chain ID to check.
+     * @returns True if the API supports the chain ID, false otherwise.
+     */
+    validateChainIdSupported(chainId: unknown): chainId is ChainId;
+    /**
+     * Type guard for whether the API can return token prices in the given
+     * currency.
+     *
+     * @param currency - The currency to check.
+     * @returns True if the API supports the currency, false otherwise.
+     */
+    validateCurrencySupported(currency: unknown): currency is Currency;
+};
+//# sourceMappingURL=abstract-token-prices-service.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-prices-service/abstract-token-prices-service.d.ts.map b/node_modules/@metamask/assets-controllers/dist/token-prices-service/abstract-token-prices-service.d.ts.map
new file mode 100644
index 0000000..a6de776
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/token-prices-service/abstract-token-prices-service.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"abstract-token-prices-service.d.ts","sourceRoot":"","sources":["../../src/token-prices-service/abstract-token-prices-service.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,GAAG,EAAE,MAAM,iBAAiB,CAAC;AAE3C;;GAEG;AACH,oBAAY,UAAU,CAAC,YAAY,SAAS,GAAG,EAAE,QAAQ,SAAS,MAAM,IAAI;IAC1E,YAAY,EAAE,YAAY,CAAC;IAC3B,KAAK,EAAE,MAAM,CAAC;IACd,QAAQ,EAAE,QAAQ,CAAC;CACpB,CAAC;AAEF;;GAEG;AACH,oBAAY,yBAAyB,CACnC,YAAY,SAAS,GAAG,EACxB,QAAQ,SAAS,MAAM,IACrB;KACD,CAAC,IAAI,YAAY,GAAG,UAAU,CAAC,CAAC,EAAE,QAAQ,CAAC;CAC7C,CAAC;AAEF;;;;;;;;;;;;GAYG;AACH,oBAAY,0BAA0B,CACpC,OAAO,SAAS,MAAM,GAAG,MAAM,EAC/B,YAAY,SAAS,GAAG,GAAG,GAAG,EAC9B,QAAQ,SAAS,MAAM,GAAG,MAAM,IAC9B;IACF;;;;;;;;;OASG;IACH,gBAAgB,CAAC,EACf,OAAO,EACP,cAAc,EACd,QAAQ,GACT,EAAE;QACD,OAAO,EAAE,OAAO,CAAC;QACjB,cAAc,EAAE,YAAY,EAAE,CAAC;QAC/B,QAAQ,EAAE,QAAQ,CAAC;KACpB,GAAG,OAAO,CAAC,yBAAyB,CAAC,YAAY,EAAE,QAAQ,CAAC,CAAC,CAAC;IAE/D;;;;;;OAMG;IACH,wBAAwB,CAAC,OAAO,EAAE,OAAO,GAAG,OAAO,IAAI,OAAO,CAAC;IAE/D;;;;;;OAMG;IACH,yBAAyB,CAAC,QAAQ,EAAE,OAAO,GAAG,QAAQ,IAAI,QAAQ,CAAC;CACpE,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-prices-service/abstract-token-prices-service.js b/node_modules/@metamask/assets-controllers/dist/token-prices-service/abstract-token-prices-service.js
new file mode 100644
index 0000000..6b79d8f
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/token-prices-service/abstract-token-prices-service.js
@@ -0,0 +1,3 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+//# sourceMappingURL=abstract-token-prices-service.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-prices-service/abstract-token-prices-service.js.map b/node_modules/@metamask/assets-controllers/dist/token-prices-service/abstract-token-prices-service.js.map
new file mode 100644
index 0000000..dc7bdb4
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/token-prices-service/abstract-token-prices-service.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"abstract-token-prices-service.js","sourceRoot":"","sources":["../../src/token-prices-service/abstract-token-prices-service.ts"],"names":[],"mappings":"","sourcesContent":["import type { Hex } from '@metamask/utils';\n\n/**\n * Represents the price of a token in a currency.\n */\nexport type TokenPrice<TokenAddress extends Hex, Currency extends string> = {\n  tokenAddress: TokenAddress;\n  value: number;\n  currency: Currency;\n};\n\n/**\n * A map of token address to its price.\n */\nexport type TokenPricesByTokenAddress<\n  TokenAddress extends Hex,\n  Currency extends string,\n> = {\n  [A in TokenAddress]: TokenPrice<A, Currency>;\n};\n\n/**\n * An ideal token prices service. All implementations must confirm to this\n * interface.\n *\n * @template ChainId - A type union of valid arguments for the `chainId`\n * argument to `fetchTokenPrices`.\n * @template TokenAddress - A type union of all token addresses. The reason this\n * type parameter exists is so that we can guarantee that same addresses that\n * `fetchTokenPrices` receives are the same addresses that shown up in the\n * return value.\n * @template Currency - A type union of valid arguments for the `currency`\n * argument to `fetchTokenPrices`.\n */\nexport type AbstractTokenPricesService<\n  ChainId extends string = string,\n  TokenAddress extends Hex = Hex,\n  Currency extends string = string,\n> = {\n  /**\n   * Retrieves prices in the given currency for the tokens identified by the\n   * given addresses which are expected to live on the given chain.\n   *\n   * @param args - The arguments to this function.\n   * @param args.chainId - An EIP-155 chain ID.\n   * @param args.tokenAddresses - Addresses for tokens that live on the chain.\n   * @param args.currency - The desired currency of the token prices.\n   * @returns The prices for the requested tokens.\n   */\n  fetchTokenPrices({\n    chainId,\n    tokenAddresses,\n    currency,\n  }: {\n    chainId: ChainId;\n    tokenAddresses: TokenAddress[];\n    currency: Currency;\n  }): Promise<TokenPricesByTokenAddress<TokenAddress, Currency>>;\n\n  /**\n   * Type guard for whether the API can return token prices for the given chain\n   * ID.\n   *\n   * @param chainId - The chain ID to check.\n   * @returns True if the API supports the chain ID, false otherwise.\n   */\n  validateChainIdSupported(chainId: unknown): chainId is ChainId;\n\n  /**\n   * Type guard for whether the API can return token prices in the given\n   * currency.\n   *\n   * @param currency - The currency to check.\n   * @returns True if the API supports the currency, false otherwise.\n   */\n  validateCurrencySupported(currency: unknown): currency is Currency;\n};\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-prices-service/codefi-v2.d.ts b/node_modules/@metamask/assets-controllers/dist/token-prices-service/codefi-v2.d.ts
new file mode 100644
index 0000000..7e39d69
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/token-prices-service/codefi-v2.d.ts
@@ -0,0 +1,80 @@
+import type { Hex } from '@metamask/utils';
+import type { AbstractTokenPricesService, TokenPricesByTokenAddress } from './abstract-token-prices-service';
+/**
+ * The list of currencies that can be supplied as the `vsCurrency` parameter to
+ * the `/spot-prices` endpoint, in lowercase form.
+ */
+export declare const SUPPORTED_CURRENCIES: readonly ["btc", "eth", "ltc", "bch", "bnb", "eos", "xrp", "xlm", "link", "dot", "yfi", "usd", "aed", "ars", "aud", "bdt", "bhd", "bmd", "brl", "cad", "chf", "clp", "cny", "czk", "dkk", "eur", "gbp", "hkd", "huf", "idr", "ils", "inr", "jpy", "krw", "kwd", "lkr", "mmk", "mxn", "myr", "ngn", "nok", "nzd", "php", "pkr", "pln", "rub", "sar", "sek", "sgd", "thb", "try", "twd", "uah", "vef", "vnd", "zar", "xdr", "xag", "xau", "bits", "sats"];
+/**
+ * A currency that can be supplied as the `vsCurrency` parameter to
+ * the `/spot-prices` endpoint. Covers both uppercase and lowercase versions.
+ */
+declare type SupportedCurrency = (typeof SUPPORTED_CURRENCIES)[number] | Uppercase<(typeof SUPPORTED_CURRENCIES)[number]>;
+/**
+ * The list of chain IDs that can be supplied in the URL for the `/spot-prices`
+ * endpoint, but in hexadecimal form (for consistency with how we represent
+ * chain IDs in other places).
+ */
+export declare const SUPPORTED_CHAIN_IDS: readonly ["1", "10", "25", "56", "57", "66", "70", "82", "88", "100", "106", "122", "128", "137", "250", "288", "321", "328", "361", "1088", "1284", "1285", "8453", "336", "10000", "42161", "42220", "42294", "43114", "535824", "1313161554", "1666600000"];
+/**
+ * A chain ID that can be supplied in the URL for the `/spot-prices` endpoint,
+ * but in hexadecimal form (for consistency with how we represent chain IDs in
+ * other places).
+ */
+declare type SupportedChainId = (typeof SUPPORTED_CHAIN_IDS)[number];
+/**
+ * This version of the token prices service uses V2 of the Codefi Price API to
+ * fetch token prices.
+ */
+export declare class CodefiTokenPricesServiceV2 implements AbstractTokenPricesService<SupportedChainId, Hex, SupportedCurrency> {
+    #private;
+    /**
+     * Construct a Codefi Token Price Service.
+     *
+     * @param options - Constructor options
+     * @param options.retries - Number of retry attempts for each token price update.
+     * @param options.maximumConsecutiveFailures - The maximum number of consecutive failures
+     * allowed before breaking the circuit and pausing further updates.
+     * @param options.circuitBreakDuration - The amount of time to wait when the circuit breaks
+     * from too many consecutive failures.
+     */
+    constructor({ retries, maximumConsecutiveFailures, circuitBreakDuration, }?: {
+        retries?: number;
+        maximumConsecutiveFailures?: number;
+        circuitBreakDuration?: number;
+    });
+    /**
+     * Retrieves prices in the given currency for the tokens identified by the
+     * given addresses which are expected to live on the given chain.
+     *
+     * @param args - The arguments to function.
+     * @param args.chainId - An EIP-155 chain ID.
+     * @param args.tokenAddresses - Addresses for tokens that live on the chain.
+     * @param args.currency - The desired currency of the token prices.
+     * @returns The prices for the requested tokens.
+     */
+    fetchTokenPrices({ chainId, tokenAddresses, currency, }: {
+        chainId: SupportedChainId;
+        tokenAddresses: Hex[];
+        currency: SupportedCurrency;
+    }): Promise<TokenPricesByTokenAddress<Hex, SupportedCurrency>>;
+    /**
+     * Type guard for whether the API can return token prices for the given chain
+     * ID.
+     *
+     * @param chainId - The chain ID to check.
+     * @returns True if the API supports the chain ID, false otherwise.
+     */
+    validateChainIdSupported(chainId: unknown): chainId is SupportedChainId;
+    /**
+     * Type guard for whether the API can return token prices in the given
+     * currency.
+     *
+     * @param currency - The currency to check. If a string, can be either
+     * lowercase or uppercase.
+     * @returns True if the API supports the currency, false otherwise.
+     */
+    validateCurrencySupported(currency: unknown): currency is SupportedCurrency;
+}
+export {};
+//# sourceMappingURL=codefi-v2.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-prices-service/codefi-v2.d.ts.map b/node_modules/@metamask/assets-controllers/dist/token-prices-service/codefi-v2.d.ts.map
new file mode 100644
index 0000000..dee2179
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/token-prices-service/codefi-v2.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"codefi-v2.d.ts","sourceRoot":"","sources":["../../src/token-prices-service/codefi-v2.ts"],"names":[],"mappings":"AACA,OAAO,KAAK,EAAE,GAAG,EAAE,MAAM,iBAAiB,CAAC;AAY3C,OAAO,KAAK,EACV,0BAA0B,EAE1B,yBAAyB,EAC1B,MAAM,iCAAiC,CAAC;AAUzC;;;GAGG;AACH,eAAO,MAAM,oBAAoB,ybA2HvB,CAAC;AAEX;;;GAGG;AACH,aAAK,iBAAiB,GAClB,CAAC,OAAO,oBAAoB,CAAC,CAAC,MAAM,CAAC,GACrC,SAAS,CAAC,CAAC,OAAO,oBAAoB,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;AAErD;;;;GAIG;AACH,eAAO,MAAM,mBAAmB,gQAkEtB,CAAC;AAEX;;;;GAIG;AACH,aAAK,gBAAgB,GAAG,CAAC,OAAO,mBAAmB,CAAC,CAAC,MAAM,CAAC,CAAC;AAY7D;;;GAGG;AACH,qBAAa,0BACX,YACE,0BAA0B,CAAC,gBAAgB,EAAE,GAAG,EAAE,iBAAiB,CAAC;;IAItE;;;;;;;;;OASG;gBACS,EACV,OAAqC,EACrC,0BAAyE,EACzE,oBAAqC,GACtC,GAAE;QACD,OAAO,CAAC,EAAE,MAAM,CAAC;QACjB,0BAA0B,CAAC,EAAE,MAAM,CAAC;QACpC,oBAAoB,CAAC,EAAE,MAAM,CAAC;KAC1B;IAcN;;;;;;;;;OASG;IACG,gBAAgB,CAAC,EACrB,OAAO,EACP,cAAc,EACd,QAAQ,GACT,EAAE;QACD,OAAO,EAAE,gBAAgB,CAAC;QAC1B,cAAc,EAAE,GAAG,EAAE,CAAC;QACtB,QAAQ,EAAE,iBAAiB,CAAC;KAC7B,GAAG,OAAO,CAAC,yBAAyB,CAAC,GAAG,EAAE,iBAAiB,CAAC,CAAC;IA+C9D;;;;;;OAMG;IACH,wBAAwB,CAAC,OAAO,EAAE,OAAO,GAAG,OAAO,IAAI,gBAAgB;IAKvE;;;;;;;OAOG;IACH,yBAAyB,CAAC,QAAQ,EAAE,OAAO,GAAG,QAAQ,IAAI,iBAAiB;CAO5E"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-prices-service/codefi-v2.js b/node_modules/@metamask/assets-controllers/dist/token-prices-service/codefi-v2.js
new file mode 100644
index 0000000..472bc07
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/token-prices-service/codefi-v2.js
@@ -0,0 +1,328 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
+    if (kind === "m") throw new TypeError("Private method is not writable");
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
+    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
+};
+var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
+    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
+};
+var _CodefiTokenPricesServiceV2_tokenPricePolicy;
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.CodefiTokenPricesServiceV2 = exports.SUPPORTED_CHAIN_IDS = exports.SUPPORTED_CURRENCIES = void 0;
+const controller_utils_1 = require("@metamask/controller-utils");
+const { hexToNumber } = require("@metamask/utils");
+const cockatiel_1 = require("cockatiel");
+/**
+ * The list of currencies that can be supplied as the `vsCurrency` parameter to
+ * the `/spot-prices` endpoint, in lowercase form.
+ */
+exports.SUPPORTED_CURRENCIES = [
+    // Bitcoin
+    'btc',
+    // Ether
+    'eth',
+    // Litecoin
+    'ltc',
+    // Bitcoin Cash
+    'bch',
+    // Binance Coin
+    'bnb',
+    // EOS
+    'eos',
+    // XRP
+    'xrp',
+    // Lumens
+    'xlm',
+    // Chainlink
+    'link',
+    // Polkadot
+    'dot',
+    // Yearn.finance
+    'yfi',
+    // US Dollar
+    'usd',
+    // United Arab Emirates Dirham
+    'aed',
+    // Argentine Peso
+    'ars',
+    // Australian Dollar
+    'aud',
+    // Bangladeshi Taka
+    'bdt',
+    // Bahraini Dinar
+    'bhd',
+    // Bermudian Dollar
+    'bmd',
+    // Brazil Real
+    'brl',
+    // Canadian Dollar
+    'cad',
+    // Swiss Franc
+    'chf',
+    // Chilean Peso
+    'clp',
+    // Chinese Yuan
+    'cny',
+    // Czech Koruna
+    'czk',
+    // Danish Krone
+    'dkk',
+    // Euro
+    'eur',
+    // British Pound Sterling
+    'gbp',
+    // Hong Kong Dollar
+    'hkd',
+    // Hungarian Forint
+    'huf',
+    // Indonesian Rupiah
+    'idr',
+    // Israeli New Shekel
+    'ils',
+    // Indian Rupee
+    'inr',
+    // Japanese Yen
+    'jpy',
+    // South Korean Won
+    'krw',
+    // Kuwaiti Dinar
+    'kwd',
+    // Sri Lankan Rupee
+    'lkr',
+    // Burmese Kyat
+    'mmk',
+    // Mexican Peso
+    'mxn',
+    // Malaysian Ringgit
+    'myr',
+    // Nigerian Naira
+    'ngn',
+    // Norwegian Krone
+    'nok',
+    // New Zealand Dollar
+    'nzd',
+    // Philippine Peso
+    'php',
+    // Pakistani Rupee
+    'pkr',
+    // Polish Zloty
+    'pln',
+    // Russian Ruble
+    'rub',
+    // Saudi Riyal
+    'sar',
+    // Swedish Krona
+    'sek',
+    // Singapore Dollar
+    'sgd',
+    // Thai Baht
+    'thb',
+    // Turkish Lira
+    'try',
+    // New Taiwan Dollar
+    'twd',
+    // Ukrainian hryvnia
+    'uah',
+    // Venezuelan bolívar fuerte
+    'vef',
+    // Vietnamese đồng
+    'vnd',
+    // South African Rand
+    'zar',
+    // IMF Special Drawing Rights
+    'xdr',
+    // Silver - Troy Ounce
+    'xag',
+    // Gold - Troy Ounce
+    'xau',
+    // Bits
+    'bits',
+    // Satoshi
+    'sats',
+];
+/**
+ * The list of chain IDs that can be supplied in the URL for the `/spot-prices`
+ * endpoint, but in hexadecimal form (for consistency with how we represent
+ * chain IDs in other places).
+ */
+exports.SUPPORTED_CHAIN_IDS = [
+   // Ethereum Mainnet
+  '0x1',
+  // OP Mainnet
+  '0xa',
+  // Cronos Mainnet
+  '0x19',
+  // BNB Smart Chain Mainnet
+  '0x38',
+  // Syscoin Mainnet
+  '0x39',
+  // OKXChain Mainnet
+  '0x42',
+  // Hoo Smart Chain
+  '0x46',
+  // Meter Mainnet
+  '0x52',
+  // TomoChain
+  '0x58',
+  // Gnosis
+  '0x64',
+  // Velas EVM Mainnet
+  '0x6a',
+  // Fuse Mainnet
+  '0x7a',
+  // Huobi ECO Chain Mainnet
+  '0x80',
+  // Polygon Mainnet
+  '0x89',
+  // Fantom Opera
+  '0xfa',
+  // Boba Network
+  '0x120',
+  // KCC Mainnet
+  '0x141',
+  // zkSync Era Mainnet
+  '0x144',
+  // Theta Mainnet
+  '0x169',
+  // Metis Andromeda Mainnet
+  '0x440',
+  // Moonbeam
+  '0x504',
+  // Moonriver
+  '0x505',
+  // Base
+  '0x2105',
+  // Shiden
+  '0x150',
+  // Smart Bitcoin Cash
+  '0x2710',
+  // Arbitrum One
+  '0xa4b1',
+  // Celo Mainnet
+  '0xa4ec',
+  // Oasis Emerald
+  '0xa516',
+  // Avalanche C-Chain
+  '0xa86a',
+  // Polis Mainnet
+  '0x518af',
+  // Aurora Mainnet
+  '0x4e454152',
+  // Harmony Mainnet Shard 0
+  '0x63564c40',
+  // Linea Mainnet
+  '0xe708',
+];
+/**
+ * All requests to V2 of the Price API start with this.
+ */
+const BASE_URL = 'https://price-api.metafi.codefi.network/v2';
+const DEFAULT_TOKEN_PRICE_RETRIES = 3;
+// Each update attempt will result (1 + retries) calls if the server is down
+const DEFAULT_TOKEN_PRICE_MAX_CONSECUTIVE_FAILURES = (1 + DEFAULT_TOKEN_PRICE_RETRIES) * 3;
+/**
+ * This version of the token prices service uses V2 of the Codefi Price API to
+ * fetch token prices.
+ */
+class CodefiTokenPricesServiceV2 {
+    /**
+     * Construct a Codefi Token Price Service.
+     *
+     * @param options - Constructor options
+     * @param options.retries - Number of retry attempts for each token price update.
+     * @param options.maximumConsecutiveFailures - The maximum number of consecutive failures
+     * allowed before breaking the circuit and pausing further updates.
+     * @param options.circuitBreakDuration - The amount of time to wait when the circuit breaks
+     * from too many consecutive failures.
+     */
+    constructor({ retries = DEFAULT_TOKEN_PRICE_RETRIES, maximumConsecutiveFailures = DEFAULT_TOKEN_PRICE_MAX_CONSECUTIVE_FAILURES, circuitBreakDuration = 30 * 60 * 1000, } = {}) {
+        _CodefiTokenPricesServiceV2_tokenPricePolicy.set(this, void 0);
+        // Construct a policy that will retry each update, and halt further updates
+        // for a certain period after too many consecutive failures.
+        const retryPolicy = (0, cockatiel_1.retry)(cockatiel_1.handleAll, {
+            maxAttempts: retries,
+            backoff: new cockatiel_1.ExponentialBackoff(),
+        });
+        const circuitBreakerPolicy = (0, cockatiel_1.circuitBreaker)(cockatiel_1.handleAll, {
+            halfOpenAfter: circuitBreakDuration,
+            breaker: new cockatiel_1.ConsecutiveBreaker(maximumConsecutiveFailures),
+        });
+        __classPrivateFieldSet(this, _CodefiTokenPricesServiceV2_tokenPricePolicy, (0, cockatiel_1.wrap)(retryPolicy, circuitBreakerPolicy), "f");
+    }
+    /**
+     * Retrieves prices in the given currency for the tokens identified by the
+     * given addresses which are expected to live on the given chain.
+     *
+     * @param args - The arguments to function.
+     * @param args.chainId - An EIP-155 chain ID.
+     * @param args.tokenAddresses - Addresses for tokens that live on the chain.
+     * @param args.currency - The desired currency of the token prices.
+     * @returns The prices for the requested tokens.
+     */
+    fetchTokenPrices({ chainId, tokenAddresses, currency, }) {
+        return __awaiter(this, void 0, void 0, function* () {
+            const chainIdAsNumber = hexToNumber(chainId);
+            const url = new URL(`${BASE_URL}/chains/${chainIdAsNumber}/spot-prices`);
+            url.searchParams.append('tokenAddresses', tokenAddresses.join(','));
+            url.searchParams.append('vsCurrency', currency);
+            const pricesByCurrencyByTokenAddress = yield __classPrivateFieldGet(this, _CodefiTokenPricesServiceV2_tokenPricePolicy, "f").execute(() => (0, controller_utils_1.handleFetch)(url));
+            return tokenAddresses.reduce((obj, tokenAddress) => {
+                var _a;
+                // The Price API lowercases both currency and token addresses, so we have
+                // to keep track of them and make sure we return the original versions.
+                const lowercasedTokenAddress = tokenAddress.toLowerCase();
+                const lowercasedCurrency = currency.toLowerCase();
+                const price = (_a = pricesByCurrencyByTokenAddress[lowercasedTokenAddress]) === null || _a === void 0 ? void 0 : _a[lowercasedCurrency];
+                if (!price) {
+                    throw new Error(`Could not find price for "${tokenAddress}" in "${currency}"`);
+                }
+                const tokenPrice = {
+                    tokenAddress,
+                    value: price,
+                    currency,
+                };
+                return Object.assign(Object.assign({}, obj), { [tokenAddress]: tokenPrice });
+            }, {});
+        });
+    }
+    /**
+     * Type guard for whether the API can return token prices for the given chain
+     * ID.
+     *
+     * @param chainId - The chain ID to check.
+     * @returns True if the API supports the chain ID, false otherwise.
+     */
+    validateChainIdSupported(chainId) {
+        const supportedChainIds = exports.SUPPORTED_CHAIN_IDS;
+        return typeof chainId === 'string' && supportedChainIds.includes(chainId);
+    }
+    /**
+     * Type guard for whether the API can return token prices in the given
+     * currency.
+     *
+     * @param currency - The currency to check. If a string, can be either
+     * lowercase or uppercase.
+     * @returns True if the API supports the currency, false otherwise.
+     */
+    validateCurrencySupported(currency) {
+        const supportedCurrencies = exports.SUPPORTED_CURRENCIES;
+        return (typeof currency === 'string' &&
+            supportedCurrencies.includes(currency.toLowerCase()));
+    }
+}
+exports.CodefiTokenPricesServiceV2 = CodefiTokenPricesServiceV2;
+_CodefiTokenPricesServiceV2_tokenPricePolicy = new WeakMap();
+//# sourceMappingURL=codefi-v2.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-prices-service/codefi-v2.js.map b/node_modules/@metamask/assets-controllers/dist/token-prices-service/codefi-v2.js.map
new file mode 100644
index 0000000..e8649de
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/token-prices-service/codefi-v2.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"codefi-v2.js","sourceRoot":"","sources":["../../src/token-prices-service/codefi-v2.ts"],"names":[],"mappings":"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","sourcesContent":["import { handleFetch } from '@metamask/controller-utils';\nimport type { Hex } from '@metamask/utils';\nimport { hexToNumber } from '@metamask/utils';\nimport {\n  circuitBreaker,\n  ConsecutiveBreaker,\n  ExponentialBackoff,\n  handleAll,\n  type IPolicy,\n  retry,\n  wrap,\n} from 'cockatiel';\n\nimport type {\n  AbstractTokenPricesService,\n  TokenPrice,\n  TokenPricesByTokenAddress,\n} from './abstract-token-prices-service';\n\n/**\n * The shape of the data that the /spot-prices endpoint returns.\n */\ntype SpotPricesEndpointData<\n  TokenAddress extends Hex,\n  Currency extends string,\n> = Record<TokenAddress, Record<Currency, number>>;\n\n/**\n * The list of currencies that can be supplied as the `vsCurrency` parameter to\n * the `/spot-prices` endpoint, in lowercase form.\n */\nexport const SUPPORTED_CURRENCIES = [\n  // Bitcoin\n  'btc',\n  // Ether\n  'eth',\n  // Litecoin\n  'ltc',\n  // Bitcoin Cash\n  'bch',\n  // Binance Coin\n  'bnb',\n  // EOS\n  'eos',\n  // XRP\n  'xrp',\n  // Lumens\n  'xlm',\n  // Chainlink\n  'link',\n  // Polkadot\n  'dot',\n  // Yearn.finance\n  'yfi',\n  // US Dollar\n  'usd',\n  // United Arab Emirates Dirham\n  'aed',\n  // Argentine Peso\n  'ars',\n  // Australian Dollar\n  'aud',\n  // Bangladeshi Taka\n  'bdt',\n  // Bahraini Dinar\n  'bhd',\n  // Bermudian Dollar\n  'bmd',\n  // Brazil Real\n  'brl',\n  // Canadian Dollar\n  'cad',\n  // Swiss Franc\n  'chf',\n  // Chilean Peso\n  'clp',\n  // Chinese Yuan\n  'cny',\n  // Czech Koruna\n  'czk',\n  // Danish Krone\n  'dkk',\n  // Euro\n  'eur',\n  // British Pound Sterling\n  'gbp',\n  // Hong Kong Dollar\n  'hkd',\n  // Hungarian Forint\n  'huf',\n  // Indonesian Rupiah\n  'idr',\n  // Israeli New Shekel\n  'ils',\n  // Indian Rupee\n  'inr',\n  // Japanese Yen\n  'jpy',\n  // South Korean Won\n  'krw',\n  // Kuwaiti Dinar\n  'kwd',\n  // Sri Lankan Rupee\n  'lkr',\n  // Burmese Kyat\n  'mmk',\n  // Mexican Peso\n  'mxn',\n  // Malaysian Ringgit\n  'myr',\n  // Nigerian Naira\n  'ngn',\n  // Norwegian Krone\n  'nok',\n  // New Zealand Dollar\n  'nzd',\n  // Philippine Peso\n  'php',\n  // Pakistani Rupee\n  'pkr',\n  // Polish Zloty\n  'pln',\n  // Russian Ruble\n  'rub',\n  // Saudi Riyal\n  'sar',\n  // Swedish Krona\n  'sek',\n  // Singapore Dollar\n  'sgd',\n  // Thai Baht\n  'thb',\n  // Turkish Lira\n  'try',\n  // New Taiwan Dollar\n  'twd',\n  // Ukrainian hryvnia\n  'uah',\n  // Venezuelan bolívar fuerte\n  'vef',\n  // Vietnamese đồng\n  'vnd',\n  // South African Rand\n  'zar',\n  // IMF Special Drawing Rights\n  'xdr',\n  // Silver - Troy Ounce\n  'xag',\n  // Gold - Troy Ounce\n  'xau',\n  // Bits\n  'bits',\n  // Satoshi\n  'sats',\n] as const;\n\n/**\n * A currency that can be supplied as the `vsCurrency` parameter to\n * the `/spot-prices` endpoint. Covers both uppercase and lowercase versions.\n */\ntype SupportedCurrency =\n  | (typeof SUPPORTED_CURRENCIES)[number]\n  | Uppercase<(typeof SUPPORTED_CURRENCIES)[number]>;\n\n/**\n * The list of chain IDs that can be supplied in the URL for the `/spot-prices`\n * endpoint, but in hexadecimal form (for consistency with how we represent\n * chain IDs in other places).\n */\nexport const SUPPORTED_CHAIN_IDS = [\n  // Ethereum Mainnet\n  '1',\n  // OP Mainnet\n  '10',\n  // Cronos Mainnet\n  '25',\n  // BNB Smart Chain Mainnet\n  '56',\n  // Syscoin Mainnet\n  '57',\n  // OKXChain Mainnet\n  '66',\n  // Hoo Smart Chain\n  '70',\n  // Meter Mainnet\n  '82',\n  // TomoChain\n  '88',\n  // Gnosis\n  '100',\n  // Velas EVM Mainnet\n  '106',\n  // Fuse Mainnet\n  '122',\n  // Huobi ECO Chain Mainnet\n  '128',\n  // Polygon Mainnet\n  '137',\n  // Fantom Opera\n  '250',\n  // Boba Network\n  '288',\n  // KCC Mainnet\n  '321',\n  // zkSync Era Mainnet\n  '328',\n  // Theta Mainnet\n  '361',\n  // Metis Andromeda Mainnet\n  '1088',\n  // Moonbeam\n  '1284',\n  // Moonriver\n  '1285',\n  // Base\n  '8453',\n  // Shiden\n  // NOTE: This is the wrong chain ID, this should be '336'\n  '336',\n  // Smart Bitcoin Cash\n  '10000',\n  // Arbitrum One\n  '42161',\n  // Celo Mainnet\n  '42220',\n  // Oasis Emerald\n  '42294',\n  // Avalanche C-Chain\n  '43114',\n  // Polis Mainnet\n  '535824',\n  // Aurora Mainnet\n  '1313161554',\n  // Harmony Mainnet Shard 0\n  '1666600000',\n] as const;\n\n/**\n * A chain ID that can be supplied in the URL for the `/spot-prices` endpoint,\n * but in hexadecimal form (for consistency with how we represent chain IDs in\n * other places).\n */\ntype SupportedChainId = (typeof SUPPORTED_CHAIN_IDS)[number];\n\n/**\n * All requests to V2 of the Price API start with this.\n */\nconst BASE_URL = 'https://price-api.metafi.codefi.network/v2';\n\nconst DEFAULT_TOKEN_PRICE_RETRIES = 3;\n// Each update attempt will result (1 + retries) calls if the server is down\nconst DEFAULT_TOKEN_PRICE_MAX_CONSECUTIVE_FAILURES =\n  (1 + DEFAULT_TOKEN_PRICE_RETRIES) * 3;\n\n/**\n * This version of the token prices service uses V2 of the Codefi Price API to\n * fetch token prices.\n */\nexport class CodefiTokenPricesServiceV2\n  implements\n    AbstractTokenPricesService<SupportedChainId, Hex, SupportedCurrency>\n{\n  #tokenPricePolicy: IPolicy;\n\n  /**\n   * Construct a Codefi Token Price Service.\n   *\n   * @param options - Constructor options\n   * @param options.retries - Number of retry attempts for each token price update.\n   * @param options.maximumConsecutiveFailures - The maximum number of consecutive failures\n   * allowed before breaking the circuit and pausing further updates.\n   * @param options.circuitBreakDuration - The amount of time to wait when the circuit breaks\n   * from too many consecutive failures.\n   */\n  constructor({\n    retries = DEFAULT_TOKEN_PRICE_RETRIES,\n    maximumConsecutiveFailures = DEFAULT_TOKEN_PRICE_MAX_CONSECUTIVE_FAILURES,\n    circuitBreakDuration = 30 * 60 * 1000,\n  }: {\n    retries?: number;\n    maximumConsecutiveFailures?: number;\n    circuitBreakDuration?: number;\n  } = {}) {\n    // Construct a policy that will retry each update, and halt further updates\n    // for a certain period after too many consecutive failures.\n    const retryPolicy = retry(handleAll, {\n      maxAttempts: retries,\n      backoff: new ExponentialBackoff(),\n    });\n    const circuitBreakerPolicy = circuitBreaker(handleAll, {\n      halfOpenAfter: circuitBreakDuration,\n      breaker: new ConsecutiveBreaker(maximumConsecutiveFailures),\n    });\n    this.#tokenPricePolicy = wrap(retryPolicy, circuitBreakerPolicy);\n  }\n\n  /**\n   * Retrieves prices in the given currency for the tokens identified by the\n   * given addresses which are expected to live on the given chain.\n   *\n   * @param args - The arguments to function.\n   * @param args.chainId - An EIP-155 chain ID.\n   * @param args.tokenAddresses - Addresses for tokens that live on the chain.\n   * @param args.currency - The desired currency of the token prices.\n   * @returns The prices for the requested tokens.\n   */\n  async fetchTokenPrices({\n    chainId,\n    tokenAddresses,\n    currency,\n  }: {\n    chainId: SupportedChainId;\n    tokenAddresses: Hex[];\n    currency: SupportedCurrency;\n  }): Promise<TokenPricesByTokenAddress<Hex, SupportedCurrency>> {\n    const url = new URL(`${BASE_URL}/chains/${chainId}/spot-prices`);\n    url.searchParams.append('tokenAddresses', tokenAddresses.join(','));\n    url.searchParams.append('vsCurrency', currency);\n\n    const pricesByCurrencyByTokenAddress: SpotPricesEndpointData<\n      Lowercase<Hex>,\n      Lowercase<SupportedCurrency>\n    > = await this.#tokenPricePolicy.execute(() => handleFetch(url));\n\n    return tokenAddresses.reduce(\n      (\n        obj: Partial<TokenPricesByTokenAddress<Hex, SupportedCurrency>>,\n        tokenAddress,\n      ) => {\n        // The Price API lowercases both currency and token addresses, so we have\n        // to keep track of them and make sure we return the original versions.\n        const lowercasedTokenAddress =\n          tokenAddress.toLowerCase() as Lowercase<Hex>;\n        const lowercasedCurrency =\n          currency.toLowerCase() as Lowercase<SupportedCurrency>;\n\n        const price =\n          pricesByCurrencyByTokenAddress[lowercasedTokenAddress]?.[\n            lowercasedCurrency\n          ];\n\n        if (!price) {\n          throw new Error(\n            `Could not find price for \"${tokenAddress}\" in \"${currency}\"`,\n          );\n        }\n\n        const tokenPrice: TokenPrice<Hex, SupportedCurrency> = {\n          tokenAddress,\n          value: price,\n          currency,\n        };\n        return {\n          ...obj,\n          [tokenAddress]: tokenPrice,\n        };\n      },\n      {},\n    ) as TokenPricesByTokenAddress<Hex, SupportedCurrency>;\n  }\n\n  /**\n   * Type guard for whether the API can return token prices for the given chain\n   * ID.\n   *\n   * @param chainId - The chain ID to check.\n   * @returns True if the API supports the chain ID, false otherwise.\n   */\n  validateChainIdSupported(chainId: unknown): chainId is SupportedChainId {\n    const supportedChainIds: readonly string[] = SUPPORTED_CHAIN_IDS;\n    return typeof chainId === 'string' && supportedChainIds.includes(chainId);\n  }\n\n  /**\n   * Type guard for whether the API can return token prices in the given\n   * currency.\n   *\n   * @param currency - The currency to check. If a string, can be either\n   * lowercase or uppercase.\n   * @returns True if the API supports the currency, false otherwise.\n   */\n  validateCurrencySupported(currency: unknown): currency is SupportedCurrency {\n    const supportedCurrencies: readonly string[] = SUPPORTED_CURRENCIES;\n    return (\n      typeof currency === 'string' &&\n      supportedCurrencies.includes(currency.toLowerCase())\n    );\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-prices-service/index.d.ts b/node_modules/@metamask/assets-controllers/dist/token-prices-service/index.d.ts
new file mode 100644
index 0000000..785225a
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/token-prices-service/index.d.ts
@@ -0,0 +1,3 @@
+export type { AbstractTokenPricesService } from './abstract-token-prices-service';
+export { CodefiTokenPricesServiceV2 } from './codefi-v2';
+//# sourceMappingURL=index.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-prices-service/index.d.ts.map b/node_modules/@metamask/assets-controllers/dist/token-prices-service/index.d.ts.map
new file mode 100644
index 0000000..48c1a1c
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/token-prices-service/index.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../src/token-prices-service/index.ts"],"names":[],"mappings":"AAAA,YAAY,EAAE,0BAA0B,EAAE,MAAM,iCAAiC,CAAC;AAClF,OAAO,EAAE,0BAA0B,EAAE,MAAM,aAAa,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-prices-service/index.js b/node_modules/@metamask/assets-controllers/dist/token-prices-service/index.js
new file mode 100644
index 0000000..5d52474
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/token-prices-service/index.js
@@ -0,0 +1,6 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.CodefiTokenPricesServiceV2 = void 0;
+var codefi_v2_1 = require("./codefi-v2");
+Object.defineProperty(exports, "CodefiTokenPricesServiceV2", { enumerable: true, get: function () { return codefi_v2_1.CodefiTokenPricesServiceV2; } });
+//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-prices-service/index.js.map b/node_modules/@metamask/assets-controllers/dist/token-prices-service/index.js.map
new file mode 100644
index 0000000..2692b27
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/token-prices-service/index.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/token-prices-service/index.ts"],"names":[],"mappings":";;;AACA,yCAAyD;AAAhD,uHAAA,0BAA0B,OAAA","sourcesContent":["export type { AbstractTokenPricesService } from './abstract-token-prices-service';\nexport { CodefiTokenPricesServiceV2 } from './codefi-v2';\n"]}
\ No newline at end of file
