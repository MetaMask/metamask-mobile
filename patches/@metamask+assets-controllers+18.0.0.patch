diff --git a/node_modules/@metamask/assets-controllers/dist/.patch.txt b/node_modules/@metamask/assets-controllers/dist/.patch.txt
new file mode 100644
index 0000000..550de56
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/.patch.txt
@@ -0,0 +1,14 @@
+PATCH GENERATED FROM MetaMask/core branch: patch/mobile-assets-controllers-v-18-0-0
+This patch backports various assets controllers features from the main branch of MetaMask/core
+Steps to update patch:
+* Create a new core branch from: patch/mobile-assets-controllers-v-18-0-0
+* Run "yarn build" in the core monorepo
+* Run "yarn patch:assets <core-directory>" in the mobile repo
+* If you have changes also add them to the branch: patch/mobile-assets-controllers-v-18-0-0
+* Steps to update the assets-controllers version
+* Create a new core branch from the next assets-controllers version
+* Merge the branch patch/mobile-assets-controllers-v-18-0-0
+* Solve the conflicts and review changes accordingly the changelog
+* Run "yarn build" in the core monorepo
+* Run "yarn patch:assets <core-directory>" in the mobile repo
+* If you have changes also add them to the branch: patch/mobile-assets-controllers-v-18-0-0
diff --git a/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.d.ts b/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.d.ts
index 41bf5fe..7b4be39 100644
--- a/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.d.ts
@@ -1,5 +1,5 @@
-import type { BaseConfig, BaseState } from '@metamask/base-controller';
-import { BaseController } from '@metamask/base-controller';
+import { BaseConfig, BaseController, BaseState } from '@metamask/base-controller';
+import { NetworkState } from '@metamask/network-controller';
 import type { Provider } from '@metamask/eth-query';
 import type { PreferencesState } from '@metamask/preferences-controller';
 /**
@@ -31,22 +31,26 @@ export interface AccountTrackerState extends BaseState {
     accounts: {
         [address: string]: AccountInformation;
     };
+    accountsByChainId: Record<string, {
+        [address: string]: AccountInformation;
+    }>;
 }
 /**
  * Controller that tracks the network balances for all user accounts.
  */
 export declare class AccountTrackerController extends BaseController<AccountTrackerConfig, AccountTrackerState> {
     private ethQuery?;
-    private readonly mutex;
+    private mutex;
     private handle?;
     private syncAccounts;
     /**
      * Name of this controller used during composition
      */
     name: string;
-    private readonly getIdentities;
-    private readonly getSelectedAddress;
-    private readonly getMultiAccountBalancesEnabled;
+    private getIdentities;
+    private getSelectedAddress;
+    private getMultiAccountBalancesEnabled;
+    getCurrentChainId: () => NetworkState['providerConfig']['chainId'];
     /**
      * Creates an AccountTracker instance.
      *
@@ -55,14 +59,16 @@ export declare class AccountTrackerController extends BaseController<AccountTrac
      * @param options.getIdentities - Gets the identities from the Preferences store.
      * @param options.getSelectedAddress - Gets the selected address from the Preferences store.
      * @param options.getMultiAccountBalancesEnabled - Gets the multi account balances enabled flag from the Preferences store.
+     * @param options.getCurrentChainId - Gets the chain ID for the current network from the Network store.
      * @param config - Initial options used to configure this controller.
      * @param state - Initial state to set on this controller.
      */
-    constructor({ onPreferencesStateChange, getIdentities, getSelectedAddress, getMultiAccountBalancesEnabled, }: {
+    constructor({ onPreferencesStateChange, getIdentities, getSelectedAddress, getMultiAccountBalancesEnabled, getCurrentChainId, }: {
         onPreferencesStateChange: (listener: (preferencesState: PreferencesState) => void) => void;
         getIdentities: () => PreferencesState['identities'];
         getSelectedAddress: () => PreferencesState['selectedAddress'];
         getMultiAccountBalancesEnabled: () => PreferencesState['isMultiAccountBalancesEnabled'];
+        getCurrentChainId: () => NetworkState['providerConfig']['chainId'];
     }, config?: Partial<AccountTrackerConfig>, state?: Partial<AccountTrackerState>);
     /**
      * Sets a new provider.
@@ -83,6 +89,8 @@ export declare class AccountTrackerController extends BaseController<AccountTrac
      * Refreshes the balances of the accounts depending on the multi-account setting.
      * If multi-account is disabled, only updates the selected account balance.
      * If multi-account is enabled, updates balances for all accounts.
+     *
+     * @async
      */
     refresh: () => Promise<void>;
     /**
diff --git a/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.d.ts.map b/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.d.ts.map
index 55c0d9e..9943e30 100644
--- a/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.d.ts.map
+++ b/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"AccountTrackerController.d.ts","sourceRoot":"","sources":["../src/AccountTrackerController.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,UAAU,EAAE,SAAS,EAAE,MAAM,2BAA2B,CAAC;AACvE,OAAO,EAAE,cAAc,EAAE,MAAM,2BAA2B,CAAC;AAO3D,OAAO,KAAK,EAAE,QAAQ,EAAE,MAAM,qBAAqB,CAAC;AACpD,OAAO,KAAK,EAAE,gBAAgB,EAAE,MAAM,kCAAkC,CAAC;AAIzE;;;;;GAKG;AACH,MAAM,WAAW,kBAAkB;IACjC,OAAO,EAAE,MAAM,CAAC;CACjB;AAED;;;;;GAKG;AACH,MAAM,WAAW,oBAAqB,SAAQ,UAAU;IACtD,QAAQ,EAAE,MAAM,CAAC;IACjB,QAAQ,CAAC,EAAE,QAAQ,CAAC;CACrB;AAED;;;;;GAKG;AACH,MAAM,WAAW,mBAAoB,SAAQ,SAAS;IACpD,QAAQ,EAAE;QAAE,CAAC,OAAO,EAAE,MAAM,GAAG,kBAAkB,CAAA;KAAE,CAAC;CACrD;AAED;;GAEG;AACH,qBAAa,wBAAyB,SAAQ,cAAc,CAC1D,oBAAoB,EACpB,mBAAmB,CACpB;IACC,OAAO,CAAC,QAAQ,CAAC,CAAW;IAE5B,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAe;IAErC,OAAO,CAAC,MAAM,CAAC,CAAgC;IAE/C,OAAO,CAAC,YAAY;IAoBpB;;OAEG;IACM,IAAI,SAA8B;IAE3C,OAAO,CAAC,QAAQ,CAAC,aAAa,CAAuC;IAErE,OAAO,CAAC,QAAQ,CAAC,kBAAkB,CAA4C;IAE/E,OAAO,CAAC,QAAQ,CAAC,8BAA8B,CAA0D;IAEzG;;;;;;;;;;OAUG;gBAED,EACE,wBAAwB,EACxB,aAAa,EACb,kBAAkB,EAClB,8BAA8B,GAC/B,EAAE;QACD,wBAAwB,EAAE,CACxB,QAAQ,EAAE,CAAC,gBAAgB,EAAE,gBAAgB,KAAK,IAAI,KACnD,IAAI,CAAC;QACV,aAAa,EAAE,MAAM,gBAAgB,CAAC,YAAY,CAAC,CAAC;QACpD,kBAAkB,EAAE,MAAM,gBAAgB,CAAC,iBAAiB,CAAC,CAAC;QAC9D,8BAA8B,EAAE,MAAM,gBAAgB,CAAC,+BAA+B,CAAC,CAAC;KACzF,EACD,MAAM,CAAC,EAAE,OAAO,CAAC,oBAAoB,CAAC,EACtC,KAAK,CAAC,EAAE,OAAO,CAAC,mBAAmB,CAAC;IAiBtC;;;;;;OAMG;IACH,IAAI,QAAQ,CAAC,QAAQ,EAAE,QAAQ,EAE9B;IAED,IAAI,QAAQ,IAJW,QAAQ,CAM9B;IAED;;;;OAIG;IACG,IAAI,CAAC,QAAQ,CAAC,EAAE,MAAM,GAAG,OAAO,CAAC,IAAI,CAAC;IAW5C;;;;OAIG;IACH,OAAO,sBAgBL;IAEF;;;;;OAKG;YACW,mBAAmB;IASjC;;;;;OAKG;IACG,wBAAwB,CAC5B,SAAS,EAAE,MAAM,EAAE,GAClB,OAAO,CAAC,MAAM,CAAC,MAAM,EAAE;QAAE,OAAO,EAAE,MAAM,CAAA;KAAE,CAAC,CAAC;CAyBhD;AAED,eAAe,wBAAwB,CAAC"}
\ No newline at end of file
+{"version":3,"file":"AccountTrackerController.d.ts","sourceRoot":"","sources":["../src/AccountTrackerController.ts"],"names":[],"mappings":"AAAA,OAAO,EACL,UAAU,EACV,cAAc,EACd,SAAS,EACV,MAAM,2BAA2B,CAAC;AAMnC,OAAO,EAAE,YAAY,EAAE,MAAM,8BAA8B,CAAC;AAG5D,OAAO,KAAK,EAAE,QAAQ,EAAE,MAAM,qBAAqB,CAAC;AACpD,OAAO,KAAK,EAAE,gBAAgB,EAAE,MAAM,kCAAkC,CAAC;AAIzE;;;;;GAKG;AACH,MAAM,WAAW,kBAAkB;IACjC,OAAO,EAAE,MAAM,CAAC;CACjB;AAED;;;;;GAKG;AACH,MAAM,WAAW,oBAAqB,SAAQ,UAAU;IACtD,QAAQ,EAAE,MAAM,CAAC;IACjB,QAAQ,CAAC,EAAE,QAAQ,CAAC;CACrB;AAED;;;;;GAKG;AACH,MAAM,WAAW,mBAAoB,SAAQ,SAAS;IACpD,QAAQ,EAAE;QAAE,CAAC,OAAO,EAAE,MAAM,GAAG,kBAAkB,CAAA;KAAE,CAAC;IACpD,iBAAiB,EAAE,MAAM,CACvB,MAAM,EACN;QACE,CAAC,OAAO,EAAE,MAAM,GAAG,kBAAkB,CAAC;KACvC,CACF,CAAC;CACH;AAED;;GAEG;AACH,qBAAa,wBAAyB,SAAQ,cAAc,CAC1D,oBAAoB,EACpB,mBAAmB,CACpB;IACC,OAAO,CAAC,QAAQ,CAAC,CAAW;IAE5B,OAAO,CAAC,KAAK,CAAe;IAE5B,OAAO,CAAC,MAAM,CAAC,CAAgC;IAE/C,OAAO,CAAC,YAAY;IAuCpB;;OAEG;IACM,IAAI,SAA8B;IAE3C,OAAO,CAAC,aAAa,CAAuC;IAE5D,OAAO,CAAC,kBAAkB,CAA4C;IAEtE,OAAO,CAAC,8BAA8B,CAA0D;IAEhG,iBAAiB,EAAE,MAAM,YAAY,CAAC,gBAAgB,CAAC,CAAC,SAAS,CAAC,CAAC;IAEnE;;;;;;;;;;;OAWG;gBAED,EACE,wBAAwB,EACxB,aAAa,EACb,kBAAkB,EAClB,8BAA8B,EAC9B,iBAAiB,GAClB,EAAE;QACD,wBAAwB,EAAE,CACxB,QAAQ,EAAE,CAAC,gBAAgB,EAAE,gBAAgB,KAAK,IAAI,KACnD,IAAI,CAAC;QACV,aAAa,EAAE,MAAM,gBAAgB,CAAC,YAAY,CAAC,CAAC;QACpD,kBAAkB,EAAE,MAAM,gBAAgB,CAAC,iBAAiB,CAAC,CAAC;QAC9D,8BAA8B,EAAE,MAAM,gBAAgB,CAAC,+BAA+B,CAAC,CAAC;QACxF,iBAAiB,EAAE,MAAM,YAAY,CAAC,gBAAgB,CAAC,CAAC,SAAS,CAAC,CAAC;KACpE,EACD,MAAM,CAAC,EAAE,OAAO,CAAC,oBAAoB,CAAC,EACtC,KAAK,CAAC,EAAE,OAAO,CAAC,mBAAmB,CAAC;IAuBtC;;;;;;OAMG;IACH,IAAI,QAAQ,CAAC,QAAQ,EAAE,QAAQ,EAE9B;IAED,IAAI,QAAQ,IAJW,QAAQ,CAM9B;IAED;;;;OAIG;IACG,IAAI,CAAC,QAAQ,CAAC,EAAE,MAAM,GAAG,OAAO,CAAC,IAAI,CAAC;IAW5C;;;;;;OAMG;IACH,OAAO,sBAgCL;IAEF;;;;;OAKG;YACW,mBAAmB;IASjC;;;;;OAKG;IACG,wBAAwB,CAC5B,SAAS,EAAE,MAAM,EAAE,GAClB,OAAO,CAAC,MAAM,CAAC,MAAM,EAAE;QAAE,OAAO,EAAE,MAAM,CAAA;KAAE,CAAC,CAAC;CAyBhD;AAED,eAAe,wBAAwB,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.js b/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.js
index 4092a67..245bfbd 100644
--- a/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.js
+++ b/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.js
@@ -15,6 +15,7 @@ Object.defineProperty(exports, "__esModule", { value: true });
 exports.AccountTrackerController = void 0;
 const base_controller_1 = require("@metamask/base-controller");
 const controller_utils_1 = require("@metamask/controller-utils");
+const lodash_1 = require("lodash");
 const eth_query_1 = __importDefault(require("@metamask/eth-query"));
 const utils_1 = require("@metamask/utils");
 const async_mutex_1 = require("async-mutex");
@@ -30,10 +31,11 @@ class AccountTrackerController extends base_controller_1.BaseController {
      * @param options.getIdentities - Gets the identities from the Preferences store.
      * @param options.getSelectedAddress - Gets the selected address from the Preferences store.
      * @param options.getMultiAccountBalancesEnabled - Gets the multi account balances enabled flag from the Preferences store.
+     * @param options.getCurrentChainId - Gets the chain ID for the current network from the Network store.
      * @param config - Initial options used to configure this controller.
      * @param state - Initial state to set on this controller.
      */
-    constructor({ onPreferencesStateChange, getIdentities, getSelectedAddress, getMultiAccountBalancesEnabled, }, config, state) {
+    constructor({ onPreferencesStateChange, getIdentities, getSelectedAddress, getMultiAccountBalancesEnabled, getCurrentChainId, }, config, state) {
         super(config, state);
         this.mutex = new async_mutex_1.Mutex();
         /**
@@ -44,25 +46,48 @@ class AccountTrackerController extends base_controller_1.BaseController {
          * Refreshes the balances of the accounts depending on the multi-account setting.
          * If multi-account is disabled, only updates the selected account balance.
          * If multi-account is enabled, updates balances for all accounts.
+         *
+         * @async
          */
         this.refresh = () => __awaiter(this, void 0, void 0, function* () {
-            this.syncAccounts();
+            const chainId = this.getCurrentChainId();
+            this.syncAccounts(chainId);
             const accounts = Object.assign({}, this.state.accounts);
+            const accountsByChainId = Object.assign({}, this.state.accountsByChainId);
+            const accountsForChain = Object.assign({}, accountsByChainId[chainId]);
             const isMultiAccountBalancesEnabled = this.getMultiAccountBalancesEnabled();
             const accountsToUpdate = isMultiAccountBalancesEnabled
                 ? Object.keys(accounts)
                 : [this.getSelectedAddress()];
             for (const address of accountsToUpdate) {
+                const balance = yield this.getBalanceFromChain(address);
+                if (!balance) {
+                    continue;
+                }
+                const hexBalance = (0, controller_utils_1.BNToHex)(balance);
                 accounts[address] = {
-                    balance: (0, controller_utils_1.BNToHex)(yield this.getBalanceFromChain(address)),
+                    balance: hexBalance,
+                };
+                accountsForChain[address] = {
+                    balance: hexBalance,
                 };
             }
-            this.update({ accounts });
+            this.update({
+                accounts,
+                accountsByChainId: Object.assign(Object.assign({}, accountsByChainId), {
+                    [chainId]: accountsForChain,
+                }),
+            });
         });
         this.defaultConfig = {
             interval: 10000,
         };
-        this.defaultState = { accounts: {} };
+        this.defaultState = {
+            accounts: {},
+            accountsByChainId: {
+                [getCurrentChainId()]: {},
+            },
+        };
         this.initialize();
         this.getIdentities = getIdentities;
         this.getSelectedAddress = getSelectedAddress;
@@ -70,21 +95,41 @@ class AccountTrackerController extends base_controller_1.BaseController {
         onPreferencesStateChange(() => {
             this.refresh();
         });
+        this.getCurrentChainId = getCurrentChainId;
         this.poll();
     }
-    syncAccounts() {
+    syncAccounts(newChainId) {
         const { accounts } = this.state;
+        const accountsByChainId = (0, lodash_1.cloneDeep)(this.state.accountsByChainId);
         const addresses = Object.keys(this.getIdentities());
         const existing = Object.keys(accounts);
-        const newAddresses = addresses.filter((address) => !existing.includes(address));
-        const oldAddresses = existing.filter((address) => !addresses.includes(address));
+        if (!accountsByChainId[newChainId]) {
+            accountsByChainId[newChainId] = {};
+            existing.forEach((address) => {
+                accountsByChainId[newChainId][address] = { balance: '0x0' };
+            });
+        }
+        const newAddresses = addresses.filter((address) => existing.indexOf(address) === -1);
+        const oldAddresses = existing.filter((address) => addresses.indexOf(address) === -1);
         newAddresses.forEach((address) => {
             accounts[address] = { balance: '0x0' };
         });
+        Object.keys(accountsByChainId).forEach((chainId) => {
+            newAddresses.forEach((address) => {
+                accountsByChainId[chainId][address] = {
+                    balance: '0x0',
+                };
+            });
+        });
         oldAddresses.forEach((address) => {
             delete accounts[address];
         });
-        this.update({ accounts: Object.assign({}, accounts) });
+        Object.keys(accountsByChainId).forEach((chainId) => {
+            oldAddresses.forEach((address) => {
+                delete accountsByChainId[chainId][address];
+            });
+        });
+        this.update({ accounts: Object.assign({}, accounts), accountsByChainId });
     }
     /**
      * Sets a new provider.
diff --git a/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.js.map b/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.js.map
index 513cb8e..da0b10d 100644
--- a/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.js.map
+++ b/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.js.map
@@ -1 +1 @@
-{"version":3,"file":"AccountTrackerController.js","sourceRoot":"","sources":["../src/AccountTrackerController.ts"],"names":[],"mappings":"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","sourcesContent":["import type { BaseConfig, BaseState } from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport {\n  BNToHex,\n  query,\n  safelyExecuteWithTimeout,\n} from '@metamask/controller-utils';\nimport EthQuery from '@metamask/eth-query';\nimport type { Provider } from '@metamask/eth-query';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport { assert } from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\n\n/**\n * @type AccountInformation\n *\n * Account information object\n * @property balance - Hex string of an account balancec in wei\n */\nexport interface AccountInformation {\n  balance: string;\n}\n\n/**\n * @type AccountTrackerConfig\n *\n * Account tracker controller configuration\n * @property provider - Provider used to create a new underlying EthQuery instance\n */\nexport interface AccountTrackerConfig extends BaseConfig {\n  interval: number;\n  provider?: Provider;\n}\n\n/**\n * @type AccountTrackerState\n *\n * Account tracker controller state\n * @property accounts - Map of addresses to account information\n */\nexport interface AccountTrackerState extends BaseState {\n  accounts: { [address: string]: AccountInformation };\n}\n\n/**\n * Controller that tracks the network balances for all user accounts.\n */\nexport class AccountTrackerController extends BaseController<\n  AccountTrackerConfig,\n  AccountTrackerState\n> {\n  private ethQuery?: EthQuery;\n\n  private readonly mutex = new Mutex();\n\n  private handle?: ReturnType<typeof setTimeout>;\n\n  private syncAccounts() {\n    const { accounts } = this.state;\n    const addresses = Object.keys(this.getIdentities());\n    const existing = Object.keys(accounts);\n    const newAddresses = addresses.filter(\n      (address) => !existing.includes(address),\n    );\n    const oldAddresses = existing.filter(\n      (address) => !addresses.includes(address),\n    );\n    newAddresses.forEach((address) => {\n      accounts[address] = { balance: '0x0' };\n    });\n\n    oldAddresses.forEach((address) => {\n      delete accounts[address];\n    });\n    this.update({ accounts: { ...accounts } });\n  }\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'AccountTrackerController';\n\n  private readonly getIdentities: () => PreferencesState['identities'];\n\n  private readonly getSelectedAddress: () => PreferencesState['selectedAddress'];\n\n  private readonly getMultiAccountBalancesEnabled: () => PreferencesState['isMultiAccountBalancesEnabled'];\n\n  /**\n   * Creates an AccountTracker instance.\n   *\n   * @param options - The controller options.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.getIdentities - Gets the identities from the Preferences store.\n   * @param options.getSelectedAddress - Gets the selected address from the Preferences store.\n   * @param options.getMultiAccountBalancesEnabled - Gets the multi account balances enabled flag from the Preferences store.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      onPreferencesStateChange,\n      getIdentities,\n      getSelectedAddress,\n      getMultiAccountBalancesEnabled,\n    }: {\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      getIdentities: () => PreferencesState['identities'];\n      getSelectedAddress: () => PreferencesState['selectedAddress'];\n      getMultiAccountBalancesEnabled: () => PreferencesState['isMultiAccountBalancesEnabled'];\n    },\n    config?: Partial<AccountTrackerConfig>,\n    state?: Partial<AccountTrackerState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      interval: 10000,\n    };\n    this.defaultState = { accounts: {} };\n    this.initialize();\n    this.getIdentities = getIdentities;\n    this.getSelectedAddress = getSelectedAddress;\n    this.getMultiAccountBalancesEnabled = getMultiAccountBalancesEnabled;\n    onPreferencesStateChange(() => {\n      this.refresh();\n    });\n    this.poll();\n  }\n\n  /**\n   * Sets a new provider.\n   *\n   * TODO: Replace this wth a method.\n   *\n   * @param provider - Provider used to create a new underlying EthQuery instance.\n   */\n  set provider(provider: Provider) {\n    this.ethQuery = new EthQuery(provider);\n  }\n\n  get provider() {\n    throw new Error('Property only used for setting');\n  }\n\n  /**\n   * Starts a new polling interval.\n   *\n   * @param interval - Polling interval trigger a 'refresh'.\n   */\n  async poll(interval?: number): Promise<void> {\n    const releaseLock = await this.mutex.acquire();\n    interval && this.configure({ interval }, false, false);\n    this.handle && clearTimeout(this.handle);\n    await this.refresh();\n    this.handle = setTimeout(() => {\n      releaseLock();\n      this.poll(this.config.interval);\n    }, this.config.interval);\n  }\n\n  /**\n   * Refreshes the balances of the accounts depending on the multi-account setting.\n   * If multi-account is disabled, only updates the selected account balance.\n   * If multi-account is enabled, updates balances for all accounts.\n   */\n  refresh = async () => {\n    this.syncAccounts();\n    const accounts = { ...this.state.accounts };\n    const isMultiAccountBalancesEnabled = this.getMultiAccountBalancesEnabled();\n\n    const accountsToUpdate = isMultiAccountBalancesEnabled\n      ? Object.keys(accounts)\n      : [this.getSelectedAddress()];\n\n    for (const address of accountsToUpdate) {\n      accounts[address] = {\n        balance: BNToHex(await this.getBalanceFromChain(address)),\n      };\n    }\n\n    this.update({ accounts });\n  };\n\n  /**\n   * Fetches the balance of a given address from the blockchain.\n   *\n   * @param address - The account address to fetch the balance for.\n   * @returns A promise that resolves to the balance in a hex string format.\n   */\n  private async getBalanceFromChain(\n    address: string,\n  ): Promise<string | undefined> {\n    return await safelyExecuteWithTimeout(async () => {\n      assert(this.ethQuery, 'Provider not set.');\n      return await query(this.ethQuery, 'getBalance', [address]);\n    });\n  }\n\n  /**\n   * Sync accounts balances with some additional addresses.\n   *\n   * @param addresses - the additional addresses, may be hardware wallet addresses.\n   * @returns accounts - addresses with synced balance\n   */\n  async syncBalanceWithAddresses(\n    addresses: string[],\n  ): Promise<Record<string, { balance: string }>> {\n    return await Promise.all(\n      addresses.map((address): Promise<[string, string] | undefined> => {\n        return safelyExecuteWithTimeout(async () => {\n          assert(this.ethQuery, 'Provider not set.');\n          const balance = await query(this.ethQuery, 'getBalance', [address]);\n          return [address, balance];\n        });\n      }),\n    ).then((value) => {\n      return value.reduce((obj, item) => {\n        if (!item) {\n          return obj;\n        }\n\n        const [address, balance] = item;\n        return {\n          ...obj,\n          [address]: {\n            balance,\n          },\n        };\n      }, {});\n    });\n  }\n}\n\nexport default AccountTrackerController;\n"]}
\ No newline at end of file
+{"version":3,"file":"AccountTrackerController.js","sourceRoot":"","sources":["../src/AccountTrackerController.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;AAAA,+DAImC;AACnC,iEAIoC;AAEpC,mCAAmC;AACnC,oEAA2C;AAG3C,2CAA8C;AAC9C,6CAAoC;AAuCpC;;GAEG;AACH,MAAa,wBAAyB,SAAQ,gCAG7C;IA2DC;;;;;;;;;;;OAWG;IACH,YACE,EACE,wBAAwB,EACxB,aAAa,EACb,kBAAkB,EAClB,8BAA8B,EAC9B,iBAAiB,GASlB,EACD,MAAsC,EACtC,KAAoC;QAEpC,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;QAvFf,UAAK,GAAG,IAAI,mBAAK,EAAE,CAAC;QA2C5B;;WAEG;QACM,SAAI,GAAG,0BAA0B,CAAC;QA6F3C;;;;;;WAMG;QACH,YAAO,GAAG,GAAS,EAAE;YACnB,MAAM,OAAO,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAC;YACzC,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC;YAC3B,MAAM,QAAQ,qBAAQ,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAE,CAAC;YAC5C,MAAM,iBAAiB,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,IAAI,CAAC,KAAK,CAAC,iBAAiB,CAAC,CAAC;YAC1E,MAAM,gBAAgB,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,iBAAiB,CAAC,OAAO,CAAC,CAAC,CAAC;YACvE,MAAM,6BAA6B,GAAG,IAAI,CAAC,8BAA8B,EAAE,CAAC;YAE5E,MAAM,gBAAgB,GAAG,6BAA6B;gBACpD,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC;gBACvB,CAAC,CAAC,CAAC,IAAI,CAAC,kBAAkB,EAAE,CAAC,CAAC;YAEhC,KAAK,MAAM,OAAO,IAAI,gBAAgB,EAAE;gBACtC,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,mBAAmB,CAAC,OAAO,CAAC,CAAC;gBACxD,IAAI,CAAC,OAAO,EAAE;oBACZ,SAAS;iBACV;gBACD,MAAM,UAAU,GAAG,IAAA,0BAAO,EAAC,OAAO,CAAC,CAAC;gBACpC,QAAQ,CAAC,OAAO,CAAC,GAAG;oBAClB,OAAO,EAAE,UAAU;iBACpB,CAAC;gBACF,gBAAgB,CAAC,OAAO,CAAC,GAAG;oBAC1B,OAAO,EAAE,UAAU;iBACpB,CAAC;aACH;YAED,IAAI,CAAC,MAAM,CAAC;gBACV,QAAQ;gBACR,iBAAiB,EAAE,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,iBAAiB,CAAC,EAAE;oBACrE,CAAC,OAAO,CAAC,EAAE,gBAAgB;iBAC5B,CAAC;aACH,CAAC,CAAC;QACL,CAAC,CAAA,CAAC;QA1FA,IAAI,CAAC,aAAa,GAAG;YACnB,QAAQ,EAAE,KAAK;SAChB,CAAC;QACF,IAAI,CAAC,YAAY,GAAG;YAClB,QAAQ,EAAE,EAAE;YACZ,iBAAiB,EAAE;gBACjB,CAAC,iBAAiB,EAAE,CAAC,EAAE,EAAE;aAC1B;SACF,CAAC;QACF,IAAI,CAAC,UAAU,EAAE,CAAC;QAClB,IAAI,CAAC,aAAa,GAAG,aAAa,CAAC;QACnC,IAAI,CAAC,kBAAkB,GAAG,kBAAkB,CAAC;QAC7C,IAAI,CAAC,8BAA8B,GAAG,8BAA8B,CAAC;QACrE,wBAAwB,CAAC,GAAG,EAAE;YAC5B,IAAI,CAAC,OAAO,EAAE,CAAC;QACjB,CAAC,CAAC,CAAC;QACH,IAAI,CAAC,iBAAiB,GAAG,iBAAiB,CAAC;QAC3C,IAAI,CAAC,IAAI,EAAE,CAAC;IACd,CAAC;IAtGO,YAAY,CAAC,UAAe;QAClC,MAAM,EAAE,QAAQ,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC;QAChC,MAAM,iBAAiB,GAAG,IAAA,kBAAS,EAAC,IAAI,CAAC,KAAK,CAAC,iBAAiB,CAAC,CAAC;QAClE,MAAM,SAAS,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE,CAAC,CAAC;QACpD,MAAM,QAAQ,GAAG,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QACvC,IAAI,CAAC,iBAAiB,CAAC,UAAU,CAAC,EAAE;YAClC,iBAAiB,CAAC,UAAU,CAAC,GAAG,EAAE,CAAC;YACnC,QAAQ,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;gBAC3B,iBAAiB,CAAC,UAAU,CAAC,CAAC,OAAO,CAAC,GAAG,EAAE,OAAO,EAAE,KAAK,EAAE,CAAC;YAC9D,CAAC,CAAC,CAAC;SACJ;QAED,MAAM,YAAY,GAAG,SAAS,CAAC,MAAM,CACnC,CAAC,OAAO,EAAE,EAAE,CAAC,QAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAC9C,CAAC;QACF,MAAM,YAAY,GAAG,QAAQ,CAAC,MAAM,CAClC,CAAC,OAAO,EAAE,EAAE,CAAC,SAAS,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAC/C,CAAC;QACF,YAAY,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;YAC/B,QAAQ,CAAC,OAAO,CAAC,GAAG,EAAE,OAAO,EAAE,KAAK,EAAE,CAAC;QACzC,CAAC,CAAC,CAAC;QACH,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;YACjD,YAAY,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;gBAC/B,iBAAiB,CAAC,OAAO,CAAC,CAAC,OAAO,CAAC,GAAG;oBACpC,OAAO,EAAE,KAAK;iBACf,CAAC;YACJ,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;QACH,YAAY,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;YAC/B,OAAO,QAAQ,CAAC,OAAO,CAAC,CAAC;QAC3B,CAAC,CAAC,CAAC;QACH,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;YACjD,YAAY,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;gBAC/B,OAAO,iBAAiB,CAAC,OAAO,CAAC,CAAC,OAAO,CAAC,CAAC;YAC7C,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;QACH,IAAI,CAAC,MAAM,CAAC,EAAE,QAAQ,oBAAO,QAAQ,CAAE,EAAE,iBAAiB,EAAE,CAAC,CAAC;IAChE,CAAC;IAmED;;;;;;OAMG;IACH,IAAI,QAAQ,CAAC,QAAkB;QAC7B,IAAI,CAAC,QAAQ,GAAG,IAAI,mBAAQ,CAAC,QAAQ,CAAC,CAAC;IACzC,CAAC;IAED,IAAI,QAAQ;QACV,MAAM,IAAI,KAAK,CAAC,gCAAgC,CAAC,CAAC;IACpD,CAAC;IAED;;;;OAIG;IACG,IAAI,CAAC,QAAiB;;YAC1B,MAAM,WAAW,GAAG,MAAM,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,CAAC;YAC/C,QAAQ,IAAI,IAAI,CAAC,SAAS,CAAC,EAAE,QAAQ,EAAE,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;YACvD,IAAI,CAAC,MAAM,IAAI,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YACzC,MAAM,IAAI,CAAC,OAAO,EAAE,CAAC;YACrB,IAAI,CAAC,MAAM,GAAG,UAAU,CAAC,GAAG,EAAE;gBAC5B,WAAW,EAAE,CAAC;gBACd,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;YAClC,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;QAC3B,CAAC;KAAA;IA2CD;;;;;OAKG;IACW,mBAAmB,CAC/B,OAAe;;YAEf,OAAO,MAAM,IAAA,2CAAwB,EAAC,GAAS,EAAE;gBAC/C,IAAA,cAAM,EAAC,IAAI,CAAC,QAAQ,EAAE,mBAAmB,CAAC,CAAC;gBAC3C,OAAO,MAAM,IAAA,wBAAK,EAAC,IAAI,CAAC,QAAQ,EAAE,YAAY,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC;YAC7D,CAAC,CAAA,CAAC,CAAC;QACL,CAAC;KAAA;IAED;;;;;OAKG;IACG,wBAAwB,CAC5B,SAAmB;;YAEnB,OAAO,MAAM,OAAO,CAAC,GAAG,CACtB,SAAS,CAAC,GAAG,CAAC,CAAC,OAAO,EAAyC,EAAE;gBAC/D,OAAO,IAAA,2CAAwB,EAAC,GAAS,EAAE;oBACzC,IAAA,cAAM,EAAC,IAAI,CAAC,QAAQ,EAAE,mBAAmB,CAAC,CAAC;oBAC3C,MAAM,OAAO,GAAG,MAAM,IAAA,wBAAK,EAAC,IAAI,CAAC,QAAQ,EAAE,YAAY,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC;oBACpE,OAAO,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;gBAC5B,CAAC,CAAA,CAAC,CAAC;YACL,CAAC,CAAC,CACH,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE;gBACf,OAAO,KAAK,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,IAAI,EAAE,EAAE;oBAChC,IAAI,CAAC,IAAI,EAAE;wBACT,OAAO,GAAG,CAAC;qBACZ;oBAED,MAAM,CAAC,OAAO,EAAE,OAAO,CAAC,GAAG,IAAI,CAAC;oBAChC,uCACK,GAAG,KACN,CAAC,OAAO,CAAC,EAAE;4BACT,OAAO;yBACR,IACD;gBACJ,CAAC,EAAE,EAAE,CAAC,CAAC;YACT,CAAC,CAAC,CAAC;QACL,CAAC;KAAA;CACF;AA1OD,4DA0OC;AAED,kBAAe,wBAAwB,CAAC","sourcesContent":["import {\n  BaseConfig,\n  BaseController,\n  BaseState,\n} from '@metamask/base-controller';\nimport {\n  BNToHex,\n  query,\n  safelyExecuteWithTimeout,\n} from '@metamask/controller-utils';\nimport { NetworkState } from '@metamask/network-controller';\nimport { cloneDeep } from 'lodash';\nimport EthQuery from '@metamask/eth-query';\nimport type { Provider } from '@metamask/eth-query';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport { Hex, assert } from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\n\n/**\n * @type AccountInformation\n *\n * Account information object\n * @property balance - Hex string of an account balancec in wei\n */\nexport interface AccountInformation {\n  balance: string;\n}\n\n/**\n * @type AccountTrackerConfig\n *\n * Account tracker controller configuration\n * @property provider - Provider used to create a new underlying EthQuery instance\n */\nexport interface AccountTrackerConfig extends BaseConfig {\n  interval: number;\n  provider?: Provider;\n}\n\n/**\n * @type AccountTrackerState\n *\n * Account tracker controller state\n * @property accounts - Map of addresses to account information\n */\nexport interface AccountTrackerState extends BaseState {\n  accounts: { [address: string]: AccountInformation };\n  accountsByChainId: Record<\n    string,\n    {\n      [address: string]: AccountInformation;\n    }\n  >;\n}\n\n/**\n * Controller that tracks the network balances for all user accounts.\n */\nexport class AccountTrackerController extends BaseController<\n  AccountTrackerConfig,\n  AccountTrackerState\n> {\n  private ethQuery?: EthQuery;\n\n  private mutex = new Mutex();\n\n  private handle?: ReturnType<typeof setTimeout>;\n\n  private syncAccounts(newChainId: Hex) {\n    const { accounts } = this.state;\n    const accountsByChainId = cloneDeep(this.state.accountsByChainId);\n    const addresses = Object.keys(this.getIdentities());\n    const existing = Object.keys(accounts);\n    if (!accountsByChainId[newChainId]) {\n      accountsByChainId[newChainId] = {};\n      existing.forEach((address) => {\n        accountsByChainId[newChainId][address] = { balance: '0x0' };\n      });\n    }\n\n    const newAddresses = addresses.filter(\n      (address) => existing.indexOf(address) === -1,\n    );\n    const oldAddresses = existing.filter(\n      (address) => addresses.indexOf(address) === -1,\n    );\n    newAddresses.forEach((address) => {\n      accounts[address] = { balance: '0x0' };\n    });\n    Object.keys(accountsByChainId).forEach((chainId) => {\n      newAddresses.forEach((address) => {\n        accountsByChainId[chainId][address] = {\n          balance: '0x0',\n        };\n      });\n    });\n    oldAddresses.forEach((address) => {\n      delete accounts[address];\n    });\n    Object.keys(accountsByChainId).forEach((chainId) => {\n      oldAddresses.forEach((address) => {\n        delete accountsByChainId[chainId][address];\n      });\n    });\n    this.update({ accounts: { ...accounts }, accountsByChainId });\n  }\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'AccountTrackerController';\n\n  private getIdentities: () => PreferencesState['identities'];\n\n  private getSelectedAddress: () => PreferencesState['selectedAddress'];\n\n  private getMultiAccountBalancesEnabled: () => PreferencesState['isMultiAccountBalancesEnabled'];\n\n  getCurrentChainId: () => NetworkState['providerConfig']['chainId'];\n\n  /**\n   * Creates an AccountTracker instance.\n   *\n   * @param options - The controller options.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.getIdentities - Gets the identities from the Preferences store.\n   * @param options.getSelectedAddress - Gets the selected address from the Preferences store.\n   * @param options.getMultiAccountBalancesEnabled - Gets the multi account balances enabled flag from the Preferences store.\n   * @param options.getCurrentChainId - Gets the chain ID for the current network from the Network store.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      onPreferencesStateChange,\n      getIdentities,\n      getSelectedAddress,\n      getMultiAccountBalancesEnabled,\n      getCurrentChainId,\n    }: {\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      getIdentities: () => PreferencesState['identities'];\n      getSelectedAddress: () => PreferencesState['selectedAddress'];\n      getMultiAccountBalancesEnabled: () => PreferencesState['isMultiAccountBalancesEnabled'];\n      getCurrentChainId: () => NetworkState['providerConfig']['chainId'];\n    },\n    config?: Partial<AccountTrackerConfig>,\n    state?: Partial<AccountTrackerState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      interval: 10000,\n    };\n    this.defaultState = {\n      accounts: {},\n      accountsByChainId: {\n        [getCurrentChainId()]: {},\n      },\n    };\n    this.initialize();\n    this.getIdentities = getIdentities;\n    this.getSelectedAddress = getSelectedAddress;\n    this.getMultiAccountBalancesEnabled = getMultiAccountBalancesEnabled;\n    onPreferencesStateChange(() => {\n      this.refresh();\n    });\n    this.getCurrentChainId = getCurrentChainId;\n    this.poll();\n  }\n\n  /**\n   * Sets a new provider.\n   *\n   * TODO: Replace this wth a method.\n   *\n   * @param provider - Provider used to create a new underlying EthQuery instance.\n   */\n  set provider(provider: Provider) {\n    this.ethQuery = new EthQuery(provider);\n  }\n\n  get provider() {\n    throw new Error('Property only used for setting');\n  }\n\n  /**\n   * Starts a new polling interval.\n   *\n   * @param interval - Polling interval trigger a 'refresh'.\n   */\n  async poll(interval?: number): Promise<void> {\n    const releaseLock = await this.mutex.acquire();\n    interval && this.configure({ interval }, false, false);\n    this.handle && clearTimeout(this.handle);\n    await this.refresh();\n    this.handle = setTimeout(() => {\n      releaseLock();\n      this.poll(this.config.interval);\n    }, this.config.interval);\n  }\n\n  /**\n   * Refreshes the balances of the accounts depending on the multi-account setting.\n   * If multi-account is disabled, only updates the selected account balance.\n   * If multi-account is enabled, updates balances for all accounts.\n   *\n   * @async\n   */\n  refresh = async () => {\n    const chainId = this.getCurrentChainId();\n    this.syncAccounts(chainId);\n    const accounts = { ...this.state.accounts };\n    const accountsByChainId = Object.assign({}, this.state.accountsByChainId);\n    const accountsForChain = Object.assign({}, accountsByChainId[chainId]);\n    const isMultiAccountBalancesEnabled = this.getMultiAccountBalancesEnabled();\n\n    const accountsToUpdate = isMultiAccountBalancesEnabled\n      ? Object.keys(accounts)\n      : [this.getSelectedAddress()];\n\n    for (const address of accountsToUpdate) {\n      const balance = await this.getBalanceFromChain(address);\n      if (!balance) {\n        continue;\n      }\n      const hexBalance = BNToHex(balance);\n      accounts[address] = {\n        balance: hexBalance,\n      };\n      accountsForChain[address] = {\n        balance: hexBalance,\n      };\n    }\n\n    this.update({\n      accounts,\n      accountsByChainId: Object.assign(Object.assign({}, accountsByChainId), {\n        [chainId]: accountsForChain,\n      }),\n    });\n  };\n\n  /**\n   * Fetches the balance of a given address from the blockchain.\n   *\n   * @param address - The account address to fetch the balance for.\n   * @returns A promise that resolves to the balance in a hex string format.\n   */\n  private async getBalanceFromChain(\n    address: string,\n  ): Promise<string | undefined> {\n    return await safelyExecuteWithTimeout(async () => {\n      assert(this.ethQuery, 'Provider not set.');\n      return await query(this.ethQuery, 'getBalance', [address]);\n    });\n  }\n\n  /**\n   * Sync accounts balances with some additional addresses.\n   *\n   * @param addresses - the additional addresses, may be hardware wallet addresses.\n   * @returns accounts - addresses with synced balance\n   */\n  async syncBalanceWithAddresses(\n    addresses: string[],\n  ): Promise<Record<string, { balance: string }>> {\n    return await Promise.all(\n      addresses.map((address): Promise<[string, string] | undefined> => {\n        return safelyExecuteWithTimeout(async () => {\n          assert(this.ethQuery, 'Provider not set.');\n          const balance = await query(this.ethQuery, 'getBalance', [address]);\n          return [address, balance];\n        });\n      }),\n    ).then((value) => {\n      return value.reduce((obj, item) => {\n        if (!item) {\n          return obj;\n        }\n\n        const [address, balance] = item;\n        return {\n          ...obj,\n          [address]: {\n            balance,\n          },\n        };\n      }, {});\n    });\n  }\n}\n\nexport default AccountTrackerController;\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/AssetsContractController.d.ts b/node_modules/@metamask/assets-controllers/dist/AssetsContractController.d.ts
index 1d65d48..2f865d2 100644
--- a/node_modules/@metamask/assets-controllers/dist/AssetsContractController.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/AssetsContractController.d.ts
@@ -1,14 +1,13 @@
 /// <reference types="bn.js" />
+import { BN } from 'ethereumjs-util';
 import { Web3Provider } from '@ethersproject/providers';
-import type { BaseConfig, BaseState } from '@metamask/base-controller';
-import { BaseController } from '@metamask/base-controller';
 import type { NetworkClientId, NetworkState, NetworkController } from '@metamask/network-controller';
-import type { PreferencesState } from '@metamask/preferences-controller';
 import type { Hex } from '@metamask/utils';
-import type { BN } from 'ethereumjs-util';
-import { ERC20Standard } from './Standards/ERC20Standard';
-import { ERC1155Standard } from './Standards/NftStandards/ERC1155/ERC1155Standard';
+import { BaseController, BaseConfig, BaseState } from '@metamask/base-controller';
+import type { PreferencesState } from '@metamask/preferences-controller';
 import { ERC721Standard } from './Standards/NftStandards/ERC721/ERC721Standard';
+import { ERC1155Standard } from './Standards/NftStandards/ERC1155/ERC1155Standard';
+import { ERC20Standard } from './Standards/ERC20Standard';
 /**
  * Check if token detection is enabled for certain networks
  *
diff --git a/node_modules/@metamask/assets-controllers/dist/AssetsContractController.d.ts.map b/node_modules/@metamask/assets-controllers/dist/AssetsContractController.d.ts.map
index 8214625..b70ded6 100644
--- a/node_modules/@metamask/assets-controllers/dist/AssetsContractController.d.ts.map
+++ b/node_modules/@metamask/assets-controllers/dist/AssetsContractController.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"AssetsContractController.d.ts","sourceRoot":"","sources":["../src/AssetsContractController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"AssetsContractController.d.ts","sourceRoot":"","sources":["../src/AssetsContractController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/AssetsContractController.js b/node_modules/@metamask/assets-controllers/dist/AssetsContractController.js
index 02abdc7..9b2ab2e 100644
--- a/node_modules/@metamask/assets-controllers/dist/AssetsContractController.js
+++ b/node_modules/@metamask/assets-controllers/dist/AssetsContractController.js
@@ -13,15 +13,15 @@ var __importDefault = (this && this.__importDefault) || function (mod) {
 };
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.AssetsContractController = exports.MISSING_PROVIDER_ERROR = exports.SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID = void 0;
+const single_call_balance_checker_abi_1 = __importDefault(require("single-call-balance-checker-abi"));
 const contracts_1 = require("@ethersproject/contracts");
 const providers_1 = require("@ethersproject/providers");
 const base_controller_1 = require("@metamask/base-controller");
 const controller_utils_1 = require("@metamask/controller-utils");
-const single_call_balance_checker_abi_1 = __importDefault(require("single-call-balance-checker-abi"));
 const assetsUtil_1 = require("./assetsUtil");
-const ERC20Standard_1 = require("./Standards/ERC20Standard");
-const ERC1155Standard_1 = require("./Standards/NftStandards/ERC1155/ERC1155Standard");
 const ERC721Standard_1 = require("./Standards/NftStandards/ERC721/ERC721Standard");
+const ERC1155Standard_1 = require("./Standards/NftStandards/ERC1155/ERC1155Standard");
+const ERC20Standard_1 = require("./Standards/ERC20Standard");
 /**
  * Check if token detection is enabled for certain networks
  *
@@ -36,6 +36,10 @@ exports.SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID = {
     [assetsUtil_1.SupportedTokenDetectionNetworks.aurora]: '0x1286415D333855237f89Df27D388127181448538',
     [assetsUtil_1.SupportedTokenDetectionNetworks.linea_goerli]: '0x10dAd7Ca3921471f616db788D9300DC97Db01783',
     [assetsUtil_1.SupportedTokenDetectionNetworks.linea_mainnet]: '0xF62e6a41561b3650a69Bb03199C735e3E3328c0D',
+    [assetsUtil_1.SupportedTokenDetectionNetworks.arbitrum]: '0x151E24A486D7258dd7C33Fb67E4bB01919B7B32c',
+    [assetsUtil_1.SupportedTokenDetectionNetworks.optimism]: '0xB1c568e9C3E6bdaf755A60c7418C269eb11524FC',
+    [assetsUtil_1.SupportedTokenDetectionNetworks.base]: '0x6AA75276052D96696134252587894ef5FFA520af',
+    [assetsUtil_1.SupportedTokenDetectionNetworks.zksync]: '0x458fEd3144680a5b8bcfaa0F9594aa19B4Ea2D34',
 };
 exports.MISSING_PROVIDER_ERROR = 'AssetsContractController failed to set the provider correctly. A provider must be set for this method to be available';
 /**
diff --git a/node_modules/@metamask/assets-controllers/dist/AssetsContractController.js.map b/node_modules/@metamask/assets-controllers/dist/AssetsContractController.js.map
index 2811ad5..63befed 100644
--- a/node_modules/@metamask/assets-controllers/dist/AssetsContractController.js.map
+++ b/node_modules/@metamask/assets-controllers/dist/AssetsContractController.js.map
@@ -1 +1 @@
-{"version":3,"file":"AssetsContractController.js","sourceRoot":"","sources":["../src/AssetsContractController.ts"],"names":[],"mappings":"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","sourcesContent":["import { Contract } from '@ethersproject/contracts';\nimport { Web3Provider } from '@ethersproject/providers';\nimport type { BaseConfig, BaseState } from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport { IPFS_DEFAULT_GATEWAY_URL } from '@metamask/controller-utils';\nimport type {\n  NetworkClientId,\n  NetworkState,\n  NetworkController,\n} from '@metamask/network-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport type { Hex } from '@metamask/utils';\nimport type { BN } from 'ethereumjs-util';\nimport abiSingleCallBalancesContract from 'single-call-balance-checker-abi';\n\nimport { SupportedTokenDetectionNetworks } from './assetsUtil';\nimport { ERC20Standard } from './Standards/ERC20Standard';\nimport { ERC1155Standard } from './Standards/NftStandards/ERC1155/ERC1155Standard';\nimport { ERC721Standard } from './Standards/NftStandards/ERC721/ERC721Standard';\n\n/**\n * Check if token detection is enabled for certain networks\n *\n * @param chainId - ChainID of network\n * @returns Whether the current network supports token detection\n */\nexport const SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID: Record<Hex, string> = {\n  [SupportedTokenDetectionNetworks.mainnet]:\n    '0xb1f8e55c7f64d203c1400b9d8555d050f94adf39',\n  [SupportedTokenDetectionNetworks.bsc]:\n    '0x2352c63A83f9Fd126af8676146721Fa00924d7e4',\n  [SupportedTokenDetectionNetworks.polygon]:\n    '0x2352c63A83f9Fd126af8676146721Fa00924d7e4',\n  [SupportedTokenDetectionNetworks.avax]:\n    '0xD023D153a0DFa485130ECFdE2FAA7e612EF94818',\n  [SupportedTokenDetectionNetworks.aurora]:\n    '0x1286415D333855237f89Df27D388127181448538',\n  [SupportedTokenDetectionNetworks.linea_goerli]:\n    '0x10dAd7Ca3921471f616db788D9300DC97Db01783',\n  [SupportedTokenDetectionNetworks.linea_mainnet]:\n    '0xF62e6a41561b3650a69Bb03199C735e3E3328c0D',\n};\n\nexport const MISSING_PROVIDER_ERROR =\n  'AssetsContractController failed to set the provider correctly. A provider must be set for this method to be available';\n\n/**\n * @type AssetsContractConfig\n *\n * Assets Contract controller configuration\n * @property provider - Provider used to create a new web3 instance\n */\nexport interface AssetsContractConfig extends BaseConfig {\n  provider: any;\n  ipfsGateway: string;\n  chainId: Hex;\n}\n\n/**\n * @type BalanceMap\n *\n * Key value object containing the balance for each tokenAddress\n * @property [tokenAddress] - Address of the token\n */\nexport interface BalanceMap {\n  [tokenAddress: string]: BN;\n}\n\n/**\n * Controller that interacts with contracts on mainnet through web3\n */\nexport class AssetsContractController extends BaseController<\n  AssetsContractConfig,\n  BaseState\n> {\n  private _provider?: any;\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'AssetsContractController';\n\n  private readonly getNetworkClientById: NetworkController['getNetworkClientById'];\n\n  /**\n   * Creates a AssetsContractController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param options.getNetworkClientById - Gets the network client with the given id from the NetworkController.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      chainId: initialChainId,\n      onPreferencesStateChange,\n      onNetworkStateChange,\n      getNetworkClientById,\n    }: {\n      chainId: Hex;\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      getNetworkClientById: NetworkController['getNetworkClientById'];\n    },\n    config?: Partial<AssetsContractConfig>,\n    state?: Partial<BaseState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      provider: undefined,\n      ipfsGateway: IPFS_DEFAULT_GATEWAY_URL,\n      chainId: initialChainId,\n    };\n    this.initialize();\n    this.getNetworkClientById = getNetworkClientById;\n\n    onPreferencesStateChange(({ ipfsGateway }) => {\n      this.configure({ ipfsGateway });\n    });\n\n    onNetworkStateChange((networkState) => {\n      if (this.config.chainId !== networkState.providerConfig.chainId) {\n        this.configure({\n          chainId: networkState.providerConfig.chainId,\n        });\n      }\n    });\n  }\n\n  /**\n   * Sets a new provider.\n   *\n   * TODO: Replace this wth a method.\n   *\n   * @property provider - Provider used to create a new underlying Web3 instance\n   */\n  set provider(provider: any) {\n    this._provider = provider;\n  }\n\n  get provider() {\n    throw new Error('Property only used for setting');\n  }\n\n  /**\n   * Get the relevant provider instance.\n   *\n   * @param networkClientId - Network Client ID.\n   * @returns Web3Provider instance.\n   */\n  getProvider(networkClientId?: NetworkClientId): Web3Provider {\n    const provider = networkClientId\n      ? this.getNetworkClientById(networkClientId).provider\n      : this._provider;\n\n    if (provider === undefined) {\n      throw new Error(MISSING_PROVIDER_ERROR);\n    }\n\n    return new Web3Provider(provider);\n  }\n\n  /**\n   * Get the relevant chain ID.\n   *\n   * @param networkClientId - Network Client ID used to get the provider.\n   * @returns Hex chain ID.\n   */\n  getChainId(networkClientId?: NetworkClientId): Hex {\n    return networkClientId\n      ? this.getNetworkClientById(networkClientId).configuration.chainId\n      : this.config.chainId;\n  }\n\n  /**\n   * Get a ERC20Standard instance using the relevant provider instance.\n   *\n   * @param networkClientId - Network Client ID used to get the provider.\n   * @returns ERC20Standard instance.\n   */\n  getERC20Standard(networkClientId?: NetworkClientId): ERC20Standard {\n    const provider = this.getProvider(networkClientId);\n    return new ERC20Standard(provider);\n  }\n\n  /**\n   * Get a ERC721Standard instance using the relevant provider instance.\n   *\n   * @param networkClientId - Network Client ID used to get the provider.\n   * @returns ERC721Standard instance.\n   */\n  getERC721Standard(networkClientId?: NetworkClientId): ERC721Standard {\n    const provider = this.getProvider(networkClientId);\n    return new ERC721Standard(provider);\n  }\n\n  /**\n   * Get a ERC1155Standard instance using the relevant provider instance.\n   *\n   * @param networkClientId - Network Client ID used to get the provider.\n   * @returns ERC1155Standard instance.\n   */\n  getERC1155Standard(networkClientId?: NetworkClientId): ERC1155Standard {\n    const provider = this.getProvider(networkClientId);\n    return new ERC1155Standard(provider);\n  }\n\n  /**\n   * Get balance or count for current account on specific asset contract.\n   *\n   * @param address - Asset ERC20 contract address.\n   * @param selectedAddress - Current account public address.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to BN object containing balance for current account on specific asset contract.\n   */\n  async getERC20BalanceOf(\n    address: string,\n    selectedAddress: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<BN> {\n    const erc20Standard = this.getERC20Standard(networkClientId);\n    return erc20Standard.getBalanceOf(address, selectedAddress);\n  }\n\n  /**\n   * Query for the decimals for a given ERC20 asset.\n   *\n   * @param address - ERC20 asset contract address.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'decimals'.\n   */\n  async getERC20TokenDecimals(\n    address: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc20Standard = this.getERC20Standard(networkClientId);\n    return erc20Standard.getTokenDecimals(address);\n  }\n\n  /**\n   * Query for the name for a given ERC20 asset.\n   *\n   * @param address - ERC20 asset contract address.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'decimals'.\n   */\n  async getERC20TokenName(\n    address: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc20Standard = this.getERC20Standard(networkClientId);\n    return erc20Standard.getTokenName(address);\n  }\n\n  /**\n   * Enumerate assets assigned to an owner.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param selectedAddress - Current account public address.\n   * @param index - An NFT counter less than `balanceOf(selectedAddress)`.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to token identifier for the 'index'th asset assigned to 'selectedAddress'.\n   */\n  getERC721NftTokenId(\n    address: string,\n    selectedAddress: string,\n    index: number,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc721Standard = this.getERC721Standard(networkClientId);\n    return erc721Standard.getNftTokenId(address, selectedAddress, index);\n  }\n\n  /**\n   * Enumerate assets assigned to an owner.\n   *\n   * @param tokenAddress - ERC721 asset contract address.\n   * @param userAddress - Current account public address.\n   * @param tokenId - ERC721 asset identifier.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to an object containing the token standard and a set of details which depend on which standard the token supports.\n   */\n  async getTokenStandardAndDetails(\n    tokenAddress: string,\n    userAddress?: string,\n    tokenId?: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<{\n    standard: string;\n    tokenURI?: string | undefined;\n    symbol?: string | undefined;\n    name?: string | undefined;\n    decimals?: string | undefined;\n    balance?: BN | undefined;\n  }> {\n    // Asserts provider is available\n    this.getProvider(networkClientId);\n\n    const { ipfsGateway } = this.config;\n\n    // ERC721\n    try {\n      const erc721Standard = this.getERC721Standard(networkClientId);\n      return {\n        ...(await erc721Standard.getDetails(\n          tokenAddress,\n          ipfsGateway,\n          tokenId,\n        )),\n      };\n    } catch {\n      // Ignore\n    }\n\n    // ERC1155\n    try {\n      const erc1155Standard = this.getERC1155Standard(networkClientId);\n      return {\n        ...(await erc1155Standard.getDetails(\n          tokenAddress,\n          ipfsGateway,\n          tokenId,\n        )),\n      };\n    } catch {\n      // Ignore\n    }\n\n    // ERC20\n    try {\n      const erc20Standard = this.getERC20Standard(networkClientId);\n      return {\n        ...(await erc20Standard.getDetails(tokenAddress, userAddress)),\n      };\n    } catch {\n      // Ignore\n    }\n\n    throw new Error('Unable to determine contract standard');\n  }\n\n  /**\n   * Query for tokenURI for a given ERC721 asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param tokenId - ERC721 asset identifier.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'tokenURI'.\n   */\n  async getERC721TokenURI(\n    address: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc721Standard = this.getERC721Standard(networkClientId);\n    return erc721Standard.getTokenURI(address, tokenId);\n  }\n\n  /**\n   * Query for name for a given asset.\n   *\n   * @param address - ERC721 or ERC20 asset contract address.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'name'.\n   */\n  async getERC721AssetName(\n    address: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc721Standard = this.getERC721Standard(networkClientId);\n    return erc721Standard.getAssetName(address);\n  }\n\n  /**\n   * Query for symbol for a given asset.\n   *\n   * @param address - ERC721 or ERC20 asset contract address.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'symbol'.\n   */\n  async getERC721AssetSymbol(\n    address: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc721Standard = this.getERC721Standard(networkClientId);\n    return erc721Standard.getAssetSymbol(address);\n  }\n\n  /**\n   * Query for owner for a given ERC721 asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param tokenId - ERC721 asset identifier.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the owner address.\n   */\n  async getERC721OwnerOf(\n    address: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc721Standard = this.getERC721Standard(networkClientId);\n    return erc721Standard.getOwnerOf(address, tokenId);\n  }\n\n  /**\n   * Query for tokenURI for a given asset.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @param tokenId - ERC1155 asset identifier.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'tokenURI'.\n   */\n  async getERC1155TokenURI(\n    address: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc1155Standard = this.getERC1155Standard(networkClientId);\n    return erc1155Standard.getTokenURI(address, tokenId);\n  }\n\n  /**\n   * Query for balance of a given ERC 1155 token.\n   *\n   * @param userAddress - Wallet public address.\n   * @param nftAddress - ERC1155 asset contract address.\n   * @param nftId - ERC1155 asset identifier.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'balanceOf'.\n   */\n  async getERC1155BalanceOf(\n    userAddress: string,\n    nftAddress: string,\n    nftId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<BN> {\n    const erc1155Standard = this.getERC1155Standard(networkClientId);\n    return erc1155Standard.getBalanceOf(nftAddress, userAddress, nftId);\n  }\n\n  /**\n   * Transfer single ERC1155 token.\n   *\n   * @param nftAddress - ERC1155 token address.\n   * @param senderAddress - ERC1155 token sender.\n   * @param recipientAddress - ERC1155 token recipient.\n   * @param nftId - ERC1155 token id.\n   * @param qty - Quantity of tokens to be sent.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'transferSingle' ERC1155 token.\n   */\n  async transferSingleERC1155(\n    nftAddress: string,\n    senderAddress: string,\n    recipientAddress: string,\n    nftId: string,\n    qty: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<void> {\n    const erc1155Standard = this.getERC1155Standard(networkClientId);\n    return erc1155Standard.transferSingle(\n      nftAddress,\n      senderAddress,\n      recipientAddress,\n      nftId,\n      qty,\n    );\n  }\n\n  /**\n   * Get the token balance for a list of token addresses in a single call. Only non-zero balances\n   * are returned.\n   *\n   * @param selectedAddress - The address to check token balances for.\n   * @param tokensToDetect - The token addresses to detect balances for.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns The list of non-zero token balances.\n   */\n  async getBalancesInSingleCall(\n    selectedAddress: string,\n    tokensToDetect: string[],\n    networkClientId?: NetworkClientId,\n  ) {\n    const chainId = this.getChainId(networkClientId);\n    const provider = this.getProvider(networkClientId);\n    if (!(chainId in SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID)) {\n      // Only fetch balance if contract address exists\n      return {};\n    }\n    const contractAddress = SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID[chainId];\n\n    const contract = new Contract(\n      contractAddress,\n      abiSingleCallBalancesContract,\n      provider,\n    );\n    const result = await contract.balances([selectedAddress], tokensToDetect);\n    const nonZeroBalances: BalanceMap = {};\n    /* istanbul ignore else */\n    if (result.length > 0) {\n      tokensToDetect.forEach((tokenAddress, index) => {\n        const balance: BN = result[index];\n        /* istanbul ignore else */\n        if (String(balance) !== '0') {\n          nonZeroBalances[tokenAddress] = balance;\n        }\n      });\n    }\n    return nonZeroBalances;\n  }\n}\n\nexport default AssetsContractController;\n"]}
\ No newline at end of file
+{"version":3,"file":"AssetsContractController.js","sourceRoot":"","sources":["../src/AssetsContractController.ts"],"names":[],"mappings":"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","sourcesContent":["import { BN } from 'ethereumjs-util';\nimport abiSingleCallBalancesContract from 'single-call-balance-checker-abi';\nimport { Contract } from '@ethersproject/contracts';\nimport { Web3Provider } from '@ethersproject/providers';\nimport type {\n  NetworkClientId,\n  NetworkState,\n  NetworkController,\n} from '@metamask/network-controller';\nimport type { Hex } from '@metamask/utils';\nimport {\n  BaseController,\n  BaseConfig,\n  BaseState,\n} from '@metamask/base-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport { IPFS_DEFAULT_GATEWAY_URL } from '@metamask/controller-utils';\nimport { SupportedTokenDetectionNetworks } from './assetsUtil';\nimport { ERC721Standard } from './Standards/NftStandards/ERC721/ERC721Standard';\nimport { ERC1155Standard } from './Standards/NftStandards/ERC1155/ERC1155Standard';\nimport { ERC20Standard } from './Standards/ERC20Standard';\n\n/**\n * Check if token detection is enabled for certain networks\n *\n * @param chainId - ChainID of network\n * @returns Whether the current network supports token detection\n */\nexport const SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID: Record<Hex, string> = {\n  [SupportedTokenDetectionNetworks.mainnet]:\n    '0xb1f8e55c7f64d203c1400b9d8555d050f94adf39',\n  [SupportedTokenDetectionNetworks.bsc]:\n    '0x2352c63A83f9Fd126af8676146721Fa00924d7e4',\n  [SupportedTokenDetectionNetworks.polygon]:\n    '0x2352c63A83f9Fd126af8676146721Fa00924d7e4',\n  [SupportedTokenDetectionNetworks.avax]:\n    '0xD023D153a0DFa485130ECFdE2FAA7e612EF94818',\n  [SupportedTokenDetectionNetworks.aurora]:\n    '0x1286415D333855237f89Df27D388127181448538',\n  [SupportedTokenDetectionNetworks.linea_goerli]:\n    '0x10dAd7Ca3921471f616db788D9300DC97Db01783',\n  [SupportedTokenDetectionNetworks.linea_mainnet]:\n    '0xF62e6a41561b3650a69Bb03199C735e3E3328c0D',\n  [SupportedTokenDetectionNetworks.arbitrum]:\n    '0x151E24A486D7258dd7C33Fb67E4bB01919B7B32c',\n  [SupportedTokenDetectionNetworks.optimism]:\n    '0xB1c568e9C3E6bdaf755A60c7418C269eb11524FC',\n  [SupportedTokenDetectionNetworks.base]:\n    '0x6AA75276052D96696134252587894ef5FFA520af',\n  [SupportedTokenDetectionNetworks.zksync]:\n    '0x458fEd3144680a5b8bcfaa0F9594aa19B4Ea2D34',\n};\n\nexport const MISSING_PROVIDER_ERROR =\n  'AssetsContractController failed to set the provider correctly. A provider must be set for this method to be available';\n\n/**\n * @type AssetsContractConfig\n *\n * Assets Contract controller configuration\n * @property provider - Provider used to create a new web3 instance\n */\nexport interface AssetsContractConfig extends BaseConfig {\n  provider: any;\n  ipfsGateway: string;\n  chainId: Hex;\n}\n\n/**\n * @type BalanceMap\n *\n * Key value object containing the balance for each tokenAddress\n * @property [tokenAddress] - Address of the token\n */\nexport interface BalanceMap {\n  [tokenAddress: string]: BN;\n}\n\n/**\n * Controller that interacts with contracts on mainnet through web3\n */\nexport class AssetsContractController extends BaseController<\n  AssetsContractConfig,\n  BaseState\n> {\n  private _provider?: any;\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'AssetsContractController';\n\n  private readonly getNetworkClientById: NetworkController['getNetworkClientById'];\n\n  /**\n   * Creates a AssetsContractController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param options.getNetworkClientById - Gets the network client with the given id from the NetworkController.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      chainId: initialChainId,\n      onPreferencesStateChange,\n      onNetworkStateChange,\n      getNetworkClientById,\n    }: {\n      chainId: Hex;\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      getNetworkClientById: NetworkController['getNetworkClientById'];\n    },\n    config?: Partial<AssetsContractConfig>,\n    state?: Partial<BaseState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      provider: undefined,\n      ipfsGateway: IPFS_DEFAULT_GATEWAY_URL,\n      chainId: initialChainId,\n    };\n    this.initialize();\n    this.getNetworkClientById = getNetworkClientById;\n\n    onPreferencesStateChange(({ ipfsGateway }) => {\n      this.configure({ ipfsGateway });\n    });\n\n    onNetworkStateChange((networkState) => {\n      if (this.config.chainId !== networkState.providerConfig.chainId) {\n        this.configure({\n          chainId: networkState.providerConfig.chainId,\n        });\n      }\n    });\n  }\n\n  /**\n   * Sets a new provider.\n   *\n   * TODO: Replace this wth a method.\n   *\n   * @property provider - Provider used to create a new underlying Web3 instance\n   */\n  set provider(provider: any) {\n    this._provider = provider;\n  }\n\n  get provider() {\n    throw new Error('Property only used for setting');\n  }\n\n  /**\n   * Get the relevant provider instance.\n   *\n   * @param networkClientId - Network Client ID.\n   * @returns Web3Provider instance.\n   */\n  getProvider(networkClientId?: NetworkClientId): Web3Provider {\n    const provider = networkClientId\n      ? this.getNetworkClientById(networkClientId).provider\n      : this._provider;\n\n    if (provider === undefined) {\n      throw new Error(MISSING_PROVIDER_ERROR);\n    }\n\n    return new Web3Provider(provider);\n  }\n\n  /**\n   * Get the relevant chain ID.\n   *\n   * @param networkClientId - Network Client ID used to get the provider.\n   * @returns Hex chain ID.\n   */\n  getChainId(networkClientId?: NetworkClientId): Hex {\n    return networkClientId\n      ? this.getNetworkClientById(networkClientId).configuration.chainId\n      : this.config.chainId;\n  }\n\n  /**\n   * Get a ERC20Standard instance using the relevant provider instance.\n   *\n   * @param networkClientId - Network Client ID used to get the provider.\n   * @returns ERC20Standard instance.\n   */\n  getERC20Standard(networkClientId?: NetworkClientId): ERC20Standard {\n    const provider = this.getProvider(networkClientId);\n    return new ERC20Standard(provider);\n  }\n\n  /**\n   * Get a ERC721Standard instance using the relevant provider instance.\n   *\n   * @param networkClientId - Network Client ID used to get the provider.\n   * @returns ERC721Standard instance.\n   */\n  getERC721Standard(networkClientId?: NetworkClientId): ERC721Standard {\n    const provider = this.getProvider(networkClientId);\n    return new ERC721Standard(provider);\n  }\n\n  /**\n   * Get a ERC1155Standard instance using the relevant provider instance.\n   *\n   * @param networkClientId - Network Client ID used to get the provider.\n   * @returns ERC1155Standard instance.\n   */\n  getERC1155Standard(networkClientId?: NetworkClientId): ERC1155Standard {\n    const provider = this.getProvider(networkClientId);\n    return new ERC1155Standard(provider);\n  }\n\n  /**\n   * Get balance or count for current account on specific asset contract.\n   *\n   * @param address - Asset ERC20 contract address.\n   * @param selectedAddress - Current account public address.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to BN object containing balance for current account on specific asset contract.\n   */\n  async getERC20BalanceOf(\n    address: string,\n    selectedAddress: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<BN> {\n    const erc20Standard = this.getERC20Standard(networkClientId);\n    return erc20Standard.getBalanceOf(address, selectedAddress);\n  }\n\n  /**\n   * Query for the decimals for a given ERC20 asset.\n   *\n   * @param address - ERC20 asset contract address.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'decimals'.\n   */\n  async getERC20TokenDecimals(\n    address: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc20Standard = this.getERC20Standard(networkClientId);\n    return erc20Standard.getTokenDecimals(address);\n  }\n\n  /**\n   * Query for the name for a given ERC20 asset.\n   *\n   * @param address - ERC20 asset contract address.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'decimals'.\n   */\n  async getERC20TokenName(\n    address: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc20Standard = this.getERC20Standard(networkClientId);\n    return erc20Standard.getTokenName(address);\n  }\n\n  /**\n   * Enumerate assets assigned to an owner.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param selectedAddress - Current account public address.\n   * @param index - An NFT counter less than `balanceOf(selectedAddress)`.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to token identifier for the 'index'th asset assigned to 'selectedAddress'.\n   */\n  getERC721NftTokenId(\n    address: string,\n    selectedAddress: string,\n    index: number,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc721Standard = this.getERC721Standard(networkClientId);\n    return erc721Standard.getNftTokenId(address, selectedAddress, index);\n  }\n\n  /**\n   * Enumerate assets assigned to an owner.\n   *\n   * @param tokenAddress - ERC721 asset contract address.\n   * @param userAddress - Current account public address.\n   * @param tokenId - ERC721 asset identifier.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to an object containing the token standard and a set of details which depend on which standard the token supports.\n   */\n  async getTokenStandardAndDetails(\n    tokenAddress: string,\n    userAddress?: string,\n    tokenId?: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<{\n    standard: string;\n    tokenURI?: string | undefined;\n    symbol?: string | undefined;\n    name?: string | undefined;\n    decimals?: string | undefined;\n    balance?: BN | undefined;\n  }> {\n    // Asserts provider is available\n    this.getProvider(networkClientId);\n\n    const { ipfsGateway } = this.config;\n\n    // ERC721\n    try {\n      const erc721Standard = this.getERC721Standard(networkClientId);\n      return {\n        ...(await erc721Standard.getDetails(\n          tokenAddress,\n          ipfsGateway,\n          tokenId,\n        )),\n      };\n    } catch {\n      // Ignore\n    }\n\n    // ERC1155\n    try {\n      const erc1155Standard = this.getERC1155Standard(networkClientId);\n      return {\n        ...(await erc1155Standard.getDetails(\n          tokenAddress,\n          ipfsGateway,\n          tokenId,\n        )),\n      };\n    } catch {\n      // Ignore\n    }\n\n    // ERC20\n    try {\n      const erc20Standard = this.getERC20Standard(networkClientId);\n      return {\n        ...(await erc20Standard.getDetails(tokenAddress, userAddress)),\n      };\n    } catch {\n      // Ignore\n    }\n\n    throw new Error('Unable to determine contract standard');\n  }\n\n  /**\n   * Query for tokenURI for a given ERC721 asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param tokenId - ERC721 asset identifier.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'tokenURI'.\n   */\n  async getERC721TokenURI(\n    address: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc721Standard = this.getERC721Standard(networkClientId);\n    return erc721Standard.getTokenURI(address, tokenId);\n  }\n\n  /**\n   * Query for name for a given asset.\n   *\n   * @param address - ERC721 or ERC20 asset contract address.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'name'.\n   */\n  async getERC721AssetName(\n    address: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc721Standard = this.getERC721Standard(networkClientId);\n    return erc721Standard.getAssetName(address);\n  }\n\n  /**\n   * Query for symbol for a given asset.\n   *\n   * @param address - ERC721 or ERC20 asset contract address.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'symbol'.\n   */\n  async getERC721AssetSymbol(\n    address: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc721Standard = this.getERC721Standard(networkClientId);\n    return erc721Standard.getAssetSymbol(address);\n  }\n\n  /**\n   * Query for owner for a given ERC721 asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param tokenId - ERC721 asset identifier.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the owner address.\n   */\n  async getERC721OwnerOf(\n    address: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc721Standard = this.getERC721Standard(networkClientId);\n    return erc721Standard.getOwnerOf(address, tokenId);\n  }\n\n  /**\n   * Query for tokenURI for a given asset.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @param tokenId - ERC1155 asset identifier.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'tokenURI'.\n   */\n  async getERC1155TokenURI(\n    address: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc1155Standard = this.getERC1155Standard(networkClientId);\n    return erc1155Standard.getTokenURI(address, tokenId);\n  }\n\n  /**\n   * Query for balance of a given ERC 1155 token.\n   *\n   * @param userAddress - Wallet public address.\n   * @param nftAddress - ERC1155 asset contract address.\n   * @param nftId - ERC1155 asset identifier.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'balanceOf'.\n   */\n  async getERC1155BalanceOf(\n    userAddress: string,\n    nftAddress: string,\n    nftId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<BN> {\n    const erc1155Standard = this.getERC1155Standard(networkClientId);\n    return erc1155Standard.getBalanceOf(nftAddress, userAddress, nftId);\n  }\n\n  /**\n   * Transfer single ERC1155 token.\n   *\n   * @param nftAddress - ERC1155 token address.\n   * @param senderAddress - ERC1155 token sender.\n   * @param recipientAddress - ERC1155 token recipient.\n   * @param nftId - ERC1155 token id.\n   * @param qty - Quantity of tokens to be sent.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'transferSingle' ERC1155 token.\n   */\n  async transferSingleERC1155(\n    nftAddress: string,\n    senderAddress: string,\n    recipientAddress: string,\n    nftId: string,\n    qty: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<void> {\n    const erc1155Standard = this.getERC1155Standard(networkClientId);\n    return erc1155Standard.transferSingle(\n      nftAddress,\n      senderAddress,\n      recipientAddress,\n      nftId,\n      qty,\n    );\n  }\n\n  /**\n   * Get the token balance for a list of token addresses in a single call. Only non-zero balances\n   * are returned.\n   *\n   * @param selectedAddress - The address to check token balances for.\n   * @param tokensToDetect - The token addresses to detect balances for.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns The list of non-zero token balances.\n   */\n  async getBalancesInSingleCall(\n    selectedAddress: string,\n    tokensToDetect: string[],\n    networkClientId?: NetworkClientId,\n  ) {\n    const chainId = this.getChainId(networkClientId);\n    const provider = this.getProvider(networkClientId);\n    if (!(chainId in SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID)) {\n      // Only fetch balance if contract address exists\n      return {};\n    }\n    const contractAddress = SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID[chainId];\n\n    const contract = new Contract(\n      contractAddress,\n      abiSingleCallBalancesContract,\n      provider,\n    );\n    const result = await contract.balances([selectedAddress], tokensToDetect);\n    const nonZeroBalances: BalanceMap = {};\n    /* istanbul ignore else */\n    if (result.length > 0) {\n      tokensToDetect.forEach((tokenAddress, index) => {\n        const balance: BN = result[index];\n        /* istanbul ignore else */\n        if (String(balance) !== '0') {\n          nonZeroBalances[tokenAddress] = balance;\n        }\n      });\n    }\n    return nonZeroBalances;\n  }\n}\n\nexport default AssetsContractController;\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/NftController.d.ts b/node_modules/@metamask/assets-controllers/dist/NftController.d.ts
index 7624647..1b1bb90 100644
--- a/node_modules/@metamask/assets-controllers/dist/NftController.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/NftController.d.ts
@@ -8,7 +8,7 @@ import type { Hex } from '@metamask/utils';
 import { EventEmitter } from 'events';
 import type { AssetsContractController } from './AssetsContractController';
 import { Source } from './constants';
-import type { ApiNftCreator, ApiNftLastSale } from './NftDetectionController';
+import type { Collection, Attributes, LastSale } from './NftDetectionController';
 declare type NFTStandardType = 'ERC721' | 'ERC1155';
 declare type SuggestedNftMeta = {
     asset: {
@@ -106,10 +106,14 @@ export interface NftMetadata {
     animation?: string;
     animationOriginal?: string;
     externalLink?: string;
-    creator?: ApiNftCreator;
-    lastSale?: ApiNftLastSale;
+    creator?: string;
     transactionId?: string;
     tokenURI?: string | null;
+    collection?: Collection;
+    address?: string;
+    attributes?: Attributes;
+    lastSale?: LastSale;
+    rarityRank?: string;
 }
 /**
  * @type NftConfig
@@ -121,9 +125,9 @@ export interface NftConfig extends BaseConfig {
     selectedAddress: string;
     chainId: Hex;
     ipfsGateway: string;
-    openSeaEnabled: boolean;
-    useIPFSSubdomains: boolean;
     isIpfsGatewayEnabled: boolean;
+    displayNftMedia: boolean;
+    useIPFSSubdomains: boolean;
 }
 /**
  * @type NftState
@@ -162,14 +166,14 @@ declare type AllowedActions = AddApprovalRequest;
  * The messenger of the {@link NftController}.
  */
 export declare type NftControllerMessenger = RestrictedControllerMessenger<typeof controllerName, AllowedActions, never, AllowedActions['type'], never>;
+export declare const getDefaultNftState: () => NftState;
 /**
  * Controller that stores assets and exposes convenience methods
  */
 export declare class NftController extends BaseController<NftConfig, NftState> {
     private readonly mutex;
     private readonly messagingSystem;
-    private getNftApi;
-    private getNftContractInformationApi;
+    getNftApi(): string;
     /**
      * Helper method to update nested state for allNfts and allNftContracts.
      *
@@ -181,7 +185,7 @@ export declare class NftController extends BaseController<NftConfig, NftState> {
      */
     private updateNestedNftState;
     /**
-     * Request individual NFT information from OpenSea API.
+     * Request individual NFT information from NFT API.
      *
      * @param contractAddress - Hex address of the NFT contract.
      * @param tokenId - The NFT identifier.
@@ -215,13 +219,6 @@ export declare class NftController extends BaseController<NftConfig, NftState> {
      * @returns Promise resolving to the current NFT name and image.
      */
     private getNftInformation;
-    /**
-     * Request NFT contract information from OpenSea API.
-     *
-     * @param contractAddress - Hex address of the NFT contract.
-     * @returns Promise resolving to the current NFT name and image.
-     */
-    private getNftContractInformationFromApi;
     /**
      * Request NFT contract information from the contract itself.
      *
@@ -231,9 +228,10 @@ export declare class NftController extends BaseController<NftConfig, NftState> {
      */
     private getNftContractInformationFromContract;
     /**
-     * Request NFT contract information from OpenSea API.
+     * Request NFT contract information from Blockchain and aggregate with received data from NFTMetadata.
      *
      * @param contractAddress - Hex address of the NFT contract.
+     * @param nftMetadataFromApi - Received NFT information to be aggregated with blockchain contract information.
      * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
      * @returns Promise resolving to the NFT contract name, image and description.
      */
@@ -256,8 +254,8 @@ export declare class NftController extends BaseController<NftConfig, NftState> {
      *
      * @param options - options.
      * @param options.tokenAddress - Hex address of the NFT contract.
-     * @param options.chainId - The chainId of the network where the NFT is being added.
      * @param options.userAddress - The address of the account where the NFT is being added.
+     * @param options.nftMetadata - The retrieved NFTMetadata from API.
      * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
      * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.
      * @returns Promise resolving to the current NFT contracts list.
@@ -268,6 +266,9 @@ export declare class NftController extends BaseController<NftConfig, NftState> {
      *
      * @param address - Hex address of the NFT contract.
      * @param tokenId - Token identifier of the NFT.
+     * @param options - options.
+     * @param options.chainId - The chainId of the network where the NFT is being removed.
+     * @param options.userAddress - The address of the account where the NFT is being removed.
      */
     private removeAndIgnoreIndividualNft;
     /**
@@ -275,19 +276,25 @@ export declare class NftController extends BaseController<NftConfig, NftState> {
      *
      * @param address - Hex address of the NFT contract.
      * @param tokenId - Token identifier of the NFT.
+     * @param options - options.
+     * @param options.chainId - The chainId of the network where the NFT is being removed.
+     * @param options.userAddress - The address of the account where the NFT is being removed.
      */
     private removeIndividualNft;
     /**
      * Removes an NFT contract to the stored NFT contracts list.
      *
      * @param address - Hex address of the NFT contract.
+     * @param options - options.
+     * @param options.chainId - The chainId of the network where the NFT is being removed.
+     * @param options.userAddress - The address of the account where the NFT is being removed.
      * @returns Promise resolving to the current NFT contracts list.
      */
     private removeNftContract;
     /**
      * EventEmitter instance used to listen to specific EIP747 events
      */
-    hub: EventEmitter;
+    hub: EventEmitter<[never]>;
     /**
      * Optional API key to use with opensea
      */
@@ -344,7 +351,7 @@ export declare class NftController extends BaseController<NftConfig, NftState> {
         }) => void;
         messenger: NftControllerMessenger;
     }, config?: Partial<BaseConfig>, state?: Partial<NftState>);
-    validateWatchNft(asset: NftAsset, type: NFTStandardType, userAddress: string): Promise<void>;
+    private validateWatchNft;
     private getCorrectChainId;
     /**
      * Adds a new suggestedAsset to state. Parameters will be validated according to
@@ -355,10 +362,15 @@ export declare class NftController extends BaseController<NftConfig, NftState> {
      * @param asset.tokenId - The ID of the asset.
      * @param type - The asset type.
      * @param origin - Domain origin to register the asset from.
-     * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @param options - Options bag.
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @param options.userAddress - The address of the account where the NFT is being added.
      * @returns Object containing a Promise resolving to the suggestedAsset address if accepted.
      */
-    watchNft(asset: NftAsset, type: NFTStandardType, origin: string, networkClientId?: NetworkClientId): Promise<void>;
+    watchNft(asset: NftAsset, type: NFTStandardType, origin: string, { networkClientId, userAddress, }?: {
+        networkClientId?: NetworkClientId;
+        userAddress?: string;
+    }): Promise<void>;
     /**
      * Sets an OpenSea API key to retrieve NFT information.
      *
@@ -371,20 +383,29 @@ export declare class NftController extends BaseController<NftConfig, NftState> {
      * @param ownerAddress - User public address.
      * @param nftAddress - NFT contract address.
      * @param tokenId - NFT token ID.
-     * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @param options - Options bag.
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
      * @returns Promise resolving the NFT ownership.
      */
-    isNftOwner(ownerAddress: string, nftAddress: string, tokenId: string, networkClientId?: NetworkClientId): Promise<boolean>;
+    isNftOwner(ownerAddress: string, nftAddress: string, tokenId: string, { networkClientId, }?: {
+        networkClientId?: NetworkClientId;
+    }): Promise<boolean>;
     /**
      * Verifies currently selected address owns entered NFT address/tokenId combo and
      * adds the NFT and respective NFT contract to the stored NFT and NFT contracts lists.
      *
      * @param address - Hex address of the NFT contract.
      * @param tokenId - The NFT identifier.
-     * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
-     * @param source - Whether the NFT was detected, added manually or suggested by a dapp.
+     * @param options - an object of arguments
+     * @param options.userAddress - The address of the current user.
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.
      */
-    addNftVerifyOwnership(address: string, tokenId: string, networkClientId?: NetworkClientId, source?: Source): Promise<void>;
+    addNftVerifyOwnership(address: string, tokenId: string, { userAddress, networkClientId, source, }?: {
+        userAddress?: string;
+        networkClientId?: NetworkClientId;
+        source?: Source;
+    }): Promise<void>;
     /**
      * Adds an NFT and respective NFT contract to the stored NFT and NFT contracts lists.
      *
@@ -392,34 +413,56 @@ export declare class NftController extends BaseController<NftConfig, NftState> {
      * @param tokenId - The NFT identifier.
      * @param options - an object of arguments
      * @param options.nftMetadata - NFT optional metadata.
-     * @param options.chainId - The chain ID of the current network.
      * @param options.userAddress - The address of the current user.
      * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.
      * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
      * @returns Promise resolving to the current NFT list.
      */
-    addNft(tokenAddress: string, tokenId: string, { nftMetadata, chainId, // TODO remove and replace chainId arg with fetch chainId using getNetworkClientById(networkClientId).configuration.chainId once polling refactor is complete
-    userAddress, source, networkClientId, }?: {
+    addNft(tokenAddress: string, tokenId: string, { nftMetadata, userAddress, source, networkClientId, }?: {
         nftMetadata?: NftMetadata;
-        chainId?: Hex;
         userAddress?: string;
         source?: Source;
         networkClientId?: NetworkClientId;
     }): Promise<void>;
+    /**
+     * Refetches NFT metadata and updates the state
+     *
+     * @param options - Options for refetching NFT metadata
+     * @param options.nfts - nfts to update metadata for.
+     * @param options.userAddress - The current user address
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     */
+    updateNftMetadata({ nfts, userAddress, networkClientId, }: {
+        nfts: Nft[];
+        userAddress?: string;
+        networkClientId?: NetworkClientId;
+    }): Promise<void>;
     /**
      * Removes an NFT from the stored token list.
      *
      * @param address - Hex address of the NFT contract.
      * @param tokenId - Token identifier of the NFT.
+     * @param options - an object of arguments
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @param options.userAddress - The address of the account where the NFT is being removed.
      */
-    removeNft(address: string, tokenId: string): void;
+    removeNft(address: string, tokenId: string, { networkClientId, userAddress, }?: {
+        networkClientId?: NetworkClientId;
+        userAddress?: string;
+    }): void;
     /**
      * Removes an NFT from the stored token list and saves it in ignored NFTs list.
      *
      * @param address - Hex address of the NFT contract.
      * @param tokenId - Token identifier of the NFT.
+     * @param options - an object of arguments
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @param options.userAddress - The address of the account where the NFT is being removed.
      */
-    removeAndIgnoreNft(address: string, tokenId: string): void;
+    removeAndIgnoreNft(address: string, tokenId: string, { networkClientId, userAddress, }?: {
+        networkClientId?: NetworkClientId;
+        userAddress?: string;
+    }): void;
     /**
      * Removes all NFTs from the ignored list.
      */
@@ -432,26 +475,38 @@ export declare class NftController extends BaseController<NftConfig, NftState> {
      * @param batch - A boolean indicating whether this method is being called as part of a batch or single update.
      * @param accountParams - The userAddress and chainId to check ownership against
      * @param accountParams.userAddress - the address passed through the confirmed transaction flow to ensure assets are stored to the correct account
-     * @param accountParams.chainId - the chainId passed through the confirmed transaction flow to ensure assets are stored to the correct account
+     * @param accountParams.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
      * @returns the NFT with the updated isCurrentlyOwned value
      */
-    checkAndUpdateSingleNftOwnershipStatus(nft: Nft, batch: boolean, { userAddress, chainId }?: {
-        userAddress: string;
-        chainId: `0x${string}`;
+    checkAndUpdateSingleNftOwnershipStatus(nft: Nft, batch: boolean, { userAddress, networkClientId, }?: {
+        networkClientId?: NetworkClientId;
+        userAddress?: string;
     }): Promise<Nft>;
     /**
      * Checks whether NFTs associated with current selectedAddress/chainId combination are still owned by the user
      * And updates the isCurrentlyOwned value on each accordingly.
+     * @param options - an object of arguments
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @param options.userAddress - The address of the account where the NFT ownership status is checked/updated.
      */
-    checkAndUpdateAllNftsOwnershipStatus(): Promise<void>;
+    checkAndUpdateAllNftsOwnershipStatus({ networkClientId, userAddress, }?: {
+        networkClientId?: NetworkClientId;
+        userAddress?: string;
+    }): Promise<void>;
     /**
      * Update NFT favorite status.
      *
      * @param address - Hex address of the NFT contract.
      * @param tokenId - Hex address of the NFT contract.
      * @param favorite - NFT new favorite status.
+     * @param options - an object of arguments
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @param options.userAddress - The address of the account where the NFT is being removed.
      */
-    updateNftFavoriteStatus(address: string, tokenId: string, favorite: boolean): void;
+    updateNftFavoriteStatus(address: string, tokenId: string, favorite: boolean, { networkClientId, userAddress, }?: {
+        networkClientId?: NetworkClientId;
+        userAddress?: string;
+    }): void;
     /**
      * Returns an NFT by the address and token id.
      *
diff --git a/node_modules/@metamask/assets-controllers/dist/NftController.d.ts.map b/node_modules/@metamask/assets-controllers/dist/NftController.d.ts.map
index f3efdb4..6d54278 100644
--- a/node_modules/@metamask/assets-controllers/dist/NftController.d.ts.map
+++ b/node_modules/@metamask/assets-controllers/dist/NftController.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"NftController.d.ts","sourceRoot":"","sources":["../src/NftController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"NftController.d.ts","sourceRoot":"","sources":["../src/NftController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/NftController.js b/node_modules/@metamask/assets-controllers/dist/NftController.js
index 65b1161..cfd81ec 100644
--- a/node_modules/@metamask/assets-controllers/dist/NftController.js
+++ b/node_modules/@metamask/assets-controllers/dist/NftController.js
@@ -8,14 +8,18 @@ var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, ge
         step((generator = generator.apply(thisArg, _arguments || [])).next());
     });
 };
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.NftController = void 0;
+exports.NftController = exports.getDefaultNftState = void 0;
 const address_1 = require("@ethersproject/address");
 const base_controller_1 = require("@metamask/base-controller");
 const controller_utils_1 = require("@metamask/controller-utils");
 const rpc_errors_1 = require("@metamask/rpc-errors");
+const utils_1 = require("@metamask/utils");
 const async_mutex_1 = require("async-mutex");
-const ethereumjs_util_1 = require("ethereumjs-util");
+const bn_js_1 = __importDefault(require("bn.js"));
 const events_1 = require("events");
 const uuid_1 = require("uuid");
 const assetsUtil_1 = require("./assetsUtil");
@@ -26,6 +30,14 @@ const ALL_NFTS_CONTRACTS_STATE_KEY = 'allNftContracts';
  * The name of the {@link NftController}.
  */
 const controllerName = 'NftController';
+const getDefaultNftState = () => {
+    return {
+        allNftContracts: {},
+        allNfts: {},
+        ignoredNfts: [],
+    };
+};
+exports.getDefaultNftState = getDefaultNftState;
 /**
  * Controller that stores assets and exposes convenience methods
  */
@@ -65,15 +77,11 @@ class NftController extends base_controller_1.BaseController {
             selectedAddress: '',
             chainId: initialChainId,
             ipfsGateway: controller_utils_1.IPFS_DEFAULT_GATEWAY_URL,
-            openSeaEnabled: false,
+            displayNftMedia: true,
             useIPFSSubdomains: true,
             isIpfsGatewayEnabled: true,
         };
-        this.defaultState = {
-            allNftContracts: {},
-            allNfts: {},
-            ignoredNfts: [],
-        };
+        this.defaultState = (0, exports.getDefaultNftState)();
         this.initialize();
         this.getERC721AssetName = getERC721AssetName;
         this.getERC721AssetSymbol = getERC721AssetSymbol;
@@ -84,24 +92,35 @@ class NftController extends base_controller_1.BaseController {
         this.getNetworkClientById = getNetworkClientById;
         this.onNftAdded = onNftAdded;
         this.messagingSystem = messenger;
-        onPreferencesStateChange(({ selectedAddress, ipfsGateway, openSeaEnabled, isIpfsGatewayEnabled, }) => {
+        onPreferencesStateChange(({ selectedAddress, ipfsGateway, displayNftMedia, isIpfsGatewayEnabled, }) => __awaiter(this, void 0, void 0, function* () {
+            var _a, _b;
             this.configure({
                 selectedAddress,
                 ipfsGateway,
-                openSeaEnabled,
+                displayNftMedia,
                 isIpfsGatewayEnabled,
             });
-        });
+            const needsUpdateNftMetadata = (isIpfsGatewayEnabled && ipfsGateway !== '') || displayNftMedia;
+            if (needsUpdateNftMetadata) {
+                const { chainId } = this.config;
+                const nfts = (_b = (_a = this.state.allNfts[selectedAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) !== null && _b !== void 0 ? _b : [];
+                // filter only nfts
+                const nftsToUpdate = nfts.filter((singleNft) => !singleNft.name && !singleNft.description && !singleNft.image);
+                if (nftsToUpdate.length !== 0) {
+                    yield this.updateNftMetadata({
+                        nfts: nftsToUpdate,
+                        userAddress: selectedAddress,
+                    });
+                }
+            }
+        }));
         onNetworkStateChange(({ providerConfig }) => {
             const { chainId } = providerConfig;
             this.configure({ chainId });
         });
     }
-    getNftApi({ contractAddress, tokenId, }) {
-        return `${controller_utils_1.OPENSEA_PROXY_URL}/asset/${contractAddress}/${tokenId}`;
-    }
-    getNftContractInformationApi({ contractAddress, }) {
-        return `${controller_utils_1.OPENSEA_PROXY_URL}/asset_contract/${contractAddress}`;
+    getNftApi() {
+        return `${controller_utils_1.NFT_API_BASE_URL}/tokens`;
     }
     /**
      * Helper method to update nested state for allNfts and allNftContracts.
@@ -112,10 +131,7 @@ class NftController extends base_controller_1.BaseController {
      * @param passedConfig.userAddress - the address passed through the NFT detection flow to ensure assets are stored to the correct account
      * @param passedConfig.chainId - the chainId passed through the NFT detection flow to ensure assets are stored to the correct account
      */
-    updateNestedNftState(newCollection, baseStateKey, { userAddress, chainId } = {
-        userAddress: this.config.selectedAddress,
-        chainId: this.config.chainId,
-    }) {
+    updateNestedNftState(newCollection, baseStateKey, { userAddress, chainId }) {
         const { [baseStateKey]: oldState } = this.state;
         const addressState = oldState[userAddress];
         const newAddressState = Object.assign(Object.assign({}, addressState), { [chainId]: newCollection });
@@ -125,24 +141,34 @@ class NftController extends base_controller_1.BaseController {
         });
     }
     /**
-     * Request individual NFT information from OpenSea API.
+     * Request individual NFT information from NFT API.
      *
      * @param contractAddress - Hex address of the NFT contract.
      * @param tokenId - The NFT identifier.
      * @returns Promise resolving to the current NFT name and image.
      */
     getNftInformationFromApi(contractAddress, tokenId) {
+        var _a, _b, _c, _d;
         return __awaiter(this, void 0, void 0, function* () {
             // TODO Parameterize this by chainId for non-mainnet token detection
-            // Attempt to fetch the data with the proxy
+            // Attempt to fetch the data with the nft-api
+            const urlParams = new URLSearchParams({
+                chainIds: '1',
+                tokens: `${contractAddress}:${tokenId}`,
+                includeTopBid: 'true',
+                includeAttributes: 'true',
+                includeLastSale: 'true',
+            }).toString();
             const nftInformation = yield (0, controller_utils_1.fetchWithErrorHandling)({
-                url: this.getNftApi({
-                    contractAddress,
-                    tokenId,
-                }),
+                url: `${this.getNftApi()}?${urlParams}`,
+                options: {
+                    headers: {
+                        Version: '1',
+                    },
+                },
             });
             // if we were still unable to fetch the data we return out the default/null of `NftMetadata`
-            if (!nftInformation) {
+            if (!((_b = (_a = nftInformation === null || nftInformation === void 0 ? void 0 : nftInformation.tokens) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.token)) {
                 return {
                     name: null,
                     description: null,
@@ -152,11 +178,11 @@ class NftController extends base_controller_1.BaseController {
             }
             // if we've reached this point, we have successfully fetched some data for nftInformation
             // now we reconfigure the data to conform to the `NftMetadata` type for storage.
-            const { num_sales, background_color, image_url, image_preview_url, image_thumbnail_url, image_original_url, animation_url, animation_original_url, name, description, external_link, creator, last_sale, asset_contract: { schema_name }, } = nftInformation;
+            const { image, metadata: { imageOriginal } = {}, name, description, collection, kind, rarityRank, rarity, attributes, lastSale, imageSmall, } = nftInformation.tokens[0].token;
             /* istanbul ignore next */
-            const nftMetadata = Object.assign({}, { name: name || null }, { description: description || null }, { image: image_url || null }, creator && { creator }, num_sales && { numberOfSales: num_sales }, background_color && { backgroundColor: background_color }, image_preview_url && { imagePreview: image_preview_url }, image_thumbnail_url && { imageThumbnail: image_thumbnail_url }, image_original_url && { imageOriginal: image_original_url }, animation_url && { animation: animation_url }, animation_original_url && {
-                animationOriginal: animation_original_url,
-            }, external_link && { externalLink: external_link }, last_sale && { lastSale: last_sale }, schema_name && { standard: schema_name });
+            const nftMetadata = Object.assign({}, { name: name || null }, { description: description || null }, { image: image || null }, (collection === null || collection === void 0 ? void 0 : collection.creator) && { creator: collection.creator }, imageOriginal && { imageOriginal }, imageSmall && { imageThumbnail: imageSmall }, kind && { standard: kind.toUpperCase() }, lastSale && { lastSale }, attributes && { attributes }, ((_c = nftInformation.tokens[0].market) === null || _c === void 0 ? void 0 : _c.topBid) && {
+                topBid: (_d = nftInformation.tokens[0].market) === null || _d === void 0 ? void 0 : _d.topBid,
+            }, rarityRank && { rarityRank }, rarity && { rarity }, collection && { collection });
             return nftMetadata;
         });
     }
@@ -170,7 +196,7 @@ class NftController extends base_controller_1.BaseController {
      */
     getNftInformationFromTokenURI(contractAddress, tokenId, networkClientId) {
         return __awaiter(this, void 0, void 0, function* () {
-            const { ipfsGateway, useIPFSSubdomains, isIpfsGatewayEnabled } = this.config;
+            const { ipfsGateway, useIPFSSubdomains, isIpfsGatewayEnabled, displayNftMedia, } = this.config;
             const result = yield this.getNftURIAndStandard(contractAddress, tokenId, networkClientId);
             let tokenURI = result[0];
             const standard = result[1];
@@ -185,8 +211,7 @@ class NftController extends base_controller_1.BaseController {
                     tokenURI: tokenURI !== null && tokenURI !== void 0 ? tokenURI : null,
                 };
             }
-            const isDisplayNFTMediaToggleEnabled = this.config.openSeaEnabled;
-            if (!hasIpfsTokenURI && !isDisplayNFTMediaToggleEnabled) {
+            if (!hasIpfsTokenURI && !displayNftMedia) {
                 return {
                     image: null,
                     name: null,
@@ -255,7 +280,7 @@ class NftController extends base_controller_1.BaseController {
                 if (!tokenURI.includes('{id}')) {
                     return [tokenURI, controller_utils_1.ERC1155];
                 }
-                const hexTokenId = (0, ethereumjs_util_1.stripHexPrefix)((0, controller_utils_1.BNToHex)(new ethereumjs_util_1.BN(tokenId)))
+                const hexTokenId = (0, utils_1.remove0x)((0, controller_utils_1.BNToHex)(new bn_js_1.default(tokenId)))
                     .padStart(64, '0')
                     .toLowerCase();
                 return [tokenURI.replace('{id}', hexTokenId), controller_utils_1.ERC1155];
@@ -277,54 +302,16 @@ class NftController extends base_controller_1.BaseController {
     getNftInformation(contractAddress, tokenId, networkClientId) {
         var _a, _b, _c, _d, _e, _f, _g, _h, _j;
         return __awaiter(this, void 0, void 0, function* () {
-            let { chainId } = this.config;
-            if (networkClientId) {
-                chainId =
-                    this.getNetworkClientById(networkClientId).configuration.chainId;
-            }
-            const [blockchainMetadata, openSeaMetadata] = yield Promise.all([
+            const chainId = this.getCorrectChainId({
+                networkClientId,
+            });
+            const [blockchainMetadata, nftApiMetadata] = yield Promise.all([
                 (0, controller_utils_1.safelyExecute)(() => this.getNftInformationFromTokenURI(contractAddress, tokenId, networkClientId)),
-                this.config.openSeaEnabled && chainId === '0x1'
+                this.config.displayNftMedia && chainId === '0x1'
                     ? (0, controller_utils_1.safelyExecute)(() => this.getNftInformationFromApi(contractAddress, tokenId))
                     : undefined,
             ]);
-            return Object.assign(Object.assign({}, openSeaMetadata), { name: (_b = (_a = blockchainMetadata.name) !== null && _a !== void 0 ? _a : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.name) !== null && _b !== void 0 ? _b : null, description: (_d = (_c = blockchainMetadata.description) !== null && _c !== void 0 ? _c : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.description) !== null && _d !== void 0 ? _d : null, image: (_f = (_e = blockchainMetadata.image) !== null && _e !== void 0 ? _e : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.image) !== null && _f !== void 0 ? _f : null, standard: (_h = (_g = blockchainMetadata.standard) !== null && _g !== void 0 ? _g : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.standard) !== null && _h !== void 0 ? _h : null, tokenURI: (_j = blockchainMetadata.tokenURI) !== null && _j !== void 0 ? _j : null });
-        });
-    }
-    /**
-     * Request NFT contract information from OpenSea API.
-     *
-     * @param contractAddress - Hex address of the NFT contract.
-     * @returns Promise resolving to the current NFT name and image.
-     */
-    getNftContractInformationFromApi(contractAddress) {
-        return __awaiter(this, void 0, void 0, function* () {
-            /* istanbul ignore if */
-            const apiNftContractObject = yield (0, controller_utils_1.fetchWithErrorHandling)({
-                url: this.getNftContractInformationApi({
-                    contractAddress,
-                }),
-            });
-            // if we successfully fetched return the fetched data immediately
-            if (apiNftContractObject) {
-                return apiNftContractObject;
-            }
-            // If we've reached this point we were unable to fetch data from either the proxy or opensea so we return
-            // the default/null of ApiNftContract
-            return {
-                address: contractAddress,
-                asset_contract_type: null,
-                created_date: null,
-                schema_name: null,
-                symbol: null,
-                total_supply: null,
-                description: null,
-                external_link: null,
-                collection: {
-                    name: null,
-                    image_url: null,
-                },
-            };
+            return Object.assign(Object.assign({}, nftApiMetadata), { name: (_b = (_a = blockchainMetadata === null || blockchainMetadata === void 0 ? void 0 : blockchainMetadata.name) !== null && _a !== void 0 ? _a : nftApiMetadata === null || nftApiMetadata === void 0 ? void 0 : nftApiMetadata.name) !== null && _b !== void 0 ? _b : null, description: (_d = (_c = blockchainMetadata === null || blockchainMetadata === void 0 ? void 0 : blockchainMetadata.description) !== null && _c !== void 0 ? _c : nftApiMetadata === null || nftApiMetadata === void 0 ? void 0 : nftApiMetadata.description) !== null && _d !== void 0 ? _d : null, image: (_f = (_e = blockchainMetadata === null || blockchainMetadata === void 0 ? void 0 : blockchainMetadata.image) !== null && _e !== void 0 ? _e : nftApiMetadata === null || nftApiMetadata === void 0 ? void 0 : nftApiMetadata.image) !== null && _f !== void 0 ? _f : null, standard: (_h = (_g = blockchainMetadata === null || blockchainMetadata === void 0 ? void 0 : blockchainMetadata.standard) !== null && _g !== void 0 ? _g : nftApiMetadata === null || nftApiMetadata === void 0 ? void 0 : nftApiMetadata.standard) !== null && _h !== void 0 ? _h : null, tokenURI: (_j = blockchainMetadata === null || blockchainMetadata === void 0 ? void 0 : blockchainMetadata.tokenURI) !== null && _j !== void 0 ? _j : null });
         });
     }
     /**
@@ -348,27 +335,20 @@ class NftController extends base_controller_1.BaseController {
         });
     }
     /**
-     * Request NFT contract information from OpenSea API.
+     * Request NFT contract information from Blockchain and aggregate with received data from NFTMetadata.
      *
      * @param contractAddress - Hex address of the NFT contract.
+     * @param nftMetadataFromApi - Received NFT information to be aggregated with blockchain contract information.
      * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
      * @returns Promise resolving to the NFT contract name, image and description.
      */
-    getNftContractInformation(contractAddress, networkClientId) {
+    getNftContractInformation(contractAddress, nftMetadataFromApi, networkClientId) {
+        var _a, _b, _c, _d, _e, _f, _g;
         return __awaiter(this, void 0, void 0, function* () {
-            const { chainId } = this.config;
-            const getCurrentChainId = this.getCorrectChainId({
-                chainId,
-                networkClientId,
-            });
-            const [blockchainContractData, openSeaContractData] = yield Promise.all([
-                (0, controller_utils_1.safelyExecute)(() => this.getNftContractInformationFromContract(contractAddress, networkClientId)),
-                this.config.openSeaEnabled && getCurrentChainId === '0x1'
-                    ? (0, controller_utils_1.safelyExecute)(() => this.getNftContractInformationFromApi(contractAddress))
-                    : undefined,
-            ]);
-            if (blockchainContractData || openSeaContractData) {
-                return Object.assign(Object.assign(Object.assign({}, openSeaContractData), blockchainContractData), { collection: Object.assign(Object.assign({ image_url: null }, openSeaContractData === null || openSeaContractData === void 0 ? void 0 : openSeaContractData.collection), blockchainContractData === null || blockchainContractData === void 0 ? void 0 : blockchainContractData.collection) });
+            const blockchainContractData = yield (0, controller_utils_1.safelyExecute)(() => this.getNftContractInformationFromContract(contractAddress, networkClientId));
+            if (blockchainContractData ||
+                !Object.values(nftMetadataFromApi).every((value) => value === null)) {
+                return Object.assign(Object.assign({ address: contractAddress }, blockchainContractData), { schema_name: (_a = nftMetadataFromApi === null || nftMetadataFromApi === void 0 ? void 0 : nftMetadataFromApi.standard) !== null && _a !== void 0 ? _a : null, collection: Object.assign(Object.assign({ name: null, image_url: (_e = (_c = (_b = nftMetadataFromApi === null || nftMetadataFromApi === void 0 ? void 0 : nftMetadataFromApi.collection) === null || _b === void 0 ? void 0 : _b.image) !== null && _c !== void 0 ? _c : (_d = nftMetadataFromApi === null || nftMetadataFromApi === void 0 ? void 0 : nftMetadataFromApi.collection) === null || _d === void 0 ? void 0 : _d.imageUrl) !== null && _e !== void 0 ? _e : null, tokenCount: (_g = (_f = nftMetadataFromApi === null || nftMetadataFromApi === void 0 ? void 0 : nftMetadataFromApi.collection) === null || _f === void 0 ? void 0 : _f.tokenCount) !== null && _g !== void 0 ? _g : null }, nftMetadataFromApi === null || nftMetadataFromApi === void 0 ? void 0 : nftMetadataFromApi.collection), blockchainContractData === null || blockchainContractData === void 0 ? void 0 : blockchainContractData.collection) });
             }
             /* istanbul ignore next */
             return {
@@ -449,54 +429,52 @@ class NftController extends base_controller_1.BaseController {
      *
      * @param options - options.
      * @param options.tokenAddress - Hex address of the NFT contract.
-     * @param options.chainId - The chainId of the network where the NFT is being added.
      * @param options.userAddress - The address of the account where the NFT is being added.
+     * @param options.nftMetadata - The retrieved NFTMetadata from API.
      * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
      * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.
      * @returns Promise resolving to the current NFT contracts list.
      */
-    addNftContract({ tokenAddress, chainId, userAddress, networkClientId, source, }) {
+    addNftContract({ tokenAddress, userAddress, networkClientId, source, nftMetadata, }) {
         var _a;
         return __awaiter(this, void 0, void 0, function* () {
             const releaseLock = yield this.mutex.acquire();
             try {
                 tokenAddress = (0, controller_utils_1.toChecksumHexAddress)(tokenAddress);
                 const { allNftContracts } = this.state;
-                const currentChainId = this.getCorrectChainId({
-                    chainId,
+                const chainId = this.getCorrectChainId({
                     networkClientId,
                 });
-                const selectedAddress = userAddress !== null && userAddress !== void 0 ? userAddress : this.config.selectedAddress;
-                const nftContracts = ((_a = allNftContracts[selectedAddress]) === null || _a === void 0 ? void 0 : _a[currentChainId]) || [];
+                const nftContracts = ((_a = allNftContracts[userAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
                 const existingEntry = nftContracts.find((nftContract) => nftContract.address.toLowerCase() === tokenAddress.toLowerCase());
                 if (existingEntry) {
                     return nftContracts;
                 }
                 // this doesn't work currently for detection if the user switches networks while the detection is processing
                 // will be fixed once detection uses networkClientIds
-                const contractInformation = yield this.getNftContractInformation(tokenAddress, networkClientId);
-                const { asset_contract_type, created_date, schema_name, symbol, total_supply, description, external_link, collection: { name, image_url }, } = contractInformation;
+                // get name and symbol if ERC721 then put together the metadata
+                const contractInformation = yield this.getNftContractInformation(tokenAddress, nftMetadata, networkClientId);
+                const { asset_contract_type, created_date, symbol, description, external_link, schema_name, collection: { name, image_url, tokenCount }, } = contractInformation;
                 // If the nft is auto-detected we want some valid metadata to be present
                 if (source === constants_1.Source.Detected &&
-                    Object.entries(contractInformation).every(([k, v]) => {
-                        if (k === 'address') {
-                            return true; // address will always be present
-                        }
-                        // collection will always be an object, we need to check the internal values
-                        if (k === 'collection') {
-                            return (v === null || v === void 0 ? void 0 : v.name) === null && (v === null || v === void 0 ? void 0 : v.image_url) === null;
-                        }
-                        return !v;
+                    'address' in contractInformation &&
+                    typeof contractInformation.address === 'string' &&
+                    'collection' in contractInformation &&
+                    contractInformation.collection.name === null &&
+                    'image_url' in contractInformation.collection &&
+                    contractInformation.collection.image_url === null &&
+                    Object.entries(contractInformation).every(([key, value]) => {
+                        return key === 'address' || key === 'collection' || !value;
                     })) {
                     return nftContracts;
                 }
                 /* istanbul ignore next */
-                const newEntry = Object.assign({}, { address: tokenAddress }, description && { description }, name && { name }, image_url && { logo: image_url }, symbol && { symbol }, total_supply !== null &&
-                    typeof total_supply !== 'undefined' && { totalSupply: total_supply }, asset_contract_type && { assetContractType: asset_contract_type }, created_date && { createdDate: created_date }, schema_name && { schemaName: schema_name }, external_link && { externalLink: external_link });
+                const newEntry = Object.assign({}, { address: tokenAddress }, description && { description }, name && { name }, image_url && { logo: image_url }, symbol && { symbol }, tokenCount !== null &&
+                    typeof tokenCount !== 'undefined' && { totalSupply: tokenCount }, asset_contract_type && { assetContractType: asset_contract_type }, created_date && { createdDate: created_date }, schema_name && { schemaName: schema_name }, external_link && { externalLink: external_link });
                 const newNftContracts = [...nftContracts, newEntry];
                 this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY, {
-                    chainId: currentChainId,
-                    userAddress: selectedAddress,
+                    chainId,
+                    userAddress,
                 });
                 return newNftContracts;
             }
@@ -510,14 +488,16 @@ class NftController extends base_controller_1.BaseController {
      *
      * @param address - Hex address of the NFT contract.
      * @param tokenId - Token identifier of the NFT.
+     * @param options - options.
+     * @param options.chainId - The chainId of the network where the NFT is being removed.
+     * @param options.userAddress - The address of the account where the NFT is being removed.
      */
-    removeAndIgnoreIndividualNft(address, tokenId) {
+    removeAndIgnoreIndividualNft(address, tokenId, { chainId, userAddress, }) {
         var _a;
         address = (0, controller_utils_1.toChecksumHexAddress)(address);
         const { allNfts, ignoredNfts } = this.state;
-        const { chainId, selectedAddress } = this.config;
         const newIgnoredNfts = [...ignoredNfts];
-        const nfts = ((_a = allNfts[selectedAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
+        const nfts = ((_a = allNfts[userAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
         const newNfts = nfts.filter((nft) => {
             if (nft.address.toLowerCase() === address.toLowerCase() &&
                 nft.tokenId === tokenId) {
@@ -527,7 +507,10 @@ class NftController extends base_controller_1.BaseController {
             }
             return true;
         });
-        this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY);
+        this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {
+            userAddress,
+            chainId,
+        });
         this.update({
             ignoredNfts: newIgnoredNfts,
         });
@@ -537,34 +520,44 @@ class NftController extends base_controller_1.BaseController {
      *
      * @param address - Hex address of the NFT contract.
      * @param tokenId - Token identifier of the NFT.
+     * @param options - options.
+     * @param options.chainId - The chainId of the network where the NFT is being removed.
+     * @param options.userAddress - The address of the account where the NFT is being removed.
      */
-    removeIndividualNft(address, tokenId) {
+    removeIndividualNft(address, tokenId, { chainId, userAddress }) {
         var _a;
         address = (0, controller_utils_1.toChecksumHexAddress)(address);
         const { allNfts } = this.state;
-        const { chainId, selectedAddress } = this.config;
-        const nfts = ((_a = allNfts[selectedAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
+        const nfts = ((_a = allNfts[userAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
         const newNfts = nfts.filter((nft) => !(nft.address.toLowerCase() === address.toLowerCase() &&
             nft.tokenId === tokenId));
-        this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY);
+        this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {
+            userAddress,
+            chainId,
+        });
     }
     /**
      * Removes an NFT contract to the stored NFT contracts list.
      *
      * @param address - Hex address of the NFT contract.
+     * @param options - options.
+     * @param options.chainId - The chainId of the network where the NFT is being removed.
+     * @param options.userAddress - The address of the account where the NFT is being removed.
      * @returns Promise resolving to the current NFT contracts list.
      */
-    removeNftContract(address) {
+    removeNftContract(address, { chainId, userAddress }) {
         var _a;
         address = (0, controller_utils_1.toChecksumHexAddress)(address);
         const { allNftContracts } = this.state;
-        const { chainId, selectedAddress } = this.config;
-        const nftContracts = ((_a = allNftContracts[selectedAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
+        const nftContracts = ((_a = allNftContracts[userAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
         const newNftContracts = nftContracts.filter((nftContract) => !(nftContract.address.toLowerCase() === address.toLowerCase()));
-        this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY);
+        this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY, {
+            chainId,
+            userAddress,
+        });
         return newNftContracts;
     }
-    validateWatchNft(asset, type, userAddress) {
+    validateWatchNft(asset, type, userAddress, { networkClientId } = {}) {
         return __awaiter(this, void 0, void 0, function* () {
             const { address: contractAddress, tokenId } = asset;
             // Validate parameters
@@ -585,26 +578,26 @@ class NftController extends base_controller_1.BaseController {
             }
             // Check if the user owns the suggested NFT
             try {
-                const isOwner = yield this.isNftOwner(userAddress, contractAddress, tokenId);
+                const isOwner = yield this.isNftOwner(userAddress, contractAddress, tokenId, { networkClientId });
                 if (!isOwner) {
                     throw rpc_errors_1.rpcErrors.invalidInput('Suggested NFT is not owned by the selected account');
                 }
             }
             catch (error) {
                 // error thrown here: "Unable to verify ownership. Possibly because the standard is not supported or the user's currently selected network does not match the chain of the asset in question."
-                throw rpc_errors_1.rpcErrors.resourceUnavailable(error.message);
+                if (error instanceof Error) {
+                    throw rpc_errors_1.rpcErrors.resourceUnavailable(error.message);
+                }
+                throw error;
             }
         });
     }
     // temporary method to get the correct chainId until we remove chainId from the config & the chainId arg from the detection logic
     // Just a helper method to prefer the networkClient chainId first then the chainId argument and then finally the config chainId
-    getCorrectChainId({ chainId, networkClientId, }) {
+    getCorrectChainId({ networkClientId, }) {
         if (networkClientId) {
             return this.getNetworkClientById(networkClientId).configuration.chainId;
         }
-        else if (chainId) {
-            return chainId;
-        }
         return this.config.chainId;
     }
     /**
@@ -616,13 +609,16 @@ class NftController extends base_controller_1.BaseController {
      * @param asset.tokenId - The ID of the asset.
      * @param type - The asset type.
      * @param origin - Domain origin to register the asset from.
-     * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @param options - Options bag.
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @param options.userAddress - The address of the account where the NFT is being added.
      * @returns Object containing a Promise resolving to the suggestedAsset address if accepted.
      */
-    watchNft(asset, type, origin, networkClientId) {
+    watchNft(asset, type, origin, { networkClientId, userAddress = this.config.selectedAddress, } = {
+        userAddress: this.config.selectedAddress,
+    }) {
         return __awaiter(this, void 0, void 0, function* () {
-            const { selectedAddress, chainId } = this.config;
-            yield this.validateWatchNft(asset, type, selectedAddress);
+            yield this.validateWatchNft(asset, type, userAddress);
             const nftMetadata = yield this.getNftInformation(asset.address, asset.tokenId, networkClientId);
             if (nftMetadata.standard && nftMetadata.standard !== type) {
                 throw rpc_errors_1.rpcErrors.invalidInput(`Suggested NFT of type ${nftMetadata.standard} does not match received type ${type}`);
@@ -632,7 +628,7 @@ class NftController extends base_controller_1.BaseController {
                 type,
                 id: (0, uuid_1.v4)(),
                 time: Date.now(),
-                interactingAddress: selectedAddress,
+                interactingAddress: userAddress,
                 origin,
             };
             yield this._requestApproval(suggestedNftMeta);
@@ -645,8 +641,7 @@ class NftController extends base_controller_1.BaseController {
                     image: image !== null && image !== void 0 ? image : null,
                     standard: standard !== null && standard !== void 0 ? standard : null,
                 },
-                chainId,
-                userAddress: selectedAddress,
+                userAddress,
                 source: constants_1.Source.Dapp,
                 networkClientId,
             });
@@ -666,10 +661,11 @@ class NftController extends base_controller_1.BaseController {
      * @param ownerAddress - User public address.
      * @param nftAddress - NFT contract address.
      * @param tokenId - NFT token ID.
-     * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @param options - Options bag.
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
      * @returns Promise resolving the NFT ownership.
      */
-    isNftOwner(ownerAddress, nftAddress, tokenId, networkClientId) {
+    isNftOwner(ownerAddress, nftAddress, tokenId, { networkClientId, } = {}) {
         return __awaiter(this, void 0, void 0, function* () {
             // Checks the ownership for ERC-721.
             try {
@@ -698,16 +694,25 @@ class NftController extends base_controller_1.BaseController {
      *
      * @param address - Hex address of the NFT contract.
      * @param tokenId - The NFT identifier.
-     * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
-     * @param source - Whether the NFT was detected, added manually or suggested by a dapp.
+     * @param options - an object of arguments
+     * @param options.userAddress - The address of the current user.
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.
      */
-    addNftVerifyOwnership(address, tokenId, networkClientId, source) {
+    addNftVerifyOwnership(address, tokenId, { userAddress = this.config.selectedAddress, networkClientId, source, } = {
+        userAddress: this.config.selectedAddress,
+    }) {
         return __awaiter(this, void 0, void 0, function* () {
-            const { selectedAddress } = this.config;
-            if (!(yield this.isNftOwner(selectedAddress, address, tokenId, networkClientId))) {
+            if (!(yield this.isNftOwner(userAddress, address, tokenId, {
+                networkClientId,
+            }))) {
                 throw new Error('This NFT is not owned by the user');
             }
-            yield this.addNft(address, tokenId, { networkClientId, source });
+            yield this.addNft(address, tokenId, {
+                networkClientId,
+                userAddress,
+                source,
+            });
         });
     }
     /**
@@ -717,33 +722,73 @@ class NftController extends base_controller_1.BaseController {
      * @param tokenId - The NFT identifier.
      * @param options - an object of arguments
      * @param options.nftMetadata - NFT optional metadata.
-     * @param options.chainId - The chain ID of the current network.
      * @param options.userAddress - The address of the current user.
      * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.
      * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
      * @returns Promise resolving to the current NFT list.
      */
-    addNft(tokenAddress, tokenId, { nftMetadata, chainId, // TODO remove and replace chainId arg with fetch chainId using getNetworkClientById(networkClientId).configuration.chainId once polling refactor is complete
-    userAddress, source = constants_1.Source.Custom, networkClientId, } = {}) {
+    addNft(tokenAddress, tokenId, { nftMetadata, userAddress = this.config.selectedAddress, source = constants_1.Source.Custom, networkClientId, } = { userAddress: this.config.selectedAddress }) {
         return __awaiter(this, void 0, void 0, function* () {
             tokenAddress = (0, controller_utils_1.toChecksumHexAddress)(tokenAddress);
-            const currentChainId = this.getCorrectChainId({ chainId, networkClientId });
-            const selectedAddress = userAddress !== null && userAddress !== void 0 ? userAddress : this.config.selectedAddress;
+            const chainId = this.getCorrectChainId({ networkClientId });
+            nftMetadata =
+                nftMetadata ||
+                    (yield this.getNftInformation(tokenAddress, tokenId, networkClientId));
             const newNftContracts = yield this.addNftContract({
                 tokenAddress,
-                chainId: currentChainId,
-                userAddress: selectedAddress,
+                userAddress,
                 networkClientId,
                 source,
+                nftMetadata,
             });
-            nftMetadata =
-                nftMetadata ||
-                    (yield this.getNftInformation(tokenAddress, tokenId, networkClientId));
             // If NFT contract was not added, do not add individual NFT
             const nftContract = newNftContracts.find((contract) => contract.address.toLowerCase() === tokenAddress.toLowerCase());
             // If NFT contract information, add individual NFT
             if (nftContract) {
-                yield this.addIndividualNft(tokenAddress, tokenId, nftMetadata, nftContract, currentChainId, selectedAddress, source);
+                yield this.addIndividualNft(tokenAddress, tokenId, nftMetadata, nftContract, chainId, userAddress, source);
+            }
+        });
+    }
+    /**
+     * Refetches NFT metadata and updates the state
+     *
+     * @param options - Options for refetching NFT metadata
+     * @param options.nfts - nfts to update metadata for.
+     * @param options.userAddress - The current user address
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     */
+    updateNftMetadata({ nfts, userAddress = this.config.selectedAddress, networkClientId, }) {
+        var _a;
+        return __awaiter(this, void 0, void 0, function* () {
+            const chainId = this.getCorrectChainId({ networkClientId });
+            const nftsWithChecksumAdr = nfts.map((nft) => {
+                return Object.assign(Object.assign({}, nft), { address: (0, controller_utils_1.toChecksumHexAddress)(nft.address) });
+            });
+            const nftMetadataResults = yield Promise.allSettled(nftsWithChecksumAdr.map((nft) => __awaiter(this, void 0, void 0, function* () {
+                const resMetadata = yield this.getNftInformation(nft.address, nft.tokenId, networkClientId);
+                return {
+                    nft,
+                    newMetadata: resMetadata,
+                };
+            })));
+            const successfulNewFetchedNfts = nftMetadataResults.filter((result) => result.status === 'fulfilled');
+            // We want to avoid updating the state if the state and fetched nft info are the same
+            const nftsWithDifferentMetadata = [];
+            const { allNfts } = this.state;
+            const stateNfts = ((_a = allNfts[userAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
+            successfulNewFetchedNfts.forEach((singleNft) => {
+                const existingEntry = stateNfts.find((nft) => nft.address.toLowerCase() ===
+                    singleNft.value.nft.address.toLowerCase() &&
+                    nft.tokenId === singleNft.value.nft.tokenId);
+                if (existingEntry) {
+                    const differentMetadata = (0, assetsUtil_1.compareNftMetadata)(singleNft.value.newMetadata, existingEntry);
+                    if (differentMetadata) {
+                        nftsWithDifferentMetadata.push(singleNft);
+                    }
+                }
+            });
+            if (nftsWithDifferentMetadata.length !== 0) {
+                nftsWithDifferentMetadata.forEach((elm) => this.updateNft(elm.value.nft, elm.value.newMetadata, userAddress, chainId));
             }
         });
     }
@@ -752,17 +797,22 @@ class NftController extends base_controller_1.BaseController {
      *
      * @param address - Hex address of the NFT contract.
      * @param tokenId - Token identifier of the NFT.
+     * @param options - an object of arguments
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @param options.userAddress - The address of the account where the NFT is being removed.
      */
-    removeNft(address, tokenId) {
+    removeNft(address, tokenId, { networkClientId, userAddress = this.config.selectedAddress, } = {
+        userAddress: this.config.selectedAddress,
+    }) {
         var _a;
+        const chainId = this.getCorrectChainId({ networkClientId });
         address = (0, controller_utils_1.toChecksumHexAddress)(address);
-        this.removeIndividualNft(address, tokenId);
+        this.removeIndividualNft(address, tokenId, { chainId, userAddress });
         const { allNfts } = this.state;
-        const { chainId, selectedAddress } = this.config;
-        const nfts = ((_a = allNfts[selectedAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
+        const nfts = ((_a = allNfts[userAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
         const remainingNft = nfts.find((nft) => nft.address.toLowerCase() === address.toLowerCase());
         if (!remainingNft) {
-            this.removeNftContract(address);
+            this.removeNftContract(address, { chainId, userAddress });
         }
     }
     /**
@@ -770,17 +820,25 @@ class NftController extends base_controller_1.BaseController {
      *
      * @param address - Hex address of the NFT contract.
      * @param tokenId - Token identifier of the NFT.
+     * @param options - an object of arguments
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @param options.userAddress - The address of the account where the NFT is being removed.
      */
-    removeAndIgnoreNft(address, tokenId) {
+    removeAndIgnoreNft(address, tokenId, { networkClientId, userAddress = this.config.selectedAddress, } = {
+        userAddress: this.config.selectedAddress,
+    }) {
         var _a;
+        const chainId = this.getCorrectChainId({ networkClientId });
         address = (0, controller_utils_1.toChecksumHexAddress)(address);
-        this.removeAndIgnoreIndividualNft(address, tokenId);
+        this.removeAndIgnoreIndividualNft(address, tokenId, {
+            chainId,
+            userAddress,
+        });
         const { allNfts } = this.state;
-        const { chainId, selectedAddress } = this.config;
-        const nfts = ((_a = allNfts[selectedAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
+        const nfts = ((_a = allNfts[userAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
         const remainingNft = nfts.find((nft) => nft.address.toLowerCase() === address.toLowerCase());
         if (!remainingNft) {
-            this.removeNftContract(address);
+            this.removeNftContract(address, { chainId, userAddress });
         }
     }
     /**
@@ -797,25 +855,26 @@ class NftController extends base_controller_1.BaseController {
      * @param batch - A boolean indicating whether this method is being called as part of a batch or single update.
      * @param accountParams - The userAddress and chainId to check ownership against
      * @param accountParams.userAddress - the address passed through the confirmed transaction flow to ensure assets are stored to the correct account
-     * @param accountParams.chainId - the chainId passed through the confirmed transaction flow to ensure assets are stored to the correct account
+     * @param accountParams.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
      * @returns the NFT with the updated isCurrentlyOwned value
      */
-    checkAndUpdateSingleNftOwnershipStatus(nft, batch, { userAddress, chainId } = {
+    checkAndUpdateSingleNftOwnershipStatus(nft, batch, { userAddress = this.config.selectedAddress, networkClientId, } = {
         userAddress: this.config.selectedAddress,
-        chainId: this.config.chainId,
     }) {
         var _a;
         return __awaiter(this, void 0, void 0, function* () {
+            const chainId = this.getCorrectChainId({ networkClientId });
             const { address, tokenId } = nft;
             let isOwned = nft.isCurrentlyOwned;
             try {
-                isOwned = yield this.isNftOwner(userAddress, address, tokenId);
+                isOwned = yield this.isNftOwner(userAddress, address, tokenId, {
+                    networkClientId,
+                });
             }
-            catch (error) {
-                if (!(error instanceof Error &&
-                    error.message.includes('Unable to verify ownership'))) {
-                    throw error;
-                }
+            catch (_b) {
+                // ignore error
+                // this will only throw an error 'Unable to verify ownership' in which case
+                // we want to keep the current value of isCurrentlyOwned for this flow.
             }
             nft.isCurrentlyOwned = isOwned;
             if (batch) {
@@ -839,18 +898,29 @@ class NftController extends base_controller_1.BaseController {
     /**
      * Checks whether NFTs associated with current selectedAddress/chainId combination are still owned by the user
      * And updates the isCurrentlyOwned value on each accordingly.
+     * @param options - an object of arguments
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @param options.userAddress - The address of the account where the NFT ownership status is checked/updated.
      */
-    checkAndUpdateAllNftsOwnershipStatus() {
+    checkAndUpdateAllNftsOwnershipStatus({ networkClientId, userAddress = this.config.selectedAddress, } = {
+        userAddress: this.config.selectedAddress,
+    }) {
         var _a;
         return __awaiter(this, void 0, void 0, function* () {
+            const chainId = this.getCorrectChainId({ networkClientId });
             const { allNfts } = this.state;
-            const { chainId, selectedAddress } = this.config;
-            const nfts = ((_a = allNfts[selectedAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
+            const nfts = ((_a = allNfts[userAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
             const updatedNfts = yield Promise.all(nfts.map((nft) => __awaiter(this, void 0, void 0, function* () {
                 var _b;
-                return ((_b = (yield this.checkAndUpdateSingleNftOwnershipStatus(nft, true))) !== null && _b !== void 0 ? _b : nft);
+                return ((_b = (yield this.checkAndUpdateSingleNftOwnershipStatus(nft, true, {
+                    networkClientId,
+                    userAddress,
+                }))) !== null && _b !== void 0 ? _b : nft);
             })));
-            this.updateNestedNftState(updatedNfts, ALL_NFTS_STATE_KEY);
+            this.updateNestedNftState(updatedNfts, ALL_NFTS_STATE_KEY, {
+                userAddress,
+                chainId,
+            });
         });
     }
     /**
@@ -859,12 +929,17 @@ class NftController extends base_controller_1.BaseController {
      * @param address - Hex address of the NFT contract.
      * @param tokenId - Hex address of the NFT contract.
      * @param favorite - NFT new favorite status.
+     * @param options - an object of arguments
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @param options.userAddress - The address of the account where the NFT is being removed.
      */
-    updateNftFavoriteStatus(address, tokenId, favorite) {
+    updateNftFavoriteStatus(address, tokenId, favorite, { networkClientId, userAddress = this.config.selectedAddress, } = {
+        userAddress: this.config.selectedAddress,
+    }) {
         var _a;
+        const chainId = this.getCorrectChainId({ networkClientId });
         const { allNfts } = this.state;
-        const { chainId, selectedAddress } = this.config;
-        const nfts = ((_a = allNfts[selectedAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
+        const nfts = ((_a = allNfts[userAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
         const index = nfts.findIndex((nft) => nft.address === address && nft.tokenId === tokenId);
         if (index === -1) {
             return;
@@ -872,7 +947,10 @@ class NftController extends base_controller_1.BaseController {
         const updatedNft = Object.assign(Object.assign({}, nfts[index]), { favorite });
         // Update Nfts array
         nfts[index] = updatedNft;
-        this.updateNestedNftState(nfts, ALL_NFTS_STATE_KEY);
+        this.updateNestedNftState(nfts, ALL_NFTS_STATE_KEY, {
+            chainId,
+            userAddress,
+        });
     }
     /**
      * Returns an NFT by the address and token id.
@@ -916,7 +994,10 @@ class NftController extends base_controller_1.BaseController {
             updatedNft,
             ...nfts.slice(nftInfo.index + 1),
         ];
-        this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY);
+        this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {
+            chainId,
+            userAddress: selectedAddress,
+        });
     }
     /**
      * Resets the transaction status of an NFT.
@@ -940,7 +1021,10 @@ class NftController extends base_controller_1.BaseController {
             updatedNft,
             ...nfts.slice(index + 1),
         ];
-        this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY);
+        this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {
+            chainId,
+            userAddress: selectedAddress,
+        });
         return true;
     }
     _requestApproval(suggestedNftMeta) {
diff --git a/node_modules/@metamask/assets-controllers/dist/NftController.js.map b/node_modules/@metamask/assets-controllers/dist/NftController.js.map
index 2056a71..29680fa 100644
--- a/node_modules/@metamask/assets-controllers/dist/NftController.js.map
+++ b/node_modules/@metamask/assets-controllers/dist/NftController.js.map
@@ -1 +1 @@
-{"version":3,"file":"NftController.js","sourceRoot":"","sources":["../src/NftController.ts"],"names":[],"mappings":"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","sourcesContent":["import { isAddress } from '@ethersproject/address';\nimport type { AddApprovalRequest } from '@metamask/approval-controller';\nimport type {\n  BaseConfig,\n  BaseState,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport {\n  safelyExecute,\n  handleFetch,\n  toChecksumHexAddress,\n  BNToHex,\n  fetchWithErrorHandling,\n  IPFS_DEFAULT_GATEWAY_URL,\n  ERC721,\n  ERC1155,\n  OPENSEA_PROXY_URL,\n  ApprovalType,\n} from '@metamask/controller-utils';\nimport type {\n  NetworkClientId,\n  NetworkController,\n  NetworkState,\n} from '@metamask/network-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type { Hex } from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\nimport { BN, stripHexPrefix } from 'ethereumjs-util';\nimport { EventEmitter } from 'events';\nimport { v4 as random } from 'uuid';\n\nimport type { AssetsContractController } from './AssetsContractController';\nimport { compareNftMetadata, getFormattedIpfsUrl } from './assetsUtil';\nimport { Source } from './constants';\nimport type {\n  ApiNft,\n  ApiNftCreator,\n  ApiNftContract,\n  ApiNftLastSale,\n} from './NftDetectionController';\n\ntype NFTStandardType = 'ERC721' | 'ERC1155';\n\ntype SuggestedNftMeta = {\n  asset: { address: string; tokenId: string } & NftMetadata;\n  id: string;\n  time: number;\n  type: NFTStandardType;\n  interactingAddress: string;\n  origin: string;\n};\n\n/**\n * @type Nft\n *\n * NFT representation\n * @property address - Hex address of a ERC721 contract\n * @property description - The NFT description\n * @property image - URI of custom NFT image associated with this tokenId\n * @property name - Name associated with this tokenId and contract address\n * @property tokenId - The NFT identifier\n * @property numberOfSales - Number of sales\n * @property backgroundColor - The background color to be displayed with the item\n * @property imagePreview - URI of a smaller image associated with this NFT\n * @property imageThumbnail - URI of a thumbnail image associated with this NFT\n * @property imageOriginal - URI of the original image associated with this NFT\n * @property animation - URI of a animation associated with this NFT\n * @property animationOriginal - URI of the original animation associated with this NFT\n * @property externalLink - External link containing additional information\n * @property creator - The NFT owner information object\n * @property isCurrentlyOwned - Boolean indicating whether the address/chainId combination where it's currently stored currently owns this NFT\n * @property transactionId - Transaction Id associated with the NFT\n */\nexport interface Nft extends NftMetadata {\n  tokenId: string;\n  address: string;\n  isCurrentlyOwned?: boolean;\n}\n\n/**\n * @type NftContract\n *\n * NFT contract information representation\n * @property name - Contract name\n * @property logo - Contract logo\n * @property address - Contract address\n * @property symbol - Contract symbol\n * @property description - Contract description\n * @property totalSupply - Total supply of NFTs\n * @property assetContractType - The NFT type, it could be `semi-fungible` or `non-fungible`\n * @property createdDate - Creation date\n * @property schemaName - The schema followed by the contract, it could be `ERC721` or `ERC1155`\n * @property externalLink - External link containing additional information\n */\nexport interface NftContract {\n  name?: string;\n  logo?: string;\n  address: string;\n  symbol?: string;\n  description?: string;\n  totalSupply?: string;\n  assetContractType?: string;\n  createdDate?: string;\n  schemaName?: string;\n  externalLink?: string;\n}\n\n/**\n * @type NftMetadata\n *\n * NFT custom information\n * @property name - NFT custom name\n * @property description - The NFT description\n * @property numberOfSales - Number of sales\n * @property backgroundColor - The background color to be displayed with the item\n * @property image - Image custom image URI\n * @property imagePreview - URI of a smaller image associated with this NFT\n * @property imageThumbnail - URI of a thumbnail image associated with this NFT\n * @property imageOriginal - URI of the original image associated with this NFT\n * @property animation - URI of a animation associated with this NFT\n * @property animationOriginal - URI of the original animation associated with this NFT\n * @property externalLink - External link containing additional information\n * @property creator - The NFT owner information object\n * @property standard - NFT standard name for the NFT, e.g., ERC-721 or ERC-1155\n */\nexport interface NftMetadata {\n  name: string | null;\n  description: string | null;\n  image: string | null;\n  standard: string | null;\n  favorite?: boolean;\n  numberOfSales?: number;\n  backgroundColor?: string;\n  imagePreview?: string;\n  imageThumbnail?: string;\n  imageOriginal?: string;\n  animation?: string;\n  animationOriginal?: string;\n  externalLink?: string;\n  creator?: ApiNftCreator;\n  lastSale?: ApiNftLastSale;\n  transactionId?: string;\n  tokenURI?: string | null;\n}\n\n/**\n * @type NftConfig\n *\n * NFT controller configuration\n * @property selectedAddress - Vault selected address\n */\nexport interface NftConfig extends BaseConfig {\n  selectedAddress: string;\n  chainId: Hex;\n  ipfsGateway: string;\n  openSeaEnabled: boolean;\n  useIPFSSubdomains: boolean;\n  isIpfsGatewayEnabled: boolean;\n}\n\n/**\n * @type NftState\n *\n * NFT controller state\n * @property allNftContracts - Object containing NFT contract information\n * @property allNfts - Object containing NFTs per account and network\n * @property ignoredNfts - List of NFTs that should be ignored\n */\nexport interface NftState extends BaseState {\n  allNftContracts: {\n    [key: string]: { [chainId: Hex]: NftContract[] };\n  };\n  allNfts: { [key: string]: { [chainId: Hex]: Nft[] } };\n  ignoredNfts: Nft[];\n}\n\nconst ALL_NFTS_STATE_KEY = 'allNfts';\nconst ALL_NFTS_CONTRACTS_STATE_KEY = 'allNftContracts';\n\ninterface NftAsset {\n  address: string;\n  tokenId: string;\n}\n\n/**\n * The name of the {@link NftController}.\n */\nconst controllerName = 'NftController';\n\n/**\n * The external actions available to the {@link NftController}.\n */\ntype AllowedActions = AddApprovalRequest;\n\n/**\n * The messenger of the {@link NftController}.\n */\nexport type NftControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  AllowedActions,\n  never,\n  AllowedActions['type'],\n  never\n>;\n\n/**\n * Controller that stores assets and exposes convenience methods\n */\nexport class NftController extends BaseController<NftConfig, NftState> {\n  private readonly mutex = new Mutex();\n\n  private readonly messagingSystem: NftControllerMessenger;\n\n  private getNftApi({\n    contractAddress,\n    tokenId,\n  }: {\n    contractAddress: string;\n    tokenId: string;\n  }) {\n    return `${OPENSEA_PROXY_URL}/asset/${contractAddress}/${tokenId}`;\n  }\n\n  private getNftContractInformationApi({\n    contractAddress,\n  }: {\n    contractAddress: string;\n  }) {\n    return `${OPENSEA_PROXY_URL}/asset_contract/${contractAddress}`;\n  }\n\n  /**\n   * Helper method to update nested state for allNfts and allNftContracts.\n   *\n   * @param newCollection - the modified piece of state to update in the controller's store\n   * @param baseStateKey - The root key in the store to update.\n   * @param passedConfig - An object containing the selectedAddress and chainId that are passed through the auto-detection flow.\n   * @param passedConfig.userAddress - the address passed through the NFT detection flow to ensure assets are stored to the correct account\n   * @param passedConfig.chainId - the chainId passed through the NFT detection flow to ensure assets are stored to the correct account\n   */\n  private updateNestedNftState(\n    newCollection: Nft[] | NftContract[],\n    baseStateKey: 'allNfts' | 'allNftContracts',\n    { userAddress, chainId } = {\n      userAddress: this.config.selectedAddress,\n      chainId: this.config.chainId,\n    },\n  ) {\n    const { [baseStateKey]: oldState } = this.state;\n\n    const addressState = oldState[userAddress];\n    const newAddressState = {\n      ...addressState,\n      ...{ [chainId]: newCollection },\n    };\n    const newState = {\n      ...oldState,\n      ...{ [userAddress]: newAddressState },\n    };\n\n    this.update({\n      [baseStateKey]: newState,\n    });\n  }\n\n  /**\n   * Request individual NFT information from OpenSea API.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftInformationFromApi(\n    contractAddress: string,\n    tokenId: string,\n  ): Promise<NftMetadata> {\n    // TODO Parameterize this by chainId for non-mainnet token detection\n    // Attempt to fetch the data with the proxy\n    const nftInformation: ApiNft | undefined = await fetchWithErrorHandling({\n      url: this.getNftApi({\n        contractAddress,\n        tokenId,\n      }),\n    });\n\n    // if we were still unable to fetch the data we return out the default/null of `NftMetadata`\n    if (!nftInformation) {\n      return {\n        name: null,\n        description: null,\n        image: null,\n        standard: null,\n      };\n    }\n\n    // if we've reached this point, we have successfully fetched some data for nftInformation\n    // now we reconfigure the data to conform to the `NftMetadata` type for storage.\n    const {\n      num_sales,\n      background_color,\n      image_url,\n      image_preview_url,\n      image_thumbnail_url,\n      image_original_url,\n      animation_url,\n      animation_original_url,\n      name,\n      description,\n      external_link,\n      creator,\n      last_sale,\n      asset_contract: { schema_name },\n    } = nftInformation;\n\n    /* istanbul ignore next */\n    const nftMetadata: NftMetadata = Object.assign(\n      {},\n      { name: name || null },\n      { description: description || null },\n      { image: image_url || null },\n      creator && { creator },\n      num_sales && { numberOfSales: num_sales },\n      background_color && { backgroundColor: background_color },\n      image_preview_url && { imagePreview: image_preview_url },\n      image_thumbnail_url && { imageThumbnail: image_thumbnail_url },\n      image_original_url && { imageOriginal: image_original_url },\n      animation_url && { animation: animation_url },\n      animation_original_url && {\n        animationOriginal: animation_original_url,\n      },\n      external_link && { externalLink: external_link },\n      last_sale && { lastSale: last_sale },\n      schema_name && { standard: schema_name },\n    );\n\n    return nftMetadata;\n  }\n\n  /**\n   * Request individual NFT information from contracts that follows Metadata Interface.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftInformationFromTokenURI(\n    contractAddress: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<NftMetadata> {\n    const { ipfsGateway, useIPFSSubdomains, isIpfsGatewayEnabled } =\n      this.config;\n    const result = await this.getNftURIAndStandard(\n      contractAddress,\n      tokenId,\n      networkClientId,\n    );\n    let tokenURI = result[0];\n    const standard = result[1];\n\n    const hasIpfsTokenURI = tokenURI.startsWith('ipfs://');\n\n    if (hasIpfsTokenURI && !isIpfsGatewayEnabled) {\n      return {\n        image: null,\n        name: null,\n        description: null,\n        standard: standard || null,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    }\n\n    const isDisplayNFTMediaToggleEnabled = this.config.openSeaEnabled;\n    if (!hasIpfsTokenURI && !isDisplayNFTMediaToggleEnabled) {\n      return {\n        image: null,\n        name: null,\n        description: null,\n        standard: standard || null,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    }\n\n    if (hasIpfsTokenURI) {\n      tokenURI = getFormattedIpfsUrl(ipfsGateway, tokenURI, useIPFSSubdomains);\n    }\n\n    try {\n      const object = await handleFetch(tokenURI);\n      // TODO: Check image_url existence. This is not part of EIP721 nor EIP1155\n      const image = Object.prototype.hasOwnProperty.call(object, 'image')\n        ? 'image'\n        : /* istanbul ignore next */ 'image_url';\n\n      return {\n        image: object[image],\n        name: object.name,\n        description: object.description,\n        standard,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    } catch {\n      return {\n        image: null,\n        name: null,\n        description: null,\n        standard: standard || null,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    }\n  }\n\n  /**\n   * Retrieve NFT uri with  metadata. TODO Update method to use IPFS.\n   *\n   * @param contractAddress - NFT contract address.\n   * @param tokenId - NFT token id.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving NFT uri and token standard.\n   */\n  private async getNftURIAndStandard(\n    contractAddress: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<[string, string]> {\n    // try ERC721 uri\n    try {\n      const uri = await this.getERC721TokenURI(\n        contractAddress,\n        tokenId,\n        networkClientId,\n      );\n      return [uri, ERC721];\n    } catch {\n      // Ignore error\n    }\n\n    // try ERC1155 uri\n    try {\n      const tokenURI = await this.getERC1155TokenURI(\n        contractAddress,\n        tokenId,\n        networkClientId,\n      );\n\n      /**\n       * According to EIP1155 the URI value allows for ID substitution\n       * in case the string `{id}` exists.\n       * https://eips.ethereum.org/EIPS/eip-1155#metadata\n       */\n\n      if (!tokenURI.includes('{id}')) {\n        return [tokenURI, ERC1155];\n      }\n\n      const hexTokenId = stripHexPrefix(BNToHex(new BN(tokenId)))\n        .padStart(64, '0')\n        .toLowerCase();\n      return [tokenURI.replace('{id}', hexTokenId), ERC1155];\n    } catch {\n      // Ignore error\n    }\n\n    return ['', ''];\n  }\n\n  /**\n   * Request individual NFT information (name, image url and description).\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftInformation(\n    contractAddress: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<NftMetadata> {\n    let { chainId } = this.config;\n    if (networkClientId) {\n      chainId =\n        this.getNetworkClientById(networkClientId).configuration.chainId;\n    }\n\n    const [blockchainMetadata, openSeaMetadata] = await Promise.all([\n      safelyExecute(() =>\n        this.getNftInformationFromTokenURI(\n          contractAddress,\n          tokenId,\n          networkClientId,\n        ),\n      ),\n      this.config.openSeaEnabled && chainId === '0x1'\n        ? safelyExecute(() =>\n            this.getNftInformationFromApi(contractAddress, tokenId),\n          )\n        : undefined,\n    ]);\n\n    return {\n      ...openSeaMetadata,\n      name: blockchainMetadata.name ?? openSeaMetadata?.name ?? null,\n      description:\n        blockchainMetadata.description ?? openSeaMetadata?.description ?? null,\n      image: blockchainMetadata.image ?? openSeaMetadata?.image ?? null,\n      standard:\n        blockchainMetadata.standard ?? openSeaMetadata?.standard ?? null,\n      tokenURI: blockchainMetadata.tokenURI ?? null,\n    };\n  }\n\n  /**\n   * Request NFT contract information from OpenSea API.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftContractInformationFromApi(\n    contractAddress: string,\n  ): Promise<ApiNftContract> {\n    /* istanbul ignore if */\n    const apiNftContractObject: ApiNftContract | undefined =\n      await fetchWithErrorHandling({\n        url: this.getNftContractInformationApi({\n          contractAddress,\n        }),\n      });\n\n    // if we successfully fetched return the fetched data immediately\n    if (apiNftContractObject) {\n      return apiNftContractObject;\n    }\n\n    // If we've reached this point we were unable to fetch data from either the proxy or opensea so we return\n    // the default/null of ApiNftContract\n    return {\n      address: contractAddress,\n      asset_contract_type: null,\n      created_date: null,\n      schema_name: null,\n      symbol: null,\n      total_supply: null,\n      description: null,\n      external_link: null,\n      collection: {\n        name: null,\n        image_url: null,\n      },\n    };\n  }\n\n  /**\n   * Request NFT contract information from the contract itself.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftContractInformationFromContract(\n    contractAddress: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<\n    Partial<ApiNftContract> &\n      Pick<ApiNftContract, 'address'> &\n      Pick<ApiNftContract, 'collection'>\n  > {\n    const [name, symbol] = await Promise.all([\n      this.getERC721AssetName(contractAddress, networkClientId),\n      this.getERC721AssetSymbol(contractAddress, networkClientId),\n    ]);\n\n    return {\n      collection: { name },\n      symbol,\n      address: contractAddress,\n    };\n  }\n\n  /**\n   * Request NFT contract information from OpenSea API.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the NFT contract name, image and description.\n   */\n  private async getNftContractInformation(\n    contractAddress: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<\n    Partial<ApiNftContract> &\n      Pick<ApiNftContract, 'address'> &\n      Pick<ApiNftContract, 'collection'>\n  > {\n    const { chainId } = this.config;\n    const getCurrentChainId = this.getCorrectChainId({\n      chainId,\n      networkClientId,\n    });\n\n    const [blockchainContractData, openSeaContractData]: [\n      Partial<ApiNftContract> &\n        Pick<ApiNftContract, 'address'> &\n        Pick<ApiNftContract, 'collection'>,\n      Partial<ApiNftContract> | undefined,\n    ] = await Promise.all([\n      safelyExecute(() =>\n        this.getNftContractInformationFromContract(\n          contractAddress,\n          networkClientId,\n        ),\n      ),\n      this.config.openSeaEnabled && getCurrentChainId === '0x1'\n        ? safelyExecute(() =>\n            this.getNftContractInformationFromApi(contractAddress),\n          )\n        : undefined,\n    ]);\n\n    if (blockchainContractData || openSeaContractData) {\n      return {\n        ...openSeaContractData,\n        ...blockchainContractData,\n        collection: {\n          image_url: null,\n          ...openSeaContractData?.collection,\n          ...blockchainContractData?.collection,\n        },\n      };\n    }\n\n    /* istanbul ignore next */\n    return {\n      address: contractAddress,\n      asset_contract_type: null,\n      created_date: null,\n      schema_name: null,\n      symbol: null,\n      total_supply: null,\n      description: null,\n      external_link: null,\n      collection: { name: null, image_url: null },\n    };\n  }\n\n  /**\n   * Adds an individual NFT to the stored NFT list.\n   *\n   * @param tokenAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param nftMetadata - NFT optional information (name, image and description).\n   * @param nftContract - An object containing contract data of the NFT being added.\n   * @param chainId - The chainId of the network where the NFT is being added.\n   * @param userAddress - The address of the account where the NFT is being added.\n   * @param source - Whether the NFT was detected, added manually or suggested by a dapp.\n   * @returns Promise resolving to the current NFT list.\n   */\n  private async addIndividualNft(\n    tokenAddress: string,\n    tokenId: string,\n    nftMetadata: NftMetadata,\n    nftContract: NftContract,\n    chainId: Hex,\n    userAddress: string,\n    source: Source,\n  ): Promise<Nft[]> {\n    // TODO: Remove unused return\n    const releaseLock = await this.mutex.acquire();\n    try {\n      tokenAddress = toChecksumHexAddress(tokenAddress);\n      const { allNfts } = this.state;\n\n      const nfts = allNfts[userAddress]?.[chainId] || [];\n\n      const existingEntry: Nft | undefined = nfts.find(\n        (nft) =>\n          nft.address.toLowerCase() === tokenAddress.toLowerCase() &&\n          nft.tokenId === tokenId,\n      );\n\n      if (existingEntry) {\n        const differentMetadata = compareNftMetadata(\n          nftMetadata,\n          existingEntry,\n        );\n        if (differentMetadata || !existingEntry.isCurrentlyOwned) {\n          // TODO: Switch to indexToUpdate\n          const indexToRemove = nfts.findIndex(\n            (nft) =>\n              nft.address.toLowerCase() === tokenAddress.toLowerCase() &&\n              nft.tokenId === tokenId,\n          );\n          /* istanbul ignore next */\n          if (indexToRemove !== -1) {\n            nfts.splice(indexToRemove, 1);\n          }\n        } else {\n          return nfts;\n        }\n      }\n\n      const newEntry: Nft = {\n        address: tokenAddress,\n        tokenId,\n        favorite: existingEntry?.favorite || false,\n        isCurrentlyOwned: true,\n        ...nftMetadata,\n      };\n\n      const newNfts = [...nfts, newEntry];\n      this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n        chainId,\n        userAddress,\n      });\n\n      if (this.onNftAdded) {\n        this.onNftAdded({\n          address: tokenAddress,\n          symbol: nftContract.symbol,\n          tokenId: tokenId.toString(),\n          standard: nftMetadata.standard,\n          source,\n        });\n      }\n\n      return newNfts;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Adds an NFT contract to the stored NFT contracts list.\n   *\n   * @param options - options.\n   * @param options.tokenAddress - Hex address of the NFT contract.\n   * @param options.chainId - The chainId of the network where the NFT is being added.\n   * @param options.userAddress - The address of the account where the NFT is being added.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.\n   * @returns Promise resolving to the current NFT contracts list.\n   */\n  private async addNftContract({\n    tokenAddress,\n    chainId,\n    userAddress,\n    networkClientId,\n    source,\n  }: {\n    tokenAddress: string;\n    chainId?: Hex;\n    userAddress?: string;\n    networkClientId?: NetworkClientId;\n    source?: Source;\n  }): Promise<NftContract[]> {\n    const releaseLock = await this.mutex.acquire();\n    try {\n      tokenAddress = toChecksumHexAddress(tokenAddress);\n      const { allNftContracts } = this.state;\n      const currentChainId = this.getCorrectChainId({\n        chainId,\n        networkClientId,\n      });\n      const selectedAddress = userAddress ?? this.config.selectedAddress;\n\n      const nftContracts =\n        allNftContracts[selectedAddress]?.[currentChainId] || [];\n\n      const existingEntry = nftContracts.find(\n        (nftContract) =>\n          nftContract.address.toLowerCase() === tokenAddress.toLowerCase(),\n      );\n      if (existingEntry) {\n        return nftContracts;\n      }\n\n      // this doesn't work currently for detection if the user switches networks while the detection is processing\n      // will be fixed once detection uses networkClientIds\n      const contractInformation = await this.getNftContractInformation(\n        tokenAddress,\n        networkClientId,\n      );\n      const {\n        asset_contract_type,\n        created_date,\n        schema_name,\n        symbol,\n        total_supply,\n        description,\n        external_link,\n        collection: { name, image_url },\n      } = contractInformation;\n\n      // If the nft is auto-detected we want some valid metadata to be present\n      if (\n        source === Source.Detected &&\n        Object.entries(contractInformation).every(([k, v]: [string, any]) => {\n          if (k === 'address') {\n            return true; // address will always be present\n          }\n          // collection will always be an object, we need to check the internal values\n          if (k === 'collection') {\n            return v?.name === null && v?.image_url === null;\n          }\n          return !v;\n        })\n      ) {\n        return nftContracts;\n      }\n\n      /* istanbul ignore next */\n      const newEntry: NftContract = Object.assign(\n        {},\n        { address: tokenAddress },\n        description && { description },\n        name && { name },\n        image_url && { logo: image_url },\n        symbol && { symbol },\n        total_supply !== null &&\n          typeof total_supply !== 'undefined' && { totalSupply: total_supply },\n        asset_contract_type && { assetContractType: asset_contract_type },\n        created_date && { createdDate: created_date },\n        schema_name && { schemaName: schema_name },\n        external_link && { externalLink: external_link },\n      );\n      const newNftContracts = [...nftContracts, newEntry];\n      this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY, {\n        chainId: currentChainId,\n        userAddress: selectedAddress,\n      });\n\n      return newNftContracts;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Removes an individual NFT from the stored token list and saves it in ignored NFTs list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   */\n  private removeAndIgnoreIndividualNft(address: string, tokenId: string) {\n    address = toChecksumHexAddress(address);\n    const { allNfts, ignoredNfts } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const newIgnoredNfts = [...ignoredNfts];\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const newNfts = nfts.filter((nft) => {\n      if (\n        nft.address.toLowerCase() === address.toLowerCase() &&\n        nft.tokenId === tokenId\n      ) {\n        const alreadyIgnored = newIgnoredNfts.find(\n          (c) => c.address === address && c.tokenId === tokenId,\n        );\n        !alreadyIgnored && newIgnoredNfts.push(nft);\n        return false;\n      }\n      return true;\n    });\n\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY);\n\n    this.update({\n      ignoredNfts: newIgnoredNfts,\n    });\n  }\n\n  /**\n   * Removes an individual NFT from the stored token list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   */\n  private removeIndividualNft(address: string, tokenId: string) {\n    address = toChecksumHexAddress(address);\n    const { allNfts } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const newNfts = nfts.filter(\n      (nft) =>\n        !(\n          nft.address.toLowerCase() === address.toLowerCase() &&\n          nft.tokenId === tokenId\n        ),\n    );\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY);\n  }\n\n  /**\n   * Removes an NFT contract to the stored NFT contracts list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @returns Promise resolving to the current NFT contracts list.\n   */\n  private removeNftContract(address: string): NftContract[] {\n    address = toChecksumHexAddress(address);\n    const { allNftContracts } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const nftContracts = allNftContracts[selectedAddress]?.[chainId] || [];\n\n    const newNftContracts = nftContracts.filter(\n      (nftContract) =>\n        !(nftContract.address.toLowerCase() === address.toLowerCase()),\n    );\n    this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY);\n\n    return newNftContracts;\n  }\n\n  /**\n   * EventEmitter instance used to listen to specific EIP747 events\n   */\n  hub = new EventEmitter();\n\n  /**\n   * Optional API key to use with opensea\n   */\n  openSeaApiKey?: string;\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'NftController';\n\n  private readonly getERC721AssetName: AssetsContractController['getERC721AssetName'];\n\n  private readonly getERC721AssetSymbol: AssetsContractController['getERC721AssetSymbol'];\n\n  private readonly getERC721TokenURI: AssetsContractController['getERC721TokenURI'];\n\n  private readonly getERC721OwnerOf: AssetsContractController['getERC721OwnerOf'];\n\n  private readonly getERC1155BalanceOf: AssetsContractController['getERC1155BalanceOf'];\n\n  private readonly getERC1155TokenURI: AssetsContractController['getERC1155TokenURI'];\n\n  private readonly getNetworkClientById: NetworkController['getNetworkClientById'];\n\n  private readonly onNftAdded?: (data: {\n    address: string;\n    symbol: string | undefined;\n    tokenId: string;\n    standard: string | null;\n    source: Source;\n  }) => void;\n\n  /**\n   * Creates an NftController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param options.getERC721AssetName - Gets the name of the asset at the given address.\n   * @param options.getERC721AssetSymbol - Gets the symbol of the asset at the given address.\n   * @param options.getERC721TokenURI - Gets the URI of the ERC721 token at the given address, with the given ID.\n   * @param options.getERC721OwnerOf - Get the owner of a ERC-721 NFT.\n   * @param options.getERC1155BalanceOf - Gets balance of a ERC-1155 NFT.\n   * @param options.getERC1155TokenURI - Gets the URI of the ERC1155 token at the given address, with the given ID.\n   * @param options.getNetworkClientById - Gets the network client for the given networkClientId.\n   * @param options.onNftAdded - Callback that is called when an NFT is added. Currently used pass data\n   * for tracking the NFT added event.\n   * @param options.messenger - The controller messenger.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      chainId: initialChainId,\n      onPreferencesStateChange,\n      onNetworkStateChange,\n      getERC721AssetName,\n      getERC721AssetSymbol,\n      getERC721TokenURI,\n      getERC721OwnerOf,\n      getERC1155BalanceOf,\n      getERC1155TokenURI,\n      getNetworkClientById,\n      onNftAdded,\n      messenger,\n    }: {\n      chainId: Hex;\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      getERC721AssetName: AssetsContractController['getERC721AssetName'];\n      getERC721AssetSymbol: AssetsContractController['getERC721AssetSymbol'];\n      getERC721TokenURI: AssetsContractController['getERC721TokenURI'];\n      getERC721OwnerOf: AssetsContractController['getERC721OwnerOf'];\n      getERC1155BalanceOf: AssetsContractController['getERC1155BalanceOf'];\n      getERC1155TokenURI: AssetsContractController['getERC1155TokenURI'];\n      getNetworkClientById: NetworkController['getNetworkClientById'];\n      onNftAdded?: (data: {\n        address: string;\n        symbol: string | undefined;\n        tokenId: string;\n        standard: string | null;\n        source: string;\n      }) => void;\n      messenger: NftControllerMessenger;\n    },\n    config?: Partial<BaseConfig>,\n    state?: Partial<NftState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      selectedAddress: '',\n      chainId: initialChainId,\n      ipfsGateway: IPFS_DEFAULT_GATEWAY_URL,\n      openSeaEnabled: false,\n      useIPFSSubdomains: true,\n      isIpfsGatewayEnabled: true,\n    };\n\n    this.defaultState = {\n      allNftContracts: {},\n      allNfts: {},\n      ignoredNfts: [],\n    };\n    this.initialize();\n    this.getERC721AssetName = getERC721AssetName;\n    this.getERC721AssetSymbol = getERC721AssetSymbol;\n    this.getERC721TokenURI = getERC721TokenURI;\n    this.getERC721OwnerOf = getERC721OwnerOf;\n    this.getERC1155BalanceOf = getERC1155BalanceOf;\n    this.getERC1155TokenURI = getERC1155TokenURI;\n    this.getNetworkClientById = getNetworkClientById;\n    this.onNftAdded = onNftAdded;\n    this.messagingSystem = messenger;\n\n    onPreferencesStateChange(\n      ({\n        selectedAddress,\n        ipfsGateway,\n        openSeaEnabled,\n        isIpfsGatewayEnabled,\n      }) => {\n        this.configure({\n          selectedAddress,\n          ipfsGateway,\n          openSeaEnabled,\n          isIpfsGatewayEnabled,\n        });\n      },\n    );\n\n    onNetworkStateChange(({ providerConfig }) => {\n      const { chainId } = providerConfig;\n      this.configure({ chainId });\n    });\n  }\n\n  async validateWatchNft(\n    asset: NftAsset,\n    type: NFTStandardType,\n    userAddress: string,\n  ) {\n    const { address: contractAddress, tokenId } = asset;\n\n    // Validate parameters\n    if (!type) {\n      throw rpcErrors.invalidParams('Asset type is required');\n    }\n\n    if (type !== ERC721 && type !== ERC1155) {\n      throw rpcErrors.invalidParams(\n        `Non NFT asset type ${type} not supported by watchNft`,\n      );\n    }\n\n    if (!contractAddress || !tokenId) {\n      throw rpcErrors.invalidParams('Both address and tokenId are required');\n    }\n\n    if (!isAddress(contractAddress)) {\n      throw rpcErrors.invalidParams('Invalid address');\n    }\n\n    if (!/^\\d+$/u.test(tokenId)) {\n      throw rpcErrors.invalidParams('Invalid tokenId');\n    }\n\n    // Check if the user owns the suggested NFT\n    try {\n      const isOwner = await this.isNftOwner(\n        userAddress,\n        contractAddress,\n        tokenId,\n      );\n      if (!isOwner) {\n        throw rpcErrors.invalidInput(\n          'Suggested NFT is not owned by the selected account',\n        );\n      }\n    } catch (error: any) {\n      // error thrown here: \"Unable to verify ownership. Possibly because the standard is not supported or the user's currently selected network does not match the chain of the asset in question.\"\n      throw rpcErrors.resourceUnavailable(error.message);\n    }\n  }\n\n  // temporary method to get the correct chainId until we remove chainId from the config & the chainId arg from the detection logic\n  // Just a helper method to prefer the networkClient chainId first then the chainId argument and then finally the config chainId\n  private getCorrectChainId({\n    chainId,\n    networkClientId,\n  }: {\n    chainId?: Hex;\n    networkClientId?: NetworkClientId;\n  }) {\n    if (networkClientId) {\n      return this.getNetworkClientById(networkClientId).configuration.chainId;\n    } else if (chainId) {\n      return chainId;\n    }\n    return this.config.chainId;\n  }\n\n  /**\n   * Adds a new suggestedAsset to state. Parameters will be validated according to\n   * asset type being watched. A `<suggestedNftMeta.id>:pending` hub event will be emitted once added.\n   *\n   * @param asset - The asset to be watched. For now ERC721 and ERC1155 tokens are accepted.\n   * @param asset.address - The address of the asset contract.\n   * @param asset.tokenId - The ID of the asset.\n   * @param type - The asset type.\n   * @param origin - Domain origin to register the asset from.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Object containing a Promise resolving to the suggestedAsset address if accepted.\n   */\n  async watchNft(\n    asset: NftAsset,\n    type: NFTStandardType,\n    origin: string,\n    networkClientId?: NetworkClientId,\n  ) {\n    const { selectedAddress, chainId } = this.config;\n\n    await this.validateWatchNft(asset, type, selectedAddress);\n\n    const nftMetadata = await this.getNftInformation(\n      asset.address,\n      asset.tokenId,\n      networkClientId,\n    );\n\n    if (nftMetadata.standard && nftMetadata.standard !== type) {\n      throw rpcErrors.invalidInput(\n        `Suggested NFT of type ${nftMetadata.standard} does not match received type ${type}`,\n      );\n    }\n\n    const suggestedNftMeta: SuggestedNftMeta = {\n      asset: { ...asset, ...nftMetadata },\n      type,\n      id: random(),\n      time: Date.now(),\n      interactingAddress: selectedAddress,\n      origin,\n    };\n    await this._requestApproval(suggestedNftMeta);\n    const { address, tokenId } = asset;\n    const { name, standard, description, image } = nftMetadata;\n\n    await this.addNft(address, tokenId, {\n      nftMetadata: {\n        name: name ?? null,\n        description: description ?? null,\n        image: image ?? null,\n        standard: standard ?? null,\n      },\n      chainId,\n      userAddress: selectedAddress,\n      source: Source.Dapp,\n      networkClientId,\n    });\n  }\n\n  /**\n   * Sets an OpenSea API key to retrieve NFT information.\n   *\n   * @param openSeaApiKey - OpenSea API key.\n   */\n  setApiKey(openSeaApiKey: string) {\n    this.openSeaApiKey = openSeaApiKey;\n  }\n\n  /**\n   * Checks the ownership of a ERC-721 or ERC-1155 NFT for a given address.\n   *\n   * @param ownerAddress - User public address.\n   * @param nftAddress - NFT contract address.\n   * @param tokenId - NFT token ID.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving the NFT ownership.\n   */\n  async isNftOwner(\n    ownerAddress: string,\n    nftAddress: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<boolean> {\n    // Checks the ownership for ERC-721.\n    try {\n      const owner = await this.getERC721OwnerOf(\n        nftAddress,\n        tokenId,\n        networkClientId,\n      );\n      return ownerAddress.toLowerCase() === owner.toLowerCase();\n      // eslint-disable-next-line no-empty\n    } catch {\n      // Ignore ERC-721 contract error\n    }\n\n    // Checks the ownership for ERC-1155.\n    try {\n      const balance = await this.getERC1155BalanceOf(\n        ownerAddress,\n        nftAddress,\n        tokenId,\n        networkClientId,\n      );\n      return !balance.isZero();\n      // eslint-disable-next-line no-empty\n    } catch {\n      // Ignore ERC-1155 contract error\n    }\n\n    throw new Error(\n      `Unable to verify ownership. Possibly because the standard is not supported or the user's currently selected network does not match the chain of the asset in question.`,\n    );\n  }\n\n  /**\n   * Verifies currently selected address owns entered NFT address/tokenId combo and\n   * adds the NFT and respective NFT contract to the stored NFT and NFT contracts lists.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param source - Whether the NFT was detected, added manually or suggested by a dapp.\n   */\n  async addNftVerifyOwnership(\n    address: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n    source?: Source,\n  ) {\n    const { selectedAddress } = this.config;\n    if (\n      !(await this.isNftOwner(\n        selectedAddress,\n        address,\n        tokenId,\n        networkClientId,\n      ))\n    ) {\n      throw new Error('This NFT is not owned by the user');\n    }\n    await this.addNft(address, tokenId, { networkClientId, source });\n  }\n\n  /**\n   * Adds an NFT and respective NFT contract to the stored NFT and NFT contracts lists.\n   *\n   * @param tokenAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param options - an object of arguments\n   * @param options.nftMetadata - NFT optional metadata.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.userAddress - The address of the current user.\n   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the current NFT list.\n   */\n  async addNft(\n    tokenAddress: string,\n    tokenId: string,\n    {\n      nftMetadata,\n      chainId, // TODO remove and replace chainId arg with fetch chainId using getNetworkClientById(networkClientId).configuration.chainId once polling refactor is complete\n      userAddress,\n      source = Source.Custom,\n      networkClientId,\n    }: {\n      nftMetadata?: NftMetadata;\n      chainId?: Hex;\n      userAddress?: string;\n      source?: Source;\n      networkClientId?: NetworkClientId;\n    } = {},\n  ) {\n    tokenAddress = toChecksumHexAddress(tokenAddress);\n\n    const currentChainId = this.getCorrectChainId({ chainId, networkClientId });\n    const selectedAddress = userAddress ?? this.config.selectedAddress;\n\n    const newNftContracts = await this.addNftContract({\n      tokenAddress,\n      chainId: currentChainId,\n      userAddress: selectedAddress,\n      networkClientId,\n      source,\n    });\n\n    nftMetadata =\n      nftMetadata ||\n      (await this.getNftInformation(tokenAddress, tokenId, networkClientId));\n\n    // If NFT contract was not added, do not add individual NFT\n    const nftContract = newNftContracts.find(\n      (contract) =>\n        contract.address.toLowerCase() === tokenAddress.toLowerCase(),\n    );\n\n    // If NFT contract information, add individual NFT\n    if (nftContract) {\n      await this.addIndividualNft(\n        tokenAddress,\n        tokenId,\n        nftMetadata,\n        nftContract,\n        currentChainId,\n        selectedAddress,\n        source,\n      );\n    }\n  }\n\n  /**\n   * Removes an NFT from the stored token list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   */\n  removeNft(address: string, tokenId: string) {\n    address = toChecksumHexAddress(address);\n    this.removeIndividualNft(address, tokenId);\n    const { allNfts } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const remainingNft = nfts.find(\n      (nft) => nft.address.toLowerCase() === address.toLowerCase(),\n    );\n    if (!remainingNft) {\n      this.removeNftContract(address);\n    }\n  }\n\n  /**\n   * Removes an NFT from the stored token list and saves it in ignored NFTs list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   */\n  removeAndIgnoreNft(address: string, tokenId: string) {\n    address = toChecksumHexAddress(address);\n    this.removeAndIgnoreIndividualNft(address, tokenId);\n    const { allNfts } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const remainingNft = nfts.find(\n      (nft) => nft.address.toLowerCase() === address.toLowerCase(),\n    );\n    if (!remainingNft) {\n      this.removeNftContract(address);\n    }\n  }\n\n  /**\n   * Removes all NFTs from the ignored list.\n   */\n  clearIgnoredNfts() {\n    this.update({ ignoredNfts: [] });\n  }\n\n  /**\n   * Checks whether input NFT is still owned by the user\n   * And updates the isCurrentlyOwned value on the NFT object accordingly.\n   *\n   * @param nft - The NFT object to check and update.\n   * @param batch - A boolean indicating whether this method is being called as part of a batch or single update.\n   * @param accountParams - The userAddress and chainId to check ownership against\n   * @param accountParams.userAddress - the address passed through the confirmed transaction flow to ensure assets are stored to the correct account\n   * @param accountParams.chainId - the chainId passed through the confirmed transaction flow to ensure assets are stored to the correct account\n   * @returns the NFT with the updated isCurrentlyOwned value\n   */\n  async checkAndUpdateSingleNftOwnershipStatus(\n    nft: Nft,\n    batch: boolean,\n    { userAddress, chainId } = {\n      userAddress: this.config.selectedAddress,\n      chainId: this.config.chainId,\n    },\n  ) {\n    const { address, tokenId } = nft;\n    let isOwned = nft.isCurrentlyOwned;\n    try {\n      isOwned = await this.isNftOwner(userAddress, address, tokenId);\n    } catch (error) {\n      if (\n        !(\n          error instanceof Error &&\n          error.message.includes('Unable to verify ownership')\n        )\n      ) {\n        throw error;\n      }\n    }\n\n    nft.isCurrentlyOwned = isOwned;\n\n    if (batch) {\n      return nft;\n    }\n\n    // if this is not part of a batched update we update this one NFT in state\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const nftToUpdate = nfts.find(\n      (item) =>\n        item.tokenId === tokenId &&\n        item.address.toLowerCase() === address.toLowerCase(),\n    );\n    if (nftToUpdate) {\n      nftToUpdate.isCurrentlyOwned = isOwned;\n      this.updateNestedNftState(nfts, ALL_NFTS_STATE_KEY, {\n        userAddress,\n        chainId,\n      });\n    }\n    return nft;\n  }\n\n  /**\n   * Checks whether NFTs associated with current selectedAddress/chainId combination are still owned by the user\n   * And updates the isCurrentlyOwned value on each accordingly.\n   */\n  async checkAndUpdateAllNftsOwnershipStatus() {\n    const { allNfts } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const updatedNfts = await Promise.all(\n      nfts.map(async (nft) => {\n        return (\n          (await this.checkAndUpdateSingleNftOwnershipStatus(nft, true)) ?? nft\n        );\n      }),\n    );\n\n    this.updateNestedNftState(updatedNfts, ALL_NFTS_STATE_KEY);\n  }\n\n  /**\n   * Update NFT favorite status.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Hex address of the NFT contract.\n   * @param favorite - NFT new favorite status.\n   */\n  updateNftFavoriteStatus(address: string, tokenId: string, favorite: boolean) {\n    const { allNfts } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const index: number = nfts.findIndex(\n      (nft) => nft.address === address && nft.tokenId === tokenId,\n    );\n\n    if (index === -1) {\n      return;\n    }\n\n    const updatedNft: Nft = {\n      ...nfts[index],\n      favorite,\n    };\n\n    // Update Nfts array\n    nfts[index] = updatedNft;\n\n    this.updateNestedNftState(nfts, ALL_NFTS_STATE_KEY);\n  }\n\n  /**\n   * Returns an NFT by the address and token id.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Number that represents the id of the token.\n   * @param selectedAddress - Hex address of the user account.\n   * @param chainId - Id of the current network.\n   * @returns Object containing the NFT and its position in the array\n   */\n  findNftByAddressAndTokenId(\n    address: string,\n    tokenId: string,\n    selectedAddress: string,\n    chainId: Hex,\n  ): { nft: Nft; index: number } | null {\n    const { allNfts } = this.state;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const index: number = nfts.findIndex(\n      (nft) =>\n        nft.address.toLowerCase() === address.toLowerCase() &&\n        nft.tokenId === tokenId,\n    );\n\n    if (index === -1) {\n      return null;\n    }\n\n    return { nft: nfts[index], index };\n  }\n\n  /**\n   * Update NFT data.\n   *\n   * @param nft - NFT object to find the right NFT to updates.\n   * @param updates - NFT partial object to update properties of the NFT.\n   * @param selectedAddress - Hex address of the user account.\n   * @param chainId - Id of the current network.\n   */\n  updateNft(\n    nft: Nft,\n    updates: Partial<Nft>,\n    selectedAddress: string,\n    chainId: Hex,\n  ) {\n    const { allNfts } = this.state;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const nftInfo = this.findNftByAddressAndTokenId(\n      nft.address,\n      nft.tokenId,\n      selectedAddress,\n      chainId,\n    );\n\n    if (!nftInfo) {\n      return;\n    }\n\n    const updatedNft: Nft = {\n      ...nft,\n      ...updates,\n    };\n\n    const newNfts = [\n      ...nfts.slice(0, nftInfo.index),\n      updatedNft,\n      ...nfts.slice(nftInfo.index + 1),\n    ];\n\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY);\n  }\n\n  /**\n   * Resets the transaction status of an NFT.\n   *\n   * @param transactionId - NFT transaction id.\n   * @param selectedAddress - Hex address of the user account.\n   * @param chainId - Id of the current network.\n   * @returns a boolean indicating if the reset was well succeeded or not\n   */\n  resetNftTransactionStatusByTransactionId(\n    transactionId: string,\n    selectedAddress: string,\n    chainId: Hex,\n  ): boolean {\n    const { allNfts } = this.state;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const index: number = nfts.findIndex(\n      (nft) => nft.transactionId === transactionId,\n    );\n\n    if (index === -1) {\n      return false;\n    }\n    const updatedNft: Nft = {\n      ...nfts[index],\n      transactionId: undefined,\n    };\n\n    const newNfts = [\n      ...nfts.slice(0, index),\n      updatedNft,\n      ...nfts.slice(index + 1),\n    ];\n\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY);\n    return true;\n  }\n\n  async _requestApproval(suggestedNftMeta: SuggestedNftMeta) {\n    return this.messagingSystem.call(\n      'ApprovalController:addRequest',\n      {\n        id: suggestedNftMeta.id,\n        origin: suggestedNftMeta.origin,\n        type: ApprovalType.WatchAsset,\n        requestData: {\n          id: suggestedNftMeta.id,\n          interactingAddress: suggestedNftMeta.interactingAddress,\n          asset: {\n            address: suggestedNftMeta.asset.address,\n            tokenId: suggestedNftMeta.asset.tokenId,\n            name: suggestedNftMeta.asset.name,\n            description: suggestedNftMeta.asset.description,\n            image: suggestedNftMeta.asset.image,\n            standard: suggestedNftMeta.asset.standard,\n          },\n        },\n      },\n      true,\n    );\n  }\n}\n\nexport default NftController;\n"]}
\ No newline at end of file
+{"version":3,"file":"NftController.js","sourceRoot":"","sources":["../src/NftController.ts"],"names":[],"mappings":"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","sourcesContent":["import { isAddress } from '@ethersproject/address';\nimport type { AddApprovalRequest } from '@metamask/approval-controller';\nimport type {\n  BaseConfig,\n  BaseState,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport {\n  safelyExecute,\n  handleFetch,\n  toChecksumHexAddress,\n  BNToHex,\n  fetchWithErrorHandling,\n  IPFS_DEFAULT_GATEWAY_URL,\n  ERC721,\n  ERC1155,\n  ApprovalType,\n  NFT_API_BASE_URL,\n} from '@metamask/controller-utils';\nimport type {\n  NetworkClientId,\n  NetworkController,\n  NetworkState,\n} from '@metamask/network-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type { Hex } from '@metamask/utils';\nimport { remove0x } from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\nimport BN from 'bn.js';\nimport { EventEmitter } from 'events';\nimport { v4 as random } from 'uuid';\n\nimport type { AssetsContractController } from './AssetsContractController';\nimport { compareNftMetadata, getFormattedIpfsUrl } from './assetsUtil';\nimport { Source } from './constants';\nimport type {\n  ApiNftContract,\n  ReservoirResponse,\n  Collection,\n  Attributes,\n  LastSale,\n} from './NftDetectionController';\n\ntype NFTStandardType = 'ERC721' | 'ERC1155';\n\ntype SuggestedNftMeta = {\n  asset: { address: string; tokenId: string } & NftMetadata;\n  id: string;\n  time: number;\n  type: NFTStandardType;\n  interactingAddress: string;\n  origin: string;\n};\n\n/**\n * @type Nft\n *\n * NFT representation\n * @property address - Hex address of a ERC721 contract\n * @property description - The NFT description\n * @property image - URI of custom NFT image associated with this tokenId\n * @property name - Name associated with this tokenId and contract address\n * @property tokenId - The NFT identifier\n * @property numberOfSales - Number of sales\n * @property backgroundColor - The background color to be displayed with the item\n * @property imagePreview - URI of a smaller image associated with this NFT\n * @property imageThumbnail - URI of a thumbnail image associated with this NFT\n * @property imageOriginal - URI of the original image associated with this NFT\n * @property animation - URI of a animation associated with this NFT\n * @property animationOriginal - URI of the original animation associated with this NFT\n * @property externalLink - External link containing additional information\n * @property creator - The NFT owner information object\n * @property isCurrentlyOwned - Boolean indicating whether the address/chainId combination where it's currently stored currently owns this NFT\n * @property transactionId - Transaction Id associated with the NFT\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface Nft extends NftMetadata {\n  tokenId: string;\n  address: string;\n  isCurrentlyOwned?: boolean;\n}\n\ntype NftUpdate = {\n  nft: Nft;\n  newMetadata: NftMetadata;\n};\n\n/**\n * @type NftContract\n *\n * NFT contract information representation\n * @property name - Contract name\n * @property logo - Contract logo\n * @property address - Contract address\n * @property symbol - Contract symbol\n * @property description - Contract description\n * @property totalSupply - Total supply of NFTs\n * @property assetContractType - The NFT type, it could be `semi-fungible` or `non-fungible`\n * @property createdDate - Creation date\n * @property schemaName - The schema followed by the contract, it could be `ERC721` or `ERC1155`\n * @property externalLink - External link containing additional information\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface NftContract {\n  name?: string;\n  logo?: string;\n  address: string;\n  symbol?: string;\n  description?: string;\n  totalSupply?: string;\n  assetContractType?: string;\n  createdDate?: string;\n  schemaName?: string;\n  externalLink?: string;\n}\n\n/**\n * @type NftMetadata\n *\n * NFT custom information\n * @property name - NFT custom name\n * @property description - The NFT description\n * @property numberOfSales - Number of sales\n * @property backgroundColor - The background color to be displayed with the item\n * @property image - Image custom image URI\n * @property imagePreview - URI of a smaller image associated with this NFT\n * @property imageThumbnail - URI of a thumbnail image associated with this NFT\n * @property imageOriginal - URI of the original image associated with this NFT\n * @property animation - URI of a animation associated with this NFT\n * @property animationOriginal - URI of the original animation associated with this NFT\n * @property externalLink - External link containing additional information\n * @property creator - The NFT owner information object\n * @property standard - NFT standard name for the NFT, e.g., ERC-721 or ERC-1155\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface NftMetadata {\n  name: string | null;\n  description: string | null;\n  image: string | null;\n  standard: string | null;\n  favorite?: boolean;\n  numberOfSales?: number;\n  backgroundColor?: string;\n  imagePreview?: string;\n  imageThumbnail?: string;\n  imageOriginal?: string;\n  animation?: string;\n  animationOriginal?: string;\n  externalLink?: string;\n  creator?: string;\n  transactionId?: string;\n  tokenURI?: string | null;\n  collection?: Collection;\n  address?: string;\n  attributes?: Attributes;\n  lastSale?: LastSale;\n  rarityRank?: string;\n}\n\n/**\n * @type NftConfig\n *\n * NFT controller configuration\n * @property selectedAddress - Vault selected address\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface NftConfig extends BaseConfig {\n  selectedAddress: string;\n  chainId: Hex;\n  ipfsGateway: string;\n  isIpfsGatewayEnabled: boolean;\n  displayNftMedia: boolean;\n  useIPFSSubdomains: boolean;\n}\n\n/**\n * @type NftState\n *\n * NFT controller state\n * @property allNftContracts - Object containing NFT contract information\n * @property allNfts - Object containing NFTs per account and network\n * @property ignoredNfts - List of NFTs that should be ignored\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface NftState extends BaseState {\n  allNftContracts: {\n    [key: string]: { [chainId: Hex]: NftContract[] };\n  };\n  allNfts: { [key: string]: { [chainId: Hex]: Nft[] } };\n  ignoredNfts: Nft[];\n}\n\nconst ALL_NFTS_STATE_KEY = 'allNfts';\nconst ALL_NFTS_CONTRACTS_STATE_KEY = 'allNftContracts';\n\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\ninterface NftAsset {\n  address: string;\n  tokenId: string;\n}\n\n/**\n * The name of the {@link NftController}.\n */\nconst controllerName = 'NftController';\n\n/**\n * The external actions available to the {@link NftController}.\n */\ntype AllowedActions = AddApprovalRequest;\n\n/**\n * The messenger of the {@link NftController}.\n */\nexport type NftControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  AllowedActions,\n  never,\n  AllowedActions['type'],\n  never\n>;\n\nexport const getDefaultNftState = (): NftState => {\n  return {\n    allNftContracts: {},\n    allNfts: {},\n    ignoredNfts: [],\n  };\n};\n\n/**\n * Controller that stores assets and exposes convenience methods\n */\nexport class NftController extends BaseController<NftConfig, NftState> {\n  private readonly mutex = new Mutex();\n\n  private readonly messagingSystem: NftControllerMessenger;\n\n  getNftApi() {\n    return `${NFT_API_BASE_URL}/tokens`;\n  }\n\n  /**\n   * Helper method to update nested state for allNfts and allNftContracts.\n   *\n   * @param newCollection - the modified piece of state to update in the controller's store\n   * @param baseStateKey - The root key in the store to update.\n   * @param passedConfig - An object containing the selectedAddress and chainId that are passed through the auto-detection flow.\n   * @param passedConfig.userAddress - the address passed through the NFT detection flow to ensure assets are stored to the correct account\n   * @param passedConfig.chainId - the chainId passed through the NFT detection flow to ensure assets are stored to the correct account\n   */\n  private updateNestedNftState(\n    newCollection: Nft[] | NftContract[],\n    baseStateKey: 'allNfts' | 'allNftContracts',\n    { userAddress, chainId }: { userAddress: string; chainId: Hex },\n  ) {\n    const { [baseStateKey]: oldState } = this.state;\n\n    const addressState = oldState[userAddress];\n    const newAddressState = {\n      ...addressState,\n      ...{ [chainId]: newCollection },\n    };\n    const newState = {\n      ...oldState,\n      ...{ [userAddress]: newAddressState },\n    };\n\n    this.update({\n      [baseStateKey]: newState,\n    });\n  }\n\n  /**\n   * Request individual NFT information from NFT API.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftInformationFromApi(\n    contractAddress: string,\n    tokenId: string,\n  ): Promise<NftMetadata> {\n    // TODO Parameterize this by chainId for non-mainnet token detection\n    // Attempt to fetch the data with the nft-api\n    const urlParams = new URLSearchParams({\n      chainIds: '1',\n      tokens: `${contractAddress}:${tokenId}`,\n      includeTopBid: 'true',\n      includeAttributes: 'true',\n      includeLastSale: 'true',\n    }).toString();\n    const nftInformation: ReservoirResponse | undefined =\n      await fetchWithErrorHandling({\n        url: `${this.getNftApi()}?${urlParams}`,\n        options: {\n          headers: {\n            Version: '1',\n          },\n        },\n      });\n    // if we were still unable to fetch the data we return out the default/null of `NftMetadata`\n    if (!nftInformation?.tokens?.[0]?.token) {\n      return {\n        name: null,\n        description: null,\n        image: null,\n        standard: null,\n      };\n    }\n\n    // if we've reached this point, we have successfully fetched some data for nftInformation\n    // now we reconfigure the data to conform to the `NftMetadata` type for storage.\n\n    const {\n      image,\n      metadata: { imageOriginal } = {},\n      name,\n      description,\n      collection,\n      kind,\n      rarityRank,\n      rarity,\n      attributes,\n      lastSale,\n      imageSmall,\n    } = nftInformation.tokens[0].token;\n\n    /* istanbul ignore next */\n    const nftMetadata: NftMetadata = Object.assign(\n      {},\n      { name: name || null },\n      { description: description || null },\n      { image: image || null },\n      collection?.creator && { creator: collection.creator },\n      imageOriginal && { imageOriginal },\n      imageSmall && { imageThumbnail: imageSmall },\n      kind && { standard: kind.toUpperCase() },\n      lastSale && { lastSale },\n      attributes && { attributes },\n      nftInformation.tokens[0].market?.topBid && {\n        topBid: nftInformation.tokens[0].market?.topBid,\n      },\n      rarityRank && { rarityRank },\n      rarity && { rarity },\n      collection && { collection },\n    );\n\n    return nftMetadata;\n  }\n\n  /**\n   * Request individual NFT information from contracts that follows Metadata Interface.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftInformationFromTokenURI(\n    contractAddress: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<NftMetadata> {\n    const {\n      ipfsGateway,\n      useIPFSSubdomains,\n      isIpfsGatewayEnabled,\n      displayNftMedia,\n    } = this.config;\n    const result = await this.getNftURIAndStandard(\n      contractAddress,\n      tokenId,\n      networkClientId,\n    );\n    let tokenURI = result[0];\n    const standard = result[1];\n\n    const hasIpfsTokenURI = tokenURI.startsWith('ipfs://');\n\n    if (hasIpfsTokenURI && !isIpfsGatewayEnabled) {\n      return {\n        image: null,\n        name: null,\n        description: null,\n        standard: standard || null,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    }\n    if (!hasIpfsTokenURI && !displayNftMedia) {\n      return {\n        image: null,\n        name: null,\n        description: null,\n        standard: standard || null,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    }\n\n    if (hasIpfsTokenURI) {\n      tokenURI = getFormattedIpfsUrl(ipfsGateway, tokenURI, useIPFSSubdomains);\n    }\n\n    try {\n      const object = await handleFetch(tokenURI);\n      // TODO: Check image_url existence. This is not part of EIP721 nor EIP1155\n      const image = Object.prototype.hasOwnProperty.call(object, 'image')\n        ? 'image'\n        : /* istanbul ignore next */ 'image_url';\n\n      return {\n        image: object[image],\n        name: object.name,\n        description: object.description,\n        standard,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    } catch {\n      return {\n        image: null,\n        name: null,\n        description: null,\n        standard: standard || null,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    }\n  }\n\n  /**\n   * Retrieve NFT uri with  metadata. TODO Update method to use IPFS.\n   *\n   * @param contractAddress - NFT contract address.\n   * @param tokenId - NFT token id.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving NFT uri and token standard.\n   */\n  private async getNftURIAndStandard(\n    contractAddress: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<[string, string]> {\n    // try ERC721 uri\n    try {\n      const uri = await this.getERC721TokenURI(\n        contractAddress,\n        tokenId,\n        networkClientId,\n      );\n      return [uri, ERC721];\n    } catch {\n      // Ignore error\n    }\n\n    // try ERC1155 uri\n    try {\n      const tokenURI = await this.getERC1155TokenURI(\n        contractAddress,\n        tokenId,\n        networkClientId,\n      );\n\n      /**\n       * According to EIP1155 the URI value allows for ID substitution\n       * in case the string `{id}` exists.\n       * https://eips.ethereum.org/EIPS/eip-1155#metadata\n       */\n\n      if (!tokenURI.includes('{id}')) {\n        return [tokenURI, ERC1155];\n      }\n\n      const hexTokenId = remove0x(BNToHex(new BN(tokenId)))\n        .padStart(64, '0')\n        .toLowerCase();\n      return [tokenURI.replace('{id}', hexTokenId), ERC1155];\n    } catch {\n      // Ignore error\n    }\n\n    return ['', ''];\n  }\n\n  /**\n   * Request individual NFT information (name, image url and description).\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftInformation(\n    contractAddress: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<NftMetadata> {\n    const chainId = this.getCorrectChainId({\n      networkClientId,\n    });\n    const [blockchainMetadata, nftApiMetadata] = await Promise.all([\n      safelyExecute(() =>\n        this.getNftInformationFromTokenURI(\n          contractAddress,\n          tokenId,\n          networkClientId,\n        ),\n      ),\n      this.config.displayNftMedia && chainId === '0x1'\n        ? safelyExecute(() =>\n            this.getNftInformationFromApi(contractAddress, tokenId),\n          )\n        : undefined,\n    ]);\n    return {\n      ...nftApiMetadata,\n      name: blockchainMetadata?.name ?? nftApiMetadata?.name ?? null,\n      description:\n        blockchainMetadata?.description ?? nftApiMetadata?.description ?? null,\n      image: blockchainMetadata?.image ?? nftApiMetadata?.image ?? null,\n      standard:\n        blockchainMetadata?.standard ?? nftApiMetadata?.standard ?? null,\n      tokenURI: blockchainMetadata?.tokenURI ?? null,\n    };\n  }\n\n  /**\n   * Request NFT contract information from the contract itself.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftContractInformationFromContract(\n    contractAddress: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<\n    Partial<ApiNftContract> &\n      Pick<ApiNftContract, 'address'> &\n      Pick<ApiNftContract, 'collection'>\n  > {\n    const [name, symbol] = await Promise.all([\n      this.getERC721AssetName(contractAddress, networkClientId),\n      this.getERC721AssetSymbol(contractAddress, networkClientId),\n    ]);\n\n    return {\n      collection: { name },\n      symbol,\n      address: contractAddress,\n    };\n  }\n\n  /**\n   * Request NFT contract information from Blockchain and aggregate with received data from NFTMetadata.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param nftMetadataFromApi - Received NFT information to be aggregated with blockchain contract information.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the NFT contract name, image and description.\n   */\n  private async getNftContractInformation(\n    contractAddress: string,\n    nftMetadataFromApi: NftMetadata,\n    networkClientId?: NetworkClientId,\n  ): Promise<\n    Partial<ApiNftContract> &\n      Pick<ApiNftContract, 'address'> &\n      Pick<ApiNftContract, 'collection'>\n  > {\n    const blockchainContractData = await safelyExecute(() =>\n      this.getNftContractInformationFromContract(\n        contractAddress,\n        networkClientId,\n      ),\n    );\n\n    if (\n      blockchainContractData ||\n      !Object.values(nftMetadataFromApi).every((value) => value === null)\n    ) {\n      return {\n        address: contractAddress,\n        ...blockchainContractData,\n        schema_name: nftMetadataFromApi?.standard ?? null,\n        collection: {\n          name: null,\n          image_url:\n            nftMetadataFromApi?.collection?.image ??\n            nftMetadataFromApi?.collection?.imageUrl ??\n            null,\n          tokenCount: nftMetadataFromApi?.collection?.tokenCount ?? null,\n          ...nftMetadataFromApi?.collection,\n          ...blockchainContractData?.collection,\n        },\n      };\n    }\n\n    /* istanbul ignore next */\n    return {\n      address: contractAddress,\n      asset_contract_type: null,\n      created_date: null,\n      schema_name: null,\n      symbol: null,\n      total_supply: null,\n      description: null,\n      external_link: null,\n      collection: { name: null, image_url: null },\n    };\n  }\n\n  /**\n   * Adds an individual NFT to the stored NFT list.\n   *\n   * @param tokenAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param nftMetadata - NFT optional information (name, image and description).\n   * @param nftContract - An object containing contract data of the NFT being added.\n   * @param chainId - The chainId of the network where the NFT is being added.\n   * @param userAddress - The address of the account where the NFT is being added.\n   * @param source - Whether the NFT was detected, added manually or suggested by a dapp.\n   * @returns Promise resolving to the current NFT list.\n   */\n  private async addIndividualNft(\n    tokenAddress: string,\n    tokenId: string,\n    nftMetadata: NftMetadata,\n    nftContract: NftContract,\n    chainId: Hex,\n    userAddress: string,\n    source: Source,\n  ): Promise<Nft[]> {\n    // TODO: Remove unused return\n    const releaseLock = await this.mutex.acquire();\n    try {\n      tokenAddress = toChecksumHexAddress(tokenAddress);\n      const { allNfts } = this.state;\n\n      const nfts = allNfts[userAddress]?.[chainId] || [];\n\n      const existingEntry: Nft | undefined = nfts.find(\n        (nft) =>\n          nft.address.toLowerCase() === tokenAddress.toLowerCase() &&\n          nft.tokenId === tokenId,\n      );\n\n      if (existingEntry) {\n        const differentMetadata = compareNftMetadata(\n          nftMetadata,\n          existingEntry,\n        );\n        if (differentMetadata || !existingEntry.isCurrentlyOwned) {\n          // TODO: Switch to indexToUpdate\n          const indexToRemove = nfts.findIndex(\n            (nft) =>\n              nft.address.toLowerCase() === tokenAddress.toLowerCase() &&\n              nft.tokenId === tokenId,\n          );\n          /* istanbul ignore next */\n          if (indexToRemove !== -1) {\n            nfts.splice(indexToRemove, 1);\n          }\n        } else {\n          return nfts;\n        }\n      }\n\n      const newEntry: Nft = {\n        address: tokenAddress,\n        tokenId,\n        favorite: existingEntry?.favorite || false,\n        isCurrentlyOwned: true,\n        ...nftMetadata,\n      };\n\n      const newNfts = [...nfts, newEntry];\n      this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n        chainId,\n        userAddress,\n      });\n\n      if (this.onNftAdded) {\n        this.onNftAdded({\n          address: tokenAddress,\n          symbol: nftContract.symbol,\n          tokenId: tokenId.toString(),\n          standard: nftMetadata.standard,\n          source,\n        });\n      }\n      return newNfts;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Adds an NFT contract to the stored NFT contracts list.\n   *\n   * @param options - options.\n   * @param options.tokenAddress - Hex address of the NFT contract.\n   * @param options.userAddress - The address of the account where the NFT is being added.\n   * @param options.nftMetadata - The retrieved NFTMetadata from API.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.\n   * @returns Promise resolving to the current NFT contracts list.\n   */\n  private async addNftContract({\n    tokenAddress,\n    userAddress,\n    networkClientId,\n    source,\n    nftMetadata,\n  }: {\n    tokenAddress: string;\n    userAddress: string;\n    nftMetadata: NftMetadata;\n    networkClientId?: NetworkClientId;\n    source?: Source;\n  }): Promise<NftContract[]> {\n    const releaseLock = await this.mutex.acquire();\n    try {\n      tokenAddress = toChecksumHexAddress(tokenAddress);\n      const { allNftContracts } = this.state;\n      const chainId = this.getCorrectChainId({\n        networkClientId,\n      });\n\n      const nftContracts = allNftContracts[userAddress]?.[chainId] || [];\n\n      const existingEntry = nftContracts.find(\n        (nftContract) =>\n          nftContract.address.toLowerCase() === tokenAddress.toLowerCase(),\n      );\n      if (existingEntry) {\n        return nftContracts;\n      }\n\n      // this doesn't work currently for detection if the user switches networks while the detection is processing\n      // will be fixed once detection uses networkClientIds\n      // get name and symbol if ERC721 then put together the metadata\n      const contractInformation = await this.getNftContractInformation(\n        tokenAddress,\n        nftMetadata,\n        networkClientId,\n      );\n      const {\n        asset_contract_type,\n        created_date,\n        symbol,\n        description,\n        external_link,\n        schema_name,\n        collection: { name, image_url, tokenCount },\n      } = contractInformation;\n\n      // If the nft is auto-detected we want some valid metadata to be present\n      if (\n        source === Source.Detected &&\n        'address' in contractInformation &&\n        typeof contractInformation.address === 'string' &&\n        'collection' in contractInformation &&\n        contractInformation.collection.name === null &&\n        'image_url' in contractInformation.collection &&\n        contractInformation.collection.image_url === null &&\n        Object.entries(contractInformation).every(([key, value]) => {\n          return key === 'address' || key === 'collection' || !value;\n        })\n      ) {\n        return nftContracts;\n      }\n\n      /* istanbul ignore next */\n      const newEntry: NftContract = Object.assign(\n        {},\n        { address: tokenAddress },\n        description && { description },\n        name && { name },\n        image_url && { logo: image_url },\n        symbol && { symbol },\n        tokenCount !== null &&\n          typeof tokenCount !== 'undefined' && { totalSupply: tokenCount },\n        asset_contract_type && { assetContractType: asset_contract_type },\n        created_date && { createdDate: created_date },\n        schema_name && { schemaName: schema_name },\n        external_link && { externalLink: external_link },\n      );\n      const newNftContracts = [...nftContracts, newEntry];\n      this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY, {\n        chainId,\n        userAddress,\n      });\n\n      return newNftContracts;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Removes an individual NFT from the stored token list and saves it in ignored NFTs list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   * @param options - options.\n   * @param options.chainId - The chainId of the network where the NFT is being removed.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   */\n  private removeAndIgnoreIndividualNft(\n    address: string,\n    tokenId: string,\n    {\n      chainId,\n      userAddress,\n    }: {\n      chainId: Hex;\n      userAddress: string;\n    },\n  ) {\n    address = toChecksumHexAddress(address);\n    const { allNfts, ignoredNfts } = this.state;\n    const newIgnoredNfts = [...ignoredNfts];\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const newNfts = nfts.filter((nft) => {\n      if (\n        nft.address.toLowerCase() === address.toLowerCase() &&\n        nft.tokenId === tokenId\n      ) {\n        const alreadyIgnored = newIgnoredNfts.find(\n          (c) => c.address === address && c.tokenId === tokenId,\n        );\n        !alreadyIgnored && newIgnoredNfts.push(nft);\n        return false;\n      }\n      return true;\n    });\n\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n      userAddress,\n      chainId,\n    });\n\n    this.update({\n      ignoredNfts: newIgnoredNfts,\n    });\n  }\n\n  /**\n   * Removes an individual NFT from the stored token list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   * @param options - options.\n   * @param options.chainId - The chainId of the network where the NFT is being removed.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   */\n  private removeIndividualNft(\n    address: string,\n    tokenId: string,\n    { chainId, userAddress }: { chainId: Hex; userAddress: string },\n  ) {\n    address = toChecksumHexAddress(address);\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const newNfts = nfts.filter(\n      (nft) =>\n        !(\n          nft.address.toLowerCase() === address.toLowerCase() &&\n          nft.tokenId === tokenId\n        ),\n    );\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n      userAddress,\n      chainId,\n    });\n  }\n\n  /**\n   * Removes an NFT contract to the stored NFT contracts list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param options - options.\n   * @param options.chainId - The chainId of the network where the NFT is being removed.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   * @returns Promise resolving to the current NFT contracts list.\n   */\n  private removeNftContract(\n    address: string,\n    { chainId, userAddress }: { chainId: Hex; userAddress: string },\n  ): NftContract[] {\n    address = toChecksumHexAddress(address);\n    const { allNftContracts } = this.state;\n    const nftContracts = allNftContracts[userAddress]?.[chainId] || [];\n\n    const newNftContracts = nftContracts.filter(\n      (nftContract) =>\n        !(nftContract.address.toLowerCase() === address.toLowerCase()),\n    );\n    this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY, {\n      chainId,\n      userAddress,\n    });\n\n    return newNftContracts;\n  }\n\n  /**\n   * EventEmitter instance used to listen to specific EIP747 events\n   */\n  hub = new EventEmitter();\n\n  /**\n   * Optional API key to use with opensea\n   */\n  openSeaApiKey?: string;\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'NftController';\n\n  private readonly getERC721AssetName: AssetsContractController['getERC721AssetName'];\n\n  private readonly getERC721AssetSymbol: AssetsContractController['getERC721AssetSymbol'];\n\n  private readonly getERC721TokenURI: AssetsContractController['getERC721TokenURI'];\n\n  private readonly getERC721OwnerOf: AssetsContractController['getERC721OwnerOf'];\n\n  private readonly getERC1155BalanceOf: AssetsContractController['getERC1155BalanceOf'];\n\n  private readonly getERC1155TokenURI: AssetsContractController['getERC1155TokenURI'];\n\n  private readonly getNetworkClientById: NetworkController['getNetworkClientById'];\n\n  private readonly onNftAdded?: (data: {\n    address: string;\n    symbol: string | undefined;\n    tokenId: string;\n    standard: string | null;\n    source: Source;\n  }) => void;\n\n  /**\n   * Creates an NftController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param options.getERC721AssetName - Gets the name of the asset at the given address.\n   * @param options.getERC721AssetSymbol - Gets the symbol of the asset at the given address.\n   * @param options.getERC721TokenURI - Gets the URI of the ERC721 token at the given address, with the given ID.\n   * @param options.getERC721OwnerOf - Get the owner of a ERC-721 NFT.\n   * @param options.getERC1155BalanceOf - Gets balance of a ERC-1155 NFT.\n   * @param options.getERC1155TokenURI - Gets the URI of the ERC1155 token at the given address, with the given ID.\n   * @param options.getNetworkClientById - Gets the network client for the given networkClientId.\n   * @param options.onNftAdded - Callback that is called when an NFT is added. Currently used pass data\n   * for tracking the NFT added event.\n   * @param options.messenger - The controller messenger.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      chainId: initialChainId,\n      onPreferencesStateChange,\n      onNetworkStateChange,\n      getERC721AssetName,\n      getERC721AssetSymbol,\n      getERC721TokenURI,\n      getERC721OwnerOf,\n      getERC1155BalanceOf,\n      getERC1155TokenURI,\n      getNetworkClientById,\n      onNftAdded,\n      messenger,\n    }: {\n      chainId: Hex;\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      getERC721AssetName: AssetsContractController['getERC721AssetName'];\n      getERC721AssetSymbol: AssetsContractController['getERC721AssetSymbol'];\n      getERC721TokenURI: AssetsContractController['getERC721TokenURI'];\n      getERC721OwnerOf: AssetsContractController['getERC721OwnerOf'];\n      getERC1155BalanceOf: AssetsContractController['getERC1155BalanceOf'];\n      getERC1155TokenURI: AssetsContractController['getERC1155TokenURI'];\n      getNetworkClientById: NetworkController['getNetworkClientById'];\n      onNftAdded?: (data: {\n        address: string;\n        symbol: string | undefined;\n        tokenId: string;\n        standard: string | null;\n        source: string;\n      }) => void;\n      messenger: NftControllerMessenger;\n    },\n    config?: Partial<BaseConfig>,\n    state?: Partial<NftState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      selectedAddress: '',\n      chainId: initialChainId,\n      ipfsGateway: IPFS_DEFAULT_GATEWAY_URL,\n      displayNftMedia: true,\n      useIPFSSubdomains: true,\n      isIpfsGatewayEnabled: true,\n    };\n\n    this.defaultState = getDefaultNftState();\n    this.initialize();\n    this.getERC721AssetName = getERC721AssetName;\n    this.getERC721AssetSymbol = getERC721AssetSymbol;\n    this.getERC721TokenURI = getERC721TokenURI;\n    this.getERC721OwnerOf = getERC721OwnerOf;\n    this.getERC1155BalanceOf = getERC1155BalanceOf;\n    this.getERC1155TokenURI = getERC1155TokenURI;\n    this.getNetworkClientById = getNetworkClientById;\n    this.onNftAdded = onNftAdded;\n    this.messagingSystem = messenger;\n\n    onPreferencesStateChange(\n      async ({\n        selectedAddress,\n        ipfsGateway,\n        displayNftMedia,\n        isIpfsGatewayEnabled,\n      }) => {\n        this.configure({\n          selectedAddress,\n          ipfsGateway,\n          displayNftMedia,\n          isIpfsGatewayEnabled,\n        });\n\n        const needsUpdateNftMetadata =\n          (isIpfsGatewayEnabled && ipfsGateway !== '') || displayNftMedia;\n\n        if (needsUpdateNftMetadata) {\n          const { chainId } = this.config;\n          const nfts: Nft[] =\n            this.state.allNfts[selectedAddress]?.[chainId] ?? [];\n          // filter only nfts\n          const nftsToUpdate = nfts.filter(\n            (singleNft) =>\n              !singleNft.name && !singleNft.description && !singleNft.image,\n          );\n          if (nftsToUpdate.length !== 0) {\n            await this.updateNftMetadata({\n              nfts: nftsToUpdate,\n              userAddress: selectedAddress,\n            });\n          }\n        }\n      },\n    );\n\n    onNetworkStateChange(({ providerConfig }) => {\n      const { chainId } = providerConfig;\n      this.configure({ chainId });\n    });\n  }\n\n  private async validateWatchNft(\n    asset: NftAsset,\n    type: NFTStandardType,\n    userAddress: string,\n    { networkClientId }: { networkClientId?: NetworkClientId } = {},\n  ) {\n    const { address: contractAddress, tokenId } = asset;\n\n    // Validate parameters\n    if (!type) {\n      throw rpcErrors.invalidParams('Asset type is required');\n    }\n\n    if (type !== ERC721 && type !== ERC1155) {\n      throw rpcErrors.invalidParams(\n        `Non NFT asset type ${type} not supported by watchNft`,\n      );\n    }\n\n    if (!contractAddress || !tokenId) {\n      throw rpcErrors.invalidParams('Both address and tokenId are required');\n    }\n\n    if (!isAddress(contractAddress)) {\n      throw rpcErrors.invalidParams('Invalid address');\n    }\n\n    if (!/^\\d+$/u.test(tokenId)) {\n      throw rpcErrors.invalidParams('Invalid tokenId');\n    }\n\n    // Check if the user owns the suggested NFT\n    try {\n      const isOwner = await this.isNftOwner(\n        userAddress,\n        contractAddress,\n        tokenId,\n        { networkClientId },\n      );\n      if (!isOwner) {\n        throw rpcErrors.invalidInput(\n          'Suggested NFT is not owned by the selected account',\n        );\n      }\n    } catch (error) {\n      // error thrown here: \"Unable to verify ownership. Possibly because the standard is not supported or the user's currently selected network does not match the chain of the asset in question.\"\n      if (error instanceof Error) {\n        throw rpcErrors.resourceUnavailable(error.message);\n      }\n      throw error;\n    }\n  }\n\n  // temporary method to get the correct chainId until we remove chainId from the config & the chainId arg from the detection logic\n  // Just a helper method to prefer the networkClient chainId first then the chainId argument and then finally the config chainId\n  private getCorrectChainId({\n    networkClientId,\n  }: {\n    networkClientId?: NetworkClientId;\n  }) {\n    if (networkClientId) {\n      return this.getNetworkClientById(networkClientId).configuration.chainId;\n    }\n    return this.config.chainId;\n  }\n\n  /**\n   * Adds a new suggestedAsset to state. Parameters will be validated according to\n   * asset type being watched. A `<suggestedNftMeta.id>:pending` hub event will be emitted once added.\n   *\n   * @param asset - The asset to be watched. For now ERC721 and ERC1155 tokens are accepted.\n   * @param asset.address - The address of the asset contract.\n   * @param asset.tokenId - The ID of the asset.\n   * @param type - The asset type.\n   * @param origin - Domain origin to register the asset from.\n   * @param options - Options bag.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The address of the account where the NFT is being added.\n   * @returns Object containing a Promise resolving to the suggestedAsset address if accepted.\n   */\n  async watchNft(\n    asset: NftAsset,\n    type: NFTStandardType,\n    origin: string,\n    {\n      networkClientId,\n      userAddress = this.config.selectedAddress,\n    }: {\n      networkClientId?: NetworkClientId;\n      userAddress?: string;\n    } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    await this.validateWatchNft(asset, type, userAddress);\n\n    const nftMetadata = await this.getNftInformation(\n      asset.address,\n      asset.tokenId,\n      networkClientId,\n    );\n\n    if (nftMetadata.standard && nftMetadata.standard !== type) {\n      throw rpcErrors.invalidInput(\n        `Suggested NFT of type ${nftMetadata.standard} does not match received type ${type}`,\n      );\n    }\n\n    const suggestedNftMeta: SuggestedNftMeta = {\n      asset: { ...asset, ...nftMetadata },\n      type,\n      id: random(),\n      time: Date.now(),\n      interactingAddress: userAddress,\n      origin,\n    };\n    await this._requestApproval(suggestedNftMeta);\n    const { address, tokenId } = asset;\n    const { name, standard, description, image } = nftMetadata;\n\n    await this.addNft(address, tokenId, {\n      nftMetadata: {\n        name: name ?? null,\n        description: description ?? null,\n        image: image ?? null,\n        standard: standard ?? null,\n      },\n      userAddress,\n      source: Source.Dapp,\n      networkClientId,\n    });\n  }\n\n  /**\n   * Sets an OpenSea API key to retrieve NFT information.\n   *\n   * @param openSeaApiKey - OpenSea API key.\n   */\n  setApiKey(openSeaApiKey: string) {\n    this.openSeaApiKey = openSeaApiKey;\n  }\n\n  /**\n   * Checks the ownership of a ERC-721 or ERC-1155 NFT for a given address.\n   *\n   * @param ownerAddress - User public address.\n   * @param nftAddress - NFT contract address.\n   * @param tokenId - NFT token ID.\n   * @param options - Options bag.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving the NFT ownership.\n   */\n  async isNftOwner(\n    ownerAddress: string,\n    nftAddress: string,\n    tokenId: string,\n    {\n      networkClientId,\n    }: {\n      networkClientId?: NetworkClientId;\n    } = {},\n  ): Promise<boolean> {\n    // Checks the ownership for ERC-721.\n    try {\n      const owner = await this.getERC721OwnerOf(\n        nftAddress,\n        tokenId,\n        networkClientId,\n      );\n      return ownerAddress.toLowerCase() === owner.toLowerCase();\n      // eslint-disable-next-line no-empty\n    } catch {\n      // Ignore ERC-721 contract error\n    }\n\n    // Checks the ownership for ERC-1155.\n    try {\n      const balance = await this.getERC1155BalanceOf(\n        ownerAddress,\n        nftAddress,\n        tokenId,\n        networkClientId,\n      );\n      return !balance.isZero();\n      // eslint-disable-next-line no-empty\n    } catch {\n      // Ignore ERC-1155 contract error\n    }\n\n    throw new Error(\n      `Unable to verify ownership. Possibly because the standard is not supported or the user's currently selected network does not match the chain of the asset in question.`,\n    );\n  }\n\n  /**\n   * Verifies currently selected address owns entered NFT address/tokenId combo and\n   * adds the NFT and respective NFT contract to the stored NFT and NFT contracts lists.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param options - an object of arguments\n   * @param options.userAddress - The address of the current user.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.\n   */\n  async addNftVerifyOwnership(\n    address: string,\n    tokenId: string,\n    {\n      userAddress = this.config.selectedAddress,\n      networkClientId,\n      source,\n    }: {\n      userAddress?: string;\n      networkClientId?: NetworkClientId;\n      source?: Source;\n    } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    if (\n      !(await this.isNftOwner(userAddress, address, tokenId, {\n        networkClientId,\n      }))\n    ) {\n      throw new Error('This NFT is not owned by the user');\n    }\n    await this.addNft(address, tokenId, {\n      networkClientId,\n      userAddress,\n      source,\n    });\n  }\n\n  /**\n   * Adds an NFT and respective NFT contract to the stored NFT and NFT contracts lists.\n   *\n   * @param tokenAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param options - an object of arguments\n   * @param options.nftMetadata - NFT optional metadata.\n   * @param options.userAddress - The address of the current user.\n   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the current NFT list.\n   */\n  async addNft(\n    tokenAddress: string,\n    tokenId: string,\n    {\n      nftMetadata,\n      userAddress = this.config.selectedAddress,\n      source = Source.Custom,\n      networkClientId,\n    }: {\n      nftMetadata?: NftMetadata;\n      userAddress?: string;\n      source?: Source;\n      networkClientId?: NetworkClientId;\n    } = { userAddress: this.config.selectedAddress },\n  ) {\n    tokenAddress = toChecksumHexAddress(tokenAddress);\n\n    const chainId = this.getCorrectChainId({ networkClientId });\n\n    nftMetadata =\n      nftMetadata ||\n      (await this.getNftInformation(tokenAddress, tokenId, networkClientId));\n\n    const newNftContracts = await this.addNftContract({\n      tokenAddress,\n      userAddress,\n      networkClientId,\n      source,\n      nftMetadata,\n    });\n\n    // If NFT contract was not added, do not add individual NFT\n    const nftContract = newNftContracts.find(\n      (contract) =>\n        contract.address.toLowerCase() === tokenAddress.toLowerCase(),\n    );\n\n    // If NFT contract information, add individual NFT\n    if (nftContract) {\n      await this.addIndividualNft(\n        tokenAddress,\n        tokenId,\n        nftMetadata,\n        nftContract,\n        chainId,\n        userAddress,\n        source,\n      );\n    }\n  }\n\n  /**\n   * Refetches NFT metadata and updates the state\n   *\n   * @param options - Options for refetching NFT metadata\n   * @param options.nfts - nfts to update metadata for.\n   * @param options.userAddress - The current user address\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   */\n  async updateNftMetadata({\n    nfts,\n    userAddress = this.config.selectedAddress,\n    networkClientId,\n  }: {\n    nfts: Nft[];\n    userAddress?: string;\n    networkClientId?: NetworkClientId;\n  }) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n\n    const nftsWithChecksumAdr = nfts.map((nft) => {\n      return {\n        ...nft,\n        address: toChecksumHexAddress(nft.address),\n      };\n    });\n    const nftMetadataResults = await Promise.allSettled(\n      nftsWithChecksumAdr.map(async (nft) => {\n        const resMetadata = await this.getNftInformation(\n          nft.address,\n          nft.tokenId,\n          networkClientId,\n        );\n        return {\n          nft,\n          newMetadata: resMetadata,\n        };\n      }),\n    );\n    const successfulNewFetchedNfts = nftMetadataResults.filter(\n      (result): result is PromiseFulfilledResult<NftUpdate> =>\n        result.status === 'fulfilled',\n    );\n    // We want to avoid updating the state if the state and fetched nft info are the same\n    const nftsWithDifferentMetadata: PromiseFulfilledResult<NftUpdate>[] = [];\n    const { allNfts } = this.state;\n    const stateNfts = allNfts[userAddress]?.[chainId] || [];\n\n    successfulNewFetchedNfts.forEach((singleNft) => {\n      const existingEntry: Nft | undefined = stateNfts.find(\n        (nft) =>\n          nft.address.toLowerCase() ===\n            singleNft.value.nft.address.toLowerCase() &&\n          nft.tokenId === singleNft.value.nft.tokenId,\n      );\n\n      if (existingEntry) {\n        const differentMetadata = compareNftMetadata(\n          singleNft.value.newMetadata,\n          existingEntry,\n        );\n\n        if (differentMetadata) {\n          nftsWithDifferentMetadata.push(singleNft);\n        }\n      }\n    });\n\n    if (nftsWithDifferentMetadata.length !== 0) {\n      nftsWithDifferentMetadata.forEach((elm) =>\n        this.updateNft(\n          elm.value.nft,\n          elm.value.newMetadata,\n          userAddress,\n          chainId,\n        ),\n      );\n    }\n  }\n\n  /**\n   * Removes an NFT from the stored token list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   * @param options - an object of arguments\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   */\n  removeNft(\n    address: string,\n    tokenId: string,\n    {\n      networkClientId,\n      userAddress = this.config.selectedAddress,\n    }: { networkClientId?: NetworkClientId; userAddress?: string } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n    address = toChecksumHexAddress(address);\n    this.removeIndividualNft(address, tokenId, { chainId, userAddress });\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const remainingNft = nfts.find(\n      (nft) => nft.address.toLowerCase() === address.toLowerCase(),\n    );\n\n    if (!remainingNft) {\n      this.removeNftContract(address, { chainId, userAddress });\n    }\n  }\n\n  /**\n   * Removes an NFT from the stored token list and saves it in ignored NFTs list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   * @param options - an object of arguments\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   */\n  removeAndIgnoreNft(\n    address: string,\n    tokenId: string,\n    {\n      networkClientId,\n      userAddress = this.config.selectedAddress,\n    }: { networkClientId?: NetworkClientId; userAddress?: string } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n    address = toChecksumHexAddress(address);\n    this.removeAndIgnoreIndividualNft(address, tokenId, {\n      chainId,\n      userAddress,\n    });\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const remainingNft = nfts.find(\n      (nft) => nft.address.toLowerCase() === address.toLowerCase(),\n    );\n    if (!remainingNft) {\n      this.removeNftContract(address, { chainId, userAddress });\n    }\n  }\n\n  /**\n   * Removes all NFTs from the ignored list.\n   */\n  clearIgnoredNfts() {\n    this.update({ ignoredNfts: [] });\n  }\n\n  /**\n   * Checks whether input NFT is still owned by the user\n   * And updates the isCurrentlyOwned value on the NFT object accordingly.\n   *\n   * @param nft - The NFT object to check and update.\n   * @param batch - A boolean indicating whether this method is being called as part of a batch or single update.\n   * @param accountParams - The userAddress and chainId to check ownership against\n   * @param accountParams.userAddress - the address passed through the confirmed transaction flow to ensure assets are stored to the correct account\n   * @param accountParams.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns the NFT with the updated isCurrentlyOwned value\n   */\n  async checkAndUpdateSingleNftOwnershipStatus(\n    nft: Nft,\n    batch: boolean,\n    {\n      userAddress = this.config.selectedAddress,\n      networkClientId,\n    }: { networkClientId?: NetworkClientId; userAddress?: string } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n    const { address, tokenId } = nft;\n    let isOwned = nft.isCurrentlyOwned;\n    try {\n      isOwned = await this.isNftOwner(userAddress, address, tokenId, {\n        networkClientId,\n      });\n    } catch {\n      // ignore error\n      // this will only throw an error 'Unable to verify ownership' in which case\n      // we want to keep the current value of isCurrentlyOwned for this flow.\n    }\n\n    nft.isCurrentlyOwned = isOwned;\n\n    if (batch) {\n      return nft;\n    }\n\n    // if this is not part of a batched update we update this one NFT in state\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const nftToUpdate = nfts.find(\n      (item) =>\n        item.tokenId === tokenId &&\n        item.address.toLowerCase() === address.toLowerCase(),\n    );\n    if (nftToUpdate) {\n      nftToUpdate.isCurrentlyOwned = isOwned;\n      this.updateNestedNftState(nfts, ALL_NFTS_STATE_KEY, {\n        userAddress,\n        chainId,\n      });\n    }\n    return nft;\n  }\n\n  /**\n   * Checks whether NFTs associated with current selectedAddress/chainId combination are still owned by the user\n   * And updates the isCurrentlyOwned value on each accordingly.\n   * @param options - an object of arguments\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The address of the account where the NFT ownership status is checked/updated.\n   */\n  async checkAndUpdateAllNftsOwnershipStatus(\n    {\n      networkClientId,\n      userAddress = this.config.selectedAddress,\n    }: { networkClientId?: NetworkClientId; userAddress?: string } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const updatedNfts = await Promise.all(\n      nfts.map(async (nft) => {\n        return (\n          (await this.checkAndUpdateSingleNftOwnershipStatus(nft, true, {\n            networkClientId,\n            userAddress,\n          })) ?? nft\n        );\n      }),\n    );\n\n    this.updateNestedNftState(updatedNfts, ALL_NFTS_STATE_KEY, {\n      userAddress,\n      chainId,\n    });\n  }\n\n  /**\n   * Update NFT favorite status.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Hex address of the NFT contract.\n   * @param favorite - NFT new favorite status.\n   * @param options - an object of arguments\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   */\n  updateNftFavoriteStatus(\n    address: string,\n    tokenId: string,\n    favorite: boolean,\n    {\n      networkClientId,\n      userAddress = this.config.selectedAddress,\n    }: {\n      networkClientId?: NetworkClientId;\n      userAddress?: string;\n    } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const index: number = nfts.findIndex(\n      (nft) => nft.address === address && nft.tokenId === tokenId,\n    );\n\n    if (index === -1) {\n      return;\n    }\n\n    const updatedNft: Nft = {\n      ...nfts[index],\n      favorite,\n    };\n\n    // Update Nfts array\n    nfts[index] = updatedNft;\n\n    this.updateNestedNftState(nfts, ALL_NFTS_STATE_KEY, {\n      chainId,\n      userAddress,\n    });\n  }\n\n  /**\n   * Returns an NFT by the address and token id.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Number that represents the id of the token.\n   * @param selectedAddress - Hex address of the user account.\n   * @param chainId - Id of the current network.\n   * @returns Object containing the NFT and its position in the array\n   */\n  findNftByAddressAndTokenId(\n    address: string,\n    tokenId: string,\n    selectedAddress: string,\n    chainId: Hex,\n  ): { nft: Nft; index: number } | null {\n    const { allNfts } = this.state;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const index: number = nfts.findIndex(\n      (nft) =>\n        nft.address.toLowerCase() === address.toLowerCase() &&\n        nft.tokenId === tokenId,\n    );\n\n    if (index === -1) {\n      return null;\n    }\n\n    return { nft: nfts[index], index };\n  }\n\n  /**\n   * Update NFT data.\n   *\n   * @param nft - NFT object to find the right NFT to updates.\n   * @param updates - NFT partial object to update properties of the NFT.\n   * @param selectedAddress - Hex address of the user account.\n   * @param chainId - Id of the current network.\n   */\n  updateNft(\n    nft: Nft,\n    updates: Partial<Nft>,\n    selectedAddress: string,\n    chainId: Hex,\n  ) {\n    const { allNfts } = this.state;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const nftInfo = this.findNftByAddressAndTokenId(\n      nft.address,\n      nft.tokenId,\n      selectedAddress,\n      chainId,\n    );\n\n    if (!nftInfo) {\n      return;\n    }\n\n    const updatedNft: Nft = {\n      ...nft,\n      ...updates,\n    };\n\n    const newNfts = [\n      ...nfts.slice(0, nftInfo.index),\n      updatedNft,\n      ...nfts.slice(nftInfo.index + 1),\n    ];\n\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n      chainId,\n      userAddress: selectedAddress,\n    });\n  }\n\n  /**\n   * Resets the transaction status of an NFT.\n   *\n   * @param transactionId - NFT transaction id.\n   * @param selectedAddress - Hex address of the user account.\n   * @param chainId - Id of the current network.\n   * @returns a boolean indicating if the reset was well succeeded or not\n   */\n  resetNftTransactionStatusByTransactionId(\n    transactionId: string,\n    selectedAddress: string,\n    chainId: Hex,\n  ): boolean {\n    const { allNfts } = this.state;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const index: number = nfts.findIndex(\n      (nft) => nft.transactionId === transactionId,\n    );\n\n    if (index === -1) {\n      return false;\n    }\n    const updatedNft: Nft = {\n      ...nfts[index],\n      transactionId: undefined,\n    };\n\n    const newNfts = [\n      ...nfts.slice(0, index),\n      updatedNft,\n      ...nfts.slice(index + 1),\n    ];\n\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n      chainId,\n      userAddress: selectedAddress,\n    });\n\n    return true;\n  }\n\n  async _requestApproval(suggestedNftMeta: SuggestedNftMeta) {\n    return this.messagingSystem.call(\n      'ApprovalController:addRequest',\n      {\n        id: suggestedNftMeta.id,\n        origin: suggestedNftMeta.origin,\n        type: ApprovalType.WatchAsset,\n        requestData: {\n          id: suggestedNftMeta.id,\n          interactingAddress: suggestedNftMeta.interactingAddress,\n          asset: {\n            address: suggestedNftMeta.asset.address,\n            tokenId: suggestedNftMeta.asset.tokenId,\n            name: suggestedNftMeta.asset.name,\n            description: suggestedNftMeta.asset.description,\n            image: suggestedNftMeta.asset.image,\n            standard: suggestedNftMeta.asset.standard,\n          },\n        },\n      },\n      true,\n    );\n  }\n}\n\nexport default NftController;"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/NftDetectionController.d.ts b/node_modules/@metamask/assets-controllers/dist/NftDetectionController.d.ts
index 208891e..32bc54c 100644
--- a/node_modules/@metamask/assets-controllers/dist/NftDetectionController.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/NftDetectionController.d.ts
@@ -1,9 +1,9 @@
-import type { BaseConfig, BaseState } from '@metamask/base-controller';
-import type { NetworkClientId, NetworkController, NetworkState, NetworkClient } from '@metamask/network-controller';
-import { PollingControllerV1 } from '@metamask/polling-controller';
-import type { PreferencesState } from '@metamask/preferences-controller';
 import type { Hex } from '@metamask/utils';
+import { BaseController, BaseConfig, BaseState } from '@metamask/base-controller';
+import type { NetworkState, NetworkClientId } from '@metamask/network-controller';
+import type { PreferencesState } from '@metamask/preferences-controller';
 import type { NftController, NftState } from './NftController';
+import { Source } from './constants';
 /**
  * @type ApiNft
  *
@@ -67,6 +67,7 @@ export interface ApiNftContract {
     collection: {
         name: string | null;
         image_url?: string | null;
+        tokenCount?: string | null;
     };
 }
 /**
@@ -113,10 +114,192 @@ export interface NftDetectionConfig extends BaseConfig {
     chainId: Hex;
     selectedAddress: string;
 }
+export declare type ReservoirResponse = {
+    tokens: TokensResponse[];
+    continuation?: string;
+};
+export declare type TokensResponse = {
+    token: TokenResponse;
+    ownership: Ownership;
+    market?: Market;
+    blockaidResult?: Blockaid;
+};
+export declare enum BlockaidResultType {
+    Benign = "Benign",
+    Spam = "Spam",
+    Warning = "Warning",
+    Malicious = "Malicious"
+}
+export declare type Blockaid = {
+    contract: string;
+    chainId: number;
+    result_type: BlockaidResultType;
+    malicious_score: string;
+    attack_types: object;
+};
+export declare type Market = {
+    floorAsk?: FloorAsk;
+    topBid?: TopBid;
+};
+export declare type TokenResponse = {
+    chainId: number;
+    contract: string;
+    tokenId: string;
+    kind?: string;
+    name?: string;
+    image?: string;
+    imageSmall?: string;
+    imageLarge?: string;
+    metadata?: Metadata;
+    description?: string;
+    supply?: number;
+    remainingSupply?: number;
+    rarityScore?: number;
+    rarity?: number;
+    rarityRank?: number;
+    media?: string;
+    isFlagged?: boolean;
+    isSpam?: boolean;
+    isNsfw?: boolean;
+    metadataDisabled?: boolean;
+    lastFlagUpdate?: string;
+    lastFlagChange?: string;
+    collection?: Collection;
+    lastSale?: LastSale;
+    topBid?: TopBid;
+    lastAppraisalValue?: number;
+    attributes?: Attributes[];
+};
+export declare type TopBid = {
+    id?: string;
+    price?: Price;
+    source?: {
+        id?: string;
+        domain?: string;
+        name?: string;
+        icon?: string;
+        url?: string;
+    };
+};
+export declare type LastSale = {
+    saleId?: string;
+    token?: {
+        contract?: string;
+        tokenId?: string;
+        name?: string;
+        image?: string;
+        collection?: {
+            id?: string;
+            name?: string;
+        };
+    };
+    orderSource?: string;
+    orderSide?: 'ask' | 'bid';
+    orderKind?: string;
+    orderId?: string;
+    from?: string;
+    to?: string;
+    amount?: string;
+    fillSource?: string;
+    block?: number;
+    txHash?: string;
+    logIndex?: number;
+    batchIndex?: number;
+    timestamp?: number;
+    price?: Price;
+    washTradingScore?: number;
+    royaltyFeeBps?: number;
+    marketplaceFeeBps?: number;
+    paidFullRoyalty?: boolean;
+    feeBreakdown?: FeeBreakdown[];
+    isDeleted?: boolean;
+    createdAt?: string;
+    updatedAt?: string;
+};
+export declare type FeeBreakdown = {
+    kind?: string;
+    bps?: number;
+    recipient?: string;
+    source?: string;
+    rawAmount?: string;
+};
+export declare type Attributes = {
+    key?: string;
+    kind?: string;
+    value: string;
+    tokenCount?: number;
+    onSaleCount?: number;
+    floorAskPrice?: Price | null;
+    topBidValue?: number | null;
+    createdAt?: string;
+};
+export declare type Collection = {
+    id?: string;
+    name?: string;
+    slug?: string;
+    symbol?: string;
+    imageUrl?: string;
+    image?: string;
+    isSpam?: boolean;
+    isNsfw?: boolean;
+    creator?: string;
+    tokenCount?: string;
+    metadataDisabled?: boolean;
+    openseaVerificationStatus?: string;
+    floorAskPrice?: Price;
+    royaltiesBps?: number;
+    royalties?: Royalties[];
+};
+export declare type Royalties = {
+    bps?: number;
+    recipient?: string;
+};
+export declare type Ownership = {
+    tokenCount?: string;
+    onSaleCount?: string;
+    floorAsk?: FloorAsk;
+    acquiredAt?: string;
+};
+export declare type FloorAsk = {
+    id?: string;
+    price?: Price;
+    maker?: string;
+    kind?: string;
+    validFrom?: number;
+    validUntil?: number;
+    source?: Source;
+    rawData?: Metadata;
+    isNativeOffChainCancellable?: boolean;
+};
+export declare type Price = {
+    currency?: {
+        contract?: string;
+        name?: string;
+        symbol?: string;
+        decimals?: number;
+        chainId?: number;
+    };
+    amount?: {
+        raw?: string;
+        decimal?: number;
+        usd?: number;
+        native?: number;
+    };
+    netAmount?: {
+        raw?: string;
+        decimal?: number;
+        usd?: number;
+        native?: number;
+    };
+};
+export declare type Metadata = {
+    imageOriginal?: string;
+    tokenURI?: string;
+};
 /**
  * Controller that passively polls on a set interval for NFT auto detection
  */
-export declare class NftDetectionController extends PollingControllerV1<NftDetectionConfig, BaseState> {
+export declare class NftDetectionController extends BaseController<NftDetectionConfig, BaseState> {
     private intervalId?;
     private getOwnerNftApi;
     private getOwnerNfts;
@@ -124,10 +307,10 @@ export declare class NftDetectionController extends PollingControllerV1<NftDetec
      * Name of this controller used during composition
      */
     name: string;
-    private readonly getOpenSeaApiKey;
-    private readonly addNft;
-    private readonly getNftState;
-    private readonly getNetworkClientById;
+    private getOpenSeaApiKey;
+    private addNft;
+    private getNftApi;
+    private getNftState;
     /**
      * Creates an NftDetectionController instance.
      *
@@ -138,24 +321,21 @@ export declare class NftDetectionController extends PollingControllerV1<NftDetec
      * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.
      * @param options.getOpenSeaApiKey - Gets the OpenSea API key, if one is set.
      * @param options.addNft - Add an NFT.
+     * @param options.getNftApi - Gets the URL to fetch an NFT from OpenSea.
      * @param options.getNftState - Gets the current state of the Assets controller.
-     * @param options.getNetworkClientById - Gets the network client by ID, from the NetworkController.
      * @param config - Initial options used to configure this controller.
      * @param state - Initial state to set on this controller.
      */
-    constructor({ chainId: initialChainId, getNetworkClientById, onPreferencesStateChange, onNetworkStateChange, getOpenSeaApiKey, addNft, getNftState, }: {
+    constructor({ chainId: initialChainId, onPreferencesStateChange, onNetworkStateChange, getOpenSeaApiKey, addNft, getNftApi, getNftState, }: {
         chainId: Hex;
-        getNetworkClientById: NetworkController['getNetworkClientById'];
         onNftsStateChange: (listener: (nftsState: NftState) => void) => void;
         onPreferencesStateChange: (listener: (preferencesState: PreferencesState) => void) => void;
         onNetworkStateChange: (listener: (networkState: NetworkState) => void) => void;
         getOpenSeaApiKey: () => string | undefined;
         addNft: NftController['addNft'];
+        getNftApi: NftController['getNftApi'];
         getNftState: () => NftState;
     }, config?: Partial<NftDetectionConfig>, state?: Partial<BaseState>);
-    _executePoll(networkClientId: string, options: {
-        address: string;
-    }): Promise<void>;
     /**
      * Start polling for the currency rate.
      */
@@ -177,16 +357,17 @@ export declare class NftDetectionController extends PollingControllerV1<NftDetec
      * @returns Whether current network is mainnet.
      */
     isMainnet: () => boolean;
-    isMainnetByNetworkClientId: (networkClient: NetworkClient) => boolean;
-    private getCorrectChainId;
     /**
      * Triggers asset ERC721 token auto detection on mainnet. Any newly detected NFTs are
      * added.
-     *
-     * @param networkClientId - The network client ID to detect NFTs on.
-     * @param accountAddress - The address to detect NFTs for.
+     * @param options - Options bag.
+     * @param options.networkClientId - The network client ID to detect NFTs on.
+     * @param options.userAddress - The address to detect NFTs for.
      */
-    detectNfts(networkClientId?: NetworkClientId, accountAddress?: string): Promise<void>;
+    detectNfts({ networkClientId, userAddress, }?: {
+        networkClientId?: NetworkClientId;
+        userAddress: string;
+    }): Promise<void>;
 }
 export default NftDetectionController;
 //# sourceMappingURL=NftDetectionController.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/NftDetectionController.d.ts.map b/node_modules/@metamask/assets-controllers/dist/NftDetectionController.d.ts.map
index 24eb3c3..40ea927 100644
--- a/node_modules/@metamask/assets-controllers/dist/NftDetectionController.d.ts.map
+++ b/node_modules/@metamask/assets-controllers/dist/NftDetectionController.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"NftDetectionController.d.ts","sourceRoot":"","sources":["../src/NftDetectionController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"NftDetectionController.d.ts","sourceRoot":"","sources":["../src/NftDetectionController.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,GAAG,EAAE,MAAM,iBAAiB,CAAC;AAC3C,OAAO,EACL,cAAc,EACd,UAAU,EACV,SAAS,EACV,MAAM,2BAA2B,CAAC;AACnC,OAAO,KAAK,EACV,YAAY,EACZ,eAAe,EAChB,MAAM,8BAA8B,CAAC;AACtC,OAAO,KAAK,EAAE,gBAAgB,EAAE,MAAM,kCAAkC,CAAC;AAOzE,OAAO,KAAK,EAAE,aAAa,EAAE,QAAQ,EAAe,MAAM,iBAAiB,CAAC;AAC5E,OAAO,EAAE,MAAM,EAAE,MAAM,aAAa,CAAC;AAIrC;;;;;;;;;;;;;;;;;;;GAmBG;AACH,MAAM,WAAW,MAAM;IACrB,QAAQ,EAAE,MAAM,CAAC;IACjB,SAAS,EAAE,MAAM,GAAG,IAAI,CAAC;IACzB,gBAAgB,EAAE,MAAM,GAAG,IAAI,CAAC;IAChC,SAAS,EAAE,MAAM,GAAG,IAAI,CAAC;IACzB,iBAAiB,EAAE,MAAM,GAAG,IAAI,CAAC;IACjC,mBAAmB,EAAE,MAAM,GAAG,IAAI,CAAC;IACnC,kBAAkB,EAAE,MAAM,GAAG,IAAI,CAAC;IAClC,aAAa,EAAE,MAAM,GAAG,IAAI,CAAC;IAC7B,sBAAsB,EAAE,MAAM,GAAG,IAAI,CAAC;IACtC,IAAI,EAAE,MAAM,GAAG,IAAI,CAAC;IACpB,WAAW,EAAE,MAAM,GAAG,IAAI,CAAC;IAC3B,aAAa,EAAE,MAAM,GAAG,IAAI,CAAC;IAC7B,cAAc,EAAE,cAAc,CAAC;IAC/B,OAAO,EAAE,aAAa,CAAC;IACvB,SAAS,EAAE,cAAc,GAAG,IAAI,CAAC;CAClC;AAED;;;;;;;;;;;;;GAaG;AACH,MAAM,WAAW,cAAc;IAC7B,OAAO,EAAE,MAAM,CAAC;IAChB,mBAAmB,EAAE,MAAM,GAAG,IAAI,CAAC;IACnC,YAAY,EAAE,MAAM,GAAG,IAAI,CAAC;IAC5B,WAAW,EAAE,MAAM,GAAG,IAAI,CAAC;IAC3B,MAAM,EAAE,MAAM,GAAG,IAAI,CAAC;IACtB,YAAY,EAAE,MAAM,GAAG,IAAI,CAAC;IAC5B,WAAW,EAAE,MAAM,GAAG,IAAI,CAAC;IAC3B,aAAa,EAAE,MAAM,GAAG,IAAI,CAAC;IAC7B,UAAU,EAAE;QACV,IAAI,EAAE,MAAM,GAAG,IAAI,CAAC;QACpB,SAAS,CAAC,EAAE,MAAM,GAAG,IAAI,CAAC;QAC1B,UAAU,CAAC,EAAE,MAAM,GAAG,IAAI,CAAC;KAC5B,CAAC;CACH;AAED;;;;;;;GAOG;AACH,MAAM,WAAW,cAAc;IAC7B,eAAe,EAAE,MAAM,CAAC;IACxB,WAAW,EAAE,MAAM,CAAC;IACpB,WAAW,EAAE;QAAE,gBAAgB,EAAE,MAAM,CAAC;QAAC,UAAU,EAAE,MAAM,CAAA;KAAE,CAAC;CAC/D;AAED;;;;;;;GAOG;AACH,MAAM,WAAW,aAAa;IAC5B,IAAI,EAAE;QAAE,QAAQ,EAAE,MAAM,CAAA;KAAE,CAAC;IAC3B,eAAe,EAAE,MAAM,CAAC;IACxB,OAAO,EAAE,MAAM,CAAC;CACjB;AAED;;;;;;;GAOG;AACH,MAAM,WAAW,kBAAmB,SAAQ,UAAU;IACpD,QAAQ,EAAE,MAAM,CAAC;IACjB,OAAO,EAAE,GAAG,CAAC;IACb,eAAe,EAAE,MAAM,CAAC;CACzB;AAED,oBAAY,iBAAiB,GAAG;IAC9B,MAAM,EAAE,cAAc,EAAE,CAAC;IACzB,YAAY,CAAC,EAAE,MAAM,CAAC;CACvB,CAAC;AAEF,oBAAY,cAAc,GAAG;IAC3B,KAAK,EAAE,aAAa,CAAC;IACrB,SAAS,EAAE,SAAS,CAAC;IACrB,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,cAAc,CAAC,EAAE,QAAQ,CAAC;CAC3B,CAAC;AAEF,oBAAY,kBAAkB;IAC5B,MAAM,WAAW;IACjB,IAAI,SAAS;IACb,OAAO,YAAY;IACnB,SAAS,cAAc;CACxB;AAED,oBAAY,QAAQ,GAAG;IACrB,QAAQ,EAAE,MAAM,CAAC;IACjB,OAAO,EAAE,MAAM,CAAC;IAChB,WAAW,EAAE,kBAAkB,CAAC;IAChC,eAAe,EAAE,MAAM,CAAC;IACxB,YAAY,EAAE,MAAM,CAAC;CACtB,CAAC;AAEF,oBAAY,MAAM,GAAG;IACnB,QAAQ,CAAC,EAAE,QAAQ,CAAC;IACpB,MAAM,CAAC,EAAE,MAAM,CAAC;CACjB,CAAC;AAEF,oBAAY,aAAa,GAAG;IAC1B,OAAO,EAAE,MAAM,CAAC;IAChB,QAAQ,EAAE,MAAM,CAAC;IACjB,OAAO,EAAE,MAAM,CAAC;IAChB,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,QAAQ,CAAC,EAAE,QAAQ,CAAC;IACpB,WAAW,CAAC,EAAE,MAAM,CAAC;IACrB,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,eAAe,CAAC,EAAE,MAAM,CAAC;IACzB,WAAW,CAAC,EAAE,MAAM,CAAC;IACrB,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,SAAS,CAAC,EAAE,OAAO,CAAC;IACpB,MAAM,CAAC,EAAE,OAAO,CAAC;IACjB,MAAM,CAAC,EAAE,OAAO,CAAC;IACjB,gBAAgB,CAAC,EAAE,OAAO,CAAC;IAC3B,cAAc,CAAC,EAAE,MAAM,CAAC;IACxB,cAAc,CAAC,EAAE,MAAM,CAAC;IACxB,UAAU,CAAC,EAAE,UAAU,CAAC;IACxB,QAAQ,CAAC,EAAE,QAAQ,CAAC;IACpB,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,kBAAkB,CAAC,EAAE,MAAM,CAAC;IAC5B,UAAU,CAAC,EAAE,UAAU,EAAE,CAAC;CAC3B,CAAC;AAEF,oBAAY,MAAM,GAAG;IACnB,EAAE,CAAC,EAAE,MAAM,CAAC;IACZ,KAAK,CAAC,EAAE,KAAK,CAAC;IACd,MAAM,CAAC,EAAE;QACP,EAAE,CAAC,EAAE,MAAM,CAAC;QACZ,MAAM,CAAC,EAAE,MAAM,CAAC;QAChB,IAAI,CAAC,EAAE,MAAM,CAAC;QACd,IAAI,CAAC,EAAE,MAAM,CAAC;QACd,GAAG,CAAC,EAAE,MAAM,CAAC;KACd,CAAC;CACH,CAAC;AAEF,oBAAY,QAAQ,GAAG;IACrB,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,KAAK,CAAC,EAAE;QACN,QAAQ,CAAC,EAAE,MAAM,CAAC;QAClB,OAAO,CAAC,EAAE,MAAM,CAAC;QACjB,IAAI,CAAC,EAAE,MAAM,CAAC;QACd,KAAK,CAAC,EAAE,MAAM,CAAC;QACf,UAAU,CAAC,EAAE;YACX,EAAE,CAAC,EAAE,MAAM,CAAC;YACZ,IAAI,CAAC,EAAE,MAAM,CAAC;SACf,CAAC;KACH,CAAC;IACF,WAAW,CAAC,EAAE,MAAM,CAAC;IACrB,SAAS,CAAC,EAAE,KAAK,GAAG,KAAK,CAAC;IAC1B,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,EAAE,CAAC,EAAE,MAAM,CAAC;IACZ,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,KAAK,CAAC,EAAE,KAAK,CAAC;IACd,gBAAgB,CAAC,EAAE,MAAM,CAAC;IAC1B,aAAa,CAAC,EAAE,MAAM,CAAC;IACvB,iBAAiB,CAAC,EAAE,MAAM,CAAC;IAC3B,eAAe,CAAC,EAAE,OAAO,CAAC;IAC1B,YAAY,CAAC,EAAE,YAAY,EAAE,CAAC;IAC9B,SAAS,CAAC,EAAE,OAAO,CAAC;IACpB,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,SAAS,CAAC,EAAE,MAAM,CAAC;CACpB,CAAC;AAEF,oBAAY,YAAY,GAAG;IACzB,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,GAAG,CAAC,EAAE,MAAM,CAAC;IACb,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,SAAS,CAAC,EAAE,MAAM,CAAC;CACpB,CAAC;AAEF,oBAAY,UAAU,GAAG;IACvB,GAAG,CAAC,EAAE,MAAM,CAAC;IACb,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,KAAK,EAAE,MAAM,CAAC;IACd,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,WAAW,CAAC,EAAE,MAAM,CAAC;IACrB,aAAa,CAAC,EAAE,KAAK,GAAG,IAAI,CAAC;IAC7B,WAAW,CAAC,EAAE,MAAM,GAAG,IAAI,CAAC;IAC5B,SAAS,CAAC,EAAE,MAAM,CAAC;CACpB,CAAC;AAEF,oBAAY,UAAU,GAAG;IACvB,EAAE,CAAC,EAAE,MAAM,CAAC;IACZ,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,MAAM,CAAC,EAAE,OAAO,CAAC;IACjB,MAAM,CAAC,EAAE,OAAO,CAAC;IACjB,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,gBAAgB,CAAC,EAAE,OAAO,CAAC;IAC3B,yBAAyB,CAAC,EAAE,MAAM,CAAC;IACnC,aAAa,CAAC,EAAE,KAAK,CAAC;IACtB,YAAY,CAAC,EAAE,MAAM,CAAC;IACtB,SAAS,CAAC,EAAE,SAAS,EAAE,CAAC;CACzB,CAAC;AAEF,oBAAY,SAAS,GAAG;IACtB,GAAG,CAAC,EAAE,MAAM,CAAC;IACb,SAAS,CAAC,EAAE,MAAM,CAAC;CACpB,CAAC;AAEF,oBAAY,SAAS,GAAG;IACtB,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,WAAW,CAAC,EAAE,MAAM,CAAC;IACrB,QAAQ,CAAC,EAAE,QAAQ,CAAC;IACpB,UAAU,CAAC,EAAE,MAAM,CAAC;CACrB,CAAC;AAEF,oBAAY,QAAQ,GAAG;IACrB,EAAE,CAAC,EAAE,MAAM,CAAC;IACZ,KAAK,CAAC,EAAE,KAAK,CAAC;IACd,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,OAAO,CAAC,EAAE,QAAQ,CAAC;IACnB,2BAA2B,CAAC,EAAE,OAAO,CAAC;CACvC,CAAC;AAEF,oBAAY,KAAK,GAAG;IAClB,QAAQ,CAAC,EAAE;QACT,QAAQ,CAAC,EAAE,MAAM,CAAC;QAClB,IAAI,CAAC,EAAE,MAAM,CAAC;QACd,MAAM,CAAC,EAAE,MAAM,CAAC;QAChB,QAAQ,CAAC,EAAE,MAAM,CAAC;QAClB,OAAO,CAAC,EAAE,MAAM,CAAC;KAClB,CAAC;IACF,MAAM,CAAC,EAAE;QACP,GAAG,CAAC,EAAE,MAAM,CAAC;QACb,OAAO,CAAC,EAAE,MAAM,CAAC;QACjB,GAAG,CAAC,EAAE,MAAM,CAAC;QACb,MAAM,CAAC,EAAE,MAAM,CAAC;KACjB,CAAC;IACF,SAAS,CAAC,EAAE;QACV,GAAG,CAAC,EAAE,MAAM,CAAC;QACb,OAAO,CAAC,EAAE,MAAM,CAAC;QACjB,GAAG,CAAC,EAAE,MAAM,CAAC;QACb,MAAM,CAAC,EAAE,MAAM,CAAC;KACjB,CAAC;CACH,CAAC;AAEF,oBAAY,QAAQ,GAAG;IACrB,aAAa,CAAC,EAAE,MAAM,CAAC;IACvB,QAAQ,CAAC,EAAE,MAAM,CAAC;CACnB,CAAC;AAEF;;GAEG;AACH,qBAAa,sBAAuB,SAAQ,cAAc,CACxD,kBAAkB,EAClB,SAAS,CACV;IACC,OAAO,CAAC,UAAU,CAAC,CAAgC;IAEnD,OAAO,CAAC,cAAc;YAYR,YAAY;IAgC1B;;OAEG;IACM,IAAI,SAA4B;IAEzC,OAAO,CAAC,gBAAgB,CAA2B;IAEnD,OAAO,CAAC,MAAM,CAA0B;IAExC,OAAO,CAAC,SAAS,CAA6B;IAE9C,OAAO,CAAC,WAAW,CAAiB;IAEpC;;;;;;;;;;;;;;OAcG;gBAED,EACE,OAAO,EAAE,cAAc,EACvB,wBAAwB,EACxB,oBAAoB,EACpB,gBAAgB,EAChB,MAAM,EACN,SAAS,EACT,WAAW,GACZ,EAAE;QACD,OAAO,EAAE,GAAG,CAAC;QACb,iBAAiB,EAAE,CAAC,QAAQ,EAAE,CAAC,SAAS,EAAE,QAAQ,KAAK,IAAI,KAAK,IAAI,CAAC;QACrE,wBAAwB,EAAE,CACxB,QAAQ,EAAE,CAAC,gBAAgB,EAAE,gBAAgB,KAAK,IAAI,KACnD,IAAI,CAAC;QACV,oBAAoB,EAAE,CACpB,QAAQ,EAAE,CAAC,YAAY,EAAE,YAAY,KAAK,IAAI,KAC3C,IAAI,CAAC;QACV,gBAAgB,EAAE,MAAM,MAAM,GAAG,SAAS,CAAC;QAC3C,MAAM,EAAE,aAAa,CAAC,QAAQ,CAAC,CAAC;QAChC,SAAS,EAAE,aAAa,CAAC,WAAW,CAAC,CAAC;QACtC,WAAW,EAAE,MAAM,QAAQ,CAAC;KAC7B,EACD,MAAM,CAAC,EAAE,OAAO,CAAC,kBAAkB,CAAC,EACpC,KAAK,CAAC,EAAE,OAAO,CAAC,SAAS,CAAC;IAuC5B;;OAEG;IACG,KAAK;IAQX;;OAEG;IACH,IAAI;IAIJ,OAAO,CAAC,WAAW;IAMnB;;;;OAIG;YACW,YAAY;IAS1B;;;;OAIG;IACH,SAAS,QAAO,OAAO,CAA4C;IAEnE;;;;;;OAMG;IACG,UAAU,CACd,EACE,eAAe,EACf,WAAW,GACZ,GAAE;QACD,eAAe,CAAC,EAAE,eAAe,CAAC;QAClC,WAAW,EAAE,MAAM,CAAC;KAC0B;CAyEnD;AAED,eAAe,sBAAsB,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/NftDetectionController.js b/node_modules/@metamask/assets-controllers/dist/NftDetectionController.js
index 81fac79..9b8e2e3 100644
--- a/node_modules/@metamask/assets-controllers/dist/NftDetectionController.js
+++ b/node_modules/@metamask/assets-controllers/dist/NftDetectionController.js
@@ -9,15 +9,22 @@ var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, ge
     });
 };
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.NftDetectionController = void 0;
+exports.NftDetectionController = exports.BlockaidResultType = void 0;
+const base_controller_1 = require("@metamask/base-controller");
 const controller_utils_1 = require("@metamask/controller-utils");
-const polling_controller_1 = require("@metamask/polling-controller");
 const constants_1 = require("./constants");
 const DEFAULT_INTERVAL = 180000;
+var BlockaidResultType;
+(function (BlockaidResultType) {
+    BlockaidResultType["Benign"] = "Benign";
+    BlockaidResultType["Spam"] = "Spam";
+    BlockaidResultType["Warning"] = "Warning";
+    BlockaidResultType["Malicious"] = "Malicious";
+})(BlockaidResultType = exports.BlockaidResultType || (exports.BlockaidResultType = {}));
 /**
  * Controller that passively polls on a set interval for NFT auto detection
  */
-class NftDetectionController extends polling_controller_1.PollingControllerV1 {
+class NftDetectionController extends base_controller_1.BaseController {
     /**
      * Creates an NftDetectionController instance.
      *
@@ -28,12 +35,12 @@ class NftDetectionController extends polling_controller_1.PollingControllerV1 {
      * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.
      * @param options.getOpenSeaApiKey - Gets the OpenSea API key, if one is set.
      * @param options.addNft - Add an NFT.
+     * @param options.getNftApi - Gets the URL to fetch an NFT from OpenSea.
      * @param options.getNftState - Gets the current state of the Assets controller.
-     * @param options.getNetworkClientById - Gets the network client by ID, from the NetworkController.
      * @param config - Initial options used to configure this controller.
      * @param state - Initial state to set on this controller.
      */
-    constructor({ chainId: initialChainId, getNetworkClientById, onPreferencesStateChange, onNetworkStateChange, getOpenSeaApiKey, addNft, getNftState, }, config, state) {
+    constructor({ chainId: initialChainId, onPreferencesStateChange, onNetworkStateChange, getOpenSeaApiKey, addNft, getNftApi, getNftState, }, config, state) {
         super(config, state);
         /**
          * Name of this controller used during composition
@@ -45,9 +52,6 @@ class NftDetectionController extends polling_controller_1.PollingControllerV1 {
          * @returns Whether current network is mainnet.
          */
         this.isMainnet = () => this.config.chainId === controller_utils_1.ChainId.mainnet;
-        this.isMainnetByNetworkClientId = (networkClient) => {
-            return networkClient.configuration.chainId === controller_utils_1.ChainId.mainnet;
-        };
         this.defaultConfig = {
             interval: DEFAULT_INTERVAL,
             chainId: initialChainId,
@@ -56,14 +60,11 @@ class NftDetectionController extends polling_controller_1.PollingControllerV1 {
         };
         this.initialize();
         this.getNftState = getNftState;
-        this.getNetworkClientById = getNetworkClientById;
         onPreferencesStateChange(({ selectedAddress, useNftDetection }) => {
             const { selectedAddress: previouslySelectedAddress, disabled } = this.config;
             if (selectedAddress !== previouslySelectedAddress ||
                 !useNftDetection !== disabled) {
                 this.configure({ selectedAddress, disabled: !useNftDetection });
-            }
-            if (useNftDetection !== undefined) {
                 if (useNftDetection) {
                     this.start();
                 }
@@ -79,40 +80,41 @@ class NftDetectionController extends polling_controller_1.PollingControllerV1 {
         });
         this.getOpenSeaApiKey = getOpenSeaApiKey;
         this.addNft = addNft;
-        this.setIntervalLength(this.config.interval);
+        this.getNftApi = getNftApi;
     }
-    getOwnerNftApi({ address, offset, }) {
-        return `${controller_utils_1.OPENSEA_PROXY_URL}/assets?owner=${address}&offset=${offset}&limit=50`;
+    getOwnerNftApi({ address, next, }) {
+        return `${controller_utils_1.NFT_API_BASE_URL}/users/${address}/tokens?chainIds=1&limit=50&includeTopBid=true&continuation=${next !== null && next !== void 0 ? next : ''}`;
     }
     getOwnerNfts(address) {
-        var _a;
         return __awaiter(this, void 0, void 0, function* () {
             let nftApiResponse;
             let nfts = [];
-            let offset = 0;
-            let pagingFinish = false;
-            /* istanbul ignore if */
+            let next;
             do {
                 nftApiResponse = yield (0, controller_utils_1.fetchWithErrorHandling)({
-                    url: this.getOwnerNftApi({ address, offset }),
+                    url: this.getOwnerNftApi({ address, next }),
+                    options: {
+                        headers: {
+                            Version: '1',
+                        },
+                    },
                     timeout: 15000,
                 });
                 if (!nftApiResponse) {
                     return nfts;
                 }
-                ((_a = nftApiResponse === null || nftApiResponse === void 0 ? void 0 : nftApiResponse.assets) === null || _a === void 0 ? void 0 : _a.length) !== 0
-                    ? (nfts = [...nfts, ...nftApiResponse.assets])
-                    : (pagingFinish = true);
-                offset += 50;
-            } while (!pagingFinish);
+                const newNfts = nftApiResponse.tokens.filter((elm) => {
+                    var _a, _b;
+                    return elm.token.isSpam === false &&
+                        (((_a = elm.blockaidResult) === null || _a === void 0 ? void 0 : _a.result_type)
+                            ? ((_b = elm.blockaidResult) === null || _b === void 0 ? void 0 : _b.result_type) === BlockaidResultType.Benign
+                            : true);
+                });
+                nfts = [...nfts, ...newNfts];
+            } while ((next = nftApiResponse.continuation));
             return nfts;
         });
     }
-    _executePoll(networkClientId, options) {
-        return __awaiter(this, void 0, void 0, function* () {
-            yield this.detectNfts(networkClientId, options.address);
-        });
-    }
     /**
      * Start polling for the currency rate.
      */
@@ -150,55 +152,45 @@ class NftDetectionController extends polling_controller_1.PollingControllerV1 {
             }), this.config.interval);
         });
     }
-    getCorrectChainId(networkClientId) {
-        if (networkClientId) {
-            return this.getNetworkClientById(networkClientId).configuration.chainId;
-        }
-        return this.config.chainId;
-    }
     /**
      * Triggers asset ERC721 token auto detection on mainnet. Any newly detected NFTs are
      * added.
-     *
-     * @param networkClientId - The network client ID to detect NFTs on.
-     * @param accountAddress - The address to detect NFTs for.
+     * @param options - Options bag.
+     * @param options.networkClientId - The network client ID to detect NFTs on.
+     * @param options.userAddress - The address to detect NFTs for.
      */
-    detectNfts(networkClientId, accountAddress) {
+    detectNfts({ networkClientId, userAddress, } = { userAddress: this.config.selectedAddress }) {
         return __awaiter(this, void 0, void 0, function* () {
-            const chainId = this.getCorrectChainId(networkClientId);
-            const selectedAddress = accountAddress || this.config.selectedAddress;
             /* istanbul ignore if */
             if (!this.isMainnet() || this.disabled) {
                 return;
             }
             /* istanbul ignore else */
-            if (!selectedAddress) {
+            if (!userAddress) {
                 return;
             }
-            const apiNfts = yield this.getOwnerNfts(selectedAddress);
+            const apiNfts = yield this.getOwnerNfts(userAddress);
             const addNftPromises = apiNfts.map((nft) => __awaiter(this, void 0, void 0, function* () {
-                const { token_id, num_sales, background_color, image_url, image_preview_url, image_thumbnail_url, image_original_url, animation_url, animation_original_url, name, description, external_link, creator, asset_contract: { address, schema_name }, last_sale, } = nft;
+                const { tokenId: token_id, contract, kind, image: image_url, imageSmall: image_thumbnail_url, metadata: { imageOriginal: image_original_url } = {}, name, description, attributes, topBid, lastSale, rarityRank, rarityScore, collection, } = nft.token;
                 let ignored;
                 /* istanbul ignore else */
                 const { ignoredNfts } = this.getNftState();
                 if (ignoredNfts.length) {
                     ignored = ignoredNfts.find((c) => {
                         /* istanbul ignore next */
-                        return (c.address === (0, controller_utils_1.toChecksumHexAddress)(address) &&
+                        return (c.address === (0, controller_utils_1.toChecksumHexAddress)(contract) &&
                             c.tokenId === token_id);
                     });
                 }
                 /* istanbul ignore else */
                 if (!ignored) {
                     /* istanbul ignore next */
-                    const nftMetadata = Object.assign({}, { name }, creator && { creator }, description && { description }, image_url && { image: image_url }, num_sales && { numberOfSales: num_sales }, background_color && { backgroundColor: background_color }, image_preview_url && { imagePreview: image_preview_url }, image_thumbnail_url && { imageThumbnail: image_thumbnail_url }, image_original_url && { imageOriginal: image_original_url }, animation_url && { animation: animation_url }, animation_original_url && {
-                        animationOriginal: animation_original_url,
-                    }, schema_name && { standard: schema_name }, external_link && { externalLink: external_link }, last_sale && { lastSale: last_sale });
-                    yield this.addNft(address, token_id, {
+                    const nftMetadata = Object.assign({}, { name }, description && { description }, image_url && { image: image_url }, image_thumbnail_url && { imageThumbnail: image_thumbnail_url }, image_original_url && { imageOriginal: image_original_url }, kind && { standard: kind.toUpperCase() }, lastSale && { lastSale }, attributes && { attributes }, topBid && { topBid }, rarityRank && { rarityRank }, rarityScore && { rarityScore }, collection && { collection });
+                    yield this.addNft(contract, token_id, {
                         nftMetadata,
-                        userAddress: selectedAddress,
-                        chainId,
+                        userAddress,
                         source: constants_1.Source.Detected,
+                        networkClientId,
                     });
                 }
             }));
diff --git a/node_modules/@metamask/assets-controllers/dist/NftDetectionController.js.map b/node_modules/@metamask/assets-controllers/dist/NftDetectionController.js.map
index 1a41786..8352668 100644
--- a/node_modules/@metamask/assets-controllers/dist/NftDetectionController.js.map
+++ b/node_modules/@metamask/assets-controllers/dist/NftDetectionController.js.map
@@ -1 +1 @@
-{"version":3,"file":"NftDetectionController.js","sourceRoot":"","sources":["../src/NftDetectionController.ts"],"names":[],"mappings":"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","sourcesContent":["import type { BaseConfig, BaseState } from '@metamask/base-controller';\nimport {\n  OPENSEA_PROXY_URL,\n  fetchWithErrorHandling,\n  toChecksumHexAddress,\n  ChainId,\n} from '@metamask/controller-utils';\nimport type {\n  NetworkClientId,\n  NetworkController,\n  NetworkState,\n  NetworkClient,\n} from '@metamask/network-controller';\nimport { PollingControllerV1 } from '@metamask/polling-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport type { Hex } from '@metamask/utils';\n\nimport { Source } from './constants';\nimport type { NftController, NftState, NftMetadata } from './NftController';\n\nconst DEFAULT_INTERVAL = 180000;\n\n/**\n * @type ApiNft\n *\n * NFT object coming from OpenSea api\n * @property token_id - The NFT identifier\n * @property num_sales - Number of sales\n * @property background_color - The background color to be displayed with the item\n * @property image_url - URI of an image associated with this NFT\n * @property image_preview_url - URI of a smaller image associated with this NFT\n * @property image_thumbnail_url - URI of a thumbnail image associated with this NFT\n * @property image_original_url - URI of the original image associated with this NFT\n * @property animation_url - URI of a animation associated with this NFT\n * @property animation_original_url - URI of the original animation associated with this NFT\n * @property name - The NFT name\n * @property description - The NFT description\n * @property external_link - External link containing additional information\n * @property assetContract - The NFT contract information object\n * @property creator - The NFT owner information object\n * @property lastSale - When this item was last sold\n */\nexport interface ApiNft {\n  token_id: string;\n  num_sales: number | null;\n  background_color: string | null;\n  image_url: string | null;\n  image_preview_url: string | null;\n  image_thumbnail_url: string | null;\n  image_original_url: string | null;\n  animation_url: string | null;\n  animation_original_url: string | null;\n  name: string | null;\n  description: string | null;\n  external_link: string | null;\n  asset_contract: ApiNftContract;\n  creator: ApiNftCreator;\n  last_sale: ApiNftLastSale | null;\n}\n\n/**\n * @type ApiNftContract\n *\n * NFT contract object coming from OpenSea api\n * @property address - Address of the NFT contract\n * @property asset_contract_type - The NFT type, it could be `semi-fungible` or `non-fungible`\n * @property created_date - Creation date\n * @property collection - Object containing the contract name and URI of an image associated\n * @property schema_name - The schema followed by the contract, it could be `ERC721` or `ERC1155`\n * @property symbol - The NFT contract symbol\n * @property total_supply - Total supply of NFTs\n * @property description - The NFT contract description\n * @property external_link - External link containing additional information\n */\nexport interface ApiNftContract {\n  address: string;\n  asset_contract_type: string | null;\n  created_date: string | null;\n  schema_name: string | null;\n  symbol: string | null;\n  total_supply: string | null;\n  description: string | null;\n  external_link: string | null;\n  collection: {\n    name: string | null;\n    image_url?: string | null;\n  };\n}\n\n/**\n * @type ApiNftLastSale\n *\n * NFT sale object coming from OpenSea api\n * @property event_timestamp - Object containing a `username`\n * @property total_price - URI of NFT image associated with this owner\n * @property transaction - Object containing transaction_hash and block_hash\n */\nexport interface ApiNftLastSale {\n  event_timestamp: string;\n  total_price: string;\n  transaction: { transaction_hash: string; block_hash: string };\n}\n\n/**\n * @type ApiNftCreator\n *\n * NFT creator object coming from OpenSea api\n * @property user - Object containing a `username`\n * @property profile_img_url - URI of NFT image associated with this owner\n * @property address - The owner address\n */\nexport interface ApiNftCreator {\n  user: { username: string };\n  profile_img_url: string;\n  address: string;\n}\n\n/**\n * @type NftDetectionConfig\n *\n * NftDetection configuration\n * @property interval - Polling interval used to fetch new token rates\n * @property chainId - Current chain ID\n * @property selectedAddress - Vault selected address\n */\nexport interface NftDetectionConfig extends BaseConfig {\n  interval: number;\n  chainId: Hex;\n  selectedAddress: string;\n}\n\n/**\n * Controller that passively polls on a set interval for NFT auto detection\n */\nexport class NftDetectionController extends PollingControllerV1<\n  NftDetectionConfig,\n  BaseState\n> {\n  private intervalId?: ReturnType<typeof setTimeout>;\n\n  private getOwnerNftApi({\n    address,\n    offset,\n  }: {\n    address: string;\n    offset: number;\n  }) {\n    return `${OPENSEA_PROXY_URL}/assets?owner=${address}&offset=${offset}&limit=50`;\n  }\n\n  private async getOwnerNfts(address: string) {\n    let nftApiResponse: { assets: ApiNft[] };\n    let nfts: ApiNft[] = [];\n    let offset = 0;\n    let pagingFinish = false;\n    /* istanbul ignore if */\n    do {\n      nftApiResponse = await fetchWithErrorHandling({\n        url: this.getOwnerNftApi({ address, offset }),\n        timeout: 15000,\n      });\n\n      if (!nftApiResponse) {\n        return nfts;\n      }\n\n      nftApiResponse?.assets?.length !== 0\n        ? (nfts = [...nfts, ...nftApiResponse.assets])\n        : (pagingFinish = true);\n      offset += 50;\n    } while (!pagingFinish);\n\n    return nfts;\n  }\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'NftDetectionController';\n\n  private readonly getOpenSeaApiKey: () => string | undefined;\n\n  private readonly addNft: NftController['addNft'];\n\n  private readonly getNftState: () => NftState;\n\n  private readonly getNetworkClientById: NetworkController['getNetworkClientById'];\n\n  /**\n   * Creates an NftDetectionController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.onNftsStateChange - Allows subscribing to assets controller state changes.\n   * @param options.onPreferencesStateChange - Allows subscribing to preferences controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param options.getOpenSeaApiKey - Gets the OpenSea API key, if one is set.\n   * @param options.addNft - Add an NFT.\n   * @param options.getNftState - Gets the current state of the Assets controller.\n   * @param options.getNetworkClientById - Gets the network client by ID, from the NetworkController.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      chainId: initialChainId,\n      getNetworkClientById,\n      onPreferencesStateChange,\n      onNetworkStateChange,\n      getOpenSeaApiKey,\n      addNft,\n      getNftState,\n    }: {\n      chainId: Hex;\n      getNetworkClientById: NetworkController['getNetworkClientById'];\n      onNftsStateChange: (listener: (nftsState: NftState) => void) => void;\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      getOpenSeaApiKey: () => string | undefined;\n      addNft: NftController['addNft'];\n      getNftState: () => NftState;\n    },\n    config?: Partial<NftDetectionConfig>,\n    state?: Partial<BaseState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      interval: DEFAULT_INTERVAL,\n      chainId: initialChainId,\n      selectedAddress: '',\n      disabled: true,\n    };\n    this.initialize();\n    this.getNftState = getNftState;\n    this.getNetworkClientById = getNetworkClientById;\n    onPreferencesStateChange(({ selectedAddress, useNftDetection }) => {\n      const { selectedAddress: previouslySelectedAddress, disabled } =\n        this.config;\n\n      if (\n        selectedAddress !== previouslySelectedAddress ||\n        !useNftDetection !== disabled\n      ) {\n        this.configure({ selectedAddress, disabled: !useNftDetection });\n      }\n\n      if (useNftDetection !== undefined) {\n        if (useNftDetection) {\n          this.start();\n        } else {\n          this.stop();\n        }\n      }\n    });\n\n    onNetworkStateChange(({ providerConfig }) => {\n      this.configure({\n        chainId: providerConfig.chainId,\n      });\n    });\n    this.getOpenSeaApiKey = getOpenSeaApiKey;\n    this.addNft = addNft;\n    this.setIntervalLength(this.config.interval);\n  }\n\n  async _executePoll(\n    networkClientId: string,\n    options: { address: string },\n  ): Promise<void> {\n    await this.detectNfts(networkClientId, options.address);\n  }\n\n  /**\n   * Start polling for the currency rate.\n   */\n  async start() {\n    if (!this.isMainnet() || this.disabled) {\n      return;\n    }\n\n    await this.startPolling();\n  }\n\n  /**\n   * Stop polling for the currency rate.\n   */\n  stop() {\n    this.stopPolling();\n  }\n\n  private stopPolling() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n  }\n\n  /**\n   * Starts a new polling interval.\n   *\n   * @param interval - An interval on which to poll.\n   */\n  private async startPolling(interval?: number): Promise<void> {\n    interval && this.configure({ interval }, false, false);\n    this.stopPolling();\n    await this.detectNfts();\n    this.intervalId = setInterval(async () => {\n      await this.detectNfts();\n    }, this.config.interval);\n  }\n\n  /**\n   * Checks whether network is mainnet or not.\n   *\n   * @returns Whether current network is mainnet.\n   */\n  isMainnet = (): boolean => this.config.chainId === ChainId.mainnet;\n\n  isMainnetByNetworkClientId = (networkClient: NetworkClient): boolean => {\n    return networkClient.configuration.chainId === ChainId.mainnet;\n  };\n\n  private getCorrectChainId(networkClientId?: NetworkClientId) {\n    if (networkClientId) {\n      return this.getNetworkClientById(networkClientId).configuration.chainId;\n    }\n    return this.config.chainId;\n  }\n\n  /**\n   * Triggers asset ERC721 token auto detection on mainnet. Any newly detected NFTs are\n   * added.\n   *\n   * @param networkClientId - The network client ID to detect NFTs on.\n   * @param accountAddress - The address to detect NFTs for.\n   */\n  async detectNfts(networkClientId?: NetworkClientId, accountAddress?: string) {\n    const chainId = this.getCorrectChainId(networkClientId);\n\n    const selectedAddress = accountAddress || this.config.selectedAddress;\n\n    /* istanbul ignore if */\n    if (!this.isMainnet() || this.disabled) {\n      return;\n    }\n    /* istanbul ignore else */\n    if (!selectedAddress) {\n      return;\n    }\n\n    const apiNfts = await this.getOwnerNfts(selectedAddress);\n    const addNftPromises = apiNfts.map(async (nft: ApiNft) => {\n      const {\n        token_id,\n        num_sales,\n        background_color,\n        image_url,\n        image_preview_url,\n        image_thumbnail_url,\n        image_original_url,\n        animation_url,\n        animation_original_url,\n        name,\n        description,\n        external_link,\n        creator,\n        asset_contract: { address, schema_name },\n        last_sale,\n      } = nft;\n\n      let ignored;\n      /* istanbul ignore else */\n      const { ignoredNfts } = this.getNftState();\n      if (ignoredNfts.length) {\n        ignored = ignoredNfts.find((c) => {\n          /* istanbul ignore next */\n          return (\n            c.address === toChecksumHexAddress(address) &&\n            c.tokenId === token_id\n          );\n        });\n      }\n\n      /* istanbul ignore else */\n      if (!ignored) {\n        /* istanbul ignore next */\n        const nftMetadata: NftMetadata = Object.assign(\n          {},\n          { name },\n          creator && { creator },\n          description && { description },\n          image_url && { image: image_url },\n          num_sales && { numberOfSales: num_sales },\n          background_color && { backgroundColor: background_color },\n          image_preview_url && { imagePreview: image_preview_url },\n          image_thumbnail_url && { imageThumbnail: image_thumbnail_url },\n          image_original_url && { imageOriginal: image_original_url },\n          animation_url && { animation: animation_url },\n          animation_original_url && {\n            animationOriginal: animation_original_url,\n          },\n          schema_name && { standard: schema_name },\n          external_link && { externalLink: external_link },\n          last_sale && { lastSale: last_sale },\n        );\n\n        await this.addNft(address, token_id, {\n          nftMetadata,\n          userAddress: selectedAddress,\n          chainId,\n          source: Source.Detected,\n        });\n      }\n    });\n    await Promise.all(addNftPromises);\n  }\n}\n\nexport default NftDetectionController;\n"]}
\ No newline at end of file
+{"version":3,"file":"NftDetectionController.js","sourceRoot":"","sources":["../src/NftDetectionController.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Hex } from '@metamask/utils';\nimport {\n  BaseController,\n  BaseConfig,\n  BaseState,\n} from '@metamask/base-controller';\nimport type {\n  NetworkState,\n  NetworkClientId,\n} from '@metamask/network-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport {\n  NFT_API_BASE_URL,\n  fetchWithErrorHandling,\n  toChecksumHexAddress,\n  ChainId,\n} from '@metamask/controller-utils';\nimport type { NftController, NftState, NftMetadata } from './NftController';\nimport { Source } from './constants';\n\nconst DEFAULT_INTERVAL = 180000;\n\n/**\n * @type ApiNft\n *\n * NFT object coming from OpenSea api\n * @property token_id - The NFT identifier\n * @property num_sales - Number of sales\n * @property background_color - The background color to be displayed with the item\n * @property image_url - URI of an image associated with this NFT\n * @property image_preview_url - URI of a smaller image associated with this NFT\n * @property image_thumbnail_url - URI of a thumbnail image associated with this NFT\n * @property image_original_url - URI of the original image associated with this NFT\n * @property animation_url - URI of a animation associated with this NFT\n * @property animation_original_url - URI of the original animation associated with this NFT\n * @property name - The NFT name\n * @property description - The NFT description\n * @property external_link - External link containing additional information\n * @property assetContract - The NFT contract information object\n * @property creator - The NFT owner information object\n * @property lastSale - When this item was last sold\n */\nexport interface ApiNft {\n  token_id: string;\n  num_sales: number | null;\n  background_color: string | null;\n  image_url: string | null;\n  image_preview_url: string | null;\n  image_thumbnail_url: string | null;\n  image_original_url: string | null;\n  animation_url: string | null;\n  animation_original_url: string | null;\n  name: string | null;\n  description: string | null;\n  external_link: string | null;\n  asset_contract: ApiNftContract;\n  creator: ApiNftCreator;\n  last_sale: ApiNftLastSale | null;\n}\n\n/**\n * @type ApiNftContract\n *\n * NFT contract object coming from OpenSea api\n * @property address - Address of the NFT contract\n * @property asset_contract_type - The NFT type, it could be `semi-fungible` or `non-fungible`\n * @property created_date - Creation date\n * @property collection - Object containing the contract name and URI of an image associated\n * @property schema_name - The schema followed by the contract, it could be `ERC721` or `ERC1155`\n * @property symbol - The NFT contract symbol\n * @property total_supply - Total supply of NFTs\n * @property description - The NFT contract description\n * @property external_link - External link containing additional information\n */\nexport interface ApiNftContract {\n  address: string;\n  asset_contract_type: string | null;\n  created_date: string | null;\n  schema_name: string | null;\n  symbol: string | null;\n  total_supply: string | null;\n  description: string | null;\n  external_link: string | null;\n  collection: {\n    name: string | null;\n    image_url?: string | null;\n    tokenCount?: string | null;\n  };\n}\n\n/**\n * @type ApiNftLastSale\n *\n * NFT sale object coming from OpenSea api\n * @property event_timestamp - Object containing a `username`\n * @property total_price - URI of NFT image associated with this owner\n * @property transaction - Object containing transaction_hash and block_hash\n */\nexport interface ApiNftLastSale {\n  event_timestamp: string;\n  total_price: string;\n  transaction: { transaction_hash: string; block_hash: string };\n}\n\n/**\n * @type ApiNftCreator\n *\n * NFT creator object coming from OpenSea api\n * @property user - Object containing a `username`\n * @property profile_img_url - URI of NFT image associated with this owner\n * @property address - The owner address\n */\nexport interface ApiNftCreator {\n  user: { username: string };\n  profile_img_url: string;\n  address: string;\n}\n\n/**\n * @type NftDetectionConfig\n *\n * NftDetection configuration\n * @property interval - Polling interval used to fetch new token rates\n * @property chainId - Current chain ID\n * @property selectedAddress - Vault selected address\n */\nexport interface NftDetectionConfig extends BaseConfig {\n  interval: number;\n  chainId: Hex;\n  selectedAddress: string;\n}\n\nexport type ReservoirResponse = {\n  tokens: TokensResponse[];\n  continuation?: string;\n};\n\nexport type TokensResponse = {\n  token: TokenResponse;\n  ownership: Ownership;\n  market?: Market;\n  blockaidResult?: Blockaid;\n};\n\nexport enum BlockaidResultType {\n  Benign = 'Benign',\n  Spam = 'Spam',\n  Warning = 'Warning',\n  Malicious = 'Malicious',\n}\n\nexport type Blockaid = {\n  contract: string;\n  chainId: number;\n  result_type: BlockaidResultType;\n  malicious_score: string;\n  attack_types: object;\n};\n\nexport type Market = {\n  floorAsk?: FloorAsk;\n  topBid?: TopBid;\n};\n\nexport type TokenResponse = {\n  chainId: number;\n  contract: string;\n  tokenId: string;\n  kind?: string;\n  name?: string;\n  image?: string;\n  imageSmall?: string;\n  imageLarge?: string;\n  metadata?: Metadata;\n  description?: string;\n  supply?: number;\n  remainingSupply?: number;\n  rarityScore?: number;\n  rarity?: number;\n  rarityRank?: number;\n  media?: string;\n  isFlagged?: boolean;\n  isSpam?: boolean;\n  isNsfw?: boolean;\n  metadataDisabled?: boolean;\n  lastFlagUpdate?: string;\n  lastFlagChange?: string;\n  collection?: Collection;\n  lastSale?: LastSale;\n  topBid?: TopBid;\n  lastAppraisalValue?: number;\n  attributes?: Attributes[];\n};\n\nexport type TopBid = {\n  id?: string;\n  price?: Price;\n  source?: {\n    id?: string;\n    domain?: string;\n    name?: string;\n    icon?: string;\n    url?: string;\n  };\n};\n\nexport type LastSale = {\n  saleId?: string;\n  token?: {\n    contract?: string;\n    tokenId?: string;\n    name?: string;\n    image?: string;\n    collection?: {\n      id?: string;\n      name?: string;\n    };\n  };\n  orderSource?: string;\n  orderSide?: 'ask' | 'bid';\n  orderKind?: string;\n  orderId?: string;\n  from?: string;\n  to?: string;\n  amount?: string;\n  fillSource?: string;\n  block?: number;\n  txHash?: string;\n  logIndex?: number;\n  batchIndex?: number;\n  timestamp?: number;\n  price?: Price;\n  washTradingScore?: number;\n  royaltyFeeBps?: number;\n  marketplaceFeeBps?: number;\n  paidFullRoyalty?: boolean;\n  feeBreakdown?: FeeBreakdown[];\n  isDeleted?: boolean;\n  createdAt?: string;\n  updatedAt?: string;\n};\n\nexport type FeeBreakdown = {\n  kind?: string;\n  bps?: number;\n  recipient?: string;\n  source?: string;\n  rawAmount?: string;\n};\n\nexport type Attributes = {\n  key?: string;\n  kind?: string;\n  value: string;\n  tokenCount?: number;\n  onSaleCount?: number;\n  floorAskPrice?: Price | null;\n  topBidValue?: number | null;\n  createdAt?: string;\n};\n\nexport type Collection = {\n  id?: string;\n  name?: string;\n  slug?: string;\n  symbol?: string;\n  imageUrl?: string;\n  image?: string;\n  isSpam?: boolean;\n  isNsfw?: boolean;\n  creator?: string;\n  tokenCount?: string;\n  metadataDisabled?: boolean;\n  openseaVerificationStatus?: string;\n  floorAskPrice?: Price;\n  royaltiesBps?: number;\n  royalties?: Royalties[];\n};\n\nexport type Royalties = {\n  bps?: number;\n  recipient?: string;\n};\n\nexport type Ownership = {\n  tokenCount?: string;\n  onSaleCount?: string;\n  floorAsk?: FloorAsk;\n  acquiredAt?: string;\n};\n\nexport type FloorAsk = {\n  id?: string;\n  price?: Price;\n  maker?: string;\n  kind?: string;\n  validFrom?: number;\n  validUntil?: number;\n  source?: Source;\n  rawData?: Metadata;\n  isNativeOffChainCancellable?: boolean;\n};\n\nexport type Price = {\n  currency?: {\n    contract?: string;\n    name?: string;\n    symbol?: string;\n    decimals?: number;\n    chainId?: number;\n  };\n  amount?: {\n    raw?: string;\n    decimal?: number;\n    usd?: number;\n    native?: number;\n  };\n  netAmount?: {\n    raw?: string;\n    decimal?: number;\n    usd?: number;\n    native?: number;\n  };\n};\n\nexport type Metadata = {\n  imageOriginal?: string;\n  tokenURI?: string;\n};\n\n/**\n * Controller that passively polls on a set interval for NFT auto detection\n */\nexport class NftDetectionController extends BaseController<\n  NftDetectionConfig,\n  BaseState\n> {\n  private intervalId?: ReturnType<typeof setTimeout>;\n\n  private getOwnerNftApi({\n    address,\n    next,\n  }: {\n    address: string;\n    next?: string;\n  }) {\n    return `${NFT_API_BASE_URL}/users/${address}/tokens?chainIds=1&limit=50&includeTopBid=true&continuation=${\n      next ?? ''\n    }`;\n  }\n\n  private async getOwnerNfts(address: string) {\n    let nftApiResponse: ReservoirResponse;\n    let nfts: TokensResponse[] = [];\n    let next;\n    do {\n      nftApiResponse = await fetchWithErrorHandling({\n        url: this.getOwnerNftApi({ address, next }),\n        options: {\n          headers: {\n            Version: '1',\n          },\n        },\n        timeout: 15000,\n      });\n\n      if (!nftApiResponse) {\n        return nfts;\n      }\n      const newNfts = nftApiResponse.tokens.filter(\n        (elm) =>\n          elm.token.isSpam === false &&\n          (elm.blockaidResult?.result_type\n            ? elm.blockaidResult?.result_type === BlockaidResultType.Benign\n            : true),\n      );\n\n      nfts = [...nfts, ...newNfts];\n    } while ((next = nftApiResponse.continuation));\n\n    return nfts;\n  }\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'NftDetectionController';\n\n  private getOpenSeaApiKey: () => string | undefined;\n\n  private addNft: NftController['addNft'];\n\n  private getNftApi: NftController['getNftApi'];\n\n  private getNftState: () => NftState;\n\n  /**\n   * Creates an NftDetectionController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.onNftsStateChange - Allows subscribing to assets controller state changes.\n   * @param options.onPreferencesStateChange - Allows subscribing to preferences controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param options.getOpenSeaApiKey - Gets the OpenSea API key, if one is set.\n   * @param options.addNft - Add an NFT.\n   * @param options.getNftApi - Gets the URL to fetch an NFT from OpenSea.\n   * @param options.getNftState - Gets the current state of the Assets controller.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      chainId: initialChainId,\n      onPreferencesStateChange,\n      onNetworkStateChange,\n      getOpenSeaApiKey,\n      addNft,\n      getNftApi,\n      getNftState,\n    }: {\n      chainId: Hex;\n      onNftsStateChange: (listener: (nftsState: NftState) => void) => void;\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      getOpenSeaApiKey: () => string | undefined;\n      addNft: NftController['addNft'];\n      getNftApi: NftController['getNftApi'];\n      getNftState: () => NftState;\n    },\n    config?: Partial<NftDetectionConfig>,\n    state?: Partial<BaseState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      interval: DEFAULT_INTERVAL,\n      chainId: initialChainId,\n      selectedAddress: '',\n      disabled: true,\n    };\n    this.initialize();\n    this.getNftState = getNftState;\n    onPreferencesStateChange(({ selectedAddress, useNftDetection }) => {\n      const { selectedAddress: previouslySelectedAddress, disabled } =\n        this.config;\n\n      if (\n        selectedAddress !== previouslySelectedAddress ||\n        !useNftDetection !== disabled\n      ) {\n        this.configure({ selectedAddress, disabled: !useNftDetection });\n\n        if (useNftDetection) {\n          this.start();\n        } else {\n          this.stop();\n        }\n      }\n    });\n\n    onNetworkStateChange(({ providerConfig }) => {\n      this.configure({\n        chainId: providerConfig.chainId,\n      });\n    });\n    this.getOpenSeaApiKey = getOpenSeaApiKey;\n    this.addNft = addNft;\n    this.getNftApi = getNftApi;\n  }\n\n  /**\n   * Start polling for the currency rate.\n   */\n  async start() {\n    if (!this.isMainnet() || this.disabled) {\n      return;\n    }\n\n    await this.startPolling();\n  }\n\n  /**\n   * Stop polling for the currency rate.\n   */\n  stop() {\n    this.stopPolling();\n  }\n\n  private stopPolling() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n  }\n\n  /**\n   * Starts a new polling interval.\n   *\n   * @param interval - An interval on which to poll.\n   */\n  private async startPolling(interval?: number): Promise<void> {\n    interval && this.configure({ interval }, false, false);\n    this.stopPolling();\n    await this.detectNfts();\n    this.intervalId = setInterval(async () => {\n      await this.detectNfts();\n    }, this.config.interval);\n  }\n\n  /**\n   * Checks whether network is mainnet or not.\n   *\n   * @returns Whether current network is mainnet.\n   */\n  isMainnet = (): boolean => this.config.chainId === ChainId.mainnet;\n\n  /**\n   * Triggers asset ERC721 token auto detection on mainnet. Any newly detected NFTs are\n   * added.\n   * @param options - Options bag.\n   * @param options.networkClientId - The network client ID to detect NFTs on.\n   * @param options.userAddress - The address to detect NFTs for.\n   */\n  async detectNfts(\n    {\n      networkClientId,\n      userAddress,\n    }: {\n      networkClientId?: NetworkClientId;\n      userAddress: string;\n    } = { userAddress: this.config.selectedAddress },\n  ) {\n    /* istanbul ignore if */\n    if (!this.isMainnet() || this.disabled) {\n      return;\n    }\n\n    /* istanbul ignore else */\n    if (!userAddress) {\n      return;\n    }\n\n    const apiNfts = await this.getOwnerNfts(userAddress);\n    const addNftPromises = apiNfts.map(async (nft) => {\n      const {\n        tokenId: token_id,\n        contract,\n        kind,\n        image: image_url,\n        imageSmall: image_thumbnail_url,\n        metadata: { imageOriginal: image_original_url } = {},\n        name,\n        description,\n        attributes,\n        topBid,\n        lastSale,\n        rarityRank,\n        rarityScore,\n        collection,\n      } = nft.token;\n\n      let ignored;\n      /* istanbul ignore else */\n      const { ignoredNfts } = this.getNftState();\n      if (ignoredNfts.length) {\n        ignored = ignoredNfts.find((c) => {\n          /* istanbul ignore next */\n          return (\n            c.address === toChecksumHexAddress(contract) &&\n            c.tokenId === token_id\n          );\n        });\n      }\n\n      /* istanbul ignore else */\n      if (!ignored) {\n        /* istanbul ignore next */\n        const nftMetadata: NftMetadata = Object.assign(\n          {},\n          { name },\n          description && { description },\n          image_url && { image: image_url },\n          image_thumbnail_url && { imageThumbnail: image_thumbnail_url },\n          image_original_url && { imageOriginal: image_original_url },\n          kind && { standard: kind.toUpperCase() },\n          lastSale && { lastSale },\n          attributes && { attributes },\n          topBid && { topBid },\n          rarityRank && { rarityRank },\n          rarityScore && { rarityScore },\n          collection && { collection },\n        );\n\n        await this.addNft(contract, token_id, {\n          nftMetadata,\n          userAddress,\n          source: Source.Detected,\n          networkClientId,\n        });\n      }\n    });\n    await Promise.all(addNftPromises);\n  }\n}\n\nexport default NftDetectionController;\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.d.ts b/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.d.ts
index f3983c1..0175a5a 100644
--- a/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.d.ts
@@ -1,8 +1,8 @@
 /// <reference types="bn.js" />
-import type { Web3Provider } from '@ethersproject/providers';
-import type { BN } from 'ethereumjs-util';
+import { BN } from 'ethereumjs-util';
+import { Web3Provider } from '@ethersproject/providers';
 export declare class ERC20Standard {
-    private readonly provider;
+    private provider;
     constructor(provider: Web3Provider);
     /**
      * Get balance or count for current account on specific asset contract.
diff --git a/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.d.ts.map b/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.d.ts.map
index 6baa9fb..f354de1 100644
--- a/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.d.ts.map
+++ b/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"ERC20Standard.d.ts","sourceRoot":"","sources":["../../src/Standards/ERC20Standard.ts"],"names":[],"mappings":";AACA,OAAO,KAAK,EAAE,YAAY,EAAE,MAAM,0BAA0B,CAAC;AAM7D,OAAO,KAAK,EAAE,EAAE,EAAE,MAAM,iBAAiB,CAAC;AAI1C,qBAAa,aAAa;IACxB,OAAO,CAAC,QAAQ,CAAC,QAAQ,CAAe;gBAE5B,QAAQ,EAAE,YAAY;IAIlC;;;;;;OAMG;IACG,YAAY,CAAC,OAAO,EAAE,MAAM,EAAE,eAAe,EAAE,MAAM,GAAG,OAAO,CAAC,EAAE,CAAC;IAMzE;;;;;OAKG;IACG,gBAAgB,CAAC,OAAO,EAAE,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;IAcxD;;;;;OAKG;IACG,YAAY,CAAC,OAAO,EAAE,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;IAcpD;;;;;OAKG;IACG,cAAc,CAAC,OAAO,EAAE,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;IA4BtD;;;;;;OAMG;IACG,UAAU,CACd,OAAO,EAAE,MAAM,EACf,WAAW,CAAC,EAAE,MAAM,GACnB,OAAO,CAAC;QACT,QAAQ,EAAE,MAAM,CAAC;QACjB,MAAM,EAAE,MAAM,GAAG,SAAS,CAAC;QAC3B,QAAQ,EAAE,MAAM,GAAG,SAAS,CAAC;QAC7B,OAAO,EAAE,EAAE,GAAG,SAAS,CAAC;KACzB,CAAC;CAaH"}
\ No newline at end of file
+{"version":3,"file":"ERC20Standard.d.ts","sourceRoot":"","sources":["../../src/Standards/ERC20Standard.ts"],"names":[],"mappings":";AAEA,OAAO,EAAE,EAAE,EAAU,MAAM,iBAAiB,CAAC;AAG7C,OAAO,EAAE,YAAY,EAAE,MAAM,0BAA0B,CAAC;AAKxD,qBAAa,aAAa;IACxB,OAAO,CAAC,QAAQ,CAAe;gBAEnB,QAAQ,EAAE,YAAY;IAIlC;;;;;;OAMG;IACG,YAAY,CAAC,OAAO,EAAE,MAAM,EAAE,eAAe,EAAE,MAAM,GAAG,OAAO,CAAC,EAAE,CAAC;IAMzE;;;;;OAKG;IACG,gBAAgB,CAAC,OAAO,EAAE,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;IAcxD;;;;;OAKG;IACG,YAAY,CAAC,OAAO,EAAE,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;IAcpD;;;;;OAKG;IACG,cAAc,CAAC,OAAO,EAAE,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;IA6BtD;;;;;;OAMG;IACG,UAAU,CACd,OAAO,EAAE,MAAM,EACf,WAAW,CAAC,EAAE,MAAM,GACnB,OAAO,CAAC;QACT,QAAQ,EAAE,MAAM,CAAC;QACjB,MAAM,EAAE,MAAM,GAAG,SAAS,CAAC;QAC3B,QAAQ,EAAE,MAAM,GAAG,SAAS,CAAC;QAC7B,OAAO,EAAE,EAAE,GAAG,SAAS,CAAC;KACzB,CAAC;CAaH"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.js b/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.js
index b7a8c56..1bc9c4f 100644
--- a/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.js
+++ b/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.js
@@ -11,11 +11,11 @@ var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, ge
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.ERC20Standard = void 0;
 const contracts_1 = require("@ethersproject/contracts");
+const metamask_eth_abis_1 = require("@metamask/metamask-eth-abis");
+const ethereumjs_util_1 = require("ethereumjs-util");
 const abi_utils_1 = require("@metamask/abi-utils");
 const controller_utils_1 = require("@metamask/controller-utils");
-const metamask_eth_abis_1 = require("@metamask/metamask-eth-abis");
 const utils_1 = require("@metamask/utils");
-const ethereumjs_util_1 = require("ethereumjs-util");
 const assetsUtil_1 = require("../assetsUtil");
 class ERC20Standard {
     constructor(provider) {
@@ -105,7 +105,8 @@ class ERC20Standard {
             try {
                 const utf8 = (0, ethereumjs_util_1.toUtf8)(result);
                 if (utf8.length > 0) {
-                    return utf8;
+                    // This utf8 returns unicode characters, wee need to replace it
+                    return utf8.replace(/[\u0000\u0003\u0020]/g, '');
                 }
             }
             catch (_b) {
diff --git a/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.js.map b/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.js.map
index 9047a6a..c4cf43b 100644
--- a/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.js.map
+++ b/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.js.map
@@ -1 +1 @@
-{"version":3,"file":"ERC20Standard.js","sourceRoot":"","sources":["../../src/Standards/ERC20Standard.ts"],"names":[],"mappings":"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","sourcesContent":["import { Contract } from '@ethersproject/contracts';\nimport type { Web3Provider } from '@ethersproject/providers';\nimport { decodeSingle } from '@metamask/abi-utils';\nimport { ERC20 } from '@metamask/controller-utils';\nimport { abiERC20 } from '@metamask/metamask-eth-abis';\nimport { assertIsStrictHexString } from '@metamask/utils';\nimport { toUtf8 } from 'ethereumjs-util';\nimport type { BN } from 'ethereumjs-util';\n\nimport { ethersBigNumberToBN } from '../assetsUtil';\n\nexport class ERC20Standard {\n  private readonly provider: Web3Provider;\n\n  constructor(provider: Web3Provider) {\n    this.provider = provider;\n  }\n\n  /**\n   * Get balance or count for current account on specific asset contract.\n   *\n   * @param address - Asset ERC20 contract address.\n   * @param selectedAddress - Current account public address.\n   * @returns Promise resolving to BN object containing balance for current account on specific asset contract.\n   */\n  async getBalanceOf(address: string, selectedAddress: string): Promise<BN> {\n    const contract = new Contract(address, abiERC20, this.provider);\n    const balance = await contract.balanceOf(selectedAddress);\n    return ethersBigNumberToBN(balance);\n  }\n\n  /**\n   * Query for the decimals for a given ERC20 asset.\n   *\n   * @param address - ERC20 asset contract string.\n   * @returns Promise resolving to the 'decimals'.\n   */\n  async getTokenDecimals(address: string): Promise<string> {\n    const contract = new Contract(address, abiERC20, this.provider);\n    try {\n      const decimals = await contract.decimals();\n      return decimals.toString();\n    } catch (err: any) {\n      // Mirror previous implementation\n      if (err.message.includes('call revert exception')) {\n        throw new Error('Failed to parse token decimals');\n      }\n      throw err;\n    }\n  }\n\n  /**\n   * Query for the name for a given ERC20 asset.\n   *\n   * @param address - ERC20 asset contract string.\n   * @returns Promise resolving to the 'name'.\n   */\n  async getTokenName(address: string): Promise<string> {\n    const contract = new Contract(address, abiERC20, this.provider);\n    try {\n      const name = await contract.name();\n      return name.toString();\n    } catch (err: any) {\n      // Mirror previous implementation\n      if (err.message.includes('call revert exception')) {\n        throw new Error('Failed to parse token name');\n      }\n      throw err;\n    }\n  }\n\n  /**\n   * Query for symbol for a given ERC20 asset.\n   *\n   * @param address - ERC20 asset contract address.\n   * @returns Promise resolving to the 'symbol'.\n   */\n  async getTokenSymbol(address: string): Promise<string> {\n    // Signature for calling `symbol()`\n    const payload = { to: address, data: '0x95d89b41' };\n    const result = await this.provider.call(payload);\n    assertIsStrictHexString(result);\n    // Parse as string - treat empty string as failure\n    try {\n      const decoded = decodeSingle('string', result);\n      if (decoded?.length > 0) {\n        return decoded;\n      }\n    } catch {\n      // Ignore error\n    }\n\n    // Parse as bytes - treat empty string as failure\n    try {\n      const utf8 = toUtf8(result);\n      if (utf8.length > 0) {\n        return utf8;\n      }\n    } catch {\n      // Ignore error\n    }\n\n    throw new Error('Failed to parse token symbol');\n  }\n\n  /**\n   * Query if a contract implements an interface.\n   *\n   * @param address - Asset contract address.\n   * @param userAddress - The public address for the currently active user's account.\n   * @returns Promise resolving an object containing the standard, decimals, symbol and balance of the given contract/userAddress pair.\n   */\n  async getDetails(\n    address: string,\n    userAddress?: string,\n  ): Promise<{\n    standard: string;\n    symbol: string | undefined;\n    decimals: string | undefined;\n    balance: BN | undefined;\n  }> {\n    const [decimals, symbol, balance] = await Promise.all([\n      this.getTokenDecimals(address),\n      this.getTokenSymbol(address),\n      userAddress ? this.getBalanceOf(address, userAddress) : undefined,\n    ]);\n    return {\n      decimals,\n      symbol,\n      balance,\n      standard: ERC20,\n    };\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"ERC20Standard.js","sourceRoot":"","sources":["../../src/Standards/ERC20Standard.ts"],"names":[],"mappings":"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","sourcesContent":["import { Contract } from '@ethersproject/contracts';\nimport { abiERC20 } from '@metamask/metamask-eth-abis';\nimport { BN, toUtf8 } from 'ethereumjs-util';\nimport { decodeSingle } from '@metamask/abi-utils';\n\nimport { Web3Provider } from '@ethersproject/providers';\nimport { ERC20 } from '@metamask/controller-utils';\nimport { assertIsStrictHexString } from '@metamask/utils';\nimport { ethersBigNumberToBN } from '../assetsUtil';\n\nexport class ERC20Standard {\n  private provider: Web3Provider;\n\n  constructor(provider: Web3Provider) {\n    this.provider = provider;\n  }\n\n  /**\n   * Get balance or count for current account on specific asset contract.\n   *\n   * @param address - Asset ERC20 contract address.\n   * @param selectedAddress - Current account public address.\n   * @returns Promise resolving to BN object containing balance for current account on specific asset contract.\n   */\n  async getBalanceOf(address: string, selectedAddress: string): Promise<BN> {\n    const contract = new Contract(address, abiERC20, this.provider);\n    const balance = await contract.balanceOf(selectedAddress);\n    return ethersBigNumberToBN(balance);\n  }\n\n  /**\n   * Query for the decimals for a given ERC20 asset.\n   *\n   * @param address - ERC20 asset contract string.\n   * @returns Promise resolving to the 'decimals'.\n   */\n  async getTokenDecimals(address: string): Promise<string> {\n    const contract = new Contract(address, abiERC20, this.provider);\n    try {\n      const decimals = await contract.decimals();\n      return decimals.toString();\n    } catch (err: any) {\n      // Mirror previous implementation\n      if (err.message.includes('call revert exception')) {\n        throw new Error('Failed to parse token decimals');\n      }\n      throw err;\n    }\n  }\n\n  /**\n   * Query for the name for a given ERC20 asset.\n   *\n   * @param address - ERC20 asset contract string.\n   * @returns Promise resolving to the 'name'.\n   */\n  async getTokenName(address: string): Promise<string> {\n    const contract = new Contract(address, abiERC20, this.provider);\n    try {\n      const name = await contract.name();\n      return name.toString();\n    } catch (err: any) {\n      // Mirror previous implementation\n      if (err.message.includes('call revert exception')) {\n        throw new Error('Failed to parse token name');\n      }\n      throw err;\n    }\n  }\n\n  /**\n   * Query for symbol for a given ERC20 asset.\n   *\n   * @param address - ERC20 asset contract address.\n   * @returns Promise resolving to the 'symbol'.\n   */\n  async getTokenSymbol(address: string): Promise<string> {\n    // Signature for calling `symbol()`\n    const payload = { to: address, data: '0x95d89b41' };\n    const result = await this.provider.call(payload);\n    assertIsStrictHexString(result);\n    // Parse as string - treat empty string as failure\n    try {\n      const decoded = decodeSingle('string', result);\n      if (decoded?.length > 0) {\n        return decoded;\n      }\n    } catch {\n      // Ignore error\n    }\n\n    // Parse as bytes - treat empty string as failure\n    try {\n      const utf8 = toUtf8(result);\n      if (utf8.length > 0) {\n        // This utf8 returns unicode characters, wee need to replace it\n        return utf8.replace(/[\\u0000\\u0003\\u0020]/g, '');\n      }\n    } catch {\n      // Ignore error\n    }\n\n    throw new Error('Failed to parse token symbol');\n  }\n\n  /**\n   * Query if a contract implements an interface.\n   *\n   * @param address - Asset contract address.\n   * @param userAddress - The public address for the currently active user's account.\n   * @returns Promise resolving an object containing the standard, decimals, symbol and balance of the given contract/userAddress pair.\n   */\n  async getDetails(\n    address: string,\n    userAddress?: string,\n  ): Promise<{\n    standard: string;\n    symbol: string | undefined;\n    decimals: string | undefined;\n    balance: BN | undefined;\n  }> {\n    const [decimals, symbol, balance] = await Promise.all([\n      this.getTokenDecimals(address),\n      this.getTokenSymbol(address),\n      userAddress ? this.getBalanceOf(address, userAddress) : undefined,\n    ]);\n    return {\n      decimals,\n      symbol,\n      balance,\n      standard: ERC20,\n    };\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC1155/ERC1155Standard.d.ts b/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC1155/ERC1155Standard.d.ts
index 6bbcc5d..52e7463 100644
--- a/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC1155/ERC1155Standard.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC1155/ERC1155Standard.d.ts
@@ -1,7 +1,7 @@
-import type { Web3Provider } from '@ethersproject/providers';
-import type { BN } from 'ethereumjs-util';
+import { BN } from 'ethereumjs-util';
+import { Web3Provider } from '@ethersproject/providers';
 export declare class ERC1155Standard {
-    private readonly provider;
+    private provider;
     constructor(provider: Web3Provider);
     /**
      * Query if contract implements ERC1155 URI Metadata interface.
@@ -61,7 +61,7 @@ export declare class ERC1155Standard {
      * @param interfaceId - Interface identifier.
      * @returns Promise resolving to whether the contract implements `interfaceID`.
      */
-    private readonly contractSupportsInterface;
+    private contractSupportsInterface;
     /**
      * Query if a contract implements an interface.
      *
diff --git a/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC1155/ERC1155Standard.d.ts.map b/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC1155/ERC1155Standard.d.ts.map
index b27e899..7713ebe 100644
--- a/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC1155/ERC1155Standard.d.ts.map
+++ b/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC1155/ERC1155Standard.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"ERC1155Standard.d.ts","sourceRoot":"","sources":["../../../../src/Standards/NftStandards/ERC1155/ERC1155Standard.ts"],"names":[],"mappings":"AACA,OAAO,KAAK,EAAE,YAAY,EAAE,MAAM,0BAA0B,CAAC;AAS7D,OAAO,KAAK,EAAE,EAAE,EAAE,MAAM,iBAAiB,CAAC;AAI1C,qBAAa,eAAe;IAC1B,OAAO,CAAC,QAAQ,CAAC,QAAQ,CAAe;gBAE5B,QAAQ,EAAE,YAAY;IAIlC;;;;;OAKG;IACH,oCAAoC,YACzB,MAAM,KACd,QAAQ,OAAO,CAAC,CAKjB;IAEF;;;;;OAKG;IACH,sCAAsC,YAC3B,MAAM,KACd,QAAQ,OAAO,CAAC,CAKjB;IAEF;;;;;OAKG;IACH,iCAAiC,YACtB,MAAM,KACd,QAAQ,OAAO,CAAC,CAEjB;IAEF;;;;;;OAMG;IACH,WAAW,YAAmB,MAAM,WAAW,MAAM,KAAG,QAAQ,MAAM,CAAC,CAGrE;IAEF;;;;;;;OAOG;IACH,YAAY,oBACO,MAAM,WACd,MAAM,WACN,MAAM,KACd,QAAQ,EAAE,CAAC,CAIZ;IAEF;;;;;;;;;;;OAWG;IACH,cAAc,aACF,MAAM,QACV,MAAM,MACR,MAAM,MACN,MAAM,SACH,MAAM,KACZ,QAAQ,IAAI,CAAC,CAmBd;IAEF;;;;;;OAMG;IACH,OAAO,CAAC,QAAQ,CAAC,yBAAyB,CAMxC;IAEF;;;;;;;OAOG;IACH,UAAU,YACC,MAAM,eACF,MAAM,YACT,MAAM;kBAEN,MAAM;kBACN,MAAM,GAAG,SAAS;eACrB,MAAM,GAAG,SAAS;OAiCzB;CACH"}
\ No newline at end of file
+{"version":3,"file":"ERC1155Standard.d.ts","sourceRoot":"","sources":["../../../../src/Standards/NftStandards/ERC1155/ERC1155Standard.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,EAAE,EAAE,MAAM,iBAAiB,CAAC;AACrC,OAAO,EAAE,YAAY,EAAE,MAAM,0BAA0B,CAAC;AAUxD,qBAAa,eAAe;IAC1B,OAAO,CAAC,QAAQ,CAAe;gBAEnB,QAAQ,EAAE,YAAY;IAIlC;;;;;OAKG;IACH,oCAAoC,YACzB,MAAM,KACd,QAAQ,OAAO,CAAC,CAKjB;IAEF;;;;;OAKG;IACH,sCAAsC,YAC3B,MAAM,KACd,QAAQ,OAAO,CAAC,CAKjB;IAEF;;;;;OAKG;IACH,iCAAiC,YACtB,MAAM,KACd,QAAQ,OAAO,CAAC,CAEjB;IAEF;;;;;;OAMG;IACH,WAAW,YAAmB,MAAM,WAAW,MAAM,KAAG,QAAQ,MAAM,CAAC,CAGrE;IAEF;;;;;;;OAOG;IACH,YAAY,oBACO,MAAM,WACd,MAAM,WACN,MAAM,KACd,QAAQ,EAAE,CAAC,CAIZ;IAEF;;;;;;;;;;;OAWG;IACH,cAAc,aACF,MAAM,QACV,MAAM,MACR,MAAM,MACN,MAAM,SACH,MAAM,KACZ,QAAQ,IAAI,CAAC,CAmBd;IAEF;;;;;;OAMG;IACH,OAAO,CAAC,yBAAyB,CAM/B;IAEF;;;;;;;OAOG;IACH,UAAU,YACC,MAAM,eACF,MAAM,YACT,MAAM;kBAEN,MAAM;kBACN,MAAM,GAAG,SAAS;eACrB,MAAM,GAAG,SAAS;OAiCzB;CACH"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC1155/ERC1155Standard.js b/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC1155/ERC1155Standard.js
index ad7fc54..3d3fa29 100644
--- a/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC1155/ERC1155Standard.js
+++ b/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC1155/ERC1155Standard.js
@@ -10,9 +10,9 @@ var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, ge
 };
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.ERC1155Standard = void 0;
+const metamask_eth_abis_1 = require("@metamask/metamask-eth-abis");
 const contracts_1 = require("@ethersproject/contracts");
 const controller_utils_1 = require("@metamask/controller-utils");
-const metamask_eth_abis_1 = require("@metamask/metamask-eth-abis");
 const assetsUtil_1 = require("../../../assetsUtil");
 class ERC1155Standard {
     constructor(provider) {
diff --git a/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC1155/ERC1155Standard.js.map b/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC1155/ERC1155Standard.js.map
index 48cc4d5..804f8f0 100644
--- a/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC1155/ERC1155Standard.js.map
+++ b/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC1155/ERC1155Standard.js.map
@@ -1 +1 @@
-{"version":3,"file":"ERC1155Standard.js","sourceRoot":"","sources":["../../../../src/Standards/NftStandards/ERC1155/ERC1155Standard.ts"],"names":[],"mappings":"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","sourcesContent":["import { Contract } from '@ethersproject/contracts';\nimport type { Web3Provider } from '@ethersproject/providers';\nimport {\n  ERC1155,\n  ERC1155_INTERFACE_ID,\n  ERC1155_METADATA_URI_INTERFACE_ID,\n  ERC1155_TOKEN_RECEIVER_INTERFACE_ID,\n  timeoutFetch,\n} from '@metamask/controller-utils';\nimport { abiERC1155 } from '@metamask/metamask-eth-abis';\nimport type { BN } from 'ethereumjs-util';\n\nimport { getFormattedIpfsUrl, ethersBigNumberToBN } from '../../../assetsUtil';\n\nexport class ERC1155Standard {\n  private readonly provider: Web3Provider;\n\n  constructor(provider: Web3Provider) {\n    this.provider = provider;\n  }\n\n  /**\n   * Query if contract implements ERC1155 URI Metadata interface.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @returns Promise resolving to whether the contract implements ERC1155 URI Metadata interface.\n   */\n  contractSupportsURIMetadataInterface = async (\n    address: string,\n  ): Promise<boolean> => {\n    return this.contractSupportsInterface(\n      address,\n      ERC1155_METADATA_URI_INTERFACE_ID,\n    );\n  };\n\n  /**\n   * Query if contract implements ERC1155 Token Receiver interface.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @returns Promise resolving to whether the contract implements ERC1155 Token Receiver interface.\n   */\n  contractSupportsTokenReceiverInterface = async (\n    address: string,\n  ): Promise<boolean> => {\n    return this.contractSupportsInterface(\n      address,\n      ERC1155_TOKEN_RECEIVER_INTERFACE_ID,\n    );\n  };\n\n  /**\n   * Query if contract implements ERC1155 interface.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @returns Promise resolving to whether the contract implements the base ERC1155 interface.\n   */\n  contractSupportsBase1155Interface = async (\n    address: string,\n  ): Promise<boolean> => {\n    return this.contractSupportsInterface(address, ERC1155_INTERFACE_ID);\n  };\n\n  /**\n   * Query for tokenURI for a given asset.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @param tokenId - ERC1155 asset identifier.\n   * @returns Promise resolving to the 'tokenURI'.\n   */\n  getTokenURI = async (address: string, tokenId: string): Promise<string> => {\n    const contract = new Contract(address, abiERC1155, this.provider);\n    return contract.uri(tokenId);\n  };\n\n  /**\n   * Query for balance of a given ERC1155 token.\n   *\n   * @param contractAddress - ERC1155 asset contract address.\n   * @param address - Wallet public address.\n   * @param tokenId - ERC1155 asset identifier.\n   * @returns Promise resolving to the 'balanceOf'.\n   */\n  getBalanceOf = async (\n    contractAddress: string,\n    address: string,\n    tokenId: string,\n  ): Promise<BN> => {\n    const contract = new Contract(contractAddress, abiERC1155, this.provider);\n    const balance = await contract.balanceOf(address, tokenId);\n    return ethersBigNumberToBN(balance);\n  };\n\n  /**\n   * Transfer single ERC1155 token.\n   * When minting/creating tokens, the from arg MUST be set to 0x0 (i.e. zero address).\n   * When burning/destroying tokens, the to arg MUST be set to 0x0 (i.e. zero address).\n   *\n   * @param operator - ERC1155 token address.\n   * @param from - ERC1155 token holder.\n   * @param to - ERC1155 token recipient.\n   * @param id - ERC1155 token id.\n   * @param value - Number of tokens to be sent.\n   * @returns Promise resolving to the 'transferSingle'.\n   */\n  transferSingle = async (\n    operator: string,\n    from: string,\n    to: string,\n    id: string,\n    value: string,\n  ): Promise<void> => {\n    const contract = new Contract(operator, abiERC1155, this.provider);\n    return new Promise<void>((resolve, reject) => {\n      contract.transferSingle(\n        operator,\n        from,\n        to,\n        id,\n        value,\n        (error: Error, result: void) => {\n          /* istanbul ignore if */\n          if (error) {\n            reject(error);\n            return;\n          }\n          resolve(result);\n        },\n      );\n    });\n  };\n\n  /**\n   * Query if a contract implements an interface.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @param interfaceId - Interface identifier.\n   * @returns Promise resolving to whether the contract implements `interfaceID`.\n   */\n  private readonly contractSupportsInterface = async (\n    address: string,\n    interfaceId: string,\n  ): Promise<boolean> => {\n    const contract = new Contract(address, abiERC1155, this.provider);\n    return contract.supportsInterface(interfaceId);\n  };\n\n  /**\n   * Query if a contract implements an interface.\n   *\n   * @param address - Asset contract address.\n   * @param ipfsGateway - The user's preferred IPFS gateway.\n   * @param tokenId - tokenId of a given token in the contract.\n   * @returns Promise resolving an object containing the standard, tokenURI, symbol and name of the given contract/tokenId pair.\n   */\n  getDetails = async (\n    address: string,\n    ipfsGateway: string,\n    tokenId?: string,\n  ): Promise<{\n    standard: string;\n    tokenURI: string | undefined;\n    image: string | undefined;\n  }> => {\n    const isERC1155 = await this.contractSupportsBase1155Interface(address);\n\n    if (!isERC1155) {\n      throw new Error(\"This isn't a valid ERC1155 contract\");\n    }\n    let tokenURI, image;\n\n    if (tokenId) {\n      tokenURI = await this.getTokenURI(address, tokenId);\n      if (tokenURI.startsWith('ipfs://')) {\n        tokenURI = getFormattedIpfsUrl(ipfsGateway, tokenURI, true);\n      }\n\n      try {\n        const response = await timeoutFetch(tokenURI);\n        const object = await response.json();\n        image = object?.image;\n        if (image?.startsWith('ipfs://')) {\n          image = getFormattedIpfsUrl(ipfsGateway, image, true);\n        }\n      } catch {\n        // ignore\n      }\n    }\n\n    // TODO consider querying to the metadata to get name.\n    return {\n      standard: ERC1155,\n      tokenURI,\n      image,\n    };\n  };\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"ERC1155Standard.js","sourceRoot":"","sources":["../../../../src/Standards/NftStandards/ERC1155/ERC1155Standard.ts"],"names":[],"mappings":"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","sourcesContent":["import { abiERC1155 } from '@metamask/metamask-eth-abis';\nimport { Contract } from '@ethersproject/contracts';\nimport { BN } from 'ethereumjs-util';\nimport { Web3Provider } from '@ethersproject/providers';\nimport {\n  ERC1155,\n  ERC1155_INTERFACE_ID,\n  ERC1155_METADATA_URI_INTERFACE_ID,\n  ERC1155_TOKEN_RECEIVER_INTERFACE_ID,\n  timeoutFetch,\n} from '@metamask/controller-utils';\nimport { getFormattedIpfsUrl, ethersBigNumberToBN } from '../../../assetsUtil';\n\nexport class ERC1155Standard {\n  private provider: Web3Provider;\n\n  constructor(provider: Web3Provider) {\n    this.provider = provider;\n  }\n\n  /**\n   * Query if contract implements ERC1155 URI Metadata interface.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @returns Promise resolving to whether the contract implements ERC1155 URI Metadata interface.\n   */\n  contractSupportsURIMetadataInterface = async (\n    address: string,\n  ): Promise<boolean> => {\n    return this.contractSupportsInterface(\n      address,\n      ERC1155_METADATA_URI_INTERFACE_ID,\n    );\n  };\n\n  /**\n   * Query if contract implements ERC1155 Token Receiver interface.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @returns Promise resolving to whether the contract implements ERC1155 Token Receiver interface.\n   */\n  contractSupportsTokenReceiverInterface = async (\n    address: string,\n  ): Promise<boolean> => {\n    return this.contractSupportsInterface(\n      address,\n      ERC1155_TOKEN_RECEIVER_INTERFACE_ID,\n    );\n  };\n\n  /**\n   * Query if contract implements ERC1155 interface.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @returns Promise resolving to whether the contract implements the base ERC1155 interface.\n   */\n  contractSupportsBase1155Interface = async (\n    address: string,\n  ): Promise<boolean> => {\n    return this.contractSupportsInterface(address, ERC1155_INTERFACE_ID);\n  };\n\n  /**\n   * Query for tokenURI for a given asset.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @param tokenId - ERC1155 asset identifier.\n   * @returns Promise resolving to the 'tokenURI'.\n   */\n  getTokenURI = async (address: string, tokenId: string): Promise<string> => {\n    const contract = new Contract(address, abiERC1155, this.provider);\n    return contract.uri(tokenId);\n  };\n\n  /**\n   * Query for balance of a given ERC1155 token.\n   *\n   * @param contractAddress - ERC1155 asset contract address.\n   * @param address - Wallet public address.\n   * @param tokenId - ERC1155 asset identifier.\n   * @returns Promise resolving to the 'balanceOf'.\n   */\n  getBalanceOf = async (\n    contractAddress: string,\n    address: string,\n    tokenId: string,\n  ): Promise<BN> => {\n    const contract = new Contract(contractAddress, abiERC1155, this.provider);\n    const balance = await contract.balanceOf(address, tokenId);\n    return ethersBigNumberToBN(balance);\n  };\n\n  /**\n   * Transfer single ERC1155 token.\n   * When minting/creating tokens, the from arg MUST be set to 0x0 (i.e. zero address).\n   * When burning/destroying tokens, the to arg MUST be set to 0x0 (i.e. zero address).\n   *\n   * @param operator - ERC1155 token address.\n   * @param from - ERC1155 token holder.\n   * @param to - ERC1155 token recipient.\n   * @param id - ERC1155 token id.\n   * @param value - Number of tokens to be sent.\n   * @returns Promise resolving to the 'transferSingle'.\n   */\n  transferSingle = async (\n    operator: string,\n    from: string,\n    to: string,\n    id: string,\n    value: string,\n  ): Promise<void> => {\n    const contract = new Contract(operator, abiERC1155, this.provider);\n    return new Promise<void>((resolve, reject) => {\n      contract.transferSingle(\n        operator,\n        from,\n        to,\n        id,\n        value,\n        (error: Error, result: void) => {\n          /* istanbul ignore if */\n          if (error) {\n            reject(error);\n            return;\n          }\n          resolve(result);\n        },\n      );\n    });\n  };\n\n  /**\n   * Query if a contract implements an interface.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @param interfaceId - Interface identifier.\n   * @returns Promise resolving to whether the contract implements `interfaceID`.\n   */\n  private contractSupportsInterface = async (\n    address: string,\n    interfaceId: string,\n  ): Promise<boolean> => {\n    const contract = new Contract(address, abiERC1155, this.provider);\n    return contract.supportsInterface(interfaceId);\n  };\n\n  /**\n   * Query if a contract implements an interface.\n   *\n   * @param address - Asset contract address.\n   * @param ipfsGateway - The user's preferred IPFS gateway.\n   * @param tokenId - tokenId of a given token in the contract.\n   * @returns Promise resolving an object containing the standard, tokenURI, symbol and name of the given contract/tokenId pair.\n   */\n  getDetails = async (\n    address: string,\n    ipfsGateway: string,\n    tokenId?: string,\n  ): Promise<{\n    standard: string;\n    tokenURI: string | undefined;\n    image: string | undefined;\n  }> => {\n    const isERC1155 = await this.contractSupportsBase1155Interface(address);\n\n    if (!isERC1155) {\n      throw new Error(\"This isn't a valid ERC1155 contract\");\n    }\n    let tokenURI, image;\n\n    if (tokenId) {\n      tokenURI = await this.getTokenURI(address, tokenId);\n      if (tokenURI.startsWith('ipfs://')) {\n        tokenURI = getFormattedIpfsUrl(ipfsGateway, tokenURI, true);\n      }\n\n      try {\n        const response = await timeoutFetch(tokenURI);\n        const object = await response.json();\n        image = object?.image;\n        if (image?.startsWith('ipfs://')) {\n          image = getFormattedIpfsUrl(ipfsGateway, image, true);\n        }\n      } catch {\n        // ignore\n      }\n    }\n\n    // TODO consider querying to the metadata to get name.\n    return {\n      standard: ERC1155,\n      tokenURI,\n      image,\n    };\n  };\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC721/ERC721Standard.d.ts b/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC721/ERC721Standard.d.ts
index 22ef482..efd93ca 100644
--- a/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC721/ERC721Standard.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC721/ERC721Standard.d.ts
@@ -1,6 +1,6 @@
-import type { Web3Provider } from '@ethersproject/providers';
+import { Web3Provider } from '@ethersproject/providers';
 export declare class ERC721Standard {
-    private readonly provider;
+    private provider;
     constructor(provider: Web3Provider);
     /**
      * Query if contract implements ERC721Metadata interface.
@@ -69,7 +69,7 @@ export declare class ERC721Standard {
      * @param interfaceId - Interface identifier.
      * @returns Promise resolving to whether the contract implements `interfaceID`.
      */
-    private readonly contractSupportsInterface;
+    private contractSupportsInterface;
     /**
      * Query if a contract implements an interface.
      *
diff --git a/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC721/ERC721Standard.d.ts.map b/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC721/ERC721Standard.d.ts.map
index 598795e..8d0bea3 100644
--- a/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC721/ERC721Standard.d.ts.map
+++ b/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC721/ERC721Standard.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"ERC721Standard.d.ts","sourceRoot":"","sources":["../../../../src/Standards/NftStandards/ERC721/ERC721Standard.ts"],"names":[],"mappings":"AACA,OAAO,KAAK,EAAE,YAAY,EAAE,MAAM,0BAA0B,CAAC;AAa7D,qBAAa,cAAc;IACzB,OAAO,CAAC,QAAQ,CAAC,QAAQ,CAAe;gBAE5B,QAAQ,EAAE,YAAY;IAIlC;;;;;OAKG;IACH,iCAAiC,YACtB,MAAM,KACd,QAAQ,OAAO,CAAC,CAKjB;IAEF;;;;;OAKG;IACH,mCAAmC,YACxB,MAAM,KACd,QAAQ,OAAO,CAAC,CAKjB;IAEF;;;;;OAKG;IACH,gCAAgC,YACrB,MAAM,KACd,QAAQ,OAAO,CAAC,CAEjB;IAEF;;;;;;;OAOG;IACH,aAAa,YACF,MAAM,mBACE,MAAM,SAChB,MAAM,KACZ,QAAQ,MAAM,CAAC,CAGhB;IAEF;;;;;;OAMG;IACH,WAAW,YAAmB,MAAM,WAAW,MAAM,KAAG,QAAQ,MAAM,CAAC,CASrE;IAEF;;;;;OAKG;IACH,YAAY,YAAmB,MAAM,KAAG,QAAQ,MAAM,CAAC,CAGrD;IAEF;;;;;OAKG;IACH,cAAc,YAAmB,MAAM,KAAG,QAAQ,MAAM,CAAC,CAGvD;IAEF;;;;;;OAMG;IACG,UAAU,CAAC,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;IAKnE;;;;;;OAMG;IACH,OAAO,CAAC,QAAQ,CAAC,yBAAyB,CAcxC;IAEF;;;;;;;OAOG;IACH,UAAU,YACC,MAAM,eACF,MAAM,YACT,MAAM;kBAEN,MAAM;kBACN,MAAM,GAAG,SAAS;gBACpB,MAAM,GAAG,SAAS;cACpB,MAAM,GAAG,SAAS;eACjB,MAAM,GAAG,SAAS;OA0CzB;CACH"}
\ No newline at end of file
+{"version":3,"file":"ERC721Standard.d.ts","sourceRoot":"","sources":["../../../../src/Standards/NftStandards/ERC721/ERC721Standard.ts"],"names":[],"mappings":"AAUA,OAAO,EAAE,YAAY,EAAE,MAAM,0BAA0B,CAAC;AAGxD,qBAAa,cAAc;IACzB,OAAO,CAAC,QAAQ,CAAe;gBAEnB,QAAQ,EAAE,YAAY;IAIlC;;;;;OAKG;IACH,iCAAiC,YACtB,MAAM,KACd,QAAQ,OAAO,CAAC,CAKjB;IAEF;;;;;OAKG;IACH,mCAAmC,YACxB,MAAM,KACd,QAAQ,OAAO,CAAC,CAKjB;IAEF;;;;;OAKG;IACH,gCAAgC,YACrB,MAAM,KACd,QAAQ,OAAO,CAAC,CAEjB;IAEF;;;;;;;OAOG;IACH,aAAa,YACF,MAAM,mBACE,MAAM,SAChB,MAAM,KACZ,QAAQ,MAAM,CAAC,CAGhB;IAEF;;;;;;OAMG;IACH,WAAW,YAAmB,MAAM,WAAW,MAAM,KAAG,QAAQ,MAAM,CAAC,CASrE;IAEF;;;;;OAKG;IACH,YAAY,YAAmB,MAAM,KAAG,QAAQ,MAAM,CAAC,CAGrD;IAEF;;;;;OAKG;IACH,cAAc,YAAmB,MAAM,KAAG,QAAQ,MAAM,CAAC,CAGvD;IAEF;;;;;;OAMG;IACG,UAAU,CAAC,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;IAKnE;;;;;;OAMG;IACH,OAAO,CAAC,yBAAyB,CAc/B;IAEF;;;;;;;OAOG;IACH,UAAU,YACC,MAAM,eACF,MAAM,YACT,MAAM;kBAEN,MAAM;kBACN,MAAM,GAAG,SAAS;gBACpB,MAAM,GAAG,SAAS;cACpB,MAAM,GAAG,SAAS;eACjB,MAAM,GAAG,SAAS;OA0CzB;CACH"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC721/ERC721Standard.js b/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC721/ERC721Standard.js
index 3b4d593..b55b933 100644
--- a/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC721/ERC721Standard.js
+++ b/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC721/ERC721Standard.js
@@ -10,9 +10,9 @@ var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, ge
 };
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.ERC721Standard = void 0;
+const metamask_eth_abis_1 = require("@metamask/metamask-eth-abis");
 const contracts_1 = require("@ethersproject/contracts");
 const controller_utils_1 = require("@metamask/controller-utils");
-const metamask_eth_abis_1 = require("@metamask/metamask-eth-abis");
 const assetsUtil_1 = require("../../../assetsUtil");
 class ERC721Standard {
     constructor(provider) {
diff --git a/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC721/ERC721Standard.js.map b/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC721/ERC721Standard.js.map
index 3aa4ac5..e540f00 100644
--- a/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC721/ERC721Standard.js.map
+++ b/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC721/ERC721Standard.js.map
@@ -1 +1 @@
-{"version":3,"file":"ERC721Standard.js","sourceRoot":"","sources":["../../../../src/Standards/NftStandards/ERC721/ERC721Standard.ts"],"names":[],"mappings":"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","sourcesContent":["import { Contract } from '@ethersproject/contracts';\nimport type { Web3Provider } from '@ethersproject/providers';\nimport {\n  timeoutFetch,\n  ERC721_INTERFACE_ID,\n  ERC721_METADATA_INTERFACE_ID,\n  ERC721_ENUMERABLE_INTERFACE_ID,\n  ERC721,\n  safelyExecute,\n} from '@metamask/controller-utils';\nimport { abiERC721 } from '@metamask/metamask-eth-abis';\n\nimport { getFormattedIpfsUrl } from '../../../assetsUtil';\n\nexport class ERC721Standard {\n  private readonly provider: Web3Provider;\n\n  constructor(provider: Web3Provider) {\n    this.provider = provider;\n  }\n\n  /**\n   * Query if contract implements ERC721Metadata interface.\n   *\n   * @param address - ERC721 asset contract address.\n   * @returns Promise resolving to whether the contract implements ERC721Metadata interface.\n   */\n  contractSupportsMetadataInterface = async (\n    address: string,\n  ): Promise<boolean> => {\n    return this.contractSupportsInterface(\n      address,\n      ERC721_METADATA_INTERFACE_ID,\n    );\n  };\n\n  /**\n   * Query if contract implements ERC721Enumerable interface.\n   *\n   * @param address - ERC721 asset contract address.\n   * @returns Promise resolving to whether the contract implements ERC721Enumerable interface.\n   */\n  contractSupportsEnumerableInterface = async (\n    address: string,\n  ): Promise<boolean> => {\n    return this.contractSupportsInterface(\n      address,\n      ERC721_ENUMERABLE_INTERFACE_ID,\n    );\n  };\n\n  /**\n   * Query if contract implements ERC721 interface.\n   *\n   * @param address - ERC721 asset contract address.\n   * @returns Promise resolving to whether the contract implements ERC721 interface.\n   */\n  contractSupportsBase721Interface = async (\n    address: string,\n  ): Promise<boolean> => {\n    return this.contractSupportsInterface(address, ERC721_INTERFACE_ID);\n  };\n\n  /**\n   * Enumerate assets assigned to an owner.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param selectedAddress - Current account public address.\n   * @param index - An NFT counter less than `balanceOf(selectedAddress)`.\n   * @returns Promise resolving to token identifier for the 'index'th asset assigned to 'selectedAddress'.\n   */\n  getNftTokenId = async (\n    address: string,\n    selectedAddress: string,\n    index: number,\n  ): Promise<string> => {\n    const contract = new Contract(address, abiERC721, this.provider);\n    return contract.tokenOfOwnerByIndex(selectedAddress, index);\n  };\n\n  /**\n   * Query for tokenURI for a given asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param tokenId - ERC721 asset identifier.\n   * @returns Promise resolving to the 'tokenURI'.\n   */\n  getTokenURI = async (address: string, tokenId: string): Promise<string> => {\n    const contract = new Contract(address, abiERC721, this.provider);\n    const supportsMetadata = await this.contractSupportsMetadataInterface(\n      address,\n    );\n    if (!supportsMetadata) {\n      throw new Error('Contract does not support ERC721 metadata interface.');\n    }\n    return contract.tokenURI(tokenId);\n  };\n\n  /**\n   * Query for name for a given asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @returns Promise resolving to the 'name'.\n   */\n  getAssetName = async (address: string): Promise<string> => {\n    const contract = new Contract(address, abiERC721, this.provider);\n    return contract.name();\n  };\n\n  /**\n   * Query for symbol for a given asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @returns Promise resolving to the 'symbol'.\n   */\n  getAssetSymbol = async (address: string): Promise<string> => {\n    const contract = new Contract(address, abiERC721, this.provider);\n    return contract.symbol();\n  };\n\n  /**\n   * Query for owner for a given ERC721 asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param tokenId - ERC721 asset identifier.\n   * @returns Promise resolving to the owner address.\n   */\n  async getOwnerOf(address: string, tokenId: string): Promise<string> {\n    const contract = new Contract(address, abiERC721, this.provider);\n    return contract.ownerOf(tokenId);\n  }\n\n  /**\n   * Query if a contract implements an interface.\n   *\n   * @param address - Asset contract address.\n   * @param interfaceId - Interface identifier.\n   * @returns Promise resolving to whether the contract implements `interfaceID`.\n   */\n  private readonly contractSupportsInterface = async (\n    address: string,\n    interfaceId: string,\n  ): Promise<boolean> => {\n    const contract = new Contract(address, abiERC721, this.provider);\n    try {\n      return await contract.supportsInterface(interfaceId);\n    } catch (err: any) {\n      // Mirror previous implementation\n      if (err.message.includes('call revert exception')) {\n        return false;\n      }\n      throw err;\n    }\n  };\n\n  /**\n   * Query if a contract implements an interface.\n   *\n   * @param address - Asset contract address.\n   * @param ipfsGateway - The user's preferred IPFS gateway.\n   * @param tokenId - tokenId of a given token in the contract.\n   * @returns Promise resolving an object containing the standard, tokenURI, symbol and name of the given contract/tokenId pair.\n   */\n  getDetails = async (\n    address: string,\n    ipfsGateway: string,\n    tokenId?: string,\n  ): Promise<{\n    standard: string;\n    tokenURI: string | undefined;\n    symbol: string | undefined;\n    name: string | undefined;\n    image: string | undefined;\n  }> => {\n    const isERC721 = await this.contractSupportsBase721Interface(address);\n    if (!isERC721) {\n      throw new Error(\"This isn't a valid ERC721 contract\");\n    }\n\n    const [symbol, name, tokenURI] = await Promise.all([\n      safelyExecute(() => this.getAssetSymbol(address)),\n      safelyExecute(() => this.getAssetName(address)),\n      tokenId\n        ? safelyExecute(() =>\n            this.getTokenURI(address, tokenId).then((uri) =>\n              uri.startsWith('ipfs://')\n                ? getFormattedIpfsUrl(ipfsGateway, uri, true)\n                : uri,\n            ),\n          )\n        : undefined,\n    ]);\n\n    let image;\n    if (tokenURI) {\n      try {\n        const response = await timeoutFetch(tokenURI);\n        const object = await response.json();\n        image = object?.image;\n        if (image?.startsWith('ipfs://')) {\n          image = getFormattedIpfsUrl(ipfsGateway, image, true);\n        }\n      } catch {\n        // ignore\n      }\n    }\n\n    return {\n      standard: ERC721,\n      tokenURI,\n      symbol,\n      name,\n      image,\n    };\n  };\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"ERC721Standard.js","sourceRoot":"","sources":["../../../../src/Standards/NftStandards/ERC721/ERC721Standard.ts"],"names":[],"mappings":"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","sourcesContent":["import { abiERC721 } from '@metamask/metamask-eth-abis';\nimport { Contract } from '@ethersproject/contracts';\nimport {\n  timeoutFetch,\n  ERC721_INTERFACE_ID,\n  ERC721_METADATA_INTERFACE_ID,\n  ERC721_ENUMERABLE_INTERFACE_ID,\n  ERC721,\n  safelyExecute,\n} from '@metamask/controller-utils';\nimport { Web3Provider } from '@ethersproject/providers';\nimport { getFormattedIpfsUrl } from '../../../assetsUtil';\n\nexport class ERC721Standard {\n  private provider: Web3Provider;\n\n  constructor(provider: Web3Provider) {\n    this.provider = provider;\n  }\n\n  /**\n   * Query if contract implements ERC721Metadata interface.\n   *\n   * @param address - ERC721 asset contract address.\n   * @returns Promise resolving to whether the contract implements ERC721Metadata interface.\n   */\n  contractSupportsMetadataInterface = async (\n    address: string,\n  ): Promise<boolean> => {\n    return this.contractSupportsInterface(\n      address,\n      ERC721_METADATA_INTERFACE_ID,\n    );\n  };\n\n  /**\n   * Query if contract implements ERC721Enumerable interface.\n   *\n   * @param address - ERC721 asset contract address.\n   * @returns Promise resolving to whether the contract implements ERC721Enumerable interface.\n   */\n  contractSupportsEnumerableInterface = async (\n    address: string,\n  ): Promise<boolean> => {\n    return this.contractSupportsInterface(\n      address,\n      ERC721_ENUMERABLE_INTERFACE_ID,\n    );\n  };\n\n  /**\n   * Query if contract implements ERC721 interface.\n   *\n   * @param address - ERC721 asset contract address.\n   * @returns Promise resolving to whether the contract implements ERC721 interface.\n   */\n  contractSupportsBase721Interface = async (\n    address: string,\n  ): Promise<boolean> => {\n    return this.contractSupportsInterface(address, ERC721_INTERFACE_ID);\n  };\n\n  /**\n   * Enumerate assets assigned to an owner.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param selectedAddress - Current account public address.\n   * @param index - An NFT counter less than `balanceOf(selectedAddress)`.\n   * @returns Promise resolving to token identifier for the 'index'th asset assigned to 'selectedAddress'.\n   */\n  getNftTokenId = async (\n    address: string,\n    selectedAddress: string,\n    index: number,\n  ): Promise<string> => {\n    const contract = new Contract(address, abiERC721, this.provider);\n    return contract.tokenOfOwnerByIndex(selectedAddress, index);\n  };\n\n  /**\n   * Query for tokenURI for a given asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param tokenId - ERC721 asset identifier.\n   * @returns Promise resolving to the 'tokenURI'.\n   */\n  getTokenURI = async (address: string, tokenId: string): Promise<string> => {\n    const contract = new Contract(address, abiERC721, this.provider);\n    const supportsMetadata = await this.contractSupportsMetadataInterface(\n      address,\n    );\n    if (!supportsMetadata) {\n      throw new Error('Contract does not support ERC721 metadata interface.');\n    }\n    return contract.tokenURI(tokenId);\n  };\n\n  /**\n   * Query for name for a given asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @returns Promise resolving to the 'name'.\n   */\n  getAssetName = async (address: string): Promise<string> => {\n    const contract = new Contract(address, abiERC721, this.provider);\n    return contract.name();\n  };\n\n  /**\n   * Query for symbol for a given asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @returns Promise resolving to the 'symbol'.\n   */\n  getAssetSymbol = async (address: string): Promise<string> => {\n    const contract = new Contract(address, abiERC721, this.provider);\n    return contract.symbol();\n  };\n\n  /**\n   * Query for owner for a given ERC721 asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param tokenId - ERC721 asset identifier.\n   * @returns Promise resolving to the owner address.\n   */\n  async getOwnerOf(address: string, tokenId: string): Promise<string> {\n    const contract = new Contract(address, abiERC721, this.provider);\n    return contract.ownerOf(tokenId);\n  }\n\n  /**\n   * Query if a contract implements an interface.\n   *\n   * @param address - Asset contract address.\n   * @param interfaceId - Interface identifier.\n   * @returns Promise resolving to whether the contract implements `interfaceID`.\n   */\n  private contractSupportsInterface = async (\n    address: string,\n    interfaceId: string,\n  ): Promise<boolean> => {\n    const contract = new Contract(address, abiERC721, this.provider);\n    try {\n      return await contract.supportsInterface(interfaceId);\n    } catch (err: any) {\n      // Mirror previous implementation\n      if (err.message.includes('call revert exception')) {\n        return false;\n      }\n      throw err;\n    }\n  };\n\n  /**\n   * Query if a contract implements an interface.\n   *\n   * @param address - Asset contract address.\n   * @param ipfsGateway - The user's preferred IPFS gateway.\n   * @param tokenId - tokenId of a given token in the contract.\n   * @returns Promise resolving an object containing the standard, tokenURI, symbol and name of the given contract/tokenId pair.\n   */\n  getDetails = async (\n    address: string,\n    ipfsGateway: string,\n    tokenId?: string,\n  ): Promise<{\n    standard: string;\n    tokenURI: string | undefined;\n    symbol: string | undefined;\n    name: string | undefined;\n    image: string | undefined;\n  }> => {\n    const isERC721 = await this.contractSupportsBase721Interface(address);\n    if (!isERC721) {\n      throw new Error(\"This isn't a valid ERC721 contract\");\n    }\n\n    const [symbol, name, tokenURI] = await Promise.all([\n      safelyExecute(() => this.getAssetSymbol(address)),\n      safelyExecute(() => this.getAssetName(address)),\n      tokenId\n        ? safelyExecute(() =>\n            this.getTokenURI(address, tokenId).then((uri) =>\n              uri.startsWith('ipfs://')\n                ? getFormattedIpfsUrl(ipfsGateway, uri, true)\n                : uri,\n            ),\n          )\n        : undefined,\n    ]);\n\n    let image;\n    if (tokenURI) {\n      try {\n        const response = await timeoutFetch(tokenURI);\n        const object = await response.json();\n        image = object?.image;\n        if (image?.startsWith('ipfs://')) {\n          image = getFormattedIpfsUrl(ipfsGateway, image, true);\n        }\n      } catch {\n        // ignore\n      }\n    }\n\n    return {\n      standard: ERC721,\n      tokenURI,\n      symbol,\n      name,\n      image,\n    };\n  };\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/Standards/standards-types.d.ts b/node_modules/@metamask/assets-controllers/dist/Standards/standards-types.d.ts
index 75dcf23..309ab00 100644
--- a/node_modules/@metamask/assets-controllers/dist/Standards/standards-types.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/Standards/standards-types.d.ts
@@ -1,4 +1,4 @@
-import type { abiERC20, abiERC1155, abiERC721 } from '@metamask/metamask-eth-abis';
+import { abiERC20, abiERC1155, abiERC721 } from '@metamask/metamask-eth-abis';
 declare type Contract = {
     at(address: string): any;
 };
diff --git a/node_modules/@metamask/assets-controllers/dist/Standards/standards-types.d.ts.map b/node_modules/@metamask/assets-controllers/dist/Standards/standards-types.d.ts.map
index 8337515..f431cd7 100644
--- a/node_modules/@metamask/assets-controllers/dist/Standards/standards-types.d.ts.map
+++ b/node_modules/@metamask/assets-controllers/dist/Standards/standards-types.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"standards-types.d.ts","sourceRoot":"","sources":["../../src/Standards/standards-types.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EACV,QAAQ,EACR,UAAU,EACV,SAAS,EACV,MAAM,6BAA6B,CAAC;AAErC,aAAK,QAAQ,GAAG;IACd,EAAE,CAAC,OAAO,EAAE,MAAM,GAAG,GAAG,CAAC;CAC1B,CAAC;AAEF,oBAAY,IAAI,GAAG;IACjB,GAAG,EAAE;QACH,IAAI,CACF,OAAO,EAAE;YAAE,EAAE,EAAE,MAAM,CAAC;YAAC,IAAI,EAAE,MAAM,CAAA;SAAE,EACrC,KAAK,EAAE,SAAS,EAChB,QAAQ,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,KAAK,IAAI,GAC/C,IAAI,CAAC;QACR,QAAQ,CACN,GAAG,EAAE,OAAO,QAAQ,GAAG,OAAO,SAAS,GAAG,OAAO,UAAU,GAC1D,QAAQ,CAAC;KACb,CAAC;CACH,CAAC"}
\ No newline at end of file
+{"version":3,"file":"standards-types.d.ts","sourceRoot":"","sources":["../../src/Standards/standards-types.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,QAAQ,EAAE,UAAU,EAAE,SAAS,EAAE,MAAM,6BAA6B,CAAC;AAE9E,aAAK,QAAQ,GAAG;IACd,EAAE,CAAC,OAAO,EAAE,MAAM,GAAG,GAAG,CAAC;CAC1B,CAAC;AAEF,oBAAY,IAAI,GAAG;IACjB,GAAG,EAAE;QACH,IAAI,CACF,OAAO,EAAE;YAAE,EAAE,EAAE,MAAM,CAAC;YAAC,IAAI,EAAE,MAAM,CAAA;SAAE,EACrC,KAAK,EAAE,SAAS,EAChB,QAAQ,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,KAAK,IAAI,GAC/C,IAAI,CAAC;QACR,QAAQ,CACN,GAAG,EAAE,OAAO,QAAQ,GAAG,OAAO,SAAS,GAAG,OAAO,UAAU,GAC1D,QAAQ,CAAC;KACb,CAAC;CACH,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/Standards/standards-types.js.map b/node_modules/@metamask/assets-controllers/dist/Standards/standards-types.js.map
index 5ecf0b5..1eaa1b1 100644
--- a/node_modules/@metamask/assets-controllers/dist/Standards/standards-types.js.map
+++ b/node_modules/@metamask/assets-controllers/dist/Standards/standards-types.js.map
@@ -1 +1 @@
-{"version":3,"file":"standards-types.js","sourceRoot":"","sources":["../../src/Standards/standards-types.ts"],"names":[],"mappings":"","sourcesContent":["import type {\n  abiERC20,\n  abiERC1155,\n  abiERC721,\n} from '@metamask/metamask-eth-abis';\n\ntype Contract = {\n  at(address: string): any;\n};\n\nexport type Web3 = {\n  eth: {\n    call(\n      payload: { to: string; data: string },\n      block: undefined,\n      callback: (error: Error, result: string) => void,\n    ): void;\n    contract(\n      abi: typeof abiERC20 | typeof abiERC721 | typeof abiERC1155,\n    ): Contract;\n  };\n};\n"]}
\ No newline at end of file
+{"version":3,"file":"standards-types.js","sourceRoot":"","sources":["../../src/Standards/standards-types.ts"],"names":[],"mappings":"","sourcesContent":["import { abiERC20, abiERC1155, abiERC721 } from '@metamask/metamask-eth-abis';\n\ntype Contract = {\n  at(address: string): any;\n};\n\nexport type Web3 = {\n  eth: {\n    call(\n      payload: { to: string; data: string },\n      block: undefined,\n      callback: (error: Error, result: string) => void,\n    ): void;\n    contract(\n      abi: typeof abiERC20 | typeof abiERC721 | typeof abiERC1155,\n    ): Contract;\n  };\n};\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.d.ts b/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.d.ts
index 315e7c8..1563e60 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.d.ts
@@ -1,11 +1,10 @@
 /// <reference types="bn.js" />
-import type { BaseConfig, BaseState } from '@metamask/base-controller';
-import { BaseController } from '@metamask/base-controller';
-import type { PreferencesState } from '@metamask/preferences-controller';
 import { BN } from 'ethereumjs-util';
+import { BaseController, BaseConfig, BaseState } from '@metamask/base-controller';
+import type { PreferencesState } from '@metamask/preferences-controller';
+import { Token } from './TokenRatesController';
+import { TokensState } from './TokensController';
 import type { AssetsContractController } from './AssetsContractController';
-import type { Token } from './TokenRatesController';
-import type { TokensState } from './TokensController';
 export { BN };
 /**
  * @type TokenBalancesConfig
@@ -39,8 +38,8 @@ export declare class TokenBalancesController extends BaseController<TokenBalance
      * Name of this controller used during composition
      */
     name: string;
-    private readonly getSelectedAddress;
-    private readonly getERC20BalanceOf;
+    private getSelectedAddress;
+    private getERC20BalanceOf;
     /**
      * Creates a TokenBalancesController instance.
      *
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.d.ts.map b/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.d.ts.map
index d26a5e1..d8205a1 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.d.ts.map
+++ b/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"TokenBalancesController.d.ts","sourceRoot":"","sources":["../src/TokenBalancesController.ts"],"names":[],"mappings":";AAAA,OAAO,KAAK,EAAE,UAAU,EAAE,SAAS,EAAE,MAAM,2BAA2B,CAAC;AACvE,OAAO,EAAE,cAAc,EAAE,MAAM,2BAA2B,CAAC;AAE3D,OAAO,KAAK,EAAE,gBAAgB,EAAE,MAAM,kCAAkC,CAAC;AACzE,OAAO,EAAE,EAAE,EAAE,MAAM,iBAAiB,CAAC;AAErC,OAAO,KAAK,EAAE,wBAAwB,EAAE,MAAM,4BAA4B,CAAC;AAC3E,OAAO,KAAK,EAAE,KAAK,EAAE,MAAM,wBAAwB,CAAC;AACpD,OAAO,KAAK,EAAE,WAAW,EAAE,MAAM,oBAAoB,CAAC;AAGtD,OAAO,EAAE,EAAE,EAAE,CAAC;AAEd;;;;;;GAMG;AACH,MAAM,WAAW,mBAAoB,SAAQ,UAAU;IACrD,QAAQ,EAAE,MAAM,CAAC;IACjB,MAAM,EAAE,KAAK,EAAE,CAAC;CACjB;AAED;;;;;GAKG;AACH,MAAM,WAAW,kBAAmB,SAAQ,SAAS;IACnD,gBAAgB,EAAE;QAAE,CAAC,OAAO,EAAE,MAAM,GAAG,EAAE,CAAA;KAAE,CAAC;CAC7C;AAED;;;GAGG;AACH,qBAAa,uBAAwB,SAAQ,cAAc,CACzD,mBAAmB,EACnB,kBAAkB,CACnB;IACC,OAAO,CAAC,MAAM,CAAC,CAAgC;IAE/C;;OAEG;IACM,IAAI,SAA6B;IAE1C,OAAO,CAAC,QAAQ,CAAC,kBAAkB,CAA4C;IAE/E,OAAO,CAAC,QAAQ,CAAC,iBAAiB,CAAgD;IAElF;;;;;;;;;OASG;gBAED,EACE,mBAAmB,EACnB,kBAAkB,EAClB,iBAAiB,GAClB,EAAE;QACD,mBAAmB,EAAE,CACnB,QAAQ,EAAE,CAAC,UAAU,EAAE,WAAW,KAAK,IAAI,KACxC,IAAI,CAAC;QACV,kBAAkB,EAAE,MAAM,gBAAgB,CAAC,iBAAiB,CAAC,CAAC;QAC9D,iBAAiB,EAAE,wBAAwB,CAAC,mBAAmB,CAAC,CAAC;KAClE,EACD,MAAM,CAAC,EAAE,OAAO,CAAC,mBAAmB,CAAC,EACrC,KAAK,CAAC,EAAE,OAAO,CAAC,kBAAkB,CAAC;IAkBrC;;;;OAIG;IACG,IAAI,CAAC,QAAQ,CAAC,EAAE,MAAM,GAAG,OAAO,CAAC,IAAI,CAAC;IAS5C;;OAEG;IACG,cAAc;CAqBrB;AAED,eAAe,uBAAuB,CAAC"}
\ No newline at end of file
+{"version":3,"file":"TokenBalancesController.d.ts","sourceRoot":"","sources":["../src/TokenBalancesController.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,EAAE,EAAE,MAAM,iBAAiB,CAAC;AACrC,OAAO,EACL,cAAc,EACd,UAAU,EACV,SAAS,EACV,MAAM,2BAA2B,CAAC;AAEnC,OAAO,KAAK,EAAE,gBAAgB,EAAE,MAAM,kCAAkC,CAAC;AACzE,OAAO,EAAE,KAAK,EAAE,MAAM,wBAAwB,CAAC;AAC/C,OAAO,EAAE,WAAW,EAAE,MAAM,oBAAoB,CAAC;AACjD,OAAO,KAAK,EAAE,wBAAwB,EAAE,MAAM,4BAA4B,CAAC;AAG3E,OAAO,EAAE,EAAE,EAAE,CAAC;AAEd;;;;;;GAMG;AACH,MAAM,WAAW,mBAAoB,SAAQ,UAAU;IACrD,QAAQ,EAAE,MAAM,CAAC;IACjB,MAAM,EAAE,KAAK,EAAE,CAAC;CACjB;AAED;;;;;GAKG;AACH,MAAM,WAAW,kBAAmB,SAAQ,SAAS;IACnD,gBAAgB,EAAE;QAAE,CAAC,OAAO,EAAE,MAAM,GAAG,EAAE,CAAA;KAAE,CAAC;CAC7C;AAED;;;GAGG;AACH,qBAAa,uBAAwB,SAAQ,cAAc,CACzD,mBAAmB,EACnB,kBAAkB,CACnB;IACC,OAAO,CAAC,MAAM,CAAC,CAAgC;IAE/C;;OAEG;IACM,IAAI,SAA6B;IAE1C,OAAO,CAAC,kBAAkB,CAA4C;IAEtE,OAAO,CAAC,iBAAiB,CAAgD;IAEzE;;;;;;;;;OASG;gBAED,EACE,mBAAmB,EACnB,kBAAkB,EAClB,iBAAiB,GAClB,EAAE;QACD,mBAAmB,EAAE,CACnB,QAAQ,EAAE,CAAC,UAAU,EAAE,WAAW,KAAK,IAAI,KACxC,IAAI,CAAC;QACV,kBAAkB,EAAE,MAAM,gBAAgB,CAAC,iBAAiB,CAAC,CAAC;QAC9D,iBAAiB,EAAE,wBAAwB,CAAC,mBAAmB,CAAC,CAAC;KAClE,EACD,MAAM,CAAC,EAAE,OAAO,CAAC,mBAAmB,CAAC,EACrC,KAAK,CAAC,EAAE,OAAO,CAAC,kBAAkB,CAAC;IAkBrC;;;;OAIG;IACG,IAAI,CAAC,QAAQ,CAAC,EAAE,MAAM,GAAG,OAAO,CAAC,IAAI,CAAC;IAS5C;;OAEG;IACG,cAAc;CAqBrB;AAED,eAAe,uBAAuB,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.js b/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.js
index f03e0db..525ad76 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.js
+++ b/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.js
@@ -10,10 +10,10 @@ var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, ge
 };
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.TokenBalancesController = exports.BN = void 0;
-const base_controller_1 = require("@metamask/base-controller");
-const controller_utils_1 = require("@metamask/controller-utils");
 const ethereumjs_util_1 = require("ethereumjs-util");
 Object.defineProperty(exports, "BN", { enumerable: true, get: function () { return ethereumjs_util_1.BN; } });
+const base_controller_1 = require("@metamask/base-controller");
+const controller_utils_1 = require("@metamask/controller-utils");
 /**
  * Controller that passively polls on a set interval token balances
  * for tokens stored in the TokensController
@@ -74,15 +74,15 @@ class TokenBalancesController extends base_controller_1.BaseController {
             }
             const { tokens } = this.config;
             const newContractBalances = {};
-            for (const token of tokens) {
-                const { address } = token;
+            for (const i in tokens) {
+                const { address } = tokens[i];
                 try {
                     newContractBalances[address] = yield this.getERC20BalanceOf(address, this.getSelectedAddress());
-                    token.balanceError = null;
+                    tokens[i].balanceError = null;
                 }
                 catch (error) {
                     newContractBalances[address] = new ethereumjs_util_1.BN(0);
-                    token.balanceError = error;
+                    tokens[i].balanceError = error;
                 }
             }
             this.update({ contractBalances: newContractBalances });
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.js.map b/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.js.map
index e7d364b..7959e93 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.js.map
+++ b/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.js.map
@@ -1 +1 @@
-{"version":3,"file":"TokenBalancesController.js","sourceRoot":"","sources":["../src/TokenBalancesController.ts"],"names":[],"mappings":";;;;;;;;;;;;AACA,+DAA2D;AAC3D,iEAA2D;AAE3D,qDAAqC;AAO5B,mFAPA,oBAAE,OAOA;AAwBX;;;GAGG;AACH,MAAa,uBAAwB,SAAQ,gCAG5C;IAYC;;;;;;;;;OASG;IACH,YACE,EACE,mBAAmB,EACnB,kBAAkB,EAClB,iBAAiB,GAOlB,EACD,MAAqC,EACrC,KAAmC;QAEnC,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;QAlCvB;;WAEG;QACM,SAAI,GAAG,yBAAyB,CAAC;QAgCxC,IAAI,CAAC,aAAa,GAAG;YACnB,QAAQ,EAAE,MAAM;YAChB,MAAM,EAAE,EAAE;SACX,CAAC;QACF,IAAI,CAAC,YAAY,GAAG,EAAE,gBAAgB,EAAE,EAAE,EAAE,CAAC;QAC7C,IAAI,CAAC,UAAU,EAAE,CAAC;QAClB,mBAAmB,CAAC,CAAC,EAAE,MAAM,EAAE,cAAc,EAAE,EAAE,EAAE;YACjD,IAAI,CAAC,SAAS,CAAC,EAAE,MAAM,EAAE,CAAC,GAAG,MAAM,EAAE,GAAG,cAAc,CAAC,EAAE,CAAC,CAAC;YAC3D,IAAI,CAAC,cAAc,EAAE,CAAC;QACxB,CAAC,CAAC,CAAC;QACH,IAAI,CAAC,kBAAkB,GAAG,kBAAkB,CAAC;QAC7C,IAAI,CAAC,iBAAiB,GAAG,iBAAiB,CAAC;QAC3C,IAAI,CAAC,IAAI,EAAE,CAAC;IACd,CAAC;IAED;;;;OAIG;IACG,IAAI,CAAC,QAAiB;;YAC1B,QAAQ,IAAI,IAAI,CAAC,SAAS,CAAC,EAAE,QAAQ,EAAE,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;YACvD,IAAI,CAAC,MAAM,IAAI,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YACzC,MAAM,IAAA,gCAAa,EAAC,GAAG,EAAE,CAAC,IAAI,CAAC,cAAc,EAAE,CAAC,CAAC;YACjD,IAAI,CAAC,MAAM,GAAG,UAAU,CAAC,GAAG,EAAE;gBAC5B,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;YAClC,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;QAC3B,CAAC;KAAA;IAED;;OAEG;IACG,cAAc;;YAClB,IAAI,IAAI,CAAC,QAAQ,EAAE;gBACjB,OAAO;aACR;YACD,MAAM,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC;YAC/B,MAAM,mBAAmB,GAA8B,EAAE,CAAC;YAC1D,KAAK,MAAM,KAAK,IAAI,MAAM,EAAE;gBAC1B,MAAM,EAAE,OAAO,EAAE,GAAG,KAAK,CAAC;gBAC1B,IAAI;oBACF,mBAAmB,CAAC,OAAO,CAAC,GAAG,MAAM,IAAI,CAAC,iBAAiB,CACzD,OAAO,EACP,IAAI,CAAC,kBAAkB,EAAE,CAC1B,CAAC;oBACF,KAAK,CAAC,YAAY,GAAG,IAAI,CAAC;iBAC3B;gBAAC,OAAO,KAAK,EAAE;oBACd,mBAAmB,CAAC,OAAO,CAAC,GAAG,IAAI,oBAAE,CAAC,CAAC,CAAC,CAAC;oBACzC,KAAK,CAAC,YAAY,GAAG,KAAK,CAAC;iBAC5B;aACF;YACD,IAAI,CAAC,MAAM,CAAC,EAAE,gBAAgB,EAAE,mBAAmB,EAAE,CAAC,CAAC;QACzD,CAAC;KAAA;CACF;AA9FD,0DA8FC;AAED,kBAAe,uBAAuB,CAAC","sourcesContent":["import type { BaseConfig, BaseState } from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport { safelyExecute } from '@metamask/controller-utils';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport { BN } from 'ethereumjs-util';\n\nimport type { AssetsContractController } from './AssetsContractController';\nimport type { Token } from './TokenRatesController';\nimport type { TokensState } from './TokensController';\n\n// TODO: Remove this export in the next major release\nexport { BN };\n\n/**\n * @type TokenBalancesConfig\n *\n * Token balances controller configuration\n * @property interval - Polling interval used to fetch new token balances\n * @property tokens - List of tokens to track balances for\n */\nexport interface TokenBalancesConfig extends BaseConfig {\n  interval: number;\n  tokens: Token[];\n}\n\n/**\n * @type TokenBalancesState\n *\n * Token balances controller state\n * @property contractBalances - Hash of token contract addresses to balances\n */\nexport interface TokenBalancesState extends BaseState {\n  contractBalances: { [address: string]: BN };\n}\n\n/**\n * Controller that passively polls on a set interval token balances\n * for tokens stored in the TokensController\n */\nexport class TokenBalancesController extends BaseController<\n  TokenBalancesConfig,\n  TokenBalancesState\n> {\n  private handle?: ReturnType<typeof setTimeout>;\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'TokenBalancesController';\n\n  private readonly getSelectedAddress: () => PreferencesState['selectedAddress'];\n\n  private readonly getERC20BalanceOf: AssetsContractController['getERC20BalanceOf'];\n\n  /**\n   * Creates a TokenBalancesController instance.\n   *\n   * @param options - The controller options.\n   * @param options.onTokensStateChange - Allows subscribing to assets controller state changes.\n   * @param options.getSelectedAddress - Gets the current selected address.\n   * @param options.getERC20BalanceOf - Gets the balance of the given account at the given contract address.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      onTokensStateChange,\n      getSelectedAddress,\n      getERC20BalanceOf,\n    }: {\n      onTokensStateChange: (\n        listener: (tokenState: TokensState) => void,\n      ) => void;\n      getSelectedAddress: () => PreferencesState['selectedAddress'];\n      getERC20BalanceOf: AssetsContractController['getERC20BalanceOf'];\n    },\n    config?: Partial<TokenBalancesConfig>,\n    state?: Partial<TokenBalancesState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      interval: 180000,\n      tokens: [],\n    };\n    this.defaultState = { contractBalances: {} };\n    this.initialize();\n    onTokensStateChange(({ tokens, detectedTokens }) => {\n      this.configure({ tokens: [...tokens, ...detectedTokens] });\n      this.updateBalances();\n    });\n    this.getSelectedAddress = getSelectedAddress;\n    this.getERC20BalanceOf = getERC20BalanceOf;\n    this.poll();\n  }\n\n  /**\n   * Starts a new polling interval.\n   *\n   * @param interval - Polling interval used to fetch new token balances.\n   */\n  async poll(interval?: number): Promise<void> {\n    interval && this.configure({ interval }, false, false);\n    this.handle && clearTimeout(this.handle);\n    await safelyExecute(() => this.updateBalances());\n    this.handle = setTimeout(() => {\n      this.poll(this.config.interval);\n    }, this.config.interval);\n  }\n\n  /**\n   * Updates balances for all tokens.\n   */\n  async updateBalances() {\n    if (this.disabled) {\n      return;\n    }\n    const { tokens } = this.config;\n    const newContractBalances: { [address: string]: BN } = {};\n    for (const token of tokens) {\n      const { address } = token;\n      try {\n        newContractBalances[address] = await this.getERC20BalanceOf(\n          address,\n          this.getSelectedAddress(),\n        );\n        token.balanceError = null;\n      } catch (error) {\n        newContractBalances[address] = new BN(0);\n        token.balanceError = error;\n      }\n    }\n    this.update({ contractBalances: newContractBalances });\n  }\n}\n\nexport default TokenBalancesController;\n"]}
\ No newline at end of file
+{"version":3,"file":"TokenBalancesController.js","sourceRoot":"","sources":["../src/TokenBalancesController.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,qDAAqC;AAa5B,mFAbA,oBAAE,OAaA;AAZX,+DAImC;AACnC,iEAA2D;AA+B3D;;;GAGG;AACH,MAAa,uBAAwB,SAAQ,gCAG5C;IAYC;;;;;;;;;OASG;IACH,YACE,EACE,mBAAmB,EACnB,kBAAkB,EAClB,iBAAiB,GAOlB,EACD,MAAqC,EACrC,KAAmC;QAEnC,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;QAlCvB;;WAEG;QACM,SAAI,GAAG,yBAAyB,CAAC;QAgCxC,IAAI,CAAC,aAAa,GAAG;YACnB,QAAQ,EAAE,MAAM;YAChB,MAAM,EAAE,EAAE;SACX,CAAC;QACF,IAAI,CAAC,YAAY,GAAG,EAAE,gBAAgB,EAAE,EAAE,EAAE,CAAC;QAC7C,IAAI,CAAC,UAAU,EAAE,CAAC;QAClB,mBAAmB,CAAC,CAAC,EAAE,MAAM,EAAE,cAAc,EAAE,EAAE,EAAE;YACjD,IAAI,CAAC,SAAS,CAAC,EAAE,MAAM,EAAE,CAAC,GAAG,MAAM,EAAE,GAAG,cAAc,CAAC,EAAE,CAAC,CAAC;YAC3D,IAAI,CAAC,cAAc,EAAE,CAAC;QACxB,CAAC,CAAC,CAAC;QACH,IAAI,CAAC,kBAAkB,GAAG,kBAAkB,CAAC;QAC7C,IAAI,CAAC,iBAAiB,GAAG,iBAAiB,CAAC;QAC3C,IAAI,CAAC,IAAI,EAAE,CAAC;IACd,CAAC;IAED;;;;OAIG;IACG,IAAI,CAAC,QAAiB;;YAC1B,QAAQ,IAAI,IAAI,CAAC,SAAS,CAAC,EAAE,QAAQ,EAAE,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;YACvD,IAAI,CAAC,MAAM,IAAI,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YACzC,MAAM,IAAA,gCAAa,EAAC,GAAG,EAAE,CAAC,IAAI,CAAC,cAAc,EAAE,CAAC,CAAC;YACjD,IAAI,CAAC,MAAM,GAAG,UAAU,CAAC,GAAG,EAAE;gBAC5B,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;YAClC,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;QAC3B,CAAC;KAAA;IAED;;OAEG;IACG,cAAc;;YAClB,IAAI,IAAI,CAAC,QAAQ,EAAE;gBACjB,OAAO;aACR;YACD,MAAM,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC;YAC/B,MAAM,mBAAmB,GAA8B,EAAE,CAAC;YAC1D,KAAK,MAAM,CAAC,IAAI,MAAM,EAAE;gBACtB,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;gBAC9B,IAAI;oBACF,mBAAmB,CAAC,OAAO,CAAC,GAAG,MAAM,IAAI,CAAC,iBAAiB,CACzD,OAAO,EACP,IAAI,CAAC,kBAAkB,EAAE,CAC1B,CAAC;oBACF,MAAM,CAAC,CAAC,CAAC,CAAC,YAAY,GAAG,IAAI,CAAC;iBAC/B;gBAAC,OAAO,KAAK,EAAE;oBACd,mBAAmB,CAAC,OAAO,CAAC,GAAG,IAAI,oBAAE,CAAC,CAAC,CAAC,CAAC;oBACzC,MAAM,CAAC,CAAC,CAAC,CAAC,YAAY,GAAG,KAAK,CAAC;iBAChC;aACF;YACD,IAAI,CAAC,MAAM,CAAC,EAAE,gBAAgB,EAAE,mBAAmB,EAAE,CAAC,CAAC;QACzD,CAAC;KAAA;CACF;AA9FD,0DA8FC;AAED,kBAAe,uBAAuB,CAAC","sourcesContent":["import { BN } from 'ethereumjs-util';\nimport {\n  BaseController,\n  BaseConfig,\n  BaseState,\n} from '@metamask/base-controller';\nimport { safelyExecute } from '@metamask/controller-utils';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport { Token } from './TokenRatesController';\nimport { TokensState } from './TokensController';\nimport type { AssetsContractController } from './AssetsContractController';\n\n// TODO: Remove this export in the next major release\nexport { BN };\n\n/**\n * @type TokenBalancesConfig\n *\n * Token balances controller configuration\n * @property interval - Polling interval used to fetch new token balances\n * @property tokens - List of tokens to track balances for\n */\nexport interface TokenBalancesConfig extends BaseConfig {\n  interval: number;\n  tokens: Token[];\n}\n\n/**\n * @type TokenBalancesState\n *\n * Token balances controller state\n * @property contractBalances - Hash of token contract addresses to balances\n */\nexport interface TokenBalancesState extends BaseState {\n  contractBalances: { [address: string]: BN };\n}\n\n/**\n * Controller that passively polls on a set interval token balances\n * for tokens stored in the TokensController\n */\nexport class TokenBalancesController extends BaseController<\n  TokenBalancesConfig,\n  TokenBalancesState\n> {\n  private handle?: ReturnType<typeof setTimeout>;\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'TokenBalancesController';\n\n  private getSelectedAddress: () => PreferencesState['selectedAddress'];\n\n  private getERC20BalanceOf: AssetsContractController['getERC20BalanceOf'];\n\n  /**\n   * Creates a TokenBalancesController instance.\n   *\n   * @param options - The controller options.\n   * @param options.onTokensStateChange - Allows subscribing to assets controller state changes.\n   * @param options.getSelectedAddress - Gets the current selected address.\n   * @param options.getERC20BalanceOf - Gets the balance of the given account at the given contract address.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      onTokensStateChange,\n      getSelectedAddress,\n      getERC20BalanceOf,\n    }: {\n      onTokensStateChange: (\n        listener: (tokenState: TokensState) => void,\n      ) => void;\n      getSelectedAddress: () => PreferencesState['selectedAddress'];\n      getERC20BalanceOf: AssetsContractController['getERC20BalanceOf'];\n    },\n    config?: Partial<TokenBalancesConfig>,\n    state?: Partial<TokenBalancesState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      interval: 180000,\n      tokens: [],\n    };\n    this.defaultState = { contractBalances: {} };\n    this.initialize();\n    onTokensStateChange(({ tokens, detectedTokens }) => {\n      this.configure({ tokens: [...tokens, ...detectedTokens] });\n      this.updateBalances();\n    });\n    this.getSelectedAddress = getSelectedAddress;\n    this.getERC20BalanceOf = getERC20BalanceOf;\n    this.poll();\n  }\n\n  /**\n   * Starts a new polling interval.\n   *\n   * @param interval - Polling interval used to fetch new token balances.\n   */\n  async poll(interval?: number): Promise<void> {\n    interval && this.configure({ interval }, false, false);\n    this.handle && clearTimeout(this.handle);\n    await safelyExecute(() => this.updateBalances());\n    this.handle = setTimeout(() => {\n      this.poll(this.config.interval);\n    }, this.config.interval);\n  }\n\n  /**\n   * Updates balances for all tokens.\n   */\n  async updateBalances() {\n    if (this.disabled) {\n      return;\n    }\n    const { tokens } = this.config;\n    const newContractBalances: { [address: string]: BN } = {};\n    for (const i in tokens) {\n      const { address } = tokens[i];\n      try {\n        newContractBalances[address] = await this.getERC20BalanceOf(\n          address,\n          this.getSelectedAddress(),\n        );\n        tokens[i].balanceError = null;\n      } catch (error) {\n        newContractBalances[address] = new BN(0);\n        tokens[i].balanceError = error;\n      }\n    }\n    this.update({ contractBalances: newContractBalances });\n  }\n}\n\nexport default TokenBalancesController;\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.d.ts b/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.d.ts
index 7e2361a..19ce677 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.d.ts
@@ -1,11 +1,10 @@
-import type { BaseConfig, BaseState } from '@metamask/base-controller';
-import type { NetworkClientId, NetworkController, NetworkState } from '@metamask/network-controller';
-import { PollingControllerV1 } from '@metamask/polling-controller';
-import type { PreferencesState } from '@metamask/preferences-controller';
 import type { Hex } from '@metamask/utils';
+import { BaseController, BaseConfig, BaseState } from '@metamask/base-controller';
+import type { NetworkState } from '@metamask/network-controller';
+import type { PreferencesState } from '@metamask/preferences-controller';
+import { TokensController, TokensState } from './TokensController';
 import type { AssetsContractController } from './AssetsContractController';
-import type { TokenListState } from './TokenListController';
-import type { TokensController, TokensState } from './TokensController';
+import { TokenListState } from './TokenListController';
 /**
  * @type TokenDetectionConfig
  *
@@ -26,17 +25,16 @@ export interface TokenDetectionConfig extends BaseConfig {
 /**
  * Controller that passively polls on a set interval for Tokens auto detection
  */
-export declare class TokenDetectionController extends PollingControllerV1<TokenDetectionConfig, BaseState> {
+export declare class TokenDetectionController extends BaseController<TokenDetectionConfig, BaseState> {
     private intervalId?;
     /**
      * Name of this controller used during composition
      */
     name: string;
-    private readonly getBalancesInSingleCall;
-    private readonly addDetectedTokens;
-    private readonly getTokensState;
-    private readonly getTokenListState;
-    private readonly getNetworkClientById;
+    private getBalancesInSingleCall;
+    private addDetectedTokens;
+    private getTokensState;
+    private getTokenListState;
     /**
      * Creates a TokenDetectionController instance.
      *
@@ -50,11 +48,10 @@ export declare class TokenDetectionController extends PollingControllerV1<TokenD
      * @param options.getTokensState - Gets the current state of the Tokens controller.
      * @param options.getNetworkState - Gets the state of the network controller.
      * @param options.getPreferencesState - Gets the state of the preferences controller.
-     * @param options.getNetworkClientById - Gets the network client by ID.
      * @param config - Initial options used to configure this controller.
      * @param state - Initial state to set on this controller.
      */
-    constructor({ onPreferencesStateChange, onNetworkStateChange, onTokenListStateChange, getBalancesInSingleCall, addDetectedTokens, getTokenListState, getTokensState, getNetworkState, getPreferencesState, getNetworkClientById, }: {
+    constructor({ onPreferencesStateChange, onNetworkStateChange, onTokenListStateChange, getBalancesInSingleCall, addDetectedTokens, getTokenListState, getTokensState, getNetworkState, getPreferencesState, }: {
         onPreferencesStateChange: (listener: (preferencesState: PreferencesState) => void) => void;
         onNetworkStateChange: (listener: (networkState: NetworkState) => void) => void;
         onTokenListStateChange: (listener: (tokenListState: TokenListState) => void) => void;
@@ -64,7 +61,6 @@ export declare class TokenDetectionController extends PollingControllerV1<TokenD
         getTokensState: () => TokensState;
         getNetworkState: () => NetworkState;
         getPreferencesState: () => PreferencesState;
-        getNetworkClientById: NetworkController['getNetworkClientById'];
     }, config?: Partial<TokenDetectionConfig>, state?: Partial<BaseState>);
     /**
      * Start polling for detected tokens.
@@ -81,21 +77,10 @@ export declare class TokenDetectionController extends PollingControllerV1<TokenD
      * @param interval - An interval on which to poll.
      */
     private startPolling;
-    private getCorrectChainId;
-    _executePoll(networkClientId: string, options: {
-        address: string;
-    }): Promise<void>;
     /**
      * Triggers asset ERC20 token auto detection for each contract address in contract metadata on mainnet.
-     *
-     * @param options - Options to detect tokens.
-     * @param options.networkClientId - The ID of the network client to use.
-     * @param options.accountAddress - The account address to use.
      */
-    detectTokens(options?: {
-        networkClientId?: NetworkClientId;
-        accountAddress?: string;
-    }): Promise<void>;
+    detectTokens(): Promise<void>;
 }
 export default TokenDetectionController;
 //# sourceMappingURL=TokenDetectionController.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.d.ts.map b/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.d.ts.map
index 2364e81..5b22dbb 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.d.ts.map
+++ b/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"TokenDetectionController.d.ts","sourceRoot":"","sources":["../src/TokenDetectionController.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,UAAU,EAAE,SAAS,EAAE,MAAM,2BAA2B,CAAC;AAKvE,OAAO,KAAK,EACV,eAAe,EACf,iBAAiB,EACjB,YAAY,EACb,MAAM,8BAA8B,CAAC;AACtC,OAAO,EAAE,mBAAmB,EAAE,MAAM,8BAA8B,CAAC;AACnE,OAAO,KAAK,EAAE,gBAAgB,EAAE,MAAM,kCAAkC,CAAC;AACzE,OAAO,KAAK,EAAE,GAAG,EAAE,MAAM,iBAAiB,CAAC;AAE3C,OAAO,KAAK,EAAE,wBAAwB,EAAE,MAAM,4BAA4B,CAAC;AAE3E,OAAO,KAAK,EAAE,cAAc,EAAE,MAAM,uBAAuB,CAAC;AAE5D,OAAO,KAAK,EAAE,gBAAgB,EAAE,WAAW,EAAE,MAAM,oBAAoB,CAAC;AAIxE;;;;;;;;;GASG;AACH,MAAM,WAAW,oBAAqB,SAAQ,UAAU;IACtD,QAAQ,EAAE,MAAM,CAAC;IACjB,eAAe,EAAE,MAAM,CAAC;IACxB,OAAO,EAAE,GAAG,CAAC;IACb,iCAAiC,EAAE,OAAO,CAAC;IAC3C,4BAA4B,EAAE,OAAO,CAAC;CACvC;AAED;;GAEG;AACH,qBAAa,wBAAyB,SAAQ,mBAAmB,CAC/D,oBAAoB,EACpB,SAAS,CACV;IACC,OAAO,CAAC,UAAU,CAAC,CAAgC;IAEnD;;OAEG;IACM,IAAI,SAA8B;IAE3C,OAAO,CAAC,QAAQ,CAAC,uBAAuB,CAAsD;IAE9F,OAAO,CAAC,QAAQ,CAAC,iBAAiB,CAAwC;IAE1E,OAAO,CAAC,QAAQ,CAAC,cAAc,CAAoB;IAEnD,OAAO,CAAC,QAAQ,CAAC,iBAAiB,CAAuB;IAEzD,OAAO,CAAC,QAAQ,CAAC,oBAAoB,CAA4C;IAEjF;;;;;;;;;;;;;;;;OAgBG;gBAED,EACE,wBAAwB,EACxB,oBAAoB,EACpB,sBAAsB,EACtB,uBAAuB,EACvB,iBAAiB,EACjB,iBAAiB,EACjB,cAAc,EACd,eAAe,EACf,mBAAmB,EACnB,oBAAoB,GACrB,EAAE;QACD,wBAAwB,EAAE,CACxB,QAAQ,EAAE,CAAC,gBAAgB,EAAE,gBAAgB,KAAK,IAAI,KACnD,IAAI,CAAC;QACV,oBAAoB,EAAE,CACpB,QAAQ,EAAE,CAAC,YAAY,EAAE,YAAY,KAAK,IAAI,KAC3C,IAAI,CAAC;QACV,sBAAsB,EAAE,CACtB,QAAQ,EAAE,CAAC,cAAc,EAAE,cAAc,KAAK,IAAI,KAC/C,IAAI,CAAC;QACV,uBAAuB,EAAE,wBAAwB,CAAC,yBAAyB,CAAC,CAAC;QAC7E,iBAAiB,EAAE,gBAAgB,CAAC,mBAAmB,CAAC,CAAC;QACzD,iBAAiB,EAAE,MAAM,cAAc,CAAC;QACxC,cAAc,EAAE,MAAM,WAAW,CAAC;QAClC,eAAe,EAAE,MAAM,YAAY,CAAC;QACpC,mBAAmB,EAAE,MAAM,gBAAgB,CAAC;QAC5C,oBAAoB,EAAE,iBAAiB,CAAC,sBAAsB,CAAC,CAAC;KACjE,EACD,MAAM,CAAC,EAAE,OAAO,CAAC,oBAAoB,CAAC,EACtC,KAAK,CAAC,EAAE,OAAO,CAAC,SAAS,CAAC;IA2E5B;;OAEG;IACG,KAAK;IAKX;;OAEG;IACH,IAAI;IAKJ,OAAO,CAAC,WAAW;IAMnB;;;;OAIG;YACW,YAAY;IAS1B,OAAO,CAAC,iBAAiB;IAOzB,YAAY,CACV,eAAe,EAAE,MAAM,EACvB,OAAO,EAAE;QAAE,OAAO,EAAE,MAAM,CAAA;KAAE,GAC3B,OAAO,CAAC,IAAI,CAAC;IAOhB;;;;;;OAMG;IACG,YAAY,CAAC,OAAO,CAAC,EAAE;QAC3B,eAAe,CAAC,EAAE,eAAe,CAAC;QAClC,cAAc,CAAC,EAAE,MAAM,CAAC;KACzB;CA0FF;AAED,eAAe,wBAAwB,CAAC"}
\ No newline at end of file
+{"version":3,"file":"TokenDetectionController.d.ts","sourceRoot":"","sources":["../src/TokenDetectionController.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,GAAG,EAAE,MAAM,iBAAiB,CAAC;AAC3C,OAAO,EACL,cAAc,EACd,UAAU,EACV,SAAS,EACV,MAAM,2BAA2B,CAAC;AACnC,OAAO,KAAK,EAAE,YAAY,EAAE,MAAM,8BAA8B,CAAC;AACjE,OAAO,KAAK,EAAE,gBAAgB,EAAE,MAAM,kCAAkC,CAAC;AAMzE,OAAO,EAAE,gBAAgB,EAAE,WAAW,EAAE,MAAM,oBAAoB,CAAC;AACnE,OAAO,KAAK,EAAE,wBAAwB,EAAE,MAAM,4BAA4B,CAAC;AAE3E,OAAO,EAAE,cAAc,EAAE,MAAM,uBAAuB,CAAC;AAIvD;;;;;;;;;GASG;AACH,MAAM,WAAW,oBAAqB,SAAQ,UAAU;IACtD,QAAQ,EAAE,MAAM,CAAC;IACjB,eAAe,EAAE,MAAM,CAAC;IACxB,OAAO,EAAE,GAAG,CAAC;IACb,iCAAiC,EAAE,OAAO,CAAC;IAC3C,4BAA4B,EAAE,OAAO,CAAC;CACvC;AAED;;GAEG;AACH,qBAAa,wBAAyB,SAAQ,cAAc,CAC1D,oBAAoB,EACpB,SAAS,CACV;IACC,OAAO,CAAC,UAAU,CAAC,CAAgC;IAEnD;;OAEG;IACM,IAAI,SAA8B;IAE3C,OAAO,CAAC,uBAAuB,CAAsD;IAErF,OAAO,CAAC,iBAAiB,CAAwC;IAEjE,OAAO,CAAC,cAAc,CAAoB;IAE1C,OAAO,CAAC,iBAAiB,CAAuB;IAEhD;;;;;;;;;;;;;;;OAeG;gBAED,EACE,wBAAwB,EACxB,oBAAoB,EACpB,sBAAsB,EACtB,uBAAuB,EACvB,iBAAiB,EACjB,iBAAiB,EACjB,cAAc,EACd,eAAe,EACf,mBAAmB,GACpB,EAAE;QACD,wBAAwB,EAAE,CACxB,QAAQ,EAAE,CAAC,gBAAgB,EAAE,gBAAgB,KAAK,IAAI,KACnD,IAAI,CAAC;QACV,oBAAoB,EAAE,CACpB,QAAQ,EAAE,CAAC,YAAY,EAAE,YAAY,KAAK,IAAI,KAC3C,IAAI,CAAC;QACV,sBAAsB,EAAE,CACtB,QAAQ,EAAE,CAAC,cAAc,EAAE,cAAc,KAAK,IAAI,KAC/C,IAAI,CAAC;QACV,uBAAuB,EAAE,wBAAwB,CAAC,yBAAyB,CAAC,CAAC;QAC7E,iBAAiB,EAAE,gBAAgB,CAAC,mBAAmB,CAAC,CAAC;QACzD,iBAAiB,EAAE,MAAM,cAAc,CAAC;QACxC,cAAc,EAAE,MAAM,WAAW,CAAC;QAClC,eAAe,EAAE,MAAM,YAAY,CAAC;QACpC,mBAAmB,EAAE,MAAM,gBAAgB,CAAC;KAC7C,EACD,MAAM,CAAC,EAAE,OAAO,CAAC,oBAAoB,CAAC,EACtC,KAAK,CAAC,EAAE,OAAO,CAAC,SAAS,CAAC;IA0E5B;;OAEG;IACG,KAAK;IAKX;;OAEG;IACH,IAAI;IAKJ,OAAO,CAAC,WAAW;IAMnB;;;;OAIG;YACW,YAAY;IAS1B;;OAEG;IACG,YAAY;CAwFnB;AAED,eAAe,wBAAwB,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.js b/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.js
index 4071e8c..0fa2aac 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.js
+++ b/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.js
@@ -10,14 +10,14 @@ var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, ge
 };
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.TokenDetectionController = void 0;
+const base_controller_1 = require("@metamask/base-controller");
 const controller_utils_1 = require("@metamask/controller-utils");
-const polling_controller_1 = require("@metamask/polling-controller");
 const assetsUtil_1 = require("./assetsUtil");
 const DEFAULT_INTERVAL = 180000;
 /**
  * Controller that passively polls on a set interval for Tokens auto detection
  */
-class TokenDetectionController extends polling_controller_1.PollingControllerV1 {
+class TokenDetectionController extends base_controller_1.BaseController {
     /**
      * Creates a TokenDetectionController instance.
      *
@@ -31,11 +31,10 @@ class TokenDetectionController extends polling_controller_1.PollingControllerV1
      * @param options.getTokensState - Gets the current state of the Tokens controller.
      * @param options.getNetworkState - Gets the state of the network controller.
      * @param options.getPreferencesState - Gets the state of the preferences controller.
-     * @param options.getNetworkClientById - Gets the network client by ID.
      * @param config - Initial options used to configure this controller.
      * @param state - Initial state to set on this controller.
      */
-    constructor({ onPreferencesStateChange, onNetworkStateChange, onTokenListStateChange, getBalancesInSingleCall, addDetectedTokens, getTokenListState, getTokensState, getNetworkState, getPreferencesState, getNetworkClientById, }, config, state) {
+    constructor({ onPreferencesStateChange, onNetworkStateChange, onTokenListStateChange, getBalancesInSingleCall, addDetectedTokens, getTokenListState, getTokensState, getNetworkState, getPreferencesState, }, config, state) {
         const { providerConfig: { chainId: defaultChainId }, } = getNetworkState();
         const { useTokenDetection: defaultUseTokenDetection } = getPreferencesState();
         super(config, state);
@@ -49,7 +48,6 @@ class TokenDetectionController extends polling_controller_1.PollingControllerV1
         this.getTokenListState = getTokenListState;
         this.addDetectedTokens = addDetectedTokens;
         this.getBalancesInSingleCall = getBalancesInSingleCall;
-        this.getNetworkClientById = getNetworkClientById;
         onTokenListStateChange(({ tokenList }) => {
             const hasTokens = Object.keys(tokenList).length;
             if (hasTokens) {
@@ -118,28 +116,11 @@ class TokenDetectionController extends polling_controller_1.PollingControllerV1
             }), this.config.interval);
         });
     }
-    getCorrectChainId(networkClientId) {
-        if (networkClientId) {
-            return this.getNetworkClientById(networkClientId).configuration.chainId;
-        }
-        return this.config.chainId;
-    }
-    _executePoll(networkClientId, options) {
-        return this.detectTokens({
-            networkClientId,
-            accountAddress: options.address,
-        });
-    }
     /**
      * Triggers asset ERC20 token auto detection for each contract address in contract metadata on mainnet.
-     *
-     * @param options - Options to detect tokens.
-     * @param options.networkClientId - The ID of the network client to use.
-     * @param options.accountAddress - The account address to use.
      */
-    detectTokens(options) {
+    detectTokens() {
         return __awaiter(this, void 0, void 0, function* () {
-            const { networkClientId, accountAddress } = options || {};
             const { disabled, isDetectionEnabledForNetwork, isDetectionEnabledFromPreferences, } = this.config;
             if (disabled ||
                 !isDetectionEnabledForNetwork ||
@@ -147,13 +128,12 @@ class TokenDetectionController extends polling_controller_1.PollingControllerV1
                 return;
             }
             const { tokens } = this.getTokensState();
-            const selectedAddress = accountAddress || this.config.selectedAddress;
-            const chainId = this.getCorrectChainId(networkClientId);
+            const { selectedAddress, chainId } = this.config;
             const tokensAddresses = tokens.map(
             /* istanbul ignore next*/ (token) => token.address.toLowerCase());
             const { tokenList } = this.getTokenListState();
             const tokensToDetect = [];
-            for (const address of Object.keys(tokenList)) {
+            for (const address in tokenList) {
                 if (!tokensAddresses.includes(address)) {
                     tokensToDetect.push(address);
                 }
@@ -172,7 +152,7 @@ class TokenDetectionController extends polling_controller_1.PollingControllerV1
                 yield (0, controller_utils_1.safelyExecute)(() => __awaiter(this, void 0, void 0, function* () {
                     const balances = yield this.getBalancesInSingleCall(selectedAddress, tokensSlice);
                     const tokensToAdd = [];
-                    for (const tokenAddress of Object.keys(balances)) {
+                    for (const tokenAddress in balances) {
                         let ignored;
                         /* istanbul ignore else */
                         const { ignoredTokens } = this.getTokensState();
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.js.map b/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.js.map
index 25a17fe..402d52b 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.js.map
+++ b/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.js.map
@@ -1 +1 @@
-{"version":3,"file":"TokenDetectionController.js","sourceRoot":"","sources":["../src/TokenDetectionController.ts"],"names":[],"mappings":"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","sourcesContent":["import type { BaseConfig, BaseState } from '@metamask/base-controller';\nimport {\n  safelyExecute,\n  toChecksumHexAddress,\n} from '@metamask/controller-utils';\nimport type {\n  NetworkClientId,\n  NetworkController,\n  NetworkState,\n} from '@metamask/network-controller';\nimport { PollingControllerV1 } from '@metamask/polling-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport type { Hex } from '@metamask/utils';\n\nimport type { AssetsContractController } from './AssetsContractController';\nimport { isTokenDetectionSupportedForNetwork } from './assetsUtil';\nimport type { TokenListState } from './TokenListController';\nimport type { Token } from './TokenRatesController';\nimport type { TokensController, TokensState } from './TokensController';\n\nconst DEFAULT_INTERVAL = 180000;\n\n/**\n * @type TokenDetectionConfig\n *\n * TokenDetection configuration\n * @property interval - Polling interval used to fetch new token rates\n * @property selectedAddress - Vault selected address\n * @property chainId - The chain ID of the current network\n * @property isDetectionEnabledFromPreferences - Boolean to track if detection is enabled from PreferencesController\n * @property isDetectionEnabledForNetwork - Boolean to track if detected is enabled for current network\n */\nexport interface TokenDetectionConfig extends BaseConfig {\n  interval: number;\n  selectedAddress: string;\n  chainId: Hex;\n  isDetectionEnabledFromPreferences: boolean;\n  isDetectionEnabledForNetwork: boolean;\n}\n\n/**\n * Controller that passively polls on a set interval for Tokens auto detection\n */\nexport class TokenDetectionController extends PollingControllerV1<\n  TokenDetectionConfig,\n  BaseState\n> {\n  private intervalId?: ReturnType<typeof setTimeout>;\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'TokenDetectionController';\n\n  private readonly getBalancesInSingleCall: AssetsContractController['getBalancesInSingleCall'];\n\n  private readonly addDetectedTokens: TokensController['addDetectedTokens'];\n\n  private readonly getTokensState: () => TokensState;\n\n  private readonly getTokenListState: () => TokenListState;\n\n  private readonly getNetworkClientById: NetworkController['getNetworkClientById'];\n\n  /**\n   * Creates a TokenDetectionController instance.\n   *\n   * @param options - The controller options.\n   * @param options.onPreferencesStateChange - Allows subscribing to preferences controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param options.onTokenListStateChange - Allows subscribing to token list controller state changes.\n   * @param options.getBalancesInSingleCall - Gets the balances of a list of tokens for the given address.\n   * @param options.addDetectedTokens - Add a list of detected tokens.\n   * @param options.getTokenListState - Gets the current state of the TokenList controller.\n   * @param options.getTokensState - Gets the current state of the Tokens controller.\n   * @param options.getNetworkState - Gets the state of the network controller.\n   * @param options.getPreferencesState - Gets the state of the preferences controller.\n   * @param options.getNetworkClientById - Gets the network client by ID.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      onPreferencesStateChange,\n      onNetworkStateChange,\n      onTokenListStateChange,\n      getBalancesInSingleCall,\n      addDetectedTokens,\n      getTokenListState,\n      getTokensState,\n      getNetworkState,\n      getPreferencesState,\n      getNetworkClientById,\n    }: {\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      onTokenListStateChange: (\n        listener: (tokenListState: TokenListState) => void,\n      ) => void;\n      getBalancesInSingleCall: AssetsContractController['getBalancesInSingleCall'];\n      addDetectedTokens: TokensController['addDetectedTokens'];\n      getTokenListState: () => TokenListState;\n      getTokensState: () => TokensState;\n      getNetworkState: () => NetworkState;\n      getPreferencesState: () => PreferencesState;\n      getNetworkClientById: NetworkController['getNetworkClientById'];\n    },\n    config?: Partial<TokenDetectionConfig>,\n    state?: Partial<BaseState>,\n  ) {\n    const {\n      providerConfig: { chainId: defaultChainId },\n    } = getNetworkState();\n    const { useTokenDetection: defaultUseTokenDetection } =\n      getPreferencesState();\n\n    super(config, state);\n    this.defaultConfig = {\n      interval: DEFAULT_INTERVAL,\n      selectedAddress: '',\n      disabled: true,\n      chainId: defaultChainId,\n      isDetectionEnabledFromPreferences: defaultUseTokenDetection,\n      isDetectionEnabledForNetwork:\n        isTokenDetectionSupportedForNetwork(defaultChainId),\n      ...config,\n    };\n\n    this.initialize();\n    this.getTokensState = getTokensState;\n    this.getTokenListState = getTokenListState;\n    this.addDetectedTokens = addDetectedTokens;\n    this.getBalancesInSingleCall = getBalancesInSingleCall;\n    this.getNetworkClientById = getNetworkClientById;\n\n    onTokenListStateChange(({ tokenList }) => {\n      const hasTokens = Object.keys(tokenList).length;\n\n      if (hasTokens) {\n        this.detectTokens();\n      }\n    });\n\n    onPreferencesStateChange(({ selectedAddress, useTokenDetection }) => {\n      const {\n        selectedAddress: currentSelectedAddress,\n        isDetectionEnabledFromPreferences,\n      } = this.config;\n      const isSelectedAddressChanged =\n        selectedAddress !== currentSelectedAddress;\n      const isDetectionChangedFromPreferences =\n        isDetectionEnabledFromPreferences !== useTokenDetection;\n\n      this.configure({\n        isDetectionEnabledFromPreferences: useTokenDetection,\n        selectedAddress,\n      });\n\n      if (\n        useTokenDetection &&\n        (isSelectedAddressChanged || isDetectionChangedFromPreferences)\n      ) {\n        this.detectTokens();\n      }\n    });\n\n    onNetworkStateChange(({ providerConfig: { chainId } }) => {\n      const { chainId: currentChainId } = this.config;\n      const isDetectionEnabledForNetwork =\n        isTokenDetectionSupportedForNetwork(chainId);\n      const isChainIdChanged = currentChainId !== chainId;\n\n      this.configure({\n        chainId,\n        isDetectionEnabledForNetwork,\n      });\n\n      if (isDetectionEnabledForNetwork && isChainIdChanged) {\n        this.detectTokens();\n      }\n    });\n  }\n\n  /**\n   * Start polling for detected tokens.\n   */\n  async start() {\n    this.configure({ disabled: false });\n    await this.startPolling();\n  }\n\n  /**\n   * Stop polling for detected tokens.\n   */\n  stop() {\n    this.configure({ disabled: true });\n    this.stopPolling();\n  }\n\n  private stopPolling() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n  }\n\n  /**\n   * Starts a new polling interval.\n   *\n   * @param interval - An interval on which to poll.\n   */\n  private async startPolling(interval?: number): Promise<void> {\n    interval && this.configure({ interval }, false, false);\n    this.stopPolling();\n    await this.detectTokens();\n    this.intervalId = setInterval(async () => {\n      await this.detectTokens();\n    }, this.config.interval);\n  }\n\n  private getCorrectChainId(networkClientId?: NetworkClientId) {\n    if (networkClientId) {\n      return this.getNetworkClientById(networkClientId).configuration.chainId;\n    }\n    return this.config.chainId;\n  }\n\n  _executePoll(\n    networkClientId: string,\n    options: { address: string },\n  ): Promise<void> {\n    return this.detectTokens({\n      networkClientId,\n      accountAddress: options.address,\n    });\n  }\n\n  /**\n   * Triggers asset ERC20 token auto detection for each contract address in contract metadata on mainnet.\n   *\n   * @param options - Options to detect tokens.\n   * @param options.networkClientId - The ID of the network client to use.\n   * @param options.accountAddress - The account address to use.\n   */\n  async detectTokens(options?: {\n    networkClientId?: NetworkClientId;\n    accountAddress?: string;\n  }) {\n    const { networkClientId, accountAddress } = options || {};\n    const {\n      disabled,\n      isDetectionEnabledForNetwork,\n      isDetectionEnabledFromPreferences,\n    } = this.config;\n    if (\n      disabled ||\n      !isDetectionEnabledForNetwork ||\n      !isDetectionEnabledFromPreferences\n    ) {\n      return;\n    }\n    const { tokens } = this.getTokensState();\n    const selectedAddress = accountAddress || this.config.selectedAddress;\n    const chainId = this.getCorrectChainId(networkClientId);\n\n    const tokensAddresses = tokens.map(\n      /* istanbul ignore next*/ (token) => token.address.toLowerCase(),\n    );\n    const { tokenList } = this.getTokenListState();\n    const tokensToDetect: string[] = [];\n    for (const address of Object.keys(tokenList)) {\n      if (!tokensAddresses.includes(address)) {\n        tokensToDetect.push(address);\n      }\n    }\n    const sliceOfTokensToDetect = [];\n    sliceOfTokensToDetect[0] = tokensToDetect.slice(0, 1000);\n    sliceOfTokensToDetect[1] = tokensToDetect.slice(\n      1000,\n      tokensToDetect.length - 1,\n    );\n\n    /* istanbul ignore else */\n    if (!selectedAddress) {\n      return;\n    }\n\n    for (const tokensSlice of sliceOfTokensToDetect) {\n      if (tokensSlice.length === 0) {\n        break;\n      }\n\n      await safelyExecute(async () => {\n        const balances = await this.getBalancesInSingleCall(\n          selectedAddress,\n          tokensSlice,\n        );\n        const tokensToAdd: Token[] = [];\n        for (const tokenAddress of Object.keys(balances)) {\n          let ignored;\n          /* istanbul ignore else */\n          const { ignoredTokens } = this.getTokensState();\n          if (ignoredTokens.length) {\n            ignored = ignoredTokens.find(\n              (ignoredTokenAddress) =>\n                ignoredTokenAddress === toChecksumHexAddress(tokenAddress),\n            );\n          }\n          const caseInsensitiveTokenKey =\n            Object.keys(tokenList).find(\n              (i) => i.toLowerCase() === tokenAddress.toLowerCase(),\n            ) || '';\n\n          if (ignored === undefined) {\n            const { decimals, symbol, aggregators, iconUrl, name } =\n              tokenList[caseInsensitiveTokenKey];\n            tokensToAdd.push({\n              address: tokenAddress,\n              decimals,\n              symbol,\n              aggregators,\n              image: iconUrl,\n              isERC721: false,\n              name,\n            });\n          }\n        }\n\n        if (tokensToAdd.length) {\n          await this.addDetectedTokens(tokensToAdd, {\n            selectedAddress,\n            chainId,\n          });\n        }\n      });\n    }\n  }\n}\n\nexport default TokenDetectionController;\n"]}
\ No newline at end of file
+{"version":3,"file":"TokenDetectionController.js","sourceRoot":"","sources":["../src/TokenDetectionController.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Hex } from '@metamask/utils';\nimport {\n  BaseController,\n  BaseConfig,\n  BaseState,\n} from '@metamask/base-controller';\nimport type { NetworkState } from '@metamask/network-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport {\n  safelyExecute,\n  toChecksumHexAddress,\n} from '@metamask/controller-utils';\nimport { isTokenDetectionSupportedForNetwork } from './assetsUtil';\nimport { TokensController, TokensState } from './TokensController';\nimport type { AssetsContractController } from './AssetsContractController';\nimport { Token } from './TokenRatesController';\nimport { TokenListState } from './TokenListController';\n\nconst DEFAULT_INTERVAL = 180000;\n\n/**\n * @type TokenDetectionConfig\n *\n * TokenDetection configuration\n * @property interval - Polling interval used to fetch new token rates\n * @property selectedAddress - Vault selected address\n * @property chainId - The chain ID of the current network\n * @property isDetectionEnabledFromPreferences - Boolean to track if detection is enabled from PreferencesController\n * @property isDetectionEnabledForNetwork - Boolean to track if detected is enabled for current network\n */\nexport interface TokenDetectionConfig extends BaseConfig {\n  interval: number;\n  selectedAddress: string;\n  chainId: Hex;\n  isDetectionEnabledFromPreferences: boolean;\n  isDetectionEnabledForNetwork: boolean;\n}\n\n/**\n * Controller that passively polls on a set interval for Tokens auto detection\n */\nexport class TokenDetectionController extends BaseController<\n  TokenDetectionConfig,\n  BaseState\n> {\n  private intervalId?: ReturnType<typeof setTimeout>;\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'TokenDetectionController';\n\n  private getBalancesInSingleCall: AssetsContractController['getBalancesInSingleCall'];\n\n  private addDetectedTokens: TokensController['addDetectedTokens'];\n\n  private getTokensState: () => TokensState;\n\n  private getTokenListState: () => TokenListState;\n\n  /**\n   * Creates a TokenDetectionController instance.\n   *\n   * @param options - The controller options.\n   * @param options.onPreferencesStateChange - Allows subscribing to preferences controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param options.onTokenListStateChange - Allows subscribing to token list controller state changes.\n   * @param options.getBalancesInSingleCall - Gets the balances of a list of tokens for the given address.\n   * @param options.addDetectedTokens - Add a list of detected tokens.\n   * @param options.getTokenListState - Gets the current state of the TokenList controller.\n   * @param options.getTokensState - Gets the current state of the Tokens controller.\n   * @param options.getNetworkState - Gets the state of the network controller.\n   * @param options.getPreferencesState - Gets the state of the preferences controller.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      onPreferencesStateChange,\n      onNetworkStateChange,\n      onTokenListStateChange,\n      getBalancesInSingleCall,\n      addDetectedTokens,\n      getTokenListState,\n      getTokensState,\n      getNetworkState,\n      getPreferencesState,\n    }: {\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      onTokenListStateChange: (\n        listener: (tokenListState: TokenListState) => void,\n      ) => void;\n      getBalancesInSingleCall: AssetsContractController['getBalancesInSingleCall'];\n      addDetectedTokens: TokensController['addDetectedTokens'];\n      getTokenListState: () => TokenListState;\n      getTokensState: () => TokensState;\n      getNetworkState: () => NetworkState;\n      getPreferencesState: () => PreferencesState;\n    },\n    config?: Partial<TokenDetectionConfig>,\n    state?: Partial<BaseState>,\n  ) {\n    const {\n      providerConfig: { chainId: defaultChainId },\n    } = getNetworkState();\n    const { useTokenDetection: defaultUseTokenDetection } =\n      getPreferencesState();\n\n    super(config, state);\n    this.defaultConfig = {\n      interval: DEFAULT_INTERVAL,\n      selectedAddress: '',\n      disabled: true,\n      chainId: defaultChainId,\n      isDetectionEnabledFromPreferences: defaultUseTokenDetection,\n      isDetectionEnabledForNetwork:\n        isTokenDetectionSupportedForNetwork(defaultChainId),\n      ...config,\n    };\n\n    this.initialize();\n    this.getTokensState = getTokensState;\n    this.getTokenListState = getTokenListState;\n    this.addDetectedTokens = addDetectedTokens;\n    this.getBalancesInSingleCall = getBalancesInSingleCall;\n\n    onTokenListStateChange(({ tokenList }) => {\n      const hasTokens = Object.keys(tokenList).length;\n\n      if (hasTokens) {\n        this.detectTokens();\n      }\n    });\n\n    onPreferencesStateChange(({ selectedAddress, useTokenDetection }) => {\n      const {\n        selectedAddress: currentSelectedAddress,\n        isDetectionEnabledFromPreferences,\n      } = this.config;\n      const isSelectedAddressChanged =\n        selectedAddress !== currentSelectedAddress;\n      const isDetectionChangedFromPreferences =\n        isDetectionEnabledFromPreferences !== useTokenDetection;\n\n      this.configure({\n        isDetectionEnabledFromPreferences: useTokenDetection,\n        selectedAddress,\n      });\n\n      if (\n        useTokenDetection &&\n        (isSelectedAddressChanged || isDetectionChangedFromPreferences)\n      ) {\n        this.detectTokens();\n      }\n    });\n\n    onNetworkStateChange(({ providerConfig: { chainId } }) => {\n      const { chainId: currentChainId } = this.config;\n      const isDetectionEnabledForNetwork =\n        isTokenDetectionSupportedForNetwork(chainId);\n      const isChainIdChanged = currentChainId !== chainId;\n\n      this.configure({\n        chainId,\n        isDetectionEnabledForNetwork,\n      });\n\n      if (isDetectionEnabledForNetwork && isChainIdChanged) {\n        this.detectTokens();\n      }\n    });\n  }\n\n  /**\n   * Start polling for detected tokens.\n   */\n  async start() {\n    this.configure({ disabled: false });\n    await this.startPolling();\n  }\n\n  /**\n   * Stop polling for detected tokens.\n   */\n  stop() {\n    this.configure({ disabled: true });\n    this.stopPolling();\n  }\n\n  private stopPolling() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n  }\n\n  /**\n   * Starts a new polling interval.\n   *\n   * @param interval - An interval on which to poll.\n   */\n  private async startPolling(interval?: number): Promise<void> {\n    interval && this.configure({ interval }, false, false);\n    this.stopPolling();\n    await this.detectTokens();\n    this.intervalId = setInterval(async () => {\n      await this.detectTokens();\n    }, this.config.interval);\n  }\n\n  /**\n   * Triggers asset ERC20 token auto detection for each contract address in contract metadata on mainnet.\n   */\n  async detectTokens() {\n    const {\n      disabled,\n      isDetectionEnabledForNetwork,\n      isDetectionEnabledFromPreferences,\n    } = this.config;\n    if (\n      disabled ||\n      !isDetectionEnabledForNetwork ||\n      !isDetectionEnabledFromPreferences\n    ) {\n      return;\n    }\n    const { tokens } = this.getTokensState();\n    const { selectedAddress, chainId } = this.config;\n\n    const tokensAddresses = tokens.map(\n      /* istanbul ignore next*/ (token) => token.address.toLowerCase(),\n    );\n    const { tokenList } = this.getTokenListState();\n    const tokensToDetect: string[] = [];\n    for (const address in tokenList) {\n      if (!tokensAddresses.includes(address)) {\n        tokensToDetect.push(address);\n      }\n    }\n    const sliceOfTokensToDetect = [];\n    sliceOfTokensToDetect[0] = tokensToDetect.slice(0, 1000);\n    sliceOfTokensToDetect[1] = tokensToDetect.slice(\n      1000,\n      tokensToDetect.length - 1,\n    );\n\n    /* istanbul ignore else */\n    if (!selectedAddress) {\n      return;\n    }\n\n    for (const tokensSlice of sliceOfTokensToDetect) {\n      if (tokensSlice.length === 0) {\n        break;\n      }\n\n      await safelyExecute(async () => {\n        const balances = await this.getBalancesInSingleCall(\n          selectedAddress,\n          tokensSlice,\n        );\n        const tokensToAdd: Token[] = [];\n        for (const tokenAddress in balances) {\n          let ignored;\n          /* istanbul ignore else */\n          const { ignoredTokens } = this.getTokensState();\n          if (ignoredTokens.length) {\n            ignored = ignoredTokens.find(\n              (ignoredTokenAddress) =>\n                ignoredTokenAddress === toChecksumHexAddress(tokenAddress),\n            );\n          }\n          const caseInsensitiveTokenKey =\n            Object.keys(tokenList).find(\n              (i) => i.toLowerCase() === tokenAddress.toLowerCase(),\n            ) || '';\n\n          if (ignored === undefined) {\n            const { decimals, symbol, aggregators, iconUrl, name } =\n              tokenList[caseInsensitiveTokenKey];\n            tokensToAdd.push({\n              address: tokenAddress,\n              decimals,\n              symbol,\n              aggregators,\n              image: iconUrl,\n              isERC721: false,\n              name,\n            });\n          }\n        }\n\n        if (tokensToAdd.length) {\n          await this.addDetectedTokens(tokensToAdd, {\n            selectedAddress,\n            chainId,\n          });\n        }\n      });\n    }\n  }\n}\n\nexport default TokenDetectionController;\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenListController.d.ts.map b/node_modules/@metamask/assets-controllers/dist/TokenListController.d.ts.map
index 55477cb..5e961db 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenListController.d.ts.map
+++ b/node_modules/@metamask/assets-controllers/dist/TokenListController.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"TokenListController.d.ts","sourceRoot":"","sources":["../src/TokenListController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"TokenListController.d.ts","sourceRoot":"","sources":["../src/TokenListController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenListController.js b/node_modules/@metamask/assets-controllers/dist/TokenListController.js
index 85d047a..cabd9ff 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenListController.js
+++ b/node_modules/@metamask/assets-controllers/dist/TokenListController.js
@@ -17,6 +17,7 @@ var _TokenListController_instances, _TokenListController_onNetworkControllerStat
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.TokenListController = void 0;
 const controller_utils_1 = require("@metamask/controller-utils");
+// eslint-disable-next-line import/no-extraneous-dependencies
 const polling_controller_1 = require("@metamask/polling-controller");
 const async_mutex_1 = require("async-mutex");
 const assetsUtil_1 = require("./assetsUtil");
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenListController.js.map b/node_modules/@metamask/assets-controllers/dist/TokenListController.js.map
index 2bf50ae..f7417ca 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenListController.js.map
+++ b/node_modules/@metamask/assets-controllers/dist/TokenListController.js.map
@@ -1 +1 @@
-{"version":3,"file":"TokenListController.js","sourceRoot":"","sources":["../src/TokenListController.ts"],"names":[],"mappings":"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","sourcesContent":["import type { RestrictedControllerMessenger } from '@metamask/base-controller';\nimport { safelyExecute } from '@metamask/controller-utils';\nimport type {\n  NetworkClientId,\n  NetworkControllerStateChangeEvent,\n  NetworkState,\n  NetworkControllerGetNetworkClientByIdAction,\n} from '@metamask/network-controller';\nimport { PollingController } from '@metamask/polling-controller';\nimport type { Hex } from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\nimport type { Patch } from 'immer';\n\nimport {\n  isTokenListSupportedForNetwork,\n  formatAggregatorNames,\n  formatIconUrlWithProxy,\n} from './assetsUtil';\nimport { fetchTokenListByChainId } from './token-service';\n\nconst DEFAULT_INTERVAL = 24 * 60 * 60 * 1000;\nconst DEFAULT_THRESHOLD = 24 * 60 * 60 * 1000;\n\nconst name = 'TokenListController';\n\nexport type TokenListToken = {\n  name: string;\n  symbol: string;\n  decimals: number;\n  address: string;\n  occurrences: number;\n  aggregators: string[];\n  iconUrl: string;\n};\n\nexport type TokenListMap = Record<string, TokenListToken>;\n\ntype DataCache = {\n  timestamp: number;\n  data: TokenListMap;\n};\ntype TokensChainsCache = {\n  [chainId: Hex]: DataCache;\n};\n\nexport type TokenListState = {\n  tokenList: TokenListMap;\n  tokensChainsCache: TokensChainsCache;\n  preventPollingOnNetworkRestart: boolean;\n};\n\nexport type TokenListStateChange = {\n  type: `${typeof name}:stateChange`;\n  payload: [TokenListState, Patch[]];\n};\n\nexport type GetTokenListState = {\n  type: `${typeof name}:getState`;\n  handler: () => TokenListState;\n};\ntype TokenListMessenger = RestrictedControllerMessenger<\n  typeof name,\n  GetTokenListState | NetworkControllerGetNetworkClientByIdAction,\n  TokenListStateChange | NetworkControllerStateChangeEvent,\n  NetworkControllerGetNetworkClientByIdAction['type'],\n  TokenListStateChange['type'] | NetworkControllerStateChangeEvent['type']\n>;\n\nconst metadata = {\n  tokenList: { persist: true, anonymous: true },\n  tokensChainsCache: { persist: true, anonymous: true },\n  preventPollingOnNetworkRestart: { persist: true, anonymous: true },\n};\n\nconst defaultState: TokenListState = {\n  tokenList: {},\n  tokensChainsCache: {},\n  preventPollingOnNetworkRestart: false,\n};\n\n/**\n * Controller that passively polls on a set interval for the list of tokens from metaswaps api\n */\nexport class TokenListController extends PollingController<\n  typeof name,\n  TokenListState,\n  TokenListMessenger\n> {\n  private readonly mutex = new Mutex();\n\n  private intervalId?: ReturnType<typeof setTimeout>;\n\n  private readonly intervalDelay: number;\n\n  private readonly cacheRefreshThreshold: number;\n\n  private chainId: Hex;\n\n  private abortController: AbortController;\n\n  /**\n   * Creates a TokenListController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.onNetworkStateChange - A function for registering an event handler for network state changes.\n   * @param options.interval - The polling interval, in milliseconds.\n   * @param options.cacheRefreshThreshold - The token cache expiry time, in milliseconds.\n   * @param options.messenger - A restricted controller messenger.\n   * @param options.state - Initial state to set on this controller.\n   * @param options.preventPollingOnNetworkRestart - Determines whether to prevent poilling on network restart in extension.\n   */\n  constructor({\n    chainId,\n    preventPollingOnNetworkRestart = false,\n    onNetworkStateChange,\n    interval = DEFAULT_INTERVAL,\n    cacheRefreshThreshold = DEFAULT_THRESHOLD,\n    messenger,\n    state,\n  }: {\n    chainId: Hex;\n    preventPollingOnNetworkRestart?: boolean;\n    onNetworkStateChange?: (\n      listener: (networkState: NetworkState) => void,\n    ) => void;\n    interval?: number;\n    cacheRefreshThreshold?: number;\n    messenger: TokenListMessenger;\n    state?: Partial<TokenListState>;\n  }) {\n    super({\n      name,\n      metadata,\n      messenger,\n      state: { ...defaultState, ...state },\n    });\n    this.intervalDelay = interval;\n    this.cacheRefreshThreshold = cacheRefreshThreshold;\n    this.chainId = chainId;\n    this.updatePreventPollingOnNetworkRestart(preventPollingOnNetworkRestart);\n    this.abortController = new AbortController();\n    if (onNetworkStateChange) {\n      onNetworkStateChange(async (networkControllerState) => {\n        await this.#onNetworkControllerStateChange(networkControllerState);\n      });\n    } else {\n      this.messagingSystem.subscribe(\n        'NetworkController:stateChange',\n        async (networkControllerState) => {\n          await this.#onNetworkControllerStateChange(networkControllerState);\n        },\n      );\n    }\n  }\n\n  /**\n   * Updates state and restarts polling on changes to the network controller\n   * state.\n   *\n   * @param networkControllerState - The updated network controller state.\n   */\n  async #onNetworkControllerStateChange(networkControllerState: NetworkState) {\n    if (this.chainId !== networkControllerState.providerConfig.chainId) {\n      this.abortController.abort();\n      this.abortController = new AbortController();\n      this.chainId = networkControllerState.providerConfig.chainId;\n      if (this.state.preventPollingOnNetworkRestart) {\n        this.clearingTokenListData();\n      } else {\n        // Ensure tokenList is referencing data from correct network\n        this.update(() => {\n          return {\n            ...this.state,\n            tokenList: this.state.tokensChainsCache[this.chainId]?.data || {},\n          };\n        });\n        await this.restart();\n      }\n    }\n  }\n\n  /**\n   * Start polling for the token list.\n   */\n  async start() {\n    if (!isTokenListSupportedForNetwork(this.chainId)) {\n      return;\n    }\n    await this.startPolling();\n  }\n\n  /**\n   * Restart polling for the token list.\n   */\n  async restart() {\n    this.stopPolling();\n    await this.startPolling();\n  }\n\n  /**\n   * Stop polling for the token list.\n   */\n  stop() {\n    this.stopPolling();\n  }\n\n  /**\n   * Prepare to discard this controller.\n   *\n   * This stops any active polling.\n   */\n  override destroy() {\n    super.destroy();\n    this.stopPolling();\n  }\n\n  private stopPolling() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n  }\n\n  /**\n   * Starts a new polling interval.\n   */\n  private async startPolling(): Promise<void> {\n    await safelyExecute(() => this.fetchTokenList());\n    this.intervalId = setInterval(async () => {\n      await safelyExecute(() => this.fetchTokenList());\n    }, this.intervalDelay);\n  }\n\n  /**\n   * Fetching token list from the Token Service API.\n   *\n   * @private\n   * @param networkClientId - The ID of the network client triggering the fetch.\n   * @returns A promise that resolves when this operation completes.\n   */\n  async _executePoll(networkClientId: string): Promise<void> {\n    return this.fetchTokenList(networkClientId);\n  }\n\n  /**\n   * Fetching token list from the Token Service API.\n   *\n   * @param networkClientId - The ID of the network client triggering the fetch.\n   */\n  async fetchTokenList(networkClientId?: NetworkClientId): Promise<void> {\n    const releaseLock = await this.mutex.acquire();\n    let networkClient;\n    if (networkClientId) {\n      networkClient = this.messagingSystem.call(\n        'NetworkController:getNetworkClientById',\n        networkClientId,\n      );\n    }\n    const chainId = networkClient?.configuration.chainId ?? this.chainId;\n    try {\n      const { tokensChainsCache } = this.state;\n      let tokenList: TokenListMap = {};\n      const cachedTokens: TokenListMap = await safelyExecute(() =>\n        this.#fetchFromCache(chainId),\n      );\n      if (cachedTokens) {\n        // Use non-expired cached tokens\n        tokenList = { ...cachedTokens };\n      } else {\n        // Fetch fresh token list\n        const tokensFromAPI: TokenListToken[] = await safelyExecute(() => {\n          return fetchTokenListByChainId(chainId, this.abortController.signal);\n        });\n        if (!tokensFromAPI) {\n          // Fallback to expired cached tokens\n          tokenList = { ...(tokensChainsCache[chainId]?.data || {}) };\n          this.update(() => {\n            return {\n              ...this.state,\n              tokenList,\n              tokensChainsCache,\n            };\n          });\n          return;\n        }\n        // Filtering out tokens with less than 3 occurrences and native tokens\n        const filteredTokenList = tokensFromAPI.filter(\n          (token) =>\n            token.occurrences &&\n            token.occurrences >= 3 &&\n            token.address !== '0x0000000000000000000000000000000000000000',\n        );\n        // Removing the tokens with symbol conflicts\n        const symbolsList = filteredTokenList.map((token) => token.symbol);\n        const duplicateSymbols = [\n          ...new Set(\n            symbolsList.filter(\n              (symbol, index) => symbolsList.indexOf(symbol) !== index,\n            ),\n          ),\n        ];\n        const uniqueTokenList = filteredTokenList.filter(\n          (token) => !duplicateSymbols.includes(token.symbol),\n        );\n        for (const token of uniqueTokenList) {\n          const formattedToken: TokenListToken = {\n            ...token,\n            aggregators: formatAggregatorNames(token.aggregators),\n            iconUrl: formatIconUrlWithProxy({\n              chainId,\n              tokenAddress: token.address,\n            }),\n          };\n          tokenList[token.address] = formattedToken;\n        }\n      }\n      const updatedTokensChainsCache: TokensChainsCache = {\n        ...tokensChainsCache,\n        [chainId]: {\n          timestamp: Date.now(),\n          data: tokenList,\n        },\n      };\n      this.update(() => {\n        return {\n          ...this.state,\n          tokenList,\n          tokensChainsCache: updatedTokensChainsCache,\n        };\n      });\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Checks if the Cache timestamp is valid,\n   * if yes data in cache will be returned\n   * otherwise null will be returned.\n   * @param chainId - The chain ID of the network for which to fetch the cache.\n   * @returns The cached data, or `null` if the cache was expired.\n   */\n  async #fetchFromCache(chainId: Hex): Promise<TokenListMap | null> {\n    const { tokensChainsCache }: TokenListState = this.state;\n    const dataCache = tokensChainsCache[chainId];\n    const now = Date.now();\n    if (\n      dataCache?.data &&\n      now - dataCache?.timestamp < this.cacheRefreshThreshold\n    ) {\n      return dataCache.data;\n    }\n    return null;\n  }\n\n  /**\n   * Clearing tokenList and tokensChainsCache explicitly.\n   */\n  clearingTokenListData(): void {\n    this.update(() => {\n      return {\n        ...this.state,\n        tokenList: {},\n        tokensChainsCache: {},\n      };\n    });\n  }\n\n  /**\n   * Updates preventPollingOnNetworkRestart from extension.\n   *\n   * @param shouldPreventPolling - Determine whether to prevent polling on network change\n   */\n  updatePreventPollingOnNetworkRestart(shouldPreventPolling: boolean): void {\n    this.update(() => {\n      return {\n        ...this.state,\n        preventPollingOnNetworkRestart: shouldPreventPolling,\n      };\n    });\n  }\n}\n\nexport default TokenListController;\n"]}
\ No newline at end of file
+{"version":3,"file":"TokenListController.js","sourceRoot":"","sources":["../src/TokenListController.ts"],"names":[],"mappings":"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","sourcesContent":["import type { RestrictedControllerMessenger } from '@metamask/base-controller';\nimport { safelyExecute } from '@metamask/controller-utils';\nimport type {\n  NetworkClientId,\n  NetworkControllerStateChangeEvent,\n  NetworkState,\n  NetworkControllerGetNetworkClientByIdAction,\n} from '@metamask/network-controller';\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport { PollingController } from '@metamask/polling-controller';\nimport type { Hex } from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\nimport type { Patch } from 'immer';\n\nimport {\n  isTokenListSupportedForNetwork,\n  formatAggregatorNames,\n  formatIconUrlWithProxy,\n} from './assetsUtil';\nimport { fetchTokenListByChainId } from './token-service';\n\nconst DEFAULT_INTERVAL = 24 * 60 * 60 * 1000;\nconst DEFAULT_THRESHOLD = 24 * 60 * 60 * 1000;\n\nconst name = 'TokenListController';\n\nexport type TokenListToken = {\n  name: string;\n  symbol: string;\n  decimals: number;\n  address: string;\n  occurrences: number;\n  aggregators: string[];\n  iconUrl: string;\n};\n\nexport type TokenListMap = Record<string, TokenListToken>;\n\ntype DataCache = {\n  timestamp: number;\n  data: TokenListMap;\n};\ntype TokensChainsCache = {\n  [chainId: Hex]: DataCache;\n};\n\nexport type TokenListState = {\n  tokenList: TokenListMap;\n  tokensChainsCache: TokensChainsCache;\n  preventPollingOnNetworkRestart: boolean;\n};\n\nexport type TokenListStateChange = {\n  type: `${typeof name}:stateChange`;\n  payload: [TokenListState, Patch[]];\n};\n\nexport type GetTokenListState = {\n  type: `${typeof name}:getState`;\n  handler: () => TokenListState;\n};\ntype TokenListMessenger = RestrictedControllerMessenger<\n  typeof name,\n  GetTokenListState | NetworkControllerGetNetworkClientByIdAction,\n  TokenListStateChange | NetworkControllerStateChangeEvent,\n  NetworkControllerGetNetworkClientByIdAction['type'],\n  TokenListStateChange['type'] | NetworkControllerStateChangeEvent['type']\n>;\n\nconst metadata = {\n  tokenList: { persist: true, anonymous: true },\n  tokensChainsCache: { persist: true, anonymous: true },\n  preventPollingOnNetworkRestart: { persist: true, anonymous: true },\n};\n\nconst defaultState: TokenListState = {\n  tokenList: {},\n  tokensChainsCache: {},\n  preventPollingOnNetworkRestart: false,\n};\n\n/**\n * Controller that passively polls on a set interval for the list of tokens from metaswaps api\n */\nexport class TokenListController extends PollingController<\n  typeof name,\n  TokenListState,\n  TokenListMessenger\n> {\n  private readonly mutex = new Mutex();\n\n  private intervalId?: ReturnType<typeof setTimeout>;\n\n  private readonly intervalDelay: number;\n\n  private readonly cacheRefreshThreshold: number;\n\n  private chainId: Hex;\n\n  private abortController: AbortController;\n\n  /**\n   * Creates a TokenListController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.onNetworkStateChange - A function for registering an event handler for network state changes.\n   * @param options.interval - The polling interval, in milliseconds.\n   * @param options.cacheRefreshThreshold - The token cache expiry time, in milliseconds.\n   * @param options.messenger - A restricted controller messenger.\n   * @param options.state - Initial state to set on this controller.\n   * @param options.preventPollingOnNetworkRestart - Determines whether to prevent poilling on network restart in extension.\n   */\n  constructor({\n    chainId,\n    preventPollingOnNetworkRestart = false,\n    onNetworkStateChange,\n    interval = DEFAULT_INTERVAL,\n    cacheRefreshThreshold = DEFAULT_THRESHOLD,\n    messenger,\n    state,\n  }: {\n    chainId: Hex;\n    preventPollingOnNetworkRestart?: boolean;\n    onNetworkStateChange?: (\n      listener: (networkState: NetworkState) => void,\n    ) => void;\n    interval?: number;\n    cacheRefreshThreshold?: number;\n    messenger: TokenListMessenger;\n    state?: Partial<TokenListState>;\n  }) {\n    super({\n      name,\n      metadata,\n      messenger,\n      state: { ...defaultState, ...state },\n    });\n    this.intervalDelay = interval;\n    this.cacheRefreshThreshold = cacheRefreshThreshold;\n    this.chainId = chainId;\n    this.updatePreventPollingOnNetworkRestart(preventPollingOnNetworkRestart);\n    this.abortController = new AbortController();\n    if (onNetworkStateChange) {\n      onNetworkStateChange(async (networkControllerState) => {\n        await this.#onNetworkControllerStateChange(networkControllerState);\n      });\n    } else {\n      this.messagingSystem.subscribe(\n        'NetworkController:stateChange',\n        async (networkControllerState) => {\n          await this.#onNetworkControllerStateChange(networkControllerState);\n        },\n      );\n    }\n  }\n\n  /**\n   * Updates state and restarts polling on changes to the network controller\n   * state.\n   *\n   * @param networkControllerState - The updated network controller state.\n   */\n  async #onNetworkControllerStateChange(networkControllerState: NetworkState) {\n    if (this.chainId !== networkControllerState.providerConfig.chainId) {\n      this.abortController.abort();\n      this.abortController = new AbortController();\n      this.chainId = networkControllerState.providerConfig.chainId;\n      if (this.state.preventPollingOnNetworkRestart) {\n        this.clearingTokenListData();\n      } else {\n        // Ensure tokenList is referencing data from correct network\n        this.update(() => {\n          return {\n            ...this.state,\n            tokenList: this.state.tokensChainsCache[this.chainId]?.data || {},\n          };\n        });\n        await this.restart();\n      }\n    }\n  }\n\n  /**\n   * Start polling for the token list.\n   */\n  async start() {\n    if (!isTokenListSupportedForNetwork(this.chainId)) {\n      return;\n    }\n    await this.startPolling();\n  }\n\n  /**\n   * Restart polling for the token list.\n   */\n  async restart() {\n    this.stopPolling();\n    await this.startPolling();\n  }\n\n  /**\n   * Stop polling for the token list.\n   */\n  stop() {\n    this.stopPolling();\n  }\n\n  /**\n   * Prepare to discard this controller.\n   *\n   * This stops any active polling.\n   */\n  override destroy() {\n    super.destroy();\n    this.stopPolling();\n  }\n\n  private stopPolling() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n  }\n\n  /**\n   * Starts a new polling interval.\n   */\n  private async startPolling(): Promise<void> {\n    await safelyExecute(() => this.fetchTokenList());\n    this.intervalId = setInterval(async () => {\n      await safelyExecute(() => this.fetchTokenList());\n    }, this.intervalDelay);\n  }\n\n  /**\n   * Fetching token list from the Token Service API.\n   *\n   * @private\n   * @param networkClientId - The ID of the network client triggering the fetch.\n   * @returns A promise that resolves when this operation completes.\n   */\n  async _executePoll(networkClientId: string): Promise<void> {\n    return this.fetchTokenList(networkClientId);\n  }\n\n  /**\n   * Fetching token list from the Token Service API.\n   *\n   * @param networkClientId - The ID of the network client triggering the fetch.\n   */\n  async fetchTokenList(networkClientId?: NetworkClientId): Promise<void> {\n    const releaseLock = await this.mutex.acquire();\n    let networkClient;\n    if (networkClientId) {\n      networkClient = this.messagingSystem.call(\n        'NetworkController:getNetworkClientById',\n        networkClientId,\n      );\n    }\n    const chainId = networkClient?.configuration.chainId ?? this.chainId;\n    try {\n      const { tokensChainsCache } = this.state;\n      let tokenList: TokenListMap = {};\n      const cachedTokens: TokenListMap = await safelyExecute(() =>\n        this.#fetchFromCache(chainId),\n      );\n      if (cachedTokens) {\n        // Use non-expired cached tokens\n        tokenList = { ...cachedTokens };\n      } else {\n        // Fetch fresh token list\n        const tokensFromAPI: TokenListToken[] = await safelyExecute(() => {\n          return fetchTokenListByChainId(chainId, this.abortController.signal);\n        });\n        if (!tokensFromAPI) {\n          // Fallback to expired cached tokens\n          tokenList = { ...(tokensChainsCache[chainId]?.data || {}) };\n          this.update(() => {\n            return {\n              ...this.state,\n              tokenList,\n              tokensChainsCache,\n            };\n          });\n          return;\n        }\n        // Filtering out tokens with less than 3 occurrences and native tokens\n        const filteredTokenList = tokensFromAPI.filter(\n          (token) =>\n            token.occurrences &&\n            token.occurrences >= 3 &&\n            token.address !== '0x0000000000000000000000000000000000000000',\n        );\n        // Removing the tokens with symbol conflicts\n        const symbolsList = filteredTokenList.map((token) => token.symbol);\n        const duplicateSymbols = [\n          ...new Set(\n            symbolsList.filter(\n              (symbol, index) => symbolsList.indexOf(symbol) !== index,\n            ),\n          ),\n        ];\n        const uniqueTokenList = filteredTokenList.filter(\n          (token) => !duplicateSymbols.includes(token.symbol),\n        );\n        for (const token of uniqueTokenList) {\n          const formattedToken: TokenListToken = {\n            ...token,\n            aggregators: formatAggregatorNames(token.aggregators),\n            iconUrl: formatIconUrlWithProxy({\n              chainId,\n              tokenAddress: token.address,\n            }),\n          };\n          tokenList[token.address] = formattedToken;\n        }\n      }\n      const updatedTokensChainsCache: TokensChainsCache = {\n        ...tokensChainsCache,\n        [chainId]: {\n          timestamp: Date.now(),\n          data: tokenList,\n        },\n      };\n      this.update(() => {\n        return {\n          ...this.state,\n          tokenList,\n          tokensChainsCache: updatedTokensChainsCache,\n        };\n      });\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Checks if the Cache timestamp is valid,\n   * if yes data in cache will be returned\n   * otherwise null will be returned.\n   * @param chainId - The chain ID of the network for which to fetch the cache.\n   * @returns The cached data, or `null` if the cache was expired.\n   */\n  async #fetchFromCache(chainId: Hex): Promise<TokenListMap | null> {\n    const { tokensChainsCache }: TokenListState = this.state;\n    const dataCache = tokensChainsCache[chainId];\n    const now = Date.now();\n    if (\n      dataCache?.data &&\n      now - dataCache?.timestamp < this.cacheRefreshThreshold\n    ) {\n      return dataCache.data;\n    }\n    return null;\n  }\n\n  /**\n   * Clearing tokenList and tokensChainsCache explicitly.\n   */\n  clearingTokenListData(): void {\n    this.update(() => {\n      return {\n        ...this.state,\n        tokenList: {},\n        tokensChainsCache: {},\n      };\n    });\n  }\n\n  /**\n   * Updates preventPollingOnNetworkRestart from extension.\n   *\n   * @param shouldPreventPolling - Determine whether to prevent polling on network change\n   */\n  updatePreventPollingOnNetworkRestart(shouldPreventPolling: boolean): void {\n    this.update(() => {\n      return {\n        ...this.state,\n        preventPollingOnNetworkRestart: shouldPreventPolling,\n      };\n    });\n  }\n}\n\nexport default TokenListController;\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenRatesController.d.ts b/node_modules/@metamask/assets-controllers/dist/TokenRatesController.d.ts
index cda8bb7..e8bbc92 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenRatesController.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/TokenRatesController.d.ts
@@ -1,30 +1,10 @@
-import type { BaseConfig, BaseState } from '@metamask/base-controller';
 import { BaseController } from '@metamask/base-controller';
+import type { BaseConfig, BaseState } from '@metamask/base-controller';
 import type { NetworkState } from '@metamask/network-controller';
 import type { PreferencesState } from '@metamask/preferences-controller';
 import type { Hex } from '@metamask/utils';
+import type { AbstractTokenPricesService } from './token-prices-service/abstract-token-prices-service';
 import type { TokensState } from './TokensController';
-/**
- * @type CoinGeckoResponse
- *
- * CoinGecko API response representation
- */
-export interface CoinGeckoResponse {
-    [address: string]: {
-        [currency: string]: number;
-    };
-}
-/**
- * @type CoinGeckoPlatform
- *
- * CoinGecko supported platform API representation
- */
-export interface CoinGeckoPlatform {
-    id: string;
-    chain_identifier: null | number;
-    name: string;
-    shortname: string;
-}
 /**
  * @type Token
  *
@@ -78,11 +58,12 @@ interface ContractExchangeRates {
  * @type TokenRatesState
  *
  * Token rates controller state
- * @property contractExchangeRates - Hash of token contract addresses to exchange rates
- * @property supportedChains - Cached chain data
+ * @property contractExchangeRates - Hash of token contract addresses to exchange rates (single globally selected chain, will be deprecated soon)
+ * @property contractExchangeRatesByChainId - Hash of token contract addresses to exchange rates keyed by chain ID and native currency (ticker)
  */
 export interface TokenRatesState extends BaseState {
     contractExchangeRates: ContractExchangeRates;
+    contractExchangeRatesByChainId: Record<string, Record<string, ContractExchangeRates>>;
 }
 /**
  * Controller that passively polls on a set interval for token-to-fiat exchange rates
@@ -91,9 +72,6 @@ export interface TokenRatesState extends BaseState {
 export declare class TokenRatesController extends BaseController<TokenRatesConfig, TokenRatesState> {
     #private;
     private handle?;
-    private tokenList;
-    private supportedChains;
-    private supportedVsCurrencies;
     /**
      * Name of this controller used during composition
      */
@@ -102,22 +80,28 @@ export declare class TokenRatesController extends BaseController<TokenRatesConfi
      * Creates a TokenRatesController instance.
      *
      * @param options - The controller options.
+     * @param options.interval - The polling interval in ms
+     * @param options.threshold - The duration in ms before metadata fetched from CoinGecko is considered stale
      * @param options.chainId - The chain ID of the current network.
      * @param options.ticker - The ticker for the current network.
      * @param options.selectedAddress - The current selected address.
      * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.
      * @param options.onTokensStateChange - Allows subscribing to token controller state changes.
      * @param options.onNetworkStateChange - Allows subscribing to network state changes.
+     * @param options.tokenPricesService - An object in charge of retrieving token prices.
      * @param config - Initial options used to configure this controller.
      * @param state - Initial state to set on this controller.
      */
-    constructor({ chainId: initialChainId, ticker: initialTicker, selectedAddress: initialSelectedAddress, onPreferencesStateChange, onTokensStateChange, onNetworkStateChange, }: {
+    constructor({ interval, threshold, chainId: initialChainId, ticker: initialTicker, selectedAddress: initialSelectedAddress, onPreferencesStateChange, onTokensStateChange, onNetworkStateChange, tokenPricesService, }: {
+        interval?: number;
+        threshold?: number;
         chainId: Hex;
         ticker: string;
         selectedAddress: string;
         onPreferencesStateChange: (listener: (preferencesState: PreferencesState) => void) => void;
         onTokensStateChange: (listener: (tokensState: TokensState) => void) => void;
         onNetworkStateChange: (listener: (networkState: NetworkState) => void) => void;
+        tokenPricesService: AbstractTokenPricesService;
     }, config?: Partial<TokenRatesConfig>, state?: Partial<TokenRatesState>);
     /**
      * Start (or restart) polling.
@@ -127,46 +111,10 @@ export declare class TokenRatesController extends BaseController<TokenRatesConfi
      * Stop polling.
      */
     stop(): void;
-    /**
-     * Fetches a pairs of token address and native currency.
-     *
-     * @param chainSlug - Chain string identifier.
-     * @param vsCurrency - Query according to tokens in tokenList and native currency.
-     * @returns The exchange rates for the given pairs.
-     */
-    fetchExchangeRate(chainSlug: string, vsCurrency: string): Promise<CoinGeckoResponse>;
-    /**
-     * Checks if the current native currency is a supported vs currency to use
-     * to query for token exchange rates.
-     *
-     * @param nativeCurrency - The native currency of the currently active network.
-     * @returns A boolean indicating whether it's a supported vsCurrency.
-     */
-    private checkIsSupportedVsCurrency;
-    /**
-     * Gets current chain ID slug from cached supported platforms CoinGecko API response.
-     * If cached supported platforms response is stale, fetches and updates it.
-     *
-     * @returns The CoinGecko slug for the current chain ID.
-     */
-    getChainSlug(): Promise<string | null>;
     /**
      * Updates exchange rates for all tokens.
      */
     updateExchangeRates(): Promise<void>;
-    /**
-     * Checks if the active network's native currency is supported by the coingecko API.
-     * If supported, it fetches and maps contractExchange rates to a format to be consumed by the UI.
-     * If not supported, it fetches contractExchange rates and maps them from token/fallback-currency
-     * to token/nativeCurrency.
-     *
-     * @param nativeCurrency - The native currency of the currently active network.
-     * @param slug - The unique slug used to id the chain by the coingecko api
-     * should be used to query token exchange rates.
-     * @returns An object with conversion rates for each token
-     * related to the network's native currency.
-     */
-    fetchAndMapExchangeRates(nativeCurrency: string, slug: string): Promise<ContractExchangeRates>;
 }
 export default TokenRatesController;
 //# sourceMappingURL=TokenRatesController.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenRatesController.d.ts.map b/node_modules/@metamask/assets-controllers/dist/TokenRatesController.d.ts.map
index 8e92171..8e741fd 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenRatesController.d.ts.map
+++ b/node_modules/@metamask/assets-controllers/dist/TokenRatesController.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"TokenRatesController.d.ts","sourceRoot":"","sources":["../src/TokenRatesController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"TokenRatesController.d.ts","sourceRoot":"","sources":["../src/TokenRatesController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenRatesController.js b/node_modules/@metamask/assets-controllers/dist/TokenRatesController.js
index c5df5be..8a84cb9 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenRatesController.js
+++ b/node_modules/@metamask/assets-controllers/dist/TokenRatesController.js
@@ -8,126 +8,129 @@ var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, ge
         step((generator = generator.apply(thisArg, _arguments || [])).next());
     });
 };
-var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
-    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
-    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
-    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
-};
 var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
     if (kind === "m") throw new TypeError("Private method is not writable");
     if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
     if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
     return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
 };
-var _TokenRatesController_instances, _TokenRatesController_pollState, _TokenRatesController_updateTokenList, _TokenRatesController_stopPoll, _TokenRatesController_poll;
+var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
+    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
+};
+var _TokenRatesController_instances, _TokenRatesController_pollState, _TokenRatesController_tokenPricesService, _TokenRatesController_inProcessExchangeRateUpdates, _TokenRatesController_getTokenAddresses, _TokenRatesController_stopPoll, _TokenRatesController_poll, _TokenRatesController_fetchAndMapExchangeRates, _TokenRatesController_fetchAndMapExchangeRatesForSupportedNativeCurrency, _TokenRatesController_fetchAndMapExchangeRatesForUnsupportedNativeCurrency;
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.TokenRatesController = void 0;
 const base_controller_1 = require("@metamask/base-controller");
 const controller_utils_1 = require("@metamask/controller-utils");
+const lodash_1 = require("lodash");
+const assetsUtil_1 = require("./assetsUtil");
 const crypto_compare_1 = require("./crypto-compare");
 var PollState;
 (function (PollState) {
     PollState["Active"] = "Active";
     PollState["Inactive"] = "Inactive";
 })(PollState || (PollState = {}));
-const CoinGeckoApi = {
-    BASE_URL: 'https://api.coingecko.com/api/v3',
-    getTokenPriceURL(chainSlug, query) {
-        return `${this.BASE_URL}/simple/token_price/${chainSlug}?${query}`;
-    },
-    getPlatformsURL() {
-        return `${this.BASE_URL}/asset_platforms`;
-    },
-    getSupportedVsCurrencies() {
-        return `${this.BASE_URL}/simple/supported_vs_currencies`;
-    },
-};
 /**
- * Finds the chain slug in the data array given a chainId.
+ * The maximum number of token addresses that should be sent to the Price API in
+ * a single request.
+ */
+const TOKEN_PRICES_BATCH_SIZE = 30;
+/**
+ * Uses the CryptoCompare API to fetch the exchange rate between one currency
+ * and another, i.e., the multiplier to apply the amount of one currency in
+ * order to convert it to another.
  *
- * @param chainId - The current chain ID.
- * @param data - A list platforms supported by the CoinGecko API.
- * @returns The CoinGecko slug for the given chain ID, or `null` if the slug was not found.
+ * @param args - The arguments to this function.
+ * @param args.from - The currency to convert from.
+ * @param args.to - The currency to convert to.
+ * @returns The exchange rate between `fromCurrency` to `toCurrency` if one
+ * exists, or null if one does not.
  */
-function findChainSlug(chainId, data) {
-    var _a;
-    if (!data) {
-        return null;
-    }
-    const chain = (_a = data.find(({ chain_identifier }) => chain_identifier !== null && (0, controller_utils_1.toHex)(chain_identifier) === chainId)) !== null && _a !== void 0 ? _a : null;
-    return (chain === null || chain === void 0 ? void 0 : chain.id) || null;
+function getCurrencyConversionRate({ from, to, }) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const includeUSDRate = false;
+        try {
+            const result = yield (0, crypto_compare_1.fetchExchangeRate)(to, from, includeUSDRate);
+            return result.conversionRate;
+        }
+        catch (error) {
+            if (error instanceof Error &&
+                error.message.includes('market does not exist for this coin pair')) {
+                return null;
+            }
+            throw error;
+        }
+    });
 }
 /**
  * Controller that passively polls on a set interval for token-to-fiat exchange rates
  * for tokens stored in the TokensController
  */
+// This is using BaseController on BaseController v3, which relates to BaseController V1
+// When rebase this patch doesn't forget about change this to `BaseController` instead of `BaseControllerV1`
 class TokenRatesController extends base_controller_1.BaseController {
     /**
      * Creates a TokenRatesController instance.
      *
      * @param options - The controller options.
+     * @param options.interval - The polling interval in ms
+     * @param options.threshold - The duration in ms before metadata fetched from CoinGecko is considered stale
      * @param options.chainId - The chain ID of the current network.
      * @param options.ticker - The ticker for the current network.
      * @param options.selectedAddress - The current selected address.
      * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.
      * @param options.onTokensStateChange - Allows subscribing to token controller state changes.
      * @param options.onNetworkStateChange - Allows subscribing to network state changes.
+     * @param options.tokenPricesService - An object in charge of retrieving token prices.
      * @param config - Initial options used to configure this controller.
      * @param state - Initial state to set on this controller.
      */
-    constructor({ chainId: initialChainId, ticker: initialTicker, selectedAddress: initialSelectedAddress, onPreferencesStateChange, onTokensStateChange, onNetworkStateChange, }, config, state) {
+    constructor({ interval = 3 * 60 * 1000, threshold = 6 * 60 * 60 * 1000, chainId: initialChainId, ticker: initialTicker, selectedAddress: initialSelectedAddress, onPreferencesStateChange, onTokensStateChange, onNetworkStateChange, tokenPricesService, }, config, state) {
         super(config, state);
         _TokenRatesController_instances.add(this);
-        this.tokenList = [];
-        this.supportedChains = {
-            timestamp: 0,
-            data: null,
-        };
-        this.supportedVsCurrencies = {
-            timestamp: 0,
-            data: [],
-        };
         _TokenRatesController_pollState.set(this, PollState.Inactive);
+        _TokenRatesController_tokenPricesService.set(this, void 0);
+        _TokenRatesController_inProcessExchangeRateUpdates.set(this, {});
         /**
          * Name of this controller used during composition
          */
         this.name = 'TokenRatesController';
         this.defaultConfig = {
+            interval,
+            threshold,
             disabled: false,
-            interval: 3 * 60 * 1000,
             nativeCurrency: initialTicker,
             chainId: initialChainId,
             selectedAddress: initialSelectedAddress,
             allTokens: {},
             allDetectedTokens: {},
-            threshold: 6 * 60 * 60 * 1000,
         };
         this.defaultState = {
             contractExchangeRates: {},
+            contractExchangeRatesByChainId: {},
         };
         this.initialize();
+        __classPrivateFieldSet(this, _TokenRatesController_tokenPricesService, tokenPricesService, "f");
         if (config === null || config === void 0 ? void 0 : config.disabled) {
             this.configure({ disabled: true }, false, false);
         }
-        __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_updateTokenList).call(this);
         onPreferencesStateChange(({ selectedAddress }) => __awaiter(this, void 0, void 0, function* () {
             if (this.config.selectedAddress !== selectedAddress) {
                 this.configure({ selectedAddress });
-                __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_updateTokenList).call(this);
                 if (__classPrivateFieldGet(this, _TokenRatesController_pollState, "f") === PollState.Active) {
                     yield this.updateExchangeRates();
                 }
             }
         }));
         onTokensStateChange(({ allTokens, allDetectedTokens }) => __awaiter(this, void 0, void 0, function* () {
-            // These two state properties are assumed to be immutable
-            if (this.config.allTokens !== allTokens ||
-                this.config.allDetectedTokens !== allDetectedTokens) {
-                this.configure({ allTokens, allDetectedTokens });
-                __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_updateTokenList).call(this);
-                if (__classPrivateFieldGet(this, _TokenRatesController_pollState, "f") === PollState.Active) {
-                    yield this.updateExchangeRates();
-                }
+            const previousTokenAddresses = __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_getTokenAddresses).call(this, this.config.chainId);
+            this.configure({ allTokens, allDetectedTokens });
+            const newTokenAddresses = __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_getTokenAddresses).call(this, this.config.chainId);
+            if (!(0, lodash_1.isEqual)(previousTokenAddresses, newTokenAddresses) &&
+                __classPrivateFieldGet(this, _TokenRatesController_pollState, "f") === PollState.Active) {
+                yield this.updateExchangeRates();
             }
         }));
         onNetworkStateChange(({ providerConfig }) => __awaiter(this, void 0, void 0, function* () {
@@ -135,8 +138,7 @@ class TokenRatesController extends base_controller_1.BaseController {
             if (this.config.chainId !== chainId ||
                 this.config.nativeCurrency !== ticker) {
                 this.update({ contractExchangeRates: {} });
-                this.configure({ chainId, nativeCurrency: ticker });
-                __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_updateTokenList).call(this);
+                this.configure({ chainId, nativeCurrency: ticker || 'ETH' });
                 if (__classPrivateFieldGet(this, _TokenRatesController_pollState, "f") === PollState.Active) {
                     yield this.updateExchangeRates();
                 }
@@ -160,155 +162,68 @@ class TokenRatesController extends base_controller_1.BaseController {
         __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_stopPoll).call(this);
         __classPrivateFieldSet(this, _TokenRatesController_pollState, PollState.Inactive, "f");
     }
-    /**
-     * Fetches a pairs of token address and native currency.
-     *
-     * @param chainSlug - Chain string identifier.
-     * @param vsCurrency - Query according to tokens in tokenList and native currency.
-     * @returns The exchange rates for the given pairs.
-     */
-    fetchExchangeRate(chainSlug, vsCurrency) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const tokenPairs = this.tokenList.map((token) => token.address).join(',');
-            const query = `contract_addresses=${tokenPairs}&vs_currencies=${vsCurrency.toLowerCase()}`;
-            return (0, controller_utils_1.handleFetch)(CoinGeckoApi.getTokenPriceURL(chainSlug, query));
-        });
-    }
-    /**
-     * Checks if the current native currency is a supported vs currency to use
-     * to query for token exchange rates.
-     *
-     * @param nativeCurrency - The native currency of the currently active network.
-     * @returns A boolean indicating whether it's a supported vsCurrency.
-     */
-    checkIsSupportedVsCurrency(nativeCurrency) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const { threshold } = this.config;
-            const { timestamp, data } = this.supportedVsCurrencies;
-            const now = Date.now();
-            if (now - timestamp > threshold) {
-                const currencies = yield (0, controller_utils_1.handleFetch)(CoinGeckoApi.getSupportedVsCurrencies());
-                this.supportedVsCurrencies = {
-                    data: currencies,
-                    timestamp: Date.now(),
-                };
-                return currencies.includes(nativeCurrency.toLowerCase());
-            }
-            return data.includes(nativeCurrency.toLowerCase());
-        });
-    }
-    /**
-     * Gets current chain ID slug from cached supported platforms CoinGecko API response.
-     * If cached supported platforms response is stale, fetches and updates it.
-     *
-     * @returns The CoinGecko slug for the current chain ID.
-     */
-    getChainSlug() {
-        return __awaiter(this, void 0, void 0, function* () {
-            const { threshold, chainId } = this.config;
-            const { data, timestamp } = this.supportedChains;
-            const now = Date.now();
-            if (now - timestamp > threshold) {
-                const platforms = yield (0, controller_utils_1.handleFetch)(CoinGeckoApi.getPlatformsURL());
-                this.supportedChains = {
-                    data: platforms,
-                    timestamp: Date.now(),
-                };
-                return findChainSlug(chainId, platforms);
-            }
-            return findChainSlug(chainId, data);
-        });
-    }
     /**
      * Updates exchange rates for all tokens.
      */
     updateExchangeRates() {
+        var _a;
         return __awaiter(this, void 0, void 0, function* () {
-            if (this.tokenList.length === 0 || this.disabled) {
+            const { chainId, nativeCurrency } = this.config;
+            if (this.disabled) {
                 return;
             }
-            const slug = yield this.getChainSlug();
-            let newContractExchangeRates = {};
-            if (!slug) {
-                this.tokenList.forEach((token) => {
-                    const address = (0, controller_utils_1.toChecksumHexAddress)(token.address);
-                    newContractExchangeRates[address] = undefined;
-                });
+            const tokenAddresses = __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_getTokenAddresses).call(this, chainId);
+            if (tokenAddresses.length === 0) {
+                return;
             }
-            else {
-                const { nativeCurrency } = this.config;
-                newContractExchangeRates = yield this.fetchAndMapExchangeRates(nativeCurrency, slug);
+            const updateKey = `${chainId}:${nativeCurrency}`;
+            if (updateKey in __classPrivateFieldGet(this, _TokenRatesController_inProcessExchangeRateUpdates, "f")) {
+                // This prevents redundant updates
+                // This promise is resolved after the in-progress update has finished,
+                // and state has been updated.
+                yield __classPrivateFieldGet(this, _TokenRatesController_inProcessExchangeRateUpdates, "f")[updateKey];
+                return;
             }
-            this.update({ contractExchangeRates: newContractExchangeRates });
-        });
-    }
-    /**
-     * Checks if the active network's native currency is supported by the coingecko API.
-     * If supported, it fetches and maps contractExchange rates to a format to be consumed by the UI.
-     * If not supported, it fetches contractExchange rates and maps them from token/fallback-currency
-     * to token/nativeCurrency.
-     *
-     * @param nativeCurrency - The native currency of the currently active network.
-     * @param slug - The unique slug used to id the chain by the coingecko api
-     * should be used to query token exchange rates.
-     * @returns An object with conversion rates for each token
-     * related to the network's native currency.
-     */
-    fetchAndMapExchangeRates(nativeCurrency, slug) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const contractExchangeRates = {};
-            // check if native currency is supported as a vs_currency by the API
-            const nativeCurrencySupported = yield this.checkIsSupportedVsCurrency(nativeCurrency);
-            if (nativeCurrencySupported) {
-                // If it is we can do a simple fetch against the CoinGecko API
-                const prices = yield this.fetchExchangeRate(slug, nativeCurrency);
-                this.tokenList.forEach((token) => {
-                    const price = prices[token.address.toLowerCase()];
-                    contractExchangeRates[(0, controller_utils_1.toChecksumHexAddress)(token.address)] = price
-                        ? price[nativeCurrency.toLowerCase()]
-                        : 0;
+            const { promise: inProgressUpdate, resolve: updateSucceeded, reject: updateFailed, } = createDeferredPromise({ suppressUnhandledRejection: true });
+            __classPrivateFieldGet(this, _TokenRatesController_inProcessExchangeRateUpdates, "f")[updateKey] = inProgressUpdate;
+            try {
+                const newContractExchangeRates = yield __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_fetchAndMapExchangeRates).call(this, {
+                    tokenAddresses,
+                    chainId,
+                    nativeCurrency,
+                });
+                const existingContractExchangeRates = this.state.contractExchangeRates;
+                const updatedContractExchangeRates = chainId === this.config.chainId &&
+                    nativeCurrency === this.config.nativeCurrency
+                    ? newContractExchangeRates
+                    : existingContractExchangeRates;
+                const existingContractExchangeRatesForChainId = (_a = this.state.contractExchangeRatesByChainId[chainId]) !== null && _a !== void 0 ? _a : {};
+                const updatedContractExchangeRatesForChainId = Object.assign(Object.assign({}, this.state.contractExchangeRatesByChainId), { [chainId]: Object.assign(Object.assign({}, existingContractExchangeRatesForChainId), { [nativeCurrency]: Object.assign(Object.assign({}, existingContractExchangeRatesForChainId[nativeCurrency]), newContractExchangeRates) }) });
+                this.update({
+                    contractExchangeRates: updatedContractExchangeRates,
+                    contractExchangeRatesByChainId: updatedContractExchangeRatesForChainId,
                 });
+                updateSucceeded();
             }
-            else {
-                // if native currency is not supported we need to use a fallback vsCurrency, get the exchange rates
-                // in token/fallback-currency format and convert them to expected token/nativeCurrency format.
-                let tokenExchangeRates;
-                let vsCurrencyToNativeCurrencyConversionRate = 0;
-                try {
-                    [
-                        tokenExchangeRates,
-                        { conversionRate: vsCurrencyToNativeCurrencyConversionRate },
-                    ] = yield Promise.all([
-                        this.fetchExchangeRate(slug, controller_utils_1.FALL_BACK_VS_CURRENCY),
-                        (0, crypto_compare_1.fetchExchangeRate)(nativeCurrency, controller_utils_1.FALL_BACK_VS_CURRENCY, false),
-                    ]);
-                }
-                catch (error) {
-                    if (error instanceof Error &&
-                        error.message.includes('market does not exist for this coin pair')) {
-                        return {};
-                    }
-                    throw error;
-                }
-                for (const [tokenAddress, conversion] of Object.entries(tokenExchangeRates)) {
-                    const tokenToVsCurrencyConversionRate = conversion[controller_utils_1.FALL_BACK_VS_CURRENCY.toLowerCase()];
-                    contractExchangeRates[(0, controller_utils_1.toChecksumHexAddress)(tokenAddress)] =
-                        tokenToVsCurrencyConversionRate *
-                            vsCurrencyToNativeCurrencyConversionRate;
-                }
+            catch (error) {
+                updateFailed(error);
+                throw error;
+            }
+            finally {
+                delete __classPrivateFieldGet(this, _TokenRatesController_inProcessExchangeRateUpdates, "f")[updateKey];
             }
-            return contractExchangeRates;
         });
     }
 }
 exports.TokenRatesController = TokenRatesController;
-_TokenRatesController_pollState = new WeakMap(), _TokenRatesController_instances = new WeakSet(), _TokenRatesController_updateTokenList = function _TokenRatesController_updateTokenList() {
+_TokenRatesController_pollState = new WeakMap(), _TokenRatesController_tokenPricesService = new WeakMap(), _TokenRatesController_inProcessExchangeRateUpdates = new WeakMap(), _TokenRatesController_instances = new WeakSet(), _TokenRatesController_getTokenAddresses = function _TokenRatesController_getTokenAddresses(chainId) {
     var _a, _b;
     const { allTokens, allDetectedTokens } = this.config;
-    const tokens = ((_a = allTokens[this.config.chainId]) === null || _a === void 0 ? void 0 : _a[this.config.selectedAddress]) || [];
-    const detectedTokens = ((_b = allDetectedTokens[this.config.chainId]) === null || _b === void 0 ? void 0 : _b[this.config.selectedAddress]) ||
-        [];
-    this.tokenList = [...tokens, ...detectedTokens];
+    const tokens = ((_a = allTokens[chainId]) === null || _a === void 0 ? void 0 : _a[this.config.selectedAddress]) || [];
+    const detectedTokens = ((_b = allDetectedTokens[chainId]) === null || _b === void 0 ? void 0 : _b[this.config.selectedAddress]) || [];
+    return [
+        ...new Set([...tokens, ...detectedTokens].map((token) => (0, controller_utils_1.toHex)((0, controller_utils_1.toChecksumHexAddress)(token.address)))),
+    ].sort();
 }, _TokenRatesController_stopPoll = function _TokenRatesController_stopPoll() {
     if (this.handle) {
         clearTimeout(this.handle);
@@ -322,6 +237,91 @@ _TokenRatesController_pollState = new WeakMap(), _TokenRatesController_instances
             __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_poll).call(this);
         }, this.config.interval);
     });
+}, _TokenRatesController_fetchAndMapExchangeRates = function _TokenRatesController_fetchAndMapExchangeRates({ tokenAddresses, chainId, nativeCurrency, }) {
+    return __awaiter(this, void 0, void 0, function* () {
+        if (!__classPrivateFieldGet(this, _TokenRatesController_tokenPricesService, "f").validateChainIdSupported(chainId)) {
+            return tokenAddresses.reduce((obj, tokenAddress) => {
+                return Object.assign(Object.assign({}, obj), { [tokenAddress]: undefined });
+            }, {});
+        }
+        if (__classPrivateFieldGet(this, _TokenRatesController_tokenPricesService, "f").validateCurrencySupported(nativeCurrency)) {
+            return yield __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_fetchAndMapExchangeRatesForSupportedNativeCurrency).call(this, {
+                tokenAddresses,
+                chainId,
+                nativeCurrency,
+            });
+        }
+        return yield __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_fetchAndMapExchangeRatesForUnsupportedNativeCurrency).call(this, {
+            tokenAddresses,
+            nativeCurrency,
+        });
+    });
+}, _TokenRatesController_fetchAndMapExchangeRatesForSupportedNativeCurrency = function _TokenRatesController_fetchAndMapExchangeRatesForSupportedNativeCurrency({ tokenAddresses, chainId, nativeCurrency, }) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const tokenPricesByTokenAddress = yield (0, assetsUtil_1.reduceInBatchesSerially)({
+            values: [...tokenAddresses].sort(),
+            batchSize: TOKEN_PRICES_BATCH_SIZE,
+            eachBatch: (allTokenPricesByTokenAddress, batch) => __awaiter(this, void 0, void 0, function* () {
+                const tokenPricesByTokenAddressForBatch = yield __classPrivateFieldGet(this, _TokenRatesController_tokenPricesService, "f").fetchTokenPrices({
+                    tokenAddresses: batch,
+                    chainId,
+                    currency: nativeCurrency,
+                });
+                return Object.assign(Object.assign({}, allTokenPricesByTokenAddress), tokenPricesByTokenAddressForBatch);
+            }),
+            initialResult: {},
+        });
+        return Object.entries(tokenPricesByTokenAddress).reduce((obj, [tokenAddress, tokenPrice]) => {
+            return Object.assign(Object.assign({}, obj), { [tokenAddress]: tokenPrice === null || tokenPrice === void 0 ? void 0 : tokenPrice.value });
+        }, {});
+    });
+}, _TokenRatesController_fetchAndMapExchangeRatesForUnsupportedNativeCurrency = function _TokenRatesController_fetchAndMapExchangeRatesForUnsupportedNativeCurrency({ tokenAddresses, nativeCurrency, }) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const [contractExchangeRates, fallbackCurrencyToNativeCurrencyConversionRate,] = yield Promise.all([
+            __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_fetchAndMapExchangeRatesForSupportedNativeCurrency).call(this, {
+                tokenAddresses,
+                chainId: this.config.chainId,
+                nativeCurrency: controller_utils_1.FALL_BACK_VS_CURRENCY,
+            }),
+            getCurrencyConversionRate({
+                from: controller_utils_1.FALL_BACK_VS_CURRENCY,
+                to: nativeCurrency,
+            }),
+        ]);
+        if (fallbackCurrencyToNativeCurrencyConversionRate === null) {
+            return {};
+        }
+        return Object.entries(contractExchangeRates).reduce((obj, [tokenAddress, tokenValue]) => {
+            return Object.assign(Object.assign({}, obj), { [tokenAddress]: tokenValue
+                    ? tokenValue * fallbackCurrencyToNativeCurrencyConversionRate
+                    : undefined });
+        }, {});
+    });
 };
+/**
+ * Create a defered Promise.
+ *
+ * TODO: Migrate this to utils
+ *
+ * @param args - The arguments.
+ * @param args.suppressUnhandledRejection - This option adds an empty error handler
+ * to the Promise to suppress the UnhandledPromiseRejection error. This can be
+ * useful if the deferred Promise is sometimes intentionally not used.
+ * @returns A deferred Promise.
+ */
+function createDeferredPromise({ suppressUnhandledRejection = false, }) {
+    let resolve;
+    let reject;
+    const promise = new Promise((innerResolve, innerReject) => {
+        resolve = innerResolve;
+        reject = innerReject;
+    });
+    if (suppressUnhandledRejection) {
+        promise.catch((_error) => {
+            // This handler is used to suppress the UnhandledPromiseRejection error
+        });
+    }
+    return { promise, resolve, reject };
+}
 exports.default = TokenRatesController;
 //# sourceMappingURL=TokenRatesController.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenRatesController.js.map b/node_modules/@metamask/assets-controllers/dist/TokenRatesController.js.map
index 6a23041..5ad6fee 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenRatesController.js.map
+++ b/node_modules/@metamask/assets-controllers/dist/TokenRatesController.js.map
@@ -1 +1 @@
-{"version":3,"file":"TokenRatesController.js","sourceRoot":"","sources":["../src/TokenRatesController.ts"],"names":[],"mappings":"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","sourcesContent":["import type { BaseConfig, BaseState } from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport {\n  safelyExecute,\n  handleFetch,\n  toChecksumHexAddress,\n  FALL_BACK_VS_CURRENCY,\n  toHex,\n} from '@metamask/controller-utils';\nimport type { NetworkState } from '@metamask/network-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport type { Hex } from '@metamask/utils';\n\nimport { fetchExchangeRate as fetchNativeExchangeRate } from './crypto-compare';\nimport type { TokensState } from './TokensController';\n\n/**\n * @type CoinGeckoResponse\n *\n * CoinGecko API response representation\n */\nexport interface CoinGeckoResponse {\n  [address: string]: {\n    [currency: string]: number;\n  };\n}\n/**\n * @type CoinGeckoPlatform\n *\n * CoinGecko supported platform API representation\n */\nexport interface CoinGeckoPlatform {\n  id: string;\n  chain_identifier: null | number;\n  name: string;\n  shortname: string;\n}\n\n/**\n * @type Token\n *\n * Token representation\n * @property address - Hex address of the token contract\n * @property decimals - Number of decimals the token uses\n * @property symbol - Symbol of the token\n * @property image - Image of the token, url or bit32 image\n */\nexport interface Token {\n  address: string;\n  decimals: number;\n  symbol: string;\n  aggregators?: string[];\n  image?: string;\n  balanceError?: unknown;\n  isERC721?: boolean;\n  name?: string;\n}\n\n/**\n * @type TokenRatesConfig\n *\n * Token rates controller configuration\n * @property interval - Polling interval used to fetch new token rates\n * @property nativeCurrency - Current native currency selected to use base of rates\n * @property chainId - Current network chainId\n * @property tokens - List of tokens to track exchange rates for\n * @property threshold - Threshold to invalidate the supportedChains\n */\nexport interface TokenRatesConfig extends BaseConfig {\n  interval: number;\n  nativeCurrency: string;\n  chainId: Hex;\n  selectedAddress: string;\n  allTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n  allDetectedTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n  threshold: number;\n}\n\ninterface ContractExchangeRates {\n  [address: string]: number | undefined;\n}\n\ninterface SupportedChainsCache {\n  timestamp: number;\n  data: CoinGeckoPlatform[] | null;\n}\n\ninterface SupportedVsCurrenciesCache {\n  timestamp: number;\n  data: string[];\n}\n\nenum PollState {\n  Active = 'Active',\n  Inactive = 'Inactive',\n}\n\n/**\n * @type TokenRatesState\n *\n * Token rates controller state\n * @property contractExchangeRates - Hash of token contract addresses to exchange rates\n * @property supportedChains - Cached chain data\n */\nexport interface TokenRatesState extends BaseState {\n  contractExchangeRates: ContractExchangeRates;\n}\n\nconst CoinGeckoApi = {\n  BASE_URL: 'https://api.coingecko.com/api/v3',\n  getTokenPriceURL(chainSlug: string, query: string) {\n    return `${this.BASE_URL}/simple/token_price/${chainSlug}?${query}`;\n  },\n  getPlatformsURL() {\n    return `${this.BASE_URL}/asset_platforms`;\n  },\n  getSupportedVsCurrencies() {\n    return `${this.BASE_URL}/simple/supported_vs_currencies`;\n  },\n};\n\n/**\n * Finds the chain slug in the data array given a chainId.\n *\n * @param chainId - The current chain ID.\n * @param data - A list platforms supported by the CoinGecko API.\n * @returns The CoinGecko slug for the given chain ID, or `null` if the slug was not found.\n */\nfunction findChainSlug(\n  chainId: Hex,\n  data: CoinGeckoPlatform[] | null,\n): string | null {\n  if (!data) {\n    return null;\n  }\n  const chain =\n    data.find(\n      ({ chain_identifier }) =>\n        chain_identifier !== null && toHex(chain_identifier) === chainId,\n    ) ?? null;\n  return chain?.id || null;\n}\n\n/**\n * Controller that passively polls on a set interval for token-to-fiat exchange rates\n * for tokens stored in the TokensController\n */\nexport class TokenRatesController extends BaseController<\n  TokenRatesConfig,\n  TokenRatesState\n> {\n  private handle?: ReturnType<typeof setTimeout>;\n\n  private tokenList: Token[] = [];\n\n  private supportedChains: SupportedChainsCache = {\n    timestamp: 0,\n    data: null,\n  };\n\n  private supportedVsCurrencies: SupportedVsCurrenciesCache = {\n    timestamp: 0,\n    data: [],\n  };\n\n  #pollState = PollState.Inactive;\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'TokenRatesController';\n\n  /**\n   * Creates a TokenRatesController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.ticker - The ticker for the current network.\n   * @param options.selectedAddress - The current selected address.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.onTokensStateChange - Allows subscribing to token controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network state changes.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      chainId: initialChainId,\n      ticker: initialTicker,\n      selectedAddress: initialSelectedAddress,\n      onPreferencesStateChange,\n      onTokensStateChange,\n      onNetworkStateChange,\n    }: {\n      chainId: Hex;\n      ticker: string;\n      selectedAddress: string;\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onTokensStateChange: (\n        listener: (tokensState: TokensState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n    },\n    config?: Partial<TokenRatesConfig>,\n    state?: Partial<TokenRatesState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      disabled: false,\n      interval: 3 * 60 * 1000,\n      nativeCurrency: initialTicker,\n      chainId: initialChainId,\n      selectedAddress: initialSelectedAddress,\n      allTokens: {}, // TODO: initialize these correctly, maybe as part of BaseControllerV2 migration\n      allDetectedTokens: {},\n      threshold: 6 * 60 * 60 * 1000,\n    };\n\n    this.defaultState = {\n      contractExchangeRates: {},\n    };\n    this.initialize();\n    if (config?.disabled) {\n      this.configure({ disabled: true }, false, false);\n    }\n    this.#updateTokenList();\n\n    onPreferencesStateChange(async ({ selectedAddress }) => {\n      if (this.config.selectedAddress !== selectedAddress) {\n        this.configure({ selectedAddress });\n        this.#updateTokenList();\n        if (this.#pollState === PollState.Active) {\n          await this.updateExchangeRates();\n        }\n      }\n    });\n\n    onTokensStateChange(async ({ allTokens, allDetectedTokens }) => {\n      // These two state properties are assumed to be immutable\n      if (\n        this.config.allTokens !== allTokens ||\n        this.config.allDetectedTokens !== allDetectedTokens\n      ) {\n        this.configure({ allTokens, allDetectedTokens });\n        this.#updateTokenList();\n        if (this.#pollState === PollState.Active) {\n          await this.updateExchangeRates();\n        }\n      }\n    });\n\n    onNetworkStateChange(async ({ providerConfig }) => {\n      const { chainId, ticker } = providerConfig;\n      if (\n        this.config.chainId !== chainId ||\n        this.config.nativeCurrency !== ticker\n      ) {\n        this.update({ contractExchangeRates: {} });\n        this.configure({ chainId, nativeCurrency: ticker });\n        this.#updateTokenList();\n        if (this.#pollState === PollState.Active) {\n          await this.updateExchangeRates();\n        }\n      }\n    });\n  }\n\n  #updateTokenList() {\n    const { allTokens, allDetectedTokens } = this.config;\n    const tokens =\n      allTokens[this.config.chainId]?.[this.config.selectedAddress] || [];\n    const detectedTokens =\n      allDetectedTokens[this.config.chainId]?.[this.config.selectedAddress] ||\n      [];\n    this.tokenList = [...tokens, ...detectedTokens];\n  }\n\n  /**\n   * Start (or restart) polling.\n   */\n  async start() {\n    this.#stopPoll();\n    this.#pollState = PollState.Active;\n    await this.#poll();\n  }\n\n  /**\n   * Stop polling.\n   */\n  stop() {\n    this.#stopPoll();\n    this.#pollState = PollState.Inactive;\n  }\n\n  /**\n   * Clear the active polling timer, if present.\n   */\n  #stopPoll() {\n    if (this.handle) {\n      clearTimeout(this.handle);\n    }\n  }\n\n  /**\n   * Poll for exchange rate updates.\n   */\n  async #poll() {\n    await safelyExecute(() => this.updateExchangeRates());\n\n    // Poll using recursive `setTimeout` instead of `setInterval` so that\n    // requests don't stack if they take longer than the polling interval\n    this.handle = setTimeout(() => {\n      this.#poll();\n    }, this.config.interval);\n  }\n\n  /**\n   * Fetches a pairs of token address and native currency.\n   *\n   * @param chainSlug - Chain string identifier.\n   * @param vsCurrency - Query according to tokens in tokenList and native currency.\n   * @returns The exchange rates for the given pairs.\n   */\n  async fetchExchangeRate(\n    chainSlug: string,\n    vsCurrency: string,\n  ): Promise<CoinGeckoResponse> {\n    const tokenPairs = this.tokenList.map((token) => token.address).join(',');\n    const query = `contract_addresses=${tokenPairs}&vs_currencies=${vsCurrency.toLowerCase()}`;\n    return handleFetch(CoinGeckoApi.getTokenPriceURL(chainSlug, query));\n  }\n\n  /**\n   * Checks if the current native currency is a supported vs currency to use\n   * to query for token exchange rates.\n   *\n   * @param nativeCurrency - The native currency of the currently active network.\n   * @returns A boolean indicating whether it's a supported vsCurrency.\n   */\n  private async checkIsSupportedVsCurrency(nativeCurrency: string) {\n    const { threshold } = this.config;\n    const { timestamp, data } = this.supportedVsCurrencies;\n\n    const now = Date.now();\n\n    if (now - timestamp > threshold) {\n      const currencies = await handleFetch(\n        CoinGeckoApi.getSupportedVsCurrencies(),\n      );\n      this.supportedVsCurrencies = {\n        data: currencies,\n        timestamp: Date.now(),\n      };\n      return currencies.includes(nativeCurrency.toLowerCase());\n    }\n\n    return data.includes(nativeCurrency.toLowerCase());\n  }\n\n  /**\n   * Gets current chain ID slug from cached supported platforms CoinGecko API response.\n   * If cached supported platforms response is stale, fetches and updates it.\n   *\n   * @returns The CoinGecko slug for the current chain ID.\n   */\n  async getChainSlug(): Promise<string | null> {\n    const { threshold, chainId } = this.config;\n    const { data, timestamp } = this.supportedChains;\n\n    const now = Date.now();\n\n    if (now - timestamp > threshold) {\n      const platforms = await handleFetch(CoinGeckoApi.getPlatformsURL());\n      this.supportedChains = {\n        data: platforms,\n        timestamp: Date.now(),\n      };\n      return findChainSlug(chainId, platforms);\n    }\n\n    return findChainSlug(chainId, data);\n  }\n\n  /**\n   * Updates exchange rates for all tokens.\n   */\n  async updateExchangeRates() {\n    if (this.tokenList.length === 0 || this.disabled) {\n      return;\n    }\n    const slug = await this.getChainSlug();\n\n    let newContractExchangeRates: ContractExchangeRates = {};\n    if (!slug) {\n      this.tokenList.forEach((token) => {\n        const address = toChecksumHexAddress(token.address);\n        newContractExchangeRates[address] = undefined;\n      });\n    } else {\n      const { nativeCurrency } = this.config;\n      newContractExchangeRates = await this.fetchAndMapExchangeRates(\n        nativeCurrency,\n        slug,\n      );\n    }\n    this.update({ contractExchangeRates: newContractExchangeRates });\n  }\n\n  /**\n   * Checks if the active network's native currency is supported by the coingecko API.\n   * If supported, it fetches and maps contractExchange rates to a format to be consumed by the UI.\n   * If not supported, it fetches contractExchange rates and maps them from token/fallback-currency\n   * to token/nativeCurrency.\n   *\n   * @param nativeCurrency - The native currency of the currently active network.\n   * @param slug - The unique slug used to id the chain by the coingecko api\n   * should be used to query token exchange rates.\n   * @returns An object with conversion rates for each token\n   * related to the network's native currency.\n   */\n  async fetchAndMapExchangeRates(\n    nativeCurrency: string,\n    slug: string,\n  ): Promise<ContractExchangeRates> {\n    const contractExchangeRates: ContractExchangeRates = {};\n\n    // check if native currency is supported as a vs_currency by the API\n    const nativeCurrencySupported = await this.checkIsSupportedVsCurrency(\n      nativeCurrency,\n    );\n\n    if (nativeCurrencySupported) {\n      // If it is we can do a simple fetch against the CoinGecko API\n      const prices = await this.fetchExchangeRate(slug, nativeCurrency);\n      this.tokenList.forEach((token) => {\n        const price = prices[token.address.toLowerCase()];\n        contractExchangeRates[toChecksumHexAddress(token.address)] = price\n          ? price[nativeCurrency.toLowerCase()]\n          : 0;\n      });\n    } else {\n      // if native currency is not supported we need to use a fallback vsCurrency, get the exchange rates\n      // in token/fallback-currency format and convert them to expected token/nativeCurrency format.\n      let tokenExchangeRates;\n      let vsCurrencyToNativeCurrencyConversionRate = 0;\n      try {\n        [\n          tokenExchangeRates,\n          { conversionRate: vsCurrencyToNativeCurrencyConversionRate },\n        ] = await Promise.all([\n          this.fetchExchangeRate(slug, FALL_BACK_VS_CURRENCY),\n          fetchNativeExchangeRate(nativeCurrency, FALL_BACK_VS_CURRENCY, false),\n        ]);\n      } catch (error) {\n        if (\n          error instanceof Error &&\n          error.message.includes('market does not exist for this coin pair')\n        ) {\n          return {};\n        }\n        throw error;\n      }\n\n      for (const [tokenAddress, conversion] of Object.entries(\n        tokenExchangeRates,\n      )) {\n        const tokenToVsCurrencyConversionRate =\n          conversion[FALL_BACK_VS_CURRENCY.toLowerCase()];\n        contractExchangeRates[toChecksumHexAddress(tokenAddress)] =\n          tokenToVsCurrencyConversionRate *\n          vsCurrencyToNativeCurrencyConversionRate;\n      }\n    }\n\n    return contractExchangeRates;\n  }\n}\n\nexport default TokenRatesController;\n"]}
\ No newline at end of file
+{"version":3,"file":"TokenRatesController.js","sourceRoot":"","sources":["../src/TokenRatesController.ts"],"names":[],"mappings":"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","sourcesContent":["import { BaseController } from '@metamask/base-controller';\nimport type { BaseConfig, BaseState } from '@metamask/base-controller';\nimport {\n  safelyExecute,\n  toChecksumHexAddress,\n  FALL_BACK_VS_CURRENCY,\n  toHex,\n} from '@metamask/controller-utils';\nimport type { NetworkState } from '@metamask/network-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport type { Hex } from '@metamask/utils';\nimport { isEqual } from 'lodash';\n\nimport { reduceInBatchesSerially } from './assetsUtil';\nimport { fetchExchangeRate as fetchNativeCurrencyExchangeRate } from './crypto-compare';\nimport type { AbstractTokenPricesService } from './token-prices-service/abstract-token-prices-service';\nimport type { TokensState } from './TokensController';\n\n/**\n * @type Token\n *\n * Token representation\n * @property address - Hex address of the token contract\n * @property decimals - Number of decimals the token uses\n * @property symbol - Symbol of the token\n * @property image - Image of the token, url or bit32 image\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface Token {\n  address: string;\n  decimals: number;\n  symbol: string;\n  aggregators?: string[];\n  image?: string;\n  balanceError?: unknown;\n  isERC721?: boolean;\n  name?: string;\n}\n\n/**\n * @type TokenRatesConfig\n *\n * Token rates controller configuration\n * @property interval - Polling interval used to fetch new token rates\n * @property nativeCurrency - Current native currency selected to use base of rates\n * @property chainId - Current network chainId\n * @property tokens - List of tokens to track exchange rates for\n * @property threshold - Threshold to invalidate the supportedChains\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface TokenRatesConfig extends BaseConfig {\n  interval: number;\n  nativeCurrency: string;\n  chainId: Hex;\n  selectedAddress: string;\n  allTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n  allDetectedTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n  threshold: number;\n}\n\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\ninterface ContractExchangeRates {\n  [address: string]: number | undefined;\n}\n\nenum PollState {\n  Active = 'Active',\n  Inactive = 'Inactive',\n}\n\n/**\n * @type TokenRatesState\n *\n * Token rates controller state\n * @property contractExchangeRates - Hash of token contract addresses to exchange rates (single globally selected chain, will be deprecated soon)\n * @property contractExchangeRatesByChainId - Hash of token contract addresses to exchange rates keyed by chain ID and native currency (ticker)\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface TokenRatesState extends BaseState {\n  contractExchangeRates: ContractExchangeRates;\n  contractExchangeRatesByChainId: Record<\n    string,\n    Record<string, ContractExchangeRates>\n  >;\n}\n\n/**\n * The maximum number of token addresses that should be sent to the Price API in\n * a single request.\n */\nconst TOKEN_PRICES_BATCH_SIZE = 30;\n\n/**\n * Uses the CryptoCompare API to fetch the exchange rate between one currency\n * and another, i.e., the multiplier to apply the amount of one currency in\n * order to convert it to another.\n *\n * @param args - The arguments to this function.\n * @param args.from - The currency to convert from.\n * @param args.to - The currency to convert to.\n * @returns The exchange rate between `fromCurrency` to `toCurrency` if one\n * exists, or null if one does not.\n */\nasync function getCurrencyConversionRate({\n  from,\n  to,\n}: {\n  from: string;\n  to: string;\n}) {\n  const includeUSDRate = false;\n  try {\n    const result = await fetchNativeCurrencyExchangeRate(\n      to,\n      from,\n      includeUSDRate,\n    );\n    return result.conversionRate;\n  } catch (error) {\n    if (\n      error instanceof Error &&\n      error.message.includes('market does not exist for this coin pair')\n    ) {\n      return null;\n    }\n    throw error;\n  }\n}\n\n/**\n * Controller that passively polls on a set interval for token-to-fiat exchange rates\n * for tokens stored in the TokensController\n */\n// This is using BaseController on BaseController v3, which relates to BaseController V1\n// When rebase this patch doesn't forget about change this to `BaseController` instead of `BaseControllerV1`\nexport class TokenRatesController extends BaseController<\n  TokenRatesConfig,\n  TokenRatesState\n> {\n  private handle?: ReturnType<typeof setTimeout>;\n\n  #pollState = PollState.Inactive;\n\n  #tokenPricesService: AbstractTokenPricesService;\n\n  #inProcessExchangeRateUpdates: Record<`${string}:${string}`, Promise<void>> =\n    {};\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'TokenRatesController';\n\n  /**\n   * Creates a TokenRatesController instance.\n   *\n   * @param options - The controller options.\n   * @param options.interval - The polling interval in ms\n   * @param options.threshold - The duration in ms before metadata fetched from CoinGecko is considered stale\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.ticker - The ticker for the current network.\n   * @param options.selectedAddress - The current selected address.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.onTokensStateChange - Allows subscribing to token controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network state changes.\n   * @param options.tokenPricesService - An object in charge of retrieving token prices.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      interval = 3 * 60 * 1000,\n      threshold = 6 * 60 * 60 * 1000,\n      chainId: initialChainId,\n      ticker: initialTicker,\n      selectedAddress: initialSelectedAddress,\n      onPreferencesStateChange,\n      onTokensStateChange,\n      onNetworkStateChange,\n      tokenPricesService,\n    }: {\n      interval?: number;\n      threshold?: number;\n      chainId: Hex;\n      ticker: string;\n      selectedAddress: string;\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onTokensStateChange: (\n        listener: (tokensState: TokensState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      tokenPricesService: AbstractTokenPricesService;\n    },\n    config?: Partial<TokenRatesConfig>,\n    state?: Partial<TokenRatesState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      interval,\n      threshold,\n      disabled: false,\n      nativeCurrency: initialTicker,\n      chainId: initialChainId,\n      selectedAddress: initialSelectedAddress,\n      allTokens: {}, // TODO: initialize these correctly, maybe as part of BaseControllerV2 migration\n      allDetectedTokens: {},\n    };\n\n    this.defaultState = {\n      contractExchangeRates: {},\n      contractExchangeRatesByChainId: {},\n    };\n    this.initialize();\n    this.#tokenPricesService = tokenPricesService;\n\n    if (config?.disabled) {\n      this.configure({ disabled: true }, false, false);\n    }\n\n    onPreferencesStateChange(async ({ selectedAddress }) => {\n      if (this.config.selectedAddress !== selectedAddress) {\n        this.configure({ selectedAddress });\n        if (this.#pollState === PollState.Active) {\n          await this.updateExchangeRates();\n        }\n      }\n    });\n\n    onTokensStateChange(async ({ allTokens, allDetectedTokens }) => {\n      const previousTokenAddresses = this.#getTokenAddresses(\n        this.config.chainId,\n      );\n      this.configure({ allTokens, allDetectedTokens });\n      const newTokenAddresses = this.#getTokenAddresses(this.config.chainId);\n      if (\n        !isEqual(previousTokenAddresses, newTokenAddresses) &&\n        this.#pollState === PollState.Active\n      ) {\n        await this.updateExchangeRates();\n      }\n    });\n\n    onNetworkStateChange(async ({ providerConfig }) => {\n      const { chainId, ticker } = providerConfig;\n      if (\n        this.config.chainId !== chainId ||\n        this.config.nativeCurrency !== ticker\n      ) {\n        this.update({ contractExchangeRates: {} });\n        this.configure({ chainId, nativeCurrency: ticker || 'ETH' });\n        if (this.#pollState === PollState.Active) {\n          await this.updateExchangeRates();\n        }\n      }\n    });\n  }\n\n  /**\n   * Get the user's tokens for the given chain.\n   *\n   * @param chainId - The chain ID.\n   * @returns The list of tokens addresses for the current chain\n   */\n  #getTokenAddresses(chainId: Hex): Hex[] {\n    const { allTokens, allDetectedTokens } = this.config;\n    const tokens = allTokens[chainId]?.[this.config.selectedAddress] || [];\n    const detectedTokens =\n      allDetectedTokens[chainId]?.[this.config.selectedAddress] || [];\n\n    return [\n      ...new Set(\n        [...tokens, ...detectedTokens].map((token) =>\n          toHex(toChecksumHexAddress(token.address)),\n        ),\n      ),\n    ].sort();\n  }\n\n  /**\n   * Start (or restart) polling.\n   */\n  async start() {\n    this.#stopPoll();\n    this.#pollState = PollState.Active;\n    await this.#poll();\n  }\n\n  /**\n   * Stop polling.\n   */\n  stop() {\n    this.#stopPoll();\n    this.#pollState = PollState.Inactive;\n  }\n\n  /**\n   * Clear the active polling timer, if present.\n   */\n  #stopPoll() {\n    if (this.handle) {\n      clearTimeout(this.handle);\n    }\n  }\n\n  /**\n   * Poll for exchange rate updates.\n   */\n  async #poll() {\n    await safelyExecute(() => this.updateExchangeRates());\n\n    // Poll using recursive `setTimeout` instead of `setInterval` so that\n    // requests don't stack if they take longer than the polling interval\n    this.handle = setTimeout(() => {\n      this.#poll();\n    }, this.config.interval);\n  }\n\n  /**\n   * Updates exchange rates for all tokens.\n   */\n  async updateExchangeRates() {\n    const { chainId, nativeCurrency } = this.config;\n\n    if (this.disabled) {\n      return;\n    }\n\n    const tokenAddresses = this.#getTokenAddresses(chainId);\n    if (tokenAddresses.length === 0) {\n      return;\n    }\n\n    const updateKey: `${string}:${string}` = `${chainId}:${nativeCurrency}`;\n    if (updateKey in this.#inProcessExchangeRateUpdates) {\n      // This prevents redundant updates\n      // This promise is resolved after the in-progress update has finished,\n      // and state has been updated.\n      await this.#inProcessExchangeRateUpdates[updateKey];\n      return;\n    }\n\n    const {\n      promise: inProgressUpdate,\n      resolve: updateSucceeded,\n      reject: updateFailed,\n    } = createDeferredPromise({ suppressUnhandledRejection: true });\n    this.#inProcessExchangeRateUpdates[updateKey] = inProgressUpdate;\n\n    try {\n      const newContractExchangeRates = await this.#fetchAndMapExchangeRates({\n        tokenAddresses,\n        chainId,\n        nativeCurrency,\n      });\n\n      const existingContractExchangeRates = this.state.contractExchangeRates;\n      const updatedContractExchangeRates =\n        chainId === this.config.chainId &&\n        nativeCurrency === this.config.nativeCurrency\n          ? newContractExchangeRates\n          : existingContractExchangeRates;\n\n      const existingContractExchangeRatesForChainId =\n        this.state.contractExchangeRatesByChainId[chainId] ?? {};\n      const updatedContractExchangeRatesForChainId = {\n        ...this.state.contractExchangeRatesByChainId,\n        [chainId]: {\n          ...existingContractExchangeRatesForChainId,\n          [nativeCurrency]: {\n            ...existingContractExchangeRatesForChainId[nativeCurrency],\n            ...newContractExchangeRates,\n          },\n        },\n      };\n\n      this.update({\n        contractExchangeRates: updatedContractExchangeRates,\n        contractExchangeRatesByChainId: updatedContractExchangeRatesForChainId,\n      });\n      updateSucceeded();\n    } catch (error: unknown) {\n      updateFailed(error);\n      throw error;\n    } finally {\n      delete this.#inProcessExchangeRateUpdates[updateKey];\n    }\n  }\n\n  /**\n   * Uses the token prices service to retrieve exchange rates for tokens in a\n   * particular currency.\n   *\n   * If the price API does not support the given chain ID, returns an empty\n   * object.\n   *\n   * If the price API does not support the given currency, retrieves exchange\n   * rates in a known currency instead, then converts those rates using the\n   * exchange rate between the known currency and desired currency.\n   *\n   * @param args - The arguments to this function.\n   * @param args.tokenAddresses - Addresses for tokens.\n   * @param args.chainId - The EIP-155 ID of the chain where the tokens live.\n   * @param args.nativeCurrency - The native currency in which to request\n   * exchange rates.\n   * @returns A map from token address to its exchange rate in the native\n   * currency, or an empty map if no exchange rates can be obtained for the\n   * chain ID.\n   */\n  async #fetchAndMapExchangeRates({\n    tokenAddresses,\n    chainId,\n    nativeCurrency,\n  }: {\n    tokenAddresses: Hex[];\n    chainId: Hex;\n    nativeCurrency: string;\n  }): Promise<ContractExchangeRates> {\n    if (!this.#tokenPricesService.validateChainIdSupported(chainId)) {\n      return tokenAddresses.reduce((obj, tokenAddress) => {\n        return {\n          ...obj,\n          [tokenAddress]: undefined,\n        };\n      }, {});\n    }\n\n    if (this.#tokenPricesService.validateCurrencySupported(nativeCurrency)) {\n      return await this.#fetchAndMapExchangeRatesForSupportedNativeCurrency({\n        tokenAddresses,\n        chainId,\n        nativeCurrency,\n      });\n    }\n\n    return await this.#fetchAndMapExchangeRatesForUnsupportedNativeCurrency({\n      tokenAddresses,\n      nativeCurrency,\n    });\n  }\n\n  /**\n   * Retrieves prices in the given currency for the given tokens on the given\n   * chain. Ensures that token addresses are checksum addresses.\n   *\n   * @param args - The arguments to this function.\n   * @param args.tokenAddresses - Addresses for tokens.\n   * @param args.chainId - The EIP-155 ID of the chain where the tokens live.\n   * @param args.nativeCurrency - The native currency in which to request\n   * prices.\n   * @returns A map of the token addresses (as checksums) to their prices in the\n   * native currency.\n   */\n  async #fetchAndMapExchangeRatesForSupportedNativeCurrency({\n    tokenAddresses,\n    chainId,\n    nativeCurrency,\n  }: {\n    tokenAddresses: Hex[];\n    chainId: Hex;\n    nativeCurrency: string;\n  }): Promise<ContractExchangeRates> {\n    const tokenPricesByTokenAddress = await reduceInBatchesSerially<\n      Hex,\n      Awaited<ReturnType<AbstractTokenPricesService['fetchTokenPrices']>>\n    >({\n      values: [...tokenAddresses].sort(),\n      batchSize: TOKEN_PRICES_BATCH_SIZE,\n      eachBatch: async (allTokenPricesByTokenAddress, batch) => {\n        const tokenPricesByTokenAddressForBatch =\n          await this.#tokenPricesService.fetchTokenPrices({\n            tokenAddresses: batch,\n            chainId,\n            currency: nativeCurrency,\n          });\n\n        return {\n          ...allTokenPricesByTokenAddress,\n          ...tokenPricesByTokenAddressForBatch,\n        };\n      },\n      initialResult: {},\n    });\n\n    return Object.entries(tokenPricesByTokenAddress).reduce(\n      (obj, [tokenAddress, tokenPrice]) => {\n        return {\n          ...obj,\n          [tokenAddress]: tokenPrice?.value,\n        };\n      },\n      {},\n    );\n  }\n\n  /**\n   * If the price API does not support a given native currency, then we need to\n   * convert it to a fallback currency and feed that currency into the price\n   * API, then convert the prices to our desired native currency.\n   *\n   * @param args - The arguments to this function.\n   * @param args.tokenAddresses - Addresses for tokens.\n   * @param args.nativeCurrency - The native currency in which to request\n   * prices.\n   * @returns A map of the token addresses (as checksums) to their prices in the\n   * native currency.\n   */\n  async #fetchAndMapExchangeRatesForUnsupportedNativeCurrency({\n    tokenAddresses,\n    nativeCurrency,\n  }: {\n    tokenAddresses: Hex[];\n    nativeCurrency: string;\n  }): Promise<ContractExchangeRates> {\n    const [\n      contractExchangeRates,\n      fallbackCurrencyToNativeCurrencyConversionRate,\n    ] = await Promise.all([\n      this.#fetchAndMapExchangeRatesForSupportedNativeCurrency({\n        tokenAddresses,\n        chainId: this.config.chainId,\n        nativeCurrency: FALL_BACK_VS_CURRENCY,\n      }),\n      getCurrencyConversionRate({\n        from: FALL_BACK_VS_CURRENCY,\n        to: nativeCurrency,\n      }),\n    ]);\n\n    if (fallbackCurrencyToNativeCurrencyConversionRate === null) {\n      return {};\n    }\n\n    return Object.entries(contractExchangeRates).reduce(\n      (obj, [tokenAddress, tokenValue]) => {\n        return {\n          ...obj,\n          [tokenAddress]: tokenValue\n            ? tokenValue * fallbackCurrencyToNativeCurrencyConversionRate\n            : undefined,\n        };\n      },\n      {},\n    );\n  }\n}\n\n/**\n * A deferred Promise.\n *\n * A deferred Promise is one that can be resolved or rejected independently of\n * the Promise construction.\n */\ntype DeferredPromise = {\n  /**\n   * The Promise that has been deferred.\n   */\n  promise: Promise<void>;\n  /**\n   * A function that resolves the Promise.\n   */\n  resolve: () => void;\n  /**\n   * A function that rejects the Promise.\n   */\n  reject: (error: unknown) => void;\n};\n\n/**\n * Create a defered Promise.\n *\n * TODO: Migrate this to utils\n *\n * @param args - The arguments.\n * @param args.suppressUnhandledRejection - This option adds an empty error handler\n * to the Promise to suppress the UnhandledPromiseRejection error. This can be\n * useful if the deferred Promise is sometimes intentionally not used.\n * @returns A deferred Promise.\n */\nfunction createDeferredPromise({\n  suppressUnhandledRejection = false,\n}: {\n  suppressUnhandledRejection: boolean;\n}): DeferredPromise {\n  let resolve: DeferredPromise['resolve'];\n  let reject: DeferredPromise['reject'];\n  const promise = new Promise<void>(\n    (innerResolve: () => void, innerReject: () => void) => {\n      resolve = innerResolve;\n      reject = innerReject;\n    },\n  );\n\n  if (suppressUnhandledRejection) {\n    promise.catch((_error) => {\n      // This handler is used to suppress the UnhandledPromiseRejection error\n    });\n  }\n\n  return { promise, resolve, reject };\n}\n\nexport default TokenRatesController;\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/TokensController.d.ts b/node_modules/@metamask/assets-controllers/dist/TokensController.d.ts
index 188ebf8..8af7b38 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokensController.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/TokensController.d.ts
@@ -1,15 +1,14 @@
 /// <reference types="node" />
+import { AddApprovalRequest } from '@metamask/approval-controller';
 import { Contract } from '@ethersproject/contracts';
-import type { AddApprovalRequest } from '@metamask/approval-controller';
-import type { BaseConfig, BaseState, RestrictedControllerMessenger } from '@metamask/base-controller';
-import { BaseController } from '@metamask/base-controller';
+import { BaseController, BaseConfig, BaseState, RestrictedControllerMessenger } from '@metamask/base-controller';
+import type { Token } from './TokenRatesController';
+import { TokenListState } from './TokenListController';
 import type { NetworkClientId, NetworkController, NetworkState } from '@metamask/network-controller';
 import type { PreferencesState } from '@metamask/preferences-controller';
 import type { Hex } from '@metamask/utils';
 import { EventEmitter } from 'events';
 import type { AssetsContractController } from './AssetsContractController';
-import type { TokenListState } from './TokenListController';
-import type { Token } from './TokenRatesController';
 /**
  * @type TokensConfig
  *
@@ -85,9 +84,10 @@ export declare type TokensControllerMessenger = RestrictedControllerMessenger<ty
  * Controller that stores assets and exposes convenience methods
  */
 export declare class TokensController extends BaseController<TokensConfig, TokensState> {
-    private readonly mutex;
+    private mutex;
     private abortController;
-    private readonly messagingSystem;
+    private messagingSystem;
+    private getERC20TokenName;
     /**
      * Fetch metadata for a token.
      *
@@ -98,12 +98,11 @@ export declare class TokensController extends BaseController<TokensConfig, Token
     /**
      * EventEmitter instance used to listen to specific EIP747 events
      */
-    hub: EventEmitter;
+    hub: EventEmitter<[never]>;
     /**
      * Name of this controller used during composition
      */
     name: string;
-    private readonly getERC20TokenName;
     private readonly getNetworkClientById;
     /**
      * Creates a TokensController instance.
@@ -118,6 +117,7 @@ export declare class TokensController extends BaseController<TokensConfig, Token
      * @param options.config - Initial options used to configure this controller.
      * @param options.state - Initial state to set on this controller.
      * @param options.messenger - The controller messenger.
+     * @param options.getERC20TokenName - Allows fetch an ERC-20 token name
      */
     constructor({ chainId: initialChainId, onPreferencesStateChange, onNetworkStateChange, onTokenListStateChange, getERC20TokenName, getNetworkClientById, config, state, messenger, }: {
         chainId: Hex;
diff --git a/node_modules/@metamask/assets-controllers/dist/TokensController.d.ts.map b/node_modules/@metamask/assets-controllers/dist/TokensController.d.ts.map
index 7f9dd91..69211a2 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokensController.d.ts.map
+++ b/node_modules/@metamask/assets-controllers/dist/TokensController.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"TokensController.d.ts","sourceRoot":"","sources":["../src/TokensController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"TokensController.d.ts","sourceRoot":"","sources":["../src/TokensController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/TokensController.js b/node_modules/@metamask/assets-controllers/dist/TokensController.js
index 83a970d..88a810f 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokensController.js
+++ b/node_modules/@metamask/assets-controllers/dist/TokensController.js
@@ -13,12 +13,13 @@ var __importDefault = (this && this.__importDefault) || function (mod) {
 };
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.TokensController = void 0;
+const contract_metadata_1 = __importDefault(require("@metamask/contract-metadata"));
 const contracts_1 = require("@ethersproject/contracts");
 const providers_1 = require("@ethersproject/providers");
 const base_controller_1 = require("@metamask/base-controller");
-const contract_metadata_1 = __importDefault(require("@metamask/contract-metadata"));
 const controller_utils_1 = require("@metamask/controller-utils");
 const metamask_eth_abis_1 = require("@metamask/metamask-eth-abis");
+const abort_controller_1 = require("abort-controller");
 const async_mutex_1 = require("async-mutex");
 const events_1 = require("events");
 const uuid_1 = require("uuid");
@@ -45,6 +46,7 @@ class TokensController extends base_controller_1.BaseController {
      * @param options.config - Initial options used to configure this controller.
      * @param options.state - Initial state to set on this controller.
      * @param options.messenger - The controller messenger.
+     * @param options.getERC20TokenName - Allows fetch an ERC-20 token name
      */
     constructor({ chainId: initialChainId, onPreferencesStateChange, onNetworkStateChange, onTokenListStateChange, getERC20TokenName, getNetworkClientById, config, state, messenger, }) {
         super(config, state);
@@ -60,7 +62,7 @@ class TokensController extends base_controller_1.BaseController {
         this.defaultConfig = Object.assign({ selectedAddress: '', chainId: initialChainId, provider: undefined }, config);
         this.defaultState = Object.assign({ tokens: [], ignoredTokens: [], detectedTokens: [], allTokens: {}, allIgnoredTokens: {}, allDetectedTokens: {} }, state);
         this.initialize();
-        this.abortController = new AbortController();
+        this.abortController = new abort_controller_1.AbortController();
         this.getERC20TokenName = getERC20TokenName;
         this.getNetworkClientById = getNetworkClientById;
         this.messagingSystem = messenger;
@@ -81,7 +83,7 @@ class TokensController extends base_controller_1.BaseController {
             const { selectedAddress } = this.config;
             const { chainId } = providerConfig;
             this.abortController.abort();
-            this.abortController = new AbortController();
+            this.abortController = new abort_controller_1.AbortController();
             this.configure({ chainId });
             this.update({
                 tokens: ((_a = allTokens[chainId]) === null || _a === void 0 ? void 0 : _a[selectedAddress]) || [],
@@ -105,7 +107,9 @@ class TokensController extends base_controller_1.BaseController {
     fetchTokenMetadata(tokenAddress) {
         return __awaiter(this, void 0, void 0, function* () {
             try {
-                const token = yield (0, token_service_1.fetchTokenMetadata)(this.config.chainId, tokenAddress, this.abortController.signal);
+                const token = yield (0, token_service_1.fetchTokenMetadata)(this.config.chainId, tokenAddress, 
+                // @ts-expect-error Ignore this typescript issue
+                this.abortController.signal);
                 return token;
             }
             catch (error) {
@@ -133,9 +137,8 @@ class TokensController extends base_controller_1.BaseController {
     addToken({ address, symbol, decimals, name, image, interactingAddress, networkClientId, }) {
         var _a, _b, _c;
         return __awaiter(this, void 0, void 0, function* () {
-            const { chainId, selectedAddress } = this.config;
-            const releaseLock = yield this.mutex.acquire();
             const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
+            const { chainId, selectedAddress } = this.config;
             let currentChainId = chainId;
             if (networkClientId) {
                 currentChainId =
@@ -143,6 +146,7 @@ class TokensController extends base_controller_1.BaseController {
             }
             const accountAddress = interactingAddress || selectedAddress;
             const isInteractingWithWalletAccount = accountAddress === selectedAddress;
+            const releaseLock = yield this.mutex.acquire();
             try {
                 address = (0, controller_utils_1.toChecksumHexAddress)(address);
                 const tokens = ((_a = allTokens[currentChainId]) === null || _a === void 0 ? void 0 : _a[accountAddress]) || [];
@@ -151,10 +155,8 @@ class TokensController extends base_controller_1.BaseController {
                 const newTokens = [...tokens];
                 const [isERC721, tokenMetadata] = yield Promise.all([
                     this._detectIsERC721(address, networkClientId),
-                    // TODO parameterize the token metadata fetch by networkClientId
                     this.fetchTokenMetadata(address),
                 ]);
-                // TODO remove this once this method is fully parameterized by networkClientId
                 if (!networkClientId && currentChainId !== this.config.chainId) {
                     throw new Error('TokensController Error: Switched networks while adding token');
                 }
diff --git a/node_modules/@metamask/assets-controllers/dist/TokensController.js.map b/node_modules/@metamask/assets-controllers/dist/TokensController.js.map
index e9011e5..976b35f 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokensController.js.map
+++ b/node_modules/@metamask/assets-controllers/dist/TokensController.js.map
@@ -1 +1 @@
-{"version":3,"file":"TokensController.js","sourceRoot":"","sources":["../src/TokensController.ts"],"names":[],"mappings":"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","sourcesContent":["import { Contract } from '@ethersproject/contracts';\nimport { Web3Provider } from '@ethersproject/providers';\nimport type { AddApprovalRequest } from '@metamask/approval-controller';\nimport type {\n  BaseConfig,\n  BaseState,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport contractsMap from '@metamask/contract-metadata';\nimport {\n  toChecksumHexAddress,\n  ERC721_INTERFACE_ID,\n  ORIGIN_METAMASK,\n  ApprovalType,\n  ERC20,\n} from '@metamask/controller-utils';\nimport { abiERC721 } from '@metamask/metamask-eth-abis';\nimport type {\n  NetworkClientId,\n  NetworkController,\n  NetworkState,\n} from '@metamask/network-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport type { Hex } from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\nimport { EventEmitter } from 'events';\nimport { v1 as random } from 'uuid';\n\nimport type { AssetsContractController } from './AssetsContractController';\nimport {\n  formatAggregatorNames,\n  formatIconUrlWithProxy,\n  validateTokenToWatch,\n} from './assetsUtil';\nimport {\n  fetchTokenMetadata,\n  TOKEN_METADATA_NO_SUPPORT_ERROR,\n} from './token-service';\nimport type {\n  TokenListMap,\n  TokenListState,\n  TokenListToken,\n} from './TokenListController';\nimport type { Token } from './TokenRatesController';\n\n/**\n * @type TokensConfig\n *\n * Tokens controller configuration\n * @property selectedAddress - Vault selected address\n */\nexport interface TokensConfig extends BaseConfig {\n  selectedAddress: string;\n  chainId: Hex;\n  provider: any;\n}\n\n/**\n * @type SuggestedAssetMeta\n *\n * Suggested asset by EIP747 meta data\n * @property id - Generated UUID associated with this suggested asset\n * @property time - Timestamp associated with this this suggested asset\n * @property type - Type type this suggested asset\n * @property asset - Asset suggested object\n * @property interactingAddress - Account address that requested watch asset\n */\ntype SuggestedAssetMeta = {\n  id: string;\n  time: number;\n  type: string;\n  asset: Token;\n  interactingAddress: string;\n};\n\n/**\n * @type TokensState\n *\n * Assets controller state\n * @property tokens - List of tokens associated with the active network and address pair\n * @property ignoredTokens - List of ignoredTokens associated with the active network and address pair\n * @property detectedTokens - List of detected tokens associated with the active network and address pair\n * @property allTokens - Object containing tokens by network and account\n * @property allIgnoredTokens - Object containing hidden/ignored tokens by network and account\n * @property allDetectedTokens - Object containing tokens detected with non-zero balances\n */\nexport interface TokensState extends BaseState {\n  tokens: Token[];\n  ignoredTokens: string[];\n  detectedTokens: Token[];\n  allTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n  allIgnoredTokens: { [chainId: Hex]: { [key: string]: string[] } };\n  allDetectedTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n}\n\n/**\n * The name of the {@link TokensController}.\n */\nconst controllerName = 'TokensController';\n\n/**\n * The external actions available to the {@link TokensController}.\n */\ntype AllowedActions = AddApprovalRequest;\n\n/**\n * The messenger of the {@link TokensController}.\n */\nexport type TokensControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  AllowedActions,\n  never,\n  AllowedActions['type'],\n  never\n>;\n\n/**\n * Controller that stores assets and exposes convenience methods\n */\nexport class TokensController extends BaseController<\n  TokensConfig,\n  TokensState\n> {\n  private readonly mutex = new Mutex();\n\n  private abortController: AbortController;\n\n  private readonly messagingSystem: TokensControllerMessenger;\n\n  /**\n   * Fetch metadata for a token.\n   *\n   * @param tokenAddress - The address of the token.\n   * @returns The token metadata.\n   */\n  private async fetchTokenMetadata(\n    tokenAddress: string,\n  ): Promise<TokenListToken | undefined> {\n    try {\n      const token = await fetchTokenMetadata<TokenListToken>(\n        this.config.chainId,\n        tokenAddress,\n        this.abortController.signal,\n      );\n      return token;\n    } catch (error) {\n      if (\n        error instanceof Error &&\n        error.message.includes(TOKEN_METADATA_NO_SUPPORT_ERROR)\n      ) {\n        return undefined;\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * EventEmitter instance used to listen to specific EIP747 events\n   */\n  hub = new EventEmitter();\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'TokensController';\n\n  private readonly getERC20TokenName: AssetsContractController['getERC20TokenName'];\n\n  private readonly getNetworkClientById: NetworkController['getNetworkClientById'];\n\n  /**\n   * Creates a TokensController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param options.onTokenListStateChange - Allows subscribing to token list controller state changes.\n   * @param options.getERC20TokenName - Gets the ERC-20 token name.\n   * @param options.getNetworkClientById - Gets the network client with the given id from the NetworkController.\n   * @param options.config - Initial options used to configure this controller.\n   * @param options.state - Initial state to set on this controller.\n   * @param options.messenger - The controller messenger.\n   */\n  constructor({\n    chainId: initialChainId,\n    onPreferencesStateChange,\n    onNetworkStateChange,\n    onTokenListStateChange,\n    getERC20TokenName,\n    getNetworkClientById,\n    config,\n    state,\n    messenger,\n  }: {\n    chainId: Hex;\n    onPreferencesStateChange: (\n      listener: (preferencesState: PreferencesState) => void,\n    ) => void;\n    onNetworkStateChange: (\n      listener: (networkState: NetworkState) => void,\n    ) => void;\n    onTokenListStateChange: (\n      listener: (tokenListState: TokenListState) => void,\n    ) => void;\n    getERC20TokenName: AssetsContractController['getERC20TokenName'];\n    getNetworkClientById: NetworkController['getNetworkClientById'];\n    config?: Partial<TokensConfig>;\n    state?: Partial<TokensState>;\n    messenger: TokensControllerMessenger;\n  }) {\n    super(config, state);\n\n    this.defaultConfig = {\n      selectedAddress: '',\n      chainId: initialChainId,\n      provider: undefined,\n      ...config,\n    };\n\n    this.defaultState = {\n      tokens: [],\n      ignoredTokens: [],\n      detectedTokens: [],\n      allTokens: {},\n      allIgnoredTokens: {},\n      allDetectedTokens: {},\n      ...state,\n    };\n\n    this.initialize();\n    this.abortController = new AbortController();\n    this.getERC20TokenName = getERC20TokenName;\n    this.getNetworkClientById = getNetworkClientById;\n\n    this.messagingSystem = messenger;\n\n    onPreferencesStateChange(({ selectedAddress }) => {\n      const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n      const { chainId } = this.config;\n      this.configure({ selectedAddress });\n      this.update({\n        tokens: allTokens[chainId]?.[selectedAddress] || [],\n        ignoredTokens: allIgnoredTokens[chainId]?.[selectedAddress] || [],\n        detectedTokens: allDetectedTokens[chainId]?.[selectedAddress] || [],\n      });\n    });\n\n    onNetworkStateChange(({ providerConfig }) => {\n      const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n      const { selectedAddress } = this.config;\n      const { chainId } = providerConfig;\n      this.abortController.abort();\n      this.abortController = new AbortController();\n      this.configure({ chainId });\n      this.update({\n        tokens: allTokens[chainId]?.[selectedAddress] || [],\n        ignoredTokens: allIgnoredTokens[chainId]?.[selectedAddress] || [],\n        detectedTokens: allDetectedTokens[chainId]?.[selectedAddress] || [],\n      });\n    });\n\n    onTokenListStateChange(({ tokenList }) => {\n      const { tokens } = this.state;\n      if (tokens.length && !tokens[0].name) {\n        this.updateTokensAttribute(tokenList, 'name');\n      }\n    });\n  }\n\n  /**\n   * Adds a token to the stored token list.\n   *\n   * @param options - The method argument object.\n   * @param options.address - Hex address of the token contract.\n   * @param options.symbol - Symbol of the token.\n   * @param options.decimals - Number of decimals the token uses.\n   * @param options.name - Name of the token.\n   * @param options.image - Image of the token.\n   * @param options.interactingAddress - The address of the account to add a token to.\n   * @param options.networkClientId - Network Client ID.\n   * @returns Current token list.\n   */\n  async addToken({\n    address,\n    symbol,\n    decimals,\n    name,\n    image,\n    interactingAddress,\n    networkClientId,\n  }: {\n    address: string;\n    symbol: string;\n    decimals: number;\n    name?: string;\n    image?: string;\n    interactingAddress?: string;\n    networkClientId?: NetworkClientId;\n  }): Promise<Token[]> {\n    const { chainId, selectedAddress } = this.config;\n    const releaseLock = await this.mutex.acquire();\n    const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n    let currentChainId = chainId;\n    if (networkClientId) {\n      currentChainId =\n        this.getNetworkClientById(networkClientId).configuration.chainId;\n    }\n\n    const accountAddress = interactingAddress || selectedAddress;\n    const isInteractingWithWalletAccount = accountAddress === selectedAddress;\n\n    try {\n      address = toChecksumHexAddress(address);\n      const tokens = allTokens[currentChainId]?.[accountAddress] || [];\n      const ignoredTokens =\n        allIgnoredTokens[currentChainId]?.[accountAddress] || [];\n      const detectedTokens =\n        allDetectedTokens[currentChainId]?.[accountAddress] || [];\n      const newTokens: Token[] = [...tokens];\n      const [isERC721, tokenMetadata] = await Promise.all([\n        this._detectIsERC721(address, networkClientId),\n        // TODO parameterize the token metadata fetch by networkClientId\n        this.fetchTokenMetadata(address),\n      ]);\n      // TODO remove this once this method is fully parameterized by networkClientId\n      if (!networkClientId && currentChainId !== this.config.chainId) {\n        throw new Error(\n          'TokensController Error: Switched networks while adding token',\n        );\n      }\n      const newEntry: Token = {\n        address,\n        symbol,\n        decimals,\n        image:\n          image ||\n          formatIconUrlWithProxy({\n            chainId: currentChainId,\n            tokenAddress: address,\n          }),\n        isERC721,\n        aggregators: formatAggregatorNames(tokenMetadata?.aggregators || []),\n        name,\n      };\n      const previousIndex = newTokens.findIndex(\n        (token) => token.address.toLowerCase() === address.toLowerCase(),\n      );\n      if (previousIndex !== -1) {\n        newTokens[previousIndex] = newEntry;\n      } else {\n        newTokens.push(newEntry);\n      }\n\n      const newIgnoredTokens = ignoredTokens.filter(\n        (tokenAddress) => tokenAddress.toLowerCase() !== address.toLowerCase(),\n      );\n      const newDetectedTokens = detectedTokens.filter(\n        (token) => token.address.toLowerCase() !== address.toLowerCase(),\n      );\n\n      const { newAllTokens, newAllIgnoredTokens, newAllDetectedTokens } =\n        this._getNewAllTokensState({\n          newTokens,\n          newIgnoredTokens,\n          newDetectedTokens,\n          interactingAddress: accountAddress,\n          interactingChainId: currentChainId,\n        });\n\n      let newState: Partial<TokensState> = {\n        allTokens: newAllTokens,\n        allIgnoredTokens: newAllIgnoredTokens,\n        allDetectedTokens: newAllDetectedTokens,\n      };\n\n      // Only update active tokens if user is interacting with their active wallet account.\n      if (isInteractingWithWalletAccount) {\n        newState = {\n          ...newState,\n          tokens: newTokens,\n          ignoredTokens: newIgnoredTokens,\n          detectedTokens: newDetectedTokens,\n        };\n      }\n\n      this.update(newState);\n      return newTokens;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Add a batch of tokens.\n   *\n   * @param tokensToImport - Array of tokens to import.\n   * @param networkClientId - Optional network client ID used to determine interacting chain ID.\n   */\n  async addTokens(tokensToImport: Token[], networkClientId?: NetworkClientId) {\n    const releaseLock = await this.mutex.acquire();\n    const { tokens, detectedTokens, ignoredTokens } = this.state;\n    const importedTokensMap: { [key: string]: true } = {};\n    // Used later to dedupe imported tokens\n    const newTokensMap = tokens.reduce((output, current) => {\n      output[current.address] = current;\n      return output;\n    }, {} as { [address: string]: Token });\n    try {\n      tokensToImport.forEach((tokenToAdd) => {\n        const { address, symbol, decimals, image, aggregators, name } =\n          tokenToAdd;\n        const checksumAddress = toChecksumHexAddress(address);\n        const formattedToken: Token = {\n          address: checksumAddress,\n          symbol,\n          decimals,\n          image,\n          aggregators,\n          name,\n        };\n        newTokensMap[address] = formattedToken;\n        importedTokensMap[address.toLowerCase()] = true;\n        return formattedToken;\n      });\n      const newTokens = Object.values(newTokensMap);\n\n      const newDetectedTokens = detectedTokens.filter(\n        (token) => !importedTokensMap[token.address.toLowerCase()],\n      );\n      const newIgnoredTokens = ignoredTokens.filter(\n        (tokenAddress) => !newTokensMap[tokenAddress.toLowerCase()],\n      );\n\n      let interactingChainId;\n      if (networkClientId) {\n        interactingChainId =\n          this.getNetworkClientById(networkClientId).configuration.chainId;\n      }\n\n      const { newAllTokens, newAllDetectedTokens, newAllIgnoredTokens } =\n        this._getNewAllTokensState({\n          newTokens,\n          newDetectedTokens,\n          newIgnoredTokens,\n          interactingChainId,\n        });\n\n      this.update({\n        tokens: newTokens,\n        allTokens: newAllTokens,\n        detectedTokens: newDetectedTokens,\n        allDetectedTokens: newAllDetectedTokens,\n        ignoredTokens: newIgnoredTokens,\n        allIgnoredTokens: newAllIgnoredTokens,\n      });\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Ignore a batch of tokens.\n   *\n   * @param tokenAddressesToIgnore - Array of token addresses to ignore.\n   */\n  ignoreTokens(tokenAddressesToIgnore: string[]) {\n    const { ignoredTokens, detectedTokens, tokens } = this.state;\n    const ignoredTokensMap: { [key: string]: true } = {};\n    let newIgnoredTokens: string[] = [...ignoredTokens];\n\n    const checksummedTokenAddresses = tokenAddressesToIgnore.map((address) => {\n      const checksumAddress = toChecksumHexAddress(address);\n      ignoredTokensMap[address.toLowerCase()] = true;\n      return checksumAddress;\n    });\n    newIgnoredTokens = [...ignoredTokens, ...checksummedTokenAddresses];\n    const newDetectedTokens = detectedTokens.filter(\n      (token) => !ignoredTokensMap[token.address.toLowerCase()],\n    );\n    const newTokens = tokens.filter(\n      (token) => !ignoredTokensMap[token.address.toLowerCase()],\n    );\n\n    const { newAllIgnoredTokens, newAllDetectedTokens, newAllTokens } =\n      this._getNewAllTokensState({\n        newIgnoredTokens,\n        newDetectedTokens,\n        newTokens,\n      });\n\n    this.update({\n      ignoredTokens: newIgnoredTokens,\n      tokens: newTokens,\n      detectedTokens: newDetectedTokens,\n      allIgnoredTokens: newAllIgnoredTokens,\n      allDetectedTokens: newAllDetectedTokens,\n      allTokens: newAllTokens,\n    });\n  }\n\n  /**\n   * Adds a batch of detected tokens to the stored token list.\n   *\n   * @param incomingDetectedTokens - Array of detected tokens to be added or updated.\n   * @param detectionDetails - An object containing the chain ID and address of the currently selected network on which the incomingDetectedTokens were detected.\n   * @param detectionDetails.selectedAddress - the account address on which the incomingDetectedTokens were detected.\n   * @param detectionDetails.chainId - the chainId on which the incomingDetectedTokens were detected.\n   */\n  async addDetectedTokens(\n    incomingDetectedTokens: Token[],\n    detectionDetails?: { selectedAddress: string; chainId: Hex },\n  ) {\n    const releaseLock = await this.mutex.acquire();\n\n    // Get existing tokens for the chain + account\n    const chainId = detectionDetails?.chainId ?? this.config.chainId;\n    const accountAddress =\n      detectionDetails?.selectedAddress ?? this.config.selectedAddress;\n\n    const { allTokens, allDetectedTokens, allIgnoredTokens } = this.state;\n    let newTokens = [...(allTokens?.[chainId]?.[accountAddress] ?? [])];\n    let newDetectedTokens = [\n      ...(allDetectedTokens?.[chainId]?.[accountAddress] ?? []),\n    ];\n\n    try {\n      incomingDetectedTokens.forEach((tokenToAdd) => {\n        const {\n          address,\n          symbol,\n          decimals,\n          image,\n          aggregators,\n          isERC721,\n          name,\n        } = tokenToAdd;\n        const checksumAddress = toChecksumHexAddress(address);\n        const newEntry: Token = {\n          address: checksumAddress,\n          symbol,\n          decimals,\n          image,\n          isERC721,\n          aggregators,\n          name,\n        };\n        const previousImportedIndex = newTokens.findIndex(\n          (token) =>\n            token.address.toLowerCase() === checksumAddress.toLowerCase(),\n        );\n        if (previousImportedIndex !== -1) {\n          // Update existing data of imported token\n          newTokens[previousImportedIndex] = newEntry;\n        } else {\n          const ignoredTokenIndex =\n            allIgnoredTokens?.[chainId]?.[accountAddress]?.indexOf(address) ??\n            -1;\n\n          if (ignoredTokenIndex === -1) {\n            // Add detected token\n            const previousDetectedIndex = newDetectedTokens.findIndex(\n              (token) =>\n                token.address.toLowerCase() === checksumAddress.toLowerCase(),\n            );\n            if (previousDetectedIndex !== -1) {\n              newDetectedTokens[previousDetectedIndex] = newEntry;\n            } else {\n              newDetectedTokens.push(newEntry);\n            }\n          }\n        }\n      });\n\n      const { newAllTokens, newAllDetectedTokens } = this._getNewAllTokensState(\n        {\n          newTokens,\n          newDetectedTokens,\n          interactingAddress: accountAddress,\n          interactingChainId: chainId,\n        },\n      );\n\n      // We may be detecting tokens on a different chain/account pair than are currently configured.\n      // Re-point `tokens` and `detectedTokens` to keep them referencing the current chain/account.\n      const { chainId: currentChain, selectedAddress: currentAddress } =\n        this.config;\n\n      newTokens = newAllTokens?.[currentChain]?.[currentAddress] || [];\n      newDetectedTokens =\n        newAllDetectedTokens?.[currentChain]?.[currentAddress] || [];\n\n      this.update({\n        tokens: newTokens,\n        allTokens: newAllTokens,\n        detectedTokens: newDetectedTokens,\n        allDetectedTokens: newAllDetectedTokens,\n      });\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Adds isERC721 field to token object. This is called when a user attempts to add tokens that\n   * were previously added which do not yet had isERC721 field.\n   *\n   * @param tokenAddress - The contract address of the token requiring the isERC721 field added.\n   * @returns The new token object with the added isERC721 field.\n   */\n  async updateTokenType(tokenAddress: string) {\n    const isERC721 = await this._detectIsERC721(tokenAddress);\n    const { tokens } = this.state;\n    const tokenIndex = tokens.findIndex((token) => {\n      return token.address.toLowerCase() === tokenAddress.toLowerCase();\n    });\n    tokens[tokenIndex].isERC721 = isERC721;\n    this.update({ tokens });\n    return tokens[tokenIndex];\n  }\n\n  /**\n   * This is a function that updates the tokens name for the tokens name if it is not defined.\n   *\n   * @param tokenList - Represents the fetched token list from service API\n   * @param tokenAttribute - Represents the token attribute that we want to update on the token list\n   */\n  private updateTokensAttribute(\n    tokenList: TokenListMap,\n    tokenAttribute: keyof Token & keyof TokenListToken,\n  ) {\n    const { tokens } = this.state;\n\n    const newTokens = tokens.map((token) => {\n      const newToken = tokenList[token.address.toLowerCase()];\n\n      return !token[tokenAttribute] && newToken?.[tokenAttribute]\n        ? { ...token, [tokenAttribute]: newToken[tokenAttribute] }\n        : { ...token };\n    });\n\n    this.update({ tokens: newTokens });\n  }\n\n  /**\n   * Detects whether or not a token is ERC-721 compatible.\n   *\n   * @param tokenAddress - The token contract address.\n   * @param networkClientId - Optional network client ID to fetch contract info with.\n   * @returns A boolean indicating whether the token address passed in supports the EIP-721\n   * interface.\n   */\n  async _detectIsERC721(\n    tokenAddress: string,\n    networkClientId?: NetworkClientId,\n  ) {\n    const checksumAddress = toChecksumHexAddress(tokenAddress);\n    // if this token is already in our contract metadata map we don't need\n    // to check against the contract\n    if (contractsMap[checksumAddress]?.erc721 === true) {\n      return Promise.resolve(true);\n    } else if (contractsMap[checksumAddress]?.erc20 === true) {\n      return Promise.resolve(false);\n    }\n\n    const tokenContract = this._createEthersContract(\n      tokenAddress,\n      abiERC721,\n      networkClientId,\n    );\n    try {\n      return await tokenContract.supportsInterface(ERC721_INTERFACE_ID);\n    } catch (error: any) {\n      // currently we see a variety of errors across different networks when\n      // token contracts are not ERC721 compatible. We need to figure out a better\n      // way of differentiating token interface types but for now if we get an error\n      // we have to assume the token is not ERC721 compatible.\n      return false;\n    }\n  }\n\n  _createEthersContract(\n    tokenAddress: string,\n    abi: string,\n    networkClientId?: NetworkClientId,\n  ): Contract {\n    const provider = networkClientId\n      ? this.getNetworkClientById(networkClientId).provider\n      : this.config?.provider;\n\n    const web3provider = new Web3Provider(provider);\n    const tokenContract = new Contract(tokenAddress, abi, web3provider);\n    return tokenContract;\n  }\n\n  _generateRandomId(): string {\n    return random();\n  }\n\n  /**\n   * Adds a new suggestedAsset to the list of watched assets.\n   * Parameters will be validated according to the asset type being watched.\n   *\n   * @param options - The method options.\n   * @param options.asset - The asset to be watched. For now only ERC20 tokens are accepted.\n   * @param options.type - The asset type.\n   * @param options.interactingAddress - The address of the account that is requesting to watch the asset.\n   * @param options.networkClientId - Network Client ID.\n   * @returns Object containing a Promise resolving to the suggestedAsset address if accepted.\n   */\n  async watchAsset({\n    asset,\n    type,\n    interactingAddress,\n    networkClientId,\n  }: {\n    asset: Token;\n    type: string;\n    interactingAddress?: string;\n    networkClientId?: NetworkClientId;\n  }): Promise<void> {\n    if (type !== ERC20) {\n      throw new Error(`Asset of type ${type} not supported`);\n    }\n\n    const { selectedAddress } = this.config;\n\n    const suggestedAssetMeta: SuggestedAssetMeta = {\n      asset,\n      id: this._generateRandomId(),\n      time: Date.now(),\n      type,\n      interactingAddress: interactingAddress || selectedAddress,\n    };\n\n    validateTokenToWatch(asset);\n\n    await this._requestApproval(suggestedAssetMeta);\n\n    let name;\n    try {\n      name = await this.getERC20TokenName(asset.address, networkClientId);\n    } catch (error) {\n      name = undefined;\n    }\n\n    const { address, symbol, decimals, image } = asset;\n    await this.addToken({\n      address,\n      symbol,\n      decimals,\n      name,\n      image,\n      interactingAddress: suggestedAssetMeta.interactingAddress,\n      networkClientId,\n    });\n  }\n\n  /**\n   * Takes a new tokens and ignoredTokens array for the current network/account combination\n   * and returns new allTokens and allIgnoredTokens state to update to.\n   *\n   * @param params - Object that holds token params.\n   * @param params.newTokens - The new tokens to set for the current network and selected account.\n   * @param params.newIgnoredTokens - The new ignored tokens to set for the current network and selected account.\n   * @param params.newDetectedTokens - The new detected tokens to set for the current network and selected account.\n   * @param params.interactingAddress - The account address to use to store the tokens.\n   * @param params.interactingChainId - The chainId to use to store the tokens.\n   * @returns The updated `allTokens` and `allIgnoredTokens` state.\n   */\n  _getNewAllTokensState(params: {\n    newTokens?: Token[];\n    newIgnoredTokens?: string[];\n    newDetectedTokens?: Token[];\n    interactingAddress?: string;\n    interactingChainId?: Hex;\n  }) {\n    const {\n      newTokens,\n      newIgnoredTokens,\n      newDetectedTokens,\n      interactingAddress,\n      interactingChainId,\n    } = params;\n    const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n    const { chainId, selectedAddress } = this.config;\n\n    const userAddressToAddTokens = interactingAddress ?? selectedAddress;\n    const chainIdToAddTokens = interactingChainId ?? chainId;\n\n    let newAllTokens = allTokens;\n    if (\n      newTokens?.length ||\n      (newTokens &&\n        allTokens &&\n        allTokens[chainIdToAddTokens] &&\n        allTokens[chainIdToAddTokens][userAddressToAddTokens])\n    ) {\n      const networkTokens = allTokens[chainIdToAddTokens];\n      const newNetworkTokens = {\n        ...networkTokens,\n        ...{ [userAddressToAddTokens]: newTokens },\n      };\n      newAllTokens = {\n        ...allTokens,\n        ...{ [chainIdToAddTokens]: newNetworkTokens },\n      };\n    }\n\n    let newAllIgnoredTokens = allIgnoredTokens;\n    if (\n      newIgnoredTokens?.length ||\n      (newIgnoredTokens &&\n        allIgnoredTokens &&\n        allIgnoredTokens[chainIdToAddTokens] &&\n        allIgnoredTokens[chainIdToAddTokens][userAddressToAddTokens])\n    ) {\n      const networkIgnoredTokens = allIgnoredTokens[chainIdToAddTokens];\n      const newIgnoredNetworkTokens = {\n        ...networkIgnoredTokens,\n        ...{ [userAddressToAddTokens]: newIgnoredTokens },\n      };\n      newAllIgnoredTokens = {\n        ...allIgnoredTokens,\n        ...{ [chainIdToAddTokens]: newIgnoredNetworkTokens },\n      };\n    }\n\n    let newAllDetectedTokens = allDetectedTokens;\n    if (\n      newDetectedTokens?.length ||\n      (newDetectedTokens &&\n        allDetectedTokens &&\n        allDetectedTokens[chainIdToAddTokens] &&\n        allDetectedTokens[chainIdToAddTokens][userAddressToAddTokens])\n    ) {\n      const networkDetectedTokens = allDetectedTokens[chainIdToAddTokens];\n      const newDetectedNetworkTokens = {\n        ...networkDetectedTokens,\n        ...{ [userAddressToAddTokens]: newDetectedTokens },\n      };\n      newAllDetectedTokens = {\n        ...allDetectedTokens,\n        ...{ [chainIdToAddTokens]: newDetectedNetworkTokens },\n      };\n    }\n    return { newAllTokens, newAllIgnoredTokens, newAllDetectedTokens };\n  }\n\n  /**\n   * Removes all tokens from the ignored list.\n   */\n  clearIgnoredTokens() {\n    this.update({ ignoredTokens: [], allIgnoredTokens: {} });\n  }\n\n  async _requestApproval(suggestedAssetMeta: SuggestedAssetMeta) {\n    return this.messagingSystem.call(\n      'ApprovalController:addRequest',\n      {\n        id: suggestedAssetMeta.id,\n        origin: ORIGIN_METAMASK,\n        type: ApprovalType.WatchAsset,\n        requestData: {\n          id: suggestedAssetMeta.id,\n          interactingAddress: suggestedAssetMeta.interactingAddress,\n          asset: {\n            address: suggestedAssetMeta.asset.address,\n            decimals: suggestedAssetMeta.asset.decimals,\n            symbol: suggestedAssetMeta.asset.symbol,\n            image: suggestedAssetMeta.asset.image || null,\n          },\n        },\n      },\n      true,\n    );\n  }\n}\n\nexport default TokensController;\n"]}
\ No newline at end of file
+{"version":3,"file":"TokensController.js","sourceRoot":"","sources":["../src/TokensController.ts"],"names":[],"mappings":"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","sourcesContent":["import { AddApprovalRequest } from '@metamask/approval-controller';\nimport contractsMap from '@metamask/contract-metadata';\nimport { Contract } from '@ethersproject/contracts';\nimport { Web3Provider } from '@ethersproject/providers';\nimport {\n  BaseController,\n  BaseConfig,\n  BaseState,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport {\n  toChecksumHexAddress,\n  ERC721_INTERFACE_ID,\n  ORIGIN_METAMASK,\n  ApprovalType,\n  ERC20,\n} from '@metamask/controller-utils';\nimport type { Token } from './TokenRatesController';\nimport {\n  TokenListMap,\n  TokenListToken,\n  TokenListState,\n} from './TokenListController';\nimport { abiERC721 } from '@metamask/metamask-eth-abis';\nimport type {\n  NetworkClientId,\n  NetworkController,\n  NetworkState,\n} from '@metamask/network-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport type { Hex } from '@metamask/utils';\nimport { AbortController as WhatwgAbortController } from 'abort-controller';\nimport { Mutex } from 'async-mutex';\nimport { EventEmitter } from 'events';\nimport { v1 as random } from 'uuid';\n\nimport type { AssetsContractController } from './AssetsContractController';\nimport {\n  formatAggregatorNames,\n  formatIconUrlWithProxy,\n  validateTokenToWatch,\n} from './assetsUtil';\nimport {\n  fetchTokenMetadata,\n  TOKEN_METADATA_NO_SUPPORT_ERROR,\n} from './token-service';\n\n/**\n * @type TokensConfig\n *\n * Tokens controller configuration\n * @property selectedAddress - Vault selected address\n */\nexport interface TokensConfig extends BaseConfig {\n  selectedAddress: string;\n  chainId: Hex;\n  provider: any;\n}\n\n/**\n * @type SuggestedAssetMeta\n *\n * Suggested asset by EIP747 meta data\n * @property id - Generated UUID associated with this suggested asset\n * @property time - Timestamp associated with this this suggested asset\n * @property type - Type type this suggested asset\n * @property asset - Asset suggested object\n * @property interactingAddress - Account address that requested watch asset\n */\ntype SuggestedAssetMeta = {\n  id: string;\n  time: number;\n  type: string;\n  asset: Token;\n  interactingAddress: string;\n};\n\n/**\n * @type TokensState\n *\n * Assets controller state\n * @property tokens - List of tokens associated with the active network and address pair\n * @property ignoredTokens - List of ignoredTokens associated with the active network and address pair\n * @property detectedTokens - List of detected tokens associated with the active network and address pair\n * @property allTokens - Object containing tokens by network and account\n * @property allIgnoredTokens - Object containing hidden/ignored tokens by network and account\n * @property allDetectedTokens - Object containing tokens detected with non-zero balances\n */\nexport interface TokensState extends BaseState {\n  tokens: Token[];\n  ignoredTokens: string[];\n  detectedTokens: Token[];\n  allTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n  allIgnoredTokens: { [chainId: Hex]: { [key: string]: string[] } };\n  allDetectedTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n}\n\n/**\n * The name of the {@link TokensController}.\n */\nconst controllerName = 'TokensController';\n\n/**\n * The external actions available to the {@link TokensController}.\n */\ntype AllowedActions = AddApprovalRequest;\n\n/**\n * The messenger of the {@link TokensController}.\n */\nexport type TokensControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  AllowedActions,\n  never,\n  AllowedActions['type'],\n  never\n>;\n\n/**\n * Controller that stores assets and exposes convenience methods\n */\nexport class TokensController extends BaseController<\n  TokensConfig,\n  TokensState\n> {\n  private mutex = new Mutex();\n\n  private abortController: WhatwgAbortController;\n\n  private messagingSystem: TokensControllerMessenger;\n\n  private getERC20TokenName: AssetsContractController['getERC20TokenName'];\n\n  /**\n   * Fetch metadata for a token.\n   *\n   * @param tokenAddress - The address of the token.\n   * @returns The token metadata.\n   */\n  private async fetchTokenMetadata(\n    tokenAddress: string,\n  ): Promise<TokenListToken | undefined> {\n    try {\n      const token = await fetchTokenMetadata<TokenListToken>(\n        this.config.chainId,\n        tokenAddress,\n        // @ts-expect-error Ignore this typescript issue\n        this.abortController.signal,\n      );\n      return token;\n    } catch (error) {\n      if (\n        error instanceof Error &&\n        error.message.includes(TOKEN_METADATA_NO_SUPPORT_ERROR)\n      ) {\n        return undefined;\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * EventEmitter instance used to listen to specific EIP747 events\n   */\n  hub = new EventEmitter();\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'TokensController';\n\n  private readonly getNetworkClientById: NetworkController['getNetworkClientById'];\n\n  /**\n   * Creates a TokensController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param options.onTokenListStateChange - Allows subscribing to token list controller state changes.\n   * @param options.getERC20TokenName - Gets the ERC-20 token name.\n   * @param options.getNetworkClientById - Gets the network client with the given id from the NetworkController.\n   * @param options.config - Initial options used to configure this controller.\n   * @param options.state - Initial state to set on this controller.\n   * @param options.messenger - The controller messenger.\n   * @param options.getERC20TokenName - Allows fetch an ERC-20 token name\n   */\n  constructor({\n    chainId: initialChainId,\n    onPreferencesStateChange,\n    onNetworkStateChange,\n    onTokenListStateChange,\n    getERC20TokenName,\n    getNetworkClientById,\n    config,\n    state,\n    messenger,\n  }: {\n    chainId: Hex;\n    onPreferencesStateChange: (\n      listener: (preferencesState: PreferencesState) => void,\n    ) => void;\n    onNetworkStateChange: (\n      listener: (networkState: NetworkState) => void,\n    ) => void;\n    onTokenListStateChange: (\n      listener: (tokenListState: TokenListState) => void,\n    ) => void;\n    getERC20TokenName: AssetsContractController['getERC20TokenName'];\n    getNetworkClientById: NetworkController['getNetworkClientById'];\n    config?: Partial<TokensConfig>;\n    state?: Partial<TokensState>;\n    messenger: TokensControllerMessenger;\n  }) {\n    super(config, state);\n\n    this.defaultConfig = {\n      selectedAddress: '',\n      chainId: initialChainId,\n      provider: undefined,\n      ...config,\n    };\n\n    this.defaultState = {\n      tokens: [],\n      ignoredTokens: [],\n      detectedTokens: [],\n      allTokens: {},\n      allIgnoredTokens: {},\n      allDetectedTokens: {},\n      ...state,\n    };\n\n    this.initialize();\n    this.abortController = new WhatwgAbortController();\n    this.getERC20TokenName = getERC20TokenName;\n    this.getNetworkClientById = getNetworkClientById;\n\n    this.messagingSystem = messenger;\n\n    onPreferencesStateChange(({ selectedAddress }) => {\n      const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n      const { chainId } = this.config;\n      this.configure({ selectedAddress });\n      this.update({\n        tokens: allTokens[chainId]?.[selectedAddress] || [],\n        ignoredTokens: allIgnoredTokens[chainId]?.[selectedAddress] || [],\n        detectedTokens: allDetectedTokens[chainId]?.[selectedAddress] || [],\n      });\n    });\n\n    onNetworkStateChange(({ providerConfig }) => {\n      const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n      const { selectedAddress } = this.config;\n      const { chainId } = providerConfig;\n      this.abortController.abort();\n      this.abortController = new WhatwgAbortController();\n      this.configure({ chainId });\n      this.update({\n        tokens: allTokens[chainId]?.[selectedAddress] || [],\n        ignoredTokens: allIgnoredTokens[chainId]?.[selectedAddress] || [],\n        detectedTokens: allDetectedTokens[chainId]?.[selectedAddress] || [],\n      });\n    });\n\n    onTokenListStateChange(({ tokenList }) => {\n      const { tokens } = this.state;\n      if (tokens.length && !tokens[0].name) {\n        this.updateTokensAttribute(tokenList, 'name');\n      }\n    });\n  }\n\n  /**\n   * Adds a token to the stored token list.\n   *\n   * @param options - The method argument object.\n   * @param options.address - Hex address of the token contract.\n   * @param options.symbol - Symbol of the token.\n   * @param options.decimals - Number of decimals the token uses.\n   * @param options.name - Name of the token.\n   * @param options.image - Image of the token.\n   * @param options.interactingAddress - The address of the account to add a token to.\n   * @param options.networkClientId - Network Client ID.\n   * @returns Current token list.\n   */\n  async addToken({\n    address,\n    symbol,\n    decimals,\n    name,\n    image,\n    interactingAddress,\n    networkClientId,\n  }: {\n    address: string;\n    symbol: string;\n    decimals: number;\n    name?: string;\n    image?: string;\n    interactingAddress?: string;\n    networkClientId?: NetworkClientId;\n  }): Promise<Token[]> {\n    const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    let currentChainId = chainId;\n    if (networkClientId) {\n      currentChainId =\n        this.getNetworkClientById(networkClientId).configuration.chainId;\n    }\n\n    const accountAddress = interactingAddress || selectedAddress;\n    const isInteractingWithWalletAccount = accountAddress === selectedAddress;\n    const releaseLock = await this.mutex.acquire();\n\n    try {\n      address = toChecksumHexAddress(address);\n      const tokens = allTokens[currentChainId]?.[accountAddress] || [];\n      const ignoredTokens =\n        allIgnoredTokens[currentChainId]?.[accountAddress] || [];\n      const detectedTokens =\n        allDetectedTokens[currentChainId]?.[accountAddress] || [];\n      const newTokens: Token[] = [...tokens];\n      const [isERC721, tokenMetadata] = await Promise.all([\n        this._detectIsERC721(address, networkClientId),\n        this.fetchTokenMetadata(address),\n      ]);\n      if (!networkClientId && currentChainId !== this.config.chainId) {\n        throw new Error(\n          'TokensController Error: Switched networks while adding token',\n        );\n      }\n      const newEntry: Token = {\n        address,\n        symbol,\n        decimals,\n        image:\n          image ||\n          formatIconUrlWithProxy({\n            chainId: currentChainId,\n            tokenAddress: address,\n          }),\n        isERC721,\n        aggregators: formatAggregatorNames(tokenMetadata?.aggregators || []),\n        name,\n      };\n      const previousIndex = newTokens.findIndex(\n        (token) => token.address.toLowerCase() === address.toLowerCase(),\n      );\n      if (previousIndex !== -1) {\n        newTokens[previousIndex] = newEntry;\n      } else {\n        newTokens.push(newEntry);\n      }\n\n      const newIgnoredTokens = ignoredTokens.filter(\n        (tokenAddress) => tokenAddress.toLowerCase() !== address.toLowerCase(),\n      );\n      const newDetectedTokens = detectedTokens.filter(\n        (token) => token.address.toLowerCase() !== address.toLowerCase(),\n      );\n\n      const { newAllTokens, newAllIgnoredTokens, newAllDetectedTokens } =\n        this._getNewAllTokensState({\n          newTokens,\n          newIgnoredTokens,\n          newDetectedTokens,\n          interactingAddress: accountAddress,\n          interactingChainId: currentChainId,\n        });\n\n      let newState: Partial<TokensState> = {\n        allTokens: newAllTokens,\n        allIgnoredTokens: newAllIgnoredTokens,\n        allDetectedTokens: newAllDetectedTokens,\n      };\n\n      // Only update active tokens if user is interacting with their active wallet account.\n      if (isInteractingWithWalletAccount) {\n        newState = {\n          ...newState,\n          tokens: newTokens,\n          ignoredTokens: newIgnoredTokens,\n          detectedTokens: newDetectedTokens,\n        };\n      }\n\n      this.update(newState);\n      return newTokens;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Add a batch of tokens.\n   *\n   * @param tokensToImport - Array of tokens to import.\n   * @param networkClientId - Optional network client ID used to determine interacting chain ID.\n   */\n  async addTokens(tokensToImport: Token[], networkClientId?: NetworkClientId) {\n    const releaseLock = await this.mutex.acquire();\n    const { tokens, detectedTokens, ignoredTokens } = this.state;\n    const importedTokensMap: { [key: string]: true } = {};\n    // Used later to dedupe imported tokens\n    const newTokensMap = tokens.reduce((output, current) => {\n      output[current.address] = current;\n      return output;\n    }, {} as { [address: string]: Token });\n    try {\n      tokensToImport.forEach((tokenToAdd) => {\n        const { address, symbol, decimals, image, aggregators, name } =\n          tokenToAdd;\n        const checksumAddress = toChecksumHexAddress(address);\n        const formattedToken: Token = {\n          address: checksumAddress,\n          symbol,\n          decimals,\n          image,\n          aggregators,\n          name,\n        };\n        newTokensMap[address] = formattedToken;\n        importedTokensMap[address.toLowerCase()] = true;\n        return formattedToken;\n      });\n      const newTokens = Object.values(newTokensMap);\n\n      const newDetectedTokens = detectedTokens.filter(\n        (token) => !importedTokensMap[token.address.toLowerCase()],\n      );\n      const newIgnoredTokens = ignoredTokens.filter(\n        (tokenAddress) => !newTokensMap[tokenAddress.toLowerCase()],\n      );\n\n      let interactingChainId;\n      if (networkClientId) {\n        interactingChainId =\n          this.getNetworkClientById(networkClientId).configuration.chainId;\n      }\n\n      const { newAllTokens, newAllDetectedTokens, newAllIgnoredTokens } =\n        this._getNewAllTokensState({\n          newTokens,\n          newDetectedTokens,\n          newIgnoredTokens,\n          interactingChainId,\n        });\n\n      this.update({\n        tokens: newTokens,\n        allTokens: newAllTokens,\n        detectedTokens: newDetectedTokens,\n        allDetectedTokens: newAllDetectedTokens,\n        ignoredTokens: newIgnoredTokens,\n        allIgnoredTokens: newAllIgnoredTokens,\n      });\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Ignore a batch of tokens.\n   *\n   * @param tokenAddressesToIgnore - Array of token addresses to ignore.\n   */\n  ignoreTokens(tokenAddressesToIgnore: string[]) {\n    const { ignoredTokens, detectedTokens, tokens } = this.state;\n    const ignoredTokensMap: { [key: string]: true } = {};\n    let newIgnoredTokens: string[] = [...ignoredTokens];\n\n    const checksummedTokenAddresses = tokenAddressesToIgnore.map((address) => {\n      const checksumAddress = toChecksumHexAddress(address);\n      ignoredTokensMap[address.toLowerCase()] = true;\n      return checksumAddress;\n    });\n    newIgnoredTokens = [...ignoredTokens, ...checksummedTokenAddresses];\n    const newDetectedTokens = detectedTokens.filter(\n      (token) => !ignoredTokensMap[token.address.toLowerCase()],\n    );\n    const newTokens = tokens.filter(\n      (token) => !ignoredTokensMap[token.address.toLowerCase()],\n    );\n\n    const { newAllIgnoredTokens, newAllDetectedTokens, newAllTokens } =\n      this._getNewAllTokensState({\n        newIgnoredTokens,\n        newDetectedTokens,\n        newTokens,\n      });\n\n    this.update({\n      ignoredTokens: newIgnoredTokens,\n      tokens: newTokens,\n      detectedTokens: newDetectedTokens,\n      allIgnoredTokens: newAllIgnoredTokens,\n      allDetectedTokens: newAllDetectedTokens,\n      allTokens: newAllTokens,\n    });\n  }\n\n  /**\n   * Adds a batch of detected tokens to the stored token list.\n   *\n   * @param incomingDetectedTokens - Array of detected tokens to be added or updated.\n   * @param detectionDetails - An object containing the chain ID and address of the currently selected network on which the incomingDetectedTokens were detected.\n   * @param detectionDetails.selectedAddress - the account address on which the incomingDetectedTokens were detected.\n   * @param detectionDetails.chainId - the chainId on which the incomingDetectedTokens were detected.\n   */\n  async addDetectedTokens(\n    incomingDetectedTokens: Token[],\n    detectionDetails?: { selectedAddress: string; chainId: Hex },\n  ) {\n    const releaseLock = await this.mutex.acquire();\n\n    // Get existing tokens for the chain + account\n    const chainId = detectionDetails?.chainId ?? this.config.chainId;\n    const accountAddress =\n      detectionDetails?.selectedAddress ?? this.config.selectedAddress;\n\n    const { allTokens, allDetectedTokens, allIgnoredTokens } = this.state;\n    let newTokens = [...(allTokens?.[chainId]?.[accountAddress] ?? [])];\n    let newDetectedTokens = [\n      ...(allDetectedTokens?.[chainId]?.[accountAddress] ?? []),\n    ];\n\n    try {\n      incomingDetectedTokens.forEach((tokenToAdd) => {\n        const {\n          address,\n          symbol,\n          decimals,\n          image,\n          aggregators,\n          isERC721,\n          name,\n        } = tokenToAdd;\n        const checksumAddress = toChecksumHexAddress(address);\n        const newEntry: Token = {\n          address: checksumAddress,\n          symbol,\n          decimals,\n          image,\n          isERC721,\n          aggregators,\n          name,\n        };\n        const previousImportedIndex = newTokens.findIndex(\n          (token) =>\n            token.address.toLowerCase() === checksumAddress.toLowerCase(),\n        );\n        if (previousImportedIndex !== -1) {\n          // Update existing data of imported token\n          newTokens[previousImportedIndex] = newEntry;\n        } else {\n          const ignoredTokenIndex =\n            allIgnoredTokens?.[chainId]?.[accountAddress]?.indexOf(address) ??\n            -1;\n\n          if (ignoredTokenIndex === -1) {\n            // Add detected token\n            const previousDetectedIndex = newDetectedTokens.findIndex(\n              (token) =>\n                token.address.toLowerCase() === checksumAddress.toLowerCase(),\n            );\n            if (previousDetectedIndex !== -1) {\n              newDetectedTokens[previousDetectedIndex] = newEntry;\n            } else {\n              newDetectedTokens.push(newEntry);\n            }\n          }\n        }\n      });\n\n      const { newAllTokens, newAllDetectedTokens } = this._getNewAllTokensState(\n        {\n          newTokens,\n          newDetectedTokens,\n          interactingAddress: accountAddress,\n          interactingChainId: chainId,\n        },\n      );\n\n      // We may be detecting tokens on a different chain/account pair than are currently configured.\n      // Re-point `tokens` and `detectedTokens` to keep them referencing the current chain/account.\n      const { chainId: currentChain, selectedAddress: currentAddress } =\n        this.config;\n\n      newTokens = newAllTokens?.[currentChain]?.[currentAddress] || [];\n      newDetectedTokens =\n        newAllDetectedTokens?.[currentChain]?.[currentAddress] || [];\n\n      this.update({\n        tokens: newTokens,\n        allTokens: newAllTokens,\n        detectedTokens: newDetectedTokens,\n        allDetectedTokens: newAllDetectedTokens,\n      });\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Adds isERC721 field to token object. This is called when a user attempts to add tokens that\n   * were previously added which do not yet had isERC721 field.\n   *\n   * @param tokenAddress - The contract address of the token requiring the isERC721 field added.\n   * @returns The new token object with the added isERC721 field.\n   */\n  async updateTokenType(tokenAddress: string) {\n    const isERC721 = await this._detectIsERC721(tokenAddress);\n    const { tokens } = this.state;\n    const tokenIndex = tokens.findIndex((token) => {\n      return token.address.toLowerCase() === tokenAddress.toLowerCase();\n    });\n    tokens[tokenIndex].isERC721 = isERC721;\n    this.update({ tokens });\n    return tokens[tokenIndex];\n  }\n\n  /**\n   * This is a function that updates the tokens name for the tokens name if it is not defined.\n   *\n   * @param tokenList - Represents the fetched token list from service API\n   * @param tokenAttribute - Represents the token attribute that we want to update on the token list\n   */\n  private updateTokensAttribute(\n    tokenList: TokenListMap,\n    tokenAttribute: keyof Token & keyof TokenListToken,\n  ) {\n    const { tokens } = this.state;\n\n    const newTokens = tokens.map((token) => {\n      const newToken = tokenList[token.address.toLowerCase()];\n\n      return !token[tokenAttribute] && newToken?.[tokenAttribute]\n        ? { ...token, [tokenAttribute]: newToken[tokenAttribute] }\n        : { ...token };\n    });\n\n    this.update({ tokens: newTokens });\n  }\n\n  /**\n   * Detects whether or not a token is ERC-721 compatible.\n   *\n   * @param tokenAddress - The token contract address.\n   * @param networkClientId - Optional network client ID to fetch contract info with.\n   * @returns A boolean indicating whether the token address passed in supports the EIP-721\n   * interface.\n   */\n  async _detectIsERC721(\n    tokenAddress: string,\n    networkClientId?: NetworkClientId,\n  ) {\n    const checksumAddress = toChecksumHexAddress(tokenAddress);\n    // if this token is already in our contract metadata map we don't need\n    // to check against the contract\n    if (contractsMap[checksumAddress]?.erc721 === true) {\n      return Promise.resolve(true);\n    } else if (contractsMap[checksumAddress]?.erc20 === true) {\n      return Promise.resolve(false);\n    }\n\n    const tokenContract = this._createEthersContract(\n      tokenAddress,\n      abiERC721,\n      networkClientId,\n    );\n    try {\n      return await tokenContract.supportsInterface(ERC721_INTERFACE_ID);\n    } catch (error: any) {\n      // currently we see a variety of errors across different networks when\n      // token contracts are not ERC721 compatible. We need to figure out a better\n      // way of differentiating token interface types but for now if we get an error\n      // we have to assume the token is not ERC721 compatible.\n      return false;\n    }\n  }\n\n  _createEthersContract(\n    tokenAddress: string,\n    abi: string,\n    networkClientId?: NetworkClientId,\n  ): Contract {\n    const provider = networkClientId\n      ? this.getNetworkClientById(networkClientId).provider\n      : this.config?.provider;\n\n    const web3provider = new Web3Provider(provider);\n    const tokenContract = new Contract(tokenAddress, abi, web3provider);\n    return tokenContract;\n  }\n\n  _generateRandomId(): string {\n    return random();\n  }\n\n  /**\n   * Adds a new suggestedAsset to the list of watched assets.\n   * Parameters will be validated according to the asset type being watched.\n   *\n   * @param options - The method options.\n   * @param options.asset - The asset to be watched. For now only ERC20 tokens are accepted.\n   * @param options.type - The asset type.\n   * @param options.interactingAddress - The address of the account that is requesting to watch the asset.\n   * @param options.networkClientId - Network Client ID.\n   * @returns Object containing a Promise resolving to the suggestedAsset address if accepted.\n   */\n  async watchAsset({\n    asset,\n    type,\n    interactingAddress,\n    networkClientId,\n  }: {\n    asset: Token;\n    type: string;\n    interactingAddress?: string;\n    networkClientId?: NetworkClientId;\n  }): Promise<void> {\n    if (type !== ERC20) {\n      throw new Error(`Asset of type ${type} not supported`);\n    }\n\n    const { selectedAddress } = this.config;\n\n    const suggestedAssetMeta: SuggestedAssetMeta = {\n      asset,\n      id: this._generateRandomId(),\n      time: Date.now(),\n      type,\n      interactingAddress: interactingAddress || selectedAddress,\n    };\n\n    validateTokenToWatch(asset);\n\n    await this._requestApproval(suggestedAssetMeta);\n\n    let name;\n    try {\n      name = await this.getERC20TokenName(asset.address, networkClientId);\n    } catch (error) {\n      name = undefined;\n    }\n\n    const { address, symbol, decimals, image } = asset;\n    await this.addToken({\n      address,\n      symbol,\n      decimals,\n      name,\n      image,\n      interactingAddress: suggestedAssetMeta.interactingAddress,\n      networkClientId,\n    });\n  }\n\n  /**\n   * Takes a new tokens and ignoredTokens array for the current network/account combination\n   * and returns new allTokens and allIgnoredTokens state to update to.\n   *\n   * @param params - Object that holds token params.\n   * @param params.newTokens - The new tokens to set for the current network and selected account.\n   * @param params.newIgnoredTokens - The new ignored tokens to set for the current network and selected account.\n   * @param params.newDetectedTokens - The new detected tokens to set for the current network and selected account.\n   * @param params.interactingAddress - The account address to use to store the tokens.\n   * @param params.interactingChainId - The chainId to use to store the tokens.\n   * @returns The updated `allTokens` and `allIgnoredTokens` state.\n   */\n  _getNewAllTokensState(params: {\n    newTokens?: Token[];\n    newIgnoredTokens?: string[];\n    newDetectedTokens?: Token[];\n    interactingAddress?: string;\n    interactingChainId?: Hex;\n  }) {\n    const {\n      newTokens,\n      newIgnoredTokens,\n      newDetectedTokens,\n      interactingAddress,\n      interactingChainId,\n    } = params;\n    const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n    const { chainId, selectedAddress } = this.config;\n\n    const userAddressToAddTokens = interactingAddress ?? selectedAddress;\n    const chainIdToAddTokens = interactingChainId ?? chainId;\n\n    let newAllTokens = allTokens;\n    if (\n      newTokens?.length ||\n      (newTokens &&\n        allTokens &&\n        allTokens[chainIdToAddTokens] &&\n        allTokens[chainIdToAddTokens][userAddressToAddTokens])\n    ) {\n      const networkTokens = allTokens[chainIdToAddTokens];\n      const newNetworkTokens = {\n        ...networkTokens,\n        ...{ [userAddressToAddTokens]: newTokens },\n      };\n      newAllTokens = {\n        ...allTokens,\n        ...{ [chainIdToAddTokens]: newNetworkTokens },\n      };\n    }\n\n    let newAllIgnoredTokens = allIgnoredTokens;\n    if (\n      newIgnoredTokens?.length ||\n      (newIgnoredTokens &&\n        allIgnoredTokens &&\n        allIgnoredTokens[chainIdToAddTokens] &&\n        allIgnoredTokens[chainIdToAddTokens][userAddressToAddTokens])\n    ) {\n      const networkIgnoredTokens = allIgnoredTokens[chainIdToAddTokens];\n      const newIgnoredNetworkTokens = {\n        ...networkIgnoredTokens,\n        ...{ [userAddressToAddTokens]: newIgnoredTokens },\n      };\n      newAllIgnoredTokens = {\n        ...allIgnoredTokens,\n        ...{ [chainIdToAddTokens]: newIgnoredNetworkTokens },\n      };\n    }\n\n    let newAllDetectedTokens = allDetectedTokens;\n    if (\n      newDetectedTokens?.length ||\n      (newDetectedTokens &&\n        allDetectedTokens &&\n        allDetectedTokens[chainIdToAddTokens] &&\n        allDetectedTokens[chainIdToAddTokens][userAddressToAddTokens])\n    ) {\n      const networkDetectedTokens = allDetectedTokens[chainIdToAddTokens];\n      const newDetectedNetworkTokens = {\n        ...networkDetectedTokens,\n        ...{ [userAddressToAddTokens]: newDetectedTokens },\n      };\n      newAllDetectedTokens = {\n        ...allDetectedTokens,\n        ...{ [chainIdToAddTokens]: newDetectedNetworkTokens },\n      };\n    }\n    return { newAllTokens, newAllIgnoredTokens, newAllDetectedTokens };\n  }\n\n  /**\n   * Removes all tokens from the ignored list.\n   */\n  clearIgnoredTokens() {\n    this.update({ ignoredTokens: [], allIgnoredTokens: {} });\n  }\n\n  async _requestApproval(suggestedAssetMeta: SuggestedAssetMeta) {\n    return this.messagingSystem.call(\n      'ApprovalController:addRequest',\n      {\n        id: suggestedAssetMeta.id,\n        origin: ORIGIN_METAMASK,\n        type: ApprovalType.WatchAsset,\n        requestData: {\n          id: suggestedAssetMeta.id,\n          interactingAddress: suggestedAssetMeta.interactingAddress,\n          asset: {\n            address: suggestedAssetMeta.asset.address,\n            decimals: suggestedAssetMeta.asset.decimals,\n            symbol: suggestedAssetMeta.asset.symbol,\n            image: suggestedAssetMeta.asset.image || null,\n          },\n        },\n      },\n      true,\n    );\n  }\n}\n\nexport default TokensController;\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/assetsUtil.d.ts b/node_modules/@metamask/assets-controllers/dist/assetsUtil.d.ts
index daf52cd..404fcf4 100644
--- a/node_modules/@metamask/assets-controllers/dist/assetsUtil.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/assetsUtil.d.ts
@@ -1,9 +1,9 @@
 /// <reference types="bn.js" />
-import type { BigNumber } from '@ethersproject/bignumber';
 import type { Hex } from '@metamask/utils';
+import { BigNumber } from '@ethersproject/bignumber';
 import { BN } from 'ethereumjs-util';
-import type { Nft, NftMetadata } from './NftController';
-import type { Token } from './TokenRatesController';
+import { Nft, NftMetadata } from './NftController';
+import { Token } from './TokenRatesController';
 /**
  * Compares nft metadata entries to any nft entry.
  * We need this method when comparing a new fetched nft metadata, in case a entry changed to a defined value,
@@ -49,7 +49,11 @@ export declare enum SupportedTokenDetectionNetworks {
     avax = "0xa86a",
     aurora = "0x4e454152",
     linea_goerli = "0xe704",
-    linea_mainnet = "0xe708"
+    linea_mainnet = "0xe708",
+    arbitrum = "0xa4b1",
+    optimism = "0xa",
+    base = "0x2105",
+    zksync = "0x144"
 }
 /**
  * Check if token detection is enabled for certain networks.
@@ -108,4 +112,37 @@ export declare function addUrlProtocolPrefix(urlString: string): string;
  * @returns A BN object.
  */
 export declare function ethersBigNumberToBN(bigNumber: BigNumber): BN;
+/**
+ * Partitions a list of values into groups that are at most `batchSize` in
+ * length.
+ *
+ * @param values - The list of values.
+ * @param args - The remaining arguments.
+ * @param args.batchSize - The desired maximum number of values per batch.
+ * @returns The list of batches.
+ */
+export declare function divideIntoBatches<Value>(values: Value[], { batchSize }: {
+    batchSize: number;
+}): Value[][];
+/**
+ * Constructs an object from processing batches of the given values
+ * sequentially.
+ *
+ * @param args - The arguments to this function.
+ * @param args.values - A list of values to iterate over.
+ * @param args.batchSize - The maximum number of values in each batch.
+ * @param args.eachBatch - A function to call for each batch. This function is
+ * similar to the function that `Array.prototype.reduce` takes, in that it
+ * receives the object that is being built, each batch in the list of batches
+ * and the index, and should return an updated version of the object.
+ * @param args.initialResult - The initial value of the final data structure,
+ * i.e., the value that will be fed into the first call of `eachBatch`.
+ * @returns The built object.
+ */
+export declare function reduceInBatchesSerially<Value, Result extends Record<PropertyKey, unknown>>({ values, batchSize, eachBatch, initialResult, }: {
+    values: Value[];
+    batchSize: number;
+    eachBatch: (workingResult: Partial<Result>, batch: Value[], index: number) => Partial<Result> | Promise<Partial<Result>>;
+    initialResult: Partial<Result>;
+}): Promise<Result>;
 //# sourceMappingURL=assetsUtil.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/assetsUtil.d.ts.map b/node_modules/@metamask/assets-controllers/dist/assetsUtil.d.ts.map
index e2d0b2a..2b9f160 100644
--- a/node_modules/@metamask/assets-controllers/dist/assetsUtil.d.ts.map
+++ b/node_modules/@metamask/assets-controllers/dist/assetsUtil.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"assetsUtil.d.ts","sourceRoot":"","sources":["../src/assetsUtil.ts"],"names":[],"mappings":";AAAA,OAAO,KAAK,EAAE,SAAS,EAAE,MAAM,0BAA0B,CAAC;AAO1D,OAAO,KAAK,EAAE,GAAG,EAAE,MAAM,iBAAiB,CAAC;AAC3C,OAAO,EAAE,EAAE,EAAkB,MAAM,iBAAiB,CAAC;AAGrD,OAAO,KAAK,EAAE,GAAG,EAAE,WAAW,EAAE,MAAM,iBAAiB,CAAC;AACxD,OAAO,KAAK,EAAE,KAAK,EAAE,MAAM,wBAAwB,CAAC;AAEpD;;;;;;;;GAQG;AACH,wBAAgB,kBAAkB,CAAC,cAAc,EAAE,WAAW,EAAE,GAAG,EAAE,GAAG,WAkBvE;AA+BD;;;;;GAKG;AACH,eAAO,MAAM,qBAAqB,gBAAiB,MAAM,EAAE,aAM1D,CAAC;AAEF;;;;;;;GAOG;AACH,eAAO,MAAM,sBAAsB;aAIxB,GAAG;kBACE,MAAM;YAIrB,CAAC;AAEF;;;;GAIG;AACH,wBAAgB,oBAAoB,CAAC,KAAK,EAAE,KAAK,QA2BhD;AAED;;GAEG;AACH,oBAAY,+BAA+B;IACzC,OAAO,QAAQ;IACf,GAAG,SAAS;IACZ,OAAO,SAAS;IAChB,IAAI,WAAW;IACf,MAAM,eAAe;IACrB,YAAY,WAAW;IACvB,aAAa,WAAW;CACzB;AAED;;;;;GAKG;AACH,wBAAgB,mCAAmC,CAAC,OAAO,EAAE,GAAG,GAAG,OAAO,CAEzE;AAED;;;;;;GAMG;AACH,wBAAgB,8BAA8B,CAAC,OAAO,EAAE,GAAG,GAAG,OAAO,CAIpE;AAED;;;;;;GAMG;AACH,wBAAgB,wBAAwB,CAAC,OAAO,EAAE,MAAM,UAQvD;AAED;;;;;;GAMG;AACH,wBAAgB,mBAAmB,CAAC,OAAO,EAAE,MAAM,GAAG;IACpD,GAAG,EAAE,MAAM,CAAC;IACZ,IAAI,CAAC,EAAE,MAAM,CAAC;CACf,CAeA;AAED;;;;;;;GAOG;AACH,wBAAgB,mBAAmB,CACjC,WAAW,EAAE,MAAM,EACnB,OAAO,EAAE,MAAM,EACf,kBAAkB,EAAE,OAAO,GAC1B,MAAM,CAQR;AAED;;;;;GAKG;AACH,wBAAgB,oBAAoB,CAAC,SAAS,EAAE,MAAM,GAAG,MAAM,CAK9D;AAED;;;;;GAKG;AACH,wBAAgB,mBAAmB,CAAC,SAAS,EAAE,SAAS,GAAG,EAAE,CAE5D"}
\ No newline at end of file
+{"version":3,"file":"assetsUtil.d.ts","sourceRoot":"","sources":["../src/assetsUtil.ts"],"names":[],"mappings":";AAEA,OAAO,KAAK,EAAE,GAAG,EAAE,MAAM,iBAAiB,CAAC;AAM3C,OAAO,EAAE,SAAS,EAAE,MAAM,0BAA0B,CAAC;AACrD,OAAO,EAAE,EAAE,EAAkB,MAAM,iBAAiB,CAAC;AACrD,OAAO,EAAE,GAAG,EAAE,WAAW,EAAE,MAAM,iBAAiB,CAAC;AACnD,OAAO,EAAE,KAAK,EAAE,MAAM,wBAAwB,CAAC;AAE/C;;;;;;;;GAQG;AACH,wBAAgB,kBAAkB,CAAC,cAAc,EAAE,WAAW,EAAE,GAAG,EAAE,GAAG,WAmBvE;AA+BD;;;;;GAKG;AACH,eAAO,MAAM,qBAAqB,gBAAiB,MAAM,EAAE,aAM1D,CAAC;AAEF;;;;;;;GAOG;AACH,eAAO,MAAM,sBAAsB;aAIxB,GAAG;kBACE,MAAM;YAIrB,CAAC;AAEF;;;;GAIG;AACH,wBAAgB,oBAAoB,CAAC,KAAK,EAAE,KAAK,QA2BhD;AAED;;GAEG;AACH,oBAAY,+BAA+B;IACzC,OAAO,QAAQ;IACf,GAAG,SAAS;IACZ,OAAO,SAAS;IAChB,IAAI,WAAW;IACf,MAAM,eAAe;IACrB,YAAY,WAAW;IACvB,aAAa,WAAW;IACxB,QAAQ,WAAW;IACnB,QAAQ,QAAQ;IAChB,IAAI,WAAW;IACf,MAAM,UAAU;CACjB;AAED;;;;;GAKG;AACH,wBAAgB,mCAAmC,CAAC,OAAO,EAAE,GAAG,GAAG,OAAO,CAEzE;AAED;;;;;;GAMG;AACH,wBAAgB,8BAA8B,CAAC,OAAO,EAAE,GAAG,GAAG,OAAO,CAIpE;AAED;;;;;;GAMG;AACH,wBAAgB,wBAAwB,CAAC,OAAO,EAAE,MAAM,UAQvD;AAED;;;;;;GAMG;AACH,wBAAgB,mBAAmB,CAAC,OAAO,EAAE,MAAM,GAAG;IACpD,GAAG,EAAE,MAAM,CAAC;IACZ,IAAI,CAAC,EAAE,MAAM,CAAC;CACf,CAeA;AAED;;;;;;;GAOG;AACH,wBAAgB,mBAAmB,CACjC,WAAW,EAAE,MAAM,EACnB,OAAO,EAAE,MAAM,EACf,kBAAkB,EAAE,OAAO,GAC1B,MAAM,CAQR;AAED;;;;;GAKG;AACH,wBAAgB,oBAAoB,CAAC,SAAS,EAAE,MAAM,GAAG,MAAM,CAK9D;AAED;;;;;GAKG;AACH,wBAAgB,mBAAmB,CAAC,SAAS,EAAE,SAAS,GAAG,EAAE,CAE5D;AAED;;;;;;;;GAQG;AACH,wBAAgB,iBAAiB,CAAC,KAAK,EACrC,MAAM,EAAE,KAAK,EAAE,EACf,EAAE,SAAS,EAAE,EAAE;IAAE,SAAS,EAAE,MAAM,CAAA;CAAE,GACnC,KAAK,EAAE,EAAE,CAMX;AAED;;;;;;;;;;;;;;GAcG;AACH,wBAAsB,uBAAuB,CAC3C,KAAK,EACL,MAAM,SAAS,MAAM,CAAC,WAAW,EAAE,OAAO,CAAC,EAC3C,EACA,MAAM,EACN,SAAS,EACT,SAAS,EACT,aAAa,GACd,EAAE;IACD,MAAM,EAAE,KAAK,EAAE,CAAC;IAChB,SAAS,EAAE,MAAM,CAAC;IAClB,SAAS,EAAE,CACT,aAAa,EAAE,OAAO,CAAC,MAAM,CAAC,EAC9B,KAAK,EAAE,KAAK,EAAE,EACd,KAAK,EAAE,MAAM,KACV,OAAO,CAAC,MAAM,CAAC,GAAG,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC;IAChD,aAAa,EAAE,OAAO,CAAC,MAAM,CAAC,CAAC;CAChC,GAAG,OAAO,CAAC,MAAM,CAAC,CAUlB"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/assetsUtil.js b/node_modules/@metamask/assets-controllers/dist/assetsUtil.js
index e7171cd..7231b1b 100644
--- a/node_modules/@metamask/assets-controllers/dist/assetsUtil.js
+++ b/node_modules/@metamask/assets-controllers/dist/assetsUtil.js
@@ -1,10 +1,19 @@
 "use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.ethersBigNumberToBN = exports.addUrlProtocolPrefix = exports.getFormattedIpfsUrl = exports.getIpfsCIDv1AndPath = exports.removeIpfsProtocolPrefix = exports.isTokenListSupportedForNetwork = exports.isTokenDetectionSupportedForNetwork = exports.SupportedTokenDetectionNetworks = exports.validateTokenToWatch = exports.formatIconUrlWithProxy = exports.formatAggregatorNames = exports.compareNftMetadata = void 0;
-const controller_utils_1 = require("@metamask/controller-utils");
+exports.reduceInBatchesSerially = exports.divideIntoBatches = exports.ethersBigNumberToBN = exports.addUrlProtocolPrefix = exports.getFormattedIpfsUrl = exports.getIpfsCIDv1AndPath = exports.removeIpfsProtocolPrefix = exports.isTokenListSupportedForNetwork = exports.isTokenDetectionSupportedForNetwork = exports.SupportedTokenDetectionNetworks = exports.validateTokenToWatch = exports.formatIconUrlWithProxy = exports.formatAggregatorNames = exports.compareNftMetadata = void 0;
 const rpc_errors_1 = require("@metamask/rpc-errors");
-const ethereumjs_util_1 = require("ethereumjs-util");
 const cid_1 = require("multiformats/cid");
+const controller_utils_1 = require("@metamask/controller-utils");
+const ethereumjs_util_1 = require("ethereumjs-util");
 /**
  * Compares nft metadata entries to any nft entry.
  * We need this method when comparing a new fetched nft metadata, in case a entry changed to a defined value,
@@ -24,6 +33,7 @@ function compareNftMetadata(newNftMetadata, nft) {
         'animation',
         'animationOriginal',
         'externalLink',
+        'tokenURI',
     ];
     const differentValues = keys.reduce((value, key) => {
         if (newNftMetadata[key] && newNftMetadata[key] !== nft[key]) {
@@ -123,6 +133,10 @@ var SupportedTokenDetectionNetworks;
     SupportedTokenDetectionNetworks["aurora"] = "0x4e454152";
     SupportedTokenDetectionNetworks["linea_goerli"] = "0xe704";
     SupportedTokenDetectionNetworks["linea_mainnet"] = "0xe708";
+    SupportedTokenDetectionNetworks["arbitrum"] = "0xa4b1";
+    SupportedTokenDetectionNetworks["optimism"] = "0xa";
+    SupportedTokenDetectionNetworks["base"] = "0x2105";
+    SupportedTokenDetectionNetworks["zksync"] = "0x144";
 })(SupportedTokenDetectionNetworks = exports.SupportedTokenDetectionNetworks || (exports.SupportedTokenDetectionNetworks = {}));
 /**
  * Check if token detection is enabled for certain networks.
@@ -226,4 +240,50 @@ function ethersBigNumberToBN(bigNumber) {
     return new ethereumjs_util_1.BN((0, ethereumjs_util_1.stripHexPrefix)(bigNumber.toHexString()), 'hex');
 }
 exports.ethersBigNumberToBN = ethersBigNumberToBN;
+/**
+ * Partitions a list of values into groups that are at most `batchSize` in
+ * length.
+ *
+ * @param values - The list of values.
+ * @param args - The remaining arguments.
+ * @param args.batchSize - The desired maximum number of values per batch.
+ * @returns The list of batches.
+ */
+function divideIntoBatches(values, { batchSize }) {
+    const batches = [];
+    for (let i = 0; i < values.length; i += batchSize) {
+        batches.push(values.slice(i, i + batchSize));
+    }
+    return batches;
+}
+exports.divideIntoBatches = divideIntoBatches;
+/**
+ * Constructs an object from processing batches of the given values
+ * sequentially.
+ *
+ * @param args - The arguments to this function.
+ * @param args.values - A list of values to iterate over.
+ * @param args.batchSize - The maximum number of values in each batch.
+ * @param args.eachBatch - A function to call for each batch. This function is
+ * similar to the function that `Array.prototype.reduce` takes, in that it
+ * receives the object that is being built, each batch in the list of batches
+ * and the index, and should return an updated version of the object.
+ * @param args.initialResult - The initial value of the final data structure,
+ * i.e., the value that will be fed into the first call of `eachBatch`.
+ * @returns The built object.
+ */
+function reduceInBatchesSerially({ values, batchSize, eachBatch, initialResult, }) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const batches = divideIntoBatches(values, { batchSize });
+        let workingResult = initialResult;
+        for (const [index, batch] of batches.entries()) {
+            workingResult = yield eachBatch(workingResult, batch, index);
+        }
+        // There's no way around this  we have to assume that in the end, the result
+        // matches the intended type.
+        const finalResult = workingResult;
+        return finalResult;
+    });
+}
+exports.reduceInBatchesSerially = reduceInBatchesSerially;
 //# sourceMappingURL=assetsUtil.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/assetsUtil.js.map b/node_modules/@metamask/assets-controllers/dist/assetsUtil.js.map
index 1d831bf..2633f60 100644
--- a/node_modules/@metamask/assets-controllers/dist/assetsUtil.js.map
+++ b/node_modules/@metamask/assets-controllers/dist/assetsUtil.js.map
@@ -1 +1 @@
-{"version":3,"file":"assetsUtil.js","sourceRoot":"","sources":["../src/assetsUtil.ts"],"names":[],"mappings":"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","sourcesContent":["import type { BigNumber } from '@ethersproject/bignumber';\nimport {\n  convertHexToDecimal,\n  isValidHexAddress,\n  GANACHE_CHAIN_ID,\n} from '@metamask/controller-utils';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type { Hex } from '@metamask/utils';\nimport { BN, stripHexPrefix } from 'ethereumjs-util';\nimport { CID } from 'multiformats/cid';\n\nimport type { Nft, NftMetadata } from './NftController';\nimport type { Token } from './TokenRatesController';\n\n/**\n * Compares nft metadata entries to any nft entry.\n * We need this method when comparing a new fetched nft metadata, in case a entry changed to a defined value,\n * there's a need to update the nft in state.\n *\n * @param newNftMetadata - Nft metadata object.\n * @param nft - Nft object to compare with.\n * @returns Whether there are differences.\n */\nexport function compareNftMetadata(newNftMetadata: NftMetadata, nft: Nft) {\n  const keys: (keyof NftMetadata)[] = [\n    'image',\n    'backgroundColor',\n    'imagePreview',\n    'imageThumbnail',\n    'imageOriginal',\n    'animation',\n    'animationOriginal',\n    'externalLink',\n  ];\n  const differentValues = keys.reduce((value, key) => {\n    if (newNftMetadata[key] && newNftMetadata[key] !== nft[key]) {\n      return value + 1;\n    }\n    return value;\n  }, 0);\n  return differentValues > 0;\n}\n\nconst aggregatorNameByKey: Record<string, string> = {\n  aave: 'Aave',\n  bancor: 'Bancor',\n  cmc: 'CMC',\n  cryptocom: 'Crypto.com',\n  coinGecko: 'CoinGecko',\n  oneInch: '1inch',\n  paraswap: 'Paraswap',\n  pmm: 'PMM',\n  zapper: 'Zapper',\n  zerion: 'Zerion',\n  zeroEx: '0x',\n  synthetix: 'Synthetix',\n  yearn: 'Yearn',\n  apeswap: 'ApeSwap',\n  binanceDex: 'BinanceDex',\n  pancakeTop100: 'PancakeTop100',\n  pancakeExtended: 'PancakeExtended',\n  balancer: 'Balancer',\n  quickswap: 'QuickSwap',\n  matcha: 'Matcha',\n  pangolinDex: 'PangolinDex',\n  pangolinDexStableCoin: 'PangolinDexStableCoin',\n  pangolinDexAvaxBridge: 'PangolinDexAvaxBridge',\n  traderJoe: 'TraderJoe',\n  airswapLight: 'AirswapLight',\n  kleros: 'Kleros',\n};\n\n/**\n * Formats aggregator names to presentable format.\n *\n * @param aggregators - List of token list names in camelcase.\n * @returns Formatted aggregator names.\n */\nexport const formatAggregatorNames = (aggregators: string[]) => {\n  return aggregators.map(\n    (key) =>\n      aggregatorNameByKey[key] ||\n      `${key[0].toUpperCase()}${key.substring(1, key.length)}`,\n  );\n};\n\n/**\n * Format token list assets to use image proxy from Codefi.\n *\n * @param params - Object that contains chainID and tokenAddress.\n * @param params.chainId - ChainID of network in 0x-prefixed hexadecimal format.\n * @param params.tokenAddress - Address of token in mixed or lowercase.\n * @returns Formatted image url\n */\nexport const formatIconUrlWithProxy = ({\n  chainId,\n  tokenAddress,\n}: {\n  chainId: Hex;\n  tokenAddress: string;\n}) => {\n  const chainIdDecimal = convertHexToDecimal(chainId).toString();\n  return `https://static.metafi.codefi.network/api/v1/tokenIcons/${chainIdDecimal}/${tokenAddress.toLowerCase()}.png`;\n};\n\n/**\n * Validates a ERC20 token to be added with EIP747.\n *\n * @param token - Token object to validate.\n */\nexport function validateTokenToWatch(token: Token) {\n  const { address, symbol, decimals } = token;\n  if (!address || !symbol || typeof decimals === 'undefined') {\n    throw rpcErrors.invalidParams(\n      `Must specify address, symbol, and decimals.`,\n    );\n  }\n\n  if (typeof symbol !== 'string') {\n    throw rpcErrors.invalidParams(`Invalid symbol: not a string.`);\n  }\n\n  if (symbol.length > 11) {\n    throw rpcErrors.invalidParams(\n      `Invalid symbol \"${symbol}\": longer than 11 characters.`,\n    );\n  }\n  const numDecimals = parseInt(decimals as unknown as string, 10);\n  if (isNaN(numDecimals) || numDecimals > 36 || numDecimals < 0) {\n    throw rpcErrors.invalidParams(\n      `Invalid decimals \"${decimals}\": must be 0 <= 36.`,\n    );\n  }\n\n  if (!isValidHexAddress(address)) {\n    throw rpcErrors.invalidParams(`Invalid address \"${address}\".`);\n  }\n}\n\n/**\n * Networks where token detection is supported - Values are in decimal format\n */\nexport enum SupportedTokenDetectionNetworks {\n  mainnet = '0x1', // decimal: 1\n  bsc = '0x38', // decimal: 56\n  polygon = '0x89', // decimal: 137\n  avax = '0xa86a', // decimal: 43114\n  aurora = '0x4e454152', // decimal: 1313161554\n  linea_goerli = '0xe704', // decimal: 59140\n  linea_mainnet = '0xe708', // decimal: 59144\n}\n\n/**\n * Check if token detection is enabled for certain networks.\n *\n * @param chainId - ChainID of network\n * @returns Whether the current network supports token detection\n */\nexport function isTokenDetectionSupportedForNetwork(chainId: Hex): boolean {\n  return Object.values<Hex>(SupportedTokenDetectionNetworks).includes(chainId);\n}\n\n/**\n * Check if token list polling is enabled for a given network.\n * Currently this method is used to support e2e testing for consumers of this package.\n *\n * @param chainId - ChainID of network\n * @returns Whether the current network supports tokenlists\n */\nexport function isTokenListSupportedForNetwork(chainId: Hex): boolean {\n  return (\n    isTokenDetectionSupportedForNetwork(chainId) || chainId === GANACHE_CHAIN_ID\n  );\n}\n\n/**\n * Removes IPFS protocol prefix from input string.\n *\n * @param ipfsUrl - An IPFS url (e.g. ipfs://{content id})\n * @returns IPFS content identifier and (possibly) path in a string\n * @throws Will throw if the url passed is not IPFS.\n */\nexport function removeIpfsProtocolPrefix(ipfsUrl: string) {\n  if (ipfsUrl.startsWith('ipfs://ipfs/')) {\n    return ipfsUrl.replace('ipfs://ipfs/', '');\n  } else if (ipfsUrl.startsWith('ipfs://')) {\n    return ipfsUrl.replace('ipfs://', '');\n  }\n  // this method should not be used with non-ipfs urls (i.e. startsWith('ipfs://') === true)\n  throw new Error('this method should not be used with non ipfs urls');\n}\n\n/**\n * Extracts content identifier and path from an input string.\n *\n * @param ipfsUrl - An IPFS URL minus the IPFS protocol prefix\n * @returns IFPS content identifier (cid) and sub path as string.\n * @throws Will throw if the url passed is not ipfs.\n */\nexport function getIpfsCIDv1AndPath(ipfsUrl: string): {\n  cid: string;\n  path?: string;\n} {\n  const url = removeIpfsProtocolPrefix(ipfsUrl);\n\n  // check if there is a path\n  // (CID is everything preceding first forward slash, path is everything after)\n  const index = url.indexOf('/');\n  const cid = index !== -1 ? url.substring(0, index) : url;\n  const path = index !== -1 ? url.substring(index) : undefined;\n\n  // We want to ensure that the CID is v1 (https://docs.ipfs.io/concepts/content-addressing/#identifier-formats)\n  // because most cid v0s appear to be incompatible with IPFS subdomains\n  return {\n    cid: CID.parse(cid).toV1().toString(),\n    path,\n  };\n}\n\n/**\n * Formats URL correctly for use retrieving assets hosted on IPFS.\n *\n * @param ipfsGateway - The users preferred IPFS gateway (full URL or just host).\n * @param ipfsUrl - The IFPS URL pointed at the asset.\n * @param subdomainSupported - Boolean indicating whether the URL should be formatted with subdomains or not.\n * @returns A formatted URL, with the user's preferred IPFS gateway and format (subdomain or not), pointing to an asset hosted on IPFS.\n */\nexport function getFormattedIpfsUrl(\n  ipfsGateway: string,\n  ipfsUrl: string,\n  subdomainSupported: boolean,\n): string {\n  const { host, protocol, origin } = new URL(addUrlProtocolPrefix(ipfsGateway));\n  if (subdomainSupported) {\n    const { cid, path } = getIpfsCIDv1AndPath(ipfsUrl);\n    return `${protocol}//${cid}.ipfs.${host}${path ?? ''}`;\n  }\n  const cidAndPath = removeIpfsProtocolPrefix(ipfsUrl);\n  return `${origin}/ipfs/${cidAndPath}`;\n}\n\n/**\n * Adds URL protocol prefix to input URL string if missing.\n *\n * @param urlString - An IPFS URL.\n * @returns A URL with a https:// prepended.\n */\nexport function addUrlProtocolPrefix(urlString: string): string {\n  if (!urlString.match(/(^http:\\/\\/)|(^https:\\/\\/)/u)) {\n    return `https://${urlString}`;\n  }\n  return urlString;\n}\n\n/**\n * Converts an Ethers BigNumber to a BN.\n *\n * @param bigNumber - An Ethers BigNumber instance.\n * @returns A BN object.\n */\nexport function ethersBigNumberToBN(bigNumber: BigNumber): BN {\n  return new BN(stripHexPrefix(bigNumber.toHexString()), 'hex');\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"assetsUtil.js","sourceRoot":"","sources":["../src/assetsUtil.ts"],"names":[],"mappings":"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","sourcesContent":["import { rpcErrors } from '@metamask/rpc-errors';\nimport { CID } from 'multiformats/cid';\nimport type { Hex } from '@metamask/utils';\nimport {\n  convertHexToDecimal,\n  isValidHexAddress,\n  GANACHE_CHAIN_ID,\n} from '@metamask/controller-utils';\nimport { BigNumber } from '@ethersproject/bignumber';\nimport { BN, stripHexPrefix } from 'ethereumjs-util';\nimport { Nft, NftMetadata } from './NftController';\nimport { Token } from './TokenRatesController';\n\n/**\n * Compares nft metadata entries to any nft entry.\n * We need this method when comparing a new fetched nft metadata, in case a entry changed to a defined value,\n * there's a need to update the nft in state.\n *\n * @param newNftMetadata - Nft metadata object.\n * @param nft - Nft object to compare with.\n * @returns Whether there are differences.\n */\nexport function compareNftMetadata(newNftMetadata: NftMetadata, nft: Nft) {\n  const keys: (keyof NftMetadata)[] = [\n    'image',\n    'backgroundColor',\n    'imagePreview',\n    'imageThumbnail',\n    'imageOriginal',\n    'animation',\n    'animationOriginal',\n    'externalLink',\n    'tokenURI',\n  ];\n  const differentValues = keys.reduce((value, key) => {\n    if (newNftMetadata[key] && newNftMetadata[key] !== nft[key]) {\n      return value + 1;\n    }\n    return value;\n  }, 0);\n  return differentValues > 0;\n}\n\nconst aggregatorNameByKey: Record<string, string> = {\n  aave: 'Aave',\n  bancor: 'Bancor',\n  cmc: 'CMC',\n  cryptocom: 'Crypto.com',\n  coinGecko: 'CoinGecko',\n  oneInch: '1inch',\n  paraswap: 'Paraswap',\n  pmm: 'PMM',\n  zapper: 'Zapper',\n  zerion: 'Zerion',\n  zeroEx: '0x',\n  synthetix: 'Synthetix',\n  yearn: 'Yearn',\n  apeswap: 'ApeSwap',\n  binanceDex: 'BinanceDex',\n  pancakeTop100: 'PancakeTop100',\n  pancakeExtended: 'PancakeExtended',\n  balancer: 'Balancer',\n  quickswap: 'QuickSwap',\n  matcha: 'Matcha',\n  pangolinDex: 'PangolinDex',\n  pangolinDexStableCoin: 'PangolinDexStableCoin',\n  pangolinDexAvaxBridge: 'PangolinDexAvaxBridge',\n  traderJoe: 'TraderJoe',\n  airswapLight: 'AirswapLight',\n  kleros: 'Kleros',\n};\n\n/**\n * Formats aggregator names to presentable format.\n *\n * @param aggregators - List of token list names in camelcase.\n * @returns Formatted aggregator names.\n */\nexport const formatAggregatorNames = (aggregators: string[]) => {\n  return aggregators.map(\n    (key) =>\n      aggregatorNameByKey[key] ||\n      `${key[0].toUpperCase()}${key.substring(1, key.length)}`,\n  );\n};\n\n/**\n * Format token list assets to use image proxy from Codefi.\n *\n * @param params - Object that contains chainID and tokenAddress.\n * @param params.chainId - ChainID of network in 0x-prefixed hexadecimal format.\n * @param params.tokenAddress - Address of token in mixed or lowercase.\n * @returns Formatted image url\n */\nexport const formatIconUrlWithProxy = ({\n  chainId,\n  tokenAddress,\n}: {\n  chainId: Hex;\n  tokenAddress: string;\n}) => {\n  const chainIdDecimal = convertHexToDecimal(chainId).toString();\n  return `https://static.metafi.codefi.network/api/v1/tokenIcons/${chainIdDecimal}/${tokenAddress.toLowerCase()}.png`;\n};\n\n/**\n * Validates a ERC20 token to be added with EIP747.\n *\n * @param token - Token object to validate.\n */\nexport function validateTokenToWatch(token: Token) {\n  const { address, symbol, decimals } = token;\n  if (!address || !symbol || typeof decimals === 'undefined') {\n    throw rpcErrors.invalidParams(\n      `Must specify address, symbol, and decimals.`,\n    );\n  }\n\n  if (typeof symbol !== 'string') {\n    throw rpcErrors.invalidParams(`Invalid symbol: not a string.`);\n  }\n\n  if (symbol.length > 11) {\n    throw rpcErrors.invalidParams(\n      `Invalid symbol \"${symbol}\": longer than 11 characters.`,\n    );\n  }\n  const numDecimals = parseInt(decimals as unknown as string, 10);\n  if (isNaN(numDecimals) || numDecimals > 36 || numDecimals < 0) {\n    throw rpcErrors.invalidParams(\n      `Invalid decimals \"${decimals}\": must be 0 <= 36.`,\n    );\n  }\n\n  if (!isValidHexAddress(address)) {\n    throw rpcErrors.invalidParams(`Invalid address \"${address}\".`);\n  }\n}\n\n/**\n * Networks where token detection is supported - Values are in decimal format\n */\nexport enum SupportedTokenDetectionNetworks {\n  mainnet = '0x1', // decimal: 1\n  bsc = '0x38', // decimal: 56\n  polygon = '0x89', // decimal: 137\n  avax = '0xa86a', // decimal: 43114\n  aurora = '0x4e454152', // decimal: 1313161554\n  linea_goerli = '0xe704', // decimal: 59140\n  linea_mainnet = '0xe708', // decimal: 59144\n  arbitrum = '0xa4b1', // decimal: 42161\n  optimism = '0xa', // decimal: 10\n  base = '0x2105', // decimal: 8453\n  zksync = '0x144', // decimal: 324\n}\n\n/**\n * Check if token detection is enabled for certain networks.\n *\n * @param chainId - ChainID of network\n * @returns Whether the current network supports token detection\n */\nexport function isTokenDetectionSupportedForNetwork(chainId: Hex): boolean {\n  return Object.values<Hex>(SupportedTokenDetectionNetworks).includes(chainId);\n}\n\n/**\n * Check if token list polling is enabled for a given network.\n * Currently this method is used to support e2e testing for consumers of this package.\n *\n * @param chainId - ChainID of network\n * @returns Whether the current network supports tokenlists\n */\nexport function isTokenListSupportedForNetwork(chainId: Hex): boolean {\n  return (\n    isTokenDetectionSupportedForNetwork(chainId) || chainId === GANACHE_CHAIN_ID\n  );\n}\n\n/**\n * Removes IPFS protocol prefix from input string.\n *\n * @param ipfsUrl - An IPFS url (e.g. ipfs://{content id})\n * @returns IPFS content identifier and (possibly) path in a string\n * @throws Will throw if the url passed is not IPFS.\n */\nexport function removeIpfsProtocolPrefix(ipfsUrl: string) {\n  if (ipfsUrl.startsWith('ipfs://ipfs/')) {\n    return ipfsUrl.replace('ipfs://ipfs/', '');\n  } else if (ipfsUrl.startsWith('ipfs://')) {\n    return ipfsUrl.replace('ipfs://', '');\n  }\n  // this method should not be used with non-ipfs urls (i.e. startsWith('ipfs://') === true)\n  throw new Error('this method should not be used with non ipfs urls');\n}\n\n/**\n * Extracts content identifier and path from an input string.\n *\n * @param ipfsUrl - An IPFS URL minus the IPFS protocol prefix\n * @returns IFPS content identifier (cid) and sub path as string.\n * @throws Will throw if the url passed is not ipfs.\n */\nexport function getIpfsCIDv1AndPath(ipfsUrl: string): {\n  cid: string;\n  path?: string;\n} {\n  const url = removeIpfsProtocolPrefix(ipfsUrl);\n\n  // check if there is a path\n  // (CID is everything preceding first forward slash, path is everything after)\n  const index = url.indexOf('/');\n  const cid = index !== -1 ? url.substring(0, index) : url;\n  const path = index !== -1 ? url.substring(index) : undefined;\n\n  // We want to ensure that the CID is v1 (https://docs.ipfs.io/concepts/content-addressing/#identifier-formats)\n  // because most cid v0s appear to be incompatible with IPFS subdomains\n  return {\n    cid: CID.parse(cid).toV1().toString(),\n    path,\n  };\n}\n\n/**\n * Formats URL correctly for use retrieving assets hosted on IPFS.\n *\n * @param ipfsGateway - The users preferred IPFS gateway (full URL or just host).\n * @param ipfsUrl - The IFPS URL pointed at the asset.\n * @param subdomainSupported - Boolean indicating whether the URL should be formatted with subdomains or not.\n * @returns A formatted URL, with the user's preferred IPFS gateway and format (subdomain or not), pointing to an asset hosted on IPFS.\n */\nexport function getFormattedIpfsUrl(\n  ipfsGateway: string,\n  ipfsUrl: string,\n  subdomainSupported: boolean,\n): string {\n  const { host, protocol, origin } = new URL(addUrlProtocolPrefix(ipfsGateway));\n  if (subdomainSupported) {\n    const { cid, path } = getIpfsCIDv1AndPath(ipfsUrl);\n    return `${protocol}//${cid}.ipfs.${host}${path ?? ''}`;\n  }\n  const cidAndPath = removeIpfsProtocolPrefix(ipfsUrl);\n  return `${origin}/ipfs/${cidAndPath}`;\n}\n\n/**\n * Adds URL protocol prefix to input URL string if missing.\n *\n * @param urlString - An IPFS URL.\n * @returns A URL with a https:// prepended.\n */\nexport function addUrlProtocolPrefix(urlString: string): string {\n  if (!urlString.match(/(^http:\\/\\/)|(^https:\\/\\/)/u)) {\n    return `https://${urlString}`;\n  }\n  return urlString;\n}\n\n/**\n * Converts an Ethers BigNumber to a BN.\n *\n * @param bigNumber - An Ethers BigNumber instance.\n * @returns A BN object.\n */\nexport function ethersBigNumberToBN(bigNumber: BigNumber): BN {\n  return new BN(stripHexPrefix(bigNumber.toHexString()), 'hex');\n}\n\n/**\n * Partitions a list of values into groups that are at most `batchSize` in\n * length.\n *\n * @param values - The list of values.\n * @param args - The remaining arguments.\n * @param args.batchSize - The desired maximum number of values per batch.\n * @returns The list of batches.\n */\nexport function divideIntoBatches<Value>(\n  values: Value[],\n  { batchSize }: { batchSize: number },\n): Value[][] {\n  const batches = [];\n  for (let i = 0; i < values.length; i += batchSize) {\n    batches.push(values.slice(i, i + batchSize));\n  }\n  return batches;\n}\n\n/**\n * Constructs an object from processing batches of the given values\n * sequentially.\n *\n * @param args - The arguments to this function.\n * @param args.values - A list of values to iterate over.\n * @param args.batchSize - The maximum number of values in each batch.\n * @param args.eachBatch - A function to call for each batch. This function is\n * similar to the function that `Array.prototype.reduce` takes, in that it\n * receives the object that is being built, each batch in the list of batches\n * and the index, and should return an updated version of the object.\n * @param args.initialResult - The initial value of the final data structure,\n * i.e., the value that will be fed into the first call of `eachBatch`.\n * @returns The built object.\n */\nexport async function reduceInBatchesSerially<\n  Value,\n  Result extends Record<PropertyKey, unknown>,\n>({\n  values,\n  batchSize,\n  eachBatch,\n  initialResult,\n}: {\n  values: Value[];\n  batchSize: number;\n  eachBatch: (\n    workingResult: Partial<Result>,\n    batch: Value[],\n    index: number,\n  ) => Partial<Result> | Promise<Partial<Result>>;\n  initialResult: Partial<Result>;\n}): Promise<Result> {\n  const batches = divideIntoBatches(values, { batchSize });\n  let workingResult = initialResult;\n  for (const [index, batch] of batches.entries()) {\n    workingResult = await eachBatch(workingResult, batch, index);\n  }\n  // There's no way around this  we have to assume that in the end, the result\n  // matches the intended type.\n  const finalResult = workingResult as Result;\n  return finalResult;\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/index.d.ts b/node_modules/@metamask/assets-controllers/dist/index.d.ts
index 9526321..5f08fce 100644
--- a/node_modules/@metamask/assets-controllers/dist/index.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/index.d.ts
@@ -9,4 +9,5 @@ export * from './TokenListController';
 export * from './TokenRatesController';
 export * from './TokensController';
 export { isTokenDetectionSupportedForNetwork, formatIconUrlWithProxy, getFormattedIpfsUrl, } from './assetsUtil';
+export { CodefiTokenPricesServiceV2 } from './token-prices-service';
 //# sourceMappingURL=index.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/index.d.ts.map b/node_modules/@metamask/assets-controllers/dist/index.d.ts.map
index dc17d8c..54c83af 100644
--- a/node_modules/@metamask/assets-controllers/dist/index.d.ts.map
+++ b/node_modules/@metamask/assets-controllers/dist/index.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"AAAA,cAAc,4BAA4B,CAAC;AAC3C,cAAc,4BAA4B,CAAC;AAC3C,cAAc,0BAA0B,CAAC;AACzC,cAAc,iBAAiB,CAAC;AAChC,cAAc,0BAA0B,CAAC;AACzC,cAAc,2BAA2B,CAAC;AAC1C,cAAc,4BAA4B,CAAC;AAC3C,cAAc,uBAAuB,CAAC;AACtC,cAAc,wBAAwB,CAAC;AACvC,cAAc,oBAAoB,CAAC;AACnC,OAAO,EACL,mCAAmC,EACnC,sBAAsB,EACtB,mBAAmB,GACpB,MAAM,cAAc,CAAC"}
\ No newline at end of file
+{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"AAAA,cAAc,4BAA4B,CAAC;AAC3C,cAAc,4BAA4B,CAAC;AAC3C,cAAc,0BAA0B,CAAC;AACzC,cAAc,iBAAiB,CAAC;AAChC,cAAc,0BAA0B,CAAC;AACzC,cAAc,2BAA2B,CAAC;AAC1C,cAAc,4BAA4B,CAAC;AAC3C,cAAc,uBAAuB,CAAC;AACtC,cAAc,wBAAwB,CAAC;AACvC,cAAc,oBAAoB,CAAC;AACnC,OAAO,EACL,mCAAmC,EACnC,sBAAsB,EACtB,mBAAmB,GACpB,MAAM,cAAc,CAAC;AACtB,OAAO,EAAE,0BAA0B,EAAE,MAAM,wBAAwB,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/index.js b/node_modules/@metamask/assets-controllers/dist/index.js
index d4d8682..1b151e6 100644
--- a/node_modules/@metamask/assets-controllers/dist/index.js
+++ b/node_modules/@metamask/assets-controllers/dist/index.js
@@ -14,7 +14,7 @@ var __exportStar = (this && this.__exportStar) || function(m, exports) {
     for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
 };
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.getFormattedIpfsUrl = exports.formatIconUrlWithProxy = exports.isTokenDetectionSupportedForNetwork = void 0;
+exports.CodefiTokenPricesServiceV2 = exports.getFormattedIpfsUrl = exports.formatIconUrlWithProxy = exports.isTokenDetectionSupportedForNetwork = void 0;
 __exportStar(require("./AccountTrackerController"), exports);
 __exportStar(require("./AssetsContractController"), exports);
 __exportStar(require("./CurrencyRateController"), exports);
@@ -29,4 +29,6 @@ var assetsUtil_1 = require("./assetsUtil");
 Object.defineProperty(exports, "isTokenDetectionSupportedForNetwork", { enumerable: true, get: function () { return assetsUtil_1.isTokenDetectionSupportedForNetwork; } });
 Object.defineProperty(exports, "formatIconUrlWithProxy", { enumerable: true, get: function () { return assetsUtil_1.formatIconUrlWithProxy; } });
 Object.defineProperty(exports, "getFormattedIpfsUrl", { enumerable: true, get: function () { return assetsUtil_1.getFormattedIpfsUrl; } });
+var token_prices_service_1 = require("./token-prices-service");
+Object.defineProperty(exports, "CodefiTokenPricesServiceV2", { enumerable: true, get: function () { return token_prices_service_1.CodefiTokenPricesServiceV2; } });
 //# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/index.js.map b/node_modules/@metamask/assets-controllers/dist/index.js.map
index ea0eaab..ab8b9b9 100644
--- a/node_modules/@metamask/assets-controllers/dist/index.js.map
+++ b/node_modules/@metamask/assets-controllers/dist/index.js.map
@@ -1 +1 @@
-{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAAA,6DAA2C;AAC3C,6DAA2C;AAC3C,2DAAyC;AACzC,kDAAgC;AAChC,2DAAyC;AACzC,4DAA0C;AAC1C,6DAA2C;AAC3C,wDAAsC;AACtC,yDAAuC;AACvC,qDAAmC;AACnC,2CAIsB;AAHpB,iIAAA,mCAAmC,OAAA;AACnC,oHAAA,sBAAsB,OAAA;AACtB,iHAAA,mBAAmB,OAAA","sourcesContent":["export * from './AccountTrackerController';\nexport * from './AssetsContractController';\nexport * from './CurrencyRateController';\nexport * from './NftController';\nexport * from './NftDetectionController';\nexport * from './TokenBalancesController';\nexport * from './TokenDetectionController';\nexport * from './TokenListController';\nexport * from './TokenRatesController';\nexport * from './TokensController';\nexport {\n  isTokenDetectionSupportedForNetwork,\n  formatIconUrlWithProxy,\n  getFormattedIpfsUrl,\n} from './assetsUtil';\n"]}
\ No newline at end of file
+{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAAA,6DAA2C;AAC3C,6DAA2C;AAC3C,2DAAyC;AACzC,kDAAgC;AAChC,2DAAyC;AACzC,4DAA0C;AAC1C,6DAA2C;AAC3C,wDAAsC;AACtC,yDAAuC;AACvC,qDAAmC;AACnC,2CAIsB;AAHpB,iIAAA,mCAAmC,OAAA;AACnC,oHAAA,sBAAsB,OAAA;AACtB,iHAAA,mBAAmB,OAAA;AAErB,+DAAoE;AAA3D,kIAAA,0BAA0B,OAAA","sourcesContent":["export * from './AccountTrackerController';\nexport * from './AssetsContractController';\nexport * from './CurrencyRateController';\nexport * from './NftController';\nexport * from './NftDetectionController';\nexport * from './TokenBalancesController';\nexport * from './TokenDetectionController';\nexport * from './TokenListController';\nexport * from './TokenRatesController';\nexport * from './TokensController';\nexport {\n  isTokenDetectionSupportedForNetwork,\n  formatIconUrlWithProxy,\n  getFormattedIpfsUrl,\n} from './assetsUtil';\nexport { CodefiTokenPricesServiceV2 } from './token-prices-service';\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-prices-service/abstract-token-prices-service.d.ts b/node_modules/@metamask/assets-controllers/dist/token-prices-service/abstract-token-prices-service.d.ts
new file mode 100644
index 0000000..2350815
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/token-prices-service/abstract-token-prices-service.d.ts
@@ -0,0 +1,62 @@
+import type { Hex } from '@metamask/utils';
+/**
+ * Represents the price of a token in a currency.
+ */
+export declare type TokenPrice<TokenAddress extends Hex, Currency extends string> = {
+    tokenAddress: TokenAddress;
+    value: number;
+    currency: Currency;
+};
+/**
+ * A map of token address to its price.
+ */
+export declare type TokenPricesByTokenAddress<TokenAddress extends Hex, Currency extends string> = {
+    [A in TokenAddress]: TokenPrice<A, Currency>;
+};
+/**
+ * An ideal token prices service. All implementations must confirm to this
+ * interface.
+ *
+ * @template ChainId - A type union of valid arguments for the `chainId`
+ * argument to `fetchTokenPrices`.
+ * @template TokenAddress - A type union of all token addresses. The reason this
+ * type parameter exists is so that we can guarantee that same addresses that
+ * `fetchTokenPrices` receives are the same addresses that shown up in the
+ * return value.
+ * @template Currency - A type union of valid arguments for the `currency`
+ * argument to `fetchTokenPrices`.
+ */
+export declare type AbstractTokenPricesService<ChainId extends string = string, TokenAddress extends Hex = Hex, Currency extends string = string> = {
+    /**
+     * Retrieves prices in the given currency for the tokens identified by the
+     * given addresses which are expected to live on the given chain.
+     *
+     * @param args - The arguments to this function.
+     * @param args.chainId - An EIP-155 chain ID.
+     * @param args.tokenAddresses - Addresses for tokens that live on the chain.
+     * @param args.currency - The desired currency of the token prices.
+     * @returns The prices for the requested tokens.
+     */
+    fetchTokenPrices({ chainId, tokenAddresses, currency, }: {
+        chainId: ChainId;
+        tokenAddresses: TokenAddress[];
+        currency: Currency;
+    }): Promise<Partial<TokenPricesByTokenAddress<TokenAddress, Currency>>>;
+    /**
+     * Type guard for whether the API can return token prices for the given chain
+     * ID.
+     *
+     * @param chainId - The chain ID to check.
+     * @returns True if the API supports the chain ID, false otherwise.
+     */
+    validateChainIdSupported(chainId: unknown): chainId is ChainId;
+    /**
+     * Type guard for whether the API can return token prices in the given
+     * currency.
+     *
+     * @param currency - The currency to check.
+     * @returns True if the API supports the currency, false otherwise.
+     */
+    validateCurrencySupported(currency: unknown): currency is Currency;
+};
+//# sourceMappingURL=abstract-token-prices-service.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-prices-service/abstract-token-prices-service.d.ts.map b/node_modules/@metamask/assets-controllers/dist/token-prices-service/abstract-token-prices-service.d.ts.map
new file mode 100644
index 0000000..31d878a
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/token-prices-service/abstract-token-prices-service.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"abstract-token-prices-service.d.ts","sourceRoot":"","sources":["../../src/token-prices-service/abstract-token-prices-service.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,GAAG,EAAE,MAAM,iBAAiB,CAAC;AAE3C;;GAEG;AACH,oBAAY,UAAU,CAAC,YAAY,SAAS,GAAG,EAAE,QAAQ,SAAS,MAAM,IAAI;IAC1E,YAAY,EAAE,YAAY,CAAC;IAC3B,KAAK,EAAE,MAAM,CAAC;IACd,QAAQ,EAAE,QAAQ,CAAC;CACpB,CAAC;AAEF;;GAEG;AACH,oBAAY,yBAAyB,CACnC,YAAY,SAAS,GAAG,EACxB,QAAQ,SAAS,MAAM,IACrB;KACD,CAAC,IAAI,YAAY,GAAG,UAAU,CAAC,CAAC,EAAE,QAAQ,CAAC;CAC7C,CAAC;AAEF;;;;;;;;;;;;GAYG;AACH,oBAAY,0BAA0B,CACpC,OAAO,SAAS,MAAM,GAAG,MAAM,EAC/B,YAAY,SAAS,GAAG,GAAG,GAAG,EAC9B,QAAQ,SAAS,MAAM,GAAG,MAAM,IAC9B;IACF;;;;;;;;;OASG;IACH,gBAAgB,CAAC,EACf,OAAO,EACP,cAAc,EACd,QAAQ,GACT,EAAE;QACD,OAAO,EAAE,OAAO,CAAC;QACjB,cAAc,EAAE,YAAY,EAAE,CAAC;QAC/B,QAAQ,EAAE,QAAQ,CAAC;KACpB,GAAG,OAAO,CAAC,OAAO,CAAC,yBAAyB,CAAC,YAAY,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC;IAExE;;;;;;OAMG;IACH,wBAAwB,CAAC,OAAO,EAAE,OAAO,GAAG,OAAO,IAAI,OAAO,CAAC;IAE/D;;;;;;OAMG;IACH,yBAAyB,CAAC,QAAQ,EAAE,OAAO,GAAG,QAAQ,IAAI,QAAQ,CAAC;CACpE,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-prices-service/abstract-token-prices-service.js b/node_modules/@metamask/assets-controllers/dist/token-prices-service/abstract-token-prices-service.js
new file mode 100644
index 0000000..6b79d8f
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/token-prices-service/abstract-token-prices-service.js
@@ -0,0 +1,3 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+//# sourceMappingURL=abstract-token-prices-service.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-prices-service/abstract-token-prices-service.js.map b/node_modules/@metamask/assets-controllers/dist/token-prices-service/abstract-token-prices-service.js.map
new file mode 100644
index 0000000..b91e096
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/token-prices-service/abstract-token-prices-service.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"abstract-token-prices-service.js","sourceRoot":"","sources":["../../src/token-prices-service/abstract-token-prices-service.ts"],"names":[],"mappings":"","sourcesContent":["import type { Hex } from '@metamask/utils';\n\n/**\n * Represents the price of a token in a currency.\n */\nexport type TokenPrice<TokenAddress extends Hex, Currency extends string> = {\n  tokenAddress: TokenAddress;\n  value: number;\n  currency: Currency;\n};\n\n/**\n * A map of token address to its price.\n */\nexport type TokenPricesByTokenAddress<\n  TokenAddress extends Hex,\n  Currency extends string,\n> = {\n  [A in TokenAddress]: TokenPrice<A, Currency>;\n};\n\n/**\n * An ideal token prices service. All implementations must confirm to this\n * interface.\n *\n * @template ChainId - A type union of valid arguments for the `chainId`\n * argument to `fetchTokenPrices`.\n * @template TokenAddress - A type union of all token addresses. The reason this\n * type parameter exists is so that we can guarantee that same addresses that\n * `fetchTokenPrices` receives are the same addresses that shown up in the\n * return value.\n * @template Currency - A type union of valid arguments for the `currency`\n * argument to `fetchTokenPrices`.\n */\nexport type AbstractTokenPricesService<\n  ChainId extends string = string,\n  TokenAddress extends Hex = Hex,\n  Currency extends string = string,\n> = {\n  /**\n   * Retrieves prices in the given currency for the tokens identified by the\n   * given addresses which are expected to live on the given chain.\n   *\n   * @param args - The arguments to this function.\n   * @param args.chainId - An EIP-155 chain ID.\n   * @param args.tokenAddresses - Addresses for tokens that live on the chain.\n   * @param args.currency - The desired currency of the token prices.\n   * @returns The prices for the requested tokens.\n   */\n  fetchTokenPrices({\n    chainId,\n    tokenAddresses,\n    currency,\n  }: {\n    chainId: ChainId;\n    tokenAddresses: TokenAddress[];\n    currency: Currency;\n  }): Promise<Partial<TokenPricesByTokenAddress<TokenAddress, Currency>>>;\n\n  /**\n   * Type guard for whether the API can return token prices for the given chain\n   * ID.\n   *\n   * @param chainId - The chain ID to check.\n   * @returns True if the API supports the chain ID, false otherwise.\n   */\n  validateChainIdSupported(chainId: unknown): chainId is ChainId;\n\n  /**\n   * Type guard for whether the API can return token prices in the given\n   * currency.\n   *\n   * @param currency - The currency to check.\n   * @returns True if the API supports the currency, false otherwise.\n   */\n  validateCurrencySupported(currency: unknown): currency is Currency;\n};\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-prices-service/codefi-v2.d.ts b/node_modules/@metamask/assets-controllers/dist/token-prices-service/codefi-v2.d.ts
new file mode 100644
index 0000000..2daa937
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/token-prices-service/codefi-v2.d.ts
@@ -0,0 +1,80 @@
+import type { Hex } from '@metamask/utils';
+import type { AbstractTokenPricesService, TokenPricesByTokenAddress } from './abstract-token-prices-service';
+/**
+ * The list of currencies that can be supplied as the `vsCurrency` parameter to
+ * the `/spot-prices` endpoint, in lowercase form.
+ */
+export declare const SUPPORTED_CURRENCIES: readonly ["btc", "eth", "ltc", "bch", "bnb", "eos", "xrp", "xlm", "link", "dot", "yfi", "usd", "aed", "ars", "aud", "bdt", "bhd", "bmd", "brl", "cad", "chf", "clp", "cny", "czk", "dkk", "eur", "gbp", "hkd", "huf", "idr", "ils", "inr", "jpy", "krw", "kwd", "lkr", "mmk", "mxn", "myr", "ngn", "nok", "nzd", "php", "pkr", "pln", "rub", "sar", "sek", "sgd", "thb", "try", "twd", "uah", "vef", "vnd", "zar", "xdr", "xag", "xau", "bits", "sats"];
+/**
+ * A currency that can be supplied as the `vsCurrency` parameter to
+ * the `/spot-prices` endpoint. Covers both uppercase and lowercase versions.
+ */
+declare type SupportedCurrency = (typeof SUPPORTED_CURRENCIES)[number] | Uppercase<(typeof SUPPORTED_CURRENCIES)[number]>;
+/**
+ * The list of chain IDs that can be supplied in the URL for the `/spot-prices`
+ * endpoint, but in hexadecimal form (for consistency with how we represent
+ * chain IDs in other places).
+ */
+export declare const SUPPORTED_CHAIN_IDS: readonly ["0x1", "0xa", "0x19", "0x38", "0x39", "0x42", "0x46", "0x52", "0x58", "0x64", "0x6a", "0x7a", "0x80", "0x89", "0xfa", "0x120", "0x141", "0x144", "0x169", "0x440", "0x504", "0x505", "0x2105", "0x150", "0x2710", "0xa4b1", "0xa4ec", "0xa516", "0xa86a", "0x518af", "0x4e454152", "0x63564c40", "0xe708"];
+/**
+ * A chain ID that can be supplied in the URL for the `/spot-prices` endpoint,
+ * but in hexadecimal form (for consistency with how we represent chain IDs in
+ * other places).
+ */
+declare type SupportedChainId = (typeof SUPPORTED_CHAIN_IDS)[number];
+/**
+ * This version of the token prices service uses V2 of the Codefi Price API to
+ * fetch token prices.
+ */
+export declare class CodefiTokenPricesServiceV2 implements AbstractTokenPricesService<SupportedChainId, Hex, SupportedCurrency> {
+    #private;
+    /**
+     * Construct a Codefi Token Price Service.
+     *
+     * @param options - Constructor options
+     * @param options.retries - Number of retry attempts for each token price update.
+     * @param options.maximumConsecutiveFailures - The maximum number of consecutive failures
+     * allowed before breaking the circuit and pausing further updates.
+     * @param options.circuitBreakDuration - The amount of time to wait when the circuit breaks
+     * from too many consecutive failures.
+     */
+    constructor({ retries, maximumConsecutiveFailures, circuitBreakDuration, }?: {
+        retries?: number;
+        maximumConsecutiveFailures?: number;
+        circuitBreakDuration?: number;
+    });
+    /**
+     * Retrieves prices in the given currency for the tokens identified by the
+     * given addresses which are expected to live on the given chain.
+     *
+     * @param args - The arguments to function.
+     * @param args.chainId - An EIP-155 chain ID.
+     * @param args.tokenAddresses - Addresses for tokens that live on the chain.
+     * @param args.currency - The desired currency of the token prices.
+     * @returns The prices for the requested tokens.
+     */
+    fetchTokenPrices({ chainId, tokenAddresses, currency, }: {
+        chainId: SupportedChainId;
+        tokenAddresses: Hex[];
+        currency: SupportedCurrency;
+    }): Promise<Partial<TokenPricesByTokenAddress<Hex, SupportedCurrency>>>;
+    /**
+     * Type guard for whether the API can return token prices for the given chain
+     * ID.
+     *
+     * @param chainId - The chain ID to check.
+     * @returns True if the API supports the chain ID, false otherwise.
+     */
+    validateChainIdSupported(chainId: unknown): chainId is SupportedChainId;
+    /**
+     * Type guard for whether the API can return token prices in the given
+     * currency.
+     *
+     * @param currency - The currency to check. If a string, can be either
+     * lowercase or uppercase.
+     * @returns True if the API supports the currency, false otherwise.
+     */
+    validateCurrencySupported(currency: unknown): currency is SupportedCurrency;
+}
+export {};
+//# sourceMappingURL=codefi-v2.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-prices-service/codefi-v2.d.ts.map b/node_modules/@metamask/assets-controllers/dist/token-prices-service/codefi-v2.d.ts.map
new file mode 100644
index 0000000..5f4b9a2
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/token-prices-service/codefi-v2.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"codefi-v2.d.ts","sourceRoot":"","sources":["../../src/token-prices-service/codefi-v2.ts"],"names":[],"mappings":"AACA,OAAO,KAAK,EAAE,GAAG,EAAE,MAAM,iBAAiB,CAAC;AAY3C,OAAO,KAAK,EACV,0BAA0B,EAE1B,yBAAyB,EAC1B,MAAM,iCAAiC,CAAC;AAUzC;;;GAGG;AACH,eAAO,MAAM,oBAAoB,ybA2HvB,CAAC;AAEX;;;GAGG;AACH,aAAK,iBAAiB,GAClB,CAAC,OAAO,oBAAoB,CAAC,CAAC,MAAM,CAAC,GACrC,SAAS,CAAC,CAAC,OAAO,oBAAoB,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;AAErD;;;;GAIG;AACH,eAAO,MAAM,mBAAmB,sTAmEtB,CAAC;AACX;;;;GAIG;AACH,aAAK,gBAAgB,GAAG,CAAC,OAAO,mBAAmB,CAAC,CAAC,MAAM,CAAC,CAAC;AAY7D;;;GAGG;AACH,qBAAa,0BACX,YACE,0BAA0B,CAAC,gBAAgB,EAAE,GAAG,EAAE,iBAAiB,CAAC;;IAItE;;;;;;;;;OASG;gBACS,EACV,OAAqC,EACrC,0BAAyE,EACzE,oBAAqC,GACtC,GAAE;QACD,OAAO,CAAC,EAAE,MAAM,CAAC;QACjB,0BAA0B,CAAC,EAAE,MAAM,CAAC;QACpC,oBAAoB,CAAC,EAAE,MAAM,CAAC;KAC1B;IAcN;;;;;;;;;OASG;IACG,gBAAgB,CAAC,EACrB,OAAO,EACP,cAAc,EACd,QAAQ,GACT,EAAE;QACD,OAAO,EAAE,gBAAgB,CAAC;QAC1B,cAAc,EAAE,GAAG,EAAE,CAAC;QACtB,QAAQ,EAAE,iBAAiB,CAAC;KAC7B,GAAG,OAAO,CAAC,OAAO,CAAC,yBAAyB,CAAC,GAAG,EAAE,iBAAiB,CAAC,CAAC,CAAC;IAoDvE;;;;;;OAMG;IACH,wBAAwB,CAAC,OAAO,EAAE,OAAO,GAAG,OAAO,IAAI,gBAAgB;IAKvE;;;;;;;OAOG;IACH,yBAAyB,CAAC,QAAQ,EAAE,OAAO,GAAG,QAAQ,IAAI,iBAAiB;CAO5E"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-prices-service/codefi-v2.js b/node_modules/@metamask/assets-controllers/dist/token-prices-service/codefi-v2.js
new file mode 100644
index 0000000..cd10d7f
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/token-prices-service/codefi-v2.js
@@ -0,0 +1,331 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
+    if (kind === "m") throw new TypeError("Private method is not writable");
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
+    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
+};
+var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
+    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
+};
+var _CodefiTokenPricesServiceV2_tokenPricePolicy;
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.CodefiTokenPricesServiceV2 = exports.SUPPORTED_CHAIN_IDS = exports.SUPPORTED_CURRENCIES = void 0;
+const controller_utils_1 = require("@metamask/controller-utils");
+const utils_1 = require("@metamask/utils");
+const cockatiel_1 = require("cockatiel");
+/**
+ * The list of currencies that can be supplied as the `vsCurrency` parameter to
+ * the `/spot-prices` endpoint, in lowercase form.
+ */
+exports.SUPPORTED_CURRENCIES = [
+    // Bitcoin
+    'btc',
+    // Ether
+    'eth',
+    // Litecoin
+    'ltc',
+    // Bitcoin Cash
+    'bch',
+    // Binance Coin
+    'bnb',
+    // EOS
+    'eos',
+    // XRP
+    'xrp',
+    // Lumens
+    'xlm',
+    // Chainlink
+    'link',
+    // Polkadot
+    'dot',
+    // Yearn.finance
+    'yfi',
+    // US Dollar
+    'usd',
+    // United Arab Emirates Dirham
+    'aed',
+    // Argentine Peso
+    'ars',
+    // Australian Dollar
+    'aud',
+    // Bangladeshi Taka
+    'bdt',
+    // Bahraini Dinar
+    'bhd',
+    // Bermudian Dollar
+    'bmd',
+    // Brazil Real
+    'brl',
+    // Canadian Dollar
+    'cad',
+    // Swiss Franc
+    'chf',
+    // Chilean Peso
+    'clp',
+    // Chinese Yuan
+    'cny',
+    // Czech Koruna
+    'czk',
+    // Danish Krone
+    'dkk',
+    // Euro
+    'eur',
+    // British Pound Sterling
+    'gbp',
+    // Hong Kong Dollar
+    'hkd',
+    // Hungarian Forint
+    'huf',
+    // Indonesian Rupiah
+    'idr',
+    // Israeli New Shekel
+    'ils',
+    // Indian Rupee
+    'inr',
+    // Japanese Yen
+    'jpy',
+    // South Korean Won
+    'krw',
+    // Kuwaiti Dinar
+    'kwd',
+    // Sri Lankan Rupee
+    'lkr',
+    // Burmese Kyat
+    'mmk',
+    // Mexican Peso
+    'mxn',
+    // Malaysian Ringgit
+    'myr',
+    // Nigerian Naira
+    'ngn',
+    // Norwegian Krone
+    'nok',
+    // New Zealand Dollar
+    'nzd',
+    // Philippine Peso
+    'php',
+    // Pakistani Rupee
+    'pkr',
+    // Polish Zloty
+    'pln',
+    // Russian Ruble
+    'rub',
+    // Saudi Riyal
+    'sar',
+    // Swedish Krona
+    'sek',
+    // Singapore Dollar
+    'sgd',
+    // Thai Baht
+    'thb',
+    // Turkish Lira
+    'try',
+    // New Taiwan Dollar
+    'twd',
+    // Ukrainian hryvnia
+    'uah',
+    // Venezuelan bolvar fuerte
+    'vef',
+    // Vietnamese ng
+    'vnd',
+    // South African Rand
+    'zar',
+    // IMF Special Drawing Rights
+    'xdr',
+    // Silver - Troy Ounce
+    'xag',
+    // Gold - Troy Ounce
+    'xau',
+    // Bits
+    'bits',
+    // Satoshi
+    'sats',
+];
+/**
+ * The list of chain IDs that can be supplied in the URL for the `/spot-prices`
+ * endpoint, but in hexadecimal form (for consistency with how we represent
+ * chain IDs in other places).
+ */
+exports.SUPPORTED_CHAIN_IDS = [
+    // Ethereum Mainnet
+    '0x1',
+    // OP Mainnet
+    '0xa',
+    // Cronos Mainnet
+    '0x19',
+    // BNB Smart Chain Mainnet
+    '0x38',
+    // Syscoin Mainnet
+    '0x39',
+    // OKXChain Mainnet
+    '0x42',
+    // Hoo Smart Chain
+    '0x46',
+    // Meter Mainnet
+    '0x52',
+    // TomoChain
+    '0x58',
+    // Gnosis
+    '0x64',
+    // Velas EVM Mainnet
+    '0x6a',
+    // Fuse Mainnet
+    '0x7a',
+    // Huobi ECO Chain Mainnet
+    '0x80',
+    // Polygon Mainnet
+    '0x89',
+    // Fantom Opera
+    '0xfa',
+    // Boba Network
+    '0x120',
+    // KCC Mainnet
+    '0x141',
+    // zkSync Era Mainnet
+    '0x144',
+    // Theta Mainnet
+    '0x169',
+    // Metis Andromeda Mainnet
+    '0x440',
+    // Moonbeam
+    '0x504',
+    // Moonriver
+    '0x505',
+    // Base
+    '0x2105',
+    // Shiden
+    '0x150',
+    // Smart Bitcoin Cash
+    '0x2710',
+    // Arbitrum One
+    '0xa4b1',
+    // Celo Mainnet
+    '0xa4ec',
+    // Oasis Emerald
+    '0xa516',
+    // Avalanche C-Chain
+    '0xa86a',
+    // Polis Mainnet
+    '0x518af',
+    // Aurora Mainnet
+    '0x4e454152',
+    // Harmony Mainnet Shard 0
+    '0x63564c40',
+    // Linea Mainnet
+    '0xe708',
+];
+/**
+ * All requests to V2 of the Price API start with this.
+ */
+const BASE_URL = 'https://price-api.metafi.codefi.network/v2';
+const DEFAULT_TOKEN_PRICE_RETRIES = 3;
+// Each update attempt will result (1 + retries) calls if the server is down
+const DEFAULT_TOKEN_PRICE_MAX_CONSECUTIVE_FAILURES = (1 + DEFAULT_TOKEN_PRICE_RETRIES) * 3;
+/**
+ * This version of the token prices service uses V2 of the Codefi Price API to
+ * fetch token prices.
+ */
+class CodefiTokenPricesServiceV2 {
+    /**
+     * Construct a Codefi Token Price Service.
+     *
+     * @param options - Constructor options
+     * @param options.retries - Number of retry attempts for each token price update.
+     * @param options.maximumConsecutiveFailures - The maximum number of consecutive failures
+     * allowed before breaking the circuit and pausing further updates.
+     * @param options.circuitBreakDuration - The amount of time to wait when the circuit breaks
+     * from too many consecutive failures.
+     */
+    constructor({ retries = DEFAULT_TOKEN_PRICE_RETRIES, maximumConsecutiveFailures = DEFAULT_TOKEN_PRICE_MAX_CONSECUTIVE_FAILURES, circuitBreakDuration = 30 * 60 * 1000, } = {}) {
+        _CodefiTokenPricesServiceV2_tokenPricePolicy.set(this, void 0);
+        // Construct a policy that will retry each update, and halt further updates
+        // for a certain period after too many consecutive failures.
+        const retryPolicy = (0, cockatiel_1.retry)(cockatiel_1.handleAll, {
+            maxAttempts: retries,
+            backoff: new cockatiel_1.ExponentialBackoff(),
+        });
+        const circuitBreakerPolicy = (0, cockatiel_1.circuitBreaker)(cockatiel_1.handleAll, {
+            halfOpenAfter: circuitBreakDuration,
+            breaker: new cockatiel_1.ConsecutiveBreaker(maximumConsecutiveFailures),
+        });
+        __classPrivateFieldSet(this, _CodefiTokenPricesServiceV2_tokenPricePolicy, (0, cockatiel_1.wrap)(retryPolicy, circuitBreakerPolicy), "f");
+    }
+    /**
+     * Retrieves prices in the given currency for the tokens identified by the
+     * given addresses which are expected to live on the given chain.
+     *
+     * @param args - The arguments to function.
+     * @param args.chainId - An EIP-155 chain ID.
+     * @param args.tokenAddresses - Addresses for tokens that live on the chain.
+     * @param args.currency - The desired currency of the token prices.
+     * @returns The prices for the requested tokens.
+     */
+    fetchTokenPrices({ chainId, tokenAddresses, currency, }) {
+        return __awaiter(this, void 0, void 0, function* () {
+            const chainIdAsNumber = (0, utils_1.hexToNumber)(chainId);
+            const url = new URL(`${BASE_URL}/chains/${chainIdAsNumber}/spot-prices`);
+            url.searchParams.append('tokenAddresses', tokenAddresses.join(','));
+            url.searchParams.append('vsCurrency', currency);
+            const pricesByCurrencyByTokenAddress = yield __classPrivateFieldGet(this, _CodefiTokenPricesServiceV2_tokenPricePolicy, "f").execute(() => (0, controller_utils_1.handleFetch)(url));
+            return tokenAddresses.reduce((obj, tokenAddress) => {
+                var _a;
+                // The Price API lowercases both currency and token addresses, so we have
+                // to keep track of them and make sure we return the original versions.
+                const lowercasedTokenAddress = tokenAddress.toLowerCase();
+                const lowercasedCurrency = currency.toLowerCase();
+                const price = (_a = pricesByCurrencyByTokenAddress[lowercasedTokenAddress]) === null || _a === void 0 ? void 0 : _a[lowercasedCurrency];
+                if (!price) {
+                    // console error instead of throwing to not interrupt the fetching of other tokens in case just one fails
+                    console.error(`Could not find price for "${tokenAddress}" in "${currency}"`);
+                }
+                const tokenPrice = {
+                    tokenAddress,
+                    value: price,
+                    currency,
+                };
+                return Object.assign(Object.assign({}, obj), (tokenPrice.value !== undefined
+                    ? { [tokenAddress]: tokenPrice }
+                    : {}));
+            }, {});
+        });
+    }
+    /**
+     * Type guard for whether the API can return token prices for the given chain
+     * ID.
+     *
+     * @param chainId - The chain ID to check.
+     * @returns True if the API supports the chain ID, false otherwise.
+     */
+    validateChainIdSupported(chainId) {
+        const supportedChainIds = exports.SUPPORTED_CHAIN_IDS;
+        return typeof chainId === 'string' && supportedChainIds.includes(chainId);
+    }
+    /**
+     * Type guard for whether the API can return token prices in the given
+     * currency.
+     *
+     * @param currency - The currency to check. If a string, can be either
+     * lowercase or uppercase.
+     * @returns True if the API supports the currency, false otherwise.
+     */
+    validateCurrencySupported(currency) {
+        const supportedCurrencies = exports.SUPPORTED_CURRENCIES;
+        return (typeof currency === 'string' &&
+            supportedCurrencies.includes(currency.toLowerCase()));
+    }
+}
+exports.CodefiTokenPricesServiceV2 = CodefiTokenPricesServiceV2;
+_CodefiTokenPricesServiceV2_tokenPricePolicy = new WeakMap();
+//# sourceMappingURL=codefi-v2.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-prices-service/codefi-v2.js.map b/node_modules/@metamask/assets-controllers/dist/token-prices-service/codefi-v2.js.map
new file mode 100644
index 0000000..81592d0
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/token-prices-service/codefi-v2.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"codefi-v2.js","sourceRoot":"","sources":["../../src/token-prices-service/codefi-v2.ts"],"names":[],"mappings":"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","sourcesContent":["import { handleFetch } from '@metamask/controller-utils';\nimport type { Hex } from '@metamask/utils';\nimport { hexToNumber } from '@metamask/utils';\nimport {\n  circuitBreaker,\n  ConsecutiveBreaker,\n  ExponentialBackoff,\n  handleAll,\n  type IPolicy,\n  retry,\n  wrap,\n} from 'cockatiel';\n\nimport type {\n  AbstractTokenPricesService,\n  TokenPrice,\n  TokenPricesByTokenAddress,\n} from './abstract-token-prices-service';\n\n/**\n * The shape of the data that the /spot-prices endpoint returns.\n */\ntype SpotPricesEndpointData<\n  TokenAddress extends Hex,\n  Currency extends string,\n> = Record<TokenAddress, Record<Currency, number>>;\n\n/**\n * The list of currencies that can be supplied as the `vsCurrency` parameter to\n * the `/spot-prices` endpoint, in lowercase form.\n */\nexport const SUPPORTED_CURRENCIES = [\n  // Bitcoin\n  'btc',\n  // Ether\n  'eth',\n  // Litecoin\n  'ltc',\n  // Bitcoin Cash\n  'bch',\n  // Binance Coin\n  'bnb',\n  // EOS\n  'eos',\n  // XRP\n  'xrp',\n  // Lumens\n  'xlm',\n  // Chainlink\n  'link',\n  // Polkadot\n  'dot',\n  // Yearn.finance\n  'yfi',\n  // US Dollar\n  'usd',\n  // United Arab Emirates Dirham\n  'aed',\n  // Argentine Peso\n  'ars',\n  // Australian Dollar\n  'aud',\n  // Bangladeshi Taka\n  'bdt',\n  // Bahraini Dinar\n  'bhd',\n  // Bermudian Dollar\n  'bmd',\n  // Brazil Real\n  'brl',\n  // Canadian Dollar\n  'cad',\n  // Swiss Franc\n  'chf',\n  // Chilean Peso\n  'clp',\n  // Chinese Yuan\n  'cny',\n  // Czech Koruna\n  'czk',\n  // Danish Krone\n  'dkk',\n  // Euro\n  'eur',\n  // British Pound Sterling\n  'gbp',\n  // Hong Kong Dollar\n  'hkd',\n  // Hungarian Forint\n  'huf',\n  // Indonesian Rupiah\n  'idr',\n  // Israeli New Shekel\n  'ils',\n  // Indian Rupee\n  'inr',\n  // Japanese Yen\n  'jpy',\n  // South Korean Won\n  'krw',\n  // Kuwaiti Dinar\n  'kwd',\n  // Sri Lankan Rupee\n  'lkr',\n  // Burmese Kyat\n  'mmk',\n  // Mexican Peso\n  'mxn',\n  // Malaysian Ringgit\n  'myr',\n  // Nigerian Naira\n  'ngn',\n  // Norwegian Krone\n  'nok',\n  // New Zealand Dollar\n  'nzd',\n  // Philippine Peso\n  'php',\n  // Pakistani Rupee\n  'pkr',\n  // Polish Zloty\n  'pln',\n  // Russian Ruble\n  'rub',\n  // Saudi Riyal\n  'sar',\n  // Swedish Krona\n  'sek',\n  // Singapore Dollar\n  'sgd',\n  // Thai Baht\n  'thb',\n  // Turkish Lira\n  'try',\n  // New Taiwan Dollar\n  'twd',\n  // Ukrainian hryvnia\n  'uah',\n  // Venezuelan bolvar fuerte\n  'vef',\n  // Vietnamese ng\n  'vnd',\n  // South African Rand\n  'zar',\n  // IMF Special Drawing Rights\n  'xdr',\n  // Silver - Troy Ounce\n  'xag',\n  // Gold - Troy Ounce\n  'xau',\n  // Bits\n  'bits',\n  // Satoshi\n  'sats',\n] as const;\n\n/**\n * A currency that can be supplied as the `vsCurrency` parameter to\n * the `/spot-prices` endpoint. Covers both uppercase and lowercase versions.\n */\ntype SupportedCurrency =\n  | (typeof SUPPORTED_CURRENCIES)[number]\n  | Uppercase<(typeof SUPPORTED_CURRENCIES)[number]>;\n\n/**\n * The list of chain IDs that can be supplied in the URL for the `/spot-prices`\n * endpoint, but in hexadecimal form (for consistency with how we represent\n * chain IDs in other places).\n */\nexport const SUPPORTED_CHAIN_IDS = [\n  // Ethereum Mainnet\n  '0x1',\n  // OP Mainnet\n  '0xa',\n  // Cronos Mainnet\n  '0x19',\n  // BNB Smart Chain Mainnet\n  '0x38',\n  // Syscoin Mainnet\n  '0x39',\n  // OKXChain Mainnet\n  '0x42',\n  // Hoo Smart Chain\n  '0x46',\n  // Meter Mainnet\n  '0x52',\n  // TomoChain\n  '0x58',\n  // Gnosis\n  '0x64',\n  // Velas EVM Mainnet\n  '0x6a',\n  // Fuse Mainnet\n  '0x7a',\n  // Huobi ECO Chain Mainnet\n  '0x80',\n  // Polygon Mainnet\n  '0x89',\n  // Fantom Opera\n  '0xfa',\n  // Boba Network\n  '0x120',\n  // KCC Mainnet\n  '0x141',\n  // zkSync Era Mainnet\n  '0x144',\n  // Theta Mainnet\n  '0x169',\n  // Metis Andromeda Mainnet\n  '0x440',\n  // Moonbeam\n  '0x504',\n  // Moonriver\n  '0x505',\n  // Base\n  '0x2105',\n  // Shiden\n  '0x150',\n  // Smart Bitcoin Cash\n  '0x2710',\n  // Arbitrum One\n  '0xa4b1',\n  // Celo Mainnet\n  '0xa4ec',\n  // Oasis Emerald\n  '0xa516',\n  // Avalanche C-Chain\n  '0xa86a',\n  // Polis Mainnet\n  '0x518af',\n  // Aurora Mainnet\n  '0x4e454152',\n  // Harmony Mainnet Shard 0\n  '0x63564c40',\n  // Linea Mainnet\n  '0xe708',\n] as const;\n/**\n * A chain ID that can be supplied in the URL for the `/spot-prices` endpoint,\n * but in hexadecimal form (for consistency with how we represent chain IDs in\n * other places).\n */\ntype SupportedChainId = (typeof SUPPORTED_CHAIN_IDS)[number];\n\n/**\n * All requests to V2 of the Price API start with this.\n */\nconst BASE_URL = 'https://price-api.metafi.codefi.network/v2';\n\nconst DEFAULT_TOKEN_PRICE_RETRIES = 3;\n// Each update attempt will result (1 + retries) calls if the server is down\nconst DEFAULT_TOKEN_PRICE_MAX_CONSECUTIVE_FAILURES =\n  (1 + DEFAULT_TOKEN_PRICE_RETRIES) * 3;\n\n/**\n * This version of the token prices service uses V2 of the Codefi Price API to\n * fetch token prices.\n */\nexport class CodefiTokenPricesServiceV2\n  implements\n    AbstractTokenPricesService<SupportedChainId, Hex, SupportedCurrency>\n{\n  #tokenPricePolicy: IPolicy;\n\n  /**\n   * Construct a Codefi Token Price Service.\n   *\n   * @param options - Constructor options\n   * @param options.retries - Number of retry attempts for each token price update.\n   * @param options.maximumConsecutiveFailures - The maximum number of consecutive failures\n   * allowed before breaking the circuit and pausing further updates.\n   * @param options.circuitBreakDuration - The amount of time to wait when the circuit breaks\n   * from too many consecutive failures.\n   */\n  constructor({\n    retries = DEFAULT_TOKEN_PRICE_RETRIES,\n    maximumConsecutiveFailures = DEFAULT_TOKEN_PRICE_MAX_CONSECUTIVE_FAILURES,\n    circuitBreakDuration = 30 * 60 * 1000,\n  }: {\n    retries?: number;\n    maximumConsecutiveFailures?: number;\n    circuitBreakDuration?: number;\n  } = {}) {\n    // Construct a policy that will retry each update, and halt further updates\n    // for a certain period after too many consecutive failures.\n    const retryPolicy = retry(handleAll, {\n      maxAttempts: retries,\n      backoff: new ExponentialBackoff(),\n    });\n    const circuitBreakerPolicy = circuitBreaker(handleAll, {\n      halfOpenAfter: circuitBreakDuration,\n      breaker: new ConsecutiveBreaker(maximumConsecutiveFailures),\n    });\n    this.#tokenPricePolicy = wrap(retryPolicy, circuitBreakerPolicy);\n  }\n\n  /**\n   * Retrieves prices in the given currency for the tokens identified by the\n   * given addresses which are expected to live on the given chain.\n   *\n   * @param args - The arguments to function.\n   * @param args.chainId - An EIP-155 chain ID.\n   * @param args.tokenAddresses - Addresses for tokens that live on the chain.\n   * @param args.currency - The desired currency of the token prices.\n   * @returns The prices for the requested tokens.\n   */\n  async fetchTokenPrices({\n    chainId,\n    tokenAddresses,\n    currency,\n  }: {\n    chainId: SupportedChainId;\n    tokenAddresses: Hex[];\n    currency: SupportedCurrency;\n  }): Promise<Partial<TokenPricesByTokenAddress<Hex, SupportedCurrency>>> {\n    const chainIdAsNumber = hexToNumber(chainId);\n\n    const url = new URL(`${BASE_URL}/chains/${chainIdAsNumber}/spot-prices`);\n    url.searchParams.append('tokenAddresses', tokenAddresses.join(','));\n    url.searchParams.append('vsCurrency', currency);\n\n    const pricesByCurrencyByTokenAddress: SpotPricesEndpointData<\n      Lowercase<Hex>,\n      Lowercase<SupportedCurrency>\n    > = await this.#tokenPricePolicy.execute(() => handleFetch(url));\n\n    return tokenAddresses.reduce(\n      (\n        obj: Partial<TokenPricesByTokenAddress<Hex, SupportedCurrency>>,\n        tokenAddress,\n      ) => {\n        // The Price API lowercases both currency and token addresses, so we have\n        // to keep track of them and make sure we return the original versions.\n        const lowercasedTokenAddress =\n          tokenAddress.toLowerCase() as Lowercase<Hex>;\n        const lowercasedCurrency =\n          currency.toLowerCase() as Lowercase<SupportedCurrency>;\n\n        const price =\n          pricesByCurrencyByTokenAddress[lowercasedTokenAddress]?.[\n            lowercasedCurrency\n          ];\n\n        if (!price) {\n          // console error instead of throwing to not interrupt the fetching of other tokens in case just one fails\n          console.error(\n            `Could not find price for \"${tokenAddress}\" in \"${currency}\"`,\n          );\n        }\n\n        const tokenPrice: TokenPrice<Hex, SupportedCurrency> = {\n          tokenAddress,\n          value: price,\n          currency,\n        };\n        return {\n          ...obj,\n          ...(tokenPrice.value !== undefined\n            ? { [tokenAddress]: tokenPrice }\n            : {}),\n        };\n      },\n      {},\n    ) as Partial<TokenPricesByTokenAddress<Hex, SupportedCurrency>>;\n  }\n\n  /**\n   * Type guard for whether the API can return token prices for the given chain\n   * ID.\n   *\n   * @param chainId - The chain ID to check.\n   * @returns True if the API supports the chain ID, false otherwise.\n   */\n  validateChainIdSupported(chainId: unknown): chainId is SupportedChainId {\n    const supportedChainIds: readonly string[] = SUPPORTED_CHAIN_IDS;\n    return typeof chainId === 'string' && supportedChainIds.includes(chainId);\n  }\n\n  /**\n   * Type guard for whether the API can return token prices in the given\n   * currency.\n   *\n   * @param currency - The currency to check. If a string, can be either\n   * lowercase or uppercase.\n   * @returns True if the API supports the currency, false otherwise.\n   */\n  validateCurrencySupported(currency: unknown): currency is SupportedCurrency {\n    const supportedCurrencies: readonly string[] = SUPPORTED_CURRENCIES;\n    return (\n      typeof currency === 'string' &&\n      supportedCurrencies.includes(currency.toLowerCase())\n    );\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-prices-service/index.d.ts b/node_modules/@metamask/assets-controllers/dist/token-prices-service/index.d.ts
new file mode 100644
index 0000000..785225a
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/token-prices-service/index.d.ts
@@ -0,0 +1,3 @@
+export type { AbstractTokenPricesService } from './abstract-token-prices-service';
+export { CodefiTokenPricesServiceV2 } from './codefi-v2';
+//# sourceMappingURL=index.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-prices-service/index.d.ts.map b/node_modules/@metamask/assets-controllers/dist/token-prices-service/index.d.ts.map
new file mode 100644
index 0000000..48c1a1c
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/token-prices-service/index.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../src/token-prices-service/index.ts"],"names":[],"mappings":"AAAA,YAAY,EAAE,0BAA0B,EAAE,MAAM,iCAAiC,CAAC;AAClF,OAAO,EAAE,0BAA0B,EAAE,MAAM,aAAa,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-prices-service/index.js b/node_modules/@metamask/assets-controllers/dist/token-prices-service/index.js
new file mode 100644
index 0000000..5d52474
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/token-prices-service/index.js
@@ -0,0 +1,6 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.CodefiTokenPricesServiceV2 = void 0;
+var codefi_v2_1 = require("./codefi-v2");
+Object.defineProperty(exports, "CodefiTokenPricesServiceV2", { enumerable: true, get: function () { return codefi_v2_1.CodefiTokenPricesServiceV2; } });
+//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-prices-service/index.js.map b/node_modules/@metamask/assets-controllers/dist/token-prices-service/index.js.map
new file mode 100644
index 0000000..2692b27
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/token-prices-service/index.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/token-prices-service/index.ts"],"names":[],"mappings":";;;AACA,yCAAyD;AAAhD,uHAAA,0BAA0B,OAAA","sourcesContent":["export type { AbstractTokenPricesService } from './abstract-token-prices-service';\nexport { CodefiTokenPricesServiceV2 } from './codefi-v2';\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-service.d.ts b/node_modules/@metamask/assets-controllers/dist/token-service.d.ts
index 9caf787..dbcb2ec 100644
--- a/node_modules/@metamask/assets-controllers/dist/token-service.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/token-service.d.ts
@@ -12,7 +12,20 @@ export declare const TOKEN_METADATA_NO_SUPPORT_ERROR = "TokenService Error: Netw
  * @returns The token list, or `undefined` if the request was cancelled.
  */
 export declare function fetchTokenListByChainId(chainId: Hex, abortSignal: AbortSignal, { timeout }?: {
-    timeout?: number | undefined;
+    timeout?: number;
+}): Promise<unknown>;
+/**
+ * Fetch the list of token metadata for a given network. This request is cancellable using the
+ * abort signal passed in.
+ *
+ * @param chainId - The chain ID of the network the requested tokens are on.
+ * @param abortSignal - The abort signal used to cancel the request if necessary.
+ * @param options - Additional fetch options.
+ * @param options.timeout - The fetch timeout.
+ * @returns The token list, or `undefined` if the request was cancelled.
+ */
+export declare function fetchTokenList(chainId: Hex, abortSignal: AbortSignal, { timeout }?: {
+    timeout?: number;
 }): Promise<unknown>;
 /**
  * Fetch metadata for the token address provided for a given network. This request is cancellable
@@ -26,6 +39,6 @@ export declare function fetchTokenListByChainId(chainId: Hex, abortSignal: Abort
  * @returns The token metadata, or `undefined` if the request was either aborted or failed.
  */
 export declare function fetchTokenMetadata<T>(chainId: Hex, tokenAddress: string, abortSignal: AbortSignal, { timeout }?: {
-    timeout?: number | undefined;
+    timeout?: number;
 }): Promise<T | undefined>;
 //# sourceMappingURL=token-service.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-service.d.ts.map b/node_modules/@metamask/assets-controllers/dist/token-service.d.ts.map
index 4de25c1..75b54ee 100644
--- a/node_modules/@metamask/assets-controllers/dist/token-service.d.ts.map
+++ b/node_modules/@metamask/assets-controllers/dist/token-service.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"token-service.d.ts","sourceRoot":"","sources":["../src/token-service.ts"],"names":[],"mappings":"AACA,OAAO,KAAK,EAAE,GAAG,EAAE,MAAM,iBAAiB,CAAC;AAI3C,eAAO,MAAM,mBAAmB,8CAA8C,CAAC;AAC/E,eAAO,MAAM,+BAA+B,oEACuB,CAAC;AA+BpE;;;;;;;;;GASG;AACH,wBAAsB,uBAAuB,CAC3C,OAAO,EAAE,GAAG,EACZ,WAAW,EAAE,WAAW,EACxB,EAAE,OAAwB,EAAE;;CAAK,GAChC,OAAO,CAAC,OAAO,CAAC,CAOlB;AAED;;;;;;;;;;GAUG;AACH,wBAAsB,kBAAkB,CAAC,CAAC,EACxC,OAAO,EAAE,GAAG,EACZ,YAAY,EAAE,MAAM,EACpB,WAAW,EAAE,WAAW,EACxB,EAAE,OAAwB,EAAE;;CAAK,GAChC,OAAO,CAAC,CAAC,GAAG,SAAS,CAAC,CAUxB"}
\ No newline at end of file
+{"version":3,"file":"token-service.d.ts","sourceRoot":"","sources":["../src/token-service.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,GAAG,EAAE,MAAM,iBAAiB,CAAC;AAI3C,eAAO,MAAM,mBAAmB,8CAA8C,CAAC;AAC/E,eAAO,MAAM,+BAA+B,oEACuB,CAAC;AA+BpE;;;;;;;;;GASG;AACH,wBAAsB,uBAAuB,CAC3C,OAAO,EAAE,GAAG,EACZ,WAAW,EAAE,WAAW,EACxB,EAAE,OAAwB,EAAE;;CAAK,GAChC,OAAO,CAAC,OAAO,CAAC,CAOlB;AAED;;;;;;;;;GASG;AACH,wBAAsB,cAAc,CAClC,OAAO,EAAE,GAAG,EACZ,WAAW,EAAE,WAAW,EACxB,EAAE,OAAwB,EAAE;;CAAK,GAChC,OAAO,CAAC,OAAO,CAAC,CAOlB;AAED;;;;;;;;;;GAUG;AACH,wBAAsB,kBAAkB,CAAC,CAAC,EACxC,OAAO,EAAE,GAAG,EACZ,YAAY,EAAE,MAAM,EACpB,WAAW,EAAE,WAAW,EACxB,EAAE,OAAwB,EAAE;;CAAK,GAChC,OAAO,CAAC,CAAC,GAAG,SAAS,CAAC,CAUxB"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-service.js b/node_modules/@metamask/assets-controllers/dist/token-service.js
index dc18bf8..4d9725f 100644
--- a/node_modules/@metamask/assets-controllers/dist/token-service.js
+++ b/node_modules/@metamask/assets-controllers/dist/token-service.js
@@ -9,7 +9,7 @@ var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, ge
     });
 };
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.fetchTokenMetadata = exports.fetchTokenListByChainId = exports.TOKEN_METADATA_NO_SUPPORT_ERROR = exports.TOKEN_END_POINT_API = void 0;
+exports.fetchTokenMetadata = exports.fetchTokenList = exports.fetchTokenListByChainId = exports.TOKEN_METADATA_NO_SUPPORT_ERROR = exports.TOKEN_END_POINT_API = void 0;
 const controller_utils_1 = require("@metamask/controller-utils");
 const assetsUtil_1 = require("./assetsUtil");
 exports.TOKEN_END_POINT_API = 'https://token-api.metaswap.codefi.network';
@@ -58,6 +58,27 @@ function fetchTokenListByChainId(chainId, abortSignal, { timeout = defaultTimeou
     });
 }
 exports.fetchTokenListByChainId = fetchTokenListByChainId;
+/**
+ * Fetch the list of token metadata for a given network. This request is cancellable using the
+ * abort signal passed in.
+ *
+ * @param chainId - The chain ID of the network the requested tokens are on.
+ * @param abortSignal - The abort signal used to cancel the request if necessary.
+ * @param options - Additional fetch options.
+ * @param options.timeout - The fetch timeout.
+ * @returns The token list, or `undefined` if the request was cancelled.
+ */
+function fetchTokenList(chainId, abortSignal, { timeout = defaultTimeout } = {}) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const tokenURL = getTokensURL(chainId);
+        const response = yield queryApi(tokenURL, abortSignal, timeout);
+        if (response) {
+            return parseJsonResponse(response);
+        }
+        return undefined;
+    });
+}
+exports.fetchTokenList = fetchTokenList;
 /**
  * Fetch metadata for the token address provided for a given network. This request is cancellable
  * using the abort signal passed in.
diff --git a/node_modules/@metamask/assets-controllers/dist/token-service.js.map b/node_modules/@metamask/assets-controllers/dist/token-service.js.map
index 2fc0afb..1a411e9 100644
--- a/node_modules/@metamask/assets-controllers/dist/token-service.js.map
+++ b/node_modules/@metamask/assets-controllers/dist/token-service.js.map
@@ -1 +1 @@
-{"version":3,"file":"token-service.js","sourceRoot":"","sources":["../src/token-service.ts"],"names":[],"mappings":"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","sourcesContent":["import { convertHexToDecimal, timeoutFetch } from '@metamask/controller-utils';\nimport type { Hex } from '@metamask/utils';\n\nimport { isTokenListSupportedForNetwork } from './assetsUtil';\n\nexport const TOKEN_END_POINT_API = 'https://token-api.metaswap.codefi.network';\nexport const TOKEN_METADATA_NO_SUPPORT_ERROR =\n  'TokenService Error: Network does not support fetchTokenMetadata';\n\n/**\n * Get the tokens URL for a specific network.\n *\n * @param chainId - The chain ID of the network the tokens requested are on.\n * @returns The tokens URL.\n */\nfunction getTokensURL(chainId: Hex) {\n  return `${TOKEN_END_POINT_API}/tokens/${convertHexToDecimal(chainId)}`;\n}\n\n/**\n * Get the token metadata URL for the given network and token.\n *\n * @param chainId - The chain ID of the network the token is on.\n * @param tokenAddress - The token address.\n * @returns The token metadata URL.\n */\nfunction getTokenMetadataURL(chainId: Hex, tokenAddress: string) {\n  return `${TOKEN_END_POINT_API}/token/${convertHexToDecimal(\n    chainId,\n  )}?address=${tokenAddress}`;\n}\n\nconst tenSecondsInMilliseconds = 10_000;\n\n// Token list averages 1.6 MB in size\n// timeoutFetch by default has a 500ms timeout, which will almost always timeout given the response size.\nconst defaultTimeout = tenSecondsInMilliseconds;\n\n/**\n * Fetch the list of token metadata for a given network. This request is cancellable using the\n * abort signal passed in.\n *\n * @param chainId - The chain ID of the network the requested tokens are on.\n * @param abortSignal - The abort signal used to cancel the request if necessary.\n * @param options - Additional fetch options.\n * @param options.timeout - The fetch timeout.\n * @returns The token list, or `undefined` if the request was cancelled.\n */\nexport async function fetchTokenListByChainId(\n  chainId: Hex,\n  abortSignal: AbortSignal,\n  { timeout = defaultTimeout } = {},\n): Promise<unknown> {\n  const tokenURL = getTokensURL(chainId);\n  const response = await queryApi(tokenURL, abortSignal, timeout);\n  if (response) {\n    return parseJsonResponse(response);\n  }\n  return undefined;\n}\n\n/**\n * Fetch metadata for the token address provided for a given network. This request is cancellable\n * using the abort signal passed in.\n *\n * @param chainId - The chain ID of the network the token is on.\n * @param tokenAddress - The address of the token to fetch metadata for.\n * @param abortSignal - The abort signal used to cancel the request if necessary.\n * @param options - Additional fetch options.\n * @param options.timeout - The fetch timeout.\n * @returns The token metadata, or `undefined` if the request was either aborted or failed.\n */\nexport async function fetchTokenMetadata<T>(\n  chainId: Hex,\n  tokenAddress: string,\n  abortSignal: AbortSignal,\n  { timeout = defaultTimeout } = {},\n): Promise<T | undefined> {\n  if (!isTokenListSupportedForNetwork(chainId)) {\n    throw new Error(TOKEN_METADATA_NO_SUPPORT_ERROR);\n  }\n  const tokenMetadataURL = getTokenMetadataURL(chainId, tokenAddress);\n  const response = await queryApi(tokenMetadataURL, abortSignal, timeout);\n  if (response) {\n    return parseJsonResponse(response) as Promise<T>;\n  }\n  return undefined;\n}\n\n/**\n * Perform fetch request against the api.\n *\n * @param apiURL - The URL of the API to fetch.\n * @param abortSignal - The abort signal used to cancel the request if necessary.\n * @param timeout - The fetch timeout.\n * @returns Promise resolving request response.\n */\nasync function queryApi(\n  apiURL: string,\n  abortSignal: AbortSignal,\n  timeout: number,\n): Promise<Response | undefined> {\n  const fetchOptions: RequestInit = {\n    referrer: apiURL,\n    referrerPolicy: 'no-referrer-when-downgrade',\n    method: 'GET',\n    mode: 'cors',\n    signal: abortSignal,\n    cache: 'default',\n  };\n  fetchOptions.headers = new window.Headers();\n  fetchOptions.headers.set('Content-Type', 'application/json');\n  try {\n    return await timeoutFetch(apiURL, fetchOptions, timeout);\n  } catch (error) {\n    if (error instanceof Error && error.name === 'AbortError') {\n      console.log('Request is aborted');\n    }\n  }\n  return undefined;\n}\n\n/**\n * Parse an API response and return the response JSON data.\n *\n * @param apiResponse - The API response to parse.\n * @returns The response JSON data.\n * @throws Will throw if the response includes an error.\n */\nasync function parseJsonResponse(apiResponse: Response): Promise<unknown> {\n  const responseObj = await apiResponse.json();\n  // api may return errors as json without setting an error http status code\n  if (responseObj?.error) {\n    throw new Error(`TokenService Error: ${responseObj.error}`);\n  }\n  return responseObj;\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"token-service.js","sourceRoot":"","sources":["../src/token-service.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Hex } from '@metamask/utils';\nimport { convertHexToDecimal, timeoutFetch } from '@metamask/controller-utils';\nimport { isTokenListSupportedForNetwork } from './assetsUtil';\n\nexport const TOKEN_END_POINT_API = 'https://token-api.metaswap.codefi.network';\nexport const TOKEN_METADATA_NO_SUPPORT_ERROR =\n  'TokenService Error: Network does not support fetchTokenMetadata';\n\n/**\n * Get the tokens URL for a specific network.\n *\n * @param chainId - The chain ID of the network the tokens requested are on.\n * @returns The tokens URL.\n */\nfunction getTokensURL(chainId: Hex) {\n  return `${TOKEN_END_POINT_API}/tokens/${convertHexToDecimal(chainId)}`;\n}\n\n/**\n * Get the token metadata URL for the given network and token.\n *\n * @param chainId - The chain ID of the network the token is on.\n * @param tokenAddress - The token address.\n * @returns The token metadata URL.\n */\nfunction getTokenMetadataURL(chainId: Hex, tokenAddress: string) {\n  return `${TOKEN_END_POINT_API}/token/${convertHexToDecimal(\n    chainId,\n  )}?address=${tokenAddress}`;\n}\n\nconst tenSecondsInMilliseconds = 10_000;\n\n// Token list averages 1.6 MB in size\n// timeoutFetch by default has a 500ms timeout, which will almost always timeout given the response size.\nconst defaultTimeout = tenSecondsInMilliseconds;\n\n/**\n * Fetch the list of token metadata for a given network. This request is cancellable using the\n * abort signal passed in.\n *\n * @param chainId - The chain ID of the network the requested tokens are on.\n * @param abortSignal - The abort signal used to cancel the request if necessary.\n * @param options - Additional fetch options.\n * @param options.timeout - The fetch timeout.\n * @returns The token list, or `undefined` if the request was cancelled.\n */\nexport async function fetchTokenListByChainId(\n  chainId: Hex,\n  abortSignal: AbortSignal,\n  { timeout = defaultTimeout } = {},\n): Promise<unknown> {\n  const tokenURL = getTokensURL(chainId);\n  const response = await queryApi(tokenURL, abortSignal, timeout);\n  if (response) {\n    return parseJsonResponse(response);\n  }\n  return undefined;\n}\n\n/**\n * Fetch the list of token metadata for a given network. This request is cancellable using the\n * abort signal passed in.\n *\n * @param chainId - The chain ID of the network the requested tokens are on.\n * @param abortSignal - The abort signal used to cancel the request if necessary.\n * @param options - Additional fetch options.\n * @param options.timeout - The fetch timeout.\n * @returns The token list, or `undefined` if the request was cancelled.\n */\nexport async function fetchTokenList(\n  chainId: Hex,\n  abortSignal: AbortSignal,\n  { timeout = defaultTimeout } = {},\n): Promise<unknown> {\n  const tokenURL = getTokensURL(chainId);\n  const response = await queryApi(tokenURL, abortSignal, timeout);\n  if (response) {\n    return parseJsonResponse(response);\n  }\n  return undefined;\n}\n\n/**\n * Fetch metadata for the token address provided for a given network. This request is cancellable\n * using the abort signal passed in.\n *\n * @param chainId - The chain ID of the network the token is on.\n * @param tokenAddress - The address of the token to fetch metadata for.\n * @param abortSignal - The abort signal used to cancel the request if necessary.\n * @param options - Additional fetch options.\n * @param options.timeout - The fetch timeout.\n * @returns The token metadata, or `undefined` if the request was either aborted or failed.\n */\nexport async function fetchTokenMetadata<T>(\n  chainId: Hex,\n  tokenAddress: string,\n  abortSignal: AbortSignal,\n  { timeout = defaultTimeout } = {},\n): Promise<T | undefined> {\n  if (!isTokenListSupportedForNetwork(chainId)) {\n    throw new Error(TOKEN_METADATA_NO_SUPPORT_ERROR);\n  }\n  const tokenMetadataURL = getTokenMetadataURL(chainId, tokenAddress);\n  const response = await queryApi(tokenMetadataURL, abortSignal, timeout);\n  if (response) {\n    return parseJsonResponse(response) as Promise<T>;\n  }\n  return undefined;\n}\n\n/**\n * Perform fetch request against the api.\n *\n * @param apiURL - The URL of the API to fetch.\n * @param abortSignal - The abort signal used to cancel the request if necessary.\n * @param timeout - The fetch timeout.\n * @returns Promise resolving request response.\n */\nasync function queryApi(\n  apiURL: string,\n  abortSignal: AbortSignal,\n  timeout: number,\n): Promise<Response | undefined> {\n  const fetchOptions: RequestInit = {\n    referrer: apiURL,\n    referrerPolicy: 'no-referrer-when-downgrade',\n    method: 'GET',\n    mode: 'cors',\n    signal: abortSignal,\n    cache: 'default',\n  };\n  fetchOptions.headers = new window.Headers();\n  fetchOptions.headers.set('Content-Type', 'application/json');\n  try {\n    return await timeoutFetch(apiURL, fetchOptions, timeout);\n  } catch (error) {\n    if (error instanceof Error && error.name === 'AbortError') {\n      console.log('Request is aborted');\n    }\n  }\n  return undefined;\n}\n\n/**\n * Parse an API response and return the response JSON data.\n *\n * @param apiResponse - The API response to parse.\n * @returns The response JSON data.\n * @throws Will throw if the response includes an error.\n */\nasync function parseJsonResponse(apiResponse: Response): Promise<unknown> {\n  const responseObj = await apiResponse.json();\n  // api may return errors as json without setting an error http status code\n  if (responseObj?.error) {\n    throw new Error(`TokenService Error: ${responseObj.error}`);\n  }\n  return responseObj;\n}\n"]}
\ No newline at end of file
