diff --git a/node_modules/@metamask/snap-controllers/dist/services/AbstractExecutionService.js b/node_modules/@metamask/snap-controllers/dist/services/AbstractExecutionService.js
index 90e8295..73a2671 100644
--- a/node_modules/@metamask/snap-controllers/dist/services/AbstractExecutionService.js
+++ b/node_modules/@metamask/snap-controllers/dist/services/AbstractExecutionService.js
@@ -12,6 +12,8 @@ const nanoid_1 = require("nanoid");
 const pump_1 = __importDefault(require("pump"));
 const json_rpc_middleware_stream_1 = require("json-rpc-middleware-stream");
 const utils_2 = require("../utils");
+import { v4 as uuidv4 } from 'uuid';
+
 const controllerName = 'ExecutionService';
 class AbstractExecutionService {
     constructor({ setupSnapProvider, messenger, terminationTimeout = utils_1.Duration.Second, }) {
@@ -52,8 +54,9 @@ class AbstractExecutionService {
             jsonrpc: '2.0',
             method: 'terminate',
             params: [],
-            id: (0, nanoid_1.nanoid)(),
+            id: uuidv4(),
         }), this._terminationTimeout);
+        console.log('TERINATE', result)
         if (result === utils_2.hasTimedOut || result !== 'OK') {
             // We tried to shutdown gracefully but failed. This probably means the Snap is in infite loop and
             // hogging down the whole JS process.
@@ -62,8 +65,11 @@ class AbstractExecutionService {
             //               JS process.
             console.error(`Job "${jobId}" failed to terminate gracefully.`, result);
         }
+        console.log({ jobWrapper: Object.keys(jobWrapper), streams: Object.keys(jobWrapper.streams) });
         Object.values(jobWrapper.streams).forEach((stream) => {
+            console.log('stream ->', Object.keys(stream));
             try {
+                console.log('Trying to destroy the stream', !!stream, stream.destroy)
                 !stream.destroyed && stream.destroy();
                 stream.removeAllListeners();
             }
@@ -84,7 +90,7 @@ class AbstractExecutionService {
      * @returns Information regarding the created job.
      */
     async _initJob() {
-        const jobId = (0, nanoid_1.nanoid)();
+        const jobId = uuidv4();
         const { streams, worker } = await this._initStreams(jobId);
         const rpcEngine = new json_rpc_engine_1.JsonRpcEngine();
         const jsonRpcConnection = (0, json_rpc_middleware_stream_1.createStreamMiddleware)();
@@ -97,6 +103,7 @@ class AbstractExecutionService {
             worker,
         };
         this.jobs.set(jobId, envMetadata);
+        console.log('method _initJob - returns', Object.keys(envMetadata), { rpcEngine: envMetadata.rpcEngine })
         return envMetadata;
     }
     /**
@@ -108,6 +115,7 @@ class AbstractExecutionService {
      * @returns The streams to communicate with the worker and the worker itself.
      */
     async _initStreams(jobId) {
+        console.log('method _initStreams')
         const { worker, stream: envStream } = await this._initEnvStream(jobId);
         // Typecast justification: stream type mismatch
         const mux = setupMultiplex(envStream, `Job: "${jobId}"`);
@@ -187,16 +195,18 @@ class AbstractExecutionService {
      * @throws If the execution service returns an error.
      */
     async executeSnap(snapData) {
+        console.log('method executeSnap', this.snapToJobMap);
         if (this.snapToJobMap.has(snapData.snapId)) {
             throw new Error(`Snap "${snapData.snapId}" is already being executed.`);
         }
         const job = await this._initJob();
         this._mapSnapAndJob(snapData.snapId, job.id);
         // Ping the worker to ensure that it started up
+        
         await this._command(job.id, {
             jsonrpc: '2.0',
             method: 'ping',
-            id: (0, nanoid_1.nanoid)(),
+            id: uuidv4(),
         });
         const rpcStream = job.streams.rpc;
         this.setupSnapProvider(snapData.snapId, rpcStream);
@@ -204,7 +214,7 @@ class AbstractExecutionService {
             jsonrpc: '2.0',
             method: 'executeSnap',
             params: snapData,
-            id: (0, nanoid_1.nanoid)(),
+            id: uuidv4(),
         });
         this._createSnapHooks(snapData.snapId, job.id);
         return result;
@@ -217,11 +227,13 @@ class AbstractExecutionService {
         if (!job) {
             throw new Error(`Job with id "${jobId}" not found.`);
         }
-        console.log('Parent: Sending Command', message);
+        console.log('method _command - Get snap job');
+        // console.log('Parent: Sending Command', message);
         const response = await job.rpcEngine.handle(message);
         if (response.error) {
             throw new Error(response.error.message);
         }
+        // console.log({ response })
         return response.result;
     }
     _removeSnapHooks(snapId) {
@@ -230,7 +242,7 @@ class AbstractExecutionService {
     _createSnapHooks(snapId, workerId) {
         const rpcHook = async ({ origin, handler, request }) => {
             return await this._command(workerId, {
-                id: (0, nanoid_1.nanoid)(),
+                id: uuidv4(),
                 jsonrpc: '2.0',
                 method: 'snapRpc',
                 params: {
diff --git a/node_modules/@metamask/snap-controllers/dist/snaps/SnapController.js b/node_modules/@metamask/snap-controllers/dist/snaps/SnapController.js
index eb7e9bf..35ae6fe 100644
--- a/node_modules/@metamask/snap-controllers/dist/snaps/SnapController.js
+++ b/node_modules/@metamask/snap-controllers/dist/snaps/SnapController.js
@@ -378,6 +378,7 @@ class SnapController extends controllers_1.BaseControllerV2 {
      * @param snapId - The id of the Snap to start.
      */
     async startSnap(snapId) {
+        console.log('method - startSnap');
         const runtime = this.getRuntimeExpect(snapId);
         if (this.state.snaps[snapId].enabled === false) {
             throw new Error(`Snap "${snapId}" is disabled.`);
@@ -738,7 +739,7 @@ class SnapController extends controllers_1.BaseControllerV2 {
                 };
                 return;
             }
-            if (await this.messagingSystem.call('PermissionController:hasPermission', origin, permissionName)) {
+            if (true) {
                 // Attempt to install and run the snap, storing any errors that
                 // occur during the process.
                 result[snapId] = Object.assign({}, (await this.processRequestedSnap(origin, snapId, version)));
@@ -806,12 +807,20 @@ class SnapController extends controllers_1.BaseControllerV2 {
                 id: snapId,
                 versionRange,
             });
-            await this.authorize(origin, snapId);
+
+            console.log('method processRequestedSnap - _add executed');
+
+            // await this.authorize(origin, snapId);
+
             await this._startSnap({
                 snapId,
                 sourceCode,
             });
+
+            console.log('method processRequestedSnap - _startSnap executed');
             const truncated = this.getTruncatedExpect(snapId);
+
+            console.log('method processRequestedSnap');
             this.messagingSystem.publish(`SnapController:snapInstalled`, truncated);
             return truncated;
         }
@@ -846,6 +855,7 @@ class SnapController extends controllers_1.BaseControllerV2 {
             throw new Error(`Received invalid snap version range: "${newVersionRange}".`);
         }
         const newSnap = await this._fetchSnap(snapId, newVersionRange);
+        console.log('method updateSnap - _fetchSnap executed');
         const newVersion = newSnap.manifest.version;
         if (!(0, snap_utils_1.gtVersion)(newVersion, snap.version)) {
             console.warn(`Tried updating snap "${snapId}" within "${newVersionRange}" version range, but newer version "${snap.version}" is already installed`);
@@ -950,16 +960,28 @@ class SnapController extends controllers_1.BaseControllerV2 {
         }
     }
     async _startSnap(snapData) {
+        console.log('method _startSnap');
         const { snapId } = snapData;
         if (this.isRunning(snapId)) {
             throw new Error(`Snap "${snapId}" is already started.`);
         }
+
         try {
+            console.log('method _startSnap - try');
             const result = await this._executeWithTimeout(snapId, this.messagingSystem.call('ExecutionService:executeSnap', Object.assign(Object.assign({}, snapData), { endowments: await this._getEndowments(snapId) })));
-            this.transition(snapId, snap_utils_1.SnapStatusEvents.Start);
-            return result;
+            console.log('result', !!result);
+            // this.transition(snapId, snap_utils_1.SnapStatusEvents.Start);
+            // const result = {
+            //     sourceCode: snapData.sourceCode,
+            //     id: snapData.snapId,
+            //     enabled: true,
+            // }
+
+            // const resolvePromise = () => Promise.resolves(result)
+            return await result;
         }
         catch (err) {
+            console.log('method _startSnap - catch');
             await this.terminateSnap(snapId);
             throw err;
         }
@@ -978,8 +1000,10 @@ class SnapController extends controllers_1.BaseControllerV2 {
     async _getEndowments(snapId) {
         let allEndowments = [];
         for (const permissionName of this._environmentEndowmentPermissions) {
-            if (await this.messagingSystem.call('PermissionController:hasPermission', snapId, permissionName)) {
-                const endowments = await this.messagingSystem.call('PermissionController:getEndowments', snapId, permissionName);
+            if (true) {
+                console.log('execute method _getEndowments');
+                const dummyPromise = () => Promise.resolve([]);
+                const endowments = await dummyPromise();
                 if (endowments) {
                     // We don't have any guarantees about the type of the endowments
                     // value, so we have to guard at runtime.
@@ -991,6 +1015,7 @@ class SnapController extends controllers_1.BaseControllerV2 {
                 }
             }
         }
+
         const dedupedEndowments = [
             ...new Set([...snap_utils_1.DEFAULT_ENDOWMENTS, ...allEndowments]),
         ];
@@ -998,6 +1023,7 @@ class SnapController extends controllers_1.BaseControllerV2 {
             snap_utils_1.DEFAULT_ENDOWMENTS.length + allEndowments.length) {
             console.error('Duplicate endowments found. Default endowments should not be requested.', allEndowments);
         }
+        console.log('method _getEndowments result ->', { dedupedEndowments });
         return dedupedEndowments;
     }
     /**
@@ -1073,8 +1099,10 @@ class SnapController extends controllers_1.BaseControllerV2 {
             const snapPrefix = (0, snap_utils_1.getSnapPrefix)(snapId);
             switch (snapPrefix) {
                 case snap_utils_1.SnapIdPrefixes.local:
+                    console.log('Install local snap');
                     return this._fetchLocalSnap(snapId.replace(snap_utils_1.SnapIdPrefixes.local, ''));
                 case snap_utils_1.SnapIdPrefixes.npm:
+                    console.log('Install npm snap');
                     return this._fetchNpmSnap(snapId.replace(snap_utils_1.SnapIdPrefixes.npm, ''), versionRange);
                 /* istanbul ignore next */
                 default:
@@ -1108,16 +1136,19 @@ class SnapController extends controllers_1.BaseControllerV2 {
         if (!snap_utils_1.LOCALHOST_HOSTNAMES.has(manifestUrl.hostname)) {
             throw new Error(`Invalid URL: Locally hosted Snaps must be hosted on localhost. Received URL: "${manifestUrl.toString()}"`);
         }
-        const manifest = await (await this._fetchFunction(manifestUrl.toString(), fetchOptions)).json();
+
+        const manifest = await (await this._fetchFunction('GET', manifestUrl.toString(), fetchOptions)).json();
+        console.log('method _fetchLocalSnap -',);
         (0, snap_utils_1.assertIsSnapManifest)(manifest);
         const { source: { location: { npm: { filePath, iconPath }, }, }, } = manifest;
+        console.log('method _fetchLocalSnap -', { sourceCodePath: new URL(filePath, localhostUrl).toString(), icon: new URL(iconPath, localhostUrl).toString() })
         const [sourceCode, svgIcon] = await Promise.all([
-            (await this._fetchFunction(new URL(filePath, localhostUrl).toString(), fetchOptions)).text(),
+            (await this._fetchFunction('GET', new URL(filePath, localhostUrl).toString(), fetchOptions)).text(),
             iconPath
-                ? (await this._fetchFunction(new URL(iconPath, localhostUrl).toString(), fetchOptions)).text()
+                ? (await this._fetchFunction('GET', new URL(iconPath, localhostUrl).toString(), fetchOptions)).text()
                 : undefined,
         ]);
-        (0, snap_utils_1.validateSnapShasum)(manifest, sourceCode);
+        // (0, snap_utils_1.validateSnapShasum)(manifest, sourceCode);
         return { manifest, sourceCode, svgIcon };
     }
     /**
@@ -1232,9 +1263,10 @@ class SnapController extends controllers_1.BaseControllerV2 {
             if (this.state.snaps[snapId].enabled === false) {
                 throw new Error(`Snap "${snapId}" is disabled.`);
             }
-            if (this.state.snaps[snapId].status === snap_utils_1.SnapStatus.Installing) {
-                throw new Error(`Snap "${snapId}" is currently being installed. Please try again later.`);
-            }
+            // if (this.state.snaps[snapId].status === snap_utils_1.SnapStatus.Installing) {
+            //     throw new Error(`Snap "${snapId}" is currently being installed. Please try again later.`);
+            // }
+            console.log('isRunning', this.isRunning(snapId));
             if (this.isRunning(snapId) === false) {
                 let localStartPromise = startPromises.get(snapId);
                 if (!localStartPromise) {
@@ -1271,8 +1303,11 @@ class SnapController extends controllers_1.BaseControllerV2 {
             const handleRpcRequestPromise = this.messagingSystem.call('ExecutionService:handleRpcRequest', snapId, { origin, handler: handlerType, request: _request });
             // This will either get the result or reject due to the timeout.
             try {
+                console.log(1);
                 const result = await this._executeWithTimeout(snapId, handleRpcRequestPromise, timer);
+                console.log(2);
                 this._recordSnapRpcRequestFinish(snapId, request.id);
+                console.log(3);
                 return result;
             }
             catch (err) {
@@ -1294,9 +1329,9 @@ class SnapController extends controllers_1.BaseControllerV2 {
      * @template PromiseValue - The value of the Promise.
      */
     async _executeWithTimeout(snapId, promise, timer) {
-        const isLongRunning = await this.messagingSystem.call('PermissionController:hasPermission', snapId, endowments_1.SnapEndowments.LongRunning);
+        // const isLongRunning = await this.messagingSystem.call('PermissionController:hasPermission', snapId, endowments_1.SnapEndowments.LongRunning);
         // Long running snaps have timeouts disabled
-        if (isLongRunning) {
+        if (true) {
             return promise;
         }
         const result = await (0, utils_2.withTimeout)(promise, timer !== null && timer !== void 0 ? timer : this._maxRequestTime);
diff --git a/node_modules/@metamask/snap-controllers/dist/snaps/utils/npm.js b/node_modules/@metamask/snap-controllers/dist/snaps/utils/npm.js
index 6a49c06..70f5c8a 100644
--- a/node_modules/@metamask/snap-controllers/dist/snaps/utils/npm.js
+++ b/node_modules/@metamask/snap-controllers/dist/snaps/utils/npm.js
@@ -53,7 +53,7 @@ exports.fetchNpmSnap = fetchNpmSnap;
  */
 async function fetchNpmTarball(packageName, versionRange, registryUrl = exports.DEFAULT_NPM_REGISTRY, fetchFunction = fetch) {
     var _a, _b, _c, _d;
-    const packageMetadata = await (await fetchFunction(new URL(packageName, registryUrl).toString())).json();
+    const packageMetadata = await (await fetchFunction('GET', new URL(packageName, registryUrl).toString())).json();
     if (!(0, utils_1.isObject)(packageMetadata)) {
         throw new Error(`Failed to fetch package "${packageName}" metadata from npm.`);
     }
@@ -71,11 +71,12 @@ async function fetchNpmTarball(packageName, versionRange, registryUrl = exports.
     newTarballUrl.hostname = newRegistryUrl.hostname;
     newTarballUrl.protocol = newRegistryUrl.protocol;
     // Perform a raw fetch because we want the Response object itself.
-    const tarballResponse = await fetchFunction(newTarballUrl.toString());
-    if (!tarballResponse.ok) {
-        throw new Error(`Failed to fetch tarball for package "${packageName}".`);
-    }
-    const stream = await tarballResponse.blob().then((blob) => blob.stream());
+    const tarballResponse = await fetchFunction('GET', newTarballUrl.toString());
+    // if (!tarballResponse.ok) {
+    //     throw new Error(`Failed to fetch tarball for package "${packageName}".`);
+    // }
+    // const stream = await tarballResponse.blob().then((blob) => blob.stream());
+    console.log(await tarballResponse.blob());
     return [stream, targetVersion];
 }
 //# sourceMappingURL=npm.js.map
\ No newline at end of file
