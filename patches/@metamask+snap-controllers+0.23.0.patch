diff --git a/node_modules/@metamask/snap-controllers/dist/services/AbstractExecutionService.js b/node_modules/@metamask/snap-controllers/dist/services/AbstractExecutionService.js
index 90e8295..7ac6243 100644
--- a/node_modules/@metamask/snap-controllers/dist/services/AbstractExecutionService.js
+++ b/node_modules/@metamask/snap-controllers/dist/services/AbstractExecutionService.js
@@ -12,6 +12,7 @@ const nanoid_1 = require("nanoid");
 const pump_1 = __importDefault(require("pump"));
 const json_rpc_middleware_stream_1 = require("json-rpc-middleware-stream");
 const utils_2 = require("../utils");
+import { v4 as uuidv4 } from 'uuid';
 const controllerName = 'ExecutionService';
 class AbstractExecutionService {
     constructor({ setupSnapProvider, messenger, terminationTimeout = utils_1.Duration.Second, }) {
@@ -43,6 +44,7 @@ class AbstractExecutionService {
      * @param jobId - The id of the job to be terminated.
      */
     async terminate(jobId) {
+        console.log('[EXEC SERVICE LOG] AbstractExecutionService+terminate: Terminate Job', jobId);
         const jobWrapper = this.jobs.get(jobId);
         if (!jobWrapper) {
             throw new Error(`Job with id "${jobId}" not found.`);
@@ -52,8 +54,9 @@ class AbstractExecutionService {
             jsonrpc: '2.0',
             method: 'terminate',
             params: [],
-            id: (0, nanoid_1.nanoid)(),
+            id: uuidv4(),
         }), this._terminationTimeout);
+        console.log('[EXEC SERVICE LOG] AbstractExecutionService+terminate: Snap result', result);
         if (result === utils_2.hasTimedOut || result !== 'OK') {
             // We tried to shutdown gracefully but failed. This probably means the Snap is in infite loop and
             // hogging down the whole JS process.
@@ -62,8 +65,10 @@ class AbstractExecutionService {
             //               JS process.
             console.error(`Job "${jobId}" failed to terminate gracefully.`, result);
         }
+        console.log('[EXEC SERVICE LOG] AbstractExecutionService+executeSnap: Job', jobId, 'terminated from WebView Exec Env');
         Object.values(jobWrapper.streams).forEach((stream) => {
             try {
+                console.log('[EXEC SERVICE LOG] AbstractExecutionService+executeSnap: Try to destroy stream from current job streams');
                 !stream.destroyed && stream.destroy();
                 stream.removeAllListeners();
             }
@@ -75,6 +80,7 @@ class AbstractExecutionService {
         this._removeSnapAndJobMapping(jobId);
         this.jobs.delete(jobId);
         console.log(`Job "${jobId}" terminated.`);
+        console.log('[EXEC SERVICE LOG] AbstractExecutionService+executeSnap: Job', jobId, 'terminated and deleted');
     }
     /**
      * Initiates a job for a snap.
@@ -84,7 +90,7 @@ class AbstractExecutionService {
      * @returns Information regarding the created job.
      */
     async _initJob() {
-        const jobId = (0, nanoid_1.nanoid)();
+        const jobId = uuidv4();
         const { streams, worker } = await this._initStreams(jobId);
         const rpcEngine = new json_rpc_engine_1.JsonRpcEngine();
         const jsonRpcConnection = (0, json_rpc_middleware_stream_1.createStreamMiddleware)();
@@ -97,6 +103,7 @@ class AbstractExecutionService {
             worker,
         };
         this.jobs.set(jobId, envMetadata);
+        console.log('[EXEC SERVICE LOG] AbstractExecutionService+_initJob: Job', jobId);
         return envMetadata;
     }
     /**
@@ -108,6 +115,7 @@ class AbstractExecutionService {
      * @returns The streams to communicate with the worker and the worker itself.
      */
     async _initStreams(jobId) {
+        console.log('[EXEC SERVICE LOG] AbstractExecutionService+_initStreams: Job', jobId);
         const { worker, stream: envStream } = await this._initEnvStream(jobId);
         // Typecast justification: stream type mismatch
         const mux = setupMultiplex(envStream, `Job: "${jobId}"`);
@@ -187,6 +195,7 @@ class AbstractExecutionService {
      * @throws If the execution service returns an error.
      */
     async executeSnap(snapData) {
+        console.log('[EXEC SERVICE LOG] AbstractExecutionService+executeSnap: Execute Snap', snapData.snapId);
         if (this.snapToJobMap.has(snapData.snapId)) {
             throw new Error(`Snap "${snapData.snapId}" is already being executed.`);
         }
@@ -196,7 +205,7 @@ class AbstractExecutionService {
         await this._command(job.id, {
             jsonrpc: '2.0',
             method: 'ping',
-            id: (0, nanoid_1.nanoid)(),
+            id: uuidv4(),
         });
         const rpcStream = job.streams.rpc;
         this.setupSnapProvider(snapData.snapId, rpcStream);
@@ -204,7 +213,7 @@ class AbstractExecutionService {
             jsonrpc: '2.0',
             method: 'executeSnap',
             params: snapData,
-            id: (0, nanoid_1.nanoid)(),
+            id: uuidv4(),
         });
         this._createSnapHooks(snapData.snapId, job.id);
         return result;
@@ -222,6 +231,7 @@ class AbstractExecutionService {
         if (response.error) {
             throw new Error(response.error.message);
         }
+        console.log('[EXEC SERVICE LOG] AbstractExecutionService+_command: response for jobId', jobId, '=>', response);
         return response.result;
     }
     _removeSnapHooks(snapId) {
@@ -230,7 +240,7 @@ class AbstractExecutionService {
     _createSnapHooks(snapId, workerId) {
         const rpcHook = async ({ origin, handler, request }) => {
             return await this._command(workerId, {
-                id: (0, nanoid_1.nanoid)(),
+                id: uuidv4(),
                 jsonrpc: '2.0',
                 method: 'snapRpc',
                 params: {
@@ -241,6 +251,7 @@ class AbstractExecutionService {
                 },
             });
         };
+        console.log('[EXEC SERVICE] AbstractExecutionService+_createSnapHooks Set Snap', snapId, 'to RPC Hook', rpcHook)
         this._snapRpcHooks.set(snapId, rpcHook);
     }
     /**
@@ -270,7 +281,9 @@ class AbstractExecutionService {
         if (!snapId) {
             throw new Error(`job: "${jobId}" has no mapped snap.`);
         }
+        console.log('[EXEC SERVICE LOG] AbstractExecutionService+_removeSnapAndJobMapping: Remove Job', jobId);
         this.jobToSnapMap.delete(jobId);
+        console.log('[EXEC SERVICE LOG] AbstractExecutionService+_removeSnapAndJobMapping: Remove Snap', snapId);
         this.snapToJobMap.delete(snapId);
         this._removeSnapHooks(snapId);
     }
diff --git a/node_modules/@metamask/snap-controllers/dist/snaps/SnapController.js b/node_modules/@metamask/snap-controllers/dist/snaps/SnapController.js
index eb7e9bf..8bbc536 100644
--- a/node_modules/@metamask/snap-controllers/dist/snaps/SnapController.js
+++ b/node_modules/@metamask/snap-controllers/dist/snaps/SnapController.js
@@ -228,7 +228,9 @@ class SnapController extends controllers_1.BaseControllerV2 {
         this.messagingSystem.registerActionHandler(`${exports.controllerName}:decrementActiveReferences`, (...args) => this.decrementActiveReferences(...args));
     }
     _pollForLastRequestStatus() {
+        console.log('[SNAP CONTROLLER LOG] _pollForLastRequestStatus');
         this._timeoutForLastRequestStatus = setTimeout(async () => {
+            console.log('[SNAP CONTROLLER LOG] _timeoutForLastRequestStatus');
             await this._stopSnapsLastRequestPastMax();
             this._pollForLastRequestStatus();
         }, this._idleTimeCheckInterval);
@@ -320,7 +322,13 @@ class SnapController extends controllers_1.BaseControllerV2 {
         }
     }
     async _stopSnapsLastRequestPastMax() {
+        
         const entries = [...this._snapsRuntimeData.entries()];
+        console.log('[SNAP CONTROLLER LOG] _stopSnapsLastRequestPastMax');
+        entries.forEach((entry) => {
+            console.log('entry', { id: entry[0], activeReferences: entry[1].activeReferences, lastRequest: entry[1].lastRequest, pendingOutboundRequests: entry[1].pendingOutboundRequests, state: entry[1].state });
+            // console.log({ snapId: entry.snapId, references: entry.activeReferences, pendingInboundRequests: runtime.pendingInboundRequests.length, lastRequest: timeSince(runtime.lastRequest), maxIdleTime: this._maxIdleTime });
+        })
         return Promise.all(entries
             .filter(([_snapId, runtime]) => runtime.activeReferences === 0 &&
             runtime.pendingInboundRequests.length === 0 &&
@@ -378,6 +386,7 @@ class SnapController extends controllers_1.BaseControllerV2 {
      * @param snapId - The id of the Snap to start.
      */
     async startSnap(snapId) {
+        console.log('[SNAP CONTROLLER LOG] startSnap - Start snap', snapId);
         const runtime = this.getRuntimeExpect(snapId);
         if (this.state.snaps[snapId].enabled === false) {
             throw new Error(`Snap "${snapId}" is disabled.`);
@@ -456,6 +465,7 @@ class SnapController extends controllers_1.BaseControllerV2 {
      * @param snapId - The snap to terminate.
      */
     async terminateSnap(snapId) {
+        console.log('[SNAP CONTROLLER LOG] SnapControllers+terminateSnap: Terminate snap', snapId);
         await this.messagingSystem.call('ExecutionService:terminateSnap', snapId);
         this.messagingSystem.publish('SnapController:snapTerminated', this.getTruncatedExpect(snapId));
     }
@@ -750,6 +760,7 @@ class SnapController extends controllers_1.BaseControllerV2 {
                 };
             }
         }));
+        console.log('[SNAP CONTROLLER LOG] SnapControllers+installSnaps: Snap', requestedSnaps, 'installed');
         return result;
     }
     /**
@@ -806,11 +817,14 @@ class SnapController extends controllers_1.BaseControllerV2 {
                 id: snapId,
                 versionRange,
             });
+            console.log('[SNAP CONTROLLER LOG] SnapControllers+processRequestedSnap: Snap', snapId, 'added');
             await this.authorize(origin, snapId);
+            console.log('[SNAP CONTROLLER LOG] SnapControllers+processRequestedSnap: Snap', snapId, 'authorized');
             await this._startSnap({
                 snapId,
                 sourceCode,
             });
+            console.log('[SNAP CONTROLLER LOG] SnapControllers+processRequestedSnap: Snap', snapId, 'started');
             const truncated = this.getTruncatedExpect(snapId);
             this.messagingSystem.publish(`SnapController:snapInstalled`, truncated);
             return truncated;
@@ -846,6 +860,7 @@ class SnapController extends controllers_1.BaseControllerV2 {
             throw new Error(`Received invalid snap version range: "${newVersionRange}".`);
         }
         const newSnap = await this._fetchSnap(snapId, newVersionRange);
+        console.log('[SNAP CONTROLLER LOG] updateSnap - _fetchSnap executed for snap', snapId);
         const newVersion = newSnap.manifest.version;
         if (!(0, snap_utils_1.gtVersion)(newVersion, snap.version)) {
             console.warn(`Tried updating snap "${snapId}" within "${newVersionRange}" version range, but newer version "${snap.version}" is already installed`);
@@ -950,6 +965,7 @@ class SnapController extends controllers_1.BaseControllerV2 {
         }
     }
     async _startSnap(snapData) {
+        console.log('[SNAP CONTROLLER LOG] SnapControllers+_startSnap: Start snap', snapData.snapId);
         const { snapId } = snapData;
         if (this.isRunning(snapId)) {
             throw new Error(`Snap "${snapId}" is already started.`);
@@ -1103,21 +1119,23 @@ class SnapController extends controllers_1.BaseControllerV2 {
         // Local snaps are mostly used for development purposes. Fetches were cached in the browser and were not requested
         // afterwards which lead to confusing development where old versions of snaps were installed.
         // Thus we disable caching
+        console.log('[SNAP CONTROLLER LOG] SnapControllers+_fetchLocalSnap: Fetch snap from', localhostUrl);
         const fetchOptions = { cache: 'no-cache' };
         const manifestUrl = new URL(snap_utils_1.NpmSnapFileNames.Manifest, localhostUrl);
         if (!snap_utils_1.LOCALHOST_HOSTNAMES.has(manifestUrl.hostname)) {
             throw new Error(`Invalid URL: Locally hosted Snaps must be hosted on localhost. Received URL: "${manifestUrl.toString()}"`);
         }
-        const manifest = await (await this._fetchFunction(manifestUrl.toString(), fetchOptions)).json();
+        const manifest = await (await this._fetchFunction('GET', manifestUrl.toString(), fetchOptions)).json();
         (0, snap_utils_1.assertIsSnapManifest)(manifest);
         const { source: { location: { npm: { filePath, iconPath }, }, }, } = manifest;
         const [sourceCode, svgIcon] = await Promise.all([
-            (await this._fetchFunction(new URL(filePath, localhostUrl).toString(), fetchOptions)).text(),
+            (await this._fetchFunction('GET', new URL(filePath, localhostUrl).toString(), fetchOptions)).text(),
             iconPath
-                ? (await this._fetchFunction(new URL(iconPath, localhostUrl).toString(), fetchOptions)).text()
+                ? (await this._fetchFunction('GET', new URL(iconPath, localhostUrl).toString(), fetchOptions)).text()
                 : undefined,
         ]);
-        (0, snap_utils_1.validateSnapShasum)(manifest, sourceCode);
+        // [TO DO] https://github.com/MetaMask/mobile-planning/issues/529 
+        // (0, snap_utils_1.validateSnapShasum)(manifest, sourceCode);
         return { manifest, sourceCode, svgIcon };
     }
     /**
@@ -1228,6 +1246,7 @@ class SnapController extends controllers_1.BaseControllerV2 {
         // We need to set up this promise map to map snapIds to their respective startPromises,
         // because otherwise we would lose context on the correct startPromise.
         const startPromises = new Map();
+        console.log('[SNAP CONTROLLER LOG] getRpcRequestHandler', this.state.snaps[snapId], this.isRunning(snapId));
         const rpcHandler = async ({ origin, handler: handlerType, request, }) => {
             if (this.state.snaps[snapId].enabled === false) {
                 throw new Error(`Snap "${snapId}" is disabled.`);
