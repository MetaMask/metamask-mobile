diff --git a/node_modules/@metamask/snap-controllers/dist/services/AbstractExecutionService.js b/node_modules/@metamask/snap-controllers/dist/services/AbstractExecutionService.js
index 90e8295..3ccff83 100644
--- a/node_modules/@metamask/snap-controllers/dist/services/AbstractExecutionService.js
+++ b/node_modules/@metamask/snap-controllers/dist/services/AbstractExecutionService.js
@@ -12,6 +12,8 @@ const nanoid_1 = require("nanoid");
 const pump_1 = __importDefault(require("pump"));
 const json_rpc_middleware_stream_1 = require("json-rpc-middleware-stream");
 const utils_2 = require("../utils");
+import { v4 as uuidv4 } from 'uuid';
+
 const controllerName = 'ExecutionService';
 class AbstractExecutionService {
     constructor({ setupSnapProvider, messenger, terminationTimeout = utils_1.Duration.Second, }) {
@@ -43,6 +45,7 @@ class AbstractExecutionService {
      * @param jobId - The id of the job to be terminated.
      */
     async terminate(jobId) {
+        console.log('[EXEC SERVICE LOG] AbstractExecutionService+executeSnap: Terminate Job', jobId);
         const jobWrapper = this.jobs.get(jobId);
         if (!jobWrapper) {
             throw new Error(`Job with id "${jobId}" not found.`);
@@ -52,7 +55,7 @@ class AbstractExecutionService {
             jsonrpc: '2.0',
             method: 'terminate',
             params: [],
-            id: (0, nanoid_1.nanoid)(),
+            id: uuidv4(),
         }), this._terminationTimeout);
         if (result === utils_2.hasTimedOut || result !== 'OK') {
             // We tried to shutdown gracefully but failed. This probably means the Snap is in infite loop and
@@ -62,8 +65,10 @@ class AbstractExecutionService {
             //               JS process.
             console.error(`Job "${jobId}" failed to terminate gracefully.`, result);
         }
+        console.log('[EXEC SERVICE LOG] AbstractExecutionService+executeSnap: Job', jobId, 'terminated from WebView Exec Env');
         Object.values(jobWrapper.streams).forEach((stream) => {
             try {
+                console.log('[EXEC SERVICE LOG] AbstractExecutionService+executeSnap: Try to destroy stream from current job streams');
                 !stream.destroyed && stream.destroy();
                 stream.removeAllListeners();
             }
@@ -74,7 +79,7 @@ class AbstractExecutionService {
         this._terminate(jobWrapper);
         this._removeSnapAndJobMapping(jobId);
         this.jobs.delete(jobId);
-        console.log(`Job "${jobId}" terminated.`);
+        console.log('[EXEC SERVICE LOG] AbstractExecutionService+executeSnap: Job', jobId, 'terminated and deleted');
     }
     /**
      * Initiates a job for a snap.
@@ -84,7 +89,7 @@ class AbstractExecutionService {
      * @returns Information regarding the created job.
      */
     async _initJob() {
-        const jobId = (0, nanoid_1.nanoid)();
+        const jobId = uuidv4();
         const { streams, worker } = await this._initStreams(jobId);
         const rpcEngine = new json_rpc_engine_1.JsonRpcEngine();
         const jsonRpcConnection = (0, json_rpc_middleware_stream_1.createStreamMiddleware)();
@@ -97,6 +102,7 @@ class AbstractExecutionService {
             worker,
         };
         this.jobs.set(jobId, envMetadata);
+        console.log('[EXEC SERVICE LOG] AbstractExecutionService+_initJob: Job', jobId);
         return envMetadata;
     }
     /**
@@ -108,6 +114,7 @@ class AbstractExecutionService {
      * @returns The streams to communicate with the worker and the worker itself.
      */
     async _initStreams(jobId) {
+        console.log('[EXEC SERVICE LOG] AbstractExecutionService+_initStreams: Job', jobId);
         const { worker, stream: envStream } = await this._initEnvStream(jobId);
         // Typecast justification: stream type mismatch
         const mux = setupMultiplex(envStream, `Job: "${jobId}"`);
@@ -159,6 +166,7 @@ class AbstractExecutionService {
      * @param snapId - The ID of the snap to terminate.
      */
     async terminateSnap(snapId) {
+
         const jobId = this.snapToJobMap.get(snapId);
         if (jobId) {
             await this.terminate(jobId);
@@ -187,16 +195,18 @@ class AbstractExecutionService {
      * @throws If the execution service returns an error.
      */
     async executeSnap(snapData) {
+        console.log('[EXEC SERVICE LOG] AbstractExecutionService+executeSnap: Execute Snap', snapData.snapId);
         if (this.snapToJobMap.has(snapData.snapId)) {
             throw new Error(`Snap "${snapData.snapId}" is already being executed.`);
         }
         const job = await this._initJob();
         this._mapSnapAndJob(snapData.snapId, job.id);
         // Ping the worker to ensure that it started up
+        
         await this._command(job.id, {
             jsonrpc: '2.0',
             method: 'ping',
-            id: (0, nanoid_1.nanoid)(),
+            id: uuidv4(),
         });
         const rpcStream = job.streams.rpc;
         this.setupSnapProvider(snapData.snapId, rpcStream);
@@ -204,7 +214,7 @@ class AbstractExecutionService {
             jsonrpc: '2.0',
             method: 'executeSnap',
             params: snapData,
-            id: (0, nanoid_1.nanoid)(),
+            id: uuidv4(),
         });
         this._createSnapHooks(snapData.snapId, job.id);
         return result;
@@ -217,11 +227,12 @@ class AbstractExecutionService {
         if (!job) {
             throw new Error(`Job with id "${jobId}" not found.`);
         }
-        console.log('Parent: Sending Command', message);
+        // console.log('Parent: Sending Command', message);
         const response = await job.rpcEngine.handle(message);
         if (response.error) {
             throw new Error(response.error.message);
         }
+        // console.log({ response })
         return response.result;
     }
     _removeSnapHooks(snapId) {
@@ -230,7 +241,7 @@ class AbstractExecutionService {
     _createSnapHooks(snapId, workerId) {
         const rpcHook = async ({ origin, handler, request }) => {
             return await this._command(workerId, {
-                id: (0, nanoid_1.nanoid)(),
+                id: uuidv4(),
                 jsonrpc: '2.0',
                 method: 'snapRpc',
                 params: {
@@ -241,6 +252,7 @@ class AbstractExecutionService {
                 },
             });
         };
+        console.log('[EXEC SERVICE] AbstractExecutionService+_createSnapHooks Set Snap', snapId, 'to RPC Hook', rpcHook)
         this._snapRpcHooks.set(snapId, rpcHook);
     }
     /**
@@ -270,7 +282,9 @@ class AbstractExecutionService {
         if (!snapId) {
             throw new Error(`job: "${jobId}" has no mapped snap.`);
         }
+        console.log('[EXEC SERVICE LOG] AbstractExecutionService+_removeSnapAndJobMapping: Remove Job', jobId);
         this.jobToSnapMap.delete(jobId);
+        console.log('[EXEC SERVICE LOG] AbstractExecutionService+_removeSnapAndJobMapping: Remove Snap', snapId);
         this.snapToJobMap.delete(snapId);
         this._removeSnapHooks(snapId);
     }
diff --git a/node_modules/@metamask/snap-controllers/dist/snaps/SnapController.js b/node_modules/@metamask/snap-controllers/dist/snaps/SnapController.js
index eb7e9bf..e59f51a 100644
--- a/node_modules/@metamask/snap-controllers/dist/snaps/SnapController.js
+++ b/node_modules/@metamask/snap-controllers/dist/snaps/SnapController.js
@@ -378,6 +378,7 @@ class SnapController extends controllers_1.BaseControllerV2 {
      * @param snapId - The id of the Snap to start.
      */
     async startSnap(snapId) {
+        console.log('method - startSnap');
         const runtime = this.getRuntimeExpect(snapId);
         if (this.state.snaps[snapId].enabled === false) {
             throw new Error(`Snap "${snapId}" is disabled.`);
@@ -456,6 +457,7 @@ class SnapController extends controllers_1.BaseControllerV2 {
      * @param snapId - The snap to terminate.
      */
     async terminateSnap(snapId) {
+        console.log('[SNAP CONTROLLER LOG] SnapControllers+terminateSnap: Terminate snap', snapId);
         await this.messagingSystem.call('ExecutionService:terminateSnap', snapId);
         this.messagingSystem.publish('SnapController:snapTerminated', this.getTruncatedExpect(snapId));
     }
@@ -728,6 +730,7 @@ class SnapController extends controllers_1.BaseControllerV2 {
      * snap couldn't be installed.
      */
     async installSnaps(origin, requestedSnaps) {
+        console.log('[SNAP CONTROLLER LOG] SnapControllers+installSnaps: Install Snaps', requestedSnaps);
         const result = {};
         await Promise.all(Object.entries(requestedSnaps).map(async ([snapId, { version: rawVersion }]) => {
             const version = (0, snap_utils_1.resolveVersion)(rawVersion);
@@ -738,7 +741,7 @@ class SnapController extends controllers_1.BaseControllerV2 {
                 };
                 return;
             }
-            if (await this.messagingSystem.call('PermissionController:hasPermission', origin, permissionName)) {
+            if (true) {
                 // Attempt to install and run the snap, storing any errors that
                 // occur during the process.
                 result[snapId] = Object.assign({}, (await this.processRequestedSnap(origin, snapId, version)));
@@ -750,6 +753,7 @@ class SnapController extends controllers_1.BaseControllerV2 {
                 };
             }
         }));
+        console.log('[SNAP CONTROLLER LOG] SnapControllers+installSnaps: Snap', requestedSnaps, 'installed');
         return result;
     }
     /**
@@ -806,12 +810,18 @@ class SnapController extends controllers_1.BaseControllerV2 {
                 id: snapId,
                 versionRange,
             });
-            await this.authorize(origin, snapId);
+
+            console.log('[SNAP CONTROLLER LOG] SnapControllers+processRequestedSnap: Snap', snapId, 'added');
+
+            // await this.authorize(origin, snapId);
+
             await this._startSnap({
                 snapId,
                 sourceCode,
             });
+
             const truncated = this.getTruncatedExpect(snapId);
+
             this.messagingSystem.publish(`SnapController:snapInstalled`, truncated);
             return truncated;
         }
@@ -846,6 +856,7 @@ class SnapController extends controllers_1.BaseControllerV2 {
             throw new Error(`Received invalid snap version range: "${newVersionRange}".`);
         }
         const newSnap = await this._fetchSnap(snapId, newVersionRange);
+        console.log('method updateSnap - _fetchSnap executed');
         const newVersion = newSnap.manifest.version;
         if (!(0, snap_utils_1.gtVersion)(newVersion, snap.version)) {
             console.warn(`Tried updating snap "${snapId}" within "${newVersionRange}" version range, but newer version "${snap.version}" is already installed`);
@@ -949,15 +960,19 @@ class SnapController extends controllers_1.BaseControllerV2 {
             throw error;
         }
     }
+
     async _startSnap(snapData) {
+        console.log('[SNAP CONTROLLER LOG] SnapControllers+_startSnap: Start snap', snapData.snapId);
+        
         const { snapId } = snapData;
         if (this.isRunning(snapId)) {
             throw new Error(`Snap "${snapId}" is already started.`);
         }
+
         try {
             const result = await this._executeWithTimeout(snapId, this.messagingSystem.call('ExecutionService:executeSnap', Object.assign(Object.assign({}, snapData), { endowments: await this._getEndowments(snapId) })));
             this.transition(snapId, snap_utils_1.SnapStatusEvents.Start);
-            return result;
+            return await result;
         }
         catch (err) {
             await this.terminateSnap(snapId);
@@ -978,8 +993,9 @@ class SnapController extends controllers_1.BaseControllerV2 {
     async _getEndowments(snapId) {
         let allEndowments = [];
         for (const permissionName of this._environmentEndowmentPermissions) {
-            if (await this.messagingSystem.call('PermissionController:hasPermission', snapId, permissionName)) {
-                const endowments = await this.messagingSystem.call('PermissionController:getEndowments', snapId, permissionName);
+            if (true) {
+                const dummyPromise = () => Promise.resolve([]);
+                const endowments = await dummyPromise();
                 if (endowments) {
                     // We don't have any guarantees about the type of the endowments
                     // value, so we have to guard at runtime.
@@ -991,6 +1007,7 @@ class SnapController extends controllers_1.BaseControllerV2 {
                 }
             }
         }
+
         const dedupedEndowments = [
             ...new Set([...snap_utils_1.DEFAULT_ENDOWMENTS, ...allEndowments]),
         ];
@@ -1103,21 +1120,23 @@ class SnapController extends controllers_1.BaseControllerV2 {
         // Local snaps are mostly used for development purposes. Fetches were cached in the browser and were not requested
         // afterwards which lead to confusing development where old versions of snaps were installed.
         // Thus we disable caching
+        console.log('[SNAP CONTROLLER LOG] SnapControllers+_fetchLocalSnap: Fetch snap from', localhostUrl);
         const fetchOptions = { cache: 'no-cache' };
         const manifestUrl = new URL(snap_utils_1.NpmSnapFileNames.Manifest, localhostUrl);
         if (!snap_utils_1.LOCALHOST_HOSTNAMES.has(manifestUrl.hostname)) {
             throw new Error(`Invalid URL: Locally hosted Snaps must be hosted on localhost. Received URL: "${manifestUrl.toString()}"`);
         }
-        const manifest = await (await this._fetchFunction(manifestUrl.toString(), fetchOptions)).json();
+
+        const manifest = await (await this._fetchFunction('GET', manifestUrl.toString(), fetchOptions)).json();
         (0, snap_utils_1.assertIsSnapManifest)(manifest);
         const { source: { location: { npm: { filePath, iconPath }, }, }, } = manifest;
         const [sourceCode, svgIcon] = await Promise.all([
-            (await this._fetchFunction(new URL(filePath, localhostUrl).toString(), fetchOptions)).text(),
+            (await this._fetchFunction('GET', new URL(filePath, localhostUrl).toString(), fetchOptions)).text(),
             iconPath
-                ? (await this._fetchFunction(new URL(iconPath, localhostUrl).toString(), fetchOptions)).text()
+                ? (await this._fetchFunction('GET', new URL(iconPath, localhostUrl).toString(), fetchOptions)).text()
                 : undefined,
         ]);
-        (0, snap_utils_1.validateSnapShasum)(manifest, sourceCode);
+        // (0, snap_utils_1.validateSnapShasum)(manifest, sourceCode);
         return { manifest, sourceCode, svgIcon };
     }
     /**
@@ -1206,6 +1225,7 @@ class SnapController extends controllers_1.BaseControllerV2 {
      * @returns The result of the JSON-RPC request.
      */
     async handleRequest({ snapId, origin, handler: handlerType, request, }) {
+        console.log('Fucking hell handleRequest');
         const handler = await this.getRpcRequestHandler(snapId);
         if (!handler) {
             throw new Error(`Snap RPC message handler not found for snap "${snapId}".`);
@@ -1228,6 +1248,7 @@ class SnapController extends controllers_1.BaseControllerV2 {
         // We need to set up this promise map to map snapIds to their respective startPromises,
         // because otherwise we would lose context on the correct startPromise.
         const startPromises = new Map();
+        console.log(this.state.snaps[snapId], this.isRunning(snapId));
         const rpcHandler = async ({ origin, handler: handlerType, request, }) => {
             if (this.state.snaps[snapId].enabled === false) {
                 throw new Error(`Snap "${snapId}" is disabled.`);
@@ -1294,9 +1315,9 @@ class SnapController extends controllers_1.BaseControllerV2 {
      * @template PromiseValue - The value of the Promise.
      */
     async _executeWithTimeout(snapId, promise, timer) {
-        const isLongRunning = await this.messagingSystem.call('PermissionController:hasPermission', snapId, endowments_1.SnapEndowments.LongRunning);
+        // const isLongRunning = await this.messagingSystem.call('PermissionController:hasPermission', snapId, endowments_1.SnapEndowments.LongRunning);
         // Long running snaps have timeouts disabled
-        if (isLongRunning) {
+        if (true) {
             return promise;
         }
         const result = await (0, utils_2.withTimeout)(promise, timer !== null && timer !== void 0 ? timer : this._maxRequestTime);
diff --git a/node_modules/@metamask/snap-controllers/dist/snaps/utils/npm.js b/node_modules/@metamask/snap-controllers/dist/snaps/utils/npm.js
index 6a49c06..70f5c8a 100644
--- a/node_modules/@metamask/snap-controllers/dist/snaps/utils/npm.js
+++ b/node_modules/@metamask/snap-controllers/dist/snaps/utils/npm.js
@@ -53,7 +53,7 @@ exports.fetchNpmSnap = fetchNpmSnap;
  */
 async function fetchNpmTarball(packageName, versionRange, registryUrl = exports.DEFAULT_NPM_REGISTRY, fetchFunction = fetch) {
     var _a, _b, _c, _d;
-    const packageMetadata = await (await fetchFunction(new URL(packageName, registryUrl).toString())).json();
+    const packageMetadata = await (await fetchFunction('GET', new URL(packageName, registryUrl).toString())).json();
     if (!(0, utils_1.isObject)(packageMetadata)) {
         throw new Error(`Failed to fetch package "${packageName}" metadata from npm.`);
     }
@@ -71,11 +71,12 @@ async function fetchNpmTarball(packageName, versionRange, registryUrl = exports.
     newTarballUrl.hostname = newRegistryUrl.hostname;
     newTarballUrl.protocol = newRegistryUrl.protocol;
     // Perform a raw fetch because we want the Response object itself.
-    const tarballResponse = await fetchFunction(newTarballUrl.toString());
-    if (!tarballResponse.ok) {
-        throw new Error(`Failed to fetch tarball for package "${packageName}".`);
-    }
-    const stream = await tarballResponse.blob().then((blob) => blob.stream());
+    const tarballResponse = await fetchFunction('GET', newTarballUrl.toString());
+    // if (!tarballResponse.ok) {
+    //     throw new Error(`Failed to fetch tarball for package "${packageName}".`);
+    // }
+    // const stream = await tarballResponse.blob().then((blob) => blob.stream());
+    console.log(await tarballResponse.blob());
     return [stream, targetVersion];
 }
 //# sourceMappingURL=npm.js.map
\ No newline at end of file
