diff --git a/node_modules/@metamask/snap-controllers/dist/services/AbstractExecutionService.js b/node_modules/@metamask/snap-controllers/dist/services/AbstractExecutionService.js
index 90e8295..613f999 100644
--- a/node_modules/@metamask/snap-controllers/dist/services/AbstractExecutionService.js
+++ b/node_modules/@metamask/snap-controllers/dist/services/AbstractExecutionService.js
@@ -12,6 +12,8 @@ const nanoid_1 = require("nanoid");
 const pump_1 = __importDefault(require("pump"));
 const json_rpc_middleware_stream_1 = require("json-rpc-middleware-stream");
 const utils_2 = require("../utils");
+import { v4 as uuidv4 } from 'uuid';
+
 const controllerName = 'ExecutionService';
 class AbstractExecutionService {
     constructor({ setupSnapProvider, messenger, terminationTimeout = utils_1.Duration.Second, }) {
@@ -43,6 +45,7 @@ class AbstractExecutionService {
      * @param jobId - The id of the job to be terminated.
      */
     async terminate(jobId) {
+        console.log('[EXEC SERVICE LOG] AbstractExecutionService+terminate: Terminate Job', jobId);
         const jobWrapper = this.jobs.get(jobId);
         if (!jobWrapper) {
             throw new Error(`Job with id "${jobId}" not found.`);
@@ -52,8 +55,10 @@ class AbstractExecutionService {
             jsonrpc: '2.0',
             method: 'terminate',
             params: [],
-            id: (0, nanoid_1.nanoid)(),
+            id: uuidv4(),
         }), this._terminationTimeout);
+
+        console.log('[EXEC SERVICE LOG] AbstractExecutionService+terminate: Snap result', result);
         if (result === utils_2.hasTimedOut || result !== 'OK') {
             // We tried to shutdown gracefully but failed. This probably means the Snap is in infite loop and
             // hogging down the whole JS process.
@@ -62,8 +67,10 @@ class AbstractExecutionService {
             //               JS process.
             console.error(`Job "${jobId}" failed to terminate gracefully.`, result);
         }
+        console.log('[EXEC SERVICE LOG] AbstractExecutionService+executeSnap: Job', jobId, 'terminated from WebView Exec Env');
         Object.values(jobWrapper.streams).forEach((stream) => {
             try {
+                console.log('[EXEC SERVICE LOG] AbstractExecutionService+executeSnap: Try to destroy stream from current job streams');
                 !stream.destroyed && stream.destroy();
                 stream.removeAllListeners();
             }
@@ -74,7 +81,7 @@ class AbstractExecutionService {
         this._terminate(jobWrapper);
         this._removeSnapAndJobMapping(jobId);
         this.jobs.delete(jobId);
-        console.log(`Job "${jobId}" terminated.`);
+        console.log('[EXEC SERVICE LOG] AbstractExecutionService+executeSnap: Job', jobId, 'terminated and deleted');
     }
     /**
      * Initiates a job for a snap.
@@ -84,7 +91,7 @@ class AbstractExecutionService {
      * @returns Information regarding the created job.
      */
     async _initJob() {
-        const jobId = (0, nanoid_1.nanoid)();
+        const jobId = uuidv4();
         const { streams, worker } = await this._initStreams(jobId);
         const rpcEngine = new json_rpc_engine_1.JsonRpcEngine();
         const jsonRpcConnection = (0, json_rpc_middleware_stream_1.createStreamMiddleware)();
@@ -97,6 +104,7 @@ class AbstractExecutionService {
             worker,
         };
         this.jobs.set(jobId, envMetadata);
+        console.log('[EXEC SERVICE LOG] AbstractExecutionService+_initJob: Job', jobId);
         return envMetadata;
     }
     /**
@@ -108,6 +116,7 @@ class AbstractExecutionService {
      * @returns The streams to communicate with the worker and the worker itself.
      */
     async _initStreams(jobId) {
+        console.log('[EXEC SERVICE LOG] AbstractExecutionService+_initStreams: Job', jobId);
         const { worker, stream: envStream } = await this._initEnvStream(jobId);
         // Typecast justification: stream type mismatch
         const mux = setupMultiplex(envStream, `Job: "${jobId}"`);
@@ -159,6 +168,7 @@ class AbstractExecutionService {
      * @param snapId - The ID of the snap to terminate.
      */
     async terminateSnap(snapId) {
+
         const jobId = this.snapToJobMap.get(snapId);
         if (jobId) {
             await this.terminate(jobId);
@@ -187,16 +197,18 @@ class AbstractExecutionService {
      * @throws If the execution service returns an error.
      */
     async executeSnap(snapData) {
+        console.log('[EXEC SERVICE LOG] AbstractExecutionService+executeSnap: Execute Snap', snapData.snapId);
         if (this.snapToJobMap.has(snapData.snapId)) {
             throw new Error(`Snap "${snapData.snapId}" is already being executed.`);
         }
         const job = await this._initJob();
         this._mapSnapAndJob(snapData.snapId, job.id);
         // Ping the worker to ensure that it started up
+        
         await this._command(job.id, {
             jsonrpc: '2.0',
             method: 'ping',
-            id: (0, nanoid_1.nanoid)(),
+            id: uuidv4(),
         });
         const rpcStream = job.streams.rpc;
         this.setupSnapProvider(snapData.snapId, rpcStream);
@@ -204,7 +216,7 @@ class AbstractExecutionService {
             jsonrpc: '2.0',
             method: 'executeSnap',
             params: snapData,
-            id: (0, nanoid_1.nanoid)(),
+            id: uuidv4(),
         });
         this._createSnapHooks(snapData.snapId, job.id);
         return result;
@@ -222,6 +234,7 @@ class AbstractExecutionService {
         if (response.error) {
             throw new Error(response.error.message);
         }
+        // console.log({ response })
         return response.result;
     }
     _removeSnapHooks(snapId) {
@@ -230,7 +243,7 @@ class AbstractExecutionService {
     _createSnapHooks(snapId, workerId) {
         const rpcHook = async ({ origin, handler, request }) => {
             return await this._command(workerId, {
-                id: (0, nanoid_1.nanoid)(),
+                id: uuidv4(),
                 jsonrpc: '2.0',
                 method: 'snapRpc',
                 params: {
@@ -241,6 +254,7 @@ class AbstractExecutionService {
                 },
             });
         };
+        console.log('[EXEC SERVICE] AbstractExecutionService+_createSnapHooks Set Snap', snapId, 'to RPC Hook', rpcHook)
         this._snapRpcHooks.set(snapId, rpcHook);
     }
     /**
@@ -270,7 +284,9 @@ class AbstractExecutionService {
         if (!snapId) {
             throw new Error(`job: "${jobId}" has no mapped snap.`);
         }
+        console.log('[EXEC SERVICE LOG] AbstractExecutionService+_removeSnapAndJobMapping: Remove Job', jobId);
         this.jobToSnapMap.delete(jobId);
+        console.log('[EXEC SERVICE LOG] AbstractExecutionService+_removeSnapAndJobMapping: Remove Snap', snapId);
         this.snapToJobMap.delete(snapId);
         this._removeSnapHooks(snapId);
     }
diff --git a/node_modules/@metamask/snap-controllers/dist/snaps/SnapController.js b/node_modules/@metamask/snap-controllers/dist/snaps/SnapController.js
index eb7e9bf..38141a3 100644
--- a/node_modules/@metamask/snap-controllers/dist/snaps/SnapController.js
+++ b/node_modules/@metamask/snap-controllers/dist/snaps/SnapController.js
@@ -320,7 +320,12 @@ class SnapController extends controllers_1.BaseControllerV2 {
         }
     }
     async _stopSnapsLastRequestPastMax() {
+        
         const entries = [...this._snapsRuntimeData.entries()];
+        entries.forEach((entry) => {
+            console.log('entry', { id: entry[0], activeReferences: entry[1].activeReferences, lastRequest: entry[1].lastRequest, pendingOutboundRequests: entry[1].pendingOutboundRequests, state: entry[1].state });
+            // console.log({ snapId: entry.snapId, references: entry.activeReferences, pendingInboundRequests: runtime.pendingInboundRequests.length, lastRequest: timeSince(runtime.lastRequest), maxIdleTime: this._maxIdleTime });
+        })
         return Promise.all(entries
             .filter(([_snapId, runtime]) => runtime.activeReferences === 0 &&
             runtime.pendingInboundRequests.length === 0 &&
@@ -378,6 +383,7 @@ class SnapController extends controllers_1.BaseControllerV2 {
      * @param snapId - The id of the Snap to start.
      */
     async startSnap(snapId) {
+        console.log('[SNAP CONTROLLER LOG] startSnap - Start snap', snapId);
         const runtime = this.getRuntimeExpect(snapId);
         if (this.state.snaps[snapId].enabled === false) {
             throw new Error(`Snap "${snapId}" is disabled.`);
@@ -456,6 +462,7 @@ class SnapController extends controllers_1.BaseControllerV2 {
      * @param snapId - The snap to terminate.
      */
     async terminateSnap(snapId) {
+        console.log('[SNAP CONTROLLER LOG] SnapControllers+terminateSnap: Terminate snap', snapId);
         await this.messagingSystem.call('ExecutionService:terminateSnap', snapId);
         this.messagingSystem.publish('SnapController:snapTerminated', this.getTruncatedExpect(snapId));
     }
@@ -750,6 +757,7 @@ class SnapController extends controllers_1.BaseControllerV2 {
                 };
             }
         }));
+        console.log('[SNAP CONTROLLER LOG] SnapControllers+installSnaps: Snap', requestedSnaps, 'installed');
         return result;
     }
     /**
@@ -806,11 +814,14 @@ class SnapController extends controllers_1.BaseControllerV2 {
                 id: snapId,
                 versionRange,
             });
-            await this.authorize(origin, snapId);
+
+            console.log('[SNAP CONTROLLER LOG] SnapControllers+processRequestedSnap: Snap', snapId, 'added');
+
+            // await this.authorize(origin, snapId);
+
             await this._startSnap({
                 snapId,
                 sourceCode,
             });
+
             const truncated = this.getTruncatedExpect(snapId);
+
             this.messagingSystem.publish(`SnapController:snapInstalled`, truncated);
             return truncated;
@@ -846,6 +857,7 @@ class SnapController extends controllers_1.BaseControllerV2 {
             throw new Error(`Received invalid snap version range: "${newVersionRange}".`);
         }
         const newSnap = await this._fetchSnap(snapId, newVersionRange);
+        console.log('[SNAP CONTROLLER LOG] updateSnap - _fetchSnap executed for snap', snapId);
         const newVersion = newSnap.manifest.version;
         if (!(0, snap_utils_1.gtVersion)(newVersion, snap.version)) {
             console.warn(`Tried updating snap "${snapId}" within "${newVersionRange}" version range, but newer version "${snap.version}" is already installed`);
@@ -950,6 +962,7 @@ class SnapController extends controllers_1.BaseControllerV2 {
         }
     }
+
     async _startSnap(snapData) {
+        console.log('[SNAP CONTROLLER LOG] SnapControllers+_startSnap: Start snap', snapData.snapId);
+        
         const { snapId } = snapData;
         if (this.isRunning(snapId)) {
             throw new Error(`Snap "${snapId}" is already started.`);
@@ -1103,21 +1116,23 @@ class SnapController extends controllers_1.BaseControllerV2 {
         // Local snaps are mostly used for development purposes. Fetches were cached in the browser and were not requested
         // afterwards which lead to confusing development where old versions of snaps were installed.
         // Thus we disable caching
+        console.log('[SNAP CONTROLLER LOG] SnapControllers+_fetchLocalSnap: Fetch snap from', localhostUrl);
         const fetchOptions = { cache: 'no-cache' };
         const manifestUrl = new URL(snap_utils_1.NpmSnapFileNames.Manifest, localhostUrl);
         if (!snap_utils_1.LOCALHOST_HOSTNAMES.has(manifestUrl.hostname)) {
             throw new Error(`Invalid URL: Locally hosted Snaps must be hosted on localhost. Received URL: "${manifestUrl.toString()}"`);
         }
-        const manifest = await (await this._fetchFunction(manifestUrl.toString(), fetchOptions)).json();
+
+        const manifest = await (await this._fetchFunction('GET', manifestUrl.toString(), fetchOptions)).json();
         (0, snap_utils_1.assertIsSnapManifest)(manifest);
         const { source: { location: { npm: { filePath, iconPath }, }, }, } = manifest;
         const [sourceCode, svgIcon] = await Promise.all([
-            (await this._fetchFunction(new URL(filePath, localhostUrl).toString(), fetchOptions)).text(),
+            (await this._fetchFunction('GET', new URL(filePath, localhostUrl).toString(), fetchOptions)).text(),
             iconPath
-                ? (await this._fetchFunction(new URL(iconPath, localhostUrl).toString(), fetchOptions)).text()
+                ? (await this._fetchFunction('GET', new URL(iconPath, localhostUrl).toString(), fetchOptions)).text()
                 : undefined,
         ]);
-        (0, snap_utils_1.validateSnapShasum)(manifest, sourceCode);
+        // (0, snap_utils_1.validateSnapShasum)(manifest, sourceCode);
         return { manifest, sourceCode, svgIcon };
     }
     /**
@@ -1228,6 +1243,7 @@ class SnapController extends controllers_1.BaseControllerV2 {
         // We need to set up this promise map to map snapIds to their respective startPromises,
         // because otherwise we would lose context on the correct startPromise.
         const startPromises = new Map();
+        console.log('[SNAP CONTROLLER LOG] getRpcRequestHandler', this.state.snaps[snapId], this.isRunning(snapId));
         const rpcHandler = async ({ origin, handler: handlerType, request, }) => {
             if (this.state.snaps[snapId].enabled === false) {
                 throw new Error(`Snap "${snapId}" is disabled.`);
@@ -1294,9 +1316,9 @@ class SnapController extends controllers_1.BaseControllerV2 {
      * @template PromiseValue - The value of the Promise.
      */
     async _executeWithTimeout(snapId, promise, timer) {
-        const isLongRunning = await this.messagingSystem.call('PermissionController:hasPermission', snapId, endowments_1.SnapEndowments.LongRunning);
+        // const isLongRunning = await this.messagingSystem.call('PermissionController:hasPermission', snapId, endowments_1.SnapEndowments.LongRunning);
         // Long running snaps have timeouts disabled
-        if (isLongRunning) {
+        if (true) {
             return promise;
         }
         const result = await (0, utils_2.withTimeout)(promise, timer !== null && timer !== void 0 ? timer : this._maxRequestTime);
diff --git a/node_modules/@metamask/snap-controllers/dist/snaps/utils/npm.js b/node_modules/@metamask/snap-controllers/dist/snaps/utils/npm.js
index 6a49c06..70f5c8a 100644
--- a/node_modules/@metamask/snap-controllers/dist/snaps/utils/npm.js
+++ b/node_modules/@metamask/snap-controllers/dist/snaps/utils/npm.js
@@ -53,7 +53,7 @@ exports.fetchNpmSnap = fetchNpmSnap;
  */
 async function fetchNpmTarball(packageName, versionRange, registryUrl = exports.DEFAULT_NPM_REGISTRY, fetchFunction = fetch) {
     var _a, _b, _c, _d;
-    const packageMetadata = await (await fetchFunction(new URL(packageName, registryUrl).toString())).json();
+    const packageMetadata = await (await fetchFunction('GET', new URL(packageName, registryUrl).toString())).json();
     if (!(0, utils_1.isObject)(packageMetadata)) {
         throw new Error(`Failed to fetch package "${packageName}" metadata from npm.`);
     }
@@ -71,11 +71,12 @@ async function fetchNpmTarball(packageName, versionRange, registryUrl = exports.
     newTarballUrl.hostname = newRegistryUrl.hostname;
     newTarballUrl.protocol = newRegistryUrl.protocol;
     // Perform a raw fetch because we want the Response object itself.
-    const tarballResponse = await fetchFunction(newTarballUrl.toString());
-    if (!tarballResponse.ok) {
-        throw new Error(`Failed to fetch tarball for package "${packageName}".`);
-    }
-    const stream = await tarballResponse.blob().then((blob) => blob.stream());
+    const tarballResponse = await fetchFunction('GET', newTarballUrl.toString());
+    // if (!tarballResponse.ok) {
+    //     throw new Error(`Failed to fetch tarball for package "${packageName}".`);
+    // }
+    // const stream = await tarballResponse.blob().then((blob) => blob.stream());
+    console.log(await tarballResponse.blob());
     return [stream, targetVersion];
 }
 //# sourceMappingURL=npm.js.map
\ No newline at end of file
