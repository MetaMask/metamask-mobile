diff --git a/node_modules/@metamask/assets-controllers/dist/NftController.cjs b/node_modules/@metamask/assets-controllers/dist/NftController.cjs
index 0f15eb6..d814ed8 100644
--- a/node_modules/@metamask/assets-controllers/dist/NftController.cjs
+++ b/node_modules/@metamask/assets-controllers/dist/NftController.cjs
@@ -13,7 +13,7 @@ var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (
 var __importDefault = (this && this.__importDefault) || function (mod) {
     return (mod && mod.__esModule) ? mod : { "default": mod };
 };
-var _NftController_instances, _NftController_mutex, _NftController_selectedAccountId, _NftController_chainId, _NftController_ipfsGateway, _NftController_openSeaEnabled, _NftController_useIpfsSubdomains, _NftController_isIpfsGatewayEnabled, _NftController_onNftAdded, _NftController_onNetworkControllerNetworkDidChange, _NftController_onPreferencesControllerStateChange, _NftController_onSelectedAccountChange, _NftController_updateNestedNftState, _NftController_getNftCollectionApi, _NftController_getNftInformationFromApi, _NftController_getNftInformationFromTokenURI, _NftController_getNftURIAndStandard, _NftController_getNftInformation, _NftController_getNftContractInformationFromContract, _NftController_getNftContractInformation, _NftController_addIndividualNft, _NftController_addNftContract, _NftController_removeAndIgnoreIndividualNft, _NftController_removeIndividualNft, _NftController_removeNftContract, _NftController_validateWatchNft, _NftController_getCorrectChainId, _NftController_getAddressOrSelectedAddress, _NftController_updateNftUpdateForAccount;
+var _NftController_instances, _NftController_mutex, _NftController_selectedAccountId, _NftController_chainId, _NftController_ipfsGateway, _NftController_displayNftMedia, _NftController_useIpfsSubdomains, _NftController_isIpfsGatewayEnabled, _NftController_onNftAdded, _NftController_onNetworkControllerNetworkDidChange, _NftController_onPreferencesControllerStateChange, _NftController_onSelectedAccountChange, _NftController_updateNestedNftState, _NftController_getNftCollectionApi, _NftController_getNftInformationFromApi, _NftController_getNftInformationFromTokenURI, _NftController_getNftURIAndStandard, _NftController_getNftInformation, _NftController_getNftContractInformationFromContract, _NftController_getNftContractInformation, _NftController_addIndividualNft, _NftController_addNftContract, _NftController_removeAndIgnoreIndividualNft, _NftController_removeIndividualNft, _NftController_removeNftContract, _NftController_validateWatchNft, _NftController_getCorrectChainId, _NftController_getAddressOrSelectedAddress, _NftController_updateNftUpdateForAccount;
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.NftController = exports.getDefaultNftControllerState = void 0;
 const address_1 = require("@ethersproject/address");
@@ -54,7 +54,7 @@ class NftController extends base_controller_1.BaseController {
      * @param options - The controller options.
      * @param options.chainId - The chain ID of the current network.
      * @param options.ipfsGateway - The configured IPFS gateway.
-     * @param options.openSeaEnabled - Controls whether the OpenSea API is used.
+     * @param options.displayNftMedia - Controls whether the NFT API is used.
      * @param options.useIpfsSubdomains - Controls whether IPFS subdomains are used.
      * @param options.isIpfsGatewayEnabled - Controls whether IPFS is enabled or not.
      * @param options.onNftAdded - Callback that is called when an NFT is added. Currently used pass data
@@ -62,7 +62,7 @@ class NftController extends base_controller_1.BaseController {
      * @param options.messenger - The messenger.
      * @param options.state - Initial state to set on this controller.
      */
-    constructor({ chainId: initialChainId, ipfsGateway = controller_utils_1.IPFS_DEFAULT_GATEWAY_URL, openSeaEnabled = false, useIpfsSubdomains = true, isIpfsGatewayEnabled = true, onNftAdded, messenger, state = {}, }) {
+    constructor({ chainId: initialChainId, ipfsGateway = controller_utils_1.IPFS_DEFAULT_GATEWAY_URL, displayNftMedia = false, useIpfsSubdomains = true, isIpfsGatewayEnabled = true, onNftAdded, messenger, state = {}, }) {
         super({
             name: controllerName,
             metadata: nftControllerMetadata,
@@ -77,14 +77,14 @@ class NftController extends base_controller_1.BaseController {
         _NftController_selectedAccountId.set(this, void 0);
         _NftController_chainId.set(this, void 0);
         _NftController_ipfsGateway.set(this, void 0);
-        _NftController_openSeaEnabled.set(this, void 0);
+        _NftController_displayNftMedia.set(this, void 0);
         _NftController_useIpfsSubdomains.set(this, void 0);
         _NftController_isIpfsGatewayEnabled.set(this, void 0);
         _NftController_onNftAdded.set(this, void 0);
         __classPrivateFieldSet(this, _NftController_selectedAccountId, this.messagingSystem.call('AccountsController:getSelectedAccount').id, "f");
         __classPrivateFieldSet(this, _NftController_chainId, initialChainId, "f");
         __classPrivateFieldSet(this, _NftController_ipfsGateway, ipfsGateway, "f");
-        __classPrivateFieldSet(this, _NftController_openSeaEnabled, openSeaEnabled, "f");
+        __classPrivateFieldSet(this, _NftController_displayNftMedia, displayNftMedia, "f");
         __classPrivateFieldSet(this, _NftController_useIpfsSubdomains, useIpfsSubdomains, "f");
         __classPrivateFieldSet(this, _NftController_isIpfsGatewayEnabled, isIpfsGatewayEnabled, "f");
         __classPrivateFieldSet(this, _NftController_onNftAdded, onNftAdded, "f");
@@ -597,7 +597,7 @@ class NftController extends base_controller_1.BaseController {
     }
 }
 exports.NftController = NftController;
-_NftController_mutex = new WeakMap(), _NftController_selectedAccountId = new WeakMap(), _NftController_chainId = new WeakMap(), _NftController_ipfsGateway = new WeakMap(), _NftController_openSeaEnabled = new WeakMap(), _NftController_useIpfsSubdomains = new WeakMap(), _NftController_isIpfsGatewayEnabled = new WeakMap(), _NftController_onNftAdded = new WeakMap(), _NftController_instances = new WeakSet(), _NftController_onNetworkControllerNetworkDidChange = function _NftController_onNetworkControllerNetworkDidChange({ selectedNetworkClientId, }) {
+_NftController_mutex = new WeakMap(), _NftController_selectedAccountId = new WeakMap(), _NftController_chainId = new WeakMap(), _NftController_ipfsGateway = new WeakMap(), _NftController_displayNftMedia = new WeakMap(), _NftController_useIpfsSubdomains = new WeakMap(), _NftController_isIpfsGatewayEnabled = new WeakMap(), _NftController_onNftAdded = new WeakMap(), _NftController_instances = new WeakSet(), _NftController_onNetworkControllerNetworkDidChange = function _NftController_onNetworkControllerNetworkDidChange({ selectedNetworkClientId, }) {
     const { configuration: { chainId }, } = this.messagingSystem.call('NetworkController:getNetworkClientById', selectedNetworkClientId);
     __classPrivateFieldSet(this, _NftController_chainId, chainId, "f");
 }, _NftController_onPreferencesControllerStateChange = 
@@ -605,20 +605,20 @@ _NftController_mutex = new WeakMap(), _NftController_selectedAccountId = new Wea
  * Handles the state change of the preference controller.
  * @param preferencesState - The new state of the preference controller.
  * @param preferencesState.ipfsGateway - The configured IPFS gateway.
- * @param preferencesState.openSeaEnabled - Controls whether the OpenSea API is used.
+ * @param preferencesState.displayNftMedia - Controls whether the NFT API is used.
  * @param preferencesState.isIpfsGatewayEnabled - Controls whether IPFS is enabled or not.
  */
-async function _NftController_onPreferencesControllerStateChange({ ipfsGateway, openSeaEnabled, isIpfsGatewayEnabled, }) {
+async function _NftController_onPreferencesControllerStateChange({ ipfsGateway, displayNftMedia, isIpfsGatewayEnabled, }) {
     const selectedAccount = this.messagingSystem.call('AccountsController:getSelectedAccount');
     __classPrivateFieldSet(this, _NftController_selectedAccountId, selectedAccount.id, "f");
     // Get current state values
     if (__classPrivateFieldGet(this, _NftController_ipfsGateway, "f") !== ipfsGateway ||
-        __classPrivateFieldGet(this, _NftController_openSeaEnabled, "f") !== openSeaEnabled ||
+        __classPrivateFieldGet(this, _NftController_displayNftMedia, "f") !== displayNftMedia ||
         __classPrivateFieldGet(this, _NftController_isIpfsGatewayEnabled, "f") !== isIpfsGatewayEnabled) {
         __classPrivateFieldSet(this, _NftController_ipfsGateway, ipfsGateway, "f");
-        __classPrivateFieldSet(this, _NftController_openSeaEnabled, openSeaEnabled, "f");
+        __classPrivateFieldSet(this, _NftController_displayNftMedia, displayNftMedia, "f");
         __classPrivateFieldSet(this, _NftController_isIpfsGatewayEnabled, isIpfsGatewayEnabled, "f");
-        const needsUpdateNftMetadata = (isIpfsGatewayEnabled && ipfsGateway !== '') || openSeaEnabled;
+        const needsUpdateNftMetadata = (isIpfsGatewayEnabled && ipfsGateway !== '') || displayNftMedia;
         if (needsUpdateNftMetadata && selectedAccount) {
             await __classPrivateFieldGet(this, _NftController_instances, "m", _NftController_updateNftUpdateForAccount).call(this, selectedAccount);
         }
@@ -632,7 +632,7 @@ async function _NftController_onSelectedAccountChange(internalAccount) {
     const oldSelectedAccountId = __classPrivateFieldGet(this, _NftController_selectedAccountId, "f");
     __classPrivateFieldSet(this, _NftController_selectedAccountId, internalAccount.id, "f");
     const needsUpdateNftMetadata = ((__classPrivateFieldGet(this, _NftController_isIpfsGatewayEnabled, "f") && __classPrivateFieldGet(this, _NftController_ipfsGateway, "f") !== '') ||
-        __classPrivateFieldGet(this, _NftController_openSeaEnabled, "f")) &&
+        __classPrivateFieldGet(this, _NftController_displayNftMedia, "f")) &&
         oldSelectedAccountId !== internalAccount.id;
     if (needsUpdateNftMetadata) {
         await __classPrivateFieldGet(this, _NftController_instances, "m", _NftController_updateNftUpdateForAccount).call(this, internalAccount);
@@ -707,6 +707,7 @@ async function _NftController_getNftInformationFromApi(contractAddress, tokenId)
             description: null,
             image: null,
             standard: null,
+            error: 'Opensea import error',
         };
     }
     // if we've reached this point, we have successfully fetched some data for nftInformation
@@ -749,9 +750,10 @@ async function _NftController_getNftInformationFromTokenURI(contractAddress, tok
             standard: standard || null,
             favorite: false,
             tokenURI: tokenURI ?? null,
+            error: 'URI import error',
         };
     }
-    const isDisplayNFTMediaToggleEnabled = __classPrivateFieldGet(this, _NftController_openSeaEnabled, "f");
+    const isDisplayNFTMediaToggleEnabled = __classPrivateFieldGet(this, _NftController_displayNftMedia, "f");
     if (!hasIpfsTokenURI && !isDisplayNFTMediaToggleEnabled) {
         return {
             image: null,
@@ -760,6 +762,7 @@ async function _NftController_getNftInformationFromTokenURI(contractAddress, tok
             standard: standard || null,
             favorite: false,
             tokenURI: tokenURI ?? null,
+            error: 'URI import error',
         };
     }
     if (hasIpfsTokenURI) {
@@ -853,10 +856,21 @@ async function _NftController_getNftInformation(contractAddress, tokenId, networ
     });
     const [blockchainMetadata, nftApiMetadata] = await Promise.all([
         (0, controller_utils_1.safelyExecute)(() => __classPrivateFieldGet(this, _NftController_instances, "m", _NftController_getNftInformationFromTokenURI).call(this, contractAddress, tokenId, networkClientId)),
-        __classPrivateFieldGet(this, _NftController_openSeaEnabled, "f") && chainId === '0x1'
+        __classPrivateFieldGet(this, _NftController_displayNftMedia, "f") && chainId === '0x1'
             ? (0, controller_utils_1.safelyExecute)(() => __classPrivateFieldGet(this, _NftController_instances, "m", _NftController_getNftInformationFromApi).call(this, contractAddress, tokenId))
             : undefined,
     ]);
+    if (blockchainMetadata?.error && nftApiMetadata?.error) {
+        return {
+            image: null,
+            name: null,
+            description: null,
+            standard: blockchainMetadata.standard ?? null,
+            favorite: false,
+            tokenURI: blockchainMetadata.tokenURI ?? null,
+            error: 'Both import failed',
+        };
+    }
     return {
         ...nftApiMetadata,
         name: blockchainMetadata?.name ?? nftApiMetadata?.name ?? null,
@@ -998,6 +1012,7 @@ async function _NftController_addIndividualNft(tokenAddress, tokenId, nftMetadat
                 tokenId: tokenId.toString(),
                 standard: nftMetadata.standard,
                 source,
+                tokenURI: nftMetadata.tokenURI
             });
         }
     }
diff --git a/node_modules/@metamask/assets-controllers/dist/NftController.d.cts b/node_modules/@metamask/assets-controllers/dist/NftController.d.cts
index 4384784..e35e71c 100644
--- a/node_modules/@metamask/assets-controllers/dist/NftController.d.cts
+++ b/node_modules/@metamask/assets-controllers/dist/NftController.d.cts
@@ -108,6 +108,7 @@ export type NftMetadata = {
     creator?: string;
     transactionId?: string;
     tokenURI?: string | null;
+    error?: string;
     collection?: Collection;
     address?: string;
     attributes?: Attributes[];
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.cjs b/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.cjs
index a70d3f4..05ed007 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.cjs
+++ b/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.cjs
@@ -10,7 +10,7 @@ var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (
     if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
     return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
 };
-var _TokenBalancesController_instances, _TokenBalancesController_queryMultipleAccounts, _TokenBalancesController_allTokens, _TokenBalancesController_allDetectedTokens, _TokenBalancesController_calculateQueryMultipleAccounts, _TokenBalancesController_onPreferencesStateChange, _TokenBalancesController_onTokensStateChange, _TokenBalancesController_onNetworkStateChange, _TokenBalancesController_getChainIds, _TokenBalancesController_getNetworkClient;
+var _TokenBalancesController_instances, _TokenBalancesController_queryMultipleAccounts, _TokenBalancesController_allTokens, _TokenBalancesController_allDetectedTokens, _TokenBalancesController_calculateQueryMultipleAccounts, _TokenBalancesController_onPreferencesStateChange, _TokenBalancesController_onTokensStateChange, _TokenBalancesController_onNetworkStateChange, _TokenBalancesController_getChainIds, _TokenBalancesController_getNetworkClient, _TokenBalancesController_handleOnAccountRemoved, _TokenBalancesController_handleTokensControllerStateChange;
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.TokenBalancesController = exports.getDefaultTokenBalancesState = void 0;
 const contracts_1 = require("@ethersproject/contracts");
@@ -103,7 +103,9 @@ class TokenBalancesController extends (0, polling_controller_1.StaticIntervalPol
                 !(0, lodash_1.isEqual)(__classPrivateFieldGet(this, _TokenBalancesController_allDetectedTokens, "f")[chainId], allDetectedTokens[chainId]));
             __classPrivateFieldSet(this, _TokenBalancesController_allTokens, allTokens, "f");
             __classPrivateFieldSet(this, _TokenBalancesController_allDetectedTokens, allDetectedTokens, "f");
-            this.updateBalances({ chainIds: chainIdsToUpdate }).catch(console.error);
+            __classPrivateFieldGet(this, _TokenBalancesController_instances, "m", _TokenBalancesController_handleTokensControllerStateChange).call(this, {
+                chainIds: chainIdsToUpdate,
+            }).catch(console.error);
         });
         /**
          * Returns an array of chain ids that have tokens.
@@ -129,6 +131,8 @@ class TokenBalancesController extends (0, polling_controller_1.StaticIntervalPol
         this.messagingSystem.subscribe('TokensController:stateChange', __classPrivateFieldGet(this, _TokenBalancesController_onTokensStateChange, "f").bind(this));
         // Subscribe to network state changes
         this.messagingSystem.subscribe('NetworkController:stateChange', __classPrivateFieldGet(this, _TokenBalancesController_instances, "m", _TokenBalancesController_onNetworkStateChange).bind(this));
+        // subscribe to account removed event to cleanup stale balances
+        this.messagingSystem.subscribe('AccountsController:accountRemoved', (accountId) => __classPrivateFieldGet(this, _TokenBalancesController_instances, "m", _TokenBalancesController_handleOnAccountRemoved).call(this, accountId));
     }
     /**
      * Polls for erc20 token balances.
@@ -168,6 +172,7 @@ class TokenBalancesController extends (0, polling_controller_1.StaticIntervalPol
         Object.entries(__classPrivateFieldGet(this, _TokenBalancesController_allTokens, "f")[chainId] ?? {}).forEach(addTokens);
         Object.entries(__classPrivateFieldGet(this, _TokenBalancesController_allDetectedTokens, "f")[chainId] ?? {}).forEach(addTokens);
         let results = [];
+        const currentTokenBalances = this.messagingSystem.call('TokenBalancesController:getState');
         if (accountTokenPairs.length > 0) {
             const provider = new providers_1.Web3Provider(__classPrivateFieldGet(this, _TokenBalancesController_instances, "m", _TokenBalancesController_getNetworkClient).call(this, chainId).provider);
             const calls = accountTokenPairs.map(({ accountAddress, tokenAddress }) => ({
@@ -177,17 +182,26 @@ class TokenBalancesController extends (0, polling_controller_1.StaticIntervalPol
             }));
             results = await (0, multicall_1.multicallOrFallback)(calls, chainId, provider);
         }
+        const updatedResults = results.map((res, i) => {
+            const { value } = res;
+            const { accountAddress, tokenAddress } = accountTokenPairs[i];
+            const currentTokenBalanceValueForAccount = currentTokenBalances.tokenBalances?.[accountAddress]?.[chainId]?.[tokenAddress];
+            const isTokenBalanceValueChanged = currentTokenBalanceValueForAccount !== (0, controller_utils_1.toHex)(value);
+            return {
+                ...res,
+                isTokenBalanceValueChanged,
+            };
+        });
+        // if all values of isTokenBalanceValueChanged are false, return
+        if (updatedResults.every((result) => !result.isTokenBalanceValueChanged)) {
+            return;
+        }
         this.update((state) => {
             var _a, _b;
-            // Reset so that when accounts or tokens are removed,
-            // their balances are removed rather than left stale.
-            for (const accountAddress of Object.keys(state.tokenBalances)) {
-                state.tokenBalances[accountAddress][chainId] = {};
-            }
-            for (let i = 0; i < results.length; i++) {
-                const { success, value } = results[i];
+            for (let i = 0; i < updatedResults.length; i++) {
+                const { success, value, isTokenBalanceValueChanged } = updatedResults[i];
                 const { accountAddress, tokenAddress } = accountTokenPairs[i];
-                if (success) {
+                if (success && isTokenBalanceValueChanged) {
                     ((_b = ((_a = state.tokenBalances)[accountAddress] ?? (_a[accountAddress] = {})))[chainId] ?? (_b[chainId] = {}))[tokenAddress] = (0, controller_utils_1.toHex)(value);
                 }
             }
@@ -216,6 +230,61 @@ _TokenBalancesController_queryMultipleAccounts = new WeakMap(), _TokenBalancesCo
             });
         }
     }
+}, _TokenBalancesController_handleOnAccountRemoved = function _TokenBalancesController_handleOnAccountRemoved(accountId) {
+    const accounts = this.messagingSystem.call('AccountsController:listAccounts');
+    const accountAddress = accounts.find((account) => account.id === accountId)?.address;
+    if (!accountAddress) {
+        return;
+    }
+    this.update((state) => {
+        delete state.tokenBalances[accountAddress];
+    });
+}, _TokenBalancesController_handleTokensControllerStateChange = async function _TokenBalancesController_handleTokensControllerStateChange({ chainIds, } = {}) {
+    const currentTokenBalancesState = this.messagingSystem.call('TokenBalancesController:getState');
+    const currentTokenBalances = currentTokenBalancesState.tokenBalances;
+    const currentAllTokens = __classPrivateFieldGet(this, _TokenBalancesController_allTokens, "f");
+    const chainIdsSet = new Set(chainIds);
+    // first we check if the state change was due to a token being removed
+    for (const currentAccount of Object.keys(currentTokenBalances)) {
+        const allChains = currentTokenBalances[currentAccount];
+        for (const currentChain of Object.keys(allChains)) {
+            if (chainIds?.length && !chainIdsSet.has(currentChain)) {
+                continue;
+            }
+            const tokensObject = allChains[currentChain];
+            const allCurrentTokens = Object.keys(tokensObject);
+            const existingTokensInState = currentAllTokens[currentChain]?.[currentAccount] || [];
+            const existingSet = new Set(existingTokensInState.map((elm) => elm.address));
+            for (const singleToken of allCurrentTokens) {
+                if (!existingSet.has(singleToken)) {
+                    this.update((state) => {
+                        delete state.tokenBalances[currentAccount][currentChain][singleToken];
+                    });
+                }
+            }
+        }
+    }
+    // then we check if the state change was due to a token being added
+    let shouldUpdate = false;
+    for (const currentChain of Object.keys(currentAllTokens)) {
+        if (chainIds?.length && !chainIdsSet.has(currentChain)) {
+            continue;
+        }
+        const accountsPerChain = currentAllTokens[currentChain];
+        for (const currentAccount of Object.keys(accountsPerChain)) {
+            const tokensList = accountsPerChain[currentAccount];
+            const tokenBalancesObject = currentTokenBalances[currentAccount]?.[currentChain] || {};
+            for (const singleToken of tokensList) {
+                if (!tokenBalancesObject?.[singleToken.address]) {
+                    shouldUpdate = true;
+                    break;
+                }
+            }
+        }
+    }
+    if (shouldUpdate) {
+        await this.updateBalances({ chainIds }).catch(console.error);
+    }
 }, _TokenBalancesController_getNetworkClient = function _TokenBalancesController_getNetworkClient(chainId) {
     const { networkConfigurationsByChainId } = this.messagingSystem.call('NetworkController:getState');
     const networkConfiguration = networkConfigurationsByChainId[chainId];
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.d.cts b/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.d.cts
index 57a407a..893142e 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.d.cts
+++ b/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.d.cts
@@ -1,4 +1,4 @@
-import type { AccountsControllerGetSelectedAccountAction } from "@metamask/accounts-controller";
+import type { AccountsControllerAccountRemovedEvent, AccountsControllerListAccountsAction, AccountsControllerGetSelectedAccountAction } from "@metamask/accounts-controller";
 import type { RestrictedMessenger, ControllerGetStateAction, ControllerStateChangeEvent } from "@metamask/base-controller";
 import type { NetworkControllerGetNetworkClientByIdAction, NetworkControllerGetStateAction, NetworkControllerStateChangeEvent } from "@metamask/network-controller";
 import type { PreferencesControllerGetStateAction, PreferencesControllerStateChangeEvent } from "@metamask/preferences-controller";
@@ -29,10 +29,10 @@ export type TokenBalancesControllerState = {
 };
 export type TokenBalancesControllerGetStateAction = ControllerGetStateAction<typeof controllerName, TokenBalancesControllerState>;
 export type TokenBalancesControllerActions = TokenBalancesControllerGetStateAction;
-export type AllowedActions = NetworkControllerGetNetworkClientByIdAction | NetworkControllerGetStateAction | TokensControllerGetStateAction | PreferencesControllerGetStateAction | AccountsControllerGetSelectedAccountAction;
+export type AllowedActions = NetworkControllerGetNetworkClientByIdAction | NetworkControllerGetStateAction | TokensControllerGetStateAction | PreferencesControllerGetStateAction | AccountsControllerGetSelectedAccountAction | AccountsControllerListAccountsAction;
 export type TokenBalancesControllerStateChangeEvent = ControllerStateChangeEvent<typeof controllerName, TokenBalancesControllerState>;
 export type TokenBalancesControllerEvents = TokenBalancesControllerStateChangeEvent;
-export type AllowedEvents = TokensControllerStateChangeEvent | PreferencesControllerStateChangeEvent | NetworkControllerStateChangeEvent;
+export type AllowedEvents = TokensControllerStateChangeEvent | PreferencesControllerStateChangeEvent | NetworkControllerStateChangeEvent | AccountsControllerAccountRemovedEvent;
 export type TokenBalancesControllerMessenger = RestrictedMessenger<typeof controllerName, TokenBalancesControllerActions | AllowedActions, TokenBalancesControllerEvents | AllowedEvents, AllowedActions['type'], AllowedEvents['type']>;
 /**
  * Get the default TokenBalancesController state.
diff --git a/node_modules/@metamask/assets-controllers/dist/TokensController.cjs b/node_modules/@metamask/assets-controllers/dist/TokensController.cjs
index 31aaf6d..1522387 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokensController.cjs
+++ b/node_modules/@metamask/assets-controllers/dist/TokensController.cjs
@@ -13,7 +13,7 @@ var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (
 var __importDefault = (this && this.__importDefault) || function (mod) {
     return (mod && mod.__esModule) ? mod : { "default": mod };
 };
-var _TokensController_instances, _TokensController_mutex, _TokensController_selectedAccountId, _TokensController_provider, _TokensController_abortController, _TokensController_onNetworkStateChange, _TokensController_onSelectedAccountChange, _TokensController_fetchTokenMetadata, _TokensController_detectIsERC721, _TokensController_getProvider, _TokensController_createEthersContract, _TokensController_generateRandomId, _TokensController_getNewAllTokensState, _TokensController_getAddressOrSelectedAddress, _TokensController_requestApproval, _TokensController_getSelectedAccount, _TokensController_getSelectedAddress;
+var _TokensController_instances, _TokensController_mutex, _TokensController_chainId, _TokensController_selectedAccountId, _TokensController_provider, _TokensController_abortController, _TokensController_onNetworkDidChange, _TokensController_onNetworkStateChange, _TokensController_onSelectedAccountChange, _TokensController_fetchTokenMetadata, _TokensController_detectIsERC721, _TokensController_getProvider, _TokensController_createEthersContract, _TokensController_generateRandomId, _TokensController_getNewAllTokensState, _TokensController_getAddressOrSelectedAddress, _TokensController_requestApproval, _TokensController_handleOnAccountRemoved, _TokensController_getSelectedAccount, _TokensController_getSelectedAddress;
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.TokensController = exports.getDefaultTokensState = void 0;
 const contracts_1 = require("@ethersproject/contracts");
@@ -65,7 +65,7 @@ class TokensController extends base_controller_1.BaseController {
      * @param options.state - Initial state to set on this controller.
      * @param options.messenger - The messenger.
      */
-    constructor({ provider, state, messenger, }) {
+    constructor({ chainId: initialChainId, provider, state, messenger, }) {
         super({
             name: controllerName,
             metadata,
@@ -77,15 +77,19 @@ class TokensController extends base_controller_1.BaseController {
         });
         _TokensController_instances.add(this);
         _TokensController_mutex.set(this, new async_mutex_1.Mutex());
+        _TokensController_chainId.set(this, void 0);
         _TokensController_selectedAccountId.set(this, void 0);
         _TokensController_provider.set(this, void 0);
         _TokensController_abortController.set(this, void 0);
+        __classPrivateFieldSet(this, _TokensController_chainId, initialChainId, "f");
         __classPrivateFieldSet(this, _TokensController_provider, provider, "f");
         __classPrivateFieldSet(this, _TokensController_selectedAccountId, __classPrivateFieldGet(this, _TokensController_instances, "m", _TokensController_getSelectedAccount).call(this).id, "f");
         __classPrivateFieldSet(this, _TokensController_abortController, new AbortController(), "f");
         this.messagingSystem.registerActionHandler(`${controllerName}:addDetectedTokens`, this.addDetectedTokens.bind(this));
         this.messagingSystem.subscribe('AccountsController:selectedEvmAccountChange', __classPrivateFieldGet(this, _TokensController_instances, "m", _TokensController_onSelectedAccountChange).bind(this));
+        this.messagingSystem.subscribe('NetworkController:networkDidChange', __classPrivateFieldGet(this, _TokensController_instances, "m", _TokensController_onNetworkDidChange).bind(this));
         this.messagingSystem.subscribe('NetworkController:stateChange', __classPrivateFieldGet(this, _TokensController_instances, "m", _TokensController_onNetworkStateChange).bind(this));
+        this.messagingSystem.subscribe('AccountsController:accountRemoved', (accountAddress) => __classPrivateFieldGet(this, _TokensController_instances, "m", _TokensController_handleOnAccountRemoved).call(this, accountAddress));
         this.messagingSystem.subscribe('TokenListController:stateChange', ({ tokensChainsCache }) => {
             const { allTokens } = this.state;
             const selectedAddress = __classPrivateFieldGet(this, _TokensController_instances, "m", _TokensController_getSelectedAddress).call(this);
@@ -128,28 +132,37 @@ class TokensController extends base_controller_1.BaseController {
      * @returns Current token list.
      */
     async addToken({ address, symbol, decimals, name, image, interactingAddress, networkClientId, }) {
+        // TODO: remove this once this method is fully parameterized by chainId
+        const chainId = __classPrivateFieldGet(this, _TokensController_chainId, "f");
         const releaseLock = await __classPrivateFieldGet(this, _TokensController_mutex, "f").acquire();
         const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
-        const chainIdToUse = this.messagingSystem.call('NetworkController:getNetworkClientById', networkClientId).configuration.chainId;
+        let currentChainId = chainId;
+        if (networkClientId) {
+            currentChainId = this.messagingSystem.call('NetworkController:getNetworkClientById', networkClientId).configuration.chainId;
+        }
         const accountAddress = __classPrivateFieldGet(this, _TokensController_instances, "m", _TokensController_getAddressOrSelectedAddress).call(this, interactingAddress);
         try {
             address = (0, controller_utils_1.toChecksumHexAddress)(address);
-            const tokens = allTokens[chainIdToUse]?.[accountAddress] || [];
-            const ignoredTokens = allIgnoredTokens[chainIdToUse]?.[accountAddress] || [];
-            const detectedTokens = allDetectedTokens[chainIdToUse]?.[accountAddress] || [];
+            const tokens = allTokens[currentChainId]?.[accountAddress] || [];
+            const ignoredTokens = allIgnoredTokens[currentChainId]?.[accountAddress] || [];
+            const detectedTokens = allDetectedTokens[currentChainId]?.[accountAddress] || [];
             const newTokens = [...tokens];
             const [isERC721, tokenMetadata] = await Promise.all([
                 __classPrivateFieldGet(this, _TokensController_instances, "m", _TokensController_detectIsERC721).call(this, address, networkClientId),
                 // TODO parameterize the token metadata fetch by networkClientId
-                __classPrivateFieldGet(this, _TokensController_instances, "m", _TokensController_fetchTokenMetadata).call(this, address, chainIdToUse),
+                __classPrivateFieldGet(this, _TokensController_instances, "m", _TokensController_fetchTokenMetadata).call(this, address),
             ]);
+            // TODO remove this once this method is fully parameterized by networkClientId
+            if (!networkClientId && currentChainId !== __classPrivateFieldGet(this, _TokensController_chainId, "f")) {
+                throw new Error('TokensController Error: Switched networks while adding token');
+            }
             const newEntry = {
                 address,
                 symbol,
                 decimals,
                 image: image ||
                     (0, assetsUtil_1.formatIconUrlWithProxy)({
-                        chainId: chainIdToUse,
+                        chainId: currentChainId,
                         tokenAddress: address,
                     }),
                 isERC721,
@@ -170,7 +183,7 @@ class TokensController extends base_controller_1.BaseController {
                 newIgnoredTokens,
                 newDetectedTokens,
                 interactingAddress: accountAddress,
-                interactingChainId: chainIdToUse,
+                interactingChainId: currentChainId,
             });
             const newState = {
                 allTokens: newAllTokens,
@@ -196,7 +209,10 @@ class TokensController extends base_controller_1.BaseController {
         const releaseLock = await __classPrivateFieldGet(this, _TokensController_mutex, "f").acquire();
         const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
         const importedTokensMap = {};
-        const interactingChainId = this.messagingSystem.call('NetworkController:getNetworkClientById', networkClientId).configuration.chainId;
+        let interactingChainId = __classPrivateFieldGet(this, _TokensController_chainId, "f");
+        if (networkClientId) {
+            interactingChainId = this.messagingSystem.call('NetworkController:getNetworkClientById', networkClientId).configuration.chainId;
+        }
         // Used later to dedupe imported tokens
         const newTokensMap = [
             ...(allTokens[interactingChainId]?.[__classPrivateFieldGet(this, _TokensController_instances, "m", _TokensController_getSelectedAccount).call(this).address] ||
@@ -223,7 +239,7 @@ class TokensController extends base_controller_1.BaseController {
                 return formattedToken;
             });
             const newTokens = Object.values(newTokensMap);
-            const newIgnoredTokens = allIgnoredTokens[interactingChainId]?.[__classPrivateFieldGet(this, _TokensController_instances, "m", _TokensController_getSelectedAddress).call(this)]?.filter((tokenAddress) => !newTokensMap[tokenAddress.toLowerCase()]);
+            const newIgnoredTokens = allIgnoredTokens[interactingChainId ?? __classPrivateFieldGet(this, _TokensController_chainId, "f")]?.[__classPrivateFieldGet(this, _TokensController_instances, "m", _TokensController_getSelectedAddress).call(this)]?.filter((tokenAddress) => !newTokensMap[tokenAddress.toLowerCase()]);
             const detectedTokensForGivenChain = interactingChainId
                 ? allDetectedTokens?.[interactingChainId]?.[__classPrivateFieldGet(this, _TokensController_instances, "m", _TokensController_getSelectedAddress).call(this)]
                 : [];
@@ -251,13 +267,16 @@ class TokensController extends base_controller_1.BaseController {
      * @param networkClientId - Optional network client ID used to determine interacting chain ID.
      */
     ignoreTokens(tokenAddressesToIgnore, networkClientId) {
-        const interactingChainId = this.messagingSystem.call('NetworkController:getNetworkClientById', networkClientId).configuration.chainId;
+        let interactingChainId = __classPrivateFieldGet(this, _TokensController_chainId, "f");
+        if (networkClientId) {
+            interactingChainId = this.messagingSystem.call('NetworkController:getNetworkClientById', networkClientId).configuration.chainId;
+        }
         const { allTokens, allDetectedTokens, allIgnoredTokens } = this.state;
         const ignoredTokensMap = {};
-        const ignoredTokens = allIgnoredTokens[interactingChainId]?.[__classPrivateFieldGet(this, _TokensController_instances, "m", _TokensController_getSelectedAddress).call(this)] || [];
+        const ignoredTokens = allIgnoredTokens[interactingChainId ?? __classPrivateFieldGet(this, _TokensController_chainId, "f")]?.[__classPrivateFieldGet(this, _TokensController_instances, "m", _TokensController_getSelectedAddress).call(this)] || [];
         let newIgnoredTokens = [...ignoredTokens];
-        const tokens = allTokens[interactingChainId]?.[__classPrivateFieldGet(this, _TokensController_instances, "m", _TokensController_getSelectedAddress).call(this)] || [];
-        const detectedTokens = allDetectedTokens[interactingChainId]?.[__classPrivateFieldGet(this, _TokensController_instances, "m", _TokensController_getSelectedAddress).call(this)] || [];
+        const tokens = allTokens[interactingChainId ?? __classPrivateFieldGet(this, _TokensController_chainId, "f")]?.[__classPrivateFieldGet(this, _TokensController_instances, "m", _TokensController_getSelectedAddress).call(this)] || [];
+        const detectedTokens = allDetectedTokens[interactingChainId ?? __classPrivateFieldGet(this, _TokensController_chainId, "f")]?.[__classPrivateFieldGet(this, _TokensController_instances, "m", _TokensController_getSelectedAddress).call(this)] || [];
         const checksummedTokenAddresses = tokenAddressesToIgnore.map((address) => {
             const checksumAddress = (0, controller_utils_1.toChecksumHexAddress)(address);
             ignoredTokensMap[address.toLowerCase()] = true;
@@ -288,7 +307,7 @@ class TokensController extends base_controller_1.BaseController {
      */
     async addDetectedTokens(incomingDetectedTokens, detectionDetails) {
         const releaseLock = await __classPrivateFieldGet(this, _TokensController_mutex, "f").acquire();
-        const { chainId } = detectionDetails;
+        const chainId = detectionDetails?.chainId ?? __classPrivateFieldGet(this, _TokensController_chainId, "f");
         // Previously selectedAddress could be an empty string. This is to preserve the behaviour
         const accountAddress = detectionDetails?.selectedAddress ?? __classPrivateFieldGet(this, _TokensController_instances, "m", _TokensController_getSelectedAddress).call(this);
         const { allTokens, allDetectedTokens, allIgnoredTokens } = this.state;
@@ -338,9 +357,9 @@ class TokensController extends base_controller_1.BaseController {
             // We may be detecting tokens on a different chain/account pair than are currently configured.
             // Re-point `tokens` and `detectedTokens` to keep them referencing the current chain/account.
             const selectedAddress = __classPrivateFieldGet(this, _TokensController_instances, "m", _TokensController_getSelectedAddress).call(this);
-            newTokens = newAllTokens?.[chainId]?.[selectedAddress] || [];
+            newTokens = newAllTokens?.[__classPrivateFieldGet(this, _TokensController_chainId, "f")]?.[selectedAddress] || [];
             newDetectedTokens =
-                newAllDetectedTokens?.[chainId]?.[selectedAddress] || [];
+                newAllDetectedTokens?.[__classPrivateFieldGet(this, _TokensController_chainId, "f")]?.[selectedAddress] || [];
             this.update((state) => {
                 state.allTokens = newAllTokens;
                 state.allDetectedTokens = newAllDetectedTokens;
@@ -355,21 +374,20 @@ class TokensController extends base_controller_1.BaseController {
      * were previously added which do not yet had isERC721 field.
      *
      * @param tokenAddress - The contract address of the token requiring the isERC721 field added.
-     * @param networkClientId - The network client ID of the network on which the token is detected.
      * @returns The new token object with the added isERC721 field.
      */
-    async updateTokenType(tokenAddress, networkClientId) {
-        const chainIdToUse = this.messagingSystem.call('NetworkController:getNetworkClientById', networkClientId).configuration.chainId;
-        const isERC721 = await __classPrivateFieldGet(this, _TokensController_instances, "m", _TokensController_detectIsERC721).call(this, tokenAddress, networkClientId);
+    async updateTokenType(tokenAddress) {
+        const isERC721 = await __classPrivateFieldGet(this, _TokensController_instances, "m", _TokensController_detectIsERC721).call(this, tokenAddress);
+        const chainId = __classPrivateFieldGet(this, _TokensController_chainId, "f");
         const accountAddress = __classPrivateFieldGet(this, _TokensController_instances, "m", _TokensController_getSelectedAddress).call(this);
-        const tokens = [...this.state.allTokens[chainIdToUse][accountAddress]];
+        const tokens = [...this.state.allTokens[chainId][accountAddress]];
         const tokenIndex = tokens.findIndex((token) => {
             return token.address.toLowerCase() === tokenAddress.toLowerCase();
         });
         const updatedToken = { ...tokens[tokenIndex], isERC721 };
         tokens[tokenIndex] = updatedToken;
         this.update((state) => {
-            state.allTokens[chainIdToUse][accountAddress] = tokens;
+            state.allTokens[chainId][accountAddress] = tokens;
         });
         return updatedToken;
     }
@@ -494,7 +512,44 @@ class TokensController extends base_controller_1.BaseController {
     }
 }
 exports.TokensController = TokensController;
-_TokensController_mutex = new WeakMap(), _TokensController_selectedAccountId = new WeakMap(), _TokensController_provider = new WeakMap(), _TokensController_abortController = new WeakMap(), _TokensController_instances = new WeakSet(), _TokensController_onNetworkStateChange = function _TokensController_onNetworkStateChange(_, patches) {
+_TokensController_mutex = new WeakMap(), _TokensController_chainId = new WeakMap(), _TokensController_selectedAccountId = new WeakMap(), _TokensController_provider = new WeakMap(), _TokensController_abortController = new WeakMap(), _TokensController_instances = new WeakSet(), _TokensController_onNetworkDidChange = function _TokensController_onNetworkDidChange({ selectedNetworkClientId }) {
+    const selectedNetworkClient = this.messagingSystem.call('NetworkController:getNetworkClientById', selectedNetworkClientId);
+    const { chainId } = selectedNetworkClient.configuration;
+    __classPrivateFieldGet(this, _TokensController_abortController, "f").abort();
+    __classPrivateFieldSet(this, _TokensController_abortController, new AbortController(), "f");
+    __classPrivateFieldSet(this, _TokensController_chainId, chainId, "f");
+}, _TokensController_handleOnAccountRemoved = function _TokensController_handleOnAccountRemoved(accountId){
+   // find the account address in allTokens, allDetectedTokens, allIgnoredTokens
+   const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
+   const accounts = this.messagingSystem.call('AccountsController:listAccounts');
+   const accountAddress = accounts.find((account) => account.id === accountId)?.address;
+   if (!accountAddress) {
+       return;
+   }
+   const newAllTokens = (0, lodash_1.cloneDeep)(allTokens);
+   const newAllDetectedTokens = (0, lodash_1.cloneDeep)(allDetectedTokens);
+   const newAllIgnoredTokens = (0, lodash_1.cloneDeep)(allIgnoredTokens);
+   for (const chainId of Object.keys(newAllTokens)) {
+       if (newAllTokens[chainId][accountAddress]) {
+           delete newAllTokens[chainId][accountAddress];
+       }
+   }
+   for (const chainId of Object.keys(newAllDetectedTokens)) {
+       if (newAllDetectedTokens[chainId][accountAddress]) {
+           delete newAllDetectedTokens[chainId][accountAddress];
+       }
+   }
+   for (const chainId of Object.keys(newAllIgnoredTokens)) {
+       if (newAllIgnoredTokens[chainId][accountAddress]) {
+           delete newAllIgnoredTokens[chainId][accountAddress];
+       }
+   }
+   this.update((state) => {
+       state.allTokens = newAllTokens;
+       state.allIgnoredTokens = newAllIgnoredTokens;
+       state.allDetectedTokens = newAllDetectedTokens;
+   });
+}, _TokensController_onNetworkStateChange = function _TokensController_onNetworkStateChange(_, patches) {
     // Remove state for deleted networks
     for (const patch of patches) {
         if (patch.op === 'remove' &&
@@ -514,12 +569,11 @@ _TokensController_mutex = new WeakMap(), _TokensController_selectedAccountId = n
  * Fetch metadata for a token.
  *
  * @param tokenAddress - The address of the token.
- * @param chainId - The chain ID of the network on which the token is detected.
  * @returns The token metadata.
  */
-async function _TokensController_fetchTokenMetadata(tokenAddress, chainId) {
+async function _TokensController_fetchTokenMetadata(tokenAddress) {
     try {
-        const token = await (0, token_service_1.fetchTokenMetadata)(chainId, tokenAddress, __classPrivateFieldGet(this, _TokensController_abortController, "f").signal);
+        const token = await (0, token_service_1.fetchTokenMetadata)(__classPrivateFieldGet(this, _TokensController_chainId, "f"), tokenAddress, __classPrivateFieldGet(this, _TokensController_abortController, "f").signal);
         return token;
     }
     catch (error) {
@@ -573,52 +627,53 @@ async function _TokensController_detectIsERC721(tokenAddress, networkClientId) {
     const { newTokens, newIgnoredTokens, newDetectedTokens, interactingAddress, interactingChainId, } = params;
     const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
     const userAddressToAddTokens = __classPrivateFieldGet(this, _TokensController_instances, "m", _TokensController_getAddressOrSelectedAddress).call(this, interactingAddress);
+    const chainIdToAddTokens = interactingChainId ?? __classPrivateFieldGet(this, _TokensController_chainId, "f");
     let newAllTokens = allTokens;
     if (newTokens?.length ||
         (newTokens &&
             allTokens &&
-            allTokens[interactingChainId] &&
-            allTokens[interactingChainId][userAddressToAddTokens])) {
-        const networkTokens = allTokens[interactingChainId];
+            allTokens[chainIdToAddTokens] &&
+            allTokens[chainIdToAddTokens][userAddressToAddTokens])) {
+        const networkTokens = allTokens[chainIdToAddTokens];
         const newNetworkTokens = {
             ...networkTokens,
             ...{ [userAddressToAddTokens]: newTokens },
         };
         newAllTokens = {
             ...allTokens,
-            ...{ [interactingChainId]: newNetworkTokens },
+            ...{ [chainIdToAddTokens]: newNetworkTokens },
         };
     }
     let newAllIgnoredTokens = allIgnoredTokens;
     if (newIgnoredTokens?.length ||
         (newIgnoredTokens &&
             allIgnoredTokens &&
-            allIgnoredTokens[interactingChainId] &&
-            allIgnoredTokens[interactingChainId][userAddressToAddTokens])) {
-        const networkIgnoredTokens = allIgnoredTokens[interactingChainId];
+            allIgnoredTokens[chainIdToAddTokens] &&
+            allIgnoredTokens[chainIdToAddTokens][userAddressToAddTokens])) {
+        const networkIgnoredTokens = allIgnoredTokens[chainIdToAddTokens];
         const newIgnoredNetworkTokens = {
             ...networkIgnoredTokens,
             ...{ [userAddressToAddTokens]: newIgnoredTokens },
         };
         newAllIgnoredTokens = {
             ...allIgnoredTokens,
-            ...{ [interactingChainId]: newIgnoredNetworkTokens },
+            ...{ [chainIdToAddTokens]: newIgnoredNetworkTokens },
         };
     }
     let newAllDetectedTokens = allDetectedTokens;
     if (newDetectedTokens?.length ||
         (newDetectedTokens &&
             allDetectedTokens &&
-            allDetectedTokens[interactingChainId] &&
-            allDetectedTokens[interactingChainId][userAddressToAddTokens])) {
-        const networkDetectedTokens = allDetectedTokens[interactingChainId];
+            allDetectedTokens[chainIdToAddTokens] &&
+            allDetectedTokens[chainIdToAddTokens][userAddressToAddTokens])) {
+        const networkDetectedTokens = allDetectedTokens[chainIdToAddTokens];
         const newDetectedNetworkTokens = {
             ...networkDetectedTokens,
             ...{ [userAddressToAddTokens]: newDetectedTokens },
         };
         newAllDetectedTokens = {
             ...allDetectedTokens,
-            ...{ [interactingChainId]: newDetectedNetworkTokens },
+            ...{ [chainIdToAddTokens]: newDetectedNetworkTokens },
         };
     }
     return { newAllTokens, newAllIgnoredTokens, newAllDetectedTokens };
diff --git a/node_modules/@metamask/assets-controllers/dist/TokensController.d.cts b/node_modules/@metamask/assets-controllers/dist/TokensController.d.cts
index bc081ba..8444407 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokensController.d.cts
+++ b/node_modules/@metamask/assets-controllers/dist/TokensController.d.cts
@@ -1,4 +1,4 @@
-import type { AccountsControllerGetAccountAction, AccountsControllerGetSelectedAccountAction, AccountsControllerSelectedEvmAccountChangeEvent } from "@metamask/accounts-controller";
+import type { AccountsControllerAccountRemovedEvent, AccountsControllerListAccountsAction, AccountsControllerGetAccountAction, AccountsControllerGetSelectedAccountAction, AccountsControllerSelectedEvmAccountChangeEvent } from "@metamask/accounts-controller";
 import type { AddApprovalRequest } from "@metamask/approval-controller";
 import type { RestrictedMessenger, ControllerGetStateAction, ControllerStateChangeEvent } from "@metamask/base-controller";
 import { BaseController } from "@metamask/base-controller";
@@ -41,10 +41,10 @@ export type TokensControllerAddDetectedTokensAction = {
 /**
  * The external actions available to the {@link TokensController}.
  */
-export type AllowedActions = AddApprovalRequest | NetworkControllerGetNetworkClientByIdAction | AccountsControllerGetAccountAction | AccountsControllerGetSelectedAccountAction;
+export type AllowedActions = AddApprovalRequest | NetworkControllerGetNetworkClientByIdAction | AccountsControllerGetAccountAction | AccountsControllerGetSelectedAccountAction | AccountsControllerListAccountsAction;
 export type TokensControllerStateChangeEvent = ControllerStateChangeEvent<typeof controllerName, TokensControllerState>;
 export type TokensControllerEvents = TokensControllerStateChangeEvent;
-export type AllowedEvents = NetworkControllerStateChangeEvent | NetworkControllerNetworkDidChangeEvent | TokenListStateChange | AccountsControllerSelectedEvmAccountChangeEvent;
+export type AllowedEvents = NetworkControllerStateChangeEvent | NetworkControllerNetworkDidChangeEvent | TokenListStateChange | AccountsControllerSelectedEvmAccountChangeEvent | AccountsControllerAccountRemovedEvent;
 /**
  * The messenger of the {@link TokensController}.
  */
@@ -63,7 +63,7 @@ export declare class TokensController extends BaseController<typeof controllerNa
      * @param options.state - Initial state to set on this controller.
      * @param options.messenger - The messenger.
      */
-    constructor({ provider, state, messenger, }: {
+    constructor({ chainId: initialChainId, provider, state, messenger, }: {
         chainId: Hex;
         provider: Provider;
         state?: Partial<TokensControllerState>;
@@ -89,7 +89,7 @@ export declare class TokensController extends BaseController<typeof controllerNa
         name?: string;
         image?: string;
         interactingAddress?: string;
-        networkClientId: NetworkClientId;
+        networkClientId?: NetworkClientId;
     }): Promise<Token[]>;
     /**
      * Add a batch of tokens.
@@ -97,14 +97,14 @@ export declare class TokensController extends BaseController<typeof controllerNa
      * @param tokensToImport - Array of tokens to import.
      * @param networkClientId - Optional network client ID used to determine interacting chain ID.
      */
-    addTokens(tokensToImport: Token[], networkClientId: NetworkClientId): Promise<void>;
+    addTokens(tokensToImport: Token[], networkClientId?: NetworkClientId): Promise<void>;
     /**
      * Ignore a batch of tokens.
      *
      * @param tokenAddressesToIgnore - Array of token addresses to ignore.
      * @param networkClientId - Optional network client ID used to determine interacting chain ID.
      */
-    ignoreTokens(tokenAddressesToIgnore: string[], networkClientId: NetworkClientId): void;
+    ignoreTokens(tokenAddressesToIgnore: string[], networkClientId?: NetworkClientId): void;
     /**
      * Adds a batch of detected tokens to the stored token list.
      *
@@ -113,8 +113,8 @@ export declare class TokensController extends BaseController<typeof controllerNa
      * @param detectionDetails.selectedAddress - the account address on which the incomingDetectedTokens were detected.
      * @param detectionDetails.chainId - the chainId on which the incomingDetectedTokens were detected.
      */
-    addDetectedTokens(incomingDetectedTokens: Token[], detectionDetails: {
-        selectedAddress?: string;
+    addDetectedTokens(incomingDetectedTokens: Token[], detectionDetails?: {
+        selectedAddress: string;
         chainId: Hex;
     }): Promise<void>;
     /**
@@ -122,10 +122,9 @@ export declare class TokensController extends BaseController<typeof controllerNa
      * were previously added which do not yet had isERC721 field.
      *
      * @param tokenAddress - The contract address of the token requiring the isERC721 field added.
-     * @param networkClientId - The network client ID of the network on which the token is detected.
      * @returns The new token object with the added isERC721 field.
      */
-    updateTokenType(tokenAddress: string, networkClientId: NetworkClientId): Promise<{
+    updateTokenType(tokenAddress: string): Promise<{
         isERC721: any;
         address: string;
         decimals: number;
@@ -150,7 +149,7 @@ export declare class TokensController extends BaseController<typeof controllerNa
         asset: Token;
         type: string;
         interactingAddress?: string;
-        networkClientId: NetworkClientId;
+        networkClientId?: NetworkClientId;
     }): Promise<void>;
     /**
      * Removes all tokens from the ignored list.
