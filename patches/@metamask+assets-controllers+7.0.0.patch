diff --git a/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.js b/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.js
index 130e3dc..137f2f7 100644
--- a/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.js
+++ b/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.js
@@ -30,7 +30,7 @@ class AccountTrackerController extends base_controller_1.BaseController {
      * @param config - Initial options used to configure this controller.
      * @param state - Initial state to set on this controller.
      */
-    constructor({ onPreferencesStateChange, getIdentities, }, config, state) {
+    constructor({ onPreferencesStateChange, getIdentities, getSelectedAddress, getMultiAccountBalancesEnabled, }, config, state) {
         super(config, state);
         this.mutex = new async_mutex_1.Mutex();
         /**
@@ -38,16 +38,28 @@ class AccountTrackerController extends base_controller_1.BaseController {
          */
         this.name = 'AccountTrackerController';
         /**
-         * Refreshes all accounts in the current keychain.
+         * Refreshes the balances of the accounts depending on the multi-account setting.
+         * If multi-account is disabled, only updates the selected account balance.
+         * If multi-account is enabled, updates balances for all accounts.
+         *
+         * @async
          */
         this.refresh = () => __awaiter(this, void 0, void 0, function* () {
             this.syncAccounts();
             const accounts = Object.assign({}, this.state.accounts);
+            const isMultiAccountBalancesEnabled = this.getMultiAccountBalancesEnabled();
+            if (!isMultiAccountBalancesEnabled) {
+                const selectedAddress = this.getSelectedAddress();
+                const balance = yield this.getBalanceFromChain(selectedAddress);
+                if (!balance) return;
+                accounts[selectedAddress] = { balance: (0, controller_utils_1.BNToHex)(balance) };
+                this.update({ accounts });
+                return;
+            }
             for (const address in accounts) {
-                yield (0, controller_utils_1.safelyExecuteWithTimeout)(() => __awaiter(this, void 0, void 0, function* () {
-                    const balance = yield (0, controller_utils_1.query)(this.ethQuery, 'getBalance', [address]);
-                    accounts[address] = { balance: (0, controller_utils_1.BNToHex)(balance) };
-                }));
+                const balance = yield this.getBalanceFromChain(address);
+                if (!balance) continue;
+                accounts[address] = { balance: (0, controller_utils_1.BNToHex)(balance) };
             }
             this.update({ accounts });
         });
@@ -57,6 +69,8 @@ class AccountTrackerController extends base_controller_1.BaseController {
         this.defaultState = { accounts: {} };
         this.initialize();
         this.getIdentities = getIdentities;
+        this.getSelectedAddress = getSelectedAddress;
+        this.getMultiAccountBalancesEnabled = getMultiAccountBalancesEnabled;
         onPreferencesStateChange(() => {
             this.refresh();
         });
@@ -106,6 +120,22 @@ class AccountTrackerController extends base_controller_1.BaseController {
             }, this.config.interval);
         });
     }
+    /**
+     * Fetches the balance of a given address from the blockchain.
+     *
+     * @async
+     * @param {string} address - The account address to fetch the balance for.
+     * @returns {Promise<string>} - A promise that resolves to the balance in a hex string format.
+     */
+    getBalanceFromChain(address) {
+        return __awaiter(this, void 0, void 0, function* () {
+            let balance;
+            yield (0, controller_utils_1.safelyExecuteWithTimeout)(() => __awaiter(this, void 0, void 0, function* () {
+                balance = yield (0, controller_utils_1.query)(this.ethQuery, 'getBalance', [address]);
+            }));
+            return balance;
+        });
+    }
     /**
      * Sync accounts balances with some additional addresses.
      *
diff --git a/node_modules/@metamask/assets-controllers/dist/AssetsContractController.js b/node_modules/@metamask/assets-controllers/dist/AssetsContractController.js
index 332c87d..b634fde 100644
--- a/node_modules/@metamask/assets-controllers/dist/AssetsContractController.js
+++ b/node_modules/@metamask/assets-controllers/dist/AssetsContractController.js
@@ -33,6 +33,7 @@ exports.SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID = {
     [assetsUtil_1.SupportedTokenDetectionNetworks.bsc]: '0x2352c63A83f9Fd126af8676146721Fa00924d7e4',
     [assetsUtil_1.SupportedTokenDetectionNetworks.polygon]: '0x2352c63A83f9Fd126af8676146721Fa00924d7e4',
     [assetsUtil_1.SupportedTokenDetectionNetworks.avax]: '0xD023D153a0DFa485130ECFdE2FAA7e612EF94818',
+    [assetsUtil_1.SupportedTokenDetectionNetworks.aurora]: '0x1286415D333855237f89Df27D388127181448538',
 };
 exports.MISSING_PROVIDER_ERROR = 'AssetsContractController failed to set the provider correctly. A provider must be set for this method to be available';
 /**
@@ -116,6 +117,20 @@ class AssetsContractController extends base_controller_1.BaseController {
             return yield this.erc20Standard.getTokenDecimals(address);
         });
     }
+     /**
+   * Query for the decimals for a given ERC20 asset.
+   *
+   * @param address - ERC20 asset contract address.
+   * @returns Promise resolving to the 'decimals'.
+   */
+   getERC20TokenName(address) {
+    return __awaiter(this, void 0, void 0, function* () {
+        if (this.erc20Standard === undefined) {
+            throw new Error(MISSING_PROVIDER_ERROR);
+        }
+        return yield this.erc20Standard.getTokenName(address);
+    });
+  }
     /**
      * Enumerate assets assigned to an owner.
      *
diff --git a/node_modules/@metamask/assets-controllers/dist/NftController.js b/node_modules/@metamask/assets-controllers/dist/NftController.js
index 6a14075..c2662fb 100644
--- a/node_modules/@metamask/assets-controllers/dist/NftController.js
+++ b/node_modules/@metamask/assets-controllers/dist/NftController.js
@@ -55,8 +55,9 @@ class NftController extends base_controller_1.BaseController {
             selectedAddress: '',
             chainId: '',
             ipfsGateway: controller_utils_1.IPFS_DEFAULT_GATEWAY_URL,
-            openSeaEnabled: false,
+            displayNftMedia: true,
             useIPFSSubdomains: true,
+            isIpfsGatewayEnabled: true,
         };
         this.defaultState = {
             allNftContracts: {},
@@ -71,23 +72,19 @@ class NftController extends base_controller_1.BaseController {
         this.getERC1155BalanceOf = getERC1155BalanceOf;
         this.getERC1155TokenURI = getERC1155TokenURI;
         this.onNftAdded = onNftAdded;
-        onPreferencesStateChange(({ selectedAddress, ipfsGateway, openSeaEnabled }) => {
-            this.configure({ selectedAddress, ipfsGateway, openSeaEnabled });
+        onPreferencesStateChange(({ selectedAddress, ipfsGateway, displayNftMedia, isIpfsGatewayEnabled }) => {
+            this.configure({ selectedAddress, ipfsGateway, displayNftMedia, isIpfsGatewayEnabled });
         });
         onNetworkStateChange(({ providerConfig }) => {
             const { chainId } = providerConfig;
             this.configure({ chainId });
         });
     }
-    getNftApi({ contractAddress, tokenId, useProxy, }) {
-        return useProxy
-            ? `${controller_utils_1.OPENSEA_PROXY_URL}/asset/${contractAddress}/${tokenId}`
-            : `${controller_utils_1.OPENSEA_API_URL}/asset/${contractAddress}/${tokenId}`;
+    getNftApi({ contractAddress, tokenId }) {
+        return `${controller_utils_1.OPENSEA_PROXY_URL}/asset/${contractAddress}/${tokenId}`;
     }
-    getNftContractInformationApi({ contractAddress, useProxy, }) {
-        return useProxy
-            ? `${controller_utils_1.OPENSEA_PROXY_URL}/asset_contract/${contractAddress}`
-            : `${controller_utils_1.OPENSEA_API_URL}/asset_contract/${contractAddress}`;
+    getNftContractInformationApi({ contractAddress }) {
+        return  `${controller_utils_1.OPENSEA_PROXY_URL}/asset_contract/${contractAddress}`;
     }
     /**
      * Helper method to update nested state for allNfts and allNftContracts.
@@ -119,29 +116,15 @@ class NftController extends base_controller_1.BaseController {
      */
     getNftInformationFromApi(contractAddress, tokenId) {
         return __awaiter(this, void 0, void 0, function* () {
+            try{
             // Attempt to fetch the data with the proxy
             let nftInformation = yield (0, controller_utils_1.fetchWithErrorHandling)({
                 url: this.getNftApi({
                     contractAddress,
                     tokenId,
-                    useProxy: true,
                 }),
             });
-            // if an openSeaApiKey is set we should attempt to refetch calling directly to OpenSea
-            if (!nftInformation && this.openSeaApiKey) {
-                nftInformation = yield (0, controller_utils_1.fetchWithErrorHandling)({
-                    url: this.getNftApi({
-                        contractAddress,
-                        tokenId,
-                        useProxy: false,
-                    }),
-                    options: {
-                        headers: { 'X-API-KEY': this.openSeaApiKey },
-                    },
-                    // catch 403 errors (in case API key is down we don't want to blow up)
-                    errorCodesToCatch: [403],
-                });
-            }
+
             // if we were still unable to fetch the data we return out the default/null of `NftMetadata`
             if (!nftInformation) {
                 return {
@@ -159,6 +142,15 @@ class NftController extends base_controller_1.BaseController {
                 animationOriginal: animation_original_url,
             }, external_link && { externalLink: external_link }, last_sale && { lastSale: last_sale }, schema_name && { standard: schema_name });
             return nftMetadata;
+        }catch(error){
+                return {
+                    name: null,
+                    description: null,
+                    image: null,
+                    standard: null,
+                    error: 'Opensea import error'
+                };
+            }
         });
     }
     /**
@@ -170,13 +162,49 @@ class NftController extends base_controller_1.BaseController {
      */
     getNftInformationFromTokenURI(contractAddress, tokenId) {
         return __awaiter(this, void 0, void 0, function* () {
-            const { ipfsGateway, useIPFSSubdomains } = this.config;
+            const { ipfsGateway, useIPFSSubdomains, isIpfsGatewayEnabled, displayNftMedia } = this.config;
             const result = yield this.getNftURIAndStandard(contractAddress, tokenId);
             let tokenURI = result[0];
             const standard = result[1];
-            if (tokenURI.startsWith('ipfs://')) {
-                tokenURI = (0, assetsUtil_1.getFormattedIpfsUrl)(ipfsGateway, tokenURI, useIPFSSubdomains);
+
+            if(!displayNftMedia && !isIpfsGatewayEnabled){
+                return {
+                    image: null,
+                    name: null,
+                    description: null,
+                    standard: standard || null,
+                    favorite: false,
+                    tokenURI
+                };
             }
+
+            const hasIpfsTokenURI = tokenURI.startsWith('ipfs://');
+
+            if (hasIpfsTokenURI && !isIpfsGatewayEnabled) {
+                return {
+                    image: null,
+                    name: null,
+                    description: null,
+                    standard: standard || null,
+                    favorite: false,
+                    tokenURI: tokenURI ?? null,
+                };
+            }
+            if (hasIpfsTokenURI) {
+                tokenURI = assetsUtil_1.getFormattedIpfsUrl(ipfsGateway, tokenURI, useIPFSSubdomains);
+            }
+
+            if(!hasIpfsTokenURI && !displayNftMedia){
+                return {
+                    image: null,
+                    name: null,
+                    description: null,
+                    standard: standard || null,
+                    favorite: false,
+                    tokenURI: tokenURI ?? null,
+                };
+            }
+
             try {
                 const object = yield (0, controller_utils_1.handleFetch)(tokenURI);
                 // TODO: Check image_url existence. This is not part of EIP721 nor EIP1155
@@ -189,6 +217,7 @@ class NftController extends base_controller_1.BaseController {
                     description: object.description,
                     standard,
                     favorite: false,
+                    tokenURI
                 };
             }
             catch (_a) {
@@ -198,6 +227,8 @@ class NftController extends base_controller_1.BaseController {
                     description: null,
                     standard: standard || null,
                     favorite: false,
+                    tokenURI: tokenURI ?? null,
+                    error: 'URI import error'
                 };
             }
         });
@@ -255,12 +286,25 @@ class NftController extends base_controller_1.BaseController {
                 return yield this.getNftInformationFromTokenURI(contractAddress, tokenId);
             }));
             let openSeaMetadata;
-            if (this.config.openSeaEnabled) {
+            if (this.config.displayNftMedia) {
                 openSeaMetadata = yield (0, controller_utils_1.safelyExecute)(() => __awaiter(this, void 0, void 0, function* () {
                     return yield this.getNftInformationFromApi(contractAddress, tokenId);
                 }));
             }
-            return Object.assign(Object.assign({}, openSeaMetadata), { name: (_b = (_a = blockchainMetadata.name) !== null && _a !== void 0 ? _a : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.name) !== null && _b !== void 0 ? _b : null, description: (_d = (_c = blockchainMetadata.description) !== null && _c !== void 0 ? _c : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.description) !== null && _d !== void 0 ? _d : null, image: (_f = (_e = blockchainMetadata.image) !== null && _e !== void 0 ? _e : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.image) !== null && _f !== void 0 ? _f : null, standard: (_h = (_g = blockchainMetadata.standard) !== null && _g !== void 0 ? _g : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.standard) !== null && _h !== void 0 ? _h : null });
+      
+            if(blockchainMetadata.error && openSeaMetadata.error){
+                return {
+                    image: null,
+                    name: null,
+                    description: null,
+                    standard: blockchainMetadata.standard ?? null,
+                    favorite: false,
+                    tokenURI: blockchainMetadata.tokenURI ?? null,
+                    error: 'Both import failed'
+                }
+            }
+          
+            return Object.assign(Object.assign({}, openSeaMetadata), { tokenURI: (_b = (_a = blockchainMetadata.tokenURI) !== null && _a !== void 0 ? _a : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.tokenURI) !== null && _b !== void 0 ? _b : null,error: (_b = (_a = blockchainMetadata.error) !== null && _a !== void 0 ? _a : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.error) !== null && _b !== void 0 ? _b : null, name: (_b = (_a = blockchainMetadata.name) !== null && _a !== void 0 ? _a : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.name) !== null && _b !== void 0 ? _b : null, description: (_d = (_c = blockchainMetadata.description) !== null && _c !== void 0 ? _c : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.description) !== null && _d !== void 0 ? _d : null, image: (_f = (_e = blockchainMetadata.image) !== null && _e !== void 0 ? _e : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.image) !== null && _f !== void 0 ? _f : null, standard: (_h = (_g = blockchainMetadata.standard) !== null && _g !== void 0 ? _g : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.standard) !== null && _h !== void 0 ? _h : null });
         });
     }
     /**
@@ -272,34 +316,15 @@ class NftController extends base_controller_1.BaseController {
     getNftContractInformationFromApi(contractAddress) {
         return __awaiter(this, void 0, void 0, function* () {
             /* istanbul ignore if */
-            let apiNftContractObject = yield (0, controller_utils_1.fetchWithErrorHandling)({
+            const apiNftContractObject = yield (0, controller_utils_1.fetchWithErrorHandling)({
                 url: this.getNftContractInformationApi({
                     contractAddress,
-                    useProxy: true,
                 }),
             });
             // if we successfully fetched return the fetched data immediately
             if (apiNftContractObject) {
                 return apiNftContractObject;
             }
-            // if we were unsuccessful in fetching from the API and an OpenSea API key is present
-            // attempt to refetch directly against the OpenSea API and if successful return the data immediately
-            if (this.openSeaApiKey) {
-                apiNftContractObject = yield (0, controller_utils_1.fetchWithErrorHandling)({
-                    url: this.getNftContractInformationApi({
-                        contractAddress,
-                        useProxy: false,
-                    }),
-                    options: {
-                        headers: { 'X-API-KEY': this.openSeaApiKey },
-                    },
-                    // catch 403 errors (in case API key is down we don't want to blow up)
-                    errorCodesToCatch: [403],
-                });
-                if (apiNftContractObject) {
-                    return apiNftContractObject;
-                }
-            }
             // If we've reached this point we were unable to fetch data from either the proxy or opensea so we return
             // the default/null of ApiNftContract
             return {
@@ -347,7 +372,7 @@ class NftController extends base_controller_1.BaseController {
                 return yield this.getNftContractInformationFromContract(contractAddress);
             }));
             let openSeaContractData;
-            if (this.config.openSeaEnabled) {
+            if (this.config.displayNftMedia) {
                 openSeaContractData = yield (0, controller_utils_1.safelyExecute)(() => __awaiter(this, void 0, void 0, function* () {
                     return yield this.getNftContractInformationFromApi(contractAddress);
                 }));
@@ -428,6 +453,7 @@ class NftController extends base_controller_1.BaseController {
                         tokenId: tokenId.toString(),
                         standard: nftMetadata.standard,
                         source: detection ? 'detected' : 'custom',
+                        tokenURI: nftMetadata.tokenURI
                     });
                 }
                 return newNfts;
diff --git a/node_modules/@metamask/assets-controllers/dist/NftDetectionController.js b/node_modules/@metamask/assets-controllers/dist/NftDetectionController.js
index 1f234ca..ef2b7e7 100644
--- a/node_modules/@metamask/assets-controllers/dist/NftDetectionController.js
+++ b/node_modules/@metamask/assets-controllers/dist/NftDetectionController.js
@@ -94,19 +94,6 @@ class NftDetectionController extends base_controller_1.BaseController {
                     url: this.getOwnerNftApi({ address, offset, useProxy: true }),
                     timeout: 15000,
                 });
-                if (openSeaApiKey && !nftApiResponse) {
-                    nftApiResponse = yield (0, controller_utils_1.fetchWithErrorHandling)({
-                        url: this.getOwnerNftApi({
-                            address,
-                            offset,
-                            useProxy: false,
-                        }),
-                        options: { headers: { 'X-API-KEY': openSeaApiKey } },
-                        timeout: 15000,
-                        // catch 403 errors (in case API key is down we don't want to blow up)
-                        errorCodesToCatch: [403],
-                    });
-                }
                 if (!nftApiResponse) {
                     return nfts;
                 }
diff --git a/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.js b/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.js
index 9ddbc28..b9f309a 100644
--- a/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.js
+++ b/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.js
@@ -14,6 +14,7 @@ const contracts_1 = require("@ethersproject/contracts");
 const metamask_eth_abis_1 = require("@metamask/metamask-eth-abis");
 const ethereumjs_util_1 = require("ethereumjs-util");
 const abi_utils_1 = require("@metamask/abi-utils");
+
 const controller_utils_1 = require("@metamask/controller-utils");
 const utils_1 = require("@metamask/utils");
 const assetsUtil_1 = require("../assetsUtil");
@@ -57,6 +58,27 @@ class ERC20Standard {
             }
         });
     }
+    /**
+     * Query for the name for a given ERC20 asset.
+     *
+     * @param address - ERC20 asset contract string.
+     * @returns Promise resolving to the 'name'.
+     */
+    getTokenName(address){
+        return __awaiter(this, void 0, void 0, function* () {
+            const contract = new contracts_1.Contract(address, metamask_eth_abis_1.abiERC20, this.provider);
+            try {
+                const name = yield contract.name();
+                return name.toString();
+            } catch (err) {
+            // Mirror previous implementation
+            if (err.message.includes('call revert exception')) {
+                throw new Error('Failed to parse token name');
+            }
+            throw err;
+            }
+        });
+    }
     /**
      * Query for symbol for a given ERC20 asset.
      *
@@ -83,7 +105,8 @@ class ERC20Standard {
             try {
                 const utf8 = (0, ethereumjs_util_1.toUtf8)(result);
                 if (utf8.length > 0) {
-                    return utf8;
+                    // This utf8 returns unicode characters, wee need to replace it
+                    return utf8.replace(/[\u0000\u0003\u0020]/g, '');
                 }
             }
             catch (_b) {
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.js b/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.js
index 4ed4990..df0524b 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.js
+++ b/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.js
@@ -34,7 +34,7 @@ class TokenDetectionController extends base_controller_1.BaseController {
      * @param config - Initial options used to configure this controller.
      * @param state - Initial state to set on this controller.
      */
-    constructor({ onPreferencesStateChange, onNetworkStateChange, onTokenListStateChange, getBalancesInSingleCall, addDetectedTokens, getTokenListState, getTokensState, getNetworkState, getPreferencesState, }, config, state) {
+    constructor({ onPreferencesStateChange, onNetworkStateChange, onTokenListStateChange, getBalancesInSingleCall, addDetectedTokens, updateTokensName, getTokenListState, getTokensState, getNetworkState, getPreferencesState, }, config, state) {
         const { providerConfig: { chainId: defaultChainId }, } = getNetworkState();
         const { useTokenDetection: defaultUseTokenDetection } = getPreferencesState();
         super(config, state);
@@ -45,6 +45,7 @@ class TokenDetectionController extends base_controller_1.BaseController {
         this.defaultConfig = Object.assign({ interval: DEFAULT_INTERVAL, selectedAddress: '', disabled: true, chainId: defaultChainId, isDetectionEnabledFromPreferences: defaultUseTokenDetection, isDetectionEnabledForNetwork: (0, assetsUtil_1.isTokenDetectionSupportedForNetwork)(defaultChainId) }, config);
         this.initialize();
         this.getTokensState = getTokensState;
+        this.updateTokensName = updateTokensName;
         this.getTokenListState = getTokenListState;
         this.addDetectedTokens = addDetectedTokens;
         this.getBalancesInSingleCall = getBalancesInSingleCall;
@@ -128,16 +129,24 @@ class TokenDetectionController extends base_controller_1.BaseController {
                 return;
             }
             const { tokens } = this.getTokensState();
+
             const { selectedAddress, chainId } = this.config;
             const tokensAddresses = tokens.map(
             /* istanbul ignore next*/ (token) => token.address.toLowerCase());
             const { tokenList } = this.getTokenListState();
+
+            if (tokens.length && !tokens[0].name) {
+                this.updateTokensName(tokenList);
+            }
+
             const tokensToDetect = [];
             for (const address in tokenList) {
                 if (!tokensAddresses.includes(address)) {
                     tokensToDetect.push(address);
                 }
             }
+
+
             const sliceOfTokensToDetect = [];
             sliceOfTokensToDetect[0] = tokensToDetect.slice(0, 1000);
             sliceOfTokensToDetect[1] = tokensToDetect.slice(1000, tokensToDetect.length - 1);
@@ -161,7 +170,7 @@ class TokenDetectionController extends base_controller_1.BaseController {
                         }
                         const caseInsensitiveTokenKey = Object.keys(tokenList).find((i) => i.toLowerCase() === tokenAddress.toLowerCase()) || '';
                         if (ignored === undefined) {
-                            const { decimals, symbol, aggregators, iconUrl } = tokenList[caseInsensitiveTokenKey];
+                            const { decimals, symbol, aggregators, iconUrl, name } = tokenList[caseInsensitiveTokenKey];
                             tokensToAdd.push({
                                 address: tokenAddress,
                                 decimals,
@@ -169,6 +178,7 @@ class TokenDetectionController extends base_controller_1.BaseController {
                                 aggregators,
                                 image: iconUrl,
                                 isERC721: false,
+                                name
                             });
                         }
                     }
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenRatesController.d.ts b/node_modules/@metamask/assets-controllers/dist/TokenRatesController.d.ts
index 8bb7c20..810d961 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenRatesController.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/TokenRatesController.d.ts
@@ -1,7 +1,8 @@
-import { BaseController, BaseConfig, BaseState } from '@metamask/base-controller';
+import type { BaseConfig, BaseState } from '@metamask/base-controller';
+import { BaseController } from '@metamask/base-controller';
 import type { NetworkState } from '@metamask/network-controller';
+import type { PreferencesState } from '@metamask/preferences-controller';
 import type { TokensState } from './TokensController';
-import type { CurrencyRateState } from './CurrencyRateController';
 /**
  * @type CoinGeckoResponse
  *
@@ -40,6 +41,7 @@ export interface Token {
     image?: string;
     balanceError?: unknown;
     isERC721?: boolean;
+    name?: string;
 }
 /**
  * @type TokenRatesConfig
@@ -55,7 +57,17 @@ export interface TokenRatesConfig extends BaseConfig {
     interval: number;
     nativeCurrency: string;
     chainId: string;
-    tokens: Token[];
+    selectedAddress: string;
+    allTokens: {
+        [chainId: string]: {
+            [key: string]: Token[];
+        };
+    };
+    allDetectedTokens: {
+        [chainId: string]: {
+            [key: string]: Token[];
+        };
+    };
     threshold: number;
 }
 interface ContractExchangeRates {
@@ -76,6 +88,7 @@ export interface TokenRatesState extends BaseState {
  * for tokens stored in the TokensController
  */
 export declare class TokenRatesController extends BaseController<TokenRatesConfig, TokenRatesState> {
+    #private;
     private handle?;
     private tokenList;
     private supportedChains;
@@ -88,41 +101,32 @@ export declare class TokenRatesController extends BaseController<TokenRatesConfi
      * Creates a TokenRatesController instance.
      *
      * @param options - The controller options.
+     * @param options.chainId - The chain ID of the current network.
+     * @param options.ticker - The ticker for the current network.
+     * @param options.selectedAddress - The current selected address.
+     * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.
      * @param options.onTokensStateChange - Allows subscribing to token controller state changes.
-     * @param options.onCurrencyRateStateChange - Allows subscribing to currency rate controller state changes.
      * @param options.onNetworkStateChange - Allows subscribing to network state changes.
      * @param config - Initial options used to configure this controller.
      * @param state - Initial state to set on this controller.
      */
-    constructor({ onTokensStateChange, onCurrencyRateStateChange, onNetworkStateChange, }: {
+    constructor({ chainId: initialChainId, ticker: initialTicker, selectedAddress: initialSelectedAddress, onPreferencesStateChange, onTokensStateChange, onNetworkStateChange, }: {
+        chainId: string;
+        ticker: string;
+        selectedAddress: string;
+        coinGeckoHeader: string;
+        onPreferencesStateChange: (listener: (preferencesState: PreferencesState) => void) => void;
         onTokensStateChange: (listener: (tokensState: TokensState) => void) => void;
-        onCurrencyRateStateChange: (listener: (currencyRateState: CurrencyRateState) => void) => void;
         onNetworkStateChange: (listener: (networkState: NetworkState) => void) => void;
     }, config?: Partial<TokenRatesConfig>, state?: Partial<TokenRatesState>);
     /**
-     * Sets a new polling interval.
-     *
-     * @param interval - Polling interval used to fetch new token rates.
+     * Start (or restart) polling.
      */
-    poll(interval?: number): Promise<void>;
+    start(): Promise<void>;
     /**
-     * Sets a new chainId.
-     *
-     * TODO: Replace this with a method.
-     *
-     * @param _chainId - The current chain ID.
-     */
-    set chainId(_chainId: string);
-    get chainId(): string;
-    /**
-     * Sets a new token list to track prices.
-     *
-     * TODO: Replace this with a method.
-     *
-     * @param tokens - List of tokens to track exchange rates for.
+     * Stop polling.
      */
-    set tokens(tokens: Token[]);
-    get tokens(): Token[];
+    stop(): void;
     /**
      * Fetches a pairs of token address and native currency.
      *
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenRatesController.js b/node_modules/@metamask/assets-controllers/dist/TokenRatesController.js
index e3f81e9..82c3dc0 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenRatesController.js
+++ b/node_modules/@metamask/assets-controllers/dist/TokenRatesController.js
@@ -8,38 +8,387 @@ var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, ge
         step((generator = generator.apply(thisArg, _arguments || [])).next());
     });
 };
+var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
+    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
+};
+var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
+    if (kind === "m") throw new TypeError("Private method is not writable");
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
+    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
+};
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+var _TokenRatesController_instances, _TokenRatesController_pollState, _TokenRatesController_updateTokenList, _TokenRatesController_stopPoll, _TokenRatesController_poll;
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.TokenRatesController = void 0;
 const base_controller_1 = require("@metamask/base-controller");
 const controller_utils_1 = require("@metamask/controller-utils");
+const fast_deep_equal_1 = __importDefault(require("fast-deep-equal"));
 const crypto_compare_1 = require("./crypto-compare");
-const CoinGeckoApi = {
-    BASE_URL: 'https://api.coingecko.com/api/v3',
-    getTokenPriceURL(chainSlug, query) {
-        return `${this.BASE_URL}/simple/token_price/${chainSlug}?${query}`;
+var PollState;
+(function (PollState) {
+    PollState["Active"] = "Active";
+    PollState["Inactive"] = "Inactive";
+})(PollState || (PollState = {}));
+
+
+const CURRENCY_PRICE_API_CURRENCIES_SUPPORTED = {
+    btc: {
+      name: 'Bitcoin',
+      ticker: 'btc',
+      currencyType: 'crypto',
     },
-    getPlatformsURL() {
-        return `${this.BASE_URL}/asset_platforms`;
+    eth: {
+      name: 'Ether',
+      ticker: 'eth',
+      currencyType: 'crypto',
     },
-    getSupportedVsCurrencies() {
-        return `${this.BASE_URL}/simple/supported_vs_currencies`;
+    ltc: {
+      name: 'Litecoin',
+      ticker: 'ltc',
+      currencyType: 'crypto',
     },
-};
-/**
- * Finds the chain slug in the data array given a chainId.
- *
- * @param chainId - The current chain ID.
- * @param data - A list platforms supported by the CoinGecko API.
- * @returns The CoinGecko slug for the given chain ID, or `null` if the slug was not found.
- */
-function findChainSlug(chainId, data) {
-    var _a;
-    if (!data) {
-        return null;
-    }
-    const chain = (_a = data.find(({ chain_identifier }) => chain_identifier !== null && String(chain_identifier) === chainId)) !== null && _a !== void 0 ? _a : null;
-    return (chain === null || chain === void 0 ? void 0 : chain.id) || null;
-}
+    bch: {
+      name: 'Bitcoin Cash',
+      ticker: 'bch',
+      currencyType: 'crypto',
+    },
+    bnb: {
+      name: 'Binance Coin',
+      ticker: 'bnb',
+      currencyType: 'crypto',
+    },
+    eos: {
+      name: 'EOS',
+      ticker: 'eos',
+      currencyType: 'crypto',
+    },
+    xrp: {
+      name: 'XRP',
+      ticker: 'xrp',
+      currencyType: 'crypto',
+    },
+    xlm: {
+      name: 'Lumens',
+      ticker: 'xlm',
+      currencyType: 'crypto',
+    },
+    link: {
+      name: 'Chainlink',
+      ticker: 'link',
+      currencyType: 'crypto',
+    },
+    dot: {
+      name: 'Polkadot',
+      ticker: 'dot',
+      currencyType: 'crypto',
+    },
+    yfi: {
+      name: 'Yearn.finance',
+      ticker: 'yfi',
+      currencyType: 'crypto',
+    },
+    usd: {
+      name: 'US Dollar',
+      ticker: 'usd',
+      value: 1,
+      currencyType: 'fiat',
+    },
+    aed: {
+      name: 'United Arab Emirates Dirham',
+      ticker: 'aed',
+      currencyType: 'fiat',
+    },
+    ars: {
+      name: 'Argentine Peso',
+      ticker: 'ars',
+      currencyType: 'fiat',
+    },
+    aud: {
+      name: 'Australian Dollar',
+      ticker: 'aud',
+      currencyType: 'fiat',
+    },
+    bdt: {
+      name: 'Bangladeshi Taka',
+      ticker: 'bdt',
+      currencyType: 'fiat',
+    },
+    bhd: {
+      name: 'Bahraini Dinar',
+      ticker: 'bhd',
+      currencyType: 'fiat',
+    },
+    bmd: {
+      name: 'Bermudian Dollar',
+      ticker: 'bmd',
+      currencyType: 'fiat',
+    },
+    brl: {
+      name: 'Brazil Real',
+      ticker: 'brl',
+      currencyType: 'fiat',
+    },
+    cad: {
+      name: 'Canadian Dollar',
+      ticker: 'cad',
+      currencyType: 'fiat',
+    },
+    chf: {
+      name: 'Swiss Franc',
+      ticker: 'chf',
+      currencyType: 'fiat',
+    },
+    clp: {
+      name: 'Chilean Peso',
+      ticker: 'clp',
+      currencyType: 'fiat',
+    },
+    cny: {
+      name: 'Chinese Yuan',
+      ticker: 'cny',
+      currencyType: 'fiat',
+    },
+    czk: {
+      name: 'Czech Koruna',
+      ticker: 'czk',
+      currencyType: 'fiat',
+    },
+    dkk: {
+      name: 'Danish Krone',
+      ticker: 'dkk',
+      currencyType: 'fiat',
+    },
+    eur: {
+      name: 'Euro',
+      ticker: 'eur',
+      currencyType: 'fiat',
+    },
+    gbp: {
+      name: 'British Pound Sterling',
+      ticker: 'gbp',
+      currencyType: 'fiat',
+    },
+    hkd: {
+      name: 'Hong Kong Dollar',
+      ticker: 'hkd',
+      currencyType: 'fiat',
+    },
+    huf: {
+      name: 'Hungarian Forint',
+      ticker: 'huf',
+      currencyType: 'fiat',
+    },
+    idr: {
+      name: 'Indonesian Rupiah',
+      ticker: 'idr',
+      currencyType: 'fiat',
+    },
+    ils: {
+      name: 'Israeli New Shekel',
+      ticker: 'ils',
+      currencyType: 'fiat',
+    },
+    inr: {
+      name: 'Indian Rupee',
+      ticker: 'inr',
+      currencyType: 'fiat',
+    },
+    jpy: {
+      name: 'Japanese Yen',
+      ticker: 'jpy',
+      currencyType: 'fiat',
+    },
+    krw: {
+      name: 'South Korean Won',
+      ticker: 'krw',
+      currencyType: 'fiat',
+    },
+    kwd: {
+      name: 'Kuwaiti Dinar',
+      ticker: 'kwd',
+      currencyType: 'fiat',
+    },
+    lkr: {
+      name: 'Sri Lankan Rupee',
+      ticker: 'lkr',
+      currencyType: 'fiat',
+    },
+    mmk: {
+      name: 'Burmese Kyat',
+      ticker: 'mmk',
+      currencyType: 'fiat',
+    },
+    mxn: {
+      name: 'Mexican Peso',
+      ticker: 'mxn',
+      currencyType: 'fiat',
+    },
+    myr: {
+      name: 'Malaysian Ringgit',
+      ticker: 'myr',
+      currencyType: 'fiat',
+    },
+    ngn: {
+      name: 'Nigerian Naira',
+      ticker: 'ngn',
+      currencyType: 'fiat',
+    },
+    nok: {
+      name: 'Norwegian Krone',
+      ticker: 'nok',
+      currencyType: 'fiat',
+    },
+    nzd: {
+      name: 'New Zealand Dollar',
+      ticker: 'nzd',
+      currencyType: 'fiat',
+    },
+    php: {
+      name: 'Philippine Peso',
+      ticker: 'php',
+      currencyType: 'fiat',
+    },
+    pkr: {
+      name: 'Pakistani Rupee',
+      ticker: 'pkr',
+      currencyType: 'fiat',
+    },
+    pln: {
+      name: 'Polish Zloty',
+      ticker: 'pln',
+      currencyType: 'fiat',
+    },
+    rub: {
+      name: 'Russian Ruble',
+      ticker: 'rub',
+      currencyType: 'fiat',
+    },
+    sar: {
+      name: 'Saudi Riyal',
+      ticker: 'sar',
+      currencyType: 'fiat',
+    },
+    sek: {
+      name: 'Swedish Krona',
+      ticker: 'sek',
+      currencyType: 'fiat',
+    },
+    sgd: {
+      name: 'Singapore Dollar',
+      ticker: 'sgd',
+      currencyType: 'fiat',
+    },
+    thb: {
+      name: 'Thai Baht',
+      ticker: 'thb',
+      currencyType: 'fiat',
+    },
+    try: {
+      name: 'Turkish Lira',
+      ticker: 'try',
+      currencyType: 'fiat',
+    },
+    twd: {
+      name: 'New Taiwan Dollar',
+      ticker: 'twd',
+      currencyType: 'fiat',
+    },
+    uah: {
+      name: 'Ukrainian hryvnia',
+      ticker: 'uah',
+      currencyType: 'fiat',
+    },
+    vef: {
+      name: 'Venezuelan bolívar fuerte',
+      ticker: 'vef',
+      currencyType: 'fiat',
+    },
+    vnd: {
+      name: 'Vietnamese đồng',
+      ticker: 'vnd',
+      currencyType: 'fiat',
+    },
+    zar: {
+      name: 'South African Rand',
+      ticker: 'zar',
+      currencyType: 'fiat',
+    },
+    xdr: {
+      name: 'IMF Special Drawing Rights',
+      ticker: 'xdr',
+      currencyType: 'fiat',
+    },
+    xag: {
+      name: 'Silver - Troy Ounce',
+      ticker: 'xag',
+      currencyType: 'commodity',
+    },
+    xau: {
+      name: 'Gold - Troy Ounce',
+      ticker: 'xau',
+      currencyType: 'commodity',
+    },
+    bits: {
+      name: 'Bits',
+      ticker: 'bits',
+      currencyType: 'crypto',
+    },
+    sats: {
+      name: 'Satoshi',
+      ticker: 'sats',
+      currencyType: 'crypto',
+    },
+  };
+  
+  const CHAIN_ID_PRICE_API_SUPPORTED = {
+    1: 'ethereum',
+    10: 'optimistic-ethereum',
+    25: 'cronos',
+    56: 'binance-smart-chain',
+    57: 'syscoin',
+    66: 'okex-chain',
+    70: 'hoo-smart-chain',
+    82: 'meter',
+    88: 'tomochain',
+    100: 'xdai',
+    106: 'velas',
+    122: 'fuse',
+    128: 'huobi-token',
+    137: 'polygon-pos',
+    250: 'fantom',
+    288: 'boba',
+    321: 'kucoin-community-chain',
+    324: 'zksync',
+    361: 'theta',
+    1088: 'metis-andromeda',
+    1284: 'moonbeam',
+    1285: 'moonriver',
+    8453: 'base',
+    8545: 'shiden network',
+    10000: 'smartbch',
+    42161: 'arbitrum-one',
+    42220: 'celo',
+    42262: 'oasis',
+    43114: 'avalanche',
+    59144: 'linea',
+    333999: 'polis-chain',
+    1313161554: 'aurora',
+    1666600000: 'harmony-shard-0',
+  };
+  
+  const PriceApi = {
+    BASE_URL: 'https://price.api.cx.metamask.io',
+    getTokenPriceURL(chainId, query) {
+      return `${this.BASE_URL}/v2/chains/${chainId}/spot-prices?${query}`;
+    },
+  };
+
+
 /**
  * Controller that passively polls on a set interval for token-to-fiat exchange rates
  * for tokens stored in the TokensController
@@ -49,33 +398,40 @@ class TokenRatesController extends base_controller_1.BaseController {
      * Creates a TokenRatesController instance.
      *
      * @param options - The controller options.
+     * @param options.chainId - The chain ID of the current network.
+     * @param options.ticker - The ticker for the current network.
+     * @param options.selectedAddress - The current selected address.
+     * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.
      * @param options.onTokensStateChange - Allows subscribing to token controller state changes.
-     * @param options.onCurrencyRateStateChange - Allows subscribing to currency rate controller state changes.
      * @param options.onNetworkStateChange - Allows subscribing to network state changes.
      * @param config - Initial options used to configure this controller.
      * @param state - Initial state to set on this controller.
      */
-    constructor({ onTokensStateChange, onCurrencyRateStateChange, onNetworkStateChange, }, config, state) {
+    constructor({ chainId: initialChainId, ticker: initialTicker, selectedAddress: initialSelectedAddress, onPreferencesStateChange, onTokensStateChange, onNetworkStateChange, }, config, state) {
         super(config, state);
+        _TokenRatesController_instances.add(this);
         this.tokenList = [];
-        this.supportedChains = {
-            timestamp: 0,
-            data: null,
-        };
         this.supportedVsCurrencies = {
             timestamp: 0,
             data: [],
         };
+        this.supportedChains = {
+            timestamp: 0,
+            data: null,
+        };
+        _TokenRatesController_pollState.set(this, PollState.Inactive);
         /**
          * Name of this controller used during composition
          */
         this.name = 'TokenRatesController';
         this.defaultConfig = {
             disabled: false,
-            interval: 3 * 60 * 1000,
-            nativeCurrency: 'eth',
-            chainId: '',
-            tokens: [],
+            interval: 30 * 60 * 1000,
+            nativeCurrency: initialTicker,
+            chainId: initialChainId,
+            selectedAddress: initialSelectedAddress,
+            allTokens: {},
+            allDetectedTokens: {},
             threshold: 6 * 60 * 60 * 1000,
         };
         this.defaultState = {
@@ -85,60 +441,56 @@ class TokenRatesController extends base_controller_1.BaseController {
         if (config === null || config === void 0 ? void 0 : config.disabled) {
             this.configure({ disabled: true }, false, false);
         }
-        onTokensStateChange(({ tokens, detectedTokens }) => {
-            this.configure({ tokens: [...tokens, ...detectedTokens] });
-        });
-        onCurrencyRateStateChange((currencyRateState) => {
-            this.configure({ nativeCurrency: currencyRateState.nativeCurrency });
-        });
-        onNetworkStateChange(({ providerConfig }) => {
-            const { chainId } = providerConfig;
-            this.update({ contractExchangeRates: {} });
-            this.configure({ chainId });
-        });
-        this.poll();
+        __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_updateTokenList).call(this);
+        onPreferencesStateChange(({ selectedAddress }) => __awaiter(this, void 0, void 0, function* () {
+            if (this.config.selectedAddress !== selectedAddress) {
+                this.configure({ selectedAddress });
+                const isEqual = __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_updateTokenList).call(this);
+                if (__classPrivateFieldGet(this, _TokenRatesController_pollState, "f") === PollState.Active && !isEqual) {
+                    yield this.updateExchangeRates();
+                }
+            }
+        }));
+        onTokensStateChange(({ allTokens, allDetectedTokens }) => __awaiter(this, void 0, void 0, function* () {
+            // These two state properties are assumed to be immutable
+            if (this.config.allTokens !== allTokens ||
+                this.config.allDetectedTokens !== allDetectedTokens) {
+                this.configure({ allTokens, allDetectedTokens });
+                const isEqual = __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_updateTokenList).call(this);
+                if (__classPrivateFieldGet(this, _TokenRatesController_pollState, "f") === PollState.Active && !isEqual) {
+                    yield this.updateExchangeRates();
+                }
+            }
+        }));
+        onNetworkStateChange(({ providerConfig }) => __awaiter(this, void 0, void 0, function* () {
+            const { chainId, ticker } = providerConfig;
+            if (this.config.chainId !== chainId ||
+                this.config.nativeCurrency !== ticker) {
+                this.update({ contractExchangeRates: {} });
+                this.configure({ chainId, nativeCurrency: ticker || 'ETH' });
+                const isEqual = __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_updateTokenList).call(this);
+                if (__classPrivateFieldGet(this, _TokenRatesController_pollState, "f") === PollState.Active && !isEqual) {
+                    yield this.updateExchangeRates();
+                }
+            }
+        }));
     }
     /**
-     * Sets a new polling interval.
-     *
-     * @param interval - Polling interval used to fetch new token rates.
+     * Start (or restart) polling.
      */
-    poll(interval) {
+    start() {
         return __awaiter(this, void 0, void 0, function* () {
-            interval && this.configure({ interval }, false, false);
-            this.handle && clearTimeout(this.handle);
-            yield (0, controller_utils_1.safelyExecute)(() => this.updateExchangeRates());
-            this.handle = setTimeout(() => {
-                this.poll(this.config.interval);
-            }, this.config.interval);
+            __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_stopPoll).call(this);
+            __classPrivateFieldSet(this, _TokenRatesController_pollState, PollState.Active, "f");
+            yield __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_poll).call(this);
         });
     }
     /**
-     * Sets a new chainId.
-     *
-     * TODO: Replace this with a method.
-     *
-     * @param _chainId - The current chain ID.
-     */
-    set chainId(_chainId) {
-        !this.disabled && (0, controller_utils_1.safelyExecute)(() => this.updateExchangeRates());
-    }
-    get chainId() {
-        throw new Error('Property only used for setting');
-    }
-    /**
-     * Sets a new token list to track prices.
-     *
-     * TODO: Replace this with a method.
-     *
-     * @param tokens - List of tokens to track exchange rates for.
+     * Stop polling.
      */
-    set tokens(tokens) {
-        this.tokenList = tokens;
-        !this.disabled && (0, controller_utils_1.safelyExecute)(() => this.updateExchangeRates());
-    }
-    get tokens() {
-        throw new Error('Property only used for setting');
+    stop() {
+        __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_stopPoll).call(this);
+        __classPrivateFieldSet(this, _TokenRatesController_pollState, PollState.Inactive, "f");
     }
     /**
      * Fetches a pairs of token address and native currency.
@@ -147,56 +499,26 @@ class TokenRatesController extends base_controller_1.BaseController {
      * @param vsCurrency - Query according to tokens in tokenList and native currency.
      * @returns The exchange rates for the given pairs.
      */
-    fetchExchangeRate(chainSlug, vsCurrency) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const tokenPairs = this.tokenList.map((token) => token.address).join(',');
-            const query = `contract_addresses=${tokenPairs}&vs_currencies=${vsCurrency.toLowerCase()}`;
-            return (0, controller_utils_1.handleFetch)(CoinGeckoApi.getTokenPriceURL(chainSlug, query));
-        });
-    }
-    /**
-     * Checks if the current native currency is a supported vs currency to use
-     * to query for token exchange rates.
-     *
-     * @param nativeCurrency - The native currency of the currently active network.
-     * @returns A boolean indicating whether it's a supported vsCurrency.
-     */
-    checkIsSupportedVsCurrency(nativeCurrency) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const { threshold } = this.config;
-            const { timestamp, data } = this.supportedVsCurrencies;
-            const now = Date.now();
-            if (now - timestamp > threshold) {
-                const currencies = yield (0, controller_utils_1.handleFetch)(CoinGeckoApi.getSupportedVsCurrencies());
-                this.supportedVsCurrencies = {
-                    data: currencies,
-                    timestamp: Date.now(),
-                };
-                return currencies.includes(nativeCurrency.toLowerCase());
-            }
-            return data.includes(nativeCurrency.toLowerCase());
-        });
-    }
-    /**
-     * Gets current chain ID slug from cached supported platforms CoinGecko API response.
-     * If cached supported platforms response is stale, fetches and updates it.
-     *
-     * @returns The CoinGecko slug for the current chain ID.
-     */
-    getChainSlug() {
+    fetchExchangeRate(vsCurrency) {
         return __awaiter(this, void 0, void 0, function* () {
-            const { threshold, chainId } = this.config;
-            const { data, timestamp } = this.supportedChains;
-            const now = Date.now();
-            if (now - timestamp > threshold) {
-                const platforms = yield (0, controller_utils_1.handleFetch)(CoinGeckoApi.getPlatformsURL());
-                this.supportedChains = {
-                    data: platforms,
-                    timestamp: Date.now(),
-                };
-                return findChainSlug(chainId, platforms);
+            const { chainId } = this.config;
+            const tokenPairs = this.tokenList;
+            const tokenPairsChunks = (chunkSize) => tokenPairs.reduce((resultArray, item, index) => {
+                const chunkIndex = Math.floor(index / chunkSize);
+                if (!resultArray[chunkIndex]) {
+                    resultArray[chunkIndex] = [];
+                }
+                resultArray[chunkIndex].push(item);
+                return resultArray;
+            }, []);
+            const tokensPairsChunks = tokenPairsChunks(20);
+            const results = [];
+            for (const tokenPairsChunk of tokensPairsChunks) {
+                const query = `tokenAddresses=${tokenPairsChunk.join(',')}&vsCurrency=${vsCurrency.toLowerCase()}`;
+                const result = yield (0, controller_utils_1.handleFetch)(PriceApi.getTokenPriceURL(chainId, query));
+                results.push(result);
             }
-            return findChainSlug(chainId, data);
+            return results;
         });
     }
     /**
@@ -207,17 +529,20 @@ class TokenRatesController extends base_controller_1.BaseController {
             if (this.tokenList.length === 0 || this.disabled) {
                 return;
             }
-            const slug = yield this.getChainSlug();
+            const { chainId } = this.config;
             let newContractExchangeRates = {};
-            if (!slug) {
-                this.tokenList.forEach((token) => {
-                    const address = (0, controller_utils_1.toChecksumHexAddress)(token.address);
+            if (!Object.prototype.hasOwnProperty.call(
+                CHAIN_ID_PRICE_API_SUPPORTED,
+                chainId,
+              )) {
+                this.tokenList.forEach((tokenAddress) => {
+                    const address = (0, controller_utils_1.toChecksumHexAddress)(tokenAddress);
                     newContractExchangeRates[address] = undefined;
                 });
             }
             else {
                 const { nativeCurrency } = this.config;
-                newContractExchangeRates = yield this.fetchAndMapExchangeRates(nativeCurrency, slug);
+                newContractExchangeRates = yield this.fetchAndMapExchangeRates(nativeCurrency);
             }
             this.update({ contractExchangeRates: newContractExchangeRates });
         });
@@ -229,22 +554,26 @@ class TokenRatesController extends base_controller_1.BaseController {
      * to token/nativeCurrency.
      *
      * @param nativeCurrency - The native currency of the currently active network.
-     * @param slug - The unique slug used to id the chain by the coingecko api
      * should be used to query token exchange rates.
      * @returns An object with conversion rates for each token
      * related to the network's native currency.
      */
-    fetchAndMapExchangeRates(nativeCurrency, slug) {
+    fetchAndMapExchangeRates(nativeCurrency) {
         return __awaiter(this, void 0, void 0, function* () {
             const contractExchangeRates = {};
-            // check if native currency is supported as a vs_currency by the API
-            const nativeCurrencySupported = yield this.checkIsSupportedVsCurrency(nativeCurrency);
-            if (nativeCurrencySupported) {
+            if (this.tokenList.length === 0) {
+                return contractExchangeRates;
+            }
+            if (Object.prototype.hasOwnProperty.call(
+                CURRENCY_PRICE_API_CURRENCIES_SUPPORTED,
+                nativeCurrency.toLowerCase(),
+              )) {
                 // If it is we can do a simple fetch against the CoinGecko API
-                const prices = yield this.fetchExchangeRate(slug, nativeCurrency);
-                this.tokenList.forEach((token) => {
-                    const price = prices[token.address.toLowerCase()];
-                    contractExchangeRates[(0, controller_utils_1.toChecksumHexAddress)(token.address)] = price
+                const res = yield this.fetchExchangeRate(nativeCurrency);
+                const prices = Object.assign({}, ...res);
+                this.tokenList.forEach((tokenAddress) => {
+                    const price = prices[tokenAddress.toLowerCase()];
+                    contractExchangeRates[(0, controller_utils_1.toChecksumHexAddress)(tokenAddress)] = price
                         ? price[nativeCurrency.toLowerCase()]
                         : 0;
                 });
@@ -252,14 +581,14 @@ class TokenRatesController extends base_controller_1.BaseController {
             else {
                 // if native currency is not supported we need to use a fallback vsCurrency, get the exchange rates
                 // in token/fallback-currency format and convert them to expected token/nativeCurrency format.
-                let tokenExchangeRates;
+                let tokenExchangeRatesResponse;
                 let vsCurrencyToNativeCurrencyConversionRate = 0;
                 try {
                     [
-                        tokenExchangeRates,
+                        tokenExchangeRatesResponse,
                         { conversionRate: vsCurrencyToNativeCurrencyConversionRate },
                     ] = yield Promise.all([
-                        this.fetchExchangeRate(slug, controller_utils_1.FALL_BACK_VS_CURRENCY),
+                        this.fetchExchangeRate(controller_utils_1.FALL_BACK_VS_CURRENCY),
                         (0, crypto_compare_1.fetchExchangeRate)(nativeCurrency, controller_utils_1.FALL_BACK_VS_CURRENCY, false),
                     ]);
                 }
@@ -270,8 +599,10 @@ class TokenRatesController extends base_controller_1.BaseController {
                     }
                     throw error;
                 }
+                const tokenExchangeRates = Object.assign({}, ...tokenExchangeRatesResponse);
                 for (const [tokenAddress, conversion] of Object.entries(tokenExchangeRates)) {
-                    const tokenToVsCurrencyConversionRate = conversion[controller_utils_1.FALL_BACK_VS_CURRENCY.toLowerCase()];
+                    const conversionTyped = conversion;
+                    const tokenToVsCurrencyConversionRate = conversionTyped[controller_utils_1.FALL_BACK_VS_CURRENCY.toLowerCase()];
                     contractExchangeRates[(0, controller_utils_1.toChecksumHexAddress)(tokenAddress)] =
                         tokenToVsCurrencyConversionRate *
                             vsCurrencyToNativeCurrencyConversionRate;
@@ -282,5 +613,29 @@ class TokenRatesController extends base_controller_1.BaseController {
     }
 }
 exports.TokenRatesController = TokenRatesController;
+_TokenRatesController_pollState = new WeakMap(), _TokenRatesController_instances = new WeakSet(), _TokenRatesController_updateTokenList = function _TokenRatesController_updateTokenList() {
+    var _a, _b;
+    const { allTokens, allDetectedTokens } = this.config;
+    const oldTokenList = this.tokenList;
+    const tokens = ((_a = allTokens[this.config.chainId]) === null || _a === void 0 ? void 0 : _a[this.config.selectedAddress]) || [];
+    const detectedTokens = ((_b = allDetectedTokens[this.config.chainId]) === null || _b === void 0 ? void 0 : _b[this.config.selectedAddress]) ||
+        [];
+    const newTokenList = [...tokens, ...detectedTokens].map((token) => token.address);
+    this.tokenList = newTokenList;
+    return (0, fast_deep_equal_1.default)(oldTokenList, newTokenList);
+}, _TokenRatesController_stopPoll = function _TokenRatesController_stopPoll() {
+    if (this.handle) {
+        clearTimeout(this.handle);
+    }
+}, _TokenRatesController_poll = function _TokenRatesController_poll() {
+    return __awaiter(this, void 0, void 0, function* () {
+        yield (0, controller_utils_1.safelyExecute)(() => this.updateExchangeRates());
+        // Poll using recursive `setTimeout` instead of `setInterval` so that
+        // requests don't stack if they take longer than the polling interval
+        this.handle = setTimeout(() => {
+            __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_poll).call(this);
+        }, this.config.interval);
+    });
+};
 exports.default = TokenRatesController;
 //# sourceMappingURL=TokenRatesController.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/TokensController.js b/node_modules/@metamask/assets-controllers/dist/TokensController.js
index 0e03b88..bd7ddbd 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokensController.js
+++ b/node_modules/@metamask/assets-controllers/dist/TokensController.js
@@ -49,8 +49,9 @@ class TokensController extends base_controller_1.BaseController {
      * @param options.config - Initial options used to configure this controller.
      * @param options.state - Initial state to set on this controller.
      * @param options.messenger - The controller messenger.
+     * @param options.getERC20TokenName - Allows fetch an ERC-20 token name
      */
-    constructor({ onPreferencesStateChange, onNetworkStateChange, config, state, messenger, }) {
+    constructor({ onPreferencesStateChange, onNetworkStateChange, config, state, messenger, getERC20TokenName, }) {
         super(config, state);
         this.mutex = new async_mutex_1.Mutex();
         /**
@@ -66,6 +67,7 @@ class TokensController extends base_controller_1.BaseController {
         this.initialize();
         this.abortController = new abort_controller_1.AbortController();
         this.messagingSystem = messenger;
+        this.getERC20TokenName = getERC20TokenName;
         onPreferencesStateChange(({ selectedAddress }) => {
             var _a, _b, _c;
             const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
@@ -93,10 +95,6 @@ class TokensController extends base_controller_1.BaseController {
             });
         });
     }
-    failSuggestedAsset(suggestedAssetMeta, error) {
-        const failedSuggestedAssetMeta = Object.assign(Object.assign({}, suggestedAssetMeta), { status: SuggestedAssetStatus.failed, error });
-        this.hub.emit(`${suggestedAssetMeta.id}:finished`, failedSuggestedAssetMeta);
-    }
     /**
      * Fetch metadata for a token.
      *
@@ -128,11 +126,13 @@ class TokensController extends base_controller_1.BaseController {
      * @param address - Hex address of the token contract.
      * @param symbol - Symbol of the token.
      * @param decimals - Number of decimals the token uses.
-     * @param image - Image of the token.
-     * @param interactingAddress - The address of the account to add a token to.
+     * @param options - Object containing name and image of the token
+     * @param options.name - Name of the token
+     * @param options.image - Image of the token
+     * @param options.interactingAddress - The address of the account to add a token to.
      * @returns Current token list.
      */
-    addToken(address, symbol, decimals, image, interactingAddress) {
+    addToken(address, symbol, decimals, { name, image, interactingAddress }) {
         var _a, _b, _c;
         return __awaiter(this, void 0, void 0, function* () {
             const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
@@ -164,6 +164,7 @@ class TokensController extends base_controller_1.BaseController {
                         }),
                     isERC721,
                     aggregators: (0, assetsUtil_1.formatAggregatorNames)((tokenMetadata === null || tokenMetadata === void 0 ? void 0 : tokenMetadata.aggregators) || []),
+                    name,
                 };
                 const previousEntry = newTokens.find((token) => token.address.toLowerCase() === address.toLowerCase());
                 if (previousEntry) {
@@ -215,7 +216,7 @@ class TokensController extends base_controller_1.BaseController {
             }, {});
             try {
                 tokensToImport.forEach((tokenToAdd) => {
-                    const { address, symbol, decimals, image, aggregators } = tokenToAdd;
+                    const { address, symbol, decimals, image, aggregators, name } = tokenToAdd;
                     const checksumAddress = (0, controller_utils_1.toChecksumHexAddress)(address);
                     const formattedToken = {
                         address: checksumAddress,
@@ -223,6 +224,7 @@ class TokensController extends base_controller_1.BaseController {
                         decimals,
                         image,
                         aggregators,
+                        name,
                     };
                     newTokensMap[address] = formattedToken;
                     importedTokensMap[address.toLowerCase()] = true;
@@ -298,7 +300,7 @@ class TokensController extends base_controller_1.BaseController {
             let newDetectedTokens = [...detectedTokens];
             try {
                 incomingDetectedTokens.forEach((tokenToAdd) => {
-                    const { address, symbol, decimals, image, aggregators, isERC721 } = tokenToAdd;
+                    const { address, symbol, decimals, image, aggregators, isERC721, name } = tokenToAdd;
                     const checksumAddress = (0, controller_utils_1.toChecksumHexAddress)(address);
                     const newEntry = {
                         address: checksumAddress,
@@ -307,6 +309,7 @@ class TokensController extends base_controller_1.BaseController {
                         image,
                         isERC721,
                         aggregators,
+                        name,
                     };
                     const previousImportedEntry = newTokens.find((token) => token.address.toLowerCase() === checksumAddress.toLowerCase());
                     if (previousImportedEntry) {
@@ -373,6 +376,22 @@ class TokensController extends base_controller_1.BaseController {
             return tokens[tokenIndex];
         });
     }
+
+    /**
+     * This is a function that updates the tokens name for the tokens name if it is not defined
+     * @param tokenList - Represents the fetched token list from service API
+     */
+    async updateTokensName(tokenList) {
+        const { tokens } = this.state;
+
+        const newTokens = tokens.map((token) => {
+            const newToken = tokenList[token.address.toLowerCase()];
+          return (!token.name && newToken?.name) ? { ...token, name: newToken.name } : {...token};
+        });
+
+        this.update({ tokens: newTokens });
+    }
+
     /**
      * Detects whether or not a token is ERC-721 compatible.
      *
@@ -423,103 +442,35 @@ class TokensController extends base_controller_1.BaseController {
      */
     watchAsset(asset, type, interactingAddress) {
         return __awaiter(this, void 0, void 0, function* () {
+            if (type !== controller_utils_1.ERC20) {
+                throw new Error(`Asset of type ${type} not supported`);
+            }
             const { selectedAddress } = this.config;
             const suggestedAssetMeta = {
                 asset,
                 id: this._generateRandomId(),
-                status: SuggestedAssetStatus.pending,
                 time: Date.now(),
                 type,
                 interactingAddress: interactingAddress || selectedAddress,
             };
+            (0, assetsUtil_1.validateTokenToWatch)(asset);
+
+            yield this._requestApproval(suggestedAssetMeta);
+
+            let name;
             try {
-                switch (type) {
-                    case 'ERC20':
-                        (0, assetsUtil_1.validateTokenToWatch)(asset);
-                        break;
-                    default:
-                        throw new Error(`Asset of type ${type} not supported`);
-                }
-            }
-            catch (error) {
-                this.failSuggestedAsset(suggestedAssetMeta, error);
-                return Promise.reject(error);
+              name = yield this.getERC20TokenName(address);
+            } catch (error) {
+              name = undefined;
             }
-            const result = new Promise((resolve, reject) => {
-                this.hub.once(`${suggestedAssetMeta.id}:finished`, (meta) => {
-                    switch (meta.status) {
-                        case SuggestedAssetStatus.accepted:
-                            return resolve(meta.asset.address);
-                        case SuggestedAssetStatus.rejected:
-                            return reject(new Error('User rejected to watch the asset.'));
-                        case SuggestedAssetStatus.failed:
-                            return reject(new Error(meta.error.message));
-                        /* istanbul ignore next */
-                        default:
-                            return reject(new Error(`Unknown status: ${meta.status}`));
-                    }
-                });
+
+            yield this.addToken(asset.address, asset.symbol, asset.decimals, {
+              name,
+              image: asset.image,
+              interactingAddress: suggestedAssetMeta.interactingAddress,
             });
-            const { suggestedAssets } = this.state;
-            suggestedAssets.push(suggestedAssetMeta);
-            this.update({ suggestedAssets: [...suggestedAssets] });
-            this._requestApproval(suggestedAssetMeta);
-            return { result, suggestedAssetMeta };
         });
     }
-    /**
-     * Accepts to watch an asset and updates it's status and deletes the suggestedAsset from state,
-     * adding the asset to corresponding asset state. In this case ERC20 tokens.
-     * A `<suggestedAssetMeta.id>:finished` hub event is fired after accepted or failure.
-     *
-     * @param suggestedAssetID - The ID of the suggestedAsset to accept.
-     */
-    acceptWatchAsset(suggestedAssetID) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const { selectedAddress } = this.config;
-            const { suggestedAssets } = this.state;
-            const index = suggestedAssets.findIndex(({ id }) => suggestedAssetID === id);
-            const suggestedAssetMeta = suggestedAssets[index];
-            try {
-                switch (suggestedAssetMeta.type) {
-                    case 'ERC20':
-                        const { address, symbol, decimals, image } = suggestedAssetMeta.asset;
-                        yield this.addToken(address, symbol, decimals, image, (suggestedAssetMeta === null || suggestedAssetMeta === void 0 ? void 0 : suggestedAssetMeta.interactingAddress) || selectedAddress);
-                        this._acceptApproval(suggestedAssetID);
-                        const acceptedSuggestedAssetMeta = Object.assign(Object.assign({}, suggestedAssetMeta), { status: SuggestedAssetStatus.accepted });
-                        this.hub.emit(`${suggestedAssetMeta.id}:finished`, acceptedSuggestedAssetMeta);
-                        break;
-                    default:
-                        throw new Error(`Asset of type ${suggestedAssetMeta.type} not supported`);
-                }
-            }
-            catch (error) {
-                this.failSuggestedAsset(suggestedAssetMeta, error);
-                this._rejectApproval(suggestedAssetID);
-            }
-            const newSuggestedAssets = suggestedAssets.filter(({ id }) => id !== suggestedAssetID);
-            this.update({ suggestedAssets: [...newSuggestedAssets] });
-        });
-    }
-    /**
-     * Rejects a watchAsset request based on its ID by setting its status to "rejected"
-     * and emitting a `<suggestedAssetMeta.id>:finished` hub event.
-     *
-     * @param suggestedAssetID - The ID of the suggestedAsset to accept.
-     */
-    rejectWatchAsset(suggestedAssetID) {
-        const { suggestedAssets } = this.state;
-        const index = suggestedAssets.findIndex(({ id }) => suggestedAssetID === id);
-        const suggestedAssetMeta = suggestedAssets[index];
-        if (!suggestedAssetMeta) {
-            return;
-        }
-        const rejectedSuggestedAssetMeta = Object.assign(Object.assign({}, suggestedAssetMeta), { status: SuggestedAssetStatus.rejected });
-        this.hub.emit(`${suggestedAssetMeta.id}:finished`, rejectedSuggestedAssetMeta);
-        const newSuggestedAssets = suggestedAssets.filter(({ id }) => id !== suggestedAssetID);
-        this.update({ suggestedAssets: [...newSuggestedAssets] });
-        this._rejectApproval(suggestedAssetID);
-    }
     /**
      * Takes a new tokens and ignoredTokens array for the current network/account combination
      * and returns new allTokens and allIgnoredTokens state to update to.
@@ -576,43 +527,26 @@ class TokensController extends base_controller_1.BaseController {
     clearIgnoredTokens() {
         this.update({ ignoredTokens: [], allIgnoredTokens: {} });
     }
+    // THIS PATCHED METHOD HAS ALREADY BEEN RELEASED IN VERSION 8.0.0 of @metamask/assets-controllers
     _requestApproval(suggestedAssetMeta) {
-        this.messagingSystem
-            .call('ApprovalController:addRequest', {
-            id: suggestedAssetMeta.id,
-            origin: controller_utils_1.ORIGIN_METAMASK,
-            type: controller_utils_1.ApprovalType.WatchAsset,
-            requestData: {
+        return __awaiter(this, void 0, void 0, function* () {
+            return this.messagingSystem.call('ApprovalController:addRequest', {
                 id: suggestedAssetMeta.id,
-                interactingAddress: suggestedAssetMeta.interactingAddress,
-                asset: {
-                    address: suggestedAssetMeta.asset.address,
-                    decimals: suggestedAssetMeta.asset.decimals,
-                    symbol: suggestedAssetMeta.asset.symbol,
-                    image: suggestedAssetMeta.asset.image || null,
+                origin: 'metamask',
+                type: 'wallet_watchAsset',
+                requestData: {
+                    id: suggestedAssetMeta.id,
+                    interactingAddress: suggestedAssetMeta.interactingAddress,
+                    asset: {
+                        address: suggestedAssetMeta.asset.address,
+                        decimals: suggestedAssetMeta.asset.decimals,
+                        symbol: suggestedAssetMeta.asset.symbol,
+                        image: suggestedAssetMeta.asset.image || null,
+                    },
                 },
-            },
-        }, true)
-            .catch(() => {
-            // Intentionally ignored as promise not currently used
+            }, true);
         });
     }
-    _acceptApproval(approvalRequestId) {
-        try {
-            this.messagingSystem.call('ApprovalController:acceptRequest', approvalRequestId);
-        }
-        catch (error) {
-            console.error('Failed to accept token watch approval request', error);
-        }
-    }
-    _rejectApproval(approvalRequestId) {
-        try {
-            this.messagingSystem.call('ApprovalController:rejectRequest', approvalRequestId, new Error('Rejected'));
-        }
-        catch (messageCallError) {
-            console.error('Failed to reject token watch approval request', messageCallError);
-        }
-    }
 }
 exports.TokensController = TokensController;
 exports.default = TokensController;
diff --git a/node_modules/@metamask/assets-controllers/dist/assetsUtil.d.ts b/node_modules/@metamask/assets-controllers/dist/assetsUtil.d.ts
index 1b69903..d45fe80 100644
--- a/node_modules/@metamask/assets-controllers/dist/assetsUtil.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/assetsUtil.d.ts
@@ -45,7 +45,8 @@ export declare enum SupportedTokenDetectionNetworks {
     mainnet = "1",
     bsc = "56",
     polygon = "137",
-    avax = "43114"
+    avax = "43114",
+    aurora = "1313161554"
 }
 /**
  * Check if token detection is enabled for certain networks.
diff --git a/node_modules/@metamask/assets-controllers/dist/assetsUtil.js b/node_modules/@metamask/assets-controllers/dist/assetsUtil.js
index 4b54e82..2322286 100644
--- a/node_modules/@metamask/assets-controllers/dist/assetsUtil.js
+++ b/node_modules/@metamask/assets-controllers/dist/assetsUtil.js
@@ -120,6 +120,7 @@ var SupportedTokenDetectionNetworks;
     SupportedTokenDetectionNetworks["bsc"] = "56";
     SupportedTokenDetectionNetworks["polygon"] = "137";
     SupportedTokenDetectionNetworks["avax"] = "43114";
+    SupportedTokenDetectionNetworks["aurora"] = "1313161554";
 })(SupportedTokenDetectionNetworks = exports.SupportedTokenDetectionNetworks || (exports.SupportedTokenDetectionNetworks = {}));
 /**
  * Check if token detection is enabled for certain networks.
