diff --git a/node_modules/@metamask/transaction-controller/dist/.patch.txt b/node_modules/@metamask/transaction-controller/dist/.patch.txt
new file mode 100644
index 0000000..550de56
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/.patch.txt
@@ -0,0 +1,7 @@
+PATCH GENERATED FROM MetaMask/core branch: refactor/transaction-controller-patch-mobile-5
+This patch backports various transaction controller features from the main branch of MetaMask/core
+Steps to update patch:
+* Create a new core branch from: patch/mobile-transaction-controller-6-1-0
+* Run "yarn build" in the core monorepo
+* Run "yarn patch:tx <core-directory>" in the mobile repo
+* Once the new patch is merged, add your changes to: patch/mobile-transaction-controller-6-1-0
diff --git a/node_modules/@metamask/transaction-controller/dist/EtherscanRemoteTransactionSource.d.ts b/node_modules/@metamask/transaction-controller/dist/EtherscanRemoteTransactionSource.d.ts
new file mode 100644
index 0000000..7637754
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/EtherscanRemoteTransactionSource.d.ts
@@ -0,0 +1,14 @@
+import type { RemoteTransactionSource, RemoteTransactionSourceRequest, TransactionMeta } from './types';
+/**
+ * A RemoteTransactionSource that fetches transaction data from Etherscan.
+ */
+export declare class EtherscanRemoteTransactionSource implements RemoteTransactionSource {
+    #private;
+    constructor({ apiKey, includeTokenTransfers, }?: {
+        apiKey?: string;
+        includeTokenTransfers?: boolean;
+    });
+    isSupportedNetwork(chainId: string, _networkId: string): boolean;
+    fetchTransactions(request: RemoteTransactionSourceRequest): Promise<TransactionMeta[]>;
+}
+//# sourceMappingURL=EtherscanRemoteTransactionSource.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/EtherscanRemoteTransactionSource.js b/node_modules/@metamask/transaction-controller/dist/EtherscanRemoteTransactionSource.js
new file mode 100644
index 0000000..0902b41
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/EtherscanRemoteTransactionSource.js
@@ -0,0 +1,99 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
+    if (kind === "m") throw new TypeError("Private method is not writable");
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
+    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
+};
+var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
+    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
+};
+var _EtherscanRemoteTransactionSource_instances, _EtherscanRemoteTransactionSource_apiKey, _EtherscanRemoteTransactionSource_includeTokenTransfers, _EtherscanRemoteTransactionSource_normalizeTransaction, _EtherscanRemoteTransactionSource_normalizeTokenTransaction, _EtherscanRemoteTransactionSource_normalizeTransactionBase;
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.EtherscanRemoteTransactionSource = void 0;
+const controller_utils_1 = require("@metamask/controller-utils");
+const ethereumjs_util_1 = require("ethereumjs-util");
+const uuid_1 = require("uuid");
+const constants_1 = require("./constants");
+const etherscan_1 = require("./etherscan");
+const types_1 = require("./types");
+/**
+ * A RemoteTransactionSource that fetches transaction data from Etherscan.
+ */
+class EtherscanRemoteTransactionSource {
+    constructor({ apiKey, includeTokenTransfers, } = {}) {
+        _EtherscanRemoteTransactionSource_instances.add(this);
+        _EtherscanRemoteTransactionSource_apiKey.set(this, void 0);
+        _EtherscanRemoteTransactionSource_includeTokenTransfers.set(this, void 0);
+        __classPrivateFieldSet(this, _EtherscanRemoteTransactionSource_apiKey, apiKey, "f");
+        __classPrivateFieldSet(this, _EtherscanRemoteTransactionSource_includeTokenTransfers, includeTokenTransfers !== null && includeTokenTransfers !== void 0 ? includeTokenTransfers : true, "f");
+    }
+    isSupportedNetwork(chainId, _networkId) {
+        return Object.keys(constants_1.ETHERSCAN_SUPPORTED_NETWORKS).includes(chainId);
+    }
+    fetchTransactions(request) {
+        return __awaiter(this, void 0, void 0, function* () {
+            const etherscanRequest = Object.assign(Object.assign({}, request), { apiKey: __classPrivateFieldGet(this, _EtherscanRemoteTransactionSource_apiKey, "f"), chainId: request.currentChainId });
+            const transactionPromise = (0, etherscan_1.fetchEtherscanTransactions)(etherscanRequest);
+            const tokenTransactionPromise = __classPrivateFieldGet(this, _EtherscanRemoteTransactionSource_includeTokenTransfers, "f")
+                ? (0, etherscan_1.fetchEtherscanTokenTransactions)(etherscanRequest)
+                : Promise.resolve({
+                    result: [],
+                });
+            const [etherscanTransactions, etherscanTokenTransactions] = yield Promise.all([transactionPromise, tokenTransactionPromise]);
+            const transactions = etherscanTransactions.result.map((tx) => __classPrivateFieldGet(this, _EtherscanRemoteTransactionSource_instances, "m", _EtherscanRemoteTransactionSource_normalizeTransaction).call(this, tx, request.currentNetworkId, request.currentChainId));
+            const tokenTransactions = etherscanTokenTransactions.result.map((tx) => __classPrivateFieldGet(this, _EtherscanRemoteTransactionSource_instances, "m", _EtherscanRemoteTransactionSource_normalizeTokenTransaction).call(this, tx, request.currentNetworkId, request.currentChainId));
+            return [...transactions, ...tokenTransactions];
+        });
+    }
+}
+exports.EtherscanRemoteTransactionSource = EtherscanRemoteTransactionSource;
+_EtherscanRemoteTransactionSource_apiKey = new WeakMap(), _EtherscanRemoteTransactionSource_includeTokenTransfers = new WeakMap(), _EtherscanRemoteTransactionSource_instances = new WeakSet(), _EtherscanRemoteTransactionSource_normalizeTransaction = function _EtherscanRemoteTransactionSource_normalizeTransaction(txMeta, currentNetworkId, currentChainId) {
+    const base = __classPrivateFieldGet(this, _EtherscanRemoteTransactionSource_instances, "m", _EtherscanRemoteTransactionSource_normalizeTransactionBase).call(this, txMeta, currentNetworkId, currentChainId);
+    return Object.assign(Object.assign(Object.assign({}, base), { transaction: Object.assign(Object.assign({}, base.transaction), { data: txMeta.input }) }), (txMeta.isError === '0'
+        ? { status: types_1.TransactionStatus.confirmed }
+        : {
+            error: new Error('Transaction failed'),
+            status: types_1.TransactionStatus.failed,
+        }));
+}, _EtherscanRemoteTransactionSource_normalizeTokenTransaction = function _EtherscanRemoteTransactionSource_normalizeTokenTransaction(txMeta, currentNetworkId, currentChainId) {
+    const base = __classPrivateFieldGet(this, _EtherscanRemoteTransactionSource_instances, "m", _EtherscanRemoteTransactionSource_normalizeTransactionBase).call(this, txMeta, currentNetworkId, currentChainId);
+    return Object.assign(Object.assign({}, base), { isTransfer: true, transferInformation: {
+            contractAddress: txMeta.contractAddress,
+            decimals: Number(txMeta.tokenDecimal),
+            symbol: txMeta.tokenSymbol,
+        } });
+}, _EtherscanRemoteTransactionSource_normalizeTransactionBase = function _EtherscanRemoteTransactionSource_normalizeTransactionBase(txMeta, currentNetworkId, currentChainId) {
+    const time = parseInt(txMeta.timeStamp, 10) * 1000;
+    return {
+        blockNumber: txMeta.blockNumber,
+        chainId: currentChainId,
+        id: (0, uuid_1.v1)({ msecs: time }),
+        networkID: currentNetworkId,
+        status: types_1.TransactionStatus.confirmed,
+        time,
+        transaction: {
+            from: txMeta.from,
+            gas: (0, controller_utils_1.BNToHex)(new ethereumjs_util_1.BN(txMeta.gas)),
+            gasPrice: (0, controller_utils_1.BNToHex)(new ethereumjs_util_1.BN(txMeta.gasPrice)),
+            gasUsed: (0, controller_utils_1.BNToHex)(new ethereumjs_util_1.BN(txMeta.gasUsed)),
+            nonce: (0, controller_utils_1.BNToHex)(new ethereumjs_util_1.BN(txMeta.nonce)),
+            to: txMeta.to,
+            value: (0, controller_utils_1.BNToHex)(new ethereumjs_util_1.BN(txMeta.value)),
+        },
+        transactionHash: txMeta.hash,
+        verifiedOnBlockchain: false,
+    };
+};
+//# sourceMappingURL=EtherscanRemoteTransactionSource.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/IncomingTransactionHelper.d.ts b/node_modules/@metamask/transaction-controller/dist/IncomingTransactionHelper.d.ts
new file mode 100644
index 0000000..5fa6cf4
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/IncomingTransactionHelper.d.ts
@@ -0,0 +1,23 @@
+/// <reference types="node" />
+import EventEmitter from 'events';
+import type { BlockTracker, NetworkState } from '@metamask/network-controller';
+import type { RemoteTransactionSource, TransactionMeta } from './types';
+export declare class IncomingTransactionHelper {
+    #private;
+    hub: EventEmitter;
+    constructor({ blockTracker, getCurrentAccount, getLastFetchedBlockNumbers, getLocalTransactions, getNetworkState, isEnabled, remoteTransactionSource, transactionLimit, updateTransactions, }: {
+        blockTracker: BlockTracker;
+        getCurrentAccount: () => string;
+        getNetworkState: () => NetworkState;
+        getLastFetchedBlockNumbers: () => Record<string, number>;
+        getLocalTransactions?: () => TransactionMeta[];
+        isEnabled?: () => boolean;
+        remoteTransactionSource: RemoteTransactionSource;
+        transactionLimit?: number;
+        updateTransactions?: boolean;
+    });
+    start(): void;
+    stop(): void;
+    update(latestBlockNumberHex?: string): Promise<void>;
+}
+//# sourceMappingURL=IncomingTransactionHelper.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/IncomingTransactionHelper.js b/node_modules/@metamask/transaction-controller/dist/IncomingTransactionHelper.js
new file mode 100644
index 0000000..18bc7af
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/IncomingTransactionHelper.js
@@ -0,0 +1,191 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
+    if (kind === "m") throw new TypeError("Private method is not writable");
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
+    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
+};
+var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
+    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
+};
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+var _IncomingTransactionHelper_instances, _IncomingTransactionHelper_blockTracker, _IncomingTransactionHelper_getCurrentAccount, _IncomingTransactionHelper_getLastFetchedBlockNumbers, _IncomingTransactionHelper_getLocalTransactions, _IncomingTransactionHelper_getNetworkState, _IncomingTransactionHelper_isEnabled, _IncomingTransactionHelper_isRunning, _IncomingTransactionHelper_mutex, _IncomingTransactionHelper_onLatestBlock, _IncomingTransactionHelper_remoteTransactionSource, _IncomingTransactionHelper_transactionLimit, _IncomingTransactionHelper_updateTransactions, _IncomingTransactionHelper_sortTransactionsByTime, _IncomingTransactionHelper_getNewTransactions, _IncomingTransactionHelper_getUpdatedTransactions, _IncomingTransactionHelper_isTransactionOutdated, _IncomingTransactionHelper_getFromBlock, _IncomingTransactionHelper_updateLastFetchedBlockNumber, _IncomingTransactionHelper_getBlockNumberKey, _IncomingTransactionHelper_canStart, _IncomingTransactionHelper_getCurrentChainId, _IncomingTransactionHelper_getCurrentNetworkId;
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.IncomingTransactionHelper = void 0;
+const events_1 = __importDefault(require("events"));
+const async_mutex_1 = require("async-mutex");
+const UPDATE_CHECKS = [
+    (txMeta) => txMeta.status,
+    (txMeta) => txMeta.transaction.gasUsed,
+];
+class IncomingTransactionHelper {
+    constructor({ blockTracker, getCurrentAccount, getLastFetchedBlockNumbers, getLocalTransactions, getNetworkState, isEnabled, remoteTransactionSource, transactionLimit, updateTransactions, }) {
+        _IncomingTransactionHelper_instances.add(this);
+        _IncomingTransactionHelper_blockTracker.set(this, void 0);
+        _IncomingTransactionHelper_getCurrentAccount.set(this, void 0);
+        _IncomingTransactionHelper_getLastFetchedBlockNumbers.set(this, void 0);
+        _IncomingTransactionHelper_getLocalTransactions.set(this, void 0);
+        _IncomingTransactionHelper_getNetworkState.set(this, void 0);
+        _IncomingTransactionHelper_isEnabled.set(this, void 0);
+        _IncomingTransactionHelper_isRunning.set(this, void 0);
+        _IncomingTransactionHelper_mutex.set(this, new async_mutex_1.Mutex());
+        _IncomingTransactionHelper_onLatestBlock.set(this, void 0);
+        _IncomingTransactionHelper_remoteTransactionSource.set(this, void 0);
+        _IncomingTransactionHelper_transactionLimit.set(this, void 0);
+        _IncomingTransactionHelper_updateTransactions.set(this, void 0);
+        this.hub = new events_1.default();
+        __classPrivateFieldSet(this, _IncomingTransactionHelper_blockTracker, blockTracker, "f");
+        __classPrivateFieldSet(this, _IncomingTransactionHelper_getCurrentAccount, getCurrentAccount, "f");
+        __classPrivateFieldSet(this, _IncomingTransactionHelper_getLastFetchedBlockNumbers, getLastFetchedBlockNumbers, "f");
+        __classPrivateFieldSet(this, _IncomingTransactionHelper_getLocalTransactions, getLocalTransactions || (() => []), "f");
+        __classPrivateFieldSet(this, _IncomingTransactionHelper_getNetworkState, getNetworkState, "f");
+        __classPrivateFieldSet(this, _IncomingTransactionHelper_isEnabled, isEnabled !== null && isEnabled !== void 0 ? isEnabled : (() => true), "f");
+        __classPrivateFieldSet(this, _IncomingTransactionHelper_isRunning, false, "f");
+        __classPrivateFieldSet(this, _IncomingTransactionHelper_remoteTransactionSource, remoteTransactionSource, "f");
+        __classPrivateFieldSet(this, _IncomingTransactionHelper_transactionLimit, transactionLimit, "f");
+        __classPrivateFieldSet(this, _IncomingTransactionHelper_updateTransactions, updateTransactions !== null && updateTransactions !== void 0 ? updateTransactions : false, "f");
+        // Using a property instead of a method to provide a listener reference
+        // with the correct scope that we can remove later if stopped.
+        __classPrivateFieldSet(this, _IncomingTransactionHelper_onLatestBlock, (blockNumberHex) => __awaiter(this, void 0, void 0, function* () {
+            try {
+                yield this.update(blockNumberHex);
+            }
+            catch (error) {
+                console.error('Error while checking incoming transactions', error);
+            }
+        }), "f");
+    }
+    start() {
+        if (__classPrivateFieldGet(this, _IncomingTransactionHelper_isRunning, "f")) {
+            return;
+        }
+        if (!__classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_canStart).call(this)) {
+            return;
+        }
+        __classPrivateFieldGet(this, _IncomingTransactionHelper_blockTracker, "f").addListener('latest', __classPrivateFieldGet(this, _IncomingTransactionHelper_onLatestBlock, "f"));
+        __classPrivateFieldSet(this, _IncomingTransactionHelper_isRunning, true, "f");
+    }
+    stop() {
+        __classPrivateFieldGet(this, _IncomingTransactionHelper_blockTracker, "f").removeListener('latest', __classPrivateFieldGet(this, _IncomingTransactionHelper_onLatestBlock, "f"));
+        __classPrivateFieldSet(this, _IncomingTransactionHelper_isRunning, false, "f");
+    }
+    update(latestBlockNumberHex) {
+        return __awaiter(this, void 0, void 0, function* () {
+            const releaseLock = yield __classPrivateFieldGet(this, _IncomingTransactionHelper_mutex, "f").acquire();
+            try {
+                if (!__classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_canStart).call(this)) {
+                    return;
+                }
+                const latestBlockNumber = parseInt(latestBlockNumberHex || (yield __classPrivateFieldGet(this, _IncomingTransactionHelper_blockTracker, "f").getLatestBlock()), 16);
+                const fromBlock = __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_getFromBlock).call(this, latestBlockNumber);
+                const address = __classPrivateFieldGet(this, _IncomingTransactionHelper_getCurrentAccount, "f").call(this);
+                const currentChainId = __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_getCurrentChainId).call(this);
+                const currentNetworkId = __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_getCurrentNetworkId).call(this);
+                let remoteTransactions = [];
+                try {
+                    remoteTransactions =
+                        yield __classPrivateFieldGet(this, _IncomingTransactionHelper_remoteTransactionSource, "f").fetchTransactions({
+                            address,
+                            currentChainId,
+                            currentNetworkId,
+                            fromBlock,
+                            limit: __classPrivateFieldGet(this, _IncomingTransactionHelper_transactionLimit, "f"),
+                        });
+                }
+                catch (error) {
+                    return;
+                }
+                if (!__classPrivateFieldGet(this, _IncomingTransactionHelper_updateTransactions, "f")) {
+                    remoteTransactions = remoteTransactions.filter((tx) => { var _a; return ((_a = tx.transaction.to) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === address.toLowerCase(); });
+                }
+                const localTransactions = !__classPrivateFieldGet(this, _IncomingTransactionHelper_updateTransactions, "f")
+                    ? []
+                    : __classPrivateFieldGet(this, _IncomingTransactionHelper_getLocalTransactions, "f").call(this);
+                const newTransactions = __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_getNewTransactions).call(this, remoteTransactions, localTransactions);
+                const updatedTransactions = __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_getUpdatedTransactions).call(this, remoteTransactions, localTransactions);
+                if (newTransactions.length > 0 || updatedTransactions.length > 0) {
+                    __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_sortTransactionsByTime).call(this, newTransactions);
+                    __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_sortTransactionsByTime).call(this, updatedTransactions);
+                    this.hub.emit('transactions', {
+                        added: newTransactions,
+                        updated: updatedTransactions,
+                    });
+                }
+                __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_updateLastFetchedBlockNumber).call(this, remoteTransactions);
+            }
+            finally {
+                releaseLock();
+            }
+        });
+    }
+}
+exports.IncomingTransactionHelper = IncomingTransactionHelper;
+_IncomingTransactionHelper_blockTracker = new WeakMap(), _IncomingTransactionHelper_getCurrentAccount = new WeakMap(), _IncomingTransactionHelper_getLastFetchedBlockNumbers = new WeakMap(), _IncomingTransactionHelper_getLocalTransactions = new WeakMap(), _IncomingTransactionHelper_getNetworkState = new WeakMap(), _IncomingTransactionHelper_isEnabled = new WeakMap(), _IncomingTransactionHelper_isRunning = new WeakMap(), _IncomingTransactionHelper_mutex = new WeakMap(), _IncomingTransactionHelper_onLatestBlock = new WeakMap(), _IncomingTransactionHelper_remoteTransactionSource = new WeakMap(), _IncomingTransactionHelper_transactionLimit = new WeakMap(), _IncomingTransactionHelper_updateTransactions = new WeakMap(), _IncomingTransactionHelper_instances = new WeakSet(), _IncomingTransactionHelper_sortTransactionsByTime = function _IncomingTransactionHelper_sortTransactionsByTime(transactions) {
+    transactions.sort((a, b) => (a.time < b.time ? -1 : 1));
+}, _IncomingTransactionHelper_getNewTransactions = function _IncomingTransactionHelper_getNewTransactions(remoteTxs, localTxs) {
+    return remoteTxs.filter((tx) => !localTxs.some(({ transactionHash }) => transactionHash === tx.transactionHash));
+}, _IncomingTransactionHelper_getUpdatedTransactions = function _IncomingTransactionHelper_getUpdatedTransactions(remoteTxs, localTxs) {
+    return remoteTxs.filter((remoteTx) => localTxs.some((localTx) => remoteTx.transactionHash === localTx.transactionHash &&
+        __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_isTransactionOutdated).call(this, remoteTx, localTx)));
+}, _IncomingTransactionHelper_isTransactionOutdated = function _IncomingTransactionHelper_isTransactionOutdated(remoteTx, localTx) {
+    return UPDATE_CHECKS.some((getValue) => getValue(remoteTx) !== getValue(localTx));
+}, _IncomingTransactionHelper_getFromBlock = function _IncomingTransactionHelper_getFromBlock(_latestBlockNumber) {
+    const lastFetchedKey = __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_getBlockNumberKey).call(this);
+    const lastFetchedBlockNumber = __classPrivateFieldGet(this, _IncomingTransactionHelper_getLastFetchedBlockNumbers, "f").call(this)[lastFetchedKey];
+    if (lastFetchedBlockNumber) {
+        return lastFetchedBlockNumber + 1;
+    }
+    // Query entire transaction history
+    return undefined;
+}, _IncomingTransactionHelper_updateLastFetchedBlockNumber = function _IncomingTransactionHelper_updateLastFetchedBlockNumber(remoteTxs) {
+    let lastFetchedBlockNumber = -1;
+    for (const tx of remoteTxs) {
+        const currentBlockNumberValue = tx.blockNumber
+            ? parseInt(tx.blockNumber, 10)
+            : -1;
+        lastFetchedBlockNumber = Math.max(lastFetchedBlockNumber, currentBlockNumberValue);
+    }
+    if (lastFetchedBlockNumber === -1) {
+        return;
+    }
+    const lastFetchedKey = __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_getBlockNumberKey).call(this);
+    const lastFetchedBlockNumbers = __classPrivateFieldGet(this, _IncomingTransactionHelper_getLastFetchedBlockNumbers, "f").call(this);
+    const previousValue = lastFetchedBlockNumbers[lastFetchedKey];
+    if (previousValue === lastFetchedBlockNumber) {
+        return;
+    }
+    lastFetchedBlockNumbers[lastFetchedKey] = lastFetchedBlockNumber;
+    this.hub.emit('updatedLastFetchedBlockNumbers', {
+        lastFetchedBlockNumbers,
+        blockNumber: lastFetchedBlockNumber,
+    });
+}, _IncomingTransactionHelper_getBlockNumberKey = function _IncomingTransactionHelper_getBlockNumberKey() {
+    var _a;
+    const currentChainId = __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_getCurrentChainId).call(this);
+    const currentAccount = (_a = __classPrivateFieldGet(this, _IncomingTransactionHelper_getCurrentAccount, "f").call(this)) === null || _a === void 0 ? void 0 : _a.toLowerCase();
+    return [currentChainId, currentAccount].join('#');
+}, _IncomingTransactionHelper_canStart = function _IncomingTransactionHelper_canStart() {
+    const isEnabled = __classPrivateFieldGet(this, _IncomingTransactionHelper_isEnabled, "f").call(this);
+    const currentChainId = __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_getCurrentChainId).call(this);
+    const currentNetworkId = __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_getCurrentNetworkId).call(this);
+    const isSupportedNetwork = __classPrivateFieldGet(this, _IncomingTransactionHelper_remoteTransactionSource, "f").isSupportedNetwork(currentChainId, currentNetworkId);
+    return isEnabled && isSupportedNetwork;
+}, _IncomingTransactionHelper_getCurrentChainId = function _IncomingTransactionHelper_getCurrentChainId() {
+    return __classPrivateFieldGet(this, _IncomingTransactionHelper_getNetworkState, "f").call(this).providerConfig.chainId;
+}, _IncomingTransactionHelper_getCurrentNetworkId = function _IncomingTransactionHelper_getCurrentNetworkId() {
+    return __classPrivateFieldGet(this, _IncomingTransactionHelper_getNetworkState, "f").call(this).networkId;
+};
+//# sourceMappingURL=IncomingTransactionHelper.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/TransactionController.d.ts b/node_modules/@metamask/transaction-controller/dist/TransactionController.d.ts
index 2c9675f..7aeceec 100644
--- a/node_modules/@metamask/transaction-controller/dist/TransactionController.d.ts
+++ b/node_modules/@metamask/transaction-controller/dist/TransactionController.d.ts
@@ -2,10 +2,12 @@
 import { EventEmitter } from 'events';
 import Common from '@ethereumjs/common';
 import { TypedTransaction } from '@ethereumjs/tx';
-import type { Hex } from '@metamask/utils';
 import { BaseController, BaseConfig, BaseState, RestrictedControllerMessenger } from '@metamask/base-controller';
 import type { BlockTracker, NetworkState, Provider } from '@metamask/network-controller';
-import { AcceptRequest as AcceptApprovalRequest, AddApprovalRequest, RejectRequest as RejectApprovalRequest } from '@metamask/approval-controller';
+import { AddApprovalRequest } from '@metamask/approval-controller';
+import { NonceLock } from 'nonce-tracker/dist/NonceTracker';
+import { GasFeeState } from '@metamask/gas-fee-controller';
+import { SecurityAlertResponse, SubmitHistoryEntry, Transaction, TransactionMeta, WalletDevice } from './types';
 /**
  * @type Result
  * @property result - Promise resolving to a new transaction hash
@@ -15,44 +17,6 @@ export interface Result {
     result: Promise<string>;
     transactionMeta: TransactionMeta;
 }
-/**
- * @type Fetch All Options
- * @property fromBlock - String containing a specific block decimal number
- * @property etherscanApiKey - API key to be used to fetch token transactions
- */
-export interface FetchAllOptions {
-    fromBlock?: string;
-    etherscanApiKey?: string;
-}
-/**
- * @type Transaction
- *
- * Transaction representation
- * @property chainId - Network ID as per EIP-155
- * @property data - Data to pass with this transaction
- * @property from - Address to send this transaction from
- * @property gas - Gas to send with this transaction
- * @property gasPrice - Price of gas with this transaction
- * @property gasUsed -  Gas used in the transaction
- * @property nonce - Unique number to prevent replay attacks
- * @property to - Address to send this transaction to
- * @property value - Value associated with this transaction
- */
-export interface Transaction {
-    chainId?: Hex;
-    data?: string;
-    from: string;
-    gas?: string;
-    gasPrice?: string;
-    gasUsed?: string;
-    nonce?: string;
-    to?: string;
-    value?: string;
-    maxFeePerGas?: string;
-    maxPriorityFeePerGas?: string;
-    estimatedBaseFee?: string;
-    estimateGasError?: string;
-}
 export interface GasPriceValue {
     gasPrice: string;
 }
@@ -60,115 +24,6 @@ export interface FeeMarketEIP1559Values {
     maxFeePerGas: string;
     maxPriorityFeePerGas: string;
 }
-/**
- * The status of the transaction. Each status represents the state of the transaction internally
- * in the wallet. Some of these correspond with the state of the transaction on the network, but
- * some are wallet-specific.
- */
-export declare enum TransactionStatus {
-    approved = "approved",
-    cancelled = "cancelled",
-    confirmed = "confirmed",
-    failed = "failed",
-    rejected = "rejected",
-    signed = "signed",
-    submitted = "submitted",
-    unapproved = "unapproved"
-}
-/**
- * Options for wallet device.
- */
-export declare enum WalletDevice {
-    MM_MOBILE = "metamask_mobile",
-    MM_EXTENSION = "metamask_extension",
-    OTHER = "other_device"
-}
-declare type TransactionMetaBase = {
-    isTransfer?: boolean;
-    transferInformation?: {
-        symbol: string;
-        contractAddress: string;
-        decimals: number;
-    };
-    id: string;
-    networkID?: string;
-    chainId?: Hex;
-    origin?: string;
-    rawTransaction?: string;
-    time: number;
-    toSmartContract?: boolean;
-    transaction: Transaction;
-    transactionHash?: string;
-    blockNumber?: string;
-    deviceConfirmedOn?: WalletDevice;
-    verifiedOnBlockchain?: boolean;
-};
-/**
- * @type TransactionMeta
- *
- * TransactionMeta representation
- * @property error - Synthesized error information for failed transactions
- * @property id - Generated UUID associated with this transaction
- * @property networkID - Network code as per EIP-155 for this transaction
- * @property origin - Origin this transaction was sent from
- * @property deviceConfirmedOn - string to indicate what device the transaction was confirmed
- * @property rawTransaction - Hex representation of the underlying transaction
- * @property status - String status of this transaction
- * @property time - Timestamp associated with this transaction
- * @property toSmartContract - Whether transaction recipient is a smart contract
- * @property transaction - Underlying Transaction object
- * @property transactionHash - Hash of a successful transaction
- * @property blockNumber - Number of the block where the transaction has been included
- */
-export declare type TransactionMeta = ({
-    status: Exclude<TransactionStatus, TransactionStatus.failed>;
-} & TransactionMetaBase) | ({
-    status: TransactionStatus.failed;
-    error: Error;
-} & TransactionMetaBase);
-/**
- * @type EtherscanTransactionMeta
- *
- * EtherscanTransactionMeta representation
- * @property blockNumber - Number of the block where the transaction has been included
- * @property timeStamp - Timestamp associated with this transaction
- * @property hash - Hash of a successful transaction
- * @property nonce - Nonce of the transaction
- * @property blockHash - Hash of the block where the transaction has been included
- * @property transactionIndex - Etherscan internal index for this transaction
- * @property from - Address to send this transaction from
- * @property to - Address to send this transaction to
- * @property gas - Gas to send with this transaction
- * @property gasPrice - Price of gas with this transaction
- * @property isError - Synthesized error information for failed transactions
- * @property txreceipt_status - Receipt status for this transaction
- * @property input - input of the transaction
- * @property contractAddress - Address of the contract
- * @property cumulativeGasUsed - Amount of gas used
- * @property confirmations - Number of confirmations
- */
-export interface EtherscanTransactionMeta {
-    blockNumber: string;
-    timeStamp: string;
-    hash: string;
-    nonce: string;
-    blockHash: string;
-    transactionIndex: string;
-    from: string;
-    to: string;
-    value: string;
-    gas: string;
-    gasPrice: string;
-    cumulativeGasUsed: string;
-    gasUsed: string;
-    isError: string;
-    txreceipt_status: string;
-    input: string;
-    contractAddress: string;
-    confirmations: string;
-    tokenDecimal: string;
-    tokenSymbol: string;
-}
 /**
  * @type TransactionConfig
  *
@@ -205,11 +60,15 @@ export interface TransactionState extends BaseState {
     methodData: {
         [key: string]: MethodData;
     };
+    lastFetchedBlockNumbers: {
+        [key: string]: number;
+    };
+    submitHistory: SubmitHistoryEntry[];
 }
 /**
  * Multiplier used to determine a transaction's increased gas fee during cancellation
  */
-export declare const CANCEL_RATE = 1.5;
+export declare const CANCEL_RATE = 1.1;
 /**
  * Multiplier used to determine a transaction's increased gas fee during speed up
  */
@@ -221,7 +80,7 @@ declare const controllerName = "TransactionController";
 /**
  * The external actions available to the {@link TransactionController}.
  */
-declare type AllowedActions = AddApprovalRequest | AcceptApprovalRequest | RejectApprovalRequest;
+declare type AllowedActions = AddApprovalRequest;
 /**
  * The messenger of the {@link TransactionController}.
  */
@@ -236,21 +95,13 @@ export declare class TransactionController extends BaseController<TransactionCon
     private provider;
     private handle?;
     private mutex;
+    private readonly gasFeeFlows;
+    private readonly getGasFeeEstimates;
     private getNetworkState;
     private messagingSystem;
+    private incomingTransactionHelper;
     private failTransaction;
     private registryLookup;
-    /**
-     * Normalizes the transaction information from etherscan
-     * to be compatible with the TransactionMeta interface.
-     *
-     * @param txMeta - The transaction.
-     * @param currentNetworkID - The current network ID.
-     * @param currentChainId - The current chain ID.
-     * @returns The normalized transaction.
-     */
-    private normalizeTx;
-    private normalizeTokenTx;
     /**
      * EventEmitter instance used to listen to specific transactional events
      */
@@ -267,20 +118,35 @@ export declare class TransactionController extends BaseController<TransactionCon
      * Creates a TransactionController instance.
      *
      * @param options - The controller options.
+     * @param options.blockTracker - The block tracker used to poll for new blocks data.
+     * @param options.getGasFeeEstimates - Callback to retrieve gas fee estimates.
      * @param options.getNetworkState - Gets the state of the network controller.
+     * @param options.getSelectedAddress - Gets the address of the currently selected account.
+     * @param options.incomingTransactions - Configuration options for incoming transaction support.
+     * @param options.incomingTransactions.apiKey - An optional API key to use when fetching remote transaction data.
+     * @param options.incomingTransactions.includeTokenTransfers - Whether or not to include ERC20 token transfers.
+     * @param options.incomingTransactions.isEnabled - Whether or not incoming transaction retrieval is enabled.
+     * @param options.incomingTransactions.updateTransactions - Whether or not to update local transactions using remote transaction data.
+     * @param options.messenger - The controller messenger.
      * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.
      * @param options.provider - The provider used to create the underlying EthQuery instance.
-     * @param options.blockTracker - The block tracker used to poll for new blocks data.
-     * @param options.messenger - The controller messenger.
      * @param config - Initial options used to configure this controller.
      * @param state - Initial state to set on this controller.
      */
-    constructor({ getNetworkState, onNetworkStateChange, provider, blockTracker, messenger, }: {
+    constructor({ blockTracker, getGasFeeEstimates, getNetworkState, getSelectedAddress, incomingTransactions, messenger, onNetworkStateChange, provider, }: {
+        blockTracker: BlockTracker;
+        getGasFeeEstimates: () => Promise<GasFeeState>;
         getNetworkState: () => NetworkState;
+        getSelectedAddress: () => string;
+        incomingTransactions: {
+            apiKey?: string;
+            includeTokenTransfers?: boolean;
+            isEnabled?: () => boolean;
+            updateTransactions?: boolean;
+        };
+        messenger: TransactionControllerMessenger;
         onNetworkStateChange: (listener: (state: NetworkState) => void) => void;
         provider: Provider;
-        blockTracker: BlockTracker;
-        messenger: TransactionControllerMessenger;
     }, config?: Partial<TransactionConfig>, state?: Partial<TransactionState>);
     /**
      * Starts a new polling interval.
@@ -301,11 +167,20 @@ export declare class TransactionController extends BaseController<TransactionCon
      * if not provided. If A `<tx.id>:unapproved` hub event will be emitted once added.
      *
      * @param transaction - The transaction object to add.
-     * @param origin - The domain origin to append to the generated TransactionMeta.
-     * @param deviceConfirmedOn - An enum to indicate what device the transaction was confirmed to append to the generated TransactionMeta.
+     * @param opts - Additional options to control how the transaction is added.
+     * @param opts.deviceConfirmedOn - An enum to indicate what device confirmed the transaction.
+     * @param opts.origin - The origin of the transaction request, such as a dApp hostname.
+     * @param opts.securityAlertResponse - Response from security validator.
      * @returns Object containing a promise resolving to the transaction hash if approved.
      */
-    addTransaction(transaction: Transaction, origin?: string, deviceConfirmedOn?: WalletDevice): Promise<Result>;
+    addTransaction(transaction: Transaction, { deviceConfirmedOn, origin, securityAlertResponse, }?: {
+        deviceConfirmedOn?: WalletDevice;
+        origin?: string;
+        securityAlertResponse?: SecurityAlertResponse;
+    }): Promise<Result>;
+    startIncomingTransactionPolling(): void;
+    stopIncomingTransactionPolling(): void;
+    updateIncomingTransactions(): Promise<void>;
     prepareUnsignedEthTx(txParams: Record<string, unknown>): TypedTransaction;
     /**
      * `@ethereumjs/tx` uses `@ethereumjs/common` as a configuration tool for
@@ -317,22 +192,6 @@ export declare class TransactionController extends BaseController<TransactionCon
      * @returns {Common} common configuration object
      */
     getCommonConfiguration(): Common;
-    /**
-     * Approves a transaction and updates it's status in state. If this is not a
-     * retry transaction, a nonce will be generated. The transaction is signed
-     * using the sign configuration property, then published to the blockchain.
-     * A `<tx.id>:finished` hub event is fired after success or failure.
-     *
-     * @param transactionID - The ID of the transaction to approve.
-     */
-    approveTransaction(transactionID: string): Promise<void>;
-    /**
-     * Cancels a transaction based on its ID by setting its status to "rejected"
-     * and emitting a `<tx.id>:finished` hub event.
-     *
-     * @param transactionID - The ID of the transaction to cancel.
-     */
-    cancelTransaction(transactionID: string): void;
     /**
      * Attempts to cancel a transaction based on its ID by setting its status to "rejected"
      * and emitting a `<tx.id>:finished` hub event.
@@ -374,6 +233,13 @@ export declare class TransactionController extends BaseController<TransactionCon
      * @param transactionMeta - The new transaction to store in state.
      */
     updateTransaction(transactionMeta: TransactionMeta): void;
+    /**
+     * Update the security alert response for a transaction.
+     *
+     * @param transactionId - ID of the transaction.
+     * @param securityAlertResponse - The new security alert response for the transaction.
+     */
+    updateSecurityAlertResponse(transactionId: string, securityAlertResponse: SecurityAlertResponse): void;
     /**
      * Removes all transactions from state, optionally based on the current network.
      *
@@ -382,15 +248,13 @@ export declare class TransactionController extends BaseController<TransactionCon
      */
     wipeTransactions(ignoreNetwork?: boolean): void;
     /**
-     * Get transactions from Etherscan for the given address. By default all transactions are
-     * returned, but the `fromBlock` option can be given to filter just for transactions from a
-     * specific block onward.
+     * Gets the next nonce according to the nonce-tracker.
+     * Ensure `releaseLock` is called once processing of the `nonce` value is complete.
      *
-     * @param address - The address to fetch the transactions for.
-     * @param opt - Object containing optional data, fromBlock and Etherscan API key.
-     * @returns The block number of the latest incoming transaction.
+     * @param address - The hex string address for the transaction.
+     * @returns object with the `nextNonce` `nonceDetails`, and the releaseLock.
      */
-    fetchAll(address: string, opt?: FetchAllOptions): Promise<string | void>;
+    getNonceLock(address: string): Promise<NonceLock>;
     /**
      * Trim the amount of transactions that are set on the state. Checks
      * if the length of the tx history is longer then desired persistence
@@ -430,63 +294,40 @@ export declare class TransactionController extends BaseController<TransactionCon
      * @returns Whether the transaction has failed.
      */
     private checkTxReceiptStatusIsFailed;
+    private processApproval;
+    private requestApproval;
+    private getApprovalId;
     /**
-     * Method to verify the state of transactions using Etherscan as a source of truth.
-     *
-     * @param remoteTxs - Transactions to reconcile that are from a remote source.
-     * @param localTxs - Transactions to reconcile that are local.
-     * @returns A tuple containing a boolean indicating whether or not an update was required, and the updated transaction.
-     */
-    private etherscanTransactionStateReconciler;
-    /**
-     * Get all transactions that are in the remote transactions array
-     * but not in the local transactions array.
-     *
-     * @param remoteTxs - Array of transactions from remote source.
-     * @param localTxs - Array of transactions stored locally.
-     * @returns The new transactions.
-     */
-    private getNewTransactions;
-    /**
-     * Get all the transactions that are locally outdated with respect
-     * to a remote source (etherscan or blockchain). The returned array
-     * contains the transactions with the updated data.
-     *
-     * @param remoteTxs - Array of transactions from remote source.
-     * @param localTxs - Array of transactions stored locally.
-     * @returns The updated transactions.
-     */
-    private getUpdatedTransactions;
-    /**
-     * Verifies if a local transaction is outdated with respect to the remote transaction.
+     * Approves a transaction and updates it's status in state. If this is not a
+     * retry transaction, a nonce will be generated. The transaction is signed
+     * using the sign configuration property, then published to the blockchain.
+     * A `<tx.id>:finished` hub event is fired after success or failure.
      *
-     * @param remoteTx - The remote transaction from Etherscan.
-     * @param localTx - The local transaction.
-     * @returns Whether the transaction is outdated.
+     * @param transactionID - The ID of the transaction to approve.
      */
-    private isTransactionOutdated;
+    private approveTransaction;
+    private publishTransaction;
     /**
-     * Verifies if the status of a local transaction is outdated with respect to the remote transaction.
+     * Cancels a transaction based on its ID by setting its status to "rejected"
+     * and emitting a `<tx.id>:finished` hub event.
      *
-     * @param remoteTxHash - Remote transaction hash.
-     * @param localTxHash - Local transaction hash.
-     * @param remoteTxStatus - Remote transaction status.
-     * @param localTxStatus - Local transaction status.
-     * @returns Whether the status is outdated.
+     * @param transactionID - The ID of the transaction to cancel.
      */
-    private isStatusOutdated;
+    private cancelTransaction;
     /**
-     * Verifies if the gas data of a local transaction is outdated with respect to the remote transaction.
+     * Whether the transaction has at least completed all local processing.
      *
-     * @param remoteGasUsed - Remote gas used in the transaction.
-     * @param localGasUsed - Local gas used in the transaction.
-     * @returns Whether the gas data is outdated.
+     * @param status - The transaction status.
+     * @returns Whether the transaction is in a final state.
      */
-    private isGasDataOutdated;
-    private requestApproval;
-    private acceptApproval;
-    private rejectApproval;
-    private getApprovalId;
+    private isLocalFinalState;
+    private getTransaction;
+    private isTransactionCompleted;
+    private onIncomingTransactions;
+    private onUpdatedLastFetchedBlockNumbers;
+    private getNonceTrackerTransactions;
+    private updateSubmitHistory;
+    private getGasFeeFlows;
 }
 export default TransactionController;
 //# sourceMappingURL=TransactionController.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/TransactionController.d.ts.map b/node_modules/@metamask/transaction-controller/dist/TransactionController.d.ts.map
deleted file mode 100644
index 236aaf1..0000000
--- a/node_modules/@metamask/transaction-controller/dist/TransactionController.d.ts.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"TransactionController.d.ts","sourceRoot":"","sources":["../src/TransactionController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/TransactionController.js b/node_modules/@metamask/transaction-controller/dist/TransactionController.js
index 3edd9c2..c4c72b4 100644
--- a/node_modules/@metamask/transaction-controller/dist/TransactionController.js
+++ b/node_modules/@metamask/transaction-controller/dist/TransactionController.js
@@ -12,7 +12,7 @@ var __importDefault = (this && this.__importDefault) || function (mod) {
     return (mod && mod.__esModule) ? mod : { "default": mod };
 };
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.TransactionController = exports.SPEED_UP_RATE = exports.CANCEL_RATE = exports.WalletDevice = exports.TransactionStatus = void 0;
+exports.TransactionController = exports.SPEED_UP_RATE = exports.CANCEL_RATE = void 0;
 const events_1 = require("events");
 const ethereumjs_util_1 = require("ethereumjs-util");
 const eth_rpc_errors_1 = require("eth-rpc-errors");
@@ -22,40 +22,22 @@ const common_1 = __importDefault(require("@ethereumjs/common"));
 const tx_1 = require("@ethereumjs/tx");
 const uuid_1 = require("uuid");
 const async_mutex_1 = require("async-mutex");
+const lodash_1 = require("lodash");
 const base_controller_1 = require("@metamask/base-controller");
 const controller_utils_1 = require("@metamask/controller-utils");
 const nonce_tracker_1 = __importDefault(require("nonce-tracker"));
 const utils_1 = require("./utils");
+const IncomingTransactionHelper_1 = require("./IncomingTransactionHelper");
+const EtherscanRemoteTransactionSource_1 = require("./EtherscanRemoteTransactionSource");
+const types_1 = require("./types");
+const GasFeePoller_1 = require("./helpers/GasFeePoller");
+const LineaGasFeeFlow_1 = require("./gas-flows/LineaGasFeeFlow");
 const HARDFORK = 'london';
-/**
- * The status of the transaction. Each status represents the state of the transaction internally
- * in the wallet. Some of these correspond with the state of the transaction on the network, but
- * some are wallet-specific.
- */
-var TransactionStatus;
-(function (TransactionStatus) {
-    TransactionStatus["approved"] = "approved";
-    TransactionStatus["cancelled"] = "cancelled";
-    TransactionStatus["confirmed"] = "confirmed";
-    TransactionStatus["failed"] = "failed";
-    TransactionStatus["rejected"] = "rejected";
-    TransactionStatus["signed"] = "signed";
-    TransactionStatus["submitted"] = "submitted";
-    TransactionStatus["unapproved"] = "unapproved";
-})(TransactionStatus = exports.TransactionStatus || (exports.TransactionStatus = {}));
-/**
- * Options for wallet device.
- */
-var WalletDevice;
-(function (WalletDevice) {
-    WalletDevice["MM_MOBILE"] = "metamask_mobile";
-    WalletDevice["MM_EXTENSION"] = "metamask_extension";
-    WalletDevice["OTHER"] = "other_device";
-})(WalletDevice = exports.WalletDevice || (exports.WalletDevice = {}));
+const SUBMIT_HISTORY_LIMIT = 100;
 /**
  * Multiplier used to determine a transaction's increased gas fee during cancellation
  */
-exports.CANCEL_RATE = 1.5;
+exports.CANCEL_RATE = 1.1;
 /**
  * Multiplier used to determine a transaction's increased gas fee during speed up
  */
@@ -72,45 +54,24 @@ class TransactionController extends base_controller_1.BaseController {
      * Creates a TransactionController instance.
      *
      * @param options - The controller options.
+     * @param options.blockTracker - The block tracker used to poll for new blocks data.
+     * @param options.getGasFeeEstimates - Callback to retrieve gas fee estimates.
      * @param options.getNetworkState - Gets the state of the network controller.
+     * @param options.getSelectedAddress - Gets the address of the currently selected account.
+     * @param options.incomingTransactions - Configuration options for incoming transaction support.
+     * @param options.incomingTransactions.apiKey - An optional API key to use when fetching remote transaction data.
+     * @param options.incomingTransactions.includeTokenTransfers - Whether or not to include ERC20 token transfers.
+     * @param options.incomingTransactions.isEnabled - Whether or not incoming transaction retrieval is enabled.
+     * @param options.incomingTransactions.updateTransactions - Whether or not to update local transactions using remote transaction data.
+     * @param options.messenger - The controller messenger.
      * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.
      * @param options.provider - The provider used to create the underlying EthQuery instance.
-     * @param options.blockTracker - The block tracker used to poll for new blocks data.
-     * @param options.messenger - The controller messenger.
      * @param config - Initial options used to configure this controller.
      * @param state - Initial state to set on this controller.
      */
-    constructor({ getNetworkState, onNetworkStateChange, provider, blockTracker, messenger, }, config, state) {
+    constructor({ blockTracker, getGasFeeEstimates, getNetworkState, getSelectedAddress, incomingTransactions = {}, messenger, onNetworkStateChange, provider, }, config, state) {
         super(config, state);
         this.mutex = new async_mutex_1.Mutex();
-        this.normalizeTokenTx = (txMeta, currentNetworkID, currentChainId) => {
-            const time = parseInt(txMeta.timeStamp, 10) * 1000;
-            const { to, from, gas, gasPrice, gasUsed, hash, contractAddress, tokenDecimal, tokenSymbol, value, } = txMeta;
-            return {
-                id: (0, uuid_1.v1)({ msecs: time }),
-                isTransfer: true,
-                networkID: currentNetworkID,
-                chainId: currentChainId,
-                status: TransactionStatus.confirmed,
-                time,
-                transaction: {
-                    chainId: currentChainId,
-                    from,
-                    gas,
-                    gasPrice,
-                    gasUsed,
-                    to,
-                    value,
-                },
-                transactionHash: hash,
-                transferInformation: {
-                    contractAddress,
-                    decimals: Number(tokenDecimal),
-                    symbol: tokenSymbol,
-                },
-                verifiedOnBlockchain: false,
-            };
-        };
         /**
          * EventEmitter instance used to listen to specific transactional events
          */
@@ -126,19 +87,51 @@ class TransactionController extends base_controller_1.BaseController {
         this.defaultState = {
             methodData: {},
             transactions: [],
+            lastFetchedBlockNumbers: {},
+            submitHistory: [],
         };
         this.initialize();
         this.provider = provider;
         this.messagingSystem = messenger;
+        this.getGasFeeEstimates = getGasFeeEstimates;
         this.getNetworkState = getNetworkState;
         this.ethQuery = new eth_query_1.default(provider);
         this.registry = new eth_method_registry_1.default({ provider });
+        this.messagingSystem = messenger;
         this.nonceTracker = new nonce_tracker_1.default({
             provider,
             blockTracker,
-            getPendingTransactions: (address) => (0, utils_1.getAndFormatTransactionsForNonceTracker)(address, TransactionStatus.submitted, this.state.transactions),
-            getConfirmedTransactions: (address) => (0, utils_1.getAndFormatTransactionsForNonceTracker)(address, TransactionStatus.confirmed, this.state.transactions),
+            getPendingTransactions: this.getNonceTrackerTransactions.bind(this, types_1.TransactionStatus.submitted),
+            getConfirmedTransactions: this.getNonceTrackerTransactions.bind(this, types_1.TransactionStatus.confirmed),
+        });
+        this.incomingTransactionHelper = new IncomingTransactionHelper_1.IncomingTransactionHelper({
+            blockTracker,
+            getCurrentAccount: getSelectedAddress,
+            getLastFetchedBlockNumbers: () => this.state.lastFetchedBlockNumbers,
+            getLocalTransactions: () => this.state.transactions,
+            getNetworkState,
+            isEnabled: incomingTransactions.isEnabled,
+            remoteTransactionSource: new EtherscanRemoteTransactionSource_1.EtherscanRemoteTransactionSource({
+                apiKey: incomingTransactions.apiKey,
+                includeTokenTransfers: incomingTransactions.includeTokenTransfers,
+            }),
+            transactionLimit: this.config.txHistoryLimit,
+            updateTransactions: incomingTransactions.updateTransactions,
+        });
+        this.incomingTransactionHelper.hub.on('transactions', this.onIncomingTransactions.bind(this));
+        this.incomingTransactionHelper.hub.on('updatedLastFetchedBlockNumbers', this.onUpdatedLastFetchedBlockNumbers.bind(this));
+        this.gasFeeFlows = this.getGasFeeFlows();
+        const gasFeePoller = new GasFeePoller_1.GasFeePoller({
+            gasFeeFlows: this.gasFeeFlows,
+            getChainIds: () => [this.getNetworkState().providerConfig.chainId],
+            getEthQuery: () => this.ethQuery,
+            getGasFeeControllerEstimates: this.getGasFeeEstimates,
+            getTransactions: () => this.state.transactions,
+            onStateChange: (listener) => {
+                this.subscribe(listener);
+            },
         });
+        gasFeePoller.hub.on('transaction-updated', this.updateTransaction.bind(this));
         onNetworkStateChange(() => {
             this.ethQuery = new eth_query_1.default(this.provider);
             this.registry = new eth_method_registry_1.default({ provider: this.provider });
@@ -146,7 +139,7 @@ class TransactionController extends base_controller_1.BaseController {
         this.poll();
     }
     failTransaction(transactionMeta, error) {
-        const newTransactionMeta = Object.assign(Object.assign({}, transactionMeta), { error, status: TransactionStatus.failed });
+        const newTransactionMeta = Object.assign(Object.assign({}, transactionMeta), { error, status: types_1.TransactionStatus.failed });
         this.updateTransaction(newTransactionMeta);
         this.hub.emit(`${transactionMeta.id}:finished`, newTransactionMeta);
     }
@@ -157,43 +150,6 @@ class TransactionController extends base_controller_1.BaseController {
             return { registryMethod, parsedRegistryMethod };
         });
     }
-    /**
-     * Normalizes the transaction information from etherscan
-     * to be compatible with the TransactionMeta interface.
-     *
-     * @param txMeta - The transaction.
-     * @param currentNetworkID - The current network ID.
-     * @param currentChainId - The current chain ID.
-     * @returns The normalized transaction.
-     */
-    normalizeTx(txMeta, currentNetworkID, currentChainId) {
-        const time = parseInt(txMeta.timeStamp, 10) * 1000;
-        const normalizedTransactionBase = {
-            blockNumber: txMeta.blockNumber,
-            id: (0, uuid_1.v1)({ msecs: time }),
-            networkID: currentNetworkID,
-            chainId: currentChainId,
-            time,
-            transaction: {
-                data: txMeta.input,
-                from: txMeta.from,
-                gas: (0, controller_utils_1.BNToHex)(new ethereumjs_util_1.BN(txMeta.gas)),
-                gasPrice: (0, controller_utils_1.BNToHex)(new ethereumjs_util_1.BN(txMeta.gasPrice)),
-                gasUsed: (0, controller_utils_1.BNToHex)(new ethereumjs_util_1.BN(txMeta.gasUsed)),
-                nonce: (0, controller_utils_1.BNToHex)(new ethereumjs_util_1.BN(txMeta.nonce)),
-                to: txMeta.to,
-                value: (0, controller_utils_1.BNToHex)(new ethereumjs_util_1.BN(txMeta.value)),
-            },
-            transactionHash: txMeta.hash,
-            verifiedOnBlockchain: false,
-        };
-        /* istanbul ignore else */
-        if (txMeta.isError === '0') {
-            return Object.assign(Object.assign({}, normalizedTransactionBase), { status: TransactionStatus.confirmed });
-        }
-        /* istanbul ignore next */
-        return Object.assign(Object.assign({}, normalizedTransactionBase), { error: new Error('Transaction failed'), status: TransactionStatus.failed });
-    }
     /**
      * Starts a new polling interval.
      *
@@ -241,26 +197,29 @@ class TransactionController extends base_controller_1.BaseController {
      * if not provided. If A `<tx.id>:unapproved` hub event will be emitted once added.
      *
      * @param transaction - The transaction object to add.
-     * @param origin - The domain origin to append to the generated TransactionMeta.
-     * @param deviceConfirmedOn - An enum to indicate what device the transaction was confirmed to append to the generated TransactionMeta.
+     * @param opts - Additional options to control how the transaction is added.
+     * @param opts.deviceConfirmedOn - An enum to indicate what device confirmed the transaction.
+     * @param opts.origin - The origin of the transaction request, such as a dApp hostname.
+     * @param opts.securityAlertResponse - Response from security validator.
      * @returns Object containing a promise resolving to the transaction hash if approved.
      */
-    addTransaction(transaction, origin, deviceConfirmedOn) {
+    addTransaction(transaction, { deviceConfirmedOn, origin, securityAlertResponse, } = {}) {
         return __awaiter(this, void 0, void 0, function* () {
             const { providerConfig, networkId } = this.getNetworkState();
             const { transactions } = this.state;
-            transaction = (0, utils_1.normalizeTransaction)(transaction);
+            transaction = (0, utils_1.normalizeTransactionParams)(transaction);
             (0, utils_1.validateTransaction)(transaction);
             const transactionMeta = {
                 id: (0, uuid_1.v1)(),
                 networkID: networkId !== null && networkId !== void 0 ? networkId : undefined,
                 chainId: providerConfig.chainId,
                 origin,
-                status: TransactionStatus.unapproved,
+                status: types_1.TransactionStatus.unapproved,
                 time: Date.now(),
                 transaction,
                 deviceConfirmedOn,
                 verifiedOnBlockchain: false,
+                securityAlertResponse,
             };
             try {
                 const { gas, estimateGasError } = yield this.estimateGas(transaction);
@@ -271,28 +230,24 @@ class TransactionController extends base_controller_1.BaseController {
                 this.failTransaction(transactionMeta, error);
                 return Promise.reject(error);
             }
-            const result = new Promise((resolve, reject) => {
-                this.hub.once(`${transactionMeta.id}:finished`, (meta) => {
-                    switch (meta.status) {
-                        case TransactionStatus.submitted:
-                            return resolve(meta.transactionHash);
-                        case TransactionStatus.rejected:
-                            return reject(eth_rpc_errors_1.ethErrors.provider.userRejectedRequest('User rejected the transaction'));
-                        case TransactionStatus.cancelled:
-                            return reject(eth_rpc_errors_1.ethErrors.rpc.internal('User cancelled the transaction'));
-                        case TransactionStatus.failed:
-                            return reject(eth_rpc_errors_1.ethErrors.rpc.internal(meta.error.message));
-                        /* istanbul ignore next */
-                        default:
-                            return reject(eth_rpc_errors_1.ethErrors.rpc.internal(`MetaMask Tx Signature: Unknown problem: ${JSON.stringify(meta)}`));
-                    }
-                });
-            });
             transactions.push(transactionMeta);
             this.update({ transactions: this.trimTransactionsForState(transactions) });
             this.hub.emit(`unapprovedTransaction`, transactionMeta);
-            this.requestApproval(transactionMeta);
-            return { result, transactionMeta };
+            return {
+                result: this.processApproval(transactionMeta),
+                transactionMeta,
+            };
+        });
+    }
+    startIncomingTransactionPolling() {
+        this.incomingTransactionHelper.start();
+    }
+    stopIncomingTransactionPolling() {
+        this.incomingTransactionHelper.stop();
+    }
+    updateIncomingTransactions() {
+        return __awaiter(this, void 0, void 0, function* () {
+            yield this.incomingTransactionHelper.update();
         });
     }
     prepareUnsignedEthTx(txParams) {
@@ -312,7 +267,9 @@ class TransactionController extends base_controller_1.BaseController {
      */
     getCommonConfiguration() {
         const { networkId, providerConfig: { type: chain, chainId, nickname: name }, } = this.getNetworkState();
-        if (chain !== controller_utils_1.RPC) {
+        if (chain !== controller_utils_1.RPC &&
+            chain !== 'linea-goerli' &&
+            chain !== 'linea-mainnet') {
             return new common_1.default({ chain, hardfork: HARDFORK });
         }
         const customChainParams = {
@@ -322,104 +279,6 @@ class TransactionController extends base_controller_1.BaseController {
         };
         return common_1.default.forCustomChain(controller_utils_1.NetworkType.mainnet, customChainParams, HARDFORK);
     }
-    /**
-     * Approves a transaction and updates it's status in state. If this is not a
-     * retry transaction, a nonce will be generated. The transaction is signed
-     * using the sign configuration property, then published to the blockchain.
-     * A `<tx.id>:finished` hub event is fired after success or failure.
-     *
-     * @param transactionID - The ID of the transaction to approve.
-     */
-    approveTransaction(transactionID) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const { transactions } = this.state;
-            const releaseLock = yield this.mutex.acquire();
-            const { providerConfig } = this.getNetworkState();
-            const { chainId } = providerConfig;
-            const index = transactions.findIndex(({ id }) => transactionID === id);
-            const transactionMeta = transactions[index];
-            const { transaction: { nonce, from }, } = transactionMeta;
-            let nonceLock;
-            try {
-                if (!this.sign) {
-                    releaseLock();
-                    this.failTransaction(transactionMeta, new Error('No sign method defined.'));
-                    this.rejectApproval(transactionMeta);
-                    return;
-                }
-                else if (!chainId) {
-                    releaseLock();
-                    this.failTransaction(transactionMeta, new Error('No chainId defined.'));
-                    this.rejectApproval(transactionMeta);
-                    return;
-                }
-                const { approved: status } = TransactionStatus;
-                let nonceToUse = nonce;
-                // if a nonce already exists on the transactionMeta it means this is a speedup or cancel transaction
-                // so we want to reuse that nonce and hope that it beats the previous attempt to chain. Otherwise use a new locked nonce
-                if (!nonceToUse) {
-                    nonceLock = yield this.nonceTracker.getNonceLock(from);
-                    nonceToUse = (0, ethereumjs_util_1.addHexPrefix)(nonceLock.nextNonce.toString(16));
-                }
-                transactionMeta.status = status;
-                transactionMeta.transaction.nonce = nonceToUse;
-                transactionMeta.transaction.chainId = chainId;
-                const baseTxParams = Object.assign(Object.assign({}, transactionMeta.transaction), { gasLimit: transactionMeta.transaction.gas });
-                const isEIP1559 = (0, utils_1.isEIP1559Transaction)(transactionMeta.transaction);
-                const txParams = isEIP1559
-                    ? Object.assign(Object.assign({}, baseTxParams), { maxFeePerGas: transactionMeta.transaction.maxFeePerGas, maxPriorityFeePerGas: transactionMeta.transaction.maxPriorityFeePerGas, estimatedBaseFee: transactionMeta.transaction.estimatedBaseFee, 
-                        // specify type 2 if maxFeePerGas and maxPriorityFeePerGas are set
-                        type: 2 }) : baseTxParams;
-                // delete gasPrice if maxFeePerGas and maxPriorityFeePerGas are set
-                if (isEIP1559) {
-                    delete txParams.gasPrice;
-                }
-                const unsignedEthTx = this.prepareUnsignedEthTx(txParams);
-                const signedTx = yield this.sign(unsignedEthTx, from);
-                transactionMeta.status = TransactionStatus.signed;
-                this.updateTransaction(transactionMeta);
-                const rawTransaction = (0, ethereumjs_util_1.bufferToHex)(signedTx.serialize());
-                transactionMeta.rawTransaction = rawTransaction;
-                this.updateTransaction(transactionMeta);
-                const transactionHash = yield (0, controller_utils_1.query)(this.ethQuery, 'sendRawTransaction', [
-                    rawTransaction,
-                ]);
-                transactionMeta.transactionHash = transactionHash;
-                transactionMeta.status = TransactionStatus.submitted;
-                this.updateTransaction(transactionMeta);
-                this.hub.emit(`${transactionMeta.id}:finished`, transactionMeta);
-                this.acceptApproval(transactionMeta);
-            }
-            catch (error) {
-                this.failTransaction(transactionMeta, error);
-                this.rejectApproval(transactionMeta);
-            }
-            finally {
-                // must set transaction to submitted/failed before releasing lock
-                if (nonceLock) {
-                    nonceLock.releaseLock();
-                }
-                releaseLock();
-            }
-        });
-    }
-    /**
-     * Cancels a transaction based on its ID by setting its status to "rejected"
-     * and emitting a `<tx.id>:finished` hub event.
-     *
-     * @param transactionID - The ID of the transaction to cancel.
-     */
-    cancelTransaction(transactionID) {
-        const transactionMeta = this.state.transactions.find(({ id }) => id === transactionID);
-        if (!transactionMeta) {
-            return;
-        }
-        transactionMeta.status = TransactionStatus.rejected;
-        this.hub.emit(`${transactionMeta.id}:finished`, transactionMeta);
-        const transactions = this.state.transactions.filter(({ id }) => id !== transactionID);
-        this.update({ transactions: this.trimTransactionsForState(transactions) });
-        this.rejectApproval(transactionMeta);
-    }
     /**
      * Attempts to cancel a transaction based on its ID by setting its status to "rejected"
      * and emitting a `<tx.id>:finished` hub event.
@@ -482,10 +341,9 @@ class TransactionController extends base_controller_1.BaseController {
             const unsignedEthTx = this.prepareUnsignedEthTx(txParams);
             const signedTx = yield this.sign(unsignedEthTx, transactionMeta.transaction.from);
             const rawTransaction = (0, ethereumjs_util_1.bufferToHex)(signedTx.serialize());
-            yield (0, controller_utils_1.query)(this.ethQuery, 'sendRawTransaction', [rawTransaction]);
-            transactionMeta.status = TransactionStatus.cancelled;
+            yield this.publishTransaction(rawTransaction, txParams, transactionMeta.chainId, 'cancel');
+            transactionMeta.status = types_1.TransactionStatus.cancelled;
             this.hub.emit(`${transactionMeta.id}:finished`, transactionMeta);
-            this.rejectApproval(transactionMeta);
         });
     }
     /**
@@ -535,9 +393,7 @@ class TransactionController extends base_controller_1.BaseController {
             const unsignedEthTx = this.prepareUnsignedEthTx(txParams);
             const signedTx = yield this.sign(unsignedEthTx, transactionMeta.transaction.from);
             const rawTransaction = (0, ethereumjs_util_1.bufferToHex)(signedTx.serialize());
-            const transactionHash = yield (0, controller_utils_1.query)(this.ethQuery, 'sendRawTransaction', [
-                rawTransaction,
-            ]);
+            const transactionHash = yield this.publishTransaction(rawTransaction, txParams, transactionMeta.chainId, controller_utils_1.ORIGIN_METAMASK);
             const baseTransactionMeta = Object.assign(Object.assign({}, transactionMeta), { id: (0, uuid_1.v1)(), time: Date.now(), transactionHash });
             const newTransactionMeta = newMaxFeePerGas && newMaxPriorityFeePerGas
                 ? Object.assign(Object.assign({}, baseTransactionMeta), { transaction: Object.assign(Object.assign({}, transactionMeta.transaction), { maxFeePerGas: newMaxFeePerGas, maxPriorityFeePerGas: newMaxPriorityFeePerGas }) }) : Object.assign(Object.assign({}, baseTransactionMeta), { transaction: Object.assign(Object.assign({}, transactionMeta.transaction), { gasPrice: newGasPrice }) });
@@ -596,6 +452,8 @@ class TransactionController extends base_controller_1.BaseController {
             }
             catch (error) {
                 estimateGasError = utils_1.ESTIMATE_GAS_ERROR;
+                // Fallback to 95% of the block gasLimit.
+                gasHex = estimatedTransaction.gas;
             }
             // 4. Pad estimated gas without exceeding the most recent block gasLimit. If the network is a
             // a custom network then return the eth_estimateGas value.
@@ -655,12 +513,29 @@ class TransactionController extends base_controller_1.BaseController {
      */
     updateTransaction(transactionMeta) {
         const { transactions } = this.state;
-        transactionMeta.transaction = (0, utils_1.normalizeTransaction)(transactionMeta.transaction);
+        transactionMeta.transaction = (0, utils_1.normalizeTransactionParams)(transactionMeta.transaction);
         (0, utils_1.validateTransaction)(transactionMeta.transaction);
         const index = transactions.findIndex(({ id }) => transactionMeta.id === id);
         transactions[index] = transactionMeta;
         this.update({ transactions: this.trimTransactionsForState(transactions) });
     }
+    /**
+     * Update the security alert response for a transaction.
+     *
+     * @param transactionId - ID of the transaction.
+     * @param securityAlertResponse - The new security alert response for the transaction.
+     */
+    updateSecurityAlertResponse(transactionId, securityAlertResponse) {
+        if (!securityAlertResponse) {
+            throw new Error('updateSecurityAlertResponse: securityAlertResponse should not be null');
+        }
+        const transactionMeta = this.getTransaction(transactionId);
+        if (!transactionMeta) {
+            throw new Error(`Cannot update security alert response as no transaction metadata found`);
+        }
+        const updatedMeta = (0, lodash_1.merge)(transactionMeta, { securityAlertResponse });
+        this.updateTransaction(updatedMeta);
+    }
     /**
      * Removes all transactions from state, optionally based on the current network.
      *
@@ -686,67 +561,15 @@ class TransactionController extends base_controller_1.BaseController {
         });
     }
     /**
-     * Get transactions from Etherscan for the given address. By default all transactions are
-     * returned, but the `fromBlock` option can be given to filter just for transactions from a
-     * specific block onward.
+     * Gets the next nonce according to the nonce-tracker.
+     * Ensure `releaseLock` is called once processing of the `nonce` value is complete.
      *
-     * @param address - The address to fetch the transactions for.
-     * @param opt - Object containing optional data, fromBlock and Etherscan API key.
-     * @returns The block number of the latest incoming transaction.
+     * @param address - The hex string address for the transaction.
+     * @returns object with the `nextNonce` `nonceDetails`, and the releaseLock.
      */
-    fetchAll(address, opt) {
+    getNonceLock(address) {
         return __awaiter(this, void 0, void 0, function* () {
-            const { providerConfig, networkId: currentNetworkID } = this.getNetworkState();
-            const { chainId: currentChainId, type: networkType } = providerConfig;
-            const { transactions } = this.state;
-            const supportedNetworkIds = ['1', '5', '11155111'];
-            /* istanbul ignore next */
-            if (currentNetworkID === null ||
-                supportedNetworkIds.indexOf(currentNetworkID) === -1) {
-                return undefined;
-            }
-            const [etherscanTxResponse, etherscanTokenResponse] = yield (0, utils_1.handleTransactionFetch)(networkType, address, this.config.txHistoryLimit, opt);
-            const normalizedTxs = etherscanTxResponse.result.map((tx) => this.normalizeTx(tx, currentNetworkID, currentChainId));
-            const normalizedTokenTxs = etherscanTokenResponse.result.map((tx) => this.normalizeTokenTx(tx, currentNetworkID, currentChainId));
-            const [updateRequired, allTxs] = this.etherscanTransactionStateReconciler([...normalizedTxs, ...normalizedTokenTxs], transactions);
-            allTxs.sort((a, b) => (a.time < b.time ? -1 : 1));
-            let latestIncomingTxBlockNumber;
-            allTxs.forEach((tx) => __awaiter(this, void 0, void 0, function* () {
-                /* istanbul ignore next */
-                if (
-                // Using fallback to networkID only when there is no chainId present. Should be removed when networkID is completely removed.
-                (tx.chainId === currentChainId ||
-                    (!tx.chainId && tx.networkID === currentNetworkID)) &&
-                    tx.transaction.to &&
-                    tx.transaction.to.toLowerCase() === address.toLowerCase()) {
-                    if (tx.blockNumber &&
-                        (!latestIncomingTxBlockNumber ||
-                            parseInt(latestIncomingTxBlockNumber, 10) <
-                                parseInt(tx.blockNumber, 10))) {
-                        latestIncomingTxBlockNumber = tx.blockNumber;
-                    }
-                }
-                /* istanbul ignore else */
-                if (tx.toSmartContract === undefined) {
-                    // If not `to` is a contract deploy, if not `data` is send eth
-                    if (tx.transaction.to &&
-                        (!tx.transaction.data || tx.transaction.data !== '0x')) {
-                        const code = yield (0, controller_utils_1.query)(this.ethQuery, 'getCode', [
-                            tx.transaction.to,
-                        ]);
-                        tx.toSmartContract = (0, controller_utils_1.isSmartContractCode)(code);
-                    }
-                    else {
-                        tx.toSmartContract = false;
-                    }
-                }
-            }));
-            // Update state only if new transactions were fetched or
-            // the status or gas data of a transaction has changed
-            if (updateRequired) {
-                this.update({ transactions: this.trimTransactionsForState(allTxs) });
-            }
-            return latestIncomingTxBlockNumber;
+            return this.nonceTracker.getNonceLock(address);
         });
     }
     /**
@@ -765,7 +588,9 @@ class TransactionController extends base_controller_1.BaseController {
      */
     trimTransactionsForState(transactions) {
         const nonceNetworkSet = new Set();
-        const txsToKeep = transactions.reverse().filter((tx) => {
+        const txsToKeep = transactions
+            .sort((a, b) => (a.time > b.time ? -1 : 1)) // Descending time order
+            .filter((tx) => {
             const { chainId, networkID, status, transaction, time } = tx;
             if (transaction) {
                 const key = `${transaction.nonce}-${chainId ? (0, controller_utils_1.convertHexToDecimal)(chainId) : networkID}-${new Date(time).toDateString()}`;
@@ -780,7 +605,7 @@ class TransactionController extends base_controller_1.BaseController {
             }
             return false;
         });
-        txsToKeep.reverse();
+        txsToKeep.reverse(); // Ascending time order
         return txsToKeep;
     }
     /**
@@ -790,10 +615,10 @@ class TransactionController extends base_controller_1.BaseController {
      * @returns Whether the transaction is in a final state.
      */
     isFinalState(status) {
-        return (status === TransactionStatus.rejected ||
-            status === TransactionStatus.confirmed ||
-            status === TransactionStatus.failed ||
-            status === TransactionStatus.cancelled);
+        return (status === types_1.TransactionStatus.rejected ||
+            status === types_1.TransactionStatus.confirmed ||
+            status === types_1.TransactionStatus.failed ||
+            status === types_1.TransactionStatus.cancelled);
     }
     /**
      * Method to verify the state of a transaction using the Blockchain as a source of truth.
@@ -805,7 +630,7 @@ class TransactionController extends base_controller_1.BaseController {
         return __awaiter(this, void 0, void 0, function* () {
             const { status, transactionHash } = meta;
             switch (status) {
-                case TransactionStatus.confirmed:
+                case types_1.TransactionStatus.confirmed:
                     const txReceipt = yield (0, controller_utils_1.query)(this.ethQuery, 'getTransactionReceipt', [
                         transactionHash,
                     ]);
@@ -822,7 +647,7 @@ class TransactionController extends base_controller_1.BaseController {
                         return [meta, false];
                     }
                     return [meta, true];
-                case TransactionStatus.submitted:
+                case types_1.TransactionStatus.submitted:
                     const txObj = yield (0, controller_utils_1.query)(this.ethQuery, 'getTransactionByHash', [
                         transactionHash,
                     ]);
@@ -837,9 +662,17 @@ class TransactionController extends base_controller_1.BaseController {
                     }
                     /* istanbul ignore next */
                     if (txObj === null || txObj === void 0 ? void 0 : txObj.blockNumber) {
-                        meta.status = TransactionStatus.confirmed;
-                        this.hub.emit(`${meta.id}:confirmed`, meta);
-                        return [meta, true];
+                        // transactions can be added to a block and still fail, so we need to check the transaction status before emitting the confirmed event
+                        const txStatusFailed = yield this.checkTxReceiptStatusIsFailed(transactionHash);
+                        if (txStatusFailed) {
+                            const error = new Error('Transaction failed. The transaction was reversed');
+                            this.failTransaction(meta, error);
+                        }
+                        else {
+                            meta.status = types_1.TransactionStatus.confirmed;
+                            this.hub.emit(`${meta.id}:confirmed`, meta);
+                            return [meta, true];
+                        }
                     }
                     return [meta, false];
                 default:
@@ -868,128 +701,236 @@ class TransactionController extends base_controller_1.BaseController {
             return Number(txReceipt.status) === 0;
         });
     }
-    /**
-     * Method to verify the state of transactions using Etherscan as a source of truth.
-     *
-     * @param remoteTxs - Transactions to reconcile that are from a remote source.
-     * @param localTxs - Transactions to reconcile that are local.
-     * @returns A tuple containing a boolean indicating whether or not an update was required, and the updated transaction.
-     */
-    etherscanTransactionStateReconciler(remoteTxs, localTxs) {
-        const updatedTxs = this.getUpdatedTransactions(remoteTxs, localTxs);
-        const newTxs = this.getNewTransactions(remoteTxs, localTxs);
-        const updatedLocalTxs = localTxs.map((tx) => {
-            const txIdx = updatedTxs.findIndex(({ transactionHash }) => transactionHash === tx.transactionHash);
-            return txIdx === -1 ? tx : updatedTxs[txIdx];
+    processApproval(transactionMeta) {
+        return __awaiter(this, void 0, void 0, function* () {
+            const transactionId = transactionMeta.id;
+            let resultCallbacks;
+            try {
+                const acceptResult = yield this.requestApproval(transactionMeta);
+                resultCallbacks = acceptResult.resultCallbacks;
+                const { meta, isCompleted } = this.isTransactionCompleted(transactionId);
+                if (meta && !isCompleted) {
+                    yield this.approveTransaction(transactionId);
+                }
+            }
+            catch (error) {
+                const { meta, isCompleted } = this.isTransactionCompleted(transactionId);
+                if (meta && !isCompleted) {
+                    if (error.code === eth_rpc_errors_1.errorCodes.provider.userRejectedRequest) {
+                        this.cancelTransaction(transactionId);
+                        throw eth_rpc_errors_1.ethErrors.provider.userRejectedRequest('User rejected the transaction');
+                    }
+                    else {
+                        this.failTransaction(meta, error);
+                    }
+                }
+            }
+            const finalMeta = this.getTransaction(transactionId);
+            switch (finalMeta === null || finalMeta === void 0 ? void 0 : finalMeta.status) {
+                case types_1.TransactionStatus.failed:
+                    resultCallbacks === null || resultCallbacks === void 0 ? void 0 : resultCallbacks.error(finalMeta.error);
+                    throw eth_rpc_errors_1.ethErrors.rpc.internal(finalMeta.error.message);
+                case types_1.TransactionStatus.cancelled:
+                    const cancelError = eth_rpc_errors_1.ethErrors.rpc.internal('User cancelled the transaction');
+                    resultCallbacks === null || resultCallbacks === void 0 ? void 0 : resultCallbacks.error(cancelError);
+                    throw cancelError;
+                case types_1.TransactionStatus.submitted:
+                    resultCallbacks === null || resultCallbacks === void 0 ? void 0 : resultCallbacks.success();
+                    return finalMeta.transactionHash;
+                default:
+                    const internalError = eth_rpc_errors_1.ethErrors.rpc.internal(`MetaMask Tx Signature: Unknown problem: ${JSON.stringify(finalMeta || transactionId)}`);
+                    resultCallbacks === null || resultCallbacks === void 0 ? void 0 : resultCallbacks.error(internalError);
+                    throw internalError;
+            }
         });
-        const updateRequired = newTxs.length > 0 || updatedLocalTxs.length > 0;
-        return [updateRequired, [...newTxs, ...updatedLocalTxs]];
     }
-    /**
-     * Get all transactions that are in the remote transactions array
-     * but not in the local transactions array.
-     *
-     * @param remoteTxs - Array of transactions from remote source.
-     * @param localTxs - Array of transactions stored locally.
-     * @returns The new transactions.
-     */
-    getNewTransactions(remoteTxs, localTxs) {
-        return remoteTxs.filter((tx) => {
-            const alreadyInTransactions = localTxs.find(({ transactionHash }) => transactionHash === tx.transactionHash);
-            return !alreadyInTransactions;
+    requestApproval(txMeta) {
+        return __awaiter(this, void 0, void 0, function* () {
+            const id = this.getApprovalId(txMeta);
+            const { origin } = txMeta;
+            const type = 'transaction';
+            const requestData = { txId: txMeta.id };
+            return this.messagingSystem.call('ApprovalController:addRequest', {
+                id,
+                origin: origin || 'metamask',
+                type,
+                requestData,
+                expectsResult: true,
+            }, true);
         });
     }
+    getApprovalId(txMeta) {
+        return String(txMeta.id);
+    }
     /**
-     * Get all the transactions that are locally outdated with respect
-     * to a remote source (etherscan or blockchain). The returned array
-     * contains the transactions with the updated data.
+     * Approves a transaction and updates it's status in state. If this is not a
+     * retry transaction, a nonce will be generated. The transaction is signed
+     * using the sign configuration property, then published to the blockchain.
+     * A `<tx.id>:finished` hub event is fired after success or failure.
      *
-     * @param remoteTxs - Array of transactions from remote source.
-     * @param localTxs - Array of transactions stored locally.
-     * @returns The updated transactions.
+     * @param transactionID - The ID of the transaction to approve.
      */
-    getUpdatedTransactions(remoteTxs, localTxs) {
-        return remoteTxs.filter((remoteTx) => {
-            const isTxOutdated = localTxs.find((localTx) => {
-                return (remoteTx.transactionHash === localTx.transactionHash &&
-                    this.isTransactionOutdated(remoteTx, localTx));
-            });
-            return isTxOutdated;
+    approveTransaction(transactionID) {
+        return __awaiter(this, void 0, void 0, function* () {
+            const { transactions } = this.state;
+            const releaseLock = yield this.mutex.acquire();
+            const { providerConfig } = this.getNetworkState();
+            const { chainId: currentChainId } = providerConfig;
+            const index = transactions.findIndex(({ id }) => transactionID === id);
+            const transactionMeta = transactions[index];
+            const { transaction: { nonce, from }, } = transactionMeta;
+            let nonceLock;
+            try {
+                if (!this.sign) {
+                    releaseLock();
+                    this.failTransaction(transactionMeta, new Error('No sign method defined.'));
+                    return;
+                }
+                else if (!currentChainId) {
+                    releaseLock();
+                    this.failTransaction(transactionMeta, new Error('No chainId defined.'));
+                    return;
+                }
+                const { approved: status } = types_1.TransactionStatus;
+                let nonceToUse = nonce;
+                // if a nonce already exists on the transactionMeta it means this is a speedup or cancel transaction
+                // so we want to reuse that nonce and hope that it beats the previous attempt to chain. Otherwise use a new locked nonce
+                if (!nonceToUse) {
+                    nonceLock = yield this.nonceTracker.getNonceLock(from);
+                    nonceToUse = (0, ethereumjs_util_1.addHexPrefix)(nonceLock.nextNonce.toString(16));
+                }
+                transactionMeta.status = status;
+                transactionMeta.transaction.nonce = nonceToUse;
+                transactionMeta.transaction.chainId = currentChainId;
+                const baseTxParams = Object.assign(Object.assign({}, transactionMeta.transaction), { gasLimit: transactionMeta.transaction.gas });
+                const isEIP1559 = (0, utils_1.isEIP1559Transaction)(transactionMeta.transaction);
+                const txParams = isEIP1559
+                    ? Object.assign(Object.assign({}, baseTxParams), { maxFeePerGas: transactionMeta.transaction.maxFeePerGas, maxPriorityFeePerGas: transactionMeta.transaction.maxPriorityFeePerGas, estimatedBaseFee: transactionMeta.transaction.estimatedBaseFee, 
+                        // specify type 2 if maxFeePerGas and maxPriorityFeePerGas are set
+                        type: 2 }) : baseTxParams;
+                // delete gasPrice if maxFeePerGas and maxPriorityFeePerGas are set
+                if (isEIP1559) {
+                    delete txParams.gasPrice;
+                }
+                const unsignedEthTx = this.prepareUnsignedEthTx(txParams);
+                const signedTx = yield this.sign(unsignedEthTx, from);
+                transactionMeta.status = types_1.TransactionStatus.signed;
+                this.updateTransaction(transactionMeta);
+                const rawTransaction = (0, ethereumjs_util_1.bufferToHex)(signedTx.serialize());
+                transactionMeta.rawTransaction = rawTransaction;
+                this.updateTransaction(transactionMeta);
+                const transactionHash = yield this.publishTransaction(rawTransaction, txParams, currentChainId, transactionMeta.origin);
+                transactionMeta.transactionHash = transactionHash;
+                transactionMeta.status = types_1.TransactionStatus.submitted;
+                this.updateTransaction(transactionMeta);
+                this.hub.emit(`${transactionMeta.id}:finished`, transactionMeta);
+            }
+            catch (error) {
+                this.failTransaction(transactionMeta, error);
+            }
+            finally {
+                // must set transaction to submitted/failed before releasing lock
+                if (nonceLock) {
+                    nonceLock.releaseLock();
+                }
+                releaseLock();
+            }
         });
     }
-    /**
-     * Verifies if a local transaction is outdated with respect to the remote transaction.
-     *
-     * @param remoteTx - The remote transaction from Etherscan.
-     * @param localTx - The local transaction.
-     * @returns Whether the transaction is outdated.
-     */
-    isTransactionOutdated(remoteTx, localTx) {
-        const statusOutdated = this.isStatusOutdated(remoteTx.transactionHash, localTx.transactionHash, remoteTx.status, localTx.status);
-        const gasDataOutdated = this.isGasDataOutdated(remoteTx.transaction.gasUsed, localTx.transaction.gasUsed);
-        return statusOutdated || gasDataOutdated;
+    publishTransaction(rawTransaction, transaction, chainId, origin) {
+        return __awaiter(this, void 0, void 0, function* () {
+            const transactionHash = yield (0, controller_utils_1.query)(this.ethQuery, 'sendRawTransaction', [
+                rawTransaction,
+            ]);
+            this.updateSubmitHistory(rawTransaction, transactionHash, transaction, chainId, origin);
+            return transactionHash;
+        });
     }
     /**
-     * Verifies if the status of a local transaction is outdated with respect to the remote transaction.
+     * Cancels a transaction based on its ID by setting its status to "rejected"
+     * and emitting a `<tx.id>:finished` hub event.
      *
-     * @param remoteTxHash - Remote transaction hash.
-     * @param localTxHash - Local transaction hash.
-     * @param remoteTxStatus - Remote transaction status.
-     * @param localTxStatus - Local transaction status.
-     * @returns Whether the status is outdated.
+     * @param transactionID - The ID of the transaction to cancel.
      */
-    isStatusOutdated(remoteTxHash, localTxHash, remoteTxStatus, localTxStatus) {
-        return remoteTxHash === localTxHash && remoteTxStatus !== localTxStatus;
+    cancelTransaction(transactionID) {
+        const transactionMeta = this.state.transactions.find(({ id }) => id === transactionID);
+        if (!transactionMeta) {
+            return;
+        }
+        transactionMeta.status = types_1.TransactionStatus.rejected;
+        this.hub.emit(`${transactionMeta.id}:finished`, transactionMeta);
+        const transactions = this.state.transactions.filter(({ id }) => id !== transactionID);
+        this.update({ transactions: this.trimTransactionsForState(transactions) });
     }
     /**
-     * Verifies if the gas data of a local transaction is outdated with respect to the remote transaction.
+     * Whether the transaction has at least completed all local processing.
      *
-     * @param remoteGasUsed - Remote gas used in the transaction.
-     * @param localGasUsed - Local gas used in the transaction.
-     * @returns Whether the gas data is outdated.
+     * @param status - The transaction status.
+     * @returns Whether the transaction is in a final state.
      */
-    isGasDataOutdated(remoteGasUsed, localGasUsed) {
-        return remoteGasUsed !== localGasUsed;
-    }
-    requestApproval(txMeta, { shouldShowRequest } = { shouldShowRequest: true }) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const id = this.getApprovalId(txMeta);
-            const { origin } = txMeta;
-            const type = controller_utils_1.ApprovalType.Transaction;
-            const requestData = { txId: txMeta.id };
-            try {
-                yield this.messagingSystem.call('ApprovalController:addRequest', {
-                    id,
-                    origin: origin || controller_utils_1.ORIGIN_METAMASK,
-                    type,
-                    requestData,
-                }, shouldShowRequest);
-            }
-            catch (error) {
-                console.info('Failed to request transaction approval', error);
-            }
-        });
-    }
-    acceptApproval(txMeta) {
-        const id = this.getApprovalId(txMeta);
-        try {
-            this.messagingSystem.call('ApprovalController:acceptRequest', id);
-        }
-        catch (error) {
-            console.info('Failed to accept transaction approval request', error);
-        }
+    isLocalFinalState(status) {
+        return [
+            types_1.TransactionStatus.cancelled,
+            types_1.TransactionStatus.confirmed,
+            types_1.TransactionStatus.failed,
+            types_1.TransactionStatus.rejected,
+            types_1.TransactionStatus.submitted,
+        ].includes(status);
+    }
+    getTransaction(transactionID) {
+        const { transactions } = this.state;
+        return transactions.find(({ id }) => id === transactionID);
     }
-    rejectApproval(txMeta) {
-        const id = this.getApprovalId(txMeta);
-        try {
-            this.messagingSystem.call('ApprovalController:rejectRequest', id, new Error('Rejected'));
+    isTransactionCompleted(transactionid) {
+        const transaction = this.getTransaction(transactionid);
+        if (!transaction) {
+            return { meta: undefined, isCompleted: false };
         }
-        catch (error) {
-            console.info('Failed to reject transaction approval request', error);
+        const isCompleted = this.isLocalFinalState(transaction.status);
+        return { meta: transaction, isCompleted };
+    }
+    onIncomingTransactions({ added, updated, }) {
+        const { transactions: currentTransactions } = this.state;
+        const updatedTransactions = [
+            ...added,
+            ...currentTransactions.map((originalTransaction) => {
+                const updatedTransaction = updated.find(({ transactionHash }) => transactionHash === originalTransaction.transactionHash);
+                return updatedTransaction !== null && updatedTransaction !== void 0 ? updatedTransaction : originalTransaction;
+            }),
+        ];
+        this.update({
+            transactions: this.trimTransactionsForState(updatedTransactions),
+        });
+        this.hub.emit('incomingTransactions', { added, updated });
+    }
+    onUpdatedLastFetchedBlockNumbers({ lastFetchedBlockNumbers, blockNumber, }) {
+        this.update({ lastFetchedBlockNumbers });
+        this.hub.emit('incomingTransactionBlock', blockNumber);
+    }
+    getNonceTrackerTransactions(status, address) {
+        const { chainId: currentChainId } = this.getNetworkState().providerConfig;
+        return (0, utils_1.getAndFormatTransactionsForNonceTracker)(currentChainId, address, status, this.state.transactions);
+    }
+    updateSubmitHistory(rawTransaction, hash, transaction, chainId, origin) {
+        const { rpcUrl: networkUrl, type: networkType } = this.getNetworkState().providerConfig;
+        const submitHistoryEntry = {
+            chainId,
+            hash,
+            networkType,
+            networkUrl,
+            origin,
+            time: Date.now(),
+            transaction,
+            rawTransaction,
+        };
+        const submitHistory = [submitHistoryEntry, ...this.state.submitHistory];
+        if (submitHistory.length > SUBMIT_HISTORY_LIMIT) {
+            submitHistory.pop();
         }
+        this.update({ submitHistory });
     }
-    getApprovalId(txMeta) {
-        return String(txMeta.id);
+    getGasFeeFlows() {
+        return [new LineaGasFeeFlow_1.LineaGasFeeFlow()];
     }
 }
 exports.TransactionController = TransactionController;
diff --git a/node_modules/@metamask/transaction-controller/dist/TransactionController.js.map b/node_modules/@metamask/transaction-controller/dist/TransactionController.js.map
deleted file mode 100644
index e356498..0000000
--- a/node_modules/@metamask/transaction-controller/dist/TransactionController.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"TransactionController.js","sourceRoot":"","sources":["../src/TransactionController.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from 'events';\nimport { addHexPrefix, bufferToHex, BN } from 'ethereumjs-util';\nimport { ethErrors } from 'eth-rpc-errors';\nimport MethodRegistry from 'eth-method-registry';\nimport EthQuery from 'eth-query';\nimport Common from '@ethereumjs/common';\nimport { TransactionFactory, TypedTransaction } from '@ethereumjs/tx';\nimport { v1 as random } from 'uuid';\nimport { Mutex } from 'async-mutex';\nimport type { Hex } from '@metamask/utils';\nimport {\n  BaseController,\n  BaseConfig,\n  BaseState,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport type {\n  BlockTracker,\n  NetworkState,\n  Provider,\n} from '@metamask/network-controller';\nimport {\n  BNToHex,\n  fractionBN,\n  hexToBN,\n  safelyExecute,\n  isSmartContractCode,\n  query,\n  NetworkType,\n  RPC,\n  ApprovalType,\n  ORIGIN_METAMASK,\n  convertHexToDecimal,\n} from '@metamask/controller-utils';\nimport {\n  AcceptRequest as AcceptApprovalRequest,\n  AddApprovalRequest,\n  RejectRequest as RejectApprovalRequest,\n} from '@metamask/approval-controller';\nimport NonceTracker from 'nonce-tracker';\nimport {\n  getAndFormatTransactionsForNonceTracker,\n  normalizeTransaction,\n  validateTransaction,\n  handleTransactionFetch,\n  getIncreasedPriceFromExisting,\n  isEIP1559Transaction,\n  isGasPriceValue,\n  isFeeMarketEIP1559Values,\n  validateGasValues,\n  validateMinimumIncrease,\n  ESTIMATE_GAS_ERROR,\n} from './utils';\n\nconst HARDFORK = 'london';\n\n/**\n * @type Result\n * @property result - Promise resolving to a new transaction hash\n * @property transactionMeta - Meta information about this new transaction\n */\nexport interface Result {\n  result: Promise<string>;\n  transactionMeta: TransactionMeta;\n}\n\n/**\n * @type Fetch All Options\n * @property fromBlock - String containing a specific block decimal number\n * @property etherscanApiKey - API key to be used to fetch token transactions\n */\nexport interface FetchAllOptions {\n  fromBlock?: string;\n  etherscanApiKey?: string;\n}\n\n/**\n * @type Transaction\n *\n * Transaction representation\n * @property chainId - Network ID as per EIP-155\n * @property data - Data to pass with this transaction\n * @property from - Address to send this transaction from\n * @property gas - Gas to send with this transaction\n * @property gasPrice - Price of gas with this transaction\n * @property gasUsed -  Gas used in the transaction\n * @property nonce - Unique number to prevent replay attacks\n * @property to - Address to send this transaction to\n * @property value - Value associated with this transaction\n */\nexport interface Transaction {\n  chainId?: Hex;\n  data?: string;\n  from: string;\n  gas?: string;\n  gasPrice?: string;\n  gasUsed?: string;\n  nonce?: string;\n  to?: string;\n  value?: string;\n  maxFeePerGas?: string;\n  maxPriorityFeePerGas?: string;\n  estimatedBaseFee?: string;\n  estimateGasError?: string;\n}\n\nexport interface GasPriceValue {\n  gasPrice: string;\n}\n\nexport interface FeeMarketEIP1559Values {\n  maxFeePerGas: string;\n  maxPriorityFeePerGas: string;\n}\n\n/**\n * The status of the transaction. Each status represents the state of the transaction internally\n * in the wallet. Some of these correspond with the state of the transaction on the network, but\n * some are wallet-specific.\n */\nexport enum TransactionStatus {\n  approved = 'approved',\n  cancelled = 'cancelled',\n  confirmed = 'confirmed',\n  failed = 'failed',\n  rejected = 'rejected',\n  signed = 'signed',\n  submitted = 'submitted',\n  unapproved = 'unapproved',\n}\n\n/**\n * Options for wallet device.\n */\nexport enum WalletDevice {\n  MM_MOBILE = 'metamask_mobile',\n  MM_EXTENSION = 'metamask_extension',\n  OTHER = 'other_device',\n}\n\ntype TransactionMetaBase = {\n  isTransfer?: boolean;\n  transferInformation?: {\n    symbol: string;\n    contractAddress: string;\n    decimals: number;\n  };\n  id: string;\n  networkID?: string;\n  chainId?: Hex;\n  origin?: string;\n  rawTransaction?: string;\n  time: number;\n  toSmartContract?: boolean;\n  transaction: Transaction;\n  transactionHash?: string;\n  blockNumber?: string;\n  deviceConfirmedOn?: WalletDevice;\n  verifiedOnBlockchain?: boolean;\n};\n\n/**\n * @type TransactionMeta\n *\n * TransactionMeta representation\n * @property error - Synthesized error information for failed transactions\n * @property id - Generated UUID associated with this transaction\n * @property networkID - Network code as per EIP-155 for this transaction\n * @property origin - Origin this transaction was sent from\n * @property deviceConfirmedOn - string to indicate what device the transaction was confirmed\n * @property rawTransaction - Hex representation of the underlying transaction\n * @property status - String status of this transaction\n * @property time - Timestamp associated with this transaction\n * @property toSmartContract - Whether transaction recipient is a smart contract\n * @property transaction - Underlying Transaction object\n * @property transactionHash - Hash of a successful transaction\n * @property blockNumber - Number of the block where the transaction has been included\n */\nexport type TransactionMeta =\n  | ({\n      status: Exclude<TransactionStatus, TransactionStatus.failed>;\n    } & TransactionMetaBase)\n  | ({ status: TransactionStatus.failed; error: Error } & TransactionMetaBase);\n\n/**\n * @type EtherscanTransactionMeta\n *\n * EtherscanTransactionMeta representation\n * @property blockNumber - Number of the block where the transaction has been included\n * @property timeStamp - Timestamp associated with this transaction\n * @property hash - Hash of a successful transaction\n * @property nonce - Nonce of the transaction\n * @property blockHash - Hash of the block where the transaction has been included\n * @property transactionIndex - Etherscan internal index for this transaction\n * @property from - Address to send this transaction from\n * @property to - Address to send this transaction to\n * @property gas - Gas to send with this transaction\n * @property gasPrice - Price of gas with this transaction\n * @property isError - Synthesized error information for failed transactions\n * @property txreceipt_status - Receipt status for this transaction\n * @property input - input of the transaction\n * @property contractAddress - Address of the contract\n * @property cumulativeGasUsed - Amount of gas used\n * @property confirmations - Number of confirmations\n */\nexport interface EtherscanTransactionMeta {\n  blockNumber: string;\n  timeStamp: string;\n  hash: string;\n  nonce: string;\n  blockHash: string;\n  transactionIndex: string;\n  from: string;\n  to: string;\n  value: string;\n  gas: string;\n  gasPrice: string;\n  cumulativeGasUsed: string;\n  gasUsed: string;\n  isError: string;\n  txreceipt_status: string;\n  input: string;\n  contractAddress: string;\n  confirmations: string;\n  tokenDecimal: string;\n  tokenSymbol: string;\n}\n\n/**\n * @type TransactionConfig\n *\n * Transaction controller configuration\n * @property interval - Polling interval used to fetch new currency rate\n * @property provider - Provider used to create a new underlying EthQuery instance\n * @property sign - Method used to sign transactions\n */\nexport interface TransactionConfig extends BaseConfig {\n  interval: number;\n  sign?: (transaction: Transaction, from: string) => Promise<any>;\n  txHistoryLimit: number;\n}\n\n/**\n * @type MethodData\n *\n * Method data registry object\n * @property registryMethod - Registry method raw string\n * @property parsedRegistryMethod - Registry method object, containing name and method arguments\n */\nexport interface MethodData {\n  registryMethod: string;\n  parsedRegistryMethod: Record<string, unknown>;\n}\n\n/**\n * @type TransactionState\n *\n * Transaction controller state\n * @property transactions - A list of TransactionMeta objects\n * @property methodData - Object containing all known method data information\n */\nexport interface TransactionState extends BaseState {\n  transactions: TransactionMeta[];\n  methodData: { [key: string]: MethodData };\n}\n\n/**\n * Multiplier used to determine a transaction's increased gas fee during cancellation\n */\nexport const CANCEL_RATE = 1.5;\n\n/**\n * Multiplier used to determine a transaction's increased gas fee during speed up\n */\nexport const SPEED_UP_RATE = 1.1;\n\n/**\n * The name of the {@link TransactionController}.\n */\nconst controllerName = 'TransactionController';\n\n/**\n * The external actions available to the {@link TransactionController}.\n */\ntype AllowedActions =\n  | AddApprovalRequest\n  | AcceptApprovalRequest\n  | RejectApprovalRequest;\n\n/**\n * The messenger of the {@link TransactionController}.\n */\nexport type TransactionControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  AllowedActions,\n  never,\n  AllowedActions['type'],\n  never\n>;\n\n/**\n * Controller responsible for submitting and managing transactions.\n */\nexport class TransactionController extends BaseController<\n  TransactionConfig,\n  TransactionState\n> {\n  private ethQuery: EthQuery;\n\n  private nonceTracker: NonceTracker;\n\n  private registry: any;\n\n  private provider: Provider;\n\n  private handle?: ReturnType<typeof setTimeout>;\n\n  private mutex = new Mutex();\n\n  private getNetworkState: () => NetworkState;\n\n  private messagingSystem: TransactionControllerMessenger;\n\n  private failTransaction(transactionMeta: TransactionMeta, error: Error) {\n    const newTransactionMeta = {\n      ...transactionMeta,\n      error,\n      status: TransactionStatus.failed,\n    };\n    this.updateTransaction(newTransactionMeta);\n    this.hub.emit(`${transactionMeta.id}:finished`, newTransactionMeta);\n  }\n\n  private async registryLookup(fourBytePrefix: string): Promise<MethodData> {\n    const registryMethod = await this.registry.lookup(fourBytePrefix);\n    const parsedRegistryMethod = this.registry.parse(registryMethod);\n    return { registryMethod, parsedRegistryMethod };\n  }\n\n  /**\n   * Normalizes the transaction information from etherscan\n   * to be compatible with the TransactionMeta interface.\n   *\n   * @param txMeta - The transaction.\n   * @param currentNetworkID - The current network ID.\n   * @param currentChainId - The current chain ID.\n   * @returns The normalized transaction.\n   */\n  private normalizeTx(\n    txMeta: EtherscanTransactionMeta,\n    currentNetworkID: string,\n    currentChainId: Hex,\n  ): TransactionMeta {\n    const time = parseInt(txMeta.timeStamp, 10) * 1000;\n    const normalizedTransactionBase = {\n      blockNumber: txMeta.blockNumber,\n      id: random({ msecs: time }),\n      networkID: currentNetworkID,\n      chainId: currentChainId,\n      time,\n      transaction: {\n        data: txMeta.input,\n        from: txMeta.from,\n        gas: BNToHex(new BN(txMeta.gas)),\n        gasPrice: BNToHex(new BN(txMeta.gasPrice)),\n        gasUsed: BNToHex(new BN(txMeta.gasUsed)),\n        nonce: BNToHex(new BN(txMeta.nonce)),\n        to: txMeta.to,\n        value: BNToHex(new BN(txMeta.value)),\n      },\n      transactionHash: txMeta.hash,\n      verifiedOnBlockchain: false,\n    };\n\n    /* istanbul ignore else */\n    if (txMeta.isError === '0') {\n      return {\n        ...normalizedTransactionBase,\n        status: TransactionStatus.confirmed,\n      };\n    }\n\n    /* istanbul ignore next */\n    return {\n      ...normalizedTransactionBase,\n      error: new Error('Transaction failed'),\n      status: TransactionStatus.failed,\n    };\n  }\n\n  private normalizeTokenTx = (\n    txMeta: EtherscanTransactionMeta,\n    currentNetworkID: string,\n    currentChainId: Hex,\n  ): TransactionMeta => {\n    const time = parseInt(txMeta.timeStamp, 10) * 1000;\n    const {\n      to,\n      from,\n      gas,\n      gasPrice,\n      gasUsed,\n      hash,\n      contractAddress,\n      tokenDecimal,\n      tokenSymbol,\n      value,\n    } = txMeta;\n    return {\n      id: random({ msecs: time }),\n      isTransfer: true,\n      networkID: currentNetworkID,\n      chainId: currentChainId,\n      status: TransactionStatus.confirmed,\n      time,\n      transaction: {\n        chainId: currentChainId,\n        from,\n        gas,\n        gasPrice,\n        gasUsed,\n        to,\n        value,\n      },\n      transactionHash: hash,\n      transferInformation: {\n        contractAddress,\n        decimals: Number(tokenDecimal),\n        symbol: tokenSymbol,\n      },\n      verifiedOnBlockchain: false,\n    };\n  };\n\n  /**\n   * EventEmitter instance used to listen to specific transactional events\n   */\n  hub = new EventEmitter();\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'TransactionController';\n\n  /**\n   * Method used to sign transactions\n   */\n  sign?: (\n    transaction: TypedTransaction,\n    from: string,\n  ) => Promise<TypedTransaction>;\n\n  /**\n   * Creates a TransactionController instance.\n   *\n   * @param options - The controller options.\n   * @param options.getNetworkState - Gets the state of the network controller.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param options.provider - The provider used to create the underlying EthQuery instance.\n   * @param options.blockTracker - The block tracker used to poll for new blocks data.\n   * @param options.messenger - The controller messenger.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      getNetworkState,\n      onNetworkStateChange,\n      provider,\n      blockTracker,\n      messenger,\n    }: {\n      getNetworkState: () => NetworkState;\n      onNetworkStateChange: (listener: (state: NetworkState) => void) => void;\n      provider: Provider;\n      blockTracker: BlockTracker;\n      messenger: TransactionControllerMessenger;\n    },\n    config?: Partial<TransactionConfig>,\n    state?: Partial<TransactionState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      interval: 15000,\n      txHistoryLimit: 40,\n    };\n\n    this.defaultState = {\n      methodData: {},\n      transactions: [],\n    };\n    this.initialize();\n    this.provider = provider;\n    this.messagingSystem = messenger;\n    this.getNetworkState = getNetworkState;\n    this.ethQuery = new EthQuery(provider);\n    this.registry = new MethodRegistry({ provider });\n    this.nonceTracker = new NonceTracker({\n      provider,\n      blockTracker,\n      getPendingTransactions: (address) =>\n        getAndFormatTransactionsForNonceTracker(\n          address,\n          TransactionStatus.submitted,\n          this.state.transactions,\n        ),\n      getConfirmedTransactions: (address) =>\n        getAndFormatTransactionsForNonceTracker(\n          address,\n          TransactionStatus.confirmed,\n          this.state.transactions,\n        ),\n    });\n\n    onNetworkStateChange(() => {\n      this.ethQuery = new EthQuery(this.provider);\n      this.registry = new MethodRegistry({ provider: this.provider });\n    });\n    this.poll();\n  }\n\n  /**\n   * Starts a new polling interval.\n   *\n   * @param interval - The polling interval used to fetch new transaction statuses.\n   */\n  async poll(interval?: number): Promise<void> {\n    interval && this.configure({ interval }, false, false);\n    this.handle && clearTimeout(this.handle);\n    await safelyExecute(() => this.queryTransactionStatuses());\n    this.handle = setTimeout(() => {\n      this.poll(this.config.interval);\n    }, this.config.interval);\n  }\n\n  /**\n   * Handle new method data request.\n   *\n   * @param fourBytePrefix - The method prefix.\n   * @returns The method data object corresponding to the given signature prefix.\n   */\n  async handleMethodData(fourBytePrefix: string): Promise<MethodData> {\n    const releaseLock = await this.mutex.acquire();\n    try {\n      const { methodData } = this.state;\n      const knownMethod = Object.keys(methodData).find(\n        (knownFourBytePrefix) => fourBytePrefix === knownFourBytePrefix,\n      );\n      if (knownMethod) {\n        return methodData[fourBytePrefix];\n      }\n      const registry = await this.registryLookup(fourBytePrefix);\n      this.update({\n        methodData: { ...methodData, ...{ [fourBytePrefix]: registry } },\n      });\n      return registry;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Add a new unapproved transaction to state. Parameters will be validated, a\n   * unique transaction id will be generated, and gas and gasPrice will be calculated\n   * if not provided. If A `<tx.id>:unapproved` hub event will be emitted once added.\n   *\n   * @param transaction - The transaction object to add.\n   * @param origin - The domain origin to append to the generated TransactionMeta.\n   * @param deviceConfirmedOn - An enum to indicate what device the transaction was confirmed to append to the generated TransactionMeta.\n   * @returns Object containing a promise resolving to the transaction hash if approved.\n   */\n  async addTransaction(\n    transaction: Transaction,\n    origin?: string,\n    deviceConfirmedOn?: WalletDevice,\n  ): Promise<Result> {\n    const { providerConfig, networkId } = this.getNetworkState();\n    const { transactions } = this.state;\n    transaction = normalizeTransaction(transaction);\n    validateTransaction(transaction);\n\n    const transactionMeta: TransactionMeta = {\n      id: random(),\n      networkID: networkId ?? undefined,\n      chainId: providerConfig.chainId,\n      origin,\n      status: TransactionStatus.unapproved as TransactionStatus.unapproved,\n      time: Date.now(),\n      transaction,\n      deviceConfirmedOn,\n      verifiedOnBlockchain: false,\n    };\n\n    try {\n      const { gas, estimateGasError } = await this.estimateGas(transaction);\n      transaction.gas = gas;\n      transaction.estimateGasError = estimateGasError;\n    } catch (error: any) {\n      this.failTransaction(transactionMeta, error);\n      return Promise.reject(error);\n    }\n\n    const result: Promise<string> = new Promise((resolve, reject) => {\n      this.hub.once(\n        `${transactionMeta.id}:finished`,\n        (meta: TransactionMeta) => {\n          switch (meta.status) {\n            case TransactionStatus.submitted:\n              return resolve(meta.transactionHash as string);\n            case TransactionStatus.rejected:\n              return reject(\n                ethErrors.provider.userRejectedRequest(\n                  'User rejected the transaction',\n                ),\n              );\n            case TransactionStatus.cancelled:\n              return reject(\n                ethErrors.rpc.internal('User cancelled the transaction'),\n              );\n            case TransactionStatus.failed:\n              return reject(ethErrors.rpc.internal(meta.error.message));\n            /* istanbul ignore next */\n            default:\n              return reject(\n                ethErrors.rpc.internal(\n                  `MetaMask Tx Signature: Unknown problem: ${JSON.stringify(\n                    meta,\n                  )}`,\n                ),\n              );\n          }\n        },\n      );\n    });\n\n    transactions.push(transactionMeta);\n    this.update({ transactions: this.trimTransactionsForState(transactions) });\n    this.hub.emit(`unapprovedTransaction`, transactionMeta);\n    this.requestApproval(transactionMeta);\n    return { result, transactionMeta };\n  }\n\n  prepareUnsignedEthTx(txParams: Record<string, unknown>): TypedTransaction {\n    return TransactionFactory.fromTxData(txParams, {\n      common: this.getCommonConfiguration(),\n      freeze: false,\n    });\n  }\n\n  /**\n   * `@ethereumjs/tx` uses `@ethereumjs/common` as a configuration tool for\n   * specifying which chain, network, hardfork and EIPs to support for\n   * a transaction. By referencing this configuration, and analyzing the fields\n   * specified in txParams, @ethereumjs/tx is able to determine which EIP-2718\n   * transaction type to use.\n   *\n   * @returns {Common} common configuration object\n   */\n\n  getCommonConfiguration(): Common {\n    const {\n      networkId,\n      providerConfig: { type: chain, chainId, nickname: name },\n    } = this.getNetworkState();\n\n    if (chain !== RPC) {\n      return new Common({ chain, hardfork: HARDFORK });\n    }\n\n    const customChainParams = {\n      name,\n      chainId: parseInt(chainId, 16),\n      networkId: networkId === null ? NaN : parseInt(networkId, undefined),\n    };\n\n    return Common.forCustomChain(\n      NetworkType.mainnet,\n      customChainParams,\n      HARDFORK,\n    );\n  }\n\n  /**\n   * Approves a transaction and updates it's status in state. If this is not a\n   * retry transaction, a nonce will be generated. The transaction is signed\n   * using the sign configuration property, then published to the blockchain.\n   * A `<tx.id>:finished` hub event is fired after success or failure.\n   *\n   * @param transactionID - The ID of the transaction to approve.\n   */\n  async approveTransaction(transactionID: string) {\n    const { transactions } = this.state;\n    const releaseLock = await this.mutex.acquire();\n    const { providerConfig } = this.getNetworkState();\n    const { chainId } = providerConfig;\n    const index = transactions.findIndex(({ id }) => transactionID === id);\n    const transactionMeta = transactions[index];\n    const {\n      transaction: { nonce, from },\n    } = transactionMeta;\n    let nonceLock;\n    try {\n      if (!this.sign) {\n        releaseLock();\n        this.failTransaction(\n          transactionMeta,\n          new Error('No sign method defined.'),\n        );\n        this.rejectApproval(transactionMeta);\n        return;\n      } else if (!chainId) {\n        releaseLock();\n        this.failTransaction(transactionMeta, new Error('No chainId defined.'));\n        this.rejectApproval(transactionMeta);\n        return;\n      }\n\n      const { approved: status } = TransactionStatus;\n      let nonceToUse = nonce;\n      // if a nonce already exists on the transactionMeta it means this is a speedup or cancel transaction\n      // so we want to reuse that nonce and hope that it beats the previous attempt to chain. Otherwise use a new locked nonce\n      if (!nonceToUse) {\n        nonceLock = await this.nonceTracker.getNonceLock(from);\n        nonceToUse = addHexPrefix(nonceLock.nextNonce.toString(16));\n      }\n\n      transactionMeta.status = status;\n      transactionMeta.transaction.nonce = nonceToUse;\n      transactionMeta.transaction.chainId = chainId;\n\n      const baseTxParams = {\n        ...transactionMeta.transaction,\n        gasLimit: transactionMeta.transaction.gas,\n      };\n\n      const isEIP1559 = isEIP1559Transaction(transactionMeta.transaction);\n\n      const txParams = isEIP1559\n        ? {\n            ...baseTxParams,\n            maxFeePerGas: transactionMeta.transaction.maxFeePerGas,\n            maxPriorityFeePerGas:\n              transactionMeta.transaction.maxPriorityFeePerGas,\n            estimatedBaseFee: transactionMeta.transaction.estimatedBaseFee,\n            // specify type 2 if maxFeePerGas and maxPriorityFeePerGas are set\n            type: 2,\n          }\n        : baseTxParams;\n\n      // delete gasPrice if maxFeePerGas and maxPriorityFeePerGas are set\n      if (isEIP1559) {\n        delete txParams.gasPrice;\n      }\n\n      const unsignedEthTx = this.prepareUnsignedEthTx(txParams);\n      const signedTx = await this.sign(unsignedEthTx, from);\n      transactionMeta.status = TransactionStatus.signed;\n      this.updateTransaction(transactionMeta);\n      const rawTransaction = bufferToHex(signedTx.serialize());\n\n      transactionMeta.rawTransaction = rawTransaction;\n      this.updateTransaction(transactionMeta);\n      const transactionHash = await query(this.ethQuery, 'sendRawTransaction', [\n        rawTransaction,\n      ]);\n      transactionMeta.transactionHash = transactionHash;\n      transactionMeta.status = TransactionStatus.submitted;\n      this.updateTransaction(transactionMeta);\n      this.hub.emit(`${transactionMeta.id}:finished`, transactionMeta);\n      this.acceptApproval(transactionMeta);\n    } catch (error: any) {\n      this.failTransaction(transactionMeta, error);\n      this.rejectApproval(transactionMeta);\n    } finally {\n      // must set transaction to submitted/failed before releasing lock\n      if (nonceLock) {\n        nonceLock.releaseLock();\n      }\n      releaseLock();\n    }\n  }\n\n  /**\n   * Cancels a transaction based on its ID by setting its status to \"rejected\"\n   * and emitting a `<tx.id>:finished` hub event.\n   *\n   * @param transactionID - The ID of the transaction to cancel.\n   */\n  cancelTransaction(transactionID: string) {\n    const transactionMeta = this.state.transactions.find(\n      ({ id }) => id === transactionID,\n    );\n    if (!transactionMeta) {\n      return;\n    }\n    transactionMeta.status = TransactionStatus.rejected;\n    this.hub.emit(`${transactionMeta.id}:finished`, transactionMeta);\n    const transactions = this.state.transactions.filter(\n      ({ id }) => id !== transactionID,\n    );\n    this.update({ transactions: this.trimTransactionsForState(transactions) });\n    this.rejectApproval(transactionMeta);\n  }\n\n  /**\n   * Attempts to cancel a transaction based on its ID by setting its status to \"rejected\"\n   * and emitting a `<tx.id>:finished` hub event.\n   *\n   * @param transactionID - The ID of the transaction to cancel.\n   * @param gasValues - The gas values to use for the cancellation transaction.\n   */\n  async stopTransaction(\n    transactionID: string,\n    gasValues?: GasPriceValue | FeeMarketEIP1559Values,\n  ) {\n    if (gasValues) {\n      validateGasValues(gasValues);\n    }\n    const transactionMeta = this.state.transactions.find(\n      ({ id }) => id === transactionID,\n    );\n    if (!transactionMeta) {\n      return;\n    }\n\n    if (!this.sign) {\n      throw new Error('No sign method defined.');\n    }\n\n    // gasPrice (legacy non EIP1559)\n    const minGasPrice = getIncreasedPriceFromExisting(\n      transactionMeta.transaction.gasPrice,\n      CANCEL_RATE,\n    );\n\n    const gasPriceFromValues = isGasPriceValue(gasValues) && gasValues.gasPrice;\n\n    const newGasPrice =\n      (gasPriceFromValues &&\n        validateMinimumIncrease(gasPriceFromValues, minGasPrice)) ||\n      minGasPrice;\n\n    // maxFeePerGas (EIP1559)\n    const existingMaxFeePerGas = transactionMeta.transaction?.maxFeePerGas;\n    const minMaxFeePerGas = getIncreasedPriceFromExisting(\n      existingMaxFeePerGas,\n      CANCEL_RATE,\n    );\n    const maxFeePerGasValues =\n      isFeeMarketEIP1559Values(gasValues) && gasValues.maxFeePerGas;\n    const newMaxFeePerGas =\n      (maxFeePerGasValues &&\n        validateMinimumIncrease(maxFeePerGasValues, minMaxFeePerGas)) ||\n      (existingMaxFeePerGas && minMaxFeePerGas);\n\n    // maxPriorityFeePerGas (EIP1559)\n    const existingMaxPriorityFeePerGas =\n      transactionMeta.transaction?.maxPriorityFeePerGas;\n    const minMaxPriorityFeePerGas = getIncreasedPriceFromExisting(\n      existingMaxPriorityFeePerGas,\n      CANCEL_RATE,\n    );\n    const maxPriorityFeePerGasValues =\n      isFeeMarketEIP1559Values(gasValues) && gasValues.maxPriorityFeePerGas;\n    const newMaxPriorityFeePerGas =\n      (maxPriorityFeePerGasValues &&\n        validateMinimumIncrease(\n          maxPriorityFeePerGasValues,\n          minMaxPriorityFeePerGas,\n        )) ||\n      (existingMaxPriorityFeePerGas && minMaxPriorityFeePerGas);\n\n    const txParams =\n      newMaxFeePerGas && newMaxPriorityFeePerGas\n        ? {\n            from: transactionMeta.transaction.from,\n            gasLimit: transactionMeta.transaction.gas,\n            maxFeePerGas: newMaxFeePerGas,\n            maxPriorityFeePerGas: newMaxPriorityFeePerGas,\n            type: 2,\n            nonce: transactionMeta.transaction.nonce,\n            to: transactionMeta.transaction.from,\n            value: '0x0',\n          }\n        : {\n            from: transactionMeta.transaction.from,\n            gasLimit: transactionMeta.transaction.gas,\n            gasPrice: newGasPrice,\n            nonce: transactionMeta.transaction.nonce,\n            to: transactionMeta.transaction.from,\n            value: '0x0',\n          };\n\n    const unsignedEthTx = this.prepareUnsignedEthTx(txParams);\n\n    const signedTx = await this.sign(\n      unsignedEthTx,\n      transactionMeta.transaction.from,\n    );\n    const rawTransaction = bufferToHex(signedTx.serialize());\n    await query(this.ethQuery, 'sendRawTransaction', [rawTransaction]);\n    transactionMeta.status = TransactionStatus.cancelled;\n    this.hub.emit(`${transactionMeta.id}:finished`, transactionMeta);\n    this.rejectApproval(transactionMeta);\n  }\n\n  /**\n   * Attempts to speed up a transaction increasing transaction gasPrice by ten percent.\n   *\n   * @param transactionID - The ID of the transaction to speed up.\n   * @param gasValues - The gas values to use for the speed up transation.\n   */\n  async speedUpTransaction(\n    transactionID: string,\n    gasValues?: GasPriceValue | FeeMarketEIP1559Values,\n  ) {\n    if (gasValues) {\n      validateGasValues(gasValues);\n    }\n    const transactionMeta = this.state.transactions.find(\n      ({ id }) => id === transactionID,\n    );\n    /* istanbul ignore next */\n    if (!transactionMeta) {\n      return;\n    }\n\n    /* istanbul ignore next */\n    if (!this.sign) {\n      throw new Error('No sign method defined.');\n    }\n\n    const { transactions } = this.state;\n\n    // gasPrice (legacy non EIP1559)\n    const minGasPrice = getIncreasedPriceFromExisting(\n      transactionMeta.transaction.gasPrice,\n      SPEED_UP_RATE,\n    );\n\n    const gasPriceFromValues = isGasPriceValue(gasValues) && gasValues.gasPrice;\n\n    const newGasPrice =\n      (gasPriceFromValues &&\n        validateMinimumIncrease(gasPriceFromValues, minGasPrice)) ||\n      minGasPrice;\n\n    // maxFeePerGas (EIP1559)\n    const existingMaxFeePerGas = transactionMeta.transaction?.maxFeePerGas;\n    const minMaxFeePerGas = getIncreasedPriceFromExisting(\n      existingMaxFeePerGas,\n      SPEED_UP_RATE,\n    );\n    const maxFeePerGasValues =\n      isFeeMarketEIP1559Values(gasValues) && gasValues.maxFeePerGas;\n    const newMaxFeePerGas =\n      (maxFeePerGasValues &&\n        validateMinimumIncrease(maxFeePerGasValues, minMaxFeePerGas)) ||\n      (existingMaxFeePerGas && minMaxFeePerGas);\n\n    // maxPriorityFeePerGas (EIP1559)\n    const existingMaxPriorityFeePerGas =\n      transactionMeta.transaction?.maxPriorityFeePerGas;\n    const minMaxPriorityFeePerGas = getIncreasedPriceFromExisting(\n      existingMaxPriorityFeePerGas,\n      SPEED_UP_RATE,\n    );\n    const maxPriorityFeePerGasValues =\n      isFeeMarketEIP1559Values(gasValues) && gasValues.maxPriorityFeePerGas;\n    const newMaxPriorityFeePerGas =\n      (maxPriorityFeePerGasValues &&\n        validateMinimumIncrease(\n          maxPriorityFeePerGasValues,\n          minMaxPriorityFeePerGas,\n        )) ||\n      (existingMaxPriorityFeePerGas && minMaxPriorityFeePerGas);\n\n    const txParams =\n      newMaxFeePerGas && newMaxPriorityFeePerGas\n        ? {\n            ...transactionMeta.transaction,\n            gasLimit: transactionMeta.transaction.gas,\n            maxFeePerGas: newMaxFeePerGas,\n            maxPriorityFeePerGas: newMaxPriorityFeePerGas,\n            type: 2,\n          }\n        : {\n            ...transactionMeta.transaction,\n            gasLimit: transactionMeta.transaction.gas,\n            gasPrice: newGasPrice,\n          };\n\n    const unsignedEthTx = this.prepareUnsignedEthTx(txParams);\n\n    const signedTx = await this.sign(\n      unsignedEthTx,\n      transactionMeta.transaction.from,\n    );\n    const rawTransaction = bufferToHex(signedTx.serialize());\n    const transactionHash = await query(this.ethQuery, 'sendRawTransaction', [\n      rawTransaction,\n    ]);\n    const baseTransactionMeta = {\n      ...transactionMeta,\n      id: random(),\n      time: Date.now(),\n      transactionHash,\n    };\n    const newTransactionMeta =\n      newMaxFeePerGas && newMaxPriorityFeePerGas\n        ? {\n            ...baseTransactionMeta,\n            transaction: {\n              ...transactionMeta.transaction,\n              maxFeePerGas: newMaxFeePerGas,\n              maxPriorityFeePerGas: newMaxPriorityFeePerGas,\n            },\n          }\n        : {\n            ...baseTransactionMeta,\n            transaction: {\n              ...transactionMeta.transaction,\n              gasPrice: newGasPrice,\n            },\n          };\n    transactions.push(newTransactionMeta);\n    this.update({ transactions: this.trimTransactionsForState(transactions) });\n    this.hub.emit(`${transactionMeta.id}:speedup`, newTransactionMeta);\n  }\n\n  /**\n   * Estimates required gas for a given transaction.\n   *\n   * @param transaction - The transaction to estimate gas for.\n   * @returns The gas and gas price.\n   */\n  async estimateGas(transaction: Transaction) {\n    const estimatedTransaction = { ...transaction };\n    const {\n      gas,\n      gasPrice: providedGasPrice,\n      to,\n      value,\n      data,\n    } = estimatedTransaction;\n    const gasPrice =\n      typeof providedGasPrice === 'undefined'\n        ? await query(this.ethQuery, 'gasPrice')\n        : providedGasPrice;\n    const { providerConfig } = this.getNetworkState();\n    const isCustomNetwork = providerConfig.type === NetworkType.rpc;\n    // 1. If gas is already defined on the transaction, use it\n    if (typeof gas !== 'undefined') {\n      return { gas, gasPrice };\n    }\n    const { gasLimit } = await query(this.ethQuery, 'getBlockByNumber', [\n      'latest',\n      false,\n    ]);\n\n    // 2. If to is not defined or this is not a contract address, and there is no data use 0x5208 / 21000.\n    // If the newtwork is a custom network then bypass this check and fetch 'estimateGas'.\n    /* istanbul ignore next */\n    const code = to ? await query(this.ethQuery, 'getCode', [to]) : undefined;\n    /* istanbul ignore next */\n    if (\n      !isCustomNetwork &&\n      (!to || (to && !data && (!code || code === '0x')))\n    ) {\n      return { gas: '0x5208', gasPrice };\n    }\n\n    // if data, should be hex string format\n    estimatedTransaction.data = !data\n      ? data\n      : /* istanbul ignore next */ addHexPrefix(data);\n\n    // 3. If this is a contract address, safely estimate gas using RPC\n    estimatedTransaction.value =\n      typeof value === 'undefined' ? '0x0' : /* istanbul ignore next */ value;\n    const gasLimitBN = hexToBN(gasLimit);\n    estimatedTransaction.gas = BNToHex(fractionBN(gasLimitBN, 19, 20));\n\n    let gasHex;\n    let estimateGasError;\n    try {\n      gasHex = await query(this.ethQuery, 'estimateGas', [\n        estimatedTransaction,\n      ]);\n    } catch (error) {\n      estimateGasError = ESTIMATE_GAS_ERROR;\n    }\n    // 4. Pad estimated gas without exceeding the most recent block gasLimit. If the network is a\n    // a custom network then return the eth_estimateGas value.\n    const gasBN = hexToBN(gasHex);\n    const maxGasBN = gasLimitBN.muln(0.9);\n    const paddedGasBN = gasBN.muln(1.5);\n    /* istanbul ignore next */\n    if (gasBN.gt(maxGasBN) || isCustomNetwork) {\n      return { gas: addHexPrefix(gasHex), gasPrice, estimateGasError };\n    }\n\n    /* istanbul ignore next */\n    if (paddedGasBN.lt(maxGasBN)) {\n      return {\n        gas: addHexPrefix(BNToHex(paddedGasBN)),\n        gasPrice,\n        estimateGasError,\n      };\n    }\n    return { gas: addHexPrefix(BNToHex(maxGasBN)), gasPrice };\n  }\n\n  /**\n   * Check the status of submitted transactions on the network to determine whether they have\n   * been included in a block. Any that have been included in a block are marked as confirmed.\n   */\n  async queryTransactionStatuses() {\n    const { transactions } = this.state;\n    const { providerConfig, networkId: currentNetworkID } =\n      this.getNetworkState();\n    const { chainId: currentChainId } = providerConfig;\n    let gotUpdates = false;\n    await safelyExecute(() =>\n      Promise.all(\n        transactions.map(async (meta, index) => {\n          // Using fallback to networkID only when there is no chainId present.\n          // Should be removed when networkID is completely removed.\n          const txBelongsToCurrentChain =\n            meta.chainId === currentChainId ||\n            (!meta.chainId && meta.networkID === currentNetworkID);\n\n          if (!meta.verifiedOnBlockchain && txBelongsToCurrentChain) {\n            const [reconciledTx, updateRequired] =\n              await this.blockchainTransactionStateReconciler(meta);\n            if (updateRequired) {\n              transactions[index] = reconciledTx;\n              gotUpdates = updateRequired;\n            }\n          }\n        }),\n      ),\n    );\n\n    /* istanbul ignore else */\n    if (gotUpdates) {\n      this.update({\n        transactions: this.trimTransactionsForState(transactions),\n      });\n    }\n  }\n\n  /**\n   * Updates an existing transaction in state.\n   *\n   * @param transactionMeta - The new transaction to store in state.\n   */\n  updateTransaction(transactionMeta: TransactionMeta) {\n    const { transactions } = this.state;\n    transactionMeta.transaction = normalizeTransaction(\n      transactionMeta.transaction,\n    );\n    validateTransaction(transactionMeta.transaction);\n    const index = transactions.findIndex(({ id }) => transactionMeta.id === id);\n    transactions[index] = transactionMeta;\n    this.update({ transactions: this.trimTransactionsForState(transactions) });\n  }\n\n  /**\n   * Removes all transactions from state, optionally based on the current network.\n   *\n   * @param ignoreNetwork - Determines whether to wipe all transactions, or just those on the\n   * current network. If `true`, all transactions are wiped.\n   */\n  wipeTransactions(ignoreNetwork?: boolean) {\n    /* istanbul ignore next */\n    if (ignoreNetwork) {\n      this.update({ transactions: [] });\n      return;\n    }\n    const { providerConfig, networkId: currentNetworkID } =\n      this.getNetworkState();\n    const { chainId: currentChainId } = providerConfig;\n    const newTransactions = this.state.transactions.filter(\n      ({ networkID, chainId }) => {\n        // Using fallback to networkID only when there is no chainId present. Should be removed when networkID is completely removed.\n        const isCurrentNetwork =\n          chainId === currentChainId ||\n          (!chainId && networkID === currentNetworkID);\n        return !isCurrentNetwork;\n      },\n    );\n\n    this.update({\n      transactions: this.trimTransactionsForState(newTransactions),\n    });\n  }\n\n  /**\n   * Get transactions from Etherscan for the given address. By default all transactions are\n   * returned, but the `fromBlock` option can be given to filter just for transactions from a\n   * specific block onward.\n   *\n   * @param address - The address to fetch the transactions for.\n   * @param opt - Object containing optional data, fromBlock and Etherscan API key.\n   * @returns The block number of the latest incoming transaction.\n   */\n  async fetchAll(\n    address: string,\n    opt?: FetchAllOptions,\n  ): Promise<string | void> {\n    const { providerConfig, networkId: currentNetworkID } =\n      this.getNetworkState();\n    const { chainId: currentChainId, type: networkType } = providerConfig;\n    const { transactions } = this.state;\n\n    const supportedNetworkIds = ['1', '5', '11155111'];\n    /* istanbul ignore next */\n    if (\n      currentNetworkID === null ||\n      supportedNetworkIds.indexOf(currentNetworkID) === -1\n    ) {\n      return undefined;\n    }\n\n    const [etherscanTxResponse, etherscanTokenResponse] =\n      await handleTransactionFetch(\n        networkType,\n        address,\n        this.config.txHistoryLimit,\n        opt,\n      );\n\n    const normalizedTxs = etherscanTxResponse.result.map(\n      (tx: EtherscanTransactionMeta) =>\n        this.normalizeTx(tx, currentNetworkID, currentChainId),\n    );\n    const normalizedTokenTxs = etherscanTokenResponse.result.map(\n      (tx: EtherscanTransactionMeta) =>\n        this.normalizeTokenTx(tx, currentNetworkID, currentChainId),\n    );\n\n    const [updateRequired, allTxs] = this.etherscanTransactionStateReconciler(\n      [...normalizedTxs, ...normalizedTokenTxs],\n      transactions,\n    );\n\n    allTxs.sort((a, b) => (a.time < b.time ? -1 : 1));\n\n    let latestIncomingTxBlockNumber: string | undefined;\n    allTxs.forEach(async (tx) => {\n      /* istanbul ignore next */\n      if (\n        // Using fallback to networkID only when there is no chainId present. Should be removed when networkID is completely removed.\n        (tx.chainId === currentChainId ||\n          (!tx.chainId && tx.networkID === currentNetworkID)) &&\n        tx.transaction.to &&\n        tx.transaction.to.toLowerCase() === address.toLowerCase()\n      ) {\n        if (\n          tx.blockNumber &&\n          (!latestIncomingTxBlockNumber ||\n            parseInt(latestIncomingTxBlockNumber, 10) <\n              parseInt(tx.blockNumber, 10))\n        ) {\n          latestIncomingTxBlockNumber = tx.blockNumber;\n        }\n      }\n\n      /* istanbul ignore else */\n      if (tx.toSmartContract === undefined) {\n        // If not `to` is a contract deploy, if not `data` is send eth\n        if (\n          tx.transaction.to &&\n          (!tx.transaction.data || tx.transaction.data !== '0x')\n        ) {\n          const code = await query(this.ethQuery, 'getCode', [\n            tx.transaction.to,\n          ]);\n          tx.toSmartContract = isSmartContractCode(code);\n        } else {\n          tx.toSmartContract = false;\n        }\n      }\n    });\n\n    // Update state only if new transactions were fetched or\n    // the status or gas data of a transaction has changed\n    if (updateRequired) {\n      this.update({ transactions: this.trimTransactionsForState(allTxs) });\n    }\n    return latestIncomingTxBlockNumber;\n  }\n\n  /**\n   * Trim the amount of transactions that are set on the state. Checks\n   * if the length of the tx history is longer then desired persistence\n   * limit and then if it is removes the oldest confirmed or rejected tx.\n   * Pending or unapproved transactions will not be removed by this\n   * operation. For safety of presenting a fully functional transaction UI\n   * representation, this function will not break apart transactions with the\n   * same nonce, created on the same day, per network. Not accounting for transactions of the same\n   * nonce, same day and network combo can result in confusing or broken experiences\n   * in the UI. The transactions are then updated using the BaseController update.\n   *\n   * @param transactions - The transactions to be applied to the state.\n   * @returns The trimmed list of transactions.\n   */\n  private trimTransactionsForState(\n    transactions: TransactionMeta[],\n  ): TransactionMeta[] {\n    const nonceNetworkSet = new Set();\n    const txsToKeep = transactions.reverse().filter((tx) => {\n      const { chainId, networkID, status, transaction, time } = tx;\n      if (transaction) {\n        const key = `${transaction.nonce}-${\n          chainId ? convertHexToDecimal(chainId) : networkID\n        }-${new Date(time).toDateString()}`;\n        if (nonceNetworkSet.has(key)) {\n          return true;\n        } else if (\n          nonceNetworkSet.size < this.config.txHistoryLimit ||\n          !this.isFinalState(status)\n        ) {\n          nonceNetworkSet.add(key);\n          return true;\n        }\n      }\n      return false;\n    });\n    txsToKeep.reverse();\n    return txsToKeep;\n  }\n\n  /**\n   * Determines if the transaction is in a final state.\n   *\n   * @param status - The transaction status.\n   * @returns Whether the transaction is in a final state.\n   */\n  private isFinalState(status: TransactionStatus): boolean {\n    return (\n      status === TransactionStatus.rejected ||\n      status === TransactionStatus.confirmed ||\n      status === TransactionStatus.failed ||\n      status === TransactionStatus.cancelled\n    );\n  }\n\n  /**\n   * Method to verify the state of a transaction using the Blockchain as a source of truth.\n   *\n   * @param meta - The local transaction to verify on the blockchain.\n   * @returns A tuple containing the updated transaction, and whether or not an update was required.\n   */\n  private async blockchainTransactionStateReconciler(\n    meta: TransactionMeta,\n  ): Promise<[TransactionMeta, boolean]> {\n    const { status, transactionHash } = meta;\n    switch (status) {\n      case TransactionStatus.confirmed:\n        const txReceipt = await query(this.ethQuery, 'getTransactionReceipt', [\n          transactionHash,\n        ]);\n\n        if (!txReceipt) {\n          return [meta, false];\n        }\n\n        meta.verifiedOnBlockchain = true;\n        meta.transaction.gasUsed = txReceipt.gasUsed;\n\n        // According to the Web3 docs:\n        // TRUE if the transaction was successful, FALSE if the EVM reverted the transaction.\n        if (Number(txReceipt.status) === 0) {\n          const error: Error = new Error(\n            'Transaction failed. The transaction was reversed',\n          );\n          this.failTransaction(meta, error);\n          return [meta, false];\n        }\n\n        return [meta, true];\n      case TransactionStatus.submitted:\n        const txObj = await query(this.ethQuery, 'getTransactionByHash', [\n          transactionHash,\n        ]);\n\n        if (!txObj) {\n          const receiptShowsFailedStatus =\n            await this.checkTxReceiptStatusIsFailed(transactionHash);\n\n          // Case the txObj is evaluated as false, a second check will\n          // determine if the tx failed or it is pending or confirmed\n          if (receiptShowsFailedStatus) {\n            const error: Error = new Error(\n              'Transaction failed. The transaction was dropped or replaced by a new one',\n            );\n            this.failTransaction(meta, error);\n          }\n        }\n\n        /* istanbul ignore next */\n        if (txObj?.blockNumber) {\n          meta.status = TransactionStatus.confirmed;\n          this.hub.emit(`${meta.id}:confirmed`, meta);\n          return [meta, true];\n        }\n\n        return [meta, false];\n      default:\n        return [meta, false];\n    }\n  }\n\n  /**\n   * Method to check if a tx has failed according to their receipt\n   * According to the Web3 docs:\n   * TRUE if the transaction was successful, FALSE if the EVM reverted the transaction.\n   * The receipt is not available for pending transactions and returns null.\n   *\n   * @param txHash - The transaction hash.\n   * @returns Whether the transaction has failed.\n   */\n  private async checkTxReceiptStatusIsFailed(\n    txHash: string | undefined,\n  ): Promise<boolean> {\n    const txReceipt = await query(this.ethQuery, 'getTransactionReceipt', [\n      txHash,\n    ]);\n    if (!txReceipt) {\n      // Transaction is pending\n      return false;\n    }\n    return Number(txReceipt.status) === 0;\n  }\n\n  /**\n   * Method to verify the state of transactions using Etherscan as a source of truth.\n   *\n   * @param remoteTxs - Transactions to reconcile that are from a remote source.\n   * @param localTxs - Transactions to reconcile that are local.\n   * @returns A tuple containing a boolean indicating whether or not an update was required, and the updated transaction.\n   */\n  private etherscanTransactionStateReconciler(\n    remoteTxs: TransactionMeta[],\n    localTxs: TransactionMeta[],\n  ): [boolean, TransactionMeta[]] {\n    const updatedTxs: TransactionMeta[] = this.getUpdatedTransactions(\n      remoteTxs,\n      localTxs,\n    );\n\n    const newTxs: TransactionMeta[] = this.getNewTransactions(\n      remoteTxs,\n      localTxs,\n    );\n\n    const updatedLocalTxs = localTxs.map((tx: TransactionMeta) => {\n      const txIdx = updatedTxs.findIndex(\n        ({ transactionHash }) => transactionHash === tx.transactionHash,\n      );\n      return txIdx === -1 ? tx : updatedTxs[txIdx];\n    });\n\n    const updateRequired = newTxs.length > 0 || updatedLocalTxs.length > 0;\n\n    return [updateRequired, [...newTxs, ...updatedLocalTxs]];\n  }\n\n  /**\n   * Get all transactions that are in the remote transactions array\n   * but not in the local transactions array.\n   *\n   * @param remoteTxs - Array of transactions from remote source.\n   * @param localTxs - Array of transactions stored locally.\n   * @returns The new transactions.\n   */\n  private getNewTransactions(\n    remoteTxs: TransactionMeta[],\n    localTxs: TransactionMeta[],\n  ): TransactionMeta[] {\n    return remoteTxs.filter((tx) => {\n      const alreadyInTransactions = localTxs.find(\n        ({ transactionHash }) => transactionHash === tx.transactionHash,\n      );\n      return !alreadyInTransactions;\n    });\n  }\n\n  /**\n   * Get all the transactions that are locally outdated with respect\n   * to a remote source (etherscan or blockchain). The returned array\n   * contains the transactions with the updated data.\n   *\n   * @param remoteTxs - Array of transactions from remote source.\n   * @param localTxs - Array of transactions stored locally.\n   * @returns The updated transactions.\n   */\n  private getUpdatedTransactions(\n    remoteTxs: TransactionMeta[],\n    localTxs: TransactionMeta[],\n  ): TransactionMeta[] {\n    return remoteTxs.filter((remoteTx) => {\n      const isTxOutdated = localTxs.find((localTx) => {\n        return (\n          remoteTx.transactionHash === localTx.transactionHash &&\n          this.isTransactionOutdated(remoteTx, localTx)\n        );\n      });\n      return isTxOutdated;\n    });\n  }\n\n  /**\n   * Verifies if a local transaction is outdated with respect to the remote transaction.\n   *\n   * @param remoteTx - The remote transaction from Etherscan.\n   * @param localTx - The local transaction.\n   * @returns Whether the transaction is outdated.\n   */\n  private isTransactionOutdated(\n    remoteTx: TransactionMeta,\n    localTx: TransactionMeta,\n  ): boolean {\n    const statusOutdated = this.isStatusOutdated(\n      remoteTx.transactionHash,\n      localTx.transactionHash,\n      remoteTx.status,\n      localTx.status,\n    );\n    const gasDataOutdated = this.isGasDataOutdated(\n      remoteTx.transaction.gasUsed,\n      localTx.transaction.gasUsed,\n    );\n    return statusOutdated || gasDataOutdated;\n  }\n\n  /**\n   * Verifies if the status of a local transaction is outdated with respect to the remote transaction.\n   *\n   * @param remoteTxHash - Remote transaction hash.\n   * @param localTxHash - Local transaction hash.\n   * @param remoteTxStatus - Remote transaction status.\n   * @param localTxStatus - Local transaction status.\n   * @returns Whether the status is outdated.\n   */\n  private isStatusOutdated(\n    remoteTxHash: string | undefined,\n    localTxHash: string | undefined,\n    remoteTxStatus: TransactionStatus,\n    localTxStatus: TransactionStatus,\n  ): boolean {\n    return remoteTxHash === localTxHash && remoteTxStatus !== localTxStatus;\n  }\n\n  /**\n   * Verifies if the gas data of a local transaction is outdated with respect to the remote transaction.\n   *\n   * @param remoteGasUsed - Remote gas used in the transaction.\n   * @param localGasUsed - Local gas used in the transaction.\n   * @returns Whether the gas data is outdated.\n   */\n  private isGasDataOutdated(\n    remoteGasUsed: string | undefined,\n    localGasUsed: string | undefined,\n  ): boolean {\n    return remoteGasUsed !== localGasUsed;\n  }\n\n  private async requestApproval(\n    txMeta: TransactionMeta,\n    { shouldShowRequest } = { shouldShowRequest: true },\n  ) {\n    const id = this.getApprovalId(txMeta);\n    const { origin } = txMeta;\n    const type = ApprovalType.Transaction;\n    const requestData = { txId: txMeta.id };\n\n    try {\n      await this.messagingSystem.call(\n        'ApprovalController:addRequest',\n        {\n          id,\n          origin: origin || ORIGIN_METAMASK,\n          type,\n          requestData,\n        },\n        shouldShowRequest,\n      );\n    } catch (error) {\n      console.info('Failed to request transaction approval', error);\n    }\n  }\n\n  private acceptApproval(txMeta: TransactionMeta) {\n    const id = this.getApprovalId(txMeta);\n\n    try {\n      this.messagingSystem.call('ApprovalController:acceptRequest', id);\n    } catch (error) {\n      console.info('Failed to accept transaction approval request', error);\n    }\n  }\n\n  private rejectApproval(txMeta: TransactionMeta) {\n    const id = this.getApprovalId(txMeta);\n\n    try {\n      this.messagingSystem.call(\n        'ApprovalController:rejectRequest',\n        id,\n        new Error('Rejected'),\n      );\n    } catch (error) {\n      console.info('Failed to reject transaction approval request', error);\n    }\n  }\n\n  private getApprovalId(txMeta: TransactionMeta) {\n    return String(txMeta.id);\n  }\n}\n\nexport default TransactionController;\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/constants.d.ts b/node_modules/@metamask/transaction-controller/dist/constants.d.ts
new file mode 100644
index 0000000..5010b5b
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/constants.d.ts
@@ -0,0 +1,119 @@
+export declare const CHAIN_IDS: {
+    readonly MAINNET: "0x1";
+    readonly GOERLI: "0x5";
+    readonly BSC: "0x38";
+    readonly BSC_TESTNET: "0x61";
+    readonly OPTIMISM: "0xa";
+    readonly OPTIMISM_SEPOLIA: "0xaa37dc";
+    readonly POLYGON: "0x89";
+    readonly POLYGON_TESTNET: "0x13881";
+    readonly AVALANCHE: "0xa86a";
+    readonly AVALANCHE_TESTNET: "0xa869";
+    readonly FANTOM: "0xfa";
+    readonly FANTOM_TESTNET: "0xfa2";
+    readonly SEPOLIA: "0xaa36a7";
+    readonly LINEA_GOERLI: "0xe704";
+    readonly LINEA_MAINNET: "0xe708";
+    readonly MOONBEAM: "0x504";
+    readonly MOONBEAM_TESTNET: "0x507";
+    readonly MOONRIVER: "0x505";
+    readonly GNOSIS: "0x64";
+};
+export declare const ETHERSCAN_SUPPORTED_NETWORKS: {
+    "0x5": {
+        domain: string;
+        subdomain: string;
+        networkId: string;
+    };
+    "0x1": {
+        domain: string;
+        subdomain: string;
+        networkId: string;
+    };
+    "0xaa36a7": {
+        domain: string;
+        subdomain: string;
+        networkId: string;
+    };
+    "0xe704": {
+        domain: string;
+        subdomain: string;
+        networkId: string;
+    };
+    "0xe708": {
+        domain: string;
+        subdomain: string;
+        networkId: string;
+    };
+    "0x38": {
+        domain: string;
+        subdomain: string;
+        networkId: string;
+    };
+    "0x61": {
+        domain: string;
+        subdomain: string;
+        networkId: string;
+    };
+    "0xa": {
+        domain: string;
+        subdomain: string;
+        networkId: string;
+    };
+    "0xaa37dc": {
+        domain: string;
+        subdomain: string;
+        networkId: string;
+    };
+    "0x89": {
+        domain: string;
+        subdomain: string;
+        networkId: string;
+    };
+    "0x13881": {
+        domain: string;
+        subdomain: string;
+        networkId: string;
+    };
+    "0xa86a": {
+        domain: string;
+        subdomain: string;
+        networkId: string;
+    };
+    "0xa869": {
+        domain: string;
+        subdomain: string;
+        networkId: string;
+    };
+    "0xfa": {
+        domain: string;
+        subdomain: string;
+        networkId: string;
+    };
+    "0xfa2": {
+        domain: string;
+        subdomain: string;
+        networkId: string;
+    };
+    "0x504": {
+        domain: string;
+        subdomain: string;
+        networkId: string;
+    };
+    "0x507": {
+        domain: string;
+        subdomain: string;
+        networkId: string;
+    };
+    "0x505": {
+        domain: string;
+        subdomain: string;
+        networkId: string;
+    };
+    "0x64": {
+        domain: string;
+        subdomain: string;
+        networkId: string;
+    };
+};
+//# sourceMappingURL=constants.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/constants.js b/node_modules/@metamask/transaction-controller/dist/constants.js
new file mode 100644
index 0000000..5f7644a
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/constants.js
@@ -0,0 +1,124 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.ETHERSCAN_SUPPORTED_NETWORKS = exports.CHAIN_IDS = void 0;
+exports.CHAIN_IDS = {
+    MAINNET: '0x1',
+    GOERLI: '0x5',
+    BSC: '0x38',
+    BSC_TESTNET: '0x61',
+    OPTIMISM: '0xa',
+    OPTIMISM_SEPOLIA: '0xaa37dc',
+    POLYGON: '0x89',
+    POLYGON_TESTNET: '0x13881',
+    AVALANCHE: '0xa86a',
+    AVALANCHE_TESTNET: '0xa869',
+    FANTOM: '0xfa',
+    FANTOM_TESTNET: '0xfa2',
+    SEPOLIA: '0xaa36a7',
+    LINEA_GOERLI: '0xe704',
+    LINEA_MAINNET: '0xe708',
+    MOONBEAM: '0x504',
+    MOONBEAM_TESTNET: '0x507',
+    MOONRIVER: '0x505',
+    GNOSIS: '0x64',
+};
+const DEFAULT_ETHERSCAN_DOMAIN = 'etherscan.io';
+const DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX = 'api';
+exports.ETHERSCAN_SUPPORTED_NETWORKS = {
+    [exports.CHAIN_IDS.GOERLI]: {
+        domain: DEFAULT_ETHERSCAN_DOMAIN,
+        subdomain: `${DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX}-goerli`,
+        networkId: parseInt(exports.CHAIN_IDS.GOERLI, 16).toString(),
+    },
+    [exports.CHAIN_IDS.MAINNET]: {
+        domain: DEFAULT_ETHERSCAN_DOMAIN,
+        subdomain: DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX,
+        networkId: parseInt(exports.CHAIN_IDS.MAINNET, 16).toString(),
+    },
+    [exports.CHAIN_IDS.SEPOLIA]: {
+        domain: DEFAULT_ETHERSCAN_DOMAIN,
+        subdomain: `${DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX}-sepolia`,
+        networkId: parseInt(exports.CHAIN_IDS.SEPOLIA, 16).toString(),
+    },
+    [exports.CHAIN_IDS.LINEA_GOERLI]: {
+        domain: 'lineascan.build',
+        subdomain: 'goerli',
+        networkId: parseInt(exports.CHAIN_IDS.LINEA_GOERLI, 16).toString(),
+    },
+    [exports.CHAIN_IDS.LINEA_MAINNET]: {
+        domain: 'lineascan.build',
+        subdomain: DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX,
+        networkId: parseInt(exports.CHAIN_IDS.LINEA_MAINNET, 16).toString(),
+    },
+    [exports.CHAIN_IDS.BSC]: {
+        domain: 'bscscan.com',
+        subdomain: DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX,
+        networkId: parseInt(exports.CHAIN_IDS.BSC, 16).toString(),
+    },
+    [exports.CHAIN_IDS.BSC_TESTNET]: {
+        domain: 'bscscan.com',
+        subdomain: `${DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX}-testnet`,
+        networkId: parseInt(exports.CHAIN_IDS.BSC_TESTNET, 16).toString(),
+    },
+    [exports.CHAIN_IDS.OPTIMISM]: {
+        domain: DEFAULT_ETHERSCAN_DOMAIN,
+        subdomain: `${DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX}-optimistic`,
+        networkId: parseInt(exports.CHAIN_IDS.OPTIMISM, 16).toString(),
+    },
+    [exports.CHAIN_IDS.OPTIMISM_SEPOLIA]: {
+        domain: DEFAULT_ETHERSCAN_DOMAIN,
+        subdomain: `${DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX}-sepolia-optimistic`,
+        networkId: parseInt(exports.CHAIN_IDS.OPTIMISM_SEPOLIA, 16).toString(),
+    },
+    [exports.CHAIN_IDS.POLYGON]: {
+        domain: 'polygonscan.com',
+        subdomain: DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX,
+        networkId: parseInt(exports.CHAIN_IDS.POLYGON, 16).toString(),
+    },
+    [exports.CHAIN_IDS.POLYGON_TESTNET]: {
+        domain: 'polygonscan.com',
+        subdomain: `${DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX}-mumbai`,
+        networkId: parseInt(exports.CHAIN_IDS.POLYGON_TESTNET, 16).toString(),
+    },
+    [exports.CHAIN_IDS.AVALANCHE]: {
+        domain: 'snowtrace.io',
+        subdomain: DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX,
+        networkId: parseInt(exports.CHAIN_IDS.AVALANCHE, 16).toString(),
+    },
+    [exports.CHAIN_IDS.AVALANCHE_TESTNET]: {
+        domain: 'snowtrace.io',
+        subdomain: `${DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX}-testnet`,
+        networkId: parseInt(exports.CHAIN_IDS.AVALANCHE_TESTNET, 16).toString(),
+    },
+    [exports.CHAIN_IDS.FANTOM]: {
+        domain: 'ftmscan.com',
+        subdomain: DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX,
+        networkId: parseInt(exports.CHAIN_IDS.FANTOM, 16).toString(),
+    },
+    [exports.CHAIN_IDS.FANTOM_TESTNET]: {
+        domain: 'ftmscan.com',
+        subdomain: `${DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX}-testnet`,
+        networkId: parseInt(exports.CHAIN_IDS.FANTOM_TESTNET, 16).toString(),
+    },
+    [exports.CHAIN_IDS.MOONBEAM]: {
+        domain: 'moonscan.io',
+        subdomain: `${DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX}-moonbeam`,
+        networkId: parseInt(exports.CHAIN_IDS.MOONBEAM, 16).toString(),
+    },
+    [exports.CHAIN_IDS.MOONBEAM_TESTNET]: {
+        domain: 'moonscan.io',
+        subdomain: `${DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX}-moonbase`,
+        networkId: parseInt(exports.CHAIN_IDS.MOONBEAM_TESTNET, 16).toString(),
+    },
+    [exports.CHAIN_IDS.MOONRIVER]: {
+        domain: 'moonscan.io',
+        subdomain: `${DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX}-moonriver`,
+        networkId: parseInt(exports.CHAIN_IDS.MOONRIVER, 16).toString(),
+    },
+    [exports.CHAIN_IDS.GNOSIS]: {
+        domain: 'gnosisscan.io',
+        subdomain: `${DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX}-gnosis`,
+        networkId: parseInt(exports.CHAIN_IDS.GNOSIS, 16).toString(),
+    },
+};
+//# sourceMappingURL=constants.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/etherscan.d.ts b/node_modules/@metamask/transaction-controller/dist/etherscan.d.ts
new file mode 100644
index 0000000..a49d68f
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/etherscan.d.ts
@@ -0,0 +1,64 @@
+export interface EtherscanTransactionMetaBase {
+    blockNumber: string;
+    blockHash: string;
+    confirmations: string;
+    contractAddress: string;
+    cumulativeGasUsed: string;
+    from: string;
+    gas: string;
+    gasPrice: string;
+    gasUsed: string;
+    hash: string;
+    nonce: string;
+    timeStamp: string;
+    to: string;
+    transactionIndex: string;
+    value: string;
+}
+export interface EtherscanTransactionMeta extends EtherscanTransactionMetaBase {
+    functionName: string;
+    input: string;
+    isError: string;
+    methodId: string;
+    txreceipt_status: string;
+}
+export interface EtherscanTokenTransactionMeta extends EtherscanTransactionMetaBase {
+    tokenDecimal: string;
+    tokenName: string;
+    tokenSymbol: string;
+}
+export interface EtherscanTransactionResponse<T extends EtherscanTransactionMetaBase> {
+    result: T[];
+}
+export interface EtherscanTransactionRequest {
+    address: string;
+    apiKey?: string;
+    chainId: string;
+    fromBlock?: number;
+    limit?: number;
+}
+/**
+ * Retrieves transaction data from Etherscan.
+ *
+ * @param request - Configuration required to fetch transactions.
+ * @param request.address - Address to retrieve transactions for.
+ * @param request.apiKey - Etherscan API key.
+ * @param request.chainId - Current chain ID used to determine subdomain and domain.
+ * @param request.fromBlock - Block number to start fetching transactions from.
+ * @param request.limit - Number of transactions to retrieve.
+ * @returns An Etherscan response object containing the request status and an array of token transaction data.
+ */
+export declare function fetchEtherscanTransactions({ address, apiKey, chainId, fromBlock, limit, }: EtherscanTransactionRequest): Promise<EtherscanTransactionResponse<EtherscanTransactionMeta>>;
+/**
+ * Retrieves token transaction data from Etherscan.
+ *
+ * @param request - Configuration required to fetch token transactions.
+ * @param request.address - Address to retrieve token transactions for.
+ * @param request.apiKey - Etherscan API key.
+ * @param request.chainId - Current chain ID used to determine subdomain and domain.
+ * @param request.fromBlock - Block number to start fetching token transactions from.
+ * @param request.limit - Number of token transactions to retrieve.
+ * @returns An Etherscan response object containing the request status and an array of token transaction data.
+ */
+export declare function fetchEtherscanTokenTransactions({ address, apiKey, chainId, fromBlock, limit, }: EtherscanTransactionRequest): Promise<EtherscanTransactionResponse<EtherscanTokenTransactionMeta>>;
+//# sourceMappingURL=etherscan.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/etherscan.js b/node_modules/@metamask/transaction-controller/dist/etherscan.js
new file mode 100644
index 0000000..0757847
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/etherscan.js
@@ -0,0 +1,118 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.fetchEtherscanTokenTransactions = exports.fetchEtherscanTransactions = void 0;
+const controller_utils_1 = require("@metamask/controller-utils");
+const constants_1 = require("./constants");
+/**
+ * Retrieves transaction data from Etherscan.
+ *
+ * @param request - Configuration required to fetch transactions.
+ * @param request.address - Address to retrieve transactions for.
+ * @param request.apiKey - Etherscan API key.
+ * @param request.chainId - Current chain ID used to determine subdomain and domain.
+ * @param request.fromBlock - Block number to start fetching transactions from.
+ * @param request.limit - Number of transactions to retrieve.
+ * @returns An Etherscan response object containing the request status and an array of token transaction data.
+ */
+function fetchEtherscanTransactions({ address, apiKey, chainId, fromBlock, limit, }) {
+    return __awaiter(this, void 0, void 0, function* () {
+        return yield fetchTransactions('txlist', {
+            address,
+            apiKey,
+            chainId,
+            fromBlock,
+            limit,
+        });
+    });
+}
+exports.fetchEtherscanTransactions = fetchEtherscanTransactions;
+/**
+ * Retrieves token transaction data from Etherscan.
+ *
+ * @param request - Configuration required to fetch token transactions.
+ * @param request.address - Address to retrieve token transactions for.
+ * @param request.apiKey - Etherscan API key.
+ * @param request.chainId - Current chain ID used to determine subdomain and domain.
+ * @param request.fromBlock - Block number to start fetching token transactions from.
+ * @param request.limit - Number of token transactions to retrieve.
+ * @returns An Etherscan response object containing the request status and an array of token transaction data.
+ */
+function fetchEtherscanTokenTransactions({ address, apiKey, chainId, fromBlock, limit, }) {
+    return __awaiter(this, void 0, void 0, function* () {
+        return yield fetchTransactions('tokentx', {
+            address,
+            apiKey,
+            chainId,
+            fromBlock,
+            limit,
+        });
+    });
+}
+exports.fetchEtherscanTokenTransactions = fetchEtherscanTokenTransactions;
+/**
+ * Retrieves transaction data from Etherscan from a specific endpoint.
+ *
+ * @param action - The Etherscan endpoint to use.
+ * @param options - Options bag.
+ * @param options.address - Address to retrieve transactions for.
+ * @param options.apiKey - Etherscan API key.
+ * @param options.chainId - Current chain ID used to determine subdomain and domain.
+ * @param options.fromBlock - Block number to start fetching transactions from.
+ * @param options.limit - Number of transactions to retrieve.
+ * @returns An object containing the request status and an array of transaction data.
+ */
+function fetchTransactions(action, { address, apiKey, chainId, limit, }) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const urlParams = {
+            module: 'account',
+            address,
+            // Not previously used in mobile due to bug, temporarily disabled to match existing behaviour.
+            startBlock: undefined,
+            apikey: apiKey,
+            offset: limit === null || limit === void 0 ? void 0 : limit.toString(),
+            sort: 'desc',
+        };
+        const etherscanTxUrl = getEtherscanApiUrl(chainId, Object.assign(Object.assign({}, urlParams), { action }));
+        const response = (yield (0, controller_utils_1.handleFetch)(etherscanTxUrl));
+        let result = response.result;
+        if (response.status === '0') {
+            result = [];
+        }
+        return { result };
+    });
+}
+/**
+ * Return a URL that can be used to fetch data from Etherscan.
+ *
+ * @param chainId - Current chain ID used to determine subdomain and domain.
+ * @param urlParams - The parameters used to construct the URL.
+ * @returns URL to access Etherscan data.
+ */
+function getEtherscanApiUrl(chainId, urlParams) {
+    const networkInfo = constants_1.ETHERSCAN_SUPPORTED_NETWORKS[chainId];
+    if (!networkInfo) {
+        throw new Error(`Etherscan does not support chain with ID: ${chainId}`);
+    }
+    const apiUrl = `https://${networkInfo.subdomain}.${networkInfo.domain}`;
+    let url = `${apiUrl}/api?`;
+    // eslint-disable-next-line guard-for-in
+    for (const paramKey in urlParams) {
+        const value = urlParams[paramKey];
+        if (!value) {
+            continue;
+        }
+        url += `${paramKey}=${value}&`;
+    }
+    url += 'tag=latest&page=1';
+    return url;
+}
+//# sourceMappingURL=etherscan.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/gas-flows/DefaultGasFeeFlow.d.ts b/node_modules/@metamask/transaction-controller/dist/gas-flows/DefaultGasFeeFlow.d.ts
new file mode 100644
index 0000000..325802b
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/gas-flows/DefaultGasFeeFlow.d.ts
@@ -0,0 +1,10 @@
+import type { GasFeeFlow, GasFeeFlowRequest, GasFeeFlowResponse, TransactionMeta } from '../types';
+/**
+ * The standard implementation of a gas fee flow that obtains gas fee estimates using only the GasFeeController.
+ */
+export declare class DefaultGasFeeFlow implements GasFeeFlow {
+    #private;
+    matchesTransaction(_transactionMeta: TransactionMeta): boolean;
+    getGasFees(request: GasFeeFlowRequest): Promise<GasFeeFlowResponse>;
+}
+//# sourceMappingURL=DefaultGasFeeFlow.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/gas-flows/DefaultGasFeeFlow.d.ts.map b/node_modules/@metamask/transaction-controller/dist/gas-flows/DefaultGasFeeFlow.d.ts.map
new file mode 100644
index 0000000..1a801e5
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/gas-flows/DefaultGasFeeFlow.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"DefaultGasFeeFlow.d.ts","sourceRoot":"","sources":["../../src/gas-flows/DefaultGasFeeFlow.ts"],"names":[],"mappings":"AASA,OAAO,KAAK,EAGV,UAAU,EACV,iBAAiB,EACjB,kBAAkB,EAClB,eAAe,EAChB,MAAM,UAAU,CAAC;AAiBlB;;GAEG;AACH,qBAAa,iBAAkB,YAAW,UAAU;;IAClD,kBAAkB,CAAC,gBAAgB,EAAE,eAAe,GAAG,OAAO;IAIxD,UAAU,CAAC,OAAO,EAAE,iBAAiB,GAAG,OAAO,CAAC,kBAAkB,CAAC;CA4E1E"}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/gas-flows/DefaultGasFeeFlow.js b/node_modules/@metamask/transaction-controller/dist/gas-flows/DefaultGasFeeFlow.js
new file mode 100644
index 0000000..2b4ffd9
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/gas-flows/DefaultGasFeeFlow.js
@@ -0,0 +1,79 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
+    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
+};
+var _DefaultGasFeeFlow_instances, _DefaultGasFeeFlow_getEstimateLevel, _DefaultGasFeeFlow_getFeeMarketLevel, _DefaultGasFeeFlow_getLegacyLevel, _DefaultGasFeeFlow_gweiDecimalToWeiHex;
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.DefaultGasFeeFlow = void 0;
+const gas_fee_controller_1 = require("@metamask/gas-fee-controller");
+const utils_1 = require("@metamask/utils");
+const controller_utils_1 = require("@metamask/controller-utils");
+const logger_1 = require("../logger");
+const types_1 = require("../types");
+const log = (0, utils_1.createModuleLogger)(logger_1.projectLogger, 'default-gas-fee-flow');
+/**
+ * The standard implementation of a gas fee flow that obtains gas fee estimates using only the GasFeeController.
+ */
+class DefaultGasFeeFlow {
+    constructor() {
+        _DefaultGasFeeFlow_instances.add(this);
+    }
+    matchesTransaction(_transactionMeta) {
+        return true;
+    }
+    getGasFees(request) {
+        return __awaiter(this, void 0, void 0, function* () {
+            const { getGasFeeControllerEstimates } = request;
+            const { gasEstimateType, gasFeeEstimates } = yield getGasFeeControllerEstimates();
+            if (gasEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.FEE_MARKET) {
+                log('Using fee market estimates', gasFeeEstimates);
+            }
+            else if (gasEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.LEGACY) {
+                log('Using legacy estimates', gasFeeEstimates);
+            }
+            else {
+                throw new Error(`'No gas fee estimates available`);
+            }
+            const estimates = Object.values(types_1.GasFeeEstimateLevel).reduce((result, level) => (Object.assign(Object.assign({}, result), { [level]: __classPrivateFieldGet(this, _DefaultGasFeeFlow_instances, "m", _DefaultGasFeeFlow_getEstimateLevel).call(this, {
+                    gasEstimateType,
+                    gasFeeEstimates,
+                    level,
+                }) })), {});
+            return { estimates };
+        });
+    }
+}
+exports.DefaultGasFeeFlow = DefaultGasFeeFlow;
+_DefaultGasFeeFlow_instances = new WeakSet(), _DefaultGasFeeFlow_getEstimateLevel = function _DefaultGasFeeFlow_getEstimateLevel({ gasEstimateType, gasFeeEstimates, level, }) {
+    if (gasEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.FEE_MARKET) {
+        return __classPrivateFieldGet(this, _DefaultGasFeeFlow_instances, "m", _DefaultGasFeeFlow_getFeeMarketLevel).call(this, gasFeeEstimates, level);
+    }
+    return __classPrivateFieldGet(this, _DefaultGasFeeFlow_instances, "m", _DefaultGasFeeFlow_getLegacyLevel).call(this, gasFeeEstimates, level);
+}, _DefaultGasFeeFlow_getFeeMarketLevel = function _DefaultGasFeeFlow_getFeeMarketLevel(gasFeeEstimates, level) {
+    const maxFeePerGas = __classPrivateFieldGet(this, _DefaultGasFeeFlow_instances, "m", _DefaultGasFeeFlow_gweiDecimalToWeiHex).call(this, gasFeeEstimates[level].suggestedMaxFeePerGas);
+    const maxPriorityFeePerGas = __classPrivateFieldGet(this, _DefaultGasFeeFlow_instances, "m", _DefaultGasFeeFlow_gweiDecimalToWeiHex).call(this, gasFeeEstimates[level].suggestedMaxPriorityFeePerGas);
+    return {
+        maxFeePerGas,
+        maxPriorityFeePerGas,
+    };
+}, _DefaultGasFeeFlow_getLegacyLevel = function _DefaultGasFeeFlow_getLegacyLevel(gasFeeEstimates, level) {
+    const gasPrice = __classPrivateFieldGet(this, _DefaultGasFeeFlow_instances, "m", _DefaultGasFeeFlow_gweiDecimalToWeiHex).call(this, gasFeeEstimates[level]);
+    return {
+        maxFeePerGas: gasPrice,
+        maxPriorityFeePerGas: gasPrice,
+    };
+}, _DefaultGasFeeFlow_gweiDecimalToWeiHex = function _DefaultGasFeeFlow_gweiDecimalToWeiHex(gweiDecimal) {
+    return (0, controller_utils_1.toHex)((0, controller_utils_1.gweiDecToWEIBN)(gweiDecimal));
+};
+//# sourceMappingURL=DefaultGasFeeFlow.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/gas-flows/DefaultGasFeeFlow.js.map b/node_modules/@metamask/transaction-controller/dist/gas-flows/DefaultGasFeeFlow.js.map
new file mode 100644
index 0000000..f95c0a5
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/gas-flows/DefaultGasFeeFlow.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"DefaultGasFeeFlow.js","sourceRoot":"","sources":["../../src/gas-flows/DefaultGasFeeFlow.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAIA,qEAAkE;AAClE,2CAA0D;AAE1D,iEAAmE;AACnE,sCAA0C;AAS1C,oCAA+C;AAE/C,MAAM,GAAG,GAAG,IAAA,0BAAkB,EAAC,sBAAa,EAAE,sBAAsB,CAAC,CAAC;AActE;;GAEG;AACH,MAAa,iBAAiB;IAA9B;;IAiFA,CAAC;IAhFC,kBAAkB,CAAC,gBAAiC;QAClD,OAAO,IAAI,CAAC;IACd,CAAC;IAEK,UAAU,CAAC,OAA0B;;YACzC,MAAM,EAAE,4BAA4B,EAAE,GAAG,OAAO,CAAC;YAEjD,MAAM,EAAE,eAAe,EAAE,eAAe,EAAE,GACxC,MAAM,4BAA4B,EAAE,CAAC;YAEvC,IAAI,eAAe,KAAK,uCAAkB,CAAC,UAAU,EAAE;gBACrD,GAAG,CAAC,4BAA4B,EAAE,eAAe,CAAC,CAAC;aACpD;iBAAM,IAAI,eAAe,KAAK,uCAAkB,CAAC,MAAM,EAAE;gBACxD,GAAG,CAAC,wBAAwB,EAAE,eAAe,CAAC,CAAC;aAChD;iBAAM;gBACL,MAAM,IAAI,KAAK,CAAC,iCAAiC,CAAC,CAAC;aACpD;YAED,MAAM,SAAS,GAAG,MAAM,CAAC,MAAM,CAAC,2BAAmB,CAAC,CAAC,MAAM,CACzD,CAAC,MAAM,EAAE,KAAK,EAAE,EAAE,CAAC,iCACd,MAAM,KACT,CAAC,KAAK,CAAC,EAAE,uBAAA,IAAI,yEAAkB,MAAtB,IAAI,EAAmB;oBAC9B,eAAe;oBACf,eAAe;oBACf,KAAK;iBAC8D,CAAC,IACtE,EACF,EAAqB,CACtB,CAAC;YAEF,OAAO,EAAE,SAAS,EAAE,CAAC;QACvB,CAAC;KAAA;CAiDF;AAjFD,8CAiFC;iIA/CmB,EAChB,eAAe,EACf,eAAe,EACf,KAAK,GAG0B;IAC/B,IAAI,eAAe,KAAK,uCAAkB,CAAC,UAAU,EAAE;QACrD,OAAO,uBAAA,IAAI,0EAAmB,MAAvB,IAAI,EAAoB,eAAe,EAAE,KAAK,CAAC,CAAC;KACxD;IAED,OAAO,uBAAA,IAAI,uEAAgB,MAApB,IAAI,EAAiB,eAAe,EAAE,KAAK,CAAC,CAAC;AACtD,CAAC,uFAGC,eAA0C,EAC1C,KAA0B;IAE1B,MAAM,YAAY,GAAG,uBAAA,IAAI,4EAAqB,MAAzB,IAAI,EACvB,eAAe,CAAC,KAAK,CAAC,CAAC,qBAAqB,CAC7C,CAAC;IAEF,MAAM,oBAAoB,GAAG,uBAAA,IAAI,4EAAqB,MAAzB,IAAI,EAC/B,eAAe,CAAC,KAAK,CAAC,CAAC,6BAA6B,CACrD,CAAC;IAEF,OAAO;QACL,YAAY;QACZ,oBAAoB;KACrB,CAAC;AACJ,CAAC,iFAGC,eAAuC,EACvC,KAA0B;IAE1B,MAAM,QAAQ,GAAG,uBAAA,IAAI,4EAAqB,MAAzB,IAAI,EAAsB,eAAe,CAAC,KAAK,CAAC,CAAC,CAAC;IAEnE,OAAO;QACL,YAAY,EAAE,QAAQ;QACtB,oBAAoB,EAAE,QAAQ;KAC/B,CAAC;AACJ,CAAC,2FAEoB,WAAmB;IACtC,OAAO,IAAA,wBAAK,EAAC,IAAA,iCAAc,EAAC,WAAW,CAAC,CAAC,CAAC;AAC5C,CAAC","sourcesContent":["import type {\n  LegacyGasPriceEstimate,\n  GasFeeEstimates as FeeMarketGasPriceEstimate,\n} from '@metamask/gas-fee-controller';\nimport { GAS_ESTIMATE_TYPES } from '@metamask/gas-fee-controller';\nimport { createModuleLogger, Hex } from '@metamask/utils';\n\nimport { gweiDecToWEIBN, toHex } from '@metamask/controller-utils';\nimport { projectLogger } from '../logger';\nimport type {\n  GasFeeEstimates,\n  GasFeeEstimatesForLevel,\n  GasFeeFlow,\n  GasFeeFlowRequest,\n  GasFeeFlowResponse,\n  TransactionMeta,\n} from '../types';\nimport { GasFeeEstimateLevel } from '../types';\n\nconst log = createModuleLogger(projectLogger, 'default-gas-fee-flow');\n\ntype FeeMarketGetEstimateLevelRequest = {\n  gasEstimateType: 'fee-market';\n  gasFeeEstimates: FeeMarketGasPriceEstimate;\n  level: GasFeeEstimateLevel;\n};\n\ntype LegacyGetEstimateLevelRequest = {\n  gasEstimateType: 'legacy';\n  gasFeeEstimates: LegacyGasPriceEstimate;\n  level: GasFeeEstimateLevel;\n};\n\n/**\n * The standard implementation of a gas fee flow that obtains gas fee estimates using only the GasFeeController.\n */\nexport class DefaultGasFeeFlow implements GasFeeFlow {\n  matchesTransaction(_transactionMeta: TransactionMeta): boolean {\n    return true;\n  }\n\n  async getGasFees(request: GasFeeFlowRequest): Promise<GasFeeFlowResponse> {\n    const { getGasFeeControllerEstimates } = request;\n\n    const { gasEstimateType, gasFeeEstimates } =\n      await getGasFeeControllerEstimates();\n\n    if (gasEstimateType === GAS_ESTIMATE_TYPES.FEE_MARKET) {\n      log('Using fee market estimates', gasFeeEstimates);\n    } else if (gasEstimateType === GAS_ESTIMATE_TYPES.LEGACY) {\n      log('Using legacy estimates', gasFeeEstimates);\n    } else {\n      throw new Error(`'No gas fee estimates available`);\n    }\n\n    const estimates = Object.values(GasFeeEstimateLevel).reduce(\n      (result, level) => ({\n        ...result,\n        [level]: this.#getEstimateLevel({\n          gasEstimateType,\n          gasFeeEstimates,\n          level,\n        } as FeeMarketGetEstimateLevelRequest | LegacyGetEstimateLevelRequest),\n      }),\n      {} as GasFeeEstimates,\n    );\n\n    return { estimates };\n  }\n\n  #getEstimateLevel({\n    gasEstimateType,\n    gasFeeEstimates,\n    level,\n  }:\n    | FeeMarketGetEstimateLevelRequest\n    | LegacyGetEstimateLevelRequest): GasFeeEstimatesForLevel {\n    if (gasEstimateType === GAS_ESTIMATE_TYPES.FEE_MARKET) {\n      return this.#getFeeMarketLevel(gasFeeEstimates, level);\n    }\n\n    return this.#getLegacyLevel(gasFeeEstimates, level);\n  }\n\n  #getFeeMarketLevel(\n    gasFeeEstimates: FeeMarketGasPriceEstimate,\n    level: GasFeeEstimateLevel,\n  ): GasFeeEstimatesForLevel {\n    const maxFeePerGas = this.#gweiDecimalToWeiHex(\n      gasFeeEstimates[level].suggestedMaxFeePerGas,\n    );\n\n    const maxPriorityFeePerGas = this.#gweiDecimalToWeiHex(\n      gasFeeEstimates[level].suggestedMaxPriorityFeePerGas,\n    );\n\n    return {\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n    };\n  }\n\n  #getLegacyLevel(\n    gasFeeEstimates: LegacyGasPriceEstimate,\n    level: GasFeeEstimateLevel,\n  ): GasFeeEstimatesForLevel {\n    const gasPrice = this.#gweiDecimalToWeiHex(gasFeeEstimates[level]);\n\n    return {\n      maxFeePerGas: gasPrice,\n      maxPriorityFeePerGas: gasPrice,\n    };\n  }\n\n  #gweiDecimalToWeiHex(gweiDecimal: string): Hex {\n    return toHex(gweiDecToWEIBN(gweiDecimal));\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/gas-flows/LineaGasFeeFlow.d.ts b/node_modules/@metamask/transaction-controller/dist/gas-flows/LineaGasFeeFlow.d.ts
new file mode 100644
index 0000000..ce728db
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/gas-flows/LineaGasFeeFlow.d.ts
@@ -0,0 +1,12 @@
+import type { GasFeeFlow, GasFeeFlowRequest, GasFeeFlowResponse, TransactionMeta } from '../types';
+/**
+ * Implementation of a gas fee flow specific to Linea networks that obtains gas fee estimates using:
+ * - The `linea_estimateGas` RPC method to obtain the base fee and lowest priority fee.
+ * - Static multipliers to increase the base and priority fees.
+ */
+export declare class LineaGasFeeFlow implements GasFeeFlow {
+    #private;
+    matchesTransaction(transactionMeta: TransactionMeta): boolean;
+    getGasFees(request: GasFeeFlowRequest): Promise<GasFeeFlowResponse>;
+}
+//# sourceMappingURL=LineaGasFeeFlow.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/gas-flows/LineaGasFeeFlow.d.ts.map b/node_modules/@metamask/transaction-controller/dist/gas-flows/LineaGasFeeFlow.d.ts.map
new file mode 100644
index 0000000..56042e1
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/gas-flows/LineaGasFeeFlow.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"LineaGasFeeFlow.d.ts","sourceRoot":"","sources":["../../src/gas-flows/LineaGasFeeFlow.ts"],"names":[],"mappings":"AAKA,OAAO,KAAK,EAEV,UAAU,EACV,iBAAiB,EACjB,kBAAkB,EAClB,eAAe,EAChB,MAAM,UAAU,CAAC;AAgClB;;;;GAIG;AACH,qBAAa,eAAgB,YAAW,UAAU;;IAChD,kBAAkB,CAAC,eAAe,EAAE,eAAe,GAAG,OAAO;IAIvD,UAAU,CAAC,OAAO,EAAE,iBAAiB,GAAG,OAAO,CAAC,kBAAkB,CAAC;CAqG1E"}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/gas-flows/LineaGasFeeFlow.js b/node_modules/@metamask/transaction-controller/dist/gas-flows/LineaGasFeeFlow.js
new file mode 100644
index 0000000..da048be
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/gas-flows/LineaGasFeeFlow.js
@@ -0,0 +1,111 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
+    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
+};
+var _LineaGasFeeFlow_instances, _LineaGasFeeFlow_getLineaGasFees, _LineaGasFeeFlow_getLineaResponse, _LineaGasFeeFlow_getValuesFromMultipliers, _LineaGasFeeFlow_getMaxFees, _LineaGasFeeFlow_feesToString;
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.LineaGasFeeFlow = void 0;
+const controller_utils_1 = require("@metamask/controller-utils");
+const utils_1 = require("@metamask/utils");
+const logger_1 = require("../logger");
+const types_1 = require("../types");
+const DefaultGasFeeFlow_1 = require("./DefaultGasFeeFlow");
+const log = (0, utils_1.createModuleLogger)(logger_1.projectLogger, 'linea-gas-fee-flow');
+const LINEA_CHAIN_IDS = [
+    controller_utils_1.ChainId['linea-mainnet'],
+    controller_utils_1.ChainId['linea-goerli'],
+];
+const BASE_FEE_MULTIPLIERS = {
+    low: 1,
+    medium: 1.35,
+    high: 1.7,
+};
+const PRIORITY_FEE_MULTIPLIERS = {
+    low: 1,
+    medium: 1.05,
+    high: 1.1,
+};
+/**
+ * Implementation of a gas fee flow specific to Linea networks that obtains gas fee estimates using:
+ * - The `linea_estimateGas` RPC method to obtain the base fee and lowest priority fee.
+ * - Static multipliers to increase the base and priority fees.
+ */
+class LineaGasFeeFlow {
+    constructor() {
+        _LineaGasFeeFlow_instances.add(this);
+    }
+    matchesTransaction(transactionMeta) {
+        return LINEA_CHAIN_IDS.includes(transactionMeta.chainId);
+    }
+    getGasFees(request) {
+        return __awaiter(this, void 0, void 0, function* () {
+            try {
+                return yield __classPrivateFieldGet(this, _LineaGasFeeFlow_instances, "m", _LineaGasFeeFlow_getLineaGasFees).call(this, request);
+            }
+            catch (error) {
+                log('Using default flow as fallback due to error', error);
+                return new DefaultGasFeeFlow_1.DefaultGasFeeFlow().getGasFees(request);
+            }
+        });
+    }
+}
+exports.LineaGasFeeFlow = LineaGasFeeFlow;
+_LineaGasFeeFlow_instances = new WeakSet(), _LineaGasFeeFlow_getLineaGasFees = function _LineaGasFeeFlow_getLineaGasFees(request) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const { ethQuery, transactionMeta } = request;
+        const lineaResponse = yield __classPrivateFieldGet(this, _LineaGasFeeFlow_instances, "m", _LineaGasFeeFlow_getLineaResponse).call(this, transactionMeta, ethQuery);
+        log('Received Linea response', lineaResponse);
+        const baseFees = __classPrivateFieldGet(this, _LineaGasFeeFlow_instances, "m", _LineaGasFeeFlow_getValuesFromMultipliers).call(this, lineaResponse.baseFeePerGas, BASE_FEE_MULTIPLIERS);
+        log('Generated base fees', __classPrivateFieldGet(this, _LineaGasFeeFlow_instances, "m", _LineaGasFeeFlow_feesToString).call(this, baseFees));
+        const priorityFees = __classPrivateFieldGet(this, _LineaGasFeeFlow_instances, "m", _LineaGasFeeFlow_getValuesFromMultipliers).call(this, lineaResponse.priorityFeePerGas, PRIORITY_FEE_MULTIPLIERS);
+        log('Generated priority fees', __classPrivateFieldGet(this, _LineaGasFeeFlow_instances, "m", _LineaGasFeeFlow_feesToString).call(this, priorityFees));
+        const maxFees = __classPrivateFieldGet(this, _LineaGasFeeFlow_instances, "m", _LineaGasFeeFlow_getMaxFees).call(this, baseFees, priorityFees);
+        log('Generated max fees', __classPrivateFieldGet(this, _LineaGasFeeFlow_instances, "m", _LineaGasFeeFlow_feesToString).call(this, maxFees));
+        const estimates = Object.values(types_1.GasFeeEstimateLevel).reduce((result, level) => (Object.assign(Object.assign({}, result), { [level]: {
+                maxFeePerGas: (0, controller_utils_1.toHex)(maxFees[level]),
+                maxPriorityFeePerGas: (0, controller_utils_1.toHex)(priorityFees[level]),
+            } })), {});
+        return { estimates };
+    });
+}, _LineaGasFeeFlow_getLineaResponse = function _LineaGasFeeFlow_getLineaResponse(transactionMeta, ethQuery) {
+    return (0, controller_utils_1.query)(ethQuery, 'linea_estimateGas', [
+        {
+            from: transactionMeta.transaction.from,
+            to: transactionMeta.transaction.to,
+            value: transactionMeta.transaction.value,
+            input: transactionMeta.transaction.data,
+            // Required in request but no impact on response.
+            gasPrice: '0x100000000',
+        },
+    ]);
+}, _LineaGasFeeFlow_getValuesFromMultipliers = function _LineaGasFeeFlow_getValuesFromMultipliers(value, multipliers) {
+    const base = (0, controller_utils_1.hexToBN)(value);
+    const low = base.muln(multipliers.low);
+    const medium = base.muln(multipliers.medium);
+    const high = base.muln(multipliers.high);
+    return {
+        low,
+        medium,
+        high,
+    };
+}, _LineaGasFeeFlow_getMaxFees = function _LineaGasFeeFlow_getMaxFees(baseFees, priorityFees) {
+    return {
+        low: baseFees.low.add(priorityFees.low),
+        medium: baseFees.medium.add(priorityFees.medium),
+        high: baseFees.high.add(priorityFees.high),
+    };
+}, _LineaGasFeeFlow_feesToString = function _LineaGasFeeFlow_feesToString(fees) {
+    return Object.values(types_1.GasFeeEstimateLevel).map((level) => fees[level].toString(10));
+};
+//# sourceMappingURL=LineaGasFeeFlow.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/gas-flows/LineaGasFeeFlow.js.map b/node_modules/@metamask/transaction-controller/dist/gas-flows/LineaGasFeeFlow.js.map
new file mode 100644
index 0000000..4742145
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/gas-flows/LineaGasFeeFlow.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"LineaGasFeeFlow.js","sourceRoot":"","sources":["../../src/gas-flows/LineaGasFeeFlow.ts"],"names":[],"mappings":"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","sourcesContent":["import { ChainId, hexToBN, query, toHex } from '@metamask/controller-utils';\nimport { createModuleLogger, type Hex } from '@metamask/utils';\nimport type { BN } from 'ethereumjs-util';\n\nimport { projectLogger } from '../logger';\nimport type {\n  GasFeeEstimates,\n  GasFeeFlow,\n  GasFeeFlowRequest,\n  GasFeeFlowResponse,\n  TransactionMeta,\n} from '../types';\nimport { GasFeeEstimateLevel } from '../types';\nimport { DefaultGasFeeFlow } from './DefaultGasFeeFlow';\n\ntype LineaEstimateGasResponse = {\n  baseFeePerGas: Hex;\n  priorityFeePerGas: Hex;\n};\n\ntype FeesByLevel = {\n  [key in GasFeeEstimateLevel]: BN;\n};\n\nconst log = createModuleLogger(projectLogger, 'linea-gas-fee-flow');\n\nconst LINEA_CHAIN_IDS: Hex[] = [\n  ChainId['linea-mainnet'],\n  ChainId['linea-goerli'],\n];\n\nconst BASE_FEE_MULTIPLIERS = {\n  low: 1,\n  medium: 1.35,\n  high: 1.7,\n};\n\nconst PRIORITY_FEE_MULTIPLIERS = {\n  low: 1,\n  medium: 1.05,\n  high: 1.1,\n};\n\n/**\n * Implementation of a gas fee flow specific to Linea networks that obtains gas fee estimates using:\n * - The `linea_estimateGas` RPC method to obtain the base fee and lowest priority fee.\n * - Static multipliers to increase the base and priority fees.\n */\nexport class LineaGasFeeFlow implements GasFeeFlow {\n  matchesTransaction(transactionMeta: TransactionMeta): boolean {\n    return LINEA_CHAIN_IDS.includes(transactionMeta.chainId as Hex);\n  }\n\n  async getGasFees(request: GasFeeFlowRequest): Promise<GasFeeFlowResponse> {\n    try {\n      return await this.#getLineaGasFees(request);\n    } catch (error) {\n      log('Using default flow as fallback due to error', error);\n      return new DefaultGasFeeFlow().getGasFees(request);\n    }\n  }\n\n  async #getLineaGasFees(\n    request: GasFeeFlowRequest,\n  ): Promise<GasFeeFlowResponse> {\n    const { ethQuery, transactionMeta } = request;\n\n    const lineaResponse = await this.#getLineaResponse(\n      transactionMeta,\n      ethQuery,\n    );\n\n    log('Received Linea response', lineaResponse);\n\n    const baseFees = this.#getValuesFromMultipliers(\n      lineaResponse.baseFeePerGas,\n      BASE_FEE_MULTIPLIERS,\n    );\n\n    log('Generated base fees', this.#feesToString(baseFees));\n\n    const priorityFees = this.#getValuesFromMultipliers(\n      lineaResponse.priorityFeePerGas,\n      PRIORITY_FEE_MULTIPLIERS,\n    );\n\n    log('Generated priority fees', this.#feesToString(priorityFees));\n\n    const maxFees = this.#getMaxFees(baseFees, priorityFees);\n\n    log('Generated max fees', this.#feesToString(maxFees));\n\n    const estimates = Object.values(GasFeeEstimateLevel).reduce(\n      (result, level) => ({\n        ...result,\n        [level]: {\n          maxFeePerGas: toHex(maxFees[level]),\n          maxPriorityFeePerGas: toHex(priorityFees[level]),\n        },\n      }),\n      {} as GasFeeEstimates,\n    );\n\n    return { estimates };\n  }\n\n  #getLineaResponse(\n    transactionMeta: TransactionMeta,\n    ethQuery: any,\n  ): Promise<LineaEstimateGasResponse> {\n    return query(ethQuery, 'linea_estimateGas', [\n      {\n        from: transactionMeta.transaction.from,\n        to: transactionMeta.transaction.to,\n        value: transactionMeta.transaction.value,\n        input: transactionMeta.transaction.data,\n        // Required in request but no impact on response.\n        gasPrice: '0x100000000',\n      },\n    ]);\n  }\n\n  #getValuesFromMultipliers(\n    value: Hex,\n    multipliers: { low: number; medium: number; high: number },\n  ): FeesByLevel {\n    const base = hexToBN(value);\n    const low = base.muln(multipliers.low);\n    const medium = base.muln(multipliers.medium);\n    const high = base.muln(multipliers.high);\n\n    return {\n      low,\n      medium,\n      high,\n    };\n  }\n\n  #getMaxFees(\n    baseFees: Record<GasFeeEstimateLevel, BN>,\n    priorityFees: Record<GasFeeEstimateLevel, BN>,\n  ): FeesByLevel {\n    return {\n      low: baseFees.low.add(priorityFees.low),\n      medium: baseFees.medium.add(priorityFees.medium),\n      high: baseFees.high.add(priorityFees.high),\n    };\n  }\n\n  #feesToString(fees: FeesByLevel) {\n    return Object.values(GasFeeEstimateLevel).map((level) =>\n      fees[level].toString(10),\n    );\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/helpers/EtherscanRemoteTransactionSource.d.ts b/node_modules/@metamask/transaction-controller/dist/helpers/EtherscanRemoteTransactionSource.d.ts
new file mode 100644
index 0000000..77cbad1
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/helpers/EtherscanRemoteTransactionSource.d.ts
@@ -0,0 +1,15 @@
+import type { Hex } from '@metamask/utils';
+import type { RemoteTransactionSource, RemoteTransactionSourceRequest, TransactionMeta } from '../types';
+/**
+ * A RemoteTransactionSource that fetches transaction data from Etherscan.
+ */
+export declare class EtherscanRemoteTransactionSource implements RemoteTransactionSource {
+    #private;
+    constructor({ includeTokenTransfers, }?: {
+        includeTokenTransfers?: boolean;
+    });
+    isSupportedNetwork(chainId: Hex): boolean;
+    getLastBlockVariations(): string[];
+    fetchTransactions(request: RemoteTransactionSourceRequest): Promise<TransactionMeta[]>;
+}
+//# sourceMappingURL=EtherscanRemoteTransactionSource.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/helpers/EtherscanRemoteTransactionSource.d.ts.map b/node_modules/@metamask/transaction-controller/dist/helpers/EtherscanRemoteTransactionSource.d.ts.map
new file mode 100644
index 0000000..e802a34
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/helpers/EtherscanRemoteTransactionSource.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"EtherscanRemoteTransactionSource.d.ts","sourceRoot":"","sources":["../../src/helpers/EtherscanRemoteTransactionSource.ts"],"names":[],"mappings":"AACA,OAAO,KAAK,EAAE,GAAG,EAAE,MAAM,iBAAiB,CAAC;AAM3C,OAAO,KAAK,EACV,uBAAuB,EACvB,8BAA8B,EAC9B,eAAe,EAChB,MAAM,UAAU,CAAC;AAclB;;GAEG;AACH,qBAAa,gCACX,YAAW,uBAAuB;;gBAMtB,EACV,qBAAqB,GACtB,GAAE;QAAE,qBAAqB,CAAC,EAAE,OAAO,CAAA;KAAO;IAK3C,kBAAkB,CAAC,OAAO,EAAE,GAAG,GAAG,OAAO;IAIzC,sBAAsB,IAAI,MAAM,EAAE;IAI5B,iBAAiB,CACrB,OAAO,EAAE,8BAA8B,GACtC,OAAO,CAAC,eAAe,EAAE,CAAC;CAmI9B"}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/helpers/EtherscanRemoteTransactionSource.js b/node_modules/@metamask/transaction-controller/dist/helpers/EtherscanRemoteTransactionSource.js
new file mode 100644
index 0000000..22a00a2
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/helpers/EtherscanRemoteTransactionSource.js
@@ -0,0 +1,123 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
+    if (kind === "m") throw new TypeError("Private method is not writable");
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
+    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
+};
+var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
+    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
+};
+var _EtherscanRemoteTransactionSource_instances, _EtherscanRemoteTransactionSource_includeTokenTransfers, _EtherscanRemoteTransactionSource_isTokenRequestPending, _EtherscanRemoteTransactionSource_fetchNormalTransactions, _EtherscanRemoteTransactionSource_fetchTokenTransactions, _EtherscanRemoteTransactionSource_getResponseTransactions, _EtherscanRemoteTransactionSource_normalizeTransaction, _EtherscanRemoteTransactionSource_normalizeTokenTransaction, _EtherscanRemoteTransactionSource_normalizeTransactionBase;
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.EtherscanRemoteTransactionSource = void 0;
+const controller_utils_1 = require("@metamask/controller-utils");
+const ethereumjs_util_1 = require("ethereumjs-util");
+const uuid_1 = require("uuid");
+const constants_1 = require("../constants");
+const logger_1 = require("../logger");
+const types_1 = require("../types");
+const etherscan_1 = require("../utils/etherscan");
+/**
+ * A RemoteTransactionSource that fetches transaction data from Etherscan.
+ */
+class EtherscanRemoteTransactionSource {
+    constructor({ includeTokenTransfers, } = {}) {
+        _EtherscanRemoteTransactionSource_instances.add(this);
+        _EtherscanRemoteTransactionSource_includeTokenTransfers.set(this, void 0);
+        _EtherscanRemoteTransactionSource_isTokenRequestPending.set(this, void 0);
+        _EtherscanRemoteTransactionSource_fetchNormalTransactions.set(this, (request, etherscanRequest) => __awaiter(this, void 0, void 0, function* () {
+            const { currentChainId } = request;
+            const etherscanTransactions = yield (0, etherscan_1.fetchEtherscanTransactions)(etherscanRequest);
+            return __classPrivateFieldGet(this, _EtherscanRemoteTransactionSource_instances, "m", _EtherscanRemoteTransactionSource_getResponseTransactions).call(this, etherscanTransactions).map((tx) => __classPrivateFieldGet(this, _EtherscanRemoteTransactionSource_instances, "m", _EtherscanRemoteTransactionSource_normalizeTransaction).call(this, tx, currentChainId));
+        }));
+        _EtherscanRemoteTransactionSource_fetchTokenTransactions.set(this, (request, etherscanRequest) => __awaiter(this, void 0, void 0, function* () {
+            const { currentChainId } = request;
+            const etherscanTransactions = yield (0, etherscan_1.fetchEtherscanTokenTransactions)(etherscanRequest);
+            return __classPrivateFieldGet(this, _EtherscanRemoteTransactionSource_instances, "m", _EtherscanRemoteTransactionSource_getResponseTransactions).call(this, etherscanTransactions).map((tx) => __classPrivateFieldGet(this, _EtherscanRemoteTransactionSource_instances, "m", _EtherscanRemoteTransactionSource_normalizeTokenTransaction).call(this, tx, currentChainId));
+        }));
+        __classPrivateFieldSet(this, _EtherscanRemoteTransactionSource_includeTokenTransfers, includeTokenTransfers !== null && includeTokenTransfers !== void 0 ? includeTokenTransfers : true, "f");
+        __classPrivateFieldSet(this, _EtherscanRemoteTransactionSource_isTokenRequestPending, false, "f");
+    }
+    isSupportedNetwork(chainId) {
+        return Object.keys(constants_1.ETHERSCAN_SUPPORTED_NETWORKS).includes(chainId);
+    }
+    getLastBlockVariations() {
+        return [__classPrivateFieldGet(this, _EtherscanRemoteTransactionSource_isTokenRequestPending, "f") ? 'token' : 'normal'];
+    }
+    fetchTransactions(request) {
+        return __awaiter(this, void 0, void 0, function* () {
+            const etherscanRequest = Object.assign(Object.assign({}, request), { chainId: request.currentChainId });
+            const transactions = __classPrivateFieldGet(this, _EtherscanRemoteTransactionSource_isTokenRequestPending, "f")
+                ? yield __classPrivateFieldGet(this, _EtherscanRemoteTransactionSource_fetchTokenTransactions, "f").call(this, request, etherscanRequest)
+                : yield __classPrivateFieldGet(this, _EtherscanRemoteTransactionSource_fetchNormalTransactions, "f").call(this, request, etherscanRequest);
+            if (__classPrivateFieldGet(this, _EtherscanRemoteTransactionSource_includeTokenTransfers, "f")) {
+                __classPrivateFieldSet(this, _EtherscanRemoteTransactionSource_isTokenRequestPending, !__classPrivateFieldGet(this, _EtherscanRemoteTransactionSource_isTokenRequestPending, "f"), "f");
+            }
+            return transactions;
+        });
+    }
+}
+exports.EtherscanRemoteTransactionSource = EtherscanRemoteTransactionSource;
+_EtherscanRemoteTransactionSource_includeTokenTransfers = new WeakMap(), _EtherscanRemoteTransactionSource_isTokenRequestPending = new WeakMap(), _EtherscanRemoteTransactionSource_fetchNormalTransactions = new WeakMap(), _EtherscanRemoteTransactionSource_fetchTokenTransactions = new WeakMap(), _EtherscanRemoteTransactionSource_instances = new WeakSet(), _EtherscanRemoteTransactionSource_getResponseTransactions = function _EtherscanRemoteTransactionSource_getResponseTransactions(response) {
+    let result = response.result;
+    if (response.status === '0') {
+        result = [];
+        if (response.result.length) {
+            (0, logger_1.incomingTransactionsLogger)('Ignored Etherscan request error', {
+                message: response.result,
+                type: __classPrivateFieldGet(this, _EtherscanRemoteTransactionSource_isTokenRequestPending, "f") ? 'token' : 'normal',
+            });
+        }
+    }
+    return result;
+}, _EtherscanRemoteTransactionSource_normalizeTransaction = function _EtherscanRemoteTransactionSource_normalizeTransaction(txMeta, currentChainId) {
+    const base = __classPrivateFieldGet(this, _EtherscanRemoteTransactionSource_instances, "m", _EtherscanRemoteTransactionSource_normalizeTransactionBase).call(this, txMeta, currentChainId);
+    return Object.assign(Object.assign(Object.assign({}, base), { txParams: Object.assign(Object.assign({}, base.txParams), { data: txMeta.input }) }), (txMeta.isError === '0'
+        ? { status: types_1.TransactionStatus.confirmed }
+        : {
+            error: new Error('Transaction failed'),
+            status: types_1.TransactionStatus.failed,
+        }));
+}, _EtherscanRemoteTransactionSource_normalizeTokenTransaction = function _EtherscanRemoteTransactionSource_normalizeTokenTransaction(txMeta, currentChainId) {
+    const base = __classPrivateFieldGet(this, _EtherscanRemoteTransactionSource_instances, "m", _EtherscanRemoteTransactionSource_normalizeTransactionBase).call(this, txMeta, currentChainId);
+    return Object.assign(Object.assign({}, base), { isTransfer: true, transferInformation: {
+            contractAddress: txMeta.contractAddress,
+            decimals: Number(txMeta.tokenDecimal),
+            symbol: txMeta.tokenSymbol,
+        } });
+}, _EtherscanRemoteTransactionSource_normalizeTransactionBase = function _EtherscanRemoteTransactionSource_normalizeTransactionBase(txMeta, currentChainId) {
+    const time = parseInt(txMeta.timeStamp, 10) * 1000;
+    return {
+        blockNumber: txMeta.blockNumber,
+        chainId: currentChainId,
+        hash: txMeta.hash,
+        id: (0, uuid_1.v1)({ msecs: time }),
+        status: types_1.TransactionStatus.confirmed,
+        time,
+        txParams: {
+            chainId: currentChainId,
+            from: txMeta.from,
+            gas: (0, controller_utils_1.BNToHex)(new ethereumjs_util_1.BN(txMeta.gas)),
+            gasPrice: (0, controller_utils_1.BNToHex)(new ethereumjs_util_1.BN(txMeta.gasPrice)),
+            gasUsed: (0, controller_utils_1.BNToHex)(new ethereumjs_util_1.BN(txMeta.gasUsed)),
+            nonce: (0, controller_utils_1.BNToHex)(new ethereumjs_util_1.BN(txMeta.nonce)),
+            to: txMeta.to,
+            value: (0, controller_utils_1.BNToHex)(new ethereumjs_util_1.BN(txMeta.value)),
+        },
+        type: types_1.TransactionType.incoming,
+        verifiedOnBlockchain: false,
+    };
+};
+//# sourceMappingURL=EtherscanRemoteTransactionSource.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/helpers/EtherscanRemoteTransactionSource.js.map b/node_modules/@metamask/transaction-controller/dist/helpers/EtherscanRemoteTransactionSource.js.map
new file mode 100644
index 0000000..121a92d
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/helpers/EtherscanRemoteTransactionSource.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"EtherscanRemoteTransactionSource.js","sourceRoot":"","sources":["../../src/helpers/EtherscanRemoteTransactionSource.ts"],"names":[],"mappings":"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","sourcesContent":["import { BNToHex } from '@metamask/controller-utils';\nimport type { Hex } from '@metamask/utils';\nimport { BN } from 'ethereumjs-util';\nimport { v1 as random } from 'uuid';\n\nimport { ETHERSCAN_SUPPORTED_NETWORKS } from '../constants';\nimport { incomingTransactionsLogger as log } from '../logger';\nimport type {\n  RemoteTransactionSource,\n  RemoteTransactionSourceRequest,\n  TransactionMeta,\n} from '../types';\nimport { TransactionStatus, TransactionType } from '../types';\nimport {\n  fetchEtherscanTokenTransactions,\n  fetchEtherscanTransactions,\n} from '../utils/etherscan';\nimport type {\n  EtherscanTokenTransactionMeta,\n  EtherscanTransactionMeta,\n  EtherscanTransactionMetaBase,\n  EtherscanTransactionRequest,\n  EtherscanTransactionResponse,\n} from '../utils/etherscan';\n\n/**\n * A RemoteTransactionSource that fetches transaction data from Etherscan.\n */\nexport class EtherscanRemoteTransactionSource\n  implements RemoteTransactionSource\n{\n  #includeTokenTransfers: boolean;\n\n  #isTokenRequestPending: boolean;\n\n  constructor({\n    includeTokenTransfers,\n  }: { includeTokenTransfers?: boolean } = {}) {\n    this.#includeTokenTransfers = includeTokenTransfers ?? true;\n    this.#isTokenRequestPending = false;\n  }\n\n  isSupportedNetwork(chainId: Hex): boolean {\n    return Object.keys(ETHERSCAN_SUPPORTED_NETWORKS).includes(chainId);\n  }\n\n  getLastBlockVariations(): string[] {\n    return [this.#isTokenRequestPending ? 'token' : 'normal'];\n  }\n\n  async fetchTransactions(\n    request: RemoteTransactionSourceRequest,\n  ): Promise<TransactionMeta[]> {\n    const etherscanRequest: EtherscanTransactionRequest = {\n      ...request,\n      chainId: request.currentChainId,\n    };\n\n    const transactions = this.#isTokenRequestPending\n      ? await this.#fetchTokenTransactions(request, etherscanRequest)\n      : await this.#fetchNormalTransactions(request, etherscanRequest);\n\n    if (this.#includeTokenTransfers) {\n      this.#isTokenRequestPending = !this.#isTokenRequestPending;\n    }\n\n    return transactions;\n  }\n\n  #fetchNormalTransactions = async (\n    request: RemoteTransactionSourceRequest,\n    etherscanRequest: EtherscanTransactionRequest,\n  ) => {\n    const { currentChainId } = request;\n\n    const etherscanTransactions = await fetchEtherscanTransactions(\n      etherscanRequest,\n    );\n\n    return this.#getResponseTransactions(etherscanTransactions).map((tx) =>\n      this.#normalizeTransaction(tx, currentChainId),\n    );\n  };\n\n  #fetchTokenTransactions = async (\n    request: RemoteTransactionSourceRequest,\n    etherscanRequest: EtherscanTransactionRequest,\n  ) => {\n    const { currentChainId } = request;\n\n    const etherscanTransactions = await fetchEtherscanTokenTransactions(\n      etherscanRequest,\n    );\n\n    return this.#getResponseTransactions(etherscanTransactions).map((tx) =>\n      this.#normalizeTokenTransaction(tx, currentChainId),\n    );\n  };\n\n  #getResponseTransactions<T extends EtherscanTransactionMetaBase>(\n    response: EtherscanTransactionResponse<T>,\n  ): T[] {\n    let result = response.result as T[];\n\n    if (response.status === '0') {\n      result = [];\n\n      if (response.result.length) {\n        log('Ignored Etherscan request error', {\n          message: response.result,\n          type: this.#isTokenRequestPending ? 'token' : 'normal',\n        });\n      }\n    }\n\n    return result;\n  }\n\n  #normalizeTransaction(\n    txMeta: EtherscanTransactionMeta,\n    currentChainId: Hex,\n  ): TransactionMeta {\n    const base = this.#normalizeTransactionBase(txMeta, currentChainId);\n\n    return {\n      ...base,\n      txParams: {\n        ...base.txParams,\n        data: txMeta.input,\n      },\n      ...(txMeta.isError === '0'\n        ? { status: TransactionStatus.confirmed }\n        : {\n            error: new Error('Transaction failed'),\n            status: TransactionStatus.failed,\n          }),\n    };\n  }\n\n  #normalizeTokenTransaction(\n    txMeta: EtherscanTokenTransactionMeta,\n    currentChainId: Hex,\n  ): TransactionMeta {\n    const base = this.#normalizeTransactionBase(txMeta, currentChainId);\n\n    return {\n      ...base,\n      isTransfer: true,\n      transferInformation: {\n        contractAddress: txMeta.contractAddress,\n        decimals: Number(txMeta.tokenDecimal),\n        symbol: txMeta.tokenSymbol,\n      },\n    };\n  }\n\n  #normalizeTransactionBase(\n    txMeta: EtherscanTransactionMetaBase,\n    currentChainId: Hex,\n  ): TransactionMeta {\n    const time = parseInt(txMeta.timeStamp, 10) * 1000;\n\n    return {\n      blockNumber: txMeta.blockNumber,\n      chainId: currentChainId,\n      hash: txMeta.hash,\n      id: random({ msecs: time }),\n      status: TransactionStatus.confirmed,\n      time,\n      txParams: {\n        chainId: currentChainId,\n        from: txMeta.from,\n        gas: BNToHex(new BN(txMeta.gas)),\n        gasPrice: BNToHex(new BN(txMeta.gasPrice)),\n        gasUsed: BNToHex(new BN(txMeta.gasUsed)),\n        nonce: BNToHex(new BN(txMeta.nonce)),\n        to: txMeta.to,\n        value: BNToHex(new BN(txMeta.value)),\n      },\n      type: TransactionType.incoming,\n      verifiedOnBlockchain: false,\n    };\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/helpers/GasFeePoller.d.ts b/node_modules/@metamask/transaction-controller/dist/helpers/GasFeePoller.d.ts
new file mode 100644
index 0000000..dfaddc5
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/helpers/GasFeePoller.d.ts
@@ -0,0 +1,32 @@
+/// <reference types="node" />
+import EventEmitter from 'events';
+import type { GasFeeState } from '@metamask/gas-fee-controller';
+import type { GasFeeFlow } from '../types';
+import { type TransactionMeta } from '../types';
+/**
+ * Automatically polls and updates suggested gas fees on unapproved transactions.
+ */
+export declare class GasFeePoller {
+    #private;
+    hub: EventEmitter;
+    /**
+     * Constructs a new instance of the GasFeePoller.
+     *
+     * @param options - The options for this instance.
+     * @param options.gasFeeFlows - The gas fee flows to use to obtain suitable gas fees.
+     * @param options.getChainIds - Callback to specify the chain IDs to monitor.
+     * @param options.getEthQuery - Callback to obtain an EthQuery instance.
+     * @param options.getGasFeeControllerEstimates - Callback to obtain the default fee estimates.
+     * @param options.getTransactions - Callback to obtain the transaction data.
+     * @param options.onStateChange - Callback to register a listener for controller state changes.
+     */
+    constructor({ gasFeeFlows, getChainIds, getEthQuery, getGasFeeControllerEstimates, getTransactions, onStateChange, }: {
+        gasFeeFlows: GasFeeFlow[];
+        getChainIds: () => string[];
+        getEthQuery: () => any;
+        getGasFeeControllerEstimates: () => Promise<GasFeeState>;
+        getTransactions: () => TransactionMeta[];
+        onStateChange: (listener: () => void) => void;
+    });
+}
+//# sourceMappingURL=GasFeePoller.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/helpers/GasFeePoller.d.ts.map b/node_modules/@metamask/transaction-controller/dist/helpers/GasFeePoller.d.ts.map
new file mode 100644
index 0000000..8ccb3d4
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/helpers/GasFeePoller.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"GasFeePoller.d.ts","sourceRoot":"","sources":["../../src/helpers/GasFeePoller.ts"],"names":[],"mappings":";AAAA,OAAO,YAAY,MAAM,QAAQ,CAAC;AAClC,OAAO,KAAK,EAAE,WAAW,EAAE,MAAM,8BAA8B,CAAC;AAIhE,OAAO,KAAK,EAAE,UAAU,EAAqB,MAAM,UAAU,CAAC;AAC9D,OAAO,EAAqB,KAAK,eAAe,EAAE,MAAM,UAAU,CAAC;AAOnE;;GAEG;AACH,qBAAa,YAAY;;IACvB,GAAG,EAAE,YAAY,CAAsB;IAgBvC;;;;;;;;;;OAUG;gBACS,EACV,WAAW,EACX,WAAW,EACX,WAAW,EACX,4BAA4B,EAC5B,eAAe,EACf,aAAa,GACd,EAAE;QACD,WAAW,EAAE,UAAU,EAAE,CAAC;QAC1B,WAAW,EAAE,MAAM,MAAM,EAAE,CAAC;QAC5B,WAAW,EAAE,MAAM,GAAG,CAAC;QACvB,4BAA4B,EAAE,MAAM,OAAO,CAAC,WAAW,CAAC,CAAC;QACzD,eAAe,EAAE,MAAM,eAAe,EAAE,CAAC;QACzC,aAAa,EAAE,CAAC,QAAQ,EAAE,MAAM,IAAI,KAAK,IAAI,CAAC;KAC/C;CA+HF"}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/helpers/GasFeePoller.js b/node_modules/@metamask/transaction-controller/dist/helpers/GasFeePoller.js
new file mode 100644
index 0000000..00676ac
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/helpers/GasFeePoller.js
@@ -0,0 +1,147 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
+    if (kind === "m") throw new TypeError("Private method is not writable");
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
+    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
+};
+var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
+    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
+};
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+var _GasFeePoller_instances, _GasFeePoller_gasFeeFlows, _GasFeePoller_getChainIds, _GasFeePoller_getEthQuery, _GasFeePoller_getGasFeeControllerEstimates, _GasFeePoller_getTransactions, _GasFeePoller_timeout, _GasFeePoller_running, _GasFeePoller_start, _GasFeePoller_stop, _GasFeePoller_onTimeout, _GasFeePoller_updateUnapprovedTransactions, _GasFeePoller_updateTransactionSuggestedFees, _GasFeePoller_getUnapprovedTransactions;
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.GasFeePoller = void 0;
+const events_1 = __importDefault(require("events"));
+const utils_1 = require("@metamask/utils");
+const logger_1 = require("../logger");
+const types_1 = require("../types");
+const gas_flow_1 = require("../utils/gas-flow");
+const log = (0, utils_1.createModuleLogger)(logger_1.projectLogger, 'gas-fee-poller');
+const INTERVAL_MILLISECONDS = 10000;
+/**
+ * Automatically polls and updates suggested gas fees on unapproved transactions.
+ */
+class GasFeePoller {
+    /**
+     * Constructs a new instance of the GasFeePoller.
+     *
+     * @param options - The options for this instance.
+     * @param options.gasFeeFlows - The gas fee flows to use to obtain suitable gas fees.
+     * @param options.getChainIds - Callback to specify the chain IDs to monitor.
+     * @param options.getEthQuery - Callback to obtain an EthQuery instance.
+     * @param options.getGasFeeControllerEstimates - Callback to obtain the default fee estimates.
+     * @param options.getTransactions - Callback to obtain the transaction data.
+     * @param options.onStateChange - Callback to register a listener for controller state changes.
+     */
+    constructor({ gasFeeFlows, getChainIds, getEthQuery, getGasFeeControllerEstimates, getTransactions, onStateChange, }) {
+        _GasFeePoller_instances.add(this);
+        this.hub = new events_1.default();
+        _GasFeePoller_gasFeeFlows.set(this, void 0);
+        _GasFeePoller_getChainIds.set(this, void 0);
+        _GasFeePoller_getEthQuery.set(this, void 0);
+        _GasFeePoller_getGasFeeControllerEstimates.set(this, void 0);
+        _GasFeePoller_getTransactions.set(this, void 0);
+        _GasFeePoller_timeout.set(this, void 0);
+        _GasFeePoller_running.set(this, false);
+        __classPrivateFieldSet(this, _GasFeePoller_gasFeeFlows, gasFeeFlows, "f");
+        __classPrivateFieldSet(this, _GasFeePoller_getChainIds, getChainIds, "f");
+        __classPrivateFieldSet(this, _GasFeePoller_getEthQuery, getEthQuery, "f");
+        __classPrivateFieldSet(this, _GasFeePoller_getGasFeeControllerEstimates, getGasFeeControllerEstimates, "f");
+        __classPrivateFieldSet(this, _GasFeePoller_getTransactions, getTransactions, "f");
+        onStateChange(() => {
+            const unapprovedTransactions = __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_getUnapprovedTransactions).call(this);
+            if (unapprovedTransactions.length) {
+                __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_start).call(this);
+            }
+            else {
+                __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_stop).call(this);
+            }
+        });
+    }
+}
+exports.GasFeePoller = GasFeePoller;
+_GasFeePoller_gasFeeFlows = new WeakMap(), _GasFeePoller_getChainIds = new WeakMap(), _GasFeePoller_getEthQuery = new WeakMap(), _GasFeePoller_getGasFeeControllerEstimates = new WeakMap(), _GasFeePoller_getTransactions = new WeakMap(), _GasFeePoller_timeout = new WeakMap(), _GasFeePoller_running = new WeakMap(), _GasFeePoller_instances = new WeakSet(), _GasFeePoller_start = function _GasFeePoller_start() {
+    if (__classPrivateFieldGet(this, _GasFeePoller_running, "f")) {
+        return;
+    }
+    // Intentionally not awaiting since this starts the timeout chain.
+    // eslint-disable-next-line @typescript-eslint/no-floating-promises
+    __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_onTimeout).call(this);
+    __classPrivateFieldSet(this, _GasFeePoller_running, true, "f");
+    log('Started polling');
+}, _GasFeePoller_stop = function _GasFeePoller_stop() {
+    if (!__classPrivateFieldGet(this, _GasFeePoller_running, "f")) {
+        return;
+    }
+    clearTimeout(__classPrivateFieldGet(this, _GasFeePoller_timeout, "f"));
+    __classPrivateFieldSet(this, _GasFeePoller_timeout, undefined, "f");
+    __classPrivateFieldSet(this, _GasFeePoller_running, false, "f");
+    log('Stopped polling');
+}, _GasFeePoller_onTimeout = function _GasFeePoller_onTimeout() {
+    return __awaiter(this, void 0, void 0, function* () {
+        yield __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_updateUnapprovedTransactions).call(this);
+        // eslint-disable-next-line @typescript-eslint/no-misused-promises
+        __classPrivateFieldSet(this, _GasFeePoller_timeout, setTimeout(() => __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_onTimeout).call(this), INTERVAL_MILLISECONDS), "f");
+    });
+}, _GasFeePoller_updateUnapprovedTransactions = function _GasFeePoller_updateUnapprovedTransactions() {
+    return __awaiter(this, void 0, void 0, function* () {
+        const unapprovedTransactions = __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_getUnapprovedTransactions).call(this);
+        log('Found unapproved transactions', {
+            count: unapprovedTransactions.length,
+        });
+        const ethQuery = __classPrivateFieldGet(this, _GasFeePoller_getEthQuery, "f").call(this);
+        yield Promise.all(unapprovedTransactions.map((tx) => __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_updateTransactionSuggestedFees).call(this, tx, ethQuery)));
+    });
+}, _GasFeePoller_updateTransactionSuggestedFees = function _GasFeePoller_updateTransactionSuggestedFees(transactionMeta, ethQuery) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const gasFeeFlow = (0, gas_flow_1.getGasFeeFlow)(transactionMeta, __classPrivateFieldGet(this, _GasFeePoller_gasFeeFlows, "f"));
+        if (!gasFeeFlow) {
+            log('No gas fee flow found', transactionMeta.id);
+        }
+        else {
+            log('Found gas fee flow', gasFeeFlow.constructor.name, transactionMeta.id);
+        }
+        const request = {
+            ethQuery,
+            getGasFeeControllerEstimates: __classPrivateFieldGet(this, _GasFeePoller_getGasFeeControllerEstimates, "f"),
+            transactionMeta,
+        };
+        if (gasFeeFlow) {
+            try {
+                const response = yield gasFeeFlow.getGasFees(request);
+                transactionMeta.gasFeeEstimates = response.estimates;
+            }
+            catch (error) {
+                log('Failed to get suggested gas fees', transactionMeta.id, error);
+            }
+        }
+        if (!gasFeeFlow && transactionMeta.gasFeeEstimatesLoaded) {
+            return;
+        }
+        transactionMeta.gasFeeEstimatesLoaded = true;
+        this.hub.emit('transaction-updated', transactionMeta, 'GasFeePoller - Suggested gas fees updated');
+        log('Updated suggested gas fees', {
+            gasFeeEstimates: transactionMeta.gasFeeEstimates,
+            transaction: transactionMeta.id,
+        });
+    });
+}, _GasFeePoller_getUnapprovedTransactions = function _GasFeePoller_getUnapprovedTransactions() {
+    const chainIds = __classPrivateFieldGet(this, _GasFeePoller_getChainIds, "f").call(this);
+    return __classPrivateFieldGet(this, _GasFeePoller_getTransactions, "f").call(this).filter((tx) => chainIds.includes(tx.chainId) &&
+        tx.status === types_1.TransactionStatus.unapproved);
+};
+//# sourceMappingURL=GasFeePoller.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/helpers/GasFeePoller.js.map b/node_modules/@metamask/transaction-controller/dist/helpers/GasFeePoller.js.map
new file mode 100644
index 0000000..08b3514
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/helpers/GasFeePoller.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"GasFeePoller.js","sourceRoot":"","sources":["../../src/helpers/GasFeePoller.ts"],"names":[],"mappings":"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","sourcesContent":["import EventEmitter from 'events';\nimport type { GasFeeState } from '@metamask/gas-fee-controller';\nimport { createModuleLogger } from '@metamask/utils';\n\nimport { projectLogger } from '../logger';\nimport type { GasFeeFlow, GasFeeFlowRequest } from '../types';\nimport { TransactionStatus, type TransactionMeta } from '../types';\nimport { getGasFeeFlow } from '../utils/gas-flow';\n\nconst log = createModuleLogger(projectLogger, 'gas-fee-poller');\n\nconst INTERVAL_MILLISECONDS = 10000;\n\n/**\n * Automatically polls and updates suggested gas fees on unapproved transactions.\n */\nexport class GasFeePoller {\n  hub: EventEmitter = new EventEmitter();\n\n  #gasFeeFlows: GasFeeFlow[];\n\n  #getChainIds: () => string[];\n\n  #getEthQuery: () => any;\n\n  #getGasFeeControllerEstimates: () => Promise<GasFeeState>;\n\n  #getTransactions: () => TransactionMeta[];\n\n  #timeout: any;\n\n  #running = false;\n\n  /**\n   * Constructs a new instance of the GasFeePoller.\n   *\n   * @param options - The options for this instance.\n   * @param options.gasFeeFlows - The gas fee flows to use to obtain suitable gas fees.\n   * @param options.getChainIds - Callback to specify the chain IDs to monitor.\n   * @param options.getEthQuery - Callback to obtain an EthQuery instance.\n   * @param options.getGasFeeControllerEstimates - Callback to obtain the default fee estimates.\n   * @param options.getTransactions - Callback to obtain the transaction data.\n   * @param options.onStateChange - Callback to register a listener for controller state changes.\n   */\n  constructor({\n    gasFeeFlows,\n    getChainIds,\n    getEthQuery,\n    getGasFeeControllerEstimates,\n    getTransactions,\n    onStateChange,\n  }: {\n    gasFeeFlows: GasFeeFlow[];\n    getChainIds: () => string[];\n    getEthQuery: () => any;\n    getGasFeeControllerEstimates: () => Promise<GasFeeState>;\n    getTransactions: () => TransactionMeta[];\n    onStateChange: (listener: () => void) => void;\n  }) {\n    this.#gasFeeFlows = gasFeeFlows;\n    this.#getChainIds = getChainIds;\n    this.#getEthQuery = getEthQuery;\n    this.#getGasFeeControllerEstimates = getGasFeeControllerEstimates;\n    this.#getTransactions = getTransactions;\n\n    onStateChange(() => {\n      const unapprovedTransactions = this.#getUnapprovedTransactions();\n\n      if (unapprovedTransactions.length) {\n        this.#start();\n      } else {\n        this.#stop();\n      }\n    });\n  }\n\n  #start() {\n    if (this.#running) {\n      return;\n    }\n\n    // Intentionally not awaiting since this starts the timeout chain.\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this.#onTimeout();\n\n    this.#running = true;\n\n    log('Started polling');\n  }\n\n  #stop() {\n    if (!this.#running) {\n      return;\n    }\n\n    clearTimeout(this.#timeout);\n\n    this.#timeout = undefined;\n    this.#running = false;\n\n    log('Stopped polling');\n  }\n\n  async #onTimeout() {\n    await this.#updateUnapprovedTransactions();\n\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    this.#timeout = setTimeout(() => this.#onTimeout(), INTERVAL_MILLISECONDS);\n  }\n\n  async #updateUnapprovedTransactions() {\n    const unapprovedTransactions = this.#getUnapprovedTransactions();\n\n    log('Found unapproved transactions', {\n      count: unapprovedTransactions.length,\n    });\n\n    const ethQuery = this.#getEthQuery();\n\n    await Promise.all(\n      unapprovedTransactions.map((tx) =>\n        this.#updateTransactionSuggestedFees(tx, ethQuery),\n      ),\n    );\n  }\n\n  async #updateTransactionSuggestedFees(\n    transactionMeta: TransactionMeta,\n    ethQuery: any,\n  ) {\n    const gasFeeFlow = getGasFeeFlow(transactionMeta, this.#gasFeeFlows);\n\n    if (!gasFeeFlow) {\n      log('No gas fee flow found', transactionMeta.id);\n    } else {\n      log(\n        'Found gas fee flow',\n        gasFeeFlow.constructor.name,\n        transactionMeta.id,\n      );\n    }\n\n    const request: GasFeeFlowRequest = {\n      ethQuery,\n      getGasFeeControllerEstimates: this.#getGasFeeControllerEstimates,\n      transactionMeta,\n    };\n\n    if (gasFeeFlow) {\n      try {\n        const response = await gasFeeFlow.getGasFees(request);\n\n        transactionMeta.gasFeeEstimates = response.estimates;\n      } catch (error) {\n        log('Failed to get suggested gas fees', transactionMeta.id, error);\n      }\n    }\n\n    if (!gasFeeFlow && transactionMeta.gasFeeEstimatesLoaded) {\n      return;\n    }\n\n    transactionMeta.gasFeeEstimatesLoaded = true;\n\n    this.hub.emit(\n      'transaction-updated',\n      transactionMeta,\n      'GasFeePoller - Suggested gas fees updated',\n    );\n\n    log('Updated suggested gas fees', {\n      gasFeeEstimates: transactionMeta.gasFeeEstimates,\n      transaction: transactionMeta.id,\n    });\n  }\n\n  #getUnapprovedTransactions() {\n    const chainIds = this.#getChainIds();\n\n    return this.#getTransactions().filter(\n      (tx) =>\n        chainIds.includes(tx.chainId as string) &&\n        tx.status === TransactionStatus.unapproved,\n    );\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/helpers/IncomingTransactionHelper.d.ts b/node_modules/@metamask/transaction-controller/dist/helpers/IncomingTransactionHelper.d.ts
new file mode 100644
index 0000000..3716ebf
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/helpers/IncomingTransactionHelper.d.ts
@@ -0,0 +1,25 @@
+/// <reference types="node" />
+import type { BlockTracker, NetworkState } from '@metamask/network-controller';
+import type { Hex } from '@metamask/utils';
+import EventEmitter from 'events';
+import type { RemoteTransactionSource, TransactionMeta } from '../types';
+export declare class IncomingTransactionHelper {
+    #private;
+    hub: EventEmitter;
+    constructor({ blockTracker, getCurrentAccount, getLastFetchedBlockNumbers, getLocalTransactions, getNetworkState, isEnabled, queryEntireHistory, remoteTransactionSource, transactionLimit, updateTransactions, }: {
+        blockTracker: BlockTracker;
+        getCurrentAccount: () => string;
+        getLastFetchedBlockNumbers: () => Record<string, number>;
+        getLocalTransactions?: () => TransactionMeta[];
+        getNetworkState: () => NetworkState;
+        isEnabled?: () => boolean;
+        queryEntireHistory?: boolean;
+        remoteTransactionSource: RemoteTransactionSource;
+        transactionLimit?: number;
+        updateTransactions?: boolean;
+    });
+    start(): void;
+    stop(): void;
+    update(latestBlockNumberHex?: Hex): Promise<void>;
+}
+//# sourceMappingURL=IncomingTransactionHelper.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/helpers/IncomingTransactionHelper.d.ts.map b/node_modules/@metamask/transaction-controller/dist/helpers/IncomingTransactionHelper.d.ts.map
new file mode 100644
index 0000000..ba41d04
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/helpers/IncomingTransactionHelper.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"IncomingTransactionHelper.d.ts","sourceRoot":"","sources":["../../src/helpers/IncomingTransactionHelper.ts"],"names":[],"mappings":";AAAA,OAAO,KAAK,EAAE,YAAY,EAAE,YAAY,EAAE,MAAM,8BAA8B,CAAC;AAC/E,OAAO,KAAK,EAAE,GAAG,EAAE,MAAM,iBAAiB,CAAC;AAE3C,OAAO,YAAY,MAAM,QAAQ,CAAC;AAGlC,OAAO,KAAK,EAAE,uBAAuB,EAAE,eAAe,EAAE,MAAM,UAAU,CAAC;AAWzE,qBAAa,yBAAyB;;IACpC,GAAG,EAAE,YAAY,CAAC;gBA4BN,EACV,YAAY,EACZ,iBAAiB,EACjB,0BAA0B,EAC1B,oBAAoB,EACpB,eAAe,EACf,SAAS,EACT,kBAAkB,EAClB,uBAAuB,EACvB,gBAAgB,EAChB,kBAAkB,GACnB,EAAE;QACD,YAAY,EAAE,YAAY,CAAC;QAC3B,iBAAiB,EAAE,MAAM,MAAM,CAAC;QAChC,0BAA0B,EAAE,MAAM,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;QACzD,oBAAoB,CAAC,EAAE,MAAM,eAAe,EAAE,CAAC;QAC/C,eAAe,EAAE,MAAM,YAAY,CAAC;QACpC,SAAS,CAAC,EAAE,MAAM,OAAO,CAAC;QAC1B,kBAAkB,CAAC,EAAE,OAAO,CAAC;QAC7B,uBAAuB,EAAE,uBAAuB,CAAC;QACjD,gBAAgB,CAAC,EAAE,MAAM,CAAC;QAC1B,kBAAkB,CAAC,EAAE,OAAO,CAAC;KAC9B;IA0BD,KAAK;IAaL,IAAI;IAKE,MAAM,CAAC,oBAAoB,CAAC,EAAE,GAAG,GAAG,OAAO,CAAC,IAAI,CAAC;CAqMxD"}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/helpers/IncomingTransactionHelper.js b/node_modules/@metamask/transaction-controller/dist/helpers/IncomingTransactionHelper.js
new file mode 100644
index 0000000..68b3070
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/helpers/IncomingTransactionHelper.js
@@ -0,0 +1,202 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
+    if (kind === "m") throw new TypeError("Private method is not writable");
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
+    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
+};
+var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
+    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
+};
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+var _IncomingTransactionHelper_instances, _IncomingTransactionHelper_blockTracker, _IncomingTransactionHelper_getCurrentAccount, _IncomingTransactionHelper_getLastFetchedBlockNumbers, _IncomingTransactionHelper_getLocalTransactions, _IncomingTransactionHelper_getNetworkState, _IncomingTransactionHelper_isEnabled, _IncomingTransactionHelper_isRunning, _IncomingTransactionHelper_mutex, _IncomingTransactionHelper_onLatestBlock, _IncomingTransactionHelper_queryEntireHistory, _IncomingTransactionHelper_remoteTransactionSource, _IncomingTransactionHelper_transactionLimit, _IncomingTransactionHelper_updateTransactions, _IncomingTransactionHelper_sortTransactionsByTime, _IncomingTransactionHelper_getNewTransactions, _IncomingTransactionHelper_getUpdatedTransactions, _IncomingTransactionHelper_isTransactionOutdated, _IncomingTransactionHelper_getFromBlock, _IncomingTransactionHelper_updateLastFetchedBlockNumber, _IncomingTransactionHelper_getBlockNumberKey, _IncomingTransactionHelper_canStart, _IncomingTransactionHelper_getCurrentChainId;
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.IncomingTransactionHelper = void 0;
+const async_mutex_1 = require("async-mutex");
+const events_1 = __importDefault(require("events"));
+const logger_1 = require("../logger");
+const RECENT_HISTORY_BLOCK_RANGE = 10;
+// TODO: Replace `any` with type
+// eslint-disable-next-line @typescript-eslint/no-explicit-any
+const UPDATE_CHECKS = [
+    (txMeta) => txMeta.status,
+    (txMeta) => txMeta.txParams.gasUsed,
+];
+class IncomingTransactionHelper {
+    constructor({ blockTracker, getCurrentAccount, getLastFetchedBlockNumbers, getLocalTransactions, getNetworkState, isEnabled, queryEntireHistory, remoteTransactionSource, transactionLimit, updateTransactions, }) {
+        _IncomingTransactionHelper_instances.add(this);
+        _IncomingTransactionHelper_blockTracker.set(this, void 0);
+        _IncomingTransactionHelper_getCurrentAccount.set(this, void 0);
+        _IncomingTransactionHelper_getLastFetchedBlockNumbers.set(this, void 0);
+        _IncomingTransactionHelper_getLocalTransactions.set(this, void 0);
+        _IncomingTransactionHelper_getNetworkState.set(this, void 0);
+        _IncomingTransactionHelper_isEnabled.set(this, void 0);
+        _IncomingTransactionHelper_isRunning.set(this, void 0);
+        _IncomingTransactionHelper_mutex.set(this, new async_mutex_1.Mutex());
+        _IncomingTransactionHelper_onLatestBlock.set(this, void 0);
+        _IncomingTransactionHelper_queryEntireHistory.set(this, void 0);
+        _IncomingTransactionHelper_remoteTransactionSource.set(this, void 0);
+        _IncomingTransactionHelper_transactionLimit.set(this, void 0);
+        _IncomingTransactionHelper_updateTransactions.set(this, void 0);
+        this.hub = new events_1.default();
+        __classPrivateFieldSet(this, _IncomingTransactionHelper_blockTracker, blockTracker, "f");
+        __classPrivateFieldSet(this, _IncomingTransactionHelper_getCurrentAccount, getCurrentAccount, "f");
+        __classPrivateFieldSet(this, _IncomingTransactionHelper_getLastFetchedBlockNumbers, getLastFetchedBlockNumbers, "f");
+        __classPrivateFieldSet(this, _IncomingTransactionHelper_getLocalTransactions, getLocalTransactions || (() => []), "f");
+        __classPrivateFieldSet(this, _IncomingTransactionHelper_getNetworkState, getNetworkState, "f");
+        __classPrivateFieldSet(this, _IncomingTransactionHelper_isEnabled, isEnabled !== null && isEnabled !== void 0 ? isEnabled : (() => true), "f");
+        __classPrivateFieldSet(this, _IncomingTransactionHelper_isRunning, false, "f");
+        __classPrivateFieldSet(this, _IncomingTransactionHelper_queryEntireHistory, queryEntireHistory !== null && queryEntireHistory !== void 0 ? queryEntireHistory : true, "f");
+        __classPrivateFieldSet(this, _IncomingTransactionHelper_remoteTransactionSource, remoteTransactionSource, "f");
+        __classPrivateFieldSet(this, _IncomingTransactionHelper_transactionLimit, transactionLimit, "f");
+        __classPrivateFieldSet(this, _IncomingTransactionHelper_updateTransactions, updateTransactions !== null && updateTransactions !== void 0 ? updateTransactions : false, "f");
+        // Using a property instead of a method to provide a listener reference
+        // with the correct scope that we can remove later if stopped.
+        __classPrivateFieldSet(this, _IncomingTransactionHelper_onLatestBlock, (blockNumberHex) => __awaiter(this, void 0, void 0, function* () {
+            try {
+                yield this.update(blockNumberHex);
+            }
+            catch (error) {
+                console.error('Error while checking incoming transactions', error);
+            }
+        }), "f");
+    }
+    start() {
+        if (__classPrivateFieldGet(this, _IncomingTransactionHelper_isRunning, "f")) {
+            return;
+        }
+        if (!__classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_canStart).call(this)) {
+            return;
+        }
+        __classPrivateFieldGet(this, _IncomingTransactionHelper_blockTracker, "f").addListener('latest', __classPrivateFieldGet(this, _IncomingTransactionHelper_onLatestBlock, "f"));
+        __classPrivateFieldSet(this, _IncomingTransactionHelper_isRunning, true, "f");
+    }
+    stop() {
+        __classPrivateFieldGet(this, _IncomingTransactionHelper_blockTracker, "f").removeListener('latest', __classPrivateFieldGet(this, _IncomingTransactionHelper_onLatestBlock, "f"));
+        __classPrivateFieldSet(this, _IncomingTransactionHelper_isRunning, false, "f");
+    }
+    update(latestBlockNumberHex) {
+        var _a, _b, _c;
+        return __awaiter(this, void 0, void 0, function* () {
+            const releaseLock = yield __classPrivateFieldGet(this, _IncomingTransactionHelper_mutex, "f").acquire();
+            (0, logger_1.incomingTransactionsLogger)('Checking for incoming transactions');
+            try {
+                if (!__classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_canStart).call(this)) {
+                    return;
+                }
+                const latestBlockNumber = parseInt(latestBlockNumberHex || (yield __classPrivateFieldGet(this, _IncomingTransactionHelper_blockTracker, "f").getLatestBlock()), 16);
+                const additionalLastFetchedKeys = (_c = (_b = (_a = __classPrivateFieldGet(this, _IncomingTransactionHelper_remoteTransactionSource, "f")).getLastBlockVariations) === null || _b === void 0 ? void 0 : _b.call(_a)) !== null && _c !== void 0 ? _c : [];
+                const fromBlock = __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_getFromBlock).call(this, latestBlockNumber, additionalLastFetchedKeys);
+                const address = __classPrivateFieldGet(this, _IncomingTransactionHelper_getCurrentAccount, "f").call(this);
+                const currentChainId = __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_getCurrentChainId).call(this);
+                let remoteTransactions = [];
+                try {
+                    remoteTransactions =
+                        yield __classPrivateFieldGet(this, _IncomingTransactionHelper_remoteTransactionSource, "f").fetchTransactions({
+                            address,
+                            currentChainId,
+                            fromBlock,
+                            limit: __classPrivateFieldGet(this, _IncomingTransactionHelper_transactionLimit, "f"),
+                        });
+                    // TODO: Replace `any` with type
+                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
+                }
+                catch (error) {
+                    (0, logger_1.incomingTransactionsLogger)('Error while fetching remote transactions', error);
+                    return;
+                }
+                if (!__classPrivateFieldGet(this, _IncomingTransactionHelper_updateTransactions, "f")) {
+                    remoteTransactions = remoteTransactions.filter((tx) => { var _a; return ((_a = tx.txParams.to) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === address.toLowerCase(); });
+                }
+                const localTransactions = !__classPrivateFieldGet(this, _IncomingTransactionHelper_updateTransactions, "f")
+                    ? []
+                    : __classPrivateFieldGet(this, _IncomingTransactionHelper_getLocalTransactions, "f").call(this);
+                const newTransactions = __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_getNewTransactions).call(this, remoteTransactions, localTransactions);
+                const updatedTransactions = __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_getUpdatedTransactions).call(this, remoteTransactions, localTransactions);
+                if (newTransactions.length > 0 || updatedTransactions.length > 0) {
+                    __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_sortTransactionsByTime).call(this, newTransactions);
+                    __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_sortTransactionsByTime).call(this, updatedTransactions);
+                    (0, logger_1.incomingTransactionsLogger)('Found incoming transactions', {
+                        new: newTransactions,
+                        updated: updatedTransactions,
+                    });
+                    this.hub.emit('transactions', {
+                        added: newTransactions,
+                        updated: updatedTransactions,
+                    });
+                }
+                __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_updateLastFetchedBlockNumber).call(this, remoteTransactions, additionalLastFetchedKeys);
+            }
+            finally {
+                releaseLock();
+            }
+        });
+    }
+}
+exports.IncomingTransactionHelper = IncomingTransactionHelper;
+_IncomingTransactionHelper_blockTracker = new WeakMap(), _IncomingTransactionHelper_getCurrentAccount = new WeakMap(), _IncomingTransactionHelper_getLastFetchedBlockNumbers = new WeakMap(), _IncomingTransactionHelper_getLocalTransactions = new WeakMap(), _IncomingTransactionHelper_getNetworkState = new WeakMap(), _IncomingTransactionHelper_isEnabled = new WeakMap(), _IncomingTransactionHelper_isRunning = new WeakMap(), _IncomingTransactionHelper_mutex = new WeakMap(), _IncomingTransactionHelper_onLatestBlock = new WeakMap(), _IncomingTransactionHelper_queryEntireHistory = new WeakMap(), _IncomingTransactionHelper_remoteTransactionSource = new WeakMap(), _IncomingTransactionHelper_transactionLimit = new WeakMap(), _IncomingTransactionHelper_updateTransactions = new WeakMap(), _IncomingTransactionHelper_instances = new WeakSet(), _IncomingTransactionHelper_sortTransactionsByTime = function _IncomingTransactionHelper_sortTransactionsByTime(transactions) {
+    transactions.sort((a, b) => (a.time < b.time ? -1 : 1));
+}, _IncomingTransactionHelper_getNewTransactions = function _IncomingTransactionHelper_getNewTransactions(remoteTxs, localTxs) {
+    return remoteTxs.filter((tx) => !localTxs.some(({ hash }) => hash === tx.hash));
+}, _IncomingTransactionHelper_getUpdatedTransactions = function _IncomingTransactionHelper_getUpdatedTransactions(remoteTxs, localTxs) {
+    return remoteTxs.filter((remoteTx) => localTxs.some((localTx) => remoteTx.hash === localTx.hash &&
+        __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_isTransactionOutdated).call(this, remoteTx, localTx)));
+}, _IncomingTransactionHelper_isTransactionOutdated = function _IncomingTransactionHelper_isTransactionOutdated(remoteTx, localTx) {
+    return UPDATE_CHECKS.some((getValue) => getValue(remoteTx) !== getValue(localTx));
+}, _IncomingTransactionHelper_getFromBlock = function _IncomingTransactionHelper_getFromBlock(latestBlockNumber, additionalKeys) {
+    const lastFetchedKey = __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_getBlockNumberKey).call(this, additionalKeys);
+    const lastFetchedBlockNumber = __classPrivateFieldGet(this, _IncomingTransactionHelper_getLastFetchedBlockNumbers, "f").call(this)[lastFetchedKey];
+    if (lastFetchedBlockNumber) {
+        return lastFetchedBlockNumber + 1;
+    }
+    return __classPrivateFieldGet(this, _IncomingTransactionHelper_queryEntireHistory, "f")
+        ? undefined
+        : latestBlockNumber - RECENT_HISTORY_BLOCK_RANGE;
+}, _IncomingTransactionHelper_updateLastFetchedBlockNumber = function _IncomingTransactionHelper_updateLastFetchedBlockNumber(remoteTxs, additionalKeys) {
+    let lastFetchedBlockNumber = -1;
+    for (const tx of remoteTxs) {
+        const currentBlockNumberValue = tx.blockNumber
+            ? parseInt(tx.blockNumber, 10)
+            : -1;
+        lastFetchedBlockNumber = Math.max(lastFetchedBlockNumber, currentBlockNumberValue);
+    }
+    if (lastFetchedBlockNumber === -1) {
+        return;
+    }
+    const lastFetchedKey = __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_getBlockNumberKey).call(this, additionalKeys);
+    const lastFetchedBlockNumbers = __classPrivateFieldGet(this, _IncomingTransactionHelper_getLastFetchedBlockNumbers, "f").call(this);
+    const previousValue = lastFetchedBlockNumbers[lastFetchedKey];
+    if (previousValue >= lastFetchedBlockNumber) {
+        return;
+    }
+    lastFetchedBlockNumbers[lastFetchedKey] = lastFetchedBlockNumber;
+    this.hub.emit('updatedLastFetchedBlockNumbers', {
+        lastFetchedBlockNumbers,
+        blockNumber: lastFetchedBlockNumber,
+    });
+}, _IncomingTransactionHelper_getBlockNumberKey = function _IncomingTransactionHelper_getBlockNumberKey(additionalKeys) {
+    const currentChainId = __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_getCurrentChainId).call(this);
+    const currentAccount = __classPrivateFieldGet(this, _IncomingTransactionHelper_getCurrentAccount, "f").call(this).toLowerCase();
+    return [currentChainId, currentAccount, ...additionalKeys].join('#');
+}, _IncomingTransactionHelper_canStart = function _IncomingTransactionHelper_canStart() {
+    const isEnabled = __classPrivateFieldGet(this, _IncomingTransactionHelper_isEnabled, "f").call(this);
+    const currentChainId = __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_getCurrentChainId).call(this);
+    const isSupportedNetwork = __classPrivateFieldGet(this, _IncomingTransactionHelper_remoteTransactionSource, "f").isSupportedNetwork(currentChainId);
+    return isEnabled && isSupportedNetwork;
+}, _IncomingTransactionHelper_getCurrentChainId = function _IncomingTransactionHelper_getCurrentChainId() {
+    return __classPrivateFieldGet(this, _IncomingTransactionHelper_getNetworkState, "f").call(this).providerConfig.chainId;
+};
+//# sourceMappingURL=IncomingTransactionHelper.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/helpers/IncomingTransactionHelper.js.map b/node_modules/@metamask/transaction-controller/dist/helpers/IncomingTransactionHelper.js.map
new file mode 100644
index 0000000..b7780b4
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/helpers/IncomingTransactionHelper.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"IncomingTransactionHelper.js","sourceRoot":"","sources":["../../src/helpers/IncomingTransactionHelper.ts"],"names":[],"mappings":"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","sourcesContent":["import type { BlockTracker, NetworkState } from '@metamask/network-controller';\nimport type { Hex } from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\nimport EventEmitter from 'events';\n\nimport { incomingTransactionsLogger as log } from '../logger';\nimport type { RemoteTransactionSource, TransactionMeta } from '../types';\n\nconst RECENT_HISTORY_BLOCK_RANGE = 10;\n\n// TODO: Replace `any` with type\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst UPDATE_CHECKS: ((txMeta: TransactionMeta) => any)[] = [\n  (txMeta) => txMeta.status,\n  (txMeta) => txMeta.txParams.gasUsed,\n];\n\nexport class IncomingTransactionHelper {\n  hub: EventEmitter;\n\n  #blockTracker: BlockTracker;\n\n  #getCurrentAccount: () => string;\n\n  #getLastFetchedBlockNumbers: () => Record<string, number>;\n\n  #getLocalTransactions: () => TransactionMeta[];\n\n  #getNetworkState: () => NetworkState;\n\n  #isEnabled: () => boolean;\n\n  #isRunning: boolean;\n\n  #mutex = new Mutex();\n\n  #onLatestBlock: (blockNumberHex: Hex) => Promise<void>;\n\n  #queryEntireHistory: boolean;\n\n  #remoteTransactionSource: RemoteTransactionSource;\n\n  #transactionLimit?: number;\n\n  #updateTransactions: boolean;\n\n  constructor({\n    blockTracker,\n    getCurrentAccount,\n    getLastFetchedBlockNumbers,\n    getLocalTransactions,\n    getNetworkState,\n    isEnabled,\n    queryEntireHistory,\n    remoteTransactionSource,\n    transactionLimit,\n    updateTransactions,\n  }: {\n    blockTracker: BlockTracker;\n    getCurrentAccount: () => string;\n    getLastFetchedBlockNumbers: () => Record<string, number>;\n    getLocalTransactions?: () => TransactionMeta[];\n    getNetworkState: () => NetworkState;\n    isEnabled?: () => boolean;\n    queryEntireHistory?: boolean;\n    remoteTransactionSource: RemoteTransactionSource;\n    transactionLimit?: number;\n    updateTransactions?: boolean;\n  }) {\n    this.hub = new EventEmitter();\n\n    this.#blockTracker = blockTracker;\n    this.#getCurrentAccount = getCurrentAccount;\n    this.#getLastFetchedBlockNumbers = getLastFetchedBlockNumbers;\n    this.#getLocalTransactions = getLocalTransactions || (() => []);\n    this.#getNetworkState = getNetworkState;\n    this.#isEnabled = isEnabled ?? (() => true);\n    this.#isRunning = false;\n    this.#queryEntireHistory = queryEntireHistory ?? true;\n    this.#remoteTransactionSource = remoteTransactionSource;\n    this.#transactionLimit = transactionLimit;\n    this.#updateTransactions = updateTransactions ?? false;\n\n    // Using a property instead of a method to provide a listener reference\n    // with the correct scope that we can remove later if stopped.\n    this.#onLatestBlock = async (blockNumberHex: Hex) => {\n      try {\n        await this.update(blockNumberHex);\n      } catch (error) {\n        console.error('Error while checking incoming transactions', error);\n      }\n    };\n  }\n\n  start() {\n    if (this.#isRunning) {\n      return;\n    }\n\n    if (!this.#canStart()) {\n      return;\n    }\n\n    this.#blockTracker.addListener('latest', this.#onLatestBlock);\n    this.#isRunning = true;\n  }\n\n  stop() {\n    this.#blockTracker.removeListener('latest', this.#onLatestBlock);\n    this.#isRunning = false;\n  }\n\n  async update(latestBlockNumberHex?: Hex): Promise<void> {\n    const releaseLock = await this.#mutex.acquire();\n\n    log('Checking for incoming transactions');\n\n    try {\n      if (!this.#canStart()) {\n        return;\n      }\n\n      const latestBlockNumber = parseInt(\n        latestBlockNumberHex || (await this.#blockTracker.getLatestBlock()),\n        16,\n      );\n\n      const additionalLastFetchedKeys =\n        this.#remoteTransactionSource.getLastBlockVariations?.() ?? [];\n\n      const fromBlock = this.#getFromBlock(\n        latestBlockNumber,\n        additionalLastFetchedKeys,\n      );\n\n      const address = this.#getCurrentAccount();\n      const currentChainId = this.#getCurrentChainId();\n\n      let remoteTransactions = [];\n\n      try {\n        remoteTransactions =\n          await this.#remoteTransactionSource.fetchTransactions({\n            address,\n            currentChainId,\n            fromBlock,\n            limit: this.#transactionLimit,\n          });\n        // TODO: Replace `any` with type\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      } catch (error: any) {\n        log('Error while fetching remote transactions', error);\n        return;\n      }\n\n      if (!this.#updateTransactions) {\n        remoteTransactions = remoteTransactions.filter(\n          (tx) => tx.txParams.to?.toLowerCase() === address.toLowerCase(),\n        );\n      }\n\n      const localTransactions = !this.#updateTransactions\n        ? []\n        : this.#getLocalTransactions();\n\n      const newTransactions = this.#getNewTransactions(\n        remoteTransactions,\n        localTransactions,\n      );\n\n      const updatedTransactions = this.#getUpdatedTransactions(\n        remoteTransactions,\n        localTransactions,\n      );\n\n      if (newTransactions.length > 0 || updatedTransactions.length > 0) {\n        this.#sortTransactionsByTime(newTransactions);\n        this.#sortTransactionsByTime(updatedTransactions);\n\n        log('Found incoming transactions', {\n          new: newTransactions,\n          updated: updatedTransactions,\n        });\n\n        this.hub.emit('transactions', {\n          added: newTransactions,\n          updated: updatedTransactions,\n        });\n      }\n\n      this.#updateLastFetchedBlockNumber(\n        remoteTransactions,\n        additionalLastFetchedKeys,\n      );\n    } finally {\n      releaseLock();\n    }\n  }\n\n  #sortTransactionsByTime(transactions: TransactionMeta[]) {\n    transactions.sort((a, b) => (a.time < b.time ? -1 : 1));\n  }\n\n  #getNewTransactions(\n    remoteTxs: TransactionMeta[],\n    localTxs: TransactionMeta[],\n  ): TransactionMeta[] {\n    return remoteTxs.filter(\n      (tx) => !localTxs.some(({ hash }) => hash === tx.hash),\n    );\n  }\n\n  #getUpdatedTransactions(\n    remoteTxs: TransactionMeta[],\n    localTxs: TransactionMeta[],\n  ): TransactionMeta[] {\n    return remoteTxs.filter((remoteTx) =>\n      localTxs.some(\n        (localTx) =>\n          remoteTx.hash === localTx.hash &&\n          this.#isTransactionOutdated(remoteTx, localTx),\n      ),\n    );\n  }\n\n  #isTransactionOutdated(\n    remoteTx: TransactionMeta,\n    localTx: TransactionMeta,\n  ): boolean {\n    return UPDATE_CHECKS.some(\n      (getValue) => getValue(remoteTx) !== getValue(localTx),\n    );\n  }\n\n  #getFromBlock(\n    latestBlockNumber: number,\n    additionalKeys: string[],\n  ): number | undefined {\n    const lastFetchedKey = this.#getBlockNumberKey(additionalKeys);\n\n    const lastFetchedBlockNumber =\n      this.#getLastFetchedBlockNumbers()[lastFetchedKey];\n\n    if (lastFetchedBlockNumber) {\n      return lastFetchedBlockNumber + 1;\n    }\n\n    return this.#queryEntireHistory\n      ? undefined\n      : latestBlockNumber - RECENT_HISTORY_BLOCK_RANGE;\n  }\n\n  #updateLastFetchedBlockNumber(\n    remoteTxs: TransactionMeta[],\n    additionalKeys: string[],\n  ) {\n    let lastFetchedBlockNumber = -1;\n\n    for (const tx of remoteTxs) {\n      const currentBlockNumberValue = tx.blockNumber\n        ? parseInt(tx.blockNumber, 10)\n        : -1;\n\n      lastFetchedBlockNumber = Math.max(\n        lastFetchedBlockNumber,\n        currentBlockNumberValue,\n      );\n    }\n\n    if (lastFetchedBlockNumber === -1) {\n      return;\n    }\n\n    const lastFetchedKey = this.#getBlockNumberKey(additionalKeys);\n    const lastFetchedBlockNumbers = this.#getLastFetchedBlockNumbers();\n    const previousValue = lastFetchedBlockNumbers[lastFetchedKey];\n\n    if (previousValue >= lastFetchedBlockNumber) {\n      return;\n    }\n\n    lastFetchedBlockNumbers[lastFetchedKey] = lastFetchedBlockNumber;\n\n    this.hub.emit('updatedLastFetchedBlockNumbers', {\n      lastFetchedBlockNumbers,\n      blockNumber: lastFetchedBlockNumber,\n    });\n  }\n\n  #getBlockNumberKey(additionalKeys: string[]): string {\n    const currentChainId = this.#getCurrentChainId();\n    const currentAccount = this.#getCurrentAccount().toLowerCase();\n\n    return [currentChainId, currentAccount, ...additionalKeys].join('#');\n  }\n\n  #canStart(): boolean {\n    const isEnabled = this.#isEnabled();\n    const currentChainId = this.#getCurrentChainId();\n\n    const isSupportedNetwork =\n      this.#remoteTransactionSource.isSupportedNetwork(currentChainId);\n\n    return isEnabled && isSupportedNetwork;\n  }\n\n  #getCurrentChainId(): Hex {\n    return this.#getNetworkState().providerConfig.chainId;\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/helpers/MultichainTrackingHelper.d.ts b/node_modules/@metamask/transaction-controller/dist/helpers/MultichainTrackingHelper.d.ts
new file mode 100644
index 0000000..0541964
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/helpers/MultichainTrackingHelper.d.ts
@@ -0,0 +1,72 @@
+import EthQuery from '@metamask/eth-query';
+import type { NetworkClientId, NetworkController, BlockTracker, Provider, NetworkControllerStateChangeEvent } from '@metamask/network-controller';
+import type { Hex } from '@metamask/utils';
+import type { NonceLock, NonceTracker } from 'nonce-tracker';
+import { EtherscanRemoteTransactionSource } from './EtherscanRemoteTransactionSource';
+import type { IncomingTransactionHelper, IncomingTransactionOptions } from './IncomingTransactionHelper';
+import type { PendingTransactionTracker } from './PendingTransactionTracker';
+export declare type MultichainTrackingHelperOptions = {
+    isMultichainEnabled: boolean;
+    provider: Provider;
+    nonceTracker: NonceTracker;
+    incomingTransactionOptions: IncomingTransactionOptions;
+    findNetworkClientIdByChainId: NetworkController['findNetworkClientIdByChainId'];
+    getNetworkClientById: NetworkController['getNetworkClientById'];
+    getNetworkClientRegistry: NetworkController['getNetworkClientRegistry'];
+    removeIncomingTransactionHelperListeners: (IncomingTransactionHelper: IncomingTransactionHelper) => void;
+    removePendingTransactionTrackerListeners: (pendingTransactionTracker: PendingTransactionTracker) => void;
+    createNonceTracker: (opts: {
+        provider: Provider;
+        blockTracker: BlockTracker;
+        chainId?: Hex;
+    }) => NonceTracker;
+    createIncomingTransactionHelper: (opts: {
+        blockTracker: BlockTracker;
+        etherscanRemoteTransactionSource: EtherscanRemoteTransactionSource;
+        chainId?: Hex;
+    }) => IncomingTransactionHelper;
+    createPendingTransactionTracker: (opts: {
+        provider: Provider;
+        blockTracker: BlockTracker;
+        chainId?: Hex;
+    }) => PendingTransactionTracker;
+    onNetworkStateChange: (listener: (...payload: NetworkControllerStateChangeEvent['payload']) => void) => void;
+};
+export declare class MultichainTrackingHelper {
+    #private;
+    constructor({ isMultichainEnabled, provider, nonceTracker, incomingTransactionOptions, findNetworkClientIdByChainId, getNetworkClientById, getNetworkClientRegistry, removeIncomingTransactionHelperListeners, removePendingTransactionTrackerListeners, createNonceTracker, createIncomingTransactionHelper, createPendingTransactionTracker, onNetworkStateChange, }: MultichainTrackingHelperOptions);
+    initialize(): void;
+    has(networkClientId: NetworkClientId): boolean;
+    getEthQuery({ networkClientId, chainId, }?: {
+        networkClientId?: NetworkClientId;
+        chainId?: Hex;
+    }): EthQuery;
+    /**
+     * Gets the mutex intended to guard the nonceTracker for a particular chainId and key .
+     *
+     * @param opts - The options object.
+     * @param opts.chainId - The hex chainId.
+     * @param opts.key - The hex address (or constant) pertaining to the chainId
+     * @returns Mutex instance for the given chainId and key pair
+     */
+    acquireNonceLockForChainIdKey({ chainId, key, }: {
+        chainId: Hex;
+        key?: string;
+    }): Promise<() => void>;
+    /**
+     * Gets the next nonce according to the nonce-tracker.
+     * Ensure `releaseLock` is called once processing of the `nonce` value is complete.
+     *
+     * @param address - The hex string address for the transaction.
+     * @param networkClientId - The network client ID for the transaction, used to fetch the correct nonce tracker.
+     * @returns object with the `nextNonce` `nonceDetails`, and the releaseLock.
+     */
+    getNonceLock(address: string, networkClientId?: NetworkClientId): Promise<NonceLock>;
+    startIncomingTransactionPolling(networkClientIds?: NetworkClientId[]): void;
+    stopIncomingTransactionPolling(networkClientIds?: NetworkClientId[]): void;
+    stopAllIncomingTransactionPolling(): void;
+    updateIncomingTransactions(networkClientIds?: NetworkClientId[]): Promise<void>;
+    checkForPendingTransactionAndStartPolling: () => void;
+    stopAllTracking(): void;
+}
+//# sourceMappingURL=MultichainTrackingHelper.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/helpers/MultichainTrackingHelper.d.ts.map b/node_modules/@metamask/transaction-controller/dist/helpers/MultichainTrackingHelper.d.ts.map
new file mode 100644
index 0000000..3cb1f3c
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/helpers/MultichainTrackingHelper.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"MultichainTrackingHelper.d.ts","sourceRoot":"","sources":["../../src/helpers/MultichainTrackingHelper.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/helpers/MultichainTrackingHelper.js b/node_modules/@metamask/transaction-controller/dist/helpers/MultichainTrackingHelper.js
new file mode 100644
index 0000000..237e8a0
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/helpers/MultichainTrackingHelper.js
@@ -0,0 +1,292 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
+    if (kind === "m") throw new TypeError("Private method is not writable");
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
+    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
+};
+var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
+    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
+};
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+var _MultichainTrackingHelper_instances, _MultichainTrackingHelper_isMultichainEnabled, _MultichainTrackingHelper_provider, _MultichainTrackingHelper_nonceTracker, _MultichainTrackingHelper_incomingTransactionOptions, _MultichainTrackingHelper_findNetworkClientIdByChainId, _MultichainTrackingHelper_getNetworkClientById, _MultichainTrackingHelper_getNetworkClientRegistry, _MultichainTrackingHelper_removeIncomingTransactionHelperListeners, _MultichainTrackingHelper_removePendingTransactionTrackerListeners, _MultichainTrackingHelper_createNonceTracker, _MultichainTrackingHelper_createIncomingTransactionHelper, _MultichainTrackingHelper_createPendingTransactionTracker, _MultichainTrackingHelper_nonceMutexesByChainId, _MultichainTrackingHelper_trackingMap, _MultichainTrackingHelper_etherscanRemoteTransactionSourcesMap, _MultichainTrackingHelper_refreshTrackingMap, _MultichainTrackingHelper_stopTrackingByNetworkClientId, _MultichainTrackingHelper_startTrackingByNetworkClientId, _MultichainTrackingHelper_refreshEtherscanRemoteTransactionSources;
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.MultichainTrackingHelper = void 0;
+const eth_query_1 = __importDefault(require("@metamask/eth-query"));
+const async_mutex_1 = require("async-mutex");
+const logger_1 = require("../logger");
+const EtherscanRemoteTransactionSource_1 = require("./EtherscanRemoteTransactionSource");
+class MultichainTrackingHelper {
+    constructor({ isMultichainEnabled, provider, nonceTracker, incomingTransactionOptions, findNetworkClientIdByChainId, getNetworkClientById, getNetworkClientRegistry, removeIncomingTransactionHelperListeners, removePendingTransactionTrackerListeners, createNonceTracker, createIncomingTransactionHelper, createPendingTransactionTracker, onNetworkStateChange, }) {
+        _MultichainTrackingHelper_instances.add(this);
+        _MultichainTrackingHelper_isMultichainEnabled.set(this, void 0);
+        _MultichainTrackingHelper_provider.set(this, void 0);
+        _MultichainTrackingHelper_nonceTracker.set(this, void 0);
+        _MultichainTrackingHelper_incomingTransactionOptions.set(this, void 0);
+        _MultichainTrackingHelper_findNetworkClientIdByChainId.set(this, void 0);
+        _MultichainTrackingHelper_getNetworkClientById.set(this, void 0);
+        _MultichainTrackingHelper_getNetworkClientRegistry.set(this, void 0);
+        _MultichainTrackingHelper_removeIncomingTransactionHelperListeners.set(this, void 0);
+        _MultichainTrackingHelper_removePendingTransactionTrackerListeners.set(this, void 0);
+        _MultichainTrackingHelper_createNonceTracker.set(this, void 0);
+        _MultichainTrackingHelper_createIncomingTransactionHelper.set(this, void 0);
+        _MultichainTrackingHelper_createPendingTransactionTracker.set(this, void 0);
+        _MultichainTrackingHelper_nonceMutexesByChainId.set(this, new Map());
+        _MultichainTrackingHelper_trackingMap.set(this, new Map());
+        _MultichainTrackingHelper_etherscanRemoteTransactionSourcesMap.set(this, new Map());
+        this.checkForPendingTransactionAndStartPolling = () => {
+            for (const [, trackers] of __classPrivateFieldGet(this, _MultichainTrackingHelper_trackingMap, "f")) {
+                trackers.pendingTransactionTracker.startIfPendingTransactions();
+            }
+        };
+        _MultichainTrackingHelper_refreshTrackingMap.set(this, (networkClients) => {
+            __classPrivateFieldGet(this, _MultichainTrackingHelper_refreshEtherscanRemoteTransactionSources, "f").call(this, networkClients);
+            const networkClientIds = Object.keys(networkClients);
+            const existingNetworkClientIds = Array.from(__classPrivateFieldGet(this, _MultichainTrackingHelper_trackingMap, "f").keys());
+            // Remove tracking for NetworkClientIds that no longer exist
+            const networkClientIdsToRemove = existingNetworkClientIds.filter((id) => !networkClientIds.includes(id));
+            networkClientIdsToRemove.forEach((id) => {
+                __classPrivateFieldGet(this, _MultichainTrackingHelper_instances, "m", _MultichainTrackingHelper_stopTrackingByNetworkClientId).call(this, id);
+            });
+            // Start tracking new NetworkClientIds from the registry
+            const networkClientIdsToAdd = networkClientIds.filter((id) => !existingNetworkClientIds.includes(id));
+            networkClientIdsToAdd.forEach((id) => {
+                __classPrivateFieldGet(this, _MultichainTrackingHelper_instances, "m", _MultichainTrackingHelper_startTrackingByNetworkClientId).call(this, id);
+            });
+        });
+        _MultichainTrackingHelper_refreshEtherscanRemoteTransactionSources.set(this, (networkClients) => {
+            // this will be prettier when we have consolidated network clients with a single chainId:
+            // check if there are still other network clients using the same chainId
+            // if not remove the etherscanRemoteTransaction source from the map
+            const chainIdsInRegistry = new Set();
+            Object.values(networkClients).forEach((networkClient) => chainIdsInRegistry.add(networkClient.configuration.chainId));
+            const existingChainIds = Array.from(__classPrivateFieldGet(this, _MultichainTrackingHelper_etherscanRemoteTransactionSourcesMap, "f").keys());
+            const chainIdsToRemove = existingChainIds.filter((chainId) => !chainIdsInRegistry.has(chainId));
+            chainIdsToRemove.forEach((chainId) => {
+                __classPrivateFieldGet(this, _MultichainTrackingHelper_etherscanRemoteTransactionSourcesMap, "f").delete(chainId);
+            });
+        });
+        __classPrivateFieldSet(this, _MultichainTrackingHelper_isMultichainEnabled, isMultichainEnabled, "f");
+        __classPrivateFieldSet(this, _MultichainTrackingHelper_provider, provider, "f");
+        __classPrivateFieldSet(this, _MultichainTrackingHelper_nonceTracker, nonceTracker, "f");
+        __classPrivateFieldSet(this, _MultichainTrackingHelper_incomingTransactionOptions, incomingTransactionOptions, "f");
+        __classPrivateFieldSet(this, _MultichainTrackingHelper_findNetworkClientIdByChainId, findNetworkClientIdByChainId, "f");
+        __classPrivateFieldSet(this, _MultichainTrackingHelper_getNetworkClientById, getNetworkClientById, "f");
+        __classPrivateFieldSet(this, _MultichainTrackingHelper_getNetworkClientRegistry, getNetworkClientRegistry, "f");
+        __classPrivateFieldSet(this, _MultichainTrackingHelper_removeIncomingTransactionHelperListeners, removeIncomingTransactionHelperListeners, "f");
+        __classPrivateFieldSet(this, _MultichainTrackingHelper_removePendingTransactionTrackerListeners, removePendingTransactionTrackerListeners, "f");
+        __classPrivateFieldSet(this, _MultichainTrackingHelper_createNonceTracker, createNonceTracker, "f");
+        __classPrivateFieldSet(this, _MultichainTrackingHelper_createIncomingTransactionHelper, createIncomingTransactionHelper, "f");
+        __classPrivateFieldSet(this, _MultichainTrackingHelper_createPendingTransactionTracker, createPendingTransactionTracker, "f");
+        onNetworkStateChange((_, patches) => {
+            if (__classPrivateFieldGet(this, _MultichainTrackingHelper_isMultichainEnabled, "f")) {
+                const networkClients = __classPrivateFieldGet(this, _MultichainTrackingHelper_getNetworkClientRegistry, "f").call(this);
+                patches.forEach(({ op, path }) => {
+                    if (op === 'remove' && path[0] === 'networkConfigurations') {
+                        const networkClientId = path[1];
+                        delete networkClients[networkClientId];
+                    }
+                });
+                __classPrivateFieldGet(this, _MultichainTrackingHelper_refreshTrackingMap, "f").call(this, networkClients);
+            }
+        });
+    }
+    initialize() {
+        if (!__classPrivateFieldGet(this, _MultichainTrackingHelper_isMultichainEnabled, "f")) {
+            return;
+        }
+        const networkClients = __classPrivateFieldGet(this, _MultichainTrackingHelper_getNetworkClientRegistry, "f").call(this);
+        __classPrivateFieldGet(this, _MultichainTrackingHelper_refreshTrackingMap, "f").call(this, networkClients);
+    }
+    has(networkClientId) {
+        return __classPrivateFieldGet(this, _MultichainTrackingHelper_trackingMap, "f").has(networkClientId);
+    }
+    getEthQuery({ networkClientId, chainId, } = {}) {
+        if (!__classPrivateFieldGet(this, _MultichainTrackingHelper_isMultichainEnabled, "f")) {
+            return new eth_query_1.default(__classPrivateFieldGet(this, _MultichainTrackingHelper_provider, "f"));
+        }
+        let networkClient;
+        if (networkClientId) {
+            try {
+                networkClient = __classPrivateFieldGet(this, _MultichainTrackingHelper_getNetworkClientById, "f").call(this, networkClientId);
+            }
+            catch (err) {
+                (0, logger_1.incomingTransactionsLogger)('failed to get network client by networkClientId');
+            }
+        }
+        if (!networkClient && chainId) {
+            try {
+                networkClientId = __classPrivateFieldGet(this, _MultichainTrackingHelper_findNetworkClientIdByChainId, "f").call(this, chainId);
+                networkClient = __classPrivateFieldGet(this, _MultichainTrackingHelper_getNetworkClientById, "f").call(this, networkClientId);
+            }
+            catch (err) {
+                (0, logger_1.incomingTransactionsLogger)('failed to get network client by chainId');
+            }
+        }
+        if (networkClient) {
+            return new eth_query_1.default(networkClient.provider);
+        }
+        // NOTE(JL): we're not ready to drop globally selected ethQuery yet.
+        // Some calls to getEthQuery only have access to optional networkClientId
+        // throw new Error('failed to get eth query instance');
+        return new eth_query_1.default(__classPrivateFieldGet(this, _MultichainTrackingHelper_provider, "f"));
+    }
+    /**
+     * Gets the mutex intended to guard the nonceTracker for a particular chainId and key .
+     *
+     * @param opts - The options object.
+     * @param opts.chainId - The hex chainId.
+     * @param opts.key - The hex address (or constant) pertaining to the chainId
+     * @returns Mutex instance for the given chainId and key pair
+     */
+    acquireNonceLockForChainIdKey({ chainId, key = 'global', }) {
+        return __awaiter(this, void 0, void 0, function* () {
+            let nonceMutexesForChainId = __classPrivateFieldGet(this, _MultichainTrackingHelper_nonceMutexesByChainId, "f").get(chainId);
+            if (!nonceMutexesForChainId) {
+                nonceMutexesForChainId = new Map();
+                __classPrivateFieldGet(this, _MultichainTrackingHelper_nonceMutexesByChainId, "f").set(chainId, nonceMutexesForChainId);
+            }
+            let nonceMutexForKey = nonceMutexesForChainId.get(key);
+            if (!nonceMutexForKey) {
+                nonceMutexForKey = new async_mutex_1.Mutex();
+                nonceMutexesForChainId.set(key, nonceMutexForKey);
+            }
+            return yield nonceMutexForKey.acquire();
+        });
+    }
+    /**
+     * Gets the next nonce according to the nonce-tracker.
+     * Ensure `releaseLock` is called once processing of the `nonce` value is complete.
+     *
+     * @param address - The hex string address for the transaction.
+     * @param networkClientId - The network client ID for the transaction, used to fetch the correct nonce tracker.
+     * @returns object with the `nextNonce` `nonceDetails`, and the releaseLock.
+     */
+    getNonceLock(address, networkClientId) {
+        return __awaiter(this, void 0, void 0, function* () {
+            let releaseLockForChainIdKey;
+            let nonceTracker = __classPrivateFieldGet(this, _MultichainTrackingHelper_nonceTracker, "f");
+            if (networkClientId && __classPrivateFieldGet(this, _MultichainTrackingHelper_isMultichainEnabled, "f")) {
+                const networkClient = __classPrivateFieldGet(this, _MultichainTrackingHelper_getNetworkClientById, "f").call(this, networkClientId);
+                releaseLockForChainIdKey = yield this.acquireNonceLockForChainIdKey({
+                    chainId: networkClient.configuration.chainId,
+                    key: address,
+                });
+                const trackers = __classPrivateFieldGet(this, _MultichainTrackingHelper_trackingMap, "f").get(networkClientId);
+                if (!trackers) {
+                    throw new Error('missing nonceTracker for networkClientId');
+                }
+                nonceTracker = trackers.nonceTracker;
+            }
+            // Acquires the lock for the chainId + address and the nonceLock from the nonceTracker, then
+            // couples them together by replacing the nonceLock's releaseLock method with
+            // an anonymous function that calls releases both the original nonceLock and the
+            // lock for the chainId.
+            try {
+                const nonceLock = yield nonceTracker.getNonceLock(address);
+                return Object.assign(Object.assign({}, nonceLock), { releaseLock: () => {
+                        nonceLock.releaseLock();
+                        releaseLockForChainIdKey === null || releaseLockForChainIdKey === void 0 ? void 0 : releaseLockForChainIdKey();
+                    } });
+            }
+            catch (err) {
+                releaseLockForChainIdKey === null || releaseLockForChainIdKey === void 0 ? void 0 : releaseLockForChainIdKey();
+                throw err;
+            }
+        });
+    }
+    startIncomingTransactionPolling(networkClientIds = []) {
+        networkClientIds.forEach((networkClientId) => {
+            var _a;
+            (_a = __classPrivateFieldGet(this, _MultichainTrackingHelper_trackingMap, "f").get(networkClientId)) === null || _a === void 0 ? void 0 : _a.incomingTransactionHelper.start();
+        });
+    }
+    stopIncomingTransactionPolling(networkClientIds = []) {
+        networkClientIds.forEach((networkClientId) => {
+            var _a;
+            (_a = __classPrivateFieldGet(this, _MultichainTrackingHelper_trackingMap, "f").get(networkClientId)) === null || _a === void 0 ? void 0 : _a.incomingTransactionHelper.stop();
+        });
+    }
+    stopAllIncomingTransactionPolling() {
+        for (const [, trackers] of __classPrivateFieldGet(this, _MultichainTrackingHelper_trackingMap, "f")) {
+            trackers.incomingTransactionHelper.stop();
+        }
+    }
+    updateIncomingTransactions(networkClientIds = []) {
+        return __awaiter(this, void 0, void 0, function* () {
+            const promises = yield Promise.allSettled(networkClientIds.map((networkClientId) => __awaiter(this, void 0, void 0, function* () {
+                var _a;
+                return yield ((_a = __classPrivateFieldGet(this, _MultichainTrackingHelper_trackingMap, "f")
+                    .get(networkClientId)) === null || _a === void 0 ? void 0 : _a.incomingTransactionHelper.update());
+            })));
+            promises
+                .filter((result) => result.status === 'rejected')
+                .forEach((result) => {
+                (0, logger_1.incomingTransactionsLogger)('failed to update incoming transactions', result.reason);
+            });
+        });
+    }
+    stopAllTracking() {
+        for (const [networkClientId] of __classPrivateFieldGet(this, _MultichainTrackingHelper_trackingMap, "f")) {
+            __classPrivateFieldGet(this, _MultichainTrackingHelper_instances, "m", _MultichainTrackingHelper_stopTrackingByNetworkClientId).call(this, networkClientId);
+        }
+    }
+}
+exports.MultichainTrackingHelper = MultichainTrackingHelper;
+_MultichainTrackingHelper_isMultichainEnabled = new WeakMap(), _MultichainTrackingHelper_provider = new WeakMap(), _MultichainTrackingHelper_nonceTracker = new WeakMap(), _MultichainTrackingHelper_incomingTransactionOptions = new WeakMap(), _MultichainTrackingHelper_findNetworkClientIdByChainId = new WeakMap(), _MultichainTrackingHelper_getNetworkClientById = new WeakMap(), _MultichainTrackingHelper_getNetworkClientRegistry = new WeakMap(), _MultichainTrackingHelper_removeIncomingTransactionHelperListeners = new WeakMap(), _MultichainTrackingHelper_removePendingTransactionTrackerListeners = new WeakMap(), _MultichainTrackingHelper_createNonceTracker = new WeakMap(), _MultichainTrackingHelper_createIncomingTransactionHelper = new WeakMap(), _MultichainTrackingHelper_createPendingTransactionTracker = new WeakMap(), _MultichainTrackingHelper_nonceMutexesByChainId = new WeakMap(), _MultichainTrackingHelper_trackingMap = new WeakMap(), _MultichainTrackingHelper_etherscanRemoteTransactionSourcesMap = new WeakMap(), _MultichainTrackingHelper_refreshTrackingMap = new WeakMap(), _MultichainTrackingHelper_refreshEtherscanRemoteTransactionSources = new WeakMap(), _MultichainTrackingHelper_instances = new WeakSet(), _MultichainTrackingHelper_stopTrackingByNetworkClientId = function _MultichainTrackingHelper_stopTrackingByNetworkClientId(networkClientId) {
+    const trackers = __classPrivateFieldGet(this, _MultichainTrackingHelper_trackingMap, "f").get(networkClientId);
+    if (trackers) {
+        trackers.pendingTransactionTracker.stop();
+        __classPrivateFieldGet(this, _MultichainTrackingHelper_removePendingTransactionTrackerListeners, "f").call(this, trackers.pendingTransactionTracker);
+        trackers.incomingTransactionHelper.stop();
+        __classPrivateFieldGet(this, _MultichainTrackingHelper_removeIncomingTransactionHelperListeners, "f").call(this, trackers.incomingTransactionHelper);
+        __classPrivateFieldGet(this, _MultichainTrackingHelper_trackingMap, "f").delete(networkClientId);
+    }
+}, _MultichainTrackingHelper_startTrackingByNetworkClientId = function _MultichainTrackingHelper_startTrackingByNetworkClientId(networkClientId) {
+    const trackers = __classPrivateFieldGet(this, _MultichainTrackingHelper_trackingMap, "f").get(networkClientId);
+    if (trackers) {
+        return;
+    }
+    const { provider, blockTracker, configuration: { chainId }, } = __classPrivateFieldGet(this, _MultichainTrackingHelper_getNetworkClientById, "f").call(this, networkClientId);
+    let etherscanRemoteTransactionSource = __classPrivateFieldGet(this, _MultichainTrackingHelper_etherscanRemoteTransactionSourcesMap, "f").get(chainId);
+    if (!etherscanRemoteTransactionSource) {
+        etherscanRemoteTransactionSource = new EtherscanRemoteTransactionSource_1.EtherscanRemoteTransactionSource({
+            includeTokenTransfers: __classPrivateFieldGet(this, _MultichainTrackingHelper_incomingTransactionOptions, "f").includeTokenTransfers,
+        });
+        __classPrivateFieldGet(this, _MultichainTrackingHelper_etherscanRemoteTransactionSourcesMap, "f").set(chainId, etherscanRemoteTransactionSource);
+    }
+    const nonceTracker = __classPrivateFieldGet(this, _MultichainTrackingHelper_createNonceTracker, "f").call(this, {
+        provider,
+        blockTracker,
+        chainId,
+    });
+    const incomingTransactionHelper = __classPrivateFieldGet(this, _MultichainTrackingHelper_createIncomingTransactionHelper, "f").call(this, {
+        blockTracker,
+        etherscanRemoteTransactionSource,
+        chainId,
+    });
+    const pendingTransactionTracker = __classPrivateFieldGet(this, _MultichainTrackingHelper_createPendingTransactionTracker, "f").call(this, {
+        provider,
+        blockTracker,
+        chainId,
+    });
+    __classPrivateFieldGet(this, _MultichainTrackingHelper_trackingMap, "f").set(networkClientId, {
+        nonceTracker,
+        incomingTransactionHelper,
+        pendingTransactionTracker,
+    });
+};
+//# sourceMappingURL=MultichainTrackingHelper.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/helpers/MultichainTrackingHelper.js.map b/node_modules/@metamask/transaction-controller/dist/helpers/MultichainTrackingHelper.js.map
new file mode 100644
index 0000000..1f96700
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/helpers/MultichainTrackingHelper.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"MultichainTrackingHelper.js","sourceRoot":"","sources":["../../src/helpers/MultichainTrackingHelper.ts"],"names":[],"mappings":"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","sourcesContent":["import EthQuery from '@metamask/eth-query';\nimport type {\n  NetworkClientId,\n  NetworkController,\n  NetworkClient,\n  BlockTracker,\n  Provider,\n  NetworkControllerStateChangeEvent,\n} from '@metamask/network-controller';\nimport type { Hex } from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\nimport type { NonceLock, NonceTracker } from 'nonce-tracker';\n\nimport { incomingTransactionsLogger as log } from '../logger';\nimport { EtherscanRemoteTransactionSource } from './EtherscanRemoteTransactionSource';\nimport type {\n  IncomingTransactionHelper,\n  IncomingTransactionOptions,\n} from './IncomingTransactionHelper';\nimport type { PendingTransactionTracker } from './PendingTransactionTracker';\n\n/**\n * Registry of network clients provided by the NetworkController\n */\ntype NetworkClientRegistry = ReturnType<\n  NetworkController['getNetworkClientRegistry']\n>;\n\nexport type MultichainTrackingHelperOptions = {\n  isMultichainEnabled: boolean;\n  provider: Provider;\n  nonceTracker: NonceTracker;\n  incomingTransactionOptions: IncomingTransactionOptions;\n\n  findNetworkClientIdByChainId: NetworkController['findNetworkClientIdByChainId'];\n  getNetworkClientById: NetworkController['getNetworkClientById'];\n  getNetworkClientRegistry: NetworkController['getNetworkClientRegistry'];\n\n  removeIncomingTransactionHelperListeners: (\n    IncomingTransactionHelper: IncomingTransactionHelper,\n  ) => void;\n  removePendingTransactionTrackerListeners: (\n    pendingTransactionTracker: PendingTransactionTracker,\n  ) => void;\n  createNonceTracker: (opts: {\n    provider: Provider;\n    blockTracker: BlockTracker;\n    chainId?: Hex;\n  }) => NonceTracker;\n  createIncomingTransactionHelper: (opts: {\n    blockTracker: BlockTracker;\n    etherscanRemoteTransactionSource: EtherscanRemoteTransactionSource;\n    chainId?: Hex;\n  }) => IncomingTransactionHelper;\n  createPendingTransactionTracker: (opts: {\n    provider: Provider;\n    blockTracker: BlockTracker;\n    chainId?: Hex;\n  }) => PendingTransactionTracker;\n  onNetworkStateChange: (\n    listener: (\n      ...payload: NetworkControllerStateChangeEvent['payload']\n    ) => void,\n  ) => void;\n};\n\nexport class MultichainTrackingHelper {\n  #isMultichainEnabled: boolean;\n\n  readonly #provider: Provider;\n\n  readonly #nonceTracker: NonceTracker;\n\n  readonly #incomingTransactionOptions: IncomingTransactionOptions;\n\n  readonly #findNetworkClientIdByChainId: NetworkController['findNetworkClientIdByChainId'];\n\n  readonly #getNetworkClientById: NetworkController['getNetworkClientById'];\n\n  readonly #getNetworkClientRegistry: NetworkController['getNetworkClientRegistry'];\n\n  readonly #removeIncomingTransactionHelperListeners: (\n    IncomingTransactionHelper: IncomingTransactionHelper,\n  ) => void;\n\n  readonly #removePendingTransactionTrackerListeners: (\n    pendingTransactionTracker: PendingTransactionTracker,\n  ) => void;\n\n  readonly #createNonceTracker: (opts: {\n    provider: Provider;\n    blockTracker: BlockTracker;\n    chainId?: Hex;\n  }) => NonceTracker;\n\n  readonly #createIncomingTransactionHelper: (opts: {\n    blockTracker: BlockTracker;\n    chainId?: Hex;\n    etherscanRemoteTransactionSource: EtherscanRemoteTransactionSource;\n  }) => IncomingTransactionHelper;\n\n  readonly #createPendingTransactionTracker: (opts: {\n    provider: Provider;\n    blockTracker: BlockTracker;\n    chainId?: Hex;\n  }) => PendingTransactionTracker;\n\n  readonly #nonceMutexesByChainId = new Map<Hex, Map<string, Mutex>>();\n\n  readonly #trackingMap: Map<\n    NetworkClientId,\n    {\n      nonceTracker: NonceTracker;\n      pendingTransactionTracker: PendingTransactionTracker;\n      incomingTransactionHelper: IncomingTransactionHelper;\n    }\n  > = new Map();\n\n  readonly #etherscanRemoteTransactionSourcesMap: Map<\n    Hex,\n    EtherscanRemoteTransactionSource\n  > = new Map();\n\n  constructor({\n    isMultichainEnabled,\n    provider,\n    nonceTracker,\n    incomingTransactionOptions,\n    findNetworkClientIdByChainId,\n    getNetworkClientById,\n    getNetworkClientRegistry,\n    removeIncomingTransactionHelperListeners,\n    removePendingTransactionTrackerListeners,\n    createNonceTracker,\n    createIncomingTransactionHelper,\n    createPendingTransactionTracker,\n    onNetworkStateChange,\n  }: MultichainTrackingHelperOptions) {\n    this.#isMultichainEnabled = isMultichainEnabled;\n    this.#provider = provider;\n    this.#nonceTracker = nonceTracker;\n    this.#incomingTransactionOptions = incomingTransactionOptions;\n\n    this.#findNetworkClientIdByChainId = findNetworkClientIdByChainId;\n    this.#getNetworkClientById = getNetworkClientById;\n    this.#getNetworkClientRegistry = getNetworkClientRegistry;\n\n    this.#removeIncomingTransactionHelperListeners =\n      removeIncomingTransactionHelperListeners;\n    this.#removePendingTransactionTrackerListeners =\n      removePendingTransactionTrackerListeners;\n    this.#createNonceTracker = createNonceTracker;\n    this.#createIncomingTransactionHelper = createIncomingTransactionHelper;\n    this.#createPendingTransactionTracker = createPendingTransactionTracker;\n\n    onNetworkStateChange((_, patches) => {\n      if (this.#isMultichainEnabled) {\n        const networkClients = this.#getNetworkClientRegistry();\n        patches.forEach(({ op, path }) => {\n          if (op === 'remove' && path[0] === 'networkConfigurations') {\n            const networkClientId = path[1] as NetworkClientId;\n            delete networkClients[networkClientId];\n          }\n        });\n\n        this.#refreshTrackingMap(networkClients);\n      }\n    });\n  }\n\n  initialize() {\n    if (!this.#isMultichainEnabled) {\n      return;\n    }\n    const networkClients = this.#getNetworkClientRegistry();\n    this.#refreshTrackingMap(networkClients);\n  }\n\n  has(networkClientId: NetworkClientId) {\n    return this.#trackingMap.has(networkClientId);\n  }\n\n  getEthQuery({\n    networkClientId,\n    chainId,\n  }: {\n    networkClientId?: NetworkClientId;\n    chainId?: Hex;\n  } = {}): EthQuery {\n    if (!this.#isMultichainEnabled) {\n      return new EthQuery(this.#provider);\n    }\n    let networkClient: NetworkClient | undefined;\n\n    if (networkClientId) {\n      try {\n        networkClient = this.#getNetworkClientById(networkClientId);\n      } catch (err) {\n        log('failed to get network client by networkClientId');\n      }\n    }\n    if (!networkClient && chainId) {\n      try {\n        networkClientId = this.#findNetworkClientIdByChainId(chainId);\n        networkClient = this.#getNetworkClientById(networkClientId);\n      } catch (err) {\n        log('failed to get network client by chainId');\n      }\n    }\n\n    if (networkClient) {\n      return new EthQuery(networkClient.provider);\n    }\n\n    // NOTE(JL): we're not ready to drop globally selected ethQuery yet.\n    // Some calls to getEthQuery only have access to optional networkClientId\n    // throw new Error('failed to get eth query instance');\n    return new EthQuery(this.#provider);\n  }\n\n  /**\n   * Gets the mutex intended to guard the nonceTracker for a particular chainId and key .\n   *\n   * @param opts - The options object.\n   * @param opts.chainId - The hex chainId.\n   * @param opts.key - The hex address (or constant) pertaining to the chainId\n   * @returns Mutex instance for the given chainId and key pair\n   */\n  async acquireNonceLockForChainIdKey({\n    chainId,\n    key = 'global',\n  }: {\n    chainId: Hex;\n    key?: string;\n  }): Promise<() => void> {\n    let nonceMutexesForChainId = this.#nonceMutexesByChainId.get(chainId);\n    if (!nonceMutexesForChainId) {\n      nonceMutexesForChainId = new Map<string, Mutex>();\n      this.#nonceMutexesByChainId.set(chainId, nonceMutexesForChainId);\n    }\n    let nonceMutexForKey = nonceMutexesForChainId.get(key);\n    if (!nonceMutexForKey) {\n      nonceMutexForKey = new Mutex();\n      nonceMutexesForChainId.set(key, nonceMutexForKey);\n    }\n\n    return await nonceMutexForKey.acquire();\n  }\n\n  /**\n   * Gets the next nonce according to the nonce-tracker.\n   * Ensure `releaseLock` is called once processing of the `nonce` value is complete.\n   *\n   * @param address - The hex string address for the transaction.\n   * @param networkClientId - The network client ID for the transaction, used to fetch the correct nonce tracker.\n   * @returns object with the `nextNonce` `nonceDetails`, and the releaseLock.\n   */\n  async getNonceLock(\n    address: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<NonceLock> {\n    let releaseLockForChainIdKey: (() => void) | undefined;\n    let nonceTracker = this.#nonceTracker;\n    if (networkClientId && this.#isMultichainEnabled) {\n      const networkClient = this.#getNetworkClientById(networkClientId);\n      releaseLockForChainIdKey = await this.acquireNonceLockForChainIdKey({\n        chainId: networkClient.configuration.chainId,\n        key: address,\n      });\n      const trackers = this.#trackingMap.get(networkClientId);\n      if (!trackers) {\n        throw new Error('missing nonceTracker for networkClientId');\n      }\n      nonceTracker = trackers.nonceTracker;\n    }\n\n    // Acquires the lock for the chainId + address and the nonceLock from the nonceTracker, then\n    // couples them together by replacing the nonceLock's releaseLock method with\n    // an anonymous function that calls releases both the original nonceLock and the\n    // lock for the chainId.\n    try {\n      const nonceLock = await nonceTracker.getNonceLock(address);\n      return {\n        ...nonceLock,\n        releaseLock: () => {\n          nonceLock.releaseLock();\n          releaseLockForChainIdKey?.();\n        },\n      };\n    } catch (err) {\n      releaseLockForChainIdKey?.();\n      throw err;\n    }\n  }\n\n  startIncomingTransactionPolling(networkClientIds: NetworkClientId[] = []) {\n    networkClientIds.forEach((networkClientId) => {\n      this.#trackingMap.get(networkClientId)?.incomingTransactionHelper.start();\n    });\n  }\n\n  stopIncomingTransactionPolling(networkClientIds: NetworkClientId[] = []) {\n    networkClientIds.forEach((networkClientId) => {\n      this.#trackingMap.get(networkClientId)?.incomingTransactionHelper.stop();\n    });\n  }\n\n  stopAllIncomingTransactionPolling() {\n    for (const [, trackers] of this.#trackingMap) {\n      trackers.incomingTransactionHelper.stop();\n    }\n  }\n\n  async updateIncomingTransactions(networkClientIds: NetworkClientId[] = []) {\n    const promises = await Promise.allSettled(\n      networkClientIds.map(async (networkClientId) => {\n        return await this.#trackingMap\n          .get(networkClientId)\n          ?.incomingTransactionHelper.update();\n      }),\n    );\n\n    promises\n      .filter((result) => result.status === 'rejected')\n      .forEach((result) => {\n        log(\n          'failed to update incoming transactions',\n          (result as PromiseRejectedResult).reason,\n        );\n      });\n  }\n\n  checkForPendingTransactionAndStartPolling = () => {\n    for (const [, trackers] of this.#trackingMap) {\n      trackers.pendingTransactionTracker.startIfPendingTransactions();\n    }\n  };\n\n  stopAllTracking() {\n    for (const [networkClientId] of this.#trackingMap) {\n      this.#stopTrackingByNetworkClientId(networkClientId);\n    }\n  }\n\n  #refreshTrackingMap = (networkClients: NetworkClientRegistry) => {\n    this.#refreshEtherscanRemoteTransactionSources(networkClients);\n\n    const networkClientIds = Object.keys(networkClients);\n    const existingNetworkClientIds = Array.from(this.#trackingMap.keys());\n\n    // Remove tracking for NetworkClientIds that no longer exist\n    const networkClientIdsToRemove = existingNetworkClientIds.filter(\n      (id) => !networkClientIds.includes(id),\n    );\n    networkClientIdsToRemove.forEach((id) => {\n      this.#stopTrackingByNetworkClientId(id);\n    });\n\n    // Start tracking new NetworkClientIds from the registry\n    const networkClientIdsToAdd = networkClientIds.filter(\n      (id) => !existingNetworkClientIds.includes(id),\n    );\n    networkClientIdsToAdd.forEach((id) => {\n      this.#startTrackingByNetworkClientId(id);\n    });\n  };\n\n  #stopTrackingByNetworkClientId(networkClientId: NetworkClientId) {\n    const trackers = this.#trackingMap.get(networkClientId);\n    if (trackers) {\n      trackers.pendingTransactionTracker.stop();\n      this.#removePendingTransactionTrackerListeners(\n        trackers.pendingTransactionTracker,\n      );\n      trackers.incomingTransactionHelper.stop();\n      this.#removeIncomingTransactionHelperListeners(\n        trackers.incomingTransactionHelper,\n      );\n      this.#trackingMap.delete(networkClientId);\n    }\n  }\n\n  #startTrackingByNetworkClientId(networkClientId: NetworkClientId) {\n    const trackers = this.#trackingMap.get(networkClientId);\n    if (trackers) {\n      return;\n    }\n\n    const {\n      provider,\n      blockTracker,\n      configuration: { chainId },\n    } = this.#getNetworkClientById(networkClientId);\n\n    let etherscanRemoteTransactionSource =\n      this.#etherscanRemoteTransactionSourcesMap.get(chainId);\n    if (!etherscanRemoteTransactionSource) {\n      etherscanRemoteTransactionSource = new EtherscanRemoteTransactionSource({\n        includeTokenTransfers:\n          this.#incomingTransactionOptions.includeTokenTransfers,\n      });\n      this.#etherscanRemoteTransactionSourcesMap.set(\n        chainId,\n        etherscanRemoteTransactionSource,\n      );\n    }\n\n    const nonceTracker = this.#createNonceTracker({\n      provider,\n      blockTracker,\n      chainId,\n    });\n\n    const incomingTransactionHelper = this.#createIncomingTransactionHelper({\n      blockTracker,\n      etherscanRemoteTransactionSource,\n      chainId,\n    });\n\n    const pendingTransactionTracker = this.#createPendingTransactionTracker({\n      provider,\n      blockTracker,\n      chainId,\n    });\n\n    this.#trackingMap.set(networkClientId, {\n      nonceTracker,\n      incomingTransactionHelper,\n      pendingTransactionTracker,\n    });\n  }\n\n  #refreshEtherscanRemoteTransactionSources = (\n    networkClients: NetworkClientRegistry,\n  ) => {\n    // this will be prettier when we have consolidated network clients with a single chainId:\n    // check if there are still other network clients using the same chainId\n    // if not remove the etherscanRemoteTransaction source from the map\n    const chainIdsInRegistry = new Set();\n    Object.values(networkClients).forEach((networkClient) =>\n      chainIdsInRegistry.add(networkClient.configuration.chainId),\n    );\n    const existingChainIds = Array.from(\n      this.#etherscanRemoteTransactionSourcesMap.keys(),\n    );\n    const chainIdsToRemove = existingChainIds.filter(\n      (chainId) => !chainIdsInRegistry.has(chainId),\n    );\n\n    chainIdsToRemove.forEach((chainId) => {\n      this.#etherscanRemoteTransactionSourcesMap.delete(chainId);\n    });\n  };\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/helpers/PendingTransactionTracker.d.ts b/node_modules/@metamask/transaction-controller/dist/helpers/PendingTransactionTracker.d.ts
new file mode 100644
index 0000000..cf31577
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/helpers/PendingTransactionTracker.d.ts
@@ -0,0 +1,37 @@
+/// <reference types="node" />
+import type EthQuery from '@metamask/eth-query';
+import type { BlockTracker } from '@metamask/network-controller';
+import EventEmitter from 'events';
+import type { NonceTracker } from 'nonce-tracker';
+import type { TransactionMeta } from '../types';
+declare type Events = {
+    'transaction-confirmed': [txMeta: TransactionMeta];
+    'transaction-dropped': [txMeta: TransactionMeta];
+    'transaction-failed': [txMeta: TransactionMeta, error: Error];
+    'transaction-updated': [txMeta: TransactionMeta, note: string];
+};
+export interface PendingTransactionTrackerEventEmitter extends EventEmitter {
+    on<T extends keyof Events>(eventName: T, listener: (...args: Events[T]) => void): this;
+    emit<T extends keyof Events>(eventName: T, ...args: Events[T]): boolean;
+}
+export declare class PendingTransactionTracker {
+    #private;
+    hub: PendingTransactionTrackerEventEmitter;
+    constructor({ approveTransaction, blockTracker, getChainId, getEthQuery, getTransactions, isResubmitEnabled, nonceTracker, onStateChange, publishTransaction, hooks, }: {
+        approveTransaction: (transactionId: string) => Promise<void>;
+        blockTracker: BlockTracker;
+        getChainId: () => string;
+        getEthQuery: () => EthQuery;
+        getTransactions: () => TransactionMeta[];
+        isResubmitEnabled?: boolean;
+        nonceTracker: NonceTracker;
+        onStateChange: (listener: () => void) => void;
+        publishTransaction: (rawTx: string) => Promise<string>;
+        hooks?: {
+            beforeCheckPendingTransaction?: (transactionMeta: TransactionMeta) => boolean;
+            beforePublish?: (transactionMeta: TransactionMeta) => boolean;
+        };
+    });
+}
+export {};
+//# sourceMappingURL=PendingTransactionTracker.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/helpers/PendingTransactionTracker.d.ts.map b/node_modules/@metamask/transaction-controller/dist/helpers/PendingTransactionTracker.d.ts.map
new file mode 100644
index 0000000..aba0260
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/helpers/PendingTransactionTracker.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"PendingTransactionTracker.d.ts","sourceRoot":"","sources":["../../src/helpers/PendingTransactionTracker.ts"],"names":[],"mappings":";AACA,OAAO,KAAK,QAAQ,MAAM,qBAAqB,CAAC;AAChD,OAAO,KAAK,EAAE,YAAY,EAAE,MAAM,8BAA8B,CAAC;AAEjE,OAAO,YAAY,MAAM,QAAQ,CAAC;AAClC,OAAO,KAAK,EAAE,YAAY,EAAE,MAAM,eAAe,CAAC;AAGlD,OAAO,KAAK,EAAE,eAAe,EAAsB,MAAM,UAAU,CAAC;AA6BpE,aAAK,MAAM,GAAG;IACZ,uBAAuB,EAAE,CAAC,MAAM,EAAE,eAAe,CAAC,CAAC;IACnD,qBAAqB,EAAE,CAAC,MAAM,EAAE,eAAe,CAAC,CAAC;IACjD,oBAAoB,EAAE,CAAC,MAAM,EAAE,eAAe,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;IAC9D,qBAAqB,EAAE,CAAC,MAAM,EAAE,eAAe,EAAE,IAAI,EAAE,MAAM,CAAC,CAAC;CAChE,CAAC;AAKF,MAAM,WAAW,qCAAsC,SAAQ,YAAY;IACzE,EAAE,CAAC,CAAC,SAAS,MAAM,MAAM,EACvB,SAAS,EAAE,CAAC,EACZ,QAAQ,EAAE,CAAC,GAAG,IAAI,EAAE,MAAM,CAAC,CAAC,CAAC,KAAK,IAAI,GACrC,IAAI,CAAC;IAER,IAAI,CAAC,CAAC,SAAS,MAAM,MAAM,EAAE,SAAS,EAAE,CAAC,EAAE,GAAG,IAAI,EAAE,MAAM,CAAC,CAAC,CAAC,GAAG,OAAO,CAAC;CACzE;AAED,qBAAa,yBAAyB;;IACpC,GAAG,EAAE,qCAAqC,CAAC;gBAgC/B,EACV,kBAAkB,EAClB,YAAY,EACZ,UAAU,EACV,WAAW,EACX,eAAe,EACf,iBAAiB,EACjB,YAAY,EACZ,aAAa,EACb,kBAAkB,EAClB,KAAK,GACN,EAAE;QACD,kBAAkB,EAAE,CAAC,aAAa,EAAE,MAAM,KAAK,OAAO,CAAC,IAAI,CAAC,CAAC;QAC7D,YAAY,EAAE,YAAY,CAAC;QAC3B,UAAU,EAAE,MAAM,MAAM,CAAC;QACzB,WAAW,EAAE,MAAM,QAAQ,CAAC;QAC5B,eAAe,EAAE,MAAM,eAAe,EAAE,CAAC;QACzC,iBAAiB,CAAC,EAAE,OAAO,CAAC;QAC5B,YAAY,EAAE,YAAY,CAAC;QAC3B,aAAa,EAAE,CAAC,QAAQ,EAAE,MAAM,IAAI,KAAK,IAAI,CAAC;QAC9C,kBAAkB,EAAE,CAAC,KAAK,EAAE,MAAM,KAAK,OAAO,CAAC,MAAM,CAAC,CAAC;QACvD,KAAK,CAAC,EAAE;YACN,6BAA6B,CAAC,EAAE,CAC9B,eAAe,EAAE,eAAe,KAC7B,OAAO,CAAC;YACb,aAAa,CAAC,EAAE,CAAC,eAAe,EAAE,eAAe,KAAK,OAAO,CAAC;SAC/D,CAAC;KACH;CA4ZF"}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/helpers/PendingTransactionTracker.js b/node_modules/@metamask/transaction-controller/dist/helpers/PendingTransactionTracker.js
new file mode 100644
index 0000000..06963b7
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/helpers/PendingTransactionTracker.js
@@ -0,0 +1,341 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
+    if (kind === "m") throw new TypeError("Private method is not writable");
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
+    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
+};
+var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
+    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
+};
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+var _PendingTransactionTracker_instances, _PendingTransactionTracker_approveTransaction, _PendingTransactionTracker_blockTracker, _PendingTransactionTracker_droppedBlockCountByHash, _PendingTransactionTracker_getChainId, _PendingTransactionTracker_getEthQuery, _PendingTransactionTracker_getTransactions, _PendingTransactionTracker_isResubmitEnabled, _PendingTransactionTracker_listener, _PendingTransactionTracker_nonceTracker, _PendingTransactionTracker_onStateChange, _PendingTransactionTracker_publishTransaction, _PendingTransactionTracker_running, _PendingTransactionTracker_beforeCheckPendingTransaction, _PendingTransactionTracker_beforePublish, _PendingTransactionTracker_start, _PendingTransactionTracker_stop, _PendingTransactionTracker_onLatestBlock, _PendingTransactionTracker_checkTransactions, _PendingTransactionTracker_resubmitTransactions, _PendingTransactionTracker_isKnownTransactionError, _PendingTransactionTracker_resubmitTransaction, _PendingTransactionTracker_isResubmitDue, _PendingTransactionTracker_checkTransaction, _PendingTransactionTracker_onTransactionConfirmed, _PendingTransactionTracker_isTransactionDropped, _PendingTransactionTracker_isNonceTaken, _PendingTransactionTracker_getPendingTransactions, _PendingTransactionTracker_warnTransaction, _PendingTransactionTracker_failTransaction, _PendingTransactionTracker_dropTransaction, _PendingTransactionTracker_updateTransaction, _PendingTransactionTracker_getTransactionReceipt, _PendingTransactionTracker_getBlockByHash, _PendingTransactionTracker_getNetworkTransactionCount, _PendingTransactionTracker_getCurrentChainTransactions;
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.PendingTransactionTracker = void 0;
+const controller_utils_1 = require("@metamask/controller-utils");
+const utils_1 = require("@metamask/utils");
+const events_1 = __importDefault(require("events"));
+const logger_1 = require("../logger");
+const types_1 = require("../types");
+/**
+ * We wait this many blocks before emitting a 'transaction-dropped' event
+ * This is because we could be talking to a node that is out of sync
+ */
+const DROPPED_BLOCK_COUNT = 3;
+const RECEIPT_STATUS_SUCCESS = '0x1';
+const RECEIPT_STATUS_FAILURE = '0x0';
+const MAX_RETRY_BLOCK_DISTANCE = 50;
+const KNOWN_TRANSACTION_ERRORS = [
+    'replacement transaction underpriced',
+    'known transaction',
+    'gas price too low to replace',
+    'transaction with the same hash was already imported',
+    'gateway timeout',
+    'nonce too low',
+];
+const log = (0, utils_1.createModuleLogger)(logger_1.projectLogger, 'pending-transactions');
+class PendingTransactionTracker {
+    constructor({ approveTransaction, blockTracker, getChainId, getEthQuery, getTransactions, isResubmitEnabled, nonceTracker, onStateChange, publishTransaction, hooks, }) {
+        var _a, _b;
+        _PendingTransactionTracker_instances.add(this);
+        _PendingTransactionTracker_approveTransaction.set(this, void 0);
+        _PendingTransactionTracker_blockTracker.set(this, void 0);
+        _PendingTransactionTracker_droppedBlockCountByHash.set(this, void 0);
+        _PendingTransactionTracker_getChainId.set(this, void 0);
+        _PendingTransactionTracker_getEthQuery.set(this, void 0);
+        _PendingTransactionTracker_getTransactions.set(this, void 0);
+        _PendingTransactionTracker_isResubmitEnabled.set(this, void 0);
+        // TODO: Replace `any` with type
+        // eslint-disable-next-line @typescript-eslint/no-explicit-any
+        _PendingTransactionTracker_listener.set(this, void 0);
+        _PendingTransactionTracker_nonceTracker.set(this, void 0);
+        _PendingTransactionTracker_onStateChange.set(this, void 0);
+        _PendingTransactionTracker_publishTransaction.set(this, void 0);
+        _PendingTransactionTracker_running.set(this, void 0);
+        _PendingTransactionTracker_beforeCheckPendingTransaction.set(this, void 0);
+        _PendingTransactionTracker_beforePublish.set(this, void 0);
+        this.hub = new events_1.default();
+        __classPrivateFieldSet(this, _PendingTransactionTracker_approveTransaction, approveTransaction, "f");
+        __classPrivateFieldSet(this, _PendingTransactionTracker_blockTracker, blockTracker, "f");
+        __classPrivateFieldSet(this, _PendingTransactionTracker_droppedBlockCountByHash, new Map(), "f");
+        __classPrivateFieldSet(this, _PendingTransactionTracker_getChainId, getChainId, "f");
+        __classPrivateFieldSet(this, _PendingTransactionTracker_getEthQuery, getEthQuery, "f");
+        __classPrivateFieldSet(this, _PendingTransactionTracker_getTransactions, getTransactions, "f");
+        __classPrivateFieldSet(this, _PendingTransactionTracker_isResubmitEnabled, isResubmitEnabled !== null && isResubmitEnabled !== void 0 ? isResubmitEnabled : true, "f");
+        __classPrivateFieldSet(this, _PendingTransactionTracker_listener, __classPrivateFieldGet(this, _PendingTransactionTracker_instances, "m", _PendingTransactionTracker_onLatestBlock).bind(this), "f");
+        __classPrivateFieldSet(this, _PendingTransactionTracker_nonceTracker, nonceTracker, "f");
+        __classPrivateFieldSet(this, _PendingTransactionTracker_onStateChange, onStateChange, "f");
+        __classPrivateFieldSet(this, _PendingTransactionTracker_publishTransaction, publishTransaction, "f");
+        __classPrivateFieldSet(this, _PendingTransactionTracker_running, false, "f");
+        __classPrivateFieldSet(this, _PendingTransactionTracker_beforePublish, (_a = hooks === null || hooks === void 0 ? void 0 : hooks.beforePublish) !== null && _a !== void 0 ? _a : (() => true), "f");
+        __classPrivateFieldSet(this, _PendingTransactionTracker_beforeCheckPendingTransaction, (_b = hooks === null || hooks === void 0 ? void 0 : hooks.beforeCheckPendingTransaction) !== null && _b !== void 0 ? _b : (() => true), "f");
+        __classPrivateFieldGet(this, _PendingTransactionTracker_onStateChange, "f").call(this, () => {
+            const pendingTransactions = __classPrivateFieldGet(this, _PendingTransactionTracker_instances, "m", _PendingTransactionTracker_getPendingTransactions).call(this);
+            if (pendingTransactions.length) {
+                __classPrivateFieldGet(this, _PendingTransactionTracker_instances, "m", _PendingTransactionTracker_start).call(this);
+            }
+            else {
+                __classPrivateFieldGet(this, _PendingTransactionTracker_instances, "m", _PendingTransactionTracker_stop).call(this);
+            }
+        });
+    }
+}
+exports.PendingTransactionTracker = PendingTransactionTracker;
+_PendingTransactionTracker_approveTransaction = new WeakMap(), _PendingTransactionTracker_blockTracker = new WeakMap(), _PendingTransactionTracker_droppedBlockCountByHash = new WeakMap(), _PendingTransactionTracker_getChainId = new WeakMap(), _PendingTransactionTracker_getEthQuery = new WeakMap(), _PendingTransactionTracker_getTransactions = new WeakMap(), _PendingTransactionTracker_isResubmitEnabled = new WeakMap(), _PendingTransactionTracker_listener = new WeakMap(), _PendingTransactionTracker_nonceTracker = new WeakMap(), _PendingTransactionTracker_onStateChange = new WeakMap(), _PendingTransactionTracker_publishTransaction = new WeakMap(), _PendingTransactionTracker_running = new WeakMap(), _PendingTransactionTracker_beforeCheckPendingTransaction = new WeakMap(), _PendingTransactionTracker_beforePublish = new WeakMap(), _PendingTransactionTracker_instances = new WeakSet(), _PendingTransactionTracker_start = function _PendingTransactionTracker_start() {
+    if (__classPrivateFieldGet(this, _PendingTransactionTracker_running, "f")) {
+        return;
+    }
+    __classPrivateFieldGet(this, _PendingTransactionTracker_blockTracker, "f").on('latest', __classPrivateFieldGet(this, _PendingTransactionTracker_listener, "f"));
+    __classPrivateFieldSet(this, _PendingTransactionTracker_running, true, "f");
+    log('Started polling');
+}, _PendingTransactionTracker_stop = function _PendingTransactionTracker_stop() {
+    if (!__classPrivateFieldGet(this, _PendingTransactionTracker_running, "f")) {
+        return;
+    }
+    __classPrivateFieldGet(this, _PendingTransactionTracker_blockTracker, "f").removeListener('latest', __classPrivateFieldGet(this, _PendingTransactionTracker_listener, "f"));
+    __classPrivateFieldSet(this, _PendingTransactionTracker_running, false, "f");
+    log('Stopped polling');
+}, _PendingTransactionTracker_onLatestBlock = function _PendingTransactionTracker_onLatestBlock(latestBlockNumber) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const nonceGlobalLock = yield __classPrivateFieldGet(this, _PendingTransactionTracker_nonceTracker, "f").getGlobalLock();
+        try {
+            yield __classPrivateFieldGet(this, _PendingTransactionTracker_instances, "m", _PendingTransactionTracker_checkTransactions).call(this);
+        }
+        catch (error) {
+            /* istanbul ignore next */
+            log('Failed to check transactions', error);
+        }
+        finally {
+            nonceGlobalLock.releaseLock();
+        }
+        try {
+            yield __classPrivateFieldGet(this, _PendingTransactionTracker_instances, "m", _PendingTransactionTracker_resubmitTransactions).call(this, latestBlockNumber);
+        }
+        catch (error) {
+            /* istanbul ignore next */
+            log('Failed to resubmit transactions', error);
+        }
+    });
+}, _PendingTransactionTracker_checkTransactions = function _PendingTransactionTracker_checkTransactions() {
+    return __awaiter(this, void 0, void 0, function* () {
+        log('Checking transactions');
+        const pendingTransactions = __classPrivateFieldGet(this, _PendingTransactionTracker_instances, "m", _PendingTransactionTracker_getPendingTransactions).call(this);
+        if (!pendingTransactions.length) {
+            log('No pending transactions to check');
+            return;
+        }
+        log('Found pending transactions to check', {
+            count: pendingTransactions.length,
+            ids: pendingTransactions.map((tx) => tx.id),
+        });
+        yield Promise.all(pendingTransactions.map((tx) => __classPrivateFieldGet(this, _PendingTransactionTracker_instances, "m", _PendingTransactionTracker_checkTransaction).call(this, tx)));
+    });
+}, _PendingTransactionTracker_resubmitTransactions = function _PendingTransactionTracker_resubmitTransactions(latestBlockNumber) {
+    var _a, _b;
+    return __awaiter(this, void 0, void 0, function* () {
+        if (!__classPrivateFieldGet(this, _PendingTransactionTracker_isResubmitEnabled, "f") || !__classPrivateFieldGet(this, _PendingTransactionTracker_running, "f")) {
+            return;
+        }
+        log('Resubmitting transactions');
+        const pendingTransactions = __classPrivateFieldGet(this, _PendingTransactionTracker_instances, "m", _PendingTransactionTracker_getPendingTransactions).call(this);
+        if (!pendingTransactions.length) {
+            log('No pending transactions to resubmit');
+            return;
+        }
+        log('Found pending transactions to resubmit', {
+            count: pendingTransactions.length,
+            ids: pendingTransactions.map((tx) => tx.id),
+        });
+        for (const txMeta of pendingTransactions) {
+            try {
+                yield __classPrivateFieldGet(this, _PendingTransactionTracker_instances, "m", _PendingTransactionTracker_resubmitTransaction).call(this, txMeta, latestBlockNumber);
+                // TODO: Replace `any` with type
+                // eslint-disable-next-line @typescript-eslint/no-explicit-any
+            }
+            catch (error) {
+                /* istanbul ignore next */
+                const errorMessage = ((_b = (_a = error.value) === null || _a === void 0 ? void 0 : _a.message) === null || _b === void 0 ? void 0 : _b.toLowerCase()) || error.message.toLowerCase();
+                if (__classPrivateFieldGet(this, _PendingTransactionTracker_instances, "m", _PendingTransactionTracker_isKnownTransactionError).call(this, errorMessage)) {
+                    log('Ignoring known transaction error', errorMessage);
+                    return;
+                }
+                __classPrivateFieldGet(this, _PendingTransactionTracker_instances, "m", _PendingTransactionTracker_warnTransaction).call(this, txMeta, error.message, 'There was an error when resubmitting this transaction.');
+            }
+        }
+    });
+}, _PendingTransactionTracker_isKnownTransactionError = function _PendingTransactionTracker_isKnownTransactionError(errorMessage) {
+    return KNOWN_TRANSACTION_ERRORS.some((knownError) => errorMessage.includes(knownError));
+}, _PendingTransactionTracker_resubmitTransaction = function _PendingTransactionTracker_resubmitTransaction(txMeta, latestBlockNumber) {
+    var _a;
+    return __awaiter(this, void 0, void 0, function* () {
+        if (!__classPrivateFieldGet(this, _PendingTransactionTracker_instances, "m", _PendingTransactionTracker_isResubmitDue).call(this, txMeta, latestBlockNumber)) {
+            return;
+        }
+        log('Resubmitting transaction', txMeta.id);
+        const { rawTx } = txMeta;
+        if (!__classPrivateFieldGet(this, _PendingTransactionTracker_beforePublish, "f").call(this, txMeta)) {
+            return;
+        }
+        if (!(rawTx === null || rawTx === void 0 ? void 0 : rawTx.length)) {
+            log('Approving transaction as no raw value');
+            yield __classPrivateFieldGet(this, _PendingTransactionTracker_approveTransaction, "f").call(this, txMeta.id);
+            return;
+        }
+        yield __classPrivateFieldGet(this, _PendingTransactionTracker_publishTransaction, "f").call(this, rawTx);
+        txMeta.retryCount = ((_a = txMeta.retryCount) !== null && _a !== void 0 ? _a : 0) + 1;
+        __classPrivateFieldGet(this, _PendingTransactionTracker_instances, "m", _PendingTransactionTracker_updateTransaction).call(this, txMeta, 'PendingTransactionTracker:transaction-retry - Retry count increased');
+    });
+}, _PendingTransactionTracker_isResubmitDue = function _PendingTransactionTracker_isResubmitDue(txMeta, latestBlockNumber) {
+    if (!txMeta.firstRetryBlockNumber) {
+        txMeta.firstRetryBlockNumber = latestBlockNumber;
+        __classPrivateFieldGet(this, _PendingTransactionTracker_instances, "m", _PendingTransactionTracker_updateTransaction).call(this, txMeta, 'PendingTransactionTracker:#isResubmitDue - First retry block number set');
+    }
+    const firstRetryBlockNumber = txMeta.firstRetryBlockNumber || latestBlockNumber;
+    const blocksSinceFirstRetry = Number.parseInt(latestBlockNumber, 16) -
+        Number.parseInt(firstRetryBlockNumber, 16);
+    const retryCount = txMeta.retryCount || 0;
+    // Exponential backoff to limit retries at publishing
+    // Capped at ~15 minutes between retries
+    const requiredBlocksSinceFirstRetry = Math.min(MAX_RETRY_BLOCK_DISTANCE, Math.pow(2, retryCount));
+    return blocksSinceFirstRetry >= requiredBlocksSinceFirstRetry;
+}, _PendingTransactionTracker_checkTransaction = function _PendingTransactionTracker_checkTransaction(txMeta) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const { hash, id } = txMeta;
+        if (!hash && __classPrivateFieldGet(this, _PendingTransactionTracker_beforeCheckPendingTransaction, "f").call(this, txMeta)) {
+            const error = new Error('We had an error while submitting this transaction, please try again.');
+            error.name = 'NoTxHashError';
+            __classPrivateFieldGet(this, _PendingTransactionTracker_instances, "m", _PendingTransactionTracker_failTransaction).call(this, txMeta, error);
+            return;
+        }
+        if (__classPrivateFieldGet(this, _PendingTransactionTracker_instances, "m", _PendingTransactionTracker_isNonceTaken).call(this, txMeta)) {
+            log('Nonce already taken', id);
+            __classPrivateFieldGet(this, _PendingTransactionTracker_instances, "m", _PendingTransactionTracker_dropTransaction).call(this, txMeta);
+            return;
+        }
+        try {
+            const receipt = yield __classPrivateFieldGet(this, _PendingTransactionTracker_instances, "m", _PendingTransactionTracker_getTransactionReceipt).call(this, hash);
+            const isSuccess = (receipt === null || receipt === void 0 ? void 0 : receipt.status) === RECEIPT_STATUS_SUCCESS;
+            const isFailure = (receipt === null || receipt === void 0 ? void 0 : receipt.status) === RECEIPT_STATUS_FAILURE;
+            if (isFailure) {
+                log('Transaction receipt has failed status');
+                __classPrivateFieldGet(this, _PendingTransactionTracker_instances, "m", _PendingTransactionTracker_failTransaction).call(this, txMeta, new Error('Transaction dropped or replaced'));
+                return;
+            }
+            const { blockNumber, blockHash } = receipt || {};
+            if (isSuccess && blockNumber && blockHash) {
+                yield __classPrivateFieldGet(this, _PendingTransactionTracker_instances, "m", _PendingTransactionTracker_onTransactionConfirmed).call(this, txMeta, Object.assign(Object.assign({}, receipt), { blockNumber,
+                    blockHash }));
+                return;
+            }
+            // TODO: Replace `any` with type
+            // eslint-disable-next-line @typescript-eslint/no-explicit-any
+        }
+        catch (error) {
+            log('Failed to check transaction', id, error);
+            __classPrivateFieldGet(this, _PendingTransactionTracker_instances, "m", _PendingTransactionTracker_warnTransaction).call(this, txMeta, error.message, 'There was a problem loading this transaction.');
+            return;
+        }
+        if (yield __classPrivateFieldGet(this, _PendingTransactionTracker_instances, "m", _PendingTransactionTracker_isTransactionDropped).call(this, txMeta)) {
+            __classPrivateFieldGet(this, _PendingTransactionTracker_instances, "m", _PendingTransactionTracker_dropTransaction).call(this, txMeta);
+        }
+    });
+}, _PendingTransactionTracker_onTransactionConfirmed = function _PendingTransactionTracker_onTransactionConfirmed(txMeta, receipt) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const { id } = txMeta;
+        const { blockHash } = receipt;
+        log('Transaction confirmed', id);
+        const { baseFeePerGas, timestamp: blockTimestamp } = yield __classPrivateFieldGet(this, _PendingTransactionTracker_instances, "m", _PendingTransactionTracker_getBlockByHash).call(this, blockHash, false);
+        txMeta.baseFeePerGas = baseFeePerGas;
+        txMeta.blockTimestamp = blockTimestamp;
+        txMeta.status = types_1.TransactionStatus.confirmed;
+        txMeta.txParams.gasUsed = receipt.gasUsed;
+        txMeta.txReceipt = receipt;
+        txMeta.verifiedOnBlockchain = true;
+        __classPrivateFieldGet(this, _PendingTransactionTracker_instances, "m", _PendingTransactionTracker_updateTransaction).call(this, txMeta, 'PendingTransactionTracker:#onTransactionConfirmed - Transaction confirmed');
+        this.hub.emit('transaction-confirmed', txMeta);
+    });
+}, _PendingTransactionTracker_isTransactionDropped = function _PendingTransactionTracker_isTransactionDropped(txMeta) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const { hash, id, txParams: { nonce, from }, } = txMeta;
+        /* istanbul ignore next */
+        if (!nonce || !hash) {
+            return false;
+        }
+        const networkNextNonceHex = yield __classPrivateFieldGet(this, _PendingTransactionTracker_instances, "m", _PendingTransactionTracker_getNetworkTransactionCount).call(this, from);
+        const networkNextNonceNumber = parseInt(networkNextNonceHex, 16);
+        const nonceNumber = parseInt(nonce, 16);
+        if (nonceNumber >= networkNextNonceNumber) {
+            return false;
+        }
+        let droppedBlockCount = __classPrivateFieldGet(this, _PendingTransactionTracker_droppedBlockCountByHash, "f").get(hash);
+        if (droppedBlockCount === undefined) {
+            droppedBlockCount = 0;
+            __classPrivateFieldGet(this, _PendingTransactionTracker_droppedBlockCountByHash, "f").set(hash, droppedBlockCount);
+        }
+        if (droppedBlockCount < DROPPED_BLOCK_COUNT) {
+            log('Incrementing dropped block count', { id, droppedBlockCount });
+            __classPrivateFieldGet(this, _PendingTransactionTracker_droppedBlockCountByHash, "f").set(hash, droppedBlockCount + 1);
+            return false;
+        }
+        log('Hit dropped block count', id);
+        __classPrivateFieldGet(this, _PendingTransactionTracker_droppedBlockCountByHash, "f").delete(hash);
+        return true;
+    });
+}, _PendingTransactionTracker_isNonceTaken = function _PendingTransactionTracker_isNonceTaken(txMeta) {
+    const { id, txParams } = txMeta;
+    return __classPrivateFieldGet(this, _PendingTransactionTracker_instances, "m", _PendingTransactionTracker_getCurrentChainTransactions).call(this).some((tx) => tx.id !== id &&
+        tx.txParams.from === txParams.from &&
+        tx.status === types_1.TransactionStatus.confirmed &&
+        tx.txParams.nonce === txParams.nonce &&
+        tx.type !== types_1.TransactionType.incoming);
+}, _PendingTransactionTracker_getPendingTransactions = function _PendingTransactionTracker_getPendingTransactions() {
+    return __classPrivateFieldGet(this, _PendingTransactionTracker_instances, "m", _PendingTransactionTracker_getCurrentChainTransactions).call(this).filter((tx) => tx.status === types_1.TransactionStatus.submitted &&
+        !tx.verifiedOnBlockchain &&
+        !tx.isUserOperation);
+}, _PendingTransactionTracker_warnTransaction = function _PendingTransactionTracker_warnTransaction(txMeta, error, message) {
+    txMeta.warning = {
+        error,
+        message,
+    };
+    __classPrivateFieldGet(this, _PendingTransactionTracker_instances, "m", _PendingTransactionTracker_updateTransaction).call(this, txMeta, 'PendingTransactionTracker:#warnTransaction - Warning added');
+}, _PendingTransactionTracker_failTransaction = function _PendingTransactionTracker_failTransaction(txMeta, error) {
+    log('Transaction failed', txMeta.id, error);
+    this.hub.emit('transaction-failed', txMeta, error);
+}, _PendingTransactionTracker_dropTransaction = function _PendingTransactionTracker_dropTransaction(txMeta) {
+    log('Transaction dropped', txMeta.id);
+    this.hub.emit('transaction-dropped', txMeta);
+}, _PendingTransactionTracker_updateTransaction = function _PendingTransactionTracker_updateTransaction(txMeta, note) {
+    this.hub.emit('transaction-updated', txMeta, note);
+}, _PendingTransactionTracker_getTransactionReceipt = function _PendingTransactionTracker_getTransactionReceipt(txHash) {
+    return __awaiter(this, void 0, void 0, function* () {
+        return yield (0, controller_utils_1.query)(__classPrivateFieldGet(this, _PendingTransactionTracker_getEthQuery, "f").call(this), 'getTransactionReceipt', [txHash]);
+    });
+}, _PendingTransactionTracker_getBlockByHash = function _PendingTransactionTracker_getBlockByHash(blockHash, includeTransactionDetails) {
+    return __awaiter(this, void 0, void 0, function* () {
+        return yield (0, controller_utils_1.query)(__classPrivateFieldGet(this, _PendingTransactionTracker_getEthQuery, "f").call(this), 'getBlockByHash', [
+            blockHash,
+            includeTransactionDetails,
+        ]);
+    });
+}, _PendingTransactionTracker_getNetworkTransactionCount = function _PendingTransactionTracker_getNetworkTransactionCount(address) {
+    return __awaiter(this, void 0, void 0, function* () {
+        return yield (0, controller_utils_1.query)(__classPrivateFieldGet(this, _PendingTransactionTracker_getEthQuery, "f").call(this), 'getTransactionCount', [address]);
+    });
+}, _PendingTransactionTracker_getCurrentChainTransactions = function _PendingTransactionTracker_getCurrentChainTransactions() {
+    const currentChainId = __classPrivateFieldGet(this, _PendingTransactionTracker_getChainId, "f").call(this);
+    return __classPrivateFieldGet(this, _PendingTransactionTracker_getTransactions, "f").call(this).filter((tx) => tx.chainId === currentChainId);
+};
+//# sourceMappingURL=PendingTransactionTracker.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/helpers/PendingTransactionTracker.js.map b/node_modules/@metamask/transaction-controller/dist/helpers/PendingTransactionTracker.js.map
new file mode 100644
index 0000000..a28fb95
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/helpers/PendingTransactionTracker.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"PendingTransactionTracker.js","sourceRoot":"","sources":["../../src/helpers/PendingTransactionTracker.ts"],"names":[],"mappings":"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","sourcesContent":["import { query } from '@metamask/controller-utils';\nimport type EthQuery from '@metamask/eth-query';\nimport type { BlockTracker } from '@metamask/network-controller';\nimport { createModuleLogger } from '@metamask/utils';\nimport EventEmitter from 'events';\nimport type { NonceTracker } from 'nonce-tracker';\n\nimport { projectLogger } from '../logger';\nimport type { TransactionMeta, TransactionReceipt } from '../types';\nimport { TransactionStatus, TransactionType } from '../types';\n\n/**\n * We wait this many blocks before emitting a 'transaction-dropped' event\n * This is because we could be talking to a node that is out of sync\n */\nconst DROPPED_BLOCK_COUNT = 3;\n\nconst RECEIPT_STATUS_SUCCESS = '0x1';\nconst RECEIPT_STATUS_FAILURE = '0x0';\nconst MAX_RETRY_BLOCK_DISTANCE = 50;\n\nconst KNOWN_TRANSACTION_ERRORS = [\n  'replacement transaction underpriced',\n  'known transaction',\n  'gas price too low to replace',\n  'transaction with the same hash was already imported',\n  'gateway timeout',\n  'nonce too low',\n];\n\nconst log = createModuleLogger(projectLogger, 'pending-transactions');\n\ntype SuccessfulTransactionReceipt = TransactionReceipt & {\n  blockNumber: string;\n  blockHash: string;\n};\n\ntype Events = {\n  'transaction-confirmed': [txMeta: TransactionMeta];\n  'transaction-dropped': [txMeta: TransactionMeta];\n  'transaction-failed': [txMeta: TransactionMeta, error: Error];\n  'transaction-updated': [txMeta: TransactionMeta, note: string];\n};\n\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface PendingTransactionTrackerEventEmitter extends EventEmitter {\n  on<T extends keyof Events>(\n    eventName: T,\n    listener: (...args: Events[T]) => void,\n  ): this;\n\n  emit<T extends keyof Events>(eventName: T, ...args: Events[T]): boolean;\n}\n\nexport class PendingTransactionTracker {\n  hub: PendingTransactionTrackerEventEmitter;\n\n  #approveTransaction: (transactionId: string) => Promise<void>;\n\n  #blockTracker: BlockTracker;\n\n  #droppedBlockCountByHash: Map<string, number>;\n\n  #getChainId: () => string;\n\n  #getEthQuery: () => EthQuery;\n\n  #getTransactions: () => TransactionMeta[];\n\n  #isResubmitEnabled: boolean;\n\n  // TODO: Replace `any` with type\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  #listener: any;\n\n  #nonceTracker: NonceTracker;\n\n  #onStateChange: (listener: () => void) => void;\n\n  #publishTransaction: (rawTx: string) => Promise<string>;\n\n  #running: boolean;\n\n  #beforeCheckPendingTransaction: (transactionMeta: TransactionMeta) => boolean;\n\n  #beforePublish: (transactionMeta: TransactionMeta) => boolean;\n\n  constructor({\n    approveTransaction,\n    blockTracker,\n    getChainId,\n    getEthQuery,\n    getTransactions,\n    isResubmitEnabled,\n    nonceTracker,\n    onStateChange,\n    publishTransaction,\n    hooks,\n  }: {\n    approveTransaction: (transactionId: string) => Promise<void>;\n    blockTracker: BlockTracker;\n    getChainId: () => string;\n    getEthQuery: () => EthQuery;\n    getTransactions: () => TransactionMeta[];\n    isResubmitEnabled?: boolean;\n    nonceTracker: NonceTracker;\n    onStateChange: (listener: () => void) => void;\n    publishTransaction: (rawTx: string) => Promise<string>;\n    hooks?: {\n      beforeCheckPendingTransaction?: (\n        transactionMeta: TransactionMeta,\n      ) => boolean;\n      beforePublish?: (transactionMeta: TransactionMeta) => boolean;\n    };\n  }) {\n    this.hub = new EventEmitter() as PendingTransactionTrackerEventEmitter;\n\n    this.#approveTransaction = approveTransaction;\n    this.#blockTracker = blockTracker;\n    this.#droppedBlockCountByHash = new Map();\n    this.#getChainId = getChainId;\n    this.#getEthQuery = getEthQuery;\n    this.#getTransactions = getTransactions;\n    this.#isResubmitEnabled = isResubmitEnabled ?? true;\n    this.#listener = this.#onLatestBlock.bind(this);\n    this.#nonceTracker = nonceTracker;\n    this.#onStateChange = onStateChange;\n    this.#publishTransaction = publishTransaction;\n    this.#running = false;\n    this.#beforePublish = hooks?.beforePublish ?? (() => true);\n    this.#beforeCheckPendingTransaction =\n      hooks?.beforeCheckPendingTransaction ?? (() => true);\n\n    this.#onStateChange(() => {\n      const pendingTransactions = this.#getPendingTransactions();\n\n      if (pendingTransactions.length) {\n        this.#start();\n      } else {\n        this.#stop();\n      }\n    });\n  }\n\n  #start() {\n    if (this.#running) {\n      return;\n    }\n\n    this.#blockTracker.on('latest', this.#listener);\n    this.#running = true;\n\n    log('Started polling');\n  }\n\n  #stop() {\n    if (!this.#running) {\n      return;\n    }\n\n    this.#blockTracker.removeListener('latest', this.#listener);\n    this.#running = false;\n\n    log('Stopped polling');\n  }\n\n  async #onLatestBlock(latestBlockNumber: string) {\n    const nonceGlobalLock = await this.#nonceTracker.getGlobalLock();\n\n    try {\n      await this.#checkTransactions();\n    } catch (error) {\n      /* istanbul ignore next */\n      log('Failed to check transactions', error);\n    } finally {\n      nonceGlobalLock.releaseLock();\n    }\n\n    try {\n      await this.#resubmitTransactions(latestBlockNumber);\n    } catch (error) {\n      /* istanbul ignore next */\n      log('Failed to resubmit transactions', error);\n    }\n  }\n\n  async #checkTransactions() {\n    log('Checking transactions');\n\n    const pendingTransactions = this.#getPendingTransactions();\n\n    if (!pendingTransactions.length) {\n      log('No pending transactions to check');\n      return;\n    }\n\n    log('Found pending transactions to check', {\n      count: pendingTransactions.length,\n      ids: pendingTransactions.map((tx) => tx.id),\n    });\n\n    await Promise.all(\n      pendingTransactions.map((tx) => this.#checkTransaction(tx)),\n    );\n  }\n\n  async #resubmitTransactions(latestBlockNumber: string) {\n    if (!this.#isResubmitEnabled || !this.#running) {\n      return;\n    }\n\n    log('Resubmitting transactions');\n\n    const pendingTransactions = this.#getPendingTransactions();\n\n    if (!pendingTransactions.length) {\n      log('No pending transactions to resubmit');\n      return;\n    }\n\n    log('Found pending transactions to resubmit', {\n      count: pendingTransactions.length,\n      ids: pendingTransactions.map((tx) => tx.id),\n    });\n\n    for (const txMeta of pendingTransactions) {\n      try {\n        await this.#resubmitTransaction(txMeta, latestBlockNumber);\n        // TODO: Replace `any` with type\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      } catch (error: any) {\n        /* istanbul ignore next */\n        const errorMessage =\n          error.value?.message?.toLowerCase() || error.message.toLowerCase();\n\n        if (this.#isKnownTransactionError(errorMessage)) {\n          log('Ignoring known transaction error', errorMessage);\n          return;\n        }\n\n        this.#warnTransaction(\n          txMeta,\n          error.message,\n          'There was an error when resubmitting this transaction.',\n        );\n      }\n    }\n  }\n\n  #isKnownTransactionError(errorMessage: string) {\n    return KNOWN_TRANSACTION_ERRORS.some((knownError) =>\n      errorMessage.includes(knownError),\n    );\n  }\n\n  async #resubmitTransaction(\n    txMeta: TransactionMeta,\n    latestBlockNumber: string,\n  ) {\n    if (!this.#isResubmitDue(txMeta, latestBlockNumber)) {\n      return;\n    }\n\n    log('Resubmitting transaction', txMeta.id);\n\n    const { rawTx } = txMeta;\n\n    if (!this.#beforePublish(txMeta)) {\n      return;\n    }\n\n    if (!rawTx?.length) {\n      log('Approving transaction as no raw value');\n      await this.#approveTransaction(txMeta.id);\n      return;\n    }\n\n    await this.#publishTransaction(rawTx);\n\n    txMeta.retryCount = (txMeta.retryCount ?? 0) + 1;\n\n    this.#updateTransaction(\n      txMeta,\n      'PendingTransactionTracker:transaction-retry - Retry count increased',\n    );\n  }\n\n  #isResubmitDue(txMeta: TransactionMeta, latestBlockNumber: string): boolean {\n    if (!txMeta.firstRetryBlockNumber) {\n      txMeta.firstRetryBlockNumber = latestBlockNumber;\n\n      this.#updateTransaction(\n        txMeta,\n        'PendingTransactionTracker:#isResubmitDue - First retry block number set',\n      );\n    }\n\n    const firstRetryBlockNumber =\n      txMeta.firstRetryBlockNumber || latestBlockNumber;\n\n    const blocksSinceFirstRetry =\n      Number.parseInt(latestBlockNumber, 16) -\n      Number.parseInt(firstRetryBlockNumber, 16);\n\n    const retryCount = txMeta.retryCount || 0;\n\n    // Exponential backoff to limit retries at publishing\n    // Capped at ~15 minutes between retries\n    const requiredBlocksSinceFirstRetry = Math.min(\n      MAX_RETRY_BLOCK_DISTANCE,\n      Math.pow(2, retryCount),\n    );\n\n    return blocksSinceFirstRetry >= requiredBlocksSinceFirstRetry;\n  }\n\n  async #checkTransaction(txMeta: TransactionMeta) {\n    const { hash, id } = txMeta;\n\n    if (!hash && this.#beforeCheckPendingTransaction(txMeta)) {\n      const error = new Error(\n        'We had an error while submitting this transaction, please try again.',\n      );\n\n      error.name = 'NoTxHashError';\n\n      this.#failTransaction(txMeta, error);\n\n      return;\n    }\n\n    if (this.#isNonceTaken(txMeta)) {\n      log('Nonce already taken', id);\n      this.#dropTransaction(txMeta);\n      return;\n    }\n\n    try {\n      const receipt = await this.#getTransactionReceipt(hash);\n      const isSuccess = receipt?.status === RECEIPT_STATUS_SUCCESS;\n      const isFailure = receipt?.status === RECEIPT_STATUS_FAILURE;\n\n      if (isFailure) {\n        log('Transaction receipt has failed status');\n\n        this.#failTransaction(\n          txMeta,\n          new Error('Transaction dropped or replaced'),\n        );\n\n        return;\n      }\n\n      const { blockNumber, blockHash } = receipt || {};\n\n      if (isSuccess && blockNumber && blockHash) {\n        await this.#onTransactionConfirmed(txMeta, {\n          ...receipt,\n          blockNumber,\n          blockHash,\n        });\n\n        return;\n      }\n      // TODO: Replace `any` with type\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (error: any) {\n      log('Failed to check transaction', id, error);\n\n      this.#warnTransaction(\n        txMeta,\n        error.message,\n        'There was a problem loading this transaction.',\n      );\n\n      return;\n    }\n\n    if (await this.#isTransactionDropped(txMeta)) {\n      this.#dropTransaction(txMeta);\n    }\n  }\n\n  async #onTransactionConfirmed(\n    txMeta: TransactionMeta,\n    receipt: SuccessfulTransactionReceipt,\n  ) {\n    const { id } = txMeta;\n    const { blockHash } = receipt;\n\n    log('Transaction confirmed', id);\n\n    const { baseFeePerGas, timestamp: blockTimestamp } =\n      await this.#getBlockByHash(blockHash, false);\n\n    txMeta.baseFeePerGas = baseFeePerGas;\n    txMeta.blockTimestamp = blockTimestamp;\n    txMeta.status = TransactionStatus.confirmed;\n    txMeta.txParams.gasUsed = receipt.gasUsed;\n    txMeta.txReceipt = receipt;\n    txMeta.verifiedOnBlockchain = true;\n\n    this.#updateTransaction(\n      txMeta,\n      'PendingTransactionTracker:#onTransactionConfirmed - Transaction confirmed',\n    );\n\n    this.hub.emit('transaction-confirmed', txMeta);\n  }\n\n  async #isTransactionDropped(txMeta: TransactionMeta) {\n    const {\n      hash,\n      id,\n      txParams: { nonce, from },\n    } = txMeta;\n\n    /* istanbul ignore next */\n    if (!nonce || !hash) {\n      return false;\n    }\n\n    const networkNextNonceHex = await this.#getNetworkTransactionCount(from);\n    const networkNextNonceNumber = parseInt(networkNextNonceHex, 16);\n    const nonceNumber = parseInt(nonce, 16);\n\n    if (nonceNumber >= networkNextNonceNumber) {\n      return false;\n    }\n\n    let droppedBlockCount = this.#droppedBlockCountByHash.get(hash);\n\n    if (droppedBlockCount === undefined) {\n      droppedBlockCount = 0;\n      this.#droppedBlockCountByHash.set(hash, droppedBlockCount);\n    }\n\n    if (droppedBlockCount < DROPPED_BLOCK_COUNT) {\n      log('Incrementing dropped block count', { id, droppedBlockCount });\n      this.#droppedBlockCountByHash.set(hash, droppedBlockCount + 1);\n      return false;\n    }\n\n    log('Hit dropped block count', id);\n\n    this.#droppedBlockCountByHash.delete(hash);\n    return true;\n  }\n\n  #isNonceTaken(txMeta: TransactionMeta): boolean {\n    const { id, txParams } = txMeta;\n\n    return this.#getCurrentChainTransactions().some(\n      (tx) =>\n        tx.id !== id &&\n        tx.txParams.from === txParams.from &&\n        tx.status === TransactionStatus.confirmed &&\n        tx.txParams.nonce === txParams.nonce &&\n        tx.type !== TransactionType.incoming,\n    );\n  }\n\n  #getPendingTransactions(): TransactionMeta[] {\n    return this.#getCurrentChainTransactions().filter(\n      (tx) =>\n        tx.status === TransactionStatus.submitted &&\n        !tx.verifiedOnBlockchain &&\n        !tx.isUserOperation,\n    );\n  }\n\n  #warnTransaction(txMeta: TransactionMeta, error: string, message: string) {\n    txMeta.warning = {\n      error,\n      message,\n    };\n\n    this.#updateTransaction(\n      txMeta,\n      'PendingTransactionTracker:#warnTransaction - Warning added',\n    );\n  }\n\n  #failTransaction(txMeta: TransactionMeta, error: Error) {\n    log('Transaction failed', txMeta.id, error);\n    this.hub.emit('transaction-failed', txMeta, error);\n  }\n\n  #dropTransaction(txMeta: TransactionMeta) {\n    log('Transaction dropped', txMeta.id);\n    this.hub.emit('transaction-dropped', txMeta);\n  }\n\n  #updateTransaction(txMeta: TransactionMeta, note: string) {\n    this.hub.emit('transaction-updated', txMeta, note);\n  }\n\n  async #getTransactionReceipt(\n    txHash?: string,\n  ): Promise<TransactionReceipt | undefined> {\n    return await query(this.#getEthQuery(), 'getTransactionReceipt', [txHash]);\n  }\n\n  async #getBlockByHash(\n    blockHash: string,\n    includeTransactionDetails: boolean,\n    // TODO: Replace `any` with type\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): Promise<any> {\n    return await query(this.#getEthQuery(), 'getBlockByHash', [\n      blockHash,\n      includeTransactionDetails,\n    ]);\n  }\n\n  async #getNetworkTransactionCount(address: string): Promise<string> {\n    return await query(this.#getEthQuery(), 'getTransactionCount', [address]);\n  }\n\n  #getCurrentChainTransactions(): TransactionMeta[] {\n    const currentChainId = this.#getChainId();\n\n    return this.#getTransactions().filter(\n      (tx) => tx.chainId === currentChainId,\n    );\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/index.d.ts b/node_modules/@metamask/transaction-controller/dist/index.d.ts
index fc7f49b..b7c9355 100644
--- a/node_modules/@metamask/transaction-controller/dist/index.d.ts
+++ b/node_modules/@metamask/transaction-controller/dist/index.d.ts
@@ -1,3 +1,5 @@
 export * from './TransactionController';
-export { isEIP1559Transaction } from './utils';
+export { isEIP1559Transaction, normalizeTransactionParams } from './utils';
+export * from './types';
+export { mergeGasFeeEstimates, getGasFeeFlow } from './utils/gas-flow';
 //# sourceMappingURL=index.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/index.d.ts.map b/node_modules/@metamask/transaction-controller/dist/index.d.ts.map
deleted file mode 100644
index 2175387..0000000
--- a/node_modules/@metamask/transaction-controller/dist/index.d.ts.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"AAAA,cAAc,yBAAyB,CAAC;AACxC,OAAO,EAAE,oBAAoB,EAAE,MAAM,SAAS,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/index.js b/node_modules/@metamask/transaction-controller/dist/index.js
index a1c07c8..0818eb8 100644
--- a/node_modules/@metamask/transaction-controller/dist/index.js
+++ b/node_modules/@metamask/transaction-controller/dist/index.js
@@ -14,8 +14,13 @@ var __exportStar = (this && this.__exportStar) || function(m, exports) {
     for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
 };
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.isEIP1559Transaction = void 0;
+exports.getGasFeeFlow = exports.mergeGasFeeEstimates = exports.normalizeTransactionParams = exports.isEIP1559Transaction = void 0;
 __exportStar(require("./TransactionController"), exports);
 var utils_1 = require("./utils");
 Object.defineProperty(exports, "isEIP1559Transaction", { enumerable: true, get: function () { return utils_1.isEIP1559Transaction; } });
+Object.defineProperty(exports, "normalizeTransactionParams", { enumerable: true, get: function () { return utils_1.normalizeTransactionParams; } });
+__exportStar(require("./types"), exports);
+var gas_flow_1 = require("./utils/gas-flow");
+Object.defineProperty(exports, "mergeGasFeeEstimates", { enumerable: true, get: function () { return gas_flow_1.mergeGasFeeEstimates; } });
+Object.defineProperty(exports, "getGasFeeFlow", { enumerable: true, get: function () { return gas_flow_1.getGasFeeFlow; } });
 //# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/index.js.map b/node_modules/@metamask/transaction-controller/dist/index.js.map
deleted file mode 100644
index a4460fa..0000000
--- a/node_modules/@metamask/transaction-controller/dist/index.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAAA,0DAAwC;AACxC,iCAA+C;AAAtC,6GAAA,oBAAoB,OAAA","sourcesContent":["export * from './TransactionController';\nexport { isEIP1559Transaction } from './utils';\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/logger.d.ts b/node_modules/@metamask/transaction-controller/dist/logger.d.ts
new file mode 100644
index 0000000..43ad63f
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/logger.d.ts
@@ -0,0 +1,6 @@
+/// <reference types="debug" />
+import { createModuleLogger } from '@metamask/utils';
+export declare const projectLogger: import("debug").Debugger;
+export declare const incomingTransactionsLogger: import("debug").Debugger;
+export { createModuleLogger };
+//# sourceMappingURL=logger.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/logger.js b/node_modules/@metamask/transaction-controller/dist/logger.js
new file mode 100644
index 0000000..bb55b17
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/logger.js
@@ -0,0 +1,9 @@
+"use strict";
+/* istanbul ignore file */
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.createModuleLogger = exports.incomingTransactionsLogger = exports.projectLogger = void 0;
+const utils_1 = require("@metamask/utils");
+Object.defineProperty(exports, "createModuleLogger", { enumerable: true, get: function () { return utils_1.createModuleLogger; } });
+exports.projectLogger = (0, utils_1.createProjectLogger)('transaction-controller');
+exports.incomingTransactionsLogger = (0, utils_1.createModuleLogger)(exports.projectLogger, 'incoming-transactions');
+//# sourceMappingURL=logger.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/mocks/txsMock.d.ts b/node_modules/@metamask/transaction-controller/dist/mocks/txsMock.d.ts
deleted file mode 100644
index 688af82..0000000
--- a/node_modules/@metamask/transaction-controller/dist/mocks/txsMock.d.ts
+++ /dev/null
@@ -1,64 +0,0 @@
-import { TransactionMeta } from '../TransactionController';
-export declare const ethTxsMock: (ethTxHash: string) => ({
-    blockNumber: string;
-    confirmations: string;
-    contractAddress: string;
-    cumulativeGasUsed: string;
-    from: string;
-    gas: string;
-    gasPrice: string;
-    gasUsed: string;
-    hash: string;
-    input: string;
-    isError: string;
-    nonce: string;
-    timeStamp: string;
-    to: string;
-    transactionIndex: string;
-    txreceipt_status: string;
-    value: string;
-} | {
-    blockNumber: string;
-    confirmations: string;
-    contractAddress: string;
-    cumulativeGasUsed: string;
-    from: string;
-    gas: string;
-    gasPrice: string;
-    gasUsed: string;
-    hash: string;
-    input: string;
-    isError: string;
-    nonce: string;
-    timeStamp: string;
-    transactionIndex: string;
-    txreceipt_status: string;
-    value: string;
-    to?: undefined;
-})[];
-export declare const tokenTxsMock: (tokenTxHash: string) => {
-    blockNumber: string;
-    timeStamp: string;
-    hash: string;
-    nonce: string;
-    blockHash: string;
-    from: string;
-    contractAddress: string;
-    to: string;
-    value: string;
-    tokenName: string;
-    tokenSymbol: string;
-    tokenDecimal: string;
-    transactionIndex: string;
-    gas: string;
-    gasPrice: string;
-    gasUsed: string;
-    cumulativeGasUsed: string;
-    input: string;
-    confirmations: string;
-}[];
-export declare const txsInStateMock: (ethTxHash: string, tokenTxHash: string) => TransactionMeta[];
-export declare const txsInStateWithOutdatedStatusMock: (ethTxHash: string, tokenTxHash: string) => TransactionMeta[];
-export declare const txsInStateWithOutdatedGasDataMock: (ethTxHash: string, tokenTxHash: string) => TransactionMeta[];
-export declare const txsInStateWithOutdatedStatusAndGasDataMock: (ethTxHash: string, tokenTxHash: string) => TransactionMeta[];
-//# sourceMappingURL=txsMock.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/mocks/txsMock.d.ts.map b/node_modules/@metamask/transaction-controller/dist/mocks/txsMock.d.ts.map
deleted file mode 100644
index c9350fa..0000000
--- a/node_modules/@metamask/transaction-controller/dist/mocks/txsMock.d.ts.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"txsMock.d.ts","sourceRoot":"","sources":["../../src/mocks/txsMock.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,eAAe,EAAqB,MAAM,0BAA0B,CAAC;AAE9E,eAAO,MAAM,UAAU,cAAe,MAAM;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IA4E3C,CAAC;AAEF,eAAO,MAAM,YAAY,gBAAiB,MAAM;;;;;;;;;;;;;;;;;;;;GA+R/C,CAAC;AAEF,eAAO,MAAM,cAAc,cACd,MAAM,eACJ,MAAM,KAClB,eAAe,EAqCjB,CAAC;AAEF,eAAO,MAAM,gCAAgC,cAChC,MAAM,eACJ,MAAM,KAClB,eAAe,EAqCjB,CAAC;AAEF,eAAO,MAAM,iCAAiC,cACjC,MAAM,eACJ,MAAM,KAClB,eAAe,EAqCjB,CAAC;AAEF,eAAO,MAAM,0CAA0C,cAC1C,MAAM,eACJ,MAAM,KAClB,eAAe,EAqCjB,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/mocks/txsMock.js b/node_modules/@metamask/transaction-controller/dist/mocks/txsMock.js
deleted file mode 100644
index d17aabf..0000000
--- a/node_modules/@metamask/transaction-controller/dist/mocks/txsMock.js
+++ /dev/null
@@ -1,516 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.txsInStateWithOutdatedStatusAndGasDataMock = exports.txsInStateWithOutdatedGasDataMock = exports.txsInStateWithOutdatedStatusMock = exports.txsInStateMock = exports.tokenTxsMock = exports.ethTxsMock = void 0;
-const controller_utils_1 = require("@metamask/controller-utils");
-const TransactionController_1 = require("../TransactionController");
-const ethTxsMock = (ethTxHash) => [
-    {
-        blockNumber: '4535101',
-        confirmations: '10',
-        contractAddress: '',
-        cumulativeGasUsed: '120607',
-        from: '0xe46abaf75cfbff815c0b7ffed6f02b0760ea27f1',
-        gas: '335208',
-        gasPrice: '10000000000',
-        gasUsed: '21000',
-        hash: ethTxHash,
-        input: '0x',
-        isError: '0',
-        nonce: '9',
-        timeStamp: '1543596286',
-        to: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',
-        transactionIndex: '2',
-        txreceipt_status: '1',
-        value: '100000000000000000',
-    },
-    {
-        blockNumber: '4535108',
-        confirmations: '3',
-        contractAddress: '',
-        cumulativeGasUsed: '693910',
-        from: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',
-        gas: '335208',
-        gasPrice: '20000000000',
-        gasUsed: '21000',
-        hash: '0x342e9d73e10004af41d04973339fc7219dbadcbb5629730cfe65e9f9cb15ff92',
-        input: '0x',
-        isError: '0',
-        nonce: '0',
-        timeStamp: '1543596378',
-        to: '0xb2d191b6fe03c5b8a1ab249cfe88c37553357a23',
-        transactionIndex: '12',
-        txreceipt_status: '1',
-        value: '50000000000000000',
-    },
-    {
-        blockNumber: '4535105',
-        confirmations: '4',
-        contractAddress: '',
-        cumulativeGasUsed: '693910',
-        from: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',
-        gas: '335208',
-        gasPrice: '20000000000',
-        gasUsed: '21000',
-        hash: '0x342e9d73e10004af41d04973339fc7219dbadcbb5629730cfe65e9f9cb15ff91',
-        input: '0x',
-        isError: '0',
-        nonce: '1',
-        timeStamp: '1543596356',
-        transactionIndex: '13',
-        txreceipt_status: '1',
-        value: '50000000000000000',
-    },
-    {
-        blockNumber: '4535106',
-        confirmations: '4',
-        contractAddress: '',
-        cumulativeGasUsed: '693910',
-        from: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',
-        gas: '335208',
-        gasPrice: '20000000000',
-        gasUsed: '21000',
-        hash: '0x342e9d73e10004af41d04973139fc7219dbadcbb5629730cfe65e9f9cb15ff91',
-        input: '0x11',
-        isError: '0',
-        nonce: '3',
-        timeStamp: '1543596356',
-        to: '0xb2d191b6fe03c5b8a1ab249cfe88c37553357a23',
-        transactionIndex: '13',
-        txreceipt_status: '1',
-        value: '50000000000000000',
-    },
-];
-exports.ethTxsMock = ethTxsMock;
-const tokenTxsMock = (tokenTxHash) => [
-    {
-        blockNumber: '8222239',
-        timeStamp: '1564091067',
-        hash: tokenTxHash,
-        nonce: '2329',
-        blockHash: '0x3c30a9be9aea7be13caad419444140c11839d72e70479ec7e9c6d8bd08c533bc',
-        from: '0xdfa6edae2ec0cf1d4a60542422724a48195a5071',
-        contractAddress: '0x89d24a6b4ccb1b6faa2625fe562bdd9a23260359',
-        to: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',
-        value: '0',
-        tokenName: 'Sai Stablecoin v1.0',
-        tokenSymbol: 'SAI',
-        tokenDecimal: '18',
-        transactionIndex: '69',
-        gas: '624874',
-        gasPrice: '20000000000',
-        gasUsed: '21000',
-        cumulativeGasUsed: '3203881',
-        input: 'deprecated',
-        confirmations: '3659676',
-    },
-    {
-        blockNumber: '8222250',
-        timeStamp: '1564091247',
-        hash: '0xdcd1c8bee545d3f76d80b20a23ad44276ba2e376681228eb4570cf3518491279',
-        nonce: '2330',
-        blockHash: '0x16986dd66bedb20a5b846ec2b6c0ecaa62f1c4b51fac58c1326101fd9126dd82',
-        from: '0xdfa6edae2ec0cf1d4a60542422724a48195a5071',
-        contractAddress: '0x89d24a6b4ccb1b6faa2625fe562bdd9a23260359',
-        to: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',
-        value: '0',
-        tokenName: 'Sai Stablecoin v1.0',
-        tokenSymbol: 'SAI',
-        tokenDecimal: '18',
-        transactionIndex: '40',
-        gas: '594268',
-        gasPrice: '20000000000',
-        gasUsed: '579268',
-        cumulativeGasUsed: '2009011',
-        input: 'deprecated',
-        confirmations: '3659665',
-    },
-    {
-        blockNumber: '8223771',
-        timeStamp: '1564111652',
-        hash: '0x070369e6f560b0deca52e050ff1a961fa7b688bbec5cea08435921c9d9b0f52e',
-        nonce: '2333',
-        blockHash: '0x0aff8b36881be99df6d176d7c64c2171672c0483684a10c112d2c90fefe30a0a',
-        from: '0xdfa6edae2ec0cf1d4a60542422724a48195a5071',
-        contractAddress: '0x89d24a6b4ccb1b6faa2625fe562bdd9a23260359',
-        to: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',
-        value: '0',
-        tokenName: 'Sai Stablecoin v1.0',
-        tokenSymbol: 'SAI',
-        tokenDecimal: '18',
-        transactionIndex: '132',
-        gas: '583810',
-        gasPrice: '6000000000',
-        gasUsed: '568810',
-        cumulativeGasUsed: '6956245',
-        input: 'deprecated',
-        confirmations: '3658144',
-    },
-    {
-        blockNumber: '8224850',
-        timeStamp: '1564126442',
-        hash: '0x8ef20ec9597c8c2e945bcc76d2668e5d3bb088b081fe8c5b5af2e1cbd315a20f',
-        nonce: '31',
-        blockHash: '0xb80d4d861ecb7a3cb14e591c0aaeb226842d0267772affa2acc1a590c7535647',
-        from: '0x6c70e3563cef0c6835703bb2664c9f59a92353e4',
-        contractAddress: '0x89d24a6b4ccb1b6faa2625fe562bdd9a23260359',
-        to: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',
-        value: '10000000000000000000',
-        tokenName: 'Sai Stablecoin v1.0',
-        tokenSymbol: 'SAI',
-        tokenDecimal: '18',
-        transactionIndex: '169',
-        gas: '78447',
-        gasPrice: '2000000000',
-        gasUsed: '52298',
-        cumulativeGasUsed: '7047823',
-        input: 'deprecated',
-        confirmations: '3657065',
-    },
-    {
-        blockNumber: '8228053',
-        timeStamp: '1564168901',
-        hash: '0xa0f2d7b558bb3cc28fa568f6feb8ed30eb28a01a674d7c0d4ae603fc691e6020',
-        nonce: '2368',
-        blockHash: '0x62c515ea049842c968ca67499f47a32a11394364d319d9c9cc0a0211652a7294',
-        from: '0xdfa6edae2ec0cf1d4a60542422724a48195a5071',
-        contractAddress: '0x89d24a6b4ccb1b6faa2625fe562bdd9a23260359',
-        to: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',
-        value: '0',
-        tokenName: 'Sai Stablecoin v1.0',
-        tokenSymbol: 'SAI',
-        tokenDecimal: '18',
-        transactionIndex: '43',
-        gas: '567156',
-        gasPrice: '3000000000',
-        gasUsed: '552156',
-        cumulativeGasUsed: '3048261',
-        input: 'deprecated',
-        confirmations: '3653862',
-    },
-    {
-        blockNumber: '8315335',
-        timeStamp: '1565339223',
-        hash: '0x464df60fe00b6dd04c9e8ab341d02af9b10a619d2fcd60fd2971f10edf12118f',
-        nonce: '206760',
-        blockHash: '0x98275388ef6708debe35ac7bf2e30143c9b1fd9e0e457ca03598fc1f4209e273',
-        from: '0x00cfbbaf7ddb3a1476767101c12a0162e241fbad',
-        contractAddress: '0x4dc3643dbc642b72c158e7f3d2ff232df61cb6ce',
-        to: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',
-        value: '100000000000000000',
-        tokenName: 'Amber',
-        tokenSymbol: 'AMB',
-        tokenDecimal: '18',
-        transactionIndex: '186',
-        gas: '60000',
-        gasPrice: '2000000000',
-        gasUsed: '52108',
-        cumulativeGasUsed: '7490707',
-        input: 'deprecated',
-        confirmations: '3566580',
-    },
-    {
-        blockNumber: '8350846',
-        timeStamp: '1565815049',
-        hash: '0xc0682327ad3efd56dfa33e8206b4e09efad4e419a6191076069d217e3ee2341f',
-        nonce: '2506',
-        blockHash: '0xd0aa3c0e319fdfeb21b0192cf77b9760b8668060a5977a5f10f8413531083afa',
-        from: '0xdfa6edae2ec0cf1d4a60542422724a48195a5071',
-        contractAddress: '0x89d24a6b4ccb1b6faa2625fe562bdd9a23260359',
-        to: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',
-        value: '4',
-        tokenName: 'Sai Stablecoin v1.0',
-        tokenSymbol: 'SAI',
-        tokenDecimal: '18',
-        transactionIndex: '48',
-        gas: '578737',
-        gasPrice: '3000000000',
-        gasUsed: '518737',
-        cumulativeGasUsed: '2848015',
-        input: 'deprecated',
-        confirmations: '3531069',
-    },
-    {
-        blockNumber: '8350859',
-        timeStamp: '1565815221',
-        hash: '0x989ea9f3ee576fa43957f44363e839adf1a4a397c3d8392a4f7cbbf7949fd0ae',
-        nonce: '2',
-        blockHash: '0xb9cf1d29c665c052e3831b5754903e539c5b0b1d33b8bcab6cd2d450764d601f',
-        from: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',
-        contractAddress: '0x89d24a6b4ccb1b6faa2625fe562bdd9a23260359',
-        to: '0x09cabec1ead1c0ba254b09efb3ee13841712be14',
-        value: '10000000000000000000',
-        tokenName: 'Sai Stablecoin v1.0',
-        tokenSymbol: 'SAI',
-        tokenDecimal: '18',
-        transactionIndex: '31',
-        gas: '60734',
-        gasPrice: '1000000000',
-        gasUsed: '54745',
-        cumulativeGasUsed: '7833857',
-        input: 'deprecated',
-        confirmations: '3531056',
-    },
-    {
-        blockNumber: '8679548',
-        timeStamp: '1570244087',
-        hash: '0xc0016b89b3b525b30d73f242653b0d80ec3ebf285376dff5bb52cef3261498b2',
-        nonce: '3',
-        blockHash: '0x1ceb2f8b83087f010773e2acf63d1526633c8a884bd1980f118a1bba576be69f',
-        from: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',
-        contractAddress: '0x89d24a6b4ccb1b6faa2625fe562bdd9a23260359',
-        to: '0xdfa6edae2ec0cf1d4a60542422724a48195a5071',
-        value: '0',
-        tokenName: 'Sai Stablecoin v1.0',
-        tokenSymbol: 'SAI',
-        tokenDecimal: '18',
-        transactionIndex: '56',
-        gas: '993379',
-        gasPrice: '1440000000',
-        gasUsed: '647253',
-        cumulativeGasUsed: '3562204',
-        input: 'deprecated',
-        confirmations: '3202367',
-    },
-    {
-        blockNumber: '8679548',
-        timeStamp: '1570244087',
-        hash: '0xc0016b89b3b525b30d73f242653b0d80ec3ebf285376dff5bb52cef3261498b2',
-        nonce: '3',
-        blockHash: '0x1ceb2f8b83087f010773e2acf63d1526633c8a884bd1980f118a1bba576be69f',
-        from: '0xdfa6edae2ec0cf1d4a60542422724a48195a5071',
-        contractAddress: '0x89d24a6b4ccb1b6faa2625fe562bdd9a23260359',
-        to: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',
-        value: '0',
-        tokenName: 'Sai Stablecoin v1.0',
-        tokenSymbol: 'SAI',
-        tokenDecimal: '18',
-        transactionIndex: '56',
-        gas: '993379',
-        gasPrice: '1440000000',
-        gasUsed: '647253',
-        cumulativeGasUsed: '3562204',
-        input: 'deprecated',
-        confirmations: '3202367',
-    },
-    {
-        blockNumber: '8694142',
-        timeStamp: '1570440625',
-        hash: '0xd8397138bb93d56e50d01e92a9eae99ebd3ae28844acdaa4663976a5501116cf',
-        nonce: '2837',
-        blockHash: '0xba45dd64e71e146066af9b6d2dd3bc5d72f4a3399148c155dced74c139fc3c51',
-        from: '0xdfa6edae2ec0cf1d4a60542422724a48195a5071',
-        contractAddress: '0x89d24a6b4ccb1b6faa2625fe562bdd9a23260359',
-        to: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',
-        value: '0',
-        tokenName: 'Sai Stablecoin v1.0',
-        tokenSymbol: 'SAI',
-        tokenDecimal: '18',
-        transactionIndex: '217',
-        gas: '600632',
-        gasPrice: '9000000000',
-        gasUsed: '570632',
-        cumulativeGasUsed: '9023725',
-        input: 'deprecated',
-        confirmations: '3187773',
-    },
-    {
-        blockNumber: '10877041',
-        timeStamp: '1600310867',
-        hash: '0xc8bd16b6b41b4c24849eb6869702e1489c808cb5b125b01f084e38fefcb5ea77',
-        nonce: '4',
-        blockHash: '0x7fa16a022bcf1f69c2d7adf6bd7d3f058e808eec5c66aaa910dfa8016a5333d1',
-        from: '0x090d4613473dee047c3f2706764f49e0821d256e',
-        contractAddress: '0x1f9840a85d5af5bf1d1762f925bdaddc4201f984',
-        to: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',
-        value: '400000000000000000000',
-        tokenName: 'Uniswap',
-        tokenSymbol: 'UNI',
-        tokenDecimal: '18',
-        transactionIndex: '42',
-        gas: '90038',
-        gasPrice: '550000000000',
-        gasUsed: '81853',
-        cumulativeGasUsed: '3163540',
-        input: 'deprecated',
-        confirmations: '1004874',
-    },
-    {
-        blockNumber: '10877897',
-        timeStamp: '1600321973',
-        hash: '0xa7162489faef826ee77862ed5210b01726524f09428f69842118dad394842d62',
-        nonce: '6',
-        blockHash: '0xa74eb9d16f65f307dde4ce58c813c981b28f242edf1090ee2ac42caac9dccaca',
-        from: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',
-        contractAddress: '0x1f9840a85d5af5bf1d1762f925bdaddc4201f984',
-        to: '0x5e736f1f25992b2cad20ded179a52823d3d24b26',
-        value: '400000000000000000000',
-        tokenName: 'Uniswap',
-        tokenSymbol: 'UNI',
-        tokenDecimal: '18',
-        transactionIndex: '86',
-        gas: '60759',
-        gasPrice: '640000000000',
-        gasUsed: '25506',
-        cumulativeGasUsed: '4408393',
-        input: 'deprecated',
-        confirmations: '1004018',
-    },
-];
-exports.tokenTxsMock = tokenTxsMock;
-const txsInStateMock = (ethTxHash, tokenTxHash) => [
-    {
-        id: 'token-transaction-id',
-        chainId: (0, controller_utils_1.toHex)(1),
-        status: TransactionController_1.TransactionStatus.confirmed,
-        time: 1615497996125,
-        transaction: {
-            from: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',
-            data: '0x',
-            gas: '624874',
-            gasPrice: '20000000000',
-            gasUsed: '21000',
-            nonce: '0x12',
-            to: '0x881d40237659c251811cec9c364ef91dc08d300c',
-            value: '0x0',
-        },
-        transactionHash: tokenTxHash,
-        toSmartContract: true,
-    },
-    {
-        id: 'eth-transaction-id',
-        chainId: (0, controller_utils_1.toHex)(1),
-        status: TransactionController_1.TransactionStatus.confirmed,
-        time: 1615497996125,
-        transaction: {
-            from: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',
-            data: '0x',
-            gas: '0x51d68',
-            gasPrice: '0x2540be400',
-            gasUsed: '0x5208',
-            nonce: '0x12',
-            to: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',
-            value: '100000000000000000',
-        },
-        transactionHash: ethTxHash,
-        toSmartContract: false,
-    },
-];
-exports.txsInStateMock = txsInStateMock;
-const txsInStateWithOutdatedStatusMock = (ethTxHash, tokenTxHash) => [
-    {
-        id: 'token-transaction-id',
-        chainId: (0, controller_utils_1.toHex)(1),
-        status: TransactionController_1.TransactionStatus.rejected,
-        time: 1615497996125,
-        transaction: {
-            from: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',
-            data: '0x',
-            gas: '624874',
-            gasPrice: '20000000000',
-            gasUsed: '21000',
-            nonce: '0x12',
-            to: '0x881d40237659c251811cec9c364ef91dc08d300c',
-            value: '0x0',
-        },
-        transactionHash: tokenTxHash,
-        toSmartContract: true,
-    },
-    {
-        id: 'eth-transaction-id',
-        chainId: (0, controller_utils_1.toHex)(1),
-        status: TransactionController_1.TransactionStatus.rejected,
-        time: 1615497996125,
-        transaction: {
-            from: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',
-            data: '0x',
-            gas: '0x51d68',
-            gasPrice: '0x2540be400',
-            gasUsed: '0x5208',
-            nonce: '0x12',
-            to: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',
-            value: '100000000000000000',
-        },
-        transactionHash: ethTxHash,
-        toSmartContract: false,
-    },
-];
-exports.txsInStateWithOutdatedStatusMock = txsInStateWithOutdatedStatusMock;
-const txsInStateWithOutdatedGasDataMock = (ethTxHash, tokenTxHash) => [
-    {
-        id: 'token-transaction-id',
-        chainId: (0, controller_utils_1.toHex)(1),
-        status: TransactionController_1.TransactionStatus.confirmed,
-        time: 1615497996125,
-        transaction: {
-            from: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',
-            data: '0x',
-            gas: '624874',
-            gasPrice: '20000000000',
-            gasUsed: undefined,
-            nonce: '0x12',
-            to: '0x881d40237659c251811cec9c364ef91dc08d300c',
-            value: '0x0',
-        },
-        transactionHash: tokenTxHash,
-        toSmartContract: true,
-    },
-    {
-        id: 'eth-transaction-id',
-        chainId: (0, controller_utils_1.toHex)(1),
-        status: TransactionController_1.TransactionStatus.confirmed,
-        time: 1615497996125,
-        transaction: {
-            from: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',
-            data: '0x',
-            gas: '0x51d68',
-            gasPrice: '0x2540be400',
-            gasUsed: undefined,
-            nonce: '0x12',
-            to: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',
-            value: '100000000000000000',
-        },
-        transactionHash: ethTxHash,
-        toSmartContract: false,
-    },
-];
-exports.txsInStateWithOutdatedGasDataMock = txsInStateWithOutdatedGasDataMock;
-const txsInStateWithOutdatedStatusAndGasDataMock = (ethTxHash, tokenTxHash) => [
-    {
-        id: 'token-transaction-id',
-        chainId: (0, controller_utils_1.toHex)(1),
-        status: TransactionController_1.TransactionStatus.rejected,
-        time: 1615497996125,
-        transaction: {
-            from: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',
-            data: '0x',
-            gas: '624874',
-            gasPrice: '20000000000',
-            gasUsed: undefined,
-            nonce: '0x12',
-            to: '0x881d40237659c251811cec9c364ef91dc08d300c',
-            value: '0x0',
-        },
-        transactionHash: tokenTxHash,
-        toSmartContract: true,
-    },
-    {
-        id: 'eth-transaction-id',
-        chainId: (0, controller_utils_1.toHex)(1),
-        status: TransactionController_1.TransactionStatus.rejected,
-        time: 1615497996125,
-        transaction: {
-            from: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',
-            data: '0x',
-            gas: '0x51d68',
-            gasPrice: '0x2540be400',
-            gasUsed: undefined,
-            nonce: '0x12',
-            to: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',
-            value: '100000000000000000',
-        },
-        transactionHash: ethTxHash,
-        toSmartContract: false,
-    },
-];
-exports.txsInStateWithOutdatedStatusAndGasDataMock = txsInStateWithOutdatedStatusAndGasDataMock;
-//# sourceMappingURL=txsMock.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/mocks/txsMock.js.map b/node_modules/@metamask/transaction-controller/dist/mocks/txsMock.js.map
deleted file mode 100644
index 99e8f02..0000000
--- a/node_modules/@metamask/transaction-controller/dist/mocks/txsMock.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"txsMock.js","sourceRoot":"","sources":["../../src/mocks/txsMock.ts"],"names":[],"mappings":"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","sourcesContent":["import { toHex } from '@metamask/controller-utils';\nimport { TransactionMeta, TransactionStatus } from '../TransactionController';\n\nexport const ethTxsMock = (ethTxHash: string) => [\n  {\n    blockNumber: '4535101',\n    confirmations: '10',\n    contractAddress: '',\n    cumulativeGasUsed: '120607',\n    from: '0xe46abaf75cfbff815c0b7ffed6f02b0760ea27f1',\n    gas: '335208',\n    gasPrice: '10000000000',\n    gasUsed: '21000',\n    hash: ethTxHash,\n    input: '0x',\n    isError: '0',\n    nonce: '9',\n    timeStamp: '1543596286',\n    to: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',\n    transactionIndex: '2',\n    txreceipt_status: '1',\n    value: '100000000000000000',\n  },\n  {\n    blockNumber: '4535108',\n    confirmations: '3',\n    contractAddress: '',\n    cumulativeGasUsed: '693910',\n    from: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',\n    gas: '335208',\n    gasPrice: '20000000000',\n    gasUsed: '21000',\n    hash: '0x342e9d73e10004af41d04973339fc7219dbadcbb5629730cfe65e9f9cb15ff92',\n    input: '0x',\n    isError: '0',\n    nonce: '0',\n    timeStamp: '1543596378',\n    to: '0xb2d191b6fe03c5b8a1ab249cfe88c37553357a23',\n    transactionIndex: '12',\n    txreceipt_status: '1',\n    value: '50000000000000000',\n  },\n  {\n    blockNumber: '4535105',\n    confirmations: '4',\n    contractAddress: '',\n    cumulativeGasUsed: '693910',\n    from: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',\n    gas: '335208',\n    gasPrice: '20000000000',\n    gasUsed: '21000',\n    hash: '0x342e9d73e10004af41d04973339fc7219dbadcbb5629730cfe65e9f9cb15ff91',\n    input: '0x',\n    isError: '0',\n    nonce: '1',\n    timeStamp: '1543596356',\n    transactionIndex: '13',\n    txreceipt_status: '1',\n    value: '50000000000000000',\n  },\n  {\n    blockNumber: '4535106',\n    confirmations: '4',\n    contractAddress: '',\n    cumulativeGasUsed: '693910',\n    from: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',\n    gas: '335208',\n    gasPrice: '20000000000',\n    gasUsed: '21000',\n    hash: '0x342e9d73e10004af41d04973139fc7219dbadcbb5629730cfe65e9f9cb15ff91',\n    input: '0x11',\n    isError: '0',\n    nonce: '3',\n    timeStamp: '1543596356',\n    to: '0xb2d191b6fe03c5b8a1ab249cfe88c37553357a23',\n    transactionIndex: '13',\n    txreceipt_status: '1',\n    value: '50000000000000000',\n  },\n];\n\nexport const tokenTxsMock = (tokenTxHash: string) => [\n  {\n    blockNumber: '8222239',\n    timeStamp: '1564091067',\n    hash: tokenTxHash,\n    nonce: '2329',\n    blockHash:\n      '0x3c30a9be9aea7be13caad419444140c11839d72e70479ec7e9c6d8bd08c533bc',\n    from: '0xdfa6edae2ec0cf1d4a60542422724a48195a5071',\n    contractAddress: '0x89d24a6b4ccb1b6faa2625fe562bdd9a23260359',\n    to: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',\n    value: '0',\n    tokenName: 'Sai Stablecoin v1.0',\n    tokenSymbol: 'SAI',\n    tokenDecimal: '18',\n    transactionIndex: '69',\n    gas: '624874',\n    gasPrice: '20000000000',\n    gasUsed: '21000',\n    cumulativeGasUsed: '3203881',\n    input: 'deprecated',\n    confirmations: '3659676',\n  },\n  {\n    blockNumber: '8222250',\n    timeStamp: '1564091247',\n    hash: '0xdcd1c8bee545d3f76d80b20a23ad44276ba2e376681228eb4570cf3518491279',\n    nonce: '2330',\n    blockHash:\n      '0x16986dd66bedb20a5b846ec2b6c0ecaa62f1c4b51fac58c1326101fd9126dd82',\n    from: '0xdfa6edae2ec0cf1d4a60542422724a48195a5071',\n    contractAddress: '0x89d24a6b4ccb1b6faa2625fe562bdd9a23260359',\n    to: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',\n    value: '0',\n    tokenName: 'Sai Stablecoin v1.0',\n    tokenSymbol: 'SAI',\n    tokenDecimal: '18',\n    transactionIndex: '40',\n    gas: '594268',\n    gasPrice: '20000000000',\n    gasUsed: '579268',\n    cumulativeGasUsed: '2009011',\n    input: 'deprecated',\n    confirmations: '3659665',\n  },\n  {\n    blockNumber: '8223771',\n    timeStamp: '1564111652',\n    hash: '0x070369e6f560b0deca52e050ff1a961fa7b688bbec5cea08435921c9d9b0f52e',\n    nonce: '2333',\n    blockHash:\n      '0x0aff8b36881be99df6d176d7c64c2171672c0483684a10c112d2c90fefe30a0a',\n    from: '0xdfa6edae2ec0cf1d4a60542422724a48195a5071',\n    contractAddress: '0x89d24a6b4ccb1b6faa2625fe562bdd9a23260359',\n    to: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',\n    value: '0',\n    tokenName: 'Sai Stablecoin v1.0',\n    tokenSymbol: 'SAI',\n    tokenDecimal: '18',\n    transactionIndex: '132',\n    gas: '583810',\n    gasPrice: '6000000000',\n    gasUsed: '568810',\n    cumulativeGasUsed: '6956245',\n    input: 'deprecated',\n    confirmations: '3658144',\n  },\n  {\n    blockNumber: '8224850',\n    timeStamp: '1564126442',\n    hash: '0x8ef20ec9597c8c2e945bcc76d2668e5d3bb088b081fe8c5b5af2e1cbd315a20f',\n    nonce: '31',\n    blockHash:\n      '0xb80d4d861ecb7a3cb14e591c0aaeb226842d0267772affa2acc1a590c7535647',\n    from: '0x6c70e3563cef0c6835703bb2664c9f59a92353e4',\n    contractAddress: '0x89d24a6b4ccb1b6faa2625fe562bdd9a23260359',\n    to: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',\n    value: '10000000000000000000',\n    tokenName: 'Sai Stablecoin v1.0',\n    tokenSymbol: 'SAI',\n    tokenDecimal: '18',\n    transactionIndex: '169',\n    gas: '78447',\n    gasPrice: '2000000000',\n    gasUsed: '52298',\n    cumulativeGasUsed: '7047823',\n    input: 'deprecated',\n    confirmations: '3657065',\n  },\n  {\n    blockNumber: '8228053',\n    timeStamp: '1564168901',\n    hash: '0xa0f2d7b558bb3cc28fa568f6feb8ed30eb28a01a674d7c0d4ae603fc691e6020',\n    nonce: '2368',\n    blockHash:\n      '0x62c515ea049842c968ca67499f47a32a11394364d319d9c9cc0a0211652a7294',\n    from: '0xdfa6edae2ec0cf1d4a60542422724a48195a5071',\n    contractAddress: '0x89d24a6b4ccb1b6faa2625fe562bdd9a23260359',\n    to: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',\n    value: '0',\n    tokenName: 'Sai Stablecoin v1.0',\n    tokenSymbol: 'SAI',\n    tokenDecimal: '18',\n    transactionIndex: '43',\n    gas: '567156',\n    gasPrice: '3000000000',\n    gasUsed: '552156',\n    cumulativeGasUsed: '3048261',\n    input: 'deprecated',\n    confirmations: '3653862',\n  },\n  {\n    blockNumber: '8315335',\n    timeStamp: '1565339223',\n    hash: '0x464df60fe00b6dd04c9e8ab341d02af9b10a619d2fcd60fd2971f10edf12118f',\n    nonce: '206760',\n    blockHash:\n      '0x98275388ef6708debe35ac7bf2e30143c9b1fd9e0e457ca03598fc1f4209e273',\n    from: '0x00cfbbaf7ddb3a1476767101c12a0162e241fbad',\n    contractAddress: '0x4dc3643dbc642b72c158e7f3d2ff232df61cb6ce',\n    to: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',\n    value: '100000000000000000',\n    tokenName: 'Amber',\n    tokenSymbol: 'AMB',\n    tokenDecimal: '18',\n    transactionIndex: '186',\n    gas: '60000',\n    gasPrice: '2000000000',\n    gasUsed: '52108',\n    cumulativeGasUsed: '7490707',\n    input: 'deprecated',\n    confirmations: '3566580',\n  },\n  {\n    blockNumber: '8350846',\n    timeStamp: '1565815049',\n    hash: '0xc0682327ad3efd56dfa33e8206b4e09efad4e419a6191076069d217e3ee2341f',\n    nonce: '2506',\n    blockHash:\n      '0xd0aa3c0e319fdfeb21b0192cf77b9760b8668060a5977a5f10f8413531083afa',\n    from: '0xdfa6edae2ec0cf1d4a60542422724a48195a5071',\n    contractAddress: '0x89d24a6b4ccb1b6faa2625fe562bdd9a23260359',\n    to: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',\n    value: '4',\n    tokenName: 'Sai Stablecoin v1.0',\n    tokenSymbol: 'SAI',\n    tokenDecimal: '18',\n    transactionIndex: '48',\n    gas: '578737',\n    gasPrice: '3000000000',\n    gasUsed: '518737',\n    cumulativeGasUsed: '2848015',\n    input: 'deprecated',\n    confirmations: '3531069',\n  },\n  {\n    blockNumber: '8350859',\n    timeStamp: '1565815221',\n    hash: '0x989ea9f3ee576fa43957f44363e839adf1a4a397c3d8392a4f7cbbf7949fd0ae',\n    nonce: '2',\n    blockHash:\n      '0xb9cf1d29c665c052e3831b5754903e539c5b0b1d33b8bcab6cd2d450764d601f',\n    from: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',\n    contractAddress: '0x89d24a6b4ccb1b6faa2625fe562bdd9a23260359',\n    to: '0x09cabec1ead1c0ba254b09efb3ee13841712be14',\n    value: '10000000000000000000',\n    tokenName: 'Sai Stablecoin v1.0',\n    tokenSymbol: 'SAI',\n    tokenDecimal: '18',\n    transactionIndex: '31',\n    gas: '60734',\n    gasPrice: '1000000000',\n    gasUsed: '54745',\n    cumulativeGasUsed: '7833857',\n    input: 'deprecated',\n    confirmations: '3531056',\n  },\n  {\n    blockNumber: '8679548',\n    timeStamp: '1570244087',\n    hash: '0xc0016b89b3b525b30d73f242653b0d80ec3ebf285376dff5bb52cef3261498b2',\n    nonce: '3',\n    blockHash:\n      '0x1ceb2f8b83087f010773e2acf63d1526633c8a884bd1980f118a1bba576be69f',\n    from: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',\n    contractAddress: '0x89d24a6b4ccb1b6faa2625fe562bdd9a23260359',\n    to: '0xdfa6edae2ec0cf1d4a60542422724a48195a5071',\n    value: '0',\n    tokenName: 'Sai Stablecoin v1.0',\n    tokenSymbol: 'SAI',\n    tokenDecimal: '18',\n    transactionIndex: '56',\n    gas: '993379',\n    gasPrice: '1440000000',\n    gasUsed: '647253',\n    cumulativeGasUsed: '3562204',\n    input: 'deprecated',\n    confirmations: '3202367',\n  },\n  {\n    blockNumber: '8679548',\n    timeStamp: '1570244087',\n    hash: '0xc0016b89b3b525b30d73f242653b0d80ec3ebf285376dff5bb52cef3261498b2',\n    nonce: '3',\n    blockHash:\n      '0x1ceb2f8b83087f010773e2acf63d1526633c8a884bd1980f118a1bba576be69f',\n    from: '0xdfa6edae2ec0cf1d4a60542422724a48195a5071',\n    contractAddress: '0x89d24a6b4ccb1b6faa2625fe562bdd9a23260359',\n    to: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',\n    value: '0',\n    tokenName: 'Sai Stablecoin v1.0',\n    tokenSymbol: 'SAI',\n    tokenDecimal: '18',\n    transactionIndex: '56',\n    gas: '993379',\n    gasPrice: '1440000000',\n    gasUsed: '647253',\n    cumulativeGasUsed: '3562204',\n    input: 'deprecated',\n    confirmations: '3202367',\n  },\n  {\n    blockNumber: '8694142',\n    timeStamp: '1570440625',\n    hash: '0xd8397138bb93d56e50d01e92a9eae99ebd3ae28844acdaa4663976a5501116cf',\n    nonce: '2837',\n    blockHash:\n      '0xba45dd64e71e146066af9b6d2dd3bc5d72f4a3399148c155dced74c139fc3c51',\n    from: '0xdfa6edae2ec0cf1d4a60542422724a48195a5071',\n    contractAddress: '0x89d24a6b4ccb1b6faa2625fe562bdd9a23260359',\n    to: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',\n    value: '0',\n    tokenName: 'Sai Stablecoin v1.0',\n    tokenSymbol: 'SAI',\n    tokenDecimal: '18',\n    transactionIndex: '217',\n    gas: '600632',\n    gasPrice: '9000000000',\n    gasUsed: '570632',\n    cumulativeGasUsed: '9023725',\n    input: 'deprecated',\n    confirmations: '3187773',\n  },\n  {\n    blockNumber: '10877041',\n    timeStamp: '1600310867',\n    hash: '0xc8bd16b6b41b4c24849eb6869702e1489c808cb5b125b01f084e38fefcb5ea77',\n    nonce: '4',\n    blockHash:\n      '0x7fa16a022bcf1f69c2d7adf6bd7d3f058e808eec5c66aaa910dfa8016a5333d1',\n    from: '0x090d4613473dee047c3f2706764f49e0821d256e',\n    contractAddress: '0x1f9840a85d5af5bf1d1762f925bdaddc4201f984',\n    to: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',\n    value: '400000000000000000000',\n    tokenName: 'Uniswap',\n    tokenSymbol: 'UNI',\n    tokenDecimal: '18',\n    transactionIndex: '42',\n    gas: '90038',\n    gasPrice: '550000000000',\n    gasUsed: '81853',\n    cumulativeGasUsed: '3163540',\n    input: 'deprecated',\n    confirmations: '1004874',\n  },\n  {\n    blockNumber: '10877897',\n    timeStamp: '1600321973',\n    hash: '0xa7162489faef826ee77862ed5210b01726524f09428f69842118dad394842d62',\n    nonce: '6',\n    blockHash:\n      '0xa74eb9d16f65f307dde4ce58c813c981b28f242edf1090ee2ac42caac9dccaca',\n    from: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',\n    contractAddress: '0x1f9840a85d5af5bf1d1762f925bdaddc4201f984',\n    to: '0x5e736f1f25992b2cad20ded179a52823d3d24b26',\n    value: '400000000000000000000',\n    tokenName: 'Uniswap',\n    tokenSymbol: 'UNI',\n    tokenDecimal: '18',\n    transactionIndex: '86',\n    gas: '60759',\n    gasPrice: '640000000000',\n    gasUsed: '25506',\n    cumulativeGasUsed: '4408393',\n    input: 'deprecated',\n    confirmations: '1004018',\n  },\n];\n\nexport const txsInStateMock = (\n  ethTxHash: string,\n  tokenTxHash: string,\n): TransactionMeta[] => [\n  {\n    id: 'token-transaction-id',\n    chainId: toHex(1),\n    status: TransactionStatus.confirmed,\n    time: 1615497996125,\n    transaction: {\n      from: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',\n      data: '0x',\n      gas: '624874',\n      gasPrice: '20000000000',\n      gasUsed: '21000',\n      nonce: '0x12',\n      to: '0x881d40237659c251811cec9c364ef91dc08d300c',\n      value: '0x0',\n    },\n    transactionHash: tokenTxHash,\n    toSmartContract: true,\n  },\n  {\n    id: 'eth-transaction-id',\n    chainId: toHex(1),\n    status: TransactionStatus.confirmed,\n    time: 1615497996125,\n    transaction: {\n      from: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',\n      data: '0x',\n      gas: '0x51d68',\n      gasPrice: '0x2540be400',\n      gasUsed: '0x5208',\n      nonce: '0x12',\n      to: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',\n      value: '100000000000000000',\n    },\n    transactionHash: ethTxHash,\n    toSmartContract: false,\n  },\n];\n\nexport const txsInStateWithOutdatedStatusMock = (\n  ethTxHash: string,\n  tokenTxHash: string,\n): TransactionMeta[] => [\n  {\n    id: 'token-transaction-id',\n    chainId: toHex(1),\n    status: TransactionStatus.rejected,\n    time: 1615497996125,\n    transaction: {\n      from: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',\n      data: '0x',\n      gas: '624874',\n      gasPrice: '20000000000',\n      gasUsed: '21000',\n      nonce: '0x12',\n      to: '0x881d40237659c251811cec9c364ef91dc08d300c',\n      value: '0x0',\n    },\n    transactionHash: tokenTxHash,\n    toSmartContract: true,\n  },\n  {\n    id: 'eth-transaction-id',\n    chainId: toHex(1),\n    status: TransactionStatus.rejected,\n    time: 1615497996125,\n    transaction: {\n      from: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',\n      data: '0x',\n      gas: '0x51d68',\n      gasPrice: '0x2540be400',\n      gasUsed: '0x5208',\n      nonce: '0x12',\n      to: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',\n      value: '100000000000000000',\n    },\n    transactionHash: ethTxHash,\n    toSmartContract: false,\n  },\n];\n\nexport const txsInStateWithOutdatedGasDataMock = (\n  ethTxHash: string,\n  tokenTxHash: string,\n): TransactionMeta[] => [\n  {\n    id: 'token-transaction-id',\n    chainId: toHex(1),\n    status: TransactionStatus.confirmed,\n    time: 1615497996125,\n    transaction: {\n      from: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',\n      data: '0x',\n      gas: '624874',\n      gasPrice: '20000000000',\n      gasUsed: undefined,\n      nonce: '0x12',\n      to: '0x881d40237659c251811cec9c364ef91dc08d300c',\n      value: '0x0',\n    },\n    transactionHash: tokenTxHash,\n    toSmartContract: true,\n  },\n  {\n    id: 'eth-transaction-id',\n    chainId: toHex(1),\n    status: TransactionStatus.confirmed,\n    time: 1615497996125,\n    transaction: {\n      from: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',\n      data: '0x',\n      gas: '0x51d68',\n      gasPrice: '0x2540be400',\n      gasUsed: undefined,\n      nonce: '0x12',\n      to: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',\n      value: '100000000000000000',\n    },\n    transactionHash: ethTxHash,\n    toSmartContract: false,\n  },\n];\n\nexport const txsInStateWithOutdatedStatusAndGasDataMock = (\n  ethTxHash: string,\n  tokenTxHash: string,\n): TransactionMeta[] => [\n  {\n    id: 'token-transaction-id',\n    chainId: toHex(1),\n    status: TransactionStatus.rejected,\n    time: 1615497996125,\n    transaction: {\n      from: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',\n      data: '0x',\n      gas: '624874',\n      gasPrice: '20000000000',\n      gasUsed: undefined,\n      nonce: '0x12',\n      to: '0x881d40237659c251811cec9c364ef91dc08d300c',\n      value: '0x0',\n    },\n    transactionHash: tokenTxHash,\n    toSmartContract: true,\n  },\n  {\n    id: 'eth-transaction-id',\n    chainId: toHex(1),\n    status: TransactionStatus.rejected,\n    time: 1615497996125,\n    transaction: {\n      from: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',\n      data: '0x',\n      gas: '0x51d68',\n      gasPrice: '0x2540be400',\n      gasUsed: undefined,\n      nonce: '0x12',\n      to: '0x6bf137f335ea1b8f193b8f6ea92561a60d23a207',\n      value: '100000000000000000',\n    },\n    transactionHash: ethTxHash,\n    toSmartContract: false,\n  },\n];\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/types.d.ts b/node_modules/@metamask/transaction-controller/dist/types.d.ts
new file mode 100644
index 0000000..39cc136
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/types.d.ts
@@ -0,0 +1,232 @@
+import { Hex } from '@metamask/utils';
+import { GasFeeState } from '@metamask/gas-fee-controller';
+/**
+ * @type TransactionMeta
+ *
+ * TransactionMeta representation
+ * @property error - Synthesized error information for failed transactions
+ * @property id - Generated UUID associated with this transaction
+ * @property networkID - Network code as per EIP-155 for this transaction
+ * @property origin - Origin this transaction was sent from
+ * @property deviceConfirmedOn - string to indicate what device the transaction was confirmed
+ * @property rawTransaction - Hex representation of the underlying transaction
+ * @property status - String status of this transaction
+ * @property time - Timestamp associated with this transaction
+ * @property toSmartContract - Whether transaction recipient is a smart contract
+ * @property transaction - Underlying Transaction object
+ * @property transactionHash - Hash of a successful transaction
+ * @property blockNumber - Number of the block where the transaction has been included
+ */
+export declare type TransactionMeta = ({
+    status: Exclude<TransactionStatus, TransactionStatus.failed>;
+} & TransactionMetaBase) | ({
+    status: TransactionStatus.failed;
+    error: Error;
+} & TransactionMetaBase);
+declare type TransactionMetaBase = {
+    isTransfer?: boolean;
+    transferInformation?: {
+        symbol: string;
+        contractAddress: string;
+        decimals: number;
+    };
+    id: string;
+    networkID?: string;
+    chainId?: Hex;
+    origin?: string;
+    rawTransaction?: string;
+    time: number;
+    toSmartContract?: boolean;
+    transaction: Transaction;
+    transactionHash?: string;
+    blockNumber?: string;
+    deviceConfirmedOn?: WalletDevice;
+    verifiedOnBlockchain?: boolean;
+    /** Alternate EIP-1559 gas fee estimates for multiple priority levels. */
+    gasFeeEstimates?: GasFeeEstimates;
+    /** Whether the gas fee estimates have been checked at least once. */
+    gasFeeEstimatesLoaded?: boolean;
+    /**
+     * Response from security validator.
+     */
+    securityAlertResponse?: SecurityAlertResponse;
+};
+/**
+ * The status of the transaction. Each status represents the state of the transaction internally
+ * in the wallet. Some of these correspond with the state of the transaction on the network, but
+ * some are wallet-specific.
+ */
+export declare enum TransactionStatus {
+    approved = "approved",
+    cancelled = "cancelled",
+    confirmed = "confirmed",
+    failed = "failed",
+    rejected = "rejected",
+    signed = "signed",
+    submitted = "submitted",
+    unapproved = "unapproved"
+}
+/**
+ * Options for wallet device.
+ */
+export declare enum WalletDevice {
+    MM_MOBILE = "metamask_mobile",
+    MM_EXTENSION = "metamask_extension",
+    OTHER = "other_device"
+}
+/**
+ * @type Transaction
+ *
+ * Transaction representation
+ * @property chainId - Network ID as per EIP-155
+ * @property data - Data to pass with this transaction
+ * @property from - Address to send this transaction from
+ * @property gas - Gas to send with this transaction
+ * @property gasPrice - Price of gas with this transaction
+ * @property gasUsed - Gas used in the transaction
+ * @property nonce - Unique number to prevent replay attacks
+ * @property to - Address to send this transaction to
+ * @property value - Value associated with this transaction
+ */
+export interface Transaction {
+    chainId?: Hex;
+    data?: string;
+    from: string;
+    gas?: string;
+    gasPrice?: string;
+    gasUsed?: string;
+    nonce?: string;
+    to?: string;
+    value?: string;
+    maxFeePerGas?: string;
+    maxPriorityFeePerGas?: string;
+    estimatedBaseFee?: string;
+    estimateGasError?: string;
+    type?: string;
+}
+/**
+ * The configuration required to fetch transaction data from a RemoteTransactionSource.
+ */
+export interface RemoteTransactionSourceRequest {
+    /**
+     * The address of the account to fetch transactions for.
+     */
+    address: string;
+    /**
+     * API key if required by the remote source.
+     */
+    apiKey?: string;
+    /**
+     * The chainId of the current network.
+     */
+    currentChainId: Hex;
+    /**
+     * The networkId of the current network.
+     */
+    currentNetworkId: string;
+    /**
+     * Block number to start fetching transactions from.
+     */
+    fromBlock?: number;
+    /**
+     * Maximum number of transactions to retrieve.
+     */
+    limit?: number;
+}
+/**
+ * An object capable of fetching transaction data from a remote source.
+ * Used by the IncomingTransactionHelper to retrieve remote transaction data.
+ */
+export interface RemoteTransactionSource {
+    isSupportedNetwork: (chainId: string, networkId: string) => boolean;
+    fetchTransactions: (request: RemoteTransactionSourceRequest) => Promise<TransactionMeta[]>;
+}
+export declare type SecurityAlertResponse = {
+    reason: string;
+    features?: string[];
+    result_type: string;
+    providerRequestsCount?: Record<string, number>;
+};
+/**
+ * Data concerning a successfully submitted transaction.
+ * Used for debugging purposes.
+ */
+export declare type SubmitHistoryEntry = {
+    /** The chain ID of the transaction as a hexadecimal string. */
+    chainId?: Hex;
+    /** The hash of the transaction returned from the RPC provider. */
+    hash: string;
+    /** True if the entry was generated using the migration and existing transaction metadata. */
+    migration?: boolean;
+    /** The type of the network where the transaction was submitted. */
+    networkType?: string;
+    /**
+     * The URL of the network the transaction was submitted to.
+     * A single network URL if it was recorded when submitted.
+     * An array of potential network URLs if it cannot be confirmed since the migration was used.
+     */
+    networkUrl?: string | string[];
+    /** The origin of the transaction. */
+    origin?: string;
+    /** The raw transaction data that was submitted. */
+    rawTransaction: string;
+    /** When the transaction was submitted. */
+    time: number;
+    /** The transaction parameters that were submitted. */
+    transaction: Record<string, unknown>;
+};
+/** Gas fee estimates for a specific priority level. */
+export declare type GasFeeEstimatesForLevel = {
+    /** Maximum amount to pay per gas. */
+    maxFeePerGas: Hex;
+    /** Maximum amount per gas to give to the validator as an incentive. */
+    maxPriorityFeePerGas: Hex;
+};
+/** Alternate priority levels for which values are provided in gas fee estimates. */
+export declare enum GasFeeEstimateLevel {
+    low = "low",
+    medium = "medium",
+    high = "high"
+}
+/** Gas fee estimates for a transaction. */
+export declare type GasFeeEstimates = {
+    /** The gas fee estimate for a low priority transaction. */
+    [GasFeeEstimateLevel.low]: GasFeeEstimatesForLevel;
+    /** The gas fee estimate for a medium priority transaction. */
+    [GasFeeEstimateLevel.medium]: GasFeeEstimatesForLevel;
+    /** The gas fee estimate for a high priority transaction. */
+    [GasFeeEstimateLevel.high]: GasFeeEstimatesForLevel;
+};
+/** Request to a gas fee flow to obtain gas fee estimates. */
+export declare type GasFeeFlowRequest = {
+    /** An EthQuery instance to enable queries to the associated RPC provider. */
+    ethQuery: any;
+    /** Callback to get the GasFeeController estimates. */
+    getGasFeeControllerEstimates: () => Promise<GasFeeState>;
+    /** The metadata of the transaction to obtain estimates for. */
+    transactionMeta: TransactionMeta;
+};
+/** Response from a gas fee flow containing gas fee estimates. */
+export declare type GasFeeFlowResponse = {
+    /** The gas fee estimates for the transaction. */
+    estimates: GasFeeEstimates;
+};
+/** A method of obtaining gas fee estimates for a specific transaction. */
+export declare type GasFeeFlow = {
+    /**
+     * Determine if the gas fee flow supports the specified transaction.
+     *
+     * @param transactionMeta - The transaction metadata.
+     * @returns Whether the gas fee flow supports the transaction.
+     */
+    matchesTransaction(transactionMeta: TransactionMeta): boolean;
+    /**
+     * Get gas fee estimates for a specific transaction.
+     *
+     * @param request - The gas fee flow request.
+     * @returns The gas fee flow response containing the gas fee estimates.
+     */
+    getGasFees: (request: GasFeeFlowRequest) => Promise<GasFeeFlowResponse>;
+};
+export {};
+//# sourceMappingURL=types.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/types.js b/node_modules/@metamask/transaction-controller/dist/types.js
new file mode 100644
index 0000000..2cc85ee
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/types.js
@@ -0,0 +1,36 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.GasFeeEstimateLevel = exports.WalletDevice = exports.TransactionStatus = void 0;
+/**
+ * The status of the transaction. Each status represents the state of the transaction internally
+ * in the wallet. Some of these correspond with the state of the transaction on the network, but
+ * some are wallet-specific.
+ */
+var TransactionStatus;
+(function (TransactionStatus) {
+    TransactionStatus["approved"] = "approved";
+    TransactionStatus["cancelled"] = "cancelled";
+    TransactionStatus["confirmed"] = "confirmed";
+    TransactionStatus["failed"] = "failed";
+    TransactionStatus["rejected"] = "rejected";
+    TransactionStatus["signed"] = "signed";
+    TransactionStatus["submitted"] = "submitted";
+    TransactionStatus["unapproved"] = "unapproved";
+})(TransactionStatus = exports.TransactionStatus || (exports.TransactionStatus = {}));
+/**
+ * Options for wallet device.
+ */
+var WalletDevice;
+(function (WalletDevice) {
+    WalletDevice["MM_MOBILE"] = "metamask_mobile";
+    WalletDevice["MM_EXTENSION"] = "metamask_extension";
+    WalletDevice["OTHER"] = "other_device";
+})(WalletDevice = exports.WalletDevice || (exports.WalletDevice = {}));
+/** Alternate priority levels for which values are provided in gas fee estimates. */
+var GasFeeEstimateLevel;
+(function (GasFeeEstimateLevel) {
+    GasFeeEstimateLevel["low"] = "low";
+    GasFeeEstimateLevel["medium"] = "medium";
+    GasFeeEstimateLevel["high"] = "high";
+})(GasFeeEstimateLevel = exports.GasFeeEstimateLevel || (exports.GasFeeEstimateLevel = {}));
+//# sourceMappingURL=types.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils.d.ts b/node_modules/@metamask/transaction-controller/dist/utils.d.ts
index ccf3362..6521edf 100644
--- a/node_modules/@metamask/transaction-controller/dist/utils.d.ts
+++ b/node_modules/@metamask/transaction-controller/dist/utils.d.ts
@@ -1,6 +1,6 @@
 import type { Transaction as NonceTrackerTransaction } from 'nonce-tracker/dist/NonceTracker';
-import { Transaction, FetchAllOptions, GasPriceValue, FeeMarketEIP1559Values, TransactionStatus } from './TransactionController';
-import type { TransactionMeta } from './TransactionController';
+import { GasPriceValue, FeeMarketEIP1559Values } from './TransactionController';
+import { Transaction, TransactionStatus, TransactionMeta } from './types';
 export declare const ESTIMATE_GAS_ERROR = "eth_estimateGas rpc method error";
 /**
  * Return a URL that can be used to fetch ETH transactions.
@@ -16,7 +16,7 @@ export declare function getEtherscanApiUrl(networkType: string, urlParams: any):
  * @param transaction - Transaction object to normalize.
  * @returns Normalized Transaction object.
  */
-export declare function normalizeTransaction(transaction: Transaction): Transaction;
+export declare function normalizeTransactionParams(transaction: Transaction): Transaction;
 /**
  * Validates a Transaction object for required properties and throws in
  * the event of any validation error.
@@ -32,20 +32,6 @@ export declare function validateTransaction(transaction: Transaction): void;
  * @returns Boolean that is true if the transaction is EIP-1559 (has maxFeePerGas and maxPriorityFeePerGas), otherwise returns false.
  */
 export declare const isEIP1559Transaction: (transaction: Transaction) => boolean;
-/**
- * Handles the fetch of incoming transactions.
- *
- * @param networkType - Network type of desired network.
- * @param address - Address to get the transactions from.
- * @param txHistoryLimit - The maximum number of transactions to fetch.
- * @param opt - Object that can contain fromBlock and Etherscan service API key.
- * @returns Responses for both ETH and ERC20 token transactions.
- */
-export declare function handleTransactionFetch(networkType: string, address: string, txHistoryLimit: number, opt?: FetchAllOptions): Promise<[{
-    [result: string]: [];
-}, {
-    [result: string]: [];
-}]>;
 export declare const validateGasValues: (gasValues: GasPriceValue | FeeMarketEIP1559Values) => void;
 export declare const isFeeMarketEIP1559Values: (gasValues?: GasPriceValue | FeeMarketEIP1559Values | undefined) => gasValues is FeeMarketEIP1559Values;
 export declare const isGasPriceValue: (gasValues?: GasPriceValue | FeeMarketEIP1559Values | undefined) => gasValues is GasPriceValue;
@@ -63,10 +49,19 @@ export declare function validateMinimumIncrease(proposed: string, min: string):
 /**
  * Helper function to filter and format transactions for the nonce tracker.
  *
+ * @param currentChainId - Chain ID of the current network.
  * @param fromAddress - Address of the account from which the transactions to filter from are sent.
  * @param transactionStatus - Status of the transactions for which to filter.
  * @param transactions - Array of transactionMeta objects that have been prefiltered.
  * @returns Array of transactions formatted for the nonce tracker.
  */
-export declare function getAndFormatTransactionsForNonceTracker(fromAddress: string, transactionStatus: TransactionStatus, transactions: TransactionMeta[]): NonceTrackerTransaction[];
+export declare function getAndFormatTransactionsForNonceTracker(currentChainId: string, fromAddress: string, transactionStatus: TransactionStatus, transactions: TransactionMeta[]): NonceTrackerTransaction[];
+/**
+ * Ensure a hex string is of even length by adding a leading 0 if necessary.
+ * Any existing `0x` prefix is preserved but is not added if missing.
+ *
+ * @param hex - The hex string to ensure is even.
+ * @returns The hex string with an even length.
+ */
+export declare function padHexToEvenLength(hex: string): string;
 //# sourceMappingURL=utils.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils.d.ts.map b/node_modules/@metamask/transaction-controller/dist/utils.d.ts.map
deleted file mode 100644
index 9d4045c..0000000
--- a/node_modules/@metamask/transaction-controller/dist/utils.d.ts.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"utils.d.ts","sourceRoot":"","sources":["../src/utils.ts"],"names":[],"mappings":"AAOA,OAAO,KAAK,EAAE,WAAW,IAAI,uBAAuB,EAAE,MAAM,iCAAiC,CAAC;AAC9F,OAAO,EACL,WAAW,EACX,eAAe,EACf,aAAa,EACb,sBAAsB,EACtB,iBAAiB,EAClB,MAAM,yBAAyB,CAAC;AACjC,OAAO,KAAK,EAAE,eAAe,EAAE,MAAM,yBAAyB,CAAC;AAE/D,eAAO,MAAM,kBAAkB,qCAAqC,CAAC;AAiBrE;;;;;;GAMG;AACH,wBAAgB,kBAAkB,CAChC,WAAW,EAAE,MAAM,EACnB,SAAS,EAAE,GAAG,GACb,MAAM,CAeR;AAED;;;;;GAKG;AACH,wBAAgB,oBAAoB,CAAC,WAAW,EAAE,WAAW,eAS5D;AAED;;;;;GAKG;AACH,wBAAgB,mBAAmB,CAAC,WAAW,EAAE,WAAW,QAmD3D;AAED;;;;;;GAMG;AACH,eAAO,MAAM,oBAAoB,gBAAiB,WAAW,KAAG,OAO/D,CAAC;AAEF;;;;;;;;GAQG;AACH,wBAAsB,sBAAsB,CAC1C,WAAW,EAAE,MAAM,EACnB,OAAO,EAAE,MAAM,EACf,cAAc,EAAE,MAAM,EACtB,GAAG,CAAC,EAAE,eAAe,GACpB,OAAO,CAAC,CAAC;IAAE,CAAC,MAAM,EAAE,MAAM,GAAG,EAAE,CAAA;CAAE,EAAE;IAAE,CAAC,MAAM,EAAE,MAAM,GAAG,EAAE,CAAA;CAAE,CAAC,CAAC,CA8C/D;AAED,eAAO,MAAM,iBAAiB,cACjB,aAAa,GAAG,sBAAsB,SAUlD,CAAC;AAEF,eAAO,MAAM,wBAAwB,yGAIsC,CAAC;AAE5E,eAAO,MAAM,eAAe,gGAG0B,CAAC;AAEvD,eAAO,MAAM,oBAAoB,UAAW,MAAM,QAAQ,MAAM,KAAG,MACF,CAAC;AAElE,eAAO,MAAM,6BAA6B,UACjC,MAAM,GAAG,SAAS,QACnB,MAAM,KACX,MAEF,CAAC;AAEF;;;;;;;GAOG;AACH,wBAAgB,uBAAuB,CAAC,QAAQ,EAAE,MAAM,EAAE,GAAG,EAAE,MAAM,UAQpE;AAED;;;;;;;GAOG;AACH,wBAAgB,uCAAuC,CACrD,WAAW,EAAE,MAAM,EACnB,iBAAiB,EAAE,iBAAiB,EACpC,YAAY,EAAE,eAAe,EAAE,GAC9B,uBAAuB,EAAE,CAsB3B"}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils.js b/node_modules/@metamask/transaction-controller/dist/utils.js
index 179a564..0bbba70 100644
--- a/node_modules/@metamask/transaction-controller/dist/utils.js
+++ b/node_modules/@metamask/transaction-controller/dist/utils.js
@@ -1,20 +1,11 @@
 "use strict";
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.getAndFormatTransactionsForNonceTracker = exports.validateMinimumIncrease = exports.getIncreasedPriceFromExisting = exports.getIncreasedPriceHex = exports.isGasPriceValue = exports.isFeeMarketEIP1559Values = exports.validateGasValues = exports.handleTransactionFetch = exports.isEIP1559Transaction = exports.validateTransaction = exports.normalizeTransaction = exports.getEtherscanApiUrl = exports.ESTIMATE_GAS_ERROR = void 0;
+exports.padHexToEvenLength = exports.getAndFormatTransactionsForNonceTracker = exports.validateMinimumIncrease = exports.getIncreasedPriceFromExisting = exports.getIncreasedPriceHex = exports.isGasPriceValue = exports.isFeeMarketEIP1559Values = exports.validateGasValues = exports.isEIP1559Transaction = exports.validateTransaction = exports.normalizeTransactionParams = exports.getEtherscanApiUrl = exports.ESTIMATE_GAS_ERROR = void 0;
 const ethereumjs_util_1 = require("ethereumjs-util");
 const controller_utils_1 = require("@metamask/controller-utils");
 exports.ESTIMATE_GAS_ERROR = 'eth_estimateGas rpc method error';
 const NORMALIZERS = {
-    data: (data) => (0, ethereumjs_util_1.addHexPrefix)(data),
+    data: (data) => (0, ethereumjs_util_1.addHexPrefix)(padHexToEvenLength(data)),
     from: (from) => (0, ethereumjs_util_1.addHexPrefix)(from).toLowerCase(),
     gas: (gas) => (0, ethereumjs_util_1.addHexPrefix)(gas),
     gasPrice: (gasPrice) => (0, ethereumjs_util_1.addHexPrefix)(gasPrice),
@@ -24,6 +15,7 @@ const NORMALIZERS = {
     maxFeePerGas: (maxFeePerGas) => (0, ethereumjs_util_1.addHexPrefix)(maxFeePerGas),
     maxPriorityFeePerGas: (maxPriorityFeePerGas) => (0, ethereumjs_util_1.addHexPrefix)(maxPriorityFeePerGas),
     estimatedBaseFee: (maxPriorityFeePerGas) => (0, ethereumjs_util_1.addHexPrefix)(maxPriorityFeePerGas),
+    type: (type) => (type === '0x0' ? '0x0' : undefined),
 };
 /**
  * Return a URL that can be used to fetch ETH transactions.
@@ -54,7 +46,7 @@ exports.getEtherscanApiUrl = getEtherscanApiUrl;
  * @param transaction - Transaction object to normalize.
  * @returns Normalized Transaction object.
  */
-function normalizeTransaction(transaction) {
+function normalizeTransactionParams(transaction) {
     const normalizedTransaction = { from: '' };
     let key;
     for (key in NORMALIZERS) {
@@ -64,7 +56,7 @@ function normalizeTransaction(transaction) {
     }
     return normalizedTransaction;
 }
-exports.normalizeTransaction = normalizeTransaction;
+exports.normalizeTransactionParams = normalizeTransactionParams;
 /**
  * Validates a Transaction object for required properties and throws in
  * the event of any validation error.
@@ -121,50 +113,6 @@ const isEIP1559Transaction = (transaction) => {
         hasOwnProp(transaction, 'maxPriorityFeePerGas'));
 };
 exports.isEIP1559Transaction = isEIP1559Transaction;
-/**
- * Handles the fetch of incoming transactions.
- *
- * @param networkType - Network type of desired network.
- * @param address - Address to get the transactions from.
- * @param txHistoryLimit - The maximum number of transactions to fetch.
- * @param opt - Object that can contain fromBlock and Etherscan service API key.
- * @returns Responses for both ETH and ERC20 token transactions.
- */
-function handleTransactionFetch(networkType, address, txHistoryLimit, opt) {
-    return __awaiter(this, void 0, void 0, function* () {
-        // transactions
-        const urlParams = {
-            module: 'account',
-            address,
-            startBlock: opt === null || opt === void 0 ? void 0 : opt.fromBlock,
-            apikey: opt === null || opt === void 0 ? void 0 : opt.etherscanApiKey,
-            offset: txHistoryLimit.toString(),
-            order: 'desc',
-        };
-        const etherscanTxUrl = getEtherscanApiUrl(networkType, Object.assign(Object.assign({}, urlParams), { action: 'txlist' }));
-        const etherscanTxResponsePromise = (0, controller_utils_1.handleFetch)(etherscanTxUrl);
-        // tokens
-        const etherscanTokenUrl = getEtherscanApiUrl(networkType, Object.assign(Object.assign({}, urlParams), { action: 'tokentx' }));
-        const etherscanTokenResponsePromise = (0, controller_utils_1.handleFetch)(etherscanTokenUrl);
-        let [etherscanTxResponse, etherscanTokenResponse] = yield Promise.all([
-            etherscanTxResponsePromise,
-            etherscanTokenResponsePromise,
-        ]);
-        if (etherscanTxResponse.status === '0' ||
-            etherscanTxResponse.result.length <= 0) {
-            etherscanTxResponse = { status: etherscanTxResponse.status, result: [] };
-        }
-        if (etherscanTokenResponse.status === '0' ||
-            etherscanTokenResponse.result.length <= 0) {
-            etherscanTokenResponse = {
-                status: etherscanTokenResponse.status,
-                result: [],
-            };
-        }
-        return [etherscanTxResponse, etherscanTokenResponse];
-    });
-}
-exports.handleTransactionFetch = handleTransactionFetch;
 const validateGasValues = (gasValues) => {
     Object.keys(gasValues).forEach((key) => {
         const value = gasValues[key];
@@ -206,14 +154,17 @@ exports.validateMinimumIncrease = validateMinimumIncrease;
 /**
  * Helper function to filter and format transactions for the nonce tracker.
  *
+ * @param currentChainId - Chain ID of the current network.
  * @param fromAddress - Address of the account from which the transactions to filter from are sent.
  * @param transactionStatus - Status of the transactions for which to filter.
  * @param transactions - Array of transactionMeta objects that have been prefiltered.
  * @returns Array of transactions formatted for the nonce tracker.
  */
-function getAndFormatTransactionsForNonceTracker(fromAddress, transactionStatus, transactions) {
+function getAndFormatTransactionsForNonceTracker(currentChainId, fromAddress, transactionStatus, transactions) {
     return transactions
-        .filter(({ status, transaction: { from } }) => status === transactionStatus &&
+        .filter(({ chainId, isTransfer, status, transaction: { from } }) => !isTransfer &&
+        chainId === currentChainId &&
+        status === transactionStatus &&
         from.toLowerCase() === fromAddress.toLowerCase())
         .map(({ status, transaction: { from, gas, value, nonce } }) => {
         // the only value we care about is the nonce
@@ -232,4 +183,18 @@ function getAndFormatTransactionsForNonceTracker(fromAddress, transactionStatus,
     });
 }
 exports.getAndFormatTransactionsForNonceTracker = getAndFormatTransactionsForNonceTracker;
+/**
+ * Ensure a hex string is of even length by adding a leading 0 if necessary.
+ * Any existing `0x` prefix is preserved but is not added if missing.
+ *
+ * @param hex - The hex string to ensure is even.
+ * @returns The hex string with an even length.
+ */
+function padHexToEvenLength(hex) {
+    const prefix = hex.toLowerCase().startsWith('0x') ? hex.slice(0, 2) : '';
+    const data = prefix ? hex.slice(2) : hex;
+    const evenData = data.length % 2 === 0 ? data : `0${data}`;
+    return prefix + evenData;
+}
+exports.padHexToEvenLength = padHexToEvenLength;
 //# sourceMappingURL=utils.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils.js.map b/node_modules/@metamask/transaction-controller/dist/utils.js.map
deleted file mode 100644
index 8f2f6e3..0000000
--- a/node_modules/@metamask/transaction-controller/dist/utils.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"utils.js","sourceRoot":"","sources":["../src/utils.ts"],"names":[],"mappings":"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","sourcesContent":["import { addHexPrefix, isHexString } from 'ethereumjs-util';\nimport {\n  NetworkType,\n  convertHexToDecimal,\n  handleFetch,\n  isValidHexAddress,\n} from '@metamask/controller-utils';\nimport type { Transaction as NonceTrackerTransaction } from 'nonce-tracker/dist/NonceTracker';\nimport {\n  Transaction,\n  FetchAllOptions,\n  GasPriceValue,\n  FeeMarketEIP1559Values,\n  TransactionStatus,\n} from './TransactionController';\nimport type { TransactionMeta } from './TransactionController';\n\nexport const ESTIMATE_GAS_ERROR = 'eth_estimateGas rpc method error';\n\nconst NORMALIZERS: { [param in keyof Transaction]: any } = {\n  data: (data: string) => addHexPrefix(data),\n  from: (from: string) => addHexPrefix(from).toLowerCase(),\n  gas: (gas: string) => addHexPrefix(gas),\n  gasPrice: (gasPrice: string) => addHexPrefix(gasPrice),\n  nonce: (nonce: string) => addHexPrefix(nonce),\n  to: (to: string) => addHexPrefix(to).toLowerCase(),\n  value: (value: string) => addHexPrefix(value),\n  maxFeePerGas: (maxFeePerGas: string) => addHexPrefix(maxFeePerGas),\n  maxPriorityFeePerGas: (maxPriorityFeePerGas: string) =>\n    addHexPrefix(maxPriorityFeePerGas),\n  estimatedBaseFee: (maxPriorityFeePerGas: string) =>\n    addHexPrefix(maxPriorityFeePerGas),\n};\n\n/**\n * Return a URL that can be used to fetch ETH transactions.\n *\n * @param networkType - Network type of desired network.\n * @param urlParams - The parameters used to construct the URL.\n * @returns URL to fetch the access the endpoint.\n */\nexport function getEtherscanApiUrl(\n  networkType: string,\n  urlParams: any,\n): string {\n  let etherscanSubdomain = 'api';\n  if (networkType !== NetworkType.mainnet) {\n    etherscanSubdomain = `api-${networkType}`;\n  }\n  const apiUrl = `https://${etherscanSubdomain}.etherscan.io`;\n  let url = `${apiUrl}/api?`;\n\n  for (const paramKey in urlParams) {\n    if (urlParams[paramKey]) {\n      url += `${paramKey}=${urlParams[paramKey]}&`;\n    }\n  }\n  url += 'tag=latest&page=1';\n  return url;\n}\n\n/**\n * Normalizes properties on a Transaction object.\n *\n * @param transaction - Transaction object to normalize.\n * @returns Normalized Transaction object.\n */\nexport function normalizeTransaction(transaction: Transaction) {\n  const normalizedTransaction: Transaction = { from: '' };\n  let key: keyof Transaction;\n  for (key in NORMALIZERS) {\n    if (transaction[key as keyof Transaction]) {\n      normalizedTransaction[key] = NORMALIZERS[key](transaction[key]) as never;\n    }\n  }\n  return normalizedTransaction;\n}\n\n/**\n * Validates a Transaction object for required properties and throws in\n * the event of any validation error.\n *\n * @param transaction - Transaction object to validate.\n */\nexport function validateTransaction(transaction: Transaction) {\n  if (\n    !transaction.from ||\n    typeof transaction.from !== 'string' ||\n    !isValidHexAddress(transaction.from)\n  ) {\n    throw new Error(\n      `Invalid \"from\" address: ${transaction.from} must be a valid string.`,\n    );\n  }\n\n  if (transaction.to === '0x' || transaction.to === undefined) {\n    if (transaction.data) {\n      delete transaction.to;\n    } else {\n      throw new Error(\n        `Invalid \"to\" address: ${transaction.to} must be a valid string.`,\n      );\n    }\n  } else if (\n    transaction.to !== undefined &&\n    !isValidHexAddress(transaction.to)\n  ) {\n    throw new Error(\n      `Invalid \"to\" address: ${transaction.to} must be a valid string.`,\n    );\n  }\n\n  if (transaction.value !== undefined) {\n    const value = transaction.value.toString();\n    if (value.includes('-')) {\n      throw new Error(`Invalid \"value\": ${value} is not a positive number.`);\n    }\n\n    if (value.includes('.')) {\n      throw new Error(\n        `Invalid \"value\": ${value} number must be denominated in wei.`,\n      );\n    }\n    const intValue = parseInt(transaction.value, 10);\n    const isValid =\n      Number.isFinite(intValue) &&\n      !Number.isNaN(intValue) &&\n      !isNaN(Number(value)) &&\n      Number.isSafeInteger(intValue);\n    if (!isValid) {\n      throw new Error(\n        `Invalid \"value\": ${value} number must be a valid number.`,\n      );\n    }\n  }\n}\n\n/**\n * Checks if a transaction is EIP-1559 by checking for the existence of\n * maxFeePerGas and maxPriorityFeePerGas within its parameters.\n *\n * @param transaction - Transaction object to add.\n * @returns Boolean that is true if the transaction is EIP-1559 (has maxFeePerGas and maxPriorityFeePerGas), otherwise returns false.\n */\nexport const isEIP1559Transaction = (transaction: Transaction): boolean => {\n  const hasOwnProp = (obj: Transaction, key: string) =>\n    Object.prototype.hasOwnProperty.call(obj, key);\n  return (\n    hasOwnProp(transaction, 'maxFeePerGas') &&\n    hasOwnProp(transaction, 'maxPriorityFeePerGas')\n  );\n};\n\n/**\n * Handles the fetch of incoming transactions.\n *\n * @param networkType - Network type of desired network.\n * @param address - Address to get the transactions from.\n * @param txHistoryLimit - The maximum number of transactions to fetch.\n * @param opt - Object that can contain fromBlock and Etherscan service API key.\n * @returns Responses for both ETH and ERC20 token transactions.\n */\nexport async function handleTransactionFetch(\n  networkType: string,\n  address: string,\n  txHistoryLimit: number,\n  opt?: FetchAllOptions,\n): Promise<[{ [result: string]: [] }, { [result: string]: [] }]> {\n  // transactions\n  const urlParams = {\n    module: 'account',\n    address,\n    startBlock: opt?.fromBlock,\n    apikey: opt?.etherscanApiKey,\n    offset: txHistoryLimit.toString(),\n    order: 'desc',\n  };\n  const etherscanTxUrl = getEtherscanApiUrl(networkType, {\n    ...urlParams,\n    action: 'txlist',\n  });\n  const etherscanTxResponsePromise = handleFetch(etherscanTxUrl);\n\n  // tokens\n  const etherscanTokenUrl = getEtherscanApiUrl(networkType, {\n    ...urlParams,\n    action: 'tokentx',\n  });\n  const etherscanTokenResponsePromise = handleFetch(etherscanTokenUrl);\n\n  let [etherscanTxResponse, etherscanTokenResponse] = await Promise.all([\n    etherscanTxResponsePromise,\n    etherscanTokenResponsePromise,\n  ]);\n\n  if (\n    etherscanTxResponse.status === '0' ||\n    etherscanTxResponse.result.length <= 0\n  ) {\n    etherscanTxResponse = { status: etherscanTxResponse.status, result: [] };\n  }\n\n  if (\n    etherscanTokenResponse.status === '0' ||\n    etherscanTokenResponse.result.length <= 0\n  ) {\n    etherscanTokenResponse = {\n      status: etherscanTokenResponse.status,\n      result: [],\n    };\n  }\n\n  return [etherscanTxResponse, etherscanTokenResponse];\n}\n\nexport const validateGasValues = (\n  gasValues: GasPriceValue | FeeMarketEIP1559Values,\n) => {\n  Object.keys(gasValues).forEach((key) => {\n    const value = (gasValues as any)[key];\n    if (typeof value !== 'string' || !isHexString(value)) {\n      throw new TypeError(\n        `expected hex string for ${key} but received: ${value}`,\n      );\n    }\n  });\n};\n\nexport const isFeeMarketEIP1559Values = (\n  gasValues?: GasPriceValue | FeeMarketEIP1559Values,\n): gasValues is FeeMarketEIP1559Values =>\n  (gasValues as FeeMarketEIP1559Values)?.maxFeePerGas !== undefined ||\n  (gasValues as FeeMarketEIP1559Values)?.maxPriorityFeePerGas !== undefined;\n\nexport const isGasPriceValue = (\n  gasValues?: GasPriceValue | FeeMarketEIP1559Values,\n): gasValues is GasPriceValue =>\n  (gasValues as GasPriceValue)?.gasPrice !== undefined;\n\nexport const getIncreasedPriceHex = (value: number, rate: number): string =>\n  addHexPrefix(`${parseInt(`${value * rate}`, 10).toString(16)}`);\n\nexport const getIncreasedPriceFromExisting = (\n  value: string | undefined,\n  rate: number,\n): string => {\n  return getIncreasedPriceHex(convertHexToDecimal(value), rate);\n};\n\n/**\n * Validates that the proposed value is greater than or equal to the minimum value.\n *\n * @param proposed - The proposed value.\n * @param min - The minimum value.\n * @returns The proposed value.\n * @throws Will throw if the proposed value is too low.\n */\nexport function validateMinimumIncrease(proposed: string, min: string) {\n  const proposedDecimal = convertHexToDecimal(proposed);\n  const minDecimal = convertHexToDecimal(min);\n  if (proposedDecimal >= minDecimal) {\n    return proposed;\n  }\n  const errorMsg = `The proposed value: ${proposedDecimal} should meet or exceed the minimum value: ${minDecimal}`;\n  throw new Error(errorMsg);\n}\n\n/**\n * Helper function to filter and format transactions for the nonce tracker.\n *\n * @param fromAddress - Address of the account from which the transactions to filter from are sent.\n * @param transactionStatus - Status of the transactions for which to filter.\n * @param transactions - Array of transactionMeta objects that have been prefiltered.\n * @returns Array of transactions formatted for the nonce tracker.\n */\nexport function getAndFormatTransactionsForNonceTracker(\n  fromAddress: string,\n  transactionStatus: TransactionStatus,\n  transactions: TransactionMeta[],\n): NonceTrackerTransaction[] {\n  return transactions\n    .filter(\n      ({ status, transaction: { from } }) =>\n        status === transactionStatus &&\n        from.toLowerCase() === fromAddress.toLowerCase(),\n    )\n    .map(({ status, transaction: { from, gas, value, nonce } }) => {\n      // the only value we care about is the nonce\n      // but we need to return the other values to satisfy the type\n      // TODO: refactor nonceTracker to not require this\n      return {\n        status,\n        history: [{}],\n        txParams: {\n          from: from ?? '',\n          gas: gas ?? '',\n          value: value ?? '',\n          nonce: nonce ?? '',\n        },\n      };\n    });\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/etherscan.d.ts b/node_modules/@metamask/transaction-controller/dist/utils/etherscan.d.ts
new file mode 100644
index 0000000..4a63542
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/etherscan.d.ts
@@ -0,0 +1,64 @@
+import type { Hex } from '@metamask/utils';
+export interface EtherscanTransactionMetaBase {
+    blockNumber: string;
+    blockHash: string;
+    confirmations: string;
+    contractAddress: string;
+    cumulativeGasUsed: string;
+    from: string;
+    gas: string;
+    gasPrice: string;
+    gasUsed: string;
+    hash: string;
+    nonce: string;
+    timeStamp: string;
+    to: string;
+    transactionIndex: string;
+    value: string;
+}
+export interface EtherscanTransactionMeta extends EtherscanTransactionMetaBase {
+    functionName: string;
+    input: string;
+    isError: string;
+    methodId: string;
+    txreceipt_status: string;
+}
+export interface EtherscanTokenTransactionMeta extends EtherscanTransactionMetaBase {
+    tokenDecimal: string;
+    tokenName: string;
+    tokenSymbol: string;
+}
+export interface EtherscanTransactionResponse<T extends EtherscanTransactionMetaBase> {
+    status: '0' | '1';
+    message?: string;
+    result: string | T[];
+}
+export interface EtherscanTransactionRequest {
+    address: string;
+    chainId: Hex;
+    fromBlock?: number;
+    limit?: number;
+}
+/**
+ * Retrieves transaction data from Etherscan.
+ *
+ * @param request - Configuration required to fetch transactions.
+ * @param request.address - Address to retrieve transactions for.
+ * @param request.chainId - Current chain ID used to determine subdomain and domain.
+ * @param request.fromBlock - Block number to start fetching transactions from.
+ * @param request.limit - Number of transactions to retrieve.
+ * @returns An Etherscan response object containing the request status and an array of token transaction data.
+ */
+export declare function fetchEtherscanTransactions({ address, chainId, fromBlock, limit, }: EtherscanTransactionRequest): Promise<EtherscanTransactionResponse<EtherscanTransactionMeta>>;
+/**
+ * Retrieves token transaction data from Etherscan.
+ *
+ * @param request - Configuration required to fetch token transactions.
+ * @param request.address - Address to retrieve token transactions for.
+ * @param request.chainId - Current chain ID used to determine subdomain and domain.
+ * @param request.fromBlock - Block number to start fetching token transactions from.
+ * @param request.limit - Number of token transactions to retrieve.
+ * @returns An Etherscan response object containing the request status and an array of token transaction data.
+ */
+export declare function fetchEtherscanTokenTransactions({ address, chainId, fromBlock, limit, }: EtherscanTransactionRequest): Promise<EtherscanTransactionResponse<EtherscanTokenTransactionMeta>>;
+//# sourceMappingURL=etherscan.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/etherscan.d.ts.map b/node_modules/@metamask/transaction-controller/dist/utils/etherscan.d.ts.map
new file mode 100644
index 0000000..bde0ec8
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/etherscan.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"etherscan.d.ts","sourceRoot":"","sources":["../../src/utils/etherscan.ts"],"names":[],"mappings":"AACA,OAAO,KAAK,EAAE,GAAG,EAAE,MAAM,iBAAiB,CAAC;AAQ3C,MAAM,WAAW,4BAA4B;IAC3C,WAAW,EAAE,MAAM,CAAC;IACpB,SAAS,EAAE,MAAM,CAAC;IAClB,aAAa,EAAE,MAAM,CAAC;IACtB,eAAe,EAAE,MAAM,CAAC;IACxB,iBAAiB,EAAE,MAAM,CAAC;IAC1B,IAAI,EAAE,MAAM,CAAC;IACb,GAAG,EAAE,MAAM,CAAC;IACZ,QAAQ,EAAE,MAAM,CAAC;IACjB,OAAO,EAAE,MAAM,CAAC;IAChB,IAAI,EAAE,MAAM,CAAC;IACb,KAAK,EAAE,MAAM,CAAC;IACd,SAAS,EAAE,MAAM,CAAC;IAClB,EAAE,EAAE,MAAM,CAAC;IACX,gBAAgB,EAAE,MAAM,CAAC;IACzB,KAAK,EAAE,MAAM,CAAC;CACf;AAKD,MAAM,WAAW,wBAAyB,SAAQ,4BAA4B;IAC5E,YAAY,EAAE,MAAM,CAAC;IACrB,KAAK,EAAE,MAAM,CAAC;IACd,OAAO,EAAE,MAAM,CAAC;IAChB,QAAQ,EAAE,MAAM,CAAC;IACjB,gBAAgB,EAAE,MAAM,CAAC;CAC1B;AAKD,MAAM,WAAW,6BACf,SAAQ,4BAA4B;IACpC,YAAY,EAAE,MAAM,CAAC;IACrB,SAAS,EAAE,MAAM,CAAC;IAClB,WAAW,EAAE,MAAM,CAAC;CACrB;AAKD,MAAM,WAAW,4BAA4B,CAC3C,CAAC,SAAS,4BAA4B;IAEtC,MAAM,EAAE,GAAG,GAAG,GAAG,CAAC;IAClB,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB,MAAM,EAAE,MAAM,GAAG,CAAC,EAAE,CAAC;CACtB;AAKD,MAAM,WAAW,2BAA2B;IAC1C,OAAO,EAAE,MAAM,CAAC;IAChB,OAAO,EAAE,GAAG,CAAC;IACb,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,KAAK,CAAC,EAAE,MAAM,CAAC;CAChB;AAED;;;;;;;;;GASG;AACH,wBAAsB,0BAA0B,CAAC,EAC/C,OAAO,EACP,OAAO,EACP,SAAS,EACT,KAAK,GACN,EAAE,2BAA2B,GAAG,OAAO,CACtC,4BAA4B,CAAC,wBAAwB,CAAC,CACvD,CAOA;AAED;;;;;;;;;GASG;AACH,wBAAsB,+BAA+B,CAAC,EACpD,OAAO,EACP,OAAO,EACP,SAAS,EACT,KAAK,GACN,EAAE,2BAA2B,GAAG,OAAO,CACtC,4BAA4B,CAAC,6BAA6B,CAAC,CAC5D,CAOA"}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/etherscan.js b/node_modules/@metamask/transaction-controller/dist/utils/etherscan.js
new file mode 100644
index 0000000..7932542
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/etherscan.js
@@ -0,0 +1,108 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.fetchEtherscanTokenTransactions = exports.fetchEtherscanTransactions = void 0;
+const controller_utils_1 = require("@metamask/controller-utils");
+const constants_1 = require("../constants");
+const logger_1 = require("../logger");
+/**
+ * Retrieves transaction data from Etherscan.
+ *
+ * @param request - Configuration required to fetch transactions.
+ * @param request.address - Address to retrieve transactions for.
+ * @param request.chainId - Current chain ID used to determine subdomain and domain.
+ * @param request.fromBlock - Block number to start fetching transactions from.
+ * @param request.limit - Number of transactions to retrieve.
+ * @returns An Etherscan response object containing the request status and an array of token transaction data.
+ */
+function fetchEtherscanTransactions({ address, chainId, fromBlock, limit, }) {
+    return __awaiter(this, void 0, void 0, function* () {
+        return yield fetchTransactions('txlist', {
+            address,
+            chainId,
+            fromBlock,
+            limit,
+        });
+    });
+}
+exports.fetchEtherscanTransactions = fetchEtherscanTransactions;
+/**
+ * Retrieves token transaction data from Etherscan.
+ *
+ * @param request - Configuration required to fetch token transactions.
+ * @param request.address - Address to retrieve token transactions for.
+ * @param request.chainId - Current chain ID used to determine subdomain and domain.
+ * @param request.fromBlock - Block number to start fetching token transactions from.
+ * @param request.limit - Number of token transactions to retrieve.
+ * @returns An Etherscan response object containing the request status and an array of token transaction data.
+ */
+function fetchEtherscanTokenTransactions({ address, chainId, fromBlock, limit, }) {
+    return __awaiter(this, void 0, void 0, function* () {
+        return yield fetchTransactions('tokentx', {
+            address,
+            chainId,
+            fromBlock,
+            limit,
+        });
+    });
+}
+exports.fetchEtherscanTokenTransactions = fetchEtherscanTokenTransactions;
+/**
+ * Retrieves transaction data from Etherscan from a specific endpoint.
+ *
+ * @param action - The Etherscan endpoint to use.
+ * @param options - Options bag.
+ * @param options.address - Address to retrieve transactions for.
+ * @param options.chainId - Current chain ID used to determine subdomain and domain.
+ * @param options.fromBlock - Block number to start fetching transactions from.
+ * @param options.limit - Number of transactions to retrieve.
+ * @returns An object containing the request status and an array of transaction data.
+ */
+function fetchTransactions(action, { address, chainId, fromBlock, limit, }) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const urlParams = {
+            module: 'account',
+            address,
+            startBlock: fromBlock === null || fromBlock === void 0 ? void 0 : fromBlock.toString(),
+            offset: limit === null || limit === void 0 ? void 0 : limit.toString(),
+            sort: 'desc',
+        };
+        const etherscanTxUrl = getEtherscanApiUrl(chainId, Object.assign(Object.assign({}, urlParams), { action }));
+        (0, logger_1.incomingTransactionsLogger)('Sending Etherscan request', etherscanTxUrl);
+        const response = (yield (0, controller_utils_1.handleFetch)(etherscanTxUrl));
+        return response;
+    });
+}
+/**
+ * Return a URL that can be used to fetch data from Etherscan.
+ *
+ * @param chainId - Current chain ID used to determine subdomain and domain.
+ * @param urlParams - The parameters used to construct the URL.
+ * @returns URL to access Etherscan data.
+ */
+function getEtherscanApiUrl(chainId, urlParams) {
+    const networkInfo = constants_1.ETHERSCAN_SUPPORTED_NETWORKS[chainId];
+    if (!networkInfo) {
+        throw new Error(`Etherscan does not support chain with ID: ${chainId}`);
+    }
+    const apiUrl = `https://${networkInfo.subdomain}.${networkInfo.domain}`;
+    let url = `${apiUrl}/api?`;
+    for (const paramKey of Object.keys(urlParams)) {
+        const value = urlParams[paramKey];
+        if (!value) {
+            continue;
+        }
+        url += `${paramKey}=${value}&`;
+    }
+    url += 'tag=latest&page=1';
+    return url;
+}
+//# sourceMappingURL=etherscan.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/etherscan.js.map b/node_modules/@metamask/transaction-controller/dist/utils/etherscan.js.map
new file mode 100644
index 0000000..b38f825
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/etherscan.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"etherscan.js","sourceRoot":"","sources":["../../src/utils/etherscan.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,iEAAyD;AAGzD,4CAA4D;AAC5D,sCAA8D;AAiE9D;;;;;;;;;GASG;AACH,SAAsB,0BAA0B,CAAC,EAC/C,OAAO,EACP,OAAO,EACP,SAAS,EACT,KAAK,GACuB;;QAG5B,OAAO,MAAM,iBAAiB,CAAC,QAAQ,EAAE;YACvC,OAAO;YACP,OAAO;YACP,SAAS;YACT,KAAK;SACN,CAAC,CAAC;IACL,CAAC;CAAA;AAdD,gEAcC;AAED;;;;;;;;;GASG;AACH,SAAsB,+BAA+B,CAAC,EACpD,OAAO,EACP,OAAO,EACP,SAAS,EACT,KAAK,GACuB;;QAG5B,OAAO,MAAM,iBAAiB,CAAC,SAAS,EAAE;YACxC,OAAO;YACP,OAAO;YACP,SAAS;YACT,KAAK;SACN,CAAC,CAAC;IACL,CAAC;CAAA;AAdD,0EAcC;AAED;;;;;;;;;;GAUG;AACH,SAAe,iBAAiB,CAC9B,MAAc,EACd,EACE,OAAO,EACP,OAAO,EACP,SAAS,EACT,KAAK,GAMN;;QAED,MAAM,SAAS,GAAG;YAChB,MAAM,EAAE,SAAS;YACjB,OAAO;YACP,UAAU,EAAE,SAAS,aAAT,SAAS,uBAAT,SAAS,CAAE,QAAQ,EAAE;YACjC,MAAM,EAAE,KAAK,aAAL,KAAK,uBAAL,KAAK,CAAE,QAAQ,EAAE;YACzB,IAAI,EAAE,MAAM;SACb,CAAC;QAEF,MAAM,cAAc,GAAG,kBAAkB,CAAC,OAAO,kCAC5C,SAAS,KACZ,MAAM,IACN,CAAC;QAEH,IAAA,mCAAG,EAAC,2BAA2B,EAAE,cAAc,CAAC,CAAC;QAEjD,MAAM,QAAQ,GAAG,CAAC,MAAM,IAAA,8BAAW,EACjC,cAAc,CACf,CAAoC,CAAC;QAEtC,OAAO,QAAQ,CAAC;IAClB,CAAC;CAAA;AAED;;;;;;GAMG;AACH,SAAS,kBAAkB,CACzB,OAAY,EACZ,SAA6C;IAI7C,MAAM,WAAW,GAAG,wCAA4B,CAAC,OAA2B,CAAC,CAAC;IAE9E,IAAI,CAAC,WAAW,EAAE;QAChB,MAAM,IAAI,KAAK,CAAC,6CAA6C,OAAO,EAAE,CAAC,CAAC;KACzE;IAED,MAAM,MAAM,GAAG,WAAW,WAAW,CAAC,SAAS,IAAI,WAAW,CAAC,MAAM,EAAE,CAAC;IACxE,IAAI,GAAG,GAAG,GAAG,MAAM,OAAO,CAAC;IAE3B,KAAK,MAAM,QAAQ,IAAI,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE;QAC7C,MAAM,KAAK,GAAG,SAAS,CAAC,QAAQ,CAAC,CAAC;QAElC,IAAI,CAAC,KAAK,EAAE;YACV,SAAS;SACV;QAED,GAAG,IAAI,GAAG,QAAQ,IAAI,KAAK,GAAG,CAAC;KAChC;IAED,GAAG,IAAI,mBAAmB,CAAC;IAE3B,OAAO,GAAG,CAAC;AACb,CAAC","sourcesContent":["import { handleFetch } from '@metamask/controller-utils';\nimport type { Hex } from '@metamask/utils';\n\nimport { ETHERSCAN_SUPPORTED_NETWORKS } from '../constants';\nimport { incomingTransactionsLogger as log } from '../logger';\n\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface EtherscanTransactionMetaBase {\n  blockNumber: string;\n  blockHash: string;\n  confirmations: string;\n  contractAddress: string;\n  cumulativeGasUsed: string;\n  from: string;\n  gas: string;\n  gasPrice: string;\n  gasUsed: string;\n  hash: string;\n  nonce: string;\n  timeStamp: string;\n  to: string;\n  transactionIndex: string;\n  value: string;\n}\n\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface EtherscanTransactionMeta extends EtherscanTransactionMetaBase {\n  functionName: string;\n  input: string;\n  isError: string;\n  methodId: string;\n  txreceipt_status: string;\n}\n\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface EtherscanTokenTransactionMeta\n  extends EtherscanTransactionMetaBase {\n  tokenDecimal: string;\n  tokenName: string;\n  tokenSymbol: string;\n}\n\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface EtherscanTransactionResponse<\n  T extends EtherscanTransactionMetaBase,\n> {\n  status: '0' | '1';\n  message?: string;\n  result: string | T[];\n}\n\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface EtherscanTransactionRequest {\n  address: string;\n  chainId: Hex;\n  fromBlock?: number;\n  limit?: number;\n}\n\n/**\n * Retrieves transaction data from Etherscan.\n *\n * @param request - Configuration required to fetch transactions.\n * @param request.address - Address to retrieve transactions for.\n * @param request.chainId - Current chain ID used to determine subdomain and domain.\n * @param request.fromBlock - Block number to start fetching transactions from.\n * @param request.limit - Number of transactions to retrieve.\n * @returns An Etherscan response object containing the request status and an array of token transaction data.\n */\nexport async function fetchEtherscanTransactions({\n  address,\n  chainId,\n  fromBlock,\n  limit,\n}: EtherscanTransactionRequest): Promise<\n  EtherscanTransactionResponse<EtherscanTransactionMeta>\n> {\n  return await fetchTransactions('txlist', {\n    address,\n    chainId,\n    fromBlock,\n    limit,\n  });\n}\n\n/**\n * Retrieves token transaction data from Etherscan.\n *\n * @param request - Configuration required to fetch token transactions.\n * @param request.address - Address to retrieve token transactions for.\n * @param request.chainId - Current chain ID used to determine subdomain and domain.\n * @param request.fromBlock - Block number to start fetching token transactions from.\n * @param request.limit - Number of token transactions to retrieve.\n * @returns An Etherscan response object containing the request status and an array of token transaction data.\n */\nexport async function fetchEtherscanTokenTransactions({\n  address,\n  chainId,\n  fromBlock,\n  limit,\n}: EtherscanTransactionRequest): Promise<\n  EtherscanTransactionResponse<EtherscanTokenTransactionMeta>\n> {\n  return await fetchTransactions('tokentx', {\n    address,\n    chainId,\n    fromBlock,\n    limit,\n  });\n}\n\n/**\n * Retrieves transaction data from Etherscan from a specific endpoint.\n *\n * @param action - The Etherscan endpoint to use.\n * @param options - Options bag.\n * @param options.address - Address to retrieve transactions for.\n * @param options.chainId - Current chain ID used to determine subdomain and domain.\n * @param options.fromBlock - Block number to start fetching transactions from.\n * @param options.limit - Number of transactions to retrieve.\n * @returns An object containing the request status and an array of transaction data.\n */\nasync function fetchTransactions<T extends EtherscanTransactionMetaBase>(\n  action: string,\n  {\n    address,\n    chainId,\n    fromBlock,\n    limit,\n  }: {\n    address: string;\n    chainId: Hex;\n    fromBlock?: number;\n    limit?: number;\n  },\n): Promise<EtherscanTransactionResponse<T>> {\n  const urlParams = {\n    module: 'account',\n    address,\n    startBlock: fromBlock?.toString(),\n    offset: limit?.toString(),\n    sort: 'desc',\n  };\n\n  const etherscanTxUrl = getEtherscanApiUrl(chainId, {\n    ...urlParams,\n    action,\n  });\n\n  log('Sending Etherscan request', etherscanTxUrl);\n\n  const response = (await handleFetch(\n    etherscanTxUrl,\n  )) as EtherscanTransactionResponse<T>;\n\n  return response;\n}\n\n/**\n * Return a URL that can be used to fetch data from Etherscan.\n *\n * @param chainId - Current chain ID used to determine subdomain and domain.\n * @param urlParams - The parameters used to construct the URL.\n * @returns URL to access Etherscan data.\n */\nfunction getEtherscanApiUrl(\n  chainId: Hex,\n  urlParams: Record<string, string | undefined>,\n): string {\n  type SupportedChainId = keyof typeof ETHERSCAN_SUPPORTED_NETWORKS;\n\n  const networkInfo = ETHERSCAN_SUPPORTED_NETWORKS[chainId as SupportedChainId];\n\n  if (!networkInfo) {\n    throw new Error(`Etherscan does not support chain with ID: ${chainId}`);\n  }\n\n  const apiUrl = `https://${networkInfo.subdomain}.${networkInfo.domain}`;\n  let url = `${apiUrl}/api?`;\n\n  for (const paramKey of Object.keys(urlParams)) {\n    const value = urlParams[paramKey];\n\n    if (!value) {\n      continue;\n    }\n\n    url += `${paramKey}=${value}&`;\n  }\n\n  url += 'tag=latest&page=1';\n\n  return url;\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/external-transactions.d.ts b/node_modules/@metamask/transaction-controller/dist/utils/external-transactions.d.ts
new file mode 100644
index 0000000..04efc8e
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/external-transactions.d.ts
@@ -0,0 +1,10 @@
+import type { TransactionMeta } from '../types';
+/**
+ * Validates the external provided transaction meta.
+ *
+ * @param transactionMeta - The transaction meta to validate.
+ * @param confirmedTxs - The confirmed transactions in controller state.
+ * @param pendingTxs - The submitted transactions in controller state.
+ */
+export declare function validateConfirmedExternalTransaction(transactionMeta?: TransactionMeta, confirmedTxs?: TransactionMeta[], pendingTxs?: TransactionMeta[]): void;
+//# sourceMappingURL=external-transactions.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/external-transactions.d.ts.map b/node_modules/@metamask/transaction-controller/dist/utils/external-transactions.d.ts.map
new file mode 100644
index 0000000..fe57dc6
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/external-transactions.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"external-transactions.d.ts","sourceRoot":"","sources":["../../src/utils/external-transactions.ts"],"names":[],"mappings":"AAIA,OAAO,KAAK,EAAE,eAAe,EAAE,MAAM,UAAU,CAAC;AAEhD;;;;;;GAMG;AACH,wBAAgB,oCAAoC,CAClD,eAAe,CAAC,EAAE,eAAe,EACjC,YAAY,CAAC,EAAE,eAAe,EAAE,EAChC,UAAU,CAAC,EAAE,eAAe,EAAE,QAoC/B"}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/external-transactions.js b/node_modules/@metamask/transaction-controller/dist/utils/external-transactions.js
new file mode 100644
index 0000000..415eaf9
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/external-transactions.js
@@ -0,0 +1,36 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.validateConfirmedExternalTransaction = void 0;
+// These utility functions are exclusively used by `confirmExternalTransaction` method in controller
+const rpc_errors_1 = require("@metamask/rpc-errors");
+const types_1 = require("../types");
+/**
+ * Validates the external provided transaction meta.
+ *
+ * @param transactionMeta - The transaction meta to validate.
+ * @param confirmedTxs - The confirmed transactions in controller state.
+ * @param pendingTxs - The submitted transactions in controller state.
+ */
+function validateConfirmedExternalTransaction(transactionMeta, confirmedTxs, pendingTxs) {
+    if (!transactionMeta || !transactionMeta.txParams) {
+        throw rpc_errors_1.rpcErrors.invalidParams('"transactionMeta" or "transactionMeta.txParams" is missing');
+    }
+    if (transactionMeta.status !== types_1.TransactionStatus.confirmed) {
+        throw rpc_errors_1.rpcErrors.invalidParams('External transaction status should be "confirmed"');
+    }
+    const externalTxNonce = transactionMeta.txParams.nonce;
+    if (pendingTxs && pendingTxs.length > 0) {
+        const foundPendingTxByNonce = pendingTxs.find((tx) => { var _a; return ((_a = tx.txParams) === null || _a === void 0 ? void 0 : _a.nonce) === externalTxNonce; });
+        if (foundPendingTxByNonce) {
+            throw rpc_errors_1.rpcErrors.invalidParams('External transaction nonce should not be in pending txs');
+        }
+    }
+    if (confirmedTxs && confirmedTxs.length > 0) {
+        const foundConfirmedTxByNonce = confirmedTxs.find((tx) => { var _a; return ((_a = tx.txParams) === null || _a === void 0 ? void 0 : _a.nonce) === externalTxNonce; });
+        if (foundConfirmedTxByNonce) {
+            throw rpc_errors_1.rpcErrors.invalidParams('External transaction nonce should not be in confirmed txs');
+        }
+    }
+}
+exports.validateConfirmedExternalTransaction = validateConfirmedExternalTransaction;
+//# sourceMappingURL=external-transactions.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/external-transactions.js.map b/node_modules/@metamask/transaction-controller/dist/utils/external-transactions.js.map
new file mode 100644
index 0000000..c0d7d83
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/external-transactions.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"external-transactions.js","sourceRoot":"","sources":["../../src/utils/external-transactions.ts"],"names":[],"mappings":";;;AAAA,oGAAoG;AACpG,qDAAiD;AAEjD,oCAA6C;AAG7C;;;;;;GAMG;AACH,SAAgB,oCAAoC,CAClD,eAAiC,EACjC,YAAgC,EAChC,UAA8B;IAE9B,IAAI,CAAC,eAAe,IAAI,CAAC,eAAe,CAAC,QAAQ,EAAE;QACjD,MAAM,sBAAS,CAAC,aAAa,CAC3B,4DAA4D,CAC7D,CAAC;KACH;IAED,IAAI,eAAe,CAAC,MAAM,KAAK,yBAAiB,CAAC,SAAS,EAAE;QAC1D,MAAM,sBAAS,CAAC,aAAa,CAC3B,mDAAmD,CACpD,CAAC;KACH;IAED,MAAM,eAAe,GAAG,eAAe,CAAC,QAAQ,CAAC,KAAK,CAAC;IACvD,IAAI,UAAU,IAAI,UAAU,CAAC,MAAM,GAAG,CAAC,EAAE;QACvC,MAAM,qBAAqB,GAAG,UAAU,CAAC,IAAI,CAC3C,CAAC,EAAE,EAAE,EAAE,WAAC,OAAA,CAAA,MAAA,EAAE,CAAC,QAAQ,0CAAE,KAAK,MAAK,eAAe,CAAA,EAAA,CAC/C,CAAC;QACF,IAAI,qBAAqB,EAAE;YACzB,MAAM,sBAAS,CAAC,aAAa,CAC3B,yDAAyD,CAC1D,CAAC;SACH;KACF;IAED,IAAI,YAAY,IAAI,YAAY,CAAC,MAAM,GAAG,CAAC,EAAE;QAC3C,MAAM,uBAAuB,GAAG,YAAY,CAAC,IAAI,CAC/C,CAAC,EAAE,EAAE,EAAE,WAAC,OAAA,CAAA,MAAA,EAAE,CAAC,QAAQ,0CAAE,KAAK,MAAK,eAAe,CAAA,EAAA,CAC/C,CAAC;QACF,IAAI,uBAAuB,EAAE;YAC3B,MAAM,sBAAS,CAAC,aAAa,CAC3B,2DAA2D,CAC5D,CAAC;SACH;KACF;AACH,CAAC;AAvCD,oFAuCC","sourcesContent":["// These utility functions are exclusively used by `confirmExternalTransaction` method in controller\nimport { rpcErrors } from '@metamask/rpc-errors';\n\nimport { TransactionStatus } from '../types';\nimport type { TransactionMeta } from '../types';\n\n/**\n * Validates the external provided transaction meta.\n *\n * @param transactionMeta - The transaction meta to validate.\n * @param confirmedTxs - The confirmed transactions in controller state.\n * @param pendingTxs - The submitted transactions in controller state.\n */\nexport function validateConfirmedExternalTransaction(\n  transactionMeta?: TransactionMeta,\n  confirmedTxs?: TransactionMeta[],\n  pendingTxs?: TransactionMeta[],\n) {\n  if (!transactionMeta || !transactionMeta.txParams) {\n    throw rpcErrors.invalidParams(\n      '\"transactionMeta\" or \"transactionMeta.txParams\" is missing',\n    );\n  }\n\n  if (transactionMeta.status !== TransactionStatus.confirmed) {\n    throw rpcErrors.invalidParams(\n      'External transaction status should be \"confirmed\"',\n    );\n  }\n\n  const externalTxNonce = transactionMeta.txParams.nonce;\n  if (pendingTxs && pendingTxs.length > 0) {\n    const foundPendingTxByNonce = pendingTxs.find(\n      (tx) => tx.txParams?.nonce === externalTxNonce,\n    );\n    if (foundPendingTxByNonce) {\n      throw rpcErrors.invalidParams(\n        'External transaction nonce should not be in pending txs',\n      );\n    }\n  }\n\n  if (confirmedTxs && confirmedTxs.length > 0) {\n    const foundConfirmedTxByNonce = confirmedTxs.find(\n      (tx) => tx.txParams?.nonce === externalTxNonce,\n    );\n    if (foundConfirmedTxByNonce) {\n      throw rpcErrors.invalidParams(\n        'External transaction nonce should not be in confirmed txs',\n      );\n    }\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/gas-fees.d.ts b/node_modules/@metamask/transaction-controller/dist/utils/gas-fees.d.ts
new file mode 100644
index 0000000..9ed9fdd
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/gas-fees.d.ts
@@ -0,0 +1,31 @@
+import type EthQuery from '@metamask/eth-query';
+import type { GasFeeState } from '@metamask/gas-fee-controller';
+import type { SavedGasFees, TransactionParams, TransactionMeta } from '../types';
+export declare type UpdateGasFeesRequest = {
+    eip1559: boolean;
+    ethQuery: EthQuery;
+    getSavedGasFees: () => SavedGasFees | undefined;
+    getGasFeeEstimates: () => Promise<GasFeeState>;
+    txMeta: TransactionMeta;
+};
+export declare type GetGasFeeRequest = UpdateGasFeesRequest & {
+    savedGasFees?: SavedGasFees;
+    initialParams: TransactionParams;
+    suggestedGasFees: Awaited<ReturnType<typeof getSuggestedGasFees>>;
+};
+export declare function updateGasFees(request: UpdateGasFeesRequest): Promise<void>;
+declare function getSuggestedGasFees(request: UpdateGasFeesRequest): Promise<{
+    maxFeePerGas?: undefined;
+    maxPriorityFeePerGas?: undefined;
+    gasPrice?: undefined;
+} | {
+    maxFeePerGas: `0x${string}`;
+    maxPriorityFeePerGas: `0x${string}`;
+    gasPrice?: undefined;
+} | {
+    gasPrice: string | undefined;
+    maxFeePerGas?: undefined;
+    maxPriorityFeePerGas?: undefined;
+}>;
+export {};
+//# sourceMappingURL=gas-fees.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/gas-fees.d.ts.map b/node_modules/@metamask/transaction-controller/dist/utils/gas-fees.d.ts.map
new file mode 100644
index 0000000..6b56c63
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/gas-fees.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"gas-fees.d.ts","sourceRoot":"","sources":["../../src/utils/gas-fees.ts"],"names":[],"mappings":"AAQA,OAAO,KAAK,QAAQ,MAAM,qBAAqB,CAAC;AAChD,OAAO,KAAK,EAAE,WAAW,EAAE,MAAM,8BAA8B,CAAC;AAMhE,OAAO,KAAK,EACV,YAAY,EACZ,iBAAiB,EACjB,eAAe,EAEhB,MAAM,UAAU,CAAC;AAIlB,oBAAY,oBAAoB,GAAG;IACjC,OAAO,EAAE,OAAO,CAAC;IACjB,QAAQ,EAAE,QAAQ,CAAC;IACnB,eAAe,EAAE,MAAM,YAAY,GAAG,SAAS,CAAC;IAChD,kBAAkB,EAAE,MAAM,OAAO,CAAC,WAAW,CAAC,CAAC;IAC/C,MAAM,EAAE,eAAe,CAAC;CACzB,CAAC;AAEF,oBAAY,gBAAgB,GAAG,oBAAoB,GAAG;IACpD,YAAY,CAAC,EAAE,YAAY,CAAC;IAC5B,aAAa,EAAE,iBAAiB,CAAC;IACjC,gBAAgB,EAAE,OAAO,CAAC,UAAU,CAAC,OAAO,mBAAmB,CAAC,CAAC,CAAC;CACnE,CAAC;AAIF,wBAAsB,aAAa,CAAC,OAAO,EAAE,oBAAoB,iBA4ChE;AA6KD,iBAAe,mBAAmB,CAAC,OAAO,EAAE,oBAAoB;;;;;;;;;;;;GAwD/D"}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/gas-fees.js b/node_modules/@metamask/transaction-controller/dist/utils/gas-fees.js
new file mode 100644
index 0000000..823fa99
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/gas-fees.js
@@ -0,0 +1,212 @@
+"use strict";
+/* eslint-disable jsdoc/require-jsdoc */
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.updateGasFees = void 0;
+const controller_utils_1 = require("@metamask/controller-utils");
+const gas_fee_controller_1 = require("@metamask/gas-fee-controller");
+const utils_1 = require("@metamask/utils");
+const ethereumjs_util_1 = require("ethereumjs-util");
+const logger_1 = require("../logger");
+const types_1 = require("../types");
+const swaps_1 = require("./swaps");
+const log = (0, utils_1.createModuleLogger)(logger_1.projectLogger, 'gas-fees');
+function updateGasFees(request) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const { txMeta } = request;
+        const initialParams = Object.assign({}, txMeta.txParams);
+        const isSwap = swaps_1.SWAP_TRANSACTION_TYPES.includes(txMeta.type);
+        const savedGasFees = isSwap ? undefined : request.getSavedGasFees();
+        const suggestedGasFees = yield getSuggestedGasFees(request);
+        log('Suggested gas fees', suggestedGasFees);
+        const getGasFeeRequest = Object.assign(Object.assign({}, request), { savedGasFees,
+            initialParams,
+            suggestedGasFees });
+        txMeta.txParams.maxFeePerGas = getMaxFeePerGas(getGasFeeRequest);
+        txMeta.txParams.maxPriorityFeePerGas =
+            getMaxPriorityFeePerGas(getGasFeeRequest);
+        txMeta.txParams.gasPrice = getGasPrice(getGasFeeRequest);
+        txMeta.userFeeLevel = getUserFeeLevel(getGasFeeRequest);
+        log('Updated gas fee properties', {
+            maxFeePerGas: txMeta.txParams.maxFeePerGas,
+            maxPriorityFeePerGas: txMeta.txParams.maxPriorityFeePerGas,
+            gasPrice: txMeta.txParams.gasPrice,
+        });
+        if (txMeta.txParams.maxFeePerGas || txMeta.txParams.maxPriorityFeePerGas) {
+            delete txMeta.txParams.gasPrice;
+        }
+        if (txMeta.txParams.gasPrice) {
+            delete txMeta.txParams.maxFeePerGas;
+            delete txMeta.txParams.maxPriorityFeePerGas;
+        }
+        updateDefaultGasEstimates(txMeta);
+    });
+}
+exports.updateGasFees = updateGasFees;
+function getMaxFeePerGas(request) {
+    const { savedGasFees, eip1559, initialParams, suggestedGasFees } = request;
+    if (!eip1559) {
+        return undefined;
+    }
+    if (savedGasFees) {
+        const maxFeePerGas = gweiDecimalToWeiHex(savedGasFees.maxBaseFee);
+        log('Using maxFeePerGas from savedGasFees', maxFeePerGas);
+        return maxFeePerGas;
+    }
+    if (initialParams.maxFeePerGas) {
+        log('Using maxFeePerGas from request', initialParams.maxFeePerGas);
+        return initialParams.maxFeePerGas;
+    }
+    if (initialParams.gasPrice && !initialParams.maxPriorityFeePerGas) {
+        log('Setting maxFeePerGas to gasPrice from request', initialParams.gasPrice);
+        return initialParams.gasPrice;
+    }
+    if (suggestedGasFees.maxFeePerGas) {
+        log('Using suggested maxFeePerGas', suggestedGasFees.maxFeePerGas);
+        return suggestedGasFees.maxFeePerGas;
+    }
+    if (suggestedGasFees.gasPrice) {
+        log('Setting maxFeePerGas to suggested gasPrice', suggestedGasFees.gasPrice);
+        return suggestedGasFees.gasPrice;
+    }
+    log('maxFeePerGas not set');
+    return undefined;
+}
+function getMaxPriorityFeePerGas(request) {
+    const { eip1559, initialParams, savedGasFees, suggestedGasFees, txMeta } = request;
+    if (!eip1559) {
+        return undefined;
+    }
+    if (savedGasFees) {
+        const maxPriorityFeePerGas = gweiDecimalToWeiHex(savedGasFees.priorityFee);
+        log('Using maxPriorityFeePerGas from savedGasFees.priorityFee', maxPriorityFeePerGas);
+        return maxPriorityFeePerGas;
+    }
+    if (initialParams.maxPriorityFeePerGas) {
+        log('Using maxPriorityFeePerGas from request', initialParams.maxPriorityFeePerGas);
+        return initialParams.maxPriorityFeePerGas;
+    }
+    if (initialParams.gasPrice && !initialParams.maxFeePerGas) {
+        log('Setting maxPriorityFeePerGas to gasPrice from request', initialParams.gasPrice);
+        return initialParams.gasPrice;
+    }
+    if (suggestedGasFees.maxPriorityFeePerGas) {
+        log('Using suggested maxPriorityFeePerGas', suggestedGasFees.maxPriorityFeePerGas);
+        return suggestedGasFees.maxPriorityFeePerGas;
+    }
+    if (txMeta.txParams.maxFeePerGas) {
+        log('Setting maxPriorityFeePerGas to maxFeePerGas', txMeta.txParams.maxFeePerGas);
+        return txMeta.txParams.maxFeePerGas;
+    }
+    log('maxPriorityFeePerGas not set');
+    return undefined;
+}
+function getGasPrice(request) {
+    const { eip1559, initialParams, suggestedGasFees } = request;
+    if (eip1559) {
+        return undefined;
+    }
+    if (initialParams.gasPrice) {
+        log('Using gasPrice from request', initialParams.gasPrice);
+        return initialParams.gasPrice;
+    }
+    if (suggestedGasFees.gasPrice) {
+        log('Using suggested gasPrice', suggestedGasFees.gasPrice);
+        return suggestedGasFees.gasPrice;
+    }
+    log('gasPrice not set');
+    return undefined;
+}
+function getUserFeeLevel(request) {
+    const { eip1559, initialParams, savedGasFees, suggestedGasFees, txMeta } = request;
+    if (!eip1559) {
+        return undefined;
+    }
+    if (savedGasFees) {
+        return types_1.UserFeeLevel.CUSTOM;
+    }
+    if (!initialParams.maxFeePerGas &&
+        !initialParams.maxPriorityFeePerGas &&
+        initialParams.gasPrice) {
+        return txMeta.origin === controller_utils_1.ORIGIN_METAMASK
+            ? types_1.UserFeeLevel.CUSTOM
+            : types_1.UserFeeLevel.DAPP_SUGGESTED;
+    }
+    if (!initialParams.maxFeePerGas &&
+        !initialParams.maxPriorityFeePerGas &&
+        suggestedGasFees.maxFeePerGas &&
+        suggestedGasFees.maxPriorityFeePerGas) {
+        return types_1.UserFeeLevel.MEDIUM;
+    }
+    if (txMeta.origin === controller_utils_1.ORIGIN_METAMASK) {
+        return types_1.UserFeeLevel.MEDIUM;
+    }
+    return types_1.UserFeeLevel.DAPP_SUGGESTED;
+}
+function updateDefaultGasEstimates(txMeta) {
+    if (!txMeta.defaultGasEstimates) {
+        txMeta.defaultGasEstimates = {};
+    }
+    txMeta.defaultGasEstimates.maxFeePerGas = txMeta.txParams.maxFeePerGas;
+    txMeta.defaultGasEstimates.maxPriorityFeePerGas =
+        txMeta.txParams.maxPriorityFeePerGas;
+    txMeta.defaultGasEstimates.gasPrice = txMeta.txParams.gasPrice;
+    txMeta.defaultGasEstimates.estimateType = txMeta.userFeeLevel;
+}
+function getSuggestedGasFees(request) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const { eip1559, ethQuery, getGasFeeEstimates, txMeta } = request;
+        if ((!eip1559 && txMeta.txParams.gasPrice) ||
+            (eip1559 &&
+                txMeta.txParams.maxFeePerGas &&
+                txMeta.txParams.maxPriorityFeePerGas)) {
+            return {};
+        }
+        try {
+            const { gasFeeEstimates, gasEstimateType } = yield getGasFeeEstimates();
+            if (eip1559 && gasEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.FEE_MARKET) {
+                const { medium: { suggestedMaxPriorityFeePerGas, suggestedMaxFeePerGas } = {}, } = gasFeeEstimates;
+                if (suggestedMaxPriorityFeePerGas && suggestedMaxFeePerGas) {
+                    return {
+                        maxFeePerGas: gweiDecimalToWeiHex(suggestedMaxFeePerGas),
+                        maxPriorityFeePerGas: gweiDecimalToWeiHex(suggestedMaxPriorityFeePerGas),
+                    };
+                }
+            }
+            if (gasEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.LEGACY) {
+                // The LEGACY type includes low, medium and high estimates of
+                // gas price values.
+                return {
+                    gasPrice: gweiDecimalToWeiHex(gasFeeEstimates.medium),
+                };
+            }
+            if (gasEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.ETH_GASPRICE) {
+                // The ETH_GASPRICE type just includes a single gas price property,
+                // which we can assume was retrieved from eth_gasPrice
+                return {
+                    gasPrice: gweiDecimalToWeiHex(gasFeeEstimates.gasPrice),
+                };
+            }
+        }
+        catch (error) {
+            log('Failed to get suggested gas fees', error);
+        }
+        const gasPriceDecimal = (yield (0, controller_utils_1.query)(ethQuery, 'gasPrice'));
+        const gasPrice = gasPriceDecimal
+            ? (0, ethereumjs_util_1.addHexPrefix)(gasPriceDecimal.toString(16))
+            : undefined;
+        return { gasPrice };
+    });
+}
+function gweiDecimalToWeiHex(value) {
+    return (0, controller_utils_1.toHex)((0, controller_utils_1.gweiDecToWEIBN)(value));
+}
+//# sourceMappingURL=gas-fees.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/gas-fees.js.map b/node_modules/@metamask/transaction-controller/dist/utils/gas-fees.js.map
new file mode 100644
index 0000000..464cc3d
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/gas-fees.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"gas-fees.js","sourceRoot":"","sources":["../../src/utils/gas-fees.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable jsdoc/require-jsdoc */\n\nimport {\n  ORIGIN_METAMASK,\n  gweiDecToWEIBN,\n  query,\n  toHex,\n} from '@metamask/controller-utils';\nimport type EthQuery from '@metamask/eth-query';\nimport type { GasFeeState } from '@metamask/gas-fee-controller';\nimport { GAS_ESTIMATE_TYPES } from '@metamask/gas-fee-controller';\nimport { createModuleLogger } from '@metamask/utils';\nimport { addHexPrefix } from 'ethereumjs-util';\n\nimport { projectLogger } from '../logger';\nimport type {\n  SavedGasFees,\n  TransactionParams,\n  TransactionMeta,\n  TransactionType,\n} from '../types';\nimport { UserFeeLevel } from '../types';\nimport { SWAP_TRANSACTION_TYPES } from './swaps';\n\nexport type UpdateGasFeesRequest = {\n  eip1559: boolean;\n  ethQuery: EthQuery;\n  getSavedGasFees: () => SavedGasFees | undefined;\n  getGasFeeEstimates: () => Promise<GasFeeState>;\n  txMeta: TransactionMeta;\n};\n\nexport type GetGasFeeRequest = UpdateGasFeesRequest & {\n  savedGasFees?: SavedGasFees;\n  initialParams: TransactionParams;\n  suggestedGasFees: Awaited<ReturnType<typeof getSuggestedGasFees>>;\n};\n\nconst log = createModuleLogger(projectLogger, 'gas-fees');\n\nexport async function updateGasFees(request: UpdateGasFeesRequest) {\n  const { txMeta } = request;\n  const initialParams = { ...txMeta.txParams };\n\n  const isSwap = SWAP_TRANSACTION_TYPES.includes(\n    txMeta.type as TransactionType,\n  );\n  const savedGasFees = isSwap ? undefined : request.getSavedGasFees();\n\n  const suggestedGasFees = await getSuggestedGasFees(request);\n\n  log('Suggested gas fees', suggestedGasFees);\n\n  const getGasFeeRequest = {\n    ...request,\n    savedGasFees,\n    initialParams,\n    suggestedGasFees,\n  };\n\n  txMeta.txParams.maxFeePerGas = getMaxFeePerGas(getGasFeeRequest);\n\n  txMeta.txParams.maxPriorityFeePerGas =\n    getMaxPriorityFeePerGas(getGasFeeRequest);\n\n  txMeta.txParams.gasPrice = getGasPrice(getGasFeeRequest);\n  txMeta.userFeeLevel = getUserFeeLevel(getGasFeeRequest);\n\n  log('Updated gas fee properties', {\n    maxFeePerGas: txMeta.txParams.maxFeePerGas,\n    maxPriorityFeePerGas: txMeta.txParams.maxPriorityFeePerGas,\n    gasPrice: txMeta.txParams.gasPrice,\n  });\n\n  if (txMeta.txParams.maxFeePerGas || txMeta.txParams.maxPriorityFeePerGas) {\n    delete txMeta.txParams.gasPrice;\n  }\n\n  if (txMeta.txParams.gasPrice) {\n    delete txMeta.txParams.maxFeePerGas;\n    delete txMeta.txParams.maxPriorityFeePerGas;\n  }\n\n  updateDefaultGasEstimates(txMeta);\n}\n\nfunction getMaxFeePerGas(request: GetGasFeeRequest): string | undefined {\n  const { savedGasFees, eip1559, initialParams, suggestedGasFees } = request;\n\n  if (!eip1559) {\n    return undefined;\n  }\n\n  if (savedGasFees) {\n    const maxFeePerGas = gweiDecimalToWeiHex(savedGasFees.maxBaseFee as string);\n    log('Using maxFeePerGas from savedGasFees', maxFeePerGas);\n    return maxFeePerGas;\n  }\n\n  if (initialParams.maxFeePerGas) {\n    log('Using maxFeePerGas from request', initialParams.maxFeePerGas);\n    return initialParams.maxFeePerGas;\n  }\n\n  if (initialParams.gasPrice && !initialParams.maxPriorityFeePerGas) {\n    log(\n      'Setting maxFeePerGas to gasPrice from request',\n      initialParams.gasPrice,\n    );\n    return initialParams.gasPrice;\n  }\n\n  if (suggestedGasFees.maxFeePerGas) {\n    log('Using suggested maxFeePerGas', suggestedGasFees.maxFeePerGas);\n    return suggestedGasFees.maxFeePerGas;\n  }\n\n  if (suggestedGasFees.gasPrice) {\n    log(\n      'Setting maxFeePerGas to suggested gasPrice',\n      suggestedGasFees.gasPrice,\n    );\n    return suggestedGasFees.gasPrice;\n  }\n\n  log('maxFeePerGas not set');\n  return undefined;\n}\n\nfunction getMaxPriorityFeePerGas(\n  request: GetGasFeeRequest,\n): string | undefined {\n  const { eip1559, initialParams, savedGasFees, suggestedGasFees, txMeta } =\n    request;\n\n  if (!eip1559) {\n    return undefined;\n  }\n\n  if (savedGasFees) {\n    const maxPriorityFeePerGas = gweiDecimalToWeiHex(savedGasFees.priorityFee);\n    log(\n      'Using maxPriorityFeePerGas from savedGasFees.priorityFee',\n      maxPriorityFeePerGas,\n    );\n    return maxPriorityFeePerGas;\n  }\n\n  if (initialParams.maxPriorityFeePerGas) {\n    log(\n      'Using maxPriorityFeePerGas from request',\n      initialParams.maxPriorityFeePerGas,\n    );\n    return initialParams.maxPriorityFeePerGas;\n  }\n\n  if (initialParams.gasPrice && !initialParams.maxFeePerGas) {\n    log(\n      'Setting maxPriorityFeePerGas to gasPrice from request',\n      initialParams.gasPrice,\n    );\n    return initialParams.gasPrice;\n  }\n\n  if (suggestedGasFees.maxPriorityFeePerGas) {\n    log(\n      'Using suggested maxPriorityFeePerGas',\n      suggestedGasFees.maxPriorityFeePerGas,\n    );\n    return suggestedGasFees.maxPriorityFeePerGas;\n  }\n\n  if (txMeta.txParams.maxFeePerGas) {\n    log(\n      'Setting maxPriorityFeePerGas to maxFeePerGas',\n      txMeta.txParams.maxFeePerGas,\n    );\n    return txMeta.txParams.maxFeePerGas;\n  }\n\n  log('maxPriorityFeePerGas not set');\n  return undefined;\n}\n\nfunction getGasPrice(request: GetGasFeeRequest): string | undefined {\n  const { eip1559, initialParams, suggestedGasFees } = request;\n\n  if (eip1559) {\n    return undefined;\n  }\n\n  if (initialParams.gasPrice) {\n    log('Using gasPrice from request', initialParams.gasPrice);\n    return initialParams.gasPrice;\n  }\n\n  if (suggestedGasFees.gasPrice) {\n    log('Using suggested gasPrice', suggestedGasFees.gasPrice);\n    return suggestedGasFees.gasPrice;\n  }\n\n  log('gasPrice not set');\n  return undefined;\n}\n\nfunction getUserFeeLevel(request: GetGasFeeRequest): UserFeeLevel | undefined {\n  const { eip1559, initialParams, savedGasFees, suggestedGasFees, txMeta } =\n    request;\n\n  if (!eip1559) {\n    return undefined;\n  }\n\n  if (savedGasFees) {\n    return UserFeeLevel.CUSTOM;\n  }\n\n  if (\n    !initialParams.maxFeePerGas &&\n    !initialParams.maxPriorityFeePerGas &&\n    initialParams.gasPrice\n  ) {\n    return txMeta.origin === ORIGIN_METAMASK\n      ? UserFeeLevel.CUSTOM\n      : UserFeeLevel.DAPP_SUGGESTED;\n  }\n\n  if (\n    !initialParams.maxFeePerGas &&\n    !initialParams.maxPriorityFeePerGas &&\n    suggestedGasFees.maxFeePerGas &&\n    suggestedGasFees.maxPriorityFeePerGas\n  ) {\n    return UserFeeLevel.MEDIUM;\n  }\n\n  if (txMeta.origin === ORIGIN_METAMASK) {\n    return UserFeeLevel.MEDIUM;\n  }\n\n  return UserFeeLevel.DAPP_SUGGESTED;\n}\n\nfunction updateDefaultGasEstimates(txMeta: TransactionMeta) {\n  if (!txMeta.defaultGasEstimates) {\n    txMeta.defaultGasEstimates = {};\n  }\n\n  txMeta.defaultGasEstimates.maxFeePerGas = txMeta.txParams.maxFeePerGas;\n\n  txMeta.defaultGasEstimates.maxPriorityFeePerGas =\n    txMeta.txParams.maxPriorityFeePerGas;\n\n  txMeta.defaultGasEstimates.gasPrice = txMeta.txParams.gasPrice;\n  txMeta.defaultGasEstimates.estimateType = txMeta.userFeeLevel;\n}\n\nasync function getSuggestedGasFees(request: UpdateGasFeesRequest) {\n  const { eip1559, ethQuery, getGasFeeEstimates, txMeta } = request;\n\n  if (\n    (!eip1559 && txMeta.txParams.gasPrice) ||\n    (eip1559 &&\n      txMeta.txParams.maxFeePerGas &&\n      txMeta.txParams.maxPriorityFeePerGas)\n  ) {\n    return {};\n  }\n\n  try {\n    const { gasFeeEstimates, gasEstimateType } = await getGasFeeEstimates();\n\n    if (eip1559 && gasEstimateType === GAS_ESTIMATE_TYPES.FEE_MARKET) {\n      const {\n        medium: { suggestedMaxPriorityFeePerGas, suggestedMaxFeePerGas } = {},\n      } = gasFeeEstimates;\n\n      if (suggestedMaxPriorityFeePerGas && suggestedMaxFeePerGas) {\n        return {\n          maxFeePerGas: gweiDecimalToWeiHex(suggestedMaxFeePerGas),\n          maxPriorityFeePerGas: gweiDecimalToWeiHex(\n            suggestedMaxPriorityFeePerGas,\n          ),\n        };\n      }\n    }\n\n    if (gasEstimateType === GAS_ESTIMATE_TYPES.LEGACY) {\n      // The LEGACY type includes low, medium and high estimates of\n      // gas price values.\n      return {\n        gasPrice: gweiDecimalToWeiHex(gasFeeEstimates.medium),\n      };\n    }\n\n    if (gasEstimateType === GAS_ESTIMATE_TYPES.ETH_GASPRICE) {\n      // The ETH_GASPRICE type just includes a single gas price property,\n      // which we can assume was retrieved from eth_gasPrice\n      return {\n        gasPrice: gweiDecimalToWeiHex(gasFeeEstimates.gasPrice),\n      };\n    }\n  } catch (error) {\n    log('Failed to get suggested gas fees', error);\n  }\n\n  const gasPriceDecimal = (await query(ethQuery, 'gasPrice')) as number;\n\n  const gasPrice = gasPriceDecimal\n    ? addHexPrefix(gasPriceDecimal.toString(16))\n    : undefined;\n\n  return { gasPrice };\n}\n\nfunction gweiDecimalToWeiHex(value: string) {\n  return toHex(gweiDecToWEIBN(value));\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/gas-flow.d.ts b/node_modules/@metamask/transaction-controller/dist/utils/gas-flow.d.ts
new file mode 100644
index 0000000..59837f9
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/gas-flow.d.ts
@@ -0,0 +1,33 @@
+import type { GasFeeEstimates, LegacyGasPriceEstimate } from '@metamask/gas-fee-controller';
+import { type GasFeeState } from '@metamask/gas-fee-controller';
+import { type GasFeeEstimates as TransactionGasFeeEstimates, type GasFeeFlow, type TransactionMeta } from '../types';
+/**
+ * Returns the first gas fee flow that matches the transaction.
+ *
+ * @param transactionMeta - The transaction metadata to find a gas fee flow for.
+ * @param gasFeeFlows - The gas fee flows to search.
+ * @returns The first gas fee flow that matches the transaction, or undefined if none match.
+ */
+export declare function getGasFeeFlow(transactionMeta: TransactionMeta, gasFeeFlows: GasFeeFlow[]): GasFeeFlow | undefined;
+declare type FeeMarketMergeGasFeeEstimatesRequest = {
+    gasFeeControllerEstimateType: 'fee-market';
+    gasFeeControllerEstimates: GasFeeEstimates;
+    transactionGasFeeEstimates: TransactionGasFeeEstimates;
+};
+declare type LegacyMergeGasFeeEstimatesRequest = {
+    gasFeeControllerEstimateType: 'legacy';
+    gasFeeControllerEstimates: LegacyGasPriceEstimate;
+    transactionGasFeeEstimates: TransactionGasFeeEstimates;
+};
+/**
+ * Merge the gas fee estimates from the gas fee controller with the gas fee estimates from a transaction.
+ *
+ * @param request - Data required to merge gas fee estimates.
+ * @param request.gasFeeControllerEstimateType - Gas fee estimate type from the gas fee controller.
+ * @param request.gasFeeControllerEstimates - Gas fee estimates from the GasFeeController.
+ * @param request.transactionGasFeeEstimates - Gas fee estimates from the transaction.
+ * @returns The merged gas fee estimates.
+ */
+export declare function mergeGasFeeEstimates({ gasFeeControllerEstimateType, gasFeeControllerEstimates, transactionGasFeeEstimates, }: FeeMarketMergeGasFeeEstimatesRequest | LegacyMergeGasFeeEstimatesRequest): GasFeeState['gasFeeEstimates'];
+export {};
+//# sourceMappingURL=gas-flow.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/gas-flow.d.ts.map b/node_modules/@metamask/transaction-controller/dist/utils/gas-flow.d.ts.map
new file mode 100644
index 0000000..46c3e5a
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/gas-flow.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"gas-flow.d.ts","sourceRoot":"","sources":["../../src/utils/gas-flow.ts"],"names":[],"mappings":"AACA,OAAO,KAAK,EAEV,eAAe,EACf,sBAAsB,EACvB,MAAM,8BAA8B,CAAC;AACtC,OAAO,EAEL,KAAK,WAAW,EACjB,MAAM,8BAA8B,CAAC;AAEtC,OAAO,EACL,KAAK,eAAe,IAAI,0BAA0B,EAClD,KAAK,UAAU,EACf,KAAK,eAAe,EAGrB,MAAM,UAAU,CAAC;AAElB;;;;;;GAMG;AACH,wBAAgB,aAAa,CAC3B,eAAe,EAAE,eAAe,EAChC,WAAW,EAAE,UAAU,EAAE,GACxB,UAAU,GAAG,SAAS,CAIxB;AAED,aAAK,oCAAoC,GAAG;IAC1C,4BAA4B,EAAE,YAAY,CAAC;IAC3C,yBAAyB,EAAE,eAAe,CAAC;IAC3C,0BAA0B,EAAE,0BAA0B,CAAC;CACxD,CAAC;AAEF,aAAK,iCAAiC,GAAG;IACvC,4BAA4B,EAAE,QAAQ,CAAC;IACvC,yBAAyB,EAAE,sBAAsB,CAAC;IAClD,0BAA0B,EAAE,0BAA0B,CAAC;CACxD,CAAC;AAEF;;;;;;;;GAQG;AACH,wBAAgB,oBAAoB,CAAC,EACnC,4BAA4B,EAC5B,yBAAyB,EACzB,0BAA0B,GAC3B,EACG,oCAAoC,GACpC,iCAAiC,GAAG,WAAW,CAAC,iBAAiB,CAAC,CAyBrE"}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/gas-flow.js b/node_modules/@metamask/transaction-controller/dist/utils/gas-flow.js
new file mode 100644
index 0000000..7f4e8a9
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/gas-flow.js
@@ -0,0 +1,56 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.mergeGasFeeEstimates = exports.getGasFeeFlow = void 0;
+const controller_utils_1 = require("@metamask/controller-utils");
+const gas_fee_controller_1 = require("@metamask/gas-fee-controller");
+const types_1 = require("../types");
+/**
+ * Returns the first gas fee flow that matches the transaction.
+ *
+ * @param transactionMeta - The transaction metadata to find a gas fee flow for.
+ * @param gasFeeFlows - The gas fee flows to search.
+ * @returns The first gas fee flow that matches the transaction, or undefined if none match.
+ */
+function getGasFeeFlow(transactionMeta, gasFeeFlows) {
+    return gasFeeFlows.find((gasFeeFlow) => gasFeeFlow.matchesTransaction(transactionMeta));
+}
+exports.getGasFeeFlow = getGasFeeFlow;
+/**
+ * Merge the gas fee estimates from the gas fee controller with the gas fee estimates from a transaction.
+ *
+ * @param request - Data required to merge gas fee estimates.
+ * @param request.gasFeeControllerEstimateType - Gas fee estimate type from the gas fee controller.
+ * @param request.gasFeeControllerEstimates - Gas fee estimates from the GasFeeController.
+ * @param request.transactionGasFeeEstimates - Gas fee estimates from the transaction.
+ * @returns The merged gas fee estimates.
+ */
+function mergeGasFeeEstimates({ gasFeeControllerEstimateType, gasFeeControllerEstimates, transactionGasFeeEstimates, }) {
+    if (gasFeeControllerEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.FEE_MARKET) {
+        return Object.values(types_1.GasFeeEstimateLevel).reduce((result, level) => (Object.assign(Object.assign({}, result), { [level]: mergeFeeMarketEstimate(gasFeeControllerEstimates[level], transactionGasFeeEstimates[level]) })), Object.assign({}, gasFeeControllerEstimates));
+    }
+    if (gasFeeControllerEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.LEGACY) {
+        return Object.values(types_1.GasFeeEstimateLevel).reduce((result, level) => (Object.assign(Object.assign({}, result), { [level]: getLegacyEstimate(transactionGasFeeEstimates[level]) })), {});
+    }
+    return gasFeeControllerEstimates;
+}
+exports.mergeGasFeeEstimates = mergeGasFeeEstimates;
+/**
+ * Merge a specific priority level of EIP-1559 gas fee estimates.
+ *
+ * @param gasFeeControllerEstimate - The gas fee estimate from the gas fee controller.
+ * @param transactionGasFeeEstimate - The gas fee estimate from the transaction.
+ * @returns The merged gas fee estimate.
+ */
+function mergeFeeMarketEstimate(gasFeeControllerEstimate, transactionGasFeeEstimate) {
+    return Object.assign(Object.assign({}, gasFeeControllerEstimate), { suggestedMaxFeePerGas: (0, controller_utils_1.weiHexToGweiDec)(transactionGasFeeEstimate.maxFeePerGas), suggestedMaxPriorityFeePerGas: (0, controller_utils_1.weiHexToGweiDec)(transactionGasFeeEstimate.maxPriorityFeePerGas) });
+}
+/**
+ * Generate a specific priority level for a legacy gas fee estimate.
+ *
+ * @param transactionGasFeeEstimate - The gas fee estimate from the transaction.
+ * @returns The legacy gas fee estimate.
+ */
+function getLegacyEstimate(transactionGasFeeEstimate) {
+    return (0, controller_utils_1.weiHexToGweiDec)(transactionGasFeeEstimate.maxFeePerGas);
+}
+//# sourceMappingURL=gas-flow.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/gas-flow.js.map b/node_modules/@metamask/transaction-controller/dist/utils/gas-flow.js.map
new file mode 100644
index 0000000..fe93a4a
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/gas-flow.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"gas-flow.js","sourceRoot":"","sources":["../../src/utils/gas-flow.ts"],"names":[],"mappings":";;;AAAA,iEAA6D;AAM7D,qEAGsC;AAEtC,oCAMkB;AAElB;;;;;;GAMG;AACH,SAAgB,aAAa,CAC3B,eAAgC,EAChC,WAAyB;IAEzB,OAAO,WAAW,CAAC,IAAI,CAAC,CAAC,UAAU,EAAE,EAAE,CACrC,UAAU,CAAC,kBAAkB,CAAC,eAAe,CAAC,CAC/C,CAAC;AACJ,CAAC;AAPD,sCAOC;AAcD;;;;;;;;GAQG;AACH,SAAgB,oBAAoB,CAAC,EACnC,4BAA4B,EAC5B,yBAAyB,EACzB,0BAA0B,GAGS;IACnC,IAAI,4BAA4B,KAAK,uCAAkB,CAAC,UAAU,EAAE;QAClE,OAAO,MAAM,CAAC,MAAM,CAAC,2BAAmB,CAAC,CAAC,MAAM,CAC9C,CAAC,MAAM,EAAE,KAAK,EAAE,EAAE,CAAC,iCACd,MAAM,KACT,CAAC,KAAK,CAAC,EAAE,sBAAsB,CAC7B,yBAAyB,CAAC,KAAK,CAAC,EAChC,0BAA0B,CAAC,KAAK,CAAC,CAClC,IACD,EACF,kBAAK,yBAAyB,CAAqB,CACpD,CAAC;KACH;IAED,IAAI,4BAA4B,KAAK,uCAAkB,CAAC,MAAM,EAAE;QAC9D,OAAO,MAAM,CAAC,MAAM,CAAC,2BAAmB,CAAC,CAAC,MAAM,CAC9C,CAAC,MAAM,EAAE,KAAK,EAAE,EAAE,CAAC,iCACd,MAAM,KACT,CAAC,KAAK,CAAC,EAAE,iBAAiB,CAAC,0BAA0B,CAAC,KAAK,CAAC,CAAC,IAC7D,EACF,EAA4B,CAC7B,CAAC;KACH;IAED,OAAO,yBAAyB,CAAC;AACnC,CAAC;AA/BD,oDA+BC;AAED;;;;;;GAMG;AACH,SAAS,sBAAsB,CAC7B,wBAAuC,EACvC,yBAAkD;IAElD,uCACK,wBAAwB,KAC3B,qBAAqB,EAAE,IAAA,kCAAe,EACpC,yBAAyB,CAAC,YAAY,CACvC,EACD,6BAA6B,EAAE,IAAA,kCAAe,EAC5C,yBAAyB,CAAC,oBAAoB,CAC/C,IACD;AACJ,CAAC;AAED;;;;;GAKG;AACH,SAAS,iBAAiB,CACxB,yBAAkD;IAElD,OAAO,IAAA,kCAAe,EAAC,yBAAyB,CAAC,YAAY,CAAC,CAAC;AACjE,CAAC","sourcesContent":["import { weiHexToGweiDec } from '@metamask/controller-utils';\nimport type {\n  Eip1559GasFee,\n  GasFeeEstimates,\n  LegacyGasPriceEstimate,\n} from '@metamask/gas-fee-controller';\nimport {\n  GAS_ESTIMATE_TYPES,\n  type GasFeeState,\n} from '@metamask/gas-fee-controller';\n\nimport {\n  type GasFeeEstimates as TransactionGasFeeEstimates,\n  type GasFeeFlow,\n  type TransactionMeta,\n  type GasFeeEstimatesForLevel,\n  GasFeeEstimateLevel,\n} from '../types';\n\n/**\n * Returns the first gas fee flow that matches the transaction.\n *\n * @param transactionMeta - The transaction metadata to find a gas fee flow for.\n * @param gasFeeFlows - The gas fee flows to search.\n * @returns The first gas fee flow that matches the transaction, or undefined if none match.\n */\nexport function getGasFeeFlow(\n  transactionMeta: TransactionMeta,\n  gasFeeFlows: GasFeeFlow[],\n): GasFeeFlow | undefined {\n  return gasFeeFlows.find((gasFeeFlow) =>\n    gasFeeFlow.matchesTransaction(transactionMeta),\n  );\n}\n\ntype FeeMarketMergeGasFeeEstimatesRequest = {\n  gasFeeControllerEstimateType: 'fee-market';\n  gasFeeControllerEstimates: GasFeeEstimates;\n  transactionGasFeeEstimates: TransactionGasFeeEstimates;\n};\n\ntype LegacyMergeGasFeeEstimatesRequest = {\n  gasFeeControllerEstimateType: 'legacy';\n  gasFeeControllerEstimates: LegacyGasPriceEstimate;\n  transactionGasFeeEstimates: TransactionGasFeeEstimates;\n};\n\n/**\n * Merge the gas fee estimates from the gas fee controller with the gas fee estimates from a transaction.\n *\n * @param request - Data required to merge gas fee estimates.\n * @param request.gasFeeControllerEstimateType - Gas fee estimate type from the gas fee controller.\n * @param request.gasFeeControllerEstimates - Gas fee estimates from the GasFeeController.\n * @param request.transactionGasFeeEstimates - Gas fee estimates from the transaction.\n * @returns The merged gas fee estimates.\n */\nexport function mergeGasFeeEstimates({\n  gasFeeControllerEstimateType,\n  gasFeeControllerEstimates,\n  transactionGasFeeEstimates,\n}:\n  | FeeMarketMergeGasFeeEstimatesRequest\n  | LegacyMergeGasFeeEstimatesRequest): GasFeeState['gasFeeEstimates'] {\n  if (gasFeeControllerEstimateType === GAS_ESTIMATE_TYPES.FEE_MARKET) {\n    return Object.values(GasFeeEstimateLevel).reduce(\n      (result, level) => ({\n        ...result,\n        [level]: mergeFeeMarketEstimate(\n          gasFeeControllerEstimates[level],\n          transactionGasFeeEstimates[level],\n        ),\n      }),\n      { ...gasFeeControllerEstimates } as GasFeeEstimates,\n    );\n  }\n\n  if (gasFeeControllerEstimateType === GAS_ESTIMATE_TYPES.LEGACY) {\n    return Object.values(GasFeeEstimateLevel).reduce(\n      (result, level) => ({\n        ...result,\n        [level]: getLegacyEstimate(transactionGasFeeEstimates[level]),\n      }),\n      {} as LegacyGasPriceEstimate,\n    );\n  }\n\n  return gasFeeControllerEstimates;\n}\n\n/**\n * Merge a specific priority level of EIP-1559 gas fee estimates.\n *\n * @param gasFeeControllerEstimate - The gas fee estimate from the gas fee controller.\n * @param transactionGasFeeEstimate - The gas fee estimate from the transaction.\n * @returns The merged gas fee estimate.\n */\nfunction mergeFeeMarketEstimate(\n  gasFeeControllerEstimate: Eip1559GasFee,\n  transactionGasFeeEstimate: GasFeeEstimatesForLevel,\n): Eip1559GasFee {\n  return {\n    ...gasFeeControllerEstimate,\n    suggestedMaxFeePerGas: weiHexToGweiDec(\n      transactionGasFeeEstimate.maxFeePerGas,\n    ),\n    suggestedMaxPriorityFeePerGas: weiHexToGweiDec(\n      transactionGasFeeEstimate.maxPriorityFeePerGas,\n    ),\n  };\n}\n\n/**\n * Generate a specific priority level for a legacy gas fee estimate.\n *\n * @param transactionGasFeeEstimate - The gas fee estimate from the transaction.\n * @returns The legacy gas fee estimate.\n */\nfunction getLegacyEstimate(\n  transactionGasFeeEstimate: GasFeeEstimatesForLevel,\n): string {\n  return weiHexToGweiDec(transactionGasFeeEstimate.maxFeePerGas);\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/gas.d.ts b/node_modules/@metamask/transaction-controller/dist/utils/gas.d.ts
new file mode 100644
index 0000000..a3abd31
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/gas.d.ts
@@ -0,0 +1,27 @@
+/// <reference types="debug" />
+import type EthQuery from '@metamask/eth-query';
+import type { ProviderConfig } from '@metamask/network-controller';
+import type { TransactionMeta, TransactionParams } from '../types';
+export declare type UpdateGasRequest = {
+    ethQuery: EthQuery;
+    providerConfig: ProviderConfig;
+    txMeta: TransactionMeta;
+};
+export declare const log: import("debug").Debugger;
+export declare const FIXED_GAS = "0x5208";
+export declare const DEFAULT_GAS_MULTIPLIER = 1.5;
+export declare function updateGas(request: UpdateGasRequest): Promise<void>;
+export declare function estimateGas(txParams: TransactionParams, ethQuery: EthQuery): Promise<{
+    blockGasLimit: string;
+    estimatedGas: string;
+    simulationFails: {
+        reason: any;
+        errorKey: any;
+        debug: {
+            blockNumber: string;
+            blockGasLimit: string;
+        };
+    } | undefined;
+}>;
+export declare function addGasBuffer(estimatedGas: string, blockGasLimit: string, multiplier: number): string;
+//# sourceMappingURL=gas.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/gas.d.ts.map b/node_modules/@metamask/transaction-controller/dist/utils/gas.d.ts.map
new file mode 100644
index 0000000..0875df2
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/gas.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"gas.d.ts","sourceRoot":"","sources":["../../src/utils/gas.ts"],"names":[],"mappings":";AASA,OAAO,KAAK,QAAQ,MAAM,qBAAqB,CAAC;AAChD,OAAO,KAAK,EAAE,cAAc,EAAE,MAAM,8BAA8B,CAAC;AAMnE,OAAO,KAAK,EAAE,eAAe,EAAE,iBAAiB,EAAE,MAAM,UAAU,CAAC;AAEnE,oBAAY,gBAAgB,GAAG;IAC7B,QAAQ,EAAE,QAAQ,CAAC;IACnB,cAAc,EAAE,cAAc,CAAC;IAC/B,MAAM,EAAE,eAAe,CAAC;CACzB,CAAC;AAEF,eAAO,MAAM,GAAG,0BAA2C,CAAC;AAE5D,eAAO,MAAM,SAAS,WAAW,CAAC;AAClC,eAAO,MAAM,sBAAsB,MAAM,CAAC;AAE1C,wBAAsB,SAAS,CAAC,OAAO,EAAE,gBAAgB,iBAkBxD;AAED,wBAAsB,WAAW,CAC/B,QAAQ,EAAE,iBAAiB,EAC3B,QAAQ,EAAE,QAAQ;;;;;;;;;;;GAwCnB;AAED,wBAAgB,YAAY,CAC1B,YAAY,EAAE,MAAM,EACpB,aAAa,EAAE,MAAM,EACrB,UAAU,EAAE,MAAM,UAqBnB"}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/gas.js b/node_modules/@metamask/transaction-controller/dist/utils/gas.js
new file mode 100644
index 0000000..072b0e6
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/gas.js
@@ -0,0 +1,136 @@
+"use strict";
+/* eslint-disable jsdoc/require-jsdoc */
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.addGasBuffer = exports.estimateGas = exports.updateGas = exports.DEFAULT_GAS_MULTIPLIER = exports.FIXED_GAS = exports.log = void 0;
+const controller_utils_1 = require("@metamask/controller-utils");
+const utils_1 = require("@metamask/utils");
+const ethereumjs_util_1 = require("ethereumjs-util");
+const constants_1 = require("../constants");
+const logger_1 = require("../logger");
+exports.log = (0, utils_1.createModuleLogger)(logger_1.projectLogger, 'gas');
+exports.FIXED_GAS = '0x5208';
+exports.DEFAULT_GAS_MULTIPLIER = 1.5;
+function updateGas(request) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const { txMeta } = request;
+        const initialParams = Object.assign({}, txMeta.txParams);
+        const [gas, simulationFails] = yield getGas(request);
+        txMeta.txParams.gas = gas;
+        txMeta.simulationFails = simulationFails;
+        if (!initialParams.gas) {
+            txMeta.originalGasEstimate = txMeta.txParams.gas;
+        }
+        if (!txMeta.defaultGasEstimates) {
+            txMeta.defaultGasEstimates = {};
+        }
+        txMeta.defaultGasEstimates.gas = txMeta.txParams.gas;
+    });
+}
+exports.updateGas = updateGas;
+function estimateGas(txParams, ethQuery) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const request = Object.assign({}, txParams);
+        const { data, value } = request;
+        const { gasLimit: gasLimitHex, number: blockNumber } = yield getLatestBlock(ethQuery);
+        const gasLimitBN = (0, controller_utils_1.hexToBN)(gasLimitHex);
+        request.data = data ? (0, ethereumjs_util_1.addHexPrefix)(data) : data;
+        request.gas = (0, controller_utils_1.BNToHex)((0, controller_utils_1.fractionBN)(gasLimitBN, 19, 20));
+        request.value = value || '0x0';
+        let estimatedGas = request.gas;
+        let simulationFails;
+        try {
+            estimatedGas = yield (0, controller_utils_1.query)(ethQuery, 'estimateGas', [request]);
+            // TODO: Replace `any` with type
+            // eslint-disable-next-line @typescript-eslint/no-explicit-any
+        }
+        catch (error) {
+            simulationFails = {
+                reason: error.message,
+                errorKey: error.errorKey,
+                debug: {
+                    blockNumber,
+                    blockGasLimit: gasLimitHex,
+                },
+            };
+            (0, exports.log)('Estimation failed', Object.assign(Object.assign({}, simulationFails), { fallback: estimateGas }));
+        }
+        return {
+            blockGasLimit: gasLimitHex,
+            estimatedGas,
+            simulationFails,
+        };
+    });
+}
+exports.estimateGas = estimateGas;
+function addGasBuffer(estimatedGas, blockGasLimit, multiplier) {
+    const estimatedGasBN = (0, controller_utils_1.hexToBN)(estimatedGas);
+    const maxGasBN = (0, controller_utils_1.hexToBN)(blockGasLimit).muln(0.9);
+    const paddedGasBN = estimatedGasBN.muln(multiplier);
+    if (estimatedGasBN.gt(maxGasBN)) {
+        const estimatedGasHex = (0, ethereumjs_util_1.addHexPrefix)(estimatedGas);
+        (0, exports.log)('Using estimated value', estimatedGasHex);
+        return estimatedGasHex;
+    }
+    if (paddedGasBN.lt(maxGasBN)) {
+        const paddedHex = (0, ethereumjs_util_1.addHexPrefix)((0, controller_utils_1.BNToHex)(paddedGasBN));
+        (0, exports.log)('Using padded estimate', paddedHex, multiplier);
+        return paddedHex;
+    }
+    const maxHex = (0, ethereumjs_util_1.addHexPrefix)((0, controller_utils_1.BNToHex)(maxGasBN));
+    (0, exports.log)('Using 90% of block gas limit', maxHex);
+    return maxHex;
+}
+exports.addGasBuffer = addGasBuffer;
+function getGas(request) {
+    var _a;
+    return __awaiter(this, void 0, void 0, function* () {
+        const { providerConfig, txMeta } = request;
+        if (txMeta.txParams.gas) {
+            (0, exports.log)('Using value from request', txMeta.txParams.gas);
+            return [txMeta.txParams.gas];
+        }
+        if (yield requiresFixedGas(request)) {
+            (0, exports.log)('Using fixed value', exports.FIXED_GAS);
+            return [exports.FIXED_GAS];
+        }
+        const { blockGasLimit, estimatedGas, simulationFails } = yield estimateGas(txMeta.txParams, request.ethQuery);
+        if (providerConfig.type === controller_utils_1.NetworkType.rpc) {
+            (0, exports.log)('Using original estimate as custom network');
+            return [estimatedGas, simulationFails];
+        }
+        const bufferMultiplier = (_a = constants_1.GAS_BUFFER_CHAIN_OVERRIDES[providerConfig.chainId]) !== null && _a !== void 0 ? _a : exports.DEFAULT_GAS_MULTIPLIER;
+        const bufferedGas = addGasBuffer(estimatedGas, blockGasLimit, bufferMultiplier);
+        return [bufferedGas, simulationFails];
+    });
+}
+function requiresFixedGas({ ethQuery, txMeta, providerConfig, }) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const isCustomNetwork = providerConfig.type === controller_utils_1.NetworkType.rpc;
+        const { txParams: { to, data }, } = txMeta;
+        if (isCustomNetwork || !to || data) {
+            return false;
+        }
+        const code = yield getCode(ethQuery, to);
+        return !code || code === '0x';
+    });
+}
+function getCode(ethQuery, address) {
+    return __awaiter(this, void 0, void 0, function* () {
+        return yield (0, controller_utils_1.query)(ethQuery, 'getCode', [address]);
+    });
+}
+function getLatestBlock(ethQuery) {
+    return __awaiter(this, void 0, void 0, function* () {
+        return yield (0, controller_utils_1.query)(ethQuery, 'getBlockByNumber', ['latest', false]);
+    });
+}
+//# sourceMappingURL=gas.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/gas.js.map b/node_modules/@metamask/transaction-controller/dist/utils/gas.js.map
new file mode 100644
index 0000000..d705124
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/gas.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"gas.js","sourceRoot":"","sources":["../../src/utils/gas.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable jsdoc/require-jsdoc */\n\nimport {\n  BNToHex,\n  NetworkType,\n  fractionBN,\n  hexToBN,\n  query,\n} from '@metamask/controller-utils';\nimport type EthQuery from '@metamask/eth-query';\nimport type { ProviderConfig } from '@metamask/network-controller';\nimport { createModuleLogger } from '@metamask/utils';\nimport { addHexPrefix } from 'ethereumjs-util';\n\nimport { GAS_BUFFER_CHAIN_OVERRIDES } from '../constants';\nimport { projectLogger } from '../logger';\nimport type { TransactionMeta, TransactionParams } from '../types';\n\nexport type UpdateGasRequest = {\n  ethQuery: EthQuery;\n  providerConfig: ProviderConfig;\n  txMeta: TransactionMeta;\n};\n\nexport const log = createModuleLogger(projectLogger, 'gas');\n\nexport const FIXED_GAS = '0x5208';\nexport const DEFAULT_GAS_MULTIPLIER = 1.5;\n\nexport async function updateGas(request: UpdateGasRequest) {\n  const { txMeta } = request;\n  const initialParams = { ...txMeta.txParams };\n\n  const [gas, simulationFails] = await getGas(request);\n\n  txMeta.txParams.gas = gas;\n  txMeta.simulationFails = simulationFails;\n\n  if (!initialParams.gas) {\n    txMeta.originalGasEstimate = txMeta.txParams.gas;\n  }\n\n  if (!txMeta.defaultGasEstimates) {\n    txMeta.defaultGasEstimates = {};\n  }\n\n  txMeta.defaultGasEstimates.gas = txMeta.txParams.gas;\n}\n\nexport async function estimateGas(\n  txParams: TransactionParams,\n  ethQuery: EthQuery,\n) {\n  const request = { ...txParams };\n  const { data, value } = request;\n\n  const { gasLimit: gasLimitHex, number: blockNumber } = await getLatestBlock(\n    ethQuery,\n  );\n\n  const gasLimitBN = hexToBN(gasLimitHex);\n\n  request.data = data ? addHexPrefix(data) : data;\n  request.gas = BNToHex(fractionBN(gasLimitBN, 19, 20));\n  request.value = value || '0x0';\n\n  let estimatedGas = request.gas;\n  let simulationFails;\n\n  try {\n    estimatedGas = await query(ethQuery, 'estimateGas', [request]);\n    // TODO: Replace `any` with type\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  } catch (error: any) {\n    simulationFails = {\n      reason: error.message,\n      errorKey: error.errorKey,\n      debug: {\n        blockNumber,\n        blockGasLimit: gasLimitHex,\n      },\n    };\n\n    log('Estimation failed', { ...simulationFails, fallback: estimateGas });\n  }\n\n  return {\n    blockGasLimit: gasLimitHex,\n    estimatedGas,\n    simulationFails,\n  };\n}\n\nexport function addGasBuffer(\n  estimatedGas: string,\n  blockGasLimit: string,\n  multiplier: number,\n) {\n  const estimatedGasBN = hexToBN(estimatedGas);\n  const maxGasBN = hexToBN(blockGasLimit).muln(0.9);\n  const paddedGasBN = estimatedGasBN.muln(multiplier);\n\n  if (estimatedGasBN.gt(maxGasBN)) {\n    const estimatedGasHex = addHexPrefix(estimatedGas);\n    log('Using estimated value', estimatedGasHex);\n    return estimatedGasHex;\n  }\n\n  if (paddedGasBN.lt(maxGasBN)) {\n    const paddedHex = addHexPrefix(BNToHex(paddedGasBN));\n    log('Using padded estimate', paddedHex, multiplier);\n    return paddedHex;\n  }\n\n  const maxHex = addHexPrefix(BNToHex(maxGasBN));\n  log('Using 90% of block gas limit', maxHex);\n  return maxHex;\n}\n\nasync function getGas(\n  request: UpdateGasRequest,\n): Promise<[string, TransactionMeta['simulationFails']?]> {\n  const { providerConfig, txMeta } = request;\n\n  if (txMeta.txParams.gas) {\n    log('Using value from request', txMeta.txParams.gas);\n    return [txMeta.txParams.gas];\n  }\n\n  if (await requiresFixedGas(request)) {\n    log('Using fixed value', FIXED_GAS);\n    return [FIXED_GAS];\n  }\n\n  const { blockGasLimit, estimatedGas, simulationFails } = await estimateGas(\n    txMeta.txParams,\n    request.ethQuery,\n  );\n\n  if (providerConfig.type === NetworkType.rpc) {\n    log('Using original estimate as custom network');\n    return [estimatedGas, simulationFails];\n  }\n\n  const bufferMultiplier =\n    GAS_BUFFER_CHAIN_OVERRIDES[\n      providerConfig.chainId as keyof typeof GAS_BUFFER_CHAIN_OVERRIDES\n    ] ?? DEFAULT_GAS_MULTIPLIER;\n\n  const bufferedGas = addGasBuffer(\n    estimatedGas,\n    blockGasLimit,\n    bufferMultiplier,\n  );\n\n  return [bufferedGas, simulationFails];\n}\n\nasync function requiresFixedGas({\n  ethQuery,\n  txMeta,\n  providerConfig,\n}: UpdateGasRequest): Promise<boolean> {\n  const isCustomNetwork = providerConfig.type === NetworkType.rpc;\n\n  const {\n    txParams: { to, data },\n  } = txMeta;\n\n  if (isCustomNetwork || !to || data) {\n    return false;\n  }\n\n  const code = await getCode(ethQuery, to);\n\n  return !code || code === '0x';\n}\n\nasync function getCode(\n  ethQuery: EthQuery,\n  address: string,\n): Promise<string | undefined> {\n  return await query(ethQuery, 'getCode', [address]);\n}\n\nasync function getLatestBlock(\n  ethQuery: EthQuery,\n): Promise<{ gasLimit: string; number: string }> {\n  return await query(ethQuery, 'getBlockByNumber', ['latest', false]);\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/history.d.ts b/node_modules/@metamask/transaction-controller/dist/utils/history.d.ts
new file mode 100644
index 0000000..bafbf48
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/history.d.ts
@@ -0,0 +1,15 @@
+import type { TransactionMeta } from '../types';
+/**
+ * Add initial history snapshot to the provided transactionMeta history.
+ *
+ * @param transactionMeta - TransactionMeta to add initial history snapshot to.
+ */
+export declare function addInitialHistorySnapshot(transactionMeta: TransactionMeta): void;
+/**
+ * Compares and adds history entry to the provided transactionMeta history.
+ *
+ * @param transactionMeta - TransactionMeta to add history entry to.
+ * @param note - Note to add to history entry.
+ */
+export declare function updateTransactionHistory(transactionMeta: TransactionMeta, note: string): void;
+//# sourceMappingURL=history.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/history.d.ts.map b/node_modules/@metamask/transaction-controller/dist/utils/history.d.ts.map
new file mode 100644
index 0000000..61f35cd
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/history.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"history.d.ts","sourceRoot":"","sources":["../../src/utils/history.ts"],"names":[],"mappings":"AAGA,OAAO,KAAK,EAGV,eAAe,EAChB,MAAM,UAAU,CAAC;AAElB;;;;GAIG;AACH,wBAAgB,yBAAyB,CAAC,eAAe,EAAE,eAAe,QAGzE;AAED;;;;;GAKG;AACH,wBAAgB,wBAAwB,CACtC,eAAe,EAAE,eAAe,EAChC,IAAI,EAAE,MAAM,GACX,IAAI,CAeN"}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/history.js b/node_modules/@metamask/transaction-controller/dist/utils/history.js
new file mode 100644
index 0000000..c2eb6d7
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/history.js
@@ -0,0 +1,84 @@
+"use strict";
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.updateTransactionHistory = exports.addInitialHistorySnapshot = void 0;
+const fast_json_patch_1 = __importDefault(require("fast-json-patch"));
+const lodash_1 = require("lodash");
+/**
+ * Add initial history snapshot to the provided transactionMeta history.
+ *
+ * @param transactionMeta - TransactionMeta to add initial history snapshot to.
+ */
+function addInitialHistorySnapshot(transactionMeta) {
+    const snapshot = snapshotFromTransactionMeta(transactionMeta);
+    transactionMeta.history = [snapshot];
+}
+exports.addInitialHistorySnapshot = addInitialHistorySnapshot;
+/**
+ * Compares and adds history entry to the provided transactionMeta history.
+ *
+ * @param transactionMeta - TransactionMeta to add history entry to.
+ * @param note - Note to add to history entry.
+ */
+function updateTransactionHistory(transactionMeta, note) {
+    var _a;
+    if (!transactionMeta.history) {
+        return;
+    }
+    const currentState = snapshotFromTransactionMeta(transactionMeta);
+    const previousState = replayHistory(transactionMeta.history);
+    const historyEntry = generateHistoryEntry(previousState, currentState, note);
+    if (historyEntry.length) {
+        (_a = transactionMeta === null || transactionMeta === void 0 ? void 0 : transactionMeta.history) === null || _a === void 0 ? void 0 : _a.push(historyEntry);
+    }
+}
+exports.updateTransactionHistory = updateTransactionHistory;
+/**
+ * Generates a history entry from the previous and new transaction metadata.
+ *
+ * @param previousState - The previous transaction metadata.
+ * @param currentState - The new transaction metadata.
+ * @param note - A note for the transaction metada update.
+ * @returns An array of history operation.
+ */
+function generateHistoryEntry(
+// TODO: Replace `any` with type
+// eslint-disable-next-line @typescript-eslint/no-explicit-any
+previousState, currentState, note) {
+    const historyOperationsEntry = fast_json_patch_1.default.compare(previousState, currentState);
+    // Add a note to the first operation, since it breaks if we append it to the entry
+    if (historyOperationsEntry[0]) {
+        if (note) {
+            historyOperationsEntry[0].note = note;
+        }
+        historyOperationsEntry[0].timestamp = Date.now();
+    }
+    return historyOperationsEntry;
+}
+/**
+ * Recovers previous transactionMeta from passed history array.
+ *
+ * @param transactionHistory - The transaction metadata to replay.
+ * @returns The transaction metadata.
+ */
+function replayHistory(transactionHistory) {
+    const shortHistory = (0, lodash_1.cloneDeep)(transactionHistory);
+    return shortHistory.reduce(
+    // TODO: Replace `any` with type
+    // eslint-disable-next-line @typescript-eslint/no-explicit-any
+    (val, entry) => fast_json_patch_1.default.applyPatch(val, entry).newDocument);
+}
+/**
+ * Clone the transaction meta data without the history property.
+ *
+ * @param transactionMeta - The transaction metadata to snapshot.
+ * @returns A deep clone of transaction metadata without history property.
+ */
+function snapshotFromTransactionMeta(transactionMeta) {
+    const snapshot = Object.assign({}, transactionMeta);
+    delete snapshot.history;
+    return (0, lodash_1.cloneDeep)(snapshot);
+}
+//# sourceMappingURL=history.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/history.js.map b/node_modules/@metamask/transaction-controller/dist/utils/history.js.map
new file mode 100644
index 0000000..fdaa643
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/history.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"history.js","sourceRoot":"","sources":["../../src/utils/history.ts"],"names":[],"mappings":";;;;;;AAAA,sEAAyC;AACzC,mCAAmC;AAQnC;;;;GAIG;AACH,SAAgB,yBAAyB,CAAC,eAAgC;IACxE,MAAM,QAAQ,GAAG,2BAA2B,CAAC,eAAe,CAAC,CAAC;IAC9D,eAAe,CAAC,OAAO,GAAG,CAAC,QAAQ,CAAC,CAAC;AACvC,CAAC;AAHD,8DAGC;AAED;;;;;GAKG;AACH,SAAgB,wBAAwB,CACtC,eAAgC,EAChC,IAAY;;IAEZ,IAAI,CAAC,eAAe,CAAC,OAAO,EAAE;QAC5B,OAAO;KACR;IAED,MAAM,YAAY,GAAG,2BAA2B,CAAC,eAAe,CAAC,CAAC;IAClE,MAAM,aAAa,GAAG,aAAa,CACjC,eAAe,CAAC,OAA6B,CAC9C,CAAC;IAEF,MAAM,YAAY,GAAG,oBAAoB,CAAC,aAAa,EAAE,YAAY,EAAE,IAAI,CAAC,CAAC;IAE7E,IAAI,YAAY,CAAC,MAAM,EAAE;QACvB,MAAA,eAAe,aAAf,eAAe,uBAAf,eAAe,CAAE,OAAO,0CAAE,IAAI,CAAC,YAAY,CAAC,CAAC;KAC9C;AACH,CAAC;AAlBD,4DAkBC;AAED;;;;;;;GAOG;AACH,SAAS,oBAAoB;AAC3B,gCAAgC;AAChC,8DAA8D;AAC9D,aAAkB,EAClB,YAA6B,EAC7B,IAAY;IAEZ,MAAM,sBAAsB,GAAG,yBAAU,CAAC,OAAO,CAC/C,aAAa,EACb,YAAY,CACc,CAAC;IAC7B,kFAAkF;IAClF,IAAI,sBAAsB,CAAC,CAAC,CAAC,EAAE;QAC7B,IAAI,IAAI,EAAE;YACR,sBAAsB,CAAC,CAAC,CAAC,CAAC,IAAI,GAAG,IAAI,CAAC;SACvC;QACD,sBAAsB,CAAC,CAAC,CAAC,CAAC,SAAS,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;KAClD;IACD,OAAO,sBAAsB,CAAC;AAChC,CAAC;AAED;;;;;GAKG;AACH,SAAS,aAAa,CACpB,kBAAsC;IAEtC,MAAM,YAAY,GAAG,IAAA,kBAAS,EAAC,kBAAkB,CAAC,CAAC;IACnD,OAAO,YAAY,CAAC,MAAM;IACxB,gCAAgC;IAChC,8DAA8D;IAC9D,CAAC,GAAG,EAAE,KAAU,EAAE,EAAE,CAAC,yBAAU,CAAC,UAAU,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC,WAAW,CAChD,CAAC;AACvB,CAAC;AAED;;;;;GAKG;AACH,SAAS,2BAA2B,CAClC,eAAgC;IAEhC,MAAM,QAAQ,qBAAQ,eAAe,CAAE,CAAC;IACxC,OAAO,QAAQ,CAAC,OAAO,CAAC;IACxB,OAAO,IAAA,kBAAS,EAAC,QAAQ,CAAC,CAAC;AAC7B,CAAC","sourcesContent":["import jsonDiffer from 'fast-json-patch';\nimport { cloneDeep } from 'lodash';\n\nimport type {\n  TransactionHistory,\n  TransactionHistoryEntry,\n  TransactionMeta,\n} from '../types';\n\n/**\n * Add initial history snapshot to the provided transactionMeta history.\n *\n * @param transactionMeta - TransactionMeta to add initial history snapshot to.\n */\nexport function addInitialHistorySnapshot(transactionMeta: TransactionMeta) {\n  const snapshot = snapshotFromTransactionMeta(transactionMeta);\n  transactionMeta.history = [snapshot];\n}\n\n/**\n * Compares and adds history entry to the provided transactionMeta history.\n *\n * @param transactionMeta - TransactionMeta to add history entry to.\n * @param note - Note to add to history entry.\n */\nexport function updateTransactionHistory(\n  transactionMeta: TransactionMeta,\n  note: string,\n): void {\n  if (!transactionMeta.history) {\n    return;\n  }\n\n  const currentState = snapshotFromTransactionMeta(transactionMeta);\n  const previousState = replayHistory(\n    transactionMeta.history as TransactionHistory,\n  );\n\n  const historyEntry = generateHistoryEntry(previousState, currentState, note);\n\n  if (historyEntry.length) {\n    transactionMeta?.history?.push(historyEntry);\n  }\n}\n\n/**\n * Generates a history entry from the previous and new transaction metadata.\n *\n * @param previousState - The previous transaction metadata.\n * @param currentState - The new transaction metadata.\n * @param note - A note for the transaction metada update.\n * @returns An array of history operation.\n */\nfunction generateHistoryEntry(\n  // TODO: Replace `any` with type\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  previousState: any,\n  currentState: TransactionMeta,\n  note: string,\n): TransactionHistoryEntry {\n  const historyOperationsEntry = jsonDiffer.compare(\n    previousState,\n    currentState,\n  ) as TransactionHistoryEntry;\n  // Add a note to the first operation, since it breaks if we append it to the entry\n  if (historyOperationsEntry[0]) {\n    if (note) {\n      historyOperationsEntry[0].note = note;\n    }\n    historyOperationsEntry[0].timestamp = Date.now();\n  }\n  return historyOperationsEntry;\n}\n\n/**\n * Recovers previous transactionMeta from passed history array.\n *\n * @param transactionHistory - The transaction metadata to replay.\n * @returns The transaction metadata.\n */\nfunction replayHistory(\n  transactionHistory: TransactionHistory,\n): TransactionMeta {\n  const shortHistory = cloneDeep(transactionHistory);\n  return shortHistory.reduce(\n    // TODO: Replace `any` with type\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (val, entry: any) => jsonDiffer.applyPatch(val, entry).newDocument,\n  ) as TransactionMeta;\n}\n\n/**\n * Clone the transaction meta data without the history property.\n *\n * @param transactionMeta - The transaction metadata to snapshot.\n * @returns A deep clone of transaction metadata without history property.\n */\nfunction snapshotFromTransactionMeta(\n  transactionMeta: TransactionMeta,\n): TransactionMeta {\n  const snapshot = { ...transactionMeta };\n  delete snapshot.history;\n  return cloneDeep(snapshot);\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/nonce.d.ts b/node_modules/@metamask/transaction-controller/dist/utils/nonce.d.ts
new file mode 100644
index 0000000..04b9b52
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/nonce.d.ts
@@ -0,0 +1,21 @@
+import type { NonceTracker, Transaction as NonceTrackerTransaction } from 'nonce-tracker';
+import type { TransactionMeta, TransactionStatus } from '../types';
+/**
+ * Determine the next nonce to be used for a transaction.
+ *
+ * @param txMeta - The transaction metadata.
+ * @param nonceTracker - An instance of a nonce tracker.
+ * @returns The next hexadecimal nonce to be used for the given transaction, and optionally a function to release the nonce lock.
+ */
+export declare function getNextNonce(txMeta: TransactionMeta, nonceTracker: NonceTracker): Promise<[string, (() => void) | undefined]>;
+/**
+ * Filter and format transactions for the nonce tracker.
+ *
+ * @param currentChainId - Chain ID of the current network.
+ * @param fromAddress - Address of the account from which the transactions to filter from are sent.
+ * @param transactionStatus - Status of the transactions for which to filter.
+ * @param transactions - Array of transactionMeta objects that have been prefiltered.
+ * @returns Array of transactions formatted for the nonce tracker.
+ */
+export declare function getAndFormatTransactionsForNonceTracker(currentChainId: string, fromAddress: string, transactionStatus: TransactionStatus, transactions: TransactionMeta[]): NonceTrackerTransaction[];
+//# sourceMappingURL=nonce.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/nonce.d.ts.map b/node_modules/@metamask/transaction-controller/dist/utils/nonce.d.ts.map
new file mode 100644
index 0000000..0914c21
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/nonce.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"nonce.d.ts","sourceRoot":"","sources":["../../src/utils/nonce.ts"],"names":[],"mappings":"AACA,OAAO,KAAK,EACV,YAAY,EACZ,WAAW,IAAI,uBAAuB,EACvC,MAAM,eAAe,CAAC;AAGvB,OAAO,KAAK,EAAE,eAAe,EAAE,iBAAiB,EAAE,MAAM,UAAU,CAAC;AAInE;;;;;;GAMG;AACH,wBAAsB,YAAY,CAChC,MAAM,EAAE,eAAe,EACvB,YAAY,EAAE,YAAY,GACzB,OAAO,CAAC,CAAC,MAAM,EAAE,CAAC,MAAM,IAAI,CAAC,GAAG,SAAS,CAAC,CAAC,CAyB7C;AAED;;;;;;;;GAQG;AACH,wBAAgB,uCAAuC,CACrD,cAAc,EAAE,MAAM,EACtB,WAAW,EAAE,MAAM,EACnB,iBAAiB,EAAE,iBAAiB,EACpC,YAAY,EAAE,eAAe,EAAE,GAC9B,uBAAuB,EAAE,CA0B3B"}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/nonce.js b/node_modules/@metamask/transaction-controller/dist/utils/nonce.js
new file mode 100644
index 0000000..686d398
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/nonce.js
@@ -0,0 +1,77 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.getAndFormatTransactionsForNonceTracker = exports.getNextNonce = void 0;
+const controller_utils_1 = require("@metamask/controller-utils");
+const logger_1 = require("../logger");
+const log = (0, logger_1.createModuleLogger)(logger_1.projectLogger, 'nonce');
+/**
+ * Determine the next nonce to be used for a transaction.
+ *
+ * @param txMeta - The transaction metadata.
+ * @param nonceTracker - An instance of a nonce tracker.
+ * @returns The next hexadecimal nonce to be used for the given transaction, and optionally a function to release the nonce lock.
+ */
+function getNextNonce(txMeta, nonceTracker) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const { customNonceValue, txParams: { from, nonce: existingNonce }, } = txMeta;
+        const customNonce = customNonceValue ? (0, controller_utils_1.toHex)(customNonceValue) : undefined;
+        if (customNonce) {
+            log('Using custom nonce', customNonce);
+            return [customNonce, undefined];
+        }
+        if (existingNonce) {
+            log('Using existing nonce', existingNonce);
+            return [existingNonce, undefined];
+        }
+        const nonceLock = yield nonceTracker.getNonceLock(from);
+        const nonce = (0, controller_utils_1.toHex)(nonceLock.nextNonce);
+        const releaseLock = nonceLock.releaseLock.bind(nonceLock);
+        log('Using nonce from nonce tracker', nonce, nonceLock.nonceDetails);
+        return [nonce, releaseLock];
+    });
+}
+exports.getNextNonce = getNextNonce;
+/**
+ * Filter and format transactions for the nonce tracker.
+ *
+ * @param currentChainId - Chain ID of the current network.
+ * @param fromAddress - Address of the account from which the transactions to filter from are sent.
+ * @param transactionStatus - Status of the transactions for which to filter.
+ * @param transactions - Array of transactionMeta objects that have been prefiltered.
+ * @returns Array of transactions formatted for the nonce tracker.
+ */
+function getAndFormatTransactionsForNonceTracker(currentChainId, fromAddress, transactionStatus, transactions) {
+    return transactions
+        .filter(({ chainId, isTransfer, isUserOperation, status, txParams: { from } }) => !isTransfer &&
+        !isUserOperation &&
+        chainId === currentChainId &&
+        status === transactionStatus &&
+        from.toLowerCase() === fromAddress.toLowerCase())
+        .map(({ status, txParams: { from, gas, value, nonce } }) => {
+        // the only value we care about is the nonce
+        // but we need to return the other values to satisfy the type
+        // TODO: refactor nonceTracker to not require this
+        /* istanbul ignore next */
+        return {
+            status,
+            history: [{}],
+            txParams: {
+                from: from !== null && from !== void 0 ? from : '',
+                gas: gas !== null && gas !== void 0 ? gas : '',
+                value: value !== null && value !== void 0 ? value : '',
+                nonce: nonce !== null && nonce !== void 0 ? nonce : '',
+            },
+        };
+    });
+}
+exports.getAndFormatTransactionsForNonceTracker = getAndFormatTransactionsForNonceTracker;
+//# sourceMappingURL=nonce.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/nonce.js.map b/node_modules/@metamask/transaction-controller/dist/utils/nonce.js.map
new file mode 100644
index 0000000..21a35c3
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/nonce.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"nonce.js","sourceRoot":"","sources":["../../src/utils/nonce.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,iEAAmD;AAMnD,sCAA8D;AAG9D,MAAM,GAAG,GAAG,IAAA,2BAAkB,EAAC,sBAAa,EAAE,OAAO,CAAC,CAAC;AAEvD;;;;;;GAMG;AACH,SAAsB,YAAY,CAChC,MAAuB,EACvB,YAA0B;;QAE1B,MAAM,EACJ,gBAAgB,EAChB,QAAQ,EAAE,EAAE,IAAI,EAAE,KAAK,EAAE,aAAa,EAAE,GACzC,GAAG,MAAM,CAAC;QAEX,MAAM,WAAW,GAAG,gBAAgB,CAAC,CAAC,CAAC,IAAA,wBAAK,EAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;QAE3E,IAAI,WAAW,EAAE;YACf,GAAG,CAAC,oBAAoB,EAAE,WAAW,CAAC,CAAC;YACvC,OAAO,CAAC,WAAW,EAAE,SAAS,CAAC,CAAC;SACjC;QAED,IAAI,aAAa,EAAE;YACjB,GAAG,CAAC,sBAAsB,EAAE,aAAa,CAAC,CAAC;YAC3C,OAAO,CAAC,aAAa,EAAE,SAAS,CAAC,CAAC;SACnC;QAED,MAAM,SAAS,GAAG,MAAM,YAAY,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;QACxD,MAAM,KAAK,GAAG,IAAA,wBAAK,EAAC,SAAS,CAAC,SAAS,CAAC,CAAC;QACzC,MAAM,WAAW,GAAG,SAAS,CAAC,WAAW,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QAE1D,GAAG,CAAC,gCAAgC,EAAE,KAAK,EAAE,SAAS,CAAC,YAAY,CAAC,CAAC;QAErE,OAAO,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC;IAC9B,CAAC;CAAA;AA5BD,oCA4BC;AAED;;;;;;;;GAQG;AACH,SAAgB,uCAAuC,CACrD,cAAsB,EACtB,WAAmB,EACnB,iBAAoC,EACpC,YAA+B;IAE/B,OAAO,YAAY;SAChB,MAAM,CACL,CAAC,EAAE,OAAO,EAAE,UAAU,EAAE,eAAe,EAAE,MAAM,EAAE,QAAQ,EAAE,EAAE,IAAI,EAAE,EAAE,EAAE,EAAE,CACvE,CAAC,UAAU;QACX,CAAC,eAAe;QAChB,OAAO,KAAK,cAAc;QAC1B,MAAM,KAAK,iBAAiB;QAC5B,IAAI,CAAC,WAAW,EAAE,KAAK,WAAW,CAAC,WAAW,EAAE,CACnD;SACA,GAAG,CAAC,CAAC,EAAE,MAAM,EAAE,QAAQ,EAAE,EAAE,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE,KAAK,EAAE,EAAE,EAAE,EAAE;QACzD,4CAA4C;QAC5C,6DAA6D;QAC7D,kDAAkD;QAClD,0BAA0B;QAC1B,OAAO;YACL,MAAM;YACN,OAAO,EAAE,CAAC,EAAE,CAAC;YACb,QAAQ,EAAE;gBACR,IAAI,EAAE,IAAI,aAAJ,IAAI,cAAJ,IAAI,GAAI,EAAE;gBAChB,GAAG,EAAE,GAAG,aAAH,GAAG,cAAH,GAAG,GAAI,EAAE;gBACd,KAAK,EAAE,KAAK,aAAL,KAAK,cAAL,KAAK,GAAI,EAAE;gBAClB,KAAK,EAAE,KAAK,aAAL,KAAK,cAAL,KAAK,GAAI,EAAE;aACnB;SACF,CAAC;IACJ,CAAC,CAAC,CAAC;AACP,CAAC;AA/BD,0FA+BC","sourcesContent":["import { toHex } from '@metamask/controller-utils';\nimport type {\n  NonceTracker,\n  Transaction as NonceTrackerTransaction,\n} from 'nonce-tracker';\n\nimport { createModuleLogger, projectLogger } from '../logger';\nimport type { TransactionMeta, TransactionStatus } from '../types';\n\nconst log = createModuleLogger(projectLogger, 'nonce');\n\n/**\n * Determine the next nonce to be used for a transaction.\n *\n * @param txMeta - The transaction metadata.\n * @param nonceTracker - An instance of a nonce tracker.\n * @returns The next hexadecimal nonce to be used for the given transaction, and optionally a function to release the nonce lock.\n */\nexport async function getNextNonce(\n  txMeta: TransactionMeta,\n  nonceTracker: NonceTracker,\n): Promise<[string, (() => void) | undefined]> {\n  const {\n    customNonceValue,\n    txParams: { from, nonce: existingNonce },\n  } = txMeta;\n\n  const customNonce = customNonceValue ? toHex(customNonceValue) : undefined;\n\n  if (customNonce) {\n    log('Using custom nonce', customNonce);\n    return [customNonce, undefined];\n  }\n\n  if (existingNonce) {\n    log('Using existing nonce', existingNonce);\n    return [existingNonce, undefined];\n  }\n\n  const nonceLock = await nonceTracker.getNonceLock(from);\n  const nonce = toHex(nonceLock.nextNonce);\n  const releaseLock = nonceLock.releaseLock.bind(nonceLock);\n\n  log('Using nonce from nonce tracker', nonce, nonceLock.nonceDetails);\n\n  return [nonce, releaseLock];\n}\n\n/**\n * Filter and format transactions for the nonce tracker.\n *\n * @param currentChainId - Chain ID of the current network.\n * @param fromAddress - Address of the account from which the transactions to filter from are sent.\n * @param transactionStatus - Status of the transactions for which to filter.\n * @param transactions - Array of transactionMeta objects that have been prefiltered.\n * @returns Array of transactions formatted for the nonce tracker.\n */\nexport function getAndFormatTransactionsForNonceTracker(\n  currentChainId: string,\n  fromAddress: string,\n  transactionStatus: TransactionStatus,\n  transactions: TransactionMeta[],\n): NonceTrackerTransaction[] {\n  return transactions\n    .filter(\n      ({ chainId, isTransfer, isUserOperation, status, txParams: { from } }) =>\n        !isTransfer &&\n        !isUserOperation &&\n        chainId === currentChainId &&\n        status === transactionStatus &&\n        from.toLowerCase() === fromAddress.toLowerCase(),\n    )\n    .map(({ status, txParams: { from, gas, value, nonce } }) => {\n      // the only value we care about is the nonce\n      // but we need to return the other values to satisfy the type\n      // TODO: refactor nonceTracker to not require this\n      /* istanbul ignore next */\n      return {\n        status,\n        history: [{}],\n        txParams: {\n          from: from ?? '',\n          gas: gas ?? '',\n          value: value ?? '',\n          nonce: nonce ?? '',\n        },\n      };\n    });\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/swaps.d.ts b/node_modules/@metamask/transaction-controller/dist/utils/swaps.d.ts
new file mode 100644
index 0000000..c2eb3a1
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/swaps.d.ts
@@ -0,0 +1,81 @@
+import type EthQuery from '@metamask/eth-query';
+import type { Events, TransactionMeta } from '../types';
+import { TransactionType } from '../types';
+/**
+ * Interval in milliseconds between checks of post transaction balance
+ */
+export declare const UPDATE_POST_TX_BALANCE_TIMEOUT = 5000;
+/**
+ * Retry attempts for checking post transaction balance
+ */
+export declare const UPDATE_POST_TX_BALANCE_ATTEMPTS = 6;
+/**
+ * An address that the metaswap-api recognizes as the default token for the current network, in place of the token address that ERC-20 tokens have
+ */
+export declare const DEFAULT_TOKEN_ADDRESS = "0x0000000000000000000000000000000000000000";
+interface SwapsTokenObject {
+    /**
+     * The name for the network
+     */
+    name: string;
+    /**
+     * An address that the metaswap-api recognizes as the default token
+     */
+    address: string;
+    /**
+     * Number of digits after decimal point
+     */
+    decimals: number;
+}
+export declare const SWAPS_CHAINID_DEFAULT_TOKEN_MAP: {
+    readonly "0x1": SwapsTokenObject;
+    readonly "0x539": SwapsTokenObject;
+    readonly "0x38": SwapsTokenObject;
+    readonly "0x89": SwapsTokenObject;
+    readonly "0x5": SwapsTokenObject;
+    readonly "0xa86a": SwapsTokenObject;
+    readonly "0xa": SwapsTokenObject;
+    readonly "0xa4b1": SwapsTokenObject;
+    readonly "0x144": SwapsTokenObject;
+};
+export declare const SWAP_TRANSACTION_TYPES: TransactionType[];
+/**
+ * Updates the transaction meta object with the swap information
+ *
+ * @param transactionMeta - The transaction meta object to update
+ * @param transactionType - The type of the transaction
+ * @param swaps - The swaps object
+ * @param swaps.hasApproveTx - Whether the swap has an approval transaction
+ * @param swaps.meta - The swap meta object
+ * @param updateSwapsTransactionRequest - Dependency bag
+ * @param updateSwapsTransactionRequest.isSwapsDisabled - Whether swaps are disabled
+ * @param updateSwapsTransactionRequest.cancelTransaction - Function to cancel a transaction
+ * @param updateSwapsTransactionRequest.controllerHubEmitter - Function to emit an event to the controller hub
+ */
+export declare function updateSwapsTransaction(transactionMeta: TransactionMeta, transactionType: TransactionType, swaps: {
+    hasApproveTx?: boolean;
+    meta?: Partial<TransactionMeta>;
+}, { isSwapsDisabled, cancelTransaction, controllerHubEmitter, }: {
+    isSwapsDisabled: boolean;
+    cancelTransaction: (transactionId: string) => void;
+    controllerHubEmitter: <T extends keyof Events>(eventName: T, ...args: Events[T]) => boolean;
+}): Promise<void>;
+/**
+ * Attempts to update the post transaction balance of the provided transaction
+ *
+ * @param transactionMeta - Transaction meta object to update
+ * @param updatePostTransactionBalanceRequest - Dependency bag
+ * @param updatePostTransactionBalanceRequest.ethQuery - EthQuery object
+ * @param updatePostTransactionBalanceRequest.getTransaction - Reading function for the latest transaction state
+ * @param updatePostTransactionBalanceRequest.updateTransaction - Updating transaction function
+ */
+export declare function updatePostTransactionBalance(transactionMeta: TransactionMeta, { ethQuery, getTransaction, updateTransaction, }: {
+    ethQuery: EthQuery;
+    getTransaction: (transactionId: string) => TransactionMeta | undefined;
+    updateTransaction: (transactionMeta: TransactionMeta, note: string) => void;
+}): Promise<{
+    updatedTransactionMeta: TransactionMeta;
+    approvalTransactionMeta?: TransactionMeta;
+}>;
+export {};
+//# sourceMappingURL=swaps.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/swaps.d.ts.map b/node_modules/@metamask/transaction-controller/dist/utils/swaps.d.ts.map
new file mode 100644
index 0000000..a1312b7
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/swaps.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"swaps.d.ts","sourceRoot":"","sources":["../../src/utils/swaps.ts"],"names":[],"mappings":"AACA,OAAO,KAAK,QAAQ,MAAM,qBAAqB,CAAC;AAKhD,OAAO,KAAK,EAAE,MAAM,EAAE,eAAe,EAAE,MAAM,UAAU,CAAC;AACxD,OAAO,EAAE,eAAe,EAAE,MAAM,UAAU,CAAC;AAK3C;;GAEG;AACH,eAAO,MAAM,8BAA8B,OAAO,CAAC;AAEnD;;GAEG;AACH,eAAO,MAAM,+BAA+B,IAAI,CAAC;AAIjD;;GAEG;AACH,eAAO,MAAM,qBAAqB,+CACY,CAAC;AAI/C,UAAU,gBAAgB;IACxB;;OAEG;IACH,IAAI,EAAE,MAAM,CAAC;IACb;;OAEG;IACH,OAAO,EAAE,MAAM,CAAC;IAChB;;OAEG;IACH,QAAQ,EAAE,MAAM,CAAC;CAClB;AAkDD,eAAO,MAAM,+BAA+B;;;;;;;;;;CAUlC,CAAC;AAEX,eAAO,MAAM,sBAAsB,mBAGlC,CAAC;AAEF;;;;;;;;;;;;GAYG;AACH,wBAAsB,sBAAsB,CAC1C,eAAe,EAAE,eAAe,EAChC,eAAe,EAAE,eAAe,EAChC,KAAK,EAAE;IACL,YAAY,CAAC,EAAE,OAAO,CAAC;IACvB,IAAI,CAAC,EAAE,OAAO,CAAC,eAAe,CAAC,CAAC;CACjC,EACD,EACE,eAAe,EACf,iBAAiB,EACjB,oBAAoB,GACrB,EAAE;IACD,eAAe,EAAE,OAAO,CAAC;IACzB,iBAAiB,EAAE,CAAC,aAAa,EAAE,MAAM,KAAK,IAAI,CAAC;IACnD,oBAAoB,EAAE,CAAC,CAAC,SAAS,MAAM,MAAM,EAC3C,SAAS,EAAE,CAAC,EACZ,GAAG,IAAI,EAAE,MAAM,CAAC,CAAC,CAAC,KACf,OAAO,CAAC;CACd,iBAyCF;AAED;;;;;;;;GAQG;AACH,wBAAsB,4BAA4B,CAChD,eAAe,EAAE,eAAe,EAChC,EACE,QAAQ,EACR,cAAc,EACd,iBAAiB,GAClB,EAAE;IACD,QAAQ,EAAE,QAAQ,CAAC;IACnB,cAAc,EAAE,CAAC,aAAa,EAAE,MAAM,KAAK,eAAe,GAAG,SAAS,CAAC;IACvE,iBAAiB,EAAE,CAAC,eAAe,EAAE,eAAe,EAAE,IAAI,EAAE,MAAM,KAAK,IAAI,CAAC;CAC7E,GACA,OAAO,CAAC;IACT,sBAAsB,EAAE,eAAe,CAAC;IACxC,uBAAuB,CAAC,EAAE,eAAe,CAAC;CAC3C,CAAC,CAyDD"}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/swaps.js b/node_modules/@metamask/transaction-controller/dist/utils/swaps.js
new file mode 100644
index 0000000..ecf4c46
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/swaps.js
@@ -0,0 +1,257 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.updatePostTransactionBalance = exports.updateSwapsTransaction = exports.SWAP_TRANSACTION_TYPES = exports.SWAPS_CHAINID_DEFAULT_TOKEN_MAP = exports.DEFAULT_TOKEN_ADDRESS = exports.UPDATE_POST_TX_BALANCE_ATTEMPTS = exports.UPDATE_POST_TX_BALANCE_TIMEOUT = void 0;
+const controller_utils_1 = require("@metamask/controller-utils");
+const lodash_1 = require("lodash");
+const constants_1 = require("../constants");
+const logger_1 = require("../logger");
+const types_1 = require("../types");
+const utils_1 = require("./utils");
+const log = (0, logger_1.createModuleLogger)(logger_1.projectLogger, 'swaps');
+/**
+ * Interval in milliseconds between checks of post transaction balance
+ */
+exports.UPDATE_POST_TX_BALANCE_TIMEOUT = 5000;
+/**
+ * Retry attempts for checking post transaction balance
+ */
+exports.UPDATE_POST_TX_BALANCE_ATTEMPTS = 6;
+const SWAPS_TESTNET_CHAIN_ID = '0x539';
+/**
+ * An address that the metaswap-api recognizes as the default token for the current network, in place of the token address that ERC-20 tokens have
+ */
+exports.DEFAULT_TOKEN_ADDRESS = '0x0000000000000000000000000000000000000000';
+const ETH_SWAPS_TOKEN_OBJECT = {
+    name: 'Ether',
+    address: exports.DEFAULT_TOKEN_ADDRESS,
+    decimals: 18,
+};
+const BNB_SWAPS_TOKEN_OBJECT = {
+    name: 'Binance Coin',
+    address: exports.DEFAULT_TOKEN_ADDRESS,
+    decimals: 18,
+};
+const MATIC_SWAPS_TOKEN_OBJECT = {
+    name: 'Matic',
+    address: exports.DEFAULT_TOKEN_ADDRESS,
+    decimals: 18,
+};
+const AVAX_SWAPS_TOKEN_OBJECT = {
+    name: 'Avalanche',
+    address: exports.DEFAULT_TOKEN_ADDRESS,
+    decimals: 18,
+};
+const TEST_ETH_SWAPS_TOKEN_OBJECT = {
+    name: 'Test Ether',
+    address: exports.DEFAULT_TOKEN_ADDRESS,
+    decimals: 18,
+};
+const GOERLI_SWAPS_TOKEN_OBJECT = {
+    name: 'Ether',
+    address: exports.DEFAULT_TOKEN_ADDRESS,
+    decimals: 18,
+};
+const ARBITRUM_SWAPS_TOKEN_OBJECT = Object.assign({}, ETH_SWAPS_TOKEN_OBJECT);
+const OPTIMISM_SWAPS_TOKEN_OBJECT = Object.assign({}, ETH_SWAPS_TOKEN_OBJECT);
+const ZKSYNC_ERA_SWAPS_TOKEN_OBJECT = Object.assign({}, ETH_SWAPS_TOKEN_OBJECT);
+exports.SWAPS_CHAINID_DEFAULT_TOKEN_MAP = {
+    [constants_1.CHAIN_IDS.MAINNET]: ETH_SWAPS_TOKEN_OBJECT,
+    [SWAPS_TESTNET_CHAIN_ID]: TEST_ETH_SWAPS_TOKEN_OBJECT,
+    [constants_1.CHAIN_IDS.BSC]: BNB_SWAPS_TOKEN_OBJECT,
+    [constants_1.CHAIN_IDS.POLYGON]: MATIC_SWAPS_TOKEN_OBJECT,
+    [constants_1.CHAIN_IDS.GOERLI]: GOERLI_SWAPS_TOKEN_OBJECT,
+    [constants_1.CHAIN_IDS.AVALANCHE]: AVAX_SWAPS_TOKEN_OBJECT,
+    [constants_1.CHAIN_IDS.OPTIMISM]: OPTIMISM_SWAPS_TOKEN_OBJECT,
+    [constants_1.CHAIN_IDS.ARBITRUM]: ARBITRUM_SWAPS_TOKEN_OBJECT,
+    [constants_1.CHAIN_IDS.ZKSYNC_ERA]: ZKSYNC_ERA_SWAPS_TOKEN_OBJECT,
+};
+exports.SWAP_TRANSACTION_TYPES = [
+    types_1.TransactionType.swap,
+    types_1.TransactionType.swapApproval,
+];
+/**
+ * Updates the transaction meta object with the swap information
+ *
+ * @param transactionMeta - The transaction meta object to update
+ * @param transactionType - The type of the transaction
+ * @param swaps - The swaps object
+ * @param swaps.hasApproveTx - Whether the swap has an approval transaction
+ * @param swaps.meta - The swap meta object
+ * @param updateSwapsTransactionRequest - Dependency bag
+ * @param updateSwapsTransactionRequest.isSwapsDisabled - Whether swaps are disabled
+ * @param updateSwapsTransactionRequest.cancelTransaction - Function to cancel a transaction
+ * @param updateSwapsTransactionRequest.controllerHubEmitter - Function to emit an event to the controller hub
+ */
+function updateSwapsTransaction(transactionMeta, transactionType, swaps, { isSwapsDisabled, cancelTransaction, controllerHubEmitter, }) {
+    return __awaiter(this, void 0, void 0, function* () {
+        if (isSwapsDisabled || !exports.SWAP_TRANSACTION_TYPES.includes(transactionType)) {
+            return;
+        }
+        // The simulationFails property is added if the estimateGas call fails. In cases
+        // when no swaps approval tx is required, this indicates that the swap will likely
+        // fail. There was an earlier estimateGas call made by the swaps controller,
+        // but it is possible that external conditions have change since then, and
+        // a previously succeeding estimate gas call could now fail. By checking for
+        // the `simulationFails` property here, we can reduce the number of swap
+        // transactions that get published to the blockchain only to fail and thereby
+        // waste the user's funds on gas.
+        if (transactionType === types_1.TransactionType.swap &&
+            (swaps === null || swaps === void 0 ? void 0 : swaps.hasApproveTx) === false &&
+            transactionMeta.simulationFails) {
+            yield cancelTransaction(transactionMeta.id);
+            throw new Error('Simulation failed');
+        }
+        const swapsMeta = swaps === null || swaps === void 0 ? void 0 : swaps.meta;
+        if (!swapsMeta) {
+            return;
+        }
+        if (transactionType === types_1.TransactionType.swapApproval) {
+            updateSwapApprovalTransaction(transactionMeta, swapsMeta);
+            controllerHubEmitter('transaction-new-swap-approval', {
+                transactionMeta,
+            });
+        }
+        if (transactionType === types_1.TransactionType.swap) {
+            updateSwapTransaction(transactionMeta, swapsMeta);
+            controllerHubEmitter('transaction-new-swap', {
+                transactionMeta,
+            });
+        }
+    });
+}
+exports.updateSwapsTransaction = updateSwapsTransaction;
+/**
+ * Attempts to update the post transaction balance of the provided transaction
+ *
+ * @param transactionMeta - Transaction meta object to update
+ * @param updatePostTransactionBalanceRequest - Dependency bag
+ * @param updatePostTransactionBalanceRequest.ethQuery - EthQuery object
+ * @param updatePostTransactionBalanceRequest.getTransaction - Reading function for the latest transaction state
+ * @param updatePostTransactionBalanceRequest.updateTransaction - Updating transaction function
+ */
+function updatePostTransactionBalance(transactionMeta, { ethQuery, getTransaction, updateTransaction, }) {
+    return __awaiter(this, void 0, void 0, function* () {
+        log('Updating post transaction balance', transactionMeta.id);
+        const transactionId = transactionMeta.id;
+        let latestTransactionMeta, approvalTransactionMeta;
+        for (let i = 0; i < exports.UPDATE_POST_TX_BALANCE_ATTEMPTS; i++) {
+            log('Querying balance', { attempt: i });
+            const postTransactionBalance = yield (0, controller_utils_1.query)(ethQuery, 'getBalance', [
+                transactionMeta.txParams.from,
+            ]);
+            latestTransactionMeta = getTransaction(transactionId);
+            approvalTransactionMeta = latestTransactionMeta.approvalTxId
+                ? getTransaction(latestTransactionMeta.approvalTxId)
+                : undefined;
+            latestTransactionMeta.postTxBalance = postTransactionBalance.toString(16);
+            const isDefaultTokenAddress = isSwapsDefaultTokenAddress(transactionMeta.destinationTokenAddress, transactionMeta.chainId);
+            if (!isDefaultTokenAddress ||
+                transactionMeta.preTxBalance !== latestTransactionMeta.postTxBalance) {
+                log('Finishing post balance update', {
+                    isDefaultTokenAddress,
+                    preTxBalance: transactionMeta.preTxBalance,
+                    postTxBalance: latestTransactionMeta.postTxBalance,
+                });
+                break;
+            }
+            log('Waiting for balance to update', {
+                delay: exports.UPDATE_POST_TX_BALANCE_TIMEOUT,
+            });
+            yield sleep(exports.UPDATE_POST_TX_BALANCE_TIMEOUT);
+        }
+        updateTransaction(latestTransactionMeta, 'TransactionController#updatePostTransactionBalance - Add post transaction balance');
+        log('Completed post balance update', latestTransactionMeta === null || latestTransactionMeta === void 0 ? void 0 : latestTransactionMeta.postTxBalance);
+        return {
+            updatedTransactionMeta: latestTransactionMeta,
+            approvalTransactionMeta,
+        };
+    });
+}
+exports.updatePostTransactionBalance = updatePostTransactionBalance;
+/**
+ * Updates the transaction meta object with the swap information
+ *
+ * @param transactionMeta - Transaction meta object to update
+ * @param propsToUpdate - Properties to update
+ * @param propsToUpdate.sourceTokenSymbol - Symbol of the token to be swapped
+ * @param propsToUpdate.destinationTokenSymbol - Symbol of the token to be received
+ * @param propsToUpdate.type - Type of the transaction
+ * @param propsToUpdate.destinationTokenDecimals - Decimals of the token to be received
+ * @param propsToUpdate.destinationTokenAddress - Address of the token to be received
+ * @param propsToUpdate.swapMetaData - Metadata of the swap
+ * @param propsToUpdate.swapTokenValue - Value of the token to be swapped
+ * @param propsToUpdate.estimatedBaseFee - Estimated base fee of the transaction
+ * @param propsToUpdate.approvalTxId - Transaction id of the approval transaction
+ */
+function updateSwapTransaction(transactionMeta, { sourceTokenSymbol, destinationTokenSymbol, type, destinationTokenDecimals, destinationTokenAddress, swapMetaData, swapTokenValue, estimatedBaseFee, approvalTxId, }) {
+    (0, utils_1.validateIfTransactionUnapproved)(transactionMeta, 'updateSwapTransaction');
+    let swapTransaction = {
+        sourceTokenSymbol,
+        destinationTokenSymbol,
+        type,
+        destinationTokenDecimals,
+        destinationTokenAddress,
+        swapMetaData,
+        swapTokenValue,
+        estimatedBaseFee,
+        approvalTxId,
+    };
+    // TODO: Replace `any` with type
+    // eslint-disable-next-line @typescript-eslint/no-explicit-any
+    swapTransaction = (0, lodash_1.pickBy)(swapTransaction);
+    (0, lodash_1.merge)(transactionMeta, swapTransaction);
+}
+/**
+ * Updates the transaction meta object with the swap approval information
+ *
+ * @param transactionMeta - Transaction meta object to update
+ * @param propsToUpdate - Properties to update
+ * @param propsToUpdate.type - Type of the transaction
+ * @param propsToUpdate.sourceTokenSymbol - Symbol of the token to be swapped
+ */
+function updateSwapApprovalTransaction(transactionMeta, { type, sourceTokenSymbol }) {
+    (0, utils_1.validateIfTransactionUnapproved)(transactionMeta, 'updateSwapApprovalTransaction');
+    // TODO: Replace `any` with type
+    // eslint-disable-next-line @typescript-eslint/no-explicit-any
+    let swapApprovalTransaction = { type, sourceTokenSymbol };
+    swapApprovalTransaction = (0, lodash_1.pickBy)({
+        type,
+        sourceTokenSymbol,
+    });
+    (0, lodash_1.merge)(transactionMeta, swapApprovalTransaction);
+}
+/**
+ * Checks whether the provided address is strictly equal to the address for
+ * the default swaps token of the provided chain.
+ *
+ * @param address - The string to compare to the default token address
+ * @param chainId - The hex encoded chain ID of the default swaps token to check
+ * @returns Whether the address is the provided chain's default token address
+ */
+function isSwapsDefaultTokenAddress(address, chainId) {
+    var _a;
+    if (!address || !chainId) {
+        return false;
+    }
+    return (address ===
+        ((_a = exports.SWAPS_CHAINID_DEFAULT_TOKEN_MAP[chainId]) === null || _a === void 0 ? void 0 : _a.address));
+}
+/**
+ * Sleeps for the provided number of milliseconds
+ *
+ * @param ms - Number of milliseconds to sleep
+ * @returns Promise that resolves after the provided number of milliseconds
+ */
+function sleep(ms) {
+    return new Promise((resolve) => setTimeout(resolve, ms));
+}
+//# sourceMappingURL=swaps.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/swaps.js.map b/node_modules/@metamask/transaction-controller/dist/utils/swaps.js.map
new file mode 100644
index 0000000..773cba5
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/swaps.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"swaps.js","sourceRoot":"","sources":["../../src/utils/swaps.ts"],"names":[],"mappings":"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","sourcesContent":["import { query } from '@metamask/controller-utils';\nimport type EthQuery from '@metamask/eth-query';\nimport { merge, pickBy } from 'lodash';\n\nimport { CHAIN_IDS } from '../constants';\nimport { createModuleLogger, projectLogger } from '../logger';\nimport type { Events, TransactionMeta } from '../types';\nimport { TransactionType } from '../types';\nimport { validateIfTransactionUnapproved } from './utils';\n\nconst log = createModuleLogger(projectLogger, 'swaps');\n\n/**\n * Interval in milliseconds between checks of post transaction balance\n */\nexport const UPDATE_POST_TX_BALANCE_TIMEOUT = 5000;\n\n/**\n * Retry attempts for checking post transaction balance\n */\nexport const UPDATE_POST_TX_BALANCE_ATTEMPTS = 6;\n\nconst SWAPS_TESTNET_CHAIN_ID = '0x539';\n\n/**\n * An address that the metaswap-api recognizes as the default token for the current network, in place of the token address that ERC-20 tokens have\n */\nexport const DEFAULT_TOKEN_ADDRESS =\n  '0x0000000000000000000000000000000000000000';\n\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\ninterface SwapsTokenObject {\n  /**\n   * The name for the network\n   */\n  name: string;\n  /**\n   * An address that the metaswap-api recognizes as the default token\n   */\n  address: string;\n  /**\n   * Number of digits after decimal point\n   */\n  decimals: number;\n}\n\nconst ETH_SWAPS_TOKEN_OBJECT: SwapsTokenObject = {\n  name: 'Ether',\n  address: DEFAULT_TOKEN_ADDRESS,\n  decimals: 18,\n};\n\nconst BNB_SWAPS_TOKEN_OBJECT: SwapsTokenObject = {\n  name: 'Binance Coin',\n  address: DEFAULT_TOKEN_ADDRESS,\n  decimals: 18,\n} as const;\n\nconst MATIC_SWAPS_TOKEN_OBJECT: SwapsTokenObject = {\n  name: 'Matic',\n  address: DEFAULT_TOKEN_ADDRESS,\n  decimals: 18,\n} as const;\n\nconst AVAX_SWAPS_TOKEN_OBJECT: SwapsTokenObject = {\n  name: 'Avalanche',\n  address: DEFAULT_TOKEN_ADDRESS,\n  decimals: 18,\n} as const;\n\nconst TEST_ETH_SWAPS_TOKEN_OBJECT: SwapsTokenObject = {\n  name: 'Test Ether',\n  address: DEFAULT_TOKEN_ADDRESS,\n  decimals: 18,\n} as const;\n\nconst GOERLI_SWAPS_TOKEN_OBJECT: SwapsTokenObject = {\n  name: 'Ether',\n  address: DEFAULT_TOKEN_ADDRESS,\n  decimals: 18,\n} as const;\n\nconst ARBITRUM_SWAPS_TOKEN_OBJECT: SwapsTokenObject = {\n  ...ETH_SWAPS_TOKEN_OBJECT,\n} as const;\n\nconst OPTIMISM_SWAPS_TOKEN_OBJECT: SwapsTokenObject = {\n  ...ETH_SWAPS_TOKEN_OBJECT,\n} as const;\n\nconst ZKSYNC_ERA_SWAPS_TOKEN_OBJECT: SwapsTokenObject = {\n  ...ETH_SWAPS_TOKEN_OBJECT,\n} as const;\n\nexport const SWAPS_CHAINID_DEFAULT_TOKEN_MAP = {\n  [CHAIN_IDS.MAINNET]: ETH_SWAPS_TOKEN_OBJECT,\n  [SWAPS_TESTNET_CHAIN_ID]: TEST_ETH_SWAPS_TOKEN_OBJECT,\n  [CHAIN_IDS.BSC]: BNB_SWAPS_TOKEN_OBJECT,\n  [CHAIN_IDS.POLYGON]: MATIC_SWAPS_TOKEN_OBJECT,\n  [CHAIN_IDS.GOERLI]: GOERLI_SWAPS_TOKEN_OBJECT,\n  [CHAIN_IDS.AVALANCHE]: AVAX_SWAPS_TOKEN_OBJECT,\n  [CHAIN_IDS.OPTIMISM]: OPTIMISM_SWAPS_TOKEN_OBJECT,\n  [CHAIN_IDS.ARBITRUM]: ARBITRUM_SWAPS_TOKEN_OBJECT,\n  [CHAIN_IDS.ZKSYNC_ERA]: ZKSYNC_ERA_SWAPS_TOKEN_OBJECT,\n} as const;\n\nexport const SWAP_TRANSACTION_TYPES = [\n  TransactionType.swap,\n  TransactionType.swapApproval,\n];\n\n/**\n * Updates the transaction meta object with the swap information\n *\n * @param transactionMeta - The transaction meta object to update\n * @param transactionType - The type of the transaction\n * @param swaps - The swaps object\n * @param swaps.hasApproveTx - Whether the swap has an approval transaction\n * @param swaps.meta - The swap meta object\n * @param updateSwapsTransactionRequest - Dependency bag\n * @param updateSwapsTransactionRequest.isSwapsDisabled - Whether swaps are disabled\n * @param updateSwapsTransactionRequest.cancelTransaction - Function to cancel a transaction\n * @param updateSwapsTransactionRequest.controllerHubEmitter - Function to emit an event to the controller hub\n */\nexport async function updateSwapsTransaction(\n  transactionMeta: TransactionMeta,\n  transactionType: TransactionType,\n  swaps: {\n    hasApproveTx?: boolean;\n    meta?: Partial<TransactionMeta>;\n  },\n  {\n    isSwapsDisabled,\n    cancelTransaction,\n    controllerHubEmitter,\n  }: {\n    isSwapsDisabled: boolean;\n    cancelTransaction: (transactionId: string) => void;\n    controllerHubEmitter: <T extends keyof Events>(\n      eventName: T,\n      ...args: Events[T]\n    ) => boolean;\n  },\n) {\n  if (isSwapsDisabled || !SWAP_TRANSACTION_TYPES.includes(transactionType)) {\n    return;\n  }\n  // The simulationFails property is added if the estimateGas call fails. In cases\n  // when no swaps approval tx is required, this indicates that the swap will likely\n  // fail. There was an earlier estimateGas call made by the swaps controller,\n  // but it is possible that external conditions have change since then, and\n  // a previously succeeding estimate gas call could now fail. By checking for\n  // the `simulationFails` property here, we can reduce the number of swap\n  // transactions that get published to the blockchain only to fail and thereby\n  // waste the user's funds on gas.\n  if (\n    transactionType === TransactionType.swap &&\n    swaps?.hasApproveTx === false &&\n    transactionMeta.simulationFails\n  ) {\n    await cancelTransaction(transactionMeta.id);\n    throw new Error('Simulation failed');\n  }\n\n  const swapsMeta = swaps?.meta as Partial<TransactionMeta>;\n\n  if (!swapsMeta) {\n    return;\n  }\n\n  if (transactionType === TransactionType.swapApproval) {\n    updateSwapApprovalTransaction(transactionMeta, swapsMeta);\n    controllerHubEmitter('transaction-new-swap-approval', {\n      transactionMeta,\n    });\n  }\n\n  if (transactionType === TransactionType.swap) {\n    updateSwapTransaction(transactionMeta, swapsMeta);\n    controllerHubEmitter('transaction-new-swap', {\n      transactionMeta,\n    });\n  }\n}\n\n/**\n * Attempts to update the post transaction balance of the provided transaction\n *\n * @param transactionMeta - Transaction meta object to update\n * @param updatePostTransactionBalanceRequest - Dependency bag\n * @param updatePostTransactionBalanceRequest.ethQuery - EthQuery object\n * @param updatePostTransactionBalanceRequest.getTransaction - Reading function for the latest transaction state\n * @param updatePostTransactionBalanceRequest.updateTransaction - Updating transaction function\n */\nexport async function updatePostTransactionBalance(\n  transactionMeta: TransactionMeta,\n  {\n    ethQuery,\n    getTransaction,\n    updateTransaction,\n  }: {\n    ethQuery: EthQuery;\n    getTransaction: (transactionId: string) => TransactionMeta | undefined;\n    updateTransaction: (transactionMeta: TransactionMeta, note: string) => void;\n  },\n): Promise<{\n  updatedTransactionMeta: TransactionMeta;\n  approvalTransactionMeta?: TransactionMeta;\n}> {\n  log('Updating post transaction balance', transactionMeta.id);\n\n  const transactionId = transactionMeta.id;\n  let latestTransactionMeta, approvalTransactionMeta;\n\n  for (let i = 0; i < UPDATE_POST_TX_BALANCE_ATTEMPTS; i++) {\n    log('Querying balance', { attempt: i });\n\n    const postTransactionBalance = await query(ethQuery, 'getBalance', [\n      transactionMeta.txParams.from,\n    ]);\n\n    latestTransactionMeta = getTransaction(transactionId) as TransactionMeta;\n\n    approvalTransactionMeta = latestTransactionMeta.approvalTxId\n      ? getTransaction(latestTransactionMeta.approvalTxId)\n      : undefined;\n\n    latestTransactionMeta.postTxBalance = postTransactionBalance.toString(16);\n\n    const isDefaultTokenAddress = isSwapsDefaultTokenAddress(\n      transactionMeta.destinationTokenAddress as string,\n      transactionMeta.chainId,\n    );\n\n    if (\n      !isDefaultTokenAddress ||\n      transactionMeta.preTxBalance !== latestTransactionMeta.postTxBalance\n    ) {\n      log('Finishing post balance update', {\n        isDefaultTokenAddress,\n        preTxBalance: transactionMeta.preTxBalance,\n        postTxBalance: latestTransactionMeta.postTxBalance,\n      });\n\n      break;\n    }\n\n    log('Waiting for balance to update', {\n      delay: UPDATE_POST_TX_BALANCE_TIMEOUT,\n    });\n\n    await sleep(UPDATE_POST_TX_BALANCE_TIMEOUT);\n  }\n\n  updateTransaction(\n    latestTransactionMeta as TransactionMeta,\n    'TransactionController#updatePostTransactionBalance - Add post transaction balance',\n  );\n\n  log('Completed post balance update', latestTransactionMeta?.postTxBalance);\n\n  return {\n    updatedTransactionMeta: latestTransactionMeta as TransactionMeta,\n    approvalTransactionMeta,\n  };\n}\n\n/**\n * Updates the transaction meta object with the swap information\n *\n * @param transactionMeta - Transaction meta object to update\n * @param propsToUpdate - Properties to update\n * @param propsToUpdate.sourceTokenSymbol - Symbol of the token to be swapped\n * @param propsToUpdate.destinationTokenSymbol - Symbol of the token to be received\n * @param propsToUpdate.type - Type of the transaction\n * @param propsToUpdate.destinationTokenDecimals - Decimals of the token to be received\n * @param propsToUpdate.destinationTokenAddress - Address of the token to be received\n * @param propsToUpdate.swapMetaData - Metadata of the swap\n * @param propsToUpdate.swapTokenValue - Value of the token to be swapped\n * @param propsToUpdate.estimatedBaseFee - Estimated base fee of the transaction\n * @param propsToUpdate.approvalTxId - Transaction id of the approval transaction\n */\nfunction updateSwapTransaction(\n  transactionMeta: TransactionMeta,\n  {\n    sourceTokenSymbol,\n    destinationTokenSymbol,\n    type,\n    destinationTokenDecimals,\n    destinationTokenAddress,\n    swapMetaData,\n    swapTokenValue,\n    estimatedBaseFee,\n    approvalTxId,\n  }: Partial<TransactionMeta>,\n) {\n  validateIfTransactionUnapproved(transactionMeta, 'updateSwapTransaction');\n\n  let swapTransaction = {\n    sourceTokenSymbol,\n    destinationTokenSymbol,\n    type,\n    destinationTokenDecimals,\n    destinationTokenAddress,\n    swapMetaData,\n    swapTokenValue,\n    estimatedBaseFee,\n    approvalTxId,\n  };\n  // TODO: Replace `any` with type\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  swapTransaction = pickBy(swapTransaction) as any;\n  merge(transactionMeta, swapTransaction);\n}\n\n/**\n * Updates the transaction meta object with the swap approval information\n *\n * @param transactionMeta - Transaction meta object to update\n * @param propsToUpdate - Properties to update\n * @param propsToUpdate.type - Type of the transaction\n * @param propsToUpdate.sourceTokenSymbol - Symbol of the token to be swapped\n */\nfunction updateSwapApprovalTransaction(\n  transactionMeta: TransactionMeta,\n  { type, sourceTokenSymbol }: Partial<TransactionMeta>,\n) {\n  validateIfTransactionUnapproved(\n    transactionMeta,\n    'updateSwapApprovalTransaction',\n  );\n\n  // TODO: Replace `any` with type\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  let swapApprovalTransaction = { type, sourceTokenSymbol } as any;\n  swapApprovalTransaction = pickBy({\n    type,\n    sourceTokenSymbol,\n  }) as Partial<TransactionMeta>;\n  merge(transactionMeta, swapApprovalTransaction);\n}\n\n/**\n * Checks whether the provided address is strictly equal to the address for\n * the default swaps token of the provided chain.\n *\n * @param address - The string to compare to the default token address\n * @param chainId - The hex encoded chain ID of the default swaps token to check\n * @returns Whether the address is the provided chain's default token address\n */\nfunction isSwapsDefaultTokenAddress(address: string, chainId: string) {\n  if (!address || !chainId) {\n    return false;\n  }\n\n  return (\n    address ===\n    SWAPS_CHAINID_DEFAULT_TOKEN_MAP[\n      chainId as keyof typeof SWAPS_CHAINID_DEFAULT_TOKEN_MAP\n    ]?.address\n  );\n}\n\n/**\n * Sleeps for the provided number of milliseconds\n *\n * @param ms - Number of milliseconds to sleep\n * @returns Promise that resolves after the provided number of milliseconds\n */\nfunction sleep(ms: number) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/transaction-type.d.ts b/node_modules/@metamask/transaction-controller/dist/utils/transaction-type.d.ts
new file mode 100644
index 0000000..8528ffc
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/transaction-type.d.ts
@@ -0,0 +1,14 @@
+import type EthQuery from '@metamask/eth-query';
+import type { InferTransactionTypeResult, TransactionParams } from '../types';
+export declare const ESTIMATE_GAS_ERROR = "eth_estimateGas rpc method error";
+/**
+ * Determines the type of the transaction by analyzing the txParams.
+ * It will never return TRANSACTION_TYPE_CANCEL or TRANSACTION_TYPE_RETRY as these
+ * represent specific events that we specify manually at transaction creation.
+ *
+ * @param txParams - Parameters for the transaction.
+ * @param ethQuery - EthQuery instance.
+ * @returns A object with the transaction type and the contract code response in Hex.
+ */
+export declare function determineTransactionType(txParams: TransactionParams, ethQuery: EthQuery): Promise<InferTransactionTypeResult>;
+//# sourceMappingURL=transaction-type.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/transaction-type.d.ts.map b/node_modules/@metamask/transaction-controller/dist/utils/transaction-type.d.ts.map
new file mode 100644
index 0000000..ee20d3e
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/transaction-type.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"transaction-type.d.ts","sourceRoot":"","sources":["../../src/utils/transaction-type.ts"],"names":[],"mappings":"AAGA,OAAO,KAAK,QAAQ,MAAM,qBAAqB,CAAC;AAGhD,OAAO,KAAK,EAAE,0BAA0B,EAAE,iBAAiB,EAAE,MAAM,UAAU,CAAC;AAG9E,eAAO,MAAM,kBAAkB,qCAAqC,CAAC;AAMrE;;;;;;;;GAQG;AACH,wBAAsB,wBAAwB,CAC5C,QAAQ,EAAE,iBAAiB,EAC3B,QAAQ,EAAE,QAAQ,GACjB,OAAO,CAAC,0BAA0B,CAAC,CA4CrC"}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/transaction-type.js b/node_modules/@metamask/transaction-controller/dist/utils/transaction-type.js
new file mode 100644
index 0000000..b04f5d5
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/transaction-type.js
@@ -0,0 +1,121 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.determineTransactionType = exports.ESTIMATE_GAS_ERROR = void 0;
+const abi_1 = require("@ethersproject/abi");
+const controller_utils_1 = require("@metamask/controller-utils");
+const metamask_eth_abis_1 = require("@metamask/metamask-eth-abis");
+const types_1 = require("../types");
+exports.ESTIMATE_GAS_ERROR = 'eth_estimateGas rpc method error';
+const ERC20Interface = new abi_1.Interface(metamask_eth_abis_1.abiERC20);
+const ERC721Interface = new abi_1.Interface(metamask_eth_abis_1.abiERC721);
+const ERC1155Interface = new abi_1.Interface(metamask_eth_abis_1.abiERC1155);
+/**
+ * Determines the type of the transaction by analyzing the txParams.
+ * It will never return TRANSACTION_TYPE_CANCEL or TRANSACTION_TYPE_RETRY as these
+ * represent specific events that we specify manually at transaction creation.
+ *
+ * @param txParams - Parameters for the transaction.
+ * @param ethQuery - EthQuery instance.
+ * @returns A object with the transaction type and the contract code response in Hex.
+ */
+function determineTransactionType(txParams, ethQuery) {
+    var _a, _b;
+    return __awaiter(this, void 0, void 0, function* () {
+        const { data, to } = txParams;
+        if (data && !to) {
+            return { type: types_1.TransactionType.deployContract, getCodeResponse: undefined };
+        }
+        const { contractCode: getCodeResponse, isContractAddress } = yield readAddressAsContract(ethQuery, to);
+        if (!isContractAddress) {
+            return { type: types_1.TransactionType.simpleSend, getCodeResponse };
+        }
+        const hasValue = Number((_a = txParams.value) !== null && _a !== void 0 ? _a : '0') !== 0;
+        const contractInteractionResult = {
+            type: types_1.TransactionType.contractInteraction,
+            getCodeResponse,
+        };
+        if (!data || hasValue) {
+            return contractInteractionResult;
+        }
+        const name = (_b = parseStandardTokenTransactionData(data)) === null || _b === void 0 ? void 0 : _b.name;
+        if (!name) {
+            return contractInteractionResult;
+        }
+        const tokenMethodName = [
+            types_1.TransactionType.tokenMethodApprove,
+            types_1.TransactionType.tokenMethodSetApprovalForAll,
+            types_1.TransactionType.tokenMethodTransfer,
+            types_1.TransactionType.tokenMethodTransferFrom,
+            types_1.TransactionType.tokenMethodSafeTransferFrom,
+        ].find((methodName) => methodName.toLowerCase() === name.toLowerCase());
+        if (tokenMethodName) {
+            return { type: tokenMethodName, getCodeResponse };
+        }
+        return contractInteractionResult;
+    });
+}
+exports.determineTransactionType = determineTransactionType;
+/**
+ * Attempts to decode transaction data using ABIs for three different token standards: ERC20, ERC721, ERC1155.
+ * The data will decode correctly if the transaction is an interaction with a contract that matches one of these
+ * contract standards
+ *
+ * @param data - Encoded transaction data.
+ * @returns A representation of an ethereum contract call.
+ */
+function parseStandardTokenTransactionData(data) {
+    if (!data) {
+        return undefined;
+    }
+    try {
+        return ERC20Interface.parseTransaction({ data });
+    }
+    catch (_a) {
+        // ignore and next try to parse with erc721 ABI
+    }
+    try {
+        return ERC721Interface.parseTransaction({ data });
+    }
+    catch (_b) {
+        // ignore and next try to parse with erc1155 ABI
+    }
+    try {
+        return ERC1155Interface.parseTransaction({ data });
+    }
+    catch (_c) {
+        // ignore and return undefined
+    }
+    return undefined;
+}
+/**
+ * Reads an Ethereum address and determines if it is a contract address.
+ *
+ * @param ethQuery - The Ethereum query object used to interact with the Ethereum blockchain.
+ * @param address - The Ethereum address.
+ * @returns An object containing the contract code and a boolean indicating if it is a contract address.
+ */
+function readAddressAsContract(ethQuery, address) {
+    return __awaiter(this, void 0, void 0, function* () {
+        let contractCode;
+        try {
+            contractCode = yield (0, controller_utils_1.query)(ethQuery, 'getCode', [address]);
+        }
+        catch (e) {
+            contractCode = null;
+        }
+        const isContractAddress = contractCode
+            ? contractCode !== '0x' && contractCode !== '0x0'
+            : false;
+        return { contractCode, isContractAddress };
+    });
+}
+//# sourceMappingURL=transaction-type.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/transaction-type.js.map b/node_modules/@metamask/transaction-controller/dist/utils/transaction-type.js.map
new file mode 100644
index 0000000..198f519
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/transaction-type.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"transaction-type.js","sourceRoot":"","sources":["../../src/utils/transaction-type.ts"],"names":[],"mappings":"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","sourcesContent":["import type { TransactionDescription } from '@ethersproject/abi';\nimport { Interface } from '@ethersproject/abi';\nimport { query } from '@metamask/controller-utils';\nimport type EthQuery from '@metamask/eth-query';\nimport { abiERC721, abiERC20, abiERC1155 } from '@metamask/metamask-eth-abis';\n\nimport type { InferTransactionTypeResult, TransactionParams } from '../types';\nimport { TransactionType } from '../types';\n\nexport const ESTIMATE_GAS_ERROR = 'eth_estimateGas rpc method error';\n\nconst ERC20Interface = new Interface(abiERC20);\nconst ERC721Interface = new Interface(abiERC721);\nconst ERC1155Interface = new Interface(abiERC1155);\n\n/**\n * Determines the type of the transaction by analyzing the txParams.\n * It will never return TRANSACTION_TYPE_CANCEL or TRANSACTION_TYPE_RETRY as these\n * represent specific events that we specify manually at transaction creation.\n *\n * @param txParams - Parameters for the transaction.\n * @param ethQuery - EthQuery instance.\n * @returns A object with the transaction type and the contract code response in Hex.\n */\nexport async function determineTransactionType(\n  txParams: TransactionParams,\n  ethQuery: EthQuery,\n): Promise<InferTransactionTypeResult> {\n  const { data, to } = txParams;\n\n  if (data && !to) {\n    return { type: TransactionType.deployContract, getCodeResponse: undefined };\n  }\n\n  const { contractCode: getCodeResponse, isContractAddress } =\n    await readAddressAsContract(ethQuery, to);\n\n  if (!isContractAddress) {\n    return { type: TransactionType.simpleSend, getCodeResponse };\n  }\n\n  const hasValue = Number(txParams.value ?? '0') !== 0;\n\n  const contractInteractionResult = {\n    type: TransactionType.contractInteraction,\n    getCodeResponse,\n  };\n\n  if (!data || hasValue) {\n    return contractInteractionResult;\n  }\n\n  const name = parseStandardTokenTransactionData(data)?.name;\n\n  if (!name) {\n    return contractInteractionResult;\n  }\n\n  const tokenMethodName = [\n    TransactionType.tokenMethodApprove,\n    TransactionType.tokenMethodSetApprovalForAll,\n    TransactionType.tokenMethodTransfer,\n    TransactionType.tokenMethodTransferFrom,\n    TransactionType.tokenMethodSafeTransferFrom,\n  ].find((methodName) => methodName.toLowerCase() === name.toLowerCase());\n\n  if (tokenMethodName) {\n    return { type: tokenMethodName, getCodeResponse };\n  }\n\n  return contractInteractionResult;\n}\n\n/**\n * Attempts to decode transaction data using ABIs for three different token standards: ERC20, ERC721, ERC1155.\n * The data will decode correctly if the transaction is an interaction with a contract that matches one of these\n * contract standards\n *\n * @param data - Encoded transaction data.\n * @returns A representation of an ethereum contract call.\n */\nfunction parseStandardTokenTransactionData(\n  data?: string,\n): TransactionDescription | undefined {\n  if (!data) {\n    return undefined;\n  }\n\n  try {\n    return ERC20Interface.parseTransaction({ data });\n  } catch {\n    // ignore and next try to parse with erc721 ABI\n  }\n\n  try {\n    return ERC721Interface.parseTransaction({ data });\n  } catch {\n    // ignore and next try to parse with erc1155 ABI\n  }\n\n  try {\n    return ERC1155Interface.parseTransaction({ data });\n  } catch {\n    // ignore and return undefined\n  }\n\n  return undefined;\n}\n\n/**\n * Reads an Ethereum address and determines if it is a contract address.\n *\n * @param ethQuery - The Ethereum query object used to interact with the Ethereum blockchain.\n * @param address - The Ethereum address.\n * @returns An object containing the contract code and a boolean indicating if it is a contract address.\n */\nasync function readAddressAsContract(\n  ethQuery: EthQuery,\n  address?: string,\n): Promise<{\n  contractCode: string | null;\n  isContractAddress: boolean;\n}> {\n  let contractCode;\n  try {\n    contractCode = await query(ethQuery, 'getCode', [address]);\n  } catch (e) {\n    contractCode = null;\n  }\n\n  const isContractAddress = contractCode\n    ? contractCode !== '0x' && contractCode !== '0x0'\n    : false;\n  return { contractCode, isContractAddress };\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/utils.d.ts b/node_modules/@metamask/transaction-controller/dist/utils/utils.d.ts
new file mode 100644
index 0000000..b2ab104
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/utils.d.ts
@@ -0,0 +1,58 @@
+import type { GasPriceValue, FeeMarketEIP1559Values } from '../TransactionController';
+import type { TransactionParams, TransactionMeta, TransactionError } from '../types';
+export declare const ESTIMATE_GAS_ERROR = "eth_estimateGas rpc method error";
+/**
+ * Normalizes properties on transaction params.
+ *
+ * @param txParams - The transaction params to normalize.
+ * @returns Normalized transaction params.
+ */
+export declare function normalizeTxParams(txParams: TransactionParams): TransactionParams;
+/**
+ * Checks if a transaction is EIP-1559 by checking for the existence of
+ * maxFeePerGas and maxPriorityFeePerGas within its parameters.
+ *
+ * @param txParams - Transaction params object to add.
+ * @returns Boolean that is true if the transaction is EIP-1559 (has maxFeePerGas and maxPriorityFeePerGas), otherwise returns false.
+ */
+export declare function isEIP1559Transaction(txParams: TransactionParams): boolean;
+export declare const validateGasValues: (gasValues: GasPriceValue | FeeMarketEIP1559Values) => void;
+export declare const isFeeMarketEIP1559Values: (gasValues?: GasPriceValue | FeeMarketEIP1559Values) => gasValues is FeeMarketEIP1559Values;
+export declare const isGasPriceValue: (gasValues?: GasPriceValue | FeeMarketEIP1559Values) => gasValues is GasPriceValue;
+export declare const getIncreasedPriceHex: (value: number, rate: number) => string;
+export declare const getIncreasedPriceFromExisting: (value: string | undefined, rate: number) => string;
+/**
+ * Validates that the proposed value is greater than or equal to the minimum value.
+ *
+ * @param proposed - The proposed value.
+ * @param min - The minimum value.
+ * @returns The proposed value.
+ * @throws Will throw if the proposed value is too low.
+ */
+export declare function validateMinimumIncrease(proposed: string, min: string): string;
+/**
+ * Validates that a transaction is unapproved.
+ * Throws if the transaction is not unapproved.
+ *
+ * @param transactionMeta - The transaction metadata to check.
+ * @param fnName - The name of the function calling this helper.
+ */
+export declare function validateIfTransactionUnapproved(transactionMeta: TransactionMeta | undefined, fnName: string): void;
+/**
+ * Normalizes properties on transaction params.
+ *
+ * @param error - The error to be normalize.
+ * @returns Normalized transaction error.
+ */
+export declare function normalizeTxError(error: Error & {
+    code?: string;
+    value?: unknown;
+}): TransactionError;
+/**
+ * Normalize an object containing gas fee values.
+ *
+ * @param gasFeeValues - An object containing gas fee values.
+ * @returns An object containing normalized gas fee values.
+ */
+export declare function normalizeGasFeeValues(gasFeeValues: GasPriceValue | FeeMarketEIP1559Values): GasPriceValue | FeeMarketEIP1559Values;
+//# sourceMappingURL=utils.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/utils.d.ts.map b/node_modules/@metamask/transaction-controller/dist/utils/utils.d.ts.map
new file mode 100644
index 0000000..f455211
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/utils.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"utils.d.ts","sourceRoot":"","sources":["../../src/utils/utils.ts"],"names":[],"mappings":"AAIA,OAAO,KAAK,EACV,aAAa,EACb,sBAAsB,EACvB,MAAM,0BAA0B,CAAC;AAElC,OAAO,KAAK,EACV,iBAAiB,EACjB,eAAe,EACf,gBAAgB,EACjB,MAAM,UAAU,CAAC;AAElB,eAAO,MAAM,kBAAkB,qCAAqC,CAAC;AAqBrE;;;;;GAKG;AACH,wBAAgB,iBAAiB,CAAC,QAAQ,EAAE,iBAAiB,qBAc5D;AAED;;;;;;GAMG;AACH,wBAAgB,oBAAoB,CAAC,QAAQ,EAAE,iBAAiB,GAAG,OAAO,CAOzE;AAED,eAAO,MAAM,iBAAiB,cACjB,aAAa,GAAG,sBAAsB,SAYlD,CAAC;AAEF,eAAO,MAAM,wBAAwB,eACvB,aAAa,GAAG,sBAAsB,wCAGuB,CAAC;AAE5E,eAAO,MAAM,eAAe,eACd,aAAa,GAAG,sBAAsB,+BAEE,CAAC;AAEvD,eAAO,MAAM,oBAAoB,UAAW,MAAM,QAAQ,MAAM,KAAG,MACF,CAAC;AAElE,eAAO,MAAM,6BAA6B,UACjC,MAAM,GAAG,SAAS,QACnB,MAAM,KACX,MAEF,CAAC;AAEF;;;;;;;GAOG;AACH,wBAAgB,uBAAuB,CAAC,QAAQ,EAAE,MAAM,EAAE,GAAG,EAAE,MAAM,UAQpE;AAED;;;;;;GAMG;AACH,wBAAgB,+BAA+B,CAC7C,eAAe,EAAE,eAAe,GAAG,SAAS,EAC5C,MAAM,EAAE,MAAM,QAQf;AAED;;;;;GAKG;AACH,wBAAgB,gBAAgB,CAC9B,KAAK,EAAE,KAAK,GAAG;IAAE,IAAI,CAAC,EAAE,MAAM,CAAC;IAAC,KAAK,CAAC,EAAE,OAAO,CAAA;CAAE,GAChD,gBAAgB,CAQlB;AAED;;;;;GAKG;AACH,wBAAgB,qBAAqB,CACnC,YAAY,EAAE,aAAa,GAAG,sBAAsB,GACnD,aAAa,GAAG,sBAAsB,CAgBxC"}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/utils.js b/node_modules/@metamask/transaction-controller/dist/utils/utils.js
new file mode 100644
index 0000000..13f878e
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/utils.js
@@ -0,0 +1,148 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.normalizeGasFeeValues = exports.normalizeTxError = exports.validateIfTransactionUnapproved = exports.validateMinimumIncrease = exports.getIncreasedPriceFromExisting = exports.getIncreasedPriceHex = exports.isGasPriceValue = exports.isFeeMarketEIP1559Values = exports.validateGasValues = exports.isEIP1559Transaction = exports.normalizeTxParams = exports.ESTIMATE_GAS_ERROR = void 0;
+const controller_utils_1 = require("@metamask/controller-utils");
+const utils_1 = require("@metamask/utils");
+const ethereumjs_util_1 = require("ethereumjs-util");
+const types_1 = require("../types");
+exports.ESTIMATE_GAS_ERROR = 'eth_estimateGas rpc method error';
+// TODO: Replace `any` with type
+// eslint-disable-next-line @typescript-eslint/no-explicit-any
+const NORMALIZERS = {
+    data: (data) => (0, ethereumjs_util_1.addHexPrefix)(data),
+    from: (from) => (0, ethereumjs_util_1.addHexPrefix)(from).toLowerCase(),
+    gas: (gas) => (0, ethereumjs_util_1.addHexPrefix)(gas),
+    gasLimit: (gas) => (0, ethereumjs_util_1.addHexPrefix)(gas),
+    gasPrice: (gasPrice) => (0, ethereumjs_util_1.addHexPrefix)(gasPrice),
+    nonce: (nonce) => (0, ethereumjs_util_1.addHexPrefix)(nonce),
+    to: (to) => (0, ethereumjs_util_1.addHexPrefix)(to).toLowerCase(),
+    value: (value) => (0, ethereumjs_util_1.addHexPrefix)(value),
+    maxFeePerGas: (maxFeePerGas) => (0, ethereumjs_util_1.addHexPrefix)(maxFeePerGas),
+    maxPriorityFeePerGas: (maxPriorityFeePerGas) => (0, ethereumjs_util_1.addHexPrefix)(maxPriorityFeePerGas),
+    estimatedBaseFee: (maxPriorityFeePerGas) => (0, ethereumjs_util_1.addHexPrefix)(maxPriorityFeePerGas),
+    type: (type) => (type === '0x0' ? '0x0' : undefined),
+};
+/**
+ * Normalizes properties on transaction params.
+ *
+ * @param txParams - The transaction params to normalize.
+ * @returns Normalized transaction params.
+ */
+function normalizeTxParams(txParams) {
+    const normalizedTxParams = { from: '' };
+    for (const key of (0, utils_1.getKnownPropertyNames)(NORMALIZERS)) {
+        if (txParams[key]) {
+            normalizedTxParams[key] = NORMALIZERS[key](txParams[key]);
+        }
+    }
+    if (!normalizedTxParams.value) {
+        normalizedTxParams.value = '0x0';
+    }
+    return normalizedTxParams;
+}
+exports.normalizeTxParams = normalizeTxParams;
+/**
+ * Checks if a transaction is EIP-1559 by checking for the existence of
+ * maxFeePerGas and maxPriorityFeePerGas within its parameters.
+ *
+ * @param txParams - Transaction params object to add.
+ * @returns Boolean that is true if the transaction is EIP-1559 (has maxFeePerGas and maxPriorityFeePerGas), otherwise returns false.
+ */
+function isEIP1559Transaction(txParams) {
+    const hasOwnProp = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);
+    return (hasOwnProp(txParams, 'maxFeePerGas') &&
+        hasOwnProp(txParams, 'maxPriorityFeePerGas'));
+}
+exports.isEIP1559Transaction = isEIP1559Transaction;
+const validateGasValues = (gasValues) => {
+    Object.keys(gasValues).forEach((key) => {
+        // TODO: Replace `any` with type
+        // eslint-disable-next-line @typescript-eslint/no-explicit-any
+        const value = gasValues[key];
+        if (typeof value !== 'string' || !(0, ethereumjs_util_1.isHexString)(value)) {
+            throw new TypeError(`expected hex string for ${key} but received: ${value}`);
+        }
+    });
+};
+exports.validateGasValues = validateGasValues;
+const isFeeMarketEIP1559Values = (gasValues) => (gasValues === null || gasValues === void 0 ? void 0 : gasValues.maxFeePerGas) !== undefined ||
+    (gasValues === null || gasValues === void 0 ? void 0 : gasValues.maxPriorityFeePerGas) !== undefined;
+exports.isFeeMarketEIP1559Values = isFeeMarketEIP1559Values;
+const isGasPriceValue = (gasValues) => (gasValues === null || gasValues === void 0 ? void 0 : gasValues.gasPrice) !== undefined;
+exports.isGasPriceValue = isGasPriceValue;
+const getIncreasedPriceHex = (value, rate) => (0, ethereumjs_util_1.addHexPrefix)(`${parseInt(`${value * rate}`, 10).toString(16)}`);
+exports.getIncreasedPriceHex = getIncreasedPriceHex;
+const getIncreasedPriceFromExisting = (value, rate) => {
+    return (0, exports.getIncreasedPriceHex)((0, controller_utils_1.convertHexToDecimal)(value), rate);
+};
+exports.getIncreasedPriceFromExisting = getIncreasedPriceFromExisting;
+/**
+ * Validates that the proposed value is greater than or equal to the minimum value.
+ *
+ * @param proposed - The proposed value.
+ * @param min - The minimum value.
+ * @returns The proposed value.
+ * @throws Will throw if the proposed value is too low.
+ */
+function validateMinimumIncrease(proposed, min) {
+    const proposedDecimal = (0, controller_utils_1.convertHexToDecimal)(proposed);
+    const minDecimal = (0, controller_utils_1.convertHexToDecimal)(min);
+    if (proposedDecimal >= minDecimal) {
+        return proposed;
+    }
+    const errorMsg = `The proposed value: ${proposedDecimal} should meet or exceed the minimum value: ${minDecimal}`;
+    throw new Error(errorMsg);
+}
+exports.validateMinimumIncrease = validateMinimumIncrease;
+/**
+ * Validates that a transaction is unapproved.
+ * Throws if the transaction is not unapproved.
+ *
+ * @param transactionMeta - The transaction metadata to check.
+ * @param fnName - The name of the function calling this helper.
+ */
+function validateIfTransactionUnapproved(transactionMeta, fnName) {
+    if ((transactionMeta === null || transactionMeta === void 0 ? void 0 : transactionMeta.status) !== types_1.TransactionStatus.unapproved) {
+        throw new Error(`TransactionsController: Can only call ${fnName} on an unapproved transaction.
+      Current tx status: ${transactionMeta === null || transactionMeta === void 0 ? void 0 : transactionMeta.status}`);
+    }
+}
+exports.validateIfTransactionUnapproved = validateIfTransactionUnapproved;
+/**
+ * Normalizes properties on transaction params.
+ *
+ * @param error - The error to be normalize.
+ * @returns Normalized transaction error.
+ */
+function normalizeTxError(error) {
+    return {
+        name: error.name,
+        message: error.message,
+        stack: error.stack,
+        code: error === null || error === void 0 ? void 0 : error.code,
+        rpc: error === null || error === void 0 ? void 0 : error.value,
+    };
+}
+exports.normalizeTxError = normalizeTxError;
+/**
+ * Normalize an object containing gas fee values.
+ *
+ * @param gasFeeValues - An object containing gas fee values.
+ * @returns An object containing normalized gas fee values.
+ */
+function normalizeGasFeeValues(gasFeeValues) {
+    // TODO: Replace `any` with type
+    // eslint-disable-next-line @typescript-eslint/no-explicit-any
+    const normalize = (value) => typeof value === 'string' ? (0, ethereumjs_util_1.addHexPrefix)(value) : value;
+    if ('gasPrice' in gasFeeValues) {
+        return {
+            gasPrice: normalize(gasFeeValues.gasPrice),
+        };
+    }
+    return {
+        maxFeePerGas: normalize(gasFeeValues.maxFeePerGas),
+        maxPriorityFeePerGas: normalize(gasFeeValues.maxPriorityFeePerGas),
+    };
+}
+exports.normalizeGasFeeValues = normalizeGasFeeValues;
+//# sourceMappingURL=utils.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/utils.js.map b/node_modules/@metamask/transaction-controller/dist/utils/utils.js.map
new file mode 100644
index 0000000..bbba8bd
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/utils.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../src/utils/utils.ts"],"names":[],"mappings":"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","sourcesContent":["import { convertHexToDecimal } from '@metamask/controller-utils';\nimport { getKnownPropertyNames } from '@metamask/utils';\nimport { addHexPrefix, isHexString } from 'ethereumjs-util';\n\nimport type {\n  GasPriceValue,\n  FeeMarketEIP1559Values,\n} from '../TransactionController';\nimport { TransactionStatus } from '../types';\nimport type {\n  TransactionParams,\n  TransactionMeta,\n  TransactionError,\n} from '../types';\n\nexport const ESTIMATE_GAS_ERROR = 'eth_estimateGas rpc method error';\n\n// TODO: Replace `any` with type\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst NORMALIZERS: { [param in keyof TransactionParams]: any } = {\n  data: (data: string) => addHexPrefix(data),\n  from: (from: string) => addHexPrefix(from).toLowerCase(),\n  gas: (gas: string) => addHexPrefix(gas),\n  gasLimit: (gas: string) => addHexPrefix(gas),\n  gasPrice: (gasPrice: string) => addHexPrefix(gasPrice),\n  nonce: (nonce: string) => addHexPrefix(nonce),\n  to: (to: string) => addHexPrefix(to).toLowerCase(),\n  value: (value: string) => addHexPrefix(value),\n  maxFeePerGas: (maxFeePerGas: string) => addHexPrefix(maxFeePerGas),\n  maxPriorityFeePerGas: (maxPriorityFeePerGas: string) =>\n    addHexPrefix(maxPriorityFeePerGas),\n  estimatedBaseFee: (maxPriorityFeePerGas: string) =>\n    addHexPrefix(maxPriorityFeePerGas),\n  type: (type: string) => (type === '0x0' ? '0x0' : undefined),\n};\n\n/**\n * Normalizes properties on transaction params.\n *\n * @param txParams - The transaction params to normalize.\n * @returns Normalized transaction params.\n */\nexport function normalizeTxParams(txParams: TransactionParams) {\n  const normalizedTxParams: TransactionParams = { from: '' };\n\n  for (const key of getKnownPropertyNames(NORMALIZERS)) {\n    if (txParams[key]) {\n      normalizedTxParams[key] = NORMALIZERS[key](txParams[key]);\n    }\n  }\n\n  if (!normalizedTxParams.value) {\n    normalizedTxParams.value = '0x0';\n  }\n\n  return normalizedTxParams;\n}\n\n/**\n * Checks if a transaction is EIP-1559 by checking for the existence of\n * maxFeePerGas and maxPriorityFeePerGas within its parameters.\n *\n * @param txParams - Transaction params object to add.\n * @returns Boolean that is true if the transaction is EIP-1559 (has maxFeePerGas and maxPriorityFeePerGas), otherwise returns false.\n */\nexport function isEIP1559Transaction(txParams: TransactionParams): boolean {\n  const hasOwnProp = (obj: TransactionParams, key: string) =>\n    Object.prototype.hasOwnProperty.call(obj, key);\n  return (\n    hasOwnProp(txParams, 'maxFeePerGas') &&\n    hasOwnProp(txParams, 'maxPriorityFeePerGas')\n  );\n}\n\nexport const validateGasValues = (\n  gasValues: GasPriceValue | FeeMarketEIP1559Values,\n) => {\n  Object.keys(gasValues).forEach((key) => {\n    // TODO: Replace `any` with type\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const value = (gasValues as any)[key];\n    if (typeof value !== 'string' || !isHexString(value)) {\n      throw new TypeError(\n        `expected hex string for ${key} but received: ${value}`,\n      );\n    }\n  });\n};\n\nexport const isFeeMarketEIP1559Values = (\n  gasValues?: GasPriceValue | FeeMarketEIP1559Values,\n): gasValues is FeeMarketEIP1559Values =>\n  (gasValues as FeeMarketEIP1559Values)?.maxFeePerGas !== undefined ||\n  (gasValues as FeeMarketEIP1559Values)?.maxPriorityFeePerGas !== undefined;\n\nexport const isGasPriceValue = (\n  gasValues?: GasPriceValue | FeeMarketEIP1559Values,\n): gasValues is GasPriceValue =>\n  (gasValues as GasPriceValue)?.gasPrice !== undefined;\n\nexport const getIncreasedPriceHex = (value: number, rate: number): string =>\n  addHexPrefix(`${parseInt(`${value * rate}`, 10).toString(16)}`);\n\nexport const getIncreasedPriceFromExisting = (\n  value: string | undefined,\n  rate: number,\n): string => {\n  return getIncreasedPriceHex(convertHexToDecimal(value), rate);\n};\n\n/**\n * Validates that the proposed value is greater than or equal to the minimum value.\n *\n * @param proposed - The proposed value.\n * @param min - The minimum value.\n * @returns The proposed value.\n * @throws Will throw if the proposed value is too low.\n */\nexport function validateMinimumIncrease(proposed: string, min: string) {\n  const proposedDecimal = convertHexToDecimal(proposed);\n  const minDecimal = convertHexToDecimal(min);\n  if (proposedDecimal >= minDecimal) {\n    return proposed;\n  }\n  const errorMsg = `The proposed value: ${proposedDecimal} should meet or exceed the minimum value: ${minDecimal}`;\n  throw new Error(errorMsg);\n}\n\n/**\n * Validates that a transaction is unapproved.\n * Throws if the transaction is not unapproved.\n *\n * @param transactionMeta - The transaction metadata to check.\n * @param fnName - The name of the function calling this helper.\n */\nexport function validateIfTransactionUnapproved(\n  transactionMeta: TransactionMeta | undefined,\n  fnName: string,\n) {\n  if (transactionMeta?.status !== TransactionStatus.unapproved) {\n    throw new Error(\n      `TransactionsController: Can only call ${fnName} on an unapproved transaction.\n      Current tx status: ${transactionMeta?.status}`,\n    );\n  }\n}\n\n/**\n * Normalizes properties on transaction params.\n *\n * @param error - The error to be normalize.\n * @returns Normalized transaction error.\n */\nexport function normalizeTxError(\n  error: Error & { code?: string; value?: unknown },\n): TransactionError {\n  return {\n    name: error.name,\n    message: error.message,\n    stack: error.stack,\n    code: error?.code,\n    rpc: error?.value,\n  };\n}\n\n/**\n * Normalize an object containing gas fee values.\n *\n * @param gasFeeValues - An object containing gas fee values.\n * @returns An object containing normalized gas fee values.\n */\nexport function normalizeGasFeeValues(\n  gasFeeValues: GasPriceValue | FeeMarketEIP1559Values,\n): GasPriceValue | FeeMarketEIP1559Values {\n  // TODO: Replace `any` with type\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const normalize = (value: any) =>\n    typeof value === 'string' ? addHexPrefix(value) : value;\n\n  if ('gasPrice' in gasFeeValues) {\n    return {\n      gasPrice: normalize(gasFeeValues.gasPrice),\n    };\n  }\n\n  return {\n    maxFeePerGas: normalize(gasFeeValues.maxFeePerGas),\n    maxPriorityFeePerGas: normalize(gasFeeValues.maxPriorityFeePerGas),\n  };\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/validation.d.ts b/node_modules/@metamask/transaction-controller/dist/utils/validation.d.ts
new file mode 100644
index 0000000..6c1d8bc
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/validation.d.ts
@@ -0,0 +1,20 @@
+import { type TransactionParams } from '../types';
+/**
+ * Validates whether a transaction initiated by a specific 'from' address is permitted by the origin.
+ *
+ * @param permittedAddresses - The permitted accounts for the given origin.
+ * @param selectedAddress - The currently selected Ethereum address in the wallet.
+ * @param from - The address from which the transaction is initiated.
+ * @param origin - The origin or source of the transaction.
+ * @throws Throws an error if the transaction is not permitted.
+ */
+export declare function validateTransactionOrigin(permittedAddresses: string[], selectedAddress: string, from: string, origin: string): Promise<void>;
+/**
+ * Validates the transaction params for required properties and throws in
+ * the event of any validation error.
+ *
+ * @param txParams - Transaction params object to validate.
+ * @param isEIP1559Compatible - whether or not the current network supports EIP-1559 transactions.
+ */
+export declare function validateTxParams(txParams: TransactionParams, isEIP1559Compatible?: boolean): void;
+//# sourceMappingURL=validation.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/validation.d.ts.map b/node_modules/@metamask/transaction-controller/dist/utils/validation.d.ts.map
new file mode 100644
index 0000000..ca49683
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/validation.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"validation.d.ts","sourceRoot":"","sources":["../../src/utils/validation.ts"],"names":[],"mappings":"AAKA,OAAO,EAA2B,KAAK,iBAAiB,EAAE,MAAM,UAAU,CAAC;AAK3E;;;;;;;;GAQG;AACH,wBAAsB,yBAAyB,CAC7C,kBAAkB,EAAE,MAAM,EAAE,EAC5B,eAAe,EAAE,MAAM,EACvB,IAAI,EAAE,MAAM,EACZ,MAAM,EAAE,MAAM,iBAqBf;AAED;;;;;;GAMG;AACH,wBAAgB,gBAAgB,CAC9B,QAAQ,EAAE,iBAAiB,EAC3B,mBAAmB,UAAO,QAS3B"}
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/validation.js b/node_modules/@metamask/transaction-controller/dist/utils/validation.js
new file mode 100644
index 0000000..6bd709c
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/validation.js
@@ -0,0 +1,259 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.validateTxParams = exports.validateTransactionOrigin = void 0;
+const abi_1 = require("@ethersproject/abi");
+const controller_utils_1 = require("@metamask/controller-utils");
+const metamask_eth_abis_1 = require("@metamask/metamask-eth-abis");
+const rpc_errors_1 = require("@metamask/rpc-errors");
+const types_1 = require("../types");
+const utils_1 = require("./utils");
+/**
+ * Validates whether a transaction initiated by a specific 'from' address is permitted by the origin.
+ *
+ * @param permittedAddresses - The permitted accounts for the given origin.
+ * @param selectedAddress - The currently selected Ethereum address in the wallet.
+ * @param from - The address from which the transaction is initiated.
+ * @param origin - The origin or source of the transaction.
+ * @throws Throws an error if the transaction is not permitted.
+ */
+function validateTransactionOrigin(permittedAddresses, selectedAddress, from, origin) {
+    return __awaiter(this, void 0, void 0, function* () {
+        if (origin === controller_utils_1.ORIGIN_METAMASK) {
+            // Ensure the 'from' address matches the currently selected address
+            if (from !== selectedAddress) {
+                throw rpc_errors_1.rpcErrors.internal({
+                    message: `Internally initiated transaction is using invalid account.`,
+                    data: {
+                        origin,
+                        fromAddress: from,
+                        selectedAddress,
+                    },
+                });
+            }
+            return;
+        }
+        // Check if the origin has permissions to initiate transactions from the specified address
+        if (!permittedAddresses.includes(from)) {
+            throw rpc_errors_1.providerErrors.unauthorized({ data: { origin } });
+        }
+    });
+}
+exports.validateTransactionOrigin = validateTransactionOrigin;
+/**
+ * Validates the transaction params for required properties and throws in
+ * the event of any validation error.
+ *
+ * @param txParams - Transaction params object to validate.
+ * @param isEIP1559Compatible - whether or not the current network supports EIP-1559 transactions.
+ */
+function validateTxParams(txParams, isEIP1559Compatible = true) {
+    validateEIP1559Compatibility(txParams, isEIP1559Compatible);
+    validateParamFrom(txParams.from);
+    validateParamRecipient(txParams);
+    validateParamValue(txParams.value);
+    validateParamData(txParams.data);
+    validateParamChainId(txParams.chainId);
+    validateGasFeeParams(txParams);
+}
+exports.validateTxParams = validateTxParams;
+/**
+ * Validates EIP-1559 compatibility for transaction creation.
+ *
+ * @param txParams - The transaction parameters to validate.
+ * @param isEIP1559Compatible - Indicates if the current network supports EIP-1559.
+ * @throws Throws invalid params if the transaction specifies EIP-1559 but the network does not support it.
+ */
+function validateEIP1559Compatibility(txParams, isEIP1559Compatible) {
+    if ((0, utils_1.isEIP1559Transaction)(txParams) && !isEIP1559Compatible) {
+        throw rpc_errors_1.rpcErrors.invalidParams('Invalid transaction params: params specify an EIP-1559 transaction but the current network does not support EIP-1559');
+    }
+}
+/**
+ * Validates value property, ensuring it is a valid positive integer number
+ * denominated in wei.
+ *
+ * @param value - The value to validate, expressed as a string.
+ * @throws Throws an error if the value is not a valid positive integer
+ * number denominated in wei.
+ * - If the value contains a hyphen (-), it is considered invalid.
+ * - If the value contains a decimal point (.), it is considered invalid.
+ * - If the value is not a finite number, is NaN, or is not a safe integer, it is considered invalid.
+ */
+function validateParamValue(value) {
+    if (value !== undefined) {
+        if (value.includes('-')) {
+            throw rpc_errors_1.rpcErrors.invalidParams(`Invalid transaction value "${value}": not a positive number.`);
+        }
+        if (value.includes('.')) {
+            throw rpc_errors_1.rpcErrors.invalidParams(`Invalid transaction value "${value}": number must be in wei.`);
+        }
+        const intValue = parseInt(value, 10);
+        const isValid = Number.isFinite(intValue) &&
+            !Number.isNaN(intValue) &&
+            !isNaN(Number(value)) &&
+            Number.isSafeInteger(intValue);
+        if (!isValid) {
+            throw rpc_errors_1.rpcErrors.invalidParams(`Invalid transaction value ${value}: number must be a valid number.`);
+        }
+    }
+}
+/**
+ * Validates the recipient address in a transaction's parameters.
+ *
+ * @param txParams - The transaction parameters object to validate.
+ * @throws Throws an error if the recipient address is invalid:
+ * - If the recipient address is an empty string ('0x') or undefined and the transaction contains data,
+ * the "to" field is removed from the transaction parameters.
+ * - If the recipient address is not a valid hexadecimal Ethereum address, an error is thrown.
+ */
+function validateParamRecipient(txParams) {
+    if (txParams.to === '0x' || txParams.to === undefined) {
+        if (txParams.data) {
+            delete txParams.to;
+        }
+        else {
+            throw rpc_errors_1.rpcErrors.invalidParams(`Invalid "to" address.`);
+        }
+    }
+    else if (txParams.to !== undefined && !(0, controller_utils_1.isValidHexAddress)(txParams.to)) {
+        throw rpc_errors_1.rpcErrors.invalidParams(`Invalid "to" address.`);
+    }
+}
+/**
+ * Validates the recipient address in a transaction's parameters.
+ *
+ * @param from - The from property to validate.
+ * @throws Throws an error if the recipient address is invalid:
+ * - If the recipient address is an empty string ('0x') or undefined and the transaction contains data,
+ * the "to" field is removed from the transaction parameters.
+ * - If the recipient address is not a valid hexadecimal Ethereum address, an error is thrown.
+ */
+function validateParamFrom(from) {
+    if (!from || typeof from !== 'string') {
+        throw rpc_errors_1.rpcErrors.invalidParams(`Invalid "from" address ${from}: not a string.`);
+    }
+    if (!(0, controller_utils_1.isValidHexAddress)(from)) {
+        throw rpc_errors_1.rpcErrors.invalidParams('Invalid "from" address.');
+    }
+}
+/**
+ * Validates input data for transactions.
+ *
+ * @param value - The input data to validate.
+ * @throws Throws invalid params if the input data is invalid.
+ */
+function validateParamData(value) {
+    if (value) {
+        const ERC20Interface = new abi_1.Interface(metamask_eth_abis_1.abiERC20);
+        try {
+            ERC20Interface.parseTransaction({ data: value });
+            // TODO: Replace `any` with type
+            // eslint-disable-next-line @typescript-eslint/no-explicit-any
+        }
+        catch (error) {
+            if (error.message.match(/BUFFER_OVERRUN/u)) {
+                throw rpc_errors_1.rpcErrors.invalidParams('Invalid transaction params: data out-of-bounds, BUFFER_OVERRUN.');
+            }
+        }
+    }
+}
+/**
+ * Validates chainId type.
+ *
+ * @param chainId - The chainId to validate.
+ */
+function validateParamChainId(chainId) {
+    if (chainId !== undefined &&
+        typeof chainId !== 'number' &&
+        typeof chainId !== 'string') {
+        throw rpc_errors_1.rpcErrors.invalidParams(`Invalid transaction params: chainId is not a Number or hex string. got: (${chainId})`);
+    }
+}
+/**
+ * Validates gas values.
+ *
+ * @param txParams - The transaction parameters to validate.
+ */
+function validateGasFeeParams(txParams) {
+    if (txParams.gasPrice) {
+        ensureProperTransactionEnvelopeTypeProvided(txParams, 'gasPrice');
+        ensureMutuallyExclusiveFieldsNotProvided(txParams, 'gasPrice', 'maxFeePerGas');
+        ensureMutuallyExclusiveFieldsNotProvided(txParams, 'gasPrice', 'maxPriorityFeePerGas');
+        ensureFieldIsString(txParams, 'gasPrice');
+    }
+    if (txParams.maxFeePerGas) {
+        ensureProperTransactionEnvelopeTypeProvided(txParams, 'maxFeePerGas');
+        ensureMutuallyExclusiveFieldsNotProvided(txParams, 'maxFeePerGas', 'gasPrice');
+        ensureFieldIsString(txParams, 'maxFeePerGas');
+    }
+    if (txParams.maxPriorityFeePerGas) {
+        ensureProperTransactionEnvelopeTypeProvided(txParams, 'maxPriorityFeePerGas');
+        ensureMutuallyExclusiveFieldsNotProvided(txParams, 'maxPriorityFeePerGas', 'gasPrice');
+        ensureFieldIsString(txParams, 'maxPriorityFeePerGas');
+    }
+}
+/**
+ * Ensures that the provided txParams has the proper 'type' specified for the
+ * given field, if it is provided. If types do not match throws an
+ * invalidParams error.
+ *
+ * @param txParams - The transaction parameters object
+ * @param field - The current field being validated
+ * @throws {ethErrors.rpc.invalidParams} Throws if type does not match the
+ * expectations for provided field.
+ */
+function ensureProperTransactionEnvelopeTypeProvided(txParams, field) {
+    switch (field) {
+        case 'maxFeePerGas':
+        case 'maxPriorityFeePerGas':
+            if (txParams.type &&
+                txParams.type !== types_1.TransactionEnvelopeType.feeMarket) {
+                throw rpc_errors_1.rpcErrors.invalidParams(`Invalid transaction envelope type: specified type "${txParams.type}" but including maxFeePerGas and maxPriorityFeePerGas requires type: "${types_1.TransactionEnvelopeType.feeMarket}"`);
+            }
+            break;
+        case 'gasPrice':
+        default:
+            if (txParams.type &&
+                txParams.type === types_1.TransactionEnvelopeType.feeMarket) {
+                throw rpc_errors_1.rpcErrors.invalidParams(`Invalid transaction envelope type: specified type "${txParams.type}" but included a gasPrice instead of maxFeePerGas and maxPriorityFeePerGas`);
+            }
+    }
+}
+/**
+ * Given two fields, ensure that the second field is not included in txParams,
+ * and if it is throw an invalidParams error.
+ *
+ * @param txParams - The transaction parameters object
+ * @param fieldBeingValidated - The current field being validated
+ * @param mutuallyExclusiveField - The field to ensure is not provided
+ * @throws {ethErrors.rpc.invalidParams} Throws if mutuallyExclusiveField is
+ * present in txParams.
+ */
+function ensureMutuallyExclusiveFieldsNotProvided(txParams, fieldBeingValidated, mutuallyExclusiveField) {
+    if (typeof txParams[mutuallyExclusiveField] !== 'undefined') {
+        throw rpc_errors_1.rpcErrors.invalidParams(`Invalid transaction params: specified ${fieldBeingValidated} but also included ${mutuallyExclusiveField}, these cannot be mixed`);
+    }
+}
+/**
+ * Ensures that the provided value for field is a string, throws an
+ * invalidParams error if field is not a string.
+ *
+ * @param txParams - The transaction parameters object
+ * @param field - The current field being validated
+ * @throws {rpcErrors.invalidParams} Throws if field is not a string
+ */
+function ensureFieldIsString(txParams, field) {
+    if (typeof txParams[field] !== 'string') {
+        throw rpc_errors_1.rpcErrors.invalidParams(`Invalid transaction params: ${field} is not a string. got: (${txParams[field]})`);
+    }
+}
+//# sourceMappingURL=validation.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/transaction-controller/dist/utils/validation.js.map b/node_modules/@metamask/transaction-controller/dist/utils/validation.js.map
new file mode 100644
index 0000000..1167caa
--- /dev/null
+++ b/node_modules/@metamask/transaction-controller/dist/utils/validation.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"validation.js","sourceRoot":"","sources":["../../src/utils/validation.ts"],"names":[],"mappings":"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","sourcesContent":["import { Interface } from '@ethersproject/abi';\nimport { ORIGIN_METAMASK, isValidHexAddress } from '@metamask/controller-utils';\nimport { abiERC20 } from '@metamask/metamask-eth-abis';\nimport { providerErrors, rpcErrors } from '@metamask/rpc-errors';\n\nimport { TransactionEnvelopeType, type TransactionParams } from '../types';\nimport { isEIP1559Transaction } from './utils';\n\ntype GasFieldsToValidate = 'gasPrice' | 'maxFeePerGas' | 'maxPriorityFeePerGas';\n\n/**\n * Validates whether a transaction initiated by a specific 'from' address is permitted by the origin.\n *\n * @param permittedAddresses - The permitted accounts for the given origin.\n * @param selectedAddress - The currently selected Ethereum address in the wallet.\n * @param from - The address from which the transaction is initiated.\n * @param origin - The origin or source of the transaction.\n * @throws Throws an error if the transaction is not permitted.\n */\nexport async function validateTransactionOrigin(\n  permittedAddresses: string[],\n  selectedAddress: string,\n  from: string,\n  origin: string,\n) {\n  if (origin === ORIGIN_METAMASK) {\n    // Ensure the 'from' address matches the currently selected address\n    if (from !== selectedAddress) {\n      throw rpcErrors.internal({\n        message: `Internally initiated transaction is using invalid account.`,\n        data: {\n          origin,\n          fromAddress: from,\n          selectedAddress,\n        },\n      });\n    }\n    return;\n  }\n\n  // Check if the origin has permissions to initiate transactions from the specified address\n  if (!permittedAddresses.includes(from)) {\n    throw providerErrors.unauthorized({ data: { origin } });\n  }\n}\n\n/**\n * Validates the transaction params for required properties and throws in\n * the event of any validation error.\n *\n * @param txParams - Transaction params object to validate.\n * @param isEIP1559Compatible - whether or not the current network supports EIP-1559 transactions.\n */\nexport function validateTxParams(\n  txParams: TransactionParams,\n  isEIP1559Compatible = true,\n) {\n  validateEIP1559Compatibility(txParams, isEIP1559Compatible);\n  validateParamFrom(txParams.from);\n  validateParamRecipient(txParams);\n  validateParamValue(txParams.value);\n  validateParamData(txParams.data);\n  validateParamChainId(txParams.chainId);\n  validateGasFeeParams(txParams);\n}\n\n/**\n * Validates EIP-1559 compatibility for transaction creation.\n *\n * @param txParams - The transaction parameters to validate.\n * @param isEIP1559Compatible - Indicates if the current network supports EIP-1559.\n * @throws Throws invalid params if the transaction specifies EIP-1559 but the network does not support it.\n */\nfunction validateEIP1559Compatibility(\n  txParams: TransactionParams,\n  isEIP1559Compatible: boolean,\n) {\n  if (isEIP1559Transaction(txParams) && !isEIP1559Compatible) {\n    throw rpcErrors.invalidParams(\n      'Invalid transaction params: params specify an EIP-1559 transaction but the current network does not support EIP-1559',\n    );\n  }\n}\n\n/**\n * Validates value property, ensuring it is a valid positive integer number\n * denominated in wei.\n *\n * @param value - The value to validate, expressed as a string.\n * @throws Throws an error if the value is not a valid positive integer\n * number denominated in wei.\n * - If the value contains a hyphen (-), it is considered invalid.\n * - If the value contains a decimal point (.), it is considered invalid.\n * - If the value is not a finite number, is NaN, or is not a safe integer, it is considered invalid.\n */\nfunction validateParamValue(value?: string) {\n  if (value !== undefined) {\n    if (value.includes('-')) {\n      throw rpcErrors.invalidParams(\n        `Invalid transaction value \"${value}\": not a positive number.`,\n      );\n    }\n\n    if (value.includes('.')) {\n      throw rpcErrors.invalidParams(\n        `Invalid transaction value \"${value}\": number must be in wei.`,\n      );\n    }\n    const intValue = parseInt(value, 10);\n    const isValid =\n      Number.isFinite(intValue) &&\n      !Number.isNaN(intValue) &&\n      !isNaN(Number(value)) &&\n      Number.isSafeInteger(intValue);\n    if (!isValid) {\n      throw rpcErrors.invalidParams(\n        `Invalid transaction value ${value}: number must be a valid number.`,\n      );\n    }\n  }\n}\n\n/**\n * Validates the recipient address in a transaction's parameters.\n *\n * @param txParams - The transaction parameters object to validate.\n * @throws Throws an error if the recipient address is invalid:\n * - If the recipient address is an empty string ('0x') or undefined and the transaction contains data,\n * the \"to\" field is removed from the transaction parameters.\n * - If the recipient address is not a valid hexadecimal Ethereum address, an error is thrown.\n */\nfunction validateParamRecipient(txParams: TransactionParams) {\n  if (txParams.to === '0x' || txParams.to === undefined) {\n    if (txParams.data) {\n      delete txParams.to;\n    } else {\n      throw rpcErrors.invalidParams(`Invalid \"to\" address.`);\n    }\n  } else if (txParams.to !== undefined && !isValidHexAddress(txParams.to)) {\n    throw rpcErrors.invalidParams(`Invalid \"to\" address.`);\n  }\n}\n\n/**\n * Validates the recipient address in a transaction's parameters.\n *\n * @param from - The from property to validate.\n * @throws Throws an error if the recipient address is invalid:\n * - If the recipient address is an empty string ('0x') or undefined and the transaction contains data,\n * the \"to\" field is removed from the transaction parameters.\n * - If the recipient address is not a valid hexadecimal Ethereum address, an error is thrown.\n */\nfunction validateParamFrom(from: string) {\n  if (!from || typeof from !== 'string') {\n    throw rpcErrors.invalidParams(\n      `Invalid \"from\" address ${from}: not a string.`,\n    );\n  }\n  if (!isValidHexAddress(from)) {\n    throw rpcErrors.invalidParams('Invalid \"from\" address.');\n  }\n}\n\n/**\n * Validates input data for transactions.\n *\n * @param value - The input data to validate.\n * @throws Throws invalid params if the input data is invalid.\n */\nfunction validateParamData(value?: string) {\n  if (value) {\n    const ERC20Interface = new Interface(abiERC20);\n    try {\n      ERC20Interface.parseTransaction({ data: value });\n      // TODO: Replace `any` with type\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (error: any) {\n      if (error.message.match(/BUFFER_OVERRUN/u)) {\n        throw rpcErrors.invalidParams(\n          'Invalid transaction params: data out-of-bounds, BUFFER_OVERRUN.',\n        );\n      }\n    }\n  }\n}\n\n/**\n * Validates chainId type.\n *\n * @param chainId - The chainId to validate.\n */\nfunction validateParamChainId(chainId: number | string | undefined) {\n  if (\n    chainId !== undefined &&\n    typeof chainId !== 'number' &&\n    typeof chainId !== 'string'\n  ) {\n    throw rpcErrors.invalidParams(\n      `Invalid transaction params: chainId is not a Number or hex string. got: (${chainId})`,\n    );\n  }\n}\n\n/**\n * Validates gas values.\n *\n * @param txParams - The transaction parameters to validate.\n */\nfunction validateGasFeeParams(txParams: TransactionParams) {\n  if (txParams.gasPrice) {\n    ensureProperTransactionEnvelopeTypeProvided(txParams, 'gasPrice');\n    ensureMutuallyExclusiveFieldsNotProvided(\n      txParams,\n      'gasPrice',\n      'maxFeePerGas',\n    );\n    ensureMutuallyExclusiveFieldsNotProvided(\n      txParams,\n      'gasPrice',\n      'maxPriorityFeePerGas',\n    );\n    ensureFieldIsString(txParams, 'gasPrice');\n  }\n\n  if (txParams.maxFeePerGas) {\n    ensureProperTransactionEnvelopeTypeProvided(txParams, 'maxFeePerGas');\n    ensureMutuallyExclusiveFieldsNotProvided(\n      txParams,\n      'maxFeePerGas',\n      'gasPrice',\n    );\n    ensureFieldIsString(txParams, 'maxFeePerGas');\n  }\n\n  if (txParams.maxPriorityFeePerGas) {\n    ensureProperTransactionEnvelopeTypeProvided(\n      txParams,\n      'maxPriorityFeePerGas',\n    );\n    ensureMutuallyExclusiveFieldsNotProvided(\n      txParams,\n      'maxPriorityFeePerGas',\n      'gasPrice',\n    );\n    ensureFieldIsString(txParams, 'maxPriorityFeePerGas');\n  }\n}\n\n/**\n * Ensures that the provided txParams has the proper 'type' specified for the\n * given field, if it is provided. If types do not match throws an\n * invalidParams error.\n *\n * @param txParams - The transaction parameters object\n * @param field - The current field being validated\n * @throws {ethErrors.rpc.invalidParams} Throws if type does not match the\n * expectations for provided field.\n */\nfunction ensureProperTransactionEnvelopeTypeProvided(\n  txParams: TransactionParams,\n  field: GasFieldsToValidate,\n) {\n  switch (field) {\n    case 'maxFeePerGas':\n    case 'maxPriorityFeePerGas':\n      if (\n        txParams.type &&\n        txParams.type !== TransactionEnvelopeType.feeMarket\n      ) {\n        throw rpcErrors.invalidParams(\n          `Invalid transaction envelope type: specified type \"${txParams.type}\" but including maxFeePerGas and maxPriorityFeePerGas requires type: \"${TransactionEnvelopeType.feeMarket}\"`,\n        );\n      }\n      break;\n    case 'gasPrice':\n    default:\n      if (\n        txParams.type &&\n        txParams.type === TransactionEnvelopeType.feeMarket\n      ) {\n        throw rpcErrors.invalidParams(\n          `Invalid transaction envelope type: specified type \"${txParams.type}\" but included a gasPrice instead of maxFeePerGas and maxPriorityFeePerGas`,\n        );\n      }\n  }\n}\n\n/**\n * Given two fields, ensure that the second field is not included in txParams,\n * and if it is throw an invalidParams error.\n *\n * @param txParams - The transaction parameters object\n * @param fieldBeingValidated - The current field being validated\n * @param mutuallyExclusiveField - The field to ensure is not provided\n * @throws {ethErrors.rpc.invalidParams} Throws if mutuallyExclusiveField is\n * present in txParams.\n */\nfunction ensureMutuallyExclusiveFieldsNotProvided(\n  txParams: TransactionParams,\n  fieldBeingValidated: GasFieldsToValidate,\n  mutuallyExclusiveField: GasFieldsToValidate,\n) {\n  if (typeof txParams[mutuallyExclusiveField] !== 'undefined') {\n    throw rpcErrors.invalidParams(\n      `Invalid transaction params: specified ${fieldBeingValidated} but also included ${mutuallyExclusiveField}, these cannot be mixed`,\n    );\n  }\n}\n\n/**\n * Ensures that the provided value for field is a string, throws an\n * invalidParams error if field is not a string.\n *\n * @param txParams - The transaction parameters object\n * @param field - The current field being validated\n * @throws {rpcErrors.invalidParams} Throws if field is not a string\n */\nfunction ensureFieldIsString(\n  txParams: TransactionParams,\n  field: GasFieldsToValidate,\n) {\n  if (typeof txParams[field] !== 'string') {\n    throw rpcErrors.invalidParams(\n      `Invalid transaction params: ${field} is not a string. got: (${txParams[field]})`,\n    );\n  }\n}\n"]}
\ No newline at end of file
