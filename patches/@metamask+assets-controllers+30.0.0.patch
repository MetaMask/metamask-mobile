diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-46UZDIXW.mjs b/node_modules/@metamask/assets-controllers/dist/chunk-46UZDIXW.mjs
index ef9295d..f21fda0 100644
--- a/node_modules/@metamask/assets-controllers/dist/chunk-46UZDIXW.mjs
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-46UZDIXW.mjs
@@ -33,6 +33,11 @@ var getDefaultNftState = () => {
     ignoredNfts: []
   };
 };
+
+/**
+ * Changes regarding displayNftMedia, TokenURI and error nft metadata property are not on the core repo and needed to be refactor to be removed from the patch
+ * updateNftMetadata changes will be introduced on latest versions of changes of assets controllers, v^30 or next
+ */
 var NftController = class extends BaseControllerV1 {
   /**
    * Creates an NftController instance.
@@ -82,7 +87,7 @@ var NftController = class extends BaseControllerV1 {
       selectedAddress: "",
       chainId: initialChainId,
       ipfsGateway: IPFS_DEFAULT_GATEWAY_URL,
-      openSeaEnabled: false,
+      displayNftMedia: false,
       useIPFSSubdomains: true,
       isIpfsGatewayEnabled: true
     };
@@ -101,16 +106,16 @@ var NftController = class extends BaseControllerV1 {
       async ({
         selectedAddress,
         ipfsGateway,
-        openSeaEnabled,
+        displayNftMedia,
         isIpfsGatewayEnabled
       }) => {
         this.configure({
           selectedAddress,
           ipfsGateway,
-          openSeaEnabled,
+          displayNftMedia,
           isIpfsGatewayEnabled
         });
-        const needsUpdateNftMetadata = isIpfsGatewayEnabled && ipfsGateway !== "" || openSeaEnabled;
+        const needsUpdateNftMetadata = isIpfsGatewayEnabled && ipfsGateway !== "" || displayNftMedia;
         if (needsUpdateNftMetadata) {
           const { chainId } = this.config;
           const nfts = this.state.allNfts[selectedAddress]?.[chainId] ?? [];
@@ -189,7 +194,8 @@ var NftController = class extends BaseControllerV1 {
         name: null,
         description: null,
         image: null,
-        standard: null
+        standard: null,
+        error: 'Opensea import error',
       };
     }
     const {
@@ -234,7 +240,13 @@ var NftController = class extends BaseControllerV1 {
    * @returns Promise resolving to the current NFT name and image.
    */
   async getNftInformationFromTokenURI(contractAddress, tokenId, networkClientId) {
-    const { ipfsGateway, useIPFSSubdomains, isIpfsGatewayEnabled } = this.config;
+    const {
+      ipfsGateway,
+      useIPFSSubdomains,
+      isIpfsGatewayEnabled,
+      displayNftMedia,
+    } = this.config;
+    
     const result = await this.getNftURIAndStandard(
       contractAddress,
       tokenId,
@@ -242,6 +254,18 @@ var NftController = class extends BaseControllerV1 {
     );
     let tokenURI = result[0];
     const standard = result[1];
+
+    if (!displayNftMedia && !isIpfsGatewayEnabled) {
+      return {
+        image: null,
+        name: null,
+        description: null,
+        standard: standard || null,
+        favorite: false,
+        tokenURI,
+      };
+    }
+
     const hasIpfsTokenURI = tokenURI.startsWith("ipfs://");
     if (hasIpfsTokenURI && !isIpfsGatewayEnabled) {
       return {
@@ -253,15 +277,16 @@ var NftController = class extends BaseControllerV1 {
         tokenURI: tokenURI ?? null
       };
     }
-    const isDisplayNFTMediaToggleEnabled = this.config.openSeaEnabled;
-    if (!hasIpfsTokenURI && !isDisplayNFTMediaToggleEnabled) {
+    
+    if (!hasIpfsTokenURI && !displayNftMedia) {
       return {
         image: null,
         name: null,
         description: null,
         standard: standard || null,
         favorite: false,
-        tokenURI: tokenURI ?? null
+        tokenURI: tokenURI ?? null,
+        error: 'URI import error',
       };
     }
     if (hasIpfsTokenURI) {
@@ -345,15 +370,28 @@ var NftController = class extends BaseControllerV1 {
           networkClientId
         )
       ),
-      this.config.openSeaEnabled && chainId === "0x1" ? safelyExecute(
+      this.config.displayNftMedia && chainId === "0x1" ? safelyExecute(
         () => this.getNftInformationFromApi(contractAddress, tokenId)
       ) : void 0
     ]);
+
+    if (blockchainMetadata?.error && nftApiMetadata?.error) {
+      return {
+        image: null,
+        name: null,
+        description: null,
+        standard: blockchainMetadata.standard ?? null,
+        favorite: false,
+        tokenURI: blockchainMetadata.tokenURI ?? null,
+        error: 'Both import failed',
+      };
+    }
+
     return {
       ...nftApiMetadata,
       name: blockchainMetadata?.name ?? nftApiMetadata?.name ?? null,
       description: blockchainMetadata?.description ?? nftApiMetadata?.description ?? null,
-      image: blockchainMetadata?.image ?? nftApiMetadata?.image ?? null,
+      image: nftApiMetadata?.image ?? blockchainMetadata?.image ?? null,
       standard: blockchainMetadata?.standard ?? nftApiMetadata?.standard ?? null,
       tokenURI: blockchainMetadata?.tokenURI ?? null
     };
@@ -472,7 +510,8 @@ var NftController = class extends BaseControllerV1 {
           symbol: nftContract.symbol,
           tokenId: tokenId.toString(),
           standard: nftMetadata.standard,
-          source
+          source,
+          tokenURI: nftMetadata.tokenURI,
         });
       }
       return newNfts;
@@ -863,57 +902,55 @@ var NftController = class extends BaseControllerV1 {
     userAddress = this.config.selectedAddress,
     networkClientId
   }) {
-    const chainId = this.getCorrectChainId({ networkClientId });
-    const nftsWithChecksumAdr = nfts.map((nft) => {
-      return {
-        ...nft,
-        address: toChecksumHexAddress(nft.address)
-      };
-    });
-    const nftMetadataResults = await Promise.allSettled(
-      nftsWithChecksumAdr.map(async (nft) => {
-        const resMetadata = await this.getNftInformation(
-          nft.address,
-          nft.tokenId,
-          networkClientId
-        );
+    const releaseLock = await this.mutex.acquire();
+    try {
+      const chainId = this.getCorrectChainId({ networkClientId });
+      const nftsWithChecksumAdr = nfts.map((nft) => {
         return {
-          nft,
-          newMetadata: resMetadata
+          ...nft,
+          address: toChecksumHexAddress(nft.address)
         };
-      })
-    );
-    const successfulNewFetchedNfts = nftMetadataResults.filter(
-      (result) => result.status === "fulfilled"
-    );
-    const nftsWithDifferentMetadata = [];
-    const { allNfts } = this.state;
-    const stateNfts = allNfts[userAddress]?.[chainId] || [];
-    successfulNewFetchedNfts.forEach((singleNft) => {
-      const existingEntry = stateNfts.find(
-        (nft) => nft.address.toLowerCase() === singleNft.value.nft.address.toLowerCase() && nft.tokenId === singleNft.value.nft.tokenId
+      });
+      const nftMetadataResults = await Promise.all(
+        nftsWithChecksumAdr.map(async (nft) => {
+          const resMetadata = await this.getNftInformation(
+            nft.address,
+            nft.tokenId,
+            networkClientId
+          );
+          return {
+            nft,
+            newMetadata: resMetadata
+          };
+        })
       );
-      if (existingEntry) {
-        const differentMetadata = compareNftMetadata(
-          singleNft.value.newMetadata,
-          existingEntry
+      const nftsWithDifferentMetadata = [];
+      const { allNfts } = this.state;
+      const stateNfts = allNfts[userAddress]?.[chainId] || [];
+      nftMetadataResults.forEach((singleNft) => {
+        const existingEntry = stateNfts.find(
+          (nft) => nft.address.toLowerCase() === singleNft.nft.address.toLowerCase() && nft.tokenId === singleNft.nft.tokenId
         );
-        if (differentMetadata) {
-          nftsWithDifferentMetadata.push(singleNft);
+        if (existingEntry) {
+          const differentMetadata = compareNftMetadata(
+            singleNft.newMetadata,
+            existingEntry
+          );
+          if (differentMetadata) {
+            nftsWithDifferentMetadata.push(singleNft);
+          }
         }
+      });
+      if (nftsWithDifferentMetadata.length !== 0) {
+        nftsWithDifferentMetadata.forEach(
+          (elm) => this.updateNft(elm.nft, elm.newMetadata, userAddress, chainId)
+        );
       }
-    });
-    if (nftsWithDifferentMetadata.length !== 0) {
-      nftsWithDifferentMetadata.forEach(
-        (elm) => this.updateNft(
-          elm.value.nft,
-          elm.value.newMetadata,
-          userAddress,
-          chainId
-        )
-      );
+    } finally {
+      releaseLock();
     }
   }
+  
   /**
    * Removes an NFT from the stored token list.
    *
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-4LY47RPI.mjs b/node_modules/@metamask/assets-controllers/dist/chunk-4LY47RPI.mjs
index b4fa939..29ff871 100644
--- a/node_modules/@metamask/assets-controllers/dist/chunk-4LY47RPI.mjs
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-4LY47RPI.mjs
@@ -19,7 +19,7 @@ function getDefaultTokenBalancesState() {
     contractBalances: {}
   };
 }
-var _handle, _getERC20BalanceOf, _interval, _tokens, _disabled;
+var _handle, _getERC20BalanceOf, _interval, _tokens, _disabled, _updateInProgress;
 var TokenBalancesController = class extends BaseController {
   /**
    * Construct a Token Balances Controller.
@@ -28,6 +28,7 @@ var TokenBalancesController = class extends BaseController {
    * @param options.interval - Polling interval used to fetch new token balances.
    * @param options.tokens - List of tokens to track balances for.
    * @param options.disabled - If set to true, all tracked tokens contract balances updates are blocked.
+   * @param options.onTokensStateChange - Allows subscribing to token controller state changes.
    * @param options.getERC20BalanceOf - Gets the balance of the given account at the given contract address.
    * @param options.state - Initial state to set on this controller.
    * @param options.messenger - The controller restricted messenger.
@@ -36,6 +37,7 @@ var TokenBalancesController = class extends BaseController {
     interval = DEFAULT_INTERVAL,
     tokens = [],
     disabled = false,
+    onTokensStateChange,
     getERC20BalanceOf,
     messenger,
     state = {}
@@ -55,15 +57,13 @@ var TokenBalancesController = class extends BaseController {
     __privateAdd(this, _tokens, void 0);
     __privateAdd(this, _disabled, void 0);
     __privateSet(this, _disabled, disabled);
+    __privateAdd(this, _updateInProgress, false);
     __privateSet(this, _interval, interval);
     __privateSet(this, _tokens, tokens);
-    this.messagingSystem.subscribe(
-      "TokensController:stateChange",
-      ({ tokens: newTokens, detectedTokens }) => {
-        __privateSet(this, _tokens, [...newTokens, ...detectedTokens]);
-        this.updateBalances();
-      }
-    );
+    onTokensStateChange(async ({ tokens: newTokens, detectedTokens }) => {
+      __privateSet.call(void 0, this, _tokens, [...newTokens, ...detectedTokens]);
+      await this.updateBalances();
+    });
     __privateSet(this, _getERC20BalanceOf, getERC20BalanceOf);
     this.poll();
   }
@@ -100,28 +100,41 @@ var TokenBalancesController = class extends BaseController {
    * Updates balances for all tokens.
    */
   async updateBalances() {
-    if (__privateGet(this, _disabled)) {
+    if (__privateGet(this, _disabled) || __privateGet(this, _updateInProgress)) {
       return;
     }
+    __privateSet.call(this, _updateInProgress, true);
     const newContractBalances = {};
-    for (const token of __privateGet(this, _tokens)) {
+    const balancePromises = __privateGet(this, _tokens).map((token) => {
       const { address } = token;
       const { selectedAddress } = this.messagingSystem.call(
         "PreferencesController:getState"
       );
-      try {
-        newContractBalances[address] = toHex(
-          await __privateGet(this, _getERC20BalanceOf).call(this, address, selectedAddress)
-        );
+      return __privateGet(this, _getERC20BalanceOf).call(this, address, selectedAddress).then((balance) => {
+        newContractBalances[address] = toHex.call(void 0, balance);
         token.balanceError = null;
-      } catch (error) {
-        newContractBalances[address] = toHex(0);
+      }).catch((error) => {
+        newContractBalances[address] = toHex.call(void 0, 0);
         token.balanceError = error;
-      }
-    }
+      });
+    });
+
+    await Promise.all(balancePromises);
+  
     this.update((state) => {
       state.contractBalances = newContractBalances;
     });
+    __privateSet.call(this, _updateInProgress, false);
+  }
+
+   /**
+   * THIS FUNCTIONS IS CURRENTLY PATCHED AND STILL NEEDS TO BE IMPLEMENTED ON THE CORE REPO
+   * Resets to the default state
+   */
+   reset() {
+    this.update((state) => {
+      state.contractBalances = {};
+    });
   }
 };
 _handle = new WeakMap();
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-6W5EQ3JQ.js b/node_modules/@metamask/assets-controllers/dist/chunk-6W5EQ3JQ.js
index 0dc70ec..3fcb94e 100644
--- a/node_modules/@metamask/assets-controllers/dist/chunk-6W5EQ3JQ.js
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-6W5EQ3JQ.js
@@ -378,9 +378,10 @@ fetchAndMapExchangeRatesForSupportedNativeCurrency_fn = async function({
   }
   return Object.entries(contractNativeInformations).reduce(
     (obj, [tokenAddress, token]) => {
+      // This is fixed on v31 of assets controllers
       obj = {
         ...obj,
-        [tokenAddress.toLowerCase()]: { ...token }
+        [tokenAddress]: { ...token }
       };
       return obj;
     },
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-HDI4L2DD.js b/node_modules/@metamask/assets-controllers/dist/chunk-HDI4L2DD.js
index 76e3362..5ab79a4 100644
--- a/node_modules/@metamask/assets-controllers/dist/chunk-HDI4L2DD.js
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-HDI4L2DD.js
@@ -34,7 +34,7 @@ var STATIC_MAINNET_TOKEN_LIST = Object.entries(
   };
 }, {});
 var controllerName = "TokenDetectionController";
-var _intervalId, _selectedAddress, _networkClientId, _tokenList, _disabled, _isUnlocked, _isDetectionEnabledFromPreferences, _isDetectionEnabledForNetwork, _getBalancesInSingleCall, _trackMetaMetricsEvent, _registerEventListeners, registerEventListeners_fn, _stopPolling, stopPolling_fn, _startPolling, startPolling_fn, _getCorrectChainIdAndNetworkClientId, getCorrectChainIdAndNetworkClientId_fn, _restartTokenDetection, restartTokenDetection_fn, _getSlicesOfTokensToDetect, getSlicesOfTokensToDetect_fn, _addDetectedTokens, addDetectedTokens_fn;
+var _intervalId, _selectedAddress, _networkClientId, _tokenList, _disabled, _isUnlocked, _isDetectionEnabledFromPreferences, _isDetectionEnabledForNetwork, _getBalancesInSingleCall, _getTokensState, _trackMetaMetricsEvent, _registerEventListeners, registerEventListeners_fn, _stopPolling, stopPolling_fn, _startPolling, startPolling_fn, _getCorrectChainIdAndNetworkClientId, getCorrectChainIdAndNetworkClientId_fn, _restartTokenDetection, restartTokenDetection_fn, _getSlicesOfTokensToDetect, getSlicesOfTokensToDetect_fn, _addDetectedTokens, addDetectedTokens_fn;
 var TokenDetectionController = class extends _pollingcontroller.StaticIntervalPollingController {
   /**
    * Creates a TokenDetectionController instance.
@@ -52,6 +52,7 @@ var TokenDetectionController = class extends _pollingcontroller.StaticIntervalPo
     interval = DEFAULT_INTERVAL,
     disabled = true,
     getBalancesInSingleCall,
+    getTokensState,
     trackMetaMetricsEvent,
     messenger
   }) {
@@ -91,6 +92,7 @@ var TokenDetectionController = class extends _pollingcontroller.StaticIntervalPo
     _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _isDetectionEnabledFromPreferences, void 0);
     _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _isDetectionEnabledForNetwork, void 0);
     _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getBalancesInSingleCall, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getTokensState, void 0);
     _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _trackMetaMetricsEvent, void 0);
     _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _disabled, disabled);
     this.setIntervalLength(interval);
@@ -101,6 +103,7 @@ var TokenDetectionController = class extends _pollingcontroller.StaticIntervalPo
     _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _isDetectionEnabledFromPreferences, defaultUseTokenDetection);
     _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _isDetectionEnabledForNetwork, _chunkNEXY7SE2js.isTokenDetectionSupportedForNetwork.call(void 0, chainId));
     _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _getBalancesInSingleCall, getBalancesInSingleCall);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _getTokensState, getTokensState);
     _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _trackMetaMetricsEvent, trackMetaMetricsEvent);
     const { isUnlocked } = this.messagingSystem.call(
       "KeyringController:getState"
@@ -203,6 +206,7 @@ _isDetectionEnabledFromPreferences = new WeakMap();
 _isDetectionEnabledForNetwork = new WeakMap();
 _getBalancesInSingleCall = new WeakMap();
 _trackMetaMetricsEvent = new WeakMap();
+_getTokensState = new WeakMap();
 _registerEventListeners = new WeakSet();
 registerEventListeners_fn = function() {
   this.messagingSystem.subscribe("KeyringController:unlock", async () => {
@@ -324,7 +328,7 @@ getSlicesOfTokensToDetect_fn = function({
   chainId,
   selectedAddress
 }) {
-  const { allTokens, allDetectedTokens, allIgnoredTokens } = this.messagingSystem.call("TokensController:getState");
+  const { allTokens, allDetectedTokens, allIgnoredTokens } = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _getTokensState).call(this);
   const [tokensAddresses, detectedTokensAddresses, ignoredTokensAddresses] = [
     allTokens,
     allDetectedTokens,
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-LD4GC7OR.js b/node_modules/@metamask/assets-controllers/dist/chunk-LD4GC7OR.js
index cd8f792..b20db8a 100644
--- a/node_modules/@metamask/assets-controllers/dist/chunk-LD4GC7OR.js
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-LD4GC7OR.js
@@ -19,7 +19,7 @@ function getDefaultTokenBalancesState() {
     contractBalances: {}
   };
 }
-var _handle, _getERC20BalanceOf, _interval, _tokens, _disabled;
+var _handle, _getERC20BalanceOf, _interval, _tokens, _disabled, _updateInProgress;
 var TokenBalancesController = class extends _basecontroller.BaseController {
   /**
    * Construct a Token Balances Controller.
@@ -28,6 +28,7 @@ var TokenBalancesController = class extends _basecontroller.BaseController {
    * @param options.interval - Polling interval used to fetch new token balances.
    * @param options.tokens - List of tokens to track balances for.
    * @param options.disabled - If set to true, all tracked tokens contract balances updates are blocked.
+   * @param options.onTokensStateChange - Allows subscribing to token controller state changes.
    * @param options.getERC20BalanceOf - Gets the balance of the given account at the given contract address.
    * @param options.state - Initial state to set on this controller.
    * @param options.messenger - The controller restricted messenger.
@@ -36,6 +37,7 @@ var TokenBalancesController = class extends _basecontroller.BaseController {
     interval = DEFAULT_INTERVAL,
     tokens = [],
     disabled = false,
+    onTokensStateChange,
     getERC20BalanceOf,
     messenger,
     state = {}
@@ -54,16 +56,14 @@ var TokenBalancesController = class extends _basecontroller.BaseController {
     _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _interval, void 0);
     _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _tokens, void 0);
     _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _disabled, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _updateInProgress, false);
     _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _disabled, disabled);
     _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _interval, interval);
     _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _tokens, tokens);
-    this.messagingSystem.subscribe(
-      "TokensController:stateChange",
-      ({ tokens: newTokens, detectedTokens }) => {
-        _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _tokens, [...newTokens, ...detectedTokens]);
-        this.updateBalances();
-      }
-    );
+    onTokensStateChange(async ({ tokens: newTokens, detectedTokens }) => {
+      _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _tokens, [...newTokens, ...detectedTokens]);
+      await this.updateBalances();
+    });
     _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _getERC20BalanceOf, getERC20BalanceOf);
     this.poll();
   }
@@ -96,39 +96,50 @@ var TokenBalancesController = class extends _basecontroller.BaseController {
       this.poll(_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _interval));
     }, _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _interval)));
   }
-  /**
+   /**
    * Updates balances for all tokens.
    */
-  async updateBalances() {
-    if (_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _disabled)) {
+   async updateBalances() {
+    if (_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _disabled) || _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _updateInProgress)) {
       return;
     }
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _updateInProgress, true);
     const newContractBalances = {};
-    for (const token of _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _tokens)) {
+    const balancePromises = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _tokens).map((token) => {
       const { address } = token;
       const { selectedAddress } = this.messagingSystem.call(
         "PreferencesController:getState"
       );
-      try {
-        newContractBalances[address] = _controllerutils.toHex.call(void 0, 
-          await _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _getERC20BalanceOf).call(this, address, selectedAddress)
-        );
+      return _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _getERC20BalanceOf).call(this, address, selectedAddress).then((balance) => {
+        newContractBalances[address] = _controllerutils.toHex.call(void 0, balance);
         token.balanceError = null;
-      } catch (error) {
+      }).catch((error) => {
         newContractBalances[address] = _controllerutils.toHex.call(void 0, 0);
         token.balanceError = error;
-      }
-    }
+      });
+    });
+    await Promise.all(balancePromises);
     this.update((state) => {
       state.contractBalances = newContractBalances;
     });
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _updateInProgress, false);
   }
+  /**
+   * THIS FUNCTIONS IS CURRENTLY PATCHED AND STILL NEEDS TO BE IMPLEMENTED ON THE CORE REPO
+   * Resets to the default state
+   */
+    reset() {
+      this.update((state) => {
+        state.contractBalances = {};
+      });
+    }
 };
 _handle = new WeakMap();
 _getERC20BalanceOf = new WeakMap();
 _interval = new WeakMap();
 _tokens = new WeakMap();
 _disabled = new WeakMap();
+_updateInProgress = new WeakMap();
 var TokenBalancesController_default = TokenBalancesController;
 
 
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-MR6EF4B7.mjs b/node_modules/@metamask/assets-controllers/dist/chunk-MR6EF4B7.mjs
index 06df77e..c1da685 100644
--- a/node_modules/@metamask/assets-controllers/dist/chunk-MR6EF4B7.mjs
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-MR6EF4B7.mjs
@@ -34,7 +34,7 @@ var STATIC_MAINNET_TOKEN_LIST = Object.entries(
   };
 }, {});
 var controllerName = "TokenDetectionController";
-var _intervalId, _selectedAddress, _networkClientId, _tokenList, _disabled, _isUnlocked, _isDetectionEnabledFromPreferences, _isDetectionEnabledForNetwork, _getBalancesInSingleCall, _trackMetaMetricsEvent, _registerEventListeners, registerEventListeners_fn, _stopPolling, stopPolling_fn, _startPolling, startPolling_fn, _getCorrectChainIdAndNetworkClientId, getCorrectChainIdAndNetworkClientId_fn, _restartTokenDetection, restartTokenDetection_fn, _getSlicesOfTokensToDetect, getSlicesOfTokensToDetect_fn, _addDetectedTokens, addDetectedTokens_fn;
+var _intervalId, _selectedAddress, _networkClientId, _tokenList, _disabled, _isUnlocked, _isDetectionEnabledFromPreferences, _isDetectionEnabledForNetwork, _getBalancesInSingleCall, _getTokensState, _trackMetaMetricsEvent, _registerEventListeners, registerEventListeners_fn, _stopPolling, stopPolling_fn, _startPolling, startPolling_fn, _getCorrectChainIdAndNetworkClientId, getCorrectChainIdAndNetworkClientId_fn, _restartTokenDetection, restartTokenDetection_fn, _getSlicesOfTokensToDetect, getSlicesOfTokensToDetect_fn, _addDetectedTokens, addDetectedTokens_fn;
 var TokenDetectionController = class extends StaticIntervalPollingController {
   /**
    * Creates a TokenDetectionController instance.
@@ -52,6 +52,7 @@ var TokenDetectionController = class extends StaticIntervalPollingController {
     interval = DEFAULT_INTERVAL,
     disabled = true,
     getBalancesInSingleCall,
+    getTokensState,
     trackMetaMetricsEvent,
     messenger
   }) {
@@ -91,6 +92,7 @@ var TokenDetectionController = class extends StaticIntervalPollingController {
     __privateAdd(this, _isDetectionEnabledFromPreferences, void 0);
     __privateAdd(this, _isDetectionEnabledForNetwork, void 0);
     __privateAdd(this, _getBalancesInSingleCall, void 0);
+    __privateAdd(this, _getTokensState, void 0);
     __privateAdd(this, _trackMetaMetricsEvent, void 0);
     __privateSet(this, _disabled, disabled);
     this.setIntervalLength(interval);
@@ -101,6 +103,7 @@ var TokenDetectionController = class extends StaticIntervalPollingController {
     __privateSet(this, _isDetectionEnabledFromPreferences, defaultUseTokenDetection);
     __privateSet(this, _isDetectionEnabledForNetwork, isTokenDetectionSupportedForNetwork(chainId));
     __privateSet(this, _getBalancesInSingleCall, getBalancesInSingleCall);
+    __privateSet(this, _getTokensState, getTokensState);
     __privateSet(this, _trackMetaMetricsEvent, trackMetaMetricsEvent);
     const { isUnlocked } = this.messagingSystem.call(
       "KeyringController:getState"
@@ -202,6 +205,7 @@ _isUnlocked = new WeakMap();
 _isDetectionEnabledFromPreferences = new WeakMap();
 _isDetectionEnabledForNetwork = new WeakMap();
 _getBalancesInSingleCall = new WeakMap();
+_getTokensState = new WeakMap();
 _trackMetaMetricsEvent = new WeakMap();
 _registerEventListeners = new WeakSet();
 registerEventListeners_fn = function() {
@@ -324,7 +328,7 @@ getSlicesOfTokensToDetect_fn = function({
   chainId,
   selectedAddress
 }) {
-  const { allTokens, allDetectedTokens, allIgnoredTokens } = this.messagingSystem.call("TokensController:getState");
+  const { allTokens, allDetectedTokens, allIgnoredTokens } = __privateGet(this, _getTokensState).call(this);
   const [tokensAddresses, detectedTokensAddresses, ignoredTokensAddresses] = [
     allTokens,
     allDetectedTokens,
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-PAJTKWEC.mjs b/node_modules/@metamask/assets-controllers/dist/chunk-PAJTKWEC.mjs
index 58047d9..fb03d52 100644
--- a/node_modules/@metamask/assets-controllers/dist/chunk-PAJTKWEC.mjs
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-PAJTKWEC.mjs
@@ -80,9 +80,11 @@ var AccountTrackerController = class extends StaticIntervalPollingControllerV1 {
             [chainId]: accountsForChain
           }
         });
-      } catch (err) {
+      } finally {
+        /**
+         * This change is not present on the core repo
+         */
         releaseLock();
-        throw err;
       }
     };
     this.defaultConfig = {
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-V4ZO3F2S.js b/node_modules/@metamask/assets-controllers/dist/chunk-V4ZO3F2S.js
index 0430e5c..dee32be 100644
--- a/node_modules/@metamask/assets-controllers/dist/chunk-V4ZO3F2S.js
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-V4ZO3F2S.js
@@ -80,9 +80,11 @@ var AccountTrackerController = class extends _pollingcontroller.StaticIntervalPo
             [chainId]: accountsForChain
           }
         });
-      } catch (err) {
+      } finally {
+        /**
+         * This change is not present on the core repo
+         */
         releaseLock();
-        throw err;
       }
     };
     this.defaultConfig = {
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-Y35SM7TO.mjs b/node_modules/@metamask/assets-controllers/dist/chunk-Y35SM7TO.mjs
index 245b7b3..1d1c9c5 100644
--- a/node_modules/@metamask/assets-controllers/dist/chunk-Y35SM7TO.mjs
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-Y35SM7TO.mjs
@@ -295,7 +295,7 @@ var CodefiTokenPricesServiceV2 = class {
       (obj, tokenAddress) => {
         const lowercasedTokenAddress = tokenAddress.toLowerCase();
         const marketData = addressCryptoDataMap[lowercasedTokenAddress];
-        if (marketData === void 0) {
+        if (!marketData) {
           return obj;
         }
         const { price } = marketData;
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-Z6TBQQE5.js b/node_modules/@metamask/assets-controllers/dist/chunk-Z6TBQQE5.js
index 2f1b66f..eb28224 100644
--- a/node_modules/@metamask/assets-controllers/dist/chunk-Z6TBQQE5.js
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-Z6TBQQE5.js
@@ -295,7 +295,8 @@ var CodefiTokenPricesServiceV2 = class {
       (obj, tokenAddress) => {
         const lowercasedTokenAddress = tokenAddress.toLowerCase();
         const marketData = addressCryptoDataMap[lowercasedTokenAddress];
-        if (marketData === void 0) {
+        // This is fixed on v31 of assets controllers
+        if (!marketData) {
           return obj;
         }
         const { price } = marketData;
diff --git a/node_modules/@metamask/assets-controllers/dist/types/NftController.d.ts b/node_modules/@metamask/assets-controllers/dist/types/NftController.d.ts
index 42a321a..e158cba 100644
--- a/node_modules/@metamask/assets-controllers/dist/types/NftController.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/types/NftController.d.ts
@@ -109,6 +109,7 @@ export interface NftMetadata {
     creator?: string;
     transactionId?: string;
     tokenURI?: string | null;
+    error?: string;
     collection?: Collection;
     address?: string;
     attributes?: Attributes;
@@ -125,7 +126,7 @@ export interface NftConfig extends BaseConfig {
     selectedAddress: string;
     chainId: Hex;
     ipfsGateway: string;
-    openSeaEnabled: boolean;
+    displayNftMedia: boolean;
     useIPFSSubdomains: boolean;
     isIpfsGatewayEnabled: boolean;
 }
diff --git a/node_modules/@metamask/assets-controllers/dist/types/TokenBalancesController.d.ts b/node_modules/@metamask/assets-controllers/dist/types/TokenBalancesController.d.ts
index 52bb3ac..1f4d15d 100644
--- a/node_modules/@metamask/assets-controllers/dist/types/TokenBalancesController.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/types/TokenBalancesController.d.ts
@@ -56,11 +56,12 @@ export declare class TokenBalancesController extends BaseController<typeof contr
      * @param options.interval - Polling interval used to fetch new token balances.
      * @param options.tokens - List of tokens to track balances for.
      * @param options.disabled - If set to true, all tracked tokens contract balances updates are blocked.
+     * @param options.onTokensStateChange -  Allows subscribing to token controller state changes.
      * @param options.getERC20BalanceOf - Gets the balance of the given account at the given contract address.
      * @param options.state - Initial state to set on this controller.
      * @param options.messenger - The controller restricted messenger.
      */
-    constructor({ interval, tokens, disabled, getERC20BalanceOf, messenger, state, }: TokenBalancesControllerOptions);
+    constructor({ interval, tokens, disabled, onTokensStateChange, getERC20BalanceOf, messenger, state, }: TokenBalancesControllerOptions);
     /**
      * Allows controller to update tracked tokens contract balances.
      */
@@ -79,6 +80,11 @@ export declare class TokenBalancesController extends BaseController<typeof contr
      * Updates balances for all tokens.
      */
     updateBalances(): Promise<void>;
+    /**
+     * THIS FUNCTIONS IS CURRENTLY PATCHED AND STILL NEEDS TO BE IMPLEMENTED ON THE CORE REPO
+     * Resets to the default state
+     */
+    reset(): void;
 }
 export default TokenBalancesController;
 //# sourceMappingURL=TokenBalancesController.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/TokenDetectionController.d.ts b/node_modules/@metamask/assets-controllers/dist/types/TokenDetectionController.d.ts
index 220d78d..795b96e 100644
--- a/node_modules/@metamask/assets-controllers/dist/types/TokenDetectionController.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/types/TokenDetectionController.d.ts
@@ -6,7 +6,7 @@ import { StaticIntervalPollingController } from '@metamask/polling-controller';
 import type { PreferencesControllerGetStateAction, PreferencesControllerStateChangeEvent } from '@metamask/preferences-controller';
 import type { AssetsContractController } from './AssetsContractController';
 import type { GetTokenListState, TokenListMap, TokenListStateChange } from './TokenListController';
-import type { TokensControllerAddDetectedTokensAction, TokensControllerGetStateAction } from './TokensController';
+import type { TokensControllerAddDetectedTokensAction, TokensControllerGetStateAction, TokensState } from './TokensController';
 /**
  * Compare 2 given strings and return boolean
  * eg: "foo" and "FOO" => true
@@ -54,11 +54,12 @@ export declare class TokenDetectionController extends StaticIntervalPollingContr
      * @param options.getBalancesInSingleCall - Gets the balances of a list of tokens for the given address.
      * @param options.trackMetaMetricsEvent - Sets options for MetaMetrics event tracking.
      */
-    constructor({ selectedAddress, interval, disabled, getBalancesInSingleCall, trackMetaMetricsEvent, messenger, }: {
+    constructor({ selectedAddress, interval, disabled, getBalancesInSingleCall, getTokensState, trackMetaMetricsEvent, messenger, }: {
         selectedAddress?: string;
         interval?: number;
         disabled?: boolean;
         getBalancesInSingleCall: AssetsContractController['getBalancesInSingleCall'];
+        getTokensState: () => TokensState;
         trackMetaMetricsEvent: (options: {
             event: string;
             category: string;
diff --git a/node_modules/@metamask/assets-controllers/dist/types/index.d.ts b/node_modules/@metamask/assets-controllers/dist/types/index.d.ts
index a71f4a7..df1ddc9 100644
--- a/node_modules/@metamask/assets-controllers/dist/types/index.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/types/index.d.ts
@@ -3,7 +3,7 @@ export * from './AssetsContractController';
 export * from './CurrencyRateController';
 export * from './NftController';
 export * from './NftDetectionController';
-export type { TokenBalancesControllerMessenger, TokenBalancesControllerActions, TokenBalancesControllerGetStateAction, TokenBalancesControllerEvents, TokenBalancesControllerStateChangeEvent, } from './TokenBalancesController';
+export type { TokenBalancesControllerMessenger, TokenBalancesControllerActions, TokenBalancesControllerGetStateAction, TokenBalancesControllerEvents, TokenBalancesControllerStateChangeEvent, TokenBalancesControllerState } from './TokenBalancesController';
 export { TokenBalancesController } from './TokenBalancesController';
 export type { TokenDetectionControllerMessenger, TokenDetectionControllerActions, TokenDetectionControllerGetStateAction, TokenDetectionControllerEvents, TokenDetectionControllerStateChangeEvent, } from './TokenDetectionController';
 export { TokenDetectionController } from './TokenDetectionController';
