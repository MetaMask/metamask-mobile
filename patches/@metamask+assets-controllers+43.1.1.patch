diff --git a/node_modules/@metamask/assets-controllers/dist/NftController.cjs b/node_modules/@metamask/assets-controllers/dist/NftController.cjs
index 6ccbe9c..49270d6 100644
--- a/node_modules/@metamask/assets-controllers/dist/NftController.cjs
+++ b/node_modules/@metamask/assets-controllers/dist/NftController.cjs
@@ -13,7 +13,7 @@ var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (
 var __importDefault = (this && this.__importDefault) || function (mod) {
     return (mod && mod.__esModule) ? mod : { "default": mod };
 };
-var _NftController_instances, _NftController_mutex, _NftController_selectedAccountId, _NftController_chainId, _NftController_ipfsGateway, _NftController_openSeaEnabled, _NftController_useIpfsSubdomains, _NftController_isIpfsGatewayEnabled, _NftController_onNftAdded, _NftController_onNetworkControllerNetworkDidChange, _NftController_onPreferencesControllerStateChange, _NftController_onSelectedAccountChange, _NftController_updateNestedNftState, _NftController_getNftCollectionApi, _NftController_getNftInformationFromApi, _NftController_getNftInformationFromTokenURI, _NftController_getNftURIAndStandard, _NftController_getNftInformation, _NftController_getNftContractInformationFromContract, _NftController_getNftContractInformation, _NftController_addIndividualNft, _NftController_addNftContract, _NftController_removeAndIgnoreIndividualNft, _NftController_removeIndividualNft, _NftController_removeNftContract, _NftController_validateWatchNft, _NftController_getCorrectChainId, _NftController_getAddressOrSelectedAddress, _NftController_updateNftUpdateForAccount;
+var _NftController_instances, _NftController_mutex, _NftController_selectedAccountId, _NftController_chainId, _NftController_ipfsGateway, _NftController_displayNftMedia, _NftController_useIpfsSubdomains, _NftController_isIpfsGatewayEnabled, _NftController_onNftAdded, _NftController_onNetworkControllerNetworkDidChange, _NftController_onPreferencesControllerStateChange, _NftController_onSelectedAccountChange, _NftController_updateNestedNftState, _NftController_getNftCollectionApi, _NftController_getNftInformationFromApi, _NftController_getNftInformationFromTokenURI, _NftController_getNftURIAndStandard, _NftController_getNftInformation, _NftController_getNftContractInformationFromContract, _NftController_getNftContractInformation, _NftController_addIndividualNft, _NftController_addNftContract, _NftController_removeAndIgnoreIndividualNft, _NftController_removeIndividualNft, _NftController_removeNftContract, _NftController_validateWatchNft, _NftController_getCorrectChainId, _NftController_getAddressOrSelectedAddress, _NftController_updateNftUpdateForAccount;
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.NftController = exports.getDefaultNftControllerState = void 0;
 const address_1 = require("@ethersproject/address");
@@ -53,7 +53,7 @@ class NftController extends base_controller_1.BaseController {
      * @param options - The controller options.
      * @param options.chainId - The chain ID of the current network.
      * @param options.ipfsGateway - The configured IPFS gateway.
-     * @param options.openSeaEnabled - Controls whether the OpenSea API is used.
+     * @param options.displayNftMedia - Controls whether the OpenSea API is used.
      * @param options.useIpfsSubdomains - Controls whether IPFS subdomains are used.
      * @param options.isIpfsGatewayEnabled - Controls whether IPFS is enabled or not.
      * @param options.onNftAdded - Callback that is called when an NFT is added. Currently used pass data
@@ -61,7 +61,7 @@ class NftController extends base_controller_1.BaseController {
      * @param options.messenger - The controller messenger.
      * @param options.state - Initial state to set on this controller.
      */
-    constructor({ chainId: initialChainId, ipfsGateway = controller_utils_1.IPFS_DEFAULT_GATEWAY_URL, openSeaEnabled = false, useIpfsSubdomains = true, isIpfsGatewayEnabled = true, onNftAdded, messenger, state = {}, }) {
+    constructor({ chainId: initialChainId, ipfsGateway = controller_utils_1.IPFS_DEFAULT_GATEWAY_URL, displayNftMedia = false, useIpfsSubdomains = true, isIpfsGatewayEnabled = true, onNftAdded, messenger, state = {}, }) {
         super({
             name: controllerName,
             metadata: nftControllerMetadata,
@@ -76,14 +76,14 @@ class NftController extends base_controller_1.BaseController {
         _NftController_selectedAccountId.set(this, void 0);
         _NftController_chainId.set(this, void 0);
         _NftController_ipfsGateway.set(this, void 0);
-        _NftController_openSeaEnabled.set(this, void 0);
+        _NftController_displayNftMedia.set(this, void 0);
         _NftController_useIpfsSubdomains.set(this, void 0);
         _NftController_isIpfsGatewayEnabled.set(this, void 0);
         _NftController_onNftAdded.set(this, void 0);
         __classPrivateFieldSet(this, _NftController_selectedAccountId, this.messagingSystem.call('AccountsController:getSelectedAccount').id, "f");
         __classPrivateFieldSet(this, _NftController_chainId, initialChainId, "f");
         __classPrivateFieldSet(this, _NftController_ipfsGateway, ipfsGateway, "f");
-        __classPrivateFieldSet(this, _NftController_openSeaEnabled, openSeaEnabled, "f");
+        __classPrivateFieldSet(this, _NftController_displayNftMedia, displayNftMedia, "f");
         __classPrivateFieldSet(this, _NftController_useIpfsSubdomains, useIpfsSubdomains, "f");
         __classPrivateFieldSet(this, _NftController_isIpfsGatewayEnabled, isIpfsGatewayEnabled, "f");
         __classPrivateFieldSet(this, _NftController_onNftAdded, onNftAdded, "f");
@@ -589,7 +589,7 @@ class NftController extends base_controller_1.BaseController {
     }
 }
 exports.NftController = NftController;
-_NftController_mutex = new WeakMap(), _NftController_selectedAccountId = new WeakMap(), _NftController_chainId = new WeakMap(), _NftController_ipfsGateway = new WeakMap(), _NftController_openSeaEnabled = new WeakMap(), _NftController_useIpfsSubdomains = new WeakMap(), _NftController_isIpfsGatewayEnabled = new WeakMap(), _NftController_onNftAdded = new WeakMap(), _NftController_instances = new WeakSet(), _NftController_onNetworkControllerNetworkDidChange = function _NftController_onNetworkControllerNetworkDidChange({ selectedNetworkClientId, }) {
+_NftController_mutex = new WeakMap(), _NftController_selectedAccountId = new WeakMap(), _NftController_chainId = new WeakMap(), _NftController_ipfsGateway = new WeakMap(), _NftController_displayNftMedia = new WeakMap(), _NftController_useIpfsSubdomains = new WeakMap(), _NftController_isIpfsGatewayEnabled = new WeakMap(), _NftController_onNftAdded = new WeakMap(), _NftController_instances = new WeakSet(), _NftController_onNetworkControllerNetworkDidChange = function _NftController_onNetworkControllerNetworkDidChange({ selectedNetworkClientId, }) {
     const { configuration: { chainId }, } = this.messagingSystem.call('NetworkController:getNetworkClientById', selectedNetworkClientId);
     __classPrivateFieldSet(this, _NftController_chainId, chainId, "f");
 }, _NftController_onPreferencesControllerStateChange = 
@@ -597,16 +597,16 @@ _NftController_mutex = new WeakMap(), _NftController_selectedAccountId = new Wea
  * Handles the state change of the preference controller.
  * @param preferencesState - The new state of the preference controller.
  * @param preferencesState.ipfsGateway - The configured IPFS gateway.
- * @param preferencesState.openSeaEnabled - Controls whether the OpenSea API is used.
+ * @param preferencesState.displayNftMedia - Controls whether the OpenSea API is used.
  * @param preferencesState.isIpfsGatewayEnabled - Controls whether IPFS is enabled or not.
  */
-async function _NftController_onPreferencesControllerStateChange({ ipfsGateway, openSeaEnabled, isIpfsGatewayEnabled, }) {
+async function _NftController_onPreferencesControllerStateChange({ ipfsGateway, displayNftMedia, isIpfsGatewayEnabled, }) {
     const selectedAccount = this.messagingSystem.call('AccountsController:getSelectedAccount');
     __classPrivateFieldSet(this, _NftController_selectedAccountId, selectedAccount.id, "f");
     __classPrivateFieldSet(this, _NftController_ipfsGateway, ipfsGateway, "f");
-    __classPrivateFieldSet(this, _NftController_openSeaEnabled, openSeaEnabled, "f");
+    __classPrivateFieldSet(this, _NftController_displayNftMedia, displayNftMedia, "f");
     __classPrivateFieldSet(this, _NftController_isIpfsGatewayEnabled, isIpfsGatewayEnabled, "f");
-    const needsUpdateNftMetadata = (isIpfsGatewayEnabled && ipfsGateway !== '') || openSeaEnabled;
+    const needsUpdateNftMetadata = (isIpfsGatewayEnabled && ipfsGateway !== '') || displayNftMedia;
     if (needsUpdateNftMetadata && selectedAccount) {
         await __classPrivateFieldGet(this, _NftController_instances, "m", _NftController_updateNftUpdateForAccount).call(this, selectedAccount);
     }
@@ -619,7 +619,7 @@ async function _NftController_onSelectedAccountChange(internalAccount) {
     const oldSelectedAccountId = __classPrivateFieldGet(this, _NftController_selectedAccountId, "f");
     __classPrivateFieldSet(this, _NftController_selectedAccountId, internalAccount.id, "f");
     const needsUpdateNftMetadata = ((__classPrivateFieldGet(this, _NftController_isIpfsGatewayEnabled, "f") && __classPrivateFieldGet(this, _NftController_ipfsGateway, "f") !== '') ||
-        __classPrivateFieldGet(this, _NftController_openSeaEnabled, "f")) &&
+        __classPrivateFieldGet(this, _NftController_displayNftMedia, "f")) &&
         oldSelectedAccountId !== internalAccount.id;
     if (needsUpdateNftMetadata) {
         await __classPrivateFieldGet(this, _NftController_instances, "m", _NftController_updateNftUpdateForAccount).call(this, internalAccount);
@@ -694,6 +694,7 @@ async function _NftController_getNftInformationFromApi(contractAddress, tokenId)
             description: null,
             image: null,
             standard: null,
+            error: 'Opensea import error',
         };
     }
     // if we've reached this point, we have successfully fetched some data for nftInformation
@@ -738,7 +739,7 @@ async function _NftController_getNftInformationFromTokenURI(contractAddress, tok
             tokenURI: tokenURI ?? null,
         };
     }
-    const isDisplayNFTMediaToggleEnabled = __classPrivateFieldGet(this, _NftController_openSeaEnabled, "f");
+    const isDisplayNFTMediaToggleEnabled = __classPrivateFieldGet(this, _NftController_displayNftMedia, "f");
     if (!hasIpfsTokenURI && !isDisplayNFTMediaToggleEnabled) {
         return {
             image: null,
@@ -747,6 +748,7 @@ async function _NftController_getNftInformationFromTokenURI(contractAddress, tok
             standard: standard || null,
             favorite: false,
             tokenURI: tokenURI ?? null,
+            error: 'URI import error',
         };
     }
     if (hasIpfsTokenURI) {
@@ -785,6 +787,7 @@ async function _NftController_getNftInformationFromTokenURI(contractAddress, tok
             standard: standard || null,
             favorite: false,
             tokenURI: tokenURI ?? null,
+            error: 'URI import error',
         };
     }
 }, _NftController_getNftURIAndStandard = 
@@ -840,10 +843,21 @@ async function _NftController_getNftInformation(contractAddress, tokenId, networ
     });
     const [blockchainMetadata, nftApiMetadata] = await Promise.all([
         (0, controller_utils_1.safelyExecute)(() => __classPrivateFieldGet(this, _NftController_instances, "m", _NftController_getNftInformationFromTokenURI).call(this, contractAddress, tokenId, networkClientId)),
-        __classPrivateFieldGet(this, _NftController_openSeaEnabled, "f") && chainId === '0x1'
+        __classPrivateFieldGet(this, _NftController_displayNftMedia, "f") && chainId === '0x1'
             ? (0, controller_utils_1.safelyExecute)(() => __classPrivateFieldGet(this, _NftController_instances, "m", _NftController_getNftInformationFromApi).call(this, contractAddress, tokenId))
             : undefined,
     ]);
+    if (blockchainMetadata?.error && nftApiMetadata?.error) {
+        return {
+          image: null,
+          name: null,
+          description: null,
+          standard: blockchainMetadata.standard ?? null,
+          favorite: false,
+          tokenURI: blockchainMetadata.tokenURI ?? null,
+          error: 'Both import failed',
+        };
+    }
     return {
         ...nftApiMetadata,
         name: blockchainMetadata?.name ?? nftApiMetadata?.name ?? null,
@@ -985,6 +999,7 @@ async function _NftController_addIndividualNft(tokenAddress, tokenId, nftMetadat
                 tokenId: tokenId.toString(),
                 standard: nftMetadata.standard,
                 source,
+                tokenURI: nftMetadata.tokenURI,
             });
         }
     }
diff --git a/node_modules/@metamask/assets-controllers/dist/NftController.d.cts b/node_modules/@metamask/assets-controllers/dist/NftController.d.cts
index a34725f..21e9d20 100644
--- a/node_modules/@metamask/assets-controllers/dist/NftController.d.cts
+++ b/node_modules/@metamask/assets-controllers/dist/NftController.d.cts
@@ -108,6 +108,7 @@ export type NftMetadata = {
     creator?: string;
     transactionId?: string;
     tokenURI?: string | null;
+    error?: string;
     collection?: Collection;
     address?: string;
     attributes?: Attributes[];
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.cjs b/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.cjs
index 6f48d64..e1532fa 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.cjs
+++ b/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.cjs
@@ -10,7 +10,7 @@ var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (
     if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
     return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
 };
-var _TokenBalancesController_handle, _TokenBalancesController_interval, _TokenBalancesController_tokens, _TokenBalancesController_disabled;
+var _TokenBalancesController_handle, _TokenBalancesController_interval, _TokenBalancesController_tokens, _TokenBalancesController_disabled, _TokenBalancesController_updateInProgress;
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.TokenBalancesController = exports.getDefaultTokenBalancesState = void 0;
 const base_controller_1 = require("@metamask/base-controller");
@@ -60,9 +60,11 @@ class TokenBalancesController extends base_controller_1.BaseController {
         _TokenBalancesController_interval.set(this, void 0);
         _TokenBalancesController_tokens.set(this, void 0);
         _TokenBalancesController_disabled.set(this, void 0);
+        _TokenBalancesController_updateInProgress.set(this, void 0);
         __classPrivateFieldSet(this, _TokenBalancesController_disabled, disabled, "f");
         __classPrivateFieldSet(this, _TokenBalancesController_interval, interval, "f");
         __classPrivateFieldSet(this, _TokenBalancesController_tokens, tokens, "f");
+        __classPrivateFieldSet(this, _TokenBalancesController_updateInProgress, false, "f");
         this.messagingSystem.subscribe('TokensController:stateChange', ({ tokens: newTokens, detectedTokens }) => {
             __classPrivateFieldSet(this, _TokenBalancesController_tokens, [...newTokens, ...detectedTokens], "f");
             // TODO: Either fix this lint violation or explain why it's necessary to ignore.
@@ -108,26 +110,34 @@ class TokenBalancesController extends base_controller_1.BaseController {
      * Updates balances for all tokens.
      */
     async updateBalances() {
-        if (__classPrivateFieldGet(this, _TokenBalancesController_disabled, "f")) {
+        if (__classPrivateFieldGet(this, _TokenBalancesController_disabled, "f") || __classPrivateFieldGet(this, _TokenBalancesController_updateInProgress, "f")) {
             return;
         }
+        __classPrivateFieldSet(this, _TokenBalancesController_updateInProgress, true, "f");
         const selectedInternalAccount = this.messagingSystem.call('AccountsController:getSelectedAccount');
         const newContractBalances = {};
-        for (const token of __classPrivateFieldGet(this, _TokenBalancesController_tokens, "f")) {
+        const balancePromises = __classPrivateFieldGet(this, _TokenBalancesController_tokens, "f").map((token) => {
             const { address } = token;
-            try {
-                const balance = await this.messagingSystem.call('AssetsContractController:getERC20BalanceOf', address, selectedInternalAccount.address);
+            return this.messagingSystem.call('AssetsContractController:getERC20BalanceOf', address, selectedInternalAccount.address)
+            .then((balance) => {
                 newContractBalances[address] = (0, controller_utils_1.toHex)(balance);
-                token.hasBalanceError = false;
-            }
-            catch (error) {
+                token = {
+                    ...token,
+                    hasBalanceError: false
+                }
+            }).catch((error) => {
                 newContractBalances[address] = (0, controller_utils_1.toHex)(0);
-                token.hasBalanceError = true;
-            }
-        }
+                token = {
+                    ...token,
+                    hasBalanceError: true
+                }
+            })
+        });
+        await Promise.all(balancePromises);
         this.update((state) => {
             state.contractBalances = newContractBalances;
         });
+        __classPrivateFieldSet(this, _TokenBalancesController_updateInProgress, false, "f");
     }
     /**
      * Reset the controller state to the default state.
@@ -139,6 +149,6 @@ class TokenBalancesController extends base_controller_1.BaseController {
     }
 }
 exports.TokenBalancesController = TokenBalancesController;
-_TokenBalancesController_handle = new WeakMap(), _TokenBalancesController_interval = new WeakMap(), _TokenBalancesController_tokens = new WeakMap(), _TokenBalancesController_disabled = new WeakMap();
+_TokenBalancesController_handle = new WeakMap(), _TokenBalancesController_interval = new WeakMap(), _TokenBalancesController_tokens = new WeakMap(), _TokenBalancesController_disabled = new WeakMap(), _TokenBalancesController_updateInProgress = new WeakMap();
 exports.default = TokenBalancesController;
 //# sourceMappingURL=TokenBalancesController.cjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.cjs b/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.cjs
index ab23c95..8fd5efd 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.cjs
+++ b/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.cjs
@@ -204,13 +204,10 @@ class TokenDetectionController extends (0, polling_controller_1.StaticIntervalPo
         // Try detecting tokens via Account API first if conditions allow
         if (supportedNetworks && chainsToDetectUsingAccountAPI.length > 0) {
             const apiResult = await __classPrivateFieldGet(this, _TokenDetectionController_instances, "m", _TokenDetectionController_attemptAccountAPIDetection).call(this, chainsToDetectUsingAccountAPI, addressToDetect, supportedNetworks);
-            // If API succeeds and no chains are left for RPC detection, we can return early
-            if (apiResult?.result === 'success' &&
-                chainsToDetectUsingRpc.length === 0) {
-                return;
+            // If the account API call failed, have those chains fall back to RPC detection
+            if (apiResult?.result === 'failed') {
+                __classPrivateFieldGet(this, _TokenDetectionController_instances, "m", _TokenDetectionController_addChainsToRpcDetection).call(this, chainsToDetectUsingRpc, chainsToDetectUsingAccountAPI, clientNetworks);
             }
-            // If API fails or chainsToDetectUsingRpc still has items, add chains to RPC detection
-            __classPrivateFieldGet(this, _TokenDetectionController_instances, "m", _TokenDetectionController_addChainsToRpcDetection).call(this, chainsToDetectUsingRpc, chainsToDetectUsingAccountAPI, clientNetworks);
         }
         // Proceed with RPC detection if there are chains remaining in chainsToDetectUsingRpc
         if (chainsToDetectUsingRpc.length > 0) {
@@ -446,8 +443,7 @@ async function _TokenDetectionController_addDetectedTokensViaAPI({ selectedAddre
         const tokenBalancesByChain = await __classPrivateFieldGet(this, _TokenDetectionController_accountsAPI, "f")
             .getMultiNetworksBalances(selectedAddress, chainIds, supportedNetworks)
             .catch(() => null);
-        if (!tokenBalancesByChain ||
-            Object.keys(tokenBalancesByChain).length === 0) {
+        if (tokenBalancesByChain === null) {
             return { result: 'failed' };
         }
         // Process each chain ID individually
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.mjs b/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.mjs
index f75eb5c..ebc30bb 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.mjs
+++ b/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.mjs
@@ -205,13 +205,10 @@ export class TokenDetectionController extends StaticIntervalPollingController()
         // Try detecting tokens via Account API first if conditions allow
         if (supportedNetworks && chainsToDetectUsingAccountAPI.length > 0) {
             const apiResult = await __classPrivateFieldGet(this, _TokenDetectionController_instances, "m", _TokenDetectionController_attemptAccountAPIDetection).call(this, chainsToDetectUsingAccountAPI, addressToDetect, supportedNetworks);
-            // If API succeeds and no chains are left for RPC detection, we can return early
-            if (apiResult?.result === 'success' &&
-                chainsToDetectUsingRpc.length === 0) {
-                return;
+            // If the account API call failed, have those chains fall back to RPC detection
+            if (apiResult?.result === 'failed') {
+                __classPrivateFieldGet(this, _TokenDetectionController_instances, "m", _TokenDetectionController_addChainsToRpcDetection).call(this, chainsToDetectUsingRpc, chainsToDetectUsingAccountAPI, clientNetworks);
             }
-            // If API fails or chainsToDetectUsingRpc still has items, add chains to RPC detection
-            __classPrivateFieldGet(this, _TokenDetectionController_instances, "m", _TokenDetectionController_addChainsToRpcDetection).call(this, chainsToDetectUsingRpc, chainsToDetectUsingAccountAPI, clientNetworks);
         }
         // Proceed with RPC detection if there are chains remaining in chainsToDetectUsingRpc
         if (chainsToDetectUsingRpc.length > 0) {
@@ -446,8 +443,7 @@ async function _TokenDetectionController_addDetectedTokensViaAPI({ selectedAddre
         const tokenBalancesByChain = await __classPrivateFieldGet(this, _TokenDetectionController_accountsAPI, "f")
             .getMultiNetworksBalances(selectedAddress, chainIds, supportedNetworks)
             .catch(() => null);
-        if (!tokenBalancesByChain ||
-            Object.keys(tokenBalancesByChain).length === 0) {
+        if (tokenBalancesByChain === null) {
             return { result: 'failed' };
         }
         // Process each chain ID individually
