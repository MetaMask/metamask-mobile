diff --git a/node_modules/@metamask/network-enablement-controller/dist/NetworkEnablementController.cjs b/node_modules/@metamask/network-enablement-controller/dist/NetworkEnablementController.cjs
index 1e96b7b..9ddb3ce 100644
--- a/node_modules/@metamask/network-enablement-controller/dist/NetworkEnablementController.cjs
+++ b/node_modules/@metamask/network-enablement-controller/dist/NetworkEnablementController.cjs
@@ -10,6 +10,7 @@ exports.NetworkEnablementController = void 0;
 const base_controller_1 = require("@metamask/base-controller");
 const controller_utils_1 = require("@metamask/controller-utils");
 const utils_1 = require("@metamask/utils");
+const constants_1 = require("./constants.cjs");
 const types_1 = require("./types.cjs");
 const utils_2 = require("./utils.cjs");
 const controllerName = 'NetworkEnablementController';
@@ -71,6 +72,12 @@ class NetworkEnablementController extends base_controller_1.BaseController {
         messenger.subscribe('NetworkController:networkRemoved', ({ chainId }) => {
             __classPrivateFieldGet(this, _NetworkEnablementController_instances, "m", _NetworkEnablementController_removeNetworkEntry).call(this, chainId);
         });
+        // Listen for confirmed staking transactions
+        messenger.subscribe('TransactionController:transactionSubmitted', (transactionMeta) => {
+            if (transactionMeta?.transactionMeta?.chainId) {
+                this.enableNetwork(transactionMeta.transactionMeta.chainId);
+            }
+        });
     }
     /**
      * Enables or disables a network for the user.
@@ -89,31 +96,98 @@ class NetworkEnablementController extends base_controller_1.BaseController {
      * - A CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet, 'solana:mainnet' for Solana)
      */
     enableNetwork(chainId) {
-        const { namespace, storageKey, reference } = (0, utils_2.deriveKeys)(chainId);
-        const isPopular = (0, utils_2.isPopularNetwork)(reference);
+        const { namespace, storageKey } = (0, utils_2.deriveKeys)(chainId);
         this.update((s) => {
             // if the namespace bucket does not exist, return
             // new nemespace are added only when a new network is added
             if (!s.enabledNetworkMap[namespace]) {
                 return;
             }
-            // If enabling a non-popular network, disable all networks in the same namespace
-            if (!isPopular) {
-                // disable all networks in the same namespace
-                Object.keys(s.enabledNetworkMap[namespace]).forEach((key) => {
-                    s.enabledNetworkMap[namespace][key] = false;
-                });
+            // disable all networks in the same namespace
+            Object.keys(s.enabledNetworkMap[namespace]).forEach((key) => {
+                s.enabledNetworkMap[namespace][key] = false;
+            });
+            // enable the network
+            s.enabledNetworkMap[namespace][storageKey] = true;
+        });
+    }
+    /**
+     * Enables all popular networks and Solana mainnet.
+     *
+     * This method enables all networks defined in POPULAR_NETWORKS (EVM networks)
+     * and Solana mainnet. Unlike the enableNetwork method which has exclusive behavior,
+     * this method enables multiple networks across namespaces simultaneously.
+     *
+     * Popular networks that don't exist in NetworkController or MultichainNetworkController configurations will be skipped silently.
+     */
+    enableAllPopularNetworks() {
+        this.update((s) => {
+            // Get current network configurations to check if networks exist
+            const networkControllerState = this.messagingSystem.call('NetworkController:getState');
+            const multichainState = this.messagingSystem.call('MultichainNetworkController:getState');
+            // Enable all popular EVM networks that exist in NetworkController configurations
+            constants_1.POPULAR_NETWORKS.forEach((chainId) => {
+                const { namespace, storageKey } = (0, utils_2.deriveKeys)(chainId);
+                // Check if network exists in NetworkController configurations
+                if (networkControllerState.networkConfigurationsByChainId[chainId]) {
+                    // Ensure namespace bucket exists
+                    __classPrivateFieldGet(this, _NetworkEnablementController_instances, "m", _NetworkEnablementController_ensureNamespaceBucket).call(this, s, namespace);
+                    // Enable the network
+                    s.enabledNetworkMap[namespace][storageKey] = true;
+                }
+            });
+            // Enable Solana mainnet if it exists in MultichainNetworkController configurations
+            const solanaKeys = (0, utils_2.deriveKeys)(types_1.SolScope.Mainnet);
+            if (multichainState.multichainNetworkConfigurationsByChainId[types_1.SolScope.Mainnet]) {
+                // Ensure namespace bucket exists
+                __classPrivateFieldGet(this, _NetworkEnablementController_instances, "m", _NetworkEnablementController_ensureNamespaceBucket).call(this, s, solanaKeys.namespace);
+                // Enable Solana mainnet
+                s.enabledNetworkMap[solanaKeys.namespace][solanaKeys.storageKey] = true;
             }
-            else {
-                // disable all custom networks
-                Object.keys(s.enabledNetworkMap[namespace]).forEach((key) => {
-                    const { reference: keyReference } = (0, utils_2.deriveKeys)(key);
-                    if (!(0, utils_2.isPopularNetwork)(keyReference)) {
-                        s.enabledNetworkMap[namespace][key] = false;
-                    }
-                });
+        });
+    }
+    /**
+     * Initializes the network enablement state from network controller configurations.
+     *
+     * This method reads the current network configurations from both NetworkController
+     * and MultichainNetworkController and initializes the enabled network map accordingly.
+     * It ensures proper namespace buckets exist for all configured networks and enables
+     * popular networks by default.
+     *
+     * This method should be called after the NetworkController and MultichainNetworkController
+     * have been initialized and their configurations are available.
+     */
+    init() {
+        this.update((s) => {
+            // Get network configurations from NetworkController (EVM networks)
+            const networkControllerState = this.messagingSystem.call('NetworkController:getState');
+            // Get network configurations from MultichainNetworkController (all networks)
+            const multichainState = this.messagingSystem.call('MultichainNetworkController:getState');
+            // Initialize namespace buckets for EVM networks from NetworkController
+            Object.keys(networkControllerState.networkConfigurationsByChainId).forEach((chainId) => {
+                const { namespace } = (0, utils_2.deriveKeys)(chainId);
+                __classPrivateFieldGet(this, _NetworkEnablementController_instances, "m", _NetworkEnablementController_ensureNamespaceBucket).call(this, s, namespace);
+            });
+            // Initialize namespace buckets for all networks from MultichainNetworkController
+            Object.keys(multichainState.multichainNetworkConfigurationsByChainId).forEach((chainId) => {
+                const { namespace } = (0, utils_2.deriveKeys)(chainId);
+                __classPrivateFieldGet(this, _NetworkEnablementController_instances, "m", _NetworkEnablementController_ensureNamespaceBucket).call(this, s, namespace);
+            });
+            // Enable popular networks that exist in the configurations
+            constants_1.POPULAR_NETWORKS.forEach((chainId) => {
+                const { namespace, storageKey } = (0, utils_2.deriveKeys)(chainId);
+                // Check if network exists in NetworkController configurations
+                if (s.enabledNetworkMap[namespace] &&
+                    networkControllerState.networkConfigurationsByChainId[chainId]) {
+                    s.enabledNetworkMap[namespace][storageKey] = true;
+                }
+            });
+            // Enable Solana mainnet if it exists in configurations
+            const solanaKeys = (0, utils_2.deriveKeys)(types_1.SolScope.Mainnet);
+            if (s.enabledNetworkMap[solanaKeys.namespace] &&
+                multichainState.multichainNetworkConfigurationsByChainId[types_1.SolScope.Mainnet]) {
+                s.enabledNetworkMap[solanaKeys.namespace][solanaKeys.storageKey] = true;
             }
-            s.enabledNetworkMap[namespace][storageKey] = true;
         });
     }
     /**
@@ -140,6 +214,19 @@ class NetworkEnablementController extends base_controller_1.BaseController {
             s.enabledNetworkMap[namespace][storageKey] = false;
         });
     }
+    /**
+     * Checks if a network is enabled.
+     *
+     * @param chainId - The chain ID of the network to check. Can be either:
+     * - A Hex string (e.g., '0x1' for Ethereum mainnet) for EVM networks
+     * - A CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet, 'solana:mainnet' for Solana)
+     * @returns True if the network is enabled, false otherwise
+     */
+    isNetworkEnabled(chainId) {
+        const derivedKeys = (0, utils_2.deriveKeys)(chainId);
+        const { namespace, storageKey } = derivedKeys;
+        return this.state.enabledNetworkMap[namespace]?.[storageKey] ?? false;
+    }
 }
 exports.NetworkEnablementController = NetworkEnablementController;
 _NetworkEnablementController_instances = new WeakSet(), _NetworkEnablementController_ensureNamespaceBucket = function _NetworkEnablementController_ensureNamespaceBucket(state, ns) {
diff --git a/node_modules/@metamask/network-enablement-controller/dist/NetworkEnablementController.cjs.map b/node_modules/@metamask/network-enablement-controller/dist/NetworkEnablementController.cjs.map
index d08632d..c7ca5eb 100644
--- a/node_modules/@metamask/network-enablement-controller/dist/NetworkEnablementController.cjs.map
+++ b/node_modules/@metamask/network-enablement-controller/dist/NetworkEnablementController.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"NetworkEnablementController.cjs","sourceRoot":"","sources":["../src/NetworkEnablementController.ts"],"names":[],"mappings":"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","sourcesContent":["import { BaseController } from '@metamask/base-controller';\nimport type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n  RestrictedMessenger,\n} from '@metamask/base-controller';\nimport { BuiltInNetworkName, ChainId } from '@metamask/controller-utils';\nimport type { MultichainNetworkControllerGetStateAction } from '@metamask/multichain-network-controller';\nimport type {\n  NetworkControllerGetStateAction,\n  NetworkControllerNetworkAddedEvent,\n  NetworkControllerNetworkRemovedEvent,\n  NetworkControllerStateChangeEvent,\n} from '@metamask/network-controller';\nimport type { CaipChainId, CaipNamespace, Hex } from '@metamask/utils';\nimport { KnownCaipNamespace } from '@metamask/utils';\n\nimport { SolScope } from './types';\nimport {\n  deriveKeys,\n  isOnlyNetworkEnabledInNamespace,\n  isPopularNetwork,\n} from './utils';\n\nconst controllerName = 'NetworkEnablementController';\n\n/**\n * Information about an ordered network.\n */\nexport type NetworksInfo = {\n  /**\n   * The network's chain id\n   */\n  networkId: CaipChainId;\n};\n\n/**\n * A map of enabled networks by CAIP namespace and chain ID.\n * For EIP-155 networks, the keys are Hex chain IDs.\n * For other networks, the keys are CAIP chain IDs.\n */\ntype EnabledMap = Record<CaipNamespace, Record<CaipChainId | Hex, boolean>>;\n\n// State shape for NetworkEnablementController\nexport type NetworkEnablementControllerState = {\n  enabledNetworkMap: EnabledMap;\n};\n\nexport type NetworkEnablementControllerGetStateAction =\n  ControllerGetStateAction<\n    typeof controllerName,\n    NetworkEnablementControllerState\n  >;\n\nexport type NetworkEnablementControllerSetEnabledNetworksAction = {\n  type: `${typeof controllerName}:enableNetwork`;\n  handler: NetworkEnablementController['enableNetwork'];\n};\n\nexport type NetworkEnablementControllerDisableNetworkAction = {\n  type: `${typeof controllerName}:disableNetwork`;\n  handler: NetworkEnablementController['disableNetwork'];\n};\n\n/**\n * All actions that {@link NetworkEnablementController} calls internally.\n */\nexport type AllowedActions =\n  | NetworkControllerGetStateAction\n  | MultichainNetworkControllerGetStateAction;\n\nexport type NetworkEnablementControllerActions =\n  | NetworkEnablementControllerGetStateAction\n  | NetworkEnablementControllerSetEnabledNetworksAction\n  | NetworkEnablementControllerDisableNetworkAction;\n\nexport type NetworkEnablementControllerStateChangeEvent =\n  ControllerStateChangeEvent<\n    typeof controllerName,\n    NetworkEnablementControllerState\n  >;\n\nexport type NetworkEnablementControllerEvents =\n  NetworkEnablementControllerStateChangeEvent;\n\n/**\n * All events that {@link NetworkEnablementController} subscribes to internally.\n */\nexport type AllowedEvents =\n  | NetworkControllerNetworkAddedEvent\n  | NetworkControllerNetworkRemovedEvent\n  | NetworkControllerStateChangeEvent;\n\nexport type NetworkEnablementControllerMessenger = RestrictedMessenger<\n  typeof controllerName,\n  NetworkEnablementControllerActions | AllowedActions,\n  NetworkEnablementControllerEvents | AllowedEvents,\n  AllowedActions['type'],\n  AllowedEvents['type']\n>;\n\n/**\n * Gets the default state for the NetworkEnablementController.\n *\n * @returns The default state with pre-enabled networks.\n */\nconst getDefaultNetworkEnablementControllerState =\n  (): NetworkEnablementControllerState => ({\n    enabledNetworkMap: {\n      [KnownCaipNamespace.Eip155]: {\n        [ChainId[BuiltInNetworkName.Mainnet]]: true,\n        [ChainId[BuiltInNetworkName.LineaMainnet]]: true,\n        [ChainId[BuiltInNetworkName.BaseMainnet]]: true,\n      },\n      [KnownCaipNamespace.Solana]: {\n        [SolScope.Mainnet]: true,\n      },\n    },\n  });\n\n// Metadata for the controller state\nconst metadata = {\n  enabledNetworkMap: {\n    persist: true,\n    anonymous: true,\n  },\n};\n\n/**\n * Controller responsible for managing network enablement state across different blockchain networks.\n *\n * This controller tracks which networks are enabled/disabled for the user and provides methods\n * to toggle network states. It supports both EVM (EIP-155) and non-EVM networks like Solana.\n *\n * The controller maintains a map of enabled networks organized by namespace (e.g., 'eip155', 'solana')\n * and provides methods to query and modify network enablement states.\n */\nexport class NetworkEnablementController extends BaseController<\n  typeof controllerName,\n  NetworkEnablementControllerState,\n  NetworkEnablementControllerMessenger\n> {\n  /**\n   * Creates a NetworkEnablementController instance.\n   *\n   * @param args - The arguments to this function.\n   * @param args.messenger - Messenger used to communicate with BaseV2 controller.\n   * @param args.state - Initial state to set on this controller.\n   */\n  constructor({\n    messenger,\n    state,\n  }: {\n    messenger: NetworkEnablementControllerMessenger;\n    state?: Partial<NetworkEnablementControllerState>;\n  }) {\n    super({\n      messenger,\n      metadata,\n      name: controllerName,\n      state: {\n        ...getDefaultNetworkEnablementControllerState(),\n        ...state,\n      },\n    });\n\n    messenger.subscribe('NetworkController:networkAdded', ({ chainId }) => {\n      this.#onAddNetwork(chainId);\n    });\n\n    messenger.subscribe('NetworkController:networkRemoved', ({ chainId }) => {\n      this.#removeNetworkEntry(chainId);\n    });\n  }\n\n  /**\n   * Enables or disables a network for the user.\n   *\n   * This method accepts either a Hex chain ID (for EVM networks) or a CAIP-2 chain ID\n   * (for any blockchain network). The method will automatically convert Hex chain IDs\n   * to CAIP-2 format internally. This dual parameter support allows for backward\n   * compatibility with existing EVM chain ID formats while supporting newer\n   * multi-chain standards.\n   *\n   * When enabling a non-popular network, this method will disable all other networks\n   * to ensure only one network is active at a time (exclusive mode).\n   *\n   * @param chainId - The chain ID of the network to enable or disable. Can be either:\n   * - A Hex string (e.g., '0x1' for Ethereum mainnet) for EVM networks\n   * - A CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet, 'solana:mainnet' for Solana)\n   */\n  enableNetwork(chainId: Hex | CaipChainId): void {\n    const { namespace, storageKey, reference } = deriveKeys(chainId);\n\n    const isPopular = isPopularNetwork(reference);\n\n    this.update((s) => {\n      // if the namespace bucket does not exist, return\n      // new nemespace are added only when a new network is added\n      if (!s.enabledNetworkMap[namespace]) {\n        return;\n      }\n\n      // If enabling a non-popular network, disable all networks in the same namespace\n      if (!isPopular) {\n        // disable all networks in the same namespace\n        Object.keys(s.enabledNetworkMap[namespace]).forEach((key) => {\n          s.enabledNetworkMap[namespace][key as CaipChainId | Hex] = false;\n        });\n      } else {\n        // disable all custom networks\n        Object.keys(s.enabledNetworkMap[namespace]).forEach((key) => {\n          const { reference: keyReference } = deriveKeys(key as CaipChainId);\n          if (!isPopularNetwork(keyReference)) {\n            s.enabledNetworkMap[namespace][key as CaipChainId | Hex] = false;\n          }\n        });\n      }\n      s.enabledNetworkMap[namespace][storageKey] = true;\n    });\n  }\n\n  /**\n   * Disables a network for the user.\n   *\n   * This method accepts either a Hex chain ID (for EVM networks) or a CAIP-2 chain ID\n   * (for any blockchain network). The method will automatically convert Hex chain IDs\n   * to CAIP-2 format internally.\n   *\n   * Note: This method will prevent disabling the last remaining enabled network\n   * to ensure at least one network is always available.\n   *\n   * @param chainId - The chain ID of the network to disable. Can be either:\n   * - A Hex string (e.g., '0x1' for Ethereum mainnet) for EVM networks\n   * - A CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet, 'solana:mainnet' for Solana)\n   */\n  disableNetwork(chainId: Hex | CaipChainId): void {\n    const derivedKeys = deriveKeys(chainId);\n    const { namespace, storageKey } = derivedKeys;\n\n    if (isOnlyNetworkEnabledInNamespace(this.state, derivedKeys)) {\n      throw new Error('Cannot disable the last remaining enabled network');\n    }\n\n    this.update((s) => {\n      s.enabledNetworkMap[namespace][storageKey] = false;\n    });\n  }\n\n  /**\n   * Ensures that a namespace bucket exists in the state.\n   *\n   * This method creates the namespace entry in the enabledNetworkMap if it doesn't\n   * already exist. This is used to prepare the state structure before adding\n   * network entries.\n   *\n   * @param state - The current controller state\n   * @param ns - The CAIP namespace to ensure exists\n   */\n  #ensureNamespaceBucket(\n    state: NetworkEnablementControllerState,\n    ns: CaipNamespace,\n  ) {\n    if (!state.enabledNetworkMap[ns]) {\n      state.enabledNetworkMap[ns] = {};\n    }\n  }\n\n  /**\n   * Removes a network entry from the state.\n   *\n   * This method is called when a network is removed from the system. It cleans up\n   * the network entry and ensures that at least one network remains enabled.\n   *\n   * @param chainId - The chain ID to remove (Hex or CAIP-2 format)\n   */\n  #removeNetworkEntry(chainId: Hex | CaipChainId): void {\n    const derivedKeys = deriveKeys(chainId);\n    const { namespace, storageKey } = derivedKeys;\n\n    this.update((s) => {\n      // fallback and enable ethereum mainnet\n      if (isOnlyNetworkEnabledInNamespace(this.state, derivedKeys)) {\n        s.enabledNetworkMap[namespace][ChainId[BuiltInNetworkName.Mainnet]] =\n          true;\n      }\n\n      if (namespace in s.enabledNetworkMap) {\n        delete s.enabledNetworkMap[namespace][storageKey];\n      }\n    });\n  }\n\n  /**\n   * Handles the addition of a new network to the controller.\n   *\n   * This method is called when a network is added to the system. It automatically\n   * enables the new network and implements exclusive mode for non-popular networks.\n   * If the network already exists, no changes are made.\n   *\n   * @param chainId - The chain ID of the network being added (Hex or CAIP-2 format)\n   */\n  #onAddNetwork(chainId: Hex | CaipChainId): void {\n    const { namespace, storageKey, reference } = deriveKeys(chainId);\n\n    this.update((s) => {\n      // Ensure the namespace bucket exists\n      this.#ensureNamespaceBucket(s, namespace);\n\n      // If adding a non-popular network, disable all other networks in the same namespace\n      // This implements exclusive mode where only one non-popular network can be active\n      if (!isPopularNetwork(reference)) {\n        Object.keys(s.enabledNetworkMap[namespace]).forEach((key) => {\n          s.enabledNetworkMap[namespace][key as CaipChainId | Hex] = false;\n        });\n      }\n\n      // Add the new network as enabled\n      s.enabledNetworkMap[namespace][storageKey] = true;\n    });\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"NetworkEnablementController.cjs","sourceRoot":"","sources":["../src/NetworkEnablementController.ts"],"names":[],"mappings":"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","sourcesContent":["import { BaseController } from '@metamask/base-controller';\nimport type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n  RestrictedMessenger,\n} from '@metamask/base-controller';\nimport { BuiltInNetworkName, ChainId } from '@metamask/controller-utils';\nimport type { MultichainNetworkControllerGetStateAction } from '@metamask/multichain-network-controller';\nimport type {\n  NetworkControllerGetStateAction,\n  NetworkControllerNetworkAddedEvent,\n  NetworkControllerNetworkRemovedEvent,\n  NetworkControllerStateChangeEvent,\n} from '@metamask/network-controller';\nimport type { TransactionControllerTransactionSubmittedEvent } from '@metamask/transaction-controller';\nimport type { CaipChainId, CaipNamespace, Hex } from '@metamask/utils';\nimport { KnownCaipNamespace } from '@metamask/utils';\n\nimport { POPULAR_NETWORKS } from './constants';\nimport { SolScope } from './types';\nimport {\n  deriveKeys,\n  isOnlyNetworkEnabledInNamespace,\n  isPopularNetwork,\n} from './utils';\n\nconst controllerName = 'NetworkEnablementController';\n\n/**\n * Information about an ordered network.\n */\nexport type NetworksInfo = {\n  /**\n   * The network's chain id\n   */\n  networkId: CaipChainId;\n};\n\n/**\n * A map of enabled networks by CAIP namespace and chain ID.\n * For EIP-155 networks, the keys are Hex chain IDs.\n * For other networks, the keys are CAIP chain IDs.\n */\ntype EnabledMap = Record<CaipNamespace, Record<CaipChainId | Hex, boolean>>;\n\n// State shape for NetworkEnablementController\nexport type NetworkEnablementControllerState = {\n  enabledNetworkMap: EnabledMap;\n};\n\nexport type NetworkEnablementControllerGetStateAction =\n  ControllerGetStateAction<\n    typeof controllerName,\n    NetworkEnablementControllerState\n  >;\n\nexport type NetworkEnablementControllerSetEnabledNetworksAction = {\n  type: `${typeof controllerName}:enableNetwork`;\n  handler: NetworkEnablementController['enableNetwork'];\n};\n\nexport type NetworkEnablementControllerDisableNetworkAction = {\n  type: `${typeof controllerName}:disableNetwork`;\n  handler: NetworkEnablementController['disableNetwork'];\n};\n\n/**\n * All actions that {@link NetworkEnablementController} calls internally.\n */\nexport type AllowedActions =\n  | NetworkControllerGetStateAction\n  | MultichainNetworkControllerGetStateAction;\n\nexport type NetworkEnablementControllerActions =\n  | NetworkEnablementControllerGetStateAction\n  | NetworkEnablementControllerSetEnabledNetworksAction\n  | NetworkEnablementControllerDisableNetworkAction;\n\nexport type NetworkEnablementControllerStateChangeEvent =\n  ControllerStateChangeEvent<\n    typeof controllerName,\n    NetworkEnablementControllerState\n  >;\n\nexport type NetworkEnablementControllerEvents =\n  NetworkEnablementControllerStateChangeEvent;\n\n/**\n * All events that {@link NetworkEnablementController} subscribes to internally.\n */\nexport type AllowedEvents =\n  | NetworkControllerNetworkAddedEvent\n  | NetworkControllerNetworkRemovedEvent\n  | NetworkControllerStateChangeEvent\n  | TransactionControllerTransactionSubmittedEvent;\n\nexport type NetworkEnablementControllerMessenger = RestrictedMessenger<\n  typeof controllerName,\n  NetworkEnablementControllerActions | AllowedActions,\n  NetworkEnablementControllerEvents | AllowedEvents,\n  AllowedActions['type'],\n  AllowedEvents['type']\n>;\n\n/**\n * Gets the default state for the NetworkEnablementController.\n *\n * @returns The default state with pre-enabled networks.\n */\nconst getDefaultNetworkEnablementControllerState =\n  (): NetworkEnablementControllerState => ({\n    enabledNetworkMap: {\n      [KnownCaipNamespace.Eip155]: {\n        [ChainId[BuiltInNetworkName.Mainnet]]: true,\n        [ChainId[BuiltInNetworkName.LineaMainnet]]: true,\n        [ChainId[BuiltInNetworkName.BaseMainnet]]: true,\n      },\n      [KnownCaipNamespace.Solana]: {\n        [SolScope.Mainnet]: true,\n      },\n    },\n  });\n\n// Metadata for the controller state\nconst metadata = {\n  enabledNetworkMap: {\n    persist: true,\n    anonymous: true,\n  },\n};\n\n/**\n * Controller responsible for managing network enablement state across different blockchain networks.\n *\n * This controller tracks which networks are enabled/disabled for the user and provides methods\n * to toggle network states. It supports both EVM (EIP-155) and non-EVM networks like Solana.\n *\n * The controller maintains a map of enabled networks organized by namespace (e.g., 'eip155', 'solana')\n * and provides methods to query and modify network enablement states.\n */\nexport class NetworkEnablementController extends BaseController<\n  typeof controllerName,\n  NetworkEnablementControllerState,\n  NetworkEnablementControllerMessenger\n> {\n  /**\n   * Creates a NetworkEnablementController instance.\n   *\n   * @param args - The arguments to this function.\n   * @param args.messenger - Messenger used to communicate with BaseV2 controller.\n   * @param args.state - Initial state to set on this controller.\n   */\n  constructor({\n    messenger,\n    state,\n  }: {\n    messenger: NetworkEnablementControllerMessenger;\n    state?: Partial<NetworkEnablementControllerState>;\n  }) {\n    super({\n      messenger,\n      metadata,\n      name: controllerName,\n      state: {\n        ...getDefaultNetworkEnablementControllerState(),\n        ...state,\n      },\n    });\n\n    messenger.subscribe('NetworkController:networkAdded', ({ chainId }) => {\n      this.#onAddNetwork(chainId);\n    });\n\n    messenger.subscribe('NetworkController:networkRemoved', ({ chainId }) => {\n      this.#removeNetworkEntry(chainId);\n    });\n\n    // Listen for confirmed staking transactions\n    messenger.subscribe(\n      'TransactionController:transactionSubmitted',\n      (transactionMeta) => {\n        if (transactionMeta?.transactionMeta?.chainId) {\n          this.enableNetwork(\n            transactionMeta.transactionMeta.chainId as Hex | CaipChainId,\n          );\n        }\n      },\n    );\n  }\n\n  /**\n   * Enables or disables a network for the user.\n   *\n   * This method accepts either a Hex chain ID (for EVM networks) or a CAIP-2 chain ID\n   * (for any blockchain network). The method will automatically convert Hex chain IDs\n   * to CAIP-2 format internally. This dual parameter support allows for backward\n   * compatibility with existing EVM chain ID formats while supporting newer\n   * multi-chain standards.\n   *\n   * When enabling a non-popular network, this method will disable all other networks\n   * to ensure only one network is active at a time (exclusive mode).\n   *\n   * @param chainId - The chain ID of the network to enable or disable. Can be either:\n   * - A Hex string (e.g., '0x1' for Ethereum mainnet) for EVM networks\n   * - A CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet, 'solana:mainnet' for Solana)\n   */\n  enableNetwork(chainId: Hex | CaipChainId): void {\n    const { namespace, storageKey } = deriveKeys(chainId);\n\n    this.update((s) => {\n      // if the namespace bucket does not exist, return\n      // new nemespace are added only when a new network is added\n      if (!s.enabledNetworkMap[namespace]) {\n        return;\n      }\n\n      // disable all networks in the same namespace\n      Object.keys(s.enabledNetworkMap[namespace]).forEach((key) => {\n        s.enabledNetworkMap[namespace][key as CaipChainId | Hex] = false;\n      });\n\n      // enable the network\n      s.enabledNetworkMap[namespace][storageKey] = true;\n    });\n  }\n\n  /**\n   * Enables all popular networks and Solana mainnet.\n   *\n   * This method enables all networks defined in POPULAR_NETWORKS (EVM networks)\n   * and Solana mainnet. Unlike the enableNetwork method which has exclusive behavior,\n   * this method enables multiple networks across namespaces simultaneously.\n   *\n   * Popular networks that don't exist in NetworkController or MultichainNetworkController configurations will be skipped silently.\n   */\n  enableAllPopularNetworks(): void {\n    this.update((s) => {\n      // Get current network configurations to check if networks exist\n      const networkControllerState = this.messagingSystem.call(\n        'NetworkController:getState',\n      );\n      const multichainState = this.messagingSystem.call(\n        'MultichainNetworkController:getState',\n      );\n\n      // Enable all popular EVM networks that exist in NetworkController configurations\n      POPULAR_NETWORKS.forEach((chainId) => {\n        const { namespace, storageKey } = deriveKeys(chainId as Hex);\n\n        // Check if network exists in NetworkController configurations\n        if (\n          networkControllerState.networkConfigurationsByChainId[chainId as Hex]\n        ) {\n          // Ensure namespace bucket exists\n          this.#ensureNamespaceBucket(s, namespace);\n          // Enable the network\n          s.enabledNetworkMap[namespace][storageKey] = true;\n        }\n      });\n\n      // Enable Solana mainnet if it exists in MultichainNetworkController configurations\n      const solanaKeys = deriveKeys(SolScope.Mainnet as CaipChainId);\n      if (\n        multichainState.multichainNetworkConfigurationsByChainId[\n          SolScope.Mainnet\n        ]\n      ) {\n        // Ensure namespace bucket exists\n        this.#ensureNamespaceBucket(s, solanaKeys.namespace);\n        // Enable Solana mainnet\n        s.enabledNetworkMap[solanaKeys.namespace][solanaKeys.storageKey] = true;\n      }\n    });\n  }\n\n  /**\n   * Initializes the network enablement state from network controller configurations.\n   *\n   * This method reads the current network configurations from both NetworkController\n   * and MultichainNetworkController and initializes the enabled network map accordingly.\n   * It ensures proper namespace buckets exist for all configured networks and enables\n   * popular networks by default.\n   *\n   * This method should be called after the NetworkController and MultichainNetworkController\n   * have been initialized and their configurations are available.\n   */\n  init(): void {\n    this.update((s) => {\n      // Get network configurations from NetworkController (EVM networks)\n      const networkControllerState = this.messagingSystem.call(\n        'NetworkController:getState',\n      );\n\n      // Get network configurations from MultichainNetworkController (all networks)\n      const multichainState = this.messagingSystem.call(\n        'MultichainNetworkController:getState',\n      );\n\n      // Initialize namespace buckets for EVM networks from NetworkController\n      Object.keys(\n        networkControllerState.networkConfigurationsByChainId,\n      ).forEach((chainId) => {\n        const { namespace } = deriveKeys(chainId as Hex);\n        this.#ensureNamespaceBucket(s, namespace);\n      });\n\n      // Initialize namespace buckets for all networks from MultichainNetworkController\n      Object.keys(\n        multichainState.multichainNetworkConfigurationsByChainId,\n      ).forEach((chainId) => {\n        const { namespace } = deriveKeys(chainId as CaipChainId);\n        this.#ensureNamespaceBucket(s, namespace);\n      });\n\n      // Enable popular networks that exist in the configurations\n      POPULAR_NETWORKS.forEach((chainId) => {\n        const { namespace, storageKey } = deriveKeys(chainId as Hex);\n\n        // Check if network exists in NetworkController configurations\n        if (\n          s.enabledNetworkMap[namespace] &&\n          networkControllerState.networkConfigurationsByChainId[chainId as Hex]\n        ) {\n          s.enabledNetworkMap[namespace][storageKey] = true;\n        }\n      });\n\n      // Enable Solana mainnet if it exists in configurations\n      const solanaKeys = deriveKeys(SolScope.Mainnet as CaipChainId);\n      if (\n        s.enabledNetworkMap[solanaKeys.namespace] &&\n        multichainState.multichainNetworkConfigurationsByChainId[\n          SolScope.Mainnet\n        ]\n      ) {\n        s.enabledNetworkMap[solanaKeys.namespace][solanaKeys.storageKey] = true;\n      }\n    });\n  }\n\n  /**\n   * Disables a network for the user.\n   *\n   * This method accepts either a Hex chain ID (for EVM networks) or a CAIP-2 chain ID\n   * (for any blockchain network). The method will automatically convert Hex chain IDs\n   * to CAIP-2 format internally.\n   *\n   * Note: This method will prevent disabling the last remaining enabled network\n   * to ensure at least one network is always available.\n   *\n   * @param chainId - The chain ID of the network to disable. Can be either:\n   * - A Hex string (e.g., '0x1' for Ethereum mainnet) for EVM networks\n   * - A CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet, 'solana:mainnet' for Solana)\n   */\n  disableNetwork(chainId: Hex | CaipChainId): void {\n    const derivedKeys = deriveKeys(chainId);\n    const { namespace, storageKey } = derivedKeys;\n\n    if (isOnlyNetworkEnabledInNamespace(this.state, derivedKeys)) {\n      throw new Error('Cannot disable the last remaining enabled network');\n    }\n\n    this.update((s) => {\n      s.enabledNetworkMap[namespace][storageKey] = false;\n    });\n  }\n\n  /**\n   * Checks if a network is enabled.\n   *\n   * @param chainId - The chain ID of the network to check. Can be either:\n   * - A Hex string (e.g., '0x1' for Ethereum mainnet) for EVM networks\n   * - A CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet, 'solana:mainnet' for Solana)\n   * @returns True if the network is enabled, false otherwise\n   */\n  isNetworkEnabled(chainId: Hex | CaipChainId): boolean {\n    const derivedKeys = deriveKeys(chainId);\n    const { namespace, storageKey } = derivedKeys;\n    return this.state.enabledNetworkMap[namespace]?.[storageKey] ?? false;\n  }\n\n  /**\n   * Ensures that a namespace bucket exists in the state.\n   *\n   * This method creates the namespace entry in the enabledNetworkMap if it doesn't\n   * already exist. This is used to prepare the state structure before adding\n   * network entries.\n   *\n   * @param state - The current controller state\n   * @param ns - The CAIP namespace to ensure exists\n   */\n  #ensureNamespaceBucket(\n    state: NetworkEnablementControllerState,\n    ns: CaipNamespace,\n  ) {\n    if (!state.enabledNetworkMap[ns]) {\n      state.enabledNetworkMap[ns] = {};\n    }\n  }\n\n  /**\n   * Removes a network entry from the state.\n   *\n   * This method is called when a network is removed from the system. It cleans up\n   * the network entry and ensures that at least one network remains enabled.\n   *\n   * @param chainId - The chain ID to remove (Hex or CAIP-2 format)\n   */\n  #removeNetworkEntry(chainId: Hex | CaipChainId): void {\n    const derivedKeys = deriveKeys(chainId);\n    const { namespace, storageKey } = derivedKeys;\n\n    this.update((s) => {\n      // fallback and enable ethereum mainnet\n      if (isOnlyNetworkEnabledInNamespace(this.state, derivedKeys)) {\n        s.enabledNetworkMap[namespace][ChainId[BuiltInNetworkName.Mainnet]] =\n          true;\n      }\n\n      if (namespace in s.enabledNetworkMap) {\n        delete s.enabledNetworkMap[namespace][storageKey];\n      }\n    });\n  }\n\n  /**\n   * Handles the addition of a new network to the controller.\n   *\n   * This method is called when a network is added to the system. It automatically\n   * enables the new network and implements exclusive mode for non-popular networks.\n   * If the network already exists, no changes are made.\n   *\n   * @param chainId - The chain ID of the network being added (Hex or CAIP-2 format)\n   */\n  #onAddNetwork(chainId: Hex | CaipChainId): void {\n    const { namespace, storageKey, reference } = deriveKeys(chainId);\n\n    this.update((s) => {\n      // Ensure the namespace bucket exists\n      this.#ensureNamespaceBucket(s, namespace);\n\n      // If adding a non-popular network, disable all other networks in the same namespace\n      // This implements exclusive mode where only one non-popular network can be active\n      if (!isPopularNetwork(reference)) {\n        Object.keys(s.enabledNetworkMap[namespace]).forEach((key) => {\n          s.enabledNetworkMap[namespace][key as CaipChainId | Hex] = false;\n        });\n      }\n\n      // Add the new network as enabled\n      s.enabledNetworkMap[namespace][storageKey] = true;\n    });\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/network-enablement-controller/dist/NetworkEnablementController.d.cts b/node_modules/@metamask/network-enablement-controller/dist/NetworkEnablementController.d.cts
index 7de5ce2..e3e5e03 100644
--- a/node_modules/@metamask/network-enablement-controller/dist/NetworkEnablementController.d.cts
+++ b/node_modules/@metamask/network-enablement-controller/dist/NetworkEnablementController.d.cts
@@ -2,6 +2,7 @@ import { BaseController } from "@metamask/base-controller";
 import type { ControllerGetStateAction, ControllerStateChangeEvent, RestrictedMessenger } from "@metamask/base-controller";
 import type { MultichainNetworkControllerGetStateAction } from "@metamask/multichain-network-controller";
 import type { NetworkControllerGetStateAction, NetworkControllerNetworkAddedEvent, NetworkControllerNetworkRemovedEvent, NetworkControllerStateChangeEvent } from "@metamask/network-controller";
+import type { TransactionControllerTransactionSubmittedEvent } from "@metamask/transaction-controller";
 import type { CaipChainId, CaipNamespace, Hex } from "@metamask/utils";
 declare const controllerName = "NetworkEnablementController";
 /**
@@ -41,7 +42,7 @@ export type NetworkEnablementControllerEvents = NetworkEnablementControllerState
 /**
  * All events that {@link NetworkEnablementController} subscribes to internally.
  */
-export type AllowedEvents = NetworkControllerNetworkAddedEvent | NetworkControllerNetworkRemovedEvent | NetworkControllerStateChangeEvent;
+export type AllowedEvents = NetworkControllerNetworkAddedEvent | NetworkControllerNetworkRemovedEvent | NetworkControllerStateChangeEvent | TransactionControllerTransactionSubmittedEvent;
 export type NetworkEnablementControllerMessenger = RestrictedMessenger<typeof controllerName, NetworkEnablementControllerActions | AllowedActions, NetworkEnablementControllerEvents | AllowedEvents, AllowedActions['type'], AllowedEvents['type']>;
 /**
  * Controller responsible for managing network enablement state across different blockchain networks.
@@ -82,6 +83,28 @@ export declare class NetworkEnablementController extends BaseController<typeof c
      * - A CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet, 'solana:mainnet' for Solana)
      */
     enableNetwork(chainId: Hex | CaipChainId): void;
+    /**
+     * Enables all popular networks and Solana mainnet.
+     *
+     * This method enables all networks defined in POPULAR_NETWORKS (EVM networks)
+     * and Solana mainnet. Unlike the enableNetwork method which has exclusive behavior,
+     * this method enables multiple networks across namespaces simultaneously.
+     *
+     * Popular networks that don't exist in NetworkController or MultichainNetworkController configurations will be skipped silently.
+     */
+    enableAllPopularNetworks(): void;
+    /**
+     * Initializes the network enablement state from network controller configurations.
+     *
+     * This method reads the current network configurations from both NetworkController
+     * and MultichainNetworkController and initializes the enabled network map accordingly.
+     * It ensures proper namespace buckets exist for all configured networks and enables
+     * popular networks by default.
+     *
+     * This method should be called after the NetworkController and MultichainNetworkController
+     * have been initialized and their configurations are available.
+     */
+    init(): void;
     /**
      * Disables a network for the user.
      *
@@ -97,6 +120,15 @@ export declare class NetworkEnablementController extends BaseController<typeof c
      * - A CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet, 'solana:mainnet' for Solana)
      */
     disableNetwork(chainId: Hex | CaipChainId): void;
+    /**
+     * Checks if a network is enabled.
+     *
+     * @param chainId - The chain ID of the network to check. Can be either:
+     * - A Hex string (e.g., '0x1' for Ethereum mainnet) for EVM networks
+     * - A CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet, 'solana:mainnet' for Solana)
+     * @returns True if the network is enabled, false otherwise
+     */
+    isNetworkEnabled(chainId: Hex | CaipChainId): boolean;
 }
 export {};
 //# sourceMappingURL=NetworkEnablementController.d.cts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/network-enablement-controller/dist/NetworkEnablementController.d.cts.map b/node_modules/@metamask/network-enablement-controller/dist/NetworkEnablementController.d.cts.map
index f83ae6c..2a46fd3 100644
--- a/node_modules/@metamask/network-enablement-controller/dist/NetworkEnablementController.d.cts.map
+++ b/node_modules/@metamask/network-enablement-controller/dist/NetworkEnablementController.d.cts.map
@@ -1 +1 @@
-{"version":3,"file":"NetworkEnablementController.d.cts","sourceRoot":"","sources":["../src/NetworkEnablementController.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,cAAc,EAAE,kCAAkC;AAC3D,OAAO,KAAK,EACV,wBAAwB,EACxB,0BAA0B,EAC1B,mBAAmB,EACpB,kCAAkC;AAEnC,OAAO,KAAK,EAAE,yCAAyC,EAAE,gDAAgD;AACzG,OAAO,KAAK,EACV,+BAA+B,EAC/B,kCAAkC,EAClC,oCAAoC,EACpC,iCAAiC,EAClC,qCAAqC;AACtC,OAAO,KAAK,EAAE,WAAW,EAAE,aAAa,EAAE,GAAG,EAAE,wBAAwB;AAUvE,QAAA,MAAM,cAAc,gCAAgC,CAAC;AAErD;;GAEG;AACH,MAAM,MAAM,YAAY,GAAG;IACzB;;OAEG;IACH,SAAS,EAAE,WAAW,CAAC;CACxB,CAAC;AAEF;;;;GAIG;AACH,KAAK,UAAU,GAAG,MAAM,CAAC,aAAa,EAAE,MAAM,CAAC,WAAW,GAAG,GAAG,EAAE,OAAO,CAAC,CAAC,CAAC;AAG5E,MAAM,MAAM,gCAAgC,GAAG;IAC7C,iBAAiB,EAAE,UAAU,CAAC;CAC/B,CAAC;AAEF,MAAM,MAAM,yCAAyC,GACnD,wBAAwB,CACtB,OAAO,cAAc,EACrB,gCAAgC,CACjC,CAAC;AAEJ,MAAM,MAAM,mDAAmD,GAAG;IAChE,IAAI,EAAE,GAAG,OAAO,cAAc,gBAAgB,CAAC;IAC/C,OAAO,EAAE,2BAA2B,CAAC,eAAe,CAAC,CAAC;CACvD,CAAC;AAEF,MAAM,MAAM,+CAA+C,GAAG;IAC5D,IAAI,EAAE,GAAG,OAAO,cAAc,iBAAiB,CAAC;IAChD,OAAO,EAAE,2BAA2B,CAAC,gBAAgB,CAAC,CAAC;CACxD,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,cAAc,GACtB,+BAA+B,GAC/B,yCAAyC,CAAC;AAE9C,MAAM,MAAM,kCAAkC,GAC1C,yCAAyC,GACzC,mDAAmD,GACnD,+CAA+C,CAAC;AAEpD,MAAM,MAAM,2CAA2C,GACrD,0BAA0B,CACxB,OAAO,cAAc,EACrB,gCAAgC,CACjC,CAAC;AAEJ,MAAM,MAAM,iCAAiC,GAC3C,2CAA2C,CAAC;AAE9C;;GAEG;AACH,MAAM,MAAM,aAAa,GACrB,kCAAkC,GAClC,oCAAoC,GACpC,iCAAiC,CAAC;AAEtC,MAAM,MAAM,oCAAoC,GAAG,mBAAmB,CACpE,OAAO,cAAc,EACrB,kCAAkC,GAAG,cAAc,EACnD,iCAAiC,GAAG,aAAa,EACjD,cAAc,CAAC,MAAM,CAAC,EACtB,aAAa,CAAC,MAAM,CAAC,CACtB,CAAC;AA6BF;;;;;;;;GAQG;AACH,qBAAa,2BAA4B,SAAQ,cAAc,CAC7D,OAAO,cAAc,EACrB,gCAAgC,EAChC,oCAAoC,CACrC;;IACC;;;;;;OAMG;gBACS,EACV,SAAS,EACT,KAAK,GACN,EAAE;QACD,SAAS,EAAE,oCAAoC,CAAC;QAChD,KAAK,CAAC,EAAE,OAAO,CAAC,gCAAgC,CAAC,CAAC;KACnD;IAoBD;;;;;;;;;;;;;;;OAeG;IACH,aAAa,CAAC,OAAO,EAAE,GAAG,GAAG,WAAW,GAAG,IAAI;IA+B/C;;;;;;;;;;;;;OAaG;IACH,cAAc,CAAC,OAAO,EAAE,GAAG,GAAG,WAAW,GAAG,IAAI;CAqFjD"}
\ No newline at end of file
+{"version":3,"file":"NetworkEnablementController.d.cts","sourceRoot":"","sources":["../src/NetworkEnablementController.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,cAAc,EAAE,kCAAkC;AAC3D,OAAO,KAAK,EACV,wBAAwB,EACxB,0BAA0B,EAC1B,mBAAmB,EACpB,kCAAkC;AAEnC,OAAO,KAAK,EAAE,yCAAyC,EAAE,gDAAgD;AACzG,OAAO,KAAK,EACV,+BAA+B,EAC/B,kCAAkC,EAClC,oCAAoC,EACpC,iCAAiC,EAClC,qCAAqC;AACtC,OAAO,KAAK,EAAE,8CAA8C,EAAE,yCAAyC;AACvG,OAAO,KAAK,EAAE,WAAW,EAAE,aAAa,EAAE,GAAG,EAAE,wBAAwB;AAWvE,QAAA,MAAM,cAAc,gCAAgC,CAAC;AAErD;;GAEG;AACH,MAAM,MAAM,YAAY,GAAG;IACzB;;OAEG;IACH,SAAS,EAAE,WAAW,CAAC;CACxB,CAAC;AAEF;;;;GAIG;AACH,KAAK,UAAU,GAAG,MAAM,CAAC,aAAa,EAAE,MAAM,CAAC,WAAW,GAAG,GAAG,EAAE,OAAO,CAAC,CAAC,CAAC;AAG5E,MAAM,MAAM,gCAAgC,GAAG;IAC7C,iBAAiB,EAAE,UAAU,CAAC;CAC/B,CAAC;AAEF,MAAM,MAAM,yCAAyC,GACnD,wBAAwB,CACtB,OAAO,cAAc,EACrB,gCAAgC,CACjC,CAAC;AAEJ,MAAM,MAAM,mDAAmD,GAAG;IAChE,IAAI,EAAE,GAAG,OAAO,cAAc,gBAAgB,CAAC;IAC/C,OAAO,EAAE,2BAA2B,CAAC,eAAe,CAAC,CAAC;CACvD,CAAC;AAEF,MAAM,MAAM,+CAA+C,GAAG;IAC5D,IAAI,EAAE,GAAG,OAAO,cAAc,iBAAiB,CAAC;IAChD,OAAO,EAAE,2BAA2B,CAAC,gBAAgB,CAAC,CAAC;CACxD,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,cAAc,GACtB,+BAA+B,GAC/B,yCAAyC,CAAC;AAE9C,MAAM,MAAM,kCAAkC,GAC1C,yCAAyC,GACzC,mDAAmD,GACnD,+CAA+C,CAAC;AAEpD,MAAM,MAAM,2CAA2C,GACrD,0BAA0B,CACxB,OAAO,cAAc,EACrB,gCAAgC,CACjC,CAAC;AAEJ,MAAM,MAAM,iCAAiC,GAC3C,2CAA2C,CAAC;AAE9C;;GAEG;AACH,MAAM,MAAM,aAAa,GACrB,kCAAkC,GAClC,oCAAoC,GACpC,iCAAiC,GACjC,8CAA8C,CAAC;AAEnD,MAAM,MAAM,oCAAoC,GAAG,mBAAmB,CACpE,OAAO,cAAc,EACrB,kCAAkC,GAAG,cAAc,EACnD,iCAAiC,GAAG,aAAa,EACjD,cAAc,CAAC,MAAM,CAAC,EACtB,aAAa,CAAC,MAAM,CAAC,CACtB,CAAC;AA6BF;;;;;;;;GAQG;AACH,qBAAa,2BAA4B,SAAQ,cAAc,CAC7D,OAAO,cAAc,EACrB,gCAAgC,EAChC,oCAAoC,CACrC;;IACC;;;;;;OAMG;gBACS,EACV,SAAS,EACT,KAAK,GACN,EAAE;QACD,SAAS,EAAE,oCAAoC,CAAC;QAChD,KAAK,CAAC,EAAE,OAAO,CAAC,gCAAgC,CAAC,CAAC;KACnD;IAgCD;;;;;;;;;;;;;;;OAeG;IACH,aAAa,CAAC,OAAO,EAAE,GAAG,GAAG,WAAW,GAAG,IAAI;IAoB/C;;;;;;;;OAQG;IACH,wBAAwB,IAAI,IAAI;IAwChC;;;;;;;;;;OAUG;IACH,IAAI,IAAI,IAAI;IAsDZ;;;;;;;;;;;;;OAaG;IACH,cAAc,CAAC,OAAO,EAAE,GAAG,GAAG,WAAW,GAAG,IAAI;IAahD;;;;;;;OAOG;IACH,gBAAgB,CAAC,OAAO,EAAE,GAAG,GAAG,WAAW,GAAG,OAAO;CA8EtD"}
\ No newline at end of file
diff --git a/node_modules/@metamask/network-enablement-controller/dist/NetworkEnablementController.d.mts b/node_modules/@metamask/network-enablement-controller/dist/NetworkEnablementController.d.mts
index 79851ac..0839822 100644
--- a/node_modules/@metamask/network-enablement-controller/dist/NetworkEnablementController.d.mts
+++ b/node_modules/@metamask/network-enablement-controller/dist/NetworkEnablementController.d.mts
@@ -2,6 +2,7 @@ import { BaseController } from "@metamask/base-controller";
 import type { ControllerGetStateAction, ControllerStateChangeEvent, RestrictedMessenger } from "@metamask/base-controller";
 import type { MultichainNetworkControllerGetStateAction } from "@metamask/multichain-network-controller";
 import type { NetworkControllerGetStateAction, NetworkControllerNetworkAddedEvent, NetworkControllerNetworkRemovedEvent, NetworkControllerStateChangeEvent } from "@metamask/network-controller";
+import type { TransactionControllerTransactionSubmittedEvent } from "@metamask/transaction-controller";
 import type { CaipChainId, CaipNamespace, Hex } from "@metamask/utils";
 declare const controllerName = "NetworkEnablementController";
 /**
@@ -41,7 +42,7 @@ export type NetworkEnablementControllerEvents = NetworkEnablementControllerState
 /**
  * All events that {@link NetworkEnablementController} subscribes to internally.
  */
-export type AllowedEvents = NetworkControllerNetworkAddedEvent | NetworkControllerNetworkRemovedEvent | NetworkControllerStateChangeEvent;
+export type AllowedEvents = NetworkControllerNetworkAddedEvent | NetworkControllerNetworkRemovedEvent | NetworkControllerStateChangeEvent | TransactionControllerTransactionSubmittedEvent;
 export type NetworkEnablementControllerMessenger = RestrictedMessenger<typeof controllerName, NetworkEnablementControllerActions | AllowedActions, NetworkEnablementControllerEvents | AllowedEvents, AllowedActions['type'], AllowedEvents['type']>;
 /**
  * Controller responsible for managing network enablement state across different blockchain networks.
@@ -82,6 +83,28 @@ export declare class NetworkEnablementController extends BaseController<typeof c
      * - A CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet, 'solana:mainnet' for Solana)
      */
     enableNetwork(chainId: Hex | CaipChainId): void;
+    /**
+     * Enables all popular networks and Solana mainnet.
+     *
+     * This method enables all networks defined in POPULAR_NETWORKS (EVM networks)
+     * and Solana mainnet. Unlike the enableNetwork method which has exclusive behavior,
+     * this method enables multiple networks across namespaces simultaneously.
+     *
+     * Popular networks that don't exist in NetworkController or MultichainNetworkController configurations will be skipped silently.
+     */
+    enableAllPopularNetworks(): void;
+    /**
+     * Initializes the network enablement state from network controller configurations.
+     *
+     * This method reads the current network configurations from both NetworkController
+     * and MultichainNetworkController and initializes the enabled network map accordingly.
+     * It ensures proper namespace buckets exist for all configured networks and enables
+     * popular networks by default.
+     *
+     * This method should be called after the NetworkController and MultichainNetworkController
+     * have been initialized and their configurations are available.
+     */
+    init(): void;
     /**
      * Disables a network for the user.
      *
@@ -97,6 +120,15 @@ export declare class NetworkEnablementController extends BaseController<typeof c
      * - A CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet, 'solana:mainnet' for Solana)
      */
     disableNetwork(chainId: Hex | CaipChainId): void;
+    /**
+     * Checks if a network is enabled.
+     *
+     * @param chainId - The chain ID of the network to check. Can be either:
+     * - A Hex string (e.g., '0x1' for Ethereum mainnet) for EVM networks
+     * - A CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet, 'solana:mainnet' for Solana)
+     * @returns True if the network is enabled, false otherwise
+     */
+    isNetworkEnabled(chainId: Hex | CaipChainId): boolean;
 }
 export {};
 //# sourceMappingURL=NetworkEnablementController.d.mts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/network-enablement-controller/dist/NetworkEnablementController.d.mts.map b/node_modules/@metamask/network-enablement-controller/dist/NetworkEnablementController.d.mts.map
index 422a182..c83488c 100644
--- a/node_modules/@metamask/network-enablement-controller/dist/NetworkEnablementController.d.mts.map
+++ b/node_modules/@metamask/network-enablement-controller/dist/NetworkEnablementController.d.mts.map
@@ -1 +1 @@
-{"version":3,"file":"NetworkEnablementController.d.mts","sourceRoot":"","sources":["../src/NetworkEnablementController.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,cAAc,EAAE,kCAAkC;AAC3D,OAAO,KAAK,EACV,wBAAwB,EACxB,0BAA0B,EAC1B,mBAAmB,EACpB,kCAAkC;AAEnC,OAAO,KAAK,EAAE,yCAAyC,EAAE,gDAAgD;AACzG,OAAO,KAAK,EACV,+BAA+B,EAC/B,kCAAkC,EAClC,oCAAoC,EACpC,iCAAiC,EAClC,qCAAqC;AACtC,OAAO,KAAK,EAAE,WAAW,EAAE,aAAa,EAAE,GAAG,EAAE,wBAAwB;AAUvE,QAAA,MAAM,cAAc,gCAAgC,CAAC;AAErD;;GAEG;AACH,MAAM,MAAM,YAAY,GAAG;IACzB;;OAEG;IACH,SAAS,EAAE,WAAW,CAAC;CACxB,CAAC;AAEF;;;;GAIG;AACH,KAAK,UAAU,GAAG,MAAM,CAAC,aAAa,EAAE,MAAM,CAAC,WAAW,GAAG,GAAG,EAAE,OAAO,CAAC,CAAC,CAAC;AAG5E,MAAM,MAAM,gCAAgC,GAAG;IAC7C,iBAAiB,EAAE,UAAU,CAAC;CAC/B,CAAC;AAEF,MAAM,MAAM,yCAAyC,GACnD,wBAAwB,CACtB,OAAO,cAAc,EACrB,gCAAgC,CACjC,CAAC;AAEJ,MAAM,MAAM,mDAAmD,GAAG;IAChE,IAAI,EAAE,GAAG,OAAO,cAAc,gBAAgB,CAAC;IAC/C,OAAO,EAAE,2BAA2B,CAAC,eAAe,CAAC,CAAC;CACvD,CAAC;AAEF,MAAM,MAAM,+CAA+C,GAAG;IAC5D,IAAI,EAAE,GAAG,OAAO,cAAc,iBAAiB,CAAC;IAChD,OAAO,EAAE,2BAA2B,CAAC,gBAAgB,CAAC,CAAC;CACxD,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,cAAc,GACtB,+BAA+B,GAC/B,yCAAyC,CAAC;AAE9C,MAAM,MAAM,kCAAkC,GAC1C,yCAAyC,GACzC,mDAAmD,GACnD,+CAA+C,CAAC;AAEpD,MAAM,MAAM,2CAA2C,GACrD,0BAA0B,CACxB,OAAO,cAAc,EACrB,gCAAgC,CACjC,CAAC;AAEJ,MAAM,MAAM,iCAAiC,GAC3C,2CAA2C,CAAC;AAE9C;;GAEG;AACH,MAAM,MAAM,aAAa,GACrB,kCAAkC,GAClC,oCAAoC,GACpC,iCAAiC,CAAC;AAEtC,MAAM,MAAM,oCAAoC,GAAG,mBAAmB,CACpE,OAAO,cAAc,EACrB,kCAAkC,GAAG,cAAc,EACnD,iCAAiC,GAAG,aAAa,EACjD,cAAc,CAAC,MAAM,CAAC,EACtB,aAAa,CAAC,MAAM,CAAC,CACtB,CAAC;AA6BF;;;;;;;;GAQG;AACH,qBAAa,2BAA4B,SAAQ,cAAc,CAC7D,OAAO,cAAc,EACrB,gCAAgC,EAChC,oCAAoC,CACrC;;IACC;;;;;;OAMG;gBACS,EACV,SAAS,EACT,KAAK,GACN,EAAE;QACD,SAAS,EAAE,oCAAoC,CAAC;QAChD,KAAK,CAAC,EAAE,OAAO,CAAC,gCAAgC,CAAC,CAAC;KACnD;IAoBD;;;;;;;;;;;;;;;OAeG;IACH,aAAa,CAAC,OAAO,EAAE,GAAG,GAAG,WAAW,GAAG,IAAI;IA+B/C;;;;;;;;;;;;;OAaG;IACH,cAAc,CAAC,OAAO,EAAE,GAAG,GAAG,WAAW,GAAG,IAAI;CAqFjD"}
\ No newline at end of file
+{"version":3,"file":"NetworkEnablementController.d.mts","sourceRoot":"","sources":["../src/NetworkEnablementController.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,cAAc,EAAE,kCAAkC;AAC3D,OAAO,KAAK,EACV,wBAAwB,EACxB,0BAA0B,EAC1B,mBAAmB,EACpB,kCAAkC;AAEnC,OAAO,KAAK,EAAE,yCAAyC,EAAE,gDAAgD;AACzG,OAAO,KAAK,EACV,+BAA+B,EAC/B,kCAAkC,EAClC,oCAAoC,EACpC,iCAAiC,EAClC,qCAAqC;AACtC,OAAO,KAAK,EAAE,8CAA8C,EAAE,yCAAyC;AACvG,OAAO,KAAK,EAAE,WAAW,EAAE,aAAa,EAAE,GAAG,EAAE,wBAAwB;AAWvE,QAAA,MAAM,cAAc,gCAAgC,CAAC;AAErD;;GAEG;AACH,MAAM,MAAM,YAAY,GAAG;IACzB;;OAEG;IACH,SAAS,EAAE,WAAW,CAAC;CACxB,CAAC;AAEF;;;;GAIG;AACH,KAAK,UAAU,GAAG,MAAM,CAAC,aAAa,EAAE,MAAM,CAAC,WAAW,GAAG,GAAG,EAAE,OAAO,CAAC,CAAC,CAAC;AAG5E,MAAM,MAAM,gCAAgC,GAAG;IAC7C,iBAAiB,EAAE,UAAU,CAAC;CAC/B,CAAC;AAEF,MAAM,MAAM,yCAAyC,GACnD,wBAAwB,CACtB,OAAO,cAAc,EACrB,gCAAgC,CACjC,CAAC;AAEJ,MAAM,MAAM,mDAAmD,GAAG;IAChE,IAAI,EAAE,GAAG,OAAO,cAAc,gBAAgB,CAAC;IAC/C,OAAO,EAAE,2BAA2B,CAAC,eAAe,CAAC,CAAC;CACvD,CAAC;AAEF,MAAM,MAAM,+CAA+C,GAAG;IAC5D,IAAI,EAAE,GAAG,OAAO,cAAc,iBAAiB,CAAC;IAChD,OAAO,EAAE,2BAA2B,CAAC,gBAAgB,CAAC,CAAC;CACxD,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,cAAc,GACtB,+BAA+B,GAC/B,yCAAyC,CAAC;AAE9C,MAAM,MAAM,kCAAkC,GAC1C,yCAAyC,GACzC,mDAAmD,GACnD,+CAA+C,CAAC;AAEpD,MAAM,MAAM,2CAA2C,GACrD,0BAA0B,CACxB,OAAO,cAAc,EACrB,gCAAgC,CACjC,CAAC;AAEJ,MAAM,MAAM,iCAAiC,GAC3C,2CAA2C,CAAC;AAE9C;;GAEG;AACH,MAAM,MAAM,aAAa,GACrB,kCAAkC,GAClC,oCAAoC,GACpC,iCAAiC,GACjC,8CAA8C,CAAC;AAEnD,MAAM,MAAM,oCAAoC,GAAG,mBAAmB,CACpE,OAAO,cAAc,EACrB,kCAAkC,GAAG,cAAc,EACnD,iCAAiC,GAAG,aAAa,EACjD,cAAc,CAAC,MAAM,CAAC,EACtB,aAAa,CAAC,MAAM,CAAC,CACtB,CAAC;AA6BF;;;;;;;;GAQG;AACH,qBAAa,2BAA4B,SAAQ,cAAc,CAC7D,OAAO,cAAc,EACrB,gCAAgC,EAChC,oCAAoC,CACrC;;IACC;;;;;;OAMG;gBACS,EACV,SAAS,EACT,KAAK,GACN,EAAE;QACD,SAAS,EAAE,oCAAoC,CAAC;QAChD,KAAK,CAAC,EAAE,OAAO,CAAC,gCAAgC,CAAC,CAAC;KACnD;IAgCD;;;;;;;;;;;;;;;OAeG;IACH,aAAa,CAAC,OAAO,EAAE,GAAG,GAAG,WAAW,GAAG,IAAI;IAoB/C;;;;;;;;OAQG;IACH,wBAAwB,IAAI,IAAI;IAwChC;;;;;;;;;;OAUG;IACH,IAAI,IAAI,IAAI;IAsDZ;;;;;;;;;;;;;OAaG;IACH,cAAc,CAAC,OAAO,EAAE,GAAG,GAAG,WAAW,GAAG,IAAI;IAahD;;;;;;;OAOG;IACH,gBAAgB,CAAC,OAAO,EAAE,GAAG,GAAG,WAAW,GAAG,OAAO;CA8EtD"}
\ No newline at end of file
diff --git a/node_modules/@metamask/network-enablement-controller/dist/NetworkEnablementController.mjs b/node_modules/@metamask/network-enablement-controller/dist/NetworkEnablementController.mjs
index 1085662..fec0f06 100644
--- a/node_modules/@metamask/network-enablement-controller/dist/NetworkEnablementController.mjs
+++ b/node_modules/@metamask/network-enablement-controller/dist/NetworkEnablementController.mjs
@@ -7,6 +7,7 @@ var _NetworkEnablementController_instances, _NetworkEnablementController_ensureN
 import { BaseController } from "@metamask/base-controller";
 import { BuiltInNetworkName, ChainId } from "@metamask/controller-utils";
 import { KnownCaipNamespace } from "@metamask/utils";
+import { POPULAR_NETWORKS } from "./constants.mjs";
 import { SolScope } from "./types.mjs";
 import { deriveKeys, isOnlyNetworkEnabledInNamespace, isPopularNetwork } from "./utils.mjs";
 const controllerName = 'NetworkEnablementController';
@@ -68,6 +69,12 @@ export class NetworkEnablementController extends BaseController {
         messenger.subscribe('NetworkController:networkRemoved', ({ chainId }) => {
             __classPrivateFieldGet(this, _NetworkEnablementController_instances, "m", _NetworkEnablementController_removeNetworkEntry).call(this, chainId);
         });
+        // Listen for confirmed staking transactions
+        messenger.subscribe('TransactionController:transactionSubmitted', (transactionMeta) => {
+            if (transactionMeta?.transactionMeta?.chainId) {
+                this.enableNetwork(transactionMeta.transactionMeta.chainId);
+            }
+        });
     }
     /**
      * Enables or disables a network for the user.
@@ -86,31 +93,98 @@ export class NetworkEnablementController extends BaseController {
      * - A CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet, 'solana:mainnet' for Solana)
      */
     enableNetwork(chainId) {
-        const { namespace, storageKey, reference } = deriveKeys(chainId);
-        const isPopular = isPopularNetwork(reference);
+        const { namespace, storageKey } = deriveKeys(chainId);
         this.update((s) => {
             // if the namespace bucket does not exist, return
             // new nemespace are added only when a new network is added
             if (!s.enabledNetworkMap[namespace]) {
                 return;
             }
-            // If enabling a non-popular network, disable all networks in the same namespace
-            if (!isPopular) {
-                // disable all networks in the same namespace
-                Object.keys(s.enabledNetworkMap[namespace]).forEach((key) => {
-                    s.enabledNetworkMap[namespace][key] = false;
-                });
+            // disable all networks in the same namespace
+            Object.keys(s.enabledNetworkMap[namespace]).forEach((key) => {
+                s.enabledNetworkMap[namespace][key] = false;
+            });
+            // enable the network
+            s.enabledNetworkMap[namespace][storageKey] = true;
+        });
+    }
+    /**
+     * Enables all popular networks and Solana mainnet.
+     *
+     * This method enables all networks defined in POPULAR_NETWORKS (EVM networks)
+     * and Solana mainnet. Unlike the enableNetwork method which has exclusive behavior,
+     * this method enables multiple networks across namespaces simultaneously.
+     *
+     * Popular networks that don't exist in NetworkController or MultichainNetworkController configurations will be skipped silently.
+     */
+    enableAllPopularNetworks() {
+        this.update((s) => {
+            // Get current network configurations to check if networks exist
+            const networkControllerState = this.messagingSystem.call('NetworkController:getState');
+            const multichainState = this.messagingSystem.call('MultichainNetworkController:getState');
+            // Enable all popular EVM networks that exist in NetworkController configurations
+            POPULAR_NETWORKS.forEach((chainId) => {
+                const { namespace, storageKey } = deriveKeys(chainId);
+                // Check if network exists in NetworkController configurations
+                if (networkControllerState.networkConfigurationsByChainId[chainId]) {
+                    // Ensure namespace bucket exists
+                    __classPrivateFieldGet(this, _NetworkEnablementController_instances, "m", _NetworkEnablementController_ensureNamespaceBucket).call(this, s, namespace);
+                    // Enable the network
+                    s.enabledNetworkMap[namespace][storageKey] = true;
+                }
+            });
+            // Enable Solana mainnet if it exists in MultichainNetworkController configurations
+            const solanaKeys = deriveKeys(SolScope.Mainnet);
+            if (multichainState.multichainNetworkConfigurationsByChainId[SolScope.Mainnet]) {
+                // Ensure namespace bucket exists
+                __classPrivateFieldGet(this, _NetworkEnablementController_instances, "m", _NetworkEnablementController_ensureNamespaceBucket).call(this, s, solanaKeys.namespace);
+                // Enable Solana mainnet
+                s.enabledNetworkMap[solanaKeys.namespace][solanaKeys.storageKey] = true;
             }
-            else {
-                // disable all custom networks
-                Object.keys(s.enabledNetworkMap[namespace]).forEach((key) => {
-                    const { reference: keyReference } = deriveKeys(key);
-                    if (!isPopularNetwork(keyReference)) {
-                        s.enabledNetworkMap[namespace][key] = false;
-                    }
-                });
+        });
+    }
+    /**
+     * Initializes the network enablement state from network controller configurations.
+     *
+     * This method reads the current network configurations from both NetworkController
+     * and MultichainNetworkController and initializes the enabled network map accordingly.
+     * It ensures proper namespace buckets exist for all configured networks and enables
+     * popular networks by default.
+     *
+     * This method should be called after the NetworkController and MultichainNetworkController
+     * have been initialized and their configurations are available.
+     */
+    init() {
+        this.update((s) => {
+            // Get network configurations from NetworkController (EVM networks)
+            const networkControllerState = this.messagingSystem.call('NetworkController:getState');
+            // Get network configurations from MultichainNetworkController (all networks)
+            const multichainState = this.messagingSystem.call('MultichainNetworkController:getState');
+            // Initialize namespace buckets for EVM networks from NetworkController
+            Object.keys(networkControllerState.networkConfigurationsByChainId).forEach((chainId) => {
+                const { namespace } = deriveKeys(chainId);
+                __classPrivateFieldGet(this, _NetworkEnablementController_instances, "m", _NetworkEnablementController_ensureNamespaceBucket).call(this, s, namespace);
+            });
+            // Initialize namespace buckets for all networks from MultichainNetworkController
+            Object.keys(multichainState.multichainNetworkConfigurationsByChainId).forEach((chainId) => {
+                const { namespace } = deriveKeys(chainId);
+                __classPrivateFieldGet(this, _NetworkEnablementController_instances, "m", _NetworkEnablementController_ensureNamespaceBucket).call(this, s, namespace);
+            });
+            // Enable popular networks that exist in the configurations
+            POPULAR_NETWORKS.forEach((chainId) => {
+                const { namespace, storageKey } = deriveKeys(chainId);
+                // Check if network exists in NetworkController configurations
+                if (s.enabledNetworkMap[namespace] &&
+                    networkControllerState.networkConfigurationsByChainId[chainId]) {
+                    s.enabledNetworkMap[namespace][storageKey] = true;
+                }
+            });
+            // Enable Solana mainnet if it exists in configurations
+            const solanaKeys = deriveKeys(SolScope.Mainnet);
+            if (s.enabledNetworkMap[solanaKeys.namespace] &&
+                multichainState.multichainNetworkConfigurationsByChainId[SolScope.Mainnet]) {
+                s.enabledNetworkMap[solanaKeys.namespace][solanaKeys.storageKey] = true;
             }
-            s.enabledNetworkMap[namespace][storageKey] = true;
         });
     }
     /**
@@ -137,6 +211,19 @@ export class NetworkEnablementController extends BaseController {
             s.enabledNetworkMap[namespace][storageKey] = false;
         });
     }
+    /**
+     * Checks if a network is enabled.
+     *
+     * @param chainId - The chain ID of the network to check. Can be either:
+     * - A Hex string (e.g., '0x1' for Ethereum mainnet) for EVM networks
+     * - A CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet, 'solana:mainnet' for Solana)
+     * @returns True if the network is enabled, false otherwise
+     */
+    isNetworkEnabled(chainId) {
+        const derivedKeys = deriveKeys(chainId);
+        const { namespace, storageKey } = derivedKeys;
+        return this.state.enabledNetworkMap[namespace]?.[storageKey] ?? false;
+    }
 }
 _NetworkEnablementController_instances = new WeakSet(), _NetworkEnablementController_ensureNamespaceBucket = function _NetworkEnablementController_ensureNamespaceBucket(state, ns) {
     if (!state.enabledNetworkMap[ns]) {
diff --git a/node_modules/@metamask/network-enablement-controller/dist/NetworkEnablementController.mjs.map b/node_modules/@metamask/network-enablement-controller/dist/NetworkEnablementController.mjs.map
index 229ac29..93c2568 100644
--- a/node_modules/@metamask/network-enablement-controller/dist/NetworkEnablementController.mjs.map
+++ b/node_modules/@metamask/network-enablement-controller/dist/NetworkEnablementController.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"NetworkEnablementController.mjs","sourceRoot":"","sources":["../src/NetworkEnablementController.ts"],"names":[],"mappings":"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","sourcesContent":["import { BaseController } from '@metamask/base-controller';\nimport type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n  RestrictedMessenger,\n} from '@metamask/base-controller';\nimport { BuiltInNetworkName, ChainId } from '@metamask/controller-utils';\nimport type { MultichainNetworkControllerGetStateAction } from '@metamask/multichain-network-controller';\nimport type {\n  NetworkControllerGetStateAction,\n  NetworkControllerNetworkAddedEvent,\n  NetworkControllerNetworkRemovedEvent,\n  NetworkControllerStateChangeEvent,\n} from '@metamask/network-controller';\nimport type { CaipChainId, CaipNamespace, Hex } from '@metamask/utils';\nimport { KnownCaipNamespace } from '@metamask/utils';\n\nimport { SolScope } from './types';\nimport {\n  deriveKeys,\n  isOnlyNetworkEnabledInNamespace,\n  isPopularNetwork,\n} from './utils';\n\nconst controllerName = 'NetworkEnablementController';\n\n/**\n * Information about an ordered network.\n */\nexport type NetworksInfo = {\n  /**\n   * The network's chain id\n   */\n  networkId: CaipChainId;\n};\n\n/**\n * A map of enabled networks by CAIP namespace and chain ID.\n * For EIP-155 networks, the keys are Hex chain IDs.\n * For other networks, the keys are CAIP chain IDs.\n */\ntype EnabledMap = Record<CaipNamespace, Record<CaipChainId | Hex, boolean>>;\n\n// State shape for NetworkEnablementController\nexport type NetworkEnablementControllerState = {\n  enabledNetworkMap: EnabledMap;\n};\n\nexport type NetworkEnablementControllerGetStateAction =\n  ControllerGetStateAction<\n    typeof controllerName,\n    NetworkEnablementControllerState\n  >;\n\nexport type NetworkEnablementControllerSetEnabledNetworksAction = {\n  type: `${typeof controllerName}:enableNetwork`;\n  handler: NetworkEnablementController['enableNetwork'];\n};\n\nexport type NetworkEnablementControllerDisableNetworkAction = {\n  type: `${typeof controllerName}:disableNetwork`;\n  handler: NetworkEnablementController['disableNetwork'];\n};\n\n/**\n * All actions that {@link NetworkEnablementController} calls internally.\n */\nexport type AllowedActions =\n  | NetworkControllerGetStateAction\n  | MultichainNetworkControllerGetStateAction;\n\nexport type NetworkEnablementControllerActions =\n  | NetworkEnablementControllerGetStateAction\n  | NetworkEnablementControllerSetEnabledNetworksAction\n  | NetworkEnablementControllerDisableNetworkAction;\n\nexport type NetworkEnablementControllerStateChangeEvent =\n  ControllerStateChangeEvent<\n    typeof controllerName,\n    NetworkEnablementControllerState\n  >;\n\nexport type NetworkEnablementControllerEvents =\n  NetworkEnablementControllerStateChangeEvent;\n\n/**\n * All events that {@link NetworkEnablementController} subscribes to internally.\n */\nexport type AllowedEvents =\n  | NetworkControllerNetworkAddedEvent\n  | NetworkControllerNetworkRemovedEvent\n  | NetworkControllerStateChangeEvent;\n\nexport type NetworkEnablementControllerMessenger = RestrictedMessenger<\n  typeof controllerName,\n  NetworkEnablementControllerActions | AllowedActions,\n  NetworkEnablementControllerEvents | AllowedEvents,\n  AllowedActions['type'],\n  AllowedEvents['type']\n>;\n\n/**\n * Gets the default state for the NetworkEnablementController.\n *\n * @returns The default state with pre-enabled networks.\n */\nconst getDefaultNetworkEnablementControllerState =\n  (): NetworkEnablementControllerState => ({\n    enabledNetworkMap: {\n      [KnownCaipNamespace.Eip155]: {\n        [ChainId[BuiltInNetworkName.Mainnet]]: true,\n        [ChainId[BuiltInNetworkName.LineaMainnet]]: true,\n        [ChainId[BuiltInNetworkName.BaseMainnet]]: true,\n      },\n      [KnownCaipNamespace.Solana]: {\n        [SolScope.Mainnet]: true,\n      },\n    },\n  });\n\n// Metadata for the controller state\nconst metadata = {\n  enabledNetworkMap: {\n    persist: true,\n    anonymous: true,\n  },\n};\n\n/**\n * Controller responsible for managing network enablement state across different blockchain networks.\n *\n * This controller tracks which networks are enabled/disabled for the user and provides methods\n * to toggle network states. It supports both EVM (EIP-155) and non-EVM networks like Solana.\n *\n * The controller maintains a map of enabled networks organized by namespace (e.g., 'eip155', 'solana')\n * and provides methods to query and modify network enablement states.\n */\nexport class NetworkEnablementController extends BaseController<\n  typeof controllerName,\n  NetworkEnablementControllerState,\n  NetworkEnablementControllerMessenger\n> {\n  /**\n   * Creates a NetworkEnablementController instance.\n   *\n   * @param args - The arguments to this function.\n   * @param args.messenger - Messenger used to communicate with BaseV2 controller.\n   * @param args.state - Initial state to set on this controller.\n   */\n  constructor({\n    messenger,\n    state,\n  }: {\n    messenger: NetworkEnablementControllerMessenger;\n    state?: Partial<NetworkEnablementControllerState>;\n  }) {\n    super({\n      messenger,\n      metadata,\n      name: controllerName,\n      state: {\n        ...getDefaultNetworkEnablementControllerState(),\n        ...state,\n      },\n    });\n\n    messenger.subscribe('NetworkController:networkAdded', ({ chainId }) => {\n      this.#onAddNetwork(chainId);\n    });\n\n    messenger.subscribe('NetworkController:networkRemoved', ({ chainId }) => {\n      this.#removeNetworkEntry(chainId);\n    });\n  }\n\n  /**\n   * Enables or disables a network for the user.\n   *\n   * This method accepts either a Hex chain ID (for EVM networks) or a CAIP-2 chain ID\n   * (for any blockchain network). The method will automatically convert Hex chain IDs\n   * to CAIP-2 format internally. This dual parameter support allows for backward\n   * compatibility with existing EVM chain ID formats while supporting newer\n   * multi-chain standards.\n   *\n   * When enabling a non-popular network, this method will disable all other networks\n   * to ensure only one network is active at a time (exclusive mode).\n   *\n   * @param chainId - The chain ID of the network to enable or disable. Can be either:\n   * - A Hex string (e.g., '0x1' for Ethereum mainnet) for EVM networks\n   * - A CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet, 'solana:mainnet' for Solana)\n   */\n  enableNetwork(chainId: Hex | CaipChainId): void {\n    const { namespace, storageKey, reference } = deriveKeys(chainId);\n\n    const isPopular = isPopularNetwork(reference);\n\n    this.update((s) => {\n      // if the namespace bucket does not exist, return\n      // new nemespace are added only when a new network is added\n      if (!s.enabledNetworkMap[namespace]) {\n        return;\n      }\n\n      // If enabling a non-popular network, disable all networks in the same namespace\n      if (!isPopular) {\n        // disable all networks in the same namespace\n        Object.keys(s.enabledNetworkMap[namespace]).forEach((key) => {\n          s.enabledNetworkMap[namespace][key as CaipChainId | Hex] = false;\n        });\n      } else {\n        // disable all custom networks\n        Object.keys(s.enabledNetworkMap[namespace]).forEach((key) => {\n          const { reference: keyReference } = deriveKeys(key as CaipChainId);\n          if (!isPopularNetwork(keyReference)) {\n            s.enabledNetworkMap[namespace][key as CaipChainId | Hex] = false;\n          }\n        });\n      }\n      s.enabledNetworkMap[namespace][storageKey] = true;\n    });\n  }\n\n  /**\n   * Disables a network for the user.\n   *\n   * This method accepts either a Hex chain ID (for EVM networks) or a CAIP-2 chain ID\n   * (for any blockchain network). The method will automatically convert Hex chain IDs\n   * to CAIP-2 format internally.\n   *\n   * Note: This method will prevent disabling the last remaining enabled network\n   * to ensure at least one network is always available.\n   *\n   * @param chainId - The chain ID of the network to disable. Can be either:\n   * - A Hex string (e.g., '0x1' for Ethereum mainnet) for EVM networks\n   * - A CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet, 'solana:mainnet' for Solana)\n   */\n  disableNetwork(chainId: Hex | CaipChainId): void {\n    const derivedKeys = deriveKeys(chainId);\n    const { namespace, storageKey } = derivedKeys;\n\n    if (isOnlyNetworkEnabledInNamespace(this.state, derivedKeys)) {\n      throw new Error('Cannot disable the last remaining enabled network');\n    }\n\n    this.update((s) => {\n      s.enabledNetworkMap[namespace][storageKey] = false;\n    });\n  }\n\n  /**\n   * Ensures that a namespace bucket exists in the state.\n   *\n   * This method creates the namespace entry in the enabledNetworkMap if it doesn't\n   * already exist. This is used to prepare the state structure before adding\n   * network entries.\n   *\n   * @param state - The current controller state\n   * @param ns - The CAIP namespace to ensure exists\n   */\n  #ensureNamespaceBucket(\n    state: NetworkEnablementControllerState,\n    ns: CaipNamespace,\n  ) {\n    if (!state.enabledNetworkMap[ns]) {\n      state.enabledNetworkMap[ns] = {};\n    }\n  }\n\n  /**\n   * Removes a network entry from the state.\n   *\n   * This method is called when a network is removed from the system. It cleans up\n   * the network entry and ensures that at least one network remains enabled.\n   *\n   * @param chainId - The chain ID to remove (Hex or CAIP-2 format)\n   */\n  #removeNetworkEntry(chainId: Hex | CaipChainId): void {\n    const derivedKeys = deriveKeys(chainId);\n    const { namespace, storageKey } = derivedKeys;\n\n    this.update((s) => {\n      // fallback and enable ethereum mainnet\n      if (isOnlyNetworkEnabledInNamespace(this.state, derivedKeys)) {\n        s.enabledNetworkMap[namespace][ChainId[BuiltInNetworkName.Mainnet]] =\n          true;\n      }\n\n      if (namespace in s.enabledNetworkMap) {\n        delete s.enabledNetworkMap[namespace][storageKey];\n      }\n    });\n  }\n\n  /**\n   * Handles the addition of a new network to the controller.\n   *\n   * This method is called when a network is added to the system. It automatically\n   * enables the new network and implements exclusive mode for non-popular networks.\n   * If the network already exists, no changes are made.\n   *\n   * @param chainId - The chain ID of the network being added (Hex or CAIP-2 format)\n   */\n  #onAddNetwork(chainId: Hex | CaipChainId): void {\n    const { namespace, storageKey, reference } = deriveKeys(chainId);\n\n    this.update((s) => {\n      // Ensure the namespace bucket exists\n      this.#ensureNamespaceBucket(s, namespace);\n\n      // If adding a non-popular network, disable all other networks in the same namespace\n      // This implements exclusive mode where only one non-popular network can be active\n      if (!isPopularNetwork(reference)) {\n        Object.keys(s.enabledNetworkMap[namespace]).forEach((key) => {\n          s.enabledNetworkMap[namespace][key as CaipChainId | Hex] = false;\n        });\n      }\n\n      // Add the new network as enabled\n      s.enabledNetworkMap[namespace][storageKey] = true;\n    });\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"NetworkEnablementController.mjs","sourceRoot":"","sources":["../src/NetworkEnablementController.ts"],"names":[],"mappings":"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","sourcesContent":["import { BaseController } from '@metamask/base-controller';\nimport type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n  RestrictedMessenger,\n} from '@metamask/base-controller';\nimport { BuiltInNetworkName, ChainId } from '@metamask/controller-utils';\nimport type { MultichainNetworkControllerGetStateAction } from '@metamask/multichain-network-controller';\nimport type {\n  NetworkControllerGetStateAction,\n  NetworkControllerNetworkAddedEvent,\n  NetworkControllerNetworkRemovedEvent,\n  NetworkControllerStateChangeEvent,\n} from '@metamask/network-controller';\nimport type { TransactionControllerTransactionSubmittedEvent } from '@metamask/transaction-controller';\nimport type { CaipChainId, CaipNamespace, Hex } from '@metamask/utils';\nimport { KnownCaipNamespace } from '@metamask/utils';\n\nimport { POPULAR_NETWORKS } from './constants';\nimport { SolScope } from './types';\nimport {\n  deriveKeys,\n  isOnlyNetworkEnabledInNamespace,\n  isPopularNetwork,\n} from './utils';\n\nconst controllerName = 'NetworkEnablementController';\n\n/**\n * Information about an ordered network.\n */\nexport type NetworksInfo = {\n  /**\n   * The network's chain id\n   */\n  networkId: CaipChainId;\n};\n\n/**\n * A map of enabled networks by CAIP namespace and chain ID.\n * For EIP-155 networks, the keys are Hex chain IDs.\n * For other networks, the keys are CAIP chain IDs.\n */\ntype EnabledMap = Record<CaipNamespace, Record<CaipChainId | Hex, boolean>>;\n\n// State shape for NetworkEnablementController\nexport type NetworkEnablementControllerState = {\n  enabledNetworkMap: EnabledMap;\n};\n\nexport type NetworkEnablementControllerGetStateAction =\n  ControllerGetStateAction<\n    typeof controllerName,\n    NetworkEnablementControllerState\n  >;\n\nexport type NetworkEnablementControllerSetEnabledNetworksAction = {\n  type: `${typeof controllerName}:enableNetwork`;\n  handler: NetworkEnablementController['enableNetwork'];\n};\n\nexport type NetworkEnablementControllerDisableNetworkAction = {\n  type: `${typeof controllerName}:disableNetwork`;\n  handler: NetworkEnablementController['disableNetwork'];\n};\n\n/**\n * All actions that {@link NetworkEnablementController} calls internally.\n */\nexport type AllowedActions =\n  | NetworkControllerGetStateAction\n  | MultichainNetworkControllerGetStateAction;\n\nexport type NetworkEnablementControllerActions =\n  | NetworkEnablementControllerGetStateAction\n  | NetworkEnablementControllerSetEnabledNetworksAction\n  | NetworkEnablementControllerDisableNetworkAction;\n\nexport type NetworkEnablementControllerStateChangeEvent =\n  ControllerStateChangeEvent<\n    typeof controllerName,\n    NetworkEnablementControllerState\n  >;\n\nexport type NetworkEnablementControllerEvents =\n  NetworkEnablementControllerStateChangeEvent;\n\n/**\n * All events that {@link NetworkEnablementController} subscribes to internally.\n */\nexport type AllowedEvents =\n  | NetworkControllerNetworkAddedEvent\n  | NetworkControllerNetworkRemovedEvent\n  | NetworkControllerStateChangeEvent\n  | TransactionControllerTransactionSubmittedEvent;\n\nexport type NetworkEnablementControllerMessenger = RestrictedMessenger<\n  typeof controllerName,\n  NetworkEnablementControllerActions | AllowedActions,\n  NetworkEnablementControllerEvents | AllowedEvents,\n  AllowedActions['type'],\n  AllowedEvents['type']\n>;\n\n/**\n * Gets the default state for the NetworkEnablementController.\n *\n * @returns The default state with pre-enabled networks.\n */\nconst getDefaultNetworkEnablementControllerState =\n  (): NetworkEnablementControllerState => ({\n    enabledNetworkMap: {\n      [KnownCaipNamespace.Eip155]: {\n        [ChainId[BuiltInNetworkName.Mainnet]]: true,\n        [ChainId[BuiltInNetworkName.LineaMainnet]]: true,\n        [ChainId[BuiltInNetworkName.BaseMainnet]]: true,\n      },\n      [KnownCaipNamespace.Solana]: {\n        [SolScope.Mainnet]: true,\n      },\n    },\n  });\n\n// Metadata for the controller state\nconst metadata = {\n  enabledNetworkMap: {\n    persist: true,\n    anonymous: true,\n  },\n};\n\n/**\n * Controller responsible for managing network enablement state across different blockchain networks.\n *\n * This controller tracks which networks are enabled/disabled for the user and provides methods\n * to toggle network states. It supports both EVM (EIP-155) and non-EVM networks like Solana.\n *\n * The controller maintains a map of enabled networks organized by namespace (e.g., 'eip155', 'solana')\n * and provides methods to query and modify network enablement states.\n */\nexport class NetworkEnablementController extends BaseController<\n  typeof controllerName,\n  NetworkEnablementControllerState,\n  NetworkEnablementControllerMessenger\n> {\n  /**\n   * Creates a NetworkEnablementController instance.\n   *\n   * @param args - The arguments to this function.\n   * @param args.messenger - Messenger used to communicate with BaseV2 controller.\n   * @param args.state - Initial state to set on this controller.\n   */\n  constructor({\n    messenger,\n    state,\n  }: {\n    messenger: NetworkEnablementControllerMessenger;\n    state?: Partial<NetworkEnablementControllerState>;\n  }) {\n    super({\n      messenger,\n      metadata,\n      name: controllerName,\n      state: {\n        ...getDefaultNetworkEnablementControllerState(),\n        ...state,\n      },\n    });\n\n    messenger.subscribe('NetworkController:networkAdded', ({ chainId }) => {\n      this.#onAddNetwork(chainId);\n    });\n\n    messenger.subscribe('NetworkController:networkRemoved', ({ chainId }) => {\n      this.#removeNetworkEntry(chainId);\n    });\n\n    // Listen for confirmed staking transactions\n    messenger.subscribe(\n      'TransactionController:transactionSubmitted',\n      (transactionMeta) => {\n        if (transactionMeta?.transactionMeta?.chainId) {\n          this.enableNetwork(\n            transactionMeta.transactionMeta.chainId as Hex | CaipChainId,\n          );\n        }\n      },\n    );\n  }\n\n  /**\n   * Enables or disables a network for the user.\n   *\n   * This method accepts either a Hex chain ID (for EVM networks) or a CAIP-2 chain ID\n   * (for any blockchain network). The method will automatically convert Hex chain IDs\n   * to CAIP-2 format internally. This dual parameter support allows for backward\n   * compatibility with existing EVM chain ID formats while supporting newer\n   * multi-chain standards.\n   *\n   * When enabling a non-popular network, this method will disable all other networks\n   * to ensure only one network is active at a time (exclusive mode).\n   *\n   * @param chainId - The chain ID of the network to enable or disable. Can be either:\n   * - A Hex string (e.g., '0x1' for Ethereum mainnet) for EVM networks\n   * - A CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet, 'solana:mainnet' for Solana)\n   */\n  enableNetwork(chainId: Hex | CaipChainId): void {\n    const { namespace, storageKey } = deriveKeys(chainId);\n\n    this.update((s) => {\n      // if the namespace bucket does not exist, return\n      // new nemespace are added only when a new network is added\n      if (!s.enabledNetworkMap[namespace]) {\n        return;\n      }\n\n      // disable all networks in the same namespace\n      Object.keys(s.enabledNetworkMap[namespace]).forEach((key) => {\n        s.enabledNetworkMap[namespace][key as CaipChainId | Hex] = false;\n      });\n\n      // enable the network\n      s.enabledNetworkMap[namespace][storageKey] = true;\n    });\n  }\n\n  /**\n   * Enables all popular networks and Solana mainnet.\n   *\n   * This method enables all networks defined in POPULAR_NETWORKS (EVM networks)\n   * and Solana mainnet. Unlike the enableNetwork method which has exclusive behavior,\n   * this method enables multiple networks across namespaces simultaneously.\n   *\n   * Popular networks that don't exist in NetworkController or MultichainNetworkController configurations will be skipped silently.\n   */\n  enableAllPopularNetworks(): void {\n    this.update((s) => {\n      // Get current network configurations to check if networks exist\n      const networkControllerState = this.messagingSystem.call(\n        'NetworkController:getState',\n      );\n      const multichainState = this.messagingSystem.call(\n        'MultichainNetworkController:getState',\n      );\n\n      // Enable all popular EVM networks that exist in NetworkController configurations\n      POPULAR_NETWORKS.forEach((chainId) => {\n        const { namespace, storageKey } = deriveKeys(chainId as Hex);\n\n        // Check if network exists in NetworkController configurations\n        if (\n          networkControllerState.networkConfigurationsByChainId[chainId as Hex]\n        ) {\n          // Ensure namespace bucket exists\n          this.#ensureNamespaceBucket(s, namespace);\n          // Enable the network\n          s.enabledNetworkMap[namespace][storageKey] = true;\n        }\n      });\n\n      // Enable Solana mainnet if it exists in MultichainNetworkController configurations\n      const solanaKeys = deriveKeys(SolScope.Mainnet as CaipChainId);\n      if (\n        multichainState.multichainNetworkConfigurationsByChainId[\n          SolScope.Mainnet\n        ]\n      ) {\n        // Ensure namespace bucket exists\n        this.#ensureNamespaceBucket(s, solanaKeys.namespace);\n        // Enable Solana mainnet\n        s.enabledNetworkMap[solanaKeys.namespace][solanaKeys.storageKey] = true;\n      }\n    });\n  }\n\n  /**\n   * Initializes the network enablement state from network controller configurations.\n   *\n   * This method reads the current network configurations from both NetworkController\n   * and MultichainNetworkController and initializes the enabled network map accordingly.\n   * It ensures proper namespace buckets exist for all configured networks and enables\n   * popular networks by default.\n   *\n   * This method should be called after the NetworkController and MultichainNetworkController\n   * have been initialized and their configurations are available.\n   */\n  init(): void {\n    this.update((s) => {\n      // Get network configurations from NetworkController (EVM networks)\n      const networkControllerState = this.messagingSystem.call(\n        'NetworkController:getState',\n      );\n\n      // Get network configurations from MultichainNetworkController (all networks)\n      const multichainState = this.messagingSystem.call(\n        'MultichainNetworkController:getState',\n      );\n\n      // Initialize namespace buckets for EVM networks from NetworkController\n      Object.keys(\n        networkControllerState.networkConfigurationsByChainId,\n      ).forEach((chainId) => {\n        const { namespace } = deriveKeys(chainId as Hex);\n        this.#ensureNamespaceBucket(s, namespace);\n      });\n\n      // Initialize namespace buckets for all networks from MultichainNetworkController\n      Object.keys(\n        multichainState.multichainNetworkConfigurationsByChainId,\n      ).forEach((chainId) => {\n        const { namespace } = deriveKeys(chainId as CaipChainId);\n        this.#ensureNamespaceBucket(s, namespace);\n      });\n\n      // Enable popular networks that exist in the configurations\n      POPULAR_NETWORKS.forEach((chainId) => {\n        const { namespace, storageKey } = deriveKeys(chainId as Hex);\n\n        // Check if network exists in NetworkController configurations\n        if (\n          s.enabledNetworkMap[namespace] &&\n          networkControllerState.networkConfigurationsByChainId[chainId as Hex]\n        ) {\n          s.enabledNetworkMap[namespace][storageKey] = true;\n        }\n      });\n\n      // Enable Solana mainnet if it exists in configurations\n      const solanaKeys = deriveKeys(SolScope.Mainnet as CaipChainId);\n      if (\n        s.enabledNetworkMap[solanaKeys.namespace] &&\n        multichainState.multichainNetworkConfigurationsByChainId[\n          SolScope.Mainnet\n        ]\n      ) {\n        s.enabledNetworkMap[solanaKeys.namespace][solanaKeys.storageKey] = true;\n      }\n    });\n  }\n\n  /**\n   * Disables a network for the user.\n   *\n   * This method accepts either a Hex chain ID (for EVM networks) or a CAIP-2 chain ID\n   * (for any blockchain network). The method will automatically convert Hex chain IDs\n   * to CAIP-2 format internally.\n   *\n   * Note: This method will prevent disabling the last remaining enabled network\n   * to ensure at least one network is always available.\n   *\n   * @param chainId - The chain ID of the network to disable. Can be either:\n   * - A Hex string (e.g., '0x1' for Ethereum mainnet) for EVM networks\n   * - A CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet, 'solana:mainnet' for Solana)\n   */\n  disableNetwork(chainId: Hex | CaipChainId): void {\n    const derivedKeys = deriveKeys(chainId);\n    const { namespace, storageKey } = derivedKeys;\n\n    if (isOnlyNetworkEnabledInNamespace(this.state, derivedKeys)) {\n      throw new Error('Cannot disable the last remaining enabled network');\n    }\n\n    this.update((s) => {\n      s.enabledNetworkMap[namespace][storageKey] = false;\n    });\n  }\n\n  /**\n   * Checks if a network is enabled.\n   *\n   * @param chainId - The chain ID of the network to check. Can be either:\n   * - A Hex string (e.g., '0x1' for Ethereum mainnet) for EVM networks\n   * - A CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet, 'solana:mainnet' for Solana)\n   * @returns True if the network is enabled, false otherwise\n   */\n  isNetworkEnabled(chainId: Hex | CaipChainId): boolean {\n    const derivedKeys = deriveKeys(chainId);\n    const { namespace, storageKey } = derivedKeys;\n    return this.state.enabledNetworkMap[namespace]?.[storageKey] ?? false;\n  }\n\n  /**\n   * Ensures that a namespace bucket exists in the state.\n   *\n   * This method creates the namespace entry in the enabledNetworkMap if it doesn't\n   * already exist. This is used to prepare the state structure before adding\n   * network entries.\n   *\n   * @param state - The current controller state\n   * @param ns - The CAIP namespace to ensure exists\n   */\n  #ensureNamespaceBucket(\n    state: NetworkEnablementControllerState,\n    ns: CaipNamespace,\n  ) {\n    if (!state.enabledNetworkMap[ns]) {\n      state.enabledNetworkMap[ns] = {};\n    }\n  }\n\n  /**\n   * Removes a network entry from the state.\n   *\n   * This method is called when a network is removed from the system. It cleans up\n   * the network entry and ensures that at least one network remains enabled.\n   *\n   * @param chainId - The chain ID to remove (Hex or CAIP-2 format)\n   */\n  #removeNetworkEntry(chainId: Hex | CaipChainId): void {\n    const derivedKeys = deriveKeys(chainId);\n    const { namespace, storageKey } = derivedKeys;\n\n    this.update((s) => {\n      // fallback and enable ethereum mainnet\n      if (isOnlyNetworkEnabledInNamespace(this.state, derivedKeys)) {\n        s.enabledNetworkMap[namespace][ChainId[BuiltInNetworkName.Mainnet]] =\n          true;\n      }\n\n      if (namespace in s.enabledNetworkMap) {\n        delete s.enabledNetworkMap[namespace][storageKey];\n      }\n    });\n  }\n\n  /**\n   * Handles the addition of a new network to the controller.\n   *\n   * This method is called when a network is added to the system. It automatically\n   * enables the new network and implements exclusive mode for non-popular networks.\n   * If the network already exists, no changes are made.\n   *\n   * @param chainId - The chain ID of the network being added (Hex or CAIP-2 format)\n   */\n  #onAddNetwork(chainId: Hex | CaipChainId): void {\n    const { namespace, storageKey, reference } = deriveKeys(chainId);\n\n    this.update((s) => {\n      // Ensure the namespace bucket exists\n      this.#ensureNamespaceBucket(s, namespace);\n\n      // If adding a non-popular network, disable all other networks in the same namespace\n      // This implements exclusive mode where only one non-popular network can be active\n      if (!isPopularNetwork(reference)) {\n        Object.keys(s.enabledNetworkMap[namespace]).forEach((key) => {\n          s.enabledNetworkMap[namespace][key as CaipChainId | Hex] = false;\n        });\n      }\n\n      // Add the new network as enabled\n      s.enabledNetworkMap[namespace][storageKey] = true;\n    });\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/network-enablement-controller/dist/constants.cjs b/node_modules/@metamask/network-enablement-controller/dist/constants.cjs
index d9dea09..394aca5 100644
--- a/node_modules/@metamask/network-enablement-controller/dist/constants.cjs
+++ b/node_modules/@metamask/network-enablement-controller/dist/constants.cjs
@@ -11,6 +11,8 @@ exports.POPULAR_NETWORKS = [
     '0xa',
     '0x89',
     '0x531',
-    '0x144', // zkSync Era (324)
+    '0x144',
+    '0x2a15c308d',
+    '0x3e7', // HyperEVM (999)
 ];
 //# sourceMappingURL=constants.cjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/network-enablement-controller/dist/constants.cjs.map b/node_modules/@metamask/network-enablement-controller/dist/constants.cjs.map
index 22b140c..a07b36b 100644
--- a/node_modules/@metamask/network-enablement-controller/dist/constants.cjs.map
+++ b/node_modules/@metamask/network-enablement-controller/dist/constants.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"constants.cjs","sourceRoot":"","sources":["../src/constants.ts"],"names":[],"mappings":";;;AAAa,QAAA,gBAAgB,GAAG;IAC9B,KAAK;IACL,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,MAAM;IACN,KAAK;IACL,MAAM;IACN,OAAO;IACP,OAAO,EAAE,mBAAmB;CAC7B,CAAC","sourcesContent":["export const POPULAR_NETWORKS = [\n  '0x1', // Ethereum Mainnet\n  '0xe708', // Linea (59144)\n  '0x2105', // Base (8453)\n  '0xa4b1', // Arbitrum One (42161)\n  '0xa86a', // Avalanche C-Chain (43114)\n  '0x38', // BNB Smart Chain (56)\n  '0xa', // Optimism (10)\n  '0x89', // Polygon (137)\n  '0x531', // Sei (Assuming 1329 used in EVM context)\n  '0x144', // zkSync Era (324)\n];\n"]}
\ No newline at end of file
+{"version":3,"file":"constants.cjs","sourceRoot":"","sources":["../src/constants.ts"],"names":[],"mappings":";;;AAAa,QAAA,gBAAgB,GAAG;IAC9B,KAAK;IACL,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,MAAM;IACN,KAAK;IACL,MAAM;IACN,OAAO;IACP,OAAO;IACP,aAAa;IACb,OAAO,EAAE,iBAAiB;CAC3B,CAAC","sourcesContent":["export const POPULAR_NETWORKS = [\n  '0x1', // Ethereum Mainnet\n  '0xe708', // Linea (59144)\n  '0x2105', // Base (8453)\n  '0xa4b1', // Arbitrum One (42161)\n  '0xa86a', // Avalanche C-Chain (43114)\n  '0x38', // BNB Smart Chain (56)\n  '0xa', // Optimism (10)\n  '0x89', // Polygon (137)\n  '0x531', // Sei (Assuming 1329 used in EVM context)\n  '0x144', // zkSync Era (324)\n  '0x2a15c308d', // Palm (11297108109)\n  '0x3e7', // HyperEVM (999)\n];\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/network-enablement-controller/dist/constants.d.cts.map b/node_modules/@metamask/network-enablement-controller/dist/constants.d.cts.map
index 14062cd..8f424bc 100644
--- a/node_modules/@metamask/network-enablement-controller/dist/constants.d.cts.map
+++ b/node_modules/@metamask/network-enablement-controller/dist/constants.d.cts.map
@@ -1 +1 @@
-{"version":3,"file":"constants.d.cts","sourceRoot":"","sources":["../src/constants.ts"],"names":[],"mappings":"AAAA,eAAO,MAAM,gBAAgB,UAW5B,CAAC"}
\ No newline at end of file
+{"version":3,"file":"constants.d.cts","sourceRoot":"","sources":["../src/constants.ts"],"names":[],"mappings":"AAAA,eAAO,MAAM,gBAAgB,UAa5B,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@metamask/network-enablement-controller/dist/constants.d.mts.map b/node_modules/@metamask/network-enablement-controller/dist/constants.d.mts.map
index eebd74a..727abd4 100644
--- a/node_modules/@metamask/network-enablement-controller/dist/constants.d.mts.map
+++ b/node_modules/@metamask/network-enablement-controller/dist/constants.d.mts.map
@@ -1 +1 @@
-{"version":3,"file":"constants.d.mts","sourceRoot":"","sources":["../src/constants.ts"],"names":[],"mappings":"AAAA,eAAO,MAAM,gBAAgB,UAW5B,CAAC"}
\ No newline at end of file
+{"version":3,"file":"constants.d.mts","sourceRoot":"","sources":["../src/constants.ts"],"names":[],"mappings":"AAAA,eAAO,MAAM,gBAAgB,UAa5B,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@metamask/network-enablement-controller/dist/constants.mjs b/node_modules/@metamask/network-enablement-controller/dist/constants.mjs
index 7d957dd..abc923d 100644
--- a/node_modules/@metamask/network-enablement-controller/dist/constants.mjs
+++ b/node_modules/@metamask/network-enablement-controller/dist/constants.mjs
@@ -8,6 +8,8 @@ export const POPULAR_NETWORKS = [
     '0xa',
     '0x89',
     '0x531',
-    '0x144', // zkSync Era (324)
+    '0x144',
+    '0x2a15c308d',
+    '0x3e7', // HyperEVM (999)
 ];
 //# sourceMappingURL=constants.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/network-enablement-controller/dist/constants.mjs.map b/node_modules/@metamask/network-enablement-controller/dist/constants.mjs.map
index 5ffa41f..e56d3e0 100644
--- a/node_modules/@metamask/network-enablement-controller/dist/constants.mjs.map
+++ b/node_modules/@metamask/network-enablement-controller/dist/constants.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"constants.mjs","sourceRoot":"","sources":["../src/constants.ts"],"names":[],"mappings":"AAAA,MAAM,CAAC,MAAM,gBAAgB,GAAG;IAC9B,KAAK;IACL,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,MAAM;IACN,KAAK;IACL,MAAM;IACN,OAAO;IACP,OAAO,EAAE,mBAAmB;CAC7B,CAAC","sourcesContent":["export const POPULAR_NETWORKS = [\n  '0x1', // Ethereum Mainnet\n  '0xe708', // Linea (59144)\n  '0x2105', // Base (8453)\n  '0xa4b1', // Arbitrum One (42161)\n  '0xa86a', // Avalanche C-Chain (43114)\n  '0x38', // BNB Smart Chain (56)\n  '0xa', // Optimism (10)\n  '0x89', // Polygon (137)\n  '0x531', // Sei (Assuming 1329 used in EVM context)\n  '0x144', // zkSync Era (324)\n];\n"]}
\ No newline at end of file
+{"version":3,"file":"constants.mjs","sourceRoot":"","sources":["../src/constants.ts"],"names":[],"mappings":"AAAA,MAAM,CAAC,MAAM,gBAAgB,GAAG;IAC9B,KAAK;IACL,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,MAAM;IACN,KAAK;IACL,MAAM;IACN,OAAO;IACP,OAAO;IACP,aAAa;IACb,OAAO,EAAE,iBAAiB;CAC3B,CAAC","sourcesContent":["export const POPULAR_NETWORKS = [\n  '0x1', // Ethereum Mainnet\n  '0xe708', // Linea (59144)\n  '0x2105', // Base (8453)\n  '0xa4b1', // Arbitrum One (42161)\n  '0xa86a', // Avalanche C-Chain (43114)\n  '0x38', // BNB Smart Chain (56)\n  '0xa', // Optimism (10)\n  '0x89', // Polygon (137)\n  '0x531', // Sei (Assuming 1329 used in EVM context)\n  '0x144', // zkSync Era (324)\n  '0x2a15c308d', // Palm (11297108109)\n  '0x3e7', // HyperEVM (999)\n];\n"]}
\ No newline at end of file
