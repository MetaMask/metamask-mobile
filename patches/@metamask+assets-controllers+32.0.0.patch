diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-4AC3X2U5.js b/node_modules/@metamask/assets-controllers/dist/chunk-4AC3X2U5.js
index bb55790..c7e7f99 100644
--- a/node_modules/@metamask/assets-controllers/dist/chunk-4AC3X2U5.js
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-4AC3X2U5.js
@@ -187,6 +187,18 @@ var TokensController = class extends _basecontroller.BaseController {
       }
     );
   }
+  /**
+  * THIS FUNCTIONS IS CURRENTLY PATCHED AND STILL NEEDS TO BE IMPLEMENTED ON THE CORE REPO
+  * Resets to the default state
+  */
+  reset() {
+    this.update((state) => {
+      state.allTokens = {};
+      state.allIgnoredTokens = {};
+      state.ignoredTokens = [];
+      state.tokens = [];
+    });
+  }
   /**
    * Adds a token to the stored token list.
    *
@@ -605,9 +617,13 @@ _selectedAddress = new WeakMap();
 _provider = new WeakMap();
 _abortController = new WeakMap();
 _onNetworkDidChange = new WeakSet();
-onNetworkDidChange_fn = function({ providerConfig }) {
+onNetworkDidChange_fn = function({ selectedNetworkClientId }) {
   const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
-  const { chainId } = providerConfig;
+  const selectedNetworkClient = this.messagingSystem.call(
+      'NetworkController:getNetworkClientById',
+       selectedNetworkClientId,
+  );
+  const { chainId } = selectedNetworkClient.configuration;
   _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _abortController).abort();
   _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _abortController, new AbortController());
   _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _chainId, chainId);
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-CGLUTXI7.js b/node_modules/@metamask/assets-controllers/dist/chunk-CGLUTXI7.js
index 7cc44fa..7a1de65 100644
--- a/node_modules/@metamask/assets-controllers/dist/chunk-CGLUTXI7.js
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-CGLUTXI7.js
@@ -44,7 +44,7 @@ var getDefaultNftControllerState = () => ({
   allNfts: {},
   ignoredNfts: []
 });
-var _mutex, _selectedAddress, _chainId, _ipfsGateway, _openSeaEnabled, _useIpfsSubdomains, _isIpfsGatewayEnabled, _getERC721AssetName, _getERC721AssetSymbol, _getERC721TokenURI, _getERC721OwnerOf, _getERC1155BalanceOf, _getERC1155TokenURI, _onNftAdded, _onNetworkControllerNetworkDidChange, onNetworkControllerNetworkDidChange_fn, _onPreferencesControllerStateChange, onPreferencesControllerStateChange_fn, _updateNestedNftState, updateNestedNftState_fn, _getNftInformationFromApi, getNftInformationFromApi_fn, _getNftInformationFromTokenURI, getNftInformationFromTokenURI_fn, _getNftURIAndStandard, getNftURIAndStandard_fn, _getNftInformation, getNftInformation_fn, _getNftContractInformationFromContract, getNftContractInformationFromContract_fn, _getNftContractInformation, getNftContractInformation_fn, _addIndividualNft, addIndividualNft_fn, _addNftContract, addNftContract_fn, _removeAndIgnoreIndividualNft, removeAndIgnoreIndividualNft_fn, _removeIndividualNft, removeIndividualNft_fn, _removeNftContract, removeNftContract_fn, _validateWatchNft, validateWatchNft_fn, _getCorrectChainId, getCorrectChainId_fn;
+var _mutex, _selectedAddress, _chainId, _ipfsGateway, _displayNftMedia, _useIpfsSubdomains, _isIpfsGatewayEnabled, _getERC721AssetName, _getERC721AssetSymbol, _getERC721TokenURI, _getERC721OwnerOf, _getERC1155BalanceOf, _getERC1155TokenURI, _onNftAdded, _onNetworkControllerNetworkDidChange, onNetworkControllerNetworkDidChange_fn, _onPreferencesControllerStateChange, onPreferencesControllerStateChange_fn, _updateNestedNftState, updateNestedNftState_fn, _getNftInformationFromApi, getNftInformationFromApi_fn, _getNftInformationFromTokenURI, getNftInformationFromTokenURI_fn, _getNftURIAndStandard, getNftURIAndStandard_fn, _getNftInformation, getNftInformation_fn, _getNftContractInformationFromContract, getNftContractInformationFromContract_fn, _getNftContractInformation, getNftContractInformation_fn, _addIndividualNft, addIndividualNft_fn, _addNftContract, addNftContract_fn, _removeAndIgnoreIndividualNft, removeAndIgnoreIndividualNft_fn, _removeIndividualNft, removeIndividualNft_fn, _removeNftContract, removeNftContract_fn, _validateWatchNft, validateWatchNft_fn, _getCorrectChainId, getCorrectChainId_fn;
 var NftController = class extends _basecontroller.BaseController {
   /**
    * Creates an NftController instance.
@@ -53,7 +53,7 @@ var NftController = class extends _basecontroller.BaseController {
    * @param options.chainId - The chain ID of the current network.
    * @param options.selectedAddress - The currently selected address.
    * @param options.ipfsGateway - The configured IPFS gateway.
-   * @param options.openSeaEnabled - Controls whether the OpenSea API is used.
+   * @param options.displayNftMedia - Controls whether the OpenSea API is used.
    * @param options.useIpfsSubdomains - Controls whether IPFS subdomains are used.
    * @param options.isIpfsGatewayEnabled - Controls whether IPFS is enabled or not.
    * @param options.getERC721AssetName - Gets the name of the asset at the given address.
@@ -71,7 +71,7 @@ var NftController = class extends _basecontroller.BaseController {
     chainId: initialChainId,
     selectedAddress = "",
     ipfsGateway = _controllerutils.IPFS_DEFAULT_GATEWAY_URL,
-    openSeaEnabled = false,
+    displayNftMedia = false,
     useIpfsSubdomains = true,
     isIpfsGatewayEnabled = true,
     getERC721AssetName,
@@ -104,7 +104,7 @@ var NftController = class extends _basecontroller.BaseController {
      * @param preferencesState - The new state of the preference controller.
      * @param preferencesState.selectedAddress - The current selected address.
      * @param preferencesState.ipfsGateway - The configured IPFS gateway.
-     * @param preferencesState.openSeaEnabled - Controls whether the OpenSea API is used.
+     * @param preferencesState.displayNftMedia - Controls whether the OpenSea API is used.
      * @param preferencesState.isIpfsGatewayEnabled - Controls whether IPFS is enabled or not.
      */
     _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _onPreferencesControllerStateChange);
@@ -233,7 +233,7 @@ var NftController = class extends _basecontroller.BaseController {
     _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _selectedAddress, void 0);
     _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _chainId, void 0);
     _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _ipfsGateway, void 0);
-    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _openSeaEnabled, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _displayNftMedia, void 0);
     _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _useIpfsSubdomains, void 0);
     _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _isIpfsGatewayEnabled, void 0);
     _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getERC721AssetName, void 0);
@@ -246,7 +246,7 @@ var NftController = class extends _basecontroller.BaseController {
     _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _selectedAddress, selectedAddress);
     _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _chainId, initialChainId);
     _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _ipfsGateway, ipfsGateway);
-    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _openSeaEnabled, openSeaEnabled);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _displayNftMedia, displayNftMedia);
     _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _useIpfsSubdomains, useIpfsSubdomains);
     _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _isIpfsGatewayEnabled, isIpfsGatewayEnabled);
     _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _getERC721AssetName, getERC721AssetName);
@@ -268,6 +268,17 @@ var NftController = class extends _basecontroller.BaseController {
   getNftApi() {
     return `${_controllerutils.NFT_API_BASE_URL}/tokens`;
   }
+  /**
+  * THIS FUNCTIONS IS CURRENTLY PATCHED AND STILL NEEDS TO BE IMPLEMENTED ON THE CORE REPO
+  * Resets to the default state
+  */
+  reset() {
+    this.update((state) => {
+      state.allNftContracts = {};
+      state.allNfts = {};
+      state.ignoredNfts = [];
+    });
+  }
   /**
    * Adds a new suggestedAsset to state. Parameters will be validated according to
    * asset type being watched. A `<suggestedNftMeta.id>:pending` hub event will be emitted once added.
@@ -771,7 +782,7 @@ _mutex = new WeakMap();
 _selectedAddress = new WeakMap();
 _chainId = new WeakMap();
 _ipfsGateway = new WeakMap();
-_openSeaEnabled = new WeakMap();
+_displayNftMedia = new WeakMap();
 _useIpfsSubdomains = new WeakMap();
 _isIpfsGatewayEnabled = new WeakMap();
 _getERC721AssetName = new WeakMap();
@@ -797,14 +808,14 @@ _onPreferencesControllerStateChange = new WeakSet();
 onPreferencesControllerStateChange_fn = async function({
   selectedAddress,
   ipfsGateway,
-  openSeaEnabled,
+  displayNftMedia,
   isIpfsGatewayEnabled
 }) {
   _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _selectedAddress, selectedAddress);
   _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _ipfsGateway, ipfsGateway);
-  _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _openSeaEnabled, openSeaEnabled);
+  _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _displayNftMedia, displayNftMedia);
   _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _isIpfsGatewayEnabled, isIpfsGatewayEnabled);
-  const needsUpdateNftMetadata = isIpfsGatewayEnabled && ipfsGateway !== "" || openSeaEnabled;
+  const needsUpdateNftMetadata = isIpfsGatewayEnabled && ipfsGateway !== "" || displayNftMedia;
   if (needsUpdateNftMetadata) {
     const nfts = this.state.allNfts[selectedAddress]?.[_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _chainId)] ?? [];
     const nftsToUpdate = nfts.filter(
@@ -818,6 +829,7 @@ onPreferencesControllerStateChange_fn = async function({
     }
   }
 };
+
 _updateNestedNftState = new WeakSet();
 updateNestedNftState_fn = function(newCollection, baseStateKey, { userAddress, chainId }) {
   this.update((state) => {
@@ -850,12 +862,25 @@ getNftInformationFromApi_fn = async function(contractAddress, tokenId) {
       }
     }
   });
+  const getCollectionParams = new URLSearchParams({
+    chainId: "1",
+    id: `${nftInformation?.tokens[0]?.token?.collection?.id}`
+  }).toString();
+  const collectionInformation = await _controllerutils.fetchWithErrorHandling.call(void 0, {
+      url: `${_controllerutils.NFT_API_BASE_URL}/collections?${getCollectionParams}`,
+      options: {
+        headers: {
+        Version: '1'
+      }
+    }
+  });
   if (!nftInformation?.tokens?.[0]?.token) {
     return {
       name: null,
       description: null,
       image: null,
-      standard: null
+      standard: null,
+      error: 'Opensea import error',
     };
   }
   const {
@@ -887,7 +912,16 @@ getNftInformationFromApi_fn = async function(contractAddress, tokenId) {
     },
     rarityRank && { rarityRank },
     rarity && { rarity },
-    collection && { collection }
+    (collection || collectionInformation) && {
+          collection: {
+            ...collection || {},
+            creator: collection?.creator || collectionInformation?.collections[0].creator,
+            openseaVerificationStatus: collectionInformation?.collections[0].openseaVerificationStatus,
+            contractDeployedAt: collectionInformation?.collections[0].contractDeployedAt,
+            ownerCount: collectionInformation?.collections[0].ownerCount,
+            topBid: collectionInformation?.collections[0].topBid
+          }
+      }
   );
   return nftMetadata;
 };
@@ -904,10 +938,11 @@ getNftInformationFromTokenURI_fn = async function(contractAddress, tokenId, netw
       description: null,
       standard: standard || null,
       favorite: false,
-      tokenURI: tokenURI ?? null
+      tokenURI: tokenURI ?? null,
+      error: 'URI import error',
     };
   }
-  const isDisplayNFTMediaToggleEnabled = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _openSeaEnabled);
+  const isDisplayNFTMediaToggleEnabled = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _displayNftMedia);
   if (!hasIpfsTokenURI && !isDisplayNFTMediaToggleEnabled) {
     return {
       image: null,
@@ -925,6 +960,16 @@ getNftInformationFromTokenURI_fn = async function(contractAddress, tokenId, netw
       _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _useIpfsSubdomains)
     );
   }
+  if (tokenURI.startsWith("data:image/")) {
+    return {
+      image: tokenURI,
+      name: null,
+      description: null,
+      standard: standard || null,
+      favorite: false,
+      tokenURI: tokenURI ?? null
+    };
+  }
   try {
     const object = await _controllerutils.handleFetch.call(void 0, tokenURI);
     const image = Object.prototype.hasOwnProperty.call(object, "image") ? "image" : (
@@ -946,7 +991,8 @@ getNftInformationFromTokenURI_fn = async function(contractAddress, tokenId, netw
       description: null,
       standard: standard || null,
       favorite: false,
-      tokenURI: tokenURI ?? null
+      tokenURI: tokenURI ?? null,
+      error: 'URI import error',
     };
   }
 };
@@ -977,15 +1023,27 @@ getNftInformation_fn = async function(contractAddress, tokenId, networkClientId)
     _controllerutils.safelyExecute.call(void 0, 
       () => _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getNftInformationFromTokenURI, getNftInformationFromTokenURI_fn).call(this, contractAddress, tokenId, networkClientId)
     ),
-    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _openSeaEnabled) && chainId === "0x1" ? _controllerutils.safelyExecute.call(void 0, 
+    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _displayNftMedia) && chainId === "0x1" ? _controllerutils.safelyExecute.call(void 0, 
       () => _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getNftInformationFromApi, getNftInformationFromApi_fn).call(this, contractAddress, tokenId)
     ) : void 0
   ]);
+
+  if (blockchainMetadata?.error && nftApiMetadata?.error) {
+        return {
+          image: null,
+          name: null,
+          description: null,
+          standard: blockchainMetadata.standard ?? null,
+          favorite: false,
+          tokenURI: blockchainMetadata.tokenURI ?? null,
+          error: 'Both import failed',
+        };
+  }
   return {
     ...nftApiMetadata,
     name: blockchainMetadata?.name ?? nftApiMetadata?.name ?? null,
     description: blockchainMetadata?.description ?? nftApiMetadata?.description ?? null,
-    image: blockchainMetadata?.image ?? nftApiMetadata?.image ?? null,
+    image: nftApiMetadata?.image ?? blockchainMetadata?.image ?? null,
     standard: blockchainMetadata?.standard ?? nftApiMetadata?.standard ?? null,
     tokenURI: blockchainMetadata?.tokenURI ?? null
   };
@@ -1048,7 +1106,8 @@ addIndividualNft_fn = async function(tokenAddress, tokenId, nftMetadata, nftCont
         nftMetadata,
         existingEntry
       );
-      if (!differentMetadata && existingEntry.isCurrentlyOwned) {
+      const hasNewFields = _chunkNEXY7SE2js.hasNewCollectionFields(nftMetadata, existingEntry);
+      if (!differentMetadata && existingEntry.isCurrentlyOwned && !hasNewFields) {
         return;
       }
       const indexToUpdate = nfts.findIndex(
@@ -1080,7 +1139,8 @@ addIndividualNft_fn = async function(tokenAddress, tokenId, nftMetadata, nftCont
         symbol: nftContract.symbol,
         tokenId: tokenId.toString(),
         standard: nftMetadata.standard,
-        source
+        source,
+        tokenURI: nftMetadata.tokenURI,
       });
     }
   } finally {
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-ELSMS5S7.js b/node_modules/@metamask/assets-controllers/dist/chunk-ELSMS5S7.js
index 45254ad..f3c6204 100644
--- a/node_modules/@metamask/assets-controllers/dist/chunk-ELSMS5S7.js
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-ELSMS5S7.js
@@ -87,6 +87,7 @@ var CurrencyRateController = class extends _pollingcontroller.StaticIntervalPoll
     const nativeCurrencyForExchangeRate = Object.values(
       _controllerutils.TESTNET_TICKER_SYMBOLS
     ).includes(nativeCurrency) ? _controllerutils.FALL_BACK_VS_CURRENCY : nativeCurrency;
+    let shouldUpdateState = true;
     try {
       if (currentCurrency && nativeCurrency && // if either currency is an empty string we can skip the comparison
       // because it will result in an error from the api and ultimately
@@ -103,23 +104,27 @@ var CurrencyRateController = class extends _pollingcontroller.StaticIntervalPoll
       }
     } catch (error) {
       if (!(error instanceof Error && error.message.includes("market does not exist for this coin pair"))) {
+        // Don't update state on transient / unexpected errors
+        shouldUpdateState = false;
         throw error;
       }
     } finally {
       try {
-        this.update(() => {
-          return {
-            currencyRates: {
-              ...currencyRates,
-              [nativeCurrency]: {
-                conversionDate,
-                conversionRate,
-                usdConversionRate
-              }
-            },
-            currentCurrency
-          };
-        });
+        if(shouldUpdateState) {
+          this.update(() => {
+            return {
+              currencyRates: {
+                ...currencyRates,
+                [nativeCurrency]: {
+                  conversionDate,
+                  conversionRate,
+                  usdConversionRate
+                }
+              },
+              currentCurrency
+            };
+          });
+        }
       } finally {
         releaseLock();
       }
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-GU53EI7A.js b/node_modules/@metamask/assets-controllers/dist/chunk-GU53EI7A.js
index 33b048f..5867375 100644
--- a/node_modules/@metamask/assets-controllers/dist/chunk-GU53EI7A.js
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-GU53EI7A.js
@@ -61,7 +61,7 @@ var AccountTrackerController = class extends _pollingcontroller.StaticIntervalPo
         this.syncAccounts(chainId);
         const { accounts, accountsByChainId } = this.state;
         const isMultiAccountBalancesEnabled = this.getMultiAccountBalancesEnabled();
-        const accountsToUpdate = isMultiAccountBalancesEnabled ? Object.keys(accounts) : [this.getSelectedAddress()];
+        const accountsToUpdate = isMultiAccountBalancesEnabled ? Object.keys(accounts) : [_controllerutils.toChecksumHexAddress.call(void 0, this.getSelectedAddress())];
         const accountsForChain = { ...accountsByChainId[chainId] };
         for (const address of accountsToUpdate) {
           const balance = await this.getBalanceFromChain(address, ethQuery);
@@ -80,9 +80,8 @@ var AccountTrackerController = class extends _pollingcontroller.StaticIntervalPo
             [chainId]: accountsForChain
           }
         });
-      } catch (err) {
+      } finally {
         releaseLock();
-        throw err;
       }
     };
     this.defaultConfig = {
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-HDI4L2DD.js b/node_modules/@metamask/assets-controllers/dist/chunk-HDI4L2DD.js
index 76e3362..8d04025 100644
--- a/node_modules/@metamask/assets-controllers/dist/chunk-HDI4L2DD.js
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-HDI4L2DD.js
@@ -3,7 +3,7 @@
 var _chunkNEXY7SE2js = require('./chunk-NEXY7SE2.js');
 
 
-
+const lodash_1 = require("lodash");
 
 
 var _chunkZ4BLTVTBjs = require('./chunk-Z4BLTVTB.js');
@@ -19,6 +19,15 @@ function isEqualCaseInsensitive(value1, value2) {
   }
   return value1.toLowerCase() === value2.toLowerCase();
 }
+
+function mapChainIdWithTokenListMap(tokensChainsCache) {
+  return (0, lodash_1.mapValues)(tokensChainsCache, (value) => {
+      if ((0, lodash_1.isObject)(value) && 'data' in value) {
+          return (0, lodash_1.get)(value, ['data']);
+      }
+      return value;
+  });
+}
 var STATIC_MAINNET_TOKEN_LIST = Object.entries(
   _contractmetadata2.default
 ).reduce((acc, [base, contract]) => {
@@ -34,7 +43,7 @@ var STATIC_MAINNET_TOKEN_LIST = Object.entries(
   };
 }, {});
 var controllerName = "TokenDetectionController";
-var _intervalId, _selectedAddress, _networkClientId, _tokenList, _disabled, _isUnlocked, _isDetectionEnabledFromPreferences, _isDetectionEnabledForNetwork, _getBalancesInSingleCall, _trackMetaMetricsEvent, _registerEventListeners, registerEventListeners_fn, _stopPolling, stopPolling_fn, _startPolling, startPolling_fn, _getCorrectChainIdAndNetworkClientId, getCorrectChainIdAndNetworkClientId_fn, _restartTokenDetection, restartTokenDetection_fn, _getSlicesOfTokensToDetect, getSlicesOfTokensToDetect_fn, _addDetectedTokens, addDetectedTokens_fn;
+var _intervalId, _selectedAddress, _networkClientId, _tokensChainsCache, _disabled, _isUnlocked, _isDetectionEnabledFromPreferences, _isDetectionEnabledForNetwork, _getBalancesInSingleCall, _trackMetaMetricsEvent, _registerEventListeners, registerEventListeners_fn, _stopPolling, stopPolling_fn, _startPolling, startPolling_fn, _getCorrectChainIdAndNetworkClientId, getCorrectChainIdAndNetworkClientId_fn, _restartTokenDetection, restartTokenDetection_fn, _getSlicesOfTokensToDetect, getSlicesOfTokensToDetect_fn, _addDetectedTokens, addDetectedTokens_fn, _compareTokensChainsCache, compareTokensChainsCache_fn, _getConvertedStaticMainnetTokenList, getConvertedStaticMainnetTokenList_fn;
 var TokenDetectionController = class extends _pollingcontroller.StaticIntervalPollingController {
   /**
    * Creates a TokenDetectionController instance.
@@ -71,6 +80,8 @@ var TokenDetectionController = class extends _pollingcontroller.StaticIntervalPo
      */
     _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _startPolling);
     _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getCorrectChainIdAndNetworkClientId);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _compareTokensChainsCache);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getConvertedStaticMainnetTokenList);
     /**
      * Restart token detection polling period and call detectNewTokens
      * in case of address change or user session initialization.
@@ -85,7 +96,7 @@ var TokenDetectionController = class extends _pollingcontroller.StaticIntervalPo
     _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _intervalId, void 0);
     _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _selectedAddress, void 0);
     _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _networkClientId, void 0);
-    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _tokenList, {});
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _tokensChainsCache, {});
     _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _disabled, void 0);
     _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _isUnlocked, void 0);
     _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _isDetectionEnabledFromPreferences, void 0);
@@ -97,6 +108,8 @@ var TokenDetectionController = class extends _pollingcontroller.StaticIntervalPo
     _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _selectedAddress, selectedAddress ?? this.messagingSystem.call("AccountsController:getSelectedAccount").address);
     const { chainId, networkClientId } = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getCorrectChainIdAndNetworkClientId, getCorrectChainIdAndNetworkClientId_fn).call(this);
     _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _networkClientId, networkClientId);
+    const { tokensChainsCache } = this.messagingSystem.call("TokenListController:getState");
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _tokensChainsCache, tokensChainsCache);
     const { useTokenDetection: defaultUseTokenDetection } = this.messagingSystem.call("PreferencesController:getState");
     _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _isDetectionEnabledFromPreferences, defaultUseTokenDetection);
     _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _isDetectionEnabledForNetwork, _chunkNEXY7SE2js.isTokenDetectionSupportedForNetwork.call(void 0, chainId));
@@ -165,7 +178,10 @@ var TokenDetectionController = class extends _pollingcontroller.StaticIntervalPo
     if (!this.isActive) {
       return;
     }
-    const addressAgainstWhichToDetect = selectedAddress ?? _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _selectedAddress);
+    //const addressAgainstWhichToDetect = selectedAddress ?? _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _selectedAddress);
+    const currentAddress = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _selectedAddress);
+    const currentAddressChecksum = _controllerutils.toChecksumHexAddress.call(void 0, currentAddress)
+    const addressAgainstWhichToDetect = _controllerutils.toChecksumHexAddress.call(void 0, selectedAddress) ?? currentAddressChecksum;
     const { chainId, networkClientId: selectedNetworkClientId } = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getCorrectChainIdAndNetworkClientId, getCorrectChainIdAndNetworkClientId_fn).call(this, networkClientId);
     const chainIdAgainstWhichToDetect = chainId;
     const networkClientIdAgainstWhichToDetect = selectedNetworkClientId;
@@ -179,7 +195,9 @@ var TokenDetectionController = class extends _pollingcontroller.StaticIntervalPo
     const { tokensChainsCache } = this.messagingSystem.call(
       "TokenListController:getState"
     );
-    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _tokenList, isTokenDetectionInactiveInMainnet ? STATIC_MAINNET_TOKEN_LIST : tokensChainsCache[chainIdAgainstWhichToDetect]?.data ?? {});
+
+    const convertedMainnet = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getConvertedStaticMainnetTokenList, getConvertedStaticMainnetTokenList_fn).call(this)
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _tokensChainsCache, isTokenDetectionInactiveInMainnet ? convertedMainnet : tokensChainsCache ?? {});
     for (const tokensSlice of _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getSlicesOfTokensToDetect, getSlicesOfTokensToDetect_fn).call(this, {
       chainId: chainIdAgainstWhichToDetect,
       selectedAddress: addressAgainstWhichToDetect
@@ -196,7 +214,7 @@ var TokenDetectionController = class extends _pollingcontroller.StaticIntervalPo
 _intervalId = new WeakMap();
 _selectedAddress = new WeakMap();
 _networkClientId = new WeakMap();
-_tokenList = new WeakMap();
+_tokensChainsCache = new WeakMap();
 _disabled = new WeakMap();
 _isUnlocked = new WeakMap();
 _isDetectionEnabledFromPreferences = new WeakMap();
@@ -215,21 +233,19 @@ registerEventListeners_fn = function() {
   });
   this.messagingSystem.subscribe(
     "TokenListController:stateChange",
-    async ({ tokenList }) => {
-      const hasTokens = Object.keys(tokenList).length;
-      if (hasTokens) {
-        await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _restartTokenDetection, restartTokenDetection_fn).call(this);
+    async ({ tokensChainsCache }) => {
+      const isEqualValues = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _compareTokensChainsCache, compareTokensChainsCache_fn).call(this, tokensChainsCache, _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _tokensChainsCache))
+      if (!isEqualValues) {
+         await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _restartTokenDetection, restartTokenDetection_fn).call(this);
       }
     }
   );
   this.messagingSystem.subscribe(
     "PreferencesController:stateChange",
-    async ({ selectedAddress: newSelectedAddress, useTokenDetection }) => {
-      const isSelectedAddressChanged = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _selectedAddress) !== newSelectedAddress;
+    async ({ useTokenDetection }) => {
       const isDetectionChangedFromPreferences = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _isDetectionEnabledFromPreferences) !== useTokenDetection;
-      _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _selectedAddress, newSelectedAddress);
       _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _isDetectionEnabledFromPreferences, useTokenDetection);
-      if (isSelectedAddressChanged || isDetectionChangedFromPreferences) {
+      if (isDetectionChangedFromPreferences) {
         await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _restartTokenDetection, restartTokenDetection_fn).call(this, {
           selectedAddress: _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _selectedAddress)
         });
@@ -280,6 +296,33 @@ startPolling_fn = async function() {
     await this.detectTokens();
   }, this.getIntervalLength()));
 };
+_compareTokensChainsCache = new WeakSet();
+compareTokensChainsCache_fn = function(tokensChainsCache, previousTokensChainsCache) {
+  const cleanPreviousTokensChainsCache = mapChainIdWithTokenListMap(previousTokensChainsCache);
+  const cleanTokensChainsCache = mapChainIdWithTokenListMap(tokensChainsCache);
+  const isEqualValues = (0, lodash_1.isEqual)(cleanTokensChainsCache, cleanPreviousTokensChainsCache);
+  return isEqualValues;
+};
+_getConvertedStaticMainnetTokenList = new WeakSet();
+getConvertedStaticMainnetTokenList_fn = function() {
+  const data = Object.entries(exports.STATIC_MAINNET_TOKEN_LIST).reduce((acc, [key, value]) => ({
+    ...acc,
+    [key]: {
+        name: value.name,
+        symbol: value.symbol,
+        decimals: value.decimals,
+        address: value.address,
+        aggregators: [],
+        iconUrl: value?.iconUrl,
+    },
+}), {});
+return {
+    '0x1': {
+        data,
+        timestamp: 0,
+    },
+};
+};
 _getCorrectChainIdAndNetworkClientId = new WeakSet();
 getCorrectChainIdAndNetworkClientId_fn = function(networkClientId) {
   if (networkClientId) {
@@ -335,7 +378,7 @@ getSlicesOfTokensToDetect_fn = function({
     )
   );
   const tokensToDetect = [];
-  for (const tokenAddress of Object.keys(_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _tokenList))) {
+  for (const tokenAddress of Object.keys(_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _tokensChainsCache)?.[chainId]?.data || {})) {
     if ([
       tokensAddresses,
       detectedTokensAddresses,
@@ -366,7 +409,7 @@ addDetectedTokens_fn = async function({
     const tokensWithBalance = [];
     const eventTokensDetails = [];
     for (const nonZeroTokenAddress of Object.keys(balances)) {
-      const { decimals, symbol, aggregators, iconUrl, name } = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _tokenList)[nonZeroTokenAddress];
+      const { decimals, symbol, aggregators, iconUrl, name } = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _tokensChainsCache)[chainId].data[nonZeroTokenAddress];
       eventTokensDetails.push(`${symbol} - ${nonZeroTokenAddress}`);
       tokensWithBalance.push({
         address: nonZeroTokenAddress,
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-IBK6AXPP.js b/node_modules/@metamask/assets-controllers/dist/chunk-IBK6AXPP.js
index f7509a1..4573718 100644
--- a/node_modules/@metamask/assets-controllers/dist/chunk-IBK6AXPP.js
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-IBK6AXPP.js
@@ -19,7 +19,7 @@ function getDefaultTokenBalancesState() {
     contractBalances: {}
   };
 }
-var _handle, _getERC20BalanceOf, _interval, _tokens, _disabled;
+var _handle, _getERC20BalanceOf, _interval, _tokens, _disabled, _updateInProgress;
 var TokenBalancesController = class extends _basecontroller.BaseController {
   /**
    * Construct a Token Balances Controller.
@@ -54,9 +54,11 @@ var TokenBalancesController = class extends _basecontroller.BaseController {
     _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _interval, void 0);
     _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _tokens, void 0);
     _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _disabled, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _updateInProgress, void 0);
     _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _disabled, disabled);
     _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _interval, interval);
     _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _tokens, tokens);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _updateInProgress, false);
     this.messagingSystem.subscribe(
       "TokensController:stateChange",
       ({ tokens: newTokens, detectedTokens }) => {
@@ -79,6 +81,15 @@ var TokenBalancesController = class extends _basecontroller.BaseController {
   disable() {
     _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _disabled, true);
   }
+  /**
+  * THIS FUNCTIONS IS CURRENTLY PATCHED AND STILL NEEDS TO BE IMPLEMENTED ON THE CORE REPO
+  * Resets to the default state
+  */
+  reset() {
+    this.update((state) => {
+        state.contractBalances = {};
+    });
+  }
   /**
    * Starts a new polling interval.
    *
@@ -100,27 +111,34 @@ var TokenBalancesController = class extends _basecontroller.BaseController {
    * Updates balances for all tokens.
    */
   async updateBalances() {
-    if (_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _disabled)) {
+    if (_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _disabled) || _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _updateInProgress)) {
       return;
     }
     const { selectedAddress } = this.messagingSystem.call(
       "PreferencesController:getState"
     );
     const newContractBalances = {};
-    for (const token of _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _tokens)) {
-      const { address } = token;
-      try {
-        const balance = await _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _getERC20BalanceOf).call(this, address, selectedAddress);
-        newContractBalances[address] = _controllerutils.toHex.call(void 0, balance);
-        token.hasBalanceError = false;
-      } catch (error) {
-        newContractBalances[address] = _controllerutils.toHex.call(void 0, 0);
-        token.hasBalanceError = true;
-      }
-    }
+    const balancePromises = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _tokens).map((token) => {
+    const { address } = token;
+        return _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _getERC20BalanceOf).call(this, address, selectedAddress).then((balance) => {
+            newContractBalances[address] = _controllerutils.toHex.call(void 0, balance);
+            token = {
+                  ...token,
+                  hasBalanceError: false
+                };
+        }).catch((error) => {
+            newContractBalances[address] = _controllerutils.toHex.call(void 0, 0);
+                token = {
+                  ...token,
+                  hasBalanceError: true
+                };
+              });
+      });
+    await Promise.all(balancePromises);
     this.update((state) => {
       state.contractBalances = newContractBalances;
     });
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _updateInProgress, false);
   }
 };
 _handle = new WeakMap();
@@ -128,6 +146,7 @@ _getERC20BalanceOf = new WeakMap();
 _interval = new WeakMap();
 _tokens = new WeakMap();
 _disabled = new WeakMap();
+_updateInProgress = new WeakMap();
 var TokenBalancesController_default = TokenBalancesController;
 
 
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-JUI3XNEF.js b/node_modules/@metamask/assets-controllers/dist/chunk-JUI3XNEF.js
index 44804c8..911a6e6 100644
--- a/node_modules/@metamask/assets-controllers/dist/chunk-JUI3XNEF.js
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-JUI3XNEF.js
@@ -247,10 +247,15 @@ var TokenListController = class extends _pollingcontroller.StaticIntervalPolling
 };
 _onNetworkControllerStateChange = new WeakSet();
 onNetworkControllerStateChange_fn = async function(networkControllerState) {
-  if (this.chainId !== networkControllerState.providerConfig.chainId) {
+  const selectedNetworkClient = this.messagingSystem.call(
+    "NetworkController:getNetworkClientById",
+    networkControllerState.selectedNetworkClientId
+  );
+  const { chainId } = selectedNetworkClient.configuration;
+  if (this.chainId !== chainId) {
     this.abortController.abort();
     this.abortController = new AbortController();
-    this.chainId = networkControllerState.providerConfig.chainId;
+    this.chainId = chainId;
     if (this.state.preventPollingOnNetworkRestart) {
       this.clearingTokenListData();
     } else {
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-NEXY7SE2.js b/node_modules/@metamask/assets-controllers/dist/chunk-NEXY7SE2.js
index 8c506d9..d1ec2d2 100644
--- a/node_modules/@metamask/assets-controllers/dist/chunk-NEXY7SE2.js
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-NEXY7SE2.js
@@ -182,7 +182,7 @@ async function fetchTokenContractExchangeRates({
     (obj, [tokenAddress, tokenPrice]) => {
       return {
         ...obj,
-        [_controllerutils.toChecksumHexAddress.call(void 0, tokenAddress)]: tokenPrice?.value
+        [_controllerutils.toChecksumHexAddress.call(void 0, tokenAddress)]: tokenPrice?.price
       };
     },
     {}
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-QFDTOEYR.js b/node_modules/@metamask/assets-controllers/dist/chunk-QFDTOEYR.js
index 5335fa5..0854306 100644
--- a/node_modules/@metamask/assets-controllers/dist/chunk-QFDTOEYR.js
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-QFDTOEYR.js
@@ -8,12 +8,14 @@ var _chunkZ4BLTVTBjs = require('./chunk-Z4BLTVTB.js');
 // src/NftDetectionController.ts
 
 
-
+var utils_1 = require('@metamask/utils');
+var _chunkR4HATJKUjs = require('./chunk-NEXY7SE2.js');
 
 
 
 
 var _controllerutils = require('@metamask/controller-utils');
+var supportedNftDetectionNetworks = [_controllerutils.ChainId.mainnet];
 var _pollingcontroller = require('@metamask/polling-controller');
 var DEFAULT_INTERVAL = 18e4;
 var controllerName = "NftDetectionController";
@@ -24,7 +26,8 @@ var BlockaidResultType = /* @__PURE__ */ ((BlockaidResultType2) => {
   BlockaidResultType2["Malicious"] = "Malicious";
   return BlockaidResultType2;
 })(BlockaidResultType || {});
-var _intervalId, _interval, _disabled, _addNft, _getNftState, _stopPolling, stopPolling_fn, _startPolling, startPolling_fn, _onPreferencesControllerStateChange, onPreferencesControllerStateChange_fn, _getOwnerNftApi, getOwnerNftApi_fn, _getOwnerNfts, getOwnerNfts_fn;
+var MAX_GET_COLLECTION_BATCH_SIZE = 20;
+var _intervalId, _interval, _disabled, _addNft, _getNftState, _stopPolling, stopPolling_fn, _startPolling, startPolling_fn, _onPreferencesControllerStateChange, onPreferencesControllerStateChange_fn, _getOwnerNftApi, getOwnerNftApi_fn, _getOwnerNfts, getOwnerNfts_fn, _inProcessNftFetchingUpdates;
 var NftDetectionController = class extends _pollingcontroller.StaticIntervalPollingController {
   /**
    * The controller options
@@ -68,8 +71,10 @@ var NftDetectionController = class extends _pollingcontroller.StaticIntervalPoll
     _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _disabled, void 0);
     _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _addNft, void 0);
     _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getNftState, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _inProcessNftFetchingUpdates, void 0);
     _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _interval, interval);
     _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _disabled, disabled);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _inProcessNftFetchingUpdates, {});
     _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _getNftState, getNftState);
     _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _addNft, addNft);
     this.messagingSystem.subscribe(
@@ -126,62 +131,152 @@ var NftDetectionController = class extends _pollingcontroller.StaticIntervalPoll
    */
   async detectNfts(options) {
     const userAddress = options?.userAddress ?? this.messagingSystem.call("PreferencesController:getState").selectedAddress;
-    if (!this.isMainnet() || _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _disabled)) {
+
+    const { selectedNetworkClientId } = this.messagingSystem.call("NetworkController:getState");
+    const { configuration: { chainId }} = this.messagingSystem.call(
+        "NetworkController:getNetworkClientById",
+        selectedNetworkClientId
+    );
+    if (!supportedNftDetectionNetworks.includes(chainId) || _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _disabled)) {
       return;
     }
     if (!userAddress) {
       return;
     }
-    const apiNfts = await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getOwnerNfts, getOwnerNfts_fn).call(this, userAddress);
-    const addNftPromises = apiNfts.map(async (nft) => {
-      const {
-        tokenId: token_id,
-        contract,
-        kind,
-        image: image_url,
-        imageSmall: image_thumbnail_url,
-        metadata: { imageOriginal: image_original_url } = {},
-        name,
-        description,
-        attributes,
-        topBid,
-        lastSale,
-        rarityRank,
-        rarityScore,
-        collection
-      } = nft.token;
-      let ignored;
-      const { ignoredNfts } = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _getNftState).call(this);
-      if (ignoredNfts.length > 0) {
-        ignored = ignoredNfts.find((c) => {
-          return c.address === _controllerutils.toChecksumHexAddress.call(void 0, contract) && c.tokenId === token_id;
-        });
-      }
-      if (!ignored) {
-        const nftMetadata = Object.assign(
-          {},
-          { name },
-          description && { description },
-          image_url && { image: image_url },
-          image_thumbnail_url && { imageThumbnail: image_thumbnail_url },
-          image_original_url && { imageOriginal: image_original_url },
-          kind && { standard: kind.toUpperCase() },
-          lastSale && { lastSale },
-          attributes && { attributes },
-          topBid && { topBid },
-          rarityRank && { rarityRank },
-          rarityScore && { rarityScore },
-          collection && { collection }
+
+    const updateKey = `${chainId}:${userAddress}`;
+    if (updateKey in _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _inProcessNftFetchingUpdates)) {
+      await _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _inProcessNftFetchingUpdates)[updateKey];
+        return;
+    }
+    const {
+          promise: inProgressUpdate,
+          resolve: updateSucceeded,
+          reject: updateFailed
+        } = utils_1.createDeferredPromise.call(void 0, { suppressUnhandledRejection: true });
+    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _inProcessNftFetchingUpdates)[updateKey] = inProgressUpdate;
+    let next;
+    let apiNfts = [];
+    let resultNftApi;
+    try{
+      do {
+        resultNftApi = await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getOwnerNfts, getOwnerNfts_fn).call(this, userAddress, chainId, next);
+        apiNfts = resultNftApi.tokens.filter(
+          (elm) => elm.token.isSpam === false && (elm.blockaidResult?.result_type ? elm.blockaidResult?.result_type === "Benign" /* Benign */ : true)
         );
-        await _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _addNft).call(this, contract, token_id, {
-          nftMetadata,
-          userAddress,
-          source: "detected" /* Detected */,
-          networkClientId: options?.networkClientId
+        const collections = apiNfts.reduce((acc, currValue) => {
+          if (!acc.includes(currValue.token.contract) && currValue.token.contract === currValue?.token?.collection?.id) {
+              acc.push(currValue.token.contract);
+          }
+          return acc;
+        }, []);
+        if (collections.length !== 0) {
+          const collectionResponse = await _chunkR4HATJKUjs.reduceInBatchesSerially.call(void 0, {
+            values: collections,
+            batchSize: MAX_GET_COLLECTION_BATCH_SIZE,
+            eachBatch: async (allResponses, batch) => {
+              const params = new URLSearchParams(
+                batch.map((s) => ["contract", s])
+              );
+              params.append("chainId", "1");
+              const collectionResponseForBatch = await _controllerutils.fetchWithErrorHandling.call(void 0, 
+                  {
+                    url: `${_controllerutils.NFT_API_BASE_URL}/collections?${params.toString()}`,
+                    options: {
+                    headers: {
+                    Version: '1'
+                    }
+                    },
+                    timeout: 15000
+                  }
+                );
+                return {
+                ...allResponses,
+                ...collectionResponseForBatch
+                };
+              },
+            initialResult: {}
+          });
+
+          if (collectionResponse.collections?.length) {
+            apiNfts.forEach((singleNFT) => {
+                const found = collectionResponse.collections.find(
+                (elm) => elm.id?.toLowerCase() === singleNFT.token.contract.toLowerCase()
+                );
+                if (found) {
+                    singleNFT.token = {
+                    ...singleNFT.token,
+                    collection: {
+                      ...singleNFT.token.collection ?? {},
+                      creator: found?.creator,
+                      openseaVerificationStatus: found?.openseaVerificationStatus,
+                      contractDeployedAt: found.contractDeployedAt,
+                      ownerCount: found.ownerCount,
+                      topBid: found.topBid
+                    }
+                  };
+                }
+            });
+          }
+        }
+
+        const addNftPromises = apiNfts.map(async (nft) => {
+        const {
+            tokenId,
+            contract,
+            kind,
+            image: imageUrl,
+              imageSmall: imageThumbnailUrl,
+              metadata: { imageOriginal: imageOriginalUrl } = {},
+              name,
+              description,
+              attributes,
+              topBid,
+              lastSale,
+              rarityRank,
+              rarityScore,
+              collection
+        } = nft.token;
+        let ignored;
+        const { ignoredNfts } = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _getNftState).call(this);
+        if (ignoredNfts.length) {
+            ignored = ignoredNfts.find((c) => {
+              return c.address === _controllerutils.toChecksumHexAddress.call(void 0, contract) && c.tokenId === tokenId;
+            });
+        }
+        if (!ignored) {
+              const nftMetadata = Object.assign(
+                {},
+                { name },
+                description && { description },
+                imageUrl && { image: imageUrl },
+                imageThumbnailUrl && { imageThumbnail: imageThumbnailUrl },
+                imageOriginalUrl && { imageOriginal: imageOriginalUrl },
+                kind && { standard: kind.toUpperCase() },
+                lastSale && { lastSale },
+                attributes && { attributes },
+                topBid && { topBid },
+                rarityRank && { rarityRank },
+                rarityScore && { rarityScore },
+                collection && { collection }
+              );
+              await _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _addNft).call(this, contract, tokenId, {
+                nftMetadata,
+                userAddress,
+                source: "detected" /* Detected */,
+                networkClientId: options?.networkClientId
+              });
+        }
         });
-      }
-    });
-    await Promise.all(addNftPromises);
+        await Promise.all(addNftPromises);
+      } while(next = resultNftApi.continuation)
+      updateSucceeded();
+    }catch(error){
+      updateFailed(error);
+      throw error;
+    }finally{
+      delete _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _inProcessNftFetchingUpdates)[updateKey];
+    }
   }
 };
 _intervalId = new WeakMap();
@@ -190,6 +285,7 @@ _disabled = new WeakMap();
 _addNft = new WeakMap();
 _getNftState = new WeakMap();
 _stopPolling = new WeakSet();
+_inProcessNftFetchingUpdates = new WeakMap();
 stopPolling_fn = function() {
   if (_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _intervalId)) {
     clearInterval(_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _intervalId));
@@ -207,41 +303,26 @@ _onPreferencesControllerStateChange = new WeakSet();
 onPreferencesControllerStateChange_fn = function({ useNftDetection }) {
   if (!useNftDetection !== _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _disabled)) {
     _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _disabled, !useNftDetection);
-    if (useNftDetection) {
-      this.start();
-    } else {
-      this.stop();
-    }
   }
 };
 _getOwnerNftApi = new WeakSet();
-getOwnerNftApi_fn = function({ address, next }) {
-  return `${_controllerutils.NFT_API_BASE_URL}/users/${address}/tokens?chainIds=1&limit=50&includeTopBid=true&continuation=${next ?? ""}`;
+getOwnerNftApi_fn = function({ chainId, address, next }) {
+  return `${_controllerutils.NFT_API_BASE_URL}/users/${address}/tokens?chainIds=${chainId}&limit=50&includeTopBid=true&continuation=${next ?? ""}`;
 };
 _getOwnerNfts = new WeakSet();
-getOwnerNfts_fn = async function(address) {
-  let nftApiResponse;
-  let nfts = [];
-  let next;
-  do {
-    nftApiResponse = await _controllerutils.fetchWithErrorHandling.call(void 0, {
-      url: _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getOwnerNftApi, getOwnerNftApi_fn).call(this, { address, next }),
-      options: {
-        headers: {
-          Version: _controllerutils.NFT_API_VERSION
-        }
-      },
-      timeout: _controllerutils.NFT_API_TIMEOUT
-    });
-    if (!nftApiResponse) {
-      return nfts;
-    }
-    const newNfts = nftApiResponse.tokens?.filter(
-      (elm) => elm.token.isSpam === false && (elm.blockaidResult?.result_type ? elm.blockaidResult?.result_type === "Benign" /* Benign */ : true)
-    ) ?? [];
-    nfts = [...nfts, ...newNfts];
-  } while (next = nftApiResponse.continuation);
-  return nfts;
+getOwnerNfts_fn = async function(address, chainId, cursor) {
+  const convertedChainId = _controllerutils.convertHexToDecimal.call(void 0, chainId).toString();
+  const url = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getOwnerNftApi, getOwnerNftApi_fn).call(this, {
+    chainId: convertedChainId,
+    address,
+    next: cursor
+  });
+  const nftApiResponse = await _controllerutils.handleFetch.call(void 0, url, {
+      headers: {
+        Version: '1'
+      }
+  });
+  return nftApiResponse;
 };
 var NftDetectionController_default = NftDetectionController;
 
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-QHWKLZUC.js b/node_modules/@metamask/assets-controllers/dist/chunk-QHWKLZUC.js
index 6f461a4..a3573af 100644
--- a/node_modules/@metamask/assets-controllers/dist/chunk-QHWKLZUC.js
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-QHWKLZUC.js
@@ -69,9 +69,10 @@ var AssetsContractController = class extends _basecontroller.BaseControllerV1 {
       this.configure({ ipfsGateway });
     });
     onNetworkDidChange((networkState) => {
-      if (this.config.chainId !== networkState.providerConfig.chainId) {
+      const {configuration: { chainId}} = this.getNetworkClientById(networkState.selectedNetworkClientId);
+      if (this.config.chainId !== chainId) {
         this.configure({
-          chainId: networkState.providerConfig.chainId
+          chainId,
         });
       }
     });
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-UEDNQBJN.js b/node_modules/@metamask/assets-controllers/dist/chunk-UEDNQBJN.js
index 80cecfb..e19a2e9 100644
--- a/node_modules/@metamask/assets-controllers/dist/chunk-UEDNQBJN.js
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-UEDNQBJN.js
@@ -380,7 +380,7 @@ fetchAndMapExchangeRatesForSupportedNativeCurrency_fn = async function({
     (obj, [tokenAddress, token]) => {
       obj = {
         ...obj,
-        [tokenAddress.toLowerCase()]: { ...token }
+        [tokenAddress]: { ...token }
       };
       return obj;
     },
@@ -416,7 +416,7 @@ fetchAndMapExchangeRatesForUnsupportedNativeCurrency_fn = async function({
       ...acc,
       [tokenAddress]: {
         ...token,
-        value: token.value ? token.value * fallbackCurrencyToNativeCurrencyConversionRate : void 0
+        price: token.price ? token.price * fallbackCurrencyToNativeCurrencyConversionRate : void 0
       }
     };
     return acc;
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-Z6TBQQE5.js b/node_modules/@metamask/assets-controllers/dist/chunk-Z6TBQQE5.js
index 2f1b66f..f4acd79 100644
--- a/node_modules/@metamask/assets-controllers/dist/chunk-Z6TBQQE5.js
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-Z6TBQQE5.js
@@ -295,13 +295,12 @@ var CodefiTokenPricesServiceV2 = class {
       (obj, tokenAddress) => {
         const lowercasedTokenAddress = tokenAddress.toLowerCase();
         const marketData = addressCryptoDataMap[lowercasedTokenAddress];
-        if (marketData === void 0) {
+        if (!marketData) {
           return obj;
         }
-        const { price } = marketData;
+
         const token = {
           tokenAddress,
-          value: price,
           currency,
           ...marketData
         };
diff --git a/node_modules/@metamask/assets-controllers/dist/types/NftController.d.ts b/node_modules/@metamask/assets-controllers/dist/types/NftController.d.ts
index bbf4f12..38b1276 100644
--- a/node_modules/@metamask/assets-controllers/dist/types/NftController.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/types/NftController.d.ts
@@ -6,7 +6,7 @@ import type { PreferencesControllerStateChangeEvent } from '@metamask/preference
 import type { Hex } from '@metamask/utils';
 import type { AssetsContractController } from './AssetsContractController';
 import { Source } from './constants';
-import type { Collection, Attributes, LastSale } from './NftDetectionController';
+import type { Collection, Attributes, LastSale, TopBid } from './NftDetectionController';
 type NFTStandardType = 'ERC721' | 'ERC1155';
 type SuggestedNftMeta = {
     asset: {
@@ -107,11 +107,13 @@ export type NftMetadata = {
     creator?: string;
     transactionId?: string;
     tokenURI?: string | null;
+    error?: string;
     collection?: Collection;
     address?: string;
-    attributes?: Attributes;
+    attributes?: Attributes[];
     lastSale?: LastSale;
     rarityRank?: string;
+    topBid?: TopBid;
 };
 /**
  * @type NftControllerState
@@ -420,6 +422,11 @@ export declare class NftController extends BaseController<typeof controllerName,
      */
     resetNftTransactionStatusByTransactionId(transactionId: string, selectedAddress: string, chainId: Hex): boolean;
     _requestApproval(suggestedNftMeta: SuggestedNftMeta): Promise<unknown>;
+    /**
+     * THIS FUNCTIONS IS CURRENTLY PATCHED AND STILL NEEDS TO BE IMPLEMENTED ON THE CORE REPO
+     * Resets to the default state
+    */
+    reset(): void;
 }
 export default NftController;
 //# sourceMappingURL=NftController.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/NftDetectionController.d.ts b/node_modules/@metamask/assets-controllers/dist/types/NftDetectionController.d.ts
index 758a85e..a4a4b72 100644
--- a/node_modules/@metamask/assets-controllers/dist/types/NftDetectionController.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/types/NftDetectionController.d.ts
@@ -225,7 +225,39 @@ export type Attributes = {
     topBidValue?: number | null;
     createdAt?: string;
 };
-export type Collection = {
+export type GetCollectionsResponse = {
+    collections: CollectionResponse[];
+};
+export type CollectionResponse = {
+    id?: string;
+    openseaVerificationStatus?: string;
+    contractDeployedAt?: string;
+    creator?: string;
+    ownerCount?: string;
+    topBid?: TopBid & {
+        sourceDomain?: string;
+    };
+};
+export type FloorAskCollection = {
+    id?: string;
+    price?: Price;
+    maker?: string;
+    kind?: string;
+    validFrom?: number;
+    validUntil?: number;
+    source?: SourceCollection;
+    rawData?: Metadata;
+    isNativeOffChainCancellable?: boolean;
+};
+  
+export type SourceCollection = {
+    id: string;
+    domain: string;
+    name: string;
+    icon: string;
+    url: string;
+};
+export type TokenCollection = {
     id?: string;
     name?: string;
     slug?: string;
@@ -241,7 +273,9 @@ export type Collection = {
     floorAskPrice?: Price;
     royaltiesBps?: number;
     royalties?: Royalties[];
+    floorAsk?: FloorAskCollection;
 };
+export type Collection = TokenCollection & CollectionResponse;
 export type Royalties = {
     bps?: number;
     recipient?: string;
diff --git a/node_modules/@metamask/assets-controllers/dist/types/TokenBalancesController.d.ts b/node_modules/@metamask/assets-controllers/dist/types/TokenBalancesController.d.ts
index 52bb3ac..d4d5c0a 100644
--- a/node_modules/@metamask/assets-controllers/dist/types/TokenBalancesController.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/types/TokenBalancesController.d.ts
@@ -79,6 +79,11 @@ export declare class TokenBalancesController extends BaseController<typeof contr
      * Updates balances for all tokens.
      */
     updateBalances(): Promise<void>;
+    /**
+     * THIS FUNCTIONS IS CURRENTLY PATCHED AND STILL NEEDS TO BE IMPLEMENTED ON THE CORE REPO
+     * Resets to the default state
+    */
+    reset(): void;
 }
 export default TokenBalancesController;
 //# sourceMappingURL=TokenBalancesController.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/TokensController.d.ts b/node_modules/@metamask/assets-controllers/dist/types/TokensController.d.ts
index bc4126d..ce8016a 100644
--- a/node_modules/@metamask/assets-controllers/dist/types/TokensController.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/types/TokensController.d.ts
@@ -162,6 +162,11 @@ export declare class TokensController extends BaseController<typeof controllerNa
      * Removes all tokens from the ignored list.
      */
     clearIgnoredTokens(): void;
+    /**
+     * THIS FUNCTIONS IS CURRENTLY PATCHED AND STILL NEEDS TO BE IMPLEMENTED ON THE CORE REPO
+     * Resets to the default state
+    */
+    reset(): void;
 }
 export default TokensController;
 //# sourceMappingURL=TokensController.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/index.d.ts b/node_modules/@metamask/assets-controllers/dist/types/index.d.ts
index bf96db8..f6eb1ea 100644
--- a/node_modules/@metamask/assets-controllers/dist/types/index.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/types/index.d.ts
@@ -5,7 +5,7 @@ export type { NftControllerState, NftControllerMessenger, NftControllerActions,
 export { getDefaultNftControllerState, NftController } from './NftController';
 export type { NftDetectionControllerMessenger, ApiNft, ApiNftContract, ApiNftLastSale, ApiNftCreator, ReservoirResponse, TokensResponse, BlockaidResultType, Blockaid, Market, TokenResponse, TopBid, LastSale, FeeBreakdown, Attributes, Collection, Royalties, Ownership, FloorAsk, Price, Metadata, } from './NftDetectionController';
 export { NftDetectionController } from './NftDetectionController';
-export type { TokenBalancesControllerMessenger, TokenBalancesControllerActions, TokenBalancesControllerGetStateAction, TokenBalancesControllerEvents, TokenBalancesControllerStateChangeEvent, } from './TokenBalancesController';
+export type { TokenBalancesControllerMessenger, TokenBalancesControllerActions, TokenBalancesControllerGetStateAction, TokenBalancesControllerEvents, TokenBalancesControllerStateChangeEvent, TokenBalancesControllerState, } from './TokenBalancesController';
 export { TokenBalancesController } from './TokenBalancesController';
 export type { TokenDetectionControllerMessenger, TokenDetectionControllerActions, TokenDetectionControllerGetStateAction, TokenDetectionControllerEvents, TokenDetectionControllerStateChangeEvent, } from './TokenDetectionController';
 export { TokenDetectionController } from './TokenDetectionController';
