diff --git a/node_modules/@metamask/key-tree/dist/BIP44CoinTypeNode.cjs b/node_modules/@metamask/key-tree/dist/BIP44CoinTypeNode.cjs
index a9e7cdd..f92488b 100644
--- a/node_modules/@metamask/key-tree/dist/BIP44CoinTypeNode.cjs
+++ b/node_modules/@metamask/key-tree/dist/BIP44CoinTypeNode.cjs
@@ -35,15 +35,6 @@ exports.BIP_44_COIN_TYPE_DEPTH = 2;
  *
  */
 class BIP44CoinTypeNode {
-    // Constructors cannot use hash names.
-    // eslint-disable-next-line no-restricted-syntax
-    constructor(node, coin_type) {
-        _BIP44CoinTypeNode_node.set(this, void 0);
-        __classPrivateFieldSet(this, _BIP44CoinTypeNode_node, node, "f");
-        this.coin_type = coin_type;
-        this.path = (0, utils_2.getBIP44CoinTypePathString)(coin_type);
-        Object.freeze(this);
-    }
     /**
      * Constructs a BIP-44 `coin_type` node. `coin_type` is the index
      * specifying the protocol for which deeper keys are intended. For the
@@ -61,8 +52,11 @@ class BIP44CoinTypeNode {
      * @param json - The {@link JsonBIP44Node} for the key of this node.
      * @param coin_type - The coin_type index of this node. Must be a non-negative
      * integer.
+     * @param cryptographicFunctions - The cryptographic functions to use. If
+     * provided, these will be used instead of the built-in implementations.
+     * @returns A BIP44CoinType node.
      */
-    static async fromJSON(json, coin_type) {
+    static async fromJSON(json, coin_type, cryptographicFunctions) {
         validateCoinType(coin_type);
         validateCoinTypeNodeDepth(json.depth);
         const node = await BIP44Node_1.BIP44Node.fromExtendedKey({
@@ -72,7 +66,7 @@ class BIP44CoinTypeNode {
             chainCode: (0, utils_2.hexStringToBytes)(json.chainCode),
             privateKey: (0, utils_2.nullableHexStringToBytes)(json.privateKey),
             publicKey: (0, utils_2.hexStringToBytes)(json.publicKey),
-        });
+        }, cryptographicFunctions);
         return new BIP44CoinTypeNode(node, coin_type);
     }
     /**
@@ -90,12 +84,15 @@ class BIP44CoinTypeNode {
      * `0 / 1 / 2 / 3 / 4 / 5`
      *
      * @param derivationPath - The derivation path for the key of this node.
+     * @param cryptographicFunctions - The cryptographic functions to use. If
+     * provided, these will be used instead of the built-in implementations.
+     * @returns A BIP44CoinType node.
      */
-    static async fromDerivationPath(derivationPath) {
+    static async fromDerivationPath(derivationPath, cryptographicFunctions) {
         validateCoinTypeNodeDepth(derivationPath.length - 1);
         const node = await BIP44Node_1.BIP44Node.fromDerivationPath({
             derivationPath,
-        });
+        }, cryptographicFunctions);
         // Split the bip32 string token and extract the coin_type index.
         const pathPart = derivationPath[exports.BIP_44_COIN_TYPE_DEPTH].split(':')[1]?.replace(`'`, '');
         (0, utils_1.assert)(pathPart, 'Invalid derivation path.');
@@ -119,6 +116,7 @@ class BIP44CoinTypeNode {
      * @param node - The {@link BIP44Node} for the key of this node.
      * @param coin_type - The coin_type index of this node. Must be a non-negative
      * integer.
+     * @returns A BIP44CoinType node.
      */
     static async fromNode(node, coin_type) {
         if (!(node instanceof BIP44Node_1.BIP44Node)) {
@@ -129,6 +127,15 @@ class BIP44CoinTypeNode {
         // TODO: Make this function not async in a future version.
         return Promise.resolve(new BIP44CoinTypeNode(node, coin_type));
     }
+    // Constructors cannot use hash names.
+    // eslint-disable-next-line no-restricted-syntax
+    constructor(node, coin_type) {
+        _BIP44CoinTypeNode_node.set(this, void 0);
+        __classPrivateFieldSet(this, _BIP44CoinTypeNode_node, node, "f");
+        this.coin_type = coin_type;
+        this.path = (0, utils_2.getBIP44CoinTypePathString)(coin_type);
+        Object.freeze(this);
+    }
     get depth() {
         return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").depth;
     }
@@ -251,19 +258,21 @@ function validateCoinType(coin_type) {
  * @param indices.account - The `account` index. Default: `0`.
  * @param indices.change - The `change` index. Default: `0`.
  * @param indices.address_index - The `address_index` index.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The derived `address_index` key for the specified derivation path.
  */
-async function deriveBIP44AddressKey(parentKeyOrNode, { account = 0, change = 0, address_index }) {
+async function deriveBIP44AddressKey(parentKeyOrNode, { account = 0, change = 0, address_index }, cryptographicFunctions) {
     const path = (0, utils_2.getBIP44CoinTypeToAddressPathTuple)({
         account,
         change,
         address_index,
     });
-    const node = await getNode(parentKeyOrNode);
+    const node = await getNode(parentKeyOrNode, cryptographicFunctions);
     const childNode = await (0, SLIP10Node_1.deriveChildNode)({
         path,
         node,
-    });
+    }, cryptographicFunctions);
     return new BIP44Node_1.BIP44Node(childNode);
 }
 exports.deriveBIP44AddressKey = deriveBIP44AddressKey;
@@ -284,12 +293,14 @@ exports.deriveBIP44AddressKey = deriveBIP44AddressKey;
  * This node contains a BIP-44 key of depth 2, `coin_type`.
  * @param accountAndChangeIndices - The `account` and `change` indices that
  * will be used to derive addresses.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The deriver function for the derivation path specified by the
  * `coin_type` node, `account`, and `change` indices.
  */
-async function getBIP44AddressKeyDeriver(node, accountAndChangeIndices) {
+async function getBIP44AddressKeyDeriver(node, accountAndChangeIndices, cryptographicFunctions) {
     const { account = 0, change = 0 } = accountAndChangeIndices ?? {};
-    const actualNode = await getNode(node);
+    const actualNode = await getNode(node, cryptographicFunctions);
     const accountNode = (0, utils_2.getHardenedBIP32NodeToken)(account);
     const changeNode = (0, utils_2.getBIP32NodeToken)(change);
     const bip44AddressKeyDeriver = async (address_index, isHardened = false) => {
@@ -302,7 +313,7 @@ async function getBIP44AddressKeyDeriver(node, accountAndChangeIndices) {
                     : (0, utils_2.getUnhardenedBIP32NodeToken)(address_index),
             ],
             node: actualNode,
-        });
+        }, cryptographicFunctions);
         return new BIP44Node_1.BIP44Node(slip10Node);
     };
     bip44AddressKeyDeriver.coin_type = actualNode.coin_type;
@@ -321,18 +332,22 @@ exports.getBIP44AddressKeyDeriver = getBIP44AddressKeyDeriver;
  * The depth of the node is validated to be a valid coin type node.
  *
  * @param node - A BIP-44 coin type node, JSON node or extended key.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations. This is
+ * only used if the node is an extended key string or JSON object.
+ * @returns A BIP44CoinType node.
  */
-async function getNode(node) {
+async function getNode(node, cryptographicFunctions) {
     if (node instanceof BIP44CoinTypeNode) {
         validateCoinTypeNodeDepth(node.depth);
         return node;
     }
     if (typeof node === 'string') {
-        const bip44Node = await BIP44Node_1.BIP44Node.fromExtendedKey(node);
+        const bip44Node = await BIP44Node_1.BIP44Node.fromExtendedKey(node, cryptographicFunctions);
         const coinTypeNode = await BIP44CoinTypeNode.fromNode(bip44Node, bip44Node.index - constants_1.BIP_32_HARDENED_OFFSET);
         validateCoinTypeNodeDepth(coinTypeNode.depth);
         return coinTypeNode;
     }
-    return BIP44CoinTypeNode.fromJSON(node, node.coin_type);
+    return BIP44CoinTypeNode.fromJSON(node, node.coin_type, cryptographicFunctions);
 }
 //# sourceMappingURL=BIP44CoinTypeNode.cjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/BIP44CoinTypeNode.cjs.map b/node_modules/@metamask/key-tree/dist/BIP44CoinTypeNode.cjs.map
index 8b32eaf..84966cf 100644
--- a/node_modules/@metamask/key-tree/dist/BIP44CoinTypeNode.cjs.map
+++ b/node_modules/@metamask/key-tree/dist/BIP44CoinTypeNode.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"BIP44CoinTypeNode.cjs","sourceRoot":"","sources":["../src/BIP44CoinTypeNode.ts"],"names":[],"mappings":"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","sourcesContent":["import { assert } from '@metamask/utils';\n\nimport type { BIP44NodeInterface, JsonBIP44Node } from './BIP44Node';\nimport { BIP44Node } from './BIP44Node';\nimport type {\n  BIP39Node,\n  BIP44Depth,\n  BIP44PurposeNodeToken,\n  CoinTypeHDPathString,\n  HardenedBIP32Node,\n} from './constants';\nimport { BIP_32_HARDENED_OFFSET } from './constants';\nimport type { SupportedCurve } from './curves';\nimport { deriveChildNode } from './SLIP10Node';\nimport type { CoinTypeToAddressIndices } from './utils';\nimport {\n  getBIP32NodeToken,\n  getBIP44ChangePathString,\n  getBIP44CoinTypePathString,\n  getBIP44CoinTypeToAddressPathTuple,\n  getHardenedBIP32NodeToken,\n  getUnhardenedBIP32NodeToken,\n  hexStringToBytes,\n  nullableHexStringToBytes,\n} from './utils';\n\nexport type CoinTypeHDPathTuple = [\n  BIP39Node,\n  typeof BIP44PurposeNodeToken,\n  HardenedBIP32Node,\n];\n\nexport const BIP_44_COIN_TYPE_DEPTH = 2;\n\nexport type JsonBIP44CoinTypeNode = JsonBIP44Node & {\n  readonly coin_type: number;\n  readonly path: CoinTypeHDPathString;\n};\n\nexport type BIP44CoinTypeNodeInterface = BIP44NodeInterface & {\n  readonly coin_type: number;\n  readonly path: CoinTypeHDPathString;\n};\n\n/**\n * A wrapper object for BIP-44 `coin_type` keys. `coin_type` is the index\n * specifying the protocol for which deeper keys are intended. For the\n * authoritative list of coin types, please see\n * [SLIP-44](https://github.com/satoshilabs/slips/blob/master/slip-0044.md).\n *\n * Recall that a BIP-44 HD tree path consists of the following nodes:\n *\n * `m / 44' / coin_type' / account' / change / address_index`\n *\n * With the following depths:\n *\n * `0 / 1 / 2 / 3 / 4 / 5`\n *\n */\nexport class BIP44CoinTypeNode implements BIP44CoinTypeNodeInterface {\n  /**\n   * Constructs a BIP-44 `coin_type` node. `coin_type` is the index\n   * specifying the protocol for which deeper keys are intended. For the\n   * authoritative list of coin types, please see\n   * [SLIP-44](https://github.com/satoshilabs/slips/blob/master/slip-0044.md).\n   *\n   * Recall that a BIP-44 HD tree path consists of the following nodes:\n   *\n   * `m / 44' / coin_type' / account' / change / address_index`\n   *\n   * With the following depths:\n   *\n   * `0 / 1 / 2 / 3 / 4 / 5`\n   *\n   * @param json - The {@link JsonBIP44Node} for the key of this node.\n   * @param coin_type - The coin_type index of this node. Must be a non-negative\n   * integer.\n   */\n  static async fromJSON(json: JsonBIP44Node, coin_type: number) {\n    validateCoinType(coin_type);\n    validateCoinTypeNodeDepth(json.depth);\n\n    const node = await BIP44Node.fromExtendedKey({\n      depth: json.depth,\n      index: json.index,\n      parentFingerprint: json.parentFingerprint,\n      chainCode: hexStringToBytes(json.chainCode),\n      privateKey: nullableHexStringToBytes(json.privateKey),\n      publicKey: hexStringToBytes(json.publicKey),\n    });\n\n    return new BIP44CoinTypeNode(node, coin_type);\n  }\n\n  /**\n   * Constructs a BIP-44 `coin_type` node. `coin_type` is the index\n   * specifying the protocol for which deeper keys are intended. For the\n   * authoritative list of coin types, please see\n   * [SLIP-44](https://github.com/satoshilabs/slips/blob/master/slip-0044.md).\n   *\n   * Recall that a BIP-44 HD tree path consists of the following nodes:\n   *\n   * `m / 44' / coin_type' / account' / change / address_index`\n   *\n   * With the following depths:\n   *\n   * `0 / 1 / 2 / 3 / 4 / 5`\n   *\n   * @param derivationPath - The derivation path for the key of this node.\n   */\n  static async fromDerivationPath(derivationPath: CoinTypeHDPathTuple) {\n    validateCoinTypeNodeDepth(derivationPath.length - 1);\n\n    const node = await BIP44Node.fromDerivationPath({\n      derivationPath,\n    });\n\n    // Split the bip32 string token and extract the coin_type index.\n    const pathPart = derivationPath[BIP_44_COIN_TYPE_DEPTH].split(\n      ':',\n    )[1]?.replace(`'`, '');\n\n    assert(pathPart, 'Invalid derivation path.');\n    const coinType = Number.parseInt(pathPart, 10);\n\n    return new BIP44CoinTypeNode(node, coinType);\n  }\n\n  /**\n   * Constructs a BIP-44 `coin_type` node. `coin_type` is the index\n   * specifying the protocol for which deeper keys are intended. For the\n   * authoritative list of coin types, please see\n   * [SLIP-44](https://github.com/satoshilabs/slips/blob/master/slip-0044.md).\n   *\n   * Recall that a BIP-44 HD tree path consists of the following nodes:\n   *\n   * `m / 44' / coin_type' / account' / change / address_index`\n   *\n   * With the following depths:\n   *\n   * `0 / 1 / 2 / 3 / 4 / 5`\n   *\n   * @param node - The {@link BIP44Node} for the key of this node.\n   * @param coin_type - The coin_type index of this node. Must be a non-negative\n   * integer.\n   */\n  static async fromNode(node: BIP44Node, coin_type: number) {\n    if (!(node instanceof BIP44Node)) {\n      throw new Error('Invalid node: Expected an instance of BIP44Node.');\n    }\n\n    validateCoinType(coin_type);\n    validateCoinTypeNodeDepth(node.depth);\n\n    // TODO: Make this function not async in a future version.\n    return Promise.resolve(new BIP44CoinTypeNode(node, coin_type));\n  }\n\n  readonly #node: BIP44Node;\n\n  public readonly path: CoinTypeHDPathString;\n\n  public readonly coin_type: number;\n\n  // Constructors cannot use hash names.\n  // eslint-disable-next-line no-restricted-syntax\n  private constructor(node: BIP44Node, coin_type: number) {\n    this.#node = node;\n    this.coin_type = coin_type;\n    this.path = getBIP44CoinTypePathString(coin_type);\n\n    Object.freeze(this);\n  }\n\n  public get depth(): BIP44Depth {\n    return this.#node.depth;\n  }\n\n  public get privateKeyBytes(): Uint8Array | undefined {\n    return this.#node.privateKeyBytes;\n  }\n\n  public get publicKeyBytes(): Uint8Array {\n    return this.#node.publicKeyBytes;\n  }\n\n  public get chainCodeBytes(): Uint8Array {\n    return this.#node.chainCodeBytes;\n  }\n\n  public get privateKey(): string | undefined {\n    return this.#node.privateKey;\n  }\n\n  public get publicKey(): string {\n    return this.#node.publicKey;\n  }\n\n  public get compressedPublicKey(): string {\n    return this.#node.compressedPublicKey;\n  }\n\n  public get compressedPublicKeyBytes(): Uint8Array {\n    return this.#node.compressedPublicKeyBytes;\n  }\n\n  public get chainCode(): string {\n    return this.#node.chainCode;\n  }\n\n  public get address(): string {\n    return this.#node.address;\n  }\n\n  public get masterFingerprint(): number | undefined {\n    return this.#node.masterFingerprint;\n  }\n\n  public get parentFingerprint(): number {\n    return this.#node.parentFingerprint;\n  }\n\n  public get fingerprint(): number {\n    return this.#node.fingerprint;\n  }\n\n  public get index(): number {\n    return this.#node.index;\n  }\n\n  public get curve(): SupportedCurve {\n    return this.#node.curve;\n  }\n\n  public get extendedKey(): string {\n    return this.#node.extendedKey;\n  }\n\n  /**\n   * Derives a BIP-44 `address_index` key corresponding to the path of this\n   * node and the specified `account`, `change`, and `address_index` values.\n   * `address_index` keys are normally the keys used to generate user account\n   * addresses.\n   *\n   * Recall that a BIP-44 HD tree path consists of the following nodes:\n   *\n   * `m / 44' / coin_type' / account' / change / address_index`\n   *\n   * With the following depths:\n   *\n   * `0 / 1 / 2 / 3 / 4 / 5`\n   *\n   * @param indices - The BIP-44 index values to use in key derivation.\n   * @param indices.account - The `account` index. Default: `0`\n   * @param indices.change - The `change` index. Default: `0`\n   * @param indices.address_index - The `address_index` index.\n   * @returns The derived BIP-44 `address_index` node.\n   */\n  async deriveBIP44AddressKey({\n    account = 0,\n    change = 0,\n    address_index,\n  }: CoinTypeToAddressIndices): Promise<BIP44Node> {\n    return await this.#node.derive(\n      getBIP44CoinTypeToAddressPathTuple({ account, change, address_index }),\n    );\n  }\n\n  toJSON(): JsonBIP44CoinTypeNode {\n    return {\n      ...this.#node.toJSON(),\n      coin_type: this.coin_type,\n      path: this.path,\n    };\n  }\n}\n\n/**\n * Validates the depth of a `coin_type` node. Simply, ensures that it is the\n * number `2`. An error is thrown if validation fails.\n *\n * @param depth - The depth to validate.\n */\nfunction validateCoinTypeNodeDepth(depth: number) {\n  if (depth !== BIP_44_COIN_TYPE_DEPTH) {\n    throw new Error(\n      `Invalid depth: Coin type nodes must be of depth ${BIP_44_COIN_TYPE_DEPTH}. Received: \"${depth}\"`,\n    );\n  }\n}\n\n/**\n * Validates that the coin type is a non-negative integer number. An error is\n * thrown if validation fails.\n *\n * @param coin_type - The coin type to validate.\n */\nfunction validateCoinType(coin_type: unknown): asserts coin_type is number {\n  if (\n    typeof coin_type !== 'number' ||\n    !Number.isInteger(coin_type) ||\n    coin_type < 0\n  ) {\n    throw new Error(\n      'Invalid coin type: The specified coin type must be a non-negative integer number.',\n    );\n  }\n}\n\n/**\n * Derives a BIP-44 address key corresponding to the specified derivation path,\n * given either by a {@link BIP44CoinTypeNode} or derivation path tuple.\n *\n * Recall that a BIP-44 HD tree path consists of the following nodes:\n *\n * `m / 44' / coin_type' / account' / change / address_index`\n *\n * With the following depths:\n *\n * `0 / 1 / 2 / 3 / 4 / 5`\n *\n * @param parentKeyOrNode - The `coin_type` parent key to derive from.\n * @param indices - The BIP-44 index values to use in key derivation.\n * @param indices.account - The `account` index. Default: `0`.\n * @param indices.change - The `change` index. Default: `0`.\n * @param indices.address_index - The `address_index` index.\n * @returns The derived `address_index` key for the specified derivation path.\n */\nexport async function deriveBIP44AddressKey(\n  parentKeyOrNode: BIP44CoinTypeNode | JsonBIP44CoinTypeNode | string,\n  { account = 0, change = 0, address_index }: CoinTypeToAddressIndices,\n): Promise<BIP44Node> {\n  const path = getBIP44CoinTypeToAddressPathTuple({\n    account,\n    change,\n    address_index,\n  });\n\n  const node = await getNode(parentKeyOrNode);\n  const childNode = await deriveChildNode({\n    path,\n    node,\n  });\n\n  return new BIP44Node(childNode);\n}\n\nexport type BIP44AddressKeyDeriver = {\n  /**\n   * @param address_index - The `address_index` value.\n   * @param isHardened - Whether the derived index is hardened.\n   * @returns The key corresponding to the path of this deriver and the\n   * specified `address_index` value.\n   */\n  (address_index: number, isHardened?: boolean): Promise<BIP44Node>;\n\n  /**\n   * A human-readable representation of the derivation path of this deriver\n   * function, excluding the `address_index`, which is parameterized.\n   *\n   * Recall that a BIP-44 HD tree path consists of the following nodes:\n   *\n   * `m / 44' / coin_type' / account' / change / address_index`\n   *\n   * With the following depths:\n   *\n   * `0 / 1 / 2 / 3 / 4 / 5`\n   */\n  path: ReturnType<typeof getBIP44ChangePathString>;\n\n  /**\n   * The `coin_type` index of addresses derived by this deriver function.\n   */\n  coin_type: number;\n};\n\n/**\n * Creates a function that derives BIP-44 address keys corresponding to the\n * specified derivation path, given either by a {@link BIP44CoinTypeNode} or\n * derivation path tuple.\n *\n * Recall that a BIP-44 HD tree path consists of the following nodes:\n *\n * `m / 44' / coin_type' / account' / change / address_index`\n *\n * With the following depths:\n *\n * `0 / 1 / 2 / 3 / 4 / 5`\n *\n * @param node - The {@link BIP44CoinTypeNode} to derive address keys from.\n * This node contains a BIP-44 key of depth 2, `coin_type`.\n * @param accountAndChangeIndices - The `account` and `change` indices that\n * will be used to derive addresses.\n * @returns The deriver function for the derivation path specified by the\n * `coin_type` node, `account`, and `change` indices.\n */\nexport async function getBIP44AddressKeyDeriver(\n  node: BIP44CoinTypeNode | JsonBIP44CoinTypeNode | string,\n  accountAndChangeIndices?: Omit<CoinTypeToAddressIndices, 'address_index'>,\n) {\n  const { account = 0, change = 0 } = accountAndChangeIndices ?? {};\n\n  const actualNode = await getNode(node);\n\n  const accountNode = getHardenedBIP32NodeToken(account);\n  const changeNode = getBIP32NodeToken(change);\n\n  const bip44AddressKeyDeriver: BIP44AddressKeyDeriver = async (\n    address_index: number,\n    isHardened = false,\n  ): Promise<BIP44Node> => {\n    const slip10Node = await deriveChildNode({\n      path: [\n        accountNode,\n        changeNode,\n        isHardened\n          ? getHardenedBIP32NodeToken(address_index)\n          : getUnhardenedBIP32NodeToken(address_index),\n      ],\n      node: actualNode,\n    });\n\n    return new BIP44Node(slip10Node);\n  };\n\n  bip44AddressKeyDeriver.coin_type = actualNode.coin_type;\n  bip44AddressKeyDeriver.path = getBIP44ChangePathString(actualNode.path, {\n    account,\n    change,\n  });\n\n  Object.freeze(bip44AddressKeyDeriver);\n\n  return bip44AddressKeyDeriver;\n}\n\n/**\n * Get a BIP-44 coin type node from a JSON node or extended key string. If an existing coin type\n * node is provided, the same node is returned.\n *\n * The depth of the node is validated to be a valid coin type node.\n *\n * @param node - A BIP-44 coin type node, JSON node or extended key.\n */\nasync function getNode(\n  node: BIP44CoinTypeNode | JsonBIP44CoinTypeNode | string,\n): Promise<BIP44CoinTypeNode> {\n  if (node instanceof BIP44CoinTypeNode) {\n    validateCoinTypeNodeDepth(node.depth);\n\n    return node;\n  }\n\n  if (typeof node === 'string') {\n    const bip44Node = await BIP44Node.fromExtendedKey(node);\n    const coinTypeNode = await BIP44CoinTypeNode.fromNode(\n      bip44Node,\n      bip44Node.index - BIP_32_HARDENED_OFFSET,\n    );\n\n    validateCoinTypeNodeDepth(coinTypeNode.depth);\n\n    return coinTypeNode;\n  }\n\n  return BIP44CoinTypeNode.fromJSON(node, node.coin_type);\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"BIP44CoinTypeNode.cjs","sourceRoot":"","sources":["../src/BIP44CoinTypeNode.ts"],"names":[],"mappings":"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","sourcesContent":["import { assert } from '@metamask/utils';\n\nimport type { BIP44NodeInterface, JsonBIP44Node } from './BIP44Node';\nimport { BIP44Node } from './BIP44Node';\nimport type {\n  BIP39Node,\n  BIP44Depth,\n  BIP44PurposeNodeToken,\n  CoinTypeHDPathString,\n  HardenedBIP32Node,\n} from './constants';\nimport { BIP_32_HARDENED_OFFSET } from './constants';\nimport type { CryptographicFunctions } from './cryptography';\nimport type { SupportedCurve } from './curves';\nimport { deriveChildNode } from './SLIP10Node';\nimport type { CoinTypeToAddressIndices } from './utils';\nimport {\n  getBIP32NodeToken,\n  getBIP44ChangePathString,\n  getBIP44CoinTypePathString,\n  getBIP44CoinTypeToAddressPathTuple,\n  getHardenedBIP32NodeToken,\n  getUnhardenedBIP32NodeToken,\n  hexStringToBytes,\n  nullableHexStringToBytes,\n} from './utils';\n\nexport type CoinTypeHDPathTuple = [\n  BIP39Node,\n  typeof BIP44PurposeNodeToken,\n  HardenedBIP32Node,\n];\n\nexport const BIP_44_COIN_TYPE_DEPTH = 2;\n\nexport type JsonBIP44CoinTypeNode = JsonBIP44Node & {\n  readonly coin_type: number;\n  readonly path: CoinTypeHDPathString;\n};\n\nexport type BIP44CoinTypeNodeInterface = BIP44NodeInterface & {\n  readonly coin_type: number;\n  readonly path: CoinTypeHDPathString;\n};\n\n/**\n * A wrapper object for BIP-44 `coin_type` keys. `coin_type` is the index\n * specifying the protocol for which deeper keys are intended. For the\n * authoritative list of coin types, please see\n * [SLIP-44](https://github.com/satoshilabs/slips/blob/master/slip-0044.md).\n *\n * Recall that a BIP-44 HD tree path consists of the following nodes:\n *\n * `m / 44' / coin_type' / account' / change / address_index`\n *\n * With the following depths:\n *\n * `0 / 1 / 2 / 3 / 4 / 5`\n *\n */\nexport class BIP44CoinTypeNode implements BIP44CoinTypeNodeInterface {\n  /**\n   * Constructs a BIP-44 `coin_type` node. `coin_type` is the index\n   * specifying the protocol for which deeper keys are intended. For the\n   * authoritative list of coin types, please see\n   * [SLIP-44](https://github.com/satoshilabs/slips/blob/master/slip-0044.md).\n   *\n   * Recall that a BIP-44 HD tree path consists of the following nodes:\n   *\n   * `m / 44' / coin_type' / account' / change / address_index`\n   *\n   * With the following depths:\n   *\n   * `0 / 1 / 2 / 3 / 4 / 5`\n   *\n   * @param json - The {@link JsonBIP44Node} for the key of this node.\n   * @param coin_type - The coin_type index of this node. Must be a non-negative\n   * integer.\n   * @param cryptographicFunctions - The cryptographic functions to use. If\n   * provided, these will be used instead of the built-in implementations.\n   * @returns A BIP44CoinType node.\n   */\n  static async fromJSON(\n    json: JsonBIP44Node,\n    coin_type: number,\n    cryptographicFunctions?: CryptographicFunctions,\n  ): Promise<BIP44CoinTypeNode> {\n    validateCoinType(coin_type);\n    validateCoinTypeNodeDepth(json.depth);\n\n    const node = await BIP44Node.fromExtendedKey(\n      {\n        depth: json.depth,\n        index: json.index,\n        parentFingerprint: json.parentFingerprint,\n        chainCode: hexStringToBytes(json.chainCode),\n        privateKey: nullableHexStringToBytes(json.privateKey),\n        publicKey: hexStringToBytes(json.publicKey),\n      },\n      cryptographicFunctions,\n    );\n\n    return new BIP44CoinTypeNode(node, coin_type);\n  }\n\n  /**\n   * Constructs a BIP-44 `coin_type` node. `coin_type` is the index\n   * specifying the protocol for which deeper keys are intended. For the\n   * authoritative list of coin types, please see\n   * [SLIP-44](https://github.com/satoshilabs/slips/blob/master/slip-0044.md).\n   *\n   * Recall that a BIP-44 HD tree path consists of the following nodes:\n   *\n   * `m / 44' / coin_type' / account' / change / address_index`\n   *\n   * With the following depths:\n   *\n   * `0 / 1 / 2 / 3 / 4 / 5`\n   *\n   * @param derivationPath - The derivation path for the key of this node.\n   * @param cryptographicFunctions - The cryptographic functions to use. If\n   * provided, these will be used instead of the built-in implementations.\n   * @returns A BIP44CoinType node.\n   */\n  static async fromDerivationPath(\n    derivationPath: CoinTypeHDPathTuple,\n    cryptographicFunctions?: CryptographicFunctions,\n  ): Promise<BIP44CoinTypeNode> {\n    validateCoinTypeNodeDepth(derivationPath.length - 1);\n\n    const node = await BIP44Node.fromDerivationPath(\n      {\n        derivationPath,\n      },\n      cryptographicFunctions,\n    );\n\n    // Split the bip32 string token and extract the coin_type index.\n    const pathPart = derivationPath[BIP_44_COIN_TYPE_DEPTH].split(\n      ':',\n    )[1]?.replace(`'`, '');\n\n    assert(pathPart, 'Invalid derivation path.');\n    const coinType = Number.parseInt(pathPart, 10);\n\n    return new BIP44CoinTypeNode(node, coinType);\n  }\n\n  /**\n   * Constructs a BIP-44 `coin_type` node. `coin_type` is the index\n   * specifying the protocol for which deeper keys are intended. For the\n   * authoritative list of coin types, please see\n   * [SLIP-44](https://github.com/satoshilabs/slips/blob/master/slip-0044.md).\n   *\n   * Recall that a BIP-44 HD tree path consists of the following nodes:\n   *\n   * `m / 44' / coin_type' / account' / change / address_index`\n   *\n   * With the following depths:\n   *\n   * `0 / 1 / 2 / 3 / 4 / 5`\n   *\n   * @param node - The {@link BIP44Node} for the key of this node.\n   * @param coin_type - The coin_type index of this node. Must be a non-negative\n   * integer.\n   * @returns A BIP44CoinType node.\n   */\n  static async fromNode(\n    node: BIP44Node,\n    coin_type: number,\n  ): Promise<BIP44CoinTypeNode> {\n    if (!(node instanceof BIP44Node)) {\n      throw new Error('Invalid node: Expected an instance of BIP44Node.');\n    }\n\n    validateCoinType(coin_type);\n    validateCoinTypeNodeDepth(node.depth);\n\n    // TODO: Make this function not async in a future version.\n    return Promise.resolve(new BIP44CoinTypeNode(node, coin_type));\n  }\n\n  readonly #node: BIP44Node;\n\n  public readonly path: CoinTypeHDPathString;\n\n  public readonly coin_type: number;\n\n  // Constructors cannot use hash names.\n  // eslint-disable-next-line no-restricted-syntax\n  private constructor(node: BIP44Node, coin_type: number) {\n    this.#node = node;\n    this.coin_type = coin_type;\n    this.path = getBIP44CoinTypePathString(coin_type);\n\n    Object.freeze(this);\n  }\n\n  public get depth(): BIP44Depth {\n    return this.#node.depth;\n  }\n\n  public get privateKeyBytes(): Uint8Array | undefined {\n    return this.#node.privateKeyBytes;\n  }\n\n  public get publicKeyBytes(): Uint8Array {\n    return this.#node.publicKeyBytes;\n  }\n\n  public get chainCodeBytes(): Uint8Array {\n    return this.#node.chainCodeBytes;\n  }\n\n  public get privateKey(): string | undefined {\n    return this.#node.privateKey;\n  }\n\n  public get publicKey(): string {\n    return this.#node.publicKey;\n  }\n\n  public get compressedPublicKey(): string {\n    return this.#node.compressedPublicKey;\n  }\n\n  public get compressedPublicKeyBytes(): Uint8Array {\n    return this.#node.compressedPublicKeyBytes;\n  }\n\n  public get chainCode(): string {\n    return this.#node.chainCode;\n  }\n\n  public get address(): string {\n    return this.#node.address;\n  }\n\n  public get masterFingerprint(): number | undefined {\n    return this.#node.masterFingerprint;\n  }\n\n  public get parentFingerprint(): number {\n    return this.#node.parentFingerprint;\n  }\n\n  public get fingerprint(): number {\n    return this.#node.fingerprint;\n  }\n\n  public get index(): number {\n    return this.#node.index;\n  }\n\n  public get curve(): SupportedCurve {\n    return this.#node.curve;\n  }\n\n  public get extendedKey(): string {\n    return this.#node.extendedKey;\n  }\n\n  /**\n   * Derives a BIP-44 `address_index` key corresponding to the path of this\n   * node and the specified `account`, `change`, and `address_index` values.\n   * `address_index` keys are normally the keys used to generate user account\n   * addresses.\n   *\n   * Recall that a BIP-44 HD tree path consists of the following nodes:\n   *\n   * `m / 44' / coin_type' / account' / change / address_index`\n   *\n   * With the following depths:\n   *\n   * `0 / 1 / 2 / 3 / 4 / 5`\n   *\n   * @param indices - The BIP-44 index values to use in key derivation.\n   * @param indices.account - The `account` index. Default: `0`\n   * @param indices.change - The `change` index. Default: `0`\n   * @param indices.address_index - The `address_index` index.\n   * @returns The derived BIP-44 `address_index` node.\n   */\n  async deriveBIP44AddressKey({\n    account = 0,\n    change = 0,\n    address_index,\n  }: CoinTypeToAddressIndices): Promise<BIP44Node> {\n    return await this.#node.derive(\n      getBIP44CoinTypeToAddressPathTuple({ account, change, address_index }),\n    );\n  }\n\n  toJSON(): JsonBIP44CoinTypeNode {\n    return {\n      ...this.#node.toJSON(),\n      coin_type: this.coin_type,\n      path: this.path,\n    };\n  }\n}\n\n/**\n * Validates the depth of a `coin_type` node. Simply, ensures that it is the\n * number `2`. An error is thrown if validation fails.\n *\n * @param depth - The depth to validate.\n */\nfunction validateCoinTypeNodeDepth(depth: number): void {\n  if (depth !== BIP_44_COIN_TYPE_DEPTH) {\n    throw new Error(\n      `Invalid depth: Coin type nodes must be of depth ${BIP_44_COIN_TYPE_DEPTH}. Received: \"${depth}\"`,\n    );\n  }\n}\n\n/**\n * Validates that the coin type is a non-negative integer number. An error is\n * thrown if validation fails.\n *\n * @param coin_type - The coin type to validate.\n */\nfunction validateCoinType(coin_type: unknown): asserts coin_type is number {\n  if (\n    typeof coin_type !== 'number' ||\n    !Number.isInteger(coin_type) ||\n    coin_type < 0\n  ) {\n    throw new Error(\n      'Invalid coin type: The specified coin type must be a non-negative integer number.',\n    );\n  }\n}\n\n/**\n * Derives a BIP-44 address key corresponding to the specified derivation path,\n * given either by a {@link BIP44CoinTypeNode} or derivation path tuple.\n *\n * Recall that a BIP-44 HD tree path consists of the following nodes:\n *\n * `m / 44' / coin_type' / account' / change / address_index`\n *\n * With the following depths:\n *\n * `0 / 1 / 2 / 3 / 4 / 5`\n *\n * @param parentKeyOrNode - The `coin_type` parent key to derive from.\n * @param indices - The BIP-44 index values to use in key derivation.\n * @param indices.account - The `account` index. Default: `0`.\n * @param indices.change - The `change` index. Default: `0`.\n * @param indices.address_index - The `address_index` index.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The derived `address_index` key for the specified derivation path.\n */\nexport async function deriveBIP44AddressKey(\n  parentKeyOrNode: BIP44CoinTypeNode | JsonBIP44CoinTypeNode | string,\n  { account = 0, change = 0, address_index }: CoinTypeToAddressIndices,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<BIP44Node> {\n  const path = getBIP44CoinTypeToAddressPathTuple({\n    account,\n    change,\n    address_index,\n  });\n\n  const node = await getNode(parentKeyOrNode, cryptographicFunctions);\n  const childNode = await deriveChildNode(\n    {\n      path,\n      node,\n    },\n    cryptographicFunctions,\n  );\n\n  return new BIP44Node(childNode);\n}\n\nexport type BIP44AddressKeyDeriver = {\n  /**\n   * @param address_index - The `address_index` value.\n   * @param isHardened - Whether the derived index is hardened.\n   * @returns The key corresponding to the path of this deriver and the\n   * specified `address_index` value.\n   */\n  (address_index: number, isHardened?: boolean): Promise<BIP44Node>;\n\n  /**\n   * A human-readable representation of the derivation path of this deriver\n   * function, excluding the `address_index`, which is parameterized.\n   *\n   * Recall that a BIP-44 HD tree path consists of the following nodes:\n   *\n   * `m / 44' / coin_type' / account' / change / address_index`\n   *\n   * With the following depths:\n   *\n   * `0 / 1 / 2 / 3 / 4 / 5`\n   */\n  path: ReturnType<typeof getBIP44ChangePathString>;\n\n  /**\n   * The `coin_type` index of addresses derived by this deriver function.\n   */\n  coin_type: number;\n};\n\n/**\n * Creates a function that derives BIP-44 address keys corresponding to the\n * specified derivation path, given either by a {@link BIP44CoinTypeNode} or\n * derivation path tuple.\n *\n * Recall that a BIP-44 HD tree path consists of the following nodes:\n *\n * `m / 44' / coin_type' / account' / change / address_index`\n *\n * With the following depths:\n *\n * `0 / 1 / 2 / 3 / 4 / 5`\n *\n * @param node - The {@link BIP44CoinTypeNode} to derive address keys from.\n * This node contains a BIP-44 key of depth 2, `coin_type`.\n * @param accountAndChangeIndices - The `account` and `change` indices that\n * will be used to derive addresses.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The deriver function for the derivation path specified by the\n * `coin_type` node, `account`, and `change` indices.\n */\nexport async function getBIP44AddressKeyDeriver(\n  node: BIP44CoinTypeNode | JsonBIP44CoinTypeNode | string,\n  accountAndChangeIndices?: Omit<CoinTypeToAddressIndices, 'address_index'>,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<BIP44AddressKeyDeriver> {\n  const { account = 0, change = 0 } = accountAndChangeIndices ?? {};\n\n  const actualNode = await getNode(node, cryptographicFunctions);\n\n  const accountNode = getHardenedBIP32NodeToken(account);\n  const changeNode = getBIP32NodeToken(change);\n\n  const bip44AddressKeyDeriver: BIP44AddressKeyDeriver = async (\n    address_index: number,\n    isHardened = false,\n  ): Promise<BIP44Node> => {\n    const slip10Node = await deriveChildNode(\n      {\n        path: [\n          accountNode,\n          changeNode,\n          isHardened\n            ? getHardenedBIP32NodeToken(address_index)\n            : getUnhardenedBIP32NodeToken(address_index),\n        ],\n        node: actualNode,\n      },\n      cryptographicFunctions,\n    );\n\n    return new BIP44Node(slip10Node);\n  };\n\n  bip44AddressKeyDeriver.coin_type = actualNode.coin_type;\n  bip44AddressKeyDeriver.path = getBIP44ChangePathString(actualNode.path, {\n    account,\n    change,\n  });\n\n  Object.freeze(bip44AddressKeyDeriver);\n\n  return bip44AddressKeyDeriver;\n}\n\n/**\n * Get a BIP-44 coin type node from a JSON node or extended key string. If an existing coin type\n * node is provided, the same node is returned.\n *\n * The depth of the node is validated to be a valid coin type node.\n *\n * @param node - A BIP-44 coin type node, JSON node or extended key.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations. This is\n * only used if the node is an extended key string or JSON object.\n * @returns A BIP44CoinType node.\n */\nasync function getNode(\n  node: BIP44CoinTypeNode | JsonBIP44CoinTypeNode | string,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<BIP44CoinTypeNode> {\n  if (node instanceof BIP44CoinTypeNode) {\n    validateCoinTypeNodeDepth(node.depth);\n\n    return node;\n  }\n\n  if (typeof node === 'string') {\n    const bip44Node = await BIP44Node.fromExtendedKey(\n      node,\n      cryptographicFunctions,\n    );\n    const coinTypeNode = await BIP44CoinTypeNode.fromNode(\n      bip44Node,\n      bip44Node.index - BIP_32_HARDENED_OFFSET,\n    );\n\n    validateCoinTypeNodeDepth(coinTypeNode.depth);\n\n    return coinTypeNode;\n  }\n\n  return BIP44CoinTypeNode.fromJSON(\n    node,\n    node.coin_type,\n    cryptographicFunctions,\n  );\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/BIP44CoinTypeNode.d.cts b/node_modules/@metamask/key-tree/dist/BIP44CoinTypeNode.d.cts
index 9831233..437fa55 100644
--- a/node_modules/@metamask/key-tree/dist/BIP44CoinTypeNode.d.cts
+++ b/node_modules/@metamask/key-tree/dist/BIP44CoinTypeNode.d.cts
@@ -1,20 +1,21 @@
 import type { BIP44NodeInterface, JsonBIP44Node } from "./BIP44Node.cjs";
 import { BIP44Node } from "./BIP44Node.cjs";
 import type { BIP39Node, BIP44Depth, BIP44PurposeNodeToken, CoinTypeHDPathString, HardenedBIP32Node } from "./constants.cjs";
+import type { CryptographicFunctions } from "./cryptography.cjs";
 import type { SupportedCurve } from "./curves/index.cjs";
 import type { CoinTypeToAddressIndices } from "./utils.cjs";
 import { getBIP44ChangePathString } from "./utils.cjs";
-export declare type CoinTypeHDPathTuple = [
+export type CoinTypeHDPathTuple = [
     BIP39Node,
     typeof BIP44PurposeNodeToken,
     HardenedBIP32Node
 ];
 export declare const BIP_44_COIN_TYPE_DEPTH = 2;
-export declare type JsonBIP44CoinTypeNode = JsonBIP44Node & {
+export type JsonBIP44CoinTypeNode = JsonBIP44Node & {
     readonly coin_type: number;
     readonly path: CoinTypeHDPathString;
 };
-export declare type BIP44CoinTypeNodeInterface = BIP44NodeInterface & {
+export type BIP44CoinTypeNodeInterface = BIP44NodeInterface & {
     readonly coin_type: number;
     readonly path: CoinTypeHDPathString;
 };
@@ -52,8 +53,11 @@ export declare class BIP44CoinTypeNode implements BIP44CoinTypeNodeInterface {
      * @param json - The {@link JsonBIP44Node} for the key of this node.
      * @param coin_type - The coin_type index of this node. Must be a non-negative
      * integer.
+     * @param cryptographicFunctions - The cryptographic functions to use. If
+     * provided, these will be used instead of the built-in implementations.
+     * @returns A BIP44CoinType node.
      */
-    static fromJSON(json: JsonBIP44Node, coin_type: number): Promise<BIP44CoinTypeNode>;
+    static fromJSON(json: JsonBIP44Node, coin_type: number, cryptographicFunctions?: CryptographicFunctions): Promise<BIP44CoinTypeNode>;
     /**
      * Constructs a BIP-44 `coin_type` node. `coin_type` is the index
      * specifying the protocol for which deeper keys are intended. For the
@@ -69,8 +73,11 @@ export declare class BIP44CoinTypeNode implements BIP44CoinTypeNodeInterface {
      * `0 / 1 / 2 / 3 / 4 / 5`
      *
      * @param derivationPath - The derivation path for the key of this node.
+     * @param cryptographicFunctions - The cryptographic functions to use. If
+     * provided, these will be used instead of the built-in implementations.
+     * @returns A BIP44CoinType node.
      */
-    static fromDerivationPath(derivationPath: CoinTypeHDPathTuple): Promise<BIP44CoinTypeNode>;
+    static fromDerivationPath(derivationPath: CoinTypeHDPathTuple, cryptographicFunctions?: CryptographicFunctions): Promise<BIP44CoinTypeNode>;
     /**
      * Constructs a BIP-44 `coin_type` node. `coin_type` is the index
      * specifying the protocol for which deeper keys are intended. For the
@@ -88,6 +95,7 @@ export declare class BIP44CoinTypeNode implements BIP44CoinTypeNodeInterface {
      * @param node - The {@link BIP44Node} for the key of this node.
      * @param coin_type - The coin_type index of this node. Must be a non-negative
      * integer.
+     * @returns A BIP44CoinType node.
      */
     static fromNode(node: BIP44Node, coin_type: number): Promise<BIP44CoinTypeNode>;
     readonly path: CoinTypeHDPathString;
@@ -149,10 +157,12 @@ export declare class BIP44CoinTypeNode implements BIP44CoinTypeNodeInterface {
  * @param indices.account - The `account` index. Default: `0`.
  * @param indices.change - The `change` index. Default: `0`.
  * @param indices.address_index - The `address_index` index.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The derived `address_index` key for the specified derivation path.
  */
-export declare function deriveBIP44AddressKey(parentKeyOrNode: BIP44CoinTypeNode | JsonBIP44CoinTypeNode | string, { account, change, address_index }: CoinTypeToAddressIndices): Promise<BIP44Node>;
-export declare type BIP44AddressKeyDeriver = {
+export declare function deriveBIP44AddressKey(parentKeyOrNode: BIP44CoinTypeNode | JsonBIP44CoinTypeNode | string, { account, change, address_index }: CoinTypeToAddressIndices, cryptographicFunctions?: CryptographicFunctions): Promise<BIP44Node>;
+export type BIP44AddressKeyDeriver = {
     /**
      * @param address_index - The `address_index` value.
      * @param isHardened - Whether the derived index is hardened.
@@ -195,8 +205,10 @@ export declare type BIP44AddressKeyDeriver = {
  * This node contains a BIP-44 key of depth 2, `coin_type`.
  * @param accountAndChangeIndices - The `account` and `change` indices that
  * will be used to derive addresses.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The deriver function for the derivation path specified by the
  * `coin_type` node, `account`, and `change` indices.
  */
-export declare function getBIP44AddressKeyDeriver(node: BIP44CoinTypeNode | JsonBIP44CoinTypeNode | string, accountAndChangeIndices?: Omit<CoinTypeToAddressIndices, 'address_index'>): Promise<BIP44AddressKeyDeriver>;
+export declare function getBIP44AddressKeyDeriver(node: BIP44CoinTypeNode | JsonBIP44CoinTypeNode | string, accountAndChangeIndices?: Omit<CoinTypeToAddressIndices, 'address_index'>, cryptographicFunctions?: CryptographicFunctions): Promise<BIP44AddressKeyDeriver>;
 //# sourceMappingURL=BIP44CoinTypeNode.d.cts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/BIP44CoinTypeNode.d.cts.map b/node_modules/@metamask/key-tree/dist/BIP44CoinTypeNode.d.cts.map
index 5b9c2fb..7f736db 100644
--- a/node_modules/@metamask/key-tree/dist/BIP44CoinTypeNode.d.cts.map
+++ b/node_modules/@metamask/key-tree/dist/BIP44CoinTypeNode.d.cts.map
@@ -1 +1 @@
-{"version":3,"file":"BIP44CoinTypeNode.d.cts","sourceRoot":"","sources":["../src/BIP44CoinTypeNode.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"BIP44CoinTypeNode.d.cts","sourceRoot":"","sources":["../src/BIP44CoinTypeNode.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/BIP44CoinTypeNode.d.mts b/node_modules/@metamask/key-tree/dist/BIP44CoinTypeNode.d.mts
index 8811f22..d203b63 100644
--- a/node_modules/@metamask/key-tree/dist/BIP44CoinTypeNode.d.mts
+++ b/node_modules/@metamask/key-tree/dist/BIP44CoinTypeNode.d.mts
@@ -1,20 +1,21 @@
 import type { BIP44NodeInterface, JsonBIP44Node } from "./BIP44Node.mjs";
 import { BIP44Node } from "./BIP44Node.mjs";
 import type { BIP39Node, BIP44Depth, BIP44PurposeNodeToken, CoinTypeHDPathString, HardenedBIP32Node } from "./constants.mjs";
+import type { CryptographicFunctions } from "./cryptography.mjs";
 import type { SupportedCurve } from "./curves/index.mjs";
 import type { CoinTypeToAddressIndices } from "./utils.mjs";
 import { getBIP44ChangePathString } from "./utils.mjs";
-export declare type CoinTypeHDPathTuple = [
+export type CoinTypeHDPathTuple = [
     BIP39Node,
     typeof BIP44PurposeNodeToken,
     HardenedBIP32Node
 ];
 export declare const BIP_44_COIN_TYPE_DEPTH = 2;
-export declare type JsonBIP44CoinTypeNode = JsonBIP44Node & {
+export type JsonBIP44CoinTypeNode = JsonBIP44Node & {
     readonly coin_type: number;
     readonly path: CoinTypeHDPathString;
 };
-export declare type BIP44CoinTypeNodeInterface = BIP44NodeInterface & {
+export type BIP44CoinTypeNodeInterface = BIP44NodeInterface & {
     readonly coin_type: number;
     readonly path: CoinTypeHDPathString;
 };
@@ -52,8 +53,11 @@ export declare class BIP44CoinTypeNode implements BIP44CoinTypeNodeInterface {
      * @param json - The {@link JsonBIP44Node} for the key of this node.
      * @param coin_type - The coin_type index of this node. Must be a non-negative
      * integer.
+     * @param cryptographicFunctions - The cryptographic functions to use. If
+     * provided, these will be used instead of the built-in implementations.
+     * @returns A BIP44CoinType node.
      */
-    static fromJSON(json: JsonBIP44Node, coin_type: number): Promise<BIP44CoinTypeNode>;
+    static fromJSON(json: JsonBIP44Node, coin_type: number, cryptographicFunctions?: CryptographicFunctions): Promise<BIP44CoinTypeNode>;
     /**
      * Constructs a BIP-44 `coin_type` node. `coin_type` is the index
      * specifying the protocol for which deeper keys are intended. For the
@@ -69,8 +73,11 @@ export declare class BIP44CoinTypeNode implements BIP44CoinTypeNodeInterface {
      * `0 / 1 / 2 / 3 / 4 / 5`
      *
      * @param derivationPath - The derivation path for the key of this node.
+     * @param cryptographicFunctions - The cryptographic functions to use. If
+     * provided, these will be used instead of the built-in implementations.
+     * @returns A BIP44CoinType node.
      */
-    static fromDerivationPath(derivationPath: CoinTypeHDPathTuple): Promise<BIP44CoinTypeNode>;
+    static fromDerivationPath(derivationPath: CoinTypeHDPathTuple, cryptographicFunctions?: CryptographicFunctions): Promise<BIP44CoinTypeNode>;
     /**
      * Constructs a BIP-44 `coin_type` node. `coin_type` is the index
      * specifying the protocol for which deeper keys are intended. For the
@@ -88,6 +95,7 @@ export declare class BIP44CoinTypeNode implements BIP44CoinTypeNodeInterface {
      * @param node - The {@link BIP44Node} for the key of this node.
      * @param coin_type - The coin_type index of this node. Must be a non-negative
      * integer.
+     * @returns A BIP44CoinType node.
      */
     static fromNode(node: BIP44Node, coin_type: number): Promise<BIP44CoinTypeNode>;
     readonly path: CoinTypeHDPathString;
@@ -149,10 +157,12 @@ export declare class BIP44CoinTypeNode implements BIP44CoinTypeNodeInterface {
  * @param indices.account - The `account` index. Default: `0`.
  * @param indices.change - The `change` index. Default: `0`.
  * @param indices.address_index - The `address_index` index.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The derived `address_index` key for the specified derivation path.
  */
-export declare function deriveBIP44AddressKey(parentKeyOrNode: BIP44CoinTypeNode | JsonBIP44CoinTypeNode | string, { account, change, address_index }: CoinTypeToAddressIndices): Promise<BIP44Node>;
-export declare type BIP44AddressKeyDeriver = {
+export declare function deriveBIP44AddressKey(parentKeyOrNode: BIP44CoinTypeNode | JsonBIP44CoinTypeNode | string, { account, change, address_index }: CoinTypeToAddressIndices, cryptographicFunctions?: CryptographicFunctions): Promise<BIP44Node>;
+export type BIP44AddressKeyDeriver = {
     /**
      * @param address_index - The `address_index` value.
      * @param isHardened - Whether the derived index is hardened.
@@ -195,8 +205,10 @@ export declare type BIP44AddressKeyDeriver = {
  * This node contains a BIP-44 key of depth 2, `coin_type`.
  * @param accountAndChangeIndices - The `account` and `change` indices that
  * will be used to derive addresses.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The deriver function for the derivation path specified by the
  * `coin_type` node, `account`, and `change` indices.
  */
-export declare function getBIP44AddressKeyDeriver(node: BIP44CoinTypeNode | JsonBIP44CoinTypeNode | string, accountAndChangeIndices?: Omit<CoinTypeToAddressIndices, 'address_index'>): Promise<BIP44AddressKeyDeriver>;
+export declare function getBIP44AddressKeyDeriver(node: BIP44CoinTypeNode | JsonBIP44CoinTypeNode | string, accountAndChangeIndices?: Omit<CoinTypeToAddressIndices, 'address_index'>, cryptographicFunctions?: CryptographicFunctions): Promise<BIP44AddressKeyDeriver>;
 //# sourceMappingURL=BIP44CoinTypeNode.d.mts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/BIP44CoinTypeNode.d.mts.map b/node_modules/@metamask/key-tree/dist/BIP44CoinTypeNode.d.mts.map
index 0b08969..8973bb8 100644
--- a/node_modules/@metamask/key-tree/dist/BIP44CoinTypeNode.d.mts.map
+++ b/node_modules/@metamask/key-tree/dist/BIP44CoinTypeNode.d.mts.map
@@ -1 +1 @@
-{"version":3,"file":"BIP44CoinTypeNode.d.mts","sourceRoot":"","sources":["../src/BIP44CoinTypeNode.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"BIP44CoinTypeNode.d.mts","sourceRoot":"","sources":["../src/BIP44CoinTypeNode.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/BIP44CoinTypeNode.mjs b/node_modules/@metamask/key-tree/dist/BIP44CoinTypeNode.mjs
index 127f727..9f9d6bd 100644
--- a/node_modules/@metamask/key-tree/dist/BIP44CoinTypeNode.mjs
+++ b/node_modules/@metamask/key-tree/dist/BIP44CoinTypeNode.mjs
@@ -32,15 +32,6 @@ export const BIP_44_COIN_TYPE_DEPTH = 2;
  *
  */
 export class BIP44CoinTypeNode {
-    // Constructors cannot use hash names.
-    // eslint-disable-next-line no-restricted-syntax
-    constructor(node, coin_type) {
-        _BIP44CoinTypeNode_node.set(this, void 0);
-        __classPrivateFieldSet(this, _BIP44CoinTypeNode_node, node, "f");
-        this.coin_type = coin_type;
-        this.path = getBIP44CoinTypePathString(coin_type);
-        Object.freeze(this);
-    }
     /**
      * Constructs a BIP-44 `coin_type` node. `coin_type` is the index
      * specifying the protocol for which deeper keys are intended. For the
@@ -58,8 +49,11 @@ export class BIP44CoinTypeNode {
      * @param json - The {@link JsonBIP44Node} for the key of this node.
      * @param coin_type - The coin_type index of this node. Must be a non-negative
      * integer.
+     * @param cryptographicFunctions - The cryptographic functions to use. If
+     * provided, these will be used instead of the built-in implementations.
+     * @returns A BIP44CoinType node.
      */
-    static async fromJSON(json, coin_type) {
+    static async fromJSON(json, coin_type, cryptographicFunctions) {
         validateCoinType(coin_type);
         validateCoinTypeNodeDepth(json.depth);
         const node = await BIP44Node.fromExtendedKey({
@@ -69,7 +63,7 @@ export class BIP44CoinTypeNode {
             chainCode: hexStringToBytes(json.chainCode),
             privateKey: nullableHexStringToBytes(json.privateKey),
             publicKey: hexStringToBytes(json.publicKey),
-        });
+        }, cryptographicFunctions);
         return new BIP44CoinTypeNode(node, coin_type);
     }
     /**
@@ -87,12 +81,15 @@ export class BIP44CoinTypeNode {
      * `0 / 1 / 2 / 3 / 4 / 5`
      *
      * @param derivationPath - The derivation path for the key of this node.
+     * @param cryptographicFunctions - The cryptographic functions to use. If
+     * provided, these will be used instead of the built-in implementations.
+     * @returns A BIP44CoinType node.
      */
-    static async fromDerivationPath(derivationPath) {
+    static async fromDerivationPath(derivationPath, cryptographicFunctions) {
         validateCoinTypeNodeDepth(derivationPath.length - 1);
         const node = await BIP44Node.fromDerivationPath({
             derivationPath,
-        });
+        }, cryptographicFunctions);
         // Split the bip32 string token and extract the coin_type index.
         const pathPart = derivationPath[BIP_44_COIN_TYPE_DEPTH].split(':')[1]?.replace(`'`, '');
         assert(pathPart, 'Invalid derivation path.');
@@ -116,6 +113,7 @@ export class BIP44CoinTypeNode {
      * @param node - The {@link BIP44Node} for the key of this node.
      * @param coin_type - The coin_type index of this node. Must be a non-negative
      * integer.
+     * @returns A BIP44CoinType node.
      */
     static async fromNode(node, coin_type) {
         if (!(node instanceof BIP44Node)) {
@@ -126,6 +124,15 @@ export class BIP44CoinTypeNode {
         // TODO: Make this function not async in a future version.
         return Promise.resolve(new BIP44CoinTypeNode(node, coin_type));
     }
+    // Constructors cannot use hash names.
+    // eslint-disable-next-line no-restricted-syntax
+    constructor(node, coin_type) {
+        _BIP44CoinTypeNode_node.set(this, void 0);
+        __classPrivateFieldSet(this, _BIP44CoinTypeNode_node, node, "f");
+        this.coin_type = coin_type;
+        this.path = getBIP44CoinTypePathString(coin_type);
+        Object.freeze(this);
+    }
     get depth() {
         return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").depth;
     }
@@ -247,19 +254,21 @@ function validateCoinType(coin_type) {
  * @param indices.account - The `account` index. Default: `0`.
  * @param indices.change - The `change` index. Default: `0`.
  * @param indices.address_index - The `address_index` index.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The derived `address_index` key for the specified derivation path.
  */
-export async function deriveBIP44AddressKey(parentKeyOrNode, { account = 0, change = 0, address_index }) {
+export async function deriveBIP44AddressKey(parentKeyOrNode, { account = 0, change = 0, address_index }, cryptographicFunctions) {
     const path = getBIP44CoinTypeToAddressPathTuple({
         account,
         change,
         address_index,
     });
-    const node = await getNode(parentKeyOrNode);
+    const node = await getNode(parentKeyOrNode, cryptographicFunctions);
     const childNode = await deriveChildNode({
         path,
         node,
-    });
+    }, cryptographicFunctions);
     return new BIP44Node(childNode);
 }
 /**
@@ -279,12 +288,14 @@ export async function deriveBIP44AddressKey(parentKeyOrNode, { account = 0, chan
  * This node contains a BIP-44 key of depth 2, `coin_type`.
  * @param accountAndChangeIndices - The `account` and `change` indices that
  * will be used to derive addresses.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The deriver function for the derivation path specified by the
  * `coin_type` node, `account`, and `change` indices.
  */
-export async function getBIP44AddressKeyDeriver(node, accountAndChangeIndices) {
+export async function getBIP44AddressKeyDeriver(node, accountAndChangeIndices, cryptographicFunctions) {
     const { account = 0, change = 0 } = accountAndChangeIndices ?? {};
-    const actualNode = await getNode(node);
+    const actualNode = await getNode(node, cryptographicFunctions);
     const accountNode = getHardenedBIP32NodeToken(account);
     const changeNode = getBIP32NodeToken(change);
     const bip44AddressKeyDeriver = async (address_index, isHardened = false) => {
@@ -297,7 +308,7 @@ export async function getBIP44AddressKeyDeriver(node, accountAndChangeIndices) {
                     : getUnhardenedBIP32NodeToken(address_index),
             ],
             node: actualNode,
-        });
+        }, cryptographicFunctions);
         return new BIP44Node(slip10Node);
     };
     bip44AddressKeyDeriver.coin_type = actualNode.coin_type;
@@ -315,18 +326,22 @@ export async function getBIP44AddressKeyDeriver(node, accountAndChangeIndices) {
  * The depth of the node is validated to be a valid coin type node.
  *
  * @param node - A BIP-44 coin type node, JSON node or extended key.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations. This is
+ * only used if the node is an extended key string or JSON object.
+ * @returns A BIP44CoinType node.
  */
-async function getNode(node) {
+async function getNode(node, cryptographicFunctions) {
     if (node instanceof BIP44CoinTypeNode) {
         validateCoinTypeNodeDepth(node.depth);
         return node;
     }
     if (typeof node === 'string') {
-        const bip44Node = await BIP44Node.fromExtendedKey(node);
+        const bip44Node = await BIP44Node.fromExtendedKey(node, cryptographicFunctions);
         const coinTypeNode = await BIP44CoinTypeNode.fromNode(bip44Node, bip44Node.index - BIP_32_HARDENED_OFFSET);
         validateCoinTypeNodeDepth(coinTypeNode.depth);
         return coinTypeNode;
     }
-    return BIP44CoinTypeNode.fromJSON(node, node.coin_type);
+    return BIP44CoinTypeNode.fromJSON(node, node.coin_type, cryptographicFunctions);
 }
 //# sourceMappingURL=BIP44CoinTypeNode.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/BIP44CoinTypeNode.mjs.map b/node_modules/@metamask/key-tree/dist/BIP44CoinTypeNode.mjs.map
index 0602e68..f021329 100644
--- a/node_modules/@metamask/key-tree/dist/BIP44CoinTypeNode.mjs.map
+++ b/node_modules/@metamask/key-tree/dist/BIP44CoinTypeNode.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"BIP44CoinTypeNode.mjs","sourceRoot":"","sources":["../src/BIP44CoinTypeNode.ts"],"names":[],"mappings":"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","sourcesContent":["import { assert } from '@metamask/utils';\n\nimport type { BIP44NodeInterface, JsonBIP44Node } from './BIP44Node';\nimport { BIP44Node } from './BIP44Node';\nimport type {\n  BIP39Node,\n  BIP44Depth,\n  BIP44PurposeNodeToken,\n  CoinTypeHDPathString,\n  HardenedBIP32Node,\n} from './constants';\nimport { BIP_32_HARDENED_OFFSET } from './constants';\nimport type { SupportedCurve } from './curves';\nimport { deriveChildNode } from './SLIP10Node';\nimport type { CoinTypeToAddressIndices } from './utils';\nimport {\n  getBIP32NodeToken,\n  getBIP44ChangePathString,\n  getBIP44CoinTypePathString,\n  getBIP44CoinTypeToAddressPathTuple,\n  getHardenedBIP32NodeToken,\n  getUnhardenedBIP32NodeToken,\n  hexStringToBytes,\n  nullableHexStringToBytes,\n} from './utils';\n\nexport type CoinTypeHDPathTuple = [\n  BIP39Node,\n  typeof BIP44PurposeNodeToken,\n  HardenedBIP32Node,\n];\n\nexport const BIP_44_COIN_TYPE_DEPTH = 2;\n\nexport type JsonBIP44CoinTypeNode = JsonBIP44Node & {\n  readonly coin_type: number;\n  readonly path: CoinTypeHDPathString;\n};\n\nexport type BIP44CoinTypeNodeInterface = BIP44NodeInterface & {\n  readonly coin_type: number;\n  readonly path: CoinTypeHDPathString;\n};\n\n/**\n * A wrapper object for BIP-44 `coin_type` keys. `coin_type` is the index\n * specifying the protocol for which deeper keys are intended. For the\n * authoritative list of coin types, please see\n * [SLIP-44](https://github.com/satoshilabs/slips/blob/master/slip-0044.md).\n *\n * Recall that a BIP-44 HD tree path consists of the following nodes:\n *\n * `m / 44' / coin_type' / account' / change / address_index`\n *\n * With the following depths:\n *\n * `0 / 1 / 2 / 3 / 4 / 5`\n *\n */\nexport class BIP44CoinTypeNode implements BIP44CoinTypeNodeInterface {\n  /**\n   * Constructs a BIP-44 `coin_type` node. `coin_type` is the index\n   * specifying the protocol for which deeper keys are intended. For the\n   * authoritative list of coin types, please see\n   * [SLIP-44](https://github.com/satoshilabs/slips/blob/master/slip-0044.md).\n   *\n   * Recall that a BIP-44 HD tree path consists of the following nodes:\n   *\n   * `m / 44' / coin_type' / account' / change / address_index`\n   *\n   * With the following depths:\n   *\n   * `0 / 1 / 2 / 3 / 4 / 5`\n   *\n   * @param json - The {@link JsonBIP44Node} for the key of this node.\n   * @param coin_type - The coin_type index of this node. Must be a non-negative\n   * integer.\n   */\n  static async fromJSON(json: JsonBIP44Node, coin_type: number) {\n    validateCoinType(coin_type);\n    validateCoinTypeNodeDepth(json.depth);\n\n    const node = await BIP44Node.fromExtendedKey({\n      depth: json.depth,\n      index: json.index,\n      parentFingerprint: json.parentFingerprint,\n      chainCode: hexStringToBytes(json.chainCode),\n      privateKey: nullableHexStringToBytes(json.privateKey),\n      publicKey: hexStringToBytes(json.publicKey),\n    });\n\n    return new BIP44CoinTypeNode(node, coin_type);\n  }\n\n  /**\n   * Constructs a BIP-44 `coin_type` node. `coin_type` is the index\n   * specifying the protocol for which deeper keys are intended. For the\n   * authoritative list of coin types, please see\n   * [SLIP-44](https://github.com/satoshilabs/slips/blob/master/slip-0044.md).\n   *\n   * Recall that a BIP-44 HD tree path consists of the following nodes:\n   *\n   * `m / 44' / coin_type' / account' / change / address_index`\n   *\n   * With the following depths:\n   *\n   * `0 / 1 / 2 / 3 / 4 / 5`\n   *\n   * @param derivationPath - The derivation path for the key of this node.\n   */\n  static async fromDerivationPath(derivationPath: CoinTypeHDPathTuple) {\n    validateCoinTypeNodeDepth(derivationPath.length - 1);\n\n    const node = await BIP44Node.fromDerivationPath({\n      derivationPath,\n    });\n\n    // Split the bip32 string token and extract the coin_type index.\n    const pathPart = derivationPath[BIP_44_COIN_TYPE_DEPTH].split(\n      ':',\n    )[1]?.replace(`'`, '');\n\n    assert(pathPart, 'Invalid derivation path.');\n    const coinType = Number.parseInt(pathPart, 10);\n\n    return new BIP44CoinTypeNode(node, coinType);\n  }\n\n  /**\n   * Constructs a BIP-44 `coin_type` node. `coin_type` is the index\n   * specifying the protocol for which deeper keys are intended. For the\n   * authoritative list of coin types, please see\n   * [SLIP-44](https://github.com/satoshilabs/slips/blob/master/slip-0044.md).\n   *\n   * Recall that a BIP-44 HD tree path consists of the following nodes:\n   *\n   * `m / 44' / coin_type' / account' / change / address_index`\n   *\n   * With the following depths:\n   *\n   * `0 / 1 / 2 / 3 / 4 / 5`\n   *\n   * @param node - The {@link BIP44Node} for the key of this node.\n   * @param coin_type - The coin_type index of this node. Must be a non-negative\n   * integer.\n   */\n  static async fromNode(node: BIP44Node, coin_type: number) {\n    if (!(node instanceof BIP44Node)) {\n      throw new Error('Invalid node: Expected an instance of BIP44Node.');\n    }\n\n    validateCoinType(coin_type);\n    validateCoinTypeNodeDepth(node.depth);\n\n    // TODO: Make this function not async in a future version.\n    return Promise.resolve(new BIP44CoinTypeNode(node, coin_type));\n  }\n\n  readonly #node: BIP44Node;\n\n  public readonly path: CoinTypeHDPathString;\n\n  public readonly coin_type: number;\n\n  // Constructors cannot use hash names.\n  // eslint-disable-next-line no-restricted-syntax\n  private constructor(node: BIP44Node, coin_type: number) {\n    this.#node = node;\n    this.coin_type = coin_type;\n    this.path = getBIP44CoinTypePathString(coin_type);\n\n    Object.freeze(this);\n  }\n\n  public get depth(): BIP44Depth {\n    return this.#node.depth;\n  }\n\n  public get privateKeyBytes(): Uint8Array | undefined {\n    return this.#node.privateKeyBytes;\n  }\n\n  public get publicKeyBytes(): Uint8Array {\n    return this.#node.publicKeyBytes;\n  }\n\n  public get chainCodeBytes(): Uint8Array {\n    return this.#node.chainCodeBytes;\n  }\n\n  public get privateKey(): string | undefined {\n    return this.#node.privateKey;\n  }\n\n  public get publicKey(): string {\n    return this.#node.publicKey;\n  }\n\n  public get compressedPublicKey(): string {\n    return this.#node.compressedPublicKey;\n  }\n\n  public get compressedPublicKeyBytes(): Uint8Array {\n    return this.#node.compressedPublicKeyBytes;\n  }\n\n  public get chainCode(): string {\n    return this.#node.chainCode;\n  }\n\n  public get address(): string {\n    return this.#node.address;\n  }\n\n  public get masterFingerprint(): number | undefined {\n    return this.#node.masterFingerprint;\n  }\n\n  public get parentFingerprint(): number {\n    return this.#node.parentFingerprint;\n  }\n\n  public get fingerprint(): number {\n    return this.#node.fingerprint;\n  }\n\n  public get index(): number {\n    return this.#node.index;\n  }\n\n  public get curve(): SupportedCurve {\n    return this.#node.curve;\n  }\n\n  public get extendedKey(): string {\n    return this.#node.extendedKey;\n  }\n\n  /**\n   * Derives a BIP-44 `address_index` key corresponding to the path of this\n   * node and the specified `account`, `change`, and `address_index` values.\n   * `address_index` keys are normally the keys used to generate user account\n   * addresses.\n   *\n   * Recall that a BIP-44 HD tree path consists of the following nodes:\n   *\n   * `m / 44' / coin_type' / account' / change / address_index`\n   *\n   * With the following depths:\n   *\n   * `0 / 1 / 2 / 3 / 4 / 5`\n   *\n   * @param indices - The BIP-44 index values to use in key derivation.\n   * @param indices.account - The `account` index. Default: `0`\n   * @param indices.change - The `change` index. Default: `0`\n   * @param indices.address_index - The `address_index` index.\n   * @returns The derived BIP-44 `address_index` node.\n   */\n  async deriveBIP44AddressKey({\n    account = 0,\n    change = 0,\n    address_index,\n  }: CoinTypeToAddressIndices): Promise<BIP44Node> {\n    return await this.#node.derive(\n      getBIP44CoinTypeToAddressPathTuple({ account, change, address_index }),\n    );\n  }\n\n  toJSON(): JsonBIP44CoinTypeNode {\n    return {\n      ...this.#node.toJSON(),\n      coin_type: this.coin_type,\n      path: this.path,\n    };\n  }\n}\n\n/**\n * Validates the depth of a `coin_type` node. Simply, ensures that it is the\n * number `2`. An error is thrown if validation fails.\n *\n * @param depth - The depth to validate.\n */\nfunction validateCoinTypeNodeDepth(depth: number) {\n  if (depth !== BIP_44_COIN_TYPE_DEPTH) {\n    throw new Error(\n      `Invalid depth: Coin type nodes must be of depth ${BIP_44_COIN_TYPE_DEPTH}. Received: \"${depth}\"`,\n    );\n  }\n}\n\n/**\n * Validates that the coin type is a non-negative integer number. An error is\n * thrown if validation fails.\n *\n * @param coin_type - The coin type to validate.\n */\nfunction validateCoinType(coin_type: unknown): asserts coin_type is number {\n  if (\n    typeof coin_type !== 'number' ||\n    !Number.isInteger(coin_type) ||\n    coin_type < 0\n  ) {\n    throw new Error(\n      'Invalid coin type: The specified coin type must be a non-negative integer number.',\n    );\n  }\n}\n\n/**\n * Derives a BIP-44 address key corresponding to the specified derivation path,\n * given either by a {@link BIP44CoinTypeNode} or derivation path tuple.\n *\n * Recall that a BIP-44 HD tree path consists of the following nodes:\n *\n * `m / 44' / coin_type' / account' / change / address_index`\n *\n * With the following depths:\n *\n * `0 / 1 / 2 / 3 / 4 / 5`\n *\n * @param parentKeyOrNode - The `coin_type` parent key to derive from.\n * @param indices - The BIP-44 index values to use in key derivation.\n * @param indices.account - The `account` index. Default: `0`.\n * @param indices.change - The `change` index. Default: `0`.\n * @param indices.address_index - The `address_index` index.\n * @returns The derived `address_index` key for the specified derivation path.\n */\nexport async function deriveBIP44AddressKey(\n  parentKeyOrNode: BIP44CoinTypeNode | JsonBIP44CoinTypeNode | string,\n  { account = 0, change = 0, address_index }: CoinTypeToAddressIndices,\n): Promise<BIP44Node> {\n  const path = getBIP44CoinTypeToAddressPathTuple({\n    account,\n    change,\n    address_index,\n  });\n\n  const node = await getNode(parentKeyOrNode);\n  const childNode = await deriveChildNode({\n    path,\n    node,\n  });\n\n  return new BIP44Node(childNode);\n}\n\nexport type BIP44AddressKeyDeriver = {\n  /**\n   * @param address_index - The `address_index` value.\n   * @param isHardened - Whether the derived index is hardened.\n   * @returns The key corresponding to the path of this deriver and the\n   * specified `address_index` value.\n   */\n  (address_index: number, isHardened?: boolean): Promise<BIP44Node>;\n\n  /**\n   * A human-readable representation of the derivation path of this deriver\n   * function, excluding the `address_index`, which is parameterized.\n   *\n   * Recall that a BIP-44 HD tree path consists of the following nodes:\n   *\n   * `m / 44' / coin_type' / account' / change / address_index`\n   *\n   * With the following depths:\n   *\n   * `0 / 1 / 2 / 3 / 4 / 5`\n   */\n  path: ReturnType<typeof getBIP44ChangePathString>;\n\n  /**\n   * The `coin_type` index of addresses derived by this deriver function.\n   */\n  coin_type: number;\n};\n\n/**\n * Creates a function that derives BIP-44 address keys corresponding to the\n * specified derivation path, given either by a {@link BIP44CoinTypeNode} or\n * derivation path tuple.\n *\n * Recall that a BIP-44 HD tree path consists of the following nodes:\n *\n * `m / 44' / coin_type' / account' / change / address_index`\n *\n * With the following depths:\n *\n * `0 / 1 / 2 / 3 / 4 / 5`\n *\n * @param node - The {@link BIP44CoinTypeNode} to derive address keys from.\n * This node contains a BIP-44 key of depth 2, `coin_type`.\n * @param accountAndChangeIndices - The `account` and `change` indices that\n * will be used to derive addresses.\n * @returns The deriver function for the derivation path specified by the\n * `coin_type` node, `account`, and `change` indices.\n */\nexport async function getBIP44AddressKeyDeriver(\n  node: BIP44CoinTypeNode | JsonBIP44CoinTypeNode | string,\n  accountAndChangeIndices?: Omit<CoinTypeToAddressIndices, 'address_index'>,\n) {\n  const { account = 0, change = 0 } = accountAndChangeIndices ?? {};\n\n  const actualNode = await getNode(node);\n\n  const accountNode = getHardenedBIP32NodeToken(account);\n  const changeNode = getBIP32NodeToken(change);\n\n  const bip44AddressKeyDeriver: BIP44AddressKeyDeriver = async (\n    address_index: number,\n    isHardened = false,\n  ): Promise<BIP44Node> => {\n    const slip10Node = await deriveChildNode({\n      path: [\n        accountNode,\n        changeNode,\n        isHardened\n          ? getHardenedBIP32NodeToken(address_index)\n          : getUnhardenedBIP32NodeToken(address_index),\n      ],\n      node: actualNode,\n    });\n\n    return new BIP44Node(slip10Node);\n  };\n\n  bip44AddressKeyDeriver.coin_type = actualNode.coin_type;\n  bip44AddressKeyDeriver.path = getBIP44ChangePathString(actualNode.path, {\n    account,\n    change,\n  });\n\n  Object.freeze(bip44AddressKeyDeriver);\n\n  return bip44AddressKeyDeriver;\n}\n\n/**\n * Get a BIP-44 coin type node from a JSON node or extended key string. If an existing coin type\n * node is provided, the same node is returned.\n *\n * The depth of the node is validated to be a valid coin type node.\n *\n * @param node - A BIP-44 coin type node, JSON node or extended key.\n */\nasync function getNode(\n  node: BIP44CoinTypeNode | JsonBIP44CoinTypeNode | string,\n): Promise<BIP44CoinTypeNode> {\n  if (node instanceof BIP44CoinTypeNode) {\n    validateCoinTypeNodeDepth(node.depth);\n\n    return node;\n  }\n\n  if (typeof node === 'string') {\n    const bip44Node = await BIP44Node.fromExtendedKey(node);\n    const coinTypeNode = await BIP44CoinTypeNode.fromNode(\n      bip44Node,\n      bip44Node.index - BIP_32_HARDENED_OFFSET,\n    );\n\n    validateCoinTypeNodeDepth(coinTypeNode.depth);\n\n    return coinTypeNode;\n  }\n\n  return BIP44CoinTypeNode.fromJSON(node, node.coin_type);\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"BIP44CoinTypeNode.mjs","sourceRoot":"","sources":["../src/BIP44CoinTypeNode.ts"],"names":[],"mappings":"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","sourcesContent":["import { assert } from '@metamask/utils';\n\nimport type { BIP44NodeInterface, JsonBIP44Node } from './BIP44Node';\nimport { BIP44Node } from './BIP44Node';\nimport type {\n  BIP39Node,\n  BIP44Depth,\n  BIP44PurposeNodeToken,\n  CoinTypeHDPathString,\n  HardenedBIP32Node,\n} from './constants';\nimport { BIP_32_HARDENED_OFFSET } from './constants';\nimport type { CryptographicFunctions } from './cryptography';\nimport type { SupportedCurve } from './curves';\nimport { deriveChildNode } from './SLIP10Node';\nimport type { CoinTypeToAddressIndices } from './utils';\nimport {\n  getBIP32NodeToken,\n  getBIP44ChangePathString,\n  getBIP44CoinTypePathString,\n  getBIP44CoinTypeToAddressPathTuple,\n  getHardenedBIP32NodeToken,\n  getUnhardenedBIP32NodeToken,\n  hexStringToBytes,\n  nullableHexStringToBytes,\n} from './utils';\n\nexport type CoinTypeHDPathTuple = [\n  BIP39Node,\n  typeof BIP44PurposeNodeToken,\n  HardenedBIP32Node,\n];\n\nexport const BIP_44_COIN_TYPE_DEPTH = 2;\n\nexport type JsonBIP44CoinTypeNode = JsonBIP44Node & {\n  readonly coin_type: number;\n  readonly path: CoinTypeHDPathString;\n};\n\nexport type BIP44CoinTypeNodeInterface = BIP44NodeInterface & {\n  readonly coin_type: number;\n  readonly path: CoinTypeHDPathString;\n};\n\n/**\n * A wrapper object for BIP-44 `coin_type` keys. `coin_type` is the index\n * specifying the protocol for which deeper keys are intended. For the\n * authoritative list of coin types, please see\n * [SLIP-44](https://github.com/satoshilabs/slips/blob/master/slip-0044.md).\n *\n * Recall that a BIP-44 HD tree path consists of the following nodes:\n *\n * `m / 44' / coin_type' / account' / change / address_index`\n *\n * With the following depths:\n *\n * `0 / 1 / 2 / 3 / 4 / 5`\n *\n */\nexport class BIP44CoinTypeNode implements BIP44CoinTypeNodeInterface {\n  /**\n   * Constructs a BIP-44 `coin_type` node. `coin_type` is the index\n   * specifying the protocol for which deeper keys are intended. For the\n   * authoritative list of coin types, please see\n   * [SLIP-44](https://github.com/satoshilabs/slips/blob/master/slip-0044.md).\n   *\n   * Recall that a BIP-44 HD tree path consists of the following nodes:\n   *\n   * `m / 44' / coin_type' / account' / change / address_index`\n   *\n   * With the following depths:\n   *\n   * `0 / 1 / 2 / 3 / 4 / 5`\n   *\n   * @param json - The {@link JsonBIP44Node} for the key of this node.\n   * @param coin_type - The coin_type index of this node. Must be a non-negative\n   * integer.\n   * @param cryptographicFunctions - The cryptographic functions to use. If\n   * provided, these will be used instead of the built-in implementations.\n   * @returns A BIP44CoinType node.\n   */\n  static async fromJSON(\n    json: JsonBIP44Node,\n    coin_type: number,\n    cryptographicFunctions?: CryptographicFunctions,\n  ): Promise<BIP44CoinTypeNode> {\n    validateCoinType(coin_type);\n    validateCoinTypeNodeDepth(json.depth);\n\n    const node = await BIP44Node.fromExtendedKey(\n      {\n        depth: json.depth,\n        index: json.index,\n        parentFingerprint: json.parentFingerprint,\n        chainCode: hexStringToBytes(json.chainCode),\n        privateKey: nullableHexStringToBytes(json.privateKey),\n        publicKey: hexStringToBytes(json.publicKey),\n      },\n      cryptographicFunctions,\n    );\n\n    return new BIP44CoinTypeNode(node, coin_type);\n  }\n\n  /**\n   * Constructs a BIP-44 `coin_type` node. `coin_type` is the index\n   * specifying the protocol for which deeper keys are intended. For the\n   * authoritative list of coin types, please see\n   * [SLIP-44](https://github.com/satoshilabs/slips/blob/master/slip-0044.md).\n   *\n   * Recall that a BIP-44 HD tree path consists of the following nodes:\n   *\n   * `m / 44' / coin_type' / account' / change / address_index`\n   *\n   * With the following depths:\n   *\n   * `0 / 1 / 2 / 3 / 4 / 5`\n   *\n   * @param derivationPath - The derivation path for the key of this node.\n   * @param cryptographicFunctions - The cryptographic functions to use. If\n   * provided, these will be used instead of the built-in implementations.\n   * @returns A BIP44CoinType node.\n   */\n  static async fromDerivationPath(\n    derivationPath: CoinTypeHDPathTuple,\n    cryptographicFunctions?: CryptographicFunctions,\n  ): Promise<BIP44CoinTypeNode> {\n    validateCoinTypeNodeDepth(derivationPath.length - 1);\n\n    const node = await BIP44Node.fromDerivationPath(\n      {\n        derivationPath,\n      },\n      cryptographicFunctions,\n    );\n\n    // Split the bip32 string token and extract the coin_type index.\n    const pathPart = derivationPath[BIP_44_COIN_TYPE_DEPTH].split(\n      ':',\n    )[1]?.replace(`'`, '');\n\n    assert(pathPart, 'Invalid derivation path.');\n    const coinType = Number.parseInt(pathPart, 10);\n\n    return new BIP44CoinTypeNode(node, coinType);\n  }\n\n  /**\n   * Constructs a BIP-44 `coin_type` node. `coin_type` is the index\n   * specifying the protocol for which deeper keys are intended. For the\n   * authoritative list of coin types, please see\n   * [SLIP-44](https://github.com/satoshilabs/slips/blob/master/slip-0044.md).\n   *\n   * Recall that a BIP-44 HD tree path consists of the following nodes:\n   *\n   * `m / 44' / coin_type' / account' / change / address_index`\n   *\n   * With the following depths:\n   *\n   * `0 / 1 / 2 / 3 / 4 / 5`\n   *\n   * @param node - The {@link BIP44Node} for the key of this node.\n   * @param coin_type - The coin_type index of this node. Must be a non-negative\n   * integer.\n   * @returns A BIP44CoinType node.\n   */\n  static async fromNode(\n    node: BIP44Node,\n    coin_type: number,\n  ): Promise<BIP44CoinTypeNode> {\n    if (!(node instanceof BIP44Node)) {\n      throw new Error('Invalid node: Expected an instance of BIP44Node.');\n    }\n\n    validateCoinType(coin_type);\n    validateCoinTypeNodeDepth(node.depth);\n\n    // TODO: Make this function not async in a future version.\n    return Promise.resolve(new BIP44CoinTypeNode(node, coin_type));\n  }\n\n  readonly #node: BIP44Node;\n\n  public readonly path: CoinTypeHDPathString;\n\n  public readonly coin_type: number;\n\n  // Constructors cannot use hash names.\n  // eslint-disable-next-line no-restricted-syntax\n  private constructor(node: BIP44Node, coin_type: number) {\n    this.#node = node;\n    this.coin_type = coin_type;\n    this.path = getBIP44CoinTypePathString(coin_type);\n\n    Object.freeze(this);\n  }\n\n  public get depth(): BIP44Depth {\n    return this.#node.depth;\n  }\n\n  public get privateKeyBytes(): Uint8Array | undefined {\n    return this.#node.privateKeyBytes;\n  }\n\n  public get publicKeyBytes(): Uint8Array {\n    return this.#node.publicKeyBytes;\n  }\n\n  public get chainCodeBytes(): Uint8Array {\n    return this.#node.chainCodeBytes;\n  }\n\n  public get privateKey(): string | undefined {\n    return this.#node.privateKey;\n  }\n\n  public get publicKey(): string {\n    return this.#node.publicKey;\n  }\n\n  public get compressedPublicKey(): string {\n    return this.#node.compressedPublicKey;\n  }\n\n  public get compressedPublicKeyBytes(): Uint8Array {\n    return this.#node.compressedPublicKeyBytes;\n  }\n\n  public get chainCode(): string {\n    return this.#node.chainCode;\n  }\n\n  public get address(): string {\n    return this.#node.address;\n  }\n\n  public get masterFingerprint(): number | undefined {\n    return this.#node.masterFingerprint;\n  }\n\n  public get parentFingerprint(): number {\n    return this.#node.parentFingerprint;\n  }\n\n  public get fingerprint(): number {\n    return this.#node.fingerprint;\n  }\n\n  public get index(): number {\n    return this.#node.index;\n  }\n\n  public get curve(): SupportedCurve {\n    return this.#node.curve;\n  }\n\n  public get extendedKey(): string {\n    return this.#node.extendedKey;\n  }\n\n  /**\n   * Derives a BIP-44 `address_index` key corresponding to the path of this\n   * node and the specified `account`, `change`, and `address_index` values.\n   * `address_index` keys are normally the keys used to generate user account\n   * addresses.\n   *\n   * Recall that a BIP-44 HD tree path consists of the following nodes:\n   *\n   * `m / 44' / coin_type' / account' / change / address_index`\n   *\n   * With the following depths:\n   *\n   * `0 / 1 / 2 / 3 / 4 / 5`\n   *\n   * @param indices - The BIP-44 index values to use in key derivation.\n   * @param indices.account - The `account` index. Default: `0`\n   * @param indices.change - The `change` index. Default: `0`\n   * @param indices.address_index - The `address_index` index.\n   * @returns The derived BIP-44 `address_index` node.\n   */\n  async deriveBIP44AddressKey({\n    account = 0,\n    change = 0,\n    address_index,\n  }: CoinTypeToAddressIndices): Promise<BIP44Node> {\n    return await this.#node.derive(\n      getBIP44CoinTypeToAddressPathTuple({ account, change, address_index }),\n    );\n  }\n\n  toJSON(): JsonBIP44CoinTypeNode {\n    return {\n      ...this.#node.toJSON(),\n      coin_type: this.coin_type,\n      path: this.path,\n    };\n  }\n}\n\n/**\n * Validates the depth of a `coin_type` node. Simply, ensures that it is the\n * number `2`. An error is thrown if validation fails.\n *\n * @param depth - The depth to validate.\n */\nfunction validateCoinTypeNodeDepth(depth: number): void {\n  if (depth !== BIP_44_COIN_TYPE_DEPTH) {\n    throw new Error(\n      `Invalid depth: Coin type nodes must be of depth ${BIP_44_COIN_TYPE_DEPTH}. Received: \"${depth}\"`,\n    );\n  }\n}\n\n/**\n * Validates that the coin type is a non-negative integer number. An error is\n * thrown if validation fails.\n *\n * @param coin_type - The coin type to validate.\n */\nfunction validateCoinType(coin_type: unknown): asserts coin_type is number {\n  if (\n    typeof coin_type !== 'number' ||\n    !Number.isInteger(coin_type) ||\n    coin_type < 0\n  ) {\n    throw new Error(\n      'Invalid coin type: The specified coin type must be a non-negative integer number.',\n    );\n  }\n}\n\n/**\n * Derives a BIP-44 address key corresponding to the specified derivation path,\n * given either by a {@link BIP44CoinTypeNode} or derivation path tuple.\n *\n * Recall that a BIP-44 HD tree path consists of the following nodes:\n *\n * `m / 44' / coin_type' / account' / change / address_index`\n *\n * With the following depths:\n *\n * `0 / 1 / 2 / 3 / 4 / 5`\n *\n * @param parentKeyOrNode - The `coin_type` parent key to derive from.\n * @param indices - The BIP-44 index values to use in key derivation.\n * @param indices.account - The `account` index. Default: `0`.\n * @param indices.change - The `change` index. Default: `0`.\n * @param indices.address_index - The `address_index` index.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The derived `address_index` key for the specified derivation path.\n */\nexport async function deriveBIP44AddressKey(\n  parentKeyOrNode: BIP44CoinTypeNode | JsonBIP44CoinTypeNode | string,\n  { account = 0, change = 0, address_index }: CoinTypeToAddressIndices,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<BIP44Node> {\n  const path = getBIP44CoinTypeToAddressPathTuple({\n    account,\n    change,\n    address_index,\n  });\n\n  const node = await getNode(parentKeyOrNode, cryptographicFunctions);\n  const childNode = await deriveChildNode(\n    {\n      path,\n      node,\n    },\n    cryptographicFunctions,\n  );\n\n  return new BIP44Node(childNode);\n}\n\nexport type BIP44AddressKeyDeriver = {\n  /**\n   * @param address_index - The `address_index` value.\n   * @param isHardened - Whether the derived index is hardened.\n   * @returns The key corresponding to the path of this deriver and the\n   * specified `address_index` value.\n   */\n  (address_index: number, isHardened?: boolean): Promise<BIP44Node>;\n\n  /**\n   * A human-readable representation of the derivation path of this deriver\n   * function, excluding the `address_index`, which is parameterized.\n   *\n   * Recall that a BIP-44 HD tree path consists of the following nodes:\n   *\n   * `m / 44' / coin_type' / account' / change / address_index`\n   *\n   * With the following depths:\n   *\n   * `0 / 1 / 2 / 3 / 4 / 5`\n   */\n  path: ReturnType<typeof getBIP44ChangePathString>;\n\n  /**\n   * The `coin_type` index of addresses derived by this deriver function.\n   */\n  coin_type: number;\n};\n\n/**\n * Creates a function that derives BIP-44 address keys corresponding to the\n * specified derivation path, given either by a {@link BIP44CoinTypeNode} or\n * derivation path tuple.\n *\n * Recall that a BIP-44 HD tree path consists of the following nodes:\n *\n * `m / 44' / coin_type' / account' / change / address_index`\n *\n * With the following depths:\n *\n * `0 / 1 / 2 / 3 / 4 / 5`\n *\n * @param node - The {@link BIP44CoinTypeNode} to derive address keys from.\n * This node contains a BIP-44 key of depth 2, `coin_type`.\n * @param accountAndChangeIndices - The `account` and `change` indices that\n * will be used to derive addresses.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The deriver function for the derivation path specified by the\n * `coin_type` node, `account`, and `change` indices.\n */\nexport async function getBIP44AddressKeyDeriver(\n  node: BIP44CoinTypeNode | JsonBIP44CoinTypeNode | string,\n  accountAndChangeIndices?: Omit<CoinTypeToAddressIndices, 'address_index'>,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<BIP44AddressKeyDeriver> {\n  const { account = 0, change = 0 } = accountAndChangeIndices ?? {};\n\n  const actualNode = await getNode(node, cryptographicFunctions);\n\n  const accountNode = getHardenedBIP32NodeToken(account);\n  const changeNode = getBIP32NodeToken(change);\n\n  const bip44AddressKeyDeriver: BIP44AddressKeyDeriver = async (\n    address_index: number,\n    isHardened = false,\n  ): Promise<BIP44Node> => {\n    const slip10Node = await deriveChildNode(\n      {\n        path: [\n          accountNode,\n          changeNode,\n          isHardened\n            ? getHardenedBIP32NodeToken(address_index)\n            : getUnhardenedBIP32NodeToken(address_index),\n        ],\n        node: actualNode,\n      },\n      cryptographicFunctions,\n    );\n\n    return new BIP44Node(slip10Node);\n  };\n\n  bip44AddressKeyDeriver.coin_type = actualNode.coin_type;\n  bip44AddressKeyDeriver.path = getBIP44ChangePathString(actualNode.path, {\n    account,\n    change,\n  });\n\n  Object.freeze(bip44AddressKeyDeriver);\n\n  return bip44AddressKeyDeriver;\n}\n\n/**\n * Get a BIP-44 coin type node from a JSON node or extended key string. If an existing coin type\n * node is provided, the same node is returned.\n *\n * The depth of the node is validated to be a valid coin type node.\n *\n * @param node - A BIP-44 coin type node, JSON node or extended key.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations. This is\n * only used if the node is an extended key string or JSON object.\n * @returns A BIP44CoinType node.\n */\nasync function getNode(\n  node: BIP44CoinTypeNode | JsonBIP44CoinTypeNode | string,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<BIP44CoinTypeNode> {\n  if (node instanceof BIP44CoinTypeNode) {\n    validateCoinTypeNodeDepth(node.depth);\n\n    return node;\n  }\n\n  if (typeof node === 'string') {\n    const bip44Node = await BIP44Node.fromExtendedKey(\n      node,\n      cryptographicFunctions,\n    );\n    const coinTypeNode = await BIP44CoinTypeNode.fromNode(\n      bip44Node,\n      bip44Node.index - BIP_32_HARDENED_OFFSET,\n    );\n\n    validateCoinTypeNodeDepth(coinTypeNode.depth);\n\n    return coinTypeNode;\n  }\n\n  return BIP44CoinTypeNode.fromJSON(\n    node,\n    node.coin_type,\n    cryptographicFunctions,\n  );\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/BIP44Node.cjs b/node_modules/@metamask/key-tree/dist/BIP44Node.cjs
index a67880e..4ee8d6b 100644
--- a/node_modules/@metamask/key-tree/dist/BIP44Node.cjs
+++ b/node_modules/@metamask/key-tree/dist/BIP44Node.cjs
@@ -1,15 +1,15 @@
 "use strict";
+var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
+    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
+};
 var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
     if (kind === "m") throw new TypeError("Private method is not writable");
     if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
     if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
     return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
 };
-var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
-    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
-    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
-    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
-};
 var _BIP44Node_node;
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.validateBIP44Depth = exports.BIP44Node = void 0;
@@ -27,19 +27,17 @@ const utils_2 = require("./utils.cjs");
  * {@link BIP44Node.toJSON} to get a JSON-compatible representation.
  */
 class BIP44Node {
-    constructor(node) {
-        _BIP44Node_node.set(this, void 0);
-        __classPrivateFieldSet(this, _BIP44Node_node, node, "f");
-        Object.freeze(this);
-    }
     /**
      * Wrapper of the {@link fromExtendedKey} function. Refer to that function
      * for documentation.
      *
      * @param json - The JSON representation of a SLIP-10 node.
+     * @param cryptographicFunctions - The cryptographic functions to use. If
+     * provided, these will be used instead of the built-in implementations.
+     * @returns A BIP44 node.
      */
-    static async fromJSON(json) {
-        return BIP44Node.fromExtendedKey(json);
+    static async fromJSON(json, cryptographicFunctions) {
+        return BIP44Node.fromExtendedKey(json, cryptographicFunctions);
     }
     /**
      * Create a new BIP-44 node from a key and chain code. You must specify
@@ -56,8 +54,11 @@ class BIP44Node {
      * @param options.publicKey - The public key for the node. If a private key is
      * specified, this parameter is ignored.
      * @param options.chainCode - The chain code for the node.
+     * @param cryptographicFunctions - The cryptographic functions to use. If
+     * provided, these will be used instead of the built-in implementations.
+     * @returns A BIP44 node.
      */
-    static async fromExtendedKey(options) {
+    static async fromExtendedKey(options, cryptographicFunctions) {
         if (typeof options === 'string') {
             const extendedKey = (0, extended_keys_1.decodeExtendedKey)(options);
             const { chainCode, depth, parentFingerprint, index } = extendedKey;
@@ -69,7 +70,7 @@ class BIP44Node {
                     index,
                     privateKey,
                     chainCode,
-                });
+                }, cryptographicFunctions);
             }
             const { publicKey } = extendedKey;
             return BIP44Node.fromExtendedKey({
@@ -78,7 +79,7 @@ class BIP44Node {
                 index,
                 publicKey,
                 chainCode,
-            });
+            }, cryptographicFunctions);
         }
         const { privateKey, publicKey, chainCode, depth, parentFingerprint, index, } = options;
         validateBIP44Depth(depth);
@@ -90,7 +91,7 @@ class BIP44Node {
             parentFingerprint,
             index,
             curve: 'secp256k1',
-        });
+        }, cryptographicFunctions);
         return new BIP44Node(node);
     }
     /**
@@ -113,14 +114,17 @@ class BIP44Node {
      * @param options - An object containing the derivation path.
      * @param options.derivationPath - The rooted HD tree path that will be used
      * to derive the key of this node.
+     * @param cryptographicFunctions - The cryptographic functions to use. If
+     * provided, these will be used instead of the built-in implementations.
+     * @returns A BIP44 node.
      */
-    static async fromDerivationPath({ derivationPath, }) {
+    static async fromDerivationPath({ derivationPath }, cryptographicFunctions) {
         validateBIP44Depth(derivationPath.length - 1);
         validateBIP44DerivationPath(derivationPath, constants_1.MIN_BIP_44_DEPTH);
         const node = await SLIP10Node_1.SLIP10Node.fromDerivationPath({
             derivationPath,
             curve: 'secp256k1',
-        });
+        }, cryptographicFunctions);
         return new BIP44Node(node);
     }
     get depth() {
@@ -166,28 +170,16 @@ class BIP44Node {
         return __classPrivateFieldGet(this, _BIP44Node_node, "f").index;
     }
     get extendedKey() {
-        const data = {
-            depth: this.depth,
-            parentFingerprint: this.parentFingerprint,
-            index: this.index,
-            chainCode: this.chainCodeBytes,
-        };
-        if (this.privateKeyBytes) {
-            return (0, extended_keys_1.encodeExtendedKey)({
-                ...data,
-                version: extended_keys_1.PRIVATE_KEY_VERSION,
-                privateKey: this.privateKeyBytes,
-            });
-        }
-        return (0, extended_keys_1.encodeExtendedKey)({
-            ...data,
-            version: extended_keys_1.PUBLIC_KEY_VERSION,
-            publicKey: this.publicKeyBytes,
-        });
+        return __classPrivateFieldGet(this, _BIP44Node_node, "f").extendedKey;
     }
     get curve() {
         return __classPrivateFieldGet(this, _BIP44Node_node, "f").curve;
     }
+    constructor(node) {
+        _BIP44Node_node.set(this, void 0);
+        __classPrivateFieldSet(this, _BIP44Node_node, node, "f");
+        Object.freeze(this);
+    }
     /**
      * Get a neutered version of this node, i.e. a node without a private key.
      *
diff --git a/node_modules/@metamask/key-tree/dist/BIP44Node.cjs.map b/node_modules/@metamask/key-tree/dist/BIP44Node.cjs.map
index e46875a..c8f25fe 100644
--- a/node_modules/@metamask/key-tree/dist/BIP44Node.cjs.map
+++ b/node_modules/@metamask/key-tree/dist/BIP44Node.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"BIP44Node.cjs","sourceRoot":"","sources":["../src/BIP44Node.ts"],"names":[],"mappings":"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","sourcesContent":["import { assert } from '@metamask/utils';\n\nimport type {\n  BIP44Depth,\n  PartialHDPathTuple,\n  RootedSLIP10PathTuple,\n  SLIP10Path,\n} from './constants';\nimport {\n  BIP44PurposeNodeToken,\n  BIP_32_PATH_REGEX,\n  BIP_39_PATH_REGEX,\n  MAX_BIP_44_DEPTH,\n  MIN_BIP_44_DEPTH,\n} from './constants';\nimport type { SupportedCurve } from './curves';\nimport {\n  decodeExtendedKey,\n  encodeExtendedKey,\n  PRIVATE_KEY_VERSION,\n  PUBLIC_KEY_VERSION,\n} from './extended-keys';\nimport { SLIP10Node, validateBIP32Depth } from './SLIP10Node';\nimport { isHardened } from './utils';\n\nexport type BIP44ExtendedKeyOptions = {\n  readonly depth: number;\n  readonly parentFingerprint: number;\n  readonly index: number;\n  readonly chainCode: Uint8Array | string;\n  readonly privateKey?: Uint8Array | string | undefined;\n  readonly publicKey?: Uint8Array | string | undefined;\n};\n\nexport type BIP44DerivationPathOptions = {\n  readonly derivationPath: RootedSLIP10PathTuple;\n};\n\n/**\n * A wrapper for BIP-44 Hierarchical Deterministic (HD) tree nodes, i.e.\n * cryptographic keys used to generate keypairs and addresses for cryptocurrency\n * protocols.\n */\nexport type JsonBIP44Node = {\n  /**\n   * The 0-indexed BIP-44 path depth of this node.\n   *\n   * A BIP-44 path is of the form:\n   *\n   * `m / 44' / coin_type' / account' / change / address_index`\n   *\n   * With the following depths:\n   *\n   * `0 / 1 / 2 / 3 / 4 / 5`\n   */\n  readonly depth: BIP44Depth;\n\n  /**\n   * The fingerprint of the master node, i.e., the node at depth 0. May be\n   * undefined if this node was created from an extended key.\n   */\n  readonly masterFingerprint?: number | undefined;\n\n  /**\n   * The fingerprint of the parent key, or 0 if this is a master node.\n   */\n  readonly parentFingerprint: number;\n\n  /**\n   * The index of the node, or 0 if this is a master node.\n   */\n  readonly index: number;\n\n  /**\n   * The hexadecimal string representation of the private key for this node.\n   * May be `undefined` if the node is a public node.\n   */\n  readonly privateKey?: string | undefined;\n\n  /**\n   * The hexadecimal string representation of the public key for this node.\n   */\n  readonly publicKey: string;\n\n  /**\n   * The hexadecimal string representation of the chain code for this node.\n   */\n  readonly chainCode: string;\n};\n\nexport type BIP44NodeInterface = JsonBIP44Node & {\n  /**\n   * @returns A JSON-compatible representation of this node's data fields.\n   */\n  toJSON(): JsonBIP44Node;\n};\n\n/**\n * A wrapper for BIP-44 Hierarchical Deterministic (HD) tree nodes, i.e.\n * cryptographic keys used to generate keypairs and addresses for cryptocurrency\n * protocols.\n *\n * This class contains methods and fields that may not serialize well. Use\n * {@link BIP44Node.toJSON} to get a JSON-compatible representation.\n */\nexport class BIP44Node implements BIP44NodeInterface {\n  /**\n   * Wrapper of the {@link fromExtendedKey} function. Refer to that function\n   * for documentation.\n   *\n   * @param json - The JSON representation of a SLIP-10 node.\n   */\n  static async fromJSON(json: JsonBIP44Node): Promise<BIP44Node> {\n    return BIP44Node.fromExtendedKey(json);\n  }\n\n  /**\n   * Create a new BIP-44 node from a key and chain code. You must specify\n   * either a private key or a public key. When specifying a private key,\n   * the public key will be derived from the private key.\n   *\n   * All parameters are stringently validated, and an error is thrown if\n   * validation fails.\n   *\n   * @param options - An object containing the extended key, or an extended\n   * public (xpub) or private (xprv) key.\n   * @param options.depth - The depth of the node.\n   * @param options.privateKey - The private key for the node.\n   * @param options.publicKey - The public key for the node. If a private key is\n   * specified, this parameter is ignored.\n   * @param options.chainCode - The chain code for the node.\n   */\n  static async fromExtendedKey(\n    options: BIP44ExtendedKeyOptions | string,\n  ): Promise<BIP44Node> {\n    if (typeof options === 'string') {\n      const extendedKey = decodeExtendedKey(options);\n\n      const { chainCode, depth, parentFingerprint, index } = extendedKey;\n\n      if (extendedKey.version === PRIVATE_KEY_VERSION) {\n        const { privateKey } = extendedKey;\n\n        return BIP44Node.fromExtendedKey({\n          depth,\n          parentFingerprint,\n          index,\n          privateKey,\n          chainCode,\n        });\n      }\n\n      const { publicKey } = extendedKey;\n\n      return BIP44Node.fromExtendedKey({\n        depth,\n        parentFingerprint,\n        index,\n        publicKey,\n        chainCode,\n      });\n    }\n\n    const {\n      privateKey,\n      publicKey,\n      chainCode,\n      depth,\n      parentFingerprint,\n      index,\n    } = options;\n\n    validateBIP44Depth(depth);\n\n    const node = await SLIP10Node.fromExtendedKey({\n      privateKey,\n      publicKey,\n      chainCode,\n      depth,\n      parentFingerprint,\n      index,\n      curve: 'secp256k1',\n    });\n\n    return new BIP44Node(node);\n  }\n\n  /**\n   * Create a new BIP-44 node from a derivation path. The derivation path\n   * must be rooted, i.e. it must begin with a BIP-39 node, given as a string of\n   * the form `bip39:MNEMONIC`, where `MNEMONIC` is a space-separated list of\n   * BIP-39 seed phrase words.\n   *\n   * All parameters are stringently validated, and an error is thrown if\n   * validation fails.\n   *\n   * Recall that a BIP-44 HD tree path consists of the following nodes:\n   *\n   * `m / 44' / coin_type' / account' / change / address_index`\n   *\n   * With the following depths:\n   *\n   * `0 / 1 / 2 / 3 / 4 / 5`\n   *\n   * @param options - An object containing the derivation path.\n   * @param options.derivationPath - The rooted HD tree path that will be used\n   * to derive the key of this node.\n   */\n  static async fromDerivationPath({\n    derivationPath,\n  }: BIP44DerivationPathOptions): Promise<BIP44Node> {\n    validateBIP44Depth(derivationPath.length - 1);\n    validateBIP44DerivationPath(derivationPath, MIN_BIP_44_DEPTH);\n\n    const node = await SLIP10Node.fromDerivationPath({\n      derivationPath,\n      curve: 'secp256k1',\n    });\n\n    return new BIP44Node(node);\n  }\n\n  #node: SLIP10Node;\n\n  public get depth(): BIP44Depth {\n    return this.#node.depth as BIP44Depth;\n  }\n\n  public get privateKeyBytes(): Uint8Array | undefined {\n    return this.#node.privateKeyBytes;\n  }\n\n  public get publicKeyBytes(): Uint8Array {\n    return this.#node.publicKeyBytes;\n  }\n\n  public get chainCodeBytes(): Uint8Array {\n    return this.#node.chainCodeBytes;\n  }\n\n  public get privateKey(): string | undefined {\n    return this.#node.privateKey;\n  }\n\n  public get publicKey(): string {\n    return this.#node.publicKey;\n  }\n\n  public get compressedPublicKey(): string {\n    return this.#node.compressedPublicKey;\n  }\n\n  public get compressedPublicKeyBytes(): Uint8Array {\n    return this.#node.compressedPublicKeyBytes;\n  }\n\n  public get chainCode(): string {\n    return this.#node.chainCode;\n  }\n\n  public get address(): string {\n    return this.#node.address;\n  }\n\n  public get masterFingerprint(): number | undefined {\n    return this.#node.masterFingerprint;\n  }\n\n  public get parentFingerprint(): number {\n    return this.#node.parentFingerprint;\n  }\n\n  public get fingerprint(): number {\n    return this.#node.fingerprint;\n  }\n\n  public get index(): number {\n    return this.#node.index;\n  }\n\n  public get extendedKey(): string {\n    const data = {\n      depth: this.depth,\n      parentFingerprint: this.parentFingerprint,\n      index: this.index,\n      chainCode: this.chainCodeBytes,\n    };\n\n    if (this.privateKeyBytes) {\n      return encodeExtendedKey({\n        ...data,\n        version: PRIVATE_KEY_VERSION,\n        privateKey: this.privateKeyBytes,\n      });\n    }\n\n    return encodeExtendedKey({\n      ...data,\n      version: PUBLIC_KEY_VERSION,\n      publicKey: this.publicKeyBytes,\n    });\n  }\n\n  public get curve(): SupportedCurve {\n    return this.#node.curve;\n  }\n\n  constructor(node: SLIP10Node) {\n    this.#node = node;\n\n    Object.freeze(this);\n  }\n\n  /**\n   * Get a neutered version of this node, i.e. a node without a private key.\n   *\n   * @returns A neutered version of this node.\n   */\n  public neuter(): BIP44Node {\n    const node = this.#node.neuter();\n    return new BIP44Node(node);\n  }\n\n  /**\n   * Derives a child of the key contains be this node and returns a new\n   * {@link BIP44Node} containing the child key.\n   *\n   * The specified path must be a valid HD path from this node, per BIP-44.\n   * At present, this means that the path must consist of no more than 5 BIP-32\n   * nodes, depending on the depth of this node.\n   *\n   * Recall that a BIP-44 HD tree path consists of the following nodes:\n   *\n   * `m / 44' / coin_type' / account' / change / address_index`\n   *\n   * With the following depths:\n   *\n   * `0 / 1 / 2 / 3 / 4 / 5`\n   *\n   * @param path - The partial (non-rooted) BIP-44 HD tree path will be used\n   * to derive a child key from the parent key contained within this node.\n   * @returns The {@link BIP44Node} corresponding to the derived child key.\n   */\n  public async derive(path: PartialHDPathTuple): Promise<BIP44Node> {\n    if (this.depth === MAX_BIP_44_DEPTH) {\n      throw new Error(\n        'Illegal operation: This HD tree node is already a leaf node.',\n      );\n    }\n\n    const newDepth = this.depth + path.length;\n\n    validateBIP44Depth(newDepth);\n    validateBIP44DerivationPath(path, (this.depth + 1) as BIP44Depth);\n\n    const node = await this.#node.derive(path);\n    return new BIP44Node(node);\n  }\n\n  // This is documented in the interface of this class.\n  public toJSON(): JsonBIP44Node {\n    return {\n      depth: this.depth,\n      masterFingerprint: this.masterFingerprint,\n      parentFingerprint: this.parentFingerprint,\n      index: this.index,\n      privateKey: this.privateKey,\n      publicKey: this.publicKey,\n      chainCode: this.chainCode,\n    };\n  }\n}\n\n/**\n * Validates a BIP-44 path depth. Effectively, asserts that the depth is an\n * integer `number` N such that 0 <= N <= 5. Throws an error if validation\n * fails.\n *\n * @param depth - The depth to validate.\n */\nexport function validateBIP44Depth(\n  depth: unknown,\n): asserts depth is BIP44Depth {\n  validateBIP32Depth(depth);\n\n  if (depth < MIN_BIP_44_DEPTH || depth > MAX_BIP_44_DEPTH) {\n    throw new Error(\n      `Invalid HD tree path depth: The depth must be a positive integer N such that 0 <= N <= 5. Received: \"${depth}\"`,\n    );\n  }\n}\n\n/**\n * Ensures that the given derivation is valid by BIP-44.\n *\n * Recall that a BIP-44 HD tree path consists of the following nodes:\n *\n * `m / 44' / coin_type' / account' / change / address_index`\n *\n * With the following depths:\n *\n * `0 / 1 / 2 / 3 / 4 / 5`\n *\n * @param path - The path to validate.\n * @param startingDepth - The depth of the first node of the derivation path.\n */\nfunction validateBIP44DerivationPath(\n  path: SLIP10Path,\n  startingDepth: BIP44Depth,\n) {\n  path.forEach((nodeToken, index) => {\n    const currentDepth = startingDepth + index;\n\n    if (currentDepth === MIN_BIP_44_DEPTH) {\n      if (\n        !(nodeToken instanceof Uint8Array) &&\n        !BIP_39_PATH_REGEX.test(nodeToken)\n      ) {\n        throw new Error(\n          'Invalid derivation path: The \"m\" / seed node (depth 0) must be a BIP-39 node.',\n        );\n      }\n\n      return;\n    }\n\n    assert(typeof nodeToken === 'string');\n\n    // eslint-disable-next-line default-case\n    switch (currentDepth) {\n      case 1:\n        if (nodeToken !== BIP44PurposeNodeToken) {\n          throw new Error(\n            `Invalid derivation path: The \"purpose\" node (depth 1) must be the string \"${BIP44PurposeNodeToken}\".`,\n          );\n        }\n        break;\n\n      case 2:\n        if (!BIP_32_PATH_REGEX.test(nodeToken) || !isHardened(nodeToken)) {\n          throw new Error(\n            'Invalid derivation path: The \"coin_type\" node (depth 2) must be a hardened BIP-32 node.',\n          );\n        }\n        break;\n\n      case 3:\n        if (!BIP_32_PATH_REGEX.test(nodeToken) || !isHardened(nodeToken)) {\n          throw new Error(\n            'Invalid derivation path: The \"account\" node (depth 3) must be a hardened BIP-32 node.',\n          );\n        }\n        break;\n\n      case 4:\n        if (!BIP_32_PATH_REGEX.test(nodeToken)) {\n          throw new Error(\n            'Invalid derivation path: The \"change\" node (depth 4) must be a BIP-32 node.',\n          );\n        }\n        break;\n\n      case MAX_BIP_44_DEPTH: // 5\n        if (!BIP_32_PATH_REGEX.test(nodeToken)) {\n          throw new Error(\n            'Invalid derivation path: The \"address_index\" node (depth 5) must be a BIP-32 node.',\n          );\n        }\n        break;\n    }\n  });\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"BIP44Node.cjs","sourceRoot":"","sources":["../src/BIP44Node.ts"],"names":[],"mappings":"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","sourcesContent":["import { assert } from '@metamask/utils';\n\nimport type {\n  BIP44Depth,\n  PartialHDPathTuple,\n  RootedSLIP10PathTuple,\n  SLIP10Path,\n} from './constants';\nimport {\n  BIP44PurposeNodeToken,\n  BIP_32_PATH_REGEX,\n  BIP_39_PATH_REGEX,\n  MAX_BIP_44_DEPTH,\n  MIN_BIP_44_DEPTH,\n} from './constants';\nimport type { CryptographicFunctions } from './cryptography';\nimport type { SupportedCurve } from './curves';\nimport { decodeExtendedKey, PRIVATE_KEY_VERSION } from './extended-keys';\nimport { SLIP10Node, validateBIP32Depth } from './SLIP10Node';\nimport { isHardened } from './utils';\n\nexport type BIP44ExtendedKeyOptions = {\n  readonly depth: number;\n  readonly parentFingerprint: number;\n  readonly index: number;\n  readonly chainCode: Uint8Array | string;\n  readonly privateKey?: Uint8Array | string | undefined;\n  readonly publicKey?: Uint8Array | string | undefined;\n};\n\nexport type BIP44DerivationPathOptions = {\n  readonly derivationPath: RootedSLIP10PathTuple;\n};\n\n/**\n * A wrapper for BIP-44 Hierarchical Deterministic (HD) tree nodes, i.e.\n * cryptographic keys used to generate keypairs and addresses for cryptocurrency\n * protocols.\n */\nexport type JsonBIP44Node = {\n  /**\n   * The 0-indexed BIP-44 path depth of this node.\n   *\n   * A BIP-44 path is of the form:\n   *\n   * `m / 44' / coin_type' / account' / change / address_index`\n   *\n   * With the following depths:\n   *\n   * `0 / 1 / 2 / 3 / 4 / 5`\n   */\n  readonly depth: BIP44Depth;\n\n  /**\n   * The fingerprint of the master node, i.e., the node at depth 0. May be\n   * undefined if this node was created from an extended key.\n   */\n  readonly masterFingerprint?: number | undefined;\n\n  /**\n   * The fingerprint of the parent key, or 0 if this is a master node.\n   */\n  readonly parentFingerprint: number;\n\n  /**\n   * The index of the node, or 0 if this is a master node.\n   */\n  readonly index: number;\n\n  /**\n   * The hexadecimal string representation of the private key for this node.\n   * May be `undefined` if the node is a public node.\n   */\n  readonly privateKey?: string | undefined;\n\n  /**\n   * The hexadecimal string representation of the public key for this node.\n   */\n  readonly publicKey: string;\n\n  /**\n   * The hexadecimal string representation of the chain code for this node.\n   */\n  readonly chainCode: string;\n};\n\nexport type BIP44NodeInterface = JsonBIP44Node & {\n  /**\n   * @returns A JSON-compatible representation of this node's data fields.\n   */\n  toJSON(): JsonBIP44Node;\n};\n\n/**\n * A wrapper for BIP-44 Hierarchical Deterministic (HD) tree nodes, i.e.\n * cryptographic keys used to generate keypairs and addresses for cryptocurrency\n * protocols.\n *\n * This class contains methods and fields that may not serialize well. Use\n * {@link BIP44Node.toJSON} to get a JSON-compatible representation.\n */\nexport class BIP44Node implements BIP44NodeInterface {\n  /**\n   * Wrapper of the {@link fromExtendedKey} function. Refer to that function\n   * for documentation.\n   *\n   * @param json - The JSON representation of a SLIP-10 node.\n   * @param cryptographicFunctions - The cryptographic functions to use. If\n   * provided, these will be used instead of the built-in implementations.\n   * @returns A BIP44 node.\n   */\n  static async fromJSON(\n    json: JsonBIP44Node,\n    cryptographicFunctions?: CryptographicFunctions,\n  ): Promise<BIP44Node> {\n    return BIP44Node.fromExtendedKey(json, cryptographicFunctions);\n  }\n\n  /**\n   * Create a new BIP-44 node from a key and chain code. You must specify\n   * either a private key or a public key. When specifying a private key,\n   * the public key will be derived from the private key.\n   *\n   * All parameters are stringently validated, and an error is thrown if\n   * validation fails.\n   *\n   * @param options - An object containing the extended key, or an extended\n   * public (xpub) or private (xprv) key.\n   * @param options.depth - The depth of the node.\n   * @param options.privateKey - The private key for the node.\n   * @param options.publicKey - The public key for the node. If a private key is\n   * specified, this parameter is ignored.\n   * @param options.chainCode - The chain code for the node.\n   * @param cryptographicFunctions - The cryptographic functions to use. If\n   * provided, these will be used instead of the built-in implementations.\n   * @returns A BIP44 node.\n   */\n  static async fromExtendedKey(\n    options: BIP44ExtendedKeyOptions | string,\n    cryptographicFunctions?: CryptographicFunctions,\n  ): Promise<BIP44Node> {\n    if (typeof options === 'string') {\n      const extendedKey = decodeExtendedKey(options);\n\n      const { chainCode, depth, parentFingerprint, index } = extendedKey;\n\n      if (extendedKey.version === PRIVATE_KEY_VERSION) {\n        const { privateKey } = extendedKey;\n\n        return BIP44Node.fromExtendedKey(\n          {\n            depth,\n            parentFingerprint,\n            index,\n            privateKey,\n            chainCode,\n          },\n          cryptographicFunctions,\n        );\n      }\n\n      const { publicKey } = extendedKey;\n\n      return BIP44Node.fromExtendedKey(\n        {\n          depth,\n          parentFingerprint,\n          index,\n          publicKey,\n          chainCode,\n        },\n        cryptographicFunctions,\n      );\n    }\n\n    const {\n      privateKey,\n      publicKey,\n      chainCode,\n      depth,\n      parentFingerprint,\n      index,\n    } = options;\n\n    validateBIP44Depth(depth);\n\n    const node = await SLIP10Node.fromExtendedKey(\n      {\n        privateKey,\n        publicKey,\n        chainCode,\n        depth,\n        parentFingerprint,\n        index,\n        curve: 'secp256k1',\n      },\n      cryptographicFunctions,\n    );\n\n    return new BIP44Node(node);\n  }\n\n  /**\n   * Create a new BIP-44 node from a derivation path. The derivation path\n   * must be rooted, i.e. it must begin with a BIP-39 node, given as a string of\n   * the form `bip39:MNEMONIC`, where `MNEMONIC` is a space-separated list of\n   * BIP-39 seed phrase words.\n   *\n   * All parameters are stringently validated, and an error is thrown if\n   * validation fails.\n   *\n   * Recall that a BIP-44 HD tree path consists of the following nodes:\n   *\n   * `m / 44' / coin_type' / account' / change / address_index`\n   *\n   * With the following depths:\n   *\n   * `0 / 1 / 2 / 3 / 4 / 5`\n   *\n   * @param options - An object containing the derivation path.\n   * @param options.derivationPath - The rooted HD tree path that will be used\n   * to derive the key of this node.\n   * @param cryptographicFunctions - The cryptographic functions to use. If\n   * provided, these will be used instead of the built-in implementations.\n   * @returns A BIP44 node.\n   */\n  static async fromDerivationPath(\n    { derivationPath }: BIP44DerivationPathOptions,\n    cryptographicFunctions?: CryptographicFunctions,\n  ): Promise<BIP44Node> {\n    validateBIP44Depth(derivationPath.length - 1);\n    validateBIP44DerivationPath(derivationPath, MIN_BIP_44_DEPTH);\n\n    const node = await SLIP10Node.fromDerivationPath(\n      {\n        derivationPath,\n        curve: 'secp256k1',\n      },\n      cryptographicFunctions,\n    );\n\n    return new BIP44Node(node);\n  }\n\n  readonly #node: SLIP10Node;\n\n  public get depth(): BIP44Depth {\n    return this.#node.depth as BIP44Depth;\n  }\n\n  public get privateKeyBytes(): Uint8Array | undefined {\n    return this.#node.privateKeyBytes;\n  }\n\n  public get publicKeyBytes(): Uint8Array {\n    return this.#node.publicKeyBytes;\n  }\n\n  public get chainCodeBytes(): Uint8Array {\n    return this.#node.chainCodeBytes;\n  }\n\n  public get privateKey(): string | undefined {\n    return this.#node.privateKey;\n  }\n\n  public get publicKey(): string {\n    return this.#node.publicKey;\n  }\n\n  public get compressedPublicKey(): string {\n    return this.#node.compressedPublicKey;\n  }\n\n  public get compressedPublicKeyBytes(): Uint8Array {\n    return this.#node.compressedPublicKeyBytes;\n  }\n\n  public get chainCode(): string {\n    return this.#node.chainCode;\n  }\n\n  public get address(): string {\n    return this.#node.address;\n  }\n\n  public get masterFingerprint(): number | undefined {\n    return this.#node.masterFingerprint;\n  }\n\n  public get parentFingerprint(): number {\n    return this.#node.parentFingerprint;\n  }\n\n  public get fingerprint(): number {\n    return this.#node.fingerprint;\n  }\n\n  public get index(): number {\n    return this.#node.index;\n  }\n\n  public get extendedKey(): string {\n    return this.#node.extendedKey;\n  }\n\n  public get curve(): SupportedCurve {\n    return this.#node.curve;\n  }\n\n  constructor(node: SLIP10Node) {\n    this.#node = node;\n\n    Object.freeze(this);\n  }\n\n  /**\n   * Get a neutered version of this node, i.e. a node without a private key.\n   *\n   * @returns A neutered version of this node.\n   */\n  public neuter(): BIP44Node {\n    const node = this.#node.neuter();\n    return new BIP44Node(node);\n  }\n\n  /**\n   * Derives a child of the key contains be this node and returns a new\n   * {@link BIP44Node} containing the child key.\n   *\n   * The specified path must be a valid HD path from this node, per BIP-44.\n   * At present, this means that the path must consist of no more than 5 BIP-32\n   * nodes, depending on the depth of this node.\n   *\n   * Recall that a BIP-44 HD tree path consists of the following nodes:\n   *\n   * `m / 44' / coin_type' / account' / change / address_index`\n   *\n   * With the following depths:\n   *\n   * `0 / 1 / 2 / 3 / 4 / 5`\n   *\n   * @param path - The partial (non-rooted) BIP-44 HD tree path will be used\n   * to derive a child key from the parent key contained within this node.\n   * @returns The {@link BIP44Node} corresponding to the derived child key.\n   */\n  public async derive(path: PartialHDPathTuple): Promise<BIP44Node> {\n    if (this.depth === MAX_BIP_44_DEPTH) {\n      throw new Error(\n        'Illegal operation: This HD tree node is already a leaf node.',\n      );\n    }\n\n    const newDepth = this.depth + path.length;\n\n    validateBIP44Depth(newDepth);\n    validateBIP44DerivationPath(path, (this.depth + 1) as BIP44Depth);\n\n    const node = await this.#node.derive(path);\n    return new BIP44Node(node);\n  }\n\n  // This is documented in the interface of this class.\n  public toJSON(): JsonBIP44Node {\n    return {\n      depth: this.depth,\n      masterFingerprint: this.masterFingerprint,\n      parentFingerprint: this.parentFingerprint,\n      index: this.index,\n      privateKey: this.privateKey,\n      publicKey: this.publicKey,\n      chainCode: this.chainCode,\n    };\n  }\n}\n\n/**\n * Validates a BIP-44 path depth. Effectively, asserts that the depth is an\n * integer `number` N such that 0 <= N <= 5. Throws an error if validation\n * fails.\n *\n * @param depth - The depth to validate.\n */\nexport function validateBIP44Depth(\n  depth: unknown,\n): asserts depth is BIP44Depth {\n  validateBIP32Depth(depth);\n\n  if (depth < MIN_BIP_44_DEPTH || depth > MAX_BIP_44_DEPTH) {\n    throw new Error(\n      `Invalid HD tree path depth: The depth must be a positive integer N such that 0 <= N <= 5. Received: \"${depth}\"`,\n    );\n  }\n}\n\n/**\n * Ensures that the given derivation is valid by BIP-44.\n *\n * Recall that a BIP-44 HD tree path consists of the following nodes:\n *\n * `m / 44' / coin_type' / account' / change / address_index`\n *\n * With the following depths:\n *\n * `0 / 1 / 2 / 3 / 4 / 5`\n *\n * @param path - The path to validate.\n * @param startingDepth - The depth of the first node of the derivation path.\n */\nfunction validateBIP44DerivationPath(\n  path: SLIP10Path,\n  startingDepth: BIP44Depth,\n): void {\n  path.forEach((nodeToken, index) => {\n    const currentDepth = startingDepth + index;\n\n    if (currentDepth === MIN_BIP_44_DEPTH) {\n      if (\n        !(nodeToken instanceof Uint8Array) &&\n        !BIP_39_PATH_REGEX.test(nodeToken)\n      ) {\n        throw new Error(\n          'Invalid derivation path: The \"m\" / seed node (depth 0) must be a BIP-39 node.',\n        );\n      }\n\n      return;\n    }\n\n    assert(typeof nodeToken === 'string');\n\n    // eslint-disable-next-line default-case\n    switch (currentDepth) {\n      case 1:\n        if (nodeToken !== BIP44PurposeNodeToken) {\n          throw new Error(\n            `Invalid derivation path: The \"purpose\" node (depth 1) must be the string \"${BIP44PurposeNodeToken}\".`,\n          );\n        }\n        break;\n\n      case 2:\n        if (!BIP_32_PATH_REGEX.test(nodeToken) || !isHardened(nodeToken)) {\n          throw new Error(\n            'Invalid derivation path: The \"coin_type\" node (depth 2) must be a hardened BIP-32 node.',\n          );\n        }\n        break;\n\n      case 3:\n        if (!BIP_32_PATH_REGEX.test(nodeToken) || !isHardened(nodeToken)) {\n          throw new Error(\n            'Invalid derivation path: The \"account\" node (depth 3) must be a hardened BIP-32 node.',\n          );\n        }\n        break;\n\n      case 4:\n        if (!BIP_32_PATH_REGEX.test(nodeToken)) {\n          throw new Error(\n            'Invalid derivation path: The \"change\" node (depth 4) must be a BIP-32 node.',\n          );\n        }\n        break;\n\n      case MAX_BIP_44_DEPTH: // 5\n        if (!BIP_32_PATH_REGEX.test(nodeToken)) {\n          throw new Error(\n            'Invalid derivation path: The \"address_index\" node (depth 5) must be a BIP-32 node.',\n          );\n        }\n        break;\n    }\n  });\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/BIP44Node.d.cts b/node_modules/@metamask/key-tree/dist/BIP44Node.d.cts
index 47882c5..f9b5aa7 100644
--- a/node_modules/@metamask/key-tree/dist/BIP44Node.d.cts
+++ b/node_modules/@metamask/key-tree/dist/BIP44Node.d.cts
@@ -1,7 +1,8 @@
 import type { BIP44Depth, PartialHDPathTuple, RootedSLIP10PathTuple } from "./constants.cjs";
+import type { CryptographicFunctions } from "./cryptography.cjs";
 import type { SupportedCurve } from "./curves/index.cjs";
 import { SLIP10Node } from "./SLIP10Node.cjs";
-export declare type BIP44ExtendedKeyOptions = {
+export type BIP44ExtendedKeyOptions = {
     readonly depth: number;
     readonly parentFingerprint: number;
     readonly index: number;
@@ -9,7 +10,7 @@ export declare type BIP44ExtendedKeyOptions = {
     readonly privateKey?: Uint8Array | string | undefined;
     readonly publicKey?: Uint8Array | string | undefined;
 };
-export declare type BIP44DerivationPathOptions = {
+export type BIP44DerivationPathOptions = {
     readonly derivationPath: RootedSLIP10PathTuple;
 };
 /**
@@ -17,7 +18,7 @@ export declare type BIP44DerivationPathOptions = {
  * cryptographic keys used to generate keypairs and addresses for cryptocurrency
  * protocols.
  */
-export declare type JsonBIP44Node = {
+export type JsonBIP44Node = {
     /**
      * The 0-indexed BIP-44 path depth of this node.
      *
@@ -57,7 +58,7 @@ export declare type JsonBIP44Node = {
      */
     readonly chainCode: string;
 };
-export declare type BIP44NodeInterface = JsonBIP44Node & {
+export type BIP44NodeInterface = JsonBIP44Node & {
     /**
      * @returns A JSON-compatible representation of this node's data fields.
      */
@@ -78,8 +79,11 @@ export declare class BIP44Node implements BIP44NodeInterface {
      * for documentation.
      *
      * @param json - The JSON representation of a SLIP-10 node.
+     * @param cryptographicFunctions - The cryptographic functions to use. If
+     * provided, these will be used instead of the built-in implementations.
+     * @returns A BIP44 node.
      */
-    static fromJSON(json: JsonBIP44Node): Promise<BIP44Node>;
+    static fromJSON(json: JsonBIP44Node, cryptographicFunctions?: CryptographicFunctions): Promise<BIP44Node>;
     /**
      * Create a new BIP-44 node from a key and chain code. You must specify
      * either a private key or a public key. When specifying a private key,
@@ -95,8 +99,11 @@ export declare class BIP44Node implements BIP44NodeInterface {
      * @param options.publicKey - The public key for the node. If a private key is
      * specified, this parameter is ignored.
      * @param options.chainCode - The chain code for the node.
+     * @param cryptographicFunctions - The cryptographic functions to use. If
+     * provided, these will be used instead of the built-in implementations.
+     * @returns A BIP44 node.
      */
-    static fromExtendedKey(options: BIP44ExtendedKeyOptions | string): Promise<BIP44Node>;
+    static fromExtendedKey(options: BIP44ExtendedKeyOptions | string, cryptographicFunctions?: CryptographicFunctions): Promise<BIP44Node>;
     /**
      * Create a new BIP-44 node from a derivation path. The derivation path
      * must be rooted, i.e. it must begin with a BIP-39 node, given as a string of
@@ -117,8 +124,11 @@ export declare class BIP44Node implements BIP44NodeInterface {
      * @param options - An object containing the derivation path.
      * @param options.derivationPath - The rooted HD tree path that will be used
      * to derive the key of this node.
+     * @param cryptographicFunctions - The cryptographic functions to use. If
+     * provided, these will be used instead of the built-in implementations.
+     * @returns A BIP44 node.
      */
-    static fromDerivationPath({ derivationPath, }: BIP44DerivationPathOptions): Promise<BIP44Node>;
+    static fromDerivationPath({ derivationPath }: BIP44DerivationPathOptions, cryptographicFunctions?: CryptographicFunctions): Promise<BIP44Node>;
     get depth(): BIP44Depth;
     get privateKeyBytes(): Uint8Array | undefined;
     get publicKeyBytes(): Uint8Array;
diff --git a/node_modules/@metamask/key-tree/dist/BIP44Node.d.cts.map b/node_modules/@metamask/key-tree/dist/BIP44Node.d.cts.map
index eb36a56..c5ace06 100644
--- a/node_modules/@metamask/key-tree/dist/BIP44Node.d.cts.map
+++ b/node_modules/@metamask/key-tree/dist/BIP44Node.d.cts.map
@@ -1 +1 @@
-{"version":3,"file":"BIP44Node.d.cts","sourceRoot":"","sources":["../src/BIP44Node.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"BIP44Node.d.cts","sourceRoot":"","sources":["../src/BIP44Node.ts"],"names":[],"mappings":"AAEA,OAAO,KAAK,EACV,UAAU,EACV,kBAAkB,EAClB,qBAAqB,EAEtB,wBAAoB;AAQrB,OAAO,KAAK,EAAE,sBAAsB,EAAE,2BAAuB;AAC7D,OAAO,KAAK,EAAE,cAAc,EAAE,2BAAiB;AAE/C,OAAO,EAAE,UAAU,EAAsB,yBAAqB;AAG9D,MAAM,MAAM,uBAAuB,GAAG;IACpC,QAAQ,CAAC,KAAK,EAAE,MAAM,CAAC;IACvB,QAAQ,CAAC,iBAAiB,EAAE,MAAM,CAAC;IACnC,QAAQ,CAAC,KAAK,EAAE,MAAM,CAAC;IACvB,QAAQ,CAAC,SAAS,EAAE,UAAU,GAAG,MAAM,CAAC;IACxC,QAAQ,CAAC,UAAU,CAAC,EAAE,UAAU,GAAG,MAAM,GAAG,SAAS,CAAC;IACtD,QAAQ,CAAC,SAAS,CAAC,EAAE,UAAU,GAAG,MAAM,GAAG,SAAS,CAAC;CACtD,CAAC;AAEF,MAAM,MAAM,0BAA0B,GAAG;IACvC,QAAQ,CAAC,cAAc,EAAE,qBAAqB,CAAC;CAChD,CAAC;AAEF;;;;GAIG;AACH,MAAM,MAAM,aAAa,GAAG;IAC1B;;;;;;;;;;OAUG;IACH,QAAQ,CAAC,KAAK,EAAE,UAAU,CAAC;IAE3B;;;OAGG;IACH,QAAQ,CAAC,iBAAiB,CAAC,EAAE,MAAM,GAAG,SAAS,CAAC;IAEhD;;OAEG;IACH,QAAQ,CAAC,iBAAiB,EAAE,MAAM,CAAC;IAEnC;;OAEG;IACH,QAAQ,CAAC,KAAK,EAAE,MAAM,CAAC;IAEvB;;;OAGG;IACH,QAAQ,CAAC,UAAU,CAAC,EAAE,MAAM,GAAG,SAAS,CAAC;IAEzC;;OAEG;IACH,QAAQ,CAAC,SAAS,EAAE,MAAM,CAAC;IAE3B;;OAEG;IACH,QAAQ,CAAC,SAAS,EAAE,MAAM,CAAC;CAC5B,CAAC;AAEF,MAAM,MAAM,kBAAkB,GAAG,aAAa,GAAG;IAC/C;;OAEG;IACH,MAAM,IAAI,aAAa,CAAC;CACzB,CAAC;AAEF;;;;;;;GAOG;AACH,qBAAa,SAAU,YAAW,kBAAkB;;IAClD;;;;;;;;OAQG;WACU,QAAQ,CACnB,IAAI,EAAE,aAAa,EACnB,sBAAsB,CAAC,EAAE,sBAAsB,GAC9C,OAAO,CAAC,SAAS,CAAC;IAIrB;;;;;;;;;;;;;;;;;;OAkBG;WACU,eAAe,CAC1B,OAAO,EAAE,uBAAuB,GAAG,MAAM,EACzC,sBAAsB,CAAC,EAAE,sBAAsB,GAC9C,OAAO,CAAC,SAAS,CAAC;IA8DrB;;;;;;;;;;;;;;;;;;;;;;;OAuBG;WACU,kBAAkB,CAC7B,EAAE,cAAc,EAAE,EAAE,0BAA0B,EAC9C,sBAAsB,CAAC,EAAE,sBAAsB,GAC9C,OAAO,CAAC,SAAS,CAAC;IAiBrB,IAAW,KAAK,IAAI,UAAU,CAE7B;IAED,IAAW,eAAe,IAAI,UAAU,GAAG,SAAS,CAEnD;IAED,IAAW,cAAc,IAAI,UAAU,CAEtC;IAED,IAAW,cAAc,IAAI,UAAU,CAEtC;IAED,IAAW,UAAU,IAAI,MAAM,GAAG,SAAS,CAE1C;IAED,IAAW,SAAS,IAAI,MAAM,CAE7B;IAED,IAAW,mBAAmB,IAAI,MAAM,CAEvC;IAED,IAAW,wBAAwB,IAAI,UAAU,CAEhD;IAED,IAAW,SAAS,IAAI,MAAM,CAE7B;IAED,IAAW,OAAO,IAAI,MAAM,CAE3B;IAED,IAAW,iBAAiB,IAAI,MAAM,GAAG,SAAS,CAEjD;IAED,IAAW,iBAAiB,IAAI,MAAM,CAErC;IAED,IAAW,WAAW,IAAI,MAAM,CAE/B;IAED,IAAW,KAAK,IAAI,MAAM,CAEzB;IAED,IAAW,WAAW,IAAI,MAAM,CAE/B;IAED,IAAW,KAAK,IAAI,cAAc,CAEjC;gBAEW,IAAI,EAAE,UAAU;IAM5B;;;;OAIG;IACI,MAAM,IAAI,SAAS;IAK1B;;;;;;;;;;;;;;;;;;;OAmBG;IACU,MAAM,CAAC,IAAI,EAAE,kBAAkB,GAAG,OAAO,CAAC,SAAS,CAAC;IAiB1D,MAAM,IAAI,aAAa;CAW/B;AAED;;;;;;GAMG;AACH,wBAAgB,kBAAkB,CAChC,KAAK,EAAE,OAAO,GACb,OAAO,CAAC,KAAK,IAAI,UAAU,CAQ7B"}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/BIP44Node.d.mts b/node_modules/@metamask/key-tree/dist/BIP44Node.d.mts
index 00a92c1..715a38c 100644
--- a/node_modules/@metamask/key-tree/dist/BIP44Node.d.mts
+++ b/node_modules/@metamask/key-tree/dist/BIP44Node.d.mts
@@ -1,7 +1,8 @@
 import type { BIP44Depth, PartialHDPathTuple, RootedSLIP10PathTuple } from "./constants.mjs";
+import type { CryptographicFunctions } from "./cryptography.mjs";
 import type { SupportedCurve } from "./curves/index.mjs";
 import { SLIP10Node } from "./SLIP10Node.mjs";
-export declare type BIP44ExtendedKeyOptions = {
+export type BIP44ExtendedKeyOptions = {
     readonly depth: number;
     readonly parentFingerprint: number;
     readonly index: number;
@@ -9,7 +10,7 @@ export declare type BIP44ExtendedKeyOptions = {
     readonly privateKey?: Uint8Array | string | undefined;
     readonly publicKey?: Uint8Array | string | undefined;
 };
-export declare type BIP44DerivationPathOptions = {
+export type BIP44DerivationPathOptions = {
     readonly derivationPath: RootedSLIP10PathTuple;
 };
 /**
@@ -17,7 +18,7 @@ export declare type BIP44DerivationPathOptions = {
  * cryptographic keys used to generate keypairs and addresses for cryptocurrency
  * protocols.
  */
-export declare type JsonBIP44Node = {
+export type JsonBIP44Node = {
     /**
      * The 0-indexed BIP-44 path depth of this node.
      *
@@ -57,7 +58,7 @@ export declare type JsonBIP44Node = {
      */
     readonly chainCode: string;
 };
-export declare type BIP44NodeInterface = JsonBIP44Node & {
+export type BIP44NodeInterface = JsonBIP44Node & {
     /**
      * @returns A JSON-compatible representation of this node's data fields.
      */
@@ -78,8 +79,11 @@ export declare class BIP44Node implements BIP44NodeInterface {
      * for documentation.
      *
      * @param json - The JSON representation of a SLIP-10 node.
+     * @param cryptographicFunctions - The cryptographic functions to use. If
+     * provided, these will be used instead of the built-in implementations.
+     * @returns A BIP44 node.
      */
-    static fromJSON(json: JsonBIP44Node): Promise<BIP44Node>;
+    static fromJSON(json: JsonBIP44Node, cryptographicFunctions?: CryptographicFunctions): Promise<BIP44Node>;
     /**
      * Create a new BIP-44 node from a key and chain code. You must specify
      * either a private key or a public key. When specifying a private key,
@@ -95,8 +99,11 @@ export declare class BIP44Node implements BIP44NodeInterface {
      * @param options.publicKey - The public key for the node. If a private key is
      * specified, this parameter is ignored.
      * @param options.chainCode - The chain code for the node.
+     * @param cryptographicFunctions - The cryptographic functions to use. If
+     * provided, these will be used instead of the built-in implementations.
+     * @returns A BIP44 node.
      */
-    static fromExtendedKey(options: BIP44ExtendedKeyOptions | string): Promise<BIP44Node>;
+    static fromExtendedKey(options: BIP44ExtendedKeyOptions | string, cryptographicFunctions?: CryptographicFunctions): Promise<BIP44Node>;
     /**
      * Create a new BIP-44 node from a derivation path. The derivation path
      * must be rooted, i.e. it must begin with a BIP-39 node, given as a string of
@@ -117,8 +124,11 @@ export declare class BIP44Node implements BIP44NodeInterface {
      * @param options - An object containing the derivation path.
      * @param options.derivationPath - The rooted HD tree path that will be used
      * to derive the key of this node.
+     * @param cryptographicFunctions - The cryptographic functions to use. If
+     * provided, these will be used instead of the built-in implementations.
+     * @returns A BIP44 node.
      */
-    static fromDerivationPath({ derivationPath, }: BIP44DerivationPathOptions): Promise<BIP44Node>;
+    static fromDerivationPath({ derivationPath }: BIP44DerivationPathOptions, cryptographicFunctions?: CryptographicFunctions): Promise<BIP44Node>;
     get depth(): BIP44Depth;
     get privateKeyBytes(): Uint8Array | undefined;
     get publicKeyBytes(): Uint8Array;
diff --git a/node_modules/@metamask/key-tree/dist/BIP44Node.d.mts.map b/node_modules/@metamask/key-tree/dist/BIP44Node.d.mts.map
index 9c3a573..403b7fb 100644
--- a/node_modules/@metamask/key-tree/dist/BIP44Node.d.mts.map
+++ b/node_modules/@metamask/key-tree/dist/BIP44Node.d.mts.map
@@ -1 +1 @@
-{"version":3,"file":"BIP44Node.d.mts","sourceRoot":"","sources":["../src/BIP44Node.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"BIP44Node.d.mts","sourceRoot":"","sources":["../src/BIP44Node.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/BIP44Node.mjs b/node_modules/@metamask/key-tree/dist/BIP44Node.mjs
index 4613b77..437ae7c 100644
--- a/node_modules/@metamask/key-tree/dist/BIP44Node.mjs
+++ b/node_modules/@metamask/key-tree/dist/BIP44Node.mjs
@@ -1,18 +1,18 @@
+var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
+    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
+};
 var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
     if (kind === "m") throw new TypeError("Private method is not writable");
     if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
     if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
     return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
 };
-var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
-    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
-    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
-    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
-};
 var _BIP44Node_node;
 import { assert } from "@metamask/utils";
 import { BIP44PurposeNodeToken, BIP_32_PATH_REGEX, BIP_39_PATH_REGEX, MAX_BIP_44_DEPTH, MIN_BIP_44_DEPTH } from "./constants.mjs";
-import { decodeExtendedKey, encodeExtendedKey, PRIVATE_KEY_VERSION, PUBLIC_KEY_VERSION } from "./extended-keys.mjs";
+import { decodeExtendedKey, PRIVATE_KEY_VERSION } from "./extended-keys.mjs";
 import { SLIP10Node, validateBIP32Depth } from "./SLIP10Node.mjs";
 import { isHardened } from "./utils.mjs";
 /**
@@ -24,19 +24,17 @@ import { isHardened } from "./utils.mjs";
  * {@link BIP44Node.toJSON} to get a JSON-compatible representation.
  */
 export class BIP44Node {
-    constructor(node) {
-        _BIP44Node_node.set(this, void 0);
-        __classPrivateFieldSet(this, _BIP44Node_node, node, "f");
-        Object.freeze(this);
-    }
     /**
      * Wrapper of the {@link fromExtendedKey} function. Refer to that function
      * for documentation.
      *
      * @param json - The JSON representation of a SLIP-10 node.
+     * @param cryptographicFunctions - The cryptographic functions to use. If
+     * provided, these will be used instead of the built-in implementations.
+     * @returns A BIP44 node.
      */
-    static async fromJSON(json) {
-        return BIP44Node.fromExtendedKey(json);
+    static async fromJSON(json, cryptographicFunctions) {
+        return BIP44Node.fromExtendedKey(json, cryptographicFunctions);
     }
     /**
      * Create a new BIP-44 node from a key and chain code. You must specify
@@ -53,8 +51,11 @@ export class BIP44Node {
      * @param options.publicKey - The public key for the node. If a private key is
      * specified, this parameter is ignored.
      * @param options.chainCode - The chain code for the node.
+     * @param cryptographicFunctions - The cryptographic functions to use. If
+     * provided, these will be used instead of the built-in implementations.
+     * @returns A BIP44 node.
      */
-    static async fromExtendedKey(options) {
+    static async fromExtendedKey(options, cryptographicFunctions) {
         if (typeof options === 'string') {
             const extendedKey = decodeExtendedKey(options);
             const { chainCode, depth, parentFingerprint, index } = extendedKey;
@@ -66,7 +67,7 @@ export class BIP44Node {
                     index,
                     privateKey,
                     chainCode,
-                });
+                }, cryptographicFunctions);
             }
             const { publicKey } = extendedKey;
             return BIP44Node.fromExtendedKey({
@@ -75,7 +76,7 @@ export class BIP44Node {
                 index,
                 publicKey,
                 chainCode,
-            });
+            }, cryptographicFunctions);
         }
         const { privateKey, publicKey, chainCode, depth, parentFingerprint, index, } = options;
         validateBIP44Depth(depth);
@@ -87,7 +88,7 @@ export class BIP44Node {
             parentFingerprint,
             index,
             curve: 'secp256k1',
-        });
+        }, cryptographicFunctions);
         return new BIP44Node(node);
     }
     /**
@@ -110,14 +111,17 @@ export class BIP44Node {
      * @param options - An object containing the derivation path.
      * @param options.derivationPath - The rooted HD tree path that will be used
      * to derive the key of this node.
+     * @param cryptographicFunctions - The cryptographic functions to use. If
+     * provided, these will be used instead of the built-in implementations.
+     * @returns A BIP44 node.
      */
-    static async fromDerivationPath({ derivationPath, }) {
+    static async fromDerivationPath({ derivationPath }, cryptographicFunctions) {
         validateBIP44Depth(derivationPath.length - 1);
         validateBIP44DerivationPath(derivationPath, MIN_BIP_44_DEPTH);
         const node = await SLIP10Node.fromDerivationPath({
             derivationPath,
             curve: 'secp256k1',
-        });
+        }, cryptographicFunctions);
         return new BIP44Node(node);
     }
     get depth() {
@@ -163,28 +167,16 @@ export class BIP44Node {
         return __classPrivateFieldGet(this, _BIP44Node_node, "f").index;
     }
     get extendedKey() {
-        const data = {
-            depth: this.depth,
-            parentFingerprint: this.parentFingerprint,
-            index: this.index,
-            chainCode: this.chainCodeBytes,
-        };
-        if (this.privateKeyBytes) {
-            return encodeExtendedKey({
-                ...data,
-                version: PRIVATE_KEY_VERSION,
-                privateKey: this.privateKeyBytes,
-            });
-        }
-        return encodeExtendedKey({
-            ...data,
-            version: PUBLIC_KEY_VERSION,
-            publicKey: this.publicKeyBytes,
-        });
+        return __classPrivateFieldGet(this, _BIP44Node_node, "f").extendedKey;
     }
     get curve() {
         return __classPrivateFieldGet(this, _BIP44Node_node, "f").curve;
     }
+    constructor(node) {
+        _BIP44Node_node.set(this, void 0);
+        __classPrivateFieldSet(this, _BIP44Node_node, node, "f");
+        Object.freeze(this);
+    }
     /**
      * Get a neutered version of this node, i.e. a node without a private key.
      *
diff --git a/node_modules/@metamask/key-tree/dist/BIP44Node.mjs.map b/node_modules/@metamask/key-tree/dist/BIP44Node.mjs.map
index acdc4cd..ff2f7e2 100644
--- a/node_modules/@metamask/key-tree/dist/BIP44Node.mjs.map
+++ b/node_modules/@metamask/key-tree/dist/BIP44Node.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"BIP44Node.mjs","sourceRoot":"","sources":["../src/BIP44Node.ts"],"names":[],"mappings":"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","sourcesContent":["import { assert } from '@metamask/utils';\n\nimport type {\n  BIP44Depth,\n  PartialHDPathTuple,\n  RootedSLIP10PathTuple,\n  SLIP10Path,\n} from './constants';\nimport {\n  BIP44PurposeNodeToken,\n  BIP_32_PATH_REGEX,\n  BIP_39_PATH_REGEX,\n  MAX_BIP_44_DEPTH,\n  MIN_BIP_44_DEPTH,\n} from './constants';\nimport type { SupportedCurve } from './curves';\nimport {\n  decodeExtendedKey,\n  encodeExtendedKey,\n  PRIVATE_KEY_VERSION,\n  PUBLIC_KEY_VERSION,\n} from './extended-keys';\nimport { SLIP10Node, validateBIP32Depth } from './SLIP10Node';\nimport { isHardened } from './utils';\n\nexport type BIP44ExtendedKeyOptions = {\n  readonly depth: number;\n  readonly parentFingerprint: number;\n  readonly index: number;\n  readonly chainCode: Uint8Array | string;\n  readonly privateKey?: Uint8Array | string | undefined;\n  readonly publicKey?: Uint8Array | string | undefined;\n};\n\nexport type BIP44DerivationPathOptions = {\n  readonly derivationPath: RootedSLIP10PathTuple;\n};\n\n/**\n * A wrapper for BIP-44 Hierarchical Deterministic (HD) tree nodes, i.e.\n * cryptographic keys used to generate keypairs and addresses for cryptocurrency\n * protocols.\n */\nexport type JsonBIP44Node = {\n  /**\n   * The 0-indexed BIP-44 path depth of this node.\n   *\n   * A BIP-44 path is of the form:\n   *\n   * `m / 44' / coin_type' / account' / change / address_index`\n   *\n   * With the following depths:\n   *\n   * `0 / 1 / 2 / 3 / 4 / 5`\n   */\n  readonly depth: BIP44Depth;\n\n  /**\n   * The fingerprint of the master node, i.e., the node at depth 0. May be\n   * undefined if this node was created from an extended key.\n   */\n  readonly masterFingerprint?: number | undefined;\n\n  /**\n   * The fingerprint of the parent key, or 0 if this is a master node.\n   */\n  readonly parentFingerprint: number;\n\n  /**\n   * The index of the node, or 0 if this is a master node.\n   */\n  readonly index: number;\n\n  /**\n   * The hexadecimal string representation of the private key for this node.\n   * May be `undefined` if the node is a public node.\n   */\n  readonly privateKey?: string | undefined;\n\n  /**\n   * The hexadecimal string representation of the public key for this node.\n   */\n  readonly publicKey: string;\n\n  /**\n   * The hexadecimal string representation of the chain code for this node.\n   */\n  readonly chainCode: string;\n};\n\nexport type BIP44NodeInterface = JsonBIP44Node & {\n  /**\n   * @returns A JSON-compatible representation of this node's data fields.\n   */\n  toJSON(): JsonBIP44Node;\n};\n\n/**\n * A wrapper for BIP-44 Hierarchical Deterministic (HD) tree nodes, i.e.\n * cryptographic keys used to generate keypairs and addresses for cryptocurrency\n * protocols.\n *\n * This class contains methods and fields that may not serialize well. Use\n * {@link BIP44Node.toJSON} to get a JSON-compatible representation.\n */\nexport class BIP44Node implements BIP44NodeInterface {\n  /**\n   * Wrapper of the {@link fromExtendedKey} function. Refer to that function\n   * for documentation.\n   *\n   * @param json - The JSON representation of a SLIP-10 node.\n   */\n  static async fromJSON(json: JsonBIP44Node): Promise<BIP44Node> {\n    return BIP44Node.fromExtendedKey(json);\n  }\n\n  /**\n   * Create a new BIP-44 node from a key and chain code. You must specify\n   * either a private key or a public key. When specifying a private key,\n   * the public key will be derived from the private key.\n   *\n   * All parameters are stringently validated, and an error is thrown if\n   * validation fails.\n   *\n   * @param options - An object containing the extended key, or an extended\n   * public (xpub) or private (xprv) key.\n   * @param options.depth - The depth of the node.\n   * @param options.privateKey - The private key for the node.\n   * @param options.publicKey - The public key for the node. If a private key is\n   * specified, this parameter is ignored.\n   * @param options.chainCode - The chain code for the node.\n   */\n  static async fromExtendedKey(\n    options: BIP44ExtendedKeyOptions | string,\n  ): Promise<BIP44Node> {\n    if (typeof options === 'string') {\n      const extendedKey = decodeExtendedKey(options);\n\n      const { chainCode, depth, parentFingerprint, index } = extendedKey;\n\n      if (extendedKey.version === PRIVATE_KEY_VERSION) {\n        const { privateKey } = extendedKey;\n\n        return BIP44Node.fromExtendedKey({\n          depth,\n          parentFingerprint,\n          index,\n          privateKey,\n          chainCode,\n        });\n      }\n\n      const { publicKey } = extendedKey;\n\n      return BIP44Node.fromExtendedKey({\n        depth,\n        parentFingerprint,\n        index,\n        publicKey,\n        chainCode,\n      });\n    }\n\n    const {\n      privateKey,\n      publicKey,\n      chainCode,\n      depth,\n      parentFingerprint,\n      index,\n    } = options;\n\n    validateBIP44Depth(depth);\n\n    const node = await SLIP10Node.fromExtendedKey({\n      privateKey,\n      publicKey,\n      chainCode,\n      depth,\n      parentFingerprint,\n      index,\n      curve: 'secp256k1',\n    });\n\n    return new BIP44Node(node);\n  }\n\n  /**\n   * Create a new BIP-44 node from a derivation path. The derivation path\n   * must be rooted, i.e. it must begin with a BIP-39 node, given as a string of\n   * the form `bip39:MNEMONIC`, where `MNEMONIC` is a space-separated list of\n   * BIP-39 seed phrase words.\n   *\n   * All parameters are stringently validated, and an error is thrown if\n   * validation fails.\n   *\n   * Recall that a BIP-44 HD tree path consists of the following nodes:\n   *\n   * `m / 44' / coin_type' / account' / change / address_index`\n   *\n   * With the following depths:\n   *\n   * `0 / 1 / 2 / 3 / 4 / 5`\n   *\n   * @param options - An object containing the derivation path.\n   * @param options.derivationPath - The rooted HD tree path that will be used\n   * to derive the key of this node.\n   */\n  static async fromDerivationPath({\n    derivationPath,\n  }: BIP44DerivationPathOptions): Promise<BIP44Node> {\n    validateBIP44Depth(derivationPath.length - 1);\n    validateBIP44DerivationPath(derivationPath, MIN_BIP_44_DEPTH);\n\n    const node = await SLIP10Node.fromDerivationPath({\n      derivationPath,\n      curve: 'secp256k1',\n    });\n\n    return new BIP44Node(node);\n  }\n\n  #node: SLIP10Node;\n\n  public get depth(): BIP44Depth {\n    return this.#node.depth as BIP44Depth;\n  }\n\n  public get privateKeyBytes(): Uint8Array | undefined {\n    return this.#node.privateKeyBytes;\n  }\n\n  public get publicKeyBytes(): Uint8Array {\n    return this.#node.publicKeyBytes;\n  }\n\n  public get chainCodeBytes(): Uint8Array {\n    return this.#node.chainCodeBytes;\n  }\n\n  public get privateKey(): string | undefined {\n    return this.#node.privateKey;\n  }\n\n  public get publicKey(): string {\n    return this.#node.publicKey;\n  }\n\n  public get compressedPublicKey(): string {\n    return this.#node.compressedPublicKey;\n  }\n\n  public get compressedPublicKeyBytes(): Uint8Array {\n    return this.#node.compressedPublicKeyBytes;\n  }\n\n  public get chainCode(): string {\n    return this.#node.chainCode;\n  }\n\n  public get address(): string {\n    return this.#node.address;\n  }\n\n  public get masterFingerprint(): number | undefined {\n    return this.#node.masterFingerprint;\n  }\n\n  public get parentFingerprint(): number {\n    return this.#node.parentFingerprint;\n  }\n\n  public get fingerprint(): number {\n    return this.#node.fingerprint;\n  }\n\n  public get index(): number {\n    return this.#node.index;\n  }\n\n  public get extendedKey(): string {\n    const data = {\n      depth: this.depth,\n      parentFingerprint: this.parentFingerprint,\n      index: this.index,\n      chainCode: this.chainCodeBytes,\n    };\n\n    if (this.privateKeyBytes) {\n      return encodeExtendedKey({\n        ...data,\n        version: PRIVATE_KEY_VERSION,\n        privateKey: this.privateKeyBytes,\n      });\n    }\n\n    return encodeExtendedKey({\n      ...data,\n      version: PUBLIC_KEY_VERSION,\n      publicKey: this.publicKeyBytes,\n    });\n  }\n\n  public get curve(): SupportedCurve {\n    return this.#node.curve;\n  }\n\n  constructor(node: SLIP10Node) {\n    this.#node = node;\n\n    Object.freeze(this);\n  }\n\n  /**\n   * Get a neutered version of this node, i.e. a node without a private key.\n   *\n   * @returns A neutered version of this node.\n   */\n  public neuter(): BIP44Node {\n    const node = this.#node.neuter();\n    return new BIP44Node(node);\n  }\n\n  /**\n   * Derives a child of the key contains be this node and returns a new\n   * {@link BIP44Node} containing the child key.\n   *\n   * The specified path must be a valid HD path from this node, per BIP-44.\n   * At present, this means that the path must consist of no more than 5 BIP-32\n   * nodes, depending on the depth of this node.\n   *\n   * Recall that a BIP-44 HD tree path consists of the following nodes:\n   *\n   * `m / 44' / coin_type' / account' / change / address_index`\n   *\n   * With the following depths:\n   *\n   * `0 / 1 / 2 / 3 / 4 / 5`\n   *\n   * @param path - The partial (non-rooted) BIP-44 HD tree path will be used\n   * to derive a child key from the parent key contained within this node.\n   * @returns The {@link BIP44Node} corresponding to the derived child key.\n   */\n  public async derive(path: PartialHDPathTuple): Promise<BIP44Node> {\n    if (this.depth === MAX_BIP_44_DEPTH) {\n      throw new Error(\n        'Illegal operation: This HD tree node is already a leaf node.',\n      );\n    }\n\n    const newDepth = this.depth + path.length;\n\n    validateBIP44Depth(newDepth);\n    validateBIP44DerivationPath(path, (this.depth + 1) as BIP44Depth);\n\n    const node = await this.#node.derive(path);\n    return new BIP44Node(node);\n  }\n\n  // This is documented in the interface of this class.\n  public toJSON(): JsonBIP44Node {\n    return {\n      depth: this.depth,\n      masterFingerprint: this.masterFingerprint,\n      parentFingerprint: this.parentFingerprint,\n      index: this.index,\n      privateKey: this.privateKey,\n      publicKey: this.publicKey,\n      chainCode: this.chainCode,\n    };\n  }\n}\n\n/**\n * Validates a BIP-44 path depth. Effectively, asserts that the depth is an\n * integer `number` N such that 0 <= N <= 5. Throws an error if validation\n * fails.\n *\n * @param depth - The depth to validate.\n */\nexport function validateBIP44Depth(\n  depth: unknown,\n): asserts depth is BIP44Depth {\n  validateBIP32Depth(depth);\n\n  if (depth < MIN_BIP_44_DEPTH || depth > MAX_BIP_44_DEPTH) {\n    throw new Error(\n      `Invalid HD tree path depth: The depth must be a positive integer N such that 0 <= N <= 5. Received: \"${depth}\"`,\n    );\n  }\n}\n\n/**\n * Ensures that the given derivation is valid by BIP-44.\n *\n * Recall that a BIP-44 HD tree path consists of the following nodes:\n *\n * `m / 44' / coin_type' / account' / change / address_index`\n *\n * With the following depths:\n *\n * `0 / 1 / 2 / 3 / 4 / 5`\n *\n * @param path - The path to validate.\n * @param startingDepth - The depth of the first node of the derivation path.\n */\nfunction validateBIP44DerivationPath(\n  path: SLIP10Path,\n  startingDepth: BIP44Depth,\n) {\n  path.forEach((nodeToken, index) => {\n    const currentDepth = startingDepth + index;\n\n    if (currentDepth === MIN_BIP_44_DEPTH) {\n      if (\n        !(nodeToken instanceof Uint8Array) &&\n        !BIP_39_PATH_REGEX.test(nodeToken)\n      ) {\n        throw new Error(\n          'Invalid derivation path: The \"m\" / seed node (depth 0) must be a BIP-39 node.',\n        );\n      }\n\n      return;\n    }\n\n    assert(typeof nodeToken === 'string');\n\n    // eslint-disable-next-line default-case\n    switch (currentDepth) {\n      case 1:\n        if (nodeToken !== BIP44PurposeNodeToken) {\n          throw new Error(\n            `Invalid derivation path: The \"purpose\" node (depth 1) must be the string \"${BIP44PurposeNodeToken}\".`,\n          );\n        }\n        break;\n\n      case 2:\n        if (!BIP_32_PATH_REGEX.test(nodeToken) || !isHardened(nodeToken)) {\n          throw new Error(\n            'Invalid derivation path: The \"coin_type\" node (depth 2) must be a hardened BIP-32 node.',\n          );\n        }\n        break;\n\n      case 3:\n        if (!BIP_32_PATH_REGEX.test(nodeToken) || !isHardened(nodeToken)) {\n          throw new Error(\n            'Invalid derivation path: The \"account\" node (depth 3) must be a hardened BIP-32 node.',\n          );\n        }\n        break;\n\n      case 4:\n        if (!BIP_32_PATH_REGEX.test(nodeToken)) {\n          throw new Error(\n            'Invalid derivation path: The \"change\" node (depth 4) must be a BIP-32 node.',\n          );\n        }\n        break;\n\n      case MAX_BIP_44_DEPTH: // 5\n        if (!BIP_32_PATH_REGEX.test(nodeToken)) {\n          throw new Error(\n            'Invalid derivation path: The \"address_index\" node (depth 5) must be a BIP-32 node.',\n          );\n        }\n        break;\n    }\n  });\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"BIP44Node.mjs","sourceRoot":"","sources":["../src/BIP44Node.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,OAAO,EAAE,MAAM,EAAE,wBAAwB;AAQzC,OAAO,EACL,qBAAqB,EACrB,iBAAiB,EACjB,iBAAiB,EACjB,gBAAgB,EAChB,gBAAgB,EACjB,wBAAoB;AAGrB,OAAO,EAAE,iBAAiB,EAAE,mBAAmB,EAAE,4BAAwB;AACzE,OAAO,EAAE,UAAU,EAAE,kBAAkB,EAAE,yBAAqB;AAC9D,OAAO,EAAE,UAAU,EAAE,oBAAgB;AA0ErC;;;;;;;GAOG;AACH,MAAM,OAAO,SAAS;IACpB;;;;;;;;OAQG;IACH,MAAM,CAAC,KAAK,CAAC,QAAQ,CACnB,IAAmB,EACnB,sBAA+C;QAE/C,OAAO,SAAS,CAAC,eAAe,CAAC,IAAI,EAAE,sBAAsB,CAAC,CAAC;IACjE,CAAC;IAED;;;;;;;;;;;;;;;;;;OAkBG;IACH,MAAM,CAAC,KAAK,CAAC,eAAe,CAC1B,OAAyC,EACzC,sBAA+C;QAE/C,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE,CAAC;YAChC,MAAM,WAAW,GAAG,iBAAiB,CAAC,OAAO,CAAC,CAAC;YAE/C,MAAM,EAAE,SAAS,EAAE,KAAK,EAAE,iBAAiB,EAAE,KAAK,EAAE,GAAG,WAAW,CAAC;YAEnE,IAAI,WAAW,CAAC,OAAO,KAAK,mBAAmB,EAAE,CAAC;gBAChD,MAAM,EAAE,UAAU,EAAE,GAAG,WAAW,CAAC;gBAEnC,OAAO,SAAS,CAAC,eAAe,CAC9B;oBACE,KAAK;oBACL,iBAAiB;oBACjB,KAAK;oBACL,UAAU;oBACV,SAAS;iBACV,EACD,sBAAsB,CACvB,CAAC;YACJ,CAAC;YAED,MAAM,EAAE,SAAS,EAAE,GAAG,WAAW,CAAC;YAElC,OAAO,SAAS,CAAC,eAAe,CAC9B;gBACE,KAAK;gBACL,iBAAiB;gBACjB,KAAK;gBACL,SAAS;gBACT,SAAS;aACV,EACD,sBAAsB,CACvB,CAAC;QACJ,CAAC;QAED,MAAM,EACJ,UAAU,EACV,SAAS,EACT,SAAS,EACT,KAAK,EACL,iBAAiB,EACjB,KAAK,GACN,GAAG,OAAO,CAAC;QAEZ,kBAAkB,CAAC,KAAK,CAAC,CAAC;QAE1B,MAAM,IAAI,GAAG,MAAM,UAAU,CAAC,eAAe,CAC3C;YACE,UAAU;YACV,SAAS;YACT,SAAS;YACT,KAAK;YACL,iBAAiB;YACjB,KAAK;YACL,KAAK,EAAE,WAAW;SACnB,EACD,sBAAsB,CACvB,CAAC;QAEF,OAAO,IAAI,SAAS,CAAC,IAAI,CAAC,CAAC;IAC7B,CAAC;IAED;;;;;;;;;;;;;;;;;;;;;;;OAuBG;IACH,MAAM,CAAC,KAAK,CAAC,kBAAkB,CAC7B,EAAE,cAAc,EAA8B,EAC9C,sBAA+C;QAE/C,kBAAkB,CAAC,cAAc,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QAC9C,2BAA2B,CAAC,cAAc,EAAE,gBAAgB,CAAC,CAAC;QAE9D,MAAM,IAAI,GAAG,MAAM,UAAU,CAAC,kBAAkB,CAC9C;YACE,cAAc;YACd,KAAK,EAAE,WAAW;SACnB,EACD,sBAAsB,CACvB,CAAC;QAEF,OAAO,IAAI,SAAS,CAAC,IAAI,CAAC,CAAC;IAC7B,CAAC;IAID,IAAW,KAAK;QACd,OAAO,uBAAA,IAAI,uBAAM,CAAC,KAAmB,CAAC;IACxC,CAAC;IAED,IAAW,eAAe;QACxB,OAAO,uBAAA,IAAI,uBAAM,CAAC,eAAe,CAAC;IACpC,CAAC;IAED,IAAW,cAAc;QACvB,OAAO,uBAAA,IAAI,uBAAM,CAAC,cAAc,CAAC;IACnC,CAAC;IAED,IAAW,cAAc;QACvB,OAAO,uBAAA,IAAI,uBAAM,CAAC,cAAc,CAAC;IACnC,CAAC;IAED,IAAW,UAAU;QACnB,OAAO,uBAAA,IAAI,uBAAM,CAAC,UAAU,CAAC;IAC/B,CAAC;IAED,IAAW,SAAS;QAClB,OAAO,uBAAA,IAAI,uBAAM,CAAC,SAAS,CAAC;IAC9B,CAAC;IAED,IAAW,mBAAmB;QAC5B,OAAO,uBAAA,IAAI,uBAAM,CAAC,mBAAmB,CAAC;IACxC,CAAC;IAED,IAAW,wBAAwB;QACjC,OAAO,uBAAA,IAAI,uBAAM,CAAC,wBAAwB,CAAC;IAC7C,CAAC;IAED,IAAW,SAAS;QAClB,OAAO,uBAAA,IAAI,uBAAM,CAAC,SAAS,CAAC;IAC9B,CAAC;IAED,IAAW,OAAO;QAChB,OAAO,uBAAA,IAAI,uBAAM,CAAC,OAAO,CAAC;IAC5B,CAAC;IAED,IAAW,iBAAiB;QAC1B,OAAO,uBAAA,IAAI,uBAAM,CAAC,iBAAiB,CAAC;IACtC,CAAC;IAED,IAAW,iBAAiB;QAC1B,OAAO,uBAAA,IAAI,uBAAM,CAAC,iBAAiB,CAAC;IACtC,CAAC;IAED,IAAW,WAAW;QACpB,OAAO,uBAAA,IAAI,uBAAM,CAAC,WAAW,CAAC;IAChC,CAAC;IAED,IAAW,KAAK;QACd,OAAO,uBAAA,IAAI,uBAAM,CAAC,KAAK,CAAC;IAC1B,CAAC;IAED,IAAW,WAAW;QACpB,OAAO,uBAAA,IAAI,uBAAM,CAAC,WAAW,CAAC;IAChC,CAAC;IAED,IAAW,KAAK;QACd,OAAO,uBAAA,IAAI,uBAAM,CAAC,KAAK,CAAC;IAC1B,CAAC;IAED,YAAY,IAAgB;QAlEnB,kCAAkB;QAmEzB,uBAAA,IAAI,mBAAS,IAAI,MAAA,CAAC;QAElB,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IACtB,CAAC;IAED;;;;OAIG;IACI,MAAM;QACX,MAAM,IAAI,GAAG,uBAAA,IAAI,uBAAM,CAAC,MAAM,EAAE,CAAC;QACjC,OAAO,IAAI,SAAS,CAAC,IAAI,CAAC,CAAC;IAC7B,CAAC;IAED;;;;;;;;;;;;;;;;;;;OAmBG;IACI,KAAK,CAAC,MAAM,CAAC,IAAwB;QAC1C,IAAI,IAAI,CAAC,KAAK,KAAK,gBAAgB,EAAE,CAAC;YACpC,MAAM,IAAI,KAAK,CACb,8DAA8D,CAC/D,CAAC;QACJ,CAAC;QAED,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC;QAE1C,kBAAkB,CAAC,QAAQ,CAAC,CAAC;QAC7B,2BAA2B,CAAC,IAAI,EAAE,CAAC,IAAI,CAAC,KAAK,GAAG,CAAC,CAAe,CAAC,CAAC;QAElE,MAAM,IAAI,GAAG,MAAM,uBAAA,IAAI,uBAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QAC3C,OAAO,IAAI,SAAS,CAAC,IAAI,CAAC,CAAC;IAC7B,CAAC;IAED,qDAAqD;IAC9C,MAAM;QACX,OAAO;YACL,KAAK,EAAE,IAAI,CAAC,KAAK;YACjB,iBAAiB,EAAE,IAAI,CAAC,iBAAiB;YACzC,iBAAiB,EAAE,IAAI,CAAC,iBAAiB;YACzC,KAAK,EAAE,IAAI,CAAC,KAAK;YACjB,UAAU,EAAE,IAAI,CAAC,UAAU;YAC3B,SAAS,EAAE,IAAI,CAAC,SAAS;YACzB,SAAS,EAAE,IAAI,CAAC,SAAS;SAC1B,CAAC;IACJ,CAAC;CACF;;AAED;;;;;;GAMG;AACH,MAAM,UAAU,kBAAkB,CAChC,KAAc;IAEd,kBAAkB,CAAC,KAAK,CAAC,CAAC;IAE1B,IAAI,KAAK,GAAG,gBAAgB,IAAI,KAAK,GAAG,gBAAgB,EAAE,CAAC;QACzD,MAAM,IAAI,KAAK,CACb,wGAAwG,KAAK,GAAG,CACjH,CAAC;IACJ,CAAC;AACH,CAAC;AAED;;;;;;;;;;;;;GAaG;AACH,SAAS,2BAA2B,CAClC,IAAgB,EAChB,aAAyB;IAEzB,IAAI,CAAC,OAAO,CAAC,CAAC,SAAS,EAAE,KAAK,EAAE,EAAE;QAChC,MAAM,YAAY,GAAG,aAAa,GAAG,KAAK,CAAC;QAE3C,IAAI,YAAY,KAAK,gBAAgB,EAAE,CAAC;YACtC,IACE,CAAC,CAAC,SAAS,YAAY,UAAU,CAAC;gBAClC,CAAC,iBAAiB,CAAC,IAAI,CAAC,SAAS,CAAC,EAClC,CAAC;gBACD,MAAM,IAAI,KAAK,CACb,+EAA+E,CAChF,CAAC;YACJ,CAAC;YAED,OAAO;QACT,CAAC;QAED,MAAM,CAAC,OAAO,SAAS,KAAK,QAAQ,CAAC,CAAC;QAEtC,wCAAwC;QACxC,QAAQ,YAAY,EAAE,CAAC;YACrB,KAAK,CAAC;gBACJ,IAAI,SAAS,KAAK,qBAAqB,EAAE,CAAC;oBACxC,MAAM,IAAI,KAAK,CACb,6EAA6E,qBAAqB,IAAI,CACvG,CAAC;gBACJ,CAAC;gBACD,MAAM;YAER,KAAK,CAAC;gBACJ,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,EAAE,CAAC;oBACjE,MAAM,IAAI,KAAK,CACb,yFAAyF,CAC1F,CAAC;gBACJ,CAAC;gBACD,MAAM;YAER,KAAK,CAAC;gBACJ,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,EAAE,CAAC;oBACjE,MAAM,IAAI,KAAK,CACb,uFAAuF,CACxF,CAAC;gBACJ,CAAC;gBACD,MAAM;YAER,KAAK,CAAC;gBACJ,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC;oBACvC,MAAM,IAAI,KAAK,CACb,6EAA6E,CAC9E,CAAC;gBACJ,CAAC;gBACD,MAAM;YAER,KAAK,gBAAgB,EAAE,IAAI;gBACzB,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC;oBACvC,MAAM,IAAI,KAAK,CACb,oFAAoF,CACrF,CAAC;gBACJ,CAAC;gBACD,MAAM;QACV,CAAC;IACH,CAAC,CAAC,CAAC;AACL,CAAC","sourcesContent":["import { assert } from '@metamask/utils';\n\nimport type {\n  BIP44Depth,\n  PartialHDPathTuple,\n  RootedSLIP10PathTuple,\n  SLIP10Path,\n} from './constants';\nimport {\n  BIP44PurposeNodeToken,\n  BIP_32_PATH_REGEX,\n  BIP_39_PATH_REGEX,\n  MAX_BIP_44_DEPTH,\n  MIN_BIP_44_DEPTH,\n} from './constants';\nimport type { CryptographicFunctions } from './cryptography';\nimport type { SupportedCurve } from './curves';\nimport { decodeExtendedKey, PRIVATE_KEY_VERSION } from './extended-keys';\nimport { SLIP10Node, validateBIP32Depth } from './SLIP10Node';\nimport { isHardened } from './utils';\n\nexport type BIP44ExtendedKeyOptions = {\n  readonly depth: number;\n  readonly parentFingerprint: number;\n  readonly index: number;\n  readonly chainCode: Uint8Array | string;\n  readonly privateKey?: Uint8Array | string | undefined;\n  readonly publicKey?: Uint8Array | string | undefined;\n};\n\nexport type BIP44DerivationPathOptions = {\n  readonly derivationPath: RootedSLIP10PathTuple;\n};\n\n/**\n * A wrapper for BIP-44 Hierarchical Deterministic (HD) tree nodes, i.e.\n * cryptographic keys used to generate keypairs and addresses for cryptocurrency\n * protocols.\n */\nexport type JsonBIP44Node = {\n  /**\n   * The 0-indexed BIP-44 path depth of this node.\n   *\n   * A BIP-44 path is of the form:\n   *\n   * `m / 44' / coin_type' / account' / change / address_index`\n   *\n   * With the following depths:\n   *\n   * `0 / 1 / 2 / 3 / 4 / 5`\n   */\n  readonly depth: BIP44Depth;\n\n  /**\n   * The fingerprint of the master node, i.e., the node at depth 0. May be\n   * undefined if this node was created from an extended key.\n   */\n  readonly masterFingerprint?: number | undefined;\n\n  /**\n   * The fingerprint of the parent key, or 0 if this is a master node.\n   */\n  readonly parentFingerprint: number;\n\n  /**\n   * The index of the node, or 0 if this is a master node.\n   */\n  readonly index: number;\n\n  /**\n   * The hexadecimal string representation of the private key for this node.\n   * May be `undefined` if the node is a public node.\n   */\n  readonly privateKey?: string | undefined;\n\n  /**\n   * The hexadecimal string representation of the public key for this node.\n   */\n  readonly publicKey: string;\n\n  /**\n   * The hexadecimal string representation of the chain code for this node.\n   */\n  readonly chainCode: string;\n};\n\nexport type BIP44NodeInterface = JsonBIP44Node & {\n  /**\n   * @returns A JSON-compatible representation of this node's data fields.\n   */\n  toJSON(): JsonBIP44Node;\n};\n\n/**\n * A wrapper for BIP-44 Hierarchical Deterministic (HD) tree nodes, i.e.\n * cryptographic keys used to generate keypairs and addresses for cryptocurrency\n * protocols.\n *\n * This class contains methods and fields that may not serialize well. Use\n * {@link BIP44Node.toJSON} to get a JSON-compatible representation.\n */\nexport class BIP44Node implements BIP44NodeInterface {\n  /**\n   * Wrapper of the {@link fromExtendedKey} function. Refer to that function\n   * for documentation.\n   *\n   * @param json - The JSON representation of a SLIP-10 node.\n   * @param cryptographicFunctions - The cryptographic functions to use. If\n   * provided, these will be used instead of the built-in implementations.\n   * @returns A BIP44 node.\n   */\n  static async fromJSON(\n    json: JsonBIP44Node,\n    cryptographicFunctions?: CryptographicFunctions,\n  ): Promise<BIP44Node> {\n    return BIP44Node.fromExtendedKey(json, cryptographicFunctions);\n  }\n\n  /**\n   * Create a new BIP-44 node from a key and chain code. You must specify\n   * either a private key or a public key. When specifying a private key,\n   * the public key will be derived from the private key.\n   *\n   * All parameters are stringently validated, and an error is thrown if\n   * validation fails.\n   *\n   * @param options - An object containing the extended key, or an extended\n   * public (xpub) or private (xprv) key.\n   * @param options.depth - The depth of the node.\n   * @param options.privateKey - The private key for the node.\n   * @param options.publicKey - The public key for the node. If a private key is\n   * specified, this parameter is ignored.\n   * @param options.chainCode - The chain code for the node.\n   * @param cryptographicFunctions - The cryptographic functions to use. If\n   * provided, these will be used instead of the built-in implementations.\n   * @returns A BIP44 node.\n   */\n  static async fromExtendedKey(\n    options: BIP44ExtendedKeyOptions | string,\n    cryptographicFunctions?: CryptographicFunctions,\n  ): Promise<BIP44Node> {\n    if (typeof options === 'string') {\n      const extendedKey = decodeExtendedKey(options);\n\n      const { chainCode, depth, parentFingerprint, index } = extendedKey;\n\n      if (extendedKey.version === PRIVATE_KEY_VERSION) {\n        const { privateKey } = extendedKey;\n\n        return BIP44Node.fromExtendedKey(\n          {\n            depth,\n            parentFingerprint,\n            index,\n            privateKey,\n            chainCode,\n          },\n          cryptographicFunctions,\n        );\n      }\n\n      const { publicKey } = extendedKey;\n\n      return BIP44Node.fromExtendedKey(\n        {\n          depth,\n          parentFingerprint,\n          index,\n          publicKey,\n          chainCode,\n        },\n        cryptographicFunctions,\n      );\n    }\n\n    const {\n      privateKey,\n      publicKey,\n      chainCode,\n      depth,\n      parentFingerprint,\n      index,\n    } = options;\n\n    validateBIP44Depth(depth);\n\n    const node = await SLIP10Node.fromExtendedKey(\n      {\n        privateKey,\n        publicKey,\n        chainCode,\n        depth,\n        parentFingerprint,\n        index,\n        curve: 'secp256k1',\n      },\n      cryptographicFunctions,\n    );\n\n    return new BIP44Node(node);\n  }\n\n  /**\n   * Create a new BIP-44 node from a derivation path. The derivation path\n   * must be rooted, i.e. it must begin with a BIP-39 node, given as a string of\n   * the form `bip39:MNEMONIC`, where `MNEMONIC` is a space-separated list of\n   * BIP-39 seed phrase words.\n   *\n   * All parameters are stringently validated, and an error is thrown if\n   * validation fails.\n   *\n   * Recall that a BIP-44 HD tree path consists of the following nodes:\n   *\n   * `m / 44' / coin_type' / account' / change / address_index`\n   *\n   * With the following depths:\n   *\n   * `0 / 1 / 2 / 3 / 4 / 5`\n   *\n   * @param options - An object containing the derivation path.\n   * @param options.derivationPath - The rooted HD tree path that will be used\n   * to derive the key of this node.\n   * @param cryptographicFunctions - The cryptographic functions to use. If\n   * provided, these will be used instead of the built-in implementations.\n   * @returns A BIP44 node.\n   */\n  static async fromDerivationPath(\n    { derivationPath }: BIP44DerivationPathOptions,\n    cryptographicFunctions?: CryptographicFunctions,\n  ): Promise<BIP44Node> {\n    validateBIP44Depth(derivationPath.length - 1);\n    validateBIP44DerivationPath(derivationPath, MIN_BIP_44_DEPTH);\n\n    const node = await SLIP10Node.fromDerivationPath(\n      {\n        derivationPath,\n        curve: 'secp256k1',\n      },\n      cryptographicFunctions,\n    );\n\n    return new BIP44Node(node);\n  }\n\n  readonly #node: SLIP10Node;\n\n  public get depth(): BIP44Depth {\n    return this.#node.depth as BIP44Depth;\n  }\n\n  public get privateKeyBytes(): Uint8Array | undefined {\n    return this.#node.privateKeyBytes;\n  }\n\n  public get publicKeyBytes(): Uint8Array {\n    return this.#node.publicKeyBytes;\n  }\n\n  public get chainCodeBytes(): Uint8Array {\n    return this.#node.chainCodeBytes;\n  }\n\n  public get privateKey(): string | undefined {\n    return this.#node.privateKey;\n  }\n\n  public get publicKey(): string {\n    return this.#node.publicKey;\n  }\n\n  public get compressedPublicKey(): string {\n    return this.#node.compressedPublicKey;\n  }\n\n  public get compressedPublicKeyBytes(): Uint8Array {\n    return this.#node.compressedPublicKeyBytes;\n  }\n\n  public get chainCode(): string {\n    return this.#node.chainCode;\n  }\n\n  public get address(): string {\n    return this.#node.address;\n  }\n\n  public get masterFingerprint(): number | undefined {\n    return this.#node.masterFingerprint;\n  }\n\n  public get parentFingerprint(): number {\n    return this.#node.parentFingerprint;\n  }\n\n  public get fingerprint(): number {\n    return this.#node.fingerprint;\n  }\n\n  public get index(): number {\n    return this.#node.index;\n  }\n\n  public get extendedKey(): string {\n    return this.#node.extendedKey;\n  }\n\n  public get curve(): SupportedCurve {\n    return this.#node.curve;\n  }\n\n  constructor(node: SLIP10Node) {\n    this.#node = node;\n\n    Object.freeze(this);\n  }\n\n  /**\n   * Get a neutered version of this node, i.e. a node without a private key.\n   *\n   * @returns A neutered version of this node.\n   */\n  public neuter(): BIP44Node {\n    const node = this.#node.neuter();\n    return new BIP44Node(node);\n  }\n\n  /**\n   * Derives a child of the key contains be this node and returns a new\n   * {@link BIP44Node} containing the child key.\n   *\n   * The specified path must be a valid HD path from this node, per BIP-44.\n   * At present, this means that the path must consist of no more than 5 BIP-32\n   * nodes, depending on the depth of this node.\n   *\n   * Recall that a BIP-44 HD tree path consists of the following nodes:\n   *\n   * `m / 44' / coin_type' / account' / change / address_index`\n   *\n   * With the following depths:\n   *\n   * `0 / 1 / 2 / 3 / 4 / 5`\n   *\n   * @param path - The partial (non-rooted) BIP-44 HD tree path will be used\n   * to derive a child key from the parent key contained within this node.\n   * @returns The {@link BIP44Node} corresponding to the derived child key.\n   */\n  public async derive(path: PartialHDPathTuple): Promise<BIP44Node> {\n    if (this.depth === MAX_BIP_44_DEPTH) {\n      throw new Error(\n        'Illegal operation: This HD tree node is already a leaf node.',\n      );\n    }\n\n    const newDepth = this.depth + path.length;\n\n    validateBIP44Depth(newDepth);\n    validateBIP44DerivationPath(path, (this.depth + 1) as BIP44Depth);\n\n    const node = await this.#node.derive(path);\n    return new BIP44Node(node);\n  }\n\n  // This is documented in the interface of this class.\n  public toJSON(): JsonBIP44Node {\n    return {\n      depth: this.depth,\n      masterFingerprint: this.masterFingerprint,\n      parentFingerprint: this.parentFingerprint,\n      index: this.index,\n      privateKey: this.privateKey,\n      publicKey: this.publicKey,\n      chainCode: this.chainCode,\n    };\n  }\n}\n\n/**\n * Validates a BIP-44 path depth. Effectively, asserts that the depth is an\n * integer `number` N such that 0 <= N <= 5. Throws an error if validation\n * fails.\n *\n * @param depth - The depth to validate.\n */\nexport function validateBIP44Depth(\n  depth: unknown,\n): asserts depth is BIP44Depth {\n  validateBIP32Depth(depth);\n\n  if (depth < MIN_BIP_44_DEPTH || depth > MAX_BIP_44_DEPTH) {\n    throw new Error(\n      `Invalid HD tree path depth: The depth must be a positive integer N such that 0 <= N <= 5. Received: \"${depth}\"`,\n    );\n  }\n}\n\n/**\n * Ensures that the given derivation is valid by BIP-44.\n *\n * Recall that a BIP-44 HD tree path consists of the following nodes:\n *\n * `m / 44' / coin_type' / account' / change / address_index`\n *\n * With the following depths:\n *\n * `0 / 1 / 2 / 3 / 4 / 5`\n *\n * @param path - The path to validate.\n * @param startingDepth - The depth of the first node of the derivation path.\n */\nfunction validateBIP44DerivationPath(\n  path: SLIP10Path,\n  startingDepth: BIP44Depth,\n): void {\n  path.forEach((nodeToken, index) => {\n    const currentDepth = startingDepth + index;\n\n    if (currentDepth === MIN_BIP_44_DEPTH) {\n      if (\n        !(nodeToken instanceof Uint8Array) &&\n        !BIP_39_PATH_REGEX.test(nodeToken)\n      ) {\n        throw new Error(\n          'Invalid derivation path: The \"m\" / seed node (depth 0) must be a BIP-39 node.',\n        );\n      }\n\n      return;\n    }\n\n    assert(typeof nodeToken === 'string');\n\n    // eslint-disable-next-line default-case\n    switch (currentDepth) {\n      case 1:\n        if (nodeToken !== BIP44PurposeNodeToken) {\n          throw new Error(\n            `Invalid derivation path: The \"purpose\" node (depth 1) must be the string \"${BIP44PurposeNodeToken}\".`,\n          );\n        }\n        break;\n\n      case 2:\n        if (!BIP_32_PATH_REGEX.test(nodeToken) || !isHardened(nodeToken)) {\n          throw new Error(\n            'Invalid derivation path: The \"coin_type\" node (depth 2) must be a hardened BIP-32 node.',\n          );\n        }\n        break;\n\n      case 3:\n        if (!BIP_32_PATH_REGEX.test(nodeToken) || !isHardened(nodeToken)) {\n          throw new Error(\n            'Invalid derivation path: The \"account\" node (depth 3) must be a hardened BIP-32 node.',\n          );\n        }\n        break;\n\n      case 4:\n        if (!BIP_32_PATH_REGEX.test(nodeToken)) {\n          throw new Error(\n            'Invalid derivation path: The \"change\" node (depth 4) must be a BIP-32 node.',\n          );\n        }\n        break;\n\n      case MAX_BIP_44_DEPTH: // 5\n        if (!BIP_32_PATH_REGEX.test(nodeToken)) {\n          throw new Error(\n            'Invalid derivation path: The \"address_index\" node (depth 5) must be a BIP-32 node.',\n          );\n        }\n        break;\n    }\n  });\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/SLIP10Node.cjs b/node_modules/@metamask/key-tree/dist/SLIP10Node.cjs
index 92314dd..f04971a 100644
--- a/node_modules/@metamask/key-tree/dist/SLIP10Node.cjs
+++ b/node_modules/@metamask/key-tree/dist/SLIP10Node.cjs
@@ -4,7 +4,13 @@ var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (
     if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
     return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
 };
-var _a, _SLIP10Node_constructorGuard;
+var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
+    if (kind === "m") throw new TypeError("Private method is not writable");
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
+    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
+};
+var _a, _SLIP10Node_constructorGuard, _SLIP10Node_cryptographicFunctions;
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.deriveChildNode = exports.validateRootIndex = exports.validateMasterParentFingerprint = exports.validateParentFingerprint = exports.validateBIP32Depth = exports.SLIP10Node = void 0;
 const utils_1 = require("@metamask/utils");
@@ -12,29 +18,20 @@ const constants_1 = require("./constants.cjs");
 const curves_1 = require("./curves/index.cjs");
 const derivation_1 = require("./derivation.cjs");
 const bip32_1 = require("./derivers/bip32.cjs");
+const extended_keys_1 = require("./extended-keys.cjs");
 const utils_2 = require("./utils.cjs");
 class SLIP10Node {
-    // eslint-disable-next-line no-restricted-syntax
-    constructor({ depth, masterFingerprint, parentFingerprint, index, chainCode, privateKey, publicKey, curve, }, constructorGuard) {
-        (0, utils_1.assert)(constructorGuard === __classPrivateFieldGet(SLIP10Node, _a, "f", _SLIP10Node_constructorGuard), 'SLIP10Node can only be constructed using `SLIP10Node.fromJSON`, `SLIP10Node.fromExtendedKey`, or `SLIP10Node.fromDerivationPath`.');
-        this.depth = depth;
-        this.masterFingerprint = masterFingerprint;
-        this.parentFingerprint = parentFingerprint;
-        this.index = index;
-        this.chainCodeBytes = chainCode;
-        this.privateKeyBytes = privateKey;
-        this.publicKeyBytes = publicKey;
-        this.curve = curve;
-        Object.freeze(this);
-    }
     /**
      * Wrapper of the {@link fromExtendedKey} function. Refer to that function
      * for documentation.
      *
      * @param json - The JSON representation of a SLIP-10 node.
+     * @param cryptographicFunctions - The cryptographic functions to use. If
+     * provided, these will be used instead of the built-in implementations.
+     * @returns A SLIP10 node.
      */
-    static async fromJSON(json) {
-        return SLIP10Node.fromExtendedKey(json);
+    static async fromJSON(json, cryptographicFunctions) {
+        return _a.fromExtendedKey(json, cryptographicFunctions);
     }
     /**
      * Create a new SLIP-10 node from a key and chain code. You must specify
@@ -44,7 +41,9 @@ class SLIP10Node {
      * All parameters are stringently validated, and an error is thrown if
      * validation fails.
      *
-     * @param options - The options for the new node.
+     * @param options - The options for the new node. This can be an object
+     * containing the extended key options, or a string containing the extended
+     * key.
      * @param options.depth - The depth of the node.
      * @param options.masterFingerprint - The fingerprint of the master node, i.e., the
      * node at depth 0. May be undefined if this node was created from an extended
@@ -57,8 +56,38 @@ class SLIP10Node {
      * specified, this parameter is ignored.
      * @param options.chainCode - The chain code for the node.
      * @param options.curve - The curve used by the node.
+     * @param cryptographicFunctions - The cryptographic functions to use. If
+     * provided, these will be used instead of the built-in implementations.
+     * @returns A SLIP10 node.
      */
-    static async fromExtendedKey({ depth, masterFingerprint, parentFingerprint, index, privateKey, publicKey, chainCode, curve, }) {
+    static async fromExtendedKey(options, cryptographicFunctions) {
+        if (typeof options === 'string') {
+            const extendedKey = (0, extended_keys_1.decodeExtendedKey)(options);
+            const { chainCode, depth, parentFingerprint, index } = extendedKey;
+            if (extendedKey.version === extended_keys_1.PRIVATE_KEY_VERSION) {
+                const { privateKey } = extendedKey;
+                return _a.fromExtendedKey({
+                    depth,
+                    parentFingerprint,
+                    index,
+                    privateKey,
+                    chainCode,
+                    // BIP-32 key serialisation assumes `secp256k1`.
+                    curve: 'secp256k1',
+                }, cryptographicFunctions);
+            }
+            const { publicKey } = extendedKey;
+            return _a.fromExtendedKey({
+                depth,
+                parentFingerprint,
+                index,
+                publicKey,
+                chainCode,
+                // BIP-32 key serialisation assumes `secp256k1`.
+                curve: 'secp256k1',
+            }, cryptographicFunctions);
+        }
+        const { depth, masterFingerprint, parentFingerprint, index, privateKey, publicKey, chainCode, curve, } = options;
         const chainCodeBytes = (0, utils_2.getBytes)(chainCode, constants_1.BYTES_KEY_LENGTH);
         (0, utils_2.validateCurve)(curve);
         validateBIP32Depth(depth);
@@ -70,7 +99,7 @@ class SLIP10Node {
         if (privateKey) {
             const privateKeyBytes = (0, utils_2.getBytesUnsafe)(privateKey, curveObject.privateKeyLength);
             (0, utils_1.assert)(curveObject.isValidPrivateKey(privateKeyBytes), `Invalid private key: Value is not a valid ${curve} private key.`);
-            return new SLIP10Node({
+            return new _a({
                 depth,
                 masterFingerprint,
                 parentFingerprint,
@@ -79,11 +108,11 @@ class SLIP10Node {
                 privateKey: privateKeyBytes,
                 publicKey: await curveObject.getPublicKey(privateKeyBytes),
                 curve,
-            }, __classPrivateFieldGet(this, _a, "f", _SLIP10Node_constructorGuard));
+            }, cryptographicFunctions, __classPrivateFieldGet(this, _a, "f", _SLIP10Node_constructorGuard));
         }
         if (publicKey) {
             const publicKeyBytes = (0, utils_2.getBytes)(publicKey, curveObject.publicKeyLength);
-            return new SLIP10Node({
+            return new _a({
                 depth,
                 masterFingerprint,
                 parentFingerprint,
@@ -91,7 +120,7 @@ class SLIP10Node {
                 chainCode: chainCodeBytes,
                 publicKey: publicKeyBytes,
                 curve,
-            }, __classPrivateFieldGet(this, _a, "f", _SLIP10Node_constructorGuard));
+            }, cryptographicFunctions, __classPrivateFieldGet(this, _a, "f", _SLIP10Node_constructorGuard));
         }
         throw new Error('Invalid options: Must provide either a private key or a public key.');
     }
@@ -116,9 +145,11 @@ class SLIP10Node {
      * @param options.derivationPath - The rooted HD tree path that will be used
      * to derive the key of this node.
      * @param options.curve - The curve used by the node.
+     * @param cryptographicFunctions - The cryptographic functions to use. If
+     * provided, these will be used instead of the built-in implementations.
      * @returns A new SLIP-10 node.
      */
-    static async fromDerivationPath({ derivationPath, curve, }) {
+    static async fromDerivationPath({ derivationPath, curve }, cryptographicFunctions) {
         (0, utils_2.validateCurve)(curve);
         if (!derivationPath) {
             throw new Error('Invalid options: Must provide a derivation path.');
@@ -130,7 +161,22 @@ class SLIP10Node {
             path: derivationPath,
             depth: derivationPath.length - 1,
             curve,
-        });
+        }, cryptographicFunctions);
+    }
+    // eslint-disable-next-line no-restricted-syntax
+    constructor({ depth, masterFingerprint, parentFingerprint, index, chainCode, privateKey, publicKey, curve, }, cryptographicFunctions = {}, constructorGuard) {
+        _SLIP10Node_cryptographicFunctions.set(this, void 0);
+        (0, utils_1.assert)(constructorGuard === __classPrivateFieldGet(_a, _a, "f", _SLIP10Node_constructorGuard), 'SLIP10Node can only be constructed using `SLIP10Node.fromJSON`, `SLIP10Node.fromExtendedKey`, or `SLIP10Node.fromDerivationPath`.');
+        this.depth = depth;
+        this.masterFingerprint = masterFingerprint;
+        this.parentFingerprint = parentFingerprint;
+        this.index = index;
+        this.chainCodeBytes = chainCode;
+        this.privateKeyBytes = privateKey;
+        this.publicKeyBytes = publicKey;
+        this.curve = curve;
+        __classPrivateFieldSet(this, _SLIP10Node_cryptographicFunctions, cryptographicFunctions, "f");
+        Object.freeze(this);
     }
     get chainCode() {
         return (0, utils_1.bytesToHex)(this.chainCodeBytes);
@@ -159,13 +205,43 @@ class SLIP10Node {
     get fingerprint() {
         return (0, utils_2.getFingerprint)(this.compressedPublicKeyBytes, (0, curves_1.getCurveByName)(this.curve).compressedPublicKeyLength);
     }
+    /**
+     * Get the extended public or private key for the SLIP-10 node. SLIP-10
+     * doesn't specify a format for extended keys, so we use the BIP-32 format.
+     *
+     * This property is only supported for `secp256k1` nodes, as other curves
+     * don't specify a standard format for extended keys.
+     *
+     * @returns The extended public or private key for the node.
+     */
+    get extendedKey() {
+        (0, utils_1.assert)(this.curve === 'secp256k1', 'Unable to get extended key for this node: Only secp256k1 is supported.');
+        const data = {
+            depth: this.depth,
+            parentFingerprint: this.parentFingerprint,
+            index: this.index,
+            chainCode: this.chainCodeBytes,
+        };
+        if (this.privateKeyBytes) {
+            return (0, extended_keys_1.encodeExtendedKey)({
+                ...data,
+                version: extended_keys_1.PRIVATE_KEY_VERSION,
+                privateKey: this.privateKeyBytes,
+            });
+        }
+        return (0, extended_keys_1.encodeExtendedKey)({
+            ...data,
+            version: extended_keys_1.PUBLIC_KEY_VERSION,
+            publicKey: this.publicKeyBytes,
+        });
+    }
     /**
      * Get a neutered version of this node, i.e. a node without a private key.
      *
      * @returns A neutered version of this node.
      */
     neuter() {
-        return new SLIP10Node({
+        return new _a({
             depth: this.depth,
             masterFingerprint: this.masterFingerprint,
             parentFingerprint: this.parentFingerprint,
@@ -173,7 +249,7 @@ class SLIP10Node {
             chainCode: this.chainCodeBytes,
             publicKey: this.publicKeyBytes,
             curve: this.curve,
-        }, __classPrivateFieldGet(SLIP10Node, _a, "f", _SLIP10Node_constructorGuard));
+        }, __classPrivateFieldGet(this, _SLIP10Node_cryptographicFunctions, "f"), __classPrivateFieldGet(_a, _a, "f", _SLIP10Node_constructorGuard));
     }
     /**
      * Derives a child of the key contains be this node and returns a new
@@ -189,7 +265,7 @@ class SLIP10Node {
         return await deriveChildNode({
             path,
             node: this,
-        });
+        }, __classPrivateFieldGet(this, _SLIP10Node_cryptographicFunctions, "f"));
     }
     // This is documented in the interface of this class.
     toJSON() {
@@ -206,7 +282,7 @@ class SLIP10Node {
     }
 }
 exports.SLIP10Node = SLIP10Node;
-_a = SLIP10Node;
+_a = SLIP10Node, _SLIP10Node_cryptographicFunctions = new WeakMap();
 _SLIP10Node_constructorGuard = { value: Symbol('SLIP10Node.constructor') };
 /**
  * Validates a BIP-32 path depth. Effectively, asserts that the depth is an
@@ -280,9 +356,11 @@ exports.validateRootIndex = validateRootIndex;
  * @param options - The options to use when deriving the child key.
  * @param options.node - The node to derive from.
  * @param options.path - The path to the child node / key.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The derived key and depth.
  */
-async function deriveChildNode({ path, node, }) {
+async function deriveChildNode({ path, node }, cryptographicFunctions) {
     if (path.length === 0) {
         throw new Error('Invalid HD tree derivation path: Deriving a path of length 0 is not defined.');
     }
@@ -294,7 +372,7 @@ async function deriveChildNode({ path, node, }) {
         path,
         node,
         depth: newDepth,
-    });
+    }, cryptographicFunctions);
 }
 exports.deriveChildNode = deriveChildNode;
 //# sourceMappingURL=SLIP10Node.cjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/SLIP10Node.cjs.map b/node_modules/@metamask/key-tree/dist/SLIP10Node.cjs.map
index e366842..728ad15 100644
--- a/node_modules/@metamask/key-tree/dist/SLIP10Node.cjs.map
+++ b/node_modules/@metamask/key-tree/dist/SLIP10Node.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"SLIP10Node.cjs","sourceRoot":"","sources":["../src/SLIP10Node.ts"],"names":[],"mappings":"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","sourcesContent":["import { assert, bytesToHex } from '@metamask/utils';\n\nimport type { BIP44CoinTypeNode } from './BIP44CoinTypeNode';\nimport type { BIP44Node } from './BIP44Node';\nimport type { RootedSLIP10PathTuple, SLIP10PathTuple } from './constants';\nimport { BYTES_KEY_LENGTH } from './constants';\nimport type { SupportedCurve } from './curves';\nimport { getCurveByName } from './curves';\nimport { deriveKeyFromPath } from './derivation';\nimport { publicKeyToEthAddress } from './derivers/bip32';\nimport {\n  getBytes,\n  getBytesUnsafe,\n  getFingerprint,\n  isValidInteger,\n  validateBIP32Index,\n  validateCurve,\n} from './utils';\n\n/**\n * A wrapper for SLIP-10 Hierarchical Deterministic (HD) tree nodes, i.e.\n * cryptographic keys used to generate key pairs and addresses for cryptocurrency\n * protocols.\n */\nexport type JsonSLIP10Node = {\n  /**\n   * The 0-indexed path depth of this node.\n   */\n  readonly depth: number;\n\n  /**\n   * The fingerprint of the master node, i.e., the node at depth 0. May be\n   * undefined if this node was created from an extended key.\n   */\n  readonly masterFingerprint?: number | undefined;\n\n  /**\n   * The fingerprint of the parent key, or 0 if this is a master node.\n   */\n  readonly parentFingerprint: number;\n\n  /**\n   * The index of the node, or 0 if this is a master node.\n   */\n  readonly index: number;\n\n  /**\n   * The (optional) private key of this node.\n   */\n  readonly privateKey?: string | undefined;\n\n  /**\n   * The public key of this node.\n   */\n  readonly publicKey: string;\n\n  /**\n   * The chain code of this node.\n   */\n  readonly chainCode: string;\n\n  /**\n   * The name of the curve used by the node.\n   */\n  readonly curve: SupportedCurve;\n};\n\nexport type SLIP10NodeInterface = JsonSLIP10Node & {\n  chainCodeBytes: Uint8Array;\n\n  /**\n   * The private key for this node, as a {@link Uint8Array}.\n   * May be undefined if this node is a public key only node.\n   */\n  privateKeyBytes?: Uint8Array | undefined;\n\n  /**\n   * The public key for this node, as a {@link Uint8Array}.\n   */\n  publicKeyBytes: Uint8Array;\n\n  /**\n   * @returns A JSON-compatible representation of this node's data fields.\n   */\n  toJSON(): JsonSLIP10Node;\n};\n\nexport type SLIP10NodeConstructorOptions = {\n  readonly depth: number;\n  readonly masterFingerprint?: number | undefined;\n  readonly parentFingerprint: number;\n  readonly index: number;\n  readonly chainCode: Uint8Array;\n  readonly privateKey?: Uint8Array | undefined;\n  readonly publicKey: Uint8Array;\n  readonly curve: SupportedCurve;\n};\n\nexport type SLIP10ExtendedKeyOptions = {\n  readonly depth: number;\n  readonly masterFingerprint?: number | undefined;\n  readonly parentFingerprint: number;\n  readonly index: number;\n  readonly chainCode: string | Uint8Array;\n  readonly privateKey?: string | Uint8Array | undefined;\n  readonly publicKey?: string | Uint8Array | undefined;\n  readonly curve: SupportedCurve;\n};\n\nexport type SLIP10DerivationPathOptions = {\n  readonly derivationPath: RootedSLIP10PathTuple;\n  readonly curve: SupportedCurve;\n};\n\nexport class SLIP10Node implements SLIP10NodeInterface {\n  /**\n   * Wrapper of the {@link fromExtendedKey} function. Refer to that function\n   * for documentation.\n   *\n   * @param json - The JSON representation of a SLIP-10 node.\n   */\n  static async fromJSON(json: JsonSLIP10Node): Promise<SLIP10Node> {\n    return SLIP10Node.fromExtendedKey(json);\n  }\n\n  /**\n   * Create a new SLIP-10 node from a key and chain code. You must specify\n   * either a private key or a public key. When specifying a private key,\n   * the public key will be derived from the private key.\n   *\n   * All parameters are stringently validated, and an error is thrown if\n   * validation fails.\n   *\n   * @param options - The options for the new node.\n   * @param options.depth - The depth of the node.\n   * @param options.masterFingerprint - The fingerprint of the master node, i.e., the\n   * node at depth 0. May be undefined if this node was created from an extended\n   * key.\n   * @param options.parentFingerprint - The fingerprint of the parent key, or 0 if\n   * the node is a master node.\n   * @param options.index - The index of the node, or 0 if the node is a master node.\n   * @param options.privateKey - The private key for the node.\n   * @param options.publicKey - The public key for the node. If a private key is\n   * specified, this parameter is ignored.\n   * @param options.chainCode - The chain code for the node.\n   * @param options.curve - The curve used by the node.\n   */\n  static async fromExtendedKey({\n    depth,\n    masterFingerprint,\n    parentFingerprint,\n    index,\n    privateKey,\n    publicKey,\n    chainCode,\n    curve,\n  }: SLIP10ExtendedKeyOptions) {\n    const chainCodeBytes = getBytes(chainCode, BYTES_KEY_LENGTH);\n\n    validateCurve(curve);\n    validateBIP32Depth(depth);\n    validateBIP32Index(index);\n    validateRootIndex(index, depth);\n    validateParentFingerprint(parentFingerprint, depth);\n    validateMasterParentFingerprint(\n      masterFingerprint,\n      parentFingerprint,\n      depth,\n    );\n\n    const curveObject = getCurveByName(curve);\n\n    if (privateKey) {\n      const privateKeyBytes = getBytesUnsafe(\n        privateKey,\n        curveObject.privateKeyLength,\n      );\n      assert(\n        curveObject.isValidPrivateKey(privateKeyBytes),\n        `Invalid private key: Value is not a valid ${curve} private key.`,\n      );\n\n      return new SLIP10Node(\n        {\n          depth,\n          masterFingerprint,\n          parentFingerprint,\n          index,\n          chainCode: chainCodeBytes,\n          privateKey: privateKeyBytes,\n          publicKey: await curveObject.getPublicKey(privateKeyBytes),\n          curve,\n        },\n        this.#constructorGuard,\n      );\n    }\n\n    if (publicKey) {\n      const publicKeyBytes = getBytes(publicKey, curveObject.publicKeyLength);\n\n      return new SLIP10Node(\n        {\n          depth,\n          masterFingerprint,\n          parentFingerprint,\n          index,\n          chainCode: chainCodeBytes,\n          publicKey: publicKeyBytes,\n          curve,\n        },\n        this.#constructorGuard,\n      );\n    }\n\n    throw new Error(\n      'Invalid options: Must provide either a private key or a public key.',\n    );\n  }\n\n  /**\n   * Create a new SLIP-10 node from a derivation path. The derivation path\n   * must be rooted, i.e. it must begin with a BIP-39 node, given as a string of\n   * the form `bip39:MNEMONIC`, where `MNEMONIC` is a space-separated list of\n   * BIP-39 seed phrase words.\n   *\n   * All parameters are stringently validated, and an error is thrown if\n   * validation fails.\n   *\n   * Recall that a BIP-44 HD tree path consists of the following nodes:\n   *\n   * `m / 44' / coin_type' / account' / change / address_index`\n   *\n   * With the following depths:\n   *\n   * `0 / 1 / 2 / 3 / 4 / 5`\n   *\n   * @param options - The options for the new node.\n   * @param options.derivationPath - The rooted HD tree path that will be used\n   * to derive the key of this node.\n   * @param options.curve - The curve used by the node.\n   * @returns A new SLIP-10 node.\n   */\n  static async fromDerivationPath({\n    derivationPath,\n    curve,\n  }: SLIP10DerivationPathOptions) {\n    validateCurve(curve);\n\n    if (!derivationPath) {\n      throw new Error('Invalid options: Must provide a derivation path.');\n    }\n\n    if (derivationPath.length === 0) {\n      throw new Error(\n        'Invalid derivation path: May not specify an empty derivation path.',\n      );\n    }\n\n    return await deriveKeyFromPath({\n      path: derivationPath,\n      depth: derivationPath.length - 1,\n      curve,\n    });\n  }\n\n  static #constructorGuard = Symbol('SLIP10Node.constructor');\n\n  public readonly curve: SupportedCurve;\n\n  public readonly depth: number;\n\n  public readonly masterFingerprint?: number | undefined;\n\n  public readonly parentFingerprint: number;\n\n  public readonly index: number;\n\n  public readonly chainCodeBytes: Uint8Array;\n\n  public readonly privateKeyBytes?: Uint8Array | undefined;\n\n  public readonly publicKeyBytes: Uint8Array;\n\n  // eslint-disable-next-line no-restricted-syntax\n  private constructor(\n    {\n      depth,\n      masterFingerprint,\n      parentFingerprint,\n      index,\n      chainCode,\n      privateKey,\n      publicKey,\n      curve,\n    }: SLIP10NodeConstructorOptions,\n    constructorGuard?: symbol,\n  ) {\n    assert(\n      constructorGuard === SLIP10Node.#constructorGuard,\n      'SLIP10Node can only be constructed using `SLIP10Node.fromJSON`, `SLIP10Node.fromExtendedKey`, or `SLIP10Node.fromDerivationPath`.',\n    );\n\n    this.depth = depth;\n    this.masterFingerprint = masterFingerprint;\n    this.parentFingerprint = parentFingerprint;\n    this.index = index;\n    this.chainCodeBytes = chainCode;\n    this.privateKeyBytes = privateKey;\n    this.publicKeyBytes = publicKey;\n    this.curve = curve;\n\n    Object.freeze(this);\n  }\n\n  public get chainCode() {\n    return bytesToHex(this.chainCodeBytes);\n  }\n\n  public get privateKey(): string | undefined {\n    if (this.privateKeyBytes) {\n      return bytesToHex(this.privateKeyBytes);\n    }\n\n    return undefined;\n  }\n\n  public get publicKey(): string {\n    return bytesToHex(this.publicKeyBytes);\n  }\n\n  public get compressedPublicKeyBytes(): Uint8Array {\n    return getCurveByName(this.curve).compressPublicKey(this.publicKeyBytes);\n  }\n\n  public get compressedPublicKey(): string {\n    return bytesToHex(this.compressedPublicKeyBytes);\n  }\n\n  public get address(): string {\n    if (this.curve !== 'secp256k1') {\n      throw new Error(\n        'Unable to get address for this node: Only secp256k1 is supported.',\n      );\n    }\n\n    return bytesToHex(publicKeyToEthAddress(this.publicKeyBytes));\n  }\n\n  public get fingerprint(): number {\n    return getFingerprint(\n      this.compressedPublicKeyBytes,\n      getCurveByName(this.curve).compressedPublicKeyLength,\n    );\n  }\n\n  /**\n   * Get a neutered version of this node, i.e. a node without a private key.\n   *\n   * @returns A neutered version of this node.\n   */\n  public neuter(): SLIP10Node {\n    return new SLIP10Node(\n      {\n        depth: this.depth,\n        masterFingerprint: this.masterFingerprint,\n        parentFingerprint: this.parentFingerprint,\n        index: this.index,\n        chainCode: this.chainCodeBytes,\n        publicKey: this.publicKeyBytes,\n        curve: this.curve,\n      },\n      SLIP10Node.#constructorGuard,\n    );\n  }\n\n  /**\n   * Derives a child of the key contains be this node and returns a new\n   * {@link SLIP10Node} containing the child key.\n   *\n   * The specified path must be a valid HD path from this node, per SLIP-10.\n   *\n   * @param path - The partial (non-rooted) SLIP-10 HD tree path will be used\n   * to derive a child key from the parent key contained within this node.\n   * @returns The {@link SLIP10Node} corresponding to the derived child key.\n   */\n  public async derive(path: SLIP10PathTuple): Promise<SLIP10Node> {\n    return await deriveChildNode({\n      path,\n      node: this,\n    });\n  }\n\n  // This is documented in the interface of this class.\n  public toJSON(): JsonSLIP10Node {\n    return {\n      depth: this.depth,\n      masterFingerprint: this.masterFingerprint,\n      parentFingerprint: this.parentFingerprint,\n      index: this.index,\n      curve: this.curve,\n      privateKey: this.privateKey,\n      publicKey: this.publicKey,\n      chainCode: this.chainCode,\n    };\n  }\n}\n\n/**\n * Validates a BIP-32 path depth. Effectively, asserts that the depth is an\n * integer `number`. Throws an error if validation fails.\n *\n * @param depth - The depth to validate.\n */\nexport function validateBIP32Depth(depth: unknown): asserts depth is number {\n  if (!isValidInteger(depth)) {\n    throw new Error(\n      `Invalid HD tree path depth: The depth must be a positive integer. Received: \"${String(\n        depth,\n      )}\".`,\n    );\n  }\n}\n\n/**\n * Validates a BIP-32 parent fingerprint. Effectively, asserts that the fingerprint is an\n * integer `number`. Throws an error if validation fails.\n *\n * @param parentFingerprint - The parent fingerprint to validate.\n * @param depth - The depth of the node to validate.\n * @throws If the parent fingerprint is not a positive integer, or invalid for\n * the current depth.\n */\nexport function validateParentFingerprint(\n  parentFingerprint: unknown,\n  depth: number,\n): asserts parentFingerprint is number {\n  if (!isValidInteger(parentFingerprint)) {\n    throw new Error(\n      `Invalid parent fingerprint: The fingerprint must be a positive integer. Received: \"${String(\n        parentFingerprint,\n      )}\".`,\n    );\n  }\n\n  if (depth === 0 && parentFingerprint !== 0) {\n    throw new Error(\n      `Invalid parent fingerprint: The fingerprint of the root node must be 0. Received: \"${String(\n        parentFingerprint,\n      )}\".`,\n    );\n  }\n\n  if (depth > 0 && parentFingerprint === 0) {\n    throw new Error(\n      `Invalid parent fingerprint: The fingerprint of a child node must not be 0. Received: \"${String(\n        parentFingerprint,\n      )}\".`,\n    );\n  }\n}\n\n/**\n * Validate that a given combination of master fingerprint and parent\n * fingerprint is valid for the given depth.\n *\n * @param masterFingerprint - The master fingerprint to validate.\n * @param parentFingerprint - The parent fingerprint to validate.\n * @param depth - The depth of the node to validate.\n * @throws If the combination of master fingerprint and parent fingerprint is\n * invalid for the given depth.\n */\nexport function validateMasterParentFingerprint(\n  masterFingerprint: number | undefined,\n  parentFingerprint: number,\n  depth: number,\n) {\n  // The master fingerprint is optional.\n  if (!masterFingerprint) {\n    return;\n  }\n\n  if (depth >= 2 && masterFingerprint === parentFingerprint) {\n    throw new Error(\n      `Invalid parent fingerprint: The fingerprint of a child node cannot be equal to the master fingerprint. Received: \"${String(\n        parentFingerprint,\n      )}\".`,\n    );\n  }\n}\n\n/**\n * Validate that the index is zero for the root node.\n *\n * @param index - The index to validate.\n * @param depth - The depth of the node to validate.\n * @throws If the index is not zero for the root node.\n */\nexport function validateRootIndex(index: number, depth: number) {\n  if (depth === 0 && index !== 0) {\n    throw new Error(\n      `Invalid index: The index of the root node must be 0. Received: \"${String(\n        index,\n      )}\".`,\n    );\n  }\n}\n\ntype DeriveChildNodeArgs = {\n  path: SLIP10PathTuple;\n  node: SLIP10Node | BIP44Node | BIP44CoinTypeNode;\n};\n\n/**\n * Derives a child key from the given parent key.\n *\n * @param options - The options to use when deriving the child key.\n * @param options.node - The node to derive from.\n * @param options.path - The path to the child node / key.\n * @returns The derived key and depth.\n */\nexport async function deriveChildNode({\n  path,\n  node,\n}: DeriveChildNodeArgs): Promise<SLIP10Node> {\n  if (path.length === 0) {\n    throw new Error(\n      'Invalid HD tree derivation path: Deriving a path of length 0 is not defined.',\n    );\n  }\n\n  // Note that we do not subtract 1 from the length of the path to the child,\n  // unlike when we calculate the depth of a rooted path.\n  const newDepth = node.depth + path.length;\n  validateBIP32Depth(newDepth);\n\n  return await deriveKeyFromPath({\n    path,\n    node,\n    depth: newDepth,\n  });\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"SLIP10Node.cjs","sourceRoot":"","sources":["../src/SLIP10Node.ts"],"names":[],"mappings":"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","sourcesContent":["import { assert, bytesToHex } from '@metamask/utils';\n\nimport type { BIP44CoinTypeNode } from './BIP44CoinTypeNode';\nimport type { BIP44Node } from './BIP44Node';\nimport type { RootedSLIP10PathTuple, SLIP10PathTuple } from './constants';\nimport { BYTES_KEY_LENGTH } from './constants';\nimport type { CryptographicFunctions } from './cryptography';\nimport type { SupportedCurve } from './curves';\nimport { getCurveByName } from './curves';\nimport { deriveKeyFromPath } from './derivation';\nimport { publicKeyToEthAddress } from './derivers/bip32';\nimport {\n  decodeExtendedKey,\n  encodeExtendedKey,\n  PRIVATE_KEY_VERSION,\n  PUBLIC_KEY_VERSION,\n} from './extended-keys';\nimport {\n  getBytes,\n  getBytesUnsafe,\n  getFingerprint,\n  isValidInteger,\n  validateBIP32Index,\n  validateCurve,\n} from './utils';\n\n/**\n * A wrapper for SLIP-10 Hierarchical Deterministic (HD) tree nodes, i.e.\n * cryptographic keys used to generate key pairs and addresses for cryptocurrency\n * protocols.\n */\nexport type JsonSLIP10Node = {\n  /**\n   * The 0-indexed path depth of this node.\n   */\n  readonly depth: number;\n\n  /**\n   * The fingerprint of the master node, i.e., the node at depth 0. May be\n   * undefined if this node was created from an extended key.\n   */\n  readonly masterFingerprint?: number | undefined;\n\n  /**\n   * The fingerprint of the parent key, or 0 if this is a master node.\n   */\n  readonly parentFingerprint: number;\n\n  /**\n   * The index of the node, or 0 if this is a master node.\n   */\n  readonly index: number;\n\n  /**\n   * The (optional) private key of this node.\n   */\n  readonly privateKey?: string | undefined;\n\n  /**\n   * The public key of this node.\n   */\n  readonly publicKey: string;\n\n  /**\n   * The chain code of this node.\n   */\n  readonly chainCode: string;\n\n  /**\n   * The name of the curve used by the node.\n   */\n  readonly curve: SupportedCurve;\n};\n\nexport type SLIP10NodeInterface = JsonSLIP10Node & {\n  chainCodeBytes: Uint8Array;\n\n  /**\n   * The private key for this node, as a {@link Uint8Array}.\n   * May be undefined if this node is a public key only node.\n   */\n  privateKeyBytes?: Uint8Array | undefined;\n\n  /**\n   * The public key for this node, as a {@link Uint8Array}.\n   */\n  publicKeyBytes: Uint8Array;\n\n  /**\n   * @returns A JSON-compatible representation of this node's data fields.\n   */\n  toJSON(): JsonSLIP10Node;\n};\n\nexport type SLIP10NodeConstructorOptions = {\n  readonly depth: number;\n  readonly masterFingerprint?: number | undefined;\n  readonly parentFingerprint: number;\n  readonly index: number;\n  readonly chainCode: Uint8Array;\n  readonly privateKey?: Uint8Array | undefined;\n  readonly publicKey: Uint8Array;\n  readonly curve: SupportedCurve;\n};\n\nexport type SLIP10ExtendedKeyOptions = {\n  readonly depth: number;\n  readonly masterFingerprint?: number | undefined;\n  readonly parentFingerprint: number;\n  readonly index: number;\n  readonly chainCode: string | Uint8Array;\n  readonly privateKey?: string | Uint8Array | undefined;\n  readonly publicKey?: string | Uint8Array | undefined;\n  readonly curve: SupportedCurve;\n};\n\nexport type SLIP10DerivationPathOptions = {\n  readonly derivationPath: RootedSLIP10PathTuple;\n  readonly curve: SupportedCurve;\n};\n\nexport class SLIP10Node implements SLIP10NodeInterface {\n  /**\n   * Wrapper of the {@link fromExtendedKey} function. Refer to that function\n   * for documentation.\n   *\n   * @param json - The JSON representation of a SLIP-10 node.\n   * @param cryptographicFunctions - The cryptographic functions to use. If\n   * provided, these will be used instead of the built-in implementations.\n   * @returns A SLIP10 node.\n   */\n  static async fromJSON(\n    json: JsonSLIP10Node,\n    cryptographicFunctions?: CryptographicFunctions,\n  ): Promise<SLIP10Node> {\n    return SLIP10Node.fromExtendedKey(json, cryptographicFunctions);\n  }\n\n  /**\n   * Create a new SLIP-10 node from a BIP-32 serialised extended key string.\n   * The key may be either public or private. Note that `secp256k1` is assumed\n   * as the curve for the key.\n   *\n   * All parameters are stringently validated, and an error is thrown if\n   * validation fails.\n   *\n   * @param extendedKey - The BIP-32 extended key string.\n   * @param cryptographicFunctions - The cryptographic functions to use. If\n   * provided, these will be used instead of the built-in implementations.\n   * @returns A SLIP10 node.\n   */\n  static async fromExtendedKey(\n    extendedKey: string,\n    cryptographicFunctions?: CryptographicFunctions,\n  ): Promise<SLIP10Node>;\n\n  /**\n   * Create a new SLIP-10 node from a key and chain code. You must specify\n   * either a private key or a public key. When specifying a private key,\n   * the public key will be derived from the private key.\n   *\n   * All parameters are stringently validated, and an error is thrown if\n   * validation fails.\n   *\n   * @param options - The options for the new node.\n   * @param options.depth - The depth of the node.\n   * @param options.masterFingerprint - The fingerprint of the master node, i.e., the\n   * node at depth 0. May be undefined if this node was created from an extended\n   * key.\n   * @param options.parentFingerprint - The fingerprint of the parent key, or 0 if\n   * the node is a master node.\n   * @param options.index - The index of the node, or 0 if the node is a master node.\n   * @param options.privateKey - The private key for the node.\n   * @param options.publicKey - The public key for the node. If a private key is\n   * specified, this parameter is ignored.\n   * @param options.chainCode - The chain code for the node.\n   * @param options.curve - The curve used by the node.\n   * @param cryptographicFunctions - The cryptographic functions to use. If\n   * provided, these will be used instead of the built-in implementations.\n   * @returns A SLIP10 node.\n   */\n  static async fromExtendedKey(\n    // These signatures could technically be combined, but it's easier to\n    // document them separately.\n    // eslint-disable-next-line @typescript-eslint/unified-signatures\n    options: SLIP10ExtendedKeyOptions,\n    cryptographicFunctions?: CryptographicFunctions,\n  ): Promise<SLIP10Node>;\n\n  /**\n   * Create a new SLIP-10 node from a key and chain code. You must specify\n   * either a private key or a public key. When specifying a private key,\n   * the public key will be derived from the private key.\n   *\n   * All parameters are stringently validated, and an error is thrown if\n   * validation fails.\n   *\n   * @param options - The options for the new node. This can be an object\n   * containing the extended key options, or a string containing the extended\n   * key.\n   * @param options.depth - The depth of the node.\n   * @param options.masterFingerprint - The fingerprint of the master node, i.e., the\n   * node at depth 0. May be undefined if this node was created from an extended\n   * key.\n   * @param options.parentFingerprint - The fingerprint of the parent key, or 0 if\n   * the node is a master node.\n   * @param options.index - The index of the node, or 0 if the node is a master node.\n   * @param options.privateKey - The private key for the node.\n   * @param options.publicKey - The public key for the node. If a private key is\n   * specified, this parameter is ignored.\n   * @param options.chainCode - The chain code for the node.\n   * @param options.curve - The curve used by the node.\n   * @param cryptographicFunctions - The cryptographic functions to use. If\n   * provided, these will be used instead of the built-in implementations.\n   * @returns A SLIP10 node.\n   */\n  static async fromExtendedKey(\n    options: SLIP10ExtendedKeyOptions | string,\n    cryptographicFunctions?: CryptographicFunctions,\n  ): Promise<SLIP10Node> {\n    if (typeof options === 'string') {\n      const extendedKey = decodeExtendedKey(options);\n\n      const { chainCode, depth, parentFingerprint, index } = extendedKey;\n\n      if (extendedKey.version === PRIVATE_KEY_VERSION) {\n        const { privateKey } = extendedKey;\n\n        return SLIP10Node.fromExtendedKey(\n          {\n            depth,\n            parentFingerprint,\n            index,\n            privateKey,\n            chainCode,\n            // BIP-32 key serialisation assumes `secp256k1`.\n            curve: 'secp256k1',\n          },\n          cryptographicFunctions,\n        );\n      }\n\n      const { publicKey } = extendedKey;\n\n      return SLIP10Node.fromExtendedKey(\n        {\n          depth,\n          parentFingerprint,\n          index,\n          publicKey,\n          chainCode,\n          // BIP-32 key serialisation assumes `secp256k1`.\n          curve: 'secp256k1',\n        },\n        cryptographicFunctions,\n      );\n    }\n\n    const {\n      depth,\n      masterFingerprint,\n      parentFingerprint,\n      index,\n      privateKey,\n      publicKey,\n      chainCode,\n      curve,\n    } = options;\n\n    const chainCodeBytes = getBytes(chainCode, BYTES_KEY_LENGTH);\n\n    validateCurve(curve);\n    validateBIP32Depth(depth);\n    validateBIP32Index(index);\n    validateRootIndex(index, depth);\n    validateParentFingerprint(parentFingerprint, depth);\n    validateMasterParentFingerprint(\n      masterFingerprint,\n      parentFingerprint,\n      depth,\n    );\n\n    const curveObject = getCurveByName(curve);\n\n    if (privateKey) {\n      const privateKeyBytes = getBytesUnsafe(\n        privateKey,\n        curveObject.privateKeyLength,\n      );\n      assert(\n        curveObject.isValidPrivateKey(privateKeyBytes),\n        `Invalid private key: Value is not a valid ${curve} private key.`,\n      );\n\n      return new SLIP10Node(\n        {\n          depth,\n          masterFingerprint,\n          parentFingerprint,\n          index,\n          chainCode: chainCodeBytes,\n          privateKey: privateKeyBytes,\n          publicKey: await curveObject.getPublicKey(privateKeyBytes),\n          curve,\n        },\n        cryptographicFunctions,\n        this.#constructorGuard,\n      );\n    }\n\n    if (publicKey) {\n      const publicKeyBytes = getBytes(publicKey, curveObject.publicKeyLength);\n\n      return new SLIP10Node(\n        {\n          depth,\n          masterFingerprint,\n          parentFingerprint,\n          index,\n          chainCode: chainCodeBytes,\n          publicKey: publicKeyBytes,\n          curve,\n        },\n        cryptographicFunctions,\n        this.#constructorGuard,\n      );\n    }\n\n    throw new Error(\n      'Invalid options: Must provide either a private key or a public key.',\n    );\n  }\n\n  /**\n   * Create a new SLIP-10 node from a derivation path. The derivation path\n   * must be rooted, i.e. it must begin with a BIP-39 node, given as a string of\n   * the form `bip39:MNEMONIC`, where `MNEMONIC` is a space-separated list of\n   * BIP-39 seed phrase words.\n   *\n   * All parameters are stringently validated, and an error is thrown if\n   * validation fails.\n   *\n   * Recall that a BIP-44 HD tree path consists of the following nodes:\n   *\n   * `m / 44' / coin_type' / account' / change / address_index`\n   *\n   * With the following depths:\n   *\n   * `0 / 1 / 2 / 3 / 4 / 5`\n   *\n   * @param options - The options for the new node.\n   * @param options.derivationPath - The rooted HD tree path that will be used\n   * to derive the key of this node.\n   * @param options.curve - The curve used by the node.\n   * @param cryptographicFunctions - The cryptographic functions to use. If\n   * provided, these will be used instead of the built-in implementations.\n   * @returns A new SLIP-10 node.\n   */\n  static async fromDerivationPath(\n    { derivationPath, curve }: SLIP10DerivationPathOptions,\n    cryptographicFunctions?: CryptographicFunctions,\n  ): Promise<SLIP10Node> {\n    validateCurve(curve);\n\n    if (!derivationPath) {\n      throw new Error('Invalid options: Must provide a derivation path.');\n    }\n\n    if (derivationPath.length === 0) {\n      throw new Error(\n        'Invalid derivation path: May not specify an empty derivation path.',\n      );\n    }\n\n    return await deriveKeyFromPath(\n      {\n        path: derivationPath,\n        depth: derivationPath.length - 1,\n        curve,\n      },\n      cryptographicFunctions,\n    );\n  }\n\n  static readonly #constructorGuard = Symbol('SLIP10Node.constructor');\n\n  public readonly curve: SupportedCurve;\n\n  public readonly depth: number;\n\n  public readonly masterFingerprint?: number | undefined;\n\n  public readonly parentFingerprint: number;\n\n  public readonly index: number;\n\n  public readonly chainCodeBytes: Uint8Array;\n\n  public readonly privateKeyBytes?: Uint8Array | undefined;\n\n  public readonly publicKeyBytes: Uint8Array;\n\n  readonly #cryptographicFunctions: CryptographicFunctions;\n\n  // eslint-disable-next-line no-restricted-syntax\n  private constructor(\n    {\n      depth,\n      masterFingerprint,\n      parentFingerprint,\n      index,\n      chainCode,\n      privateKey,\n      publicKey,\n      curve,\n    }: SLIP10NodeConstructorOptions,\n    cryptographicFunctions: CryptographicFunctions = {},\n    constructorGuard?: symbol,\n  ) {\n    assert(\n      constructorGuard === SLIP10Node.#constructorGuard,\n      'SLIP10Node can only be constructed using `SLIP10Node.fromJSON`, `SLIP10Node.fromExtendedKey`, or `SLIP10Node.fromDerivationPath`.',\n    );\n\n    this.depth = depth;\n    this.masterFingerprint = masterFingerprint;\n    this.parentFingerprint = parentFingerprint;\n    this.index = index;\n    this.chainCodeBytes = chainCode;\n    this.privateKeyBytes = privateKey;\n    this.publicKeyBytes = publicKey;\n    this.curve = curve;\n    this.#cryptographicFunctions = cryptographicFunctions;\n\n    Object.freeze(this);\n  }\n\n  public get chainCode(): string {\n    return bytesToHex(this.chainCodeBytes);\n  }\n\n  public get privateKey(): string | undefined {\n    if (this.privateKeyBytes) {\n      return bytesToHex(this.privateKeyBytes);\n    }\n\n    return undefined;\n  }\n\n  public get publicKey(): string {\n    return bytesToHex(this.publicKeyBytes);\n  }\n\n  public get compressedPublicKeyBytes(): Uint8Array {\n    return getCurveByName(this.curve).compressPublicKey(this.publicKeyBytes);\n  }\n\n  public get compressedPublicKey(): string {\n    return bytesToHex(this.compressedPublicKeyBytes);\n  }\n\n  public get address(): string {\n    if (this.curve !== 'secp256k1') {\n      throw new Error(\n        'Unable to get address for this node: Only secp256k1 is supported.',\n      );\n    }\n\n    return bytesToHex(publicKeyToEthAddress(this.publicKeyBytes));\n  }\n\n  public get fingerprint(): number {\n    return getFingerprint(\n      this.compressedPublicKeyBytes,\n      getCurveByName(this.curve).compressedPublicKeyLength,\n    );\n  }\n\n  /**\n   * Get the extended public or private key for the SLIP-10 node. SLIP-10\n   * doesn't specify a format for extended keys, so we use the BIP-32 format.\n   *\n   * This property is only supported for `secp256k1` nodes, as other curves\n   * don't specify a standard format for extended keys.\n   *\n   * @returns The extended public or private key for the node.\n   */\n  public get extendedKey(): string {\n    assert(\n      this.curve === 'secp256k1',\n      'Unable to get extended key for this node: Only secp256k1 is supported.',\n    );\n\n    const data = {\n      depth: this.depth,\n      parentFingerprint: this.parentFingerprint,\n      index: this.index,\n      chainCode: this.chainCodeBytes,\n    };\n\n    if (this.privateKeyBytes) {\n      return encodeExtendedKey({\n        ...data,\n        version: PRIVATE_KEY_VERSION,\n        privateKey: this.privateKeyBytes,\n      });\n    }\n\n    return encodeExtendedKey({\n      ...data,\n      version: PUBLIC_KEY_VERSION,\n      publicKey: this.publicKeyBytes,\n    });\n  }\n\n  /**\n   * Get a neutered version of this node, i.e. a node without a private key.\n   *\n   * @returns A neutered version of this node.\n   */\n  public neuter(): SLIP10Node {\n    return new SLIP10Node(\n      {\n        depth: this.depth,\n        masterFingerprint: this.masterFingerprint,\n        parentFingerprint: this.parentFingerprint,\n        index: this.index,\n        chainCode: this.chainCodeBytes,\n        publicKey: this.publicKeyBytes,\n        curve: this.curve,\n      },\n      this.#cryptographicFunctions,\n      SLIP10Node.#constructorGuard,\n    );\n  }\n\n  /**\n   * Derives a child of the key contains be this node and returns a new\n   * {@link SLIP10Node} containing the child key.\n   *\n   * The specified path must be a valid HD path from this node, per SLIP-10.\n   *\n   * @param path - The partial (non-rooted) SLIP-10 HD tree path will be used\n   * to derive a child key from the parent key contained within this node.\n   * @returns The {@link SLIP10Node} corresponding to the derived child key.\n   */\n  public async derive(path: SLIP10PathTuple): Promise<SLIP10Node> {\n    return await deriveChildNode(\n      {\n        path,\n        node: this,\n      },\n      this.#cryptographicFunctions,\n    );\n  }\n\n  // This is documented in the interface of this class.\n  public toJSON(): JsonSLIP10Node {\n    return {\n      depth: this.depth,\n      masterFingerprint: this.masterFingerprint,\n      parentFingerprint: this.parentFingerprint,\n      index: this.index,\n      curve: this.curve,\n      privateKey: this.privateKey,\n      publicKey: this.publicKey,\n      chainCode: this.chainCode,\n    };\n  }\n}\n\n/**\n * Validates a BIP-32 path depth. Effectively, asserts that the depth is an\n * integer `number`. Throws an error if validation fails.\n *\n * @param depth - The depth to validate.\n */\nexport function validateBIP32Depth(depth: unknown): asserts depth is number {\n  if (!isValidInteger(depth)) {\n    throw new Error(\n      `Invalid HD tree path depth: The depth must be a positive integer. Received: \"${String(\n        depth,\n      )}\".`,\n    );\n  }\n}\n\n/**\n * Validates a BIP-32 parent fingerprint. Effectively, asserts that the fingerprint is an\n * integer `number`. Throws an error if validation fails.\n *\n * @param parentFingerprint - The parent fingerprint to validate.\n * @param depth - The depth of the node to validate.\n * @throws If the parent fingerprint is not a positive integer, or invalid for\n * the current depth.\n */\nexport function validateParentFingerprint(\n  parentFingerprint: unknown,\n  depth: number,\n): asserts parentFingerprint is number {\n  if (!isValidInteger(parentFingerprint)) {\n    throw new Error(\n      `Invalid parent fingerprint: The fingerprint must be a positive integer. Received: \"${String(\n        parentFingerprint,\n      )}\".`,\n    );\n  }\n\n  if (depth === 0 && parentFingerprint !== 0) {\n    throw new Error(\n      `Invalid parent fingerprint: The fingerprint of the root node must be 0. Received: \"${String(\n        parentFingerprint,\n      )}\".`,\n    );\n  }\n\n  if (depth > 0 && parentFingerprint === 0) {\n    throw new Error(\n      `Invalid parent fingerprint: The fingerprint of a child node must not be 0. Received: \"${String(\n        parentFingerprint,\n      )}\".`,\n    );\n  }\n}\n\n/**\n * Validate that a given combination of master fingerprint and parent\n * fingerprint is valid for the given depth.\n *\n * @param masterFingerprint - The master fingerprint to validate.\n * @param parentFingerprint - The parent fingerprint to validate.\n * @param depth - The depth of the node to validate.\n * @throws If the combination of master fingerprint and parent fingerprint is\n * invalid for the given depth.\n */\nexport function validateMasterParentFingerprint(\n  masterFingerprint: number | undefined,\n  parentFingerprint: number,\n  depth: number,\n): void {\n  // The master fingerprint is optional.\n  if (!masterFingerprint) {\n    return;\n  }\n\n  if (depth >= 2 && masterFingerprint === parentFingerprint) {\n    throw new Error(\n      `Invalid parent fingerprint: The fingerprint of a child node cannot be equal to the master fingerprint. Received: \"${String(\n        parentFingerprint,\n      )}\".`,\n    );\n  }\n}\n\n/**\n * Validate that the index is zero for the root node.\n *\n * @param index - The index to validate.\n * @param depth - The depth of the node to validate.\n * @throws If the index is not zero for the root node.\n */\nexport function validateRootIndex(index: number, depth: number): void {\n  if (depth === 0 && index !== 0) {\n    throw new Error(\n      `Invalid index: The index of the root node must be 0. Received: \"${String(\n        index,\n      )}\".`,\n    );\n  }\n}\n\ntype DeriveChildNodeArgs = {\n  path: SLIP10PathTuple;\n  node: SLIP10Node | BIP44Node | BIP44CoinTypeNode;\n};\n\n/**\n * Derives a child key from the given parent key.\n *\n * @param options - The options to use when deriving the child key.\n * @param options.node - The node to derive from.\n * @param options.path - The path to the child node / key.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The derived key and depth.\n */\nexport async function deriveChildNode(\n  { path, node }: DeriveChildNodeArgs,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<SLIP10Node> {\n  if (path.length === 0) {\n    throw new Error(\n      'Invalid HD tree derivation path: Deriving a path of length 0 is not defined.',\n    );\n  }\n\n  // Note that we do not subtract 1 from the length of the path to the child,\n  // unlike when we calculate the depth of a rooted path.\n  const newDepth = node.depth + path.length;\n  validateBIP32Depth(newDepth);\n\n  return await deriveKeyFromPath(\n    {\n      path,\n      node,\n      depth: newDepth,\n    },\n    cryptographicFunctions,\n  );\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/SLIP10Node.d.cts b/node_modules/@metamask/key-tree/dist/SLIP10Node.d.cts
index 5b883d5..cf34448 100644
--- a/node_modules/@metamask/key-tree/dist/SLIP10Node.d.cts
+++ b/node_modules/@metamask/key-tree/dist/SLIP10Node.d.cts
@@ -1,13 +1,14 @@
 import type { BIP44CoinTypeNode } from "./BIP44CoinTypeNode.cjs";
 import type { BIP44Node } from "./BIP44Node.cjs";
 import type { RootedSLIP10PathTuple, SLIP10PathTuple } from "./constants.cjs";
+import type { CryptographicFunctions } from "./cryptography.cjs";
 import type { SupportedCurve } from "./curves/index.cjs";
 /**
  * A wrapper for SLIP-10 Hierarchical Deterministic (HD) tree nodes, i.e.
  * cryptographic keys used to generate key pairs and addresses for cryptocurrency
  * protocols.
  */
-export declare type JsonSLIP10Node = {
+export type JsonSLIP10Node = {
     /**
      * The 0-indexed path depth of this node.
      */
@@ -42,7 +43,7 @@ export declare type JsonSLIP10Node = {
      */
     readonly curve: SupportedCurve;
 };
-export declare type SLIP10NodeInterface = JsonSLIP10Node & {
+export type SLIP10NodeInterface = JsonSLIP10Node & {
     chainCodeBytes: Uint8Array;
     /**
      * The private key for this node, as a {@link Uint8Array}.
@@ -58,7 +59,7 @@ export declare type SLIP10NodeInterface = JsonSLIP10Node & {
      */
     toJSON(): JsonSLIP10Node;
 };
-export declare type SLIP10NodeConstructorOptions = {
+export type SLIP10NodeConstructorOptions = {
     readonly depth: number;
     readonly masterFingerprint?: number | undefined;
     readonly parentFingerprint: number;
@@ -68,7 +69,7 @@ export declare type SLIP10NodeConstructorOptions = {
     readonly publicKey: Uint8Array;
     readonly curve: SupportedCurve;
 };
-export declare type SLIP10ExtendedKeyOptions = {
+export type SLIP10ExtendedKeyOptions = {
     readonly depth: number;
     readonly masterFingerprint?: number | undefined;
     readonly parentFingerprint: number;
@@ -78,7 +79,7 @@ export declare type SLIP10ExtendedKeyOptions = {
     readonly publicKey?: string | Uint8Array | undefined;
     readonly curve: SupportedCurve;
 };
-export declare type SLIP10DerivationPathOptions = {
+export type SLIP10DerivationPathOptions = {
     readonly derivationPath: RootedSLIP10PathTuple;
     readonly curve: SupportedCurve;
 };
@@ -89,8 +90,25 @@ export declare class SLIP10Node implements SLIP10NodeInterface {
      * for documentation.
      *
      * @param json - The JSON representation of a SLIP-10 node.
+     * @param cryptographicFunctions - The cryptographic functions to use. If
+     * provided, these will be used instead of the built-in implementations.
+     * @returns A SLIP10 node.
      */
-    static fromJSON(json: JsonSLIP10Node): Promise<SLIP10Node>;
+    static fromJSON(json: JsonSLIP10Node, cryptographicFunctions?: CryptographicFunctions): Promise<SLIP10Node>;
+    /**
+     * Create a new SLIP-10 node from a BIP-32 serialised extended key string.
+     * The key may be either public or private. Note that `secp256k1` is assumed
+     * as the curve for the key.
+     *
+     * All parameters are stringently validated, and an error is thrown if
+     * validation fails.
+     *
+     * @param extendedKey - The BIP-32 extended key string.
+     * @param cryptographicFunctions - The cryptographic functions to use. If
+     * provided, these will be used instead of the built-in implementations.
+     * @returns A SLIP10 node.
+     */
+    static fromExtendedKey(extendedKey: string, cryptographicFunctions?: CryptographicFunctions): Promise<SLIP10Node>;
     /**
      * Create a new SLIP-10 node from a key and chain code. You must specify
      * either a private key or a public key. When specifying a private key,
@@ -112,8 +130,11 @@ export declare class SLIP10Node implements SLIP10NodeInterface {
      * specified, this parameter is ignored.
      * @param options.chainCode - The chain code for the node.
      * @param options.curve - The curve used by the node.
+     * @param cryptographicFunctions - The cryptographic functions to use. If
+     * provided, these will be used instead of the built-in implementations.
+     * @returns A SLIP10 node.
      */
-    static fromExtendedKey({ depth, masterFingerprint, parentFingerprint, index, privateKey, publicKey, chainCode, curve, }: SLIP10ExtendedKeyOptions): Promise<SLIP10Node>;
+    static fromExtendedKey(options: SLIP10ExtendedKeyOptions, cryptographicFunctions?: CryptographicFunctions): Promise<SLIP10Node>;
     /**
      * Create a new SLIP-10 node from a derivation path. The derivation path
      * must be rooted, i.e. it must begin with a BIP-39 node, given as a string of
@@ -135,9 +156,11 @@ export declare class SLIP10Node implements SLIP10NodeInterface {
      * @param options.derivationPath - The rooted HD tree path that will be used
      * to derive the key of this node.
      * @param options.curve - The curve used by the node.
+     * @param cryptographicFunctions - The cryptographic functions to use. If
+     * provided, these will be used instead of the built-in implementations.
      * @returns A new SLIP-10 node.
      */
-    static fromDerivationPath({ derivationPath, curve, }: SLIP10DerivationPathOptions): Promise<SLIP10Node>;
+    static fromDerivationPath({ derivationPath, curve }: SLIP10DerivationPathOptions, cryptographicFunctions?: CryptographicFunctions): Promise<SLIP10Node>;
     readonly curve: SupportedCurve;
     readonly depth: number;
     readonly masterFingerprint?: number | undefined;
@@ -147,13 +170,23 @@ export declare class SLIP10Node implements SLIP10NodeInterface {
     readonly privateKeyBytes?: Uint8Array | undefined;
     readonly publicKeyBytes: Uint8Array;
     private constructor();
-    get chainCode(): `0x${string}`;
+    get chainCode(): string;
     get privateKey(): string | undefined;
     get publicKey(): string;
     get compressedPublicKeyBytes(): Uint8Array;
     get compressedPublicKey(): string;
     get address(): string;
     get fingerprint(): number;
+    /**
+     * Get the extended public or private key for the SLIP-10 node. SLIP-10
+     * doesn't specify a format for extended keys, so we use the BIP-32 format.
+     *
+     * This property is only supported for `secp256k1` nodes, as other curves
+     * don't specify a standard format for extended keys.
+     *
+     * @returns The extended public or private key for the node.
+     */
+    get extendedKey(): string;
     /**
      * Get a neutered version of this node, i.e. a node without a private key.
      *
@@ -209,7 +242,7 @@ export declare function validateMasterParentFingerprint(masterFingerprint: numbe
  * @throws If the index is not zero for the root node.
  */
 export declare function validateRootIndex(index: number, depth: number): void;
-declare type DeriveChildNodeArgs = {
+type DeriveChildNodeArgs = {
     path: SLIP10PathTuple;
     node: SLIP10Node | BIP44Node | BIP44CoinTypeNode;
 };
@@ -219,8 +252,10 @@ declare type DeriveChildNodeArgs = {
  * @param options - The options to use when deriving the child key.
  * @param options.node - The node to derive from.
  * @param options.path - The path to the child node / key.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The derived key and depth.
  */
-export declare function deriveChildNode({ path, node, }: DeriveChildNodeArgs): Promise<SLIP10Node>;
+export declare function deriveChildNode({ path, node }: DeriveChildNodeArgs, cryptographicFunctions?: CryptographicFunctions): Promise<SLIP10Node>;
 export {};
 //# sourceMappingURL=SLIP10Node.d.cts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/SLIP10Node.d.cts.map b/node_modules/@metamask/key-tree/dist/SLIP10Node.d.cts.map
index f63f923..9128c7c 100644
--- a/node_modules/@metamask/key-tree/dist/SLIP10Node.d.cts.map
+++ b/node_modules/@metamask/key-tree/dist/SLIP10Node.d.cts.map
@@ -1 +1 @@
-{"version":3,"file":"SLIP10Node.d.cts","sourceRoot":"","sources":["../src/SLIP10Node.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"SLIP10Node.d.cts","sourceRoot":"","sources":["../src/SLIP10Node.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/SLIP10Node.d.mts b/node_modules/@metamask/key-tree/dist/SLIP10Node.d.mts
index 95c4884..b1f35a0 100644
--- a/node_modules/@metamask/key-tree/dist/SLIP10Node.d.mts
+++ b/node_modules/@metamask/key-tree/dist/SLIP10Node.d.mts
@@ -1,13 +1,14 @@
 import type { BIP44CoinTypeNode } from "./BIP44CoinTypeNode.mjs";
 import type { BIP44Node } from "./BIP44Node.mjs";
 import type { RootedSLIP10PathTuple, SLIP10PathTuple } from "./constants.mjs";
+import type { CryptographicFunctions } from "./cryptography.mjs";
 import type { SupportedCurve } from "./curves/index.mjs";
 /**
  * A wrapper for SLIP-10 Hierarchical Deterministic (HD) tree nodes, i.e.
  * cryptographic keys used to generate key pairs and addresses for cryptocurrency
  * protocols.
  */
-export declare type JsonSLIP10Node = {
+export type JsonSLIP10Node = {
     /**
      * The 0-indexed path depth of this node.
      */
@@ -42,7 +43,7 @@ export declare type JsonSLIP10Node = {
      */
     readonly curve: SupportedCurve;
 };
-export declare type SLIP10NodeInterface = JsonSLIP10Node & {
+export type SLIP10NodeInterface = JsonSLIP10Node & {
     chainCodeBytes: Uint8Array;
     /**
      * The private key for this node, as a {@link Uint8Array}.
@@ -58,7 +59,7 @@ export declare type SLIP10NodeInterface = JsonSLIP10Node & {
      */
     toJSON(): JsonSLIP10Node;
 };
-export declare type SLIP10NodeConstructorOptions = {
+export type SLIP10NodeConstructorOptions = {
     readonly depth: number;
     readonly masterFingerprint?: number | undefined;
     readonly parentFingerprint: number;
@@ -68,7 +69,7 @@ export declare type SLIP10NodeConstructorOptions = {
     readonly publicKey: Uint8Array;
     readonly curve: SupportedCurve;
 };
-export declare type SLIP10ExtendedKeyOptions = {
+export type SLIP10ExtendedKeyOptions = {
     readonly depth: number;
     readonly masterFingerprint?: number | undefined;
     readonly parentFingerprint: number;
@@ -78,7 +79,7 @@ export declare type SLIP10ExtendedKeyOptions = {
     readonly publicKey?: string | Uint8Array | undefined;
     readonly curve: SupportedCurve;
 };
-export declare type SLIP10DerivationPathOptions = {
+export type SLIP10DerivationPathOptions = {
     readonly derivationPath: RootedSLIP10PathTuple;
     readonly curve: SupportedCurve;
 };
@@ -89,8 +90,25 @@ export declare class SLIP10Node implements SLIP10NodeInterface {
      * for documentation.
      *
      * @param json - The JSON representation of a SLIP-10 node.
+     * @param cryptographicFunctions - The cryptographic functions to use. If
+     * provided, these will be used instead of the built-in implementations.
+     * @returns A SLIP10 node.
      */
-    static fromJSON(json: JsonSLIP10Node): Promise<SLIP10Node>;
+    static fromJSON(json: JsonSLIP10Node, cryptographicFunctions?: CryptographicFunctions): Promise<SLIP10Node>;
+    /**
+     * Create a new SLIP-10 node from a BIP-32 serialised extended key string.
+     * The key may be either public or private. Note that `secp256k1` is assumed
+     * as the curve for the key.
+     *
+     * All parameters are stringently validated, and an error is thrown if
+     * validation fails.
+     *
+     * @param extendedKey - The BIP-32 extended key string.
+     * @param cryptographicFunctions - The cryptographic functions to use. If
+     * provided, these will be used instead of the built-in implementations.
+     * @returns A SLIP10 node.
+     */
+    static fromExtendedKey(extendedKey: string, cryptographicFunctions?: CryptographicFunctions): Promise<SLIP10Node>;
     /**
      * Create a new SLIP-10 node from a key and chain code. You must specify
      * either a private key or a public key. When specifying a private key,
@@ -112,8 +130,11 @@ export declare class SLIP10Node implements SLIP10NodeInterface {
      * specified, this parameter is ignored.
      * @param options.chainCode - The chain code for the node.
      * @param options.curve - The curve used by the node.
+     * @param cryptographicFunctions - The cryptographic functions to use. If
+     * provided, these will be used instead of the built-in implementations.
+     * @returns A SLIP10 node.
      */
-    static fromExtendedKey({ depth, masterFingerprint, parentFingerprint, index, privateKey, publicKey, chainCode, curve, }: SLIP10ExtendedKeyOptions): Promise<SLIP10Node>;
+    static fromExtendedKey(options: SLIP10ExtendedKeyOptions, cryptographicFunctions?: CryptographicFunctions): Promise<SLIP10Node>;
     /**
      * Create a new SLIP-10 node from a derivation path. The derivation path
      * must be rooted, i.e. it must begin with a BIP-39 node, given as a string of
@@ -135,9 +156,11 @@ export declare class SLIP10Node implements SLIP10NodeInterface {
      * @param options.derivationPath - The rooted HD tree path that will be used
      * to derive the key of this node.
      * @param options.curve - The curve used by the node.
+     * @param cryptographicFunctions - The cryptographic functions to use. If
+     * provided, these will be used instead of the built-in implementations.
      * @returns A new SLIP-10 node.
      */
-    static fromDerivationPath({ derivationPath, curve, }: SLIP10DerivationPathOptions): Promise<SLIP10Node>;
+    static fromDerivationPath({ derivationPath, curve }: SLIP10DerivationPathOptions, cryptographicFunctions?: CryptographicFunctions): Promise<SLIP10Node>;
     readonly curve: SupportedCurve;
     readonly depth: number;
     readonly masterFingerprint?: number | undefined;
@@ -147,13 +170,23 @@ export declare class SLIP10Node implements SLIP10NodeInterface {
     readonly privateKeyBytes?: Uint8Array | undefined;
     readonly publicKeyBytes: Uint8Array;
     private constructor();
-    get chainCode(): `0x${string}`;
+    get chainCode(): string;
     get privateKey(): string | undefined;
     get publicKey(): string;
     get compressedPublicKeyBytes(): Uint8Array;
     get compressedPublicKey(): string;
     get address(): string;
     get fingerprint(): number;
+    /**
+     * Get the extended public or private key for the SLIP-10 node. SLIP-10
+     * doesn't specify a format for extended keys, so we use the BIP-32 format.
+     *
+     * This property is only supported for `secp256k1` nodes, as other curves
+     * don't specify a standard format for extended keys.
+     *
+     * @returns The extended public or private key for the node.
+     */
+    get extendedKey(): string;
     /**
      * Get a neutered version of this node, i.e. a node without a private key.
      *
@@ -209,7 +242,7 @@ export declare function validateMasterParentFingerprint(masterFingerprint: numbe
  * @throws If the index is not zero for the root node.
  */
 export declare function validateRootIndex(index: number, depth: number): void;
-declare type DeriveChildNodeArgs = {
+type DeriveChildNodeArgs = {
     path: SLIP10PathTuple;
     node: SLIP10Node | BIP44Node | BIP44CoinTypeNode;
 };
@@ -219,8 +252,10 @@ declare type DeriveChildNodeArgs = {
  * @param options - The options to use when deriving the child key.
  * @param options.node - The node to derive from.
  * @param options.path - The path to the child node / key.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The derived key and depth.
  */
-export declare function deriveChildNode({ path, node, }: DeriveChildNodeArgs): Promise<SLIP10Node>;
+export declare function deriveChildNode({ path, node }: DeriveChildNodeArgs, cryptographicFunctions?: CryptographicFunctions): Promise<SLIP10Node>;
 export {};
 //# sourceMappingURL=SLIP10Node.d.mts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/SLIP10Node.d.mts.map b/node_modules/@metamask/key-tree/dist/SLIP10Node.d.mts.map
index 32fc51e..a0df27b 100644
--- a/node_modules/@metamask/key-tree/dist/SLIP10Node.d.mts.map
+++ b/node_modules/@metamask/key-tree/dist/SLIP10Node.d.mts.map
@@ -1 +1 @@
-{"version":3,"file":"SLIP10Node.d.mts","sourceRoot":"","sources":["../src/SLIP10Node.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"SLIP10Node.d.mts","sourceRoot":"","sources":["../src/SLIP10Node.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/SLIP10Node.mjs b/node_modules/@metamask/key-tree/dist/SLIP10Node.mjs
index 8f88389..d281f31 100644
--- a/node_modules/@metamask/key-tree/dist/SLIP10Node.mjs
+++ b/node_modules/@metamask/key-tree/dist/SLIP10Node.mjs
@@ -3,35 +3,32 @@ var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (
     if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
     return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
 };
-var _a, _SLIP10Node_constructorGuard;
+var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
+    if (kind === "m") throw new TypeError("Private method is not writable");
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
+    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
+};
+var _a, _SLIP10Node_constructorGuard, _SLIP10Node_cryptographicFunctions;
 import { assert, bytesToHex } from "@metamask/utils";
 import { BYTES_KEY_LENGTH } from "./constants.mjs";
 import { getCurveByName } from "./curves/index.mjs";
 import { deriveKeyFromPath } from "./derivation.mjs";
 import { publicKeyToEthAddress } from "./derivers/bip32.mjs";
+import { decodeExtendedKey, encodeExtendedKey, PRIVATE_KEY_VERSION, PUBLIC_KEY_VERSION } from "./extended-keys.mjs";
 import { getBytes, getBytesUnsafe, getFingerprint, isValidInteger, validateBIP32Index, validateCurve } from "./utils.mjs";
 export class SLIP10Node {
-    // eslint-disable-next-line no-restricted-syntax
-    constructor({ depth, masterFingerprint, parentFingerprint, index, chainCode, privateKey, publicKey, curve, }, constructorGuard) {
-        assert(constructorGuard === __classPrivateFieldGet(SLIP10Node, _a, "f", _SLIP10Node_constructorGuard), 'SLIP10Node can only be constructed using `SLIP10Node.fromJSON`, `SLIP10Node.fromExtendedKey`, or `SLIP10Node.fromDerivationPath`.');
-        this.depth = depth;
-        this.masterFingerprint = masterFingerprint;
-        this.parentFingerprint = parentFingerprint;
-        this.index = index;
-        this.chainCodeBytes = chainCode;
-        this.privateKeyBytes = privateKey;
-        this.publicKeyBytes = publicKey;
-        this.curve = curve;
-        Object.freeze(this);
-    }
     /**
      * Wrapper of the {@link fromExtendedKey} function. Refer to that function
      * for documentation.
      *
      * @param json - The JSON representation of a SLIP-10 node.
+     * @param cryptographicFunctions - The cryptographic functions to use. If
+     * provided, these will be used instead of the built-in implementations.
+     * @returns A SLIP10 node.
      */
-    static async fromJSON(json) {
-        return SLIP10Node.fromExtendedKey(json);
+    static async fromJSON(json, cryptographicFunctions) {
+        return _a.fromExtendedKey(json, cryptographicFunctions);
     }
     /**
      * Create a new SLIP-10 node from a key and chain code. You must specify
@@ -41,7 +38,9 @@ export class SLIP10Node {
      * All parameters are stringently validated, and an error is thrown if
      * validation fails.
      *
-     * @param options - The options for the new node.
+     * @param options - The options for the new node. This can be an object
+     * containing the extended key options, or a string containing the extended
+     * key.
      * @param options.depth - The depth of the node.
      * @param options.masterFingerprint - The fingerprint of the master node, i.e., the
      * node at depth 0. May be undefined if this node was created from an extended
@@ -54,8 +53,38 @@ export class SLIP10Node {
      * specified, this parameter is ignored.
      * @param options.chainCode - The chain code for the node.
      * @param options.curve - The curve used by the node.
+     * @param cryptographicFunctions - The cryptographic functions to use. If
+     * provided, these will be used instead of the built-in implementations.
+     * @returns A SLIP10 node.
      */
-    static async fromExtendedKey({ depth, masterFingerprint, parentFingerprint, index, privateKey, publicKey, chainCode, curve, }) {
+    static async fromExtendedKey(options, cryptographicFunctions) {
+        if (typeof options === 'string') {
+            const extendedKey = decodeExtendedKey(options);
+            const { chainCode, depth, parentFingerprint, index } = extendedKey;
+            if (extendedKey.version === PRIVATE_KEY_VERSION) {
+                const { privateKey } = extendedKey;
+                return _a.fromExtendedKey({
+                    depth,
+                    parentFingerprint,
+                    index,
+                    privateKey,
+                    chainCode,
+                    // BIP-32 key serialisation assumes `secp256k1`.
+                    curve: 'secp256k1',
+                }, cryptographicFunctions);
+            }
+            const { publicKey } = extendedKey;
+            return _a.fromExtendedKey({
+                depth,
+                parentFingerprint,
+                index,
+                publicKey,
+                chainCode,
+                // BIP-32 key serialisation assumes `secp256k1`.
+                curve: 'secp256k1',
+            }, cryptographicFunctions);
+        }
+        const { depth, masterFingerprint, parentFingerprint, index, privateKey, publicKey, chainCode, curve, } = options;
         const chainCodeBytes = getBytes(chainCode, BYTES_KEY_LENGTH);
         validateCurve(curve);
         validateBIP32Depth(depth);
@@ -67,7 +96,7 @@ export class SLIP10Node {
         if (privateKey) {
             const privateKeyBytes = getBytesUnsafe(privateKey, curveObject.privateKeyLength);
             assert(curveObject.isValidPrivateKey(privateKeyBytes), `Invalid private key: Value is not a valid ${curve} private key.`);
-            return new SLIP10Node({
+            return new _a({
                 depth,
                 masterFingerprint,
                 parentFingerprint,
@@ -76,11 +105,11 @@ export class SLIP10Node {
                 privateKey: privateKeyBytes,
                 publicKey: await curveObject.getPublicKey(privateKeyBytes),
                 curve,
-            }, __classPrivateFieldGet(this, _a, "f", _SLIP10Node_constructorGuard));
+            }, cryptographicFunctions, __classPrivateFieldGet(this, _a, "f", _SLIP10Node_constructorGuard));
         }
         if (publicKey) {
             const publicKeyBytes = getBytes(publicKey, curveObject.publicKeyLength);
-            return new SLIP10Node({
+            return new _a({
                 depth,
                 masterFingerprint,
                 parentFingerprint,
@@ -88,7 +117,7 @@ export class SLIP10Node {
                 chainCode: chainCodeBytes,
                 publicKey: publicKeyBytes,
                 curve,
-            }, __classPrivateFieldGet(this, _a, "f", _SLIP10Node_constructorGuard));
+            }, cryptographicFunctions, __classPrivateFieldGet(this, _a, "f", _SLIP10Node_constructorGuard));
         }
         throw new Error('Invalid options: Must provide either a private key or a public key.');
     }
@@ -113,9 +142,11 @@ export class SLIP10Node {
      * @param options.derivationPath - The rooted HD tree path that will be used
      * to derive the key of this node.
      * @param options.curve - The curve used by the node.
+     * @param cryptographicFunctions - The cryptographic functions to use. If
+     * provided, these will be used instead of the built-in implementations.
      * @returns A new SLIP-10 node.
      */
-    static async fromDerivationPath({ derivationPath, curve, }) {
+    static async fromDerivationPath({ derivationPath, curve }, cryptographicFunctions) {
         validateCurve(curve);
         if (!derivationPath) {
             throw new Error('Invalid options: Must provide a derivation path.');
@@ -127,7 +158,22 @@ export class SLIP10Node {
             path: derivationPath,
             depth: derivationPath.length - 1,
             curve,
-        });
+        }, cryptographicFunctions);
+    }
+    // eslint-disable-next-line no-restricted-syntax
+    constructor({ depth, masterFingerprint, parentFingerprint, index, chainCode, privateKey, publicKey, curve, }, cryptographicFunctions = {}, constructorGuard) {
+        _SLIP10Node_cryptographicFunctions.set(this, void 0);
+        assert(constructorGuard === __classPrivateFieldGet(_a, _a, "f", _SLIP10Node_constructorGuard), 'SLIP10Node can only be constructed using `SLIP10Node.fromJSON`, `SLIP10Node.fromExtendedKey`, or `SLIP10Node.fromDerivationPath`.');
+        this.depth = depth;
+        this.masterFingerprint = masterFingerprint;
+        this.parentFingerprint = parentFingerprint;
+        this.index = index;
+        this.chainCodeBytes = chainCode;
+        this.privateKeyBytes = privateKey;
+        this.publicKeyBytes = publicKey;
+        this.curve = curve;
+        __classPrivateFieldSet(this, _SLIP10Node_cryptographicFunctions, cryptographicFunctions, "f");
+        Object.freeze(this);
     }
     get chainCode() {
         return bytesToHex(this.chainCodeBytes);
@@ -156,13 +202,43 @@ export class SLIP10Node {
     get fingerprint() {
         return getFingerprint(this.compressedPublicKeyBytes, getCurveByName(this.curve).compressedPublicKeyLength);
     }
+    /**
+     * Get the extended public or private key for the SLIP-10 node. SLIP-10
+     * doesn't specify a format for extended keys, so we use the BIP-32 format.
+     *
+     * This property is only supported for `secp256k1` nodes, as other curves
+     * don't specify a standard format for extended keys.
+     *
+     * @returns The extended public or private key for the node.
+     */
+    get extendedKey() {
+        assert(this.curve === 'secp256k1', 'Unable to get extended key for this node: Only secp256k1 is supported.');
+        const data = {
+            depth: this.depth,
+            parentFingerprint: this.parentFingerprint,
+            index: this.index,
+            chainCode: this.chainCodeBytes,
+        };
+        if (this.privateKeyBytes) {
+            return encodeExtendedKey({
+                ...data,
+                version: PRIVATE_KEY_VERSION,
+                privateKey: this.privateKeyBytes,
+            });
+        }
+        return encodeExtendedKey({
+            ...data,
+            version: PUBLIC_KEY_VERSION,
+            publicKey: this.publicKeyBytes,
+        });
+    }
     /**
      * Get a neutered version of this node, i.e. a node without a private key.
      *
      * @returns A neutered version of this node.
      */
     neuter() {
-        return new SLIP10Node({
+        return new _a({
             depth: this.depth,
             masterFingerprint: this.masterFingerprint,
             parentFingerprint: this.parentFingerprint,
@@ -170,7 +246,7 @@ export class SLIP10Node {
             chainCode: this.chainCodeBytes,
             publicKey: this.publicKeyBytes,
             curve: this.curve,
-        }, __classPrivateFieldGet(SLIP10Node, _a, "f", _SLIP10Node_constructorGuard));
+        }, __classPrivateFieldGet(this, _SLIP10Node_cryptographicFunctions, "f"), __classPrivateFieldGet(_a, _a, "f", _SLIP10Node_constructorGuard));
     }
     /**
      * Derives a child of the key contains be this node and returns a new
@@ -186,7 +262,7 @@ export class SLIP10Node {
         return await deriveChildNode({
             path,
             node: this,
-        });
+        }, __classPrivateFieldGet(this, _SLIP10Node_cryptographicFunctions, "f"));
     }
     // This is documented in the interface of this class.
     toJSON() {
@@ -202,7 +278,7 @@ export class SLIP10Node {
         };
     }
 }
-_a = SLIP10Node;
+_a = SLIP10Node, _SLIP10Node_cryptographicFunctions = new WeakMap();
 _SLIP10Node_constructorGuard = { value: Symbol('SLIP10Node.constructor') };
 /**
  * Validates a BIP-32 path depth. Effectively, asserts that the depth is an
@@ -272,9 +348,11 @@ export function validateRootIndex(index, depth) {
  * @param options - The options to use when deriving the child key.
  * @param options.node - The node to derive from.
  * @param options.path - The path to the child node / key.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The derived key and depth.
  */
-export async function deriveChildNode({ path, node, }) {
+export async function deriveChildNode({ path, node }, cryptographicFunctions) {
     if (path.length === 0) {
         throw new Error('Invalid HD tree derivation path: Deriving a path of length 0 is not defined.');
     }
@@ -286,6 +364,6 @@ export async function deriveChildNode({ path, node, }) {
         path,
         node,
         depth: newDepth,
-    });
+    }, cryptographicFunctions);
 }
 //# sourceMappingURL=SLIP10Node.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/SLIP10Node.mjs.map b/node_modules/@metamask/key-tree/dist/SLIP10Node.mjs.map
index 3c8a60e..58c6569 100644
--- a/node_modules/@metamask/key-tree/dist/SLIP10Node.mjs.map
+++ b/node_modules/@metamask/key-tree/dist/SLIP10Node.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"SLIP10Node.mjs","sourceRoot":"","sources":["../src/SLIP10Node.ts"],"names":[],"mappings":";;;;;;AAAA,OAAO,EAAE,MAAM,EAAE,UAAU,EAAE,wBAAwB;AAKrD,OAAO,EAAE,gBAAgB,EAAE,wBAAoB;AAE/C,OAAO,EAAE,cAAc,EAAE,2BAAiB;AAC1C,OAAO,EAAE,iBAAiB,EAAE,yBAAqB;AACjD,OAAO,EAAE,qBAAqB,EAAE,6BAAyB;AACzD,OAAO,EACL,QAAQ,EACR,cAAc,EACd,cAAc,EACd,cAAc,EACd,kBAAkB,EAClB,aAAa,EACd,oBAAgB;AAiGjB,MAAM,OAAO,UAAU;IAyKrB,gDAAgD;IAChD,YACE,EACE,KAAK,EACL,iBAAiB,EACjB,iBAAiB,EACjB,KAAK,EACL,SAAS,EACT,UAAU,EACV,SAAS,EACT,KAAK,GACwB,EAC/B,gBAAyB;QAEzB,MAAM,CACJ,gBAAgB,KAAK,uBAAA,UAAU,wCAAkB,EACjD,mIAAmI,CACpI,CAAC;QAEF,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,iBAAiB,GAAG,iBAAiB,CAAC;QAC3C,IAAI,CAAC,iBAAiB,GAAG,iBAAiB,CAAC;QAC3C,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,cAAc,GAAG,SAAS,CAAC;QAChC,IAAI,CAAC,eAAe,GAAG,UAAU,CAAC;QAClC,IAAI,CAAC,cAAc,GAAG,SAAS,CAAC;QAChC,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QAEnB,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IACtB,CAAC;IArMD;;;;;OAKG;IACH,MAAM,CAAC,KAAK,CAAC,QAAQ,CAAC,IAAoB;QACxC,OAAO,UAAU,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;IAC1C,CAAC;IAED;;;;;;;;;;;;;;;;;;;;;OAqBG;IACH,MAAM,CAAC,KAAK,CAAC,eAAe,CAAC,EAC3B,KAAK,EACL,iBAAiB,EACjB,iBAAiB,EACjB,KAAK,EACL,UAAU,EACV,SAAS,EACT,SAAS,EACT,KAAK,GACoB;QACzB,MAAM,cAAc,GAAG,QAAQ,CAAC,SAAS,EAAE,gBAAgB,CAAC,CAAC;QAE7D,aAAa,CAAC,KAAK,CAAC,CAAC;QACrB,kBAAkB,CAAC,KAAK,CAAC,CAAC;QAC1B,kBAAkB,CAAC,KAAK,CAAC,CAAC;QAC1B,iBAAiB,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;QAChC,yBAAyB,CAAC,iBAAiB,EAAE,KAAK,CAAC,CAAC;QACpD,+BAA+B,CAC7B,iBAAiB,EACjB,iBAAiB,EACjB,KAAK,CACN,CAAC;QAEF,MAAM,WAAW,GAAG,cAAc,CAAC,KAAK,CAAC,CAAC;QAE1C,IAAI,UAAU,EAAE;YACd,MAAM,eAAe,GAAG,cAAc,CACpC,UAAU,EACV,WAAW,CAAC,gBAAgB,CAC7B,CAAC;YACF,MAAM,CACJ,WAAW,CAAC,iBAAiB,CAAC,eAAe,CAAC,EAC9C,6CAA6C,KAAK,eAAe,CAClE,CAAC;YAEF,OAAO,IAAI,UAAU,CACnB;gBACE,KAAK;gBACL,iBAAiB;gBACjB,iBAAiB;gBACjB,KAAK;gBACL,SAAS,EAAE,cAAc;gBACzB,UAAU,EAAE,eAAe;gBAC3B,SAAS,EAAE,MAAM,WAAW,CAAC,YAAY,CAAC,eAAe,CAAC;gBAC1D,KAAK;aACN,EACD,uBAAA,IAAI,wCAAkB,CACvB,CAAC;SACH;QAED,IAAI,SAAS,EAAE;YACb,MAAM,cAAc,GAAG,QAAQ,CAAC,SAAS,EAAE,WAAW,CAAC,eAAe,CAAC,CAAC;YAExE,OAAO,IAAI,UAAU,CACnB;gBACE,KAAK;gBACL,iBAAiB;gBACjB,iBAAiB;gBACjB,KAAK;gBACL,SAAS,EAAE,cAAc;gBACzB,SAAS,EAAE,cAAc;gBACzB,KAAK;aACN,EACD,uBAAA,IAAI,wCAAkB,CACvB,CAAC;SACH;QAED,MAAM,IAAI,KAAK,CACb,qEAAqE,CACtE,CAAC;IACJ,CAAC;IAED;;;;;;;;;;;;;;;;;;;;;;OAsBG;IACH,MAAM,CAAC,KAAK,CAAC,kBAAkB,CAAC,EAC9B,cAAc,EACd,KAAK,GACuB;QAC5B,aAAa,CAAC,KAAK,CAAC,CAAC;QAErB,IAAI,CAAC,cAAc,EAAE;YACnB,MAAM,IAAI,KAAK,CAAC,kDAAkD,CAAC,CAAC;SACrE;QAED,IAAI,cAAc,CAAC,MAAM,KAAK,CAAC,EAAE;YAC/B,MAAM,IAAI,KAAK,CACb,oEAAoE,CACrE,CAAC;SACH;QAED,OAAO,MAAM,iBAAiB,CAAC;YAC7B,IAAI,EAAE,cAAc;YACpB,KAAK,EAAE,cAAc,CAAC,MAAM,GAAG,CAAC;YAChC,KAAK;SACN,CAAC,CAAC;IACL,CAAC;IAmDD,IAAW,SAAS;QAClB,OAAO,UAAU,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;IACzC,CAAC;IAED,IAAW,UAAU;QACnB,IAAI,IAAI,CAAC,eAAe,EAAE;YACxB,OAAO,UAAU,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;SACzC;QAED,OAAO,SAAS,CAAC;IACnB,CAAC;IAED,IAAW,SAAS;QAClB,OAAO,UAAU,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;IACzC,CAAC;IAED,IAAW,wBAAwB;QACjC,OAAO,cAAc,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,iBAAiB,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;IAC3E,CAAC;IAED,IAAW,mBAAmB;QAC5B,OAAO,UAAU,CAAC,IAAI,CAAC,wBAAwB,CAAC,CAAC;IACnD,CAAC;IAED,IAAW,OAAO;QAChB,IAAI,IAAI,CAAC,KAAK,KAAK,WAAW,EAAE;YAC9B,MAAM,IAAI,KAAK,CACb,mEAAmE,CACpE,CAAC;SACH;QAED,OAAO,UAAU,CAAC,qBAAqB,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC;IAChE,CAAC;IAED,IAAW,WAAW;QACpB,OAAO,cAAc,CACnB,IAAI,CAAC,wBAAwB,EAC7B,cAAc,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,yBAAyB,CACrD,CAAC;IACJ,CAAC;IAED;;;;OAIG;IACI,MAAM;QACX,OAAO,IAAI,UAAU,CACnB;YACE,KAAK,EAAE,IAAI,CAAC,KAAK;YACjB,iBAAiB,EAAE,IAAI,CAAC,iBAAiB;YACzC,iBAAiB,EAAE,IAAI,CAAC,iBAAiB;YACzC,KAAK,EAAE,IAAI,CAAC,KAAK;YACjB,SAAS,EAAE,IAAI,CAAC,cAAc;YAC9B,SAAS,EAAE,IAAI,CAAC,cAAc;YAC9B,KAAK,EAAE,IAAI,CAAC,KAAK;SAClB,EACD,uBAAA,UAAU,wCAAkB,CAC7B,CAAC;IACJ,CAAC;IAED;;;;;;;;;OASG;IACI,KAAK,CAAC,MAAM,CAAC,IAAqB;QACvC,OAAO,MAAM,eAAe,CAAC;YAC3B,IAAI;YACJ,IAAI,EAAE,IAAI;SACX,CAAC,CAAC;IACL,CAAC;IAED,qDAAqD;IAC9C,MAAM;QACX,OAAO;YACL,KAAK,EAAE,IAAI,CAAC,KAAK;YACjB,iBAAiB,EAAE,IAAI,CAAC,iBAAiB;YACzC,iBAAiB,EAAE,IAAI,CAAC,iBAAiB;YACzC,KAAK,EAAE,IAAI,CAAC,KAAK;YACjB,KAAK,EAAE,IAAI,CAAC,KAAK;YACjB,UAAU,EAAE,IAAI,CAAC,UAAU;YAC3B,SAAS,EAAE,IAAI,CAAC,SAAS;YACzB,SAAS,EAAE,IAAI,CAAC,SAAS;SAC1B,CAAC;IACJ,CAAC;;;AA3IM,wCAAoB,MAAM,CAAC,wBAAwB,CAAC,GAAC;AA8I9D;;;;;GAKG;AACH,MAAM,UAAU,kBAAkB,CAAC,KAAc;IAC/C,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,EAAE;QAC1B,MAAM,IAAI,KAAK,CACb,gFAAgF,MAAM,CACpF,KAAK,CACN,IAAI,CACN,CAAC;KACH;AACH,CAAC;AAED;;;;;;;;GAQG;AACH,MAAM,UAAU,yBAAyB,CACvC,iBAA0B,EAC1B,KAAa;IAEb,IAAI,CAAC,cAAc,CAAC,iBAAiB,CAAC,EAAE;QACtC,MAAM,IAAI,KAAK,CACb,sFAAsF,MAAM,CAC1F,iBAAiB,CAClB,IAAI,CACN,CAAC;KACH;IAED,IAAI,KAAK,KAAK,CAAC,IAAI,iBAAiB,KAAK,CAAC,EAAE;QAC1C,MAAM,IAAI,KAAK,CACb,sFAAsF,MAAM,CAC1F,iBAAiB,CAClB,IAAI,CACN,CAAC;KACH;IAED,IAAI,KAAK,GAAG,CAAC,IAAI,iBAAiB,KAAK,CAAC,EAAE;QACxC,MAAM,IAAI,KAAK,CACb,yFAAyF,MAAM,CAC7F,iBAAiB,CAClB,IAAI,CACN,CAAC;KACH;AACH,CAAC;AAED;;;;;;;;;GASG;AACH,MAAM,UAAU,+BAA+B,CAC7C,iBAAqC,EACrC,iBAAyB,EACzB,KAAa;IAEb,sCAAsC;IACtC,IAAI,CAAC,iBAAiB,EAAE;QACtB,OAAO;KACR;IAED,IAAI,KAAK,IAAI,CAAC,IAAI,iBAAiB,KAAK,iBAAiB,EAAE;QACzD,MAAM,IAAI,KAAK,CACb,qHAAqH,MAAM,CACzH,iBAAiB,CAClB,IAAI,CACN,CAAC;KACH;AACH,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,iBAAiB,CAAC,KAAa,EAAE,KAAa;IAC5D,IAAI,KAAK,KAAK,CAAC,IAAI,KAAK,KAAK,CAAC,EAAE;QAC9B,MAAM,IAAI,KAAK,CACb,mEAAmE,MAAM,CACvE,KAAK,CACN,IAAI,CACN,CAAC;KACH;AACH,CAAC;AAOD;;;;;;;GAOG;AACH,MAAM,CAAC,KAAK,UAAU,eAAe,CAAC,EACpC,IAAI,EACJ,IAAI,GACgB;IACpB,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE;QACrB,MAAM,IAAI,KAAK,CACb,8EAA8E,CAC/E,CAAC;KACH;IAED,2EAA2E;IAC3E,uDAAuD;IACvD,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC;IAC1C,kBAAkB,CAAC,QAAQ,CAAC,CAAC;IAE7B,OAAO,MAAM,iBAAiB,CAAC;QAC7B,IAAI;QACJ,IAAI;QACJ,KAAK,EAAE,QAAQ;KAChB,CAAC,CAAC;AACL,CAAC","sourcesContent":["import { assert, bytesToHex } from '@metamask/utils';\n\nimport type { BIP44CoinTypeNode } from './BIP44CoinTypeNode';\nimport type { BIP44Node } from './BIP44Node';\nimport type { RootedSLIP10PathTuple, SLIP10PathTuple } from './constants';\nimport { BYTES_KEY_LENGTH } from './constants';\nimport type { SupportedCurve } from './curves';\nimport { getCurveByName } from './curves';\nimport { deriveKeyFromPath } from './derivation';\nimport { publicKeyToEthAddress } from './derivers/bip32';\nimport {\n  getBytes,\n  getBytesUnsafe,\n  getFingerprint,\n  isValidInteger,\n  validateBIP32Index,\n  validateCurve,\n} from './utils';\n\n/**\n * A wrapper for SLIP-10 Hierarchical Deterministic (HD) tree nodes, i.e.\n * cryptographic keys used to generate key pairs and addresses for cryptocurrency\n * protocols.\n */\nexport type JsonSLIP10Node = {\n  /**\n   * The 0-indexed path depth of this node.\n   */\n  readonly depth: number;\n\n  /**\n   * The fingerprint of the master node, i.e., the node at depth 0. May be\n   * undefined if this node was created from an extended key.\n   */\n  readonly masterFingerprint?: number | undefined;\n\n  /**\n   * The fingerprint of the parent key, or 0 if this is a master node.\n   */\n  readonly parentFingerprint: number;\n\n  /**\n   * The index of the node, or 0 if this is a master node.\n   */\n  readonly index: number;\n\n  /**\n   * The (optional) private key of this node.\n   */\n  readonly privateKey?: string | undefined;\n\n  /**\n   * The public key of this node.\n   */\n  readonly publicKey: string;\n\n  /**\n   * The chain code of this node.\n   */\n  readonly chainCode: string;\n\n  /**\n   * The name of the curve used by the node.\n   */\n  readonly curve: SupportedCurve;\n};\n\nexport type SLIP10NodeInterface = JsonSLIP10Node & {\n  chainCodeBytes: Uint8Array;\n\n  /**\n   * The private key for this node, as a {@link Uint8Array}.\n   * May be undefined if this node is a public key only node.\n   */\n  privateKeyBytes?: Uint8Array | undefined;\n\n  /**\n   * The public key for this node, as a {@link Uint8Array}.\n   */\n  publicKeyBytes: Uint8Array;\n\n  /**\n   * @returns A JSON-compatible representation of this node's data fields.\n   */\n  toJSON(): JsonSLIP10Node;\n};\n\nexport type SLIP10NodeConstructorOptions = {\n  readonly depth: number;\n  readonly masterFingerprint?: number | undefined;\n  readonly parentFingerprint: number;\n  readonly index: number;\n  readonly chainCode: Uint8Array;\n  readonly privateKey?: Uint8Array | undefined;\n  readonly publicKey: Uint8Array;\n  readonly curve: SupportedCurve;\n};\n\nexport type SLIP10ExtendedKeyOptions = {\n  readonly depth: number;\n  readonly masterFingerprint?: number | undefined;\n  readonly parentFingerprint: number;\n  readonly index: number;\n  readonly chainCode: string | Uint8Array;\n  readonly privateKey?: string | Uint8Array | undefined;\n  readonly publicKey?: string | Uint8Array | undefined;\n  readonly curve: SupportedCurve;\n};\n\nexport type SLIP10DerivationPathOptions = {\n  readonly derivationPath: RootedSLIP10PathTuple;\n  readonly curve: SupportedCurve;\n};\n\nexport class SLIP10Node implements SLIP10NodeInterface {\n  /**\n   * Wrapper of the {@link fromExtendedKey} function. Refer to that function\n   * for documentation.\n   *\n   * @param json - The JSON representation of a SLIP-10 node.\n   */\n  static async fromJSON(json: JsonSLIP10Node): Promise<SLIP10Node> {\n    return SLIP10Node.fromExtendedKey(json);\n  }\n\n  /**\n   * Create a new SLIP-10 node from a key and chain code. You must specify\n   * either a private key or a public key. When specifying a private key,\n   * the public key will be derived from the private key.\n   *\n   * All parameters are stringently validated, and an error is thrown if\n   * validation fails.\n   *\n   * @param options - The options for the new node.\n   * @param options.depth - The depth of the node.\n   * @param options.masterFingerprint - The fingerprint of the master node, i.e., the\n   * node at depth 0. May be undefined if this node was created from an extended\n   * key.\n   * @param options.parentFingerprint - The fingerprint of the parent key, or 0 if\n   * the node is a master node.\n   * @param options.index - The index of the node, or 0 if the node is a master node.\n   * @param options.privateKey - The private key for the node.\n   * @param options.publicKey - The public key for the node. If a private key is\n   * specified, this parameter is ignored.\n   * @param options.chainCode - The chain code for the node.\n   * @param options.curve - The curve used by the node.\n   */\n  static async fromExtendedKey({\n    depth,\n    masterFingerprint,\n    parentFingerprint,\n    index,\n    privateKey,\n    publicKey,\n    chainCode,\n    curve,\n  }: SLIP10ExtendedKeyOptions) {\n    const chainCodeBytes = getBytes(chainCode, BYTES_KEY_LENGTH);\n\n    validateCurve(curve);\n    validateBIP32Depth(depth);\n    validateBIP32Index(index);\n    validateRootIndex(index, depth);\n    validateParentFingerprint(parentFingerprint, depth);\n    validateMasterParentFingerprint(\n      masterFingerprint,\n      parentFingerprint,\n      depth,\n    );\n\n    const curveObject = getCurveByName(curve);\n\n    if (privateKey) {\n      const privateKeyBytes = getBytesUnsafe(\n        privateKey,\n        curveObject.privateKeyLength,\n      );\n      assert(\n        curveObject.isValidPrivateKey(privateKeyBytes),\n        `Invalid private key: Value is not a valid ${curve} private key.`,\n      );\n\n      return new SLIP10Node(\n        {\n          depth,\n          masterFingerprint,\n          parentFingerprint,\n          index,\n          chainCode: chainCodeBytes,\n          privateKey: privateKeyBytes,\n          publicKey: await curveObject.getPublicKey(privateKeyBytes),\n          curve,\n        },\n        this.#constructorGuard,\n      );\n    }\n\n    if (publicKey) {\n      const publicKeyBytes = getBytes(publicKey, curveObject.publicKeyLength);\n\n      return new SLIP10Node(\n        {\n          depth,\n          masterFingerprint,\n          parentFingerprint,\n          index,\n          chainCode: chainCodeBytes,\n          publicKey: publicKeyBytes,\n          curve,\n        },\n        this.#constructorGuard,\n      );\n    }\n\n    throw new Error(\n      'Invalid options: Must provide either a private key or a public key.',\n    );\n  }\n\n  /**\n   * Create a new SLIP-10 node from a derivation path. The derivation path\n   * must be rooted, i.e. it must begin with a BIP-39 node, given as a string of\n   * the form `bip39:MNEMONIC`, where `MNEMONIC` is a space-separated list of\n   * BIP-39 seed phrase words.\n   *\n   * All parameters are stringently validated, and an error is thrown if\n   * validation fails.\n   *\n   * Recall that a BIP-44 HD tree path consists of the following nodes:\n   *\n   * `m / 44' / coin_type' / account' / change / address_index`\n   *\n   * With the following depths:\n   *\n   * `0 / 1 / 2 / 3 / 4 / 5`\n   *\n   * @param options - The options for the new node.\n   * @param options.derivationPath - The rooted HD tree path that will be used\n   * to derive the key of this node.\n   * @param options.curve - The curve used by the node.\n   * @returns A new SLIP-10 node.\n   */\n  static async fromDerivationPath({\n    derivationPath,\n    curve,\n  }: SLIP10DerivationPathOptions) {\n    validateCurve(curve);\n\n    if (!derivationPath) {\n      throw new Error('Invalid options: Must provide a derivation path.');\n    }\n\n    if (derivationPath.length === 0) {\n      throw new Error(\n        'Invalid derivation path: May not specify an empty derivation path.',\n      );\n    }\n\n    return await deriveKeyFromPath({\n      path: derivationPath,\n      depth: derivationPath.length - 1,\n      curve,\n    });\n  }\n\n  static #constructorGuard = Symbol('SLIP10Node.constructor');\n\n  public readonly curve: SupportedCurve;\n\n  public readonly depth: number;\n\n  public readonly masterFingerprint?: number | undefined;\n\n  public readonly parentFingerprint: number;\n\n  public readonly index: number;\n\n  public readonly chainCodeBytes: Uint8Array;\n\n  public readonly privateKeyBytes?: Uint8Array | undefined;\n\n  public readonly publicKeyBytes: Uint8Array;\n\n  // eslint-disable-next-line no-restricted-syntax\n  private constructor(\n    {\n      depth,\n      masterFingerprint,\n      parentFingerprint,\n      index,\n      chainCode,\n      privateKey,\n      publicKey,\n      curve,\n    }: SLIP10NodeConstructorOptions,\n    constructorGuard?: symbol,\n  ) {\n    assert(\n      constructorGuard === SLIP10Node.#constructorGuard,\n      'SLIP10Node can only be constructed using `SLIP10Node.fromJSON`, `SLIP10Node.fromExtendedKey`, or `SLIP10Node.fromDerivationPath`.',\n    );\n\n    this.depth = depth;\n    this.masterFingerprint = masterFingerprint;\n    this.parentFingerprint = parentFingerprint;\n    this.index = index;\n    this.chainCodeBytes = chainCode;\n    this.privateKeyBytes = privateKey;\n    this.publicKeyBytes = publicKey;\n    this.curve = curve;\n\n    Object.freeze(this);\n  }\n\n  public get chainCode() {\n    return bytesToHex(this.chainCodeBytes);\n  }\n\n  public get privateKey(): string | undefined {\n    if (this.privateKeyBytes) {\n      return bytesToHex(this.privateKeyBytes);\n    }\n\n    return undefined;\n  }\n\n  public get publicKey(): string {\n    return bytesToHex(this.publicKeyBytes);\n  }\n\n  public get compressedPublicKeyBytes(): Uint8Array {\n    return getCurveByName(this.curve).compressPublicKey(this.publicKeyBytes);\n  }\n\n  public get compressedPublicKey(): string {\n    return bytesToHex(this.compressedPublicKeyBytes);\n  }\n\n  public get address(): string {\n    if (this.curve !== 'secp256k1') {\n      throw new Error(\n        'Unable to get address for this node: Only secp256k1 is supported.',\n      );\n    }\n\n    return bytesToHex(publicKeyToEthAddress(this.publicKeyBytes));\n  }\n\n  public get fingerprint(): number {\n    return getFingerprint(\n      this.compressedPublicKeyBytes,\n      getCurveByName(this.curve).compressedPublicKeyLength,\n    );\n  }\n\n  /**\n   * Get a neutered version of this node, i.e. a node without a private key.\n   *\n   * @returns A neutered version of this node.\n   */\n  public neuter(): SLIP10Node {\n    return new SLIP10Node(\n      {\n        depth: this.depth,\n        masterFingerprint: this.masterFingerprint,\n        parentFingerprint: this.parentFingerprint,\n        index: this.index,\n        chainCode: this.chainCodeBytes,\n        publicKey: this.publicKeyBytes,\n        curve: this.curve,\n      },\n      SLIP10Node.#constructorGuard,\n    );\n  }\n\n  /**\n   * Derives a child of the key contains be this node and returns a new\n   * {@link SLIP10Node} containing the child key.\n   *\n   * The specified path must be a valid HD path from this node, per SLIP-10.\n   *\n   * @param path - The partial (non-rooted) SLIP-10 HD tree path will be used\n   * to derive a child key from the parent key contained within this node.\n   * @returns The {@link SLIP10Node} corresponding to the derived child key.\n   */\n  public async derive(path: SLIP10PathTuple): Promise<SLIP10Node> {\n    return await deriveChildNode({\n      path,\n      node: this,\n    });\n  }\n\n  // This is documented in the interface of this class.\n  public toJSON(): JsonSLIP10Node {\n    return {\n      depth: this.depth,\n      masterFingerprint: this.masterFingerprint,\n      parentFingerprint: this.parentFingerprint,\n      index: this.index,\n      curve: this.curve,\n      privateKey: this.privateKey,\n      publicKey: this.publicKey,\n      chainCode: this.chainCode,\n    };\n  }\n}\n\n/**\n * Validates a BIP-32 path depth. Effectively, asserts that the depth is an\n * integer `number`. Throws an error if validation fails.\n *\n * @param depth - The depth to validate.\n */\nexport function validateBIP32Depth(depth: unknown): asserts depth is number {\n  if (!isValidInteger(depth)) {\n    throw new Error(\n      `Invalid HD tree path depth: The depth must be a positive integer. Received: \"${String(\n        depth,\n      )}\".`,\n    );\n  }\n}\n\n/**\n * Validates a BIP-32 parent fingerprint. Effectively, asserts that the fingerprint is an\n * integer `number`. Throws an error if validation fails.\n *\n * @param parentFingerprint - The parent fingerprint to validate.\n * @param depth - The depth of the node to validate.\n * @throws If the parent fingerprint is not a positive integer, or invalid for\n * the current depth.\n */\nexport function validateParentFingerprint(\n  parentFingerprint: unknown,\n  depth: number,\n): asserts parentFingerprint is number {\n  if (!isValidInteger(parentFingerprint)) {\n    throw new Error(\n      `Invalid parent fingerprint: The fingerprint must be a positive integer. Received: \"${String(\n        parentFingerprint,\n      )}\".`,\n    );\n  }\n\n  if (depth === 0 && parentFingerprint !== 0) {\n    throw new Error(\n      `Invalid parent fingerprint: The fingerprint of the root node must be 0. Received: \"${String(\n        parentFingerprint,\n      )}\".`,\n    );\n  }\n\n  if (depth > 0 && parentFingerprint === 0) {\n    throw new Error(\n      `Invalid parent fingerprint: The fingerprint of a child node must not be 0. Received: \"${String(\n        parentFingerprint,\n      )}\".`,\n    );\n  }\n}\n\n/**\n * Validate that a given combination of master fingerprint and parent\n * fingerprint is valid for the given depth.\n *\n * @param masterFingerprint - The master fingerprint to validate.\n * @param parentFingerprint - The parent fingerprint to validate.\n * @param depth - The depth of the node to validate.\n * @throws If the combination of master fingerprint and parent fingerprint is\n * invalid for the given depth.\n */\nexport function validateMasterParentFingerprint(\n  masterFingerprint: number | undefined,\n  parentFingerprint: number,\n  depth: number,\n) {\n  // The master fingerprint is optional.\n  if (!masterFingerprint) {\n    return;\n  }\n\n  if (depth >= 2 && masterFingerprint === parentFingerprint) {\n    throw new Error(\n      `Invalid parent fingerprint: The fingerprint of a child node cannot be equal to the master fingerprint. Received: \"${String(\n        parentFingerprint,\n      )}\".`,\n    );\n  }\n}\n\n/**\n * Validate that the index is zero for the root node.\n *\n * @param index - The index to validate.\n * @param depth - The depth of the node to validate.\n * @throws If the index is not zero for the root node.\n */\nexport function validateRootIndex(index: number, depth: number) {\n  if (depth === 0 && index !== 0) {\n    throw new Error(\n      `Invalid index: The index of the root node must be 0. Received: \"${String(\n        index,\n      )}\".`,\n    );\n  }\n}\n\ntype DeriveChildNodeArgs = {\n  path: SLIP10PathTuple;\n  node: SLIP10Node | BIP44Node | BIP44CoinTypeNode;\n};\n\n/**\n * Derives a child key from the given parent key.\n *\n * @param options - The options to use when deriving the child key.\n * @param options.node - The node to derive from.\n * @param options.path - The path to the child node / key.\n * @returns The derived key and depth.\n */\nexport async function deriveChildNode({\n  path,\n  node,\n}: DeriveChildNodeArgs): Promise<SLIP10Node> {\n  if (path.length === 0) {\n    throw new Error(\n      'Invalid HD tree derivation path: Deriving a path of length 0 is not defined.',\n    );\n  }\n\n  // Note that we do not subtract 1 from the length of the path to the child,\n  // unlike when we calculate the depth of a rooted path.\n  const newDepth = node.depth + path.length;\n  validateBIP32Depth(newDepth);\n\n  return await deriveKeyFromPath({\n    path,\n    node,\n    depth: newDepth,\n  });\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"SLIP10Node.mjs","sourceRoot":"","sources":["../src/SLIP10Node.ts"],"names":[],"mappings":"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","sourcesContent":["import { assert, bytesToHex } from '@metamask/utils';\n\nimport type { BIP44CoinTypeNode } from './BIP44CoinTypeNode';\nimport type { BIP44Node } from './BIP44Node';\nimport type { RootedSLIP10PathTuple, SLIP10PathTuple } from './constants';\nimport { BYTES_KEY_LENGTH } from './constants';\nimport type { CryptographicFunctions } from './cryptography';\nimport type { SupportedCurve } from './curves';\nimport { getCurveByName } from './curves';\nimport { deriveKeyFromPath } from './derivation';\nimport { publicKeyToEthAddress } from './derivers/bip32';\nimport {\n  decodeExtendedKey,\n  encodeExtendedKey,\n  PRIVATE_KEY_VERSION,\n  PUBLIC_KEY_VERSION,\n} from './extended-keys';\nimport {\n  getBytes,\n  getBytesUnsafe,\n  getFingerprint,\n  isValidInteger,\n  validateBIP32Index,\n  validateCurve,\n} from './utils';\n\n/**\n * A wrapper for SLIP-10 Hierarchical Deterministic (HD) tree nodes, i.e.\n * cryptographic keys used to generate key pairs and addresses for cryptocurrency\n * protocols.\n */\nexport type JsonSLIP10Node = {\n  /**\n   * The 0-indexed path depth of this node.\n   */\n  readonly depth: number;\n\n  /**\n   * The fingerprint of the master node, i.e., the node at depth 0. May be\n   * undefined if this node was created from an extended key.\n   */\n  readonly masterFingerprint?: number | undefined;\n\n  /**\n   * The fingerprint of the parent key, or 0 if this is a master node.\n   */\n  readonly parentFingerprint: number;\n\n  /**\n   * The index of the node, or 0 if this is a master node.\n   */\n  readonly index: number;\n\n  /**\n   * The (optional) private key of this node.\n   */\n  readonly privateKey?: string | undefined;\n\n  /**\n   * The public key of this node.\n   */\n  readonly publicKey: string;\n\n  /**\n   * The chain code of this node.\n   */\n  readonly chainCode: string;\n\n  /**\n   * The name of the curve used by the node.\n   */\n  readonly curve: SupportedCurve;\n};\n\nexport type SLIP10NodeInterface = JsonSLIP10Node & {\n  chainCodeBytes: Uint8Array;\n\n  /**\n   * The private key for this node, as a {@link Uint8Array}.\n   * May be undefined if this node is a public key only node.\n   */\n  privateKeyBytes?: Uint8Array | undefined;\n\n  /**\n   * The public key for this node, as a {@link Uint8Array}.\n   */\n  publicKeyBytes: Uint8Array;\n\n  /**\n   * @returns A JSON-compatible representation of this node's data fields.\n   */\n  toJSON(): JsonSLIP10Node;\n};\n\nexport type SLIP10NodeConstructorOptions = {\n  readonly depth: number;\n  readonly masterFingerprint?: number | undefined;\n  readonly parentFingerprint: number;\n  readonly index: number;\n  readonly chainCode: Uint8Array;\n  readonly privateKey?: Uint8Array | undefined;\n  readonly publicKey: Uint8Array;\n  readonly curve: SupportedCurve;\n};\n\nexport type SLIP10ExtendedKeyOptions = {\n  readonly depth: number;\n  readonly masterFingerprint?: number | undefined;\n  readonly parentFingerprint: number;\n  readonly index: number;\n  readonly chainCode: string | Uint8Array;\n  readonly privateKey?: string | Uint8Array | undefined;\n  readonly publicKey?: string | Uint8Array | undefined;\n  readonly curve: SupportedCurve;\n};\n\nexport type SLIP10DerivationPathOptions = {\n  readonly derivationPath: RootedSLIP10PathTuple;\n  readonly curve: SupportedCurve;\n};\n\nexport class SLIP10Node implements SLIP10NodeInterface {\n  /**\n   * Wrapper of the {@link fromExtendedKey} function. Refer to that function\n   * for documentation.\n   *\n   * @param json - The JSON representation of a SLIP-10 node.\n   * @param cryptographicFunctions - The cryptographic functions to use. If\n   * provided, these will be used instead of the built-in implementations.\n   * @returns A SLIP10 node.\n   */\n  static async fromJSON(\n    json: JsonSLIP10Node,\n    cryptographicFunctions?: CryptographicFunctions,\n  ): Promise<SLIP10Node> {\n    return SLIP10Node.fromExtendedKey(json, cryptographicFunctions);\n  }\n\n  /**\n   * Create a new SLIP-10 node from a BIP-32 serialised extended key string.\n   * The key may be either public or private. Note that `secp256k1` is assumed\n   * as the curve for the key.\n   *\n   * All parameters are stringently validated, and an error is thrown if\n   * validation fails.\n   *\n   * @param extendedKey - The BIP-32 extended key string.\n   * @param cryptographicFunctions - The cryptographic functions to use. If\n   * provided, these will be used instead of the built-in implementations.\n   * @returns A SLIP10 node.\n   */\n  static async fromExtendedKey(\n    extendedKey: string,\n    cryptographicFunctions?: CryptographicFunctions,\n  ): Promise<SLIP10Node>;\n\n  /**\n   * Create a new SLIP-10 node from a key and chain code. You must specify\n   * either a private key or a public key. When specifying a private key,\n   * the public key will be derived from the private key.\n   *\n   * All parameters are stringently validated, and an error is thrown if\n   * validation fails.\n   *\n   * @param options - The options for the new node.\n   * @param options.depth - The depth of the node.\n   * @param options.masterFingerprint - The fingerprint of the master node, i.e., the\n   * node at depth 0. May be undefined if this node was created from an extended\n   * key.\n   * @param options.parentFingerprint - The fingerprint of the parent key, or 0 if\n   * the node is a master node.\n   * @param options.index - The index of the node, or 0 if the node is a master node.\n   * @param options.privateKey - The private key for the node.\n   * @param options.publicKey - The public key for the node. If a private key is\n   * specified, this parameter is ignored.\n   * @param options.chainCode - The chain code for the node.\n   * @param options.curve - The curve used by the node.\n   * @param cryptographicFunctions - The cryptographic functions to use. If\n   * provided, these will be used instead of the built-in implementations.\n   * @returns A SLIP10 node.\n   */\n  static async fromExtendedKey(\n    // These signatures could technically be combined, but it's easier to\n    // document them separately.\n    // eslint-disable-next-line @typescript-eslint/unified-signatures\n    options: SLIP10ExtendedKeyOptions,\n    cryptographicFunctions?: CryptographicFunctions,\n  ): Promise<SLIP10Node>;\n\n  /**\n   * Create a new SLIP-10 node from a key and chain code. You must specify\n   * either a private key or a public key. When specifying a private key,\n   * the public key will be derived from the private key.\n   *\n   * All parameters are stringently validated, and an error is thrown if\n   * validation fails.\n   *\n   * @param options - The options for the new node. This can be an object\n   * containing the extended key options, or a string containing the extended\n   * key.\n   * @param options.depth - The depth of the node.\n   * @param options.masterFingerprint - The fingerprint of the master node, i.e., the\n   * node at depth 0. May be undefined if this node was created from an extended\n   * key.\n   * @param options.parentFingerprint - The fingerprint of the parent key, or 0 if\n   * the node is a master node.\n   * @param options.index - The index of the node, or 0 if the node is a master node.\n   * @param options.privateKey - The private key for the node.\n   * @param options.publicKey - The public key for the node. If a private key is\n   * specified, this parameter is ignored.\n   * @param options.chainCode - The chain code for the node.\n   * @param options.curve - The curve used by the node.\n   * @param cryptographicFunctions - The cryptographic functions to use. If\n   * provided, these will be used instead of the built-in implementations.\n   * @returns A SLIP10 node.\n   */\n  static async fromExtendedKey(\n    options: SLIP10ExtendedKeyOptions | string,\n    cryptographicFunctions?: CryptographicFunctions,\n  ): Promise<SLIP10Node> {\n    if (typeof options === 'string') {\n      const extendedKey = decodeExtendedKey(options);\n\n      const { chainCode, depth, parentFingerprint, index } = extendedKey;\n\n      if (extendedKey.version === PRIVATE_KEY_VERSION) {\n        const { privateKey } = extendedKey;\n\n        return SLIP10Node.fromExtendedKey(\n          {\n            depth,\n            parentFingerprint,\n            index,\n            privateKey,\n            chainCode,\n            // BIP-32 key serialisation assumes `secp256k1`.\n            curve: 'secp256k1',\n          },\n          cryptographicFunctions,\n        );\n      }\n\n      const { publicKey } = extendedKey;\n\n      return SLIP10Node.fromExtendedKey(\n        {\n          depth,\n          parentFingerprint,\n          index,\n          publicKey,\n          chainCode,\n          // BIP-32 key serialisation assumes `secp256k1`.\n          curve: 'secp256k1',\n        },\n        cryptographicFunctions,\n      );\n    }\n\n    const {\n      depth,\n      masterFingerprint,\n      parentFingerprint,\n      index,\n      privateKey,\n      publicKey,\n      chainCode,\n      curve,\n    } = options;\n\n    const chainCodeBytes = getBytes(chainCode, BYTES_KEY_LENGTH);\n\n    validateCurve(curve);\n    validateBIP32Depth(depth);\n    validateBIP32Index(index);\n    validateRootIndex(index, depth);\n    validateParentFingerprint(parentFingerprint, depth);\n    validateMasterParentFingerprint(\n      masterFingerprint,\n      parentFingerprint,\n      depth,\n    );\n\n    const curveObject = getCurveByName(curve);\n\n    if (privateKey) {\n      const privateKeyBytes = getBytesUnsafe(\n        privateKey,\n        curveObject.privateKeyLength,\n      );\n      assert(\n        curveObject.isValidPrivateKey(privateKeyBytes),\n        `Invalid private key: Value is not a valid ${curve} private key.`,\n      );\n\n      return new SLIP10Node(\n        {\n          depth,\n          masterFingerprint,\n          parentFingerprint,\n          index,\n          chainCode: chainCodeBytes,\n          privateKey: privateKeyBytes,\n          publicKey: await curveObject.getPublicKey(privateKeyBytes),\n          curve,\n        },\n        cryptographicFunctions,\n        this.#constructorGuard,\n      );\n    }\n\n    if (publicKey) {\n      const publicKeyBytes = getBytes(publicKey, curveObject.publicKeyLength);\n\n      return new SLIP10Node(\n        {\n          depth,\n          masterFingerprint,\n          parentFingerprint,\n          index,\n          chainCode: chainCodeBytes,\n          publicKey: publicKeyBytes,\n          curve,\n        },\n        cryptographicFunctions,\n        this.#constructorGuard,\n      );\n    }\n\n    throw new Error(\n      'Invalid options: Must provide either a private key or a public key.',\n    );\n  }\n\n  /**\n   * Create a new SLIP-10 node from a derivation path. The derivation path\n   * must be rooted, i.e. it must begin with a BIP-39 node, given as a string of\n   * the form `bip39:MNEMONIC`, where `MNEMONIC` is a space-separated list of\n   * BIP-39 seed phrase words.\n   *\n   * All parameters are stringently validated, and an error is thrown if\n   * validation fails.\n   *\n   * Recall that a BIP-44 HD tree path consists of the following nodes:\n   *\n   * `m / 44' / coin_type' / account' / change / address_index`\n   *\n   * With the following depths:\n   *\n   * `0 / 1 / 2 / 3 / 4 / 5`\n   *\n   * @param options - The options for the new node.\n   * @param options.derivationPath - The rooted HD tree path that will be used\n   * to derive the key of this node.\n   * @param options.curve - The curve used by the node.\n   * @param cryptographicFunctions - The cryptographic functions to use. If\n   * provided, these will be used instead of the built-in implementations.\n   * @returns A new SLIP-10 node.\n   */\n  static async fromDerivationPath(\n    { derivationPath, curve }: SLIP10DerivationPathOptions,\n    cryptographicFunctions?: CryptographicFunctions,\n  ): Promise<SLIP10Node> {\n    validateCurve(curve);\n\n    if (!derivationPath) {\n      throw new Error('Invalid options: Must provide a derivation path.');\n    }\n\n    if (derivationPath.length === 0) {\n      throw new Error(\n        'Invalid derivation path: May not specify an empty derivation path.',\n      );\n    }\n\n    return await deriveKeyFromPath(\n      {\n        path: derivationPath,\n        depth: derivationPath.length - 1,\n        curve,\n      },\n      cryptographicFunctions,\n    );\n  }\n\n  static readonly #constructorGuard = Symbol('SLIP10Node.constructor');\n\n  public readonly curve: SupportedCurve;\n\n  public readonly depth: number;\n\n  public readonly masterFingerprint?: number | undefined;\n\n  public readonly parentFingerprint: number;\n\n  public readonly index: number;\n\n  public readonly chainCodeBytes: Uint8Array;\n\n  public readonly privateKeyBytes?: Uint8Array | undefined;\n\n  public readonly publicKeyBytes: Uint8Array;\n\n  readonly #cryptographicFunctions: CryptographicFunctions;\n\n  // eslint-disable-next-line no-restricted-syntax\n  private constructor(\n    {\n      depth,\n      masterFingerprint,\n      parentFingerprint,\n      index,\n      chainCode,\n      privateKey,\n      publicKey,\n      curve,\n    }: SLIP10NodeConstructorOptions,\n    cryptographicFunctions: CryptographicFunctions = {},\n    constructorGuard?: symbol,\n  ) {\n    assert(\n      constructorGuard === SLIP10Node.#constructorGuard,\n      'SLIP10Node can only be constructed using `SLIP10Node.fromJSON`, `SLIP10Node.fromExtendedKey`, or `SLIP10Node.fromDerivationPath`.',\n    );\n\n    this.depth = depth;\n    this.masterFingerprint = masterFingerprint;\n    this.parentFingerprint = parentFingerprint;\n    this.index = index;\n    this.chainCodeBytes = chainCode;\n    this.privateKeyBytes = privateKey;\n    this.publicKeyBytes = publicKey;\n    this.curve = curve;\n    this.#cryptographicFunctions = cryptographicFunctions;\n\n    Object.freeze(this);\n  }\n\n  public get chainCode(): string {\n    return bytesToHex(this.chainCodeBytes);\n  }\n\n  public get privateKey(): string | undefined {\n    if (this.privateKeyBytes) {\n      return bytesToHex(this.privateKeyBytes);\n    }\n\n    return undefined;\n  }\n\n  public get publicKey(): string {\n    return bytesToHex(this.publicKeyBytes);\n  }\n\n  public get compressedPublicKeyBytes(): Uint8Array {\n    return getCurveByName(this.curve).compressPublicKey(this.publicKeyBytes);\n  }\n\n  public get compressedPublicKey(): string {\n    return bytesToHex(this.compressedPublicKeyBytes);\n  }\n\n  public get address(): string {\n    if (this.curve !== 'secp256k1') {\n      throw new Error(\n        'Unable to get address for this node: Only secp256k1 is supported.',\n      );\n    }\n\n    return bytesToHex(publicKeyToEthAddress(this.publicKeyBytes));\n  }\n\n  public get fingerprint(): number {\n    return getFingerprint(\n      this.compressedPublicKeyBytes,\n      getCurveByName(this.curve).compressedPublicKeyLength,\n    );\n  }\n\n  /**\n   * Get the extended public or private key for the SLIP-10 node. SLIP-10\n   * doesn't specify a format for extended keys, so we use the BIP-32 format.\n   *\n   * This property is only supported for `secp256k1` nodes, as other curves\n   * don't specify a standard format for extended keys.\n   *\n   * @returns The extended public or private key for the node.\n   */\n  public get extendedKey(): string {\n    assert(\n      this.curve === 'secp256k1',\n      'Unable to get extended key for this node: Only secp256k1 is supported.',\n    );\n\n    const data = {\n      depth: this.depth,\n      parentFingerprint: this.parentFingerprint,\n      index: this.index,\n      chainCode: this.chainCodeBytes,\n    };\n\n    if (this.privateKeyBytes) {\n      return encodeExtendedKey({\n        ...data,\n        version: PRIVATE_KEY_VERSION,\n        privateKey: this.privateKeyBytes,\n      });\n    }\n\n    return encodeExtendedKey({\n      ...data,\n      version: PUBLIC_KEY_VERSION,\n      publicKey: this.publicKeyBytes,\n    });\n  }\n\n  /**\n   * Get a neutered version of this node, i.e. a node without a private key.\n   *\n   * @returns A neutered version of this node.\n   */\n  public neuter(): SLIP10Node {\n    return new SLIP10Node(\n      {\n        depth: this.depth,\n        masterFingerprint: this.masterFingerprint,\n        parentFingerprint: this.parentFingerprint,\n        index: this.index,\n        chainCode: this.chainCodeBytes,\n        publicKey: this.publicKeyBytes,\n        curve: this.curve,\n      },\n      this.#cryptographicFunctions,\n      SLIP10Node.#constructorGuard,\n    );\n  }\n\n  /**\n   * Derives a child of the key contains be this node and returns a new\n   * {@link SLIP10Node} containing the child key.\n   *\n   * The specified path must be a valid HD path from this node, per SLIP-10.\n   *\n   * @param path - The partial (non-rooted) SLIP-10 HD tree path will be used\n   * to derive a child key from the parent key contained within this node.\n   * @returns The {@link SLIP10Node} corresponding to the derived child key.\n   */\n  public async derive(path: SLIP10PathTuple): Promise<SLIP10Node> {\n    return await deriveChildNode(\n      {\n        path,\n        node: this,\n      },\n      this.#cryptographicFunctions,\n    );\n  }\n\n  // This is documented in the interface of this class.\n  public toJSON(): JsonSLIP10Node {\n    return {\n      depth: this.depth,\n      masterFingerprint: this.masterFingerprint,\n      parentFingerprint: this.parentFingerprint,\n      index: this.index,\n      curve: this.curve,\n      privateKey: this.privateKey,\n      publicKey: this.publicKey,\n      chainCode: this.chainCode,\n    };\n  }\n}\n\n/**\n * Validates a BIP-32 path depth. Effectively, asserts that the depth is an\n * integer `number`. Throws an error if validation fails.\n *\n * @param depth - The depth to validate.\n */\nexport function validateBIP32Depth(depth: unknown): asserts depth is number {\n  if (!isValidInteger(depth)) {\n    throw new Error(\n      `Invalid HD tree path depth: The depth must be a positive integer. Received: \"${String(\n        depth,\n      )}\".`,\n    );\n  }\n}\n\n/**\n * Validates a BIP-32 parent fingerprint. Effectively, asserts that the fingerprint is an\n * integer `number`. Throws an error if validation fails.\n *\n * @param parentFingerprint - The parent fingerprint to validate.\n * @param depth - The depth of the node to validate.\n * @throws If the parent fingerprint is not a positive integer, or invalid for\n * the current depth.\n */\nexport function validateParentFingerprint(\n  parentFingerprint: unknown,\n  depth: number,\n): asserts parentFingerprint is number {\n  if (!isValidInteger(parentFingerprint)) {\n    throw new Error(\n      `Invalid parent fingerprint: The fingerprint must be a positive integer. Received: \"${String(\n        parentFingerprint,\n      )}\".`,\n    );\n  }\n\n  if (depth === 0 && parentFingerprint !== 0) {\n    throw new Error(\n      `Invalid parent fingerprint: The fingerprint of the root node must be 0. Received: \"${String(\n        parentFingerprint,\n      )}\".`,\n    );\n  }\n\n  if (depth > 0 && parentFingerprint === 0) {\n    throw new Error(\n      `Invalid parent fingerprint: The fingerprint of a child node must not be 0. Received: \"${String(\n        parentFingerprint,\n      )}\".`,\n    );\n  }\n}\n\n/**\n * Validate that a given combination of master fingerprint and parent\n * fingerprint is valid for the given depth.\n *\n * @param masterFingerprint - The master fingerprint to validate.\n * @param parentFingerprint - The parent fingerprint to validate.\n * @param depth - The depth of the node to validate.\n * @throws If the combination of master fingerprint and parent fingerprint is\n * invalid for the given depth.\n */\nexport function validateMasterParentFingerprint(\n  masterFingerprint: number | undefined,\n  parentFingerprint: number,\n  depth: number,\n): void {\n  // The master fingerprint is optional.\n  if (!masterFingerprint) {\n    return;\n  }\n\n  if (depth >= 2 && masterFingerprint === parentFingerprint) {\n    throw new Error(\n      `Invalid parent fingerprint: The fingerprint of a child node cannot be equal to the master fingerprint. Received: \"${String(\n        parentFingerprint,\n      )}\".`,\n    );\n  }\n}\n\n/**\n * Validate that the index is zero for the root node.\n *\n * @param index - The index to validate.\n * @param depth - The depth of the node to validate.\n * @throws If the index is not zero for the root node.\n */\nexport function validateRootIndex(index: number, depth: number): void {\n  if (depth === 0 && index !== 0) {\n    throw new Error(\n      `Invalid index: The index of the root node must be 0. Received: \"${String(\n        index,\n      )}\".`,\n    );\n  }\n}\n\ntype DeriveChildNodeArgs = {\n  path: SLIP10PathTuple;\n  node: SLIP10Node | BIP44Node | BIP44CoinTypeNode;\n};\n\n/**\n * Derives a child key from the given parent key.\n *\n * @param options - The options to use when deriving the child key.\n * @param options.node - The node to derive from.\n * @param options.path - The path to the child node / key.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The derived key and depth.\n */\nexport async function deriveChildNode(\n  { path, node }: DeriveChildNodeArgs,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<SLIP10Node> {\n  if (path.length === 0) {\n    throw new Error(\n      'Invalid HD tree derivation path: Deriving a path of length 0 is not defined.',\n    );\n  }\n\n  // Note that we do not subtract 1 from the length of the path to the child,\n  // unlike when we calculate the depth of a rooted path.\n  const newDepth = node.depth + path.length;\n  validateBIP32Depth(newDepth);\n\n  return await deriveKeyFromPath(\n    {\n      path,\n      node,\n      depth: newDepth,\n    },\n    cryptographicFunctions,\n  );\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/constants.d.cts b/node_modules/@metamask/key-tree/dist/constants.d.cts
index 0d35d26..bf42ba2 100644
--- a/node_modules/@metamask/key-tree/dist/constants.d.cts
+++ b/node_modules/@metamask/key-tree/dist/constants.d.cts
@@ -3,22 +3,22 @@ export declare const MIN_BIP_44_DEPTH = 0;
 export declare const MAX_BIP_44_DEPTH = 5;
 export declare const MAX_UNHARDENED_BIP_32_INDEX = 2147483647;
 export declare const MAX_BIP_32_INDEX = 4294967295;
-export declare type MinBIP44Depth = typeof MIN_BIP_44_DEPTH;
-export declare type MaxBIP44Depth = typeof MAX_BIP_44_DEPTH;
-export declare type BIP44Depth = MinBIP44Depth | 1 | 2 | 3 | 4 | MaxBIP44Depth;
-export declare type UnprefixedNode = `${number}'`;
-export declare type AnonymizedBIP39Node = 'm';
-export declare type BIP39StringNode = `bip39:${string}`;
-export declare type BIP39Node = BIP39StringNode | Uint8Array;
-export declare type HardenedBIP32Node = `bip32:${number}'`;
-export declare type UnhardenedBIP32Node = `bip32:${number}`;
-export declare type BIP32Node = HardenedBIP32Node | UnhardenedBIP32Node;
-export declare type HardenedSLIP10Node = `slip10:${number}'`;
-export declare type UnhardenedSLIP10Node = `slip10:${number}`;
-export declare type SLIP10PathNode = HardenedSLIP10Node | UnhardenedSLIP10Node;
-export declare type HardenedCIP3Node = `cip3:${number}'`;
-export declare type UnhardenedCIP3Node = `cip3:${number}`;
-export declare type CIP3PathNode = HardenedCIP3Node | UnhardenedCIP3Node;
+export type MinBIP44Depth = typeof MIN_BIP_44_DEPTH;
+export type MaxBIP44Depth = typeof MAX_BIP_44_DEPTH;
+export type BIP44Depth = MinBIP44Depth | 1 | 2 | 3 | 4 | MaxBIP44Depth;
+export type UnprefixedNode = `${number}'`;
+export type AnonymizedBIP39Node = 'm';
+export type BIP39StringNode = `bip39:${string}`;
+export type BIP39Node = BIP39StringNode | Uint8Array;
+export type HardenedBIP32Node = `bip32:${number}'`;
+export type UnhardenedBIP32Node = `bip32:${number}`;
+export type BIP32Node = HardenedBIP32Node | UnhardenedBIP32Node;
+export type HardenedSLIP10Node = `slip10:${number}'`;
+export type UnhardenedSLIP10Node = `slip10:${number}`;
+export type SLIP10PathNode = HardenedSLIP10Node | UnhardenedSLIP10Node;
+export type HardenedCIP3Node = `cip3:${number}'`;
+export type UnhardenedCIP3Node = `cip3:${number}`;
+export type CIP3PathNode = HardenedCIP3Node | UnhardenedCIP3Node;
 export declare const BIP44PurposeNodeToken = "bip32:44'";
 export declare const UNPREFIXED_PATH_REGEX: RegExp;
 /**
@@ -52,73 +52,73 @@ export declare const CIP_3_PATH_REGEX: RegExp;
  */
 export declare const BIP_39_PATH_REGEX: RegExp;
 export declare const BIP_32_HARDENED_OFFSET = 2147483648;
-export declare type HDPathString0 = AnonymizedBIP39Node;
-export declare type HDPathString1 = `${HDPathString0} / ${HardenedBIP32Node}`;
-export declare type HDPathString2 = `${HDPathString1} / ${HardenedBIP32Node}`;
-export declare type HDPathString3 = `${HDPathString2} / ${HardenedBIP32Node}`;
-export declare type HDPathString4 = `${HDPathString3} / ${BIP32Node}`;
-export declare type HDPathString5 = `${HDPathString4} / ${BIP32Node}`;
-export declare type CoinTypeHDPathString = HDPathString2;
-export declare type ChangeHDPathString = HDPathString4;
-export declare type AddressHDPathString = HDPathString5;
-export declare type HDPathString = HDPathString0 | HDPathString1 | HDPathString2 | HDPathString3 | HDPathString4 | HDPathString5;
-export declare type RootedHDPathTuple0 = readonly [BIP39Node];
-export declare type RootedHDPathTuple1 = readonly [
+export type HDPathString0 = AnonymizedBIP39Node;
+export type HDPathString1 = `${HDPathString0} / ${HardenedBIP32Node}`;
+export type HDPathString2 = `${HDPathString1} / ${HardenedBIP32Node}`;
+export type HDPathString3 = `${HDPathString2} / ${HardenedBIP32Node}`;
+export type HDPathString4 = `${HDPathString3} / ${BIP32Node}`;
+export type HDPathString5 = `${HDPathString4} / ${BIP32Node}`;
+export type CoinTypeHDPathString = HDPathString2;
+export type ChangeHDPathString = HDPathString4;
+export type AddressHDPathString = HDPathString5;
+export type HDPathString = HDPathString0 | HDPathString1 | HDPathString2 | HDPathString3 | HDPathString4 | HDPathString5;
+export type RootedHDPathTuple0 = readonly [BIP39Node];
+export type RootedHDPathTuple1 = readonly [
     ...RootedHDPathTuple0,
     HardenedBIP32Node
 ];
-export declare type RootedHDPathTuple2 = readonly [
+export type RootedHDPathTuple2 = readonly [
     ...RootedHDPathTuple1,
     HardenedBIP32Node
 ];
-export declare type RootedHDPathTuple3 = readonly [
+export type RootedHDPathTuple3 = readonly [
     ...RootedHDPathTuple2,
     HardenedBIP32Node
 ];
-export declare type RootedHDPathTuple4 = readonly [...RootedHDPathTuple3, BIP32Node];
-export declare type RootedHDPathTuple5 = readonly [...RootedHDPathTuple4, BIP32Node];
-export declare type RootedHDPathTuple = RootedHDPathTuple0 | RootedHDPathTuple1 | RootedHDPathTuple2 | RootedHDPathTuple3 | RootedHDPathTuple4 | RootedHDPathTuple5;
-export declare type PartialHDPathTuple1 = readonly [HardenedBIP32Node];
-export declare type PartialHDPathTuple2 = readonly [
+export type RootedHDPathTuple4 = readonly [...RootedHDPathTuple3, BIP32Node];
+export type RootedHDPathTuple5 = readonly [...RootedHDPathTuple4, BIP32Node];
+export type RootedHDPathTuple = RootedHDPathTuple0 | RootedHDPathTuple1 | RootedHDPathTuple2 | RootedHDPathTuple3 | RootedHDPathTuple4 | RootedHDPathTuple5;
+export type PartialHDPathTuple1 = readonly [HardenedBIP32Node];
+export type PartialHDPathTuple2 = readonly [
     ...PartialHDPathTuple1,
     HardenedBIP32Node
 ];
-export declare type PartialHDPathTuple3 = readonly [
+export type PartialHDPathTuple3 = readonly [
     ...PartialHDPathTuple2,
     HardenedBIP32Node
 ];
-export declare type PartialHDPathTuple4 = readonly [...PartialHDPathTuple3, BIP32Node];
-export declare type PartialHDPathTuple5 = readonly [...PartialHDPathTuple4, BIP32Node];
-export declare type PartialHDPathTuple6 = readonly [BIP32Node];
-export declare type PartialHDPathTuple7 = readonly [BIP32Node, BIP32Node];
-export declare type PartialHDPathTuple8 = readonly [
+export type PartialHDPathTuple4 = readonly [...PartialHDPathTuple3, BIP32Node];
+export type PartialHDPathTuple5 = readonly [...PartialHDPathTuple4, BIP32Node];
+export type PartialHDPathTuple6 = readonly [BIP32Node];
+export type PartialHDPathTuple7 = readonly [BIP32Node, BIP32Node];
+export type PartialHDPathTuple8 = readonly [
     HardenedBIP32Node,
     BIP32Node,
     BIP32Node
 ];
-export declare type PartialHDPathTuple9 = readonly [HardenedBIP32Node, BIP32Node];
-export declare type PartialHDPathTuple10 = readonly [
+export type PartialHDPathTuple9 = readonly [HardenedBIP32Node, BIP32Node];
+export type PartialHDPathTuple10 = readonly [
     HardenedBIP32Node,
     HardenedBIP32Node,
     BIP32Node
 ];
-export declare type PartialHDPathTuple11 = readonly [
+export type PartialHDPathTuple11 = readonly [
     HardenedBIP32Node,
     HardenedBIP32Node,
     BIP32Node,
     BIP32Node
 ];
-export declare type CoinTypeToAddressTuple = PartialHDPathTuple8;
-export declare type PartialHDPathTuple = PartialHDPathTuple1 | PartialHDPathTuple2 | PartialHDPathTuple3 | PartialHDPathTuple4 | PartialHDPathTuple5 | PartialHDPathTuple6 | PartialHDPathTuple7 | PartialHDPathTuple8 | PartialHDPathTuple9 | PartialHDPathTuple10 | PartialHDPathTuple11;
+export type CoinTypeToAddressTuple = PartialHDPathTuple8;
+export type PartialHDPathTuple = PartialHDPathTuple1 | PartialHDPathTuple2 | PartialHDPathTuple3 | PartialHDPathTuple4 | PartialHDPathTuple5 | PartialHDPathTuple6 | PartialHDPathTuple7 | PartialHDPathTuple8 | PartialHDPathTuple9 | PartialHDPathTuple10 | PartialHDPathTuple11;
 /**
  * Every ordered subset of a full HD path tuple.
  */
-export declare type HDPathTuple = RootedHDPathTuple | PartialHDPathTuple;
-export declare type RootedSLIP10PathTuple = readonly [
+export type HDPathTuple = RootedHDPathTuple | PartialHDPathTuple;
+export type RootedSLIP10PathTuple = readonly [
     BIP39Node,
     ...(BIP32Node[] | SLIP10PathNode[] | CIP3PathNode[])
 ];
-export declare type SLIP10PathTuple = readonly BIP32Node[] | readonly SLIP10PathNode[] | readonly CIP3PathNode[];
-export declare type SLIP10Path = RootedSLIP10PathTuple | SLIP10PathTuple;
-export declare type FullHDPathTuple = RootedHDPathTuple5;
+export type SLIP10PathTuple = readonly BIP32Node[] | readonly SLIP10PathNode[] | readonly CIP3PathNode[];
+export type SLIP10Path = RootedSLIP10PathTuple | SLIP10PathTuple;
+export type FullHDPathTuple = RootedHDPathTuple5;
 //# sourceMappingURL=constants.d.cts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/constants.d.cts.map b/node_modules/@metamask/key-tree/dist/constants.d.cts.map
index 44cd84e..7f27204 100644
--- a/node_modules/@metamask/key-tree/dist/constants.d.cts.map
+++ b/node_modules/@metamask/key-tree/dist/constants.d.cts.map
@@ -1 +1 @@
-{"version":3,"file":"constants.d.cts","sourceRoot":"","sources":["../src/constants.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"constants.d.cts","sourceRoot":"","sources":["../src/constants.ts"],"names":[],"mappings":"AAAA,eAAO,MAAM,gBAAgB,KAAK,CAAC;AAEnC,eAAO,MAAM,gBAAgB,IAAI,CAAC;AAClC,eAAO,MAAM,gBAAgB,IAAI,CAAC;AAElC,eAAO,MAAM,2BAA2B,aAAa,CAAC;AACtD,eAAO,MAAM,gBAAgB,aAAa,CAAC;AAE3C,MAAM,MAAM,aAAa,GAAG,OAAO,gBAAgB,CAAC;AACpD,MAAM,MAAM,aAAa,GAAG,OAAO,gBAAgB,CAAC;AACpD,MAAM,MAAM,UAAU,GAAG,aAAa,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,aAAa,CAAC;AAYvE,MAAM,MAAM,cAAc,GAAG,GAAG,MAAM,GAAG,CAAC;AAE1C,MAAM,MAAM,mBAAmB,GAAG,GAAG,CAAC;AACtC,MAAM,MAAM,eAAe,GAAG,SAAS,MAAM,EAAE,CAAC;AAChD,MAAM,MAAM,SAAS,GAAG,eAAe,GAAG,UAAU,CAAC;AAErD,MAAM,MAAM,iBAAiB,GAAG,SAAS,MAAM,GAAG,CAAC;AACnD,MAAM,MAAM,mBAAmB,GAAG,SAAS,MAAM,EAAE,CAAC;AACpD,MAAM,MAAM,SAAS,GAAG,iBAAiB,GAAG,mBAAmB,CAAC;AAEhE,MAAM,MAAM,kBAAkB,GAAG,UAAU,MAAM,GAAG,CAAC;AACrD,MAAM,MAAM,oBAAoB,GAAG,UAAU,MAAM,EAAE,CAAC;AACtD,MAAM,MAAM,cAAc,GAAG,kBAAkB,GAAG,oBAAoB,CAAC;AAEvE,MAAM,MAAM,gBAAgB,GAAG,QAAQ,MAAM,GAAG,CAAC;AACjD,MAAM,MAAM,kBAAkB,GAAG,QAAQ,MAAM,EAAE,CAAC;AAClD,MAAM,MAAM,YAAY,GAAG,gBAAgB,GAAG,kBAAkB,CAAC;AAEjE,eAAO,MAAM,qBAAqB,cAAc,CAAC;AAEjD,eAAO,MAAM,qBAAqB,QAAW,CAAC;AAE9C;;;;GAIG;AACH,eAAO,MAAM,4BAA4B,QAAuB,CAAC;AAEjE;;;;GAIG;AACH,eAAO,MAAM,iBAAiB,QAAmB,CAAC;AAElD;;;;GAIG;AACH,eAAO,MAAM,kBAAkB,QAAoB,CAAC;AAEpD;;;;GAIG;AACH,eAAO,MAAM,gBAAgB,QAAkB,CAAC;AAEhD;;;;GAIG;AACH,eAAO,MAAM,iBAAiB,QAAyC,CAAC;AAExE,eAAO,MAAM,sBAAsB,aAAa,CAAC;AAEjD,MAAM,MAAM,aAAa,GAAG,mBAAmB,CAAC;AAChD,MAAM,MAAM,aAAa,GAAG,GAAG,aAAa,MAAM,iBAAiB,EAAE,CAAC;AACtE,MAAM,MAAM,aAAa,GAAG,GAAG,aAAa,MAAM,iBAAiB,EAAE,CAAC;AACtE,MAAM,MAAM,aAAa,GAAG,GAAG,aAAa,MAAM,iBAAiB,EAAE,CAAC;AACtE,MAAM,MAAM,aAAa,GAAG,GAAG,aAAa,MAAM,SAAS,EAAE,CAAC;AAC9D,MAAM,MAAM,aAAa,GAAG,GAAG,aAAa,MAAM,SAAS,EAAE,CAAC;AAE9D,MAAM,MAAM,oBAAoB,GAAG,aAAa,CAAC;AACjD,MAAM,MAAM,kBAAkB,GAAG,aAAa,CAAC;AAC/C,MAAM,MAAM,mBAAmB,GAAG,aAAa,CAAC;AAEhD,MAAM,MAAM,YAAY,GACpB,aAAa,GACb,aAAa,GACb,aAAa,GACb,aAAa,GACb,aAAa,GACb,aAAa,CAAC;AAElB,MAAM,MAAM,kBAAkB,GAAG,SAAS,CAAC,SAAS,CAAC,CAAC;AACtD,MAAM,MAAM,kBAAkB,GAAG,SAAS;IACxC,GAAG,kBAAkB;IACrB,iBAAiB;CAClB,CAAC;AACF,MAAM,MAAM,kBAAkB,GAAG,SAAS;IACxC,GAAG,kBAAkB;IACrB,iBAAiB;CAClB,CAAC;AACF,MAAM,MAAM,kBAAkB,GAAG,SAAS;IACxC,GAAG,kBAAkB;IACrB,iBAAiB;CAClB,CAAC;AACF,MAAM,MAAM,kBAAkB,GAAG,SAAS,CAAC,GAAG,kBAAkB,EAAE,SAAS,CAAC,CAAC;AAC7E,MAAM,MAAM,kBAAkB,GAAG,SAAS,CAAC,GAAG,kBAAkB,EAAE,SAAS,CAAC,CAAC;AAE7E,MAAM,MAAM,iBAAiB,GACzB,kBAAkB,GAClB,kBAAkB,GAClB,kBAAkB,GAClB,kBAAkB,GAClB,kBAAkB,GAClB,kBAAkB,CAAC;AAEvB,MAAM,MAAM,mBAAmB,GAAG,SAAS,CAAC,iBAAiB,CAAC,CAAC;AAC/D,MAAM,MAAM,mBAAmB,GAAG,SAAS;IACzC,GAAG,mBAAmB;IACtB,iBAAiB;CAClB,CAAC;AACF,MAAM,MAAM,mBAAmB,GAAG,SAAS;IACzC,GAAG,mBAAmB;IACtB,iBAAiB;CAClB,CAAC;AACF,MAAM,MAAM,mBAAmB,GAAG,SAAS,CAAC,GAAG,mBAAmB,EAAE,SAAS,CAAC,CAAC;AAC/E,MAAM,MAAM,mBAAmB,GAAG,SAAS,CAAC,GAAG,mBAAmB,EAAE,SAAS,CAAC,CAAC;AAC/E,MAAM,MAAM,mBAAmB,GAAG,SAAS,CAAC,SAAS,CAAC,CAAC;AACvD,MAAM,MAAM,mBAAmB,GAAG,SAAS,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC;AAClE,MAAM,MAAM,mBAAmB,GAAG,SAAS;IACzC,iBAAiB;IACjB,SAAS;IACT,SAAS;CACV,CAAC;AACF,MAAM,MAAM,mBAAmB,GAAG,SAAS,CAAC,iBAAiB,EAAE,SAAS,CAAC,CAAC;AAC1E,MAAM,MAAM,oBAAoB,GAAG,SAAS;IAC1C,iBAAiB;IACjB,iBAAiB;IACjB,SAAS;CACV,CAAC;AACF,MAAM,MAAM,oBAAoB,GAAG,SAAS;IAC1C,iBAAiB;IACjB,iBAAiB;IACjB,SAAS;IACT,SAAS;CACV,CAAC;AAEF,MAAM,MAAM,sBAAsB,GAAG,mBAAmB,CAAC;AAEzD,MAAM,MAAM,kBAAkB,GAC1B,mBAAmB,GACnB,mBAAmB,GACnB,mBAAmB,GACnB,mBAAmB,GACnB,mBAAmB,GACnB,mBAAmB,GACnB,mBAAmB,GACnB,mBAAmB,GACnB,mBAAmB,GACnB,oBAAoB,GACpB,oBAAoB,CAAC;AAEzB;;GAEG;AACH,MAAM,MAAM,WAAW,GAAG,iBAAiB,GAAG,kBAAkB,CAAC;AAEjE,MAAM,MAAM,qBAAqB,GAAG,SAAS;IAC3C,SAAS;IACT,GAAG,CAAC,SAAS,EAAE,GAAG,cAAc,EAAE,GAAG,YAAY,EAAE,CAAC;CACrD,CAAC;AAEF,MAAM,MAAM,eAAe,GACvB,SAAS,SAAS,EAAE,GACpB,SAAS,cAAc,EAAE,GACzB,SAAS,YAAY,EAAE,CAAC;AAC5B,MAAM,MAAM,UAAU,GAAG,qBAAqB,GAAG,eAAe,CAAC;AAEjE,MAAM,MAAM,eAAe,GAAG,kBAAkB,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/constants.d.mts b/node_modules/@metamask/key-tree/dist/constants.d.mts
index 820b54d..0db21c4 100644
--- a/node_modules/@metamask/key-tree/dist/constants.d.mts
+++ b/node_modules/@metamask/key-tree/dist/constants.d.mts
@@ -3,22 +3,22 @@ export declare const MIN_BIP_44_DEPTH = 0;
 export declare const MAX_BIP_44_DEPTH = 5;
 export declare const MAX_UNHARDENED_BIP_32_INDEX = 2147483647;
 export declare const MAX_BIP_32_INDEX = 4294967295;
-export declare type MinBIP44Depth = typeof MIN_BIP_44_DEPTH;
-export declare type MaxBIP44Depth = typeof MAX_BIP_44_DEPTH;
-export declare type BIP44Depth = MinBIP44Depth | 1 | 2 | 3 | 4 | MaxBIP44Depth;
-export declare type UnprefixedNode = `${number}'`;
-export declare type AnonymizedBIP39Node = 'm';
-export declare type BIP39StringNode = `bip39:${string}`;
-export declare type BIP39Node = BIP39StringNode | Uint8Array;
-export declare type HardenedBIP32Node = `bip32:${number}'`;
-export declare type UnhardenedBIP32Node = `bip32:${number}`;
-export declare type BIP32Node = HardenedBIP32Node | UnhardenedBIP32Node;
-export declare type HardenedSLIP10Node = `slip10:${number}'`;
-export declare type UnhardenedSLIP10Node = `slip10:${number}`;
-export declare type SLIP10PathNode = HardenedSLIP10Node | UnhardenedSLIP10Node;
-export declare type HardenedCIP3Node = `cip3:${number}'`;
-export declare type UnhardenedCIP3Node = `cip3:${number}`;
-export declare type CIP3PathNode = HardenedCIP3Node | UnhardenedCIP3Node;
+export type MinBIP44Depth = typeof MIN_BIP_44_DEPTH;
+export type MaxBIP44Depth = typeof MAX_BIP_44_DEPTH;
+export type BIP44Depth = MinBIP44Depth | 1 | 2 | 3 | 4 | MaxBIP44Depth;
+export type UnprefixedNode = `${number}'`;
+export type AnonymizedBIP39Node = 'm';
+export type BIP39StringNode = `bip39:${string}`;
+export type BIP39Node = BIP39StringNode | Uint8Array;
+export type HardenedBIP32Node = `bip32:${number}'`;
+export type UnhardenedBIP32Node = `bip32:${number}`;
+export type BIP32Node = HardenedBIP32Node | UnhardenedBIP32Node;
+export type HardenedSLIP10Node = `slip10:${number}'`;
+export type UnhardenedSLIP10Node = `slip10:${number}`;
+export type SLIP10PathNode = HardenedSLIP10Node | UnhardenedSLIP10Node;
+export type HardenedCIP3Node = `cip3:${number}'`;
+export type UnhardenedCIP3Node = `cip3:${number}`;
+export type CIP3PathNode = HardenedCIP3Node | UnhardenedCIP3Node;
 export declare const BIP44PurposeNodeToken = "bip32:44'";
 export declare const UNPREFIXED_PATH_REGEX: RegExp;
 /**
@@ -52,73 +52,73 @@ export declare const CIP_3_PATH_REGEX: RegExp;
  */
 export declare const BIP_39_PATH_REGEX: RegExp;
 export declare const BIP_32_HARDENED_OFFSET = 2147483648;
-export declare type HDPathString0 = AnonymizedBIP39Node;
-export declare type HDPathString1 = `${HDPathString0} / ${HardenedBIP32Node}`;
-export declare type HDPathString2 = `${HDPathString1} / ${HardenedBIP32Node}`;
-export declare type HDPathString3 = `${HDPathString2} / ${HardenedBIP32Node}`;
-export declare type HDPathString4 = `${HDPathString3} / ${BIP32Node}`;
-export declare type HDPathString5 = `${HDPathString4} / ${BIP32Node}`;
-export declare type CoinTypeHDPathString = HDPathString2;
-export declare type ChangeHDPathString = HDPathString4;
-export declare type AddressHDPathString = HDPathString5;
-export declare type HDPathString = HDPathString0 | HDPathString1 | HDPathString2 | HDPathString3 | HDPathString4 | HDPathString5;
-export declare type RootedHDPathTuple0 = readonly [BIP39Node];
-export declare type RootedHDPathTuple1 = readonly [
+export type HDPathString0 = AnonymizedBIP39Node;
+export type HDPathString1 = `${HDPathString0} / ${HardenedBIP32Node}`;
+export type HDPathString2 = `${HDPathString1} / ${HardenedBIP32Node}`;
+export type HDPathString3 = `${HDPathString2} / ${HardenedBIP32Node}`;
+export type HDPathString4 = `${HDPathString3} / ${BIP32Node}`;
+export type HDPathString5 = `${HDPathString4} / ${BIP32Node}`;
+export type CoinTypeHDPathString = HDPathString2;
+export type ChangeHDPathString = HDPathString4;
+export type AddressHDPathString = HDPathString5;
+export type HDPathString = HDPathString0 | HDPathString1 | HDPathString2 | HDPathString3 | HDPathString4 | HDPathString5;
+export type RootedHDPathTuple0 = readonly [BIP39Node];
+export type RootedHDPathTuple1 = readonly [
     ...RootedHDPathTuple0,
     HardenedBIP32Node
 ];
-export declare type RootedHDPathTuple2 = readonly [
+export type RootedHDPathTuple2 = readonly [
     ...RootedHDPathTuple1,
     HardenedBIP32Node
 ];
-export declare type RootedHDPathTuple3 = readonly [
+export type RootedHDPathTuple3 = readonly [
     ...RootedHDPathTuple2,
     HardenedBIP32Node
 ];
-export declare type RootedHDPathTuple4 = readonly [...RootedHDPathTuple3, BIP32Node];
-export declare type RootedHDPathTuple5 = readonly [...RootedHDPathTuple4, BIP32Node];
-export declare type RootedHDPathTuple = RootedHDPathTuple0 | RootedHDPathTuple1 | RootedHDPathTuple2 | RootedHDPathTuple3 | RootedHDPathTuple4 | RootedHDPathTuple5;
-export declare type PartialHDPathTuple1 = readonly [HardenedBIP32Node];
-export declare type PartialHDPathTuple2 = readonly [
+export type RootedHDPathTuple4 = readonly [...RootedHDPathTuple3, BIP32Node];
+export type RootedHDPathTuple5 = readonly [...RootedHDPathTuple4, BIP32Node];
+export type RootedHDPathTuple = RootedHDPathTuple0 | RootedHDPathTuple1 | RootedHDPathTuple2 | RootedHDPathTuple3 | RootedHDPathTuple4 | RootedHDPathTuple5;
+export type PartialHDPathTuple1 = readonly [HardenedBIP32Node];
+export type PartialHDPathTuple2 = readonly [
     ...PartialHDPathTuple1,
     HardenedBIP32Node
 ];
-export declare type PartialHDPathTuple3 = readonly [
+export type PartialHDPathTuple3 = readonly [
     ...PartialHDPathTuple2,
     HardenedBIP32Node
 ];
-export declare type PartialHDPathTuple4 = readonly [...PartialHDPathTuple3, BIP32Node];
-export declare type PartialHDPathTuple5 = readonly [...PartialHDPathTuple4, BIP32Node];
-export declare type PartialHDPathTuple6 = readonly [BIP32Node];
-export declare type PartialHDPathTuple7 = readonly [BIP32Node, BIP32Node];
-export declare type PartialHDPathTuple8 = readonly [
+export type PartialHDPathTuple4 = readonly [...PartialHDPathTuple3, BIP32Node];
+export type PartialHDPathTuple5 = readonly [...PartialHDPathTuple4, BIP32Node];
+export type PartialHDPathTuple6 = readonly [BIP32Node];
+export type PartialHDPathTuple7 = readonly [BIP32Node, BIP32Node];
+export type PartialHDPathTuple8 = readonly [
     HardenedBIP32Node,
     BIP32Node,
     BIP32Node
 ];
-export declare type PartialHDPathTuple9 = readonly [HardenedBIP32Node, BIP32Node];
-export declare type PartialHDPathTuple10 = readonly [
+export type PartialHDPathTuple9 = readonly [HardenedBIP32Node, BIP32Node];
+export type PartialHDPathTuple10 = readonly [
     HardenedBIP32Node,
     HardenedBIP32Node,
     BIP32Node
 ];
-export declare type PartialHDPathTuple11 = readonly [
+export type PartialHDPathTuple11 = readonly [
     HardenedBIP32Node,
     HardenedBIP32Node,
     BIP32Node,
     BIP32Node
 ];
-export declare type CoinTypeToAddressTuple = PartialHDPathTuple8;
-export declare type PartialHDPathTuple = PartialHDPathTuple1 | PartialHDPathTuple2 | PartialHDPathTuple3 | PartialHDPathTuple4 | PartialHDPathTuple5 | PartialHDPathTuple6 | PartialHDPathTuple7 | PartialHDPathTuple8 | PartialHDPathTuple9 | PartialHDPathTuple10 | PartialHDPathTuple11;
+export type CoinTypeToAddressTuple = PartialHDPathTuple8;
+export type PartialHDPathTuple = PartialHDPathTuple1 | PartialHDPathTuple2 | PartialHDPathTuple3 | PartialHDPathTuple4 | PartialHDPathTuple5 | PartialHDPathTuple6 | PartialHDPathTuple7 | PartialHDPathTuple8 | PartialHDPathTuple9 | PartialHDPathTuple10 | PartialHDPathTuple11;
 /**
  * Every ordered subset of a full HD path tuple.
  */
-export declare type HDPathTuple = RootedHDPathTuple | PartialHDPathTuple;
-export declare type RootedSLIP10PathTuple = readonly [
+export type HDPathTuple = RootedHDPathTuple | PartialHDPathTuple;
+export type RootedSLIP10PathTuple = readonly [
     BIP39Node,
     ...(BIP32Node[] | SLIP10PathNode[] | CIP3PathNode[])
 ];
-export declare type SLIP10PathTuple = readonly BIP32Node[] | readonly SLIP10PathNode[] | readonly CIP3PathNode[];
-export declare type SLIP10Path = RootedSLIP10PathTuple | SLIP10PathTuple;
-export declare type FullHDPathTuple = RootedHDPathTuple5;
+export type SLIP10PathTuple = readonly BIP32Node[] | readonly SLIP10PathNode[] | readonly CIP3PathNode[];
+export type SLIP10Path = RootedSLIP10PathTuple | SLIP10PathTuple;
+export type FullHDPathTuple = RootedHDPathTuple5;
 //# sourceMappingURL=constants.d.mts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/constants.d.mts.map b/node_modules/@metamask/key-tree/dist/constants.d.mts.map
index 4eadf4c..8b78679 100644
--- a/node_modules/@metamask/key-tree/dist/constants.d.mts.map
+++ b/node_modules/@metamask/key-tree/dist/constants.d.mts.map
@@ -1 +1 @@
-{"version":3,"file":"constants.d.mts","sourceRoot":"","sources":["../src/constants.ts"],"names":[],"mappings":"AAAA,eAAO,MAAM,gBAAgB,KAAK,CAAC;AAEnC,eAAO,MAAM,gBAAgB,IAAI,CAAC;AAClC,eAAO,MAAM,gBAAgB,IAAI,CAAC;AAElC,eAAO,MAAM,2BAA2B,aAAa,CAAC;AACtD,eAAO,MAAM,gBAAgB,aAAa,CAAC;AAE3C,oBAAY,aAAa,GAAG,OAAO,gBAAgB,CAAC;AACpD,oBAAY,aAAa,GAAG,OAAO,gBAAgB,CAAC;AACpD,oBAAY,UAAU,GAAG,aAAa,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,aAAa,CAAC;AAYvE,oBAAY,cAAc,GAAG,GAAG,MAAM,GAAG,CAAC;AAE1C,oBAAY,mBAAmB,GAAG,GAAG,CAAC;AACtC,oBAAY,eAAe,GAAG,SAAS,MAAM,EAAE,CAAC;AAChD,oBAAY,SAAS,GAAG,eAAe,GAAG,UAAU,CAAC;AAErD,oBAAY,iBAAiB,GAAG,SAAS,MAAM,GAAG,CAAC;AACnD,oBAAY,mBAAmB,GAAG,SAAS,MAAM,EAAE,CAAC;AACpD,oBAAY,SAAS,GAAG,iBAAiB,GAAG,mBAAmB,CAAC;AAEhE,oBAAY,kBAAkB,GAAG,UAAU,MAAM,GAAG,CAAC;AACrD,oBAAY,oBAAoB,GAAG,UAAU,MAAM,EAAE,CAAC;AACtD,oBAAY,cAAc,GAAG,kBAAkB,GAAG,oBAAoB,CAAC;AAEvE,oBAAY,gBAAgB,GAAG,QAAQ,MAAM,GAAG,CAAC;AACjD,oBAAY,kBAAkB,GAAG,QAAQ,MAAM,EAAE,CAAC;AAClD,oBAAY,YAAY,GAAG,gBAAgB,GAAG,kBAAkB,CAAC;AAEjE,eAAO,MAAM,qBAAqB,cAAc,CAAC;AAEjD,eAAO,MAAM,qBAAqB,QAAW,CAAC;AAE9C;;;;GAIG;AACH,eAAO,MAAM,4BAA4B,QAAuB,CAAC;AAEjE;;;;GAIG;AACH,eAAO,MAAM,iBAAiB,QAAmB,CAAC;AAElD;;;;GAIG;AACH,eAAO,MAAM,kBAAkB,QAAoB,CAAC;AAEpD;;;;GAIG;AACH,eAAO,MAAM,gBAAgB,QAAkB,CAAC;AAEhD;;;;GAIG;AACH,eAAO,MAAM,iBAAiB,QAAyC,CAAC;AAExE,eAAO,MAAM,sBAAsB,aAAa,CAAC;AAEjD,oBAAY,aAAa,GAAG,mBAAmB,CAAC;AAChD,oBAAY,aAAa,GAAG,GAAG,aAAa,MAAM,iBAAiB,EAAE,CAAC;AACtE,oBAAY,aAAa,GAAG,GAAG,aAAa,MAAM,iBAAiB,EAAE,CAAC;AACtE,oBAAY,aAAa,GAAG,GAAG,aAAa,MAAM,iBAAiB,EAAE,CAAC;AACtE,oBAAY,aAAa,GAAG,GAAG,aAAa,MAAM,SAAS,EAAE,CAAC;AAC9D,oBAAY,aAAa,GAAG,GAAG,aAAa,MAAM,SAAS,EAAE,CAAC;AAE9D,oBAAY,oBAAoB,GAAG,aAAa,CAAC;AACjD,oBAAY,kBAAkB,GAAG,aAAa,CAAC;AAC/C,oBAAY,mBAAmB,GAAG,aAAa,CAAC;AAEhD,oBAAY,YAAY,GACpB,aAAa,GACb,aAAa,GACb,aAAa,GACb,aAAa,GACb,aAAa,GACb,aAAa,CAAC;AAElB,oBAAY,kBAAkB,GAAG,SAAS,CAAC,SAAS,CAAC,CAAC;AACtD,oBAAY,kBAAkB,GAAG,SAAS;IACxC,GAAG,kBAAkB;IACrB,iBAAiB;CAClB,CAAC;AACF,oBAAY,kBAAkB,GAAG,SAAS;IACxC,GAAG,kBAAkB;IACrB,iBAAiB;CAClB,CAAC;AACF,oBAAY,kBAAkB,GAAG,SAAS;IACxC,GAAG,kBAAkB;IACrB,iBAAiB;CAClB,CAAC;AACF,oBAAY,kBAAkB,GAAG,SAAS,CAAC,GAAG,kBAAkB,EAAE,SAAS,CAAC,CAAC;AAC7E,oBAAY,kBAAkB,GAAG,SAAS,CAAC,GAAG,kBAAkB,EAAE,SAAS,CAAC,CAAC;AAE7E,oBAAY,iBAAiB,GACzB,kBAAkB,GAClB,kBAAkB,GAClB,kBAAkB,GAClB,kBAAkB,GAClB,kBAAkB,GAClB,kBAAkB,CAAC;AAEvB,oBAAY,mBAAmB,GAAG,SAAS,CAAC,iBAAiB,CAAC,CAAC;AAC/D,oBAAY,mBAAmB,GAAG,SAAS;IACzC,GAAG,mBAAmB;IACtB,iBAAiB;CAClB,CAAC;AACF,oBAAY,mBAAmB,GAAG,SAAS;IACzC,GAAG,mBAAmB;IACtB,iBAAiB;CAClB,CAAC;AACF,oBAAY,mBAAmB,GAAG,SAAS,CAAC,GAAG,mBAAmB,EAAE,SAAS,CAAC,CAAC;AAC/E,oBAAY,mBAAmB,GAAG,SAAS,CAAC,GAAG,mBAAmB,EAAE,SAAS,CAAC,CAAC;AAC/E,oBAAY,mBAAmB,GAAG,SAAS,CAAC,SAAS,CAAC,CAAC;AACvD,oBAAY,mBAAmB,GAAG,SAAS,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC;AAClE,oBAAY,mBAAmB,GAAG,SAAS;IACzC,iBAAiB;IACjB,SAAS;IACT,SAAS;CACV,CAAC;AACF,oBAAY,mBAAmB,GAAG,SAAS,CAAC,iBAAiB,EAAE,SAAS,CAAC,CAAC;AAC1E,oBAAY,oBAAoB,GAAG,SAAS;IAC1C,iBAAiB;IACjB,iBAAiB;IACjB,SAAS;CACV,CAAC;AACF,oBAAY,oBAAoB,GAAG,SAAS;IAC1C,iBAAiB;IACjB,iBAAiB;IACjB,SAAS;IACT,SAAS;CACV,CAAC;AAEF,oBAAY,sBAAsB,GAAG,mBAAmB,CAAC;AAEzD,oBAAY,kBAAkB,GAC1B,mBAAmB,GACnB,mBAAmB,GACnB,mBAAmB,GACnB,mBAAmB,GACnB,mBAAmB,GACnB,mBAAmB,GACnB,mBAAmB,GACnB,mBAAmB,GACnB,mBAAmB,GACnB,oBAAoB,GACpB,oBAAoB,CAAC;AAEzB;;GAEG;AACH,oBAAY,WAAW,GAAG,iBAAiB,GAAG,kBAAkB,CAAC;AAEjE,oBAAY,qBAAqB,GAAG,SAAS;IAC3C,SAAS;IACT,GAAG,CAAC,SAAS,EAAE,GAAG,cAAc,EAAE,GAAG,YAAY,EAAE,CAAC;CACrD,CAAC;AAEF,oBAAY,eAAe,GACvB,SAAS,SAAS,EAAE,GACpB,SAAS,cAAc,EAAE,GACzB,SAAS,YAAY,EAAE,CAAC;AAC5B,oBAAY,UAAU,GAAG,qBAAqB,GAAG,eAAe,CAAC;AAEjE,oBAAY,eAAe,GAAG,kBAAkB,CAAC"}
\ No newline at end of file
+{"version":3,"file":"constants.d.mts","sourceRoot":"","sources":["../src/constants.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/cryptography.cjs b/node_modules/@metamask/key-tree/dist/cryptography.cjs
new file mode 100644
index 0000000..2677e5b
--- /dev/null
+++ b/node_modules/@metamask/key-tree/dist/cryptography.cjs
@@ -0,0 +1,116 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.sha256 = exports.ripemd160 = exports.pbkdf2Sha512 = exports.keccak256 = exports.hmacSha512 = void 0;
+const hmac_1 = require("@noble/hashes/hmac");
+const pbkdf2_1 = require("@noble/hashes/pbkdf2");
+const ripemd160_1 = require("@noble/hashes/ripemd160");
+const sha256_1 = require("@noble/hashes/sha256");
+const sha3_1 = require("@noble/hashes/sha3");
+const sha512_1 = require("@noble/hashes/sha512");
+const utils_1 = require("./utils.cjs");
+/**
+ * Compute the HMAC-SHA-512 of the given data using the given key.
+ *
+ * This function uses the Web Crypto API if available, falling back to a
+ * JavaScript implementation if not.
+ *
+ * @param key - The key to use.
+ * @param data - The data to hash.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
+ * @returns The HMAC-SHA-512 of the data.
+ */
+async function hmacSha512(key, data, cryptographicFunctions = {}) {
+    if (cryptographicFunctions.hmacSha512) {
+        return await cryptographicFunctions.hmacSha512(key, data);
+    }
+    if ((0, utils_1.isWebCryptoSupported)()) {
+        /* eslint-disable no-restricted-globals */
+        const subtleKey = await crypto.subtle.importKey('raw', key, { name: 'HMAC', hash: 'SHA-512' }, false, ['sign']);
+        const result = await crypto.subtle.sign('HMAC', subtleKey, data);
+        return new Uint8Array(result);
+        /* eslint-enable no-restricted-globals */
+    }
+    return (0, hmac_1.hmac)(sha512_1.sha512, key, data);
+}
+exports.hmacSha512 = hmacSha512;
+/**
+ * Compute the Keccak-256 of the given data synchronously.
+ *
+ * Right now this is just a wrapper around `keccak256` from the `@noble/hashes`
+ * package, but it's here in case we want to change the implementation in the
+ * future to allow for asynchronous hashing.
+ *
+ * @param data - The data to hash.
+ * @returns The Keccak-256 of the data.
+ */
+function keccak256(data) {
+    return (0, sha3_1.keccak_256)(data);
+}
+exports.keccak256 = keccak256;
+/**
+ * Compute the PBKDF2 of the given password, salt, iterations, and key length.
+ * The hash function used is SHA-512.
+ *
+ * @param password - The password to hash.
+ * @param salt - The salt to use.
+ * @param iterations - The number of iterations.
+ * @param keyLength - The desired key length.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
+ * @returns The PBKDF2 of the password.
+ */
+async function pbkdf2Sha512(password, salt, iterations, keyLength, cryptographicFunctions = {}) {
+    if (cryptographicFunctions.pbkdf2Sha512) {
+        return await cryptographicFunctions.pbkdf2Sha512(password, salt, iterations, keyLength);
+    }
+    if ((0, utils_1.isWebCryptoSupported)()) {
+        /* eslint-disable no-restricted-globals */
+        const key = await crypto.subtle.importKey('raw', password, { name: 'PBKDF2' }, false, ['deriveBits']);
+        const derivedBits = await crypto.subtle.deriveBits({
+            name: 'PBKDF2',
+            salt,
+            iterations,
+            hash: { name: 'SHA-512' },
+        }, key, 
+        // `keyLength` is the number of bytes, but `deriveBits` expects the
+        // number of bits, so we multiply by 8.
+        keyLength * 8);
+        return new Uint8Array(derivedBits);
+        /* eslint-enable no-restricted-globals */
+    }
+    return await (0, pbkdf2_1.pbkdf2Async)(sha512_1.sha512, password, salt, {
+        c: iterations,
+        dkLen: keyLength,
+    });
+}
+exports.pbkdf2Sha512 = pbkdf2Sha512;
+/**
+ * Compute the RIPEMD-160 of the given data.
+ *
+ * Right now this is just a wrapper around `ripemd160` from the `@noble/hashes`
+ * package, but it's here in case we want to change the implementation in the
+ * future to allow for asynchronous hashing.
+ *
+ * @param data - The data to hash.
+ * @returns The RIPEMD-160 of the data.
+ */
+function ripemd160(data) {
+    return (0, ripemd160_1.ripemd160)(data);
+}
+exports.ripemd160 = ripemd160;
+/**
+ * Compute the SHA-256 of the given data synchronously.
+ *
+ * Right now this is just a wrapper around `sha256` from the `@noble/hashes`
+ * package, but it's here in case we want to change the implementation in the
+ * future to allow for asynchronous hashing.
+ *
+ * @param data - The data to hash.
+ * @returns The SHA-256 of the data.
+ */
+function sha256(data) {
+    return (0, sha256_1.sha256)(data);
+}
+exports.sha256 = sha256;
+//# sourceMappingURL=cryptography.cjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/cryptography.cjs.map b/node_modules/@metamask/key-tree/dist/cryptography.cjs.map
new file mode 100644
index 0000000..1800cdf
--- /dev/null
+++ b/node_modules/@metamask/key-tree/dist/cryptography.cjs.map
@@ -0,0 +1 @@
+{"version":3,"file":"cryptography.cjs","sourceRoot":"","sources":["../src/cryptography.ts"],"names":[],"mappings":";;;AAAA,6CAAuD;AACvD,iDAAkE;AAClE,uDAAsE;AACtE,iDAA6D;AAC7D,6CAAkE;AAClE,iDAA6D;AAE7D,uCAA+C;AA8B/C;;;;;;;;;;;GAWG;AACI,KAAK,UAAU,UAAU,CAC9B,GAAe,EACf,IAAgB,EAChB,yBAAiD,EAAE;IAEnD,IAAI,sBAAsB,CAAC,UAAU,EAAE,CAAC;QACtC,OAAO,MAAM,sBAAsB,CAAC,UAAU,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;IAC5D,CAAC;IAED,IAAI,IAAA,4BAAoB,GAAE,EAAE,CAAC;QAC3B,0CAA0C;QAC1C,MAAM,SAAS,GAAG,MAAM,MAAM,CAAC,MAAM,CAAC,SAAS,CAC7C,KAAK,EACL,GAAG,EACH,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,SAAS,EAAE,EACjC,KAAK,EACL,CAAC,MAAM,CAAC,CACT,CAAC;QAEF,MAAM,MAAM,GAAG,MAAM,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,EAAE,SAAS,EAAE,IAAI,CAAC,CAAC;QACjE,OAAO,IAAI,UAAU,CAAC,MAAM,CAAC,CAAC;QAC9B,yCAAyC;IAC3C,CAAC;IAED,OAAO,IAAA,WAAS,EAAC,eAAW,EAAE,GAAG,EAAE,IAAI,CAAC,CAAC;AAC3C,CAAC;AAzBD,gCAyBC;AAED;;;;;;;;;GASG;AACH,SAAgB,SAAS,CAAC,IAAgB;IACxC,OAAO,IAAA,iBAAc,EAAC,IAAI,CAAC,CAAC;AAC9B,CAAC;AAFD,8BAEC;AAED;;;;;;;;;;;GAWG;AACI,KAAK,UAAU,YAAY,CAChC,QAAoB,EACpB,IAAgB,EAChB,UAAkB,EAClB,SAAiB,EACjB,yBAAiD,EAAE;IAEnD,IAAI,sBAAsB,CAAC,YAAY,EAAE,CAAC;QACxC,OAAO,MAAM,sBAAsB,CAAC,YAAY,CAC9C,QAAQ,EACR,IAAI,EACJ,UAAU,EACV,SAAS,CACV,CAAC;IACJ,CAAC;IAED,IAAI,IAAA,4BAAoB,GAAE,EAAE,CAAC;QAC3B,0CAA0C;QAC1C,MAAM,GAAG,GAAG,MAAM,MAAM,CAAC,MAAM,CAAC,SAAS,CACvC,KAAK,EACL,QAAQ,EACR,EAAE,IAAI,EAAE,QAAQ,EAAE,EAClB,KAAK,EACL,CAAC,YAAY,CAAC,CACf,CAAC;QAEF,MAAM,WAAW,GAAG,MAAM,MAAM,CAAC,MAAM,CAAC,UAAU,CAChD;YACE,IAAI,EAAE,QAAQ;YACd,IAAI;YACJ,UAAU;YACV,IAAI,EAAE,EAAE,IAAI,EAAE,SAAS,EAAE;SAC1B,EACD,GAAG;QACH,mEAAmE;QACnE,uCAAuC;QACvC,SAAS,GAAG,CAAC,CACd,CAAC;QAEF,OAAO,IAAI,UAAU,CAAC,WAAW,CAAC,CAAC;QACnC,yCAAyC;IAC3C,CAAC;IAED,OAAO,MAAM,IAAA,oBAAW,EAAC,eAAW,EAAE,QAAQ,EAAE,IAAI,EAAE;QACpD,CAAC,EAAE,UAAU;QACb,KAAK,EAAE,SAAS;KACjB,CAAC,CAAC;AACL,CAAC;AA/CD,oCA+CC;AAED;;;;;;;;;GASG;AACH,SAAgB,SAAS,CAAC,IAAgB;IACxC,OAAO,IAAA,qBAAc,EAAC,IAAI,CAAC,CAAC;AAC9B,CAAC;AAFD,8BAEC;AAED;;;;;;;;;GASG;AACH,SAAgB,MAAM,CAAC,IAAgB;IACrC,OAAO,IAAA,eAAW,EAAC,IAAI,CAAC,CAAC;AAC3B,CAAC;AAFD,wBAEC","sourcesContent":["import { hmac as nobleHmac } from '@noble/hashes/hmac';\nimport { pbkdf2Async as noblePbkdf2 } from '@noble/hashes/pbkdf2';\nimport { ripemd160 as nobleRipemd160 } from '@noble/hashes/ripemd160';\nimport { sha256 as nobleSha256 } from '@noble/hashes/sha256';\nimport { keccak_256 as nobleKeccak256 } from '@noble/hashes/sha3';\nimport { sha512 as nobleSha512 } from '@noble/hashes/sha512';\n\nimport { isWebCryptoSupported } from './utils';\n\nexport type CryptographicFunctions = {\n  /**\n   * Compute the HMAC-SHA-512 of the given data using the given key.\n   *\n   * @param key - The key to use.\n   * @param data - The data to hash.\n   * @returns The HMAC-SHA-512 of the data.\n   */\n  hmacSha512?: (key: Uint8Array, data: Uint8Array) => Promise<Uint8Array>;\n\n  /**\n   * Compute the PBKDF2 of the given password, salt, iterations, and key length.\n   * The hash function used is SHA-512.\n   *\n   * @param password - The password to hash.\n   * @param salt - The salt to use.\n   * @param iterations - The number of iterations.\n   * @param keyLength - The desired key length in bytes.\n   * @returns The PBKDF2 of the password.\n   */\n  pbkdf2Sha512?: (\n    password: Uint8Array,\n    salt: Uint8Array,\n    iterations: number,\n    keyLength: number,\n  ) => Promise<Uint8Array>;\n};\n\n/**\n * Compute the HMAC-SHA-512 of the given data using the given key.\n *\n * This function uses the Web Crypto API if available, falling back to a\n * JavaScript implementation if not.\n *\n * @param key - The key to use.\n * @param data - The data to hash.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The HMAC-SHA-512 of the data.\n */\nexport async function hmacSha512(\n  key: Uint8Array,\n  data: Uint8Array,\n  cryptographicFunctions: CryptographicFunctions = {},\n): Promise<Uint8Array> {\n  if (cryptographicFunctions.hmacSha512) {\n    return await cryptographicFunctions.hmacSha512(key, data);\n  }\n\n  if (isWebCryptoSupported()) {\n    /* eslint-disable no-restricted-globals */\n    const subtleKey = await crypto.subtle.importKey(\n      'raw',\n      key,\n      { name: 'HMAC', hash: 'SHA-512' },\n      false,\n      ['sign'],\n    );\n\n    const result = await crypto.subtle.sign('HMAC', subtleKey, data);\n    return new Uint8Array(result);\n    /* eslint-enable no-restricted-globals */\n  }\n\n  return nobleHmac(nobleSha512, key, data);\n}\n\n/**\n * Compute the Keccak-256 of the given data synchronously.\n *\n * Right now this is just a wrapper around `keccak256` from the `@noble/hashes`\n * package, but it's here in case we want to change the implementation in the\n * future to allow for asynchronous hashing.\n *\n * @param data - The data to hash.\n * @returns The Keccak-256 of the data.\n */\nexport function keccak256(data: Uint8Array): Uint8Array {\n  return nobleKeccak256(data);\n}\n\n/**\n * Compute the PBKDF2 of the given password, salt, iterations, and key length.\n * The hash function used is SHA-512.\n *\n * @param password - The password to hash.\n * @param salt - The salt to use.\n * @param iterations - The number of iterations.\n * @param keyLength - The desired key length.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The PBKDF2 of the password.\n */\nexport async function pbkdf2Sha512(\n  password: Uint8Array,\n  salt: Uint8Array,\n  iterations: number,\n  keyLength: number,\n  cryptographicFunctions: CryptographicFunctions = {},\n): Promise<Uint8Array> {\n  if (cryptographicFunctions.pbkdf2Sha512) {\n    return await cryptographicFunctions.pbkdf2Sha512(\n      password,\n      salt,\n      iterations,\n      keyLength,\n    );\n  }\n\n  if (isWebCryptoSupported()) {\n    /* eslint-disable no-restricted-globals */\n    const key = await crypto.subtle.importKey(\n      'raw',\n      password,\n      { name: 'PBKDF2' },\n      false,\n      ['deriveBits'],\n    );\n\n    const derivedBits = await crypto.subtle.deriveBits(\n      {\n        name: 'PBKDF2',\n        salt,\n        iterations,\n        hash: { name: 'SHA-512' },\n      },\n      key,\n      // `keyLength` is the number of bytes, but `deriveBits` expects the\n      // number of bits, so we multiply by 8.\n      keyLength * 8,\n    );\n\n    return new Uint8Array(derivedBits);\n    /* eslint-enable no-restricted-globals */\n  }\n\n  return await noblePbkdf2(nobleSha512, password, salt, {\n    c: iterations,\n    dkLen: keyLength,\n  });\n}\n\n/**\n * Compute the RIPEMD-160 of the given data.\n *\n * Right now this is just a wrapper around `ripemd160` from the `@noble/hashes`\n * package, but it's here in case we want to change the implementation in the\n * future to allow for asynchronous hashing.\n *\n * @param data - The data to hash.\n * @returns The RIPEMD-160 of the data.\n */\nexport function ripemd160(data: Uint8Array): Uint8Array {\n  return nobleRipemd160(data);\n}\n\n/**\n * Compute the SHA-256 of the given data synchronously.\n *\n * Right now this is just a wrapper around `sha256` from the `@noble/hashes`\n * package, but it's here in case we want to change the implementation in the\n * future to allow for asynchronous hashing.\n *\n * @param data - The data to hash.\n * @returns The SHA-256 of the data.\n */\nexport function sha256(data: Uint8Array): Uint8Array {\n  return nobleSha256(data);\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/cryptography.d.cts b/node_modules/@metamask/key-tree/dist/cryptography.d.cts
new file mode 100644
index 0000000..67ecafd
--- /dev/null
+++ b/node_modules/@metamask/key-tree/dist/cryptography.d.cts
@@ -0,0 +1,81 @@
+export type CryptographicFunctions = {
+    /**
+     * Compute the HMAC-SHA-512 of the given data using the given key.
+     *
+     * @param key - The key to use.
+     * @param data - The data to hash.
+     * @returns The HMAC-SHA-512 of the data.
+     */
+    hmacSha512?: (key: Uint8Array, data: Uint8Array) => Promise<Uint8Array>;
+    /**
+     * Compute the PBKDF2 of the given password, salt, iterations, and key length.
+     * The hash function used is SHA-512.
+     *
+     * @param password - The password to hash.
+     * @param salt - The salt to use.
+     * @param iterations - The number of iterations.
+     * @param keyLength - The desired key length in bytes.
+     * @returns The PBKDF2 of the password.
+     */
+    pbkdf2Sha512?: (password: Uint8Array, salt: Uint8Array, iterations: number, keyLength: number) => Promise<Uint8Array>;
+};
+/**
+ * Compute the HMAC-SHA-512 of the given data using the given key.
+ *
+ * This function uses the Web Crypto API if available, falling back to a
+ * JavaScript implementation if not.
+ *
+ * @param key - The key to use.
+ * @param data - The data to hash.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
+ * @returns The HMAC-SHA-512 of the data.
+ */
+export declare function hmacSha512(key: Uint8Array, data: Uint8Array, cryptographicFunctions?: CryptographicFunctions): Promise<Uint8Array>;
+/**
+ * Compute the Keccak-256 of the given data synchronously.
+ *
+ * Right now this is just a wrapper around `keccak256` from the `@noble/hashes`
+ * package, but it's here in case we want to change the implementation in the
+ * future to allow for asynchronous hashing.
+ *
+ * @param data - The data to hash.
+ * @returns The Keccak-256 of the data.
+ */
+export declare function keccak256(data: Uint8Array): Uint8Array;
+/**
+ * Compute the PBKDF2 of the given password, salt, iterations, and key length.
+ * The hash function used is SHA-512.
+ *
+ * @param password - The password to hash.
+ * @param salt - The salt to use.
+ * @param iterations - The number of iterations.
+ * @param keyLength - The desired key length.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
+ * @returns The PBKDF2 of the password.
+ */
+export declare function pbkdf2Sha512(password: Uint8Array, salt: Uint8Array, iterations: number, keyLength: number, cryptographicFunctions?: CryptographicFunctions): Promise<Uint8Array>;
+/**
+ * Compute the RIPEMD-160 of the given data.
+ *
+ * Right now this is just a wrapper around `ripemd160` from the `@noble/hashes`
+ * package, but it's here in case we want to change the implementation in the
+ * future to allow for asynchronous hashing.
+ *
+ * @param data - The data to hash.
+ * @returns The RIPEMD-160 of the data.
+ */
+export declare function ripemd160(data: Uint8Array): Uint8Array;
+/**
+ * Compute the SHA-256 of the given data synchronously.
+ *
+ * Right now this is just a wrapper around `sha256` from the `@noble/hashes`
+ * package, but it's here in case we want to change the implementation in the
+ * future to allow for asynchronous hashing.
+ *
+ * @param data - The data to hash.
+ * @returns The SHA-256 of the data.
+ */
+export declare function sha256(data: Uint8Array): Uint8Array;
+//# sourceMappingURL=cryptography.d.cts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/cryptography.d.cts.map b/node_modules/@metamask/key-tree/dist/cryptography.d.cts.map
new file mode 100644
index 0000000..850c56b
--- /dev/null
+++ b/node_modules/@metamask/key-tree/dist/cryptography.d.cts.map
@@ -0,0 +1 @@
+{"version":3,"file":"cryptography.d.cts","sourceRoot":"","sources":["../src/cryptography.ts"],"names":[],"mappings":"AASA,MAAM,MAAM,sBAAsB,GAAG;IACnC;;;;;;OAMG;IACH,UAAU,CAAC,EAAE,CAAC,GAAG,EAAE,UAAU,EAAE,IAAI,EAAE,UAAU,KAAK,OAAO,CAAC,UAAU,CAAC,CAAC;IAExE;;;;;;;;;OASG;IACH,YAAY,CAAC,EAAE,CACb,QAAQ,EAAE,UAAU,EACpB,IAAI,EAAE,UAAU,EAChB,UAAU,EAAE,MAAM,EAClB,SAAS,EAAE,MAAM,KACd,OAAO,CAAC,UAAU,CAAC,CAAC;CAC1B,CAAC;AAEF;;;;;;;;;;;GAWG;AACH,wBAAsB,UAAU,CAC9B,GAAG,EAAE,UAAU,EACf,IAAI,EAAE,UAAU,EAChB,sBAAsB,GAAE,sBAA2B,GAClD,OAAO,CAAC,UAAU,CAAC,CAqBrB;AAED;;;;;;;;;GASG;AACH,wBAAgB,SAAS,CAAC,IAAI,EAAE,UAAU,GAAG,UAAU,CAEtD;AAED;;;;;;;;;;;GAWG;AACH,wBAAsB,YAAY,CAChC,QAAQ,EAAE,UAAU,EACpB,IAAI,EAAE,UAAU,EAChB,UAAU,EAAE,MAAM,EAClB,SAAS,EAAE,MAAM,EACjB,sBAAsB,GAAE,sBAA2B,GAClD,OAAO,CAAC,UAAU,CAAC,CAyCrB;AAED;;;;;;;;;GASG;AACH,wBAAgB,SAAS,CAAC,IAAI,EAAE,UAAU,GAAG,UAAU,CAEtD;AAED;;;;;;;;;GASG;AACH,wBAAgB,MAAM,CAAC,IAAI,EAAE,UAAU,GAAG,UAAU,CAEnD"}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/cryptography.d.mts b/node_modules/@metamask/key-tree/dist/cryptography.d.mts
new file mode 100644
index 0000000..3e8ff9e
--- /dev/null
+++ b/node_modules/@metamask/key-tree/dist/cryptography.d.mts
@@ -0,0 +1,81 @@
+export type CryptographicFunctions = {
+    /**
+     * Compute the HMAC-SHA-512 of the given data using the given key.
+     *
+     * @param key - The key to use.
+     * @param data - The data to hash.
+     * @returns The HMAC-SHA-512 of the data.
+     */
+    hmacSha512?: (key: Uint8Array, data: Uint8Array) => Promise<Uint8Array>;
+    /**
+     * Compute the PBKDF2 of the given password, salt, iterations, and key length.
+     * The hash function used is SHA-512.
+     *
+     * @param password - The password to hash.
+     * @param salt - The salt to use.
+     * @param iterations - The number of iterations.
+     * @param keyLength - The desired key length in bytes.
+     * @returns The PBKDF2 of the password.
+     */
+    pbkdf2Sha512?: (password: Uint8Array, salt: Uint8Array, iterations: number, keyLength: number) => Promise<Uint8Array>;
+};
+/**
+ * Compute the HMAC-SHA-512 of the given data using the given key.
+ *
+ * This function uses the Web Crypto API if available, falling back to a
+ * JavaScript implementation if not.
+ *
+ * @param key - The key to use.
+ * @param data - The data to hash.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
+ * @returns The HMAC-SHA-512 of the data.
+ */
+export declare function hmacSha512(key: Uint8Array, data: Uint8Array, cryptographicFunctions?: CryptographicFunctions): Promise<Uint8Array>;
+/**
+ * Compute the Keccak-256 of the given data synchronously.
+ *
+ * Right now this is just a wrapper around `keccak256` from the `@noble/hashes`
+ * package, but it's here in case we want to change the implementation in the
+ * future to allow for asynchronous hashing.
+ *
+ * @param data - The data to hash.
+ * @returns The Keccak-256 of the data.
+ */
+export declare function keccak256(data: Uint8Array): Uint8Array;
+/**
+ * Compute the PBKDF2 of the given password, salt, iterations, and key length.
+ * The hash function used is SHA-512.
+ *
+ * @param password - The password to hash.
+ * @param salt - The salt to use.
+ * @param iterations - The number of iterations.
+ * @param keyLength - The desired key length.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
+ * @returns The PBKDF2 of the password.
+ */
+export declare function pbkdf2Sha512(password: Uint8Array, salt: Uint8Array, iterations: number, keyLength: number, cryptographicFunctions?: CryptographicFunctions): Promise<Uint8Array>;
+/**
+ * Compute the RIPEMD-160 of the given data.
+ *
+ * Right now this is just a wrapper around `ripemd160` from the `@noble/hashes`
+ * package, but it's here in case we want to change the implementation in the
+ * future to allow for asynchronous hashing.
+ *
+ * @param data - The data to hash.
+ * @returns The RIPEMD-160 of the data.
+ */
+export declare function ripemd160(data: Uint8Array): Uint8Array;
+/**
+ * Compute the SHA-256 of the given data synchronously.
+ *
+ * Right now this is just a wrapper around `sha256` from the `@noble/hashes`
+ * package, but it's here in case we want to change the implementation in the
+ * future to allow for asynchronous hashing.
+ *
+ * @param data - The data to hash.
+ * @returns The SHA-256 of the data.
+ */
+export declare function sha256(data: Uint8Array): Uint8Array;
+//# sourceMappingURL=cryptography.d.mts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/cryptography.d.mts.map b/node_modules/@metamask/key-tree/dist/cryptography.d.mts.map
new file mode 100644
index 0000000..dd3a3d0
--- /dev/null
+++ b/node_modules/@metamask/key-tree/dist/cryptography.d.mts.map
@@ -0,0 +1 @@
+{"version":3,"file":"cryptography.d.mts","sourceRoot":"","sources":["../src/cryptography.ts"],"names":[],"mappings":"AASA,MAAM,MAAM,sBAAsB,GAAG;IACnC;;;;;;OAMG;IACH,UAAU,CAAC,EAAE,CAAC,GAAG,EAAE,UAAU,EAAE,IAAI,EAAE,UAAU,KAAK,OAAO,CAAC,UAAU,CAAC,CAAC;IAExE;;;;;;;;;OASG;IACH,YAAY,CAAC,EAAE,CACb,QAAQ,EAAE,UAAU,EACpB,IAAI,EAAE,UAAU,EAChB,UAAU,EAAE,MAAM,EAClB,SAAS,EAAE,MAAM,KACd,OAAO,CAAC,UAAU,CAAC,CAAC;CAC1B,CAAC;AAEF;;;;;;;;;;;GAWG;AACH,wBAAsB,UAAU,CAC9B,GAAG,EAAE,UAAU,EACf,IAAI,EAAE,UAAU,EAChB,sBAAsB,GAAE,sBAA2B,GAClD,OAAO,CAAC,UAAU,CAAC,CAqBrB;AAED;;;;;;;;;GASG;AACH,wBAAgB,SAAS,CAAC,IAAI,EAAE,UAAU,GAAG,UAAU,CAEtD;AAED;;;;;;;;;;;GAWG;AACH,wBAAsB,YAAY,CAChC,QAAQ,EAAE,UAAU,EACpB,IAAI,EAAE,UAAU,EAChB,UAAU,EAAE,MAAM,EAClB,SAAS,EAAE,MAAM,EACjB,sBAAsB,GAAE,sBAA2B,GAClD,OAAO,CAAC,UAAU,CAAC,CAyCrB;AAED;;;;;;;;;GASG;AACH,wBAAgB,SAAS,CAAC,IAAI,EAAE,UAAU,GAAG,UAAU,CAEtD;AAED;;;;;;;;;GASG;AACH,wBAAgB,MAAM,CAAC,IAAI,EAAE,UAAU,GAAG,UAAU,CAEnD"}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/cryptography.mjs b/node_modules/@metamask/key-tree/dist/cryptography.mjs
new file mode 100644
index 0000000..5cf3dd3
--- /dev/null
+++ b/node_modules/@metamask/key-tree/dist/cryptography.mjs
@@ -0,0 +1,108 @@
+import { hmac as nobleHmac } from "@noble/hashes/hmac";
+import { pbkdf2Async as noblePbkdf2 } from "@noble/hashes/pbkdf2";
+import { ripemd160 as nobleRipemd160 } from "@noble/hashes/ripemd160";
+import { sha256 as nobleSha256 } from "@noble/hashes/sha256";
+import { keccak_256 as nobleKeccak256 } from "@noble/hashes/sha3";
+import { sha512 as nobleSha512 } from "@noble/hashes/sha512";
+import { isWebCryptoSupported } from "./utils.mjs";
+/**
+ * Compute the HMAC-SHA-512 of the given data using the given key.
+ *
+ * This function uses the Web Crypto API if available, falling back to a
+ * JavaScript implementation if not.
+ *
+ * @param key - The key to use.
+ * @param data - The data to hash.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
+ * @returns The HMAC-SHA-512 of the data.
+ */
+export async function hmacSha512(key, data, cryptographicFunctions = {}) {
+    if (cryptographicFunctions.hmacSha512) {
+        return await cryptographicFunctions.hmacSha512(key, data);
+    }
+    if (isWebCryptoSupported()) {
+        /* eslint-disable no-restricted-globals */
+        const subtleKey = await crypto.subtle.importKey('raw', key, { name: 'HMAC', hash: 'SHA-512' }, false, ['sign']);
+        const result = await crypto.subtle.sign('HMAC', subtleKey, data);
+        return new Uint8Array(result);
+        /* eslint-enable no-restricted-globals */
+    }
+    return nobleHmac(nobleSha512, key, data);
+}
+/**
+ * Compute the Keccak-256 of the given data synchronously.
+ *
+ * Right now this is just a wrapper around `keccak256` from the `@noble/hashes`
+ * package, but it's here in case we want to change the implementation in the
+ * future to allow for asynchronous hashing.
+ *
+ * @param data - The data to hash.
+ * @returns The Keccak-256 of the data.
+ */
+export function keccak256(data) {
+    return nobleKeccak256(data);
+}
+/**
+ * Compute the PBKDF2 of the given password, salt, iterations, and key length.
+ * The hash function used is SHA-512.
+ *
+ * @param password - The password to hash.
+ * @param salt - The salt to use.
+ * @param iterations - The number of iterations.
+ * @param keyLength - The desired key length.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
+ * @returns The PBKDF2 of the password.
+ */
+export async function pbkdf2Sha512(password, salt, iterations, keyLength, cryptographicFunctions = {}) {
+    if (cryptographicFunctions.pbkdf2Sha512) {
+        return await cryptographicFunctions.pbkdf2Sha512(password, salt, iterations, keyLength);
+    }
+    if (isWebCryptoSupported()) {
+        /* eslint-disable no-restricted-globals */
+        const key = await crypto.subtle.importKey('raw', password, { name: 'PBKDF2' }, false, ['deriveBits']);
+        const derivedBits = await crypto.subtle.deriveBits({
+            name: 'PBKDF2',
+            salt,
+            iterations,
+            hash: { name: 'SHA-512' },
+        }, key, 
+        // `keyLength` is the number of bytes, but `deriveBits` expects the
+        // number of bits, so we multiply by 8.
+        keyLength * 8);
+        return new Uint8Array(derivedBits);
+        /* eslint-enable no-restricted-globals */
+    }
+    return await noblePbkdf2(nobleSha512, password, salt, {
+        c: iterations,
+        dkLen: keyLength,
+    });
+}
+/**
+ * Compute the RIPEMD-160 of the given data.
+ *
+ * Right now this is just a wrapper around `ripemd160` from the `@noble/hashes`
+ * package, but it's here in case we want to change the implementation in the
+ * future to allow for asynchronous hashing.
+ *
+ * @param data - The data to hash.
+ * @returns The RIPEMD-160 of the data.
+ */
+export function ripemd160(data) {
+    return nobleRipemd160(data);
+}
+/**
+ * Compute the SHA-256 of the given data synchronously.
+ *
+ * Right now this is just a wrapper around `sha256` from the `@noble/hashes`
+ * package, but it's here in case we want to change the implementation in the
+ * future to allow for asynchronous hashing.
+ *
+ * @param data - The data to hash.
+ * @returns The SHA-256 of the data.
+ */
+export function sha256(data) {
+    return nobleSha256(data);
+}
+//# sourceMappingURL=cryptography.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/cryptography.mjs.map b/node_modules/@metamask/key-tree/dist/cryptography.mjs.map
new file mode 100644
index 0000000..6875e68
--- /dev/null
+++ b/node_modules/@metamask/key-tree/dist/cryptography.mjs.map
@@ -0,0 +1 @@
+{"version":3,"file":"cryptography.mjs","sourceRoot":"","sources":["../src/cryptography.ts"],"names":[],"mappings":"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","sourcesContent":["import { hmac as nobleHmac } from '@noble/hashes/hmac';\nimport { pbkdf2Async as noblePbkdf2 } from '@noble/hashes/pbkdf2';\nimport { ripemd160 as nobleRipemd160 } from '@noble/hashes/ripemd160';\nimport { sha256 as nobleSha256 } from '@noble/hashes/sha256';\nimport { keccak_256 as nobleKeccak256 } from '@noble/hashes/sha3';\nimport { sha512 as nobleSha512 } from '@noble/hashes/sha512';\n\nimport { isWebCryptoSupported } from './utils';\n\nexport type CryptographicFunctions = {\n  /**\n   * Compute the HMAC-SHA-512 of the given data using the given key.\n   *\n   * @param key - The key to use.\n   * @param data - The data to hash.\n   * @returns The HMAC-SHA-512 of the data.\n   */\n  hmacSha512?: (key: Uint8Array, data: Uint8Array) => Promise<Uint8Array>;\n\n  /**\n   * Compute the PBKDF2 of the given password, salt, iterations, and key length.\n   * The hash function used is SHA-512.\n   *\n   * @param password - The password to hash.\n   * @param salt - The salt to use.\n   * @param iterations - The number of iterations.\n   * @param keyLength - The desired key length in bytes.\n   * @returns The PBKDF2 of the password.\n   */\n  pbkdf2Sha512?: (\n    password: Uint8Array,\n    salt: Uint8Array,\n    iterations: number,\n    keyLength: number,\n  ) => Promise<Uint8Array>;\n};\n\n/**\n * Compute the HMAC-SHA-512 of the given data using the given key.\n *\n * This function uses the Web Crypto API if available, falling back to a\n * JavaScript implementation if not.\n *\n * @param key - The key to use.\n * @param data - The data to hash.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The HMAC-SHA-512 of the data.\n */\nexport async function hmacSha512(\n  key: Uint8Array,\n  data: Uint8Array,\n  cryptographicFunctions: CryptographicFunctions = {},\n): Promise<Uint8Array> {\n  if (cryptographicFunctions.hmacSha512) {\n    return await cryptographicFunctions.hmacSha512(key, data);\n  }\n\n  if (isWebCryptoSupported()) {\n    /* eslint-disable no-restricted-globals */\n    const subtleKey = await crypto.subtle.importKey(\n      'raw',\n      key,\n      { name: 'HMAC', hash: 'SHA-512' },\n      false,\n      ['sign'],\n    );\n\n    const result = await crypto.subtle.sign('HMAC', subtleKey, data);\n    return new Uint8Array(result);\n    /* eslint-enable no-restricted-globals */\n  }\n\n  return nobleHmac(nobleSha512, key, data);\n}\n\n/**\n * Compute the Keccak-256 of the given data synchronously.\n *\n * Right now this is just a wrapper around `keccak256` from the `@noble/hashes`\n * package, but it's here in case we want to change the implementation in the\n * future to allow for asynchronous hashing.\n *\n * @param data - The data to hash.\n * @returns The Keccak-256 of the data.\n */\nexport function keccak256(data: Uint8Array): Uint8Array {\n  return nobleKeccak256(data);\n}\n\n/**\n * Compute the PBKDF2 of the given password, salt, iterations, and key length.\n * The hash function used is SHA-512.\n *\n * @param password - The password to hash.\n * @param salt - The salt to use.\n * @param iterations - The number of iterations.\n * @param keyLength - The desired key length.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The PBKDF2 of the password.\n */\nexport async function pbkdf2Sha512(\n  password: Uint8Array,\n  salt: Uint8Array,\n  iterations: number,\n  keyLength: number,\n  cryptographicFunctions: CryptographicFunctions = {},\n): Promise<Uint8Array> {\n  if (cryptographicFunctions.pbkdf2Sha512) {\n    return await cryptographicFunctions.pbkdf2Sha512(\n      password,\n      salt,\n      iterations,\n      keyLength,\n    );\n  }\n\n  if (isWebCryptoSupported()) {\n    /* eslint-disable no-restricted-globals */\n    const key = await crypto.subtle.importKey(\n      'raw',\n      password,\n      { name: 'PBKDF2' },\n      false,\n      ['deriveBits'],\n    );\n\n    const derivedBits = await crypto.subtle.deriveBits(\n      {\n        name: 'PBKDF2',\n        salt,\n        iterations,\n        hash: { name: 'SHA-512' },\n      },\n      key,\n      // `keyLength` is the number of bytes, but `deriveBits` expects the\n      // number of bits, so we multiply by 8.\n      keyLength * 8,\n    );\n\n    return new Uint8Array(derivedBits);\n    /* eslint-enable no-restricted-globals */\n  }\n\n  return await noblePbkdf2(nobleSha512, password, salt, {\n    c: iterations,\n    dkLen: keyLength,\n  });\n}\n\n/**\n * Compute the RIPEMD-160 of the given data.\n *\n * Right now this is just a wrapper around `ripemd160` from the `@noble/hashes`\n * package, but it's here in case we want to change the implementation in the\n * future to allow for asynchronous hashing.\n *\n * @param data - The data to hash.\n * @returns The RIPEMD-160 of the data.\n */\nexport function ripemd160(data: Uint8Array): Uint8Array {\n  return nobleRipemd160(data);\n}\n\n/**\n * Compute the SHA-256 of the given data synchronously.\n *\n * Right now this is just a wrapper around `sha256` from the `@noble/hashes`\n * package, but it's here in case we want to change the implementation in the\n * future to allow for asynchronous hashing.\n *\n * @param data - The data to hash.\n * @returns The SHA-256 of the data.\n */\nexport function sha256(data: Uint8Array): Uint8Array {\n  return nobleSha256(data);\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/curves/curve.d.cts b/node_modules/@metamask/key-tree/dist/curves/curve.d.cts
index 668483e..c802c1e 100644
--- a/node_modules/@metamask/key-tree/dist/curves/curve.d.cts
+++ b/node_modules/@metamask/key-tree/dist/curves/curve.d.cts
@@ -1,20 +1,20 @@
 import * as ed25519 from "./ed25519.cjs";
 import * as ed25519Bip32 from "./ed25519Bip32.cjs";
 import * as secp256k1 from "./secp256k1.cjs";
-export declare type SupportedCurve = keyof typeof curves;
+export type SupportedCurve = keyof typeof curves;
 export declare const curves: {
     secp256k1: typeof secp256k1;
     ed25519: typeof ed25519;
     ed25519Bip32: typeof ed25519Bip32;
 };
-declare type CurveSpecification = {
+type CurveSpecification = {
     masterNodeGenerationSpec: 'slip10';
     name: Extract<SupportedCurve, 'secp256k1' | 'ed25519'>;
 } | {
     name: Extract<SupportedCurve, 'ed25519Bip32'>;
     masterNodeGenerationSpec: 'cip3';
 };
-export declare type Curve = {
+export type Curve = {
     secret: Uint8Array;
     deriveUnhardenedKeys: boolean;
     publicKeyLength: number;
diff --git a/node_modules/@metamask/key-tree/dist/curves/curve.d.cts.map b/node_modules/@metamask/key-tree/dist/curves/curve.d.cts.map
index d5eb8ed..8bf0fa8 100644
--- a/node_modules/@metamask/key-tree/dist/curves/curve.d.cts.map
+++ b/node_modules/@metamask/key-tree/dist/curves/curve.d.cts.map
@@ -1 +1 @@
-{"version":3,"file":"curve.d.cts","sourceRoot":"","sources":["../../src/curves/curve.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,OAAO,sBAAkB;AACrC,OAAO,KAAK,YAAY,2BAAuB;AAC/C,OAAO,KAAK,SAAS,wBAAoB;AAEzC,oBAAY,cAAc,GAAG,MAAM,OAAO,MAAM,CAAC;AAEjD,eAAO,MAAM,MAAM;;;;CAIlB,CAAC;AAEF,aAAK,kBAAkB,GACnB;IACE,wBAAwB,EAAE,QAAQ,CAAC;IACnC,IAAI,EAAE,OAAO,CAAC,cAAc,EAAE,WAAW,GAAG,SAAS,CAAC,CAAC;CACxD,GACD;IACE,IAAI,EAAE,OAAO,CAAC,cAAc,EAAE,cAAc,CAAC,CAAC;IAC9C,wBAAwB,EAAE,MAAM,CAAC;CAClC,CAAC;AAEN,oBAAY,KAAK,GAAG;IAClB,MAAM,EAAE,UAAU,CAAC;IACnB,oBAAoB,EAAE,OAAO,CAAC;IAC9B,eAAe,EAAE,MAAM,CAAC;IACxB,KAAK,EAAE;QACL,CAAC,EAAE,MAAM,CAAC;KACX,CAAC;IACF,YAAY,EAAE,CACZ,UAAU,EAAE,UAAU,EACtB,UAAU,CAAC,EAAE,OAAO,KACjB,UAAU,GAAG,OAAO,CAAC,UAAU,CAAC,CAAC;IACtC,iBAAiB,EAAE,CAAC,UAAU,EAAE,UAAU,KAAK,OAAO,CAAC;IACvD,SAAS,EAAE,CAAC,SAAS,EAAE,UAAU,EAAE,KAAK,EAAE,UAAU,KAAK,UAAU,CAAC;IACpE,iBAAiB,EAAE,CAAC,SAAS,EAAE,UAAU,KAAK,UAAU,CAAC;IACzD,mBAAmB,EAAE,CAAC,SAAS,EAAE,UAAU,KAAK,UAAU,CAAC;IAC3D,gBAAgB,EAAE,MAAM,CAAC;IACzB,yBAAyB,EAAE,MAAM,CAAC;CACnC,GAAG,kBAAkB,CAAC;AAEvB;;;;;GAKG;AACH,wBAAgB,cAAc,CAAC,SAAS,EAAE,cAAc,GAAG,KAAK,CAE/D;AAED,OAAO,EAAE,GAAG,EAAE,uCAAuC"}
\ No newline at end of file
+{"version":3,"file":"curve.d.cts","sourceRoot":"","sources":["../../src/curves/curve.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,OAAO,sBAAkB;AACrC,OAAO,KAAK,YAAY,2BAAuB;AAC/C,OAAO,KAAK,SAAS,wBAAoB;AAEzC,MAAM,MAAM,cAAc,GAAG,MAAM,OAAO,MAAM,CAAC;AAEjD,eAAO,MAAM,MAAM;;;;CAIlB,CAAC;AAEF,KAAK,kBAAkB,GACnB;IACE,wBAAwB,EAAE,QAAQ,CAAC;IACnC,IAAI,EAAE,OAAO,CAAC,cAAc,EAAE,WAAW,GAAG,SAAS,CAAC,CAAC;CACxD,GACD;IACE,IAAI,EAAE,OAAO,CAAC,cAAc,EAAE,cAAc,CAAC,CAAC;IAC9C,wBAAwB,EAAE,MAAM,CAAC;CAClC,CAAC;AAEN,MAAM,MAAM,KAAK,GAAG;IAClB,MAAM,EAAE,UAAU,CAAC;IACnB,oBAAoB,EAAE,OAAO,CAAC;IAC9B,eAAe,EAAE,MAAM,CAAC;IACxB,KAAK,EAAE;QACL,CAAC,EAAE,MAAM,CAAC;KACX,CAAC;IACF,YAAY,EAAE,CACZ,UAAU,EAAE,UAAU,EACtB,UAAU,CAAC,EAAE,OAAO,KACjB,UAAU,GAAG,OAAO,CAAC,UAAU,CAAC,CAAC;IACtC,iBAAiB,EAAE,CAAC,UAAU,EAAE,UAAU,KAAK,OAAO,CAAC;IACvD,SAAS,EAAE,CAAC,SAAS,EAAE,UAAU,EAAE,KAAK,EAAE,UAAU,KAAK,UAAU,CAAC;IACpE,iBAAiB,EAAE,CAAC,SAAS,EAAE,UAAU,KAAK,UAAU,CAAC;IACzD,mBAAmB,EAAE,CAAC,SAAS,EAAE,UAAU,KAAK,UAAU,CAAC;IAC3D,gBAAgB,EAAE,MAAM,CAAC;IACzB,yBAAyB,EAAE,MAAM,CAAC;CACnC,GAAG,kBAAkB,CAAC;AAEvB;;;;;GAKG;AACH,wBAAgB,cAAc,CAAC,SAAS,EAAE,cAAc,GAAG,KAAK,CAE/D;AAED,OAAO,EAAE,GAAG,EAAE,uCAAuC"}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/curves/curve.d.mts b/node_modules/@metamask/key-tree/dist/curves/curve.d.mts
index 3f64bdc..5a36559 100644
--- a/node_modules/@metamask/key-tree/dist/curves/curve.d.mts
+++ b/node_modules/@metamask/key-tree/dist/curves/curve.d.mts
@@ -1,20 +1,20 @@
 import * as ed25519 from "./ed25519.mjs";
 import * as ed25519Bip32 from "./ed25519Bip32.mjs";
 import * as secp256k1 from "./secp256k1.mjs";
-export declare type SupportedCurve = keyof typeof curves;
+export type SupportedCurve = keyof typeof curves;
 export declare const curves: {
     secp256k1: typeof secp256k1;
     ed25519: typeof ed25519;
     ed25519Bip32: typeof ed25519Bip32;
 };
-declare type CurveSpecification = {
+type CurveSpecification = {
     masterNodeGenerationSpec: 'slip10';
     name: Extract<SupportedCurve, 'secp256k1' | 'ed25519'>;
 } | {
     name: Extract<SupportedCurve, 'ed25519Bip32'>;
     masterNodeGenerationSpec: 'cip3';
 };
-export declare type Curve = {
+export type Curve = {
     secret: Uint8Array;
     deriveUnhardenedKeys: boolean;
     publicKeyLength: number;
diff --git a/node_modules/@metamask/key-tree/dist/curves/curve.d.mts.map b/node_modules/@metamask/key-tree/dist/curves/curve.d.mts.map
index f4bca51..4bfb8bb 100644
--- a/node_modules/@metamask/key-tree/dist/curves/curve.d.mts.map
+++ b/node_modules/@metamask/key-tree/dist/curves/curve.d.mts.map
@@ -1 +1 @@
-{"version":3,"file":"curve.d.mts","sourceRoot":"","sources":["../../src/curves/curve.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,OAAO,sBAAkB;AACrC,OAAO,KAAK,YAAY,2BAAuB;AAC/C,OAAO,KAAK,SAAS,wBAAoB;AAEzC,oBAAY,cAAc,GAAG,MAAM,OAAO,MAAM,CAAC;AAEjD,eAAO,MAAM,MAAM;;;;CAIlB,CAAC;AAEF,aAAK,kBAAkB,GACnB;IACE,wBAAwB,EAAE,QAAQ,CAAC;IACnC,IAAI,EAAE,OAAO,CAAC,cAAc,EAAE,WAAW,GAAG,SAAS,CAAC,CAAC;CACxD,GACD;IACE,IAAI,EAAE,OAAO,CAAC,cAAc,EAAE,cAAc,CAAC,CAAC;IAC9C,wBAAwB,EAAE,MAAM,CAAC;CAClC,CAAC;AAEN,oBAAY,KAAK,GAAG;IAClB,MAAM,EAAE,UAAU,CAAC;IACnB,oBAAoB,EAAE,OAAO,CAAC;IAC9B,eAAe,EAAE,MAAM,CAAC;IACxB,KAAK,EAAE;QACL,CAAC,EAAE,MAAM,CAAC;KACX,CAAC;IACF,YAAY,EAAE,CACZ,UAAU,EAAE,UAAU,EACtB,UAAU,CAAC,EAAE,OAAO,KACjB,UAAU,GAAG,OAAO,CAAC,UAAU,CAAC,CAAC;IACtC,iBAAiB,EAAE,CAAC,UAAU,EAAE,UAAU,KAAK,OAAO,CAAC;IACvD,SAAS,EAAE,CAAC,SAAS,EAAE,UAAU,EAAE,KAAK,EAAE,UAAU,KAAK,UAAU,CAAC;IACpE,iBAAiB,EAAE,CAAC,SAAS,EAAE,UAAU,KAAK,UAAU,CAAC;IACzD,mBAAmB,EAAE,CAAC,SAAS,EAAE,UAAU,KAAK,UAAU,CAAC;IAC3D,gBAAgB,EAAE,MAAM,CAAC;IACzB,yBAAyB,EAAE,MAAM,CAAC;CACnC,GAAG,kBAAkB,CAAC;AAEvB;;;;;GAKG;AACH,wBAAgB,cAAc,CAAC,SAAS,EAAE,cAAc,GAAG,KAAK,CAE/D;AAED,OAAO,EAAE,GAAG,EAAE,uCAAuC"}
\ No newline at end of file
+{"version":3,"file":"curve.d.mts","sourceRoot":"","sources":["../../src/curves/curve.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,OAAO,sBAAkB;AACrC,OAAO,KAAK,YAAY,2BAAuB;AAC/C,OAAO,KAAK,SAAS,wBAAoB;AAEzC,MAAM,MAAM,cAAc,GAAG,MAAM,OAAO,MAAM,CAAC;AAEjD,eAAO,MAAM,MAAM;;;;CAIlB,CAAC;AAEF,KAAK,kBAAkB,GACnB;IACE,wBAAwB,EAAE,QAAQ,CAAC;IACnC,IAAI,EAAE,OAAO,CAAC,cAAc,EAAE,WAAW,GAAG,SAAS,CAAC,CAAC;CACxD,GACD;IACE,IAAI,EAAE,OAAO,CAAC,cAAc,EAAE,cAAc,CAAC,CAAC;IAC9C,wBAAwB,EAAE,MAAM,CAAC;CAClC,CAAC;AAEN,MAAM,MAAM,KAAK,GAAG;IAClB,MAAM,EAAE,UAAU,CAAC;IACnB,oBAAoB,EAAE,OAAO,CAAC;IAC9B,eAAe,EAAE,MAAM,CAAC;IACxB,KAAK,EAAE;QACL,CAAC,EAAE,MAAM,CAAC;KACX,CAAC;IACF,YAAY,EAAE,CACZ,UAAU,EAAE,UAAU,EACtB,UAAU,CAAC,EAAE,OAAO,KACjB,UAAU,GAAG,OAAO,CAAC,UAAU,CAAC,CAAC;IACtC,iBAAiB,EAAE,CAAC,UAAU,EAAE,UAAU,KAAK,OAAO,CAAC;IACvD,SAAS,EAAE,CAAC,SAAS,EAAE,UAAU,EAAE,KAAK,EAAE,UAAU,KAAK,UAAU,CAAC;IACpE,iBAAiB,EAAE,CAAC,SAAS,EAAE,UAAU,KAAK,UAAU,CAAC;IACzD,mBAAmB,EAAE,CAAC,SAAS,EAAE,UAAU,KAAK,UAAU,CAAC;IAC3D,gBAAgB,EAAE,MAAM,CAAC;IACzB,yBAAyB,EAAE,MAAM,CAAC;CACnC,GAAG,kBAAkB,CAAC;AAEvB;;;;;GAKG;AACH,wBAAgB,cAAc,CAAC,SAAS,EAAE,cAAc,GAAG,KAAK,CAE/D;AAED,OAAO,EAAE,GAAG,EAAE,uCAAuC"}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/curves/ed25519.cjs.map b/node_modules/@metamask/key-tree/dist/curves/ed25519.cjs.map
index 89caa27..b5e8976 100644
--- a/node_modules/@metamask/key-tree/dist/curves/ed25519.cjs.map
+++ b/node_modules/@metamask/key-tree/dist/curves/ed25519.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"ed25519.cjs","sourceRoot":"","sources":["../../src/curves/ed25519.ts"],"names":[],"mappings":";;;AAAA,2CAA6D;AAC7D,mDAAgD;AAEnC,QAAA,KAAK,GAAG,iBAAO,CAAC,KAAK,CAAC;AACtB,QAAA,IAAI,GAAG,SAAS,CAAC;AAE9B,gCAAgC;AAChC,wHAAwH;AAC3G,QAAA,MAAM,GAAG,IAAA,qBAAa,EAAC,cAAc,CAAC,CAAC;AAEpD,0CAA0C;AAC1C,wHAAwH;AACjH,MAAM,iBAAiB,GAAG,CAAC,WAAyC,EAAE,EAAE,CAC7E,IAAI,CAAC;AADM,QAAA,iBAAiB,qBACvB;AAEM,QAAA,oBAAoB,GAAG,KAAK,CAAC;AAE7B,QAAA,eAAe,GAAG,EAAE,CAAC;AAE3B,MAAM,YAAY,GAAG,CAC1B,UAAsB,EACtB,WAAqB,EACT,EAAE;IACd,MAAM,SAAS,GAAG,iBAAO,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC;IACnD,OAAO,IAAA,mBAAW,EAAC,CAAC,IAAI,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC,CAAC;AACvD,CAAC,CAAC;AANW,QAAA,YAAY,gBAMvB;AAEK,MAAM,SAAS,GAAG,CACvB,UAAsB,EACtB,MAAkB,EACN,EAAE;IACd,MAAM,IAAI,KAAK,CAAC,iDAAiD,CAAC,CAAC;AACrE,CAAC,CAAC;AALW,QAAA,SAAS,aAKpB;AAEK,MAAM,iBAAiB,GAAG,CAAC,SAAqB,EAAc,EAAE;IACrE,oDAAoD;IACpD,OAAO,SAAS,CAAC;AACnB,CAAC,CAAC;AAHW,QAAA,iBAAiB,qBAG5B;AAEK,MAAM,mBAAmB,GAAG,CAAC,SAAqB,EAAc,EAAE;IACvE,oDAAoD;IACpD,OAAO,SAAS,CAAC;AACnB,CAAC,CAAC;AAHW,QAAA,mBAAmB,uBAG9B;AAEW,QAAA,gBAAgB,GAAG,EAAE,CAAC;AAEtB,QAAA,wBAAwB,GAAG,QAAQ,CAAC;AAEpC,QAAA,yBAAyB,GAAG,EAAE,CAAC","sourcesContent":["import { concatBytes, stringToBytes } from '@metamask/utils';\nimport { ed25519 } from '@noble/curves/ed25519';\n\nexport const curve = ed25519.CURVE;\nexport const name = 'ed25519';\n\n// Secret is defined in SLIP-10:\n// https://github.com/satoshilabs/slips/blob/133ea52a8e43d338b98be208907e144277e44c0e/slip-0010.md#master-key-generation\nexport const secret = stringToBytes('ed25519 seed');\n\n// All private keys are valid for ed25519:\n// https://github.com/satoshilabs/slips/blob/133ea52a8e43d338b98be208907e144277e44c0e/slip-0010.md#master-key-generation\nexport const isValidPrivateKey = (_privateKey: Uint8Array | string | bigint) =>\n  true;\n\nexport const deriveUnhardenedKeys = false;\n\nexport const publicKeyLength = 33;\n\nexport const getPublicKey = (\n  privateKey: Uint8Array,\n  _compressed?: boolean,\n): Uint8Array => {\n  const publicKey = ed25519.getPublicKey(privateKey);\n  return concatBytes([new Uint8Array([0]), publicKey]);\n};\n\nexport const publicAdd = (\n  _publicKey: Uint8Array,\n  _tweak: Uint8Array,\n): Uint8Array => {\n  throw new Error('Ed25519 does not support public key derivation.');\n};\n\nexport const compressPublicKey = (publicKey: Uint8Array): Uint8Array => {\n  // Ed25519 public keys don't have a compressed form.\n  return publicKey;\n};\n\nexport const decompressPublicKey = (publicKey: Uint8Array): Uint8Array => {\n  // Ed25519 public keys don't have a compressed form.\n  return publicKey;\n};\n\nexport const privateKeyLength = 32;\n\nexport const masterNodeGenerationSpec = 'slip10';\n\nexport const compressedPublicKeyLength = 33;\n"]}
\ No newline at end of file
+{"version":3,"file":"ed25519.cjs","sourceRoot":"","sources":["../../src/curves/ed25519.ts"],"names":[],"mappings":";;;AAAA,2CAA6D;AAC7D,mDAAgD;AAEnC,QAAA,KAAK,GAAG,iBAAO,CAAC,KAAK,CAAC;AACtB,QAAA,IAAI,GAAG,SAAS,CAAC;AAE9B,gCAAgC;AAChC,wHAAwH;AAC3G,QAAA,MAAM,GAAG,IAAA,qBAAa,EAAC,cAAc,CAAC,CAAC;AAEpD,0CAA0C;AAC1C,wHAAwH;AACjH,MAAM,iBAAiB,GAAG,CAC/B,WAAyC,EAChC,EAAE,CAAC,IAAI,CAAC;AAFN,QAAA,iBAAiB,qBAEX;AAEN,QAAA,oBAAoB,GAAG,KAAK,CAAC;AAE7B,QAAA,eAAe,GAAG,EAAE,CAAC;AAE3B,MAAM,YAAY,GAAG,CAC1B,UAAsB,EACtB,WAAqB,EACT,EAAE;IACd,MAAM,SAAS,GAAG,iBAAO,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC;IACnD,OAAO,IAAA,mBAAW,EAAC,CAAC,IAAI,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC,CAAC;AACvD,CAAC,CAAC;AANW,QAAA,YAAY,gBAMvB;AAEK,MAAM,SAAS,GAAG,CACvB,UAAsB,EACtB,MAAkB,EACN,EAAE;IACd,MAAM,IAAI,KAAK,CAAC,iDAAiD,CAAC,CAAC;AACrE,CAAC,CAAC;AALW,QAAA,SAAS,aAKpB;AAEK,MAAM,iBAAiB,GAAG,CAAC,SAAqB,EAAc,EAAE;IACrE,oDAAoD;IACpD,OAAO,SAAS,CAAC;AACnB,CAAC,CAAC;AAHW,QAAA,iBAAiB,qBAG5B;AAEK,MAAM,mBAAmB,GAAG,CAAC,SAAqB,EAAc,EAAE;IACvE,oDAAoD;IACpD,OAAO,SAAS,CAAC;AACnB,CAAC,CAAC;AAHW,QAAA,mBAAmB,uBAG9B;AAEW,QAAA,gBAAgB,GAAG,EAAE,CAAC;AAEtB,QAAA,wBAAwB,GAAG,QAAQ,CAAC;AAEpC,QAAA,yBAAyB,GAAG,EAAE,CAAC","sourcesContent":["import { concatBytes, stringToBytes } from '@metamask/utils';\nimport { ed25519 } from '@noble/curves/ed25519';\n\nexport const curve = ed25519.CURVE;\nexport const name = 'ed25519';\n\n// Secret is defined in SLIP-10:\n// https://github.com/satoshilabs/slips/blob/133ea52a8e43d338b98be208907e144277e44c0e/slip-0010.md#master-key-generation\nexport const secret = stringToBytes('ed25519 seed');\n\n// All private keys are valid for ed25519:\n// https://github.com/satoshilabs/slips/blob/133ea52a8e43d338b98be208907e144277e44c0e/slip-0010.md#master-key-generation\nexport const isValidPrivateKey = (\n  _privateKey: Uint8Array | string | bigint,\n): boolean => true;\n\nexport const deriveUnhardenedKeys = false;\n\nexport const publicKeyLength = 33;\n\nexport const getPublicKey = (\n  privateKey: Uint8Array,\n  _compressed?: boolean,\n): Uint8Array => {\n  const publicKey = ed25519.getPublicKey(privateKey);\n  return concatBytes([new Uint8Array([0]), publicKey]);\n};\n\nexport const publicAdd = (\n  _publicKey: Uint8Array,\n  _tweak: Uint8Array,\n): Uint8Array => {\n  throw new Error('Ed25519 does not support public key derivation.');\n};\n\nexport const compressPublicKey = (publicKey: Uint8Array): Uint8Array => {\n  // Ed25519 public keys don't have a compressed form.\n  return publicKey;\n};\n\nexport const decompressPublicKey = (publicKey: Uint8Array): Uint8Array => {\n  // Ed25519 public keys don't have a compressed form.\n  return publicKey;\n};\n\nexport const privateKeyLength = 32;\n\nexport const masterNodeGenerationSpec = 'slip10';\n\nexport const compressedPublicKeyLength = 33;\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/curves/ed25519.d.cts.map b/node_modules/@metamask/key-tree/dist/curves/ed25519.d.cts.map
index ba969b6..69b02eb 100644
--- a/node_modules/@metamask/key-tree/dist/curves/ed25519.d.cts.map
+++ b/node_modules/@metamask/key-tree/dist/curves/ed25519.d.cts.map
@@ -1 +1 @@
-{"version":3,"file":"ed25519.d.cts","sourceRoot":"","sources":["../../src/curves/ed25519.ts"],"names":[],"mappings":"AAGA,eAAO,MAAM,KAAK;;;;;;;;;;;;;;;;;;;;;;;EAAgB,CAAC;AACnC,eAAO,MAAM,IAAI,YAAY,CAAC;AAI9B,eAAO,MAAM,MAAM,YAAgC,CAAC;AAIpD,eAAO,MAAM,iBAAiB,gBAAiB,UAAU,GAAG,MAAM,GAAG,MAAM,YACrE,CAAC;AAEP,eAAO,MAAM,oBAAoB,QAAQ,CAAC;AAE1C,eAAO,MAAM,eAAe,KAAK,CAAC;AAElC,eAAO,MAAM,YAAY,eACX,UAAU,gBACR,OAAO,KACpB,UAGF,CAAC;AAEF,eAAO,MAAM,SAAS,eACR,UAAU,UACd,UAAU,KACjB,UAEF,CAAC;AAEF,eAAO,MAAM,iBAAiB,cAAe,UAAU,KAAG,UAGzD,CAAC;AAEF,eAAO,MAAM,mBAAmB,cAAe,UAAU,KAAG,UAG3D,CAAC;AAEF,eAAO,MAAM,gBAAgB,KAAK,CAAC;AAEnC,eAAO,MAAM,wBAAwB,WAAW,CAAC;AAEjD,eAAO,MAAM,yBAAyB,KAAK,CAAC"}
\ No newline at end of file
+{"version":3,"file":"ed25519.d.cts","sourceRoot":"","sources":["../../src/curves/ed25519.ts"],"names":[],"mappings":"AAGA,eAAO,MAAM,KAAK;;;;;;;;;;;;;;;;;;;;;;;EAAgB,CAAC;AACnC,eAAO,MAAM,IAAI,YAAY,CAAC;AAI9B,eAAO,MAAM,MAAM,YAAgC,CAAC;AAIpD,eAAO,MAAM,iBAAiB,gBACf,UAAU,GAAG,MAAM,GAAG,MAAM,KACxC,OAAe,CAAC;AAEnB,eAAO,MAAM,oBAAoB,QAAQ,CAAC;AAE1C,eAAO,MAAM,eAAe,KAAK,CAAC;AAElC,eAAO,MAAM,YAAY,eACX,UAAU,gBACR,OAAO,KACpB,UAGF,CAAC;AAEF,eAAO,MAAM,SAAS,eACR,UAAU,UACd,UAAU,KACjB,UAEF,CAAC;AAEF,eAAO,MAAM,iBAAiB,cAAe,UAAU,KAAG,UAGzD,CAAC;AAEF,eAAO,MAAM,mBAAmB,cAAe,UAAU,KAAG,UAG3D,CAAC;AAEF,eAAO,MAAM,gBAAgB,KAAK,CAAC;AAEnC,eAAO,MAAM,wBAAwB,WAAW,CAAC;AAEjD,eAAO,MAAM,yBAAyB,KAAK,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/curves/ed25519.d.mts.map b/node_modules/@metamask/key-tree/dist/curves/ed25519.d.mts.map
index e96d0c9..98f8408 100644
--- a/node_modules/@metamask/key-tree/dist/curves/ed25519.d.mts.map
+++ b/node_modules/@metamask/key-tree/dist/curves/ed25519.d.mts.map
@@ -1 +1 @@
-{"version":3,"file":"ed25519.d.mts","sourceRoot":"","sources":["../../src/curves/ed25519.ts"],"names":[],"mappings":"AAGA,eAAO,MAAM,KAAK;;;;;;;;;;;;;;;;;;;;;;;EAAgB,CAAC;AACnC,eAAO,MAAM,IAAI,YAAY,CAAC;AAI9B,eAAO,MAAM,MAAM,YAAgC,CAAC;AAIpD,eAAO,MAAM,iBAAiB,gBAAiB,UAAU,GAAG,MAAM,GAAG,MAAM,YACrE,CAAC;AAEP,eAAO,MAAM,oBAAoB,QAAQ,CAAC;AAE1C,eAAO,MAAM,eAAe,KAAK,CAAC;AAElC,eAAO,MAAM,YAAY,eACX,UAAU,gBACR,OAAO,KACpB,UAGF,CAAC;AAEF,eAAO,MAAM,SAAS,eACR,UAAU,UACd,UAAU,KACjB,UAEF,CAAC;AAEF,eAAO,MAAM,iBAAiB,cAAe,UAAU,KAAG,UAGzD,CAAC;AAEF,eAAO,MAAM,mBAAmB,cAAe,UAAU,KAAG,UAG3D,CAAC;AAEF,eAAO,MAAM,gBAAgB,KAAK,CAAC;AAEnC,eAAO,MAAM,wBAAwB,WAAW,CAAC;AAEjD,eAAO,MAAM,yBAAyB,KAAK,CAAC"}
\ No newline at end of file
+{"version":3,"file":"ed25519.d.mts","sourceRoot":"","sources":["../../src/curves/ed25519.ts"],"names":[],"mappings":"AAGA,eAAO,MAAM,KAAK;;;;;;;;;;;;;;;;;;;;;;;EAAgB,CAAC;AACnC,eAAO,MAAM,IAAI,YAAY,CAAC;AAI9B,eAAO,MAAM,MAAM,YAAgC,CAAC;AAIpD,eAAO,MAAM,iBAAiB,gBACf,UAAU,GAAG,MAAM,GAAG,MAAM,KACxC,OAAe,CAAC;AAEnB,eAAO,MAAM,oBAAoB,QAAQ,CAAC;AAE1C,eAAO,MAAM,eAAe,KAAK,CAAC;AAElC,eAAO,MAAM,YAAY,eACX,UAAU,gBACR,OAAO,KACpB,UAGF,CAAC;AAEF,eAAO,MAAM,SAAS,eACR,UAAU,UACd,UAAU,KACjB,UAEF,CAAC;AAEF,eAAO,MAAM,iBAAiB,cAAe,UAAU,KAAG,UAGzD,CAAC;AAEF,eAAO,MAAM,mBAAmB,cAAe,UAAU,KAAG,UAG3D,CAAC;AAEF,eAAO,MAAM,gBAAgB,KAAK,CAAC;AAEnC,eAAO,MAAM,wBAAwB,WAAW,CAAC;AAEjD,eAAO,MAAM,yBAAyB,KAAK,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/curves/ed25519.mjs.map b/node_modules/@metamask/key-tree/dist/curves/ed25519.mjs.map
index e225aa8..714f0e5 100644
--- a/node_modules/@metamask/key-tree/dist/curves/ed25519.mjs.map
+++ b/node_modules/@metamask/key-tree/dist/curves/ed25519.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"ed25519.mjs","sourceRoot":"","sources":["../../src/curves/ed25519.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,WAAW,EAAE,aAAa,EAAE,wBAAwB;AAC7D,OAAO,EAAE,OAAO,EAAE,8BAA8B;AAEhD,MAAM,CAAC,MAAM,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC;AACnC,MAAM,CAAC,MAAM,IAAI,GAAG,SAAS,CAAC;AAE9B,gCAAgC;AAChC,wHAAwH;AACxH,MAAM,CAAC,MAAM,MAAM,GAAG,aAAa,CAAC,cAAc,CAAC,CAAC;AAEpD,0CAA0C;AAC1C,wHAAwH;AACxH,MAAM,CAAC,MAAM,iBAAiB,GAAG,CAAC,WAAyC,EAAE,EAAE,CAC7E,IAAI,CAAC;AAEP,MAAM,CAAC,MAAM,oBAAoB,GAAG,KAAK,CAAC;AAE1C,MAAM,CAAC,MAAM,eAAe,GAAG,EAAE,CAAC;AAElC,MAAM,CAAC,MAAM,YAAY,GAAG,CAC1B,UAAsB,EACtB,WAAqB,EACT,EAAE;IACd,MAAM,SAAS,GAAG,OAAO,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC;IACnD,OAAO,WAAW,CAAC,CAAC,IAAI,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC,CAAC;AACvD,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,SAAS,GAAG,CACvB,UAAsB,EACtB,MAAkB,EACN,EAAE;IACd,MAAM,IAAI,KAAK,CAAC,iDAAiD,CAAC,CAAC;AACrE,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,iBAAiB,GAAG,CAAC,SAAqB,EAAc,EAAE;IACrE,oDAAoD;IACpD,OAAO,SAAS,CAAC;AACnB,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,mBAAmB,GAAG,CAAC,SAAqB,EAAc,EAAE;IACvE,oDAAoD;IACpD,OAAO,SAAS,CAAC;AACnB,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,gBAAgB,GAAG,EAAE,CAAC;AAEnC,MAAM,CAAC,MAAM,wBAAwB,GAAG,QAAQ,CAAC;AAEjD,MAAM,CAAC,MAAM,yBAAyB,GAAG,EAAE,CAAC","sourcesContent":["import { concatBytes, stringToBytes } from '@metamask/utils';\nimport { ed25519 } from '@noble/curves/ed25519';\n\nexport const curve = ed25519.CURVE;\nexport const name = 'ed25519';\n\n// Secret is defined in SLIP-10:\n// https://github.com/satoshilabs/slips/blob/133ea52a8e43d338b98be208907e144277e44c0e/slip-0010.md#master-key-generation\nexport const secret = stringToBytes('ed25519 seed');\n\n// All private keys are valid for ed25519:\n// https://github.com/satoshilabs/slips/blob/133ea52a8e43d338b98be208907e144277e44c0e/slip-0010.md#master-key-generation\nexport const isValidPrivateKey = (_privateKey: Uint8Array | string | bigint) =>\n  true;\n\nexport const deriveUnhardenedKeys = false;\n\nexport const publicKeyLength = 33;\n\nexport const getPublicKey = (\n  privateKey: Uint8Array,\n  _compressed?: boolean,\n): Uint8Array => {\n  const publicKey = ed25519.getPublicKey(privateKey);\n  return concatBytes([new Uint8Array([0]), publicKey]);\n};\n\nexport const publicAdd = (\n  _publicKey: Uint8Array,\n  _tweak: Uint8Array,\n): Uint8Array => {\n  throw new Error('Ed25519 does not support public key derivation.');\n};\n\nexport const compressPublicKey = (publicKey: Uint8Array): Uint8Array => {\n  // Ed25519 public keys don't have a compressed form.\n  return publicKey;\n};\n\nexport const decompressPublicKey = (publicKey: Uint8Array): Uint8Array => {\n  // Ed25519 public keys don't have a compressed form.\n  return publicKey;\n};\n\nexport const privateKeyLength = 32;\n\nexport const masterNodeGenerationSpec = 'slip10';\n\nexport const compressedPublicKeyLength = 33;\n"]}
\ No newline at end of file
+{"version":3,"file":"ed25519.mjs","sourceRoot":"","sources":["../../src/curves/ed25519.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,WAAW,EAAE,aAAa,EAAE,wBAAwB;AAC7D,OAAO,EAAE,OAAO,EAAE,8BAA8B;AAEhD,MAAM,CAAC,MAAM,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC;AACnC,MAAM,CAAC,MAAM,IAAI,GAAG,SAAS,CAAC;AAE9B,gCAAgC;AAChC,wHAAwH;AACxH,MAAM,CAAC,MAAM,MAAM,GAAG,aAAa,CAAC,cAAc,CAAC,CAAC;AAEpD,0CAA0C;AAC1C,wHAAwH;AACxH,MAAM,CAAC,MAAM,iBAAiB,GAAG,CAC/B,WAAyC,EAChC,EAAE,CAAC,IAAI,CAAC;AAEnB,MAAM,CAAC,MAAM,oBAAoB,GAAG,KAAK,CAAC;AAE1C,MAAM,CAAC,MAAM,eAAe,GAAG,EAAE,CAAC;AAElC,MAAM,CAAC,MAAM,YAAY,GAAG,CAC1B,UAAsB,EACtB,WAAqB,EACT,EAAE;IACd,MAAM,SAAS,GAAG,OAAO,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC;IACnD,OAAO,WAAW,CAAC,CAAC,IAAI,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC,CAAC;AACvD,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,SAAS,GAAG,CACvB,UAAsB,EACtB,MAAkB,EACN,EAAE;IACd,MAAM,IAAI,KAAK,CAAC,iDAAiD,CAAC,CAAC;AACrE,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,iBAAiB,GAAG,CAAC,SAAqB,EAAc,EAAE;IACrE,oDAAoD;IACpD,OAAO,SAAS,CAAC;AACnB,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,mBAAmB,GAAG,CAAC,SAAqB,EAAc,EAAE;IACvE,oDAAoD;IACpD,OAAO,SAAS,CAAC;AACnB,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,gBAAgB,GAAG,EAAE,CAAC;AAEnC,MAAM,CAAC,MAAM,wBAAwB,GAAG,QAAQ,CAAC;AAEjD,MAAM,CAAC,MAAM,yBAAyB,GAAG,EAAE,CAAC","sourcesContent":["import { concatBytes, stringToBytes } from '@metamask/utils';\nimport { ed25519 } from '@noble/curves/ed25519';\n\nexport const curve = ed25519.CURVE;\nexport const name = 'ed25519';\n\n// Secret is defined in SLIP-10:\n// https://github.com/satoshilabs/slips/blob/133ea52a8e43d338b98be208907e144277e44c0e/slip-0010.md#master-key-generation\nexport const secret = stringToBytes('ed25519 seed');\n\n// All private keys are valid for ed25519:\n// https://github.com/satoshilabs/slips/blob/133ea52a8e43d338b98be208907e144277e44c0e/slip-0010.md#master-key-generation\nexport const isValidPrivateKey = (\n  _privateKey: Uint8Array | string | bigint,\n): boolean => true;\n\nexport const deriveUnhardenedKeys = false;\n\nexport const publicKeyLength = 33;\n\nexport const getPublicKey = (\n  privateKey: Uint8Array,\n  _compressed?: boolean,\n): Uint8Array => {\n  const publicKey = ed25519.getPublicKey(privateKey);\n  return concatBytes([new Uint8Array([0]), publicKey]);\n};\n\nexport const publicAdd = (\n  _publicKey: Uint8Array,\n  _tweak: Uint8Array,\n): Uint8Array => {\n  throw new Error('Ed25519 does not support public key derivation.');\n};\n\nexport const compressPublicKey = (publicKey: Uint8Array): Uint8Array => {\n  // Ed25519 public keys don't have a compressed form.\n  return publicKey;\n};\n\nexport const decompressPublicKey = (publicKey: Uint8Array): Uint8Array => {\n  // Ed25519 public keys don't have a compressed form.\n  return publicKey;\n};\n\nexport const privateKeyLength = 32;\n\nexport const masterNodeGenerationSpec = 'slip10';\n\nexport const compressedPublicKeyLength = 33;\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/curves/ed25519Bip32.cjs.map b/node_modules/@metamask/key-tree/dist/curves/ed25519Bip32.cjs.map
index ffc51e1..9167042 100644
--- a/node_modules/@metamask/key-tree/dist/curves/ed25519Bip32.cjs.map
+++ b/node_modules/@metamask/key-tree/dist/curves/ed25519Bip32.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"ed25519Bip32.cjs","sourceRoot":"","sources":["../../src/curves/ed25519Bip32.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  stringToBytes,\n  bytesToHex,\n  hexToBigInt,\n  remove0x,\n  assert,\n} from '@metamask/utils';\nimport { mod } from '@noble/curves/abstract/modular';\nimport { ed25519 } from '@noble/curves/ed25519';\n\nexport const curve = ed25519.CURVE;\n\n/**\n * Named after whitepaper: BIP32-Ed25519 Hierarchical Deterministic Keys over a Non-linear Keyspace\n * https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf\n * \"vanilla\" \"ed25519\" curve follows SLIP10: https://tezos.stackexchange.com/questions/2837/can-i-use-bip32-hd-key-pairs-to-derive-ed25519-addresses\n * note that that the important difference of the \"bip32\" version is that it allows unhardened key derivation\n */\nexport const name = 'ed25519Bip32';\n\n// Secret is empty string if not provided by user\nexport const secret = stringToBytes('');\n\n/**\n * Get a byte from a private key at a given index.\n *\n * @param privateKey - The private key.\n * @param index - The index of the byte to get.\n * @returns The byte at the given index.\n * @throws If the private key is too short.\n */\nfunction getByte(privateKey: Uint8Array, index: number): number {\n  const byte = privateKey[index];\n  assert(byte !== undefined, 'Private key is too short.');\n\n  return byte;\n}\n\n/**\n * Check if a private key is valid.\n *\n * @param privateKey - The private key to check.\n * @returns Whether the private key is valid.\n */\nexport const isValidPrivateKey = (privateKey: Uint8Array) => {\n  /* eslint-disable no-bitwise */\n  // Lowest 3 bits of the first byte must be zero\n  if ((getByte(privateKey, 0) & 0b00000111) !== 0) {\n    return false;\n  }\n\n  // The highest bit of the last byte must be zero\n  if ((getByte(privateKey, 31) & 0b10000000) !== 0) {\n    return false;\n  }\n\n  // The second highest bit of the last byte must be one\n  if ((getByte(privateKey, 31) & 0b01000000) !== 0b01000000) {\n    return false;\n  }\n  /* eslint-enable no-bitwise */\n\n  return true;\n};\n\nexport const deriveUnhardenedKeys = true;\n\nexport const publicKeyLength = 32;\n\n/**\n * Converts a Uint8Array of bytes to a bigint in little-endian format.\n *\n * @param bytes - The Uint8Array of bytes to convert.\n * @returns The converted bigint value.\n */\nexport const bytesToNumberLE = (bytes: Uint8Array): bigint => {\n  return hexToBigInt(bytesToHex(Uint8Array.from(bytes).reverse()));\n};\n\n/**\n * Multiplies the given key with the base point on the Edwards curve.\n * equivalent to https://github.com/jedisct1/libsodium/blob/93a6e79750a31bc0b946bf483b2ba1c77f9e94ce/src/libsodium/crypto_scalarmult/ed25519/ref10/scalarmult_ed25519_ref10.c#L105 .\n * which is used by cardano-js-sdk/crypto https://github.com/input-output-hk/cardano-js-sdk/blob/8a6db2a251cd1c956f52730a0d35de2b7fc67404/packages/crypto/src/Bip32/Bip32PrivateKey.ts#L161 .\n *\n * @param key - The key to multiply with the base point.\n * @returns The resulting point on the Edwards curve.\n */\nexport const multiplyWithBase = (key: Uint8Array): Uint8Array => {\n  // Little-endian SHA512 with modulo n\n  const scalar = mod(bytesToNumberLE(key), curve.n); // The actual scalar\n  const point = ed25519.ExtendedPoint.BASE.multiply(scalar); // Point on Edwards curve aka public key\n  return point.toRawBytes(); // Uint8Array representation\n};\n\n/**\n * Calculates the public key corresponding to a given private key.\n *\n * @param privateKey - The private key.\n * @param _compressed - Optional parameter to indicate if the public key should be compressed.\n * @returns The public key.\n */\nexport const getPublicKey = async (\n  privateKey: Uint8Array,\n  _compressed?: boolean,\n): Promise<Uint8Array> => {\n  return multiplyWithBase(privateKey.slice(0, 32));\n};\n\n/**\n * Adds a tweak to a public key.\n *\n * @param publicKey - The public key.\n * @param tweak - The tweak to add.\n * @returns The resulting public key.\n */\nexport const publicAdd = (\n  publicKey: Uint8Array,\n  tweak: Uint8Array,\n): Uint8Array => {\n  return ed25519.ExtendedPoint.fromHex(remove0x(bytesToHex(publicKey)))\n    .add(ed25519.ExtendedPoint.fromHex(remove0x(bytesToHex(tweak))))\n    .toRawBytes();\n};\n\n/**\n * Compresses an Ed25519 public key.\n *\n * @param publicKey - The public key to compress.\n * @returns The compressed public key.\n */\nexport const compressPublicKey = (publicKey: Uint8Array): Uint8Array => {\n  // Ed25519 public keys don't have a compressed form.\n  return publicKey;\n};\n\n/**\n * Decompresses a compressed Ed25519Bip32 public key.\n *\n * @param publicKey - The compressed public key.\n * @returns The decompressed public key.\n */\nexport const decompressPublicKey = (publicKey: Uint8Array): Uint8Array => {\n  // Ed25519 public keys don't have a compressed form.\n  return publicKey;\n};\n\nexport const privateKeyLength = 64;\n\nexport const masterNodeGenerationSpec = 'cip3';\n\nexport const compressedPublicKeyLength = 32;\n"]}
\ No newline at end of file
+{"version":3,"file":"ed25519Bip32.cjs","sourceRoot":"","sources":["../../src/curves/ed25519Bip32.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  stringToBytes,\n  bytesToHex,\n  hexToBigInt,\n  remove0x,\n  assert,\n} from '@metamask/utils';\nimport { mod } from '@noble/curves/abstract/modular';\nimport { ed25519 } from '@noble/curves/ed25519';\n\nexport const curve = ed25519.CURVE;\n\n/**\n * Named after whitepaper: BIP32-Ed25519 Hierarchical Deterministic Keys over a Non-linear Keyspace\n * https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf\n * \"vanilla\" \"ed25519\" curve follows SLIP10: https://tezos.stackexchange.com/questions/2837/can-i-use-bip32-hd-key-pairs-to-derive-ed25519-addresses\n * note that that the important difference of the \"bip32\" version is that it allows unhardened key derivation\n */\nexport const name = 'ed25519Bip32';\n\n// Secret is empty string if not provided by user\nexport const secret = stringToBytes('');\n\n/**\n * Get a byte from a private key at a given index.\n *\n * @param privateKey - The private key.\n * @param index - The index of the byte to get.\n * @returns The byte at the given index.\n * @throws If the private key is too short.\n */\nfunction getByte(privateKey: Uint8Array, index: number): number {\n  const byte = privateKey[index];\n  assert(byte !== undefined, 'Private key is too short.');\n\n  return byte;\n}\n\n/**\n * Check if a private key is valid.\n *\n * @param privateKey - The private key to check.\n * @returns Whether the private key is valid.\n */\nexport const isValidPrivateKey = (privateKey: Uint8Array): boolean => {\n  /* eslint-disable no-bitwise */\n  // Lowest 3 bits of the first byte must be zero\n  if ((getByte(privateKey, 0) & 0b00000111) !== 0) {\n    return false;\n  }\n\n  // The highest bit of the last byte must be zero\n  if ((getByte(privateKey, 31) & 0b10000000) !== 0) {\n    return false;\n  }\n\n  // The second highest bit of the last byte must be one\n  if ((getByte(privateKey, 31) & 0b01000000) !== 0b01000000) {\n    return false;\n  }\n  /* eslint-enable no-bitwise */\n\n  return true;\n};\n\nexport const deriveUnhardenedKeys = true;\n\nexport const publicKeyLength = 32;\n\n/**\n * Converts a Uint8Array of bytes to a bigint in little-endian format.\n *\n * @param bytes - The Uint8Array of bytes to convert.\n * @returns The converted bigint value.\n */\nexport const bytesToNumberLE = (bytes: Uint8Array): bigint => {\n  return hexToBigInt(bytesToHex(Uint8Array.from(bytes).reverse()));\n};\n\n/**\n * Multiplies the given key with the base point on the Edwards curve.\n * equivalent to https://github.com/jedisct1/libsodium/blob/93a6e79750a31bc0b946bf483b2ba1c77f9e94ce/src/libsodium/crypto_scalarmult/ed25519/ref10/scalarmult_ed25519_ref10.c#L105 .\n * which is used by cardano-js-sdk/crypto https://github.com/input-output-hk/cardano-js-sdk/blob/8a6db2a251cd1c956f52730a0d35de2b7fc67404/packages/crypto/src/Bip32/Bip32PrivateKey.ts#L161 .\n *\n * @param key - The key to multiply with the base point.\n * @returns The resulting point on the Edwards curve.\n */\nexport const multiplyWithBase = (key: Uint8Array): Uint8Array => {\n  // Little-endian SHA512 with modulo n\n  const scalar = mod(bytesToNumberLE(key), curve.n); // The actual scalar\n  const point = ed25519.ExtendedPoint.BASE.multiply(scalar); // Point on Edwards curve aka public key\n  return point.toRawBytes(); // Uint8Array representation\n};\n\n/**\n * Calculates the public key corresponding to a given private key.\n *\n * @param privateKey - The private key.\n * @param _compressed - Optional parameter to indicate if the public key should be compressed.\n * @returns The public key.\n */\nexport const getPublicKey = async (\n  privateKey: Uint8Array,\n  _compressed?: boolean,\n): Promise<Uint8Array> => {\n  return multiplyWithBase(privateKey.slice(0, 32));\n};\n\n/**\n * Adds a tweak to a public key.\n *\n * @param publicKey - The public key.\n * @param tweak - The tweak to add.\n * @returns The resulting public key.\n */\nexport const publicAdd = (\n  publicKey: Uint8Array,\n  tweak: Uint8Array,\n): Uint8Array => {\n  return ed25519.ExtendedPoint.fromHex(remove0x(bytesToHex(publicKey)))\n    .add(ed25519.ExtendedPoint.fromHex(remove0x(bytesToHex(tweak))))\n    .toRawBytes();\n};\n\n/**\n * Compresses an Ed25519 public key.\n *\n * @param publicKey - The public key to compress.\n * @returns The compressed public key.\n */\nexport const compressPublicKey = (publicKey: Uint8Array): Uint8Array => {\n  // Ed25519 public keys don't have a compressed form.\n  return publicKey;\n};\n\n/**\n * Decompresses a compressed Ed25519Bip32 public key.\n *\n * @param publicKey - The compressed public key.\n * @returns The decompressed public key.\n */\nexport const decompressPublicKey = (publicKey: Uint8Array): Uint8Array => {\n  // Ed25519 public keys don't have a compressed form.\n  return publicKey;\n};\n\nexport const privateKeyLength = 64;\n\nexport const masterNodeGenerationSpec = 'cip3';\n\nexport const compressedPublicKeyLength = 32;\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/curves/ed25519Bip32.d.cts.map b/node_modules/@metamask/key-tree/dist/curves/ed25519Bip32.d.cts.map
index ee3156b..a0f245c 100644
--- a/node_modules/@metamask/key-tree/dist/curves/ed25519Bip32.d.cts.map
+++ b/node_modules/@metamask/key-tree/dist/curves/ed25519Bip32.d.cts.map
@@ -1 +1 @@
-{"version":3,"file":"ed25519Bip32.d.cts","sourceRoot":"","sources":["../../src/curves/ed25519Bip32.ts"],"names":[],"mappings":"AAUA,eAAO,MAAM,KAAK;;;;IAalB;;;;;;;OAOG;;;;;;;;;;;;;;;;;;;;EApB+B,CAAC;AAEnC;;;;;GAKG;AACH,eAAO,MAAM,IAAI,iBAAiB,CAAC;AAGnC,eAAO,MAAM,MAAM,YAAoB,CAAC;AAiBxC;;;;;GAKG;AACH,eAAO,MAAM,iBAAiB,eAAgB,UAAU,YAmBvD,CAAC;AAEF,eAAO,MAAM,oBAAoB,OAAO,CAAC;AAEzC,eAAO,MAAM,eAAe,KAAK,CAAC;AAElC;;;;;GAKG;AACH,eAAO,MAAM,eAAe,UAAW,UAAU,KAAG,MAEnD,CAAC;AAEF;;;;;;;GAOG;AACH,eAAO,MAAM,gBAAgB,QAAS,UAAU,KAAG,UAKlD,CAAC;AAEF;;;;;;GAMG;AACH,eAAO,MAAM,YAAY,eACX,UAAU,gBACR,OAAO,KACpB,QAAQ,UAAU,CAEpB,CAAC;AAEF;;;;;;GAMG;AACH,eAAO,MAAM,SAAS,cACT,UAAU,SACd,UAAU,KAChB,UAIF,CAAC;AAEF;;;;;GAKG;AACH,eAAO,MAAM,iBAAiB,cAAe,UAAU,KAAG,UAGzD,CAAC;AAEF;;;;;GAKG;AACH,eAAO,MAAM,mBAAmB,cAAe,UAAU,KAAG,UAG3D,CAAC;AAEF,eAAO,MAAM,gBAAgB,KAAK,CAAC;AAEnC,eAAO,MAAM,wBAAwB,SAAS,CAAC;AAE/C,eAAO,MAAM,yBAAyB,KAAK,CAAC"}
\ No newline at end of file
+{"version":3,"file":"ed25519Bip32.d.cts","sourceRoot":"","sources":["../../src/curves/ed25519Bip32.ts"],"names":[],"mappings":"AAUA,eAAO,MAAM,KAAK;;;;IAalB;;;;;;;OAOG;;;;;;;;;;;;;;;;;;;;EApB+B,CAAC;AAEnC;;;;;GAKG;AACH,eAAO,MAAM,IAAI,iBAAiB,CAAC;AAGnC,eAAO,MAAM,MAAM,YAAoB,CAAC;AAiBxC;;;;;GAKG;AACH,eAAO,MAAM,iBAAiB,eAAgB,UAAU,KAAG,OAmB1D,CAAC;AAEF,eAAO,MAAM,oBAAoB,OAAO,CAAC;AAEzC,eAAO,MAAM,eAAe,KAAK,CAAC;AAElC;;;;;GAKG;AACH,eAAO,MAAM,eAAe,UAAW,UAAU,KAAG,MAEnD,CAAC;AAEF;;;;;;;GAOG;AACH,eAAO,MAAM,gBAAgB,QAAS,UAAU,KAAG,UAKlD,CAAC;AAEF;;;;;;GAMG;AACH,eAAO,MAAM,YAAY,eACX,UAAU,gBACR,OAAO,KACpB,QAAQ,UAAU,CAEpB,CAAC;AAEF;;;;;;GAMG;AACH,eAAO,MAAM,SAAS,cACT,UAAU,SACd,UAAU,KAChB,UAIF,CAAC;AAEF;;;;;GAKG;AACH,eAAO,MAAM,iBAAiB,cAAe,UAAU,KAAG,UAGzD,CAAC;AAEF;;;;;GAKG;AACH,eAAO,MAAM,mBAAmB,cAAe,UAAU,KAAG,UAG3D,CAAC;AAEF,eAAO,MAAM,gBAAgB,KAAK,CAAC;AAEnC,eAAO,MAAM,wBAAwB,SAAS,CAAC;AAE/C,eAAO,MAAM,yBAAyB,KAAK,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/curves/ed25519Bip32.d.mts.map b/node_modules/@metamask/key-tree/dist/curves/ed25519Bip32.d.mts.map
index f56d203..2770c65 100644
--- a/node_modules/@metamask/key-tree/dist/curves/ed25519Bip32.d.mts.map
+++ b/node_modules/@metamask/key-tree/dist/curves/ed25519Bip32.d.mts.map
@@ -1 +1 @@
-{"version":3,"file":"ed25519Bip32.d.mts","sourceRoot":"","sources":["../../src/curves/ed25519Bip32.ts"],"names":[],"mappings":"AAUA,eAAO,MAAM,KAAK;;;;IAalB;;;;;;;OAOG;;;;;;;;;;;;;;;;;;;;EApB+B,CAAC;AAEnC;;;;;GAKG;AACH,eAAO,MAAM,IAAI,iBAAiB,CAAC;AAGnC,eAAO,MAAM,MAAM,YAAoB,CAAC;AAiBxC;;;;;GAKG;AACH,eAAO,MAAM,iBAAiB,eAAgB,UAAU,YAmBvD,CAAC;AAEF,eAAO,MAAM,oBAAoB,OAAO,CAAC;AAEzC,eAAO,MAAM,eAAe,KAAK,CAAC;AAElC;;;;;GAKG;AACH,eAAO,MAAM,eAAe,UAAW,UAAU,KAAG,MAEnD,CAAC;AAEF;;;;;;;GAOG;AACH,eAAO,MAAM,gBAAgB,QAAS,UAAU,KAAG,UAKlD,CAAC;AAEF;;;;;;GAMG;AACH,eAAO,MAAM,YAAY,eACX,UAAU,gBACR,OAAO,KACpB,QAAQ,UAAU,CAEpB,CAAC;AAEF;;;;;;GAMG;AACH,eAAO,MAAM,SAAS,cACT,UAAU,SACd,UAAU,KAChB,UAIF,CAAC;AAEF;;;;;GAKG;AACH,eAAO,MAAM,iBAAiB,cAAe,UAAU,KAAG,UAGzD,CAAC;AAEF;;;;;GAKG;AACH,eAAO,MAAM,mBAAmB,cAAe,UAAU,KAAG,UAG3D,CAAC;AAEF,eAAO,MAAM,gBAAgB,KAAK,CAAC;AAEnC,eAAO,MAAM,wBAAwB,SAAS,CAAC;AAE/C,eAAO,MAAM,yBAAyB,KAAK,CAAC"}
\ No newline at end of file
+{"version":3,"file":"ed25519Bip32.d.mts","sourceRoot":"","sources":["../../src/curves/ed25519Bip32.ts"],"names":[],"mappings":"AAUA,eAAO,MAAM,KAAK;;;;IAalB;;;;;;;OAOG;;;;;;;;;;;;;;;;;;;;EApB+B,CAAC;AAEnC;;;;;GAKG;AACH,eAAO,MAAM,IAAI,iBAAiB,CAAC;AAGnC,eAAO,MAAM,MAAM,YAAoB,CAAC;AAiBxC;;;;;GAKG;AACH,eAAO,MAAM,iBAAiB,eAAgB,UAAU,KAAG,OAmB1D,CAAC;AAEF,eAAO,MAAM,oBAAoB,OAAO,CAAC;AAEzC,eAAO,MAAM,eAAe,KAAK,CAAC;AAElC;;;;;GAKG;AACH,eAAO,MAAM,eAAe,UAAW,UAAU,KAAG,MAEnD,CAAC;AAEF;;;;;;;GAOG;AACH,eAAO,MAAM,gBAAgB,QAAS,UAAU,KAAG,UAKlD,CAAC;AAEF;;;;;;GAMG;AACH,eAAO,MAAM,YAAY,eACX,UAAU,gBACR,OAAO,KACpB,QAAQ,UAAU,CAEpB,CAAC;AAEF;;;;;;GAMG;AACH,eAAO,MAAM,SAAS,cACT,UAAU,SACd,UAAU,KAChB,UAIF,CAAC;AAEF;;;;;GAKG;AACH,eAAO,MAAM,iBAAiB,cAAe,UAAU,KAAG,UAGzD,CAAC;AAEF;;;;;GAKG;AACH,eAAO,MAAM,mBAAmB,cAAe,UAAU,KAAG,UAG3D,CAAC;AAEF,eAAO,MAAM,gBAAgB,KAAK,CAAC;AAEnC,eAAO,MAAM,wBAAwB,SAAS,CAAC;AAE/C,eAAO,MAAM,yBAAyB,KAAK,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/curves/ed25519Bip32.mjs.map b/node_modules/@metamask/key-tree/dist/curves/ed25519Bip32.mjs.map
index 28bd5c9..bcf5b69 100644
--- a/node_modules/@metamask/key-tree/dist/curves/ed25519Bip32.mjs.map
+++ b/node_modules/@metamask/key-tree/dist/curves/ed25519Bip32.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"ed25519Bip32.mjs","sourceRoot":"","sources":["../../src/curves/ed25519Bip32.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  stringToBytes,\n  bytesToHex,\n  hexToBigInt,\n  remove0x,\n  assert,\n} from '@metamask/utils';\nimport { mod } from '@noble/curves/abstract/modular';\nimport { ed25519 } from '@noble/curves/ed25519';\n\nexport const curve = ed25519.CURVE;\n\n/**\n * Named after whitepaper: BIP32-Ed25519 Hierarchical Deterministic Keys over a Non-linear Keyspace\n * https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf\n * \"vanilla\" \"ed25519\" curve follows SLIP10: https://tezos.stackexchange.com/questions/2837/can-i-use-bip32-hd-key-pairs-to-derive-ed25519-addresses\n * note that that the important difference of the \"bip32\" version is that it allows unhardened key derivation\n */\nexport const name = 'ed25519Bip32';\n\n// Secret is empty string if not provided by user\nexport const secret = stringToBytes('');\n\n/**\n * Get a byte from a private key at a given index.\n *\n * @param privateKey - The private key.\n * @param index - The index of the byte to get.\n * @returns The byte at the given index.\n * @throws If the private key is too short.\n */\nfunction getByte(privateKey: Uint8Array, index: number): number {\n  const byte = privateKey[index];\n  assert(byte !== undefined, 'Private key is too short.');\n\n  return byte;\n}\n\n/**\n * Check if a private key is valid.\n *\n * @param privateKey - The private key to check.\n * @returns Whether the private key is valid.\n */\nexport const isValidPrivateKey = (privateKey: Uint8Array) => {\n  /* eslint-disable no-bitwise */\n  // Lowest 3 bits of the first byte must be zero\n  if ((getByte(privateKey, 0) & 0b00000111) !== 0) {\n    return false;\n  }\n\n  // The highest bit of the last byte must be zero\n  if ((getByte(privateKey, 31) & 0b10000000) !== 0) {\n    return false;\n  }\n\n  // The second highest bit of the last byte must be one\n  if ((getByte(privateKey, 31) & 0b01000000) !== 0b01000000) {\n    return false;\n  }\n  /* eslint-enable no-bitwise */\n\n  return true;\n};\n\nexport const deriveUnhardenedKeys = true;\n\nexport const publicKeyLength = 32;\n\n/**\n * Converts a Uint8Array of bytes to a bigint in little-endian format.\n *\n * @param bytes - The Uint8Array of bytes to convert.\n * @returns The converted bigint value.\n */\nexport const bytesToNumberLE = (bytes: Uint8Array): bigint => {\n  return hexToBigInt(bytesToHex(Uint8Array.from(bytes).reverse()));\n};\n\n/**\n * Multiplies the given key with the base point on the Edwards curve.\n * equivalent to https://github.com/jedisct1/libsodium/blob/93a6e79750a31bc0b946bf483b2ba1c77f9e94ce/src/libsodium/crypto_scalarmult/ed25519/ref10/scalarmult_ed25519_ref10.c#L105 .\n * which is used by cardano-js-sdk/crypto https://github.com/input-output-hk/cardano-js-sdk/blob/8a6db2a251cd1c956f52730a0d35de2b7fc67404/packages/crypto/src/Bip32/Bip32PrivateKey.ts#L161 .\n *\n * @param key - The key to multiply with the base point.\n * @returns The resulting point on the Edwards curve.\n */\nexport const multiplyWithBase = (key: Uint8Array): Uint8Array => {\n  // Little-endian SHA512 with modulo n\n  const scalar = mod(bytesToNumberLE(key), curve.n); // The actual scalar\n  const point = ed25519.ExtendedPoint.BASE.multiply(scalar); // Point on Edwards curve aka public key\n  return point.toRawBytes(); // Uint8Array representation\n};\n\n/**\n * Calculates the public key corresponding to a given private key.\n *\n * @param privateKey - The private key.\n * @param _compressed - Optional parameter to indicate if the public key should be compressed.\n * @returns The public key.\n */\nexport const getPublicKey = async (\n  privateKey: Uint8Array,\n  _compressed?: boolean,\n): Promise<Uint8Array> => {\n  return multiplyWithBase(privateKey.slice(0, 32));\n};\n\n/**\n * Adds a tweak to a public key.\n *\n * @param publicKey - The public key.\n * @param tweak - The tweak to add.\n * @returns The resulting public key.\n */\nexport const publicAdd = (\n  publicKey: Uint8Array,\n  tweak: Uint8Array,\n): Uint8Array => {\n  return ed25519.ExtendedPoint.fromHex(remove0x(bytesToHex(publicKey)))\n    .add(ed25519.ExtendedPoint.fromHex(remove0x(bytesToHex(tweak))))\n    .toRawBytes();\n};\n\n/**\n * Compresses an Ed25519 public key.\n *\n * @param publicKey - The public key to compress.\n * @returns The compressed public key.\n */\nexport const compressPublicKey = (publicKey: Uint8Array): Uint8Array => {\n  // Ed25519 public keys don't have a compressed form.\n  return publicKey;\n};\n\n/**\n * Decompresses a compressed Ed25519Bip32 public key.\n *\n * @param publicKey - The compressed public key.\n * @returns The decompressed public key.\n */\nexport const decompressPublicKey = (publicKey: Uint8Array): Uint8Array => {\n  // Ed25519 public keys don't have a compressed form.\n  return publicKey;\n};\n\nexport const privateKeyLength = 64;\n\nexport const masterNodeGenerationSpec = 'cip3';\n\nexport const compressedPublicKeyLength = 32;\n"]}
\ No newline at end of file
+{"version":3,"file":"ed25519Bip32.mjs","sourceRoot":"","sources":["../../src/curves/ed25519Bip32.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  stringToBytes,\n  bytesToHex,\n  hexToBigInt,\n  remove0x,\n  assert,\n} from '@metamask/utils';\nimport { mod } from '@noble/curves/abstract/modular';\nimport { ed25519 } from '@noble/curves/ed25519';\n\nexport const curve = ed25519.CURVE;\n\n/**\n * Named after whitepaper: BIP32-Ed25519 Hierarchical Deterministic Keys over a Non-linear Keyspace\n * https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf\n * \"vanilla\" \"ed25519\" curve follows SLIP10: https://tezos.stackexchange.com/questions/2837/can-i-use-bip32-hd-key-pairs-to-derive-ed25519-addresses\n * note that that the important difference of the \"bip32\" version is that it allows unhardened key derivation\n */\nexport const name = 'ed25519Bip32';\n\n// Secret is empty string if not provided by user\nexport const secret = stringToBytes('');\n\n/**\n * Get a byte from a private key at a given index.\n *\n * @param privateKey - The private key.\n * @param index - The index of the byte to get.\n * @returns The byte at the given index.\n * @throws If the private key is too short.\n */\nfunction getByte(privateKey: Uint8Array, index: number): number {\n  const byte = privateKey[index];\n  assert(byte !== undefined, 'Private key is too short.');\n\n  return byte;\n}\n\n/**\n * Check if a private key is valid.\n *\n * @param privateKey - The private key to check.\n * @returns Whether the private key is valid.\n */\nexport const isValidPrivateKey = (privateKey: Uint8Array): boolean => {\n  /* eslint-disable no-bitwise */\n  // Lowest 3 bits of the first byte must be zero\n  if ((getByte(privateKey, 0) & 0b00000111) !== 0) {\n    return false;\n  }\n\n  // The highest bit of the last byte must be zero\n  if ((getByte(privateKey, 31) & 0b10000000) !== 0) {\n    return false;\n  }\n\n  // The second highest bit of the last byte must be one\n  if ((getByte(privateKey, 31) & 0b01000000) !== 0b01000000) {\n    return false;\n  }\n  /* eslint-enable no-bitwise */\n\n  return true;\n};\n\nexport const deriveUnhardenedKeys = true;\n\nexport const publicKeyLength = 32;\n\n/**\n * Converts a Uint8Array of bytes to a bigint in little-endian format.\n *\n * @param bytes - The Uint8Array of bytes to convert.\n * @returns The converted bigint value.\n */\nexport const bytesToNumberLE = (bytes: Uint8Array): bigint => {\n  return hexToBigInt(bytesToHex(Uint8Array.from(bytes).reverse()));\n};\n\n/**\n * Multiplies the given key with the base point on the Edwards curve.\n * equivalent to https://github.com/jedisct1/libsodium/blob/93a6e79750a31bc0b946bf483b2ba1c77f9e94ce/src/libsodium/crypto_scalarmult/ed25519/ref10/scalarmult_ed25519_ref10.c#L105 .\n * which is used by cardano-js-sdk/crypto https://github.com/input-output-hk/cardano-js-sdk/blob/8a6db2a251cd1c956f52730a0d35de2b7fc67404/packages/crypto/src/Bip32/Bip32PrivateKey.ts#L161 .\n *\n * @param key - The key to multiply with the base point.\n * @returns The resulting point on the Edwards curve.\n */\nexport const multiplyWithBase = (key: Uint8Array): Uint8Array => {\n  // Little-endian SHA512 with modulo n\n  const scalar = mod(bytesToNumberLE(key), curve.n); // The actual scalar\n  const point = ed25519.ExtendedPoint.BASE.multiply(scalar); // Point on Edwards curve aka public key\n  return point.toRawBytes(); // Uint8Array representation\n};\n\n/**\n * Calculates the public key corresponding to a given private key.\n *\n * @param privateKey - The private key.\n * @param _compressed - Optional parameter to indicate if the public key should be compressed.\n * @returns The public key.\n */\nexport const getPublicKey = async (\n  privateKey: Uint8Array,\n  _compressed?: boolean,\n): Promise<Uint8Array> => {\n  return multiplyWithBase(privateKey.slice(0, 32));\n};\n\n/**\n * Adds a tweak to a public key.\n *\n * @param publicKey - The public key.\n * @param tweak - The tweak to add.\n * @returns The resulting public key.\n */\nexport const publicAdd = (\n  publicKey: Uint8Array,\n  tweak: Uint8Array,\n): Uint8Array => {\n  return ed25519.ExtendedPoint.fromHex(remove0x(bytesToHex(publicKey)))\n    .add(ed25519.ExtendedPoint.fromHex(remove0x(bytesToHex(tweak))))\n    .toRawBytes();\n};\n\n/**\n * Compresses an Ed25519 public key.\n *\n * @param publicKey - The public key to compress.\n * @returns The compressed public key.\n */\nexport const compressPublicKey = (publicKey: Uint8Array): Uint8Array => {\n  // Ed25519 public keys don't have a compressed form.\n  return publicKey;\n};\n\n/**\n * Decompresses a compressed Ed25519Bip32 public key.\n *\n * @param publicKey - The compressed public key.\n * @returns The decompressed public key.\n */\nexport const decompressPublicKey = (publicKey: Uint8Array): Uint8Array => {\n  // Ed25519 public keys don't have a compressed form.\n  return publicKey;\n};\n\nexport const privateKeyLength = 64;\n\nexport const masterNodeGenerationSpec = 'cip3';\n\nexport const compressedPublicKeyLength = 32;\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/curves/secp256k1.cjs.map b/node_modules/@metamask/key-tree/dist/curves/secp256k1.cjs.map
index 70d3c29..844270c 100644
--- a/node_modules/@metamask/key-tree/dist/curves/secp256k1.cjs.map
+++ b/node_modules/@metamask/key-tree/dist/curves/secp256k1.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"secp256k1.cjs","sourceRoot":"","sources":["../../src/curves/secp256k1.ts"],"names":[],"mappings":";;;AAAA,2CAAwD;AACxD,uDAAoD;AAEpD,wCAA2C;AAE9B,QAAA,KAAK,GAAG,qBAAS,CAAC,KAAK,CAAC;AACxB,QAAA,IAAI,GAAG,WAAW,CAAC;AAEhC,2CAA2C;AAC3C,yHAAyH;AACzH,wHAAwH;AAC3G,QAAA,MAAM,GAAG,IAAA,qBAAa,EAAC,cAAc,CAAC,CAAC;AAEvC,QAAA,oBAAoB,GAAG,IAAI,CAAC;AAE5B,QAAA,eAAe,GAAG,EAAE,CAAC;AAE3B,MAAM,iBAAiB,GAAG,CAAC,UAAsB,EAAE,EAAE;IAC1D,OAAO,qBAAS,CAAC,KAAK,CAAC,iBAAiB,CAAC,UAAU,CAAC,CAAC;AACvD,CAAC,CAAC;AAFW,QAAA,iBAAiB,qBAE5B;AAEK,MAAM,YAAY,GAAG,CAC1B,UAAsB,EACtB,UAAU,GAAG,KAAK,EACN,EAAE,CAAC,qBAAS,CAAC,YAAY,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC;AAHnD,QAAA,YAAY,gBAGuC;AAEzD,MAAM,SAAS,GAAG,CACvB,SAAqB,EACrB,KAAiB,EACL,EAAE;IACd,IAAA,cAAM,EACJ,IAAA,uBAAe,EAAC,KAAK,EAAE,EAAE,CAAC,EAC1B,6DAA6D,CAC9D,CAAC;IAEF,MAAM,KAAK,GAAG,qBAAS,CAAC,eAAe,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;IAE3D,2DAA2D;IAC3D,uEAAuE;IACvE,uIAAuI;IACvI,MAAM,QAAQ,GAAG,KAAK,CAAC,GAAG,CAAC,qBAAS,CAAC,eAAe,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,CAAC;IAC5E,QAAQ,CAAC,cAAc,EAAE,CAAC;IAE1B,OAAO,QAAQ,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;AACpC,CAAC,CAAC;AAlBW,QAAA,SAAS,aAkBpB;AAEK,MAAM,iBAAiB,GAAG,CAAC,SAAqB,EAAc,EAAE;IACrE,MAAM,KAAK,GAAG,qBAAS,CAAC,eAAe,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;IAC3D,OAAO,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;AAChC,CAAC,CAAC;AAHW,QAAA,iBAAiB,qBAG5B;AAEK,MAAM,mBAAmB,GAAG,CAAC,SAAqB,EAAc,EAAE;IACvE,8FAA8F;IAC9F,0DAA0D;IAC1D,MAAM,KAAK,GAAG,qBAAS,CAAC,eAAe,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;IAC3D,OAAO,KAAK,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;AACjC,CAAC,CAAC;AALW,QAAA,mBAAmB,uBAK9B;AAEW,QAAA,gBAAgB,GAAG,EAAE,CAAC;AAEtB,QAAA,wBAAwB,GAAG,QAAQ,CAAC;AAEpC,QAAA,yBAAyB,GAAG,EAAE,CAAC","sourcesContent":["import { assert, stringToBytes } from '@metamask/utils';\nimport { secp256k1 } from '@noble/curves/secp256k1';\n\nimport { isValidBytesKey } from '../utils';\n\nexport const curve = secp256k1.CURVE;\nexport const name = 'secp256k1';\n\n// Secret is defined in BIP-32 and SLIP-10:\n// https://github.com/bitcoin/bips/blob/274fa400d630ba757bec0c03b35ebe2345197108/bip-0032.mediawiki#master-key-generation\n// https://github.com/satoshilabs/slips/blob/133ea52a8e43d338b98be208907e144277e44c0e/slip-0010.md#master-key-generation\nexport const secret = stringToBytes('Bitcoin seed');\n\nexport const deriveUnhardenedKeys = true;\n\nexport const publicKeyLength = 65;\n\nexport const isValidPrivateKey = (privateKey: Uint8Array) => {\n  return secp256k1.utils.isValidPrivateKey(privateKey);\n};\n\nexport const getPublicKey = (\n  privateKey: Uint8Array,\n  compressed = false,\n): Uint8Array => secp256k1.getPublicKey(privateKey, compressed);\n\nexport const publicAdd = (\n  publicKey: Uint8Array,\n  tweak: Uint8Array,\n): Uint8Array => {\n  assert(\n    isValidBytesKey(tweak, 32),\n    'Invalid tweak: Tweak must be a non-zero 32-byte Uint8Array.',\n  );\n\n  const point = secp256k1.ProjectivePoint.fromHex(publicKey);\n\n  // The returned child key Ki is point(parse256(IL)) + Kpar.\n  // This multiplies the tweak with the base point of the curve (Gx, Gy).\n  // https://github.com/bitcoin/bips/blob/274fa400d630ba757bec0c03b35ebe2345197108/bip-0032.mediawiki#public-parent-key--public-child-key\n  const newPoint = point.add(secp256k1.ProjectivePoint.fromPrivateKey(tweak));\n  newPoint.assertValidity();\n\n  return newPoint.toRawBytes(false);\n};\n\nexport const compressPublicKey = (publicKey: Uint8Array): Uint8Array => {\n  const point = secp256k1.ProjectivePoint.fromHex(publicKey);\n  return point.toRawBytes(true);\n};\n\nexport const decompressPublicKey = (publicKey: Uint8Array): Uint8Array => {\n  // This calculates a point on the elliptic curve from a compressed public key. We can then use\n  // this to get the uncompressed version of the public key.\n  const point = secp256k1.ProjectivePoint.fromHex(publicKey);\n  return point.toRawBytes(false);\n};\n\nexport const privateKeyLength = 32;\n\nexport const masterNodeGenerationSpec = 'slip10';\n\nexport const compressedPublicKeyLength = 33;\n"]}
\ No newline at end of file
+{"version":3,"file":"secp256k1.cjs","sourceRoot":"","sources":["../../src/curves/secp256k1.ts"],"names":[],"mappings":";;;AAAA,2CAAwD;AACxD,uDAAoD;AAEpD,wCAA2C;AAE9B,QAAA,KAAK,GAAG,qBAAS,CAAC,KAAK,CAAC;AACxB,QAAA,IAAI,GAAG,WAAW,CAAC;AAEhC,2CAA2C;AAC3C,yHAAyH;AACzH,wHAAwH;AAC3G,QAAA,MAAM,GAAG,IAAA,qBAAa,EAAC,cAAc,CAAC,CAAC;AAEvC,QAAA,oBAAoB,GAAG,IAAI,CAAC;AAE5B,QAAA,eAAe,GAAG,EAAE,CAAC;AAE3B,MAAM,iBAAiB,GAAG,CAAC,UAAsB,EAAW,EAAE;IACnE,OAAO,qBAAS,CAAC,KAAK,CAAC,iBAAiB,CAAC,UAAU,CAAC,CAAC;AACvD,CAAC,CAAC;AAFW,QAAA,iBAAiB,qBAE5B;AAEK,MAAM,YAAY,GAAG,CAC1B,UAAsB,EACtB,UAAU,GAAG,KAAK,EACN,EAAE,CAAC,qBAAS,CAAC,YAAY,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC;AAHnD,QAAA,YAAY,gBAGuC;AAEzD,MAAM,SAAS,GAAG,CACvB,SAAqB,EACrB,KAAiB,EACL,EAAE;IACd,IAAA,cAAM,EACJ,IAAA,uBAAe,EAAC,KAAK,EAAE,EAAE,CAAC,EAC1B,6DAA6D,CAC9D,CAAC;IAEF,MAAM,KAAK,GAAG,qBAAS,CAAC,eAAe,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;IAE3D,2DAA2D;IAC3D,uEAAuE;IACvE,uIAAuI;IACvI,MAAM,QAAQ,GAAG,KAAK,CAAC,GAAG,CAAC,qBAAS,CAAC,eAAe,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,CAAC;IAC5E,QAAQ,CAAC,cAAc,EAAE,CAAC;IAE1B,OAAO,QAAQ,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;AACpC,CAAC,CAAC;AAlBW,QAAA,SAAS,aAkBpB;AAEK,MAAM,iBAAiB,GAAG,CAAC,SAAqB,EAAc,EAAE;IACrE,MAAM,KAAK,GAAG,qBAAS,CAAC,eAAe,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;IAC3D,OAAO,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;AAChC,CAAC,CAAC;AAHW,QAAA,iBAAiB,qBAG5B;AAEK,MAAM,mBAAmB,GAAG,CAAC,SAAqB,EAAc,EAAE;IACvE,8FAA8F;IAC9F,0DAA0D;IAC1D,MAAM,KAAK,GAAG,qBAAS,CAAC,eAAe,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;IAC3D,OAAO,KAAK,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;AACjC,CAAC,CAAC;AALW,QAAA,mBAAmB,uBAK9B;AAEW,QAAA,gBAAgB,GAAG,EAAE,CAAC;AAEtB,QAAA,wBAAwB,GAAG,QAAQ,CAAC;AAEpC,QAAA,yBAAyB,GAAG,EAAE,CAAC","sourcesContent":["import { assert, stringToBytes } from '@metamask/utils';\nimport { secp256k1 } from '@noble/curves/secp256k1';\n\nimport { isValidBytesKey } from '../utils';\n\nexport const curve = secp256k1.CURVE;\nexport const name = 'secp256k1';\n\n// Secret is defined in BIP-32 and SLIP-10:\n// https://github.com/bitcoin/bips/blob/274fa400d630ba757bec0c03b35ebe2345197108/bip-0032.mediawiki#master-key-generation\n// https://github.com/satoshilabs/slips/blob/133ea52a8e43d338b98be208907e144277e44c0e/slip-0010.md#master-key-generation\nexport const secret = stringToBytes('Bitcoin seed');\n\nexport const deriveUnhardenedKeys = true;\n\nexport const publicKeyLength = 65;\n\nexport const isValidPrivateKey = (privateKey: Uint8Array): boolean => {\n  return secp256k1.utils.isValidPrivateKey(privateKey);\n};\n\nexport const getPublicKey = (\n  privateKey: Uint8Array,\n  compressed = false,\n): Uint8Array => secp256k1.getPublicKey(privateKey, compressed);\n\nexport const publicAdd = (\n  publicKey: Uint8Array,\n  tweak: Uint8Array,\n): Uint8Array => {\n  assert(\n    isValidBytesKey(tweak, 32),\n    'Invalid tweak: Tweak must be a non-zero 32-byte Uint8Array.',\n  );\n\n  const point = secp256k1.ProjectivePoint.fromHex(publicKey);\n\n  // The returned child key Ki is point(parse256(IL)) + Kpar.\n  // This multiplies the tweak with the base point of the curve (Gx, Gy).\n  // https://github.com/bitcoin/bips/blob/274fa400d630ba757bec0c03b35ebe2345197108/bip-0032.mediawiki#public-parent-key--public-child-key\n  const newPoint = point.add(secp256k1.ProjectivePoint.fromPrivateKey(tweak));\n  newPoint.assertValidity();\n\n  return newPoint.toRawBytes(false);\n};\n\nexport const compressPublicKey = (publicKey: Uint8Array): Uint8Array => {\n  const point = secp256k1.ProjectivePoint.fromHex(publicKey);\n  return point.toRawBytes(true);\n};\n\nexport const decompressPublicKey = (publicKey: Uint8Array): Uint8Array => {\n  // This calculates a point on the elliptic curve from a compressed public key. We can then use\n  // this to get the uncompressed version of the public key.\n  const point = secp256k1.ProjectivePoint.fromHex(publicKey);\n  return point.toRawBytes(false);\n};\n\nexport const privateKeyLength = 32;\n\nexport const masterNodeGenerationSpec = 'slip10';\n\nexport const compressedPublicKeyLength = 33;\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/curves/secp256k1.d.cts.map b/node_modules/@metamask/key-tree/dist/curves/secp256k1.d.cts.map
index d8ad677..248bfa2 100644
--- a/node_modules/@metamask/key-tree/dist/curves/secp256k1.d.cts.map
+++ b/node_modules/@metamask/key-tree/dist/curves/secp256k1.d.cts.map
@@ -1 +1 @@
-{"version":3,"file":"secp256k1.d.cts","sourceRoot":"","sources":["../../src/curves/secp256k1.ts"],"names":[],"mappings":"AAKA,eAAO,MAAM,KAAK;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAkB,CAAC;AACrC,eAAO,MAAM,IAAI,cAAc,CAAC;AAKhC,eAAO,MAAM,MAAM,YAAgC,CAAC;AAEpD,eAAO,MAAM,oBAAoB,OAAO,CAAC;AAEzC,eAAO,MAAM,eAAe,KAAK,CAAC;AAElC,eAAO,MAAM,iBAAiB,eAAgB,UAAU,YAEvD,CAAC;AAEF,eAAO,MAAM,YAAY,eACX,UAAU,2BAErB,UAA4D,CAAC;AAEhE,eAAO,MAAM,SAAS,cACT,UAAU,SACd,UAAU,KAChB,UAeF,CAAC;AAEF,eAAO,MAAM,iBAAiB,cAAe,UAAU,KAAG,UAGzD,CAAC;AAEF,eAAO,MAAM,mBAAmB,cAAe,UAAU,KAAG,UAK3D,CAAC;AAEF,eAAO,MAAM,gBAAgB,KAAK,CAAC;AAEnC,eAAO,MAAM,wBAAwB,WAAW,CAAC;AAEjD,eAAO,MAAM,yBAAyB,KAAK,CAAC"}
\ No newline at end of file
+{"version":3,"file":"secp256k1.d.cts","sourceRoot":"","sources":["../../src/curves/secp256k1.ts"],"names":[],"mappings":"AAKA,eAAO,MAAM,KAAK;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAkB,CAAC;AACrC,eAAO,MAAM,IAAI,cAAc,CAAC;AAKhC,eAAO,MAAM,MAAM,YAAgC,CAAC;AAEpD,eAAO,MAAM,oBAAoB,OAAO,CAAC;AAEzC,eAAO,MAAM,eAAe,KAAK,CAAC;AAElC,eAAO,MAAM,iBAAiB,eAAgB,UAAU,KAAG,OAE1D,CAAC;AAEF,eAAO,MAAM,YAAY,eACX,UAAU,2BAErB,UAA4D,CAAC;AAEhE,eAAO,MAAM,SAAS,cACT,UAAU,SACd,UAAU,KAChB,UAeF,CAAC;AAEF,eAAO,MAAM,iBAAiB,cAAe,UAAU,KAAG,UAGzD,CAAC;AAEF,eAAO,MAAM,mBAAmB,cAAe,UAAU,KAAG,UAK3D,CAAC;AAEF,eAAO,MAAM,gBAAgB,KAAK,CAAC;AAEnC,eAAO,MAAM,wBAAwB,WAAW,CAAC;AAEjD,eAAO,MAAM,yBAAyB,KAAK,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/curves/secp256k1.d.mts.map b/node_modules/@metamask/key-tree/dist/curves/secp256k1.d.mts.map
index 28b5b13..ddbb128 100644
--- a/node_modules/@metamask/key-tree/dist/curves/secp256k1.d.mts.map
+++ b/node_modules/@metamask/key-tree/dist/curves/secp256k1.d.mts.map
@@ -1 +1 @@
-{"version":3,"file":"secp256k1.d.mts","sourceRoot":"","sources":["../../src/curves/secp256k1.ts"],"names":[],"mappings":"AAKA,eAAO,MAAM,KAAK;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAkB,CAAC;AACrC,eAAO,MAAM,IAAI,cAAc,CAAC;AAKhC,eAAO,MAAM,MAAM,YAAgC,CAAC;AAEpD,eAAO,MAAM,oBAAoB,OAAO,CAAC;AAEzC,eAAO,MAAM,eAAe,KAAK,CAAC;AAElC,eAAO,MAAM,iBAAiB,eAAgB,UAAU,YAEvD,CAAC;AAEF,eAAO,MAAM,YAAY,eACX,UAAU,2BAErB,UAA4D,CAAC;AAEhE,eAAO,MAAM,SAAS,cACT,UAAU,SACd,UAAU,KAChB,UAeF,CAAC;AAEF,eAAO,MAAM,iBAAiB,cAAe,UAAU,KAAG,UAGzD,CAAC;AAEF,eAAO,MAAM,mBAAmB,cAAe,UAAU,KAAG,UAK3D,CAAC;AAEF,eAAO,MAAM,gBAAgB,KAAK,CAAC;AAEnC,eAAO,MAAM,wBAAwB,WAAW,CAAC;AAEjD,eAAO,MAAM,yBAAyB,KAAK,CAAC"}
\ No newline at end of file
+{"version":3,"file":"secp256k1.d.mts","sourceRoot":"","sources":["../../src/curves/secp256k1.ts"],"names":[],"mappings":"AAKA,eAAO,MAAM,KAAK;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAkB,CAAC;AACrC,eAAO,MAAM,IAAI,cAAc,CAAC;AAKhC,eAAO,MAAM,MAAM,YAAgC,CAAC;AAEpD,eAAO,MAAM,oBAAoB,OAAO,CAAC;AAEzC,eAAO,MAAM,eAAe,KAAK,CAAC;AAElC,eAAO,MAAM,iBAAiB,eAAgB,UAAU,KAAG,OAE1D,CAAC;AAEF,eAAO,MAAM,YAAY,eACX,UAAU,2BAErB,UAA4D,CAAC;AAEhE,eAAO,MAAM,SAAS,cACT,UAAU,SACd,UAAU,KAChB,UAeF,CAAC;AAEF,eAAO,MAAM,iBAAiB,cAAe,UAAU,KAAG,UAGzD,CAAC;AAEF,eAAO,MAAM,mBAAmB,cAAe,UAAU,KAAG,UAK3D,CAAC;AAEF,eAAO,MAAM,gBAAgB,KAAK,CAAC;AAEnC,eAAO,MAAM,wBAAwB,WAAW,CAAC;AAEjD,eAAO,MAAM,yBAAyB,KAAK,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/curves/secp256k1.mjs.map b/node_modules/@metamask/key-tree/dist/curves/secp256k1.mjs.map
index d5fdc38..fa4bf48 100644
--- a/node_modules/@metamask/key-tree/dist/curves/secp256k1.mjs.map
+++ b/node_modules/@metamask/key-tree/dist/curves/secp256k1.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"secp256k1.mjs","sourceRoot":"","sources":["../../src/curves/secp256k1.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,MAAM,EAAE,aAAa,EAAE,wBAAwB;AACxD,OAAO,EAAE,SAAS,EAAE,gCAAgC;AAEpD,OAAO,EAAE,eAAe,EAAE,qBAAiB;AAE3C,MAAM,CAAC,MAAM,KAAK,GAAG,SAAS,CAAC,KAAK,CAAC;AACrC,MAAM,CAAC,MAAM,IAAI,GAAG,WAAW,CAAC;AAEhC,2CAA2C;AAC3C,yHAAyH;AACzH,wHAAwH;AACxH,MAAM,CAAC,MAAM,MAAM,GAAG,aAAa,CAAC,cAAc,CAAC,CAAC;AAEpD,MAAM,CAAC,MAAM,oBAAoB,GAAG,IAAI,CAAC;AAEzC,MAAM,CAAC,MAAM,eAAe,GAAG,EAAE,CAAC;AAElC,MAAM,CAAC,MAAM,iBAAiB,GAAG,CAAC,UAAsB,EAAE,EAAE;IAC1D,OAAO,SAAS,CAAC,KAAK,CAAC,iBAAiB,CAAC,UAAU,CAAC,CAAC;AACvD,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,YAAY,GAAG,CAC1B,UAAsB,EACtB,UAAU,GAAG,KAAK,EACN,EAAE,CAAC,SAAS,CAAC,YAAY,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC;AAEhE,MAAM,CAAC,MAAM,SAAS,GAAG,CACvB,SAAqB,EACrB,KAAiB,EACL,EAAE;IACd,MAAM,CACJ,eAAe,CAAC,KAAK,EAAE,EAAE,CAAC,EAC1B,6DAA6D,CAC9D,CAAC;IAEF,MAAM,KAAK,GAAG,SAAS,CAAC,eAAe,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;IAE3D,2DAA2D;IAC3D,uEAAuE;IACvE,uIAAuI;IACvI,MAAM,QAAQ,GAAG,KAAK,CAAC,GAAG,CAAC,SAAS,CAAC,eAAe,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,CAAC;IAC5E,QAAQ,CAAC,cAAc,EAAE,CAAC;IAE1B,OAAO,QAAQ,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;AACpC,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,iBAAiB,GAAG,CAAC,SAAqB,EAAc,EAAE;IACrE,MAAM,KAAK,GAAG,SAAS,CAAC,eAAe,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;IAC3D,OAAO,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;AAChC,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,mBAAmB,GAAG,CAAC,SAAqB,EAAc,EAAE;IACvE,8FAA8F;IAC9F,0DAA0D;IAC1D,MAAM,KAAK,GAAG,SAAS,CAAC,eAAe,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;IAC3D,OAAO,KAAK,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;AACjC,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,gBAAgB,GAAG,EAAE,CAAC;AAEnC,MAAM,CAAC,MAAM,wBAAwB,GAAG,QAAQ,CAAC;AAEjD,MAAM,CAAC,MAAM,yBAAyB,GAAG,EAAE,CAAC","sourcesContent":["import { assert, stringToBytes } from '@metamask/utils';\nimport { secp256k1 } from '@noble/curves/secp256k1';\n\nimport { isValidBytesKey } from '../utils';\n\nexport const curve = secp256k1.CURVE;\nexport const name = 'secp256k1';\n\n// Secret is defined in BIP-32 and SLIP-10:\n// https://github.com/bitcoin/bips/blob/274fa400d630ba757bec0c03b35ebe2345197108/bip-0032.mediawiki#master-key-generation\n// https://github.com/satoshilabs/slips/blob/133ea52a8e43d338b98be208907e144277e44c0e/slip-0010.md#master-key-generation\nexport const secret = stringToBytes('Bitcoin seed');\n\nexport const deriveUnhardenedKeys = true;\n\nexport const publicKeyLength = 65;\n\nexport const isValidPrivateKey = (privateKey: Uint8Array) => {\n  return secp256k1.utils.isValidPrivateKey(privateKey);\n};\n\nexport const getPublicKey = (\n  privateKey: Uint8Array,\n  compressed = false,\n): Uint8Array => secp256k1.getPublicKey(privateKey, compressed);\n\nexport const publicAdd = (\n  publicKey: Uint8Array,\n  tweak: Uint8Array,\n): Uint8Array => {\n  assert(\n    isValidBytesKey(tweak, 32),\n    'Invalid tweak: Tweak must be a non-zero 32-byte Uint8Array.',\n  );\n\n  const point = secp256k1.ProjectivePoint.fromHex(publicKey);\n\n  // The returned child key Ki is point(parse256(IL)) + Kpar.\n  // This multiplies the tweak with the base point of the curve (Gx, Gy).\n  // https://github.com/bitcoin/bips/blob/274fa400d630ba757bec0c03b35ebe2345197108/bip-0032.mediawiki#public-parent-key--public-child-key\n  const newPoint = point.add(secp256k1.ProjectivePoint.fromPrivateKey(tweak));\n  newPoint.assertValidity();\n\n  return newPoint.toRawBytes(false);\n};\n\nexport const compressPublicKey = (publicKey: Uint8Array): Uint8Array => {\n  const point = secp256k1.ProjectivePoint.fromHex(publicKey);\n  return point.toRawBytes(true);\n};\n\nexport const decompressPublicKey = (publicKey: Uint8Array): Uint8Array => {\n  // This calculates a point on the elliptic curve from a compressed public key. We can then use\n  // this to get the uncompressed version of the public key.\n  const point = secp256k1.ProjectivePoint.fromHex(publicKey);\n  return point.toRawBytes(false);\n};\n\nexport const privateKeyLength = 32;\n\nexport const masterNodeGenerationSpec = 'slip10';\n\nexport const compressedPublicKeyLength = 33;\n"]}
\ No newline at end of file
+{"version":3,"file":"secp256k1.mjs","sourceRoot":"","sources":["../../src/curves/secp256k1.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,MAAM,EAAE,aAAa,EAAE,wBAAwB;AACxD,OAAO,EAAE,SAAS,EAAE,gCAAgC;AAEpD,OAAO,EAAE,eAAe,EAAE,qBAAiB;AAE3C,MAAM,CAAC,MAAM,KAAK,GAAG,SAAS,CAAC,KAAK,CAAC;AACrC,MAAM,CAAC,MAAM,IAAI,GAAG,WAAW,CAAC;AAEhC,2CAA2C;AAC3C,yHAAyH;AACzH,wHAAwH;AACxH,MAAM,CAAC,MAAM,MAAM,GAAG,aAAa,CAAC,cAAc,CAAC,CAAC;AAEpD,MAAM,CAAC,MAAM,oBAAoB,GAAG,IAAI,CAAC;AAEzC,MAAM,CAAC,MAAM,eAAe,GAAG,EAAE,CAAC;AAElC,MAAM,CAAC,MAAM,iBAAiB,GAAG,CAAC,UAAsB,EAAW,EAAE;IACnE,OAAO,SAAS,CAAC,KAAK,CAAC,iBAAiB,CAAC,UAAU,CAAC,CAAC;AACvD,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,YAAY,GAAG,CAC1B,UAAsB,EACtB,UAAU,GAAG,KAAK,EACN,EAAE,CAAC,SAAS,CAAC,YAAY,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC;AAEhE,MAAM,CAAC,MAAM,SAAS,GAAG,CACvB,SAAqB,EACrB,KAAiB,EACL,EAAE;IACd,MAAM,CACJ,eAAe,CAAC,KAAK,EAAE,EAAE,CAAC,EAC1B,6DAA6D,CAC9D,CAAC;IAEF,MAAM,KAAK,GAAG,SAAS,CAAC,eAAe,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;IAE3D,2DAA2D;IAC3D,uEAAuE;IACvE,uIAAuI;IACvI,MAAM,QAAQ,GAAG,KAAK,CAAC,GAAG,CAAC,SAAS,CAAC,eAAe,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,CAAC;IAC5E,QAAQ,CAAC,cAAc,EAAE,CAAC;IAE1B,OAAO,QAAQ,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;AACpC,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,iBAAiB,GAAG,CAAC,SAAqB,EAAc,EAAE;IACrE,MAAM,KAAK,GAAG,SAAS,CAAC,eAAe,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;IAC3D,OAAO,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;AAChC,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,mBAAmB,GAAG,CAAC,SAAqB,EAAc,EAAE;IACvE,8FAA8F;IAC9F,0DAA0D;IAC1D,MAAM,KAAK,GAAG,SAAS,CAAC,eAAe,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;IAC3D,OAAO,KAAK,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;AACjC,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,gBAAgB,GAAG,EAAE,CAAC;AAEnC,MAAM,CAAC,MAAM,wBAAwB,GAAG,QAAQ,CAAC;AAEjD,MAAM,CAAC,MAAM,yBAAyB,GAAG,EAAE,CAAC","sourcesContent":["import { assert, stringToBytes } from '@metamask/utils';\nimport { secp256k1 } from '@noble/curves/secp256k1';\n\nimport { isValidBytesKey } from '../utils';\n\nexport const curve = secp256k1.CURVE;\nexport const name = 'secp256k1';\n\n// Secret is defined in BIP-32 and SLIP-10:\n// https://github.com/bitcoin/bips/blob/274fa400d630ba757bec0c03b35ebe2345197108/bip-0032.mediawiki#master-key-generation\n// https://github.com/satoshilabs/slips/blob/133ea52a8e43d338b98be208907e144277e44c0e/slip-0010.md#master-key-generation\nexport const secret = stringToBytes('Bitcoin seed');\n\nexport const deriveUnhardenedKeys = true;\n\nexport const publicKeyLength = 65;\n\nexport const isValidPrivateKey = (privateKey: Uint8Array): boolean => {\n  return secp256k1.utils.isValidPrivateKey(privateKey);\n};\n\nexport const getPublicKey = (\n  privateKey: Uint8Array,\n  compressed = false,\n): Uint8Array => secp256k1.getPublicKey(privateKey, compressed);\n\nexport const publicAdd = (\n  publicKey: Uint8Array,\n  tweak: Uint8Array,\n): Uint8Array => {\n  assert(\n    isValidBytesKey(tweak, 32),\n    'Invalid tweak: Tweak must be a non-zero 32-byte Uint8Array.',\n  );\n\n  const point = secp256k1.ProjectivePoint.fromHex(publicKey);\n\n  // The returned child key Ki is point(parse256(IL)) + Kpar.\n  // This multiplies the tweak with the base point of the curve (Gx, Gy).\n  // https://github.com/bitcoin/bips/blob/274fa400d630ba757bec0c03b35ebe2345197108/bip-0032.mediawiki#public-parent-key--public-child-key\n  const newPoint = point.add(secp256k1.ProjectivePoint.fromPrivateKey(tweak));\n  newPoint.assertValidity();\n\n  return newPoint.toRawBytes(false);\n};\n\nexport const compressPublicKey = (publicKey: Uint8Array): Uint8Array => {\n  const point = secp256k1.ProjectivePoint.fromHex(publicKey);\n  return point.toRawBytes(true);\n};\n\nexport const decompressPublicKey = (publicKey: Uint8Array): Uint8Array => {\n  // This calculates a point on the elliptic curve from a compressed public key. We can then use\n  // this to get the uncompressed version of the public key.\n  const point = secp256k1.ProjectivePoint.fromHex(publicKey);\n  return point.toRawBytes(false);\n};\n\nexport const privateKeyLength = 32;\n\nexport const masterNodeGenerationSpec = 'slip10';\n\nexport const compressedPublicKeyLength = 33;\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/derivation.cjs b/node_modules/@metamask/key-tree/dist/derivation.cjs
index d4cfa3a..96f497f 100644
--- a/node_modules/@metamask/key-tree/dist/derivation.cjs
+++ b/node_modules/@metamask/key-tree/dist/derivation.cjs
@@ -26,9 +26,11 @@ const SLIP10Node_1 = require("./SLIP10Node.cjs");
  * BIP-39 seed phrases must be lowercase, space-delimited, and 12-24 words long.
  * @param args.node - The node to derive from.
  * @param args.depth - The depth of the segment.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The derived key.
  */
-async function deriveKeyFromPath(args) {
+async function deriveKeyFromPath(args, cryptographicFunctions) {
     const { path, depth = path.length } = args;
     const node = 'node' in args ? args.node : undefined;
     const curve = 'curve' in args ? args.curve : node?.curve;
@@ -57,7 +59,7 @@ async function deriveKeyFromPath(args) {
                 path: pathPart,
                 node: derivedNode,
                 curve: (0, curves_1.getCurveByName)(curve),
-            });
+            }, cryptographicFunctions);
         }
         // Only the first path segment can be a Uint8Array.
         (0, utils_1.assert)(index === 0, getMalformedError());
@@ -65,7 +67,7 @@ async function deriveKeyFromPath(args) {
             path: pathNode,
             node: derivedNode,
             curve: (0, curves_1.getCurveByName)(curve),
-        });
+        }, cryptographicFunctions);
     }, Promise.resolve(node));
 }
 exports.deriveKeyFromPath = deriveKeyFromPath;
diff --git a/node_modules/@metamask/key-tree/dist/derivation.cjs.map b/node_modules/@metamask/key-tree/dist/derivation.cjs.map
index 63f787d..fa58631 100644
--- a/node_modules/@metamask/key-tree/dist/derivation.cjs.map
+++ b/node_modules/@metamask/key-tree/dist/derivation.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"derivation.cjs","sourceRoot":"","sources":["../src/derivation.ts"],"names":[],"mappings":"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","sourcesContent":["import { assert } from '@metamask/utils';\n\nimport { BIP44CoinTypeNode } from './BIP44CoinTypeNode';\nimport { BIP44Node } from './BIP44Node';\nimport type { SLIP10Path } from './constants';\nimport {\n  BIP_32_PATH_REGEX,\n  BIP_39_PATH_REGEX,\n  MIN_BIP_44_DEPTH,\n  SLIP_10_PATH_REGEX,\n  CIP_3_PATH_REGEX,\n} from './constants';\nimport type { SupportedCurve } from './curves';\nimport { getCurveByName } from './curves';\nimport type { Deriver } from './derivers';\nimport { derivers } from './derivers';\nimport { SLIP10Node } from './SLIP10Node';\n\n/**\n * Ethereum default seed path: \"m/44'/60'/0'/0/{account_index}\"\n * Multipath: \"bip32:44'/bip32:60'/bip32:0'/bip32:0/bip32:{account_index}\"\n *\n * m: { privateKey, chainCode } = sha512Hmac(\"Bitcoin seed\", masterSeed)\n * 44': { privateKey, chainCode } = parentKey.privateKey + sha512Hmac(parentKey.chainCode, [0x00, parentKey.privateKey, index + HARDENED_OFFSET])\n * 60': { privateKey, chainCode } = parentKey.privateKey + sha512Hmac(parentKey.chainCode, [0x00, parentKey.privateKey, index + HARDENED_OFFSET])\n * 0': { privateKey, chainCode } = parentKey.privateKey + sha512Hmac(parentKey.chainCode, [0x00, parentKey.privateKey, index + HARDENED_OFFSET])\n * 0: { privateKey, chainCode } = parentKey.privateKey + sha512Hmac(parentKey.chainCode, [parentKey.publicKey, index])\n * 0: { privateKey, chainCode } = parentKey.privateKey + sha512Hmac(parentKey.chainCode, [parentKey.publicKey, index])\n */\n\ntype BaseDeriveKeyFromPathArgs = {\n  path: SLIP10Path;\n  depth?: number;\n};\n\ntype DeriveKeyFromPathNodeArgs = BaseDeriveKeyFromPathArgs & {\n  node?: SLIP10Node | BIP44Node | BIP44CoinTypeNode;\n};\n\ntype DeriveKeyFromPathCurveArgs = BaseDeriveKeyFromPathArgs & {\n  curve: SupportedCurve;\n};\n\ntype DeriveKeyFromPathArgs =\n  | DeriveKeyFromPathNodeArgs\n  | DeriveKeyFromPathCurveArgs;\n\n/**\n * Takes a full or partial HD path string and returns the key corresponding to\n * the given path, with the following constraints:\n *\n * - If the path starts with a BIP-32 node, a parent key must be provided.\n * - If the path starts with a BIP-39 node, a parent key must NOT be provided.\n * - The path cannot exceed 5 BIP-32 nodes in length, optionally preceded by\n * a single BIP-39 node.\n *\n * WARNING: It is the consumer's responsibility to ensure that the path is valid\n * relative to its parent key.\n *\n * @param args - The arguments for deriving a key from a path.\n * @param args.path - A full or partial HD path, e.g.:\n * `bip39:SEED_PHRASE/bip32:44'/bip32:60'/bip32:0'/bip32:0/bip32:0`.\n * BIP-39 seed phrases must be lowercase, space-delimited, and 12-24 words long.\n * @param args.node - The node to derive from.\n * @param args.depth - The depth of the segment.\n * @returns The derived key.\n */\nexport async function deriveKeyFromPath(\n  args: DeriveKeyFromPathArgs,\n): Promise<SLIP10Node> {\n  const { path, depth = path.length } = args;\n\n  const node = 'node' in args ? args.node : undefined;\n  const curve = 'curve' in args ? args.curve : node?.curve;\n\n  if (\n    node &&\n    !(node instanceof SLIP10Node) &&\n    !(node instanceof BIP44Node) &&\n    !(node instanceof BIP44CoinTypeNode)\n  ) {\n    throw new Error(\n      'Invalid arguments: Node must be a SLIP-10 node or a BIP-44 node when provided.',\n    );\n  }\n\n  if (!curve) {\n    throw new Error(\n      'Invalid arguments: Must specify either a parent node or curve.',\n    );\n  }\n\n  validatePathSegment(\n    path,\n    Boolean(node?.privateKey) || Boolean(node?.publicKey),\n    depth,\n  );\n\n  // Derive through each part of path. `pathSegment` needs to be cast because\n  // `HDPathTuple.reduce()` doesn't work. Note that the first element of the\n  // path can be a Uint8Array.\n  return await (path as readonly [Uint8Array | string, ...string[]]).reduce<\n    Promise<SLIP10Node>\n  >(async (promise, pathNode, index) => {\n    const derivedNode = await promise;\n\n    if (typeof pathNode === 'string') {\n      const [pathType, pathPart] = pathNode.split(':');\n\n      assert(pathType);\n      assert(pathPart);\n      assert(hasDeriver(pathType), `Unknown derivation type: \"${pathType}\".`);\n\n      const deriver = derivers[pathType] as Deriver;\n      return await deriver.deriveChildKey({\n        path: pathPart,\n        node: derivedNode,\n        curve: getCurveByName(curve),\n      });\n    }\n\n    // Only the first path segment can be a Uint8Array.\n    assert(index === 0, getMalformedError());\n\n    return await derivers.bip39.deriveChildKey({\n      path: pathNode,\n      node: derivedNode,\n      curve: getCurveByName(curve),\n    });\n  }, Promise.resolve(node as SLIP10Node));\n}\n\n/**\n * Check if the given path type is a valid deriver.\n *\n * @param pathType - The path type to check.\n * @returns Whether the path type is a valid deriver.\n */\nfunction hasDeriver(pathType: string): pathType is keyof typeof derivers {\n  return pathType in derivers;\n}\n\n/**\n * The path segment must be one of the following:\n * - A lone BIP-32 path node.\n * - A lone BIP-39 path node.\n * - A multipath.\n *\n * @param path - The path segment string to validate.\n * @param hasKey - Whether the path segment has a key.\n * @param depth - The depth of the segment.\n */\nexport function validatePathSegment(\n  path: SLIP10Path,\n  hasKey: boolean,\n  depth?: number,\n) {\n  if ((path as any).length === 0) {\n    throw new Error(`Invalid HD path segment: The segment must not be empty.`);\n  }\n\n  let startsWithBip39 = false;\n  path.forEach((node, index) => {\n    if (index === 0) {\n      startsWithBip39 =\n        node instanceof Uint8Array || BIP_39_PATH_REGEX.test(node);\n\n      if (\n        // TypeScript is unable to infer that `node` is a string here, so we\n        // need to explicitly check it again.\n        !(node instanceof Uint8Array) &&\n        !startsWithBip39 &&\n        !BIP_32_PATH_REGEX.test(node) &&\n        !SLIP_10_PATH_REGEX.test(node) &&\n        !CIP_3_PATH_REGEX.test(node)\n      ) {\n        throw getMalformedError();\n      }\n    } else if (\n      node instanceof Uint8Array ||\n      (!BIP_32_PATH_REGEX.test(node) &&\n        !SLIP_10_PATH_REGEX.test(node) &&\n        !CIP_3_PATH_REGEX.test(node))\n    ) {\n      throw getMalformedError();\n    }\n  });\n\n  if (depth === MIN_BIP_44_DEPTH && (!startsWithBip39 || path.length !== 1)) {\n    throw new Error(\n      `Invalid HD path segment: The segment must consist of a single BIP-39 node for depths of ${MIN_BIP_44_DEPTH}. Received: \"${String(\n        path,\n      )}\".`,\n    );\n  }\n\n  if (!hasKey && !startsWithBip39) {\n    throw new Error(\n      'Invalid derivation parameters: Must specify parent key if the first node of the path segment is not a BIP-39 node.',\n    );\n  }\n\n  if (hasKey && startsWithBip39) {\n    throw new Error(\n      'Invalid derivation parameters: May not specify parent key if the path segment starts with a BIP-39 node.',\n    );\n  }\n\n  const pathWithoutKey = (startsWithBip39 ? path.slice(1) : path) as string[];\n  if (pathWithoutKey.length > 0) {\n    const firstSegmentType = pathWithoutKey[0]?.split(':')[0];\n    assert(firstSegmentType);\n    assert(\n      pathWithoutKey.every((segment) =>\n        segment.startsWith(`${firstSegmentType}:`),\n      ),\n      `Invalid HD path segment: Cannot mix 'bip32' and 'slip10' path segments.`,\n    );\n  }\n}\n\n/**\n * Get the error for a malformed path segment.\n *\n * @returns The error.\n */\nfunction getMalformedError() {\n  return new Error('Invalid HD path segment: The path segment is malformed.');\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"derivation.cjs","sourceRoot":"","sources":["../src/derivation.ts"],"names":[],"mappings":"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","sourcesContent":["import { assert } from '@metamask/utils';\n\nimport { BIP44CoinTypeNode } from './BIP44CoinTypeNode';\nimport { BIP44Node } from './BIP44Node';\nimport type { SLIP10Path } from './constants';\nimport {\n  BIP_32_PATH_REGEX,\n  BIP_39_PATH_REGEX,\n  MIN_BIP_44_DEPTH,\n  SLIP_10_PATH_REGEX,\n  CIP_3_PATH_REGEX,\n} from './constants';\nimport type { CryptographicFunctions } from './cryptography';\nimport type { SupportedCurve } from './curves';\nimport { getCurveByName } from './curves';\nimport type { Deriver } from './derivers';\nimport { derivers } from './derivers';\nimport { SLIP10Node } from './SLIP10Node';\n\n/**\n * Ethereum default seed path: \"m/44'/60'/0'/0/{account_index}\"\n * Multipath: \"bip32:44'/bip32:60'/bip32:0'/bip32:0/bip32:{account_index}\"\n *\n * m: { privateKey, chainCode } = sha512Hmac(\"Bitcoin seed\", masterSeed)\n * 44': { privateKey, chainCode } = parentKey.privateKey + sha512Hmac(parentKey.chainCode, [0x00, parentKey.privateKey, index + HARDENED_OFFSET])\n * 60': { privateKey, chainCode } = parentKey.privateKey + sha512Hmac(parentKey.chainCode, [0x00, parentKey.privateKey, index + HARDENED_OFFSET])\n * 0': { privateKey, chainCode } = parentKey.privateKey + sha512Hmac(parentKey.chainCode, [0x00, parentKey.privateKey, index + HARDENED_OFFSET])\n * 0: { privateKey, chainCode } = parentKey.privateKey + sha512Hmac(parentKey.chainCode, [parentKey.publicKey, index])\n * 0: { privateKey, chainCode } = parentKey.privateKey + sha512Hmac(parentKey.chainCode, [parentKey.publicKey, index])\n */\n\ntype BaseDeriveKeyFromPathArgs = {\n  path: SLIP10Path;\n  depth?: number;\n};\n\ntype DeriveKeyFromPathNodeArgs = BaseDeriveKeyFromPathArgs & {\n  node?: SLIP10Node | BIP44Node | BIP44CoinTypeNode;\n};\n\ntype DeriveKeyFromPathCurveArgs = BaseDeriveKeyFromPathArgs & {\n  curve: SupportedCurve;\n};\n\ntype DeriveKeyFromPathArgs =\n  | DeriveKeyFromPathNodeArgs\n  | DeriveKeyFromPathCurveArgs;\n\n/**\n * Takes a full or partial HD path string and returns the key corresponding to\n * the given path, with the following constraints:\n *\n * - If the path starts with a BIP-32 node, a parent key must be provided.\n * - If the path starts with a BIP-39 node, a parent key must NOT be provided.\n * - The path cannot exceed 5 BIP-32 nodes in length, optionally preceded by\n * a single BIP-39 node.\n *\n * WARNING: It is the consumer's responsibility to ensure that the path is valid\n * relative to its parent key.\n *\n * @param args - The arguments for deriving a key from a path.\n * @param args.path - A full or partial HD path, e.g.:\n * `bip39:SEED_PHRASE/bip32:44'/bip32:60'/bip32:0'/bip32:0/bip32:0`.\n * BIP-39 seed phrases must be lowercase, space-delimited, and 12-24 words long.\n * @param args.node - The node to derive from.\n * @param args.depth - The depth of the segment.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The derived key.\n */\nexport async function deriveKeyFromPath(\n  args: DeriveKeyFromPathArgs,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<SLIP10Node> {\n  const { path, depth = path.length } = args;\n\n  const node = 'node' in args ? args.node : undefined;\n  const curve = 'curve' in args ? args.curve : node?.curve;\n\n  if (\n    node &&\n    !(node instanceof SLIP10Node) &&\n    !(node instanceof BIP44Node) &&\n    !(node instanceof BIP44CoinTypeNode)\n  ) {\n    throw new Error(\n      'Invalid arguments: Node must be a SLIP-10 node or a BIP-44 node when provided.',\n    );\n  }\n\n  if (!curve) {\n    throw new Error(\n      'Invalid arguments: Must specify either a parent node or curve.',\n    );\n  }\n\n  validatePathSegment(\n    path,\n    Boolean(node?.privateKey) || Boolean(node?.publicKey),\n    depth,\n  );\n\n  // Derive through each part of path. `pathSegment` needs to be cast because\n  // `HDPathTuple.reduce()` doesn't work. Note that the first element of the\n  // path can be a Uint8Array.\n  return await (path as readonly [Uint8Array | string, ...string[]]).reduce<\n    Promise<SLIP10Node>\n  >(\n    async (promise, pathNode, index) => {\n      const derivedNode = await promise;\n\n      if (typeof pathNode === 'string') {\n        const [pathType, pathPart] = pathNode.split(':');\n\n        assert(pathType);\n        assert(pathPart);\n        assert(hasDeriver(pathType), `Unknown derivation type: \"${pathType}\".`);\n\n        const deriver = derivers[pathType] as Deriver;\n        return await deriver.deriveChildKey(\n          {\n            path: pathPart,\n            node: derivedNode,\n            curve: getCurveByName(curve),\n          },\n          cryptographicFunctions,\n        );\n      }\n\n      // Only the first path segment can be a Uint8Array.\n      assert(index === 0, getMalformedError());\n\n      return await derivers.bip39.deriveChildKey(\n        {\n          path: pathNode,\n          node: derivedNode,\n          curve: getCurveByName(curve),\n        },\n        cryptographicFunctions,\n      );\n    },\n    Promise.resolve(node as SLIP10Node),\n  );\n}\n\n/**\n * Check if the given path type is a valid deriver.\n *\n * @param pathType - The path type to check.\n * @returns Whether the path type is a valid deriver.\n */\nfunction hasDeriver(pathType: string): pathType is keyof typeof derivers {\n  return pathType in derivers;\n}\n\n/**\n * The path segment must be one of the following:\n * - A lone BIP-32 path node.\n * - A lone BIP-39 path node.\n * - A multipath.\n *\n * @param path - The path segment string to validate.\n * @param hasKey - Whether the path segment has a key.\n * @param depth - The depth of the segment.\n */\nexport function validatePathSegment(\n  path: SLIP10Path,\n  hasKey: boolean,\n  depth?: number,\n): void {\n  if ((path as any).length === 0) {\n    throw new Error(`Invalid HD path segment: The segment must not be empty.`);\n  }\n\n  let startsWithBip39 = false;\n  path.forEach((node, index) => {\n    if (index === 0) {\n      startsWithBip39 =\n        node instanceof Uint8Array || BIP_39_PATH_REGEX.test(node);\n\n      if (\n        // TypeScript is unable to infer that `node` is a string here, so we\n        // need to explicitly check it again.\n        !(node instanceof Uint8Array) &&\n        !startsWithBip39 &&\n        !BIP_32_PATH_REGEX.test(node) &&\n        !SLIP_10_PATH_REGEX.test(node) &&\n        !CIP_3_PATH_REGEX.test(node)\n      ) {\n        throw getMalformedError();\n      }\n    } else if (\n      node instanceof Uint8Array ||\n      (!BIP_32_PATH_REGEX.test(node) &&\n        !SLIP_10_PATH_REGEX.test(node) &&\n        !CIP_3_PATH_REGEX.test(node))\n    ) {\n      throw getMalformedError();\n    }\n  });\n\n  if (depth === MIN_BIP_44_DEPTH && (!startsWithBip39 || path.length !== 1)) {\n    throw new Error(\n      `Invalid HD path segment: The segment must consist of a single BIP-39 node for depths of ${MIN_BIP_44_DEPTH}. Received: \"${String(\n        path,\n      )}\".`,\n    );\n  }\n\n  if (!hasKey && !startsWithBip39) {\n    throw new Error(\n      'Invalid derivation parameters: Must specify parent key if the first node of the path segment is not a BIP-39 node.',\n    );\n  }\n\n  if (hasKey && startsWithBip39) {\n    throw new Error(\n      'Invalid derivation parameters: May not specify parent key if the path segment starts with a BIP-39 node.',\n    );\n  }\n\n  const pathWithoutKey = (startsWithBip39 ? path.slice(1) : path) as string[];\n  if (pathWithoutKey.length > 0) {\n    const firstSegmentType = pathWithoutKey[0]?.split(':')[0];\n    assert(firstSegmentType);\n    assert(\n      pathWithoutKey.every((segment) =>\n        segment.startsWith(`${firstSegmentType}:`),\n      ),\n      `Invalid HD path segment: Cannot mix 'bip32' and 'slip10' path segments.`,\n    );\n  }\n}\n\n/**\n * Get the error for a malformed path segment.\n *\n * @returns The error.\n */\nfunction getMalformedError(): Error {\n  return new Error('Invalid HD path segment: The path segment is malformed.');\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/derivation.d.cts b/node_modules/@metamask/key-tree/dist/derivation.d.cts
index 6e1a814..e9228ce 100644
--- a/node_modules/@metamask/key-tree/dist/derivation.d.cts
+++ b/node_modules/@metamask/key-tree/dist/derivation.d.cts
@@ -1,6 +1,7 @@
 import { BIP44CoinTypeNode } from "./BIP44CoinTypeNode.cjs";
 import { BIP44Node } from "./BIP44Node.cjs";
 import type { SLIP10Path } from "./constants.cjs";
+import type { CryptographicFunctions } from "./cryptography.cjs";
 import type { SupportedCurve } from "./curves/index.cjs";
 import { SLIP10Node } from "./SLIP10Node.cjs";
 /**
@@ -14,17 +15,17 @@ import { SLIP10Node } from "./SLIP10Node.cjs";
  * 0: { privateKey, chainCode } = parentKey.privateKey + sha512Hmac(parentKey.chainCode, [parentKey.publicKey, index])
  * 0: { privateKey, chainCode } = parentKey.privateKey + sha512Hmac(parentKey.chainCode, [parentKey.publicKey, index])
  */
-declare type BaseDeriveKeyFromPathArgs = {
+type BaseDeriveKeyFromPathArgs = {
     path: SLIP10Path;
     depth?: number;
 };
-declare type DeriveKeyFromPathNodeArgs = BaseDeriveKeyFromPathArgs & {
+type DeriveKeyFromPathNodeArgs = BaseDeriveKeyFromPathArgs & {
     node?: SLIP10Node | BIP44Node | BIP44CoinTypeNode;
 };
-declare type DeriveKeyFromPathCurveArgs = BaseDeriveKeyFromPathArgs & {
+type DeriveKeyFromPathCurveArgs = BaseDeriveKeyFromPathArgs & {
     curve: SupportedCurve;
 };
-declare type DeriveKeyFromPathArgs = DeriveKeyFromPathNodeArgs | DeriveKeyFromPathCurveArgs;
+type DeriveKeyFromPathArgs = DeriveKeyFromPathNodeArgs | DeriveKeyFromPathCurveArgs;
 /**
  * Takes a full or partial HD path string and returns the key corresponding to
  * the given path, with the following constraints:
@@ -43,9 +44,11 @@ declare type DeriveKeyFromPathArgs = DeriveKeyFromPathNodeArgs | DeriveKeyFromPa
  * BIP-39 seed phrases must be lowercase, space-delimited, and 12-24 words long.
  * @param args.node - The node to derive from.
  * @param args.depth - The depth of the segment.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The derived key.
  */
-export declare function deriveKeyFromPath(args: DeriveKeyFromPathArgs): Promise<SLIP10Node>;
+export declare function deriveKeyFromPath(args: DeriveKeyFromPathArgs, cryptographicFunctions?: CryptographicFunctions): Promise<SLIP10Node>;
 /**
  * The path segment must be one of the following:
  * - A lone BIP-32 path node.
diff --git a/node_modules/@metamask/key-tree/dist/derivation.d.cts.map b/node_modules/@metamask/key-tree/dist/derivation.d.cts.map
index ea8139f..16bf634 100644
--- a/node_modules/@metamask/key-tree/dist/derivation.d.cts.map
+++ b/node_modules/@metamask/key-tree/dist/derivation.d.cts.map
@@ -1 +1 @@
-{"version":3,"file":"derivation.d.cts","sourceRoot":"","sources":["../src/derivation.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,iBAAiB,EAAE,gCAA4B;AACxD,OAAO,EAAE,SAAS,EAAE,wBAAoB;AACxC,OAAO,KAAK,EAAE,UAAU,EAAE,wBAAoB;AAQ9C,OAAO,KAAK,EAAE,cAAc,EAAE,2BAAiB;AAI/C,OAAO,EAAE,UAAU,EAAE,yBAAqB;AAE1C;;;;;;;;;;GAUG;AAEH,aAAK,yBAAyB,GAAG;IAC/B,IAAI,EAAE,UAAU,CAAC;IACjB,KAAK,CAAC,EAAE,MAAM,CAAC;CAChB,CAAC;AAEF,aAAK,yBAAyB,GAAG,yBAAyB,GAAG;IAC3D,IAAI,CAAC,EAAE,UAAU,GAAG,SAAS,GAAG,iBAAiB,CAAC;CACnD,CAAC;AAEF,aAAK,0BAA0B,GAAG,yBAAyB,GAAG;IAC5D,KAAK,EAAE,cAAc,CAAC;CACvB,CAAC;AAEF,aAAK,qBAAqB,GACtB,yBAAyB,GACzB,0BAA0B,CAAC;AAE/B;;;;;;;;;;;;;;;;;;;GAmBG;AACH,wBAAsB,iBAAiB,CACrC,IAAI,EAAE,qBAAqB,GAC1B,OAAO,CAAC,UAAU,CAAC,CA6DrB;AAYD;;;;;;;;;GASG;AACH,wBAAgB,mBAAmB,CACjC,IAAI,EAAE,UAAU,EAChB,MAAM,EAAE,OAAO,EACf,KAAK,CAAC,EAAE,MAAM,QAgEf"}
\ No newline at end of file
+{"version":3,"file":"derivation.d.cts","sourceRoot":"","sources":["../src/derivation.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,iBAAiB,EAAE,gCAA4B;AACxD,OAAO,EAAE,SAAS,EAAE,wBAAoB;AACxC,OAAO,KAAK,EAAE,UAAU,EAAE,wBAAoB;AAQ9C,OAAO,KAAK,EAAE,sBAAsB,EAAE,2BAAuB;AAC7D,OAAO,KAAK,EAAE,cAAc,EAAE,2BAAiB;AAI/C,OAAO,EAAE,UAAU,EAAE,yBAAqB;AAE1C;;;;;;;;;;GAUG;AAEH,KAAK,yBAAyB,GAAG;IAC/B,IAAI,EAAE,UAAU,CAAC;IACjB,KAAK,CAAC,EAAE,MAAM,CAAC;CAChB,CAAC;AAEF,KAAK,yBAAyB,GAAG,yBAAyB,GAAG;IAC3D,IAAI,CAAC,EAAE,UAAU,GAAG,SAAS,GAAG,iBAAiB,CAAC;CACnD,CAAC;AAEF,KAAK,0BAA0B,GAAG,yBAAyB,GAAG;IAC5D,KAAK,EAAE,cAAc,CAAC;CACvB,CAAC;AAEF,KAAK,qBAAqB,GACtB,yBAAyB,GACzB,0BAA0B,CAAC;AAE/B;;;;;;;;;;;;;;;;;;;;;GAqBG;AACH,wBAAsB,iBAAiB,CACrC,IAAI,EAAE,qBAAqB,EAC3B,sBAAsB,CAAC,EAAE,sBAAsB,GAC9C,OAAO,CAAC,UAAU,CAAC,CAsErB;AAYD;;;;;;;;;GASG;AACH,wBAAgB,mBAAmB,CACjC,IAAI,EAAE,UAAU,EAChB,MAAM,EAAE,OAAO,EACf,KAAK,CAAC,EAAE,MAAM,GACb,IAAI,CA+DN"}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/derivation.d.mts b/node_modules/@metamask/key-tree/dist/derivation.d.mts
index f264482..345fe57 100644
--- a/node_modules/@metamask/key-tree/dist/derivation.d.mts
+++ b/node_modules/@metamask/key-tree/dist/derivation.d.mts
@@ -1,6 +1,7 @@
 import { BIP44CoinTypeNode } from "./BIP44CoinTypeNode.mjs";
 import { BIP44Node } from "./BIP44Node.mjs";
 import type { SLIP10Path } from "./constants.mjs";
+import type { CryptographicFunctions } from "./cryptography.mjs";
 import type { SupportedCurve } from "./curves/index.mjs";
 import { SLIP10Node } from "./SLIP10Node.mjs";
 /**
@@ -14,17 +15,17 @@ import { SLIP10Node } from "./SLIP10Node.mjs";
  * 0: { privateKey, chainCode } = parentKey.privateKey + sha512Hmac(parentKey.chainCode, [parentKey.publicKey, index])
  * 0: { privateKey, chainCode } = parentKey.privateKey + sha512Hmac(parentKey.chainCode, [parentKey.publicKey, index])
  */
-declare type BaseDeriveKeyFromPathArgs = {
+type BaseDeriveKeyFromPathArgs = {
     path: SLIP10Path;
     depth?: number;
 };
-declare type DeriveKeyFromPathNodeArgs = BaseDeriveKeyFromPathArgs & {
+type DeriveKeyFromPathNodeArgs = BaseDeriveKeyFromPathArgs & {
     node?: SLIP10Node | BIP44Node | BIP44CoinTypeNode;
 };
-declare type DeriveKeyFromPathCurveArgs = BaseDeriveKeyFromPathArgs & {
+type DeriveKeyFromPathCurveArgs = BaseDeriveKeyFromPathArgs & {
     curve: SupportedCurve;
 };
-declare type DeriveKeyFromPathArgs = DeriveKeyFromPathNodeArgs | DeriveKeyFromPathCurveArgs;
+type DeriveKeyFromPathArgs = DeriveKeyFromPathNodeArgs | DeriveKeyFromPathCurveArgs;
 /**
  * Takes a full or partial HD path string and returns the key corresponding to
  * the given path, with the following constraints:
@@ -43,9 +44,11 @@ declare type DeriveKeyFromPathArgs = DeriveKeyFromPathNodeArgs | DeriveKeyFromPa
  * BIP-39 seed phrases must be lowercase, space-delimited, and 12-24 words long.
  * @param args.node - The node to derive from.
  * @param args.depth - The depth of the segment.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The derived key.
  */
-export declare function deriveKeyFromPath(args: DeriveKeyFromPathArgs): Promise<SLIP10Node>;
+export declare function deriveKeyFromPath(args: DeriveKeyFromPathArgs, cryptographicFunctions?: CryptographicFunctions): Promise<SLIP10Node>;
 /**
  * The path segment must be one of the following:
  * - A lone BIP-32 path node.
diff --git a/node_modules/@metamask/key-tree/dist/derivation.d.mts.map b/node_modules/@metamask/key-tree/dist/derivation.d.mts.map
index 2013299..409fcd2 100644
--- a/node_modules/@metamask/key-tree/dist/derivation.d.mts.map
+++ b/node_modules/@metamask/key-tree/dist/derivation.d.mts.map
@@ -1 +1 @@
-{"version":3,"file":"derivation.d.mts","sourceRoot":"","sources":["../src/derivation.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,iBAAiB,EAAE,gCAA4B;AACxD,OAAO,EAAE,SAAS,EAAE,wBAAoB;AACxC,OAAO,KAAK,EAAE,UAAU,EAAE,wBAAoB;AAQ9C,OAAO,KAAK,EAAE,cAAc,EAAE,2BAAiB;AAI/C,OAAO,EAAE,UAAU,EAAE,yBAAqB;AAE1C;;;;;;;;;;GAUG;AAEH,aAAK,yBAAyB,GAAG;IAC/B,IAAI,EAAE,UAAU,CAAC;IACjB,KAAK,CAAC,EAAE,MAAM,CAAC;CAChB,CAAC;AAEF,aAAK,yBAAyB,GAAG,yBAAyB,GAAG;IAC3D,IAAI,CAAC,EAAE,UAAU,GAAG,SAAS,GAAG,iBAAiB,CAAC;CACnD,CAAC;AAEF,aAAK,0BAA0B,GAAG,yBAAyB,GAAG;IAC5D,KAAK,EAAE,cAAc,CAAC;CACvB,CAAC;AAEF,aAAK,qBAAqB,GACtB,yBAAyB,GACzB,0BAA0B,CAAC;AAE/B;;;;;;;;;;;;;;;;;;;GAmBG;AACH,wBAAsB,iBAAiB,CACrC,IAAI,EAAE,qBAAqB,GAC1B,OAAO,CAAC,UAAU,CAAC,CA6DrB;AAYD;;;;;;;;;GASG;AACH,wBAAgB,mBAAmB,CACjC,IAAI,EAAE,UAAU,EAChB,MAAM,EAAE,OAAO,EACf,KAAK,CAAC,EAAE,MAAM,QAgEf"}
\ No newline at end of file
+{"version":3,"file":"derivation.d.mts","sourceRoot":"","sources":["../src/derivation.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,iBAAiB,EAAE,gCAA4B;AACxD,OAAO,EAAE,SAAS,EAAE,wBAAoB;AACxC,OAAO,KAAK,EAAE,UAAU,EAAE,wBAAoB;AAQ9C,OAAO,KAAK,EAAE,sBAAsB,EAAE,2BAAuB;AAC7D,OAAO,KAAK,EAAE,cAAc,EAAE,2BAAiB;AAI/C,OAAO,EAAE,UAAU,EAAE,yBAAqB;AAE1C;;;;;;;;;;GAUG;AAEH,KAAK,yBAAyB,GAAG;IAC/B,IAAI,EAAE,UAAU,CAAC;IACjB,KAAK,CAAC,EAAE,MAAM,CAAC;CAChB,CAAC;AAEF,KAAK,yBAAyB,GAAG,yBAAyB,GAAG;IAC3D,IAAI,CAAC,EAAE,UAAU,GAAG,SAAS,GAAG,iBAAiB,CAAC;CACnD,CAAC;AAEF,KAAK,0BAA0B,GAAG,yBAAyB,GAAG;IAC5D,KAAK,EAAE,cAAc,CAAC;CACvB,CAAC;AAEF,KAAK,qBAAqB,GACtB,yBAAyB,GACzB,0BAA0B,CAAC;AAE/B;;;;;;;;;;;;;;;;;;;;;GAqBG;AACH,wBAAsB,iBAAiB,CACrC,IAAI,EAAE,qBAAqB,EAC3B,sBAAsB,CAAC,EAAE,sBAAsB,GAC9C,OAAO,CAAC,UAAU,CAAC,CAsErB;AAYD;;;;;;;;;GASG;AACH,wBAAgB,mBAAmB,CACjC,IAAI,EAAE,UAAU,EAChB,MAAM,EAAE,OAAO,EACf,KAAK,CAAC,EAAE,MAAM,GACb,IAAI,CA+DN"}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/derivation.mjs b/node_modules/@metamask/key-tree/dist/derivation.mjs
index bf716b0..2e20c81 100644
--- a/node_modules/@metamask/key-tree/dist/derivation.mjs
+++ b/node_modules/@metamask/key-tree/dist/derivation.mjs
@@ -23,9 +23,11 @@ import { SLIP10Node } from "./SLIP10Node.mjs";
  * BIP-39 seed phrases must be lowercase, space-delimited, and 12-24 words long.
  * @param args.node - The node to derive from.
  * @param args.depth - The depth of the segment.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The derived key.
  */
-export async function deriveKeyFromPath(args) {
+export async function deriveKeyFromPath(args, cryptographicFunctions) {
     const { path, depth = path.length } = args;
     const node = 'node' in args ? args.node : undefined;
     const curve = 'curve' in args ? args.curve : node?.curve;
@@ -54,7 +56,7 @@ export async function deriveKeyFromPath(args) {
                 path: pathPart,
                 node: derivedNode,
                 curve: getCurveByName(curve),
-            });
+            }, cryptographicFunctions);
         }
         // Only the first path segment can be a Uint8Array.
         assert(index === 0, getMalformedError());
@@ -62,7 +64,7 @@ export async function deriveKeyFromPath(args) {
             path: pathNode,
             node: derivedNode,
             curve: getCurveByName(curve),
-        });
+        }, cryptographicFunctions);
     }, Promise.resolve(node));
 }
 /**
diff --git a/node_modules/@metamask/key-tree/dist/derivation.mjs.map b/node_modules/@metamask/key-tree/dist/derivation.mjs.map
index 97dedb8..93c22d0 100644
--- a/node_modules/@metamask/key-tree/dist/derivation.mjs.map
+++ b/node_modules/@metamask/key-tree/dist/derivation.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"derivation.mjs","sourceRoot":"","sources":["../src/derivation.ts"],"names":[],"mappings":"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","sourcesContent":["import { assert } from '@metamask/utils';\n\nimport { BIP44CoinTypeNode } from './BIP44CoinTypeNode';\nimport { BIP44Node } from './BIP44Node';\nimport type { SLIP10Path } from './constants';\nimport {\n  BIP_32_PATH_REGEX,\n  BIP_39_PATH_REGEX,\n  MIN_BIP_44_DEPTH,\n  SLIP_10_PATH_REGEX,\n  CIP_3_PATH_REGEX,\n} from './constants';\nimport type { SupportedCurve } from './curves';\nimport { getCurveByName } from './curves';\nimport type { Deriver } from './derivers';\nimport { derivers } from './derivers';\nimport { SLIP10Node } from './SLIP10Node';\n\n/**\n * Ethereum default seed path: \"m/44'/60'/0'/0/{account_index}\"\n * Multipath: \"bip32:44'/bip32:60'/bip32:0'/bip32:0/bip32:{account_index}\"\n *\n * m: { privateKey, chainCode } = sha512Hmac(\"Bitcoin seed\", masterSeed)\n * 44': { privateKey, chainCode } = parentKey.privateKey + sha512Hmac(parentKey.chainCode, [0x00, parentKey.privateKey, index + HARDENED_OFFSET])\n * 60': { privateKey, chainCode } = parentKey.privateKey + sha512Hmac(parentKey.chainCode, [0x00, parentKey.privateKey, index + HARDENED_OFFSET])\n * 0': { privateKey, chainCode } = parentKey.privateKey + sha512Hmac(parentKey.chainCode, [0x00, parentKey.privateKey, index + HARDENED_OFFSET])\n * 0: { privateKey, chainCode } = parentKey.privateKey + sha512Hmac(parentKey.chainCode, [parentKey.publicKey, index])\n * 0: { privateKey, chainCode } = parentKey.privateKey + sha512Hmac(parentKey.chainCode, [parentKey.publicKey, index])\n */\n\ntype BaseDeriveKeyFromPathArgs = {\n  path: SLIP10Path;\n  depth?: number;\n};\n\ntype DeriveKeyFromPathNodeArgs = BaseDeriveKeyFromPathArgs & {\n  node?: SLIP10Node | BIP44Node | BIP44CoinTypeNode;\n};\n\ntype DeriveKeyFromPathCurveArgs = BaseDeriveKeyFromPathArgs & {\n  curve: SupportedCurve;\n};\n\ntype DeriveKeyFromPathArgs =\n  | DeriveKeyFromPathNodeArgs\n  | DeriveKeyFromPathCurveArgs;\n\n/**\n * Takes a full or partial HD path string and returns the key corresponding to\n * the given path, with the following constraints:\n *\n * - If the path starts with a BIP-32 node, a parent key must be provided.\n * - If the path starts with a BIP-39 node, a parent key must NOT be provided.\n * - The path cannot exceed 5 BIP-32 nodes in length, optionally preceded by\n * a single BIP-39 node.\n *\n * WARNING: It is the consumer's responsibility to ensure that the path is valid\n * relative to its parent key.\n *\n * @param args - The arguments for deriving a key from a path.\n * @param args.path - A full or partial HD path, e.g.:\n * `bip39:SEED_PHRASE/bip32:44'/bip32:60'/bip32:0'/bip32:0/bip32:0`.\n * BIP-39 seed phrases must be lowercase, space-delimited, and 12-24 words long.\n * @param args.node - The node to derive from.\n * @param args.depth - The depth of the segment.\n * @returns The derived key.\n */\nexport async function deriveKeyFromPath(\n  args: DeriveKeyFromPathArgs,\n): Promise<SLIP10Node> {\n  const { path, depth = path.length } = args;\n\n  const node = 'node' in args ? args.node : undefined;\n  const curve = 'curve' in args ? args.curve : node?.curve;\n\n  if (\n    node &&\n    !(node instanceof SLIP10Node) &&\n    !(node instanceof BIP44Node) &&\n    !(node instanceof BIP44CoinTypeNode)\n  ) {\n    throw new Error(\n      'Invalid arguments: Node must be a SLIP-10 node or a BIP-44 node when provided.',\n    );\n  }\n\n  if (!curve) {\n    throw new Error(\n      'Invalid arguments: Must specify either a parent node or curve.',\n    );\n  }\n\n  validatePathSegment(\n    path,\n    Boolean(node?.privateKey) || Boolean(node?.publicKey),\n    depth,\n  );\n\n  // Derive through each part of path. `pathSegment` needs to be cast because\n  // `HDPathTuple.reduce()` doesn't work. Note that the first element of the\n  // path can be a Uint8Array.\n  return await (path as readonly [Uint8Array | string, ...string[]]).reduce<\n    Promise<SLIP10Node>\n  >(async (promise, pathNode, index) => {\n    const derivedNode = await promise;\n\n    if (typeof pathNode === 'string') {\n      const [pathType, pathPart] = pathNode.split(':');\n\n      assert(pathType);\n      assert(pathPart);\n      assert(hasDeriver(pathType), `Unknown derivation type: \"${pathType}\".`);\n\n      const deriver = derivers[pathType] as Deriver;\n      return await deriver.deriveChildKey({\n        path: pathPart,\n        node: derivedNode,\n        curve: getCurveByName(curve),\n      });\n    }\n\n    // Only the first path segment can be a Uint8Array.\n    assert(index === 0, getMalformedError());\n\n    return await derivers.bip39.deriveChildKey({\n      path: pathNode,\n      node: derivedNode,\n      curve: getCurveByName(curve),\n    });\n  }, Promise.resolve(node as SLIP10Node));\n}\n\n/**\n * Check if the given path type is a valid deriver.\n *\n * @param pathType - The path type to check.\n * @returns Whether the path type is a valid deriver.\n */\nfunction hasDeriver(pathType: string): pathType is keyof typeof derivers {\n  return pathType in derivers;\n}\n\n/**\n * The path segment must be one of the following:\n * - A lone BIP-32 path node.\n * - A lone BIP-39 path node.\n * - A multipath.\n *\n * @param path - The path segment string to validate.\n * @param hasKey - Whether the path segment has a key.\n * @param depth - The depth of the segment.\n */\nexport function validatePathSegment(\n  path: SLIP10Path,\n  hasKey: boolean,\n  depth?: number,\n) {\n  if ((path as any).length === 0) {\n    throw new Error(`Invalid HD path segment: The segment must not be empty.`);\n  }\n\n  let startsWithBip39 = false;\n  path.forEach((node, index) => {\n    if (index === 0) {\n      startsWithBip39 =\n        node instanceof Uint8Array || BIP_39_PATH_REGEX.test(node);\n\n      if (\n        // TypeScript is unable to infer that `node` is a string here, so we\n        // need to explicitly check it again.\n        !(node instanceof Uint8Array) &&\n        !startsWithBip39 &&\n        !BIP_32_PATH_REGEX.test(node) &&\n        !SLIP_10_PATH_REGEX.test(node) &&\n        !CIP_3_PATH_REGEX.test(node)\n      ) {\n        throw getMalformedError();\n      }\n    } else if (\n      node instanceof Uint8Array ||\n      (!BIP_32_PATH_REGEX.test(node) &&\n        !SLIP_10_PATH_REGEX.test(node) &&\n        !CIP_3_PATH_REGEX.test(node))\n    ) {\n      throw getMalformedError();\n    }\n  });\n\n  if (depth === MIN_BIP_44_DEPTH && (!startsWithBip39 || path.length !== 1)) {\n    throw new Error(\n      `Invalid HD path segment: The segment must consist of a single BIP-39 node for depths of ${MIN_BIP_44_DEPTH}. Received: \"${String(\n        path,\n      )}\".`,\n    );\n  }\n\n  if (!hasKey && !startsWithBip39) {\n    throw new Error(\n      'Invalid derivation parameters: Must specify parent key if the first node of the path segment is not a BIP-39 node.',\n    );\n  }\n\n  if (hasKey && startsWithBip39) {\n    throw new Error(\n      'Invalid derivation parameters: May not specify parent key if the path segment starts with a BIP-39 node.',\n    );\n  }\n\n  const pathWithoutKey = (startsWithBip39 ? path.slice(1) : path) as string[];\n  if (pathWithoutKey.length > 0) {\n    const firstSegmentType = pathWithoutKey[0]?.split(':')[0];\n    assert(firstSegmentType);\n    assert(\n      pathWithoutKey.every((segment) =>\n        segment.startsWith(`${firstSegmentType}:`),\n      ),\n      `Invalid HD path segment: Cannot mix 'bip32' and 'slip10' path segments.`,\n    );\n  }\n}\n\n/**\n * Get the error for a malformed path segment.\n *\n * @returns The error.\n */\nfunction getMalformedError() {\n  return new Error('Invalid HD path segment: The path segment is malformed.');\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"derivation.mjs","sourceRoot":"","sources":["../src/derivation.ts"],"names":[],"mappings":"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","sourcesContent":["import { assert } from '@metamask/utils';\n\nimport { BIP44CoinTypeNode } from './BIP44CoinTypeNode';\nimport { BIP44Node } from './BIP44Node';\nimport type { SLIP10Path } from './constants';\nimport {\n  BIP_32_PATH_REGEX,\n  BIP_39_PATH_REGEX,\n  MIN_BIP_44_DEPTH,\n  SLIP_10_PATH_REGEX,\n  CIP_3_PATH_REGEX,\n} from './constants';\nimport type { CryptographicFunctions } from './cryptography';\nimport type { SupportedCurve } from './curves';\nimport { getCurveByName } from './curves';\nimport type { Deriver } from './derivers';\nimport { derivers } from './derivers';\nimport { SLIP10Node } from './SLIP10Node';\n\n/**\n * Ethereum default seed path: \"m/44'/60'/0'/0/{account_index}\"\n * Multipath: \"bip32:44'/bip32:60'/bip32:0'/bip32:0/bip32:{account_index}\"\n *\n * m: { privateKey, chainCode } = sha512Hmac(\"Bitcoin seed\", masterSeed)\n * 44': { privateKey, chainCode } = parentKey.privateKey + sha512Hmac(parentKey.chainCode, [0x00, parentKey.privateKey, index + HARDENED_OFFSET])\n * 60': { privateKey, chainCode } = parentKey.privateKey + sha512Hmac(parentKey.chainCode, [0x00, parentKey.privateKey, index + HARDENED_OFFSET])\n * 0': { privateKey, chainCode } = parentKey.privateKey + sha512Hmac(parentKey.chainCode, [0x00, parentKey.privateKey, index + HARDENED_OFFSET])\n * 0: { privateKey, chainCode } = parentKey.privateKey + sha512Hmac(parentKey.chainCode, [parentKey.publicKey, index])\n * 0: { privateKey, chainCode } = parentKey.privateKey + sha512Hmac(parentKey.chainCode, [parentKey.publicKey, index])\n */\n\ntype BaseDeriveKeyFromPathArgs = {\n  path: SLIP10Path;\n  depth?: number;\n};\n\ntype DeriveKeyFromPathNodeArgs = BaseDeriveKeyFromPathArgs & {\n  node?: SLIP10Node | BIP44Node | BIP44CoinTypeNode;\n};\n\ntype DeriveKeyFromPathCurveArgs = BaseDeriveKeyFromPathArgs & {\n  curve: SupportedCurve;\n};\n\ntype DeriveKeyFromPathArgs =\n  | DeriveKeyFromPathNodeArgs\n  | DeriveKeyFromPathCurveArgs;\n\n/**\n * Takes a full or partial HD path string and returns the key corresponding to\n * the given path, with the following constraints:\n *\n * - If the path starts with a BIP-32 node, a parent key must be provided.\n * - If the path starts with a BIP-39 node, a parent key must NOT be provided.\n * - The path cannot exceed 5 BIP-32 nodes in length, optionally preceded by\n * a single BIP-39 node.\n *\n * WARNING: It is the consumer's responsibility to ensure that the path is valid\n * relative to its parent key.\n *\n * @param args - The arguments for deriving a key from a path.\n * @param args.path - A full or partial HD path, e.g.:\n * `bip39:SEED_PHRASE/bip32:44'/bip32:60'/bip32:0'/bip32:0/bip32:0`.\n * BIP-39 seed phrases must be lowercase, space-delimited, and 12-24 words long.\n * @param args.node - The node to derive from.\n * @param args.depth - The depth of the segment.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The derived key.\n */\nexport async function deriveKeyFromPath(\n  args: DeriveKeyFromPathArgs,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<SLIP10Node> {\n  const { path, depth = path.length } = args;\n\n  const node = 'node' in args ? args.node : undefined;\n  const curve = 'curve' in args ? args.curve : node?.curve;\n\n  if (\n    node &&\n    !(node instanceof SLIP10Node) &&\n    !(node instanceof BIP44Node) &&\n    !(node instanceof BIP44CoinTypeNode)\n  ) {\n    throw new Error(\n      'Invalid arguments: Node must be a SLIP-10 node or a BIP-44 node when provided.',\n    );\n  }\n\n  if (!curve) {\n    throw new Error(\n      'Invalid arguments: Must specify either a parent node or curve.',\n    );\n  }\n\n  validatePathSegment(\n    path,\n    Boolean(node?.privateKey) || Boolean(node?.publicKey),\n    depth,\n  );\n\n  // Derive through each part of path. `pathSegment` needs to be cast because\n  // `HDPathTuple.reduce()` doesn't work. Note that the first element of the\n  // path can be a Uint8Array.\n  return await (path as readonly [Uint8Array | string, ...string[]]).reduce<\n    Promise<SLIP10Node>\n  >(\n    async (promise, pathNode, index) => {\n      const derivedNode = await promise;\n\n      if (typeof pathNode === 'string') {\n        const [pathType, pathPart] = pathNode.split(':');\n\n        assert(pathType);\n        assert(pathPart);\n        assert(hasDeriver(pathType), `Unknown derivation type: \"${pathType}\".`);\n\n        const deriver = derivers[pathType] as Deriver;\n        return await deriver.deriveChildKey(\n          {\n            path: pathPart,\n            node: derivedNode,\n            curve: getCurveByName(curve),\n          },\n          cryptographicFunctions,\n        );\n      }\n\n      // Only the first path segment can be a Uint8Array.\n      assert(index === 0, getMalformedError());\n\n      return await derivers.bip39.deriveChildKey(\n        {\n          path: pathNode,\n          node: derivedNode,\n          curve: getCurveByName(curve),\n        },\n        cryptographicFunctions,\n      );\n    },\n    Promise.resolve(node as SLIP10Node),\n  );\n}\n\n/**\n * Check if the given path type is a valid deriver.\n *\n * @param pathType - The path type to check.\n * @returns Whether the path type is a valid deriver.\n */\nfunction hasDeriver(pathType: string): pathType is keyof typeof derivers {\n  return pathType in derivers;\n}\n\n/**\n * The path segment must be one of the following:\n * - A lone BIP-32 path node.\n * - A lone BIP-39 path node.\n * - A multipath.\n *\n * @param path - The path segment string to validate.\n * @param hasKey - Whether the path segment has a key.\n * @param depth - The depth of the segment.\n */\nexport function validatePathSegment(\n  path: SLIP10Path,\n  hasKey: boolean,\n  depth?: number,\n): void {\n  if ((path as any).length === 0) {\n    throw new Error(`Invalid HD path segment: The segment must not be empty.`);\n  }\n\n  let startsWithBip39 = false;\n  path.forEach((node, index) => {\n    if (index === 0) {\n      startsWithBip39 =\n        node instanceof Uint8Array || BIP_39_PATH_REGEX.test(node);\n\n      if (\n        // TypeScript is unable to infer that `node` is a string here, so we\n        // need to explicitly check it again.\n        !(node instanceof Uint8Array) &&\n        !startsWithBip39 &&\n        !BIP_32_PATH_REGEX.test(node) &&\n        !SLIP_10_PATH_REGEX.test(node) &&\n        !CIP_3_PATH_REGEX.test(node)\n      ) {\n        throw getMalformedError();\n      }\n    } else if (\n      node instanceof Uint8Array ||\n      (!BIP_32_PATH_REGEX.test(node) &&\n        !SLIP_10_PATH_REGEX.test(node) &&\n        !CIP_3_PATH_REGEX.test(node))\n    ) {\n      throw getMalformedError();\n    }\n  });\n\n  if (depth === MIN_BIP_44_DEPTH && (!startsWithBip39 || path.length !== 1)) {\n    throw new Error(\n      `Invalid HD path segment: The segment must consist of a single BIP-39 node for depths of ${MIN_BIP_44_DEPTH}. Received: \"${String(\n        path,\n      )}\".`,\n    );\n  }\n\n  if (!hasKey && !startsWithBip39) {\n    throw new Error(\n      'Invalid derivation parameters: Must specify parent key if the first node of the path segment is not a BIP-39 node.',\n    );\n  }\n\n  if (hasKey && startsWithBip39) {\n    throw new Error(\n      'Invalid derivation parameters: May not specify parent key if the path segment starts with a BIP-39 node.',\n    );\n  }\n\n  const pathWithoutKey = (startsWithBip39 ? path.slice(1) : path) as string[];\n  if (pathWithoutKey.length > 0) {\n    const firstSegmentType = pathWithoutKey[0]?.split(':')[0];\n    assert(firstSegmentType);\n    assert(\n      pathWithoutKey.every((segment) =>\n        segment.startsWith(`${firstSegmentType}:`),\n      ),\n      `Invalid HD path segment: Cannot mix 'bip32' and 'slip10' path segments.`,\n    );\n  }\n}\n\n/**\n * Get the error for a malformed path segment.\n *\n * @returns The error.\n */\nfunction getMalformedError(): Error {\n  return new Error('Invalid HD path segment: The path segment is malformed.');\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/derivers/bip32.cjs b/node_modules/@metamask/key-tree/dist/derivers/bip32.cjs
index a2d9b2b..1dab193 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/bip32.cjs
+++ b/node_modules/@metamask/key-tree/dist/derivers/bip32.cjs
@@ -2,11 +2,11 @@
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.deriveChildKey = exports.publicKeyToEthAddress = exports.privateKeyToEthAddress = void 0;
 const utils_1 = require("@metamask/utils");
-const sha3_1 = require("@noble/hashes/sha3");
+const shared_1 = require("./shared.cjs");
 const constants_1 = require("../constants.cjs");
+const cryptography_1 = require("../cryptography.cjs");
 const curves_1 = require("../curves/index.cjs");
 const utils_2 = require("../utils.cjs");
-const shared_1 = require("./shared.cjs");
 /**
  * Converts a BIP-32 private key to an Ethereum address.
  *
@@ -38,7 +38,7 @@ exports.privateKeyToEthAddress = privateKeyToEthAddress;
 function publicKeyToEthAddress(key) {
     (0, utils_1.assert)(key instanceof Uint8Array &&
         (0, utils_2.isValidBytesKey)(key, curves_1.secp256k1.publicKeyLength), 'Invalid key: The key must be a 65-byte, non-zero Uint8Array.');
-    return (0, sha3_1.keccak_256)(key.slice(1)).slice(-20);
+    return (0, cryptography_1.keccak256)(key.slice(1)).slice(-20);
 }
 exports.publicKeyToEthAddress = publicKeyToEthAddress;
 /**
@@ -48,11 +48,13 @@ exports.publicKeyToEthAddress = publicKeyToEthAddress;
  * @param options.path - The derivation path part to derive.
  * @param options.node - The node to derive from.
  * @param options.curve - The curve to use for derivation.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The derived child key as a {@link SLIP10Node}.
  */
-async function deriveChildKey(options) {
+async function deriveChildKey(options, cryptographicFunctions) {
     (0, utils_1.assert)(options.curve.name === 'secp256k1', 'Invalid curve: Only secp256k1 is supported by BIP-32.');
-    return (0, shared_1.deriveChildKey)(options, handleError);
+    return (0, shared_1.deriveChildKey)(options, handleError, cryptographicFunctions);
 }
 exports.deriveChildKey = deriveChildKey;
 /**
@@ -61,10 +63,12 @@ exports.deriveChildKey = deriveChildKey;
  *
  * @param _ - The error that was thrown.
  * @param options - The options for deriving a child key.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The options for deriving a child key with the child index
  * incremented by one.
  */
-async function handleError(_, options) {
+async function handleError(_, options, cryptographicFunctions) {
     const { childIndex, privateKey, publicKey, isHardened, curve, chainCode } = options;
     (0, utils_2.validateBIP32Index)(childIndex + 1);
     if (privateKey) {
@@ -74,10 +78,10 @@ async function handleError(_, options) {
             isHardened,
             curve,
         });
-        const newEntropy = (0, shared_1.generateEntropy)({
+        const newEntropy = await (0, shared_1.generateEntropy)({
             chainCode,
             extension: secretExtension,
-        });
+        }, cryptographicFunctions);
         return {
             ...options,
             childIndex: childIndex + 1,
@@ -88,7 +92,7 @@ async function handleError(_, options) {
         parentPublicKey: publicKey,
         childIndex: childIndex + 1,
     });
-    const newEntropy = (0, shared_1.generateEntropy)({
+    const newEntropy = await (0, shared_1.generateEntropy)({
         chainCode,
         extension: publicExtension,
     });
diff --git a/node_modules/@metamask/key-tree/dist/derivers/bip32.cjs.map b/node_modules/@metamask/key-tree/dist/derivers/bip32.cjs.map
index 39b7b0d..6f9f15d 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/bip32.cjs.map
+++ b/node_modules/@metamask/key-tree/dist/derivers/bip32.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"bip32.cjs","sourceRoot":"","sources":["../../src/derivers/bip32.ts"],"names":[],"mappings":";;;AAAA,2CAAyC;AACzC,6CAA6D;AAG7D,gDAAgD;AAChD,gDAAsC;AAEtC,wCAA+D;AAE/D,yCAKkB;AAElB;;;;;;;;;;GAUG;AACH,SAAgB,sBAAsB,CAAC,GAAe;IACpD,IAAA,cAAM,EACJ,GAAG,YAAY,UAAU,IAAI,IAAA,uBAAe,EAAC,GAAG,EAAE,4BAAgB,CAAC,EACnE,8DAA8D,CAC/D,CAAC;IAEF,MAAM,SAAS,GAAG,kBAAS,CAAC,YAAY,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;IACrD,OAAO,qBAAqB,CAAC,SAAS,CAAC,CAAC;AAC1C,CAAC;AARD,wDAQC;AAED;;;;;;;;;;GAUG;AACH,SAAgB,qBAAqB,CAAC,GAAe;IACnD,IAAA,cAAM,EACJ,GAAG,YAAY,UAAU;QACvB,IAAA,uBAAe,EAAC,GAAG,EAAE,kBAAS,CAAC,eAAe,CAAC,EACjD,8DAA8D,CAC/D,CAAC;IAEF,OAAO,IAAA,iBAAS,EAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC;AAC5C,CAAC;AARD,sDAQC;AAED;;;;;;;;GAQG;AACI,KAAK,UAAU,cAAc,CAClC,OAA2B;IAE3B,IAAA,cAAM,EACJ,OAAO,CAAC,KAAK,CAAC,IAAI,KAAK,WAAW,EAClC,uDAAuD,CACxD,CAAC;IAEF,OAAO,IAAA,uBAAoB,EAAC,OAAO,EAAE,WAAW,CAAC,CAAC;AACpD,CAAC;AATD,wCASC;AAED;;;;;;;;GAQG;AACH,KAAK,UAAU,WAAW,CACxB,CAAU,EACV,OAAuB;IAEvB,MAAM,EAAE,UAAU,EAAE,UAAU,EAAE,SAAS,EAAE,UAAU,EAAE,KAAK,EAAE,SAAS,EAAE,GACvE,OAAO,CAAC;IAEV,IAAA,0BAAkB,EAAC,UAAU,GAAG,CAAC,CAAC,CAAC;IAEnC,IAAI,UAAU,EAAE;QACd,MAAM,eAAe,GAAG,MAAM,IAAA,8BAAqB,EAAC;YAClD,UAAU;YACV,UAAU,EAAE,UAAU,GAAG,CAAC;YAC1B,UAAU;YACV,KAAK;SACN,CAAC,CAAC;QAEH,MAAM,UAAU,GAAG,IAAA,wBAAe,EAAC;YACjC,SAAS;YACT,SAAS,EAAE,eAAe;SAC3B,CAAC,CAAC;QAEH,OAAO;YACL,GAAG,OAAO;YACV,UAAU,EAAE,UAAU,GAAG,CAAC;YAC1B,OAAO,EAAE,UAAU;SACpB,CAAC;KACH;IAED,MAAM,eAAe,GAAG,IAAA,8BAAqB,EAAC;QAC5C,eAAe,EAAE,SAAS;QAC1B,UAAU,EAAE,UAAU,GAAG,CAAC;KAC3B,CAAC,CAAC;IAEH,MAAM,UAAU,GAAG,IAAA,wBAAe,EAAC;QACjC,SAAS;QACT,SAAS,EAAE,eAAe;KAC3B,CAAC,CAAC;IAEH,OAAO;QACL,GAAG,OAAO;QACV,UAAU,EAAE,UAAU,GAAG,CAAC;QAC1B,OAAO,EAAE,UAAU;KACpB,CAAC;AACJ,CAAC","sourcesContent":["import { assert } from '@metamask/utils';\nimport { keccak_256 as keccak256 } from '@noble/hashes/sha3';\n\nimport type { DeriveChildKeyArgs } from '.';\nimport { BYTES_KEY_LENGTH } from '../constants';\nimport { secp256k1 } from '../curves';\nimport type { SLIP10Node } from '../SLIP10Node';\nimport { isValidBytesKey, validateBIP32Index } from '../utils';\nimport type { DeriveNodeArgs } from './shared';\nimport {\n  deriveChildKey as sharedDeriveChildKey,\n  deriveSecretExtension,\n  generateEntropy,\n  derivePublicExtension,\n} from './shared';\n\n/**\n * Converts a BIP-32 private key to an Ethereum address.\n *\n * **WARNING:** Only validates that the key is non-zero and of the correct\n * length. It is the consumer's responsibility to ensure that the specified\n * key is a valid BIP-44 Ethereum `address_index` key.\n *\n * @param key - The `address_index` private key bytes to convert to an Ethereum\n * address.\n * @returns The Ethereum address corresponding to the given key.\n */\nexport function privateKeyToEthAddress(key: Uint8Array) {\n  assert(\n    key instanceof Uint8Array && isValidBytesKey(key, BYTES_KEY_LENGTH),\n    'Invalid key: The key must be a 32-byte, non-zero Uint8Array.',\n  );\n\n  const publicKey = secp256k1.getPublicKey(key, false);\n  return publicKeyToEthAddress(publicKey);\n}\n\n/**\n * Converts a BIP-32 public key to an Ethereum address.\n *\n * **WARNING:** Only validates that the key is non-zero and of the correct\n * length. It is the consumer's responsibility to ensure that the specified\n * key is a valid BIP-44 Ethereum `address_index` key.\n *\n * @param key - The `address_index` public key bytes to convert to an Ethereum\n * address.\n * @returns The Ethereum address corresponding to the given key.\n */\nexport function publicKeyToEthAddress(key: Uint8Array) {\n  assert(\n    key instanceof Uint8Array &&\n      isValidBytesKey(key, secp256k1.publicKeyLength),\n    'Invalid key: The key must be a 65-byte, non-zero Uint8Array.',\n  );\n\n  return keccak256(key.slice(1)).slice(-20);\n}\n\n/**\n * Derive a BIP-32 child key with a given path from a parent key.\n *\n * @param options - The options for deriving a child key.\n * @param options.path - The derivation path part to derive.\n * @param options.node - The node to derive from.\n * @param options.curve - The curve to use for derivation.\n * @returns The derived child key as a {@link SLIP10Node}.\n */\nexport async function deriveChildKey(\n  options: DeriveChildKeyArgs,\n): Promise<SLIP10Node> {\n  assert(\n    options.curve.name === 'secp256k1',\n    'Invalid curve: Only secp256k1 is supported by BIP-32.',\n  );\n\n  return sharedDeriveChildKey(options, handleError);\n}\n\n/**\n * Handles an error thrown during derivation by incrementing the child index\n * and retrying.\n *\n * @param _ - The error that was thrown.\n * @param options - The options for deriving a child key.\n * @returns The options for deriving a child key with the child index\n * incremented by one.\n */\nasync function handleError(\n  _: unknown,\n  options: DeriveNodeArgs,\n): Promise<DeriveNodeArgs> {\n  const { childIndex, privateKey, publicKey, isHardened, curve, chainCode } =\n    options;\n\n  validateBIP32Index(childIndex + 1);\n\n  if (privateKey) {\n    const secretExtension = await deriveSecretExtension({\n      privateKey,\n      childIndex: childIndex + 1,\n      isHardened,\n      curve,\n    });\n\n    const newEntropy = generateEntropy({\n      chainCode,\n      extension: secretExtension,\n    });\n\n    return {\n      ...options,\n      childIndex: childIndex + 1,\n      entropy: newEntropy,\n    };\n  }\n\n  const publicExtension = derivePublicExtension({\n    parentPublicKey: publicKey,\n    childIndex: childIndex + 1,\n  });\n\n  const newEntropy = generateEntropy({\n    chainCode,\n    extension: publicExtension,\n  });\n\n  return {\n    ...options,\n    childIndex: childIndex + 1,\n    entropy: newEntropy,\n  };\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"bip32.cjs","sourceRoot":"","sources":["../../src/derivers/bip32.ts"],"names":[],"mappings":";;;AAAA,2CAAyC;AAIzC,yCAKkB;AAClB,gDAAgD;AAEhD,sDAA4C;AAC5C,gDAAsC;AAEtC,wCAA+D;AAE/D;;;;;;;;;;GAUG;AACH,SAAgB,sBAAsB,CAAC,GAAe;IACpD,IAAA,cAAM,EACJ,GAAG,YAAY,UAAU,IAAI,IAAA,uBAAe,EAAC,GAAG,EAAE,4BAAgB,CAAC,EACnE,8DAA8D,CAC/D,CAAC;IAEF,MAAM,SAAS,GAAG,kBAAS,CAAC,YAAY,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;IACrD,OAAO,qBAAqB,CAAC,SAAS,CAAC,CAAC;AAC1C,CAAC;AARD,wDAQC;AAED;;;;;;;;;;GAUG;AACH,SAAgB,qBAAqB,CAAC,GAAe;IACnD,IAAA,cAAM,EACJ,GAAG,YAAY,UAAU;QACvB,IAAA,uBAAe,EAAC,GAAG,EAAE,kBAAS,CAAC,eAAe,CAAC,EACjD,8DAA8D,CAC/D,CAAC;IAEF,OAAO,IAAA,wBAAS,EAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC;AAC5C,CAAC;AARD,sDAQC;AAED;;;;;;;;;;GAUG;AACI,KAAK,UAAU,cAAc,CAClC,OAA2B,EAC3B,sBAA+C;IAE/C,IAAA,cAAM,EACJ,OAAO,CAAC,KAAK,CAAC,IAAI,KAAK,WAAW,EAClC,uDAAuD,CACxD,CAAC;IAEF,OAAO,IAAA,uBAAoB,EAAC,OAAO,EAAE,WAAW,EAAE,sBAAsB,CAAC,CAAC;AAC5E,CAAC;AAVD,wCAUC;AAED;;;;;;;;;;GAUG;AACH,KAAK,UAAU,WAAW,CACxB,CAAU,EACV,OAAuB,EACvB,sBAA+C;IAE/C,MAAM,EAAE,UAAU,EAAE,UAAU,EAAE,SAAS,EAAE,UAAU,EAAE,KAAK,EAAE,SAAS,EAAE,GACvE,OAAO,CAAC;IAEV,IAAA,0BAAkB,EAAC,UAAU,GAAG,CAAC,CAAC,CAAC;IAEnC,IAAI,UAAU,EAAE,CAAC;QACf,MAAM,eAAe,GAAG,MAAM,IAAA,8BAAqB,EAAC;YAClD,UAAU;YACV,UAAU,EAAE,UAAU,GAAG,CAAC;YAC1B,UAAU;YACV,KAAK;SACN,CAAC,CAAC;QAEH,MAAM,UAAU,GAAG,MAAM,IAAA,wBAAe,EACtC;YACE,SAAS;YACT,SAAS,EAAE,eAAe;SAC3B,EACD,sBAAsB,CACvB,CAAC;QAEF,OAAO;YACL,GAAG,OAAO;YACV,UAAU,EAAE,UAAU,GAAG,CAAC;YAC1B,OAAO,EAAE,UAAU;SACpB,CAAC;IACJ,CAAC;IAED,MAAM,eAAe,GAAG,IAAA,8BAAqB,EAAC;QAC5C,eAAe,EAAE,SAAS;QAC1B,UAAU,EAAE,UAAU,GAAG,CAAC;KAC3B,CAAC,CAAC;IAEH,MAAM,UAAU,GAAG,MAAM,IAAA,wBAAe,EAAC;QACvC,SAAS;QACT,SAAS,EAAE,eAAe;KAC3B,CAAC,CAAC;IAEH,OAAO;QACL,GAAG,OAAO;QACV,UAAU,EAAE,UAAU,GAAG,CAAC;QAC1B,OAAO,EAAE,UAAU;KACpB,CAAC;AACJ,CAAC","sourcesContent":["import { assert } from '@metamask/utils';\n\nimport type { DeriveChildKeyArgs } from '.';\nimport type { DeriveNodeArgs } from './shared';\nimport {\n  deriveChildKey as sharedDeriveChildKey,\n  deriveSecretExtension,\n  generateEntropy,\n  derivePublicExtension,\n} from './shared';\nimport { BYTES_KEY_LENGTH } from '../constants';\nimport type { CryptographicFunctions } from '../cryptography';\nimport { keccak256 } from '../cryptography';\nimport { secp256k1 } from '../curves';\nimport type { SLIP10Node } from '../SLIP10Node';\nimport { isValidBytesKey, validateBIP32Index } from '../utils';\n\n/**\n * Converts a BIP-32 private key to an Ethereum address.\n *\n * **WARNING:** Only validates that the key is non-zero and of the correct\n * length. It is the consumer's responsibility to ensure that the specified\n * key is a valid BIP-44 Ethereum `address_index` key.\n *\n * @param key - The `address_index` private key bytes to convert to an Ethereum\n * address.\n * @returns The Ethereum address corresponding to the given key.\n */\nexport function privateKeyToEthAddress(key: Uint8Array): Uint8Array {\n  assert(\n    key instanceof Uint8Array && isValidBytesKey(key, BYTES_KEY_LENGTH),\n    'Invalid key: The key must be a 32-byte, non-zero Uint8Array.',\n  );\n\n  const publicKey = secp256k1.getPublicKey(key, false);\n  return publicKeyToEthAddress(publicKey);\n}\n\n/**\n * Converts a BIP-32 public key to an Ethereum address.\n *\n * **WARNING:** Only validates that the key is non-zero and of the correct\n * length. It is the consumer's responsibility to ensure that the specified\n * key is a valid BIP-44 Ethereum `address_index` key.\n *\n * @param key - The `address_index` public key bytes to convert to an Ethereum\n * address.\n * @returns The Ethereum address corresponding to the given key.\n */\nexport function publicKeyToEthAddress(key: Uint8Array): Uint8Array {\n  assert(\n    key instanceof Uint8Array &&\n      isValidBytesKey(key, secp256k1.publicKeyLength),\n    'Invalid key: The key must be a 65-byte, non-zero Uint8Array.',\n  );\n\n  return keccak256(key.slice(1)).slice(-20);\n}\n\n/**\n * Derive a BIP-32 child key with a given path from a parent key.\n *\n * @param options - The options for deriving a child key.\n * @param options.path - The derivation path part to derive.\n * @param options.node - The node to derive from.\n * @param options.curve - The curve to use for derivation.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The derived child key as a {@link SLIP10Node}.\n */\nexport async function deriveChildKey(\n  options: DeriveChildKeyArgs,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<SLIP10Node> {\n  assert(\n    options.curve.name === 'secp256k1',\n    'Invalid curve: Only secp256k1 is supported by BIP-32.',\n  );\n\n  return sharedDeriveChildKey(options, handleError, cryptographicFunctions);\n}\n\n/**\n * Handles an error thrown during derivation by incrementing the child index\n * and retrying.\n *\n * @param _ - The error that was thrown.\n * @param options - The options for deriving a child key.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The options for deriving a child key with the child index\n * incremented by one.\n */\nasync function handleError(\n  _: unknown,\n  options: DeriveNodeArgs,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<DeriveNodeArgs> {\n  const { childIndex, privateKey, publicKey, isHardened, curve, chainCode } =\n    options;\n\n  validateBIP32Index(childIndex + 1);\n\n  if (privateKey) {\n    const secretExtension = await deriveSecretExtension({\n      privateKey,\n      childIndex: childIndex + 1,\n      isHardened,\n      curve,\n    });\n\n    const newEntropy = await generateEntropy(\n      {\n        chainCode,\n        extension: secretExtension,\n      },\n      cryptographicFunctions,\n    );\n\n    return {\n      ...options,\n      childIndex: childIndex + 1,\n      entropy: newEntropy,\n    };\n  }\n\n  const publicExtension = derivePublicExtension({\n    parentPublicKey: publicKey,\n    childIndex: childIndex + 1,\n  });\n\n  const newEntropy = await generateEntropy({\n    chainCode,\n    extension: publicExtension,\n  });\n\n  return {\n    ...options,\n    childIndex: childIndex + 1,\n    entropy: newEntropy,\n  };\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/derivers/bip32.d.cts b/node_modules/@metamask/key-tree/dist/derivers/bip32.d.cts
index 9a1f5a6..810a389 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/bip32.d.cts
+++ b/node_modules/@metamask/key-tree/dist/derivers/bip32.d.cts
@@ -1,4 +1,5 @@
 import type { DeriveChildKeyArgs } from "./index.cjs";
+import type { CryptographicFunctions } from "../cryptography.cjs";
 import type { SLIP10Node } from "../SLIP10Node.cjs";
 /**
  * Converts a BIP-32 private key to an Ethereum address.
@@ -31,7 +32,9 @@ export declare function publicKeyToEthAddress(key: Uint8Array): Uint8Array;
  * @param options.path - The derivation path part to derive.
  * @param options.node - The node to derive from.
  * @param options.curve - The curve to use for derivation.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The derived child key as a {@link SLIP10Node}.
  */
-export declare function deriveChildKey(options: DeriveChildKeyArgs): Promise<SLIP10Node>;
+export declare function deriveChildKey(options: DeriveChildKeyArgs, cryptographicFunctions?: CryptographicFunctions): Promise<SLIP10Node>;
 //# sourceMappingURL=bip32.d.cts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/derivers/bip32.d.cts.map b/node_modules/@metamask/key-tree/dist/derivers/bip32.d.cts.map
index 1c3f1e5..06c4676 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/bip32.d.cts.map
+++ b/node_modules/@metamask/key-tree/dist/derivers/bip32.d.cts.map
@@ -1 +1 @@
-{"version":3,"file":"bip32.d.cts","sourceRoot":"","sources":["../../src/derivers/bip32.ts"],"names":[],"mappings":"AAGA,OAAO,KAAK,EAAE,kBAAkB,EAAE,oBAAU;AAG5C,OAAO,KAAK,EAAE,UAAU,EAAE,0BAAsB;AAUhD;;;;;;;;;;GAUG;AACH,wBAAgB,sBAAsB,CAAC,GAAG,EAAE,UAAU,cAQrD;AAED;;;;;;;;;;GAUG;AACH,wBAAgB,qBAAqB,CAAC,GAAG,EAAE,UAAU,cAQpD;AAED;;;;;;;;GAQG;AACH,wBAAsB,cAAc,CAClC,OAAO,EAAE,kBAAkB,GAC1B,OAAO,CAAC,UAAU,CAAC,CAOrB"}
\ No newline at end of file
+{"version":3,"file":"bip32.d.cts","sourceRoot":"","sources":["../../src/derivers/bip32.ts"],"names":[],"mappings":"AAEA,OAAO,KAAK,EAAE,kBAAkB,EAAE,oBAAU;AAS5C,OAAO,KAAK,EAAE,sBAAsB,EAAE,4BAAwB;AAG9D,OAAO,KAAK,EAAE,UAAU,EAAE,0BAAsB;AAGhD;;;;;;;;;;GAUG;AACH,wBAAgB,sBAAsB,CAAC,GAAG,EAAE,UAAU,GAAG,UAAU,CAQlE;AAED;;;;;;;;;;GAUG;AACH,wBAAgB,qBAAqB,CAAC,GAAG,EAAE,UAAU,GAAG,UAAU,CAQjE;AAED;;;;;;;;;;GAUG;AACH,wBAAsB,cAAc,CAClC,OAAO,EAAE,kBAAkB,EAC3B,sBAAsB,CAAC,EAAE,sBAAsB,GAC9C,OAAO,CAAC,UAAU,CAAC,CAOrB"}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/derivers/bip32.d.mts b/node_modules/@metamask/key-tree/dist/derivers/bip32.d.mts
index 689087f..f54c164 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/bip32.d.mts
+++ b/node_modules/@metamask/key-tree/dist/derivers/bip32.d.mts
@@ -1,4 +1,5 @@
 import type { DeriveChildKeyArgs } from "./index.mjs";
+import type { CryptographicFunctions } from "../cryptography.mjs";
 import type { SLIP10Node } from "../SLIP10Node.mjs";
 /**
  * Converts a BIP-32 private key to an Ethereum address.
@@ -31,7 +32,9 @@ export declare function publicKeyToEthAddress(key: Uint8Array): Uint8Array;
  * @param options.path - The derivation path part to derive.
  * @param options.node - The node to derive from.
  * @param options.curve - The curve to use for derivation.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The derived child key as a {@link SLIP10Node}.
  */
-export declare function deriveChildKey(options: DeriveChildKeyArgs): Promise<SLIP10Node>;
+export declare function deriveChildKey(options: DeriveChildKeyArgs, cryptographicFunctions?: CryptographicFunctions): Promise<SLIP10Node>;
 //# sourceMappingURL=bip32.d.mts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/derivers/bip32.d.mts.map b/node_modules/@metamask/key-tree/dist/derivers/bip32.d.mts.map
index ebb3dd9..523b42c 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/bip32.d.mts.map
+++ b/node_modules/@metamask/key-tree/dist/derivers/bip32.d.mts.map
@@ -1 +1 @@
-{"version":3,"file":"bip32.d.mts","sourceRoot":"","sources":["../../src/derivers/bip32.ts"],"names":[],"mappings":"AAGA,OAAO,KAAK,EAAE,kBAAkB,EAAE,oBAAU;AAG5C,OAAO,KAAK,EAAE,UAAU,EAAE,0BAAsB;AAUhD;;;;;;;;;;GAUG;AACH,wBAAgB,sBAAsB,CAAC,GAAG,EAAE,UAAU,cAQrD;AAED;;;;;;;;;;GAUG;AACH,wBAAgB,qBAAqB,CAAC,GAAG,EAAE,UAAU,cAQpD;AAED;;;;;;;;GAQG;AACH,wBAAsB,cAAc,CAClC,OAAO,EAAE,kBAAkB,GAC1B,OAAO,CAAC,UAAU,CAAC,CAOrB"}
\ No newline at end of file
+{"version":3,"file":"bip32.d.mts","sourceRoot":"","sources":["../../src/derivers/bip32.ts"],"names":[],"mappings":"AAEA,OAAO,KAAK,EAAE,kBAAkB,EAAE,oBAAU;AAS5C,OAAO,KAAK,EAAE,sBAAsB,EAAE,4BAAwB;AAG9D,OAAO,KAAK,EAAE,UAAU,EAAE,0BAAsB;AAGhD;;;;;;;;;;GAUG;AACH,wBAAgB,sBAAsB,CAAC,GAAG,EAAE,UAAU,GAAG,UAAU,CAQlE;AAED;;;;;;;;;;GAUG;AACH,wBAAgB,qBAAqB,CAAC,GAAG,EAAE,UAAU,GAAG,UAAU,CAQjE;AAED;;;;;;;;;;GAUG;AACH,wBAAsB,cAAc,CAClC,OAAO,EAAE,kBAAkB,EAC3B,sBAAsB,CAAC,EAAE,sBAAsB,GAC9C,OAAO,CAAC,UAAU,CAAC,CAOrB"}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/derivers/bip32.mjs b/node_modules/@metamask/key-tree/dist/derivers/bip32.mjs
index e6a24fe..7929091 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/bip32.mjs
+++ b/node_modules/@metamask/key-tree/dist/derivers/bip32.mjs
@@ -1,9 +1,9 @@
 import { assert } from "@metamask/utils";
-import { keccak_256 as keccak256 } from "@noble/hashes/sha3";
+import { deriveChildKey as sharedDeriveChildKey, deriveSecretExtension, generateEntropy, derivePublicExtension } from "./shared.mjs";
 import { BYTES_KEY_LENGTH } from "../constants.mjs";
+import { keccak256 } from "../cryptography.mjs";
 import { secp256k1 } from "../curves/index.mjs";
 import { isValidBytesKey, validateBIP32Index } from "../utils.mjs";
-import { deriveChildKey as sharedDeriveChildKey, deriveSecretExtension, generateEntropy, derivePublicExtension } from "./shared.mjs";
 /**
  * Converts a BIP-32 private key to an Ethereum address.
  *
@@ -43,11 +43,13 @@ export function publicKeyToEthAddress(key) {
  * @param options.path - The derivation path part to derive.
  * @param options.node - The node to derive from.
  * @param options.curve - The curve to use for derivation.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The derived child key as a {@link SLIP10Node}.
  */
-export async function deriveChildKey(options) {
+export async function deriveChildKey(options, cryptographicFunctions) {
     assert(options.curve.name === 'secp256k1', 'Invalid curve: Only secp256k1 is supported by BIP-32.');
-    return sharedDeriveChildKey(options, handleError);
+    return sharedDeriveChildKey(options, handleError, cryptographicFunctions);
 }
 /**
  * Handles an error thrown during derivation by incrementing the child index
@@ -55,10 +57,12 @@ export async function deriveChildKey(options) {
  *
  * @param _ - The error that was thrown.
  * @param options - The options for deriving a child key.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The options for deriving a child key with the child index
  * incremented by one.
  */
-async function handleError(_, options) {
+async function handleError(_, options, cryptographicFunctions) {
     const { childIndex, privateKey, publicKey, isHardened, curve, chainCode } = options;
     validateBIP32Index(childIndex + 1);
     if (privateKey) {
@@ -68,10 +72,10 @@ async function handleError(_, options) {
             isHardened,
             curve,
         });
-        const newEntropy = generateEntropy({
+        const newEntropy = await generateEntropy({
             chainCode,
             extension: secretExtension,
-        });
+        }, cryptographicFunctions);
         return {
             ...options,
             childIndex: childIndex + 1,
@@ -82,7 +86,7 @@ async function handleError(_, options) {
         parentPublicKey: publicKey,
         childIndex: childIndex + 1,
     });
-    const newEntropy = generateEntropy({
+    const newEntropy = await generateEntropy({
         chainCode,
         extension: publicExtension,
     });
diff --git a/node_modules/@metamask/key-tree/dist/derivers/bip32.mjs.map b/node_modules/@metamask/key-tree/dist/derivers/bip32.mjs.map
index cd22349..3b10e0f 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/bip32.mjs.map
+++ b/node_modules/@metamask/key-tree/dist/derivers/bip32.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"bip32.mjs","sourceRoot":"","sources":["../../src/derivers/bip32.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,MAAM,EAAE,wBAAwB;AACzC,OAAO,EAAE,UAAU,IAAI,SAAS,EAAE,2BAA2B;AAG7D,OAAO,EAAE,gBAAgB,EAAE,yBAAqB;AAChD,OAAO,EAAE,SAAS,EAAE,4BAAkB;AAEtC,OAAO,EAAE,eAAe,EAAE,kBAAkB,EAAE,qBAAiB;AAE/D,OAAO,EACL,cAAc,IAAI,oBAAoB,EACtC,qBAAqB,EACrB,eAAe,EACf,qBAAqB,EACtB,qBAAiB;AAElB;;;;;;;;;;GAUG;AACH,MAAM,UAAU,sBAAsB,CAAC,GAAe;IACpD,MAAM,CACJ,GAAG,YAAY,UAAU,IAAI,eAAe,CAAC,GAAG,EAAE,gBAAgB,CAAC,EACnE,8DAA8D,CAC/D,CAAC;IAEF,MAAM,SAAS,GAAG,SAAS,CAAC,YAAY,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;IACrD,OAAO,qBAAqB,CAAC,SAAS,CAAC,CAAC;AAC1C,CAAC;AAED;;;;;;;;;;GAUG;AACH,MAAM,UAAU,qBAAqB,CAAC,GAAe;IACnD,MAAM,CACJ,GAAG,YAAY,UAAU;QACvB,eAAe,CAAC,GAAG,EAAE,SAAS,CAAC,eAAe,CAAC,EACjD,8DAA8D,CAC/D,CAAC;IAEF,OAAO,SAAS,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC;AAC5C,CAAC;AAED;;;;;;;;GAQG;AACH,MAAM,CAAC,KAAK,UAAU,cAAc,CAClC,OAA2B;IAE3B,MAAM,CACJ,OAAO,CAAC,KAAK,CAAC,IAAI,KAAK,WAAW,EAClC,uDAAuD,CACxD,CAAC;IAEF,OAAO,oBAAoB,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;AACpD,CAAC;AAED;;;;;;;;GAQG;AACH,KAAK,UAAU,WAAW,CACxB,CAAU,EACV,OAAuB;IAEvB,MAAM,EAAE,UAAU,EAAE,UAAU,EAAE,SAAS,EAAE,UAAU,EAAE,KAAK,EAAE,SAAS,EAAE,GACvE,OAAO,CAAC;IAEV,kBAAkB,CAAC,UAAU,GAAG,CAAC,CAAC,CAAC;IAEnC,IAAI,UAAU,EAAE;QACd,MAAM,eAAe,GAAG,MAAM,qBAAqB,CAAC;YAClD,UAAU;YACV,UAAU,EAAE,UAAU,GAAG,CAAC;YAC1B,UAAU;YACV,KAAK;SACN,CAAC,CAAC;QAEH,MAAM,UAAU,GAAG,eAAe,CAAC;YACjC,SAAS;YACT,SAAS,EAAE,eAAe;SAC3B,CAAC,CAAC;QAEH,OAAO;YACL,GAAG,OAAO;YACV,UAAU,EAAE,UAAU,GAAG,CAAC;YAC1B,OAAO,EAAE,UAAU;SACpB,CAAC;KACH;IAED,MAAM,eAAe,GAAG,qBAAqB,CAAC;QAC5C,eAAe,EAAE,SAAS;QAC1B,UAAU,EAAE,UAAU,GAAG,CAAC;KAC3B,CAAC,CAAC;IAEH,MAAM,UAAU,GAAG,eAAe,CAAC;QACjC,SAAS;QACT,SAAS,EAAE,eAAe;KAC3B,CAAC,CAAC;IAEH,OAAO;QACL,GAAG,OAAO;QACV,UAAU,EAAE,UAAU,GAAG,CAAC;QAC1B,OAAO,EAAE,UAAU;KACpB,CAAC;AACJ,CAAC","sourcesContent":["import { assert } from '@metamask/utils';\nimport { keccak_256 as keccak256 } from '@noble/hashes/sha3';\n\nimport type { DeriveChildKeyArgs } from '.';\nimport { BYTES_KEY_LENGTH } from '../constants';\nimport { secp256k1 } from '../curves';\nimport type { SLIP10Node } from '../SLIP10Node';\nimport { isValidBytesKey, validateBIP32Index } from '../utils';\nimport type { DeriveNodeArgs } from './shared';\nimport {\n  deriveChildKey as sharedDeriveChildKey,\n  deriveSecretExtension,\n  generateEntropy,\n  derivePublicExtension,\n} from './shared';\n\n/**\n * Converts a BIP-32 private key to an Ethereum address.\n *\n * **WARNING:** Only validates that the key is non-zero and of the correct\n * length. It is the consumer's responsibility to ensure that the specified\n * key is a valid BIP-44 Ethereum `address_index` key.\n *\n * @param key - The `address_index` private key bytes to convert to an Ethereum\n * address.\n * @returns The Ethereum address corresponding to the given key.\n */\nexport function privateKeyToEthAddress(key: Uint8Array) {\n  assert(\n    key instanceof Uint8Array && isValidBytesKey(key, BYTES_KEY_LENGTH),\n    'Invalid key: The key must be a 32-byte, non-zero Uint8Array.',\n  );\n\n  const publicKey = secp256k1.getPublicKey(key, false);\n  return publicKeyToEthAddress(publicKey);\n}\n\n/**\n * Converts a BIP-32 public key to an Ethereum address.\n *\n * **WARNING:** Only validates that the key is non-zero and of the correct\n * length. It is the consumer's responsibility to ensure that the specified\n * key is a valid BIP-44 Ethereum `address_index` key.\n *\n * @param key - The `address_index` public key bytes to convert to an Ethereum\n * address.\n * @returns The Ethereum address corresponding to the given key.\n */\nexport function publicKeyToEthAddress(key: Uint8Array) {\n  assert(\n    key instanceof Uint8Array &&\n      isValidBytesKey(key, secp256k1.publicKeyLength),\n    'Invalid key: The key must be a 65-byte, non-zero Uint8Array.',\n  );\n\n  return keccak256(key.slice(1)).slice(-20);\n}\n\n/**\n * Derive a BIP-32 child key with a given path from a parent key.\n *\n * @param options - The options for deriving a child key.\n * @param options.path - The derivation path part to derive.\n * @param options.node - The node to derive from.\n * @param options.curve - The curve to use for derivation.\n * @returns The derived child key as a {@link SLIP10Node}.\n */\nexport async function deriveChildKey(\n  options: DeriveChildKeyArgs,\n): Promise<SLIP10Node> {\n  assert(\n    options.curve.name === 'secp256k1',\n    'Invalid curve: Only secp256k1 is supported by BIP-32.',\n  );\n\n  return sharedDeriveChildKey(options, handleError);\n}\n\n/**\n * Handles an error thrown during derivation by incrementing the child index\n * and retrying.\n *\n * @param _ - The error that was thrown.\n * @param options - The options for deriving a child key.\n * @returns The options for deriving a child key with the child index\n * incremented by one.\n */\nasync function handleError(\n  _: unknown,\n  options: DeriveNodeArgs,\n): Promise<DeriveNodeArgs> {\n  const { childIndex, privateKey, publicKey, isHardened, curve, chainCode } =\n    options;\n\n  validateBIP32Index(childIndex + 1);\n\n  if (privateKey) {\n    const secretExtension = await deriveSecretExtension({\n      privateKey,\n      childIndex: childIndex + 1,\n      isHardened,\n      curve,\n    });\n\n    const newEntropy = generateEntropy({\n      chainCode,\n      extension: secretExtension,\n    });\n\n    return {\n      ...options,\n      childIndex: childIndex + 1,\n      entropy: newEntropy,\n    };\n  }\n\n  const publicExtension = derivePublicExtension({\n    parentPublicKey: publicKey,\n    childIndex: childIndex + 1,\n  });\n\n  const newEntropy = generateEntropy({\n    chainCode,\n    extension: publicExtension,\n  });\n\n  return {\n    ...options,\n    childIndex: childIndex + 1,\n    entropy: newEntropy,\n  };\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"bip32.mjs","sourceRoot":"","sources":["../../src/derivers/bip32.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,MAAM,EAAE,wBAAwB;AAIzC,OAAO,EACL,cAAc,IAAI,oBAAoB,EACtC,qBAAqB,EACrB,eAAe,EACf,qBAAqB,EACtB,qBAAiB;AAClB,OAAO,EAAE,gBAAgB,EAAE,yBAAqB;AAEhD,OAAO,EAAE,SAAS,EAAE,4BAAwB;AAC5C,OAAO,EAAE,SAAS,EAAE,4BAAkB;AAEtC,OAAO,EAAE,eAAe,EAAE,kBAAkB,EAAE,qBAAiB;AAE/D;;;;;;;;;;GAUG;AACH,MAAM,UAAU,sBAAsB,CAAC,GAAe;IACpD,MAAM,CACJ,GAAG,YAAY,UAAU,IAAI,eAAe,CAAC,GAAG,EAAE,gBAAgB,CAAC,EACnE,8DAA8D,CAC/D,CAAC;IAEF,MAAM,SAAS,GAAG,SAAS,CAAC,YAAY,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;IACrD,OAAO,qBAAqB,CAAC,SAAS,CAAC,CAAC;AAC1C,CAAC;AAED;;;;;;;;;;GAUG;AACH,MAAM,UAAU,qBAAqB,CAAC,GAAe;IACnD,MAAM,CACJ,GAAG,YAAY,UAAU;QACvB,eAAe,CAAC,GAAG,EAAE,SAAS,CAAC,eAAe,CAAC,EACjD,8DAA8D,CAC/D,CAAC;IAEF,OAAO,SAAS,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC;AAC5C,CAAC;AAED;;;;;;;;;;GAUG;AACH,MAAM,CAAC,KAAK,UAAU,cAAc,CAClC,OAA2B,EAC3B,sBAA+C;IAE/C,MAAM,CACJ,OAAO,CAAC,KAAK,CAAC,IAAI,KAAK,WAAW,EAClC,uDAAuD,CACxD,CAAC;IAEF,OAAO,oBAAoB,CAAC,OAAO,EAAE,WAAW,EAAE,sBAAsB,CAAC,CAAC;AAC5E,CAAC;AAED;;;;;;;;;;GAUG;AACH,KAAK,UAAU,WAAW,CACxB,CAAU,EACV,OAAuB,EACvB,sBAA+C;IAE/C,MAAM,EAAE,UAAU,EAAE,UAAU,EAAE,SAAS,EAAE,UAAU,EAAE,KAAK,EAAE,SAAS,EAAE,GACvE,OAAO,CAAC;IAEV,kBAAkB,CAAC,UAAU,GAAG,CAAC,CAAC,CAAC;IAEnC,IAAI,UAAU,EAAE,CAAC;QACf,MAAM,eAAe,GAAG,MAAM,qBAAqB,CAAC;YAClD,UAAU;YACV,UAAU,EAAE,UAAU,GAAG,CAAC;YAC1B,UAAU;YACV,KAAK;SACN,CAAC,CAAC;QAEH,MAAM,UAAU,GAAG,MAAM,eAAe,CACtC;YACE,SAAS;YACT,SAAS,EAAE,eAAe;SAC3B,EACD,sBAAsB,CACvB,CAAC;QAEF,OAAO;YACL,GAAG,OAAO;YACV,UAAU,EAAE,UAAU,GAAG,CAAC;YAC1B,OAAO,EAAE,UAAU;SACpB,CAAC;IACJ,CAAC;IAED,MAAM,eAAe,GAAG,qBAAqB,CAAC;QAC5C,eAAe,EAAE,SAAS;QAC1B,UAAU,EAAE,UAAU,GAAG,CAAC;KAC3B,CAAC,CAAC;IAEH,MAAM,UAAU,GAAG,MAAM,eAAe,CAAC;QACvC,SAAS;QACT,SAAS,EAAE,eAAe;KAC3B,CAAC,CAAC;IAEH,OAAO;QACL,GAAG,OAAO;QACV,UAAU,EAAE,UAAU,GAAG,CAAC;QAC1B,OAAO,EAAE,UAAU;KACpB,CAAC;AACJ,CAAC","sourcesContent":["import { assert } from '@metamask/utils';\n\nimport type { DeriveChildKeyArgs } from '.';\nimport type { DeriveNodeArgs } from './shared';\nimport {\n  deriveChildKey as sharedDeriveChildKey,\n  deriveSecretExtension,\n  generateEntropy,\n  derivePublicExtension,\n} from './shared';\nimport { BYTES_KEY_LENGTH } from '../constants';\nimport type { CryptographicFunctions } from '../cryptography';\nimport { keccak256 } from '../cryptography';\nimport { secp256k1 } from '../curves';\nimport type { SLIP10Node } from '../SLIP10Node';\nimport { isValidBytesKey, validateBIP32Index } from '../utils';\n\n/**\n * Converts a BIP-32 private key to an Ethereum address.\n *\n * **WARNING:** Only validates that the key is non-zero and of the correct\n * length. It is the consumer's responsibility to ensure that the specified\n * key is a valid BIP-44 Ethereum `address_index` key.\n *\n * @param key - The `address_index` private key bytes to convert to an Ethereum\n * address.\n * @returns The Ethereum address corresponding to the given key.\n */\nexport function privateKeyToEthAddress(key: Uint8Array): Uint8Array {\n  assert(\n    key instanceof Uint8Array && isValidBytesKey(key, BYTES_KEY_LENGTH),\n    'Invalid key: The key must be a 32-byte, non-zero Uint8Array.',\n  );\n\n  const publicKey = secp256k1.getPublicKey(key, false);\n  return publicKeyToEthAddress(publicKey);\n}\n\n/**\n * Converts a BIP-32 public key to an Ethereum address.\n *\n * **WARNING:** Only validates that the key is non-zero and of the correct\n * length. It is the consumer's responsibility to ensure that the specified\n * key is a valid BIP-44 Ethereum `address_index` key.\n *\n * @param key - The `address_index` public key bytes to convert to an Ethereum\n * address.\n * @returns The Ethereum address corresponding to the given key.\n */\nexport function publicKeyToEthAddress(key: Uint8Array): Uint8Array {\n  assert(\n    key instanceof Uint8Array &&\n      isValidBytesKey(key, secp256k1.publicKeyLength),\n    'Invalid key: The key must be a 65-byte, non-zero Uint8Array.',\n  );\n\n  return keccak256(key.slice(1)).slice(-20);\n}\n\n/**\n * Derive a BIP-32 child key with a given path from a parent key.\n *\n * @param options - The options for deriving a child key.\n * @param options.path - The derivation path part to derive.\n * @param options.node - The node to derive from.\n * @param options.curve - The curve to use for derivation.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The derived child key as a {@link SLIP10Node}.\n */\nexport async function deriveChildKey(\n  options: DeriveChildKeyArgs,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<SLIP10Node> {\n  assert(\n    options.curve.name === 'secp256k1',\n    'Invalid curve: Only secp256k1 is supported by BIP-32.',\n  );\n\n  return sharedDeriveChildKey(options, handleError, cryptographicFunctions);\n}\n\n/**\n * Handles an error thrown during derivation by incrementing the child index\n * and retrying.\n *\n * @param _ - The error that was thrown.\n * @param options - The options for deriving a child key.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The options for deriving a child key with the child index\n * incremented by one.\n */\nasync function handleError(\n  _: unknown,\n  options: DeriveNodeArgs,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<DeriveNodeArgs> {\n  const { childIndex, privateKey, publicKey, isHardened, curve, chainCode } =\n    options;\n\n  validateBIP32Index(childIndex + 1);\n\n  if (privateKey) {\n    const secretExtension = await deriveSecretExtension({\n      privateKey,\n      childIndex: childIndex + 1,\n      isHardened,\n      curve,\n    });\n\n    const newEntropy = await generateEntropy(\n      {\n        chainCode,\n        extension: secretExtension,\n      },\n      cryptographicFunctions,\n    );\n\n    return {\n      ...options,\n      childIndex: childIndex + 1,\n      entropy: newEntropy,\n    };\n  }\n\n  const publicExtension = derivePublicExtension({\n    parentPublicKey: publicKey,\n    childIndex: childIndex + 1,\n  });\n\n  const newEntropy = await generateEntropy({\n    chainCode,\n    extension: publicExtension,\n  });\n\n  return {\n    ...options,\n    childIndex: childIndex + 1,\n    entropy: newEntropy,\n  };\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/derivers/bip39.cjs b/node_modules/@metamask/key-tree/dist/derivers/bip39.cjs
index c11debe..846ff96 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/bip39.cjs
+++ b/node_modules/@metamask/key-tree/dist/derivers/bip39.cjs
@@ -1,15 +1,64 @@
 "use strict";
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.entropyToCip3MasterNode = exports.createBip39KeyFromSeed = exports.deriveChildKey = exports.bip39MnemonicToMultipath = void 0;
+exports.entropyToCip3MasterNode = exports.createBip39KeyFromSeed = exports.deriveChildKey = exports.bip39MnemonicToMultipath = exports.mnemonicToSeed = void 0;
 const scure_bip39_1 = require("@metamask/scure-bip39");
 const english_1 = require("@metamask/scure-bip39/dist/wordlists/english.js");
 const utils_1 = require("@metamask/utils");
-const hmac_1 = require("@noble/hashes/hmac");
-const pbkdf2_1 = require("@noble/hashes/pbkdf2");
-const sha512_1 = require("@noble/hashes/sha512");
 const constants_1 = require("../constants.cjs");
+const cryptography_1 = require("../cryptography.cjs");
 const SLIP10Node_1 = require("../SLIP10Node.cjs");
 const utils_2 = require("../utils.cjs");
+const MNEMONIC_PHRASE_LENGTHS = [12, 15, 18, 21, 24];
+/**
+ * Validate a BIP-39 mnemonic phrase. The phrase must:
+ *
+ * - Consist of 12, 15, 18, 21, or 24 words.
+ * - Contain only words from the English wordlist.
+ *
+ * @param mnemonicPhrase - The mnemonic phrase to validate.
+ * @throws If the mnemonic phrase is invalid.
+ */
+function validateMnemonicPhrase(mnemonicPhrase) {
+    const words = mnemonicPhrase.split(' ');
+    (0, utils_1.assert)(MNEMONIC_PHRASE_LENGTHS.includes(words.length), `Invalid mnemonic phrase: The mnemonic phrase must consist of 12, 15, 18, 21, or 24 words.`);
+    (0, utils_1.assert)(words.every((word) => english_1.wordlist.includes(word)), 'Invalid mnemonic phrase: The mnemonic phrase contains an unknown word.');
+}
+/**
+ * Encode a BIP-39 mnemonic phrase to a `Uint8Array` for use in seed generation.
+ * If the mnemonic is already a `Uint8Array`, it is assumed to contain the
+ * indices of the words in the wordlist.
+ *
+ * @param mnemonic - The mnemonic phrase to encode.
+ * @param wordlist - The wordlist to use.
+ * @returns The encoded mnemonic phrase.
+ */
+function encodeMnemonicPhrase(mnemonic, wordlist) {
+    if (typeof mnemonic === 'string') {
+        validateMnemonicPhrase(mnemonic);
+        return (0, utils_1.stringToBytes)(mnemonic.normalize('NFKD'));
+    }
+    const mnemonicString = Array.from(new Uint16Array(mnemonic.buffer))
+        .map((i) => wordlist[i])
+        .join(' ');
+    validateMnemonicPhrase(mnemonicString);
+    return (0, utils_1.stringToBytes)(mnemonicString);
+}
+/**
+ * Convert a BIP-39 mnemonic phrase to a seed.
+ *
+ * @param mnemonic - The BIP-39 mnemonic phrase to convert. If the mnemonic is a
+ * `Uint8Array`, it is assumed to contain the indices of the words in the
+ * English wordlist.
+ * @param passphrase - The passphrase to use.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
+ * @returns The seed.
+ */
+async function mnemonicToSeed(mnemonic, passphrase = '', cryptographicFunctions) {
+    const salt = `mnemonic${passphrase}`.normalize('NFKD');
+    return await (0, cryptography_1.pbkdf2Sha512)(encodeMnemonicPhrase(mnemonic, english_1.wordlist), (0, utils_1.stringToBytes)(salt), 2048, 64, cryptographicFunctions);
+}
+exports.mnemonicToSeed = mnemonicToSeed;
 /**
  * Convert a BIP-39 mnemonic phrase to a multi path.
  *
@@ -26,14 +75,16 @@ exports.bip39MnemonicToMultipath = bip39MnemonicToMultipath;
  * @param options - The options for creating the node.
  * @param options.path - The multi path.
  * @param options.curve - The curve to use for derivation.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The node.
  */
-async function deriveChildKey({ path, curve, }) {
+async function deriveChildKey({ path, curve }, cryptographicFunctions) {
     switch (curve.masterNodeGenerationSpec) {
         case 'slip10':
-            return createBip39KeyFromSeed(await (0, scure_bip39_1.mnemonicToSeed)(path, english_1.wordlist), curve);
+            return createBip39KeyFromSeed(await mnemonicToSeed(path, '', cryptographicFunctions), curve, cryptographicFunctions);
         case 'cip3':
-            return entropyToCip3MasterNode((0, scure_bip39_1.mnemonicToEntropy)(path, english_1.wordlist), curve);
+            return entropyToCip3MasterNode((0, scure_bip39_1.mnemonicToEntropy)(path, english_1.wordlist), curve, cryptographicFunctions);
         default:
             throw new Error('Unsupported master node generation spec.');
     }
@@ -44,12 +95,14 @@ exports.deriveChildKey = deriveChildKey;
  *
  * @param seed - The cryptographic seed bytes.
  * @param curve - The curve to use.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns An object containing the corresponding BIP-39 master key and chain
  * code.
  */
-async function createBip39KeyFromSeed(seed, curve) {
+async function createBip39KeyFromSeed(seed, curve, cryptographicFunctions) {
     (0, utils_1.assert)(seed.length >= 16 && seed.length <= 64, 'Invalid seed: The seed must be between 16 and 64 bytes long.');
-    const key = (0, hmac_1.hmac)(sha512_1.sha512, curve.secret, seed);
+    const key = await (0, cryptography_1.hmacSha512)(curve.secret, seed, cryptographicFunctions);
     const privateKey = key.slice(0, constants_1.BYTES_KEY_LENGTH);
     const chainCode = key.slice(constants_1.BYTES_KEY_LENGTH);
     (0, utils_1.assert)(curve.isValidPrivateKey(privateKey), 'Invalid private key: The private key must greater than 0 and less than the curve order.');
@@ -62,7 +115,7 @@ async function createBip39KeyFromSeed(seed, curve) {
         parentFingerprint: 0,
         index: 0,
         curve: curve.name,
-    });
+    }, cryptographicFunctions);
 }
 exports.createBip39KeyFromSeed = createBip39KeyFromSeed;
 /**
@@ -73,14 +126,13 @@ exports.createBip39KeyFromSeed = createBip39KeyFromSeed;
  *
  * @param entropy - The entropy value.
  * @param curve - The curve to use.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The root key pair consisting of 64-byte private key and 32-byte chain code.
  */
-async function entropyToCip3MasterNode(entropy, curve) {
+async function entropyToCip3MasterNode(entropy, curve, cryptographicFunctions) {
     (0, utils_1.assert)(entropy.length >= 16 && entropy.length <= 64, 'Invalid entropy: The entropy must be between 16 and 64 bytes long.');
-    const rootNode = (0, pbkdf2_1.pbkdf2)(sha512_1.sha512, curve.secret, entropy, {
-        c: 4096,
-        dkLen: 96,
-    });
+    const rootNode = await (0, cryptography_1.pbkdf2Sha512)(curve.secret, entropy, 4096, 96, cryptographicFunctions);
     // Consistent with the Icarus derivation scheme.
     // https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/Icarus.md
     /* eslint-disable no-bitwise */
@@ -100,7 +152,7 @@ async function entropyToCip3MasterNode(entropy, curve) {
         parentFingerprint: 0,
         index: 0,
         curve: curve.name,
-    });
+    }, cryptographicFunctions);
 }
 exports.entropyToCip3MasterNode = entropyToCip3MasterNode;
 //# sourceMappingURL=bip39.cjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/derivers/bip39.cjs.map b/node_modules/@metamask/key-tree/dist/derivers/bip39.cjs.map
index 7efb477..0ef78ed 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/bip39.cjs.map
+++ b/node_modules/@metamask/key-tree/dist/derivers/bip39.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"bip39.cjs","sourceRoot":"","sources":["../../src/derivers/bip39.ts"],"names":[],"mappings":"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","sourcesContent":["import { mnemonicToEntropy, mnemonicToSeed } from '@metamask/scure-bip39';\nimport { wordlist as englishWordlist } from '@metamask/scure-bip39/dist/wordlists/english';\nimport { assert } from '@metamask/utils';\nimport { hmac } from '@noble/hashes/hmac';\nimport { pbkdf2 } from '@noble/hashes/pbkdf2';\nimport { sha512 } from '@noble/hashes/sha512';\n\nimport type { DeriveChildKeyArgs } from '.';\nimport type { BIP39StringNode } from '../constants';\nimport { BYTES_KEY_LENGTH } from '../constants';\nimport type { Curve } from '../curves';\nimport { SLIP10Node } from '../SLIP10Node';\nimport { getFingerprint } from '../utils';\n\n/**\n * Convert a BIP-39 mnemonic phrase to a multi path.\n *\n * @param mnemonic - The BIP-39 mnemonic phrase to convert.\n * @returns The multi path.\n */\nexport function bip39MnemonicToMultipath(mnemonic: string): BIP39StringNode {\n  return `bip39:${mnemonic.toLowerCase().trim()}`;\n}\n\n/**\n * Create a {@link SLIP10Node} from a BIP-39 mnemonic phrase.\n *\n * @param options - The options for creating the node.\n * @param options.path - The multi path.\n * @param options.curve - The curve to use for derivation.\n * @returns The node.\n */\nexport async function deriveChildKey({\n  path,\n  curve,\n}: DeriveChildKeyArgs): Promise<SLIP10Node> {\n  switch (curve.masterNodeGenerationSpec) {\n    case 'slip10':\n      return createBip39KeyFromSeed(\n        await mnemonicToSeed(path, englishWordlist),\n        curve,\n      );\n    case 'cip3':\n      return entropyToCip3MasterNode(\n        mnemonicToEntropy(path, englishWordlist),\n        curve,\n      );\n    default:\n      throw new Error('Unsupported master node generation spec.');\n  }\n}\n\n/**\n * Create a {@link SLIP10Node} from a BIP-39 seed.\n *\n * @param seed - The cryptographic seed bytes.\n * @param curve - The curve to use.\n * @returns An object containing the corresponding BIP-39 master key and chain\n * code.\n */\nexport async function createBip39KeyFromSeed(\n  seed: Uint8Array,\n  curve: Extract<Curve, { masterNodeGenerationSpec: 'slip10' }>,\n): Promise<SLIP10Node> {\n  assert(\n    seed.length >= 16 && seed.length <= 64,\n    'Invalid seed: The seed must be between 16 and 64 bytes long.',\n  );\n\n  const key = hmac(sha512, curve.secret, seed);\n  const privateKey = key.slice(0, BYTES_KEY_LENGTH);\n  const chainCode = key.slice(BYTES_KEY_LENGTH);\n\n  assert(\n    curve.isValidPrivateKey(privateKey),\n    'Invalid private key: The private key must greater than 0 and less than the curve order.',\n  );\n\n  const masterFingerprint = getFingerprint(\n    await curve.getPublicKey(privateKey, true),\n    curve.compressedPublicKeyLength,\n  );\n\n  return SLIP10Node.fromExtendedKey({\n    privateKey,\n    chainCode,\n    masterFingerprint,\n    depth: 0,\n    parentFingerprint: 0,\n    index: 0,\n    curve: curve.name,\n  });\n}\n\n/**\n * Create a {@link SLIP10Node} from BIP-39 entropy.\n * This function is consistent with the Icarus derivation scheme.\n * Icarus root key derivation scheme: https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/Icarus.md.\n * CIP3: https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/CIP-0003.md#master-key-generation.\n *\n * @param entropy - The entropy value.\n * @param curve - The curve to use.\n * @returns The root key pair consisting of 64-byte private key and 32-byte chain code.\n */\nexport async function entropyToCip3MasterNode(\n  entropy: Uint8Array,\n  curve: Extract<Curve, { masterNodeGenerationSpec: 'cip3' }>,\n): Promise<SLIP10Node> {\n  assert(\n    entropy.length >= 16 && entropy.length <= 64,\n    'Invalid entropy: The entropy must be between 16 and 64 bytes long.',\n  );\n\n  const rootNode = pbkdf2(sha512, curve.secret, entropy, {\n    c: 4096,\n    dkLen: 96,\n  });\n\n  // Consistent with the Icarus derivation scheme.\n  // https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/Icarus.md\n  /* eslint-disable no-bitwise */\n  rootNode[0] &= 0b1111_1000;\n  rootNode[31] &= 0b0001_1111;\n  rootNode[31] |= 0b0100_0000;\n  /* eslint-enable no-bitwise */\n\n  const privateKey = rootNode.slice(0, curve.privateKeyLength);\n  const chainCode = rootNode.slice(curve.privateKeyLength);\n\n  assert(curve.isValidPrivateKey(privateKey), 'Invalid private key.');\n\n  const masterFingerprint = getFingerprint(\n    await curve.getPublicKey(privateKey),\n    curve.compressedPublicKeyLength,\n  );\n\n  return SLIP10Node.fromExtendedKey({\n    privateKey,\n    chainCode,\n    masterFingerprint,\n    depth: 0,\n    parentFingerprint: 0,\n    index: 0,\n    curve: curve.name,\n  });\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"bip39.cjs","sourceRoot":"","sources":["../../src/derivers/bip39.ts"],"names":[],"mappings":"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","sourcesContent":["import { mnemonicToEntropy } from '@metamask/scure-bip39';\nimport { wordlist as englishWordlist } from '@metamask/scure-bip39/dist/wordlists/english';\nimport { assert, stringToBytes } from '@metamask/utils';\n\nimport type { DeriveChildKeyArgs } from '.';\nimport type { BIP39StringNode } from '../constants';\nimport { BYTES_KEY_LENGTH } from '../constants';\nimport type { CryptographicFunctions } from '../cryptography';\nimport { hmacSha512, pbkdf2Sha512 } from '../cryptography';\nimport type { Curve } from '../curves';\nimport { SLIP10Node } from '../SLIP10Node';\nimport { getFingerprint } from '../utils';\n\nconst MNEMONIC_PHRASE_LENGTHS = [12, 15, 18, 21, 24];\n\n/**\n * Validate a BIP-39 mnemonic phrase. The phrase must:\n *\n * - Consist of 12, 15, 18, 21, or 24 words.\n * - Contain only words from the English wordlist.\n *\n * @param mnemonicPhrase - The mnemonic phrase to validate.\n * @throws If the mnemonic phrase is invalid.\n */\nfunction validateMnemonicPhrase(mnemonicPhrase: string): void {\n  const words = mnemonicPhrase.split(' ');\n\n  assert(\n    MNEMONIC_PHRASE_LENGTHS.includes(words.length),\n    `Invalid mnemonic phrase: The mnemonic phrase must consist of 12, 15, 18, 21, or 24 words.`,\n  );\n\n  assert(\n    words.every((word) => englishWordlist.includes(word)),\n    'Invalid mnemonic phrase: The mnemonic phrase contains an unknown word.',\n  );\n}\n\n/**\n * Encode a BIP-39 mnemonic phrase to a `Uint8Array` for use in seed generation.\n * If the mnemonic is already a `Uint8Array`, it is assumed to contain the\n * indices of the words in the wordlist.\n *\n * @param mnemonic - The mnemonic phrase to encode.\n * @param wordlist - The wordlist to use.\n * @returns The encoded mnemonic phrase.\n */\nfunction encodeMnemonicPhrase(\n  mnemonic: string | Uint8Array,\n  wordlist: string[],\n): Uint8Array {\n  if (typeof mnemonic === 'string') {\n    validateMnemonicPhrase(mnemonic);\n    return stringToBytes(mnemonic.normalize('NFKD'));\n  }\n\n  const mnemonicString = Array.from(new Uint16Array(mnemonic.buffer))\n    .map((i) => wordlist[i])\n    .join(' ');\n\n  validateMnemonicPhrase(mnemonicString);\n  return stringToBytes(mnemonicString);\n}\n\n/**\n * Convert a BIP-39 mnemonic phrase to a seed.\n *\n * @param mnemonic - The BIP-39 mnemonic phrase to convert. If the mnemonic is a\n * `Uint8Array`, it is assumed to contain the indices of the words in the\n * English wordlist.\n * @param passphrase - The passphrase to use.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The seed.\n */\nexport async function mnemonicToSeed(\n  mnemonic: string | Uint8Array,\n  passphrase = '',\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<Uint8Array> {\n  const salt = `mnemonic${passphrase}`.normalize('NFKD');\n  return await pbkdf2Sha512(\n    encodeMnemonicPhrase(mnemonic, englishWordlist),\n    stringToBytes(salt),\n    2048,\n    64,\n    cryptographicFunctions,\n  );\n}\n\n/**\n * Convert a BIP-39 mnemonic phrase to a multi path.\n *\n * @param mnemonic - The BIP-39 mnemonic phrase to convert.\n * @returns The multi path.\n */\nexport function bip39MnemonicToMultipath(mnemonic: string): BIP39StringNode {\n  return `bip39:${mnemonic.toLowerCase().trim()}`;\n}\n\n/**\n * Create a {@link SLIP10Node} from a BIP-39 mnemonic phrase.\n *\n * @param options - The options for creating the node.\n * @param options.path - The multi path.\n * @param options.curve - The curve to use for derivation.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The node.\n */\nexport async function deriveChildKey(\n  { path, curve }: DeriveChildKeyArgs,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<SLIP10Node> {\n  switch (curve.masterNodeGenerationSpec) {\n    case 'slip10':\n      return createBip39KeyFromSeed(\n        await mnemonicToSeed(path, '', cryptographicFunctions),\n        curve,\n        cryptographicFunctions,\n      );\n    case 'cip3':\n      return entropyToCip3MasterNode(\n        mnemonicToEntropy(path, englishWordlist),\n        curve,\n        cryptographicFunctions,\n      );\n    default:\n      throw new Error('Unsupported master node generation spec.');\n  }\n}\n\n/**\n * Create a {@link SLIP10Node} from a BIP-39 seed.\n *\n * @param seed - The cryptographic seed bytes.\n * @param curve - The curve to use.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns An object containing the corresponding BIP-39 master key and chain\n * code.\n */\nexport async function createBip39KeyFromSeed(\n  seed: Uint8Array,\n  curve: Extract<Curve, { masterNodeGenerationSpec: 'slip10' }>,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<SLIP10Node> {\n  assert(\n    seed.length >= 16 && seed.length <= 64,\n    'Invalid seed: The seed must be between 16 and 64 bytes long.',\n  );\n\n  const key = await hmacSha512(curve.secret, seed, cryptographicFunctions);\n  const privateKey = key.slice(0, BYTES_KEY_LENGTH);\n  const chainCode = key.slice(BYTES_KEY_LENGTH);\n\n  assert(\n    curve.isValidPrivateKey(privateKey),\n    'Invalid private key: The private key must greater than 0 and less than the curve order.',\n  );\n\n  const masterFingerprint = getFingerprint(\n    await curve.getPublicKey(privateKey, true),\n    curve.compressedPublicKeyLength,\n  );\n\n  return SLIP10Node.fromExtendedKey(\n    {\n      privateKey,\n      chainCode,\n      masterFingerprint,\n      depth: 0,\n      parentFingerprint: 0,\n      index: 0,\n      curve: curve.name,\n    },\n    cryptographicFunctions,\n  );\n}\n\n/**\n * Create a {@link SLIP10Node} from BIP-39 entropy.\n * This function is consistent with the Icarus derivation scheme.\n * Icarus root key derivation scheme: https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/Icarus.md.\n * CIP3: https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/CIP-0003.md#master-key-generation.\n *\n * @param entropy - The entropy value.\n * @param curve - The curve to use.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The root key pair consisting of 64-byte private key and 32-byte chain code.\n */\nexport async function entropyToCip3MasterNode(\n  entropy: Uint8Array,\n  curve: Extract<Curve, { masterNodeGenerationSpec: 'cip3' }>,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<SLIP10Node> {\n  assert(\n    entropy.length >= 16 && entropy.length <= 64,\n    'Invalid entropy: The entropy must be between 16 and 64 bytes long.',\n  );\n\n  const rootNode = await pbkdf2Sha512(\n    curve.secret,\n    entropy,\n    4096,\n    96,\n    cryptographicFunctions,\n  );\n\n  // Consistent with the Icarus derivation scheme.\n  // https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/Icarus.md\n  /* eslint-disable no-bitwise */\n  rootNode[0] &= 0b1111_1000;\n  rootNode[31] &= 0b0001_1111;\n  rootNode[31] |= 0b0100_0000;\n  /* eslint-enable no-bitwise */\n\n  const privateKey = rootNode.slice(0, curve.privateKeyLength);\n  const chainCode = rootNode.slice(curve.privateKeyLength);\n\n  assert(curve.isValidPrivateKey(privateKey), 'Invalid private key.');\n\n  const masterFingerprint = getFingerprint(\n    await curve.getPublicKey(privateKey),\n    curve.compressedPublicKeyLength,\n  );\n\n  return SLIP10Node.fromExtendedKey(\n    {\n      privateKey,\n      chainCode,\n      masterFingerprint,\n      depth: 0,\n      parentFingerprint: 0,\n      index: 0,\n      curve: curve.name,\n    },\n    cryptographicFunctions,\n  );\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/derivers/bip39.d.cts b/node_modules/@metamask/key-tree/dist/derivers/bip39.d.cts
index 78ce81e..2d94a9c 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/bip39.d.cts
+++ b/node_modules/@metamask/key-tree/dist/derivers/bip39.d.cts
@@ -1,7 +1,20 @@
 import type { DeriveChildKeyArgs } from "./index.cjs";
 import type { BIP39StringNode } from "../constants.cjs";
+import type { CryptographicFunctions } from "../cryptography.cjs";
 import type { Curve } from "../curves/index.cjs";
 import { SLIP10Node } from "../SLIP10Node.cjs";
+/**
+ * Convert a BIP-39 mnemonic phrase to a seed.
+ *
+ * @param mnemonic - The BIP-39 mnemonic phrase to convert. If the mnemonic is a
+ * `Uint8Array`, it is assumed to contain the indices of the words in the
+ * English wordlist.
+ * @param passphrase - The passphrase to use.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
+ * @returns The seed.
+ */
+export declare function mnemonicToSeed(mnemonic: string | Uint8Array, passphrase?: string, cryptographicFunctions?: CryptographicFunctions): Promise<Uint8Array>;
 /**
  * Convert a BIP-39 mnemonic phrase to a multi path.
  *
@@ -15,20 +28,24 @@ export declare function bip39MnemonicToMultipath(mnemonic: string): BIP39StringN
  * @param options - The options for creating the node.
  * @param options.path - The multi path.
  * @param options.curve - The curve to use for derivation.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The node.
  */
-export declare function deriveChildKey({ path, curve, }: DeriveChildKeyArgs): Promise<SLIP10Node>;
+export declare function deriveChildKey({ path, curve }: DeriveChildKeyArgs, cryptographicFunctions?: CryptographicFunctions): Promise<SLIP10Node>;
 /**
  * Create a {@link SLIP10Node} from a BIP-39 seed.
  *
  * @param seed - The cryptographic seed bytes.
  * @param curve - The curve to use.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns An object containing the corresponding BIP-39 master key and chain
  * code.
  */
 export declare function createBip39KeyFromSeed(seed: Uint8Array, curve: Extract<Curve, {
     masterNodeGenerationSpec: 'slip10';
-}>): Promise<SLIP10Node>;
+}>, cryptographicFunctions?: CryptographicFunctions): Promise<SLIP10Node>;
 /**
  * Create a {@link SLIP10Node} from BIP-39 entropy.
  * This function is consistent with the Icarus derivation scheme.
@@ -37,9 +54,11 @@ export declare function createBip39KeyFromSeed(seed: Uint8Array, curve: Extract<
  *
  * @param entropy - The entropy value.
  * @param curve - The curve to use.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The root key pair consisting of 64-byte private key and 32-byte chain code.
  */
 export declare function entropyToCip3MasterNode(entropy: Uint8Array, curve: Extract<Curve, {
     masterNodeGenerationSpec: 'cip3';
-}>): Promise<SLIP10Node>;
+}>, cryptographicFunctions?: CryptographicFunctions): Promise<SLIP10Node>;
 //# sourceMappingURL=bip39.d.cts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/derivers/bip39.d.cts.map b/node_modules/@metamask/key-tree/dist/derivers/bip39.d.cts.map
index ce19060..dc96098 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/bip39.d.cts.map
+++ b/node_modules/@metamask/key-tree/dist/derivers/bip39.d.cts.map
@@ -1 +1 @@
-{"version":3,"file":"bip39.d.cts","sourceRoot":"","sources":["../../src/derivers/bip39.ts"],"names":[],"mappings":"AAOA,OAAO,KAAK,EAAE,kBAAkB,EAAE,oBAAU;AAC5C,OAAO,KAAK,EAAE,eAAe,EAAE,yBAAqB;AAEpD,OAAO,KAAK,EAAE,KAAK,EAAE,4BAAkB;AACvC,OAAO,EAAE,UAAU,EAAE,0BAAsB;AAG3C;;;;;GAKG;AACH,wBAAgB,wBAAwB,CAAC,QAAQ,EAAE,MAAM,GAAG,eAAe,CAE1E;AAED;;;;;;;GAOG;AACH,wBAAsB,cAAc,CAAC,EACnC,IAAI,EACJ,KAAK,GACN,EAAE,kBAAkB,GAAG,OAAO,CAAC,UAAU,CAAC,CAe1C;AAED;;;;;;;GAOG;AACH,wBAAsB,sBAAsB,CAC1C,IAAI,EAAE,UAAU,EAChB,KAAK,EAAE,OAAO,CAAC,KAAK,EAAE;IAAE,wBAAwB,EAAE,QAAQ,CAAA;CAAE,CAAC,GAC5D,OAAO,CAAC,UAAU,CAAC,CA6BrB;AAED;;;;;;;;;GASG;AACH,wBAAsB,uBAAuB,CAC3C,OAAO,EAAE,UAAU,EACnB,KAAK,EAAE,OAAO,CAAC,KAAK,EAAE;IAAE,wBAAwB,EAAE,MAAM,CAAA;CAAE,CAAC,GAC1D,OAAO,CAAC,UAAU,CAAC,CAsCrB"}
\ No newline at end of file
+{"version":3,"file":"bip39.d.cts","sourceRoot":"","sources":["../../src/derivers/bip39.ts"],"names":[],"mappings":"AAIA,OAAO,KAAK,EAAE,kBAAkB,EAAE,oBAAU;AAC5C,OAAO,KAAK,EAAE,eAAe,EAAE,yBAAqB;AAEpD,OAAO,KAAK,EAAE,sBAAsB,EAAE,4BAAwB;AAE9D,OAAO,KAAK,EAAE,KAAK,EAAE,4BAAkB;AACvC,OAAO,EAAE,UAAU,EAAE,0BAAsB;AAsD3C;;;;;;;;;;GAUG;AACH,wBAAsB,cAAc,CAClC,QAAQ,EAAE,MAAM,GAAG,UAAU,EAC7B,UAAU,SAAK,EACf,sBAAsB,CAAC,EAAE,sBAAsB,GAC9C,OAAO,CAAC,UAAU,CAAC,CASrB;AAED;;;;;GAKG;AACH,wBAAgB,wBAAwB,CAAC,QAAQ,EAAE,MAAM,GAAG,eAAe,CAE1E;AAED;;;;;;;;;GASG;AACH,wBAAsB,cAAc,CAClC,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE,kBAAkB,EACnC,sBAAsB,CAAC,EAAE,sBAAsB,GAC9C,OAAO,CAAC,UAAU,CAAC,CAiBrB;AAED;;;;;;;;;GASG;AACH,wBAAsB,sBAAsB,CAC1C,IAAI,EAAE,UAAU,EAChB,KAAK,EAAE,OAAO,CAAC,KAAK,EAAE;IAAE,wBAAwB,EAAE,QAAQ,CAAA;CAAE,CAAC,EAC7D,sBAAsB,CAAC,EAAE,sBAAsB,GAC9C,OAAO,CAAC,UAAU,CAAC,CAgCrB;AAED;;;;;;;;;;;GAWG;AACH,wBAAsB,uBAAuB,CAC3C,OAAO,EAAE,UAAU,EACnB,KAAK,EAAE,OAAO,CAAC,KAAK,EAAE;IAAE,wBAAwB,EAAE,MAAM,CAAA;CAAE,CAAC,EAC3D,sBAAsB,CAAC,EAAE,sBAAsB,GAC9C,OAAO,CAAC,UAAU,CAAC,CA4CrB"}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/derivers/bip39.d.mts b/node_modules/@metamask/key-tree/dist/derivers/bip39.d.mts
index 0a74122..7e1887c 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/bip39.d.mts
+++ b/node_modules/@metamask/key-tree/dist/derivers/bip39.d.mts
@@ -1,7 +1,20 @@
 import type { DeriveChildKeyArgs } from "./index.mjs";
 import type { BIP39StringNode } from "../constants.mjs";
+import type { CryptographicFunctions } from "../cryptography.mjs";
 import type { Curve } from "../curves/index.mjs";
 import { SLIP10Node } from "../SLIP10Node.mjs";
+/**
+ * Convert a BIP-39 mnemonic phrase to a seed.
+ *
+ * @param mnemonic - The BIP-39 mnemonic phrase to convert. If the mnemonic is a
+ * `Uint8Array`, it is assumed to contain the indices of the words in the
+ * English wordlist.
+ * @param passphrase - The passphrase to use.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
+ * @returns The seed.
+ */
+export declare function mnemonicToSeed(mnemonic: string | Uint8Array, passphrase?: string, cryptographicFunctions?: CryptographicFunctions): Promise<Uint8Array>;
 /**
  * Convert a BIP-39 mnemonic phrase to a multi path.
  *
@@ -15,20 +28,24 @@ export declare function bip39MnemonicToMultipath(mnemonic: string): BIP39StringN
  * @param options - The options for creating the node.
  * @param options.path - The multi path.
  * @param options.curve - The curve to use for derivation.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The node.
  */
-export declare function deriveChildKey({ path, curve, }: DeriveChildKeyArgs): Promise<SLIP10Node>;
+export declare function deriveChildKey({ path, curve }: DeriveChildKeyArgs, cryptographicFunctions?: CryptographicFunctions): Promise<SLIP10Node>;
 /**
  * Create a {@link SLIP10Node} from a BIP-39 seed.
  *
  * @param seed - The cryptographic seed bytes.
  * @param curve - The curve to use.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns An object containing the corresponding BIP-39 master key and chain
  * code.
  */
 export declare function createBip39KeyFromSeed(seed: Uint8Array, curve: Extract<Curve, {
     masterNodeGenerationSpec: 'slip10';
-}>): Promise<SLIP10Node>;
+}>, cryptographicFunctions?: CryptographicFunctions): Promise<SLIP10Node>;
 /**
  * Create a {@link SLIP10Node} from BIP-39 entropy.
  * This function is consistent with the Icarus derivation scheme.
@@ -37,9 +54,11 @@ export declare function createBip39KeyFromSeed(seed: Uint8Array, curve: Extract<
  *
  * @param entropy - The entropy value.
  * @param curve - The curve to use.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The root key pair consisting of 64-byte private key and 32-byte chain code.
  */
 export declare function entropyToCip3MasterNode(entropy: Uint8Array, curve: Extract<Curve, {
     masterNodeGenerationSpec: 'cip3';
-}>): Promise<SLIP10Node>;
+}>, cryptographicFunctions?: CryptographicFunctions): Promise<SLIP10Node>;
 //# sourceMappingURL=bip39.d.mts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/derivers/bip39.d.mts.map b/node_modules/@metamask/key-tree/dist/derivers/bip39.d.mts.map
index 895a95d..f1cf1ce 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/bip39.d.mts.map
+++ b/node_modules/@metamask/key-tree/dist/derivers/bip39.d.mts.map
@@ -1 +1 @@
-{"version":3,"file":"bip39.d.mts","sourceRoot":"","sources":["../../src/derivers/bip39.ts"],"names":[],"mappings":"AAOA,OAAO,KAAK,EAAE,kBAAkB,EAAE,oBAAU;AAC5C,OAAO,KAAK,EAAE,eAAe,EAAE,yBAAqB;AAEpD,OAAO,KAAK,EAAE,KAAK,EAAE,4BAAkB;AACvC,OAAO,EAAE,UAAU,EAAE,0BAAsB;AAG3C;;;;;GAKG;AACH,wBAAgB,wBAAwB,CAAC,QAAQ,EAAE,MAAM,GAAG,eAAe,CAE1E;AAED;;;;;;;GAOG;AACH,wBAAsB,cAAc,CAAC,EACnC,IAAI,EACJ,KAAK,GACN,EAAE,kBAAkB,GAAG,OAAO,CAAC,UAAU,CAAC,CAe1C;AAED;;;;;;;GAOG;AACH,wBAAsB,sBAAsB,CAC1C,IAAI,EAAE,UAAU,EAChB,KAAK,EAAE,OAAO,CAAC,KAAK,EAAE;IAAE,wBAAwB,EAAE,QAAQ,CAAA;CAAE,CAAC,GAC5D,OAAO,CAAC,UAAU,CAAC,CA6BrB;AAED;;;;;;;;;GASG;AACH,wBAAsB,uBAAuB,CAC3C,OAAO,EAAE,UAAU,EACnB,KAAK,EAAE,OAAO,CAAC,KAAK,EAAE;IAAE,wBAAwB,EAAE,MAAM,CAAA;CAAE,CAAC,GAC1D,OAAO,CAAC,UAAU,CAAC,CAsCrB"}
\ No newline at end of file
+{"version":3,"file":"bip39.d.mts","sourceRoot":"","sources":["../../src/derivers/bip39.ts"],"names":[],"mappings":"AAIA,OAAO,KAAK,EAAE,kBAAkB,EAAE,oBAAU;AAC5C,OAAO,KAAK,EAAE,eAAe,EAAE,yBAAqB;AAEpD,OAAO,KAAK,EAAE,sBAAsB,EAAE,4BAAwB;AAE9D,OAAO,KAAK,EAAE,KAAK,EAAE,4BAAkB;AACvC,OAAO,EAAE,UAAU,EAAE,0BAAsB;AAsD3C;;;;;;;;;;GAUG;AACH,wBAAsB,cAAc,CAClC,QAAQ,EAAE,MAAM,GAAG,UAAU,EAC7B,UAAU,SAAK,EACf,sBAAsB,CAAC,EAAE,sBAAsB,GAC9C,OAAO,CAAC,UAAU,CAAC,CASrB;AAED;;;;;GAKG;AACH,wBAAgB,wBAAwB,CAAC,QAAQ,EAAE,MAAM,GAAG,eAAe,CAE1E;AAED;;;;;;;;;GASG;AACH,wBAAsB,cAAc,CAClC,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE,kBAAkB,EACnC,sBAAsB,CAAC,EAAE,sBAAsB,GAC9C,OAAO,CAAC,UAAU,CAAC,CAiBrB;AAED;;;;;;;;;GASG;AACH,wBAAsB,sBAAsB,CAC1C,IAAI,EAAE,UAAU,EAChB,KAAK,EAAE,OAAO,CAAC,KAAK,EAAE;IAAE,wBAAwB,EAAE,QAAQ,CAAA;CAAE,CAAC,EAC7D,sBAAsB,CAAC,EAAE,sBAAsB,GAC9C,OAAO,CAAC,UAAU,CAAC,CAgCrB;AAED;;;;;;;;;;;GAWG;AACH,wBAAsB,uBAAuB,CAC3C,OAAO,EAAE,UAAU,EACnB,KAAK,EAAE,OAAO,CAAC,KAAK,EAAE;IAAE,wBAAwB,EAAE,MAAM,CAAA;CAAE,CAAC,EAC3D,sBAAsB,CAAC,EAAE,sBAAsB,GAC9C,OAAO,CAAC,UAAU,CAAC,CA4CrB"}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/derivers/bip39.mjs b/node_modules/@metamask/key-tree/dist/derivers/bip39.mjs
index 5f93815..55bc4bc 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/bip39.mjs
+++ b/node_modules/@metamask/key-tree/dist/derivers/bip39.mjs
@@ -1,12 +1,60 @@
-import { mnemonicToEntropy, mnemonicToSeed } from "@metamask/scure-bip39";
+import { mnemonicToEntropy } from "@metamask/scure-bip39";
 import { wordlist as englishWordlist } from "@metamask/scure-bip39/dist/wordlists/english.js";
-import { assert } from "@metamask/utils";
-import { hmac } from "@noble/hashes/hmac";
-import { pbkdf2 } from "@noble/hashes/pbkdf2";
-import { sha512 } from "@noble/hashes/sha512";
+import { assert, stringToBytes } from "@metamask/utils";
 import { BYTES_KEY_LENGTH } from "../constants.mjs";
+import { hmacSha512, pbkdf2Sha512 } from "../cryptography.mjs";
 import { SLIP10Node } from "../SLIP10Node.mjs";
 import { getFingerprint } from "../utils.mjs";
+const MNEMONIC_PHRASE_LENGTHS = [12, 15, 18, 21, 24];
+/**
+ * Validate a BIP-39 mnemonic phrase. The phrase must:
+ *
+ * - Consist of 12, 15, 18, 21, or 24 words.
+ * - Contain only words from the English wordlist.
+ *
+ * @param mnemonicPhrase - The mnemonic phrase to validate.
+ * @throws If the mnemonic phrase is invalid.
+ */
+function validateMnemonicPhrase(mnemonicPhrase) {
+    const words = mnemonicPhrase.split(' ');
+    assert(MNEMONIC_PHRASE_LENGTHS.includes(words.length), `Invalid mnemonic phrase: The mnemonic phrase must consist of 12, 15, 18, 21, or 24 words.`);
+    assert(words.every((word) => englishWordlist.includes(word)), 'Invalid mnemonic phrase: The mnemonic phrase contains an unknown word.');
+}
+/**
+ * Encode a BIP-39 mnemonic phrase to a `Uint8Array` for use in seed generation.
+ * If the mnemonic is already a `Uint8Array`, it is assumed to contain the
+ * indices of the words in the wordlist.
+ *
+ * @param mnemonic - The mnemonic phrase to encode.
+ * @param wordlist - The wordlist to use.
+ * @returns The encoded mnemonic phrase.
+ */
+function encodeMnemonicPhrase(mnemonic, wordlist) {
+    if (typeof mnemonic === 'string') {
+        validateMnemonicPhrase(mnemonic);
+        return stringToBytes(mnemonic.normalize('NFKD'));
+    }
+    const mnemonicString = Array.from(new Uint16Array(mnemonic.buffer))
+        .map((i) => wordlist[i])
+        .join(' ');
+    validateMnemonicPhrase(mnemonicString);
+    return stringToBytes(mnemonicString);
+}
+/**
+ * Convert a BIP-39 mnemonic phrase to a seed.
+ *
+ * @param mnemonic - The BIP-39 mnemonic phrase to convert. If the mnemonic is a
+ * `Uint8Array`, it is assumed to contain the indices of the words in the
+ * English wordlist.
+ * @param passphrase - The passphrase to use.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
+ * @returns The seed.
+ */
+export async function mnemonicToSeed(mnemonic, passphrase = '', cryptographicFunctions) {
+    const salt = `mnemonic${passphrase}`.normalize('NFKD');
+    return await pbkdf2Sha512(encodeMnemonicPhrase(mnemonic, englishWordlist), stringToBytes(salt), 2048, 64, cryptographicFunctions);
+}
 /**
  * Convert a BIP-39 mnemonic phrase to a multi path.
  *
@@ -22,14 +70,16 @@ export function bip39MnemonicToMultipath(mnemonic) {
  * @param options - The options for creating the node.
  * @param options.path - The multi path.
  * @param options.curve - The curve to use for derivation.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The node.
  */
-export async function deriveChildKey({ path, curve, }) {
+export async function deriveChildKey({ path, curve }, cryptographicFunctions) {
     switch (curve.masterNodeGenerationSpec) {
         case 'slip10':
-            return createBip39KeyFromSeed(await mnemonicToSeed(path, englishWordlist), curve);
+            return createBip39KeyFromSeed(await mnemonicToSeed(path, '', cryptographicFunctions), curve, cryptographicFunctions);
         case 'cip3':
-            return entropyToCip3MasterNode(mnemonicToEntropy(path, englishWordlist), curve);
+            return entropyToCip3MasterNode(mnemonicToEntropy(path, englishWordlist), curve, cryptographicFunctions);
         default:
             throw new Error('Unsupported master node generation spec.');
     }
@@ -39,12 +89,14 @@ export async function deriveChildKey({ path, curve, }) {
  *
  * @param seed - The cryptographic seed bytes.
  * @param curve - The curve to use.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns An object containing the corresponding BIP-39 master key and chain
  * code.
  */
-export async function createBip39KeyFromSeed(seed, curve) {
+export async function createBip39KeyFromSeed(seed, curve, cryptographicFunctions) {
     assert(seed.length >= 16 && seed.length <= 64, 'Invalid seed: The seed must be between 16 and 64 bytes long.');
-    const key = hmac(sha512, curve.secret, seed);
+    const key = await hmacSha512(curve.secret, seed, cryptographicFunctions);
     const privateKey = key.slice(0, BYTES_KEY_LENGTH);
     const chainCode = key.slice(BYTES_KEY_LENGTH);
     assert(curve.isValidPrivateKey(privateKey), 'Invalid private key: The private key must greater than 0 and less than the curve order.');
@@ -57,7 +109,7 @@ export async function createBip39KeyFromSeed(seed, curve) {
         parentFingerprint: 0,
         index: 0,
         curve: curve.name,
-    });
+    }, cryptographicFunctions);
 }
 /**
  * Create a {@link SLIP10Node} from BIP-39 entropy.
@@ -67,14 +119,13 @@ export async function createBip39KeyFromSeed(seed, curve) {
  *
  * @param entropy - The entropy value.
  * @param curve - The curve to use.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The root key pair consisting of 64-byte private key and 32-byte chain code.
  */
-export async function entropyToCip3MasterNode(entropy, curve) {
+export async function entropyToCip3MasterNode(entropy, curve, cryptographicFunctions) {
     assert(entropy.length >= 16 && entropy.length <= 64, 'Invalid entropy: The entropy must be between 16 and 64 bytes long.');
-    const rootNode = pbkdf2(sha512, curve.secret, entropy, {
-        c: 4096,
-        dkLen: 96,
-    });
+    const rootNode = await pbkdf2Sha512(curve.secret, entropy, 4096, 96, cryptographicFunctions);
     // Consistent with the Icarus derivation scheme.
     // https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/Icarus.md
     /* eslint-disable no-bitwise */
@@ -94,6 +145,6 @@ export async function entropyToCip3MasterNode(entropy, curve) {
         parentFingerprint: 0,
         index: 0,
         curve: curve.name,
-    });
+    }, cryptographicFunctions);
 }
 //# sourceMappingURL=bip39.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/derivers/bip39.mjs.map b/node_modules/@metamask/key-tree/dist/derivers/bip39.mjs.map
index 5618af8..006b5a3 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/bip39.mjs.map
+++ b/node_modules/@metamask/key-tree/dist/derivers/bip39.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"bip39.mjs","sourceRoot":"","sources":["../../src/derivers/bip39.ts"],"names":[],"mappings":"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","sourcesContent":["import { mnemonicToEntropy, mnemonicToSeed } from '@metamask/scure-bip39';\nimport { wordlist as englishWordlist } from '@metamask/scure-bip39/dist/wordlists/english';\nimport { assert } from '@metamask/utils';\nimport { hmac } from '@noble/hashes/hmac';\nimport { pbkdf2 } from '@noble/hashes/pbkdf2';\nimport { sha512 } from '@noble/hashes/sha512';\n\nimport type { DeriveChildKeyArgs } from '.';\nimport type { BIP39StringNode } from '../constants';\nimport { BYTES_KEY_LENGTH } from '../constants';\nimport type { Curve } from '../curves';\nimport { SLIP10Node } from '../SLIP10Node';\nimport { getFingerprint } from '../utils';\n\n/**\n * Convert a BIP-39 mnemonic phrase to a multi path.\n *\n * @param mnemonic - The BIP-39 mnemonic phrase to convert.\n * @returns The multi path.\n */\nexport function bip39MnemonicToMultipath(mnemonic: string): BIP39StringNode {\n  return `bip39:${mnemonic.toLowerCase().trim()}`;\n}\n\n/**\n * Create a {@link SLIP10Node} from a BIP-39 mnemonic phrase.\n *\n * @param options - The options for creating the node.\n * @param options.path - The multi path.\n * @param options.curve - The curve to use for derivation.\n * @returns The node.\n */\nexport async function deriveChildKey({\n  path,\n  curve,\n}: DeriveChildKeyArgs): Promise<SLIP10Node> {\n  switch (curve.masterNodeGenerationSpec) {\n    case 'slip10':\n      return createBip39KeyFromSeed(\n        await mnemonicToSeed(path, englishWordlist),\n        curve,\n      );\n    case 'cip3':\n      return entropyToCip3MasterNode(\n        mnemonicToEntropy(path, englishWordlist),\n        curve,\n      );\n    default:\n      throw new Error('Unsupported master node generation spec.');\n  }\n}\n\n/**\n * Create a {@link SLIP10Node} from a BIP-39 seed.\n *\n * @param seed - The cryptographic seed bytes.\n * @param curve - The curve to use.\n * @returns An object containing the corresponding BIP-39 master key and chain\n * code.\n */\nexport async function createBip39KeyFromSeed(\n  seed: Uint8Array,\n  curve: Extract<Curve, { masterNodeGenerationSpec: 'slip10' }>,\n): Promise<SLIP10Node> {\n  assert(\n    seed.length >= 16 && seed.length <= 64,\n    'Invalid seed: The seed must be between 16 and 64 bytes long.',\n  );\n\n  const key = hmac(sha512, curve.secret, seed);\n  const privateKey = key.slice(0, BYTES_KEY_LENGTH);\n  const chainCode = key.slice(BYTES_KEY_LENGTH);\n\n  assert(\n    curve.isValidPrivateKey(privateKey),\n    'Invalid private key: The private key must greater than 0 and less than the curve order.',\n  );\n\n  const masterFingerprint = getFingerprint(\n    await curve.getPublicKey(privateKey, true),\n    curve.compressedPublicKeyLength,\n  );\n\n  return SLIP10Node.fromExtendedKey({\n    privateKey,\n    chainCode,\n    masterFingerprint,\n    depth: 0,\n    parentFingerprint: 0,\n    index: 0,\n    curve: curve.name,\n  });\n}\n\n/**\n * Create a {@link SLIP10Node} from BIP-39 entropy.\n * This function is consistent with the Icarus derivation scheme.\n * Icarus root key derivation scheme: https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/Icarus.md.\n * CIP3: https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/CIP-0003.md#master-key-generation.\n *\n * @param entropy - The entropy value.\n * @param curve - The curve to use.\n * @returns The root key pair consisting of 64-byte private key and 32-byte chain code.\n */\nexport async function entropyToCip3MasterNode(\n  entropy: Uint8Array,\n  curve: Extract<Curve, { masterNodeGenerationSpec: 'cip3' }>,\n): Promise<SLIP10Node> {\n  assert(\n    entropy.length >= 16 && entropy.length <= 64,\n    'Invalid entropy: The entropy must be between 16 and 64 bytes long.',\n  );\n\n  const rootNode = pbkdf2(sha512, curve.secret, entropy, {\n    c: 4096,\n    dkLen: 96,\n  });\n\n  // Consistent with the Icarus derivation scheme.\n  // https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/Icarus.md\n  /* eslint-disable no-bitwise */\n  rootNode[0] &= 0b1111_1000;\n  rootNode[31] &= 0b0001_1111;\n  rootNode[31] |= 0b0100_0000;\n  /* eslint-enable no-bitwise */\n\n  const privateKey = rootNode.slice(0, curve.privateKeyLength);\n  const chainCode = rootNode.slice(curve.privateKeyLength);\n\n  assert(curve.isValidPrivateKey(privateKey), 'Invalid private key.');\n\n  const masterFingerprint = getFingerprint(\n    await curve.getPublicKey(privateKey),\n    curve.compressedPublicKeyLength,\n  );\n\n  return SLIP10Node.fromExtendedKey({\n    privateKey,\n    chainCode,\n    masterFingerprint,\n    depth: 0,\n    parentFingerprint: 0,\n    index: 0,\n    curve: curve.name,\n  });\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"bip39.mjs","sourceRoot":"","sources":["../../src/derivers/bip39.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,iBAAiB,EAAE,8BAA8B;AAC1D,OAAO,EAAE,QAAQ,IAAI,eAAe,EAAE,wDAAqD;AAC3F,OAAO,EAAE,MAAM,EAAE,aAAa,EAAE,wBAAwB;AAIxD,OAAO,EAAE,gBAAgB,EAAE,yBAAqB;AAEhD,OAAO,EAAE,UAAU,EAAE,YAAY,EAAE,4BAAwB;AAE3D,OAAO,EAAE,UAAU,EAAE,0BAAsB;AAC3C,OAAO,EAAE,cAAc,EAAE,qBAAiB;AAE1C,MAAM,uBAAuB,GAAG,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC;AAErD;;;;;;;;GAQG;AACH,SAAS,sBAAsB,CAAC,cAAsB;IACpD,MAAM,KAAK,GAAG,cAAc,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IAExC,MAAM,CACJ,uBAAuB,CAAC,QAAQ,CAAC,KAAK,CAAC,MAAM,CAAC,EAC9C,2FAA2F,CAC5F,CAAC;IAEF,MAAM,CACJ,KAAK,CAAC,KAAK,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,eAAe,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,EACrD,wEAAwE,CACzE,CAAC;AACJ,CAAC;AAED;;;;;;;;GAQG;AACH,SAAS,oBAAoB,CAC3B,QAA6B,EAC7B,QAAkB;IAElB,IAAI,OAAO,QAAQ,KAAK,QAAQ,EAAE,CAAC;QACjC,sBAAsB,CAAC,QAAQ,CAAC,CAAC;QACjC,OAAO,aAAa,CAAC,QAAQ,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC;IACnD,CAAC;IAED,MAAM,cAAc,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,WAAW,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;SAChE,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;SACvB,IAAI,CAAC,GAAG,CAAC,CAAC;IAEb,sBAAsB,CAAC,cAAc,CAAC,CAAC;IACvC,OAAO,aAAa,CAAC,cAAc,CAAC,CAAC;AACvC,CAAC;AAED;;;;;;;;;;GAUG;AACH,MAAM,CAAC,KAAK,UAAU,cAAc,CAClC,QAA6B,EAC7B,UAAU,GAAG,EAAE,EACf,sBAA+C;IAE/C,MAAM,IAAI,GAAG,WAAW,UAAU,EAAE,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;IACvD,OAAO,MAAM,YAAY,CACvB,oBAAoB,CAAC,QAAQ,EAAE,eAAe,CAAC,EAC/C,aAAa,CAAC,IAAI,CAAC,EACnB,IAAI,EACJ,EAAE,EACF,sBAAsB,CACvB,CAAC;AACJ,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,wBAAwB,CAAC,QAAgB;IACvD,OAAO,SAAS,QAAQ,CAAC,WAAW,EAAE,CAAC,IAAI,EAAE,EAAE,CAAC;AAClD,CAAC;AAED;;;;;;;;;GASG;AACH,MAAM,CAAC,KAAK,UAAU,cAAc,CAClC,EAAE,IAAI,EAAE,KAAK,EAAsB,EACnC,sBAA+C;IAE/C,QAAQ,KAAK,CAAC,wBAAwB,EAAE,CAAC;QACvC,KAAK,QAAQ;YACX,OAAO,sBAAsB,CAC3B,MAAM,cAAc,CAAC,IAAI,EAAE,EAAE,EAAE,sBAAsB,CAAC,EACtD,KAAK,EACL,sBAAsB,CACvB,CAAC;QACJ,KAAK,MAAM;YACT,OAAO,uBAAuB,CAC5B,iBAAiB,CAAC,IAAI,EAAE,eAAe,CAAC,EACxC,KAAK,EACL,sBAAsB,CACvB,CAAC;QACJ;YACE,MAAM,IAAI,KAAK,CAAC,0CAA0C,CAAC,CAAC;IAChE,CAAC;AACH,CAAC;AAED;;;;;;;;;GASG;AACH,MAAM,CAAC,KAAK,UAAU,sBAAsB,CAC1C,IAAgB,EAChB,KAA6D,EAC7D,sBAA+C;IAE/C,MAAM,CACJ,IAAI,CAAC,MAAM,IAAI,EAAE,IAAI,IAAI,CAAC,MAAM,IAAI,EAAE,EACtC,8DAA8D,CAC/D,CAAC;IAEF,MAAM,GAAG,GAAG,MAAM,UAAU,CAAC,KAAK,CAAC,MAAM,EAAE,IAAI,EAAE,sBAAsB,CAAC,CAAC;IACzE,MAAM,UAAU,GAAG,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE,gBAAgB,CAAC,CAAC;IAClD,MAAM,SAAS,GAAG,GAAG,CAAC,KAAK,CAAC,gBAAgB,CAAC,CAAC;IAE9C,MAAM,CACJ,KAAK,CAAC,iBAAiB,CAAC,UAAU,CAAC,EACnC,yFAAyF,CAC1F,CAAC;IAEF,MAAM,iBAAiB,GAAG,cAAc,CACtC,MAAM,KAAK,CAAC,YAAY,CAAC,UAAU,EAAE,IAAI,CAAC,EAC1C,KAAK,CAAC,yBAAyB,CAChC,CAAC;IAEF,OAAO,UAAU,CAAC,eAAe,CAC/B;QACE,UAAU;QACV,SAAS;QACT,iBAAiB;QACjB,KAAK,EAAE,CAAC;QACR,iBAAiB,EAAE,CAAC;QACpB,KAAK,EAAE,CAAC;QACR,KAAK,EAAE,KAAK,CAAC,IAAI;KAClB,EACD,sBAAsB,CACvB,CAAC;AACJ,CAAC;AAED;;;;;;;;;;;GAWG;AACH,MAAM,CAAC,KAAK,UAAU,uBAAuB,CAC3C,OAAmB,EACnB,KAA2D,EAC3D,sBAA+C;IAE/C,MAAM,CACJ,OAAO,CAAC,MAAM,IAAI,EAAE,IAAI,OAAO,CAAC,MAAM,IAAI,EAAE,EAC5C,oEAAoE,CACrE,CAAC;IAEF,MAAM,QAAQ,GAAG,MAAM,YAAY,CACjC,KAAK,CAAC,MAAM,EACZ,OAAO,EACP,IAAI,EACJ,EAAE,EACF,sBAAsB,CACvB,CAAC;IAEF,gDAAgD;IAChD,8GAA8G;IAC9G,+BAA+B;IAC/B,QAAQ,CAAC,CAAC,CAAC,IAAI,GAAW,CAAC;IAC3B,QAAQ,CAAC,EAAE,CAAC,IAAI,EAAW,CAAC;IAC5B,QAAQ,CAAC,EAAE,CAAC,IAAI,EAAW,CAAC;IAC5B,8BAA8B;IAE9B,MAAM,UAAU,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,CAAC,gBAAgB,CAAC,CAAC;IAC7D,MAAM,SAAS,GAAG,QAAQ,CAAC,KAAK,CAAC,KAAK,CAAC,gBAAgB,CAAC,CAAC;IAEzD,MAAM,CAAC,KAAK,CAAC,iBAAiB,CAAC,UAAU,CAAC,EAAE,sBAAsB,CAAC,CAAC;IAEpE,MAAM,iBAAiB,GAAG,cAAc,CACtC,MAAM,KAAK,CAAC,YAAY,CAAC,UAAU,CAAC,EACpC,KAAK,CAAC,yBAAyB,CAChC,CAAC;IAEF,OAAO,UAAU,CAAC,eAAe,CAC/B;QACE,UAAU;QACV,SAAS;QACT,iBAAiB;QACjB,KAAK,EAAE,CAAC;QACR,iBAAiB,EAAE,CAAC;QACpB,KAAK,EAAE,CAAC;QACR,KAAK,EAAE,KAAK,CAAC,IAAI;KAClB,EACD,sBAAsB,CACvB,CAAC;AACJ,CAAC","sourcesContent":["import { mnemonicToEntropy } from '@metamask/scure-bip39';\nimport { wordlist as englishWordlist } from '@metamask/scure-bip39/dist/wordlists/english';\nimport { assert, stringToBytes } from '@metamask/utils';\n\nimport type { DeriveChildKeyArgs } from '.';\nimport type { BIP39StringNode } from '../constants';\nimport { BYTES_KEY_LENGTH } from '../constants';\nimport type { CryptographicFunctions } from '../cryptography';\nimport { hmacSha512, pbkdf2Sha512 } from '../cryptography';\nimport type { Curve } from '../curves';\nimport { SLIP10Node } from '../SLIP10Node';\nimport { getFingerprint } from '../utils';\n\nconst MNEMONIC_PHRASE_LENGTHS = [12, 15, 18, 21, 24];\n\n/**\n * Validate a BIP-39 mnemonic phrase. The phrase must:\n *\n * - Consist of 12, 15, 18, 21, or 24 words.\n * - Contain only words from the English wordlist.\n *\n * @param mnemonicPhrase - The mnemonic phrase to validate.\n * @throws If the mnemonic phrase is invalid.\n */\nfunction validateMnemonicPhrase(mnemonicPhrase: string): void {\n  const words = mnemonicPhrase.split(' ');\n\n  assert(\n    MNEMONIC_PHRASE_LENGTHS.includes(words.length),\n    `Invalid mnemonic phrase: The mnemonic phrase must consist of 12, 15, 18, 21, or 24 words.`,\n  );\n\n  assert(\n    words.every((word) => englishWordlist.includes(word)),\n    'Invalid mnemonic phrase: The mnemonic phrase contains an unknown word.',\n  );\n}\n\n/**\n * Encode a BIP-39 mnemonic phrase to a `Uint8Array` for use in seed generation.\n * If the mnemonic is already a `Uint8Array`, it is assumed to contain the\n * indices of the words in the wordlist.\n *\n * @param mnemonic - The mnemonic phrase to encode.\n * @param wordlist - The wordlist to use.\n * @returns The encoded mnemonic phrase.\n */\nfunction encodeMnemonicPhrase(\n  mnemonic: string | Uint8Array,\n  wordlist: string[],\n): Uint8Array {\n  if (typeof mnemonic === 'string') {\n    validateMnemonicPhrase(mnemonic);\n    return stringToBytes(mnemonic.normalize('NFKD'));\n  }\n\n  const mnemonicString = Array.from(new Uint16Array(mnemonic.buffer))\n    .map((i) => wordlist[i])\n    .join(' ');\n\n  validateMnemonicPhrase(mnemonicString);\n  return stringToBytes(mnemonicString);\n}\n\n/**\n * Convert a BIP-39 mnemonic phrase to a seed.\n *\n * @param mnemonic - The BIP-39 mnemonic phrase to convert. If the mnemonic is a\n * `Uint8Array`, it is assumed to contain the indices of the words in the\n * English wordlist.\n * @param passphrase - The passphrase to use.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The seed.\n */\nexport async function mnemonicToSeed(\n  mnemonic: string | Uint8Array,\n  passphrase = '',\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<Uint8Array> {\n  const salt = `mnemonic${passphrase}`.normalize('NFKD');\n  return await pbkdf2Sha512(\n    encodeMnemonicPhrase(mnemonic, englishWordlist),\n    stringToBytes(salt),\n    2048,\n    64,\n    cryptographicFunctions,\n  );\n}\n\n/**\n * Convert a BIP-39 mnemonic phrase to a multi path.\n *\n * @param mnemonic - The BIP-39 mnemonic phrase to convert.\n * @returns The multi path.\n */\nexport function bip39MnemonicToMultipath(mnemonic: string): BIP39StringNode {\n  return `bip39:${mnemonic.toLowerCase().trim()}`;\n}\n\n/**\n * Create a {@link SLIP10Node} from a BIP-39 mnemonic phrase.\n *\n * @param options - The options for creating the node.\n * @param options.path - The multi path.\n * @param options.curve - The curve to use for derivation.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The node.\n */\nexport async function deriveChildKey(\n  { path, curve }: DeriveChildKeyArgs,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<SLIP10Node> {\n  switch (curve.masterNodeGenerationSpec) {\n    case 'slip10':\n      return createBip39KeyFromSeed(\n        await mnemonicToSeed(path, '', cryptographicFunctions),\n        curve,\n        cryptographicFunctions,\n      );\n    case 'cip3':\n      return entropyToCip3MasterNode(\n        mnemonicToEntropy(path, englishWordlist),\n        curve,\n        cryptographicFunctions,\n      );\n    default:\n      throw new Error('Unsupported master node generation spec.');\n  }\n}\n\n/**\n * Create a {@link SLIP10Node} from a BIP-39 seed.\n *\n * @param seed - The cryptographic seed bytes.\n * @param curve - The curve to use.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns An object containing the corresponding BIP-39 master key and chain\n * code.\n */\nexport async function createBip39KeyFromSeed(\n  seed: Uint8Array,\n  curve: Extract<Curve, { masterNodeGenerationSpec: 'slip10' }>,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<SLIP10Node> {\n  assert(\n    seed.length >= 16 && seed.length <= 64,\n    'Invalid seed: The seed must be between 16 and 64 bytes long.',\n  );\n\n  const key = await hmacSha512(curve.secret, seed, cryptographicFunctions);\n  const privateKey = key.slice(0, BYTES_KEY_LENGTH);\n  const chainCode = key.slice(BYTES_KEY_LENGTH);\n\n  assert(\n    curve.isValidPrivateKey(privateKey),\n    'Invalid private key: The private key must greater than 0 and less than the curve order.',\n  );\n\n  const masterFingerprint = getFingerprint(\n    await curve.getPublicKey(privateKey, true),\n    curve.compressedPublicKeyLength,\n  );\n\n  return SLIP10Node.fromExtendedKey(\n    {\n      privateKey,\n      chainCode,\n      masterFingerprint,\n      depth: 0,\n      parentFingerprint: 0,\n      index: 0,\n      curve: curve.name,\n    },\n    cryptographicFunctions,\n  );\n}\n\n/**\n * Create a {@link SLIP10Node} from BIP-39 entropy.\n * This function is consistent with the Icarus derivation scheme.\n * Icarus root key derivation scheme: https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/Icarus.md.\n * CIP3: https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/CIP-0003.md#master-key-generation.\n *\n * @param entropy - The entropy value.\n * @param curve - The curve to use.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The root key pair consisting of 64-byte private key and 32-byte chain code.\n */\nexport async function entropyToCip3MasterNode(\n  entropy: Uint8Array,\n  curve: Extract<Curve, { masterNodeGenerationSpec: 'cip3' }>,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<SLIP10Node> {\n  assert(\n    entropy.length >= 16 && entropy.length <= 64,\n    'Invalid entropy: The entropy must be between 16 and 64 bytes long.',\n  );\n\n  const rootNode = await pbkdf2Sha512(\n    curve.secret,\n    entropy,\n    4096,\n    96,\n    cryptographicFunctions,\n  );\n\n  // Consistent with the Icarus derivation scheme.\n  // https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/Icarus.md\n  /* eslint-disable no-bitwise */\n  rootNode[0] &= 0b1111_1000;\n  rootNode[31] &= 0b0001_1111;\n  rootNode[31] |= 0b0100_0000;\n  /* eslint-enable no-bitwise */\n\n  const privateKey = rootNode.slice(0, curve.privateKeyLength);\n  const chainCode = rootNode.slice(curve.privateKeyLength);\n\n  assert(curve.isValidPrivateKey(privateKey), 'Invalid private key.');\n\n  const masterFingerprint = getFingerprint(\n    await curve.getPublicKey(privateKey),\n    curve.compressedPublicKeyLength,\n  );\n\n  return SLIP10Node.fromExtendedKey(\n    {\n      privateKey,\n      chainCode,\n      masterFingerprint,\n      depth: 0,\n      parentFingerprint: 0,\n      index: 0,\n      curve: curve.name,\n    },\n    cryptographicFunctions,\n  );\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/derivers/cip3.cjs b/node_modules/@metamask/key-tree/dist/derivers/cip3.cjs
index 8a1bc21..ad2c38f 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/cip3.cjs
+++ b/node_modules/@metamask/key-tree/dist/derivers/cip3.cjs
@@ -2,11 +2,11 @@
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.deriveChildKey = exports.derivePublicKey = exports.deriveChainCode = exports.derivePrivateKey = exports.getKeyExtension = exports.add = exports.mod2Pow256 = exports.trunc28Mul8 = exports.padEnd32Bytes = exports.bigIntToBytes = exports.bytesToBigInt = exports.toReversed = void 0;
 const utils_1 = require("@metamask/utils");
+const shared_1 = require("./shared.cjs");
 const constants_1 = require("../constants.cjs");
 const curves_1 = require("../curves/index.cjs");
 const SLIP10Node_1 = require("../SLIP10Node.cjs");
 const utils_2 = require("../utils.cjs");
-const shared_1 = require("./shared.cjs");
 /**
  * CIP-3 https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/CIP-0003.md.
  *
@@ -124,26 +124,30 @@ const Z_TAGS = {
     hardened: 0,
 };
 /**
- * Derives a private child key.
+ * Derive a private child key.
  *
- * Following "Section V. BIP32-ED25519: SPECIFICATION, C.1,2" in https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.
+ * Following "Section V. BIP32-ED25519: SPECIFICATION, C.1,2" in
+ * https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.
  *
- * @param param1 - The parameters for deriving a child key.
- * @param param1.parentNode - The parent node containing private key, chain code, and public key.
- * @param param1.childIndex - The index of the child key.
- * @param param1.isHardened - Indicates if the child key is hardened.
+ * @param options - The parameters for deriving a child key.
+ * @param options.parentNode - The parent node containing private key, chain
+ * code, and public key.
+ * @param options.childIndex - The index of the child key.
+ * @param options.isHardened - Indicates if the child key is hardened.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The derived child key.
  */
-const derivePrivateKey = async ({ parentNode, childIndex, isHardened, }) => {
+const derivePrivateKey = async ({ parentNode, childIndex, isHardened }, cryptographicFunctions) => {
     // extension = i >= 2^31 ? (0x00||kp||i) : (0x02||Ap||i)
     const extension = isHardened
         ? (0, exports.getKeyExtension)(Z_TAGS.hardened, parentNode.privateKeyBytes, childIndex + constants_1.BIP_32_HARDENED_OFFSET)
         : (0, exports.getKeyExtension)(Z_TAGS.normal, parentNode.publicKeyBytes, childIndex);
     // entropy = Fcp(extension)
-    const entropy = (0, shared_1.generateEntropy)({
+    const entropy = await (0, shared_1.generateEntropy)({
         chainCode: parentNode.chainCodeBytes,
         extension,
-    });
+    }, cryptographicFunctions);
     const zl = entropy.subarray(0, 32);
     const zr = entropy.subarray(32);
     const parentKl = parentNode.privateKeyBytes.subarray(0, 32);
@@ -160,26 +164,30 @@ const CHAIN_CODE_TAGS = {
     hardened: 1,
 };
 /**
- * Derives a child chainCode.
+ * Derive a child chainCode.
  *
- * Following "Section V. BIP32-ED25519: SPECIFICATION, C.3" in https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.
+ * Following "Section V. BIP32-ED25519: SPECIFICATION, C.3" in
+ * https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.
  *
- * @param param1 - The parameters for deriving a child chainCode.
- * @param param1.parentNode - The parent node containing optionally a private key, chain code, and public key.
- * @param param1.childIndex - The index of the child key.
- * @param param1.isHardened - Indicates if the child key is hardened.
+ * @param options - The parameters for deriving a child chainCode.
+ * @param options.parentNode - The parent node containing optionally a private
+ * key, chain code, and public key.
+ * @param options.childIndex - The index of the child key.
+ * @param options.isHardened - Indicates if the child key is hardened.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The derived child chainCode.
  */
-const deriveChainCode = async ({ parentNode, childIndex, isHardened, }) => {
+const deriveChainCode = async ({ parentNode, childIndex, isHardened, }, cryptographicFunctions) => {
     // extension = i >= 2^31 ? (0x01||kp||i) : (0x03||Ap||i)
     const extension = isHardened
         ? (0, exports.getKeyExtension)(CHAIN_CODE_TAGS.hardened, parentNode.privateKeyBytes, childIndex + constants_1.BIP_32_HARDENED_OFFSET)
         : (0, exports.getKeyExtension)(CHAIN_CODE_TAGS.normal, parentNode.publicKeyBytes, childIndex);
     // entropy = Fcp(extension)
-    const entropy = (0, shared_1.generateEntropy)({
+    const entropy = await (0, shared_1.generateEntropy)({
         chainCode: parentNode.chainCodeBytes,
         extension,
-    });
+    }, cryptographicFunctions);
     return entropy.subarray(32);
 };
 exports.deriveChainCode = deriveChainCode;
@@ -187,24 +195,27 @@ const PUBLIC_KEY_TAGS = {
     normal: 2,
 };
 /**
- * Derives a public key.
+ * Derive a public key.
  *
- * Following "Section V. BIP32-ED25519: SPECIFICATION, D" in https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.
+ * Following "Section V. BIP32-ED25519: SPECIFICATION, D" in
+ * https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.
  *
- * @param param1 - The parameters for deriving a child public key.
- * @param param1.parentNode - The parent node containing chain code, and public key.
- * @param param1.childIndex - The index of the child key.
- * @param param1.curve - Derivation curve.
+ * @param options - The parameters for deriving a child public key.
+ * @param options.parentNode - The parent node containing chain code, and public key.
+ * @param options.childIndex - The index of the child key.
+ * @param options.curve - Derivation curve.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The derived child public key.
  */
-const derivePublicKey = async ({ parentNode, childIndex, curve, }) => {
+const derivePublicKey = async ({ parentNode, childIndex, curve }, cryptographicFunctions) => {
     // extension = (0x02||Ap||i)
     const extension = (0, exports.getKeyExtension)(PUBLIC_KEY_TAGS.normal, parentNode.publicKeyBytes, childIndex);
     // entropy = Fcp(extension)
-    const entropy = (0, shared_1.generateEntropy)({
+    const entropy = await (0, shared_1.generateEntropy)({
         chainCode: parentNode.chainCodeBytes,
         extension,
-    });
+    }, cryptographicFunctions);
     const zl = entropy.slice(0, 32);
     // right = [8ZL] * B
     const right = await curve.getPublicKey(
@@ -218,9 +229,11 @@ exports.derivePublicKey = derivePublicKey;
  * Derive a SLIP-10 child key with a given path from a parent key.
  *
  * @param options - The options for deriving a child key.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns SLIP10Node.
  */
-async function deriveChildKey(options) {
+async function deriveChildKey(options, cryptographicFunctions) {
     const { curve, node, path } = options;
     (0, shared_1.validateNode)(node);
     const { childIndex, isHardened } = (0, shared_1.getValidatedPath)(path, node, curve);
@@ -239,12 +252,12 @@ async function deriveChildKey(options) {
             parentNode,
             childIndex,
             isHardened,
-        });
+        }, cryptographicFunctions);
         const chainCode = await (0, exports.deriveChainCode)({
             parentNode,
             childIndex,
             isHardened,
-        });
+        }, cryptographicFunctions);
         return SLIP10Node_1.SLIP10Node.fromExtendedKey({
             privateKey: (0, utils_1.bytesToHex)(privateKey),
             chainCode: (0, utils_1.bytesToHex)(chainCode),
@@ -253,7 +266,7 @@ async function deriveChildKey(options) {
             parentFingerprint,
             index: actualChildIndex,
             curve: curve.name,
-        });
+        }, cryptographicFunctions);
     }
     (0, utils_1.assert)(!isHardened, 'Invalid parameters: Cannot derive hardened child keys without a private key.');
     const parentNode = {
@@ -265,12 +278,12 @@ async function deriveChildKey(options) {
         childIndex,
         isHardened: false,
         curve,
-    });
+    }, cryptographicFunctions);
     const chainCode = await (0, exports.deriveChainCode)({
         parentNode,
         childIndex,
         isHardened: false,
-    });
+    }, cryptographicFunctions);
     return SLIP10Node_1.SLIP10Node.fromExtendedKey({
         publicKey: (0, utils_1.bytesToHex)(publicKey),
         chainCode: (0, utils_1.bytesToHex)(chainCode),
@@ -279,7 +292,7 @@ async function deriveChildKey(options) {
         parentFingerprint,
         index: actualChildIndex,
         curve: curve.name,
-    });
+    }, cryptographicFunctions);
 }
 exports.deriveChildKey = deriveChildKey;
 //# sourceMappingURL=cip3.cjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/derivers/cip3.cjs.map b/node_modules/@metamask/key-tree/dist/derivers/cip3.cjs.map
index 28dd0da..3fd79e5 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/cip3.cjs.map
+++ b/node_modules/@metamask/key-tree/dist/derivers/cip3.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"cip3.cjs","sourceRoot":"","sources":["../../src/derivers/cip3.ts"],"names":[],"mappings":"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","sourcesContent":["import { assert, bytesToHex, concatBytes, hexToBytes } from '@metamask/utils';\n\nimport type { DeriveChildKeyArgs } from '.';\nimport { BIP_32_HARDENED_OFFSET } from '../constants';\nimport { type Curve, mod } from '../curves';\nimport { SLIP10Node } from '../SLIP10Node';\nimport { numberToUint32 } from '../utils';\nimport { generateEntropy, getValidatedPath, validateNode } from './shared';\n\n/**\n * CIP-3 https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/CIP-0003.md.\n *\n * CIP-3 defines standards for deriving keys on Cardano.\n *\n * Key attributes.\n * - Root/Master key is derived from entropy, not seed. For this implementation we work with Icarus standard as it is the most widely used.\n * - See https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/Icarus.md.\n *\n * - HD node consists of a 64 byte private key, 32 byte public key and 32 byte chain code.\n * - See https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/CIP-0003.md#master-key-generation.\n *\n * - For derivation of BIP32 HD nodes, it uses modified version called BIP32-Ed25519.\n * - See https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.\n */\n\n/**\n * Reverses the order of bytes in a Uint8Array.\n *\n * Native BigInt uses big-endian. Since cip3(bip32Edd25519) uses little-endian.\n * We need to reverse the bytes and have separate functions for bigIntToBytes and bytesToBigInt.\n * .slice() is used just to make a copy of the array.\n *\n * @param bytes - The input Uint8Array.\n * @returns A new Uint8Array with the bytes in reversed order.\n */\nexport const toReversed = (bytes: Uint8Array) => bytes.slice().reverse();\n\n/**\n * Converts an array of bytes to a BigInt.\n *\n * @param bytes - The array of bytes to convert.\n * @returns The BigInt representation of the bytes.\n */\nexport const bytesToBigInt = (bytes: Uint8Array) => {\n  const reversed = toReversed(bytes);\n  const bytesInHex = bytesToHex(reversed);\n  return BigInt(bytesInHex);\n};\n\n/**\n * Converts a BigInt to a byte array.\n *\n * @param bigInt - The BigInt to convert.\n * @returns The byte array representation of the BigInt.\n */\nexport const bigIntToBytes = (bigInt: bigint) => {\n  const hexadecimal = bigInt.toString(16);\n  return toReversed(hexToBytes(hexadecimal));\n};\n\n/**\n * Pads end of the given bytes array with zeros to a length of 32 bytes.\n *\n * @param bytes - The bytes array to pad.\n * @returns The padded bytes array.\n */\nexport const padEnd32Bytes = (bytes: Uint8Array) => {\n  return concatBytes([\n    bytes,\n    new Uint8Array(Math.max(32 - bytes.length, 0)).fill(0),\n  ]);\n};\n\n/**\n * Truncates to first 28 bytes and multiplies by 8.\n *\n * @param bytes - Little-Endian big number in bytes.\n * @returns PadEnd32Bytes(left[0, 28] * 8)).\n */\nexport const trunc28Mul8 = (bytes: Uint8Array): Uint8Array => {\n  const truncLeftMul8 = bytesToBigInt(bytes.slice(0, 28)) * BigInt(8);\n  return padEnd32Bytes(bigIntToBytes(truncLeftMul8));\n};\n\n/**\n * Does module 2^256.\n *\n * @param bytes - Little-Endian big number in bytes.\n * @returns PadEnd32Bytes(mod(bytes, 2^256))).\n */\nexport const mod2Pow256 = (bytes: Uint8Array): Uint8Array => {\n  return padEnd32Bytes(\n    bigIntToBytes(mod(bytesToBigInt(bytes), BigInt(2) ** BigInt(256))),\n  );\n};\n\n/**\n * Adds the left to the right.\n *\n * @param left - Left hand side Little-Endian big number.\n * @param right - Right hand side Little-Endian big number.\n * @returns PadEnd32Bytes(left + right).\n */\nexport const add = (left: Uint8Array, right: Uint8Array): Uint8Array => {\n  const added = bytesToBigInt(left) + bytesToBigInt(right);\n  return padEnd32Bytes(bigIntToBytes(added)).slice(0, 32);\n};\n\n/**\n * Concat tag, key and childIndex.\n *\n * @param tag - Key specific tag.\n * @param key - Key.\n * @param childIndex - Child index.\n * @returns PadEnd32Bytes(left + right).\n */\nexport const getKeyExtension = (\n  tag: number,\n  key: Uint8Array,\n  childIndex: number,\n) => {\n  return concatBytes([\n    new Uint8Array([tag]),\n    key,\n    numberToUint32(childIndex, true),\n  ]);\n};\n\nexport type Cip3SupportedCurve = Extract<Curve, { name: 'ed25519Bip32' }>;\n\ntype DeriveKeyBaseArgs = { childIndex: number };\n\ntype DeriveWithPrivateArgs = DeriveKeyBaseArgs & {\n  parentNode: {\n    privateKeyBytes: Uint8Array;\n    chainCodeBytes: Uint8Array;\n    publicKeyBytes: Uint8Array;\n  };\n  isHardened: boolean;\n};\n\nconst Z_TAGS = {\n  normal: 2,\n  hardened: 0,\n};\n\n/**\n * Derives a private child key.\n *\n * Following \"Section V. BIP32-ED25519: SPECIFICATION, C.1,2\" in https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.\n *\n * @param param1 - The parameters for deriving a child key.\n * @param param1.parentNode - The parent node containing private key, chain code, and public key.\n * @param param1.childIndex - The index of the child key.\n * @param param1.isHardened - Indicates if the child key is hardened.\n * @returns The derived child key.\n */\nexport const derivePrivateKey = async ({\n  parentNode,\n  childIndex,\n  isHardened,\n}: DeriveWithPrivateArgs) => {\n  // extension = i >= 2^31 ? (0x00||kp||i) : (0x02||Ap||i)\n  const extension = isHardened\n    ? getKeyExtension(\n        Z_TAGS.hardened,\n        parentNode.privateKeyBytes,\n        childIndex + BIP_32_HARDENED_OFFSET,\n      )\n    : getKeyExtension(Z_TAGS.normal, parentNode.publicKeyBytes, childIndex);\n\n  // entropy = Fcp(extension)\n  const entropy = generateEntropy({\n    chainCode: parentNode.chainCodeBytes,\n    extension,\n  });\n\n  const zl = entropy.subarray(0, 32);\n  const zr = entropy.subarray(32);\n\n  const parentKl = parentNode.privateKeyBytes.subarray(0, 32);\n  const parentKr = parentNode.privateKeyBytes.subarray(32);\n\n  // 8[ZL] + kPL\n  const childKl = add(trunc28Mul8(zl), parentKl);\n  // ZR + kPR\n  const childKr = add(zr, parentKr);\n  return concatBytes([childKl, childKr]);\n};\n\ntype DeriveWithoutPrivateArgs = DeriveKeyBaseArgs & {\n  parentNode: {\n    chainCodeBytes: Uint8Array;\n    publicKeyBytes: Uint8Array;\n  };\n  isHardened: false;\n};\n\nconst CHAIN_CODE_TAGS = {\n  normal: 3,\n  hardened: 1,\n};\n\n/**\n * Derives a child chainCode.\n *\n * Following \"Section V. BIP32-ED25519: SPECIFICATION, C.3\" in https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.\n *\n * @param param1 - The parameters for deriving a child chainCode.\n * @param param1.parentNode - The parent node containing optionally a private key, chain code, and public key.\n * @param param1.childIndex - The index of the child key.\n * @param param1.isHardened - Indicates if the child key is hardened.\n * @returns The derived child chainCode.\n */\nexport const deriveChainCode = async ({\n  parentNode,\n  childIndex,\n  isHardened,\n}: DeriveWithPrivateArgs | DeriveWithoutPrivateArgs) => {\n  // extension = i >= 2^31 ? (0x01||kp||i) : (0x03||Ap||i)\n  const extension = isHardened\n    ? getKeyExtension(\n        CHAIN_CODE_TAGS.hardened,\n        parentNode.privateKeyBytes,\n        childIndex + BIP_32_HARDENED_OFFSET,\n      )\n    : getKeyExtension(\n        CHAIN_CODE_TAGS.normal,\n        parentNode.publicKeyBytes,\n        childIndex,\n      );\n\n  // entropy = Fcp(extension)\n  const entropy = generateEntropy({\n    chainCode: parentNode.chainCodeBytes,\n    extension,\n  });\n\n  return entropy.subarray(32);\n};\n\nconst PUBLIC_KEY_TAGS = {\n  normal: 2,\n};\n\ntype DerivePublicKeyArgs = DeriveWithoutPrivateArgs & {\n  curve: Cip3SupportedCurve;\n};\n\n/**\n * Derives a public key.\n *\n * Following \"Section V. BIP32-ED25519: SPECIFICATION, D\" in https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.\n *\n * @param param1 - The parameters for deriving a child public key.\n * @param param1.parentNode - The parent node containing chain code, and public key.\n * @param param1.childIndex - The index of the child key.\n * @param param1.curve - Derivation curve.\n * @returns The derived child public key.\n */\nexport const derivePublicKey = async ({\n  parentNode,\n  childIndex,\n  curve,\n}: DerivePublicKeyArgs) => {\n  // extension = (0x02||Ap||i)\n  const extension = getKeyExtension(\n    PUBLIC_KEY_TAGS.normal,\n    parentNode.publicKeyBytes,\n    childIndex,\n  );\n\n  // entropy = Fcp(extension)\n  const entropy = generateEntropy({\n    chainCode: parentNode.chainCodeBytes,\n    extension,\n  });\n\n  const zl = entropy.slice(0, 32);\n\n  // right = [8ZL] * B\n  const right = await curve.getPublicKey(\n    // [8ZL]\n    trunc28Mul8(zl),\n  );\n\n  // Ai = AP + [8ZL]B,\n  return curve.publicAdd(parentNode.publicKeyBytes, right);\n};\n\ntype Cip3DeriveChildKeyArgs = DeriveChildKeyArgs & {\n  curve: Cip3SupportedCurve;\n};\n\n/**\n * Derive a SLIP-10 child key with a given path from a parent key.\n *\n * @param options - The options for deriving a child key.\n * @returns SLIP10Node.\n */\nexport async function deriveChildKey(\n  options: Cip3DeriveChildKeyArgs,\n): Promise<SLIP10Node> {\n  const { curve, node, path } = options;\n  validateNode(node);\n\n  const { childIndex, isHardened } = getValidatedPath(path, node, curve);\n  if (curve.name !== 'ed25519Bip32' || !node) {\n    throw new Error(\n      'Unsupported curve: Only ed25519Bip32 is supported by CIP3.',\n    );\n  }\n\n  const actualChildIndex =\n    childIndex + (isHardened ? BIP_32_HARDENED_OFFSET : 0);\n\n  const {\n    privateKeyBytes,\n    chainCodeBytes,\n    publicKeyBytes,\n    masterFingerprint,\n    depth,\n    fingerprint: parentFingerprint,\n  } = node;\n\n  if (privateKeyBytes) {\n    const parentNode = {\n      privateKeyBytes,\n      chainCodeBytes,\n      publicKeyBytes,\n    };\n\n    const privateKey = await derivePrivateKey({\n      parentNode,\n      childIndex,\n      isHardened,\n    });\n\n    const chainCode = await deriveChainCode({\n      parentNode,\n      childIndex,\n      isHardened,\n    });\n\n    return SLIP10Node.fromExtendedKey({\n      privateKey: bytesToHex(privateKey),\n      chainCode: bytesToHex(chainCode),\n      masterFingerprint,\n      depth: depth + 1,\n      parentFingerprint,\n      index: actualChildIndex,\n      curve: curve.name,\n    });\n  }\n\n  assert(\n    !isHardened,\n    'Invalid parameters: Cannot derive hardened child keys without a private key.',\n  );\n\n  const parentNode = {\n    chainCodeBytes,\n    publicKeyBytes,\n  };\n\n  const publicKey = await derivePublicKey({\n    parentNode,\n    childIndex,\n    isHardened: false,\n    curve,\n  });\n\n  const chainCode = await deriveChainCode({\n    parentNode,\n    childIndex,\n    isHardened: false,\n  });\n\n  return SLIP10Node.fromExtendedKey({\n    publicKey: bytesToHex(publicKey),\n    chainCode: bytesToHex(chainCode),\n    masterFingerprint,\n    depth: depth + 1,\n    parentFingerprint,\n    index: actualChildIndex,\n    curve: curve.name,\n  });\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"cip3.cjs","sourceRoot":"","sources":["../../src/derivers/cip3.ts"],"names":[],"mappings":"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","sourcesContent":["import { assert, bytesToHex, concatBytes, hexToBytes } from '@metamask/utils';\n\nimport type { DeriveChildKeyArgs } from '.';\nimport { generateEntropy, getValidatedPath, validateNode } from './shared';\nimport { BIP_32_HARDENED_OFFSET } from '../constants';\nimport type { CryptographicFunctions } from '../cryptography';\nimport { type Curve, mod } from '../curves';\nimport { SLIP10Node } from '../SLIP10Node';\nimport { numberToUint32 } from '../utils';\n\n/**\n * CIP-3 https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/CIP-0003.md.\n *\n * CIP-3 defines standards for deriving keys on Cardano.\n *\n * Key attributes.\n * - Root/Master key is derived from entropy, not seed. For this implementation we work with Icarus standard as it is the most widely used.\n * - See https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/Icarus.md.\n *\n * - HD node consists of a 64 byte private key, 32 byte public key and 32 byte chain code.\n * - See https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/CIP-0003.md#master-key-generation.\n *\n * - For derivation of BIP32 HD nodes, it uses modified version called BIP32-Ed25519.\n * - See https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.\n */\n\n/**\n * Reverses the order of bytes in a Uint8Array.\n *\n * Native BigInt uses big-endian. Since cip3(bip32Edd25519) uses little-endian.\n * We need to reverse the bytes and have separate functions for bigIntToBytes and bytesToBigInt.\n * .slice() is used just to make a copy of the array.\n *\n * @param bytes - The input Uint8Array.\n * @returns A new Uint8Array with the bytes in reversed order.\n */\nexport const toReversed = (bytes: Uint8Array): Uint8Array =>\n  bytes.slice().reverse();\n\n/**\n * Converts an array of bytes to a BigInt.\n *\n * @param bytes - The array of bytes to convert.\n * @returns The BigInt representation of the bytes.\n */\nexport const bytesToBigInt = (bytes: Uint8Array): bigint => {\n  const reversed = toReversed(bytes);\n  const bytesInHex = bytesToHex(reversed);\n  return BigInt(bytesInHex);\n};\n\n/**\n * Converts a BigInt to a byte array.\n *\n * @param bigInt - The BigInt to convert.\n * @returns The byte array representation of the BigInt.\n */\nexport const bigIntToBytes = (bigInt: bigint): Uint8Array => {\n  const hexadecimal = bigInt.toString(16);\n  return toReversed(hexToBytes(hexadecimal));\n};\n\n/**\n * Pads end of the given bytes array with zeros to a length of 32 bytes.\n *\n * @param bytes - The bytes array to pad.\n * @returns The padded bytes array.\n */\nexport const padEnd32Bytes = (bytes: Uint8Array): Uint8Array => {\n  return concatBytes([\n    bytes,\n    new Uint8Array(Math.max(32 - bytes.length, 0)).fill(0),\n  ]);\n};\n\n/**\n * Truncates to first 28 bytes and multiplies by 8.\n *\n * @param bytes - Little-Endian big number in bytes.\n * @returns PadEnd32Bytes(left[0, 28] * 8)).\n */\nexport const trunc28Mul8 = (bytes: Uint8Array): Uint8Array => {\n  const truncLeftMul8 = bytesToBigInt(bytes.slice(0, 28)) * BigInt(8);\n  return padEnd32Bytes(bigIntToBytes(truncLeftMul8));\n};\n\n/**\n * Does module 2^256.\n *\n * @param bytes - Little-Endian big number in bytes.\n * @returns PadEnd32Bytes(mod(bytes, 2^256))).\n */\nexport const mod2Pow256 = (bytes: Uint8Array): Uint8Array => {\n  return padEnd32Bytes(\n    bigIntToBytes(mod(bytesToBigInt(bytes), BigInt(2) ** BigInt(256))),\n  );\n};\n\n/**\n * Adds the left to the right.\n *\n * @param left - Left hand side Little-Endian big number.\n * @param right - Right hand side Little-Endian big number.\n * @returns PadEnd32Bytes(left + right).\n */\nexport const add = (left: Uint8Array, right: Uint8Array): Uint8Array => {\n  const added = bytesToBigInt(left) + bytesToBigInt(right);\n  return padEnd32Bytes(bigIntToBytes(added)).slice(0, 32);\n};\n\n/**\n * Concat tag, key and childIndex.\n *\n * @param tag - Key specific tag.\n * @param key - Key.\n * @param childIndex - Child index.\n * @returns PadEnd32Bytes(left + right).\n */\nexport const getKeyExtension = (\n  tag: number,\n  key: Uint8Array,\n  childIndex: number,\n): Uint8Array => {\n  return concatBytes([\n    new Uint8Array([tag]),\n    key,\n    numberToUint32(childIndex, true),\n  ]);\n};\n\nexport type Cip3SupportedCurve = Extract<Curve, { name: 'ed25519Bip32' }>;\n\ntype DeriveKeyBaseArgs = { childIndex: number };\n\ntype DeriveWithPrivateArgs = DeriveKeyBaseArgs & {\n  parentNode: {\n    privateKeyBytes: Uint8Array;\n    chainCodeBytes: Uint8Array;\n    publicKeyBytes: Uint8Array;\n  };\n  isHardened: boolean;\n};\n\nconst Z_TAGS = {\n  normal: 2,\n  hardened: 0,\n};\n\n/**\n * Derive a private child key.\n *\n * Following \"Section V. BIP32-ED25519: SPECIFICATION, C.1,2\" in\n * https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.\n *\n * @param options - The parameters for deriving a child key.\n * @param options.parentNode - The parent node containing private key, chain\n * code, and public key.\n * @param options.childIndex - The index of the child key.\n * @param options.isHardened - Indicates if the child key is hardened.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The derived child key.\n */\nexport const derivePrivateKey = async (\n  { parentNode, childIndex, isHardened }: DeriveWithPrivateArgs,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<Uint8Array> => {\n  // extension = i >= 2^31 ? (0x00||kp||i) : (0x02||Ap||i)\n  const extension = isHardened\n    ? getKeyExtension(\n        Z_TAGS.hardened,\n        parentNode.privateKeyBytes,\n        childIndex + BIP_32_HARDENED_OFFSET,\n      )\n    : getKeyExtension(Z_TAGS.normal, parentNode.publicKeyBytes, childIndex);\n\n  // entropy = Fcp(extension)\n  const entropy = await generateEntropy(\n    {\n      chainCode: parentNode.chainCodeBytes,\n      extension,\n    },\n    cryptographicFunctions,\n  );\n\n  const zl = entropy.subarray(0, 32);\n  const zr = entropy.subarray(32);\n\n  const parentKl = parentNode.privateKeyBytes.subarray(0, 32);\n  const parentKr = parentNode.privateKeyBytes.subarray(32);\n\n  // 8[ZL] + kPL\n  const childKl = add(trunc28Mul8(zl), parentKl);\n  // ZR + kPR\n  const childKr = add(zr, parentKr);\n  return concatBytes([childKl, childKr]);\n};\n\ntype DeriveWithoutPrivateArgs = DeriveKeyBaseArgs & {\n  parentNode: {\n    chainCodeBytes: Uint8Array;\n    publicKeyBytes: Uint8Array;\n  };\n  isHardened: false;\n};\n\nconst CHAIN_CODE_TAGS = {\n  normal: 3,\n  hardened: 1,\n};\n\n/**\n * Derive a child chainCode.\n *\n * Following \"Section V. BIP32-ED25519: SPECIFICATION, C.3\" in\n * https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.\n *\n * @param options - The parameters for deriving a child chainCode.\n * @param options.parentNode - The parent node containing optionally a private\n * key, chain code, and public key.\n * @param options.childIndex - The index of the child key.\n * @param options.isHardened - Indicates if the child key is hardened.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The derived child chainCode.\n */\nexport const deriveChainCode = async (\n  {\n    parentNode,\n    childIndex,\n    isHardened,\n  }: DeriveWithPrivateArgs | DeriveWithoutPrivateArgs,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<Uint8Array> => {\n  // extension = i >= 2^31 ? (0x01||kp||i) : (0x03||Ap||i)\n  const extension = isHardened\n    ? getKeyExtension(\n        CHAIN_CODE_TAGS.hardened,\n        parentNode.privateKeyBytes,\n        childIndex + BIP_32_HARDENED_OFFSET,\n      )\n    : getKeyExtension(\n        CHAIN_CODE_TAGS.normal,\n        parentNode.publicKeyBytes,\n        childIndex,\n      );\n\n  // entropy = Fcp(extension)\n  const entropy = await generateEntropy(\n    {\n      chainCode: parentNode.chainCodeBytes,\n      extension,\n    },\n    cryptographicFunctions,\n  );\n\n  return entropy.subarray(32);\n};\n\nconst PUBLIC_KEY_TAGS = {\n  normal: 2,\n};\n\ntype DerivePublicKeyArgs = DeriveWithoutPrivateArgs & {\n  curve: Cip3SupportedCurve;\n};\n\n/**\n * Derive a public key.\n *\n * Following \"Section V. BIP32-ED25519: SPECIFICATION, D\" in\n * https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.\n *\n * @param options - The parameters for deriving a child public key.\n * @param options.parentNode - The parent node containing chain code, and public key.\n * @param options.childIndex - The index of the child key.\n * @param options.curve - Derivation curve.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The derived child public key.\n */\nexport const derivePublicKey = async (\n  { parentNode, childIndex, curve }: DerivePublicKeyArgs,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<Uint8Array> => {\n  // extension = (0x02||Ap||i)\n  const extension = getKeyExtension(\n    PUBLIC_KEY_TAGS.normal,\n    parentNode.publicKeyBytes,\n    childIndex,\n  );\n\n  // entropy = Fcp(extension)\n  const entropy = await generateEntropy(\n    {\n      chainCode: parentNode.chainCodeBytes,\n      extension,\n    },\n    cryptographicFunctions,\n  );\n\n  const zl = entropy.slice(0, 32);\n\n  // right = [8ZL] * B\n  const right = await curve.getPublicKey(\n    // [8ZL]\n    trunc28Mul8(zl),\n  );\n\n  // Ai = AP + [8ZL]B,\n  return curve.publicAdd(parentNode.publicKeyBytes, right);\n};\n\ntype Cip3DeriveChildKeyArgs = DeriveChildKeyArgs & {\n  curve: Cip3SupportedCurve;\n};\n\n/**\n * Derive a SLIP-10 child key with a given path from a parent key.\n *\n * @param options - The options for deriving a child key.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns SLIP10Node.\n */\nexport async function deriveChildKey(\n  options: Cip3DeriveChildKeyArgs,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<SLIP10Node> {\n  const { curve, node, path } = options;\n  validateNode(node);\n\n  const { childIndex, isHardened } = getValidatedPath(path, node, curve);\n  if (curve.name !== 'ed25519Bip32' || !node) {\n    throw new Error(\n      'Unsupported curve: Only ed25519Bip32 is supported by CIP3.',\n    );\n  }\n\n  const actualChildIndex =\n    childIndex + (isHardened ? BIP_32_HARDENED_OFFSET : 0);\n\n  const {\n    privateKeyBytes,\n    chainCodeBytes,\n    publicKeyBytes,\n    masterFingerprint,\n    depth,\n    fingerprint: parentFingerprint,\n  } = node;\n\n  if (privateKeyBytes) {\n    const parentNode = {\n      privateKeyBytes,\n      chainCodeBytes,\n      publicKeyBytes,\n    };\n\n    const privateKey = await derivePrivateKey(\n      {\n        parentNode,\n        childIndex,\n        isHardened,\n      },\n      cryptographicFunctions,\n    );\n\n    const chainCode = await deriveChainCode(\n      {\n        parentNode,\n        childIndex,\n        isHardened,\n      },\n      cryptographicFunctions,\n    );\n\n    return SLIP10Node.fromExtendedKey(\n      {\n        privateKey: bytesToHex(privateKey),\n        chainCode: bytesToHex(chainCode),\n        masterFingerprint,\n        depth: depth + 1,\n        parentFingerprint,\n        index: actualChildIndex,\n        curve: curve.name,\n      },\n      cryptographicFunctions,\n    );\n  }\n\n  assert(\n    !isHardened,\n    'Invalid parameters: Cannot derive hardened child keys without a private key.',\n  );\n\n  const parentNode = {\n    chainCodeBytes,\n    publicKeyBytes,\n  };\n\n  const publicKey = await derivePublicKey(\n    {\n      parentNode,\n      childIndex,\n      isHardened: false,\n      curve,\n    },\n    cryptographicFunctions,\n  );\n\n  const chainCode = await deriveChainCode(\n    {\n      parentNode,\n      childIndex,\n      isHardened: false,\n    },\n    cryptographicFunctions,\n  );\n\n  return SLIP10Node.fromExtendedKey(\n    {\n      publicKey: bytesToHex(publicKey),\n      chainCode: bytesToHex(chainCode),\n      masterFingerprint,\n      depth: depth + 1,\n      parentFingerprint,\n      index: actualChildIndex,\n      curve: curve.name,\n    },\n    cryptographicFunctions,\n  );\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/derivers/cip3.d.cts b/node_modules/@metamask/key-tree/dist/derivers/cip3.d.cts
index 07343ee..bee0953 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/cip3.d.cts
+++ b/node_modules/@metamask/key-tree/dist/derivers/cip3.d.cts
@@ -1,4 +1,5 @@
 import type { DeriveChildKeyArgs } from "./index.cjs";
+import type { CryptographicFunctions } from "../cryptography.cjs";
 import { type Curve } from "../curves/index.cjs";
 import { SLIP10Node } from "../SLIP10Node.cjs";
 /**
@@ -79,13 +80,13 @@ export declare const add: (left: Uint8Array, right: Uint8Array) => Uint8Array;
  * @returns PadEnd32Bytes(left + right).
  */
 export declare const getKeyExtension: (tag: number, key: Uint8Array, childIndex: number) => Uint8Array;
-export declare type Cip3SupportedCurve = Extract<Curve, {
+export type Cip3SupportedCurve = Extract<Curve, {
     name: 'ed25519Bip32';
 }>;
-declare type DeriveKeyBaseArgs = {
+type DeriveKeyBaseArgs = {
     childIndex: number;
 };
-declare type DeriveWithPrivateArgs = DeriveKeyBaseArgs & {
+type DeriveWithPrivateArgs = DeriveKeyBaseArgs & {
     parentNode: {
         privateKeyBytes: Uint8Array;
         chainCodeBytes: Uint8Array;
@@ -94,18 +95,22 @@ declare type DeriveWithPrivateArgs = DeriveKeyBaseArgs & {
     isHardened: boolean;
 };
 /**
- * Derives a private child key.
- *
- * Following "Section V. BIP32-ED25519: SPECIFICATION, C.1,2" in https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.
- *
- * @param param1 - The parameters for deriving a child key.
- * @param param1.parentNode - The parent node containing private key, chain code, and public key.
- * @param param1.childIndex - The index of the child key.
- * @param param1.isHardened - Indicates if the child key is hardened.
+ * Derive a private child key.
+ *
+ * Following "Section V. BIP32-ED25519: SPECIFICATION, C.1,2" in
+ * https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.
+ *
+ * @param options - The parameters for deriving a child key.
+ * @param options.parentNode - The parent node containing private key, chain
+ * code, and public key.
+ * @param options.childIndex - The index of the child key.
+ * @param options.isHardened - Indicates if the child key is hardened.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The derived child key.
  */
-export declare const derivePrivateKey: ({ parentNode, childIndex, isHardened, }: DeriveWithPrivateArgs) => Promise<Uint8Array>;
-declare type DeriveWithoutPrivateArgs = DeriveKeyBaseArgs & {
+export declare const derivePrivateKey: ({ parentNode, childIndex, isHardened }: DeriveWithPrivateArgs, cryptographicFunctions?: CryptographicFunctions) => Promise<Uint8Array>;
+type DeriveWithoutPrivateArgs = DeriveKeyBaseArgs & {
     parentNode: {
         chainCodeBytes: Uint8Array;
         publicKeyBytes: Uint8Array;
@@ -113,41 +118,50 @@ declare type DeriveWithoutPrivateArgs = DeriveKeyBaseArgs & {
     isHardened: false;
 };
 /**
- * Derives a child chainCode.
- *
- * Following "Section V. BIP32-ED25519: SPECIFICATION, C.3" in https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.
- *
- * @param param1 - The parameters for deriving a child chainCode.
- * @param param1.parentNode - The parent node containing optionally a private key, chain code, and public key.
- * @param param1.childIndex - The index of the child key.
- * @param param1.isHardened - Indicates if the child key is hardened.
+ * Derive a child chainCode.
+ *
+ * Following "Section V. BIP32-ED25519: SPECIFICATION, C.3" in
+ * https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.
+ *
+ * @param options - The parameters for deriving a child chainCode.
+ * @param options.parentNode - The parent node containing optionally a private
+ * key, chain code, and public key.
+ * @param options.childIndex - The index of the child key.
+ * @param options.isHardened - Indicates if the child key is hardened.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The derived child chainCode.
  */
-export declare const deriveChainCode: ({ parentNode, childIndex, isHardened, }: DeriveWithPrivateArgs | DeriveWithoutPrivateArgs) => Promise<Uint8Array>;
-declare type DerivePublicKeyArgs = DeriveWithoutPrivateArgs & {
+export declare const deriveChainCode: ({ parentNode, childIndex, isHardened, }: DeriveWithPrivateArgs | DeriveWithoutPrivateArgs, cryptographicFunctions?: CryptographicFunctions) => Promise<Uint8Array>;
+type DerivePublicKeyArgs = DeriveWithoutPrivateArgs & {
     curve: Cip3SupportedCurve;
 };
 /**
- * Derives a public key.
+ * Derive a public key.
  *
- * Following "Section V. BIP32-ED25519: SPECIFICATION, D" in https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.
+ * Following "Section V. BIP32-ED25519: SPECIFICATION, D" in
+ * https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.
  *
- * @param param1 - The parameters for deriving a child public key.
- * @param param1.parentNode - The parent node containing chain code, and public key.
- * @param param1.childIndex - The index of the child key.
- * @param param1.curve - Derivation curve.
+ * @param options - The parameters for deriving a child public key.
+ * @param options.parentNode - The parent node containing chain code, and public key.
+ * @param options.childIndex - The index of the child key.
+ * @param options.curve - Derivation curve.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The derived child public key.
  */
-export declare const derivePublicKey: ({ parentNode, childIndex, curve, }: DerivePublicKeyArgs) => Promise<Uint8Array>;
-declare type Cip3DeriveChildKeyArgs = DeriveChildKeyArgs & {
+export declare const derivePublicKey: ({ parentNode, childIndex, curve }: DerivePublicKeyArgs, cryptographicFunctions?: CryptographicFunctions) => Promise<Uint8Array>;
+type Cip3DeriveChildKeyArgs = DeriveChildKeyArgs & {
     curve: Cip3SupportedCurve;
 };
 /**
  * Derive a SLIP-10 child key with a given path from a parent key.
  *
  * @param options - The options for deriving a child key.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns SLIP10Node.
  */
-export declare function deriveChildKey(options: Cip3DeriveChildKeyArgs): Promise<SLIP10Node>;
+export declare function deriveChildKey(options: Cip3DeriveChildKeyArgs, cryptographicFunctions?: CryptographicFunctions): Promise<SLIP10Node>;
 export {};
 //# sourceMappingURL=cip3.d.cts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/derivers/cip3.d.cts.map b/node_modules/@metamask/key-tree/dist/derivers/cip3.d.cts.map
index 307d4bf..2523f34 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/cip3.d.cts.map
+++ b/node_modules/@metamask/key-tree/dist/derivers/cip3.d.cts.map
@@ -1 +1 @@
-{"version":3,"file":"cip3.d.cts","sourceRoot":"","sources":["../../src/derivers/cip3.ts"],"names":[],"mappings":"AAEA,OAAO,KAAK,EAAE,kBAAkB,EAAE,oBAAU;AAE5C,OAAO,EAAE,KAAK,KAAK,EAAO,4BAAkB;AAC5C,OAAO,EAAE,UAAU,EAAE,0BAAsB;AAI3C;;;;;;;;;;;;;;GAcG;AAEH;;;;;;;;;GASG;AACH,eAAO,MAAM,UAAU,UAAW,UAAU,eAA4B,CAAC;AAEzE;;;;;GAKG;AACH,eAAO,MAAM,aAAa,UAAW,UAAU,WAI9C,CAAC;AAEF;;;;;GAKG;AACH,eAAO,MAAM,aAAa,WAAY,MAAM,eAG3C,CAAC;AAEF;;;;;GAKG;AACH,eAAO,MAAM,aAAa,UAAW,UAAU,eAK9C,CAAC;AAEF;;;;;GAKG;AACH,eAAO,MAAM,WAAW,UAAW,UAAU,KAAG,UAG/C,CAAC;AAEF;;;;;GAKG;AACH,eAAO,MAAM,UAAU,UAAW,UAAU,KAAG,UAI9C,CAAC;AAEF;;;;;;GAMG;AACH,eAAO,MAAM,GAAG,SAAU,UAAU,SAAS,UAAU,KAAG,UAGzD,CAAC;AAEF;;;;;;;GAOG;AACH,eAAO,MAAM,eAAe,QACrB,MAAM,OACN,UAAU,cACH,MAAM,eAOnB,CAAC;AAEF,oBAAY,kBAAkB,GAAG,OAAO,CAAC,KAAK,EAAE;IAAE,IAAI,EAAE,cAAc,CAAA;CAAE,CAAC,CAAC;AAE1E,aAAK,iBAAiB,GAAG;IAAE,UAAU,EAAE,MAAM,CAAA;CAAE,CAAC;AAEhD,aAAK,qBAAqB,GAAG,iBAAiB,GAAG;IAC/C,UAAU,EAAE;QACV,eAAe,EAAE,UAAU,CAAC;QAC5B,cAAc,EAAE,UAAU,CAAC;QAC3B,cAAc,EAAE,UAAU,CAAC;KAC5B,CAAC;IACF,UAAU,EAAE,OAAO,CAAC;CACrB,CAAC;AAOF;;;;;;;;;;GAUG;AACH,eAAO,MAAM,gBAAgB,4CAI1B,qBAAqB,wBA2BvB,CAAC;AAEF,aAAK,wBAAwB,GAAG,iBAAiB,GAAG;IAClD,UAAU,EAAE;QACV,cAAc,EAAE,UAAU,CAAC;QAC3B,cAAc,EAAE,UAAU,CAAC;KAC5B,CAAC;IACF,UAAU,EAAE,KAAK,CAAC;CACnB,CAAC;AAOF;;;;;;;;;;GAUG;AACH,eAAO,MAAM,eAAe,4CAIzB,qBAAqB,GAAG,wBAAwB,wBAqBlD,CAAC;AAMF,aAAK,mBAAmB,GAAG,wBAAwB,GAAG;IACpD,KAAK,EAAE,kBAAkB,CAAC;CAC3B,CAAC;AAEF;;;;;;;;;;GAUG;AACH,eAAO,MAAM,eAAe,uCAIzB,mBAAmB,wBAwBrB,CAAC;AAEF,aAAK,sBAAsB,GAAG,kBAAkB,GAAG;IACjD,KAAK,EAAE,kBAAkB,CAAC;CAC3B,CAAC;AAEF;;;;;GAKG;AACH,wBAAsB,cAAc,CAClC,OAAO,EAAE,sBAAsB,GAC9B,OAAO,CAAC,UAAU,CAAC,CAqFrB"}
\ No newline at end of file
+{"version":3,"file":"cip3.d.cts","sourceRoot":"","sources":["../../src/derivers/cip3.ts"],"names":[],"mappings":"AAEA,OAAO,KAAK,EAAE,kBAAkB,EAAE,oBAAU;AAG5C,OAAO,KAAK,EAAE,sBAAsB,EAAE,4BAAwB;AAC9D,OAAO,EAAE,KAAK,KAAK,EAAO,4BAAkB;AAC5C,OAAO,EAAE,UAAU,EAAE,0BAAsB;AAG3C;;;;;;;;;;;;;;GAcG;AAEH;;;;;;;;;GASG;AACH,eAAO,MAAM,UAAU,UAAW,UAAU,KAAG,UACtB,CAAC;AAE1B;;;;;GAKG;AACH,eAAO,MAAM,aAAa,UAAW,UAAU,KAAG,MAIjD,CAAC;AAEF;;;;;GAKG;AACH,eAAO,MAAM,aAAa,WAAY,MAAM,KAAG,UAG9C,CAAC;AAEF;;;;;GAKG;AACH,eAAO,MAAM,aAAa,UAAW,UAAU,KAAG,UAKjD,CAAC;AAEF;;;;;GAKG;AACH,eAAO,MAAM,WAAW,UAAW,UAAU,KAAG,UAG/C,CAAC;AAEF;;;;;GAKG;AACH,eAAO,MAAM,UAAU,UAAW,UAAU,KAAG,UAI9C,CAAC;AAEF;;;;;;GAMG;AACH,eAAO,MAAM,GAAG,SAAU,UAAU,SAAS,UAAU,KAAG,UAGzD,CAAC;AAEF;;;;;;;GAOG;AACH,eAAO,MAAM,eAAe,QACrB,MAAM,OACN,UAAU,cACH,MAAM,KACjB,UAMF,CAAC;AAEF,MAAM,MAAM,kBAAkB,GAAG,OAAO,CAAC,KAAK,EAAE;IAAE,IAAI,EAAE,cAAc,CAAA;CAAE,CAAC,CAAC;AAE1E,KAAK,iBAAiB,GAAG;IAAE,UAAU,EAAE,MAAM,CAAA;CAAE,CAAC;AAEhD,KAAK,qBAAqB,GAAG,iBAAiB,GAAG;IAC/C,UAAU,EAAE;QACV,eAAe,EAAE,UAAU,CAAC;QAC5B,cAAc,EAAE,UAAU,CAAC;QAC3B,cAAc,EAAE,UAAU,CAAC;KAC5B,CAAC;IACF,UAAU,EAAE,OAAO,CAAC;CACrB,CAAC;AAOF;;;;;;;;;;;;;;GAcG;AACH,eAAO,MAAM,gBAAgB,2CACa,qBAAqB,2BACpC,sBAAsB,KAC9C,QAAQ,UAAU,CA8BpB,CAAC;AAEF,KAAK,wBAAwB,GAAG,iBAAiB,GAAG;IAClD,UAAU,EAAE;QACV,cAAc,EAAE,UAAU,CAAC;QAC3B,cAAc,EAAE,UAAU,CAAC;KAC5B,CAAC;IACF,UAAU,EAAE,KAAK,CAAC;CACnB,CAAC;AAOF;;;;;;;;;;;;;;GAcG;AACH,eAAO,MAAM,eAAe,4CAKvB,qBAAqB,GAAG,wBAAwB,2BAC1B,sBAAsB,KAC9C,QAAQ,UAAU,CAwBpB,CAAC;AAMF,KAAK,mBAAmB,GAAG,wBAAwB,GAAG;IACpD,KAAK,EAAE,kBAAkB,CAAC;CAC3B,CAAC;AAEF;;;;;;;;;;;;;GAaG;AACH,eAAO,MAAM,eAAe,sCACS,mBAAmB,2BAC7B,sBAAsB,KAC9C,QAAQ,UAAU,CA2BpB,CAAC;AAEF,KAAK,sBAAsB,GAAG,kBAAkB,GAAG;IACjD,KAAK,EAAE,kBAAkB,CAAC;CAC3B,CAAC;AAEF;;;;;;;GAOG;AACH,wBAAsB,cAAc,CAClC,OAAO,EAAE,sBAAsB,EAC/B,sBAAsB,CAAC,EAAE,sBAAsB,GAC9C,OAAO,CAAC,UAAU,CAAC,CAuGrB"}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/derivers/cip3.d.mts b/node_modules/@metamask/key-tree/dist/derivers/cip3.d.mts
index 048ed57..457a06d 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/cip3.d.mts
+++ b/node_modules/@metamask/key-tree/dist/derivers/cip3.d.mts
@@ -1,4 +1,5 @@
 import type { DeriveChildKeyArgs } from "./index.mjs";
+import type { CryptographicFunctions } from "../cryptography.mjs";
 import { type Curve } from "../curves/index.mjs";
 import { SLIP10Node } from "../SLIP10Node.mjs";
 /**
@@ -79,13 +80,13 @@ export declare const add: (left: Uint8Array, right: Uint8Array) => Uint8Array;
  * @returns PadEnd32Bytes(left + right).
  */
 export declare const getKeyExtension: (tag: number, key: Uint8Array, childIndex: number) => Uint8Array;
-export declare type Cip3SupportedCurve = Extract<Curve, {
+export type Cip3SupportedCurve = Extract<Curve, {
     name: 'ed25519Bip32';
 }>;
-declare type DeriveKeyBaseArgs = {
+type DeriveKeyBaseArgs = {
     childIndex: number;
 };
-declare type DeriveWithPrivateArgs = DeriveKeyBaseArgs & {
+type DeriveWithPrivateArgs = DeriveKeyBaseArgs & {
     parentNode: {
         privateKeyBytes: Uint8Array;
         chainCodeBytes: Uint8Array;
@@ -94,18 +95,22 @@ declare type DeriveWithPrivateArgs = DeriveKeyBaseArgs & {
     isHardened: boolean;
 };
 /**
- * Derives a private child key.
- *
- * Following "Section V. BIP32-ED25519: SPECIFICATION, C.1,2" in https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.
- *
- * @param param1 - The parameters for deriving a child key.
- * @param param1.parentNode - The parent node containing private key, chain code, and public key.
- * @param param1.childIndex - The index of the child key.
- * @param param1.isHardened - Indicates if the child key is hardened.
+ * Derive a private child key.
+ *
+ * Following "Section V. BIP32-ED25519: SPECIFICATION, C.1,2" in
+ * https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.
+ *
+ * @param options - The parameters for deriving a child key.
+ * @param options.parentNode - The parent node containing private key, chain
+ * code, and public key.
+ * @param options.childIndex - The index of the child key.
+ * @param options.isHardened - Indicates if the child key is hardened.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The derived child key.
  */
-export declare const derivePrivateKey: ({ parentNode, childIndex, isHardened, }: DeriveWithPrivateArgs) => Promise<Uint8Array>;
-declare type DeriveWithoutPrivateArgs = DeriveKeyBaseArgs & {
+export declare const derivePrivateKey: ({ parentNode, childIndex, isHardened }: DeriveWithPrivateArgs, cryptographicFunctions?: CryptographicFunctions) => Promise<Uint8Array>;
+type DeriveWithoutPrivateArgs = DeriveKeyBaseArgs & {
     parentNode: {
         chainCodeBytes: Uint8Array;
         publicKeyBytes: Uint8Array;
@@ -113,41 +118,50 @@ declare type DeriveWithoutPrivateArgs = DeriveKeyBaseArgs & {
     isHardened: false;
 };
 /**
- * Derives a child chainCode.
- *
- * Following "Section V. BIP32-ED25519: SPECIFICATION, C.3" in https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.
- *
- * @param param1 - The parameters for deriving a child chainCode.
- * @param param1.parentNode - The parent node containing optionally a private key, chain code, and public key.
- * @param param1.childIndex - The index of the child key.
- * @param param1.isHardened - Indicates if the child key is hardened.
+ * Derive a child chainCode.
+ *
+ * Following "Section V. BIP32-ED25519: SPECIFICATION, C.3" in
+ * https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.
+ *
+ * @param options - The parameters for deriving a child chainCode.
+ * @param options.parentNode - The parent node containing optionally a private
+ * key, chain code, and public key.
+ * @param options.childIndex - The index of the child key.
+ * @param options.isHardened - Indicates if the child key is hardened.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The derived child chainCode.
  */
-export declare const deriveChainCode: ({ parentNode, childIndex, isHardened, }: DeriveWithPrivateArgs | DeriveWithoutPrivateArgs) => Promise<Uint8Array>;
-declare type DerivePublicKeyArgs = DeriveWithoutPrivateArgs & {
+export declare const deriveChainCode: ({ parentNode, childIndex, isHardened, }: DeriveWithPrivateArgs | DeriveWithoutPrivateArgs, cryptographicFunctions?: CryptographicFunctions) => Promise<Uint8Array>;
+type DerivePublicKeyArgs = DeriveWithoutPrivateArgs & {
     curve: Cip3SupportedCurve;
 };
 /**
- * Derives a public key.
+ * Derive a public key.
  *
- * Following "Section V. BIP32-ED25519: SPECIFICATION, D" in https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.
+ * Following "Section V. BIP32-ED25519: SPECIFICATION, D" in
+ * https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.
  *
- * @param param1 - The parameters for deriving a child public key.
- * @param param1.parentNode - The parent node containing chain code, and public key.
- * @param param1.childIndex - The index of the child key.
- * @param param1.curve - Derivation curve.
+ * @param options - The parameters for deriving a child public key.
+ * @param options.parentNode - The parent node containing chain code, and public key.
+ * @param options.childIndex - The index of the child key.
+ * @param options.curve - Derivation curve.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The derived child public key.
  */
-export declare const derivePublicKey: ({ parentNode, childIndex, curve, }: DerivePublicKeyArgs) => Promise<Uint8Array>;
-declare type Cip3DeriveChildKeyArgs = DeriveChildKeyArgs & {
+export declare const derivePublicKey: ({ parentNode, childIndex, curve }: DerivePublicKeyArgs, cryptographicFunctions?: CryptographicFunctions) => Promise<Uint8Array>;
+type Cip3DeriveChildKeyArgs = DeriveChildKeyArgs & {
     curve: Cip3SupportedCurve;
 };
 /**
  * Derive a SLIP-10 child key with a given path from a parent key.
  *
  * @param options - The options for deriving a child key.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns SLIP10Node.
  */
-export declare function deriveChildKey(options: Cip3DeriveChildKeyArgs): Promise<SLIP10Node>;
+export declare function deriveChildKey(options: Cip3DeriveChildKeyArgs, cryptographicFunctions?: CryptographicFunctions): Promise<SLIP10Node>;
 export {};
 //# sourceMappingURL=cip3.d.mts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/derivers/cip3.d.mts.map b/node_modules/@metamask/key-tree/dist/derivers/cip3.d.mts.map
index c1d9259..97c49d8 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/cip3.d.mts.map
+++ b/node_modules/@metamask/key-tree/dist/derivers/cip3.d.mts.map
@@ -1 +1 @@
-{"version":3,"file":"cip3.d.mts","sourceRoot":"","sources":["../../src/derivers/cip3.ts"],"names":[],"mappings":"AAEA,OAAO,KAAK,EAAE,kBAAkB,EAAE,oBAAU;AAE5C,OAAO,EAAE,KAAK,KAAK,EAAO,4BAAkB;AAC5C,OAAO,EAAE,UAAU,EAAE,0BAAsB;AAI3C;;;;;;;;;;;;;;GAcG;AAEH;;;;;;;;;GASG;AACH,eAAO,MAAM,UAAU,UAAW,UAAU,eAA4B,CAAC;AAEzE;;;;;GAKG;AACH,eAAO,MAAM,aAAa,UAAW,UAAU,WAI9C,CAAC;AAEF;;;;;GAKG;AACH,eAAO,MAAM,aAAa,WAAY,MAAM,eAG3C,CAAC;AAEF;;;;;GAKG;AACH,eAAO,MAAM,aAAa,UAAW,UAAU,eAK9C,CAAC;AAEF;;;;;GAKG;AACH,eAAO,MAAM,WAAW,UAAW,UAAU,KAAG,UAG/C,CAAC;AAEF;;;;;GAKG;AACH,eAAO,MAAM,UAAU,UAAW,UAAU,KAAG,UAI9C,CAAC;AAEF;;;;;;GAMG;AACH,eAAO,MAAM,GAAG,SAAU,UAAU,SAAS,UAAU,KAAG,UAGzD,CAAC;AAEF;;;;;;;GAOG;AACH,eAAO,MAAM,eAAe,QACrB,MAAM,OACN,UAAU,cACH,MAAM,eAOnB,CAAC;AAEF,oBAAY,kBAAkB,GAAG,OAAO,CAAC,KAAK,EAAE;IAAE,IAAI,EAAE,cAAc,CAAA;CAAE,CAAC,CAAC;AAE1E,aAAK,iBAAiB,GAAG;IAAE,UAAU,EAAE,MAAM,CAAA;CAAE,CAAC;AAEhD,aAAK,qBAAqB,GAAG,iBAAiB,GAAG;IAC/C,UAAU,EAAE;QACV,eAAe,EAAE,UAAU,CAAC;QAC5B,cAAc,EAAE,UAAU,CAAC;QAC3B,cAAc,EAAE,UAAU,CAAC;KAC5B,CAAC;IACF,UAAU,EAAE,OAAO,CAAC;CACrB,CAAC;AAOF;;;;;;;;;;GAUG;AACH,eAAO,MAAM,gBAAgB,4CAI1B,qBAAqB,wBA2BvB,CAAC;AAEF,aAAK,wBAAwB,GAAG,iBAAiB,GAAG;IAClD,UAAU,EAAE;QACV,cAAc,EAAE,UAAU,CAAC;QAC3B,cAAc,EAAE,UAAU,CAAC;KAC5B,CAAC;IACF,UAAU,EAAE,KAAK,CAAC;CACnB,CAAC;AAOF;;;;;;;;;;GAUG;AACH,eAAO,MAAM,eAAe,4CAIzB,qBAAqB,GAAG,wBAAwB,wBAqBlD,CAAC;AAMF,aAAK,mBAAmB,GAAG,wBAAwB,GAAG;IACpD,KAAK,EAAE,kBAAkB,CAAC;CAC3B,CAAC;AAEF;;;;;;;;;;GAUG;AACH,eAAO,MAAM,eAAe,uCAIzB,mBAAmB,wBAwBrB,CAAC;AAEF,aAAK,sBAAsB,GAAG,kBAAkB,GAAG;IACjD,KAAK,EAAE,kBAAkB,CAAC;CAC3B,CAAC;AAEF;;;;;GAKG;AACH,wBAAsB,cAAc,CAClC,OAAO,EAAE,sBAAsB,GAC9B,OAAO,CAAC,UAAU,CAAC,CAqFrB"}
\ No newline at end of file
+{"version":3,"file":"cip3.d.mts","sourceRoot":"","sources":["../../src/derivers/cip3.ts"],"names":[],"mappings":"AAEA,OAAO,KAAK,EAAE,kBAAkB,EAAE,oBAAU;AAG5C,OAAO,KAAK,EAAE,sBAAsB,EAAE,4BAAwB;AAC9D,OAAO,EAAE,KAAK,KAAK,EAAO,4BAAkB;AAC5C,OAAO,EAAE,UAAU,EAAE,0BAAsB;AAG3C;;;;;;;;;;;;;;GAcG;AAEH;;;;;;;;;GASG;AACH,eAAO,MAAM,UAAU,UAAW,UAAU,KAAG,UACtB,CAAC;AAE1B;;;;;GAKG;AACH,eAAO,MAAM,aAAa,UAAW,UAAU,KAAG,MAIjD,CAAC;AAEF;;;;;GAKG;AACH,eAAO,MAAM,aAAa,WAAY,MAAM,KAAG,UAG9C,CAAC;AAEF;;;;;GAKG;AACH,eAAO,MAAM,aAAa,UAAW,UAAU,KAAG,UAKjD,CAAC;AAEF;;;;;GAKG;AACH,eAAO,MAAM,WAAW,UAAW,UAAU,KAAG,UAG/C,CAAC;AAEF;;;;;GAKG;AACH,eAAO,MAAM,UAAU,UAAW,UAAU,KAAG,UAI9C,CAAC;AAEF;;;;;;GAMG;AACH,eAAO,MAAM,GAAG,SAAU,UAAU,SAAS,UAAU,KAAG,UAGzD,CAAC;AAEF;;;;;;;GAOG;AACH,eAAO,MAAM,eAAe,QACrB,MAAM,OACN,UAAU,cACH,MAAM,KACjB,UAMF,CAAC;AAEF,MAAM,MAAM,kBAAkB,GAAG,OAAO,CAAC,KAAK,EAAE;IAAE,IAAI,EAAE,cAAc,CAAA;CAAE,CAAC,CAAC;AAE1E,KAAK,iBAAiB,GAAG;IAAE,UAAU,EAAE,MAAM,CAAA;CAAE,CAAC;AAEhD,KAAK,qBAAqB,GAAG,iBAAiB,GAAG;IAC/C,UAAU,EAAE;QACV,eAAe,EAAE,UAAU,CAAC;QAC5B,cAAc,EAAE,UAAU,CAAC;QAC3B,cAAc,EAAE,UAAU,CAAC;KAC5B,CAAC;IACF,UAAU,EAAE,OAAO,CAAC;CACrB,CAAC;AAOF;;;;;;;;;;;;;;GAcG;AACH,eAAO,MAAM,gBAAgB,2CACa,qBAAqB,2BACpC,sBAAsB,KAC9C,QAAQ,UAAU,CA8BpB,CAAC;AAEF,KAAK,wBAAwB,GAAG,iBAAiB,GAAG;IAClD,UAAU,EAAE;QACV,cAAc,EAAE,UAAU,CAAC;QAC3B,cAAc,EAAE,UAAU,CAAC;KAC5B,CAAC;IACF,UAAU,EAAE,KAAK,CAAC;CACnB,CAAC;AAOF;;;;;;;;;;;;;;GAcG;AACH,eAAO,MAAM,eAAe,4CAKvB,qBAAqB,GAAG,wBAAwB,2BAC1B,sBAAsB,KAC9C,QAAQ,UAAU,CAwBpB,CAAC;AAMF,KAAK,mBAAmB,GAAG,wBAAwB,GAAG;IACpD,KAAK,EAAE,kBAAkB,CAAC;CAC3B,CAAC;AAEF;;;;;;;;;;;;;GAaG;AACH,eAAO,MAAM,eAAe,sCACS,mBAAmB,2BAC7B,sBAAsB,KAC9C,QAAQ,UAAU,CA2BpB,CAAC;AAEF,KAAK,sBAAsB,GAAG,kBAAkB,GAAG;IACjD,KAAK,EAAE,kBAAkB,CAAC;CAC3B,CAAC;AAEF;;;;;;;GAOG;AACH,wBAAsB,cAAc,CAClC,OAAO,EAAE,sBAAsB,EAC/B,sBAAsB,CAAC,EAAE,sBAAsB,GAC9C,OAAO,CAAC,UAAU,CAAC,CAuGrB"}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/derivers/cip3.mjs b/node_modules/@metamask/key-tree/dist/derivers/cip3.mjs
index 6191f2b..5e6eb2e 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/cip3.mjs
+++ b/node_modules/@metamask/key-tree/dist/derivers/cip3.mjs
@@ -1,9 +1,9 @@
 import { assert, bytesToHex, concatBytes, hexToBytes } from "@metamask/utils";
+import { generateEntropy, getValidatedPath, validateNode } from "./shared.mjs";
 import { BIP_32_HARDENED_OFFSET } from "../constants.mjs";
 import { mod } from "../curves/index.mjs";
 import { SLIP10Node } from "../SLIP10Node.mjs";
 import { numberToUint32 } from "../utils.mjs";
-import { generateEntropy, getValidatedPath, validateNode } from "./shared.mjs";
 /**
  * CIP-3 https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/CIP-0003.md.
  *
@@ -113,26 +113,30 @@ const Z_TAGS = {
     hardened: 0,
 };
 /**
- * Derives a private child key.
+ * Derive a private child key.
  *
- * Following "Section V. BIP32-ED25519: SPECIFICATION, C.1,2" in https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.
+ * Following "Section V. BIP32-ED25519: SPECIFICATION, C.1,2" in
+ * https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.
  *
- * @param param1 - The parameters for deriving a child key.
- * @param param1.parentNode - The parent node containing private key, chain code, and public key.
- * @param param1.childIndex - The index of the child key.
- * @param param1.isHardened - Indicates if the child key is hardened.
+ * @param options - The parameters for deriving a child key.
+ * @param options.parentNode - The parent node containing private key, chain
+ * code, and public key.
+ * @param options.childIndex - The index of the child key.
+ * @param options.isHardened - Indicates if the child key is hardened.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The derived child key.
  */
-export const derivePrivateKey = async ({ parentNode, childIndex, isHardened, }) => {
+export const derivePrivateKey = async ({ parentNode, childIndex, isHardened }, cryptographicFunctions) => {
     // extension = i >= 2^31 ? (0x00||kp||i) : (0x02||Ap||i)
     const extension = isHardened
         ? getKeyExtension(Z_TAGS.hardened, parentNode.privateKeyBytes, childIndex + BIP_32_HARDENED_OFFSET)
         : getKeyExtension(Z_TAGS.normal, parentNode.publicKeyBytes, childIndex);
     // entropy = Fcp(extension)
-    const entropy = generateEntropy({
+    const entropy = await generateEntropy({
         chainCode: parentNode.chainCodeBytes,
         extension,
-    });
+    }, cryptographicFunctions);
     const zl = entropy.subarray(0, 32);
     const zr = entropy.subarray(32);
     const parentKl = parentNode.privateKeyBytes.subarray(0, 32);
@@ -148,50 +152,57 @@ const CHAIN_CODE_TAGS = {
     hardened: 1,
 };
 /**
- * Derives a child chainCode.
+ * Derive a child chainCode.
  *
- * Following "Section V. BIP32-ED25519: SPECIFICATION, C.3" in https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.
+ * Following "Section V. BIP32-ED25519: SPECIFICATION, C.3" in
+ * https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.
  *
- * @param param1 - The parameters for deriving a child chainCode.
- * @param param1.parentNode - The parent node containing optionally a private key, chain code, and public key.
- * @param param1.childIndex - The index of the child key.
- * @param param1.isHardened - Indicates if the child key is hardened.
+ * @param options - The parameters for deriving a child chainCode.
+ * @param options.parentNode - The parent node containing optionally a private
+ * key, chain code, and public key.
+ * @param options.childIndex - The index of the child key.
+ * @param options.isHardened - Indicates if the child key is hardened.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The derived child chainCode.
  */
-export const deriveChainCode = async ({ parentNode, childIndex, isHardened, }) => {
+export const deriveChainCode = async ({ parentNode, childIndex, isHardened, }, cryptographicFunctions) => {
     // extension = i >= 2^31 ? (0x01||kp||i) : (0x03||Ap||i)
     const extension = isHardened
         ? getKeyExtension(CHAIN_CODE_TAGS.hardened, parentNode.privateKeyBytes, childIndex + BIP_32_HARDENED_OFFSET)
         : getKeyExtension(CHAIN_CODE_TAGS.normal, parentNode.publicKeyBytes, childIndex);
     // entropy = Fcp(extension)
-    const entropy = generateEntropy({
+    const entropy = await generateEntropy({
         chainCode: parentNode.chainCodeBytes,
         extension,
-    });
+    }, cryptographicFunctions);
     return entropy.subarray(32);
 };
 const PUBLIC_KEY_TAGS = {
     normal: 2,
 };
 /**
- * Derives a public key.
+ * Derive a public key.
  *
- * Following "Section V. BIP32-ED25519: SPECIFICATION, D" in https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.
+ * Following "Section V. BIP32-ED25519: SPECIFICATION, D" in
+ * https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.
  *
- * @param param1 - The parameters for deriving a child public key.
- * @param param1.parentNode - The parent node containing chain code, and public key.
- * @param param1.childIndex - The index of the child key.
- * @param param1.curve - Derivation curve.
+ * @param options - The parameters for deriving a child public key.
+ * @param options.parentNode - The parent node containing chain code, and public key.
+ * @param options.childIndex - The index of the child key.
+ * @param options.curve - Derivation curve.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The derived child public key.
  */
-export const derivePublicKey = async ({ parentNode, childIndex, curve, }) => {
+export const derivePublicKey = async ({ parentNode, childIndex, curve }, cryptographicFunctions) => {
     // extension = (0x02||Ap||i)
     const extension = getKeyExtension(PUBLIC_KEY_TAGS.normal, parentNode.publicKeyBytes, childIndex);
     // entropy = Fcp(extension)
-    const entropy = generateEntropy({
+    const entropy = await generateEntropy({
         chainCode: parentNode.chainCodeBytes,
         extension,
-    });
+    }, cryptographicFunctions);
     const zl = entropy.slice(0, 32);
     // right = [8ZL] * B
     const right = await curve.getPublicKey(
@@ -204,9 +215,11 @@ export const derivePublicKey = async ({ parentNode, childIndex, curve, }) => {
  * Derive a SLIP-10 child key with a given path from a parent key.
  *
  * @param options - The options for deriving a child key.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns SLIP10Node.
  */
-export async function deriveChildKey(options) {
+export async function deriveChildKey(options, cryptographicFunctions) {
     const { curve, node, path } = options;
     validateNode(node);
     const { childIndex, isHardened } = getValidatedPath(path, node, curve);
@@ -225,12 +238,12 @@ export async function deriveChildKey(options) {
             parentNode,
             childIndex,
             isHardened,
-        });
+        }, cryptographicFunctions);
         const chainCode = await deriveChainCode({
             parentNode,
             childIndex,
             isHardened,
-        });
+        }, cryptographicFunctions);
         return SLIP10Node.fromExtendedKey({
             privateKey: bytesToHex(privateKey),
             chainCode: bytesToHex(chainCode),
@@ -239,7 +252,7 @@ export async function deriveChildKey(options) {
             parentFingerprint,
             index: actualChildIndex,
             curve: curve.name,
-        });
+        }, cryptographicFunctions);
     }
     assert(!isHardened, 'Invalid parameters: Cannot derive hardened child keys without a private key.');
     const parentNode = {
@@ -251,12 +264,12 @@ export async function deriveChildKey(options) {
         childIndex,
         isHardened: false,
         curve,
-    });
+    }, cryptographicFunctions);
     const chainCode = await deriveChainCode({
         parentNode,
         childIndex,
         isHardened: false,
-    });
+    }, cryptographicFunctions);
     return SLIP10Node.fromExtendedKey({
         publicKey: bytesToHex(publicKey),
         chainCode: bytesToHex(chainCode),
@@ -265,6 +278,6 @@ export async function deriveChildKey(options) {
         parentFingerprint,
         index: actualChildIndex,
         curve: curve.name,
-    });
+    }, cryptographicFunctions);
 }
 //# sourceMappingURL=cip3.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/derivers/cip3.mjs.map b/node_modules/@metamask/key-tree/dist/derivers/cip3.mjs.map
index 71b4f1d..ce20d1c 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/cip3.mjs.map
+++ b/node_modules/@metamask/key-tree/dist/derivers/cip3.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"cip3.mjs","sourceRoot":"","sources":["../../src/derivers/cip3.ts"],"names":[],"mappings":"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","sourcesContent":["import { assert, bytesToHex, concatBytes, hexToBytes } from '@metamask/utils';\n\nimport type { DeriveChildKeyArgs } from '.';\nimport { BIP_32_HARDENED_OFFSET } from '../constants';\nimport { type Curve, mod } from '../curves';\nimport { SLIP10Node } from '../SLIP10Node';\nimport { numberToUint32 } from '../utils';\nimport { generateEntropy, getValidatedPath, validateNode } from './shared';\n\n/**\n * CIP-3 https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/CIP-0003.md.\n *\n * CIP-3 defines standards for deriving keys on Cardano.\n *\n * Key attributes.\n * - Root/Master key is derived from entropy, not seed. For this implementation we work with Icarus standard as it is the most widely used.\n * - See https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/Icarus.md.\n *\n * - HD node consists of a 64 byte private key, 32 byte public key and 32 byte chain code.\n * - See https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/CIP-0003.md#master-key-generation.\n *\n * - For derivation of BIP32 HD nodes, it uses modified version called BIP32-Ed25519.\n * - See https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.\n */\n\n/**\n * Reverses the order of bytes in a Uint8Array.\n *\n * Native BigInt uses big-endian. Since cip3(bip32Edd25519) uses little-endian.\n * We need to reverse the bytes and have separate functions for bigIntToBytes and bytesToBigInt.\n * .slice() is used just to make a copy of the array.\n *\n * @param bytes - The input Uint8Array.\n * @returns A new Uint8Array with the bytes in reversed order.\n */\nexport const toReversed = (bytes: Uint8Array) => bytes.slice().reverse();\n\n/**\n * Converts an array of bytes to a BigInt.\n *\n * @param bytes - The array of bytes to convert.\n * @returns The BigInt representation of the bytes.\n */\nexport const bytesToBigInt = (bytes: Uint8Array) => {\n  const reversed = toReversed(bytes);\n  const bytesInHex = bytesToHex(reversed);\n  return BigInt(bytesInHex);\n};\n\n/**\n * Converts a BigInt to a byte array.\n *\n * @param bigInt - The BigInt to convert.\n * @returns The byte array representation of the BigInt.\n */\nexport const bigIntToBytes = (bigInt: bigint) => {\n  const hexadecimal = bigInt.toString(16);\n  return toReversed(hexToBytes(hexadecimal));\n};\n\n/**\n * Pads end of the given bytes array with zeros to a length of 32 bytes.\n *\n * @param bytes - The bytes array to pad.\n * @returns The padded bytes array.\n */\nexport const padEnd32Bytes = (bytes: Uint8Array) => {\n  return concatBytes([\n    bytes,\n    new Uint8Array(Math.max(32 - bytes.length, 0)).fill(0),\n  ]);\n};\n\n/**\n * Truncates to first 28 bytes and multiplies by 8.\n *\n * @param bytes - Little-Endian big number in bytes.\n * @returns PadEnd32Bytes(left[0, 28] * 8)).\n */\nexport const trunc28Mul8 = (bytes: Uint8Array): Uint8Array => {\n  const truncLeftMul8 = bytesToBigInt(bytes.slice(0, 28)) * BigInt(8);\n  return padEnd32Bytes(bigIntToBytes(truncLeftMul8));\n};\n\n/**\n * Does module 2^256.\n *\n * @param bytes - Little-Endian big number in bytes.\n * @returns PadEnd32Bytes(mod(bytes, 2^256))).\n */\nexport const mod2Pow256 = (bytes: Uint8Array): Uint8Array => {\n  return padEnd32Bytes(\n    bigIntToBytes(mod(bytesToBigInt(bytes), BigInt(2) ** BigInt(256))),\n  );\n};\n\n/**\n * Adds the left to the right.\n *\n * @param left - Left hand side Little-Endian big number.\n * @param right - Right hand side Little-Endian big number.\n * @returns PadEnd32Bytes(left + right).\n */\nexport const add = (left: Uint8Array, right: Uint8Array): Uint8Array => {\n  const added = bytesToBigInt(left) + bytesToBigInt(right);\n  return padEnd32Bytes(bigIntToBytes(added)).slice(0, 32);\n};\n\n/**\n * Concat tag, key and childIndex.\n *\n * @param tag - Key specific tag.\n * @param key - Key.\n * @param childIndex - Child index.\n * @returns PadEnd32Bytes(left + right).\n */\nexport const getKeyExtension = (\n  tag: number,\n  key: Uint8Array,\n  childIndex: number,\n) => {\n  return concatBytes([\n    new Uint8Array([tag]),\n    key,\n    numberToUint32(childIndex, true),\n  ]);\n};\n\nexport type Cip3SupportedCurve = Extract<Curve, { name: 'ed25519Bip32' }>;\n\ntype DeriveKeyBaseArgs = { childIndex: number };\n\ntype DeriveWithPrivateArgs = DeriveKeyBaseArgs & {\n  parentNode: {\n    privateKeyBytes: Uint8Array;\n    chainCodeBytes: Uint8Array;\n    publicKeyBytes: Uint8Array;\n  };\n  isHardened: boolean;\n};\n\nconst Z_TAGS = {\n  normal: 2,\n  hardened: 0,\n};\n\n/**\n * Derives a private child key.\n *\n * Following \"Section V. BIP32-ED25519: SPECIFICATION, C.1,2\" in https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.\n *\n * @param param1 - The parameters for deriving a child key.\n * @param param1.parentNode - The parent node containing private key, chain code, and public key.\n * @param param1.childIndex - The index of the child key.\n * @param param1.isHardened - Indicates if the child key is hardened.\n * @returns The derived child key.\n */\nexport const derivePrivateKey = async ({\n  parentNode,\n  childIndex,\n  isHardened,\n}: DeriveWithPrivateArgs) => {\n  // extension = i >= 2^31 ? (0x00||kp||i) : (0x02||Ap||i)\n  const extension = isHardened\n    ? getKeyExtension(\n        Z_TAGS.hardened,\n        parentNode.privateKeyBytes,\n        childIndex + BIP_32_HARDENED_OFFSET,\n      )\n    : getKeyExtension(Z_TAGS.normal, parentNode.publicKeyBytes, childIndex);\n\n  // entropy = Fcp(extension)\n  const entropy = generateEntropy({\n    chainCode: parentNode.chainCodeBytes,\n    extension,\n  });\n\n  const zl = entropy.subarray(0, 32);\n  const zr = entropy.subarray(32);\n\n  const parentKl = parentNode.privateKeyBytes.subarray(0, 32);\n  const parentKr = parentNode.privateKeyBytes.subarray(32);\n\n  // 8[ZL] + kPL\n  const childKl = add(trunc28Mul8(zl), parentKl);\n  // ZR + kPR\n  const childKr = add(zr, parentKr);\n  return concatBytes([childKl, childKr]);\n};\n\ntype DeriveWithoutPrivateArgs = DeriveKeyBaseArgs & {\n  parentNode: {\n    chainCodeBytes: Uint8Array;\n    publicKeyBytes: Uint8Array;\n  };\n  isHardened: false;\n};\n\nconst CHAIN_CODE_TAGS = {\n  normal: 3,\n  hardened: 1,\n};\n\n/**\n * Derives a child chainCode.\n *\n * Following \"Section V. BIP32-ED25519: SPECIFICATION, C.3\" in https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.\n *\n * @param param1 - The parameters for deriving a child chainCode.\n * @param param1.parentNode - The parent node containing optionally a private key, chain code, and public key.\n * @param param1.childIndex - The index of the child key.\n * @param param1.isHardened - Indicates if the child key is hardened.\n * @returns The derived child chainCode.\n */\nexport const deriveChainCode = async ({\n  parentNode,\n  childIndex,\n  isHardened,\n}: DeriveWithPrivateArgs | DeriveWithoutPrivateArgs) => {\n  // extension = i >= 2^31 ? (0x01||kp||i) : (0x03||Ap||i)\n  const extension = isHardened\n    ? getKeyExtension(\n        CHAIN_CODE_TAGS.hardened,\n        parentNode.privateKeyBytes,\n        childIndex + BIP_32_HARDENED_OFFSET,\n      )\n    : getKeyExtension(\n        CHAIN_CODE_TAGS.normal,\n        parentNode.publicKeyBytes,\n        childIndex,\n      );\n\n  // entropy = Fcp(extension)\n  const entropy = generateEntropy({\n    chainCode: parentNode.chainCodeBytes,\n    extension,\n  });\n\n  return entropy.subarray(32);\n};\n\nconst PUBLIC_KEY_TAGS = {\n  normal: 2,\n};\n\ntype DerivePublicKeyArgs = DeriveWithoutPrivateArgs & {\n  curve: Cip3SupportedCurve;\n};\n\n/**\n * Derives a public key.\n *\n * Following \"Section V. BIP32-ED25519: SPECIFICATION, D\" in https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.\n *\n * @param param1 - The parameters for deriving a child public key.\n * @param param1.parentNode - The parent node containing chain code, and public key.\n * @param param1.childIndex - The index of the child key.\n * @param param1.curve - Derivation curve.\n * @returns The derived child public key.\n */\nexport const derivePublicKey = async ({\n  parentNode,\n  childIndex,\n  curve,\n}: DerivePublicKeyArgs) => {\n  // extension = (0x02||Ap||i)\n  const extension = getKeyExtension(\n    PUBLIC_KEY_TAGS.normal,\n    parentNode.publicKeyBytes,\n    childIndex,\n  );\n\n  // entropy = Fcp(extension)\n  const entropy = generateEntropy({\n    chainCode: parentNode.chainCodeBytes,\n    extension,\n  });\n\n  const zl = entropy.slice(0, 32);\n\n  // right = [8ZL] * B\n  const right = await curve.getPublicKey(\n    // [8ZL]\n    trunc28Mul8(zl),\n  );\n\n  // Ai = AP + [8ZL]B,\n  return curve.publicAdd(parentNode.publicKeyBytes, right);\n};\n\ntype Cip3DeriveChildKeyArgs = DeriveChildKeyArgs & {\n  curve: Cip3SupportedCurve;\n};\n\n/**\n * Derive a SLIP-10 child key with a given path from a parent key.\n *\n * @param options - The options for deriving a child key.\n * @returns SLIP10Node.\n */\nexport async function deriveChildKey(\n  options: Cip3DeriveChildKeyArgs,\n): Promise<SLIP10Node> {\n  const { curve, node, path } = options;\n  validateNode(node);\n\n  const { childIndex, isHardened } = getValidatedPath(path, node, curve);\n  if (curve.name !== 'ed25519Bip32' || !node) {\n    throw new Error(\n      'Unsupported curve: Only ed25519Bip32 is supported by CIP3.',\n    );\n  }\n\n  const actualChildIndex =\n    childIndex + (isHardened ? BIP_32_HARDENED_OFFSET : 0);\n\n  const {\n    privateKeyBytes,\n    chainCodeBytes,\n    publicKeyBytes,\n    masterFingerprint,\n    depth,\n    fingerprint: parentFingerprint,\n  } = node;\n\n  if (privateKeyBytes) {\n    const parentNode = {\n      privateKeyBytes,\n      chainCodeBytes,\n      publicKeyBytes,\n    };\n\n    const privateKey = await derivePrivateKey({\n      parentNode,\n      childIndex,\n      isHardened,\n    });\n\n    const chainCode = await deriveChainCode({\n      parentNode,\n      childIndex,\n      isHardened,\n    });\n\n    return SLIP10Node.fromExtendedKey({\n      privateKey: bytesToHex(privateKey),\n      chainCode: bytesToHex(chainCode),\n      masterFingerprint,\n      depth: depth + 1,\n      parentFingerprint,\n      index: actualChildIndex,\n      curve: curve.name,\n    });\n  }\n\n  assert(\n    !isHardened,\n    'Invalid parameters: Cannot derive hardened child keys without a private key.',\n  );\n\n  const parentNode = {\n    chainCodeBytes,\n    publicKeyBytes,\n  };\n\n  const publicKey = await derivePublicKey({\n    parentNode,\n    childIndex,\n    isHardened: false,\n    curve,\n  });\n\n  const chainCode = await deriveChainCode({\n    parentNode,\n    childIndex,\n    isHardened: false,\n  });\n\n  return SLIP10Node.fromExtendedKey({\n    publicKey: bytesToHex(publicKey),\n    chainCode: bytesToHex(chainCode),\n    masterFingerprint,\n    depth: depth + 1,\n    parentFingerprint,\n    index: actualChildIndex,\n    curve: curve.name,\n  });\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"cip3.mjs","sourceRoot":"","sources":["../../src/derivers/cip3.ts"],"names":[],"mappings":"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","sourcesContent":["import { assert, bytesToHex, concatBytes, hexToBytes } from '@metamask/utils';\n\nimport type { DeriveChildKeyArgs } from '.';\nimport { generateEntropy, getValidatedPath, validateNode } from './shared';\nimport { BIP_32_HARDENED_OFFSET } from '../constants';\nimport type { CryptographicFunctions } from '../cryptography';\nimport { type Curve, mod } from '../curves';\nimport { SLIP10Node } from '../SLIP10Node';\nimport { numberToUint32 } from '../utils';\n\n/**\n * CIP-3 https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/CIP-0003.md.\n *\n * CIP-3 defines standards for deriving keys on Cardano.\n *\n * Key attributes.\n * - Root/Master key is derived from entropy, not seed. For this implementation we work with Icarus standard as it is the most widely used.\n * - See https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/Icarus.md.\n *\n * - HD node consists of a 64 byte private key, 32 byte public key and 32 byte chain code.\n * - See https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/CIP-0003.md#master-key-generation.\n *\n * - For derivation of BIP32 HD nodes, it uses modified version called BIP32-Ed25519.\n * - See https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.\n */\n\n/**\n * Reverses the order of bytes in a Uint8Array.\n *\n * Native BigInt uses big-endian. Since cip3(bip32Edd25519) uses little-endian.\n * We need to reverse the bytes and have separate functions for bigIntToBytes and bytesToBigInt.\n * .slice() is used just to make a copy of the array.\n *\n * @param bytes - The input Uint8Array.\n * @returns A new Uint8Array with the bytes in reversed order.\n */\nexport const toReversed = (bytes: Uint8Array): Uint8Array =>\n  bytes.slice().reverse();\n\n/**\n * Converts an array of bytes to a BigInt.\n *\n * @param bytes - The array of bytes to convert.\n * @returns The BigInt representation of the bytes.\n */\nexport const bytesToBigInt = (bytes: Uint8Array): bigint => {\n  const reversed = toReversed(bytes);\n  const bytesInHex = bytesToHex(reversed);\n  return BigInt(bytesInHex);\n};\n\n/**\n * Converts a BigInt to a byte array.\n *\n * @param bigInt - The BigInt to convert.\n * @returns The byte array representation of the BigInt.\n */\nexport const bigIntToBytes = (bigInt: bigint): Uint8Array => {\n  const hexadecimal = bigInt.toString(16);\n  return toReversed(hexToBytes(hexadecimal));\n};\n\n/**\n * Pads end of the given bytes array with zeros to a length of 32 bytes.\n *\n * @param bytes - The bytes array to pad.\n * @returns The padded bytes array.\n */\nexport const padEnd32Bytes = (bytes: Uint8Array): Uint8Array => {\n  return concatBytes([\n    bytes,\n    new Uint8Array(Math.max(32 - bytes.length, 0)).fill(0),\n  ]);\n};\n\n/**\n * Truncates to first 28 bytes and multiplies by 8.\n *\n * @param bytes - Little-Endian big number in bytes.\n * @returns PadEnd32Bytes(left[0, 28] * 8)).\n */\nexport const trunc28Mul8 = (bytes: Uint8Array): Uint8Array => {\n  const truncLeftMul8 = bytesToBigInt(bytes.slice(0, 28)) * BigInt(8);\n  return padEnd32Bytes(bigIntToBytes(truncLeftMul8));\n};\n\n/**\n * Does module 2^256.\n *\n * @param bytes - Little-Endian big number in bytes.\n * @returns PadEnd32Bytes(mod(bytes, 2^256))).\n */\nexport const mod2Pow256 = (bytes: Uint8Array): Uint8Array => {\n  return padEnd32Bytes(\n    bigIntToBytes(mod(bytesToBigInt(bytes), BigInt(2) ** BigInt(256))),\n  );\n};\n\n/**\n * Adds the left to the right.\n *\n * @param left - Left hand side Little-Endian big number.\n * @param right - Right hand side Little-Endian big number.\n * @returns PadEnd32Bytes(left + right).\n */\nexport const add = (left: Uint8Array, right: Uint8Array): Uint8Array => {\n  const added = bytesToBigInt(left) + bytesToBigInt(right);\n  return padEnd32Bytes(bigIntToBytes(added)).slice(0, 32);\n};\n\n/**\n * Concat tag, key and childIndex.\n *\n * @param tag - Key specific tag.\n * @param key - Key.\n * @param childIndex - Child index.\n * @returns PadEnd32Bytes(left + right).\n */\nexport const getKeyExtension = (\n  tag: number,\n  key: Uint8Array,\n  childIndex: number,\n): Uint8Array => {\n  return concatBytes([\n    new Uint8Array([tag]),\n    key,\n    numberToUint32(childIndex, true),\n  ]);\n};\n\nexport type Cip3SupportedCurve = Extract<Curve, { name: 'ed25519Bip32' }>;\n\ntype DeriveKeyBaseArgs = { childIndex: number };\n\ntype DeriveWithPrivateArgs = DeriveKeyBaseArgs & {\n  parentNode: {\n    privateKeyBytes: Uint8Array;\n    chainCodeBytes: Uint8Array;\n    publicKeyBytes: Uint8Array;\n  };\n  isHardened: boolean;\n};\n\nconst Z_TAGS = {\n  normal: 2,\n  hardened: 0,\n};\n\n/**\n * Derive a private child key.\n *\n * Following \"Section V. BIP32-ED25519: SPECIFICATION, C.1,2\" in\n * https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.\n *\n * @param options - The parameters for deriving a child key.\n * @param options.parentNode - The parent node containing private key, chain\n * code, and public key.\n * @param options.childIndex - The index of the child key.\n * @param options.isHardened - Indicates if the child key is hardened.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The derived child key.\n */\nexport const derivePrivateKey = async (\n  { parentNode, childIndex, isHardened }: DeriveWithPrivateArgs,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<Uint8Array> => {\n  // extension = i >= 2^31 ? (0x00||kp||i) : (0x02||Ap||i)\n  const extension = isHardened\n    ? getKeyExtension(\n        Z_TAGS.hardened,\n        parentNode.privateKeyBytes,\n        childIndex + BIP_32_HARDENED_OFFSET,\n      )\n    : getKeyExtension(Z_TAGS.normal, parentNode.publicKeyBytes, childIndex);\n\n  // entropy = Fcp(extension)\n  const entropy = await generateEntropy(\n    {\n      chainCode: parentNode.chainCodeBytes,\n      extension,\n    },\n    cryptographicFunctions,\n  );\n\n  const zl = entropy.subarray(0, 32);\n  const zr = entropy.subarray(32);\n\n  const parentKl = parentNode.privateKeyBytes.subarray(0, 32);\n  const parentKr = parentNode.privateKeyBytes.subarray(32);\n\n  // 8[ZL] + kPL\n  const childKl = add(trunc28Mul8(zl), parentKl);\n  // ZR + kPR\n  const childKr = add(zr, parentKr);\n  return concatBytes([childKl, childKr]);\n};\n\ntype DeriveWithoutPrivateArgs = DeriveKeyBaseArgs & {\n  parentNode: {\n    chainCodeBytes: Uint8Array;\n    publicKeyBytes: Uint8Array;\n  };\n  isHardened: false;\n};\n\nconst CHAIN_CODE_TAGS = {\n  normal: 3,\n  hardened: 1,\n};\n\n/**\n * Derive a child chainCode.\n *\n * Following \"Section V. BIP32-ED25519: SPECIFICATION, C.3\" in\n * https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.\n *\n * @param options - The parameters for deriving a child chainCode.\n * @param options.parentNode - The parent node containing optionally a private\n * key, chain code, and public key.\n * @param options.childIndex - The index of the child key.\n * @param options.isHardened - Indicates if the child key is hardened.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The derived child chainCode.\n */\nexport const deriveChainCode = async (\n  {\n    parentNode,\n    childIndex,\n    isHardened,\n  }: DeriveWithPrivateArgs | DeriveWithoutPrivateArgs,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<Uint8Array> => {\n  // extension = i >= 2^31 ? (0x01||kp||i) : (0x03||Ap||i)\n  const extension = isHardened\n    ? getKeyExtension(\n        CHAIN_CODE_TAGS.hardened,\n        parentNode.privateKeyBytes,\n        childIndex + BIP_32_HARDENED_OFFSET,\n      )\n    : getKeyExtension(\n        CHAIN_CODE_TAGS.normal,\n        parentNode.publicKeyBytes,\n        childIndex,\n      );\n\n  // entropy = Fcp(extension)\n  const entropy = await generateEntropy(\n    {\n      chainCode: parentNode.chainCodeBytes,\n      extension,\n    },\n    cryptographicFunctions,\n  );\n\n  return entropy.subarray(32);\n};\n\nconst PUBLIC_KEY_TAGS = {\n  normal: 2,\n};\n\ntype DerivePublicKeyArgs = DeriveWithoutPrivateArgs & {\n  curve: Cip3SupportedCurve;\n};\n\n/**\n * Derive a public key.\n *\n * Following \"Section V. BIP32-ED25519: SPECIFICATION, D\" in\n * https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.\n *\n * @param options - The parameters for deriving a child public key.\n * @param options.parentNode - The parent node containing chain code, and public key.\n * @param options.childIndex - The index of the child key.\n * @param options.curve - Derivation curve.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The derived child public key.\n */\nexport const derivePublicKey = async (\n  { parentNode, childIndex, curve }: DerivePublicKeyArgs,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<Uint8Array> => {\n  // extension = (0x02||Ap||i)\n  const extension = getKeyExtension(\n    PUBLIC_KEY_TAGS.normal,\n    parentNode.publicKeyBytes,\n    childIndex,\n  );\n\n  // entropy = Fcp(extension)\n  const entropy = await generateEntropy(\n    {\n      chainCode: parentNode.chainCodeBytes,\n      extension,\n    },\n    cryptographicFunctions,\n  );\n\n  const zl = entropy.slice(0, 32);\n\n  // right = [8ZL] * B\n  const right = await curve.getPublicKey(\n    // [8ZL]\n    trunc28Mul8(zl),\n  );\n\n  // Ai = AP + [8ZL]B,\n  return curve.publicAdd(parentNode.publicKeyBytes, right);\n};\n\ntype Cip3DeriveChildKeyArgs = DeriveChildKeyArgs & {\n  curve: Cip3SupportedCurve;\n};\n\n/**\n * Derive a SLIP-10 child key with a given path from a parent key.\n *\n * @param options - The options for deriving a child key.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns SLIP10Node.\n */\nexport async function deriveChildKey(\n  options: Cip3DeriveChildKeyArgs,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<SLIP10Node> {\n  const { curve, node, path } = options;\n  validateNode(node);\n\n  const { childIndex, isHardened } = getValidatedPath(path, node, curve);\n  if (curve.name !== 'ed25519Bip32' || !node) {\n    throw new Error(\n      'Unsupported curve: Only ed25519Bip32 is supported by CIP3.',\n    );\n  }\n\n  const actualChildIndex =\n    childIndex + (isHardened ? BIP_32_HARDENED_OFFSET : 0);\n\n  const {\n    privateKeyBytes,\n    chainCodeBytes,\n    publicKeyBytes,\n    masterFingerprint,\n    depth,\n    fingerprint: parentFingerprint,\n  } = node;\n\n  if (privateKeyBytes) {\n    const parentNode = {\n      privateKeyBytes,\n      chainCodeBytes,\n      publicKeyBytes,\n    };\n\n    const privateKey = await derivePrivateKey(\n      {\n        parentNode,\n        childIndex,\n        isHardened,\n      },\n      cryptographicFunctions,\n    );\n\n    const chainCode = await deriveChainCode(\n      {\n        parentNode,\n        childIndex,\n        isHardened,\n      },\n      cryptographicFunctions,\n    );\n\n    return SLIP10Node.fromExtendedKey(\n      {\n        privateKey: bytesToHex(privateKey),\n        chainCode: bytesToHex(chainCode),\n        masterFingerprint,\n        depth: depth + 1,\n        parentFingerprint,\n        index: actualChildIndex,\n        curve: curve.name,\n      },\n      cryptographicFunctions,\n    );\n  }\n\n  assert(\n    !isHardened,\n    'Invalid parameters: Cannot derive hardened child keys without a private key.',\n  );\n\n  const parentNode = {\n    chainCodeBytes,\n    publicKeyBytes,\n  };\n\n  const publicKey = await derivePublicKey(\n    {\n      parentNode,\n      childIndex,\n      isHardened: false,\n      curve,\n    },\n    cryptographicFunctions,\n  );\n\n  const chainCode = await deriveChainCode(\n    {\n      parentNode,\n      childIndex,\n      isHardened: false,\n    },\n    cryptographicFunctions,\n  );\n\n  return SLIP10Node.fromExtendedKey(\n    {\n      publicKey: bytesToHex(publicKey),\n      chainCode: bytesToHex(chainCode),\n      masterFingerprint,\n      depth: depth + 1,\n      parentFingerprint,\n      index: actualChildIndex,\n      curve: curve.name,\n    },\n    cryptographicFunctions,\n  );\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/derivers/index.cjs b/node_modules/@metamask/key-tree/dist/derivers/index.cjs
index 0267f60..b43b17f 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/index.cjs
+++ b/node_modules/@metamask/key-tree/dist/derivers/index.cjs
@@ -23,7 +23,7 @@ var __importStar = (this && this.__importStar) || function (mod) {
     return result;
 };
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.createBip39KeyFromSeed = exports.derivers = void 0;
+exports.mnemonicToSeed = exports.createBip39KeyFromSeed = exports.derivers = void 0;
 const bip32 = __importStar(require("./bip32.cjs"));
 const bip39 = __importStar(require("./bip39.cjs"));
 const cip3 = __importStar(require("./cip3.cjs"));
@@ -36,4 +36,5 @@ exports.derivers = {
 };
 var bip39_1 = require("./bip39.cjs");
 Object.defineProperty(exports, "createBip39KeyFromSeed", { enumerable: true, get: function () { return bip39_1.createBip39KeyFromSeed; } });
+Object.defineProperty(exports, "mnemonicToSeed", { enumerable: true, get: function () { return bip39_1.mnemonicToSeed; } });
 //# sourceMappingURL=index.cjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/derivers/index.cjs.map b/node_modules/@metamask/key-tree/dist/derivers/index.cjs.map
index 4b6eaa3..faa8424 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/index.cjs.map
+++ b/node_modules/@metamask/key-tree/dist/derivers/index.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"index.cjs","sourceRoot":"","sources":["../../src/derivers/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,mDAAiC;AACjC,mDAAiC;AACjC,iDAA+B;AAC/B,qDAAmC;AAqBtB,QAAA,QAAQ,GAAG;IACtB,KAAK;IACL,KAAK;IACL,MAAM;IACN,IAAI;CACL,CAAC;AAEF,qCAAiD;AAAxC,+GAAA,sBAAsB,OAAA","sourcesContent":["import type { Curve } from '../curves';\nimport type { SLIP10Node } from '../SLIP10Node';\nimport * as bip32 from './bip32';\nimport * as bip39 from './bip39';\nimport * as cip3 from './cip3';\nimport * as slip10 from './slip10';\n\nexport type DerivedKeys = {\n  /**\n   * The derived private key, can be undefined if public key derivation was used.\n   */\n  privateKey?: Uint8Array;\n  publicKey: Uint8Array;\n  chainCode: Uint8Array;\n};\n\nexport type DeriveChildKeyArgs = {\n  path: Uint8Array | string;\n  curve: Curve;\n  node?: SLIP10Node;\n};\n\nexport type Deriver = {\n  deriveChildKey: (args: DeriveChildKeyArgs) => Promise<SLIP10Node>;\n};\n\nexport const derivers = {\n  bip32,\n  bip39,\n  slip10,\n  cip3,\n};\n\nexport { createBip39KeyFromSeed } from './bip39';\n"]}
\ No newline at end of file
+{"version":3,"file":"index.cjs","sourceRoot":"","sources":["../../src/derivers/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,mDAAiC;AACjC,mDAAiC;AACjC,iDAA+B;AAC/B,qDAAmC;AA2BtB,QAAA,QAAQ,GAAG;IACtB,KAAK;IACL,KAAK;IACL,MAAM;IACN,IAAI;CACL,CAAC;AAEF,qCAAiE;AAAxD,+GAAA,sBAAsB,OAAA;AAAE,uGAAA,cAAc,OAAA","sourcesContent":["import * as bip32 from './bip32';\nimport * as bip39 from './bip39';\nimport * as cip3 from './cip3';\nimport * as slip10 from './slip10';\nimport type { CryptographicFunctions } from '../cryptography';\nimport type { Curve } from '../curves';\nimport type { SLIP10Node } from '../SLIP10Node';\n\nexport type DerivedKeys = {\n  /**\n   * The derived private key, can be undefined if public key derivation was used.\n   */\n  privateKey?: Uint8Array;\n  publicKey: Uint8Array;\n  chainCode: Uint8Array;\n};\n\nexport type DeriveChildKeyArgs = {\n  path: Uint8Array | string;\n  curve: Curve;\n  node?: SLIP10Node;\n};\n\nexport type Deriver = {\n  deriveChildKey: (\n    args: DeriveChildKeyArgs,\n    cryptographicFunctions?: CryptographicFunctions,\n  ) => Promise<SLIP10Node>;\n};\n\nexport const derivers = {\n  bip32,\n  bip39,\n  slip10,\n  cip3,\n};\n\nexport { createBip39KeyFromSeed, mnemonicToSeed } from './bip39';\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/derivers/index.d.cts b/node_modules/@metamask/key-tree/dist/derivers/index.d.cts
index cfcef13..e284873 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/index.d.cts
+++ b/node_modules/@metamask/key-tree/dist/derivers/index.d.cts
@@ -1,10 +1,11 @@
-import type { Curve } from "../curves/index.cjs";
-import type { SLIP10Node } from "../SLIP10Node.cjs";
 import * as bip32 from "./bip32.cjs";
 import * as bip39 from "./bip39.cjs";
 import * as cip3 from "./cip3.cjs";
 import * as slip10 from "./slip10.cjs";
-export declare type DerivedKeys = {
+import type { CryptographicFunctions } from "../cryptography.cjs";
+import type { Curve } from "../curves/index.cjs";
+import type { SLIP10Node } from "../SLIP10Node.cjs";
+export type DerivedKeys = {
     /**
      * The derived private key, can be undefined if public key derivation was used.
      */
@@ -12,13 +13,13 @@ export declare type DerivedKeys = {
     publicKey: Uint8Array;
     chainCode: Uint8Array;
 };
-export declare type DeriveChildKeyArgs = {
+export type DeriveChildKeyArgs = {
     path: Uint8Array | string;
     curve: Curve;
     node?: SLIP10Node;
 };
-export declare type Deriver = {
-    deriveChildKey: (args: DeriveChildKeyArgs) => Promise<SLIP10Node>;
+export type Deriver = {
+    deriveChildKey: (args: DeriveChildKeyArgs, cryptographicFunctions?: CryptographicFunctions) => Promise<SLIP10Node>;
 };
 export declare const derivers: {
     bip32: typeof bip32;
@@ -26,5 +27,5 @@ export declare const derivers: {
     slip10: typeof slip10;
     cip3: typeof cip3;
 };
-export { createBip39KeyFromSeed } from "./bip39.cjs";
+export { createBip39KeyFromSeed, mnemonicToSeed } from "./bip39.cjs";
 //# sourceMappingURL=index.d.cts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/derivers/index.d.cts.map b/node_modules/@metamask/key-tree/dist/derivers/index.d.cts.map
index 983a5c9..7c0134c 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/index.d.cts.map
+++ b/node_modules/@metamask/key-tree/dist/derivers/index.d.cts.map
@@ -1 +1 @@
-{"version":3,"file":"index.d.cts","sourceRoot":"","sources":["../../src/derivers/index.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,KAAK,EAAE,4BAAkB;AACvC,OAAO,KAAK,EAAE,UAAU,EAAE,0BAAsB;AAChD,OAAO,KAAK,KAAK,oBAAgB;AACjC,OAAO,KAAK,KAAK,oBAAgB;AACjC,OAAO,KAAK,IAAI,mBAAe;AAC/B,OAAO,KAAK,MAAM,qBAAiB;AAEnC,oBAAY,WAAW,GAAG;IACxB;;OAEG;IACH,UAAU,CAAC,EAAE,UAAU,CAAC;IACxB,SAAS,EAAE,UAAU,CAAC;IACtB,SAAS,EAAE,UAAU,CAAC;CACvB,CAAC;AAEF,oBAAY,kBAAkB,GAAG;IAC/B,IAAI,EAAE,UAAU,GAAG,MAAM,CAAC;IAC1B,KAAK,EAAE,KAAK,CAAC;IACb,IAAI,CAAC,EAAE,UAAU,CAAC;CACnB,CAAC;AAEF,oBAAY,OAAO,GAAG;IACpB,cAAc,EAAE,CAAC,IAAI,EAAE,kBAAkB,KAAK,OAAO,CAAC,UAAU,CAAC,CAAC;CACnE,CAAC;AAEF,eAAO,MAAM,QAAQ;;;;;CAKpB,CAAC;AAEF,OAAO,EAAE,sBAAsB,EAAE,oBAAgB"}
\ No newline at end of file
+{"version":3,"file":"index.d.cts","sourceRoot":"","sources":["../../src/derivers/index.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,KAAK,oBAAgB;AACjC,OAAO,KAAK,KAAK,oBAAgB;AACjC,OAAO,KAAK,IAAI,mBAAe;AAC/B,OAAO,KAAK,MAAM,qBAAiB;AACnC,OAAO,KAAK,EAAE,sBAAsB,EAAE,4BAAwB;AAC9D,OAAO,KAAK,EAAE,KAAK,EAAE,4BAAkB;AACvC,OAAO,KAAK,EAAE,UAAU,EAAE,0BAAsB;AAEhD,MAAM,MAAM,WAAW,GAAG;IACxB;;OAEG;IACH,UAAU,CAAC,EAAE,UAAU,CAAC;IACxB,SAAS,EAAE,UAAU,CAAC;IACtB,SAAS,EAAE,UAAU,CAAC;CACvB,CAAC;AAEF,MAAM,MAAM,kBAAkB,GAAG;IAC/B,IAAI,EAAE,UAAU,GAAG,MAAM,CAAC;IAC1B,KAAK,EAAE,KAAK,CAAC;IACb,IAAI,CAAC,EAAE,UAAU,CAAC;CACnB,CAAC;AAEF,MAAM,MAAM,OAAO,GAAG;IACpB,cAAc,EAAE,CACd,IAAI,EAAE,kBAAkB,EACxB,sBAAsB,CAAC,EAAE,sBAAsB,KAC5C,OAAO,CAAC,UAAU,CAAC,CAAC;CAC1B,CAAC;AAEF,eAAO,MAAM,QAAQ;;;;;CAKpB,CAAC;AAEF,OAAO,EAAE,sBAAsB,EAAE,cAAc,EAAE,oBAAgB"}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/derivers/index.d.mts b/node_modules/@metamask/key-tree/dist/derivers/index.d.mts
index 3fc5ef9..7c1287a 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/index.d.mts
+++ b/node_modules/@metamask/key-tree/dist/derivers/index.d.mts
@@ -1,10 +1,11 @@
-import type { Curve } from "../curves/index.mjs";
-import type { SLIP10Node } from "../SLIP10Node.mjs";
 import * as bip32 from "./bip32.mjs";
 import * as bip39 from "./bip39.mjs";
 import * as cip3 from "./cip3.mjs";
 import * as slip10 from "./slip10.mjs";
-export declare type DerivedKeys = {
+import type { CryptographicFunctions } from "../cryptography.mjs";
+import type { Curve } from "../curves/index.mjs";
+import type { SLIP10Node } from "../SLIP10Node.mjs";
+export type DerivedKeys = {
     /**
      * The derived private key, can be undefined if public key derivation was used.
      */
@@ -12,13 +13,13 @@ export declare type DerivedKeys = {
     publicKey: Uint8Array;
     chainCode: Uint8Array;
 };
-export declare type DeriveChildKeyArgs = {
+export type DeriveChildKeyArgs = {
     path: Uint8Array | string;
     curve: Curve;
     node?: SLIP10Node;
 };
-export declare type Deriver = {
-    deriveChildKey: (args: DeriveChildKeyArgs) => Promise<SLIP10Node>;
+export type Deriver = {
+    deriveChildKey: (args: DeriveChildKeyArgs, cryptographicFunctions?: CryptographicFunctions) => Promise<SLIP10Node>;
 };
 export declare const derivers: {
     bip32: typeof bip32;
@@ -26,5 +27,5 @@ export declare const derivers: {
     slip10: typeof slip10;
     cip3: typeof cip3;
 };
-export { createBip39KeyFromSeed } from "./bip39.mjs";
+export { createBip39KeyFromSeed, mnemonicToSeed } from "./bip39.mjs";
 //# sourceMappingURL=index.d.mts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/derivers/index.d.mts.map b/node_modules/@metamask/key-tree/dist/derivers/index.d.mts.map
index 2e7d2ff..5448e63 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/index.d.mts.map
+++ b/node_modules/@metamask/key-tree/dist/derivers/index.d.mts.map
@@ -1 +1 @@
-{"version":3,"file":"index.d.mts","sourceRoot":"","sources":["../../src/derivers/index.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,KAAK,EAAE,4BAAkB;AACvC,OAAO,KAAK,EAAE,UAAU,EAAE,0BAAsB;AAChD,OAAO,KAAK,KAAK,oBAAgB;AACjC,OAAO,KAAK,KAAK,oBAAgB;AACjC,OAAO,KAAK,IAAI,mBAAe;AAC/B,OAAO,KAAK,MAAM,qBAAiB;AAEnC,oBAAY,WAAW,GAAG;IACxB;;OAEG;IACH,UAAU,CAAC,EAAE,UAAU,CAAC;IACxB,SAAS,EAAE,UAAU,CAAC;IACtB,SAAS,EAAE,UAAU,CAAC;CACvB,CAAC;AAEF,oBAAY,kBAAkB,GAAG;IAC/B,IAAI,EAAE,UAAU,GAAG,MAAM,CAAC;IAC1B,KAAK,EAAE,KAAK,CAAC;IACb,IAAI,CAAC,EAAE,UAAU,CAAC;CACnB,CAAC;AAEF,oBAAY,OAAO,GAAG;IACpB,cAAc,EAAE,CAAC,IAAI,EAAE,kBAAkB,KAAK,OAAO,CAAC,UAAU,CAAC,CAAC;CACnE,CAAC;AAEF,eAAO,MAAM,QAAQ;;;;;CAKpB,CAAC;AAEF,OAAO,EAAE,sBAAsB,EAAE,oBAAgB"}
\ No newline at end of file
+{"version":3,"file":"index.d.mts","sourceRoot":"","sources":["../../src/derivers/index.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,KAAK,oBAAgB;AACjC,OAAO,KAAK,KAAK,oBAAgB;AACjC,OAAO,KAAK,IAAI,mBAAe;AAC/B,OAAO,KAAK,MAAM,qBAAiB;AACnC,OAAO,KAAK,EAAE,sBAAsB,EAAE,4BAAwB;AAC9D,OAAO,KAAK,EAAE,KAAK,EAAE,4BAAkB;AACvC,OAAO,KAAK,EAAE,UAAU,EAAE,0BAAsB;AAEhD,MAAM,MAAM,WAAW,GAAG;IACxB;;OAEG;IACH,UAAU,CAAC,EAAE,UAAU,CAAC;IACxB,SAAS,EAAE,UAAU,CAAC;IACtB,SAAS,EAAE,UAAU,CAAC;CACvB,CAAC;AAEF,MAAM,MAAM,kBAAkB,GAAG;IAC/B,IAAI,EAAE,UAAU,GAAG,MAAM,CAAC;IAC1B,KAAK,EAAE,KAAK,CAAC;IACb,IAAI,CAAC,EAAE,UAAU,CAAC;CACnB,CAAC;AAEF,MAAM,MAAM,OAAO,GAAG;IACpB,cAAc,EAAE,CACd,IAAI,EAAE,kBAAkB,EACxB,sBAAsB,CAAC,EAAE,sBAAsB,KAC5C,OAAO,CAAC,UAAU,CAAC,CAAC;CAC1B,CAAC;AAEF,eAAO,MAAM,QAAQ;;;;;CAKpB,CAAC;AAEF,OAAO,EAAE,sBAAsB,EAAE,cAAc,EAAE,oBAAgB"}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/derivers/index.mjs b/node_modules/@metamask/key-tree/dist/derivers/index.mjs
index de604bb..f982be0 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/index.mjs
+++ b/node_modules/@metamask/key-tree/dist/derivers/index.mjs
@@ -8,5 +8,5 @@ export const derivers = {
     slip10,
     cip3,
 };
-export { createBip39KeyFromSeed } from "./bip39.mjs";
+export { createBip39KeyFromSeed, mnemonicToSeed } from "./bip39.mjs";
 //# sourceMappingURL=index.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/derivers/index.mjs.map b/node_modules/@metamask/key-tree/dist/derivers/index.mjs.map
index 4891138..24415dc 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/index.mjs.map
+++ b/node_modules/@metamask/key-tree/dist/derivers/index.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"index.mjs","sourceRoot":"","sources":["../../src/derivers/index.ts"],"names":[],"mappings":"AAEA,OAAO,KAAK,KAAK,oBAAgB;AACjC,OAAO,KAAK,KAAK,oBAAgB;AACjC,OAAO,KAAK,IAAI,mBAAe;AAC/B,OAAO,KAAK,MAAM,qBAAiB;AAqBnC,MAAM,CAAC,MAAM,QAAQ,GAAG;IACtB,KAAK;IACL,KAAK;IACL,MAAM;IACN,IAAI;CACL,CAAC;AAEF,OAAO,EAAE,sBAAsB,EAAE,oBAAgB","sourcesContent":["import type { Curve } from '../curves';\nimport type { SLIP10Node } from '../SLIP10Node';\nimport * as bip32 from './bip32';\nimport * as bip39 from './bip39';\nimport * as cip3 from './cip3';\nimport * as slip10 from './slip10';\n\nexport type DerivedKeys = {\n  /**\n   * The derived private key, can be undefined if public key derivation was used.\n   */\n  privateKey?: Uint8Array;\n  publicKey: Uint8Array;\n  chainCode: Uint8Array;\n};\n\nexport type DeriveChildKeyArgs = {\n  path: Uint8Array | string;\n  curve: Curve;\n  node?: SLIP10Node;\n};\n\nexport type Deriver = {\n  deriveChildKey: (args: DeriveChildKeyArgs) => Promise<SLIP10Node>;\n};\n\nexport const derivers = {\n  bip32,\n  bip39,\n  slip10,\n  cip3,\n};\n\nexport { createBip39KeyFromSeed } from './bip39';\n"]}
\ No newline at end of file
+{"version":3,"file":"index.mjs","sourceRoot":"","sources":["../../src/derivers/index.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,KAAK,oBAAgB;AACjC,OAAO,KAAK,KAAK,oBAAgB;AACjC,OAAO,KAAK,IAAI,mBAAe;AAC/B,OAAO,KAAK,MAAM,qBAAiB;AA2BnC,MAAM,CAAC,MAAM,QAAQ,GAAG;IACtB,KAAK;IACL,KAAK;IACL,MAAM;IACN,IAAI;CACL,CAAC;AAEF,OAAO,EAAE,sBAAsB,EAAE,cAAc,EAAE,oBAAgB","sourcesContent":["import * as bip32 from './bip32';\nimport * as bip39 from './bip39';\nimport * as cip3 from './cip3';\nimport * as slip10 from './slip10';\nimport type { CryptographicFunctions } from '../cryptography';\nimport type { Curve } from '../curves';\nimport type { SLIP10Node } from '../SLIP10Node';\n\nexport type DerivedKeys = {\n  /**\n   * The derived private key, can be undefined if public key derivation was used.\n   */\n  privateKey?: Uint8Array;\n  publicKey: Uint8Array;\n  chainCode: Uint8Array;\n};\n\nexport type DeriveChildKeyArgs = {\n  path: Uint8Array | string;\n  curve: Curve;\n  node?: SLIP10Node;\n};\n\nexport type Deriver = {\n  deriveChildKey: (\n    args: DeriveChildKeyArgs,\n    cryptographicFunctions?: CryptographicFunctions,\n  ) => Promise<SLIP10Node>;\n};\n\nexport const derivers = {\n  bip32,\n  bip39,\n  slip10,\n  cip3,\n};\n\nexport { createBip39KeyFromSeed, mnemonicToSeed } from './bip39';\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/derivers/shared.cjs b/node_modules/@metamask/key-tree/dist/derivers/shared.cjs
index 69d76c2..1c33ea3 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/shared.cjs
+++ b/node_modules/@metamask/key-tree/dist/derivers/shared.cjs
@@ -2,9 +2,8 @@
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.getValidatedPath = exports.validateNode = exports.generateEntropy = exports.privateAdd = exports.derivePublicChildKey = exports.derivePublicExtension = exports.deriveSecretExtension = exports.deriveChildKey = void 0;
 const utils_1 = require("@metamask/utils");
-const hmac_1 = require("@noble/hashes/hmac");
-const sha512_1 = require("@noble/hashes/sha512");
 const constants_1 = require("../constants.cjs");
+const cryptography_1 = require("../cryptography.cjs");
 const curves_1 = require("../curves/index.cjs");
 const SLIP10Node_1 = require("../SLIP10Node.cjs");
 const utils_2 = require("../utils.cjs");
@@ -20,9 +19,11 @@ const utils_2 = require("../utils.cjs");
  * @param options.curve - The curve to use for derivation.
  * @param handleError - A function that can handle errors that occur during
  * derivation.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The derived node.
  */
-async function deriveChildKey({ path, node, curve }, handleError) {
+async function deriveChildKey({ path, node, curve }, handleError, cryptographicFunctions) {
     validateNode(node);
     const { childIndex, isHardened } = getValidatedPath(path, node, curve);
     const args = {
@@ -41,29 +42,29 @@ async function deriveChildKey({ path, node, curve }, handleError) {
             isHardened,
             curve,
         });
-        const entropy = generateEntropy({
+        const entropy = await generateEntropy({
             chainCode: node.chainCodeBytes,
             extension: secretExtension,
-        });
+        }, cryptographicFunctions);
         return await deriveNode({
             privateKey: node.privateKeyBytes,
             entropy,
             ...args,
-        }, handleError);
+        }, handleError, cryptographicFunctions);
     }
     const publicExtension = derivePublicExtension({
         parentPublicKey: node.compressedPublicKeyBytes,
         childIndex,
     });
-    const entropy = generateEntropy({
+    const entropy = await generateEntropy({
         chainCode: node.chainCodeBytes,
         extension: publicExtension,
-    });
+    }, cryptographicFunctions);
     return await deriveNode({
         publicKey: node.compressedPublicKeyBytes,
         entropy,
         ...args,
-    }, handleError);
+    }, handleError, cryptographicFunctions);
 }
 exports.deriveChildKey = deriveChildKey;
 /**
@@ -81,9 +82,11 @@ exports.deriveChildKey = deriveChildKey;
  * @param options.masterFingerprint - The fingerprint of the master key.
  * @param options.curve - The curve to use for deriving the child key.
  * @param handleError - A function to handle errors during derivation.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The derived child key as {@link SLIP10Node}.
  */
-async function deriveNode(options, handleError) {
+async function deriveNode(options, handleError, cryptographicFunctions) {
     const { privateKey, publicKey, entropy, childIndex, isHardened, depth, parentFingerprint, masterFingerprint, curve, } = options;
     try {
         if (privateKey) {
@@ -96,7 +99,7 @@ async function deriveNode(options, handleError) {
                 childIndex,
                 isHardened,
                 curve,
-            });
+            }, cryptographicFunctions);
         }
         return await derivePublicChildKey({
             entropy,
@@ -106,10 +109,10 @@ async function deriveNode(options, handleError) {
             parentFingerprint,
             childIndex,
             curve,
-        });
+        }, cryptographicFunctions);
     }
     catch (error) {
-        return await deriveNode(await handleError(error, options), handleError);
+        return await deriveNode(await handleError(error, options, cryptographicFunctions), handleError, cryptographicFunctions);
     }
 }
 /**
@@ -182,9 +185,11 @@ async function generateKey({ privateKey, entropy, curve, }) {
  * @param args.childIndex - The child index to derive.
  * @param args.isHardened - Whether the child index is hardened.
  * @param args.curve - The curve to use for derivation.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The derived {@link SLIP10Node}.
  */
-async function derivePrivateChildKey({ entropy, privateKey, depth, masterFingerprint, parentFingerprint, childIndex, isHardened, curve, }) {
+async function derivePrivateChildKey({ entropy, privateKey, depth, masterFingerprint, parentFingerprint, childIndex, isHardened, curve, }, cryptographicFunctions) {
     const actualChildIndex = childIndex + (isHardened ? constants_1.BIP_32_HARDENED_OFFSET : 0);
     const { privateKey: childPrivateKey, chainCode: childChainCode } = await generateKey({
         privateKey,
@@ -199,7 +204,7 @@ async function derivePrivateChildKey({ entropy, privateKey, depth, masterFingerp
         parentFingerprint,
         index: actualChildIndex,
         curve: curve.name,
-    });
+    }, cryptographicFunctions);
 }
 /**
  * Derive a BIP-32 public key from a parent key and public extension.
@@ -231,9 +236,11 @@ function generatePublicKey({ publicKey, entropy, curve, }) {
  * @param args.parentFingerprint - The fingerprint of the parent node.
  * @param args.childIndex - The child index to derive.
  * @param args.curve - The curve to use for derivation.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The derived {@link SLIP10Node}.
  */
-async function derivePublicChildKey({ entropy, publicKey, depth, masterFingerprint, parentFingerprint, childIndex, curve, }) {
+async function derivePublicChildKey({ entropy, publicKey, depth, masterFingerprint, parentFingerprint, childIndex, curve, }, cryptographicFunctions) {
     const { publicKey: childPublicKey, chainCode: childChainCode } = generatePublicKey({
         publicKey,
         entropy,
@@ -247,7 +254,7 @@ async function derivePublicChildKey({ entropy, publicKey, depth, masterFingerpri
         parentFingerprint,
         index: childIndex,
         curve: curve.name,
-    });
+    }, cryptographicFunctions);
 }
 exports.derivePublicChildKey = derivePublicChildKey;
 /**
@@ -281,10 +288,12 @@ exports.privateAdd = privateAdd;
  * @param args - The arguments for generating entropy.
  * @param args.chainCode - The parent chain code bytes.
  * @param args.extension - The extension bytes.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The generated entropy bytes.
  */
-function generateEntropy({ chainCode, extension }) {
-    return (0, hmac_1.hmac)(sha512_1.sha512, chainCode, extension);
+async function generateEntropy({ chainCode, extension }, cryptographicFunctions) {
+    return await (0, cryptography_1.hmacSha512)(chainCode, extension, cryptographicFunctions);
 }
 exports.generateEntropy = generateEntropy;
 /**
diff --git a/node_modules/@metamask/key-tree/dist/derivers/shared.cjs.map b/node_modules/@metamask/key-tree/dist/derivers/shared.cjs.map
index 8fe7dca..7116af8 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/shared.cjs.map
+++ b/node_modules/@metamask/key-tree/dist/derivers/shared.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"shared.cjs","sourceRoot":"","sources":["../../src/derivers/shared.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  assert,\n  bytesToBigInt,\n  concatBytes,\n  hexToBytes,\n} from '@metamask/utils';\nimport { hmac } from '@noble/hashes/hmac';\nimport { sha512 } from '@noble/hashes/sha512';\n\nimport type { DeriveChildKeyArgs, DerivedKeys } from '.';\nimport { BIP_32_HARDENED_OFFSET, UNPREFIXED_PATH_REGEX } from '../constants';\nimport type { Curve } from '../curves';\nimport { mod } from '../curves';\nimport { SLIP10Node } from '../SLIP10Node';\nimport { isValidBytesKey, numberToUint32 } from '../utils';\n\ntype ErrorHandler = (\n  error: unknown,\n  options: DeriveNodeArgs,\n) => Promise<DeriveNodeArgs>;\n\n/**\n * Derive a BIP-32 or SLIP-10 child key with a given path from a parent key.\n *\n * Since BIP-32 and SLIP-10 are very similar, this function can be used to\n * derive both types of keys.\n *\n * @param options - The options for deriving a child key.\n * @param options.path - The derivation path part to derive.\n * @param options.node - The node to derive from.\n * @param options.curve - The curve to use for derivation.\n * @param handleError - A function that can handle errors that occur during\n * derivation.\n * @returns The derived node.\n */\nexport async function deriveChildKey(\n  { path, node, curve }: DeriveChildKeyArgs,\n  handleError: ErrorHandler,\n) {\n  validateNode(node);\n\n  const { childIndex, isHardened } = getValidatedPath(path, node, curve);\n\n  const args = {\n    chainCode: node.chainCodeBytes,\n    childIndex,\n    isHardened,\n    depth: node.depth,\n    parentFingerprint: node.fingerprint,\n    masterFingerprint: node.masterFingerprint,\n    curve,\n  };\n\n  if (node.privateKeyBytes) {\n    const secretExtension = await deriveSecretExtension({\n      privateKey: node.privateKeyBytes,\n      childIndex,\n      isHardened,\n      curve,\n    });\n\n    const entropy = generateEntropy({\n      chainCode: node.chainCodeBytes,\n      extension: secretExtension,\n    });\n\n    return await deriveNode(\n      {\n        privateKey: node.privateKeyBytes,\n        entropy,\n        ...args,\n      },\n      handleError,\n    );\n  }\n\n  const publicExtension = derivePublicExtension({\n    parentPublicKey: node.compressedPublicKeyBytes,\n    childIndex,\n  });\n\n  const entropy = generateEntropy({\n    chainCode: node.chainCodeBytes,\n    extension: publicExtension,\n  });\n\n  return await deriveNode(\n    {\n      publicKey: node.compressedPublicKeyBytes,\n      entropy,\n      ...args,\n    },\n    handleError,\n  );\n}\n\ntype BaseDeriveNodeArgs = {\n  entropy: Uint8Array;\n  chainCode: Uint8Array;\n  childIndex: number;\n  isHardened: boolean;\n  depth: number;\n  parentFingerprint: number;\n  masterFingerprint?: number | undefined;\n  curve: Curve;\n};\n\ntype DerivePrivateKeyArgs = BaseDeriveNodeArgs & {\n  privateKey: Uint8Array;\n  publicKey?: never | undefined;\n};\n\ntype DerivePublicKeyArgs = BaseDeriveNodeArgs & {\n  publicKey: Uint8Array;\n  privateKey?: never | undefined;\n};\n\nexport type DeriveNodeArgs = DerivePrivateKeyArgs | DerivePublicKeyArgs;\n\ntype DeriveSecretExtensionArgs = {\n  privateKey: Uint8Array;\n  childIndex: number;\n  isHardened: boolean;\n  curve: Curve;\n};\n\n/**\n * Derive a SLIP-10 child key from a parent key.\n *\n * @param options - The options for deriving a child key.\n * @param options.privateKey - The private key to derive from.\n * @param options.publicKey - The public key to derive from.\n * @param options.entropy - The entropy to use for deriving the child key.\n * @param options.chainCode - The chain code to use for deriving the child key.\n * @param options.childIndex - The child index to use for deriving the child key.\n * @param options.isHardened - Whether the child key is hardened.\n * @param options.depth - The depth of the child key.\n * @param options.parentFingerprint - The fingerprint of the parent key.\n * @param options.masterFingerprint - The fingerprint of the master key.\n * @param options.curve - The curve to use for deriving the child key.\n * @param handleError - A function to handle errors during derivation.\n * @returns The derived child key as {@link SLIP10Node}.\n */\nasync function deriveNode(\n  options: DeriveNodeArgs,\n  handleError: (\n    error: unknown,\n    args: DeriveNodeArgs,\n  ) => Promise<DeriveNodeArgs>,\n): Promise<SLIP10Node> {\n  const {\n    privateKey,\n    publicKey,\n    entropy,\n    childIndex,\n    isHardened,\n    depth,\n    parentFingerprint,\n    masterFingerprint,\n    curve,\n  } = options;\n\n  try {\n    if (privateKey) {\n      return await derivePrivateChildKey({\n        entropy,\n        privateKey,\n        depth,\n        masterFingerprint,\n        parentFingerprint,\n        childIndex,\n        isHardened,\n        curve,\n      });\n    }\n\n    return await derivePublicChildKey({\n      entropy,\n      publicKey,\n      depth,\n      masterFingerprint,\n      parentFingerprint,\n      childIndex,\n      curve,\n    });\n  } catch (error) {\n    return await deriveNode(await handleError(error, options), handleError);\n  }\n}\n\n/**\n * Derive a BIP-32 secret extension from a parent key and child index.\n *\n * @param options - The options for deriving a secret extension.\n * @param options.privateKey - The parent private key bytes.\n * @param options.childIndex - The child index to derive.\n * @param options.isHardened - Whether the child index is hardened.\n * @param options.curve - The curve to use for derivation.\n * @returns The secret extension bytes.\n */\nexport async function deriveSecretExtension({\n  privateKey,\n  childIndex,\n  isHardened,\n  curve,\n}: DeriveSecretExtensionArgs) {\n  if (isHardened) {\n    // Hardened child\n    return concatBytes([\n      new Uint8Array([0]),\n      privateKey,\n      numberToUint32(childIndex + BIP_32_HARDENED_OFFSET),\n    ]);\n  }\n\n  // Normal child\n  const parentPublicKey = await curve.getPublicKey(privateKey, true);\n  return derivePublicExtension({ parentPublicKey, childIndex });\n}\n\ntype DerivePublicExtensionArgs = {\n  parentPublicKey: Uint8Array;\n  childIndex: number;\n};\n\n/**\n * Derive a BIP-32 public extension from a parent key and child index.\n *\n * @param options - The options for deriving a public extension.\n * @param options.parentPublicKey - The parent public key bytes.\n * @param options.childIndex - The child index to derive.\n * @returns The public extension bytes.\n */\nexport function derivePublicExtension({\n  parentPublicKey,\n  childIndex,\n}: DerivePublicExtensionArgs) {\n  return concatBytes([parentPublicKey, numberToUint32(childIndex)]);\n}\n\ntype GenerateKeyArgs = {\n  privateKey: Uint8Array;\n  entropy: Uint8Array;\n  curve: Curve;\n};\n\n/**\n * Derive a BIP-32 key from a parent key and secret extension.\n *\n * @param options - The options for deriving a key.\n * @param options.privateKey - The parent private key bytes.\n * @param options.entropy - The entropy bytes.\n * @param options.curve - The curve to use for derivation.\n * @returns The derived key.\n */\nasync function generateKey({\n  privateKey,\n  entropy,\n  curve,\n}: GenerateKeyArgs): Promise<DerivedKeys & { privateKey: Uint8Array }> {\n  const keyMaterial = entropy.slice(0, 32);\n  const childChainCode = entropy.slice(32);\n\n  // If curve is ed25519: The returned child key ki is parse256(IL).\n  // https://github.com/satoshilabs/slips/blob/133ea52a8e43d338b98be208907e144277e44c0e/slip-0010.md#private-parent-key--private-child-key\n  if (curve.name === 'ed25519') {\n    const publicKey = await curve.getPublicKey(keyMaterial);\n    return { privateKey: keyMaterial, publicKey, chainCode: childChainCode };\n  }\n\n  const childPrivateKey = privateAdd(privateKey, keyMaterial, curve);\n  const publicKey = await curve.getPublicKey(childPrivateKey);\n\n  return { privateKey: childPrivateKey, publicKey, chainCode: childChainCode };\n}\n\ntype DerivePrivateChildKeyArgs = {\n  entropy: Uint8Array;\n  privateKey: Uint8Array;\n  depth: number;\n  masterFingerprint?: number | undefined;\n  parentFingerprint: number;\n  childIndex: number;\n  isHardened: boolean;\n  curve: Curve;\n};\n\n/**\n * Derive a BIP-32 private child key with a given path from a parent key.\n *\n * @param args - The arguments for deriving a private child key.\n * @param args.entropy - The entropy to use for derivation.\n * @param args.privateKey - The parent private key to use for derivation.\n * @param args.depth - The depth of the parent node.\n * @param args.masterFingerprint - The fingerprint of the master node.\n * @param args.parentFingerprint - The fingerprint of the parent node.\n * @param args.childIndex - The child index to derive.\n * @param args.isHardened - Whether the child index is hardened.\n * @param args.curve - The curve to use for derivation.\n * @returns The derived {@link SLIP10Node}.\n */\nasync function derivePrivateChildKey({\n  entropy,\n  privateKey,\n  depth,\n  masterFingerprint,\n  parentFingerprint,\n  childIndex,\n  isHardened,\n  curve,\n}: DerivePrivateChildKeyArgs): Promise<SLIP10Node> {\n  const actualChildIndex =\n    childIndex + (isHardened ? BIP_32_HARDENED_OFFSET : 0);\n\n  const { privateKey: childPrivateKey, chainCode: childChainCode } =\n    await generateKey({\n      privateKey,\n      entropy,\n      curve,\n    });\n\n  return await SLIP10Node.fromExtendedKey({\n    privateKey: childPrivateKey,\n    chainCode: childChainCode,\n    depth: depth + 1,\n    masterFingerprint,\n    parentFingerprint,\n    index: actualChildIndex,\n    curve: curve.name,\n  });\n}\n\ntype GeneratePublicKeyArgs = {\n  publicKey: Uint8Array;\n  entropy: Uint8Array;\n  curve: Curve;\n};\n\n/**\n * Derive a BIP-32 public key from a parent key and public extension.\n *\n * @param options - The options for deriving a public key.\n * @param options.publicKey - The parent public key bytes.\n * @param options.entropy - The entropy bytes.\n * @param options.curve - The curve to use for derivation.\n * @returns The derived public key.\n */\nfunction generatePublicKey({\n  publicKey,\n  entropy,\n  curve,\n}: GeneratePublicKeyArgs): DerivedKeys {\n  const keyMaterial = entropy.slice(0, 32);\n  const childChainCode = entropy.slice(32);\n\n  // This function may fail if the resulting key is invalid.\n  const childPublicKey = curve.publicAdd(publicKey, keyMaterial);\n\n  return {\n    publicKey: childPublicKey,\n    chainCode: childChainCode,\n  };\n}\n\ntype DerivePublicChildKeyArgs = {\n  entropy: Uint8Array;\n  publicKey: Uint8Array;\n  depth: number;\n  masterFingerprint?: number | undefined;\n  parentFingerprint: number;\n  childIndex: number;\n  curve: Curve;\n};\n\n/**\n * Derive a BIP-32 public child key with a given path from a parent key.\n *\n * @param args - The arguments for deriving a public child key.\n * @param args.entropy - The entropy to use for derivation.\n * @param args.publicKey - The parent public key to use for derivation.\n * @param args.depth - The depth of the parent node.\n * @param args.masterFingerprint - The fingerprint of the master node.\n * @param args.parentFingerprint - The fingerprint of the parent node.\n * @param args.childIndex - The child index to derive.\n * @param args.curve - The curve to use for derivation.\n * @returns The derived {@link SLIP10Node}.\n */\nexport async function derivePublicChildKey({\n  entropy,\n  publicKey,\n  depth,\n  masterFingerprint,\n  parentFingerprint,\n  childIndex,\n  curve,\n}: DerivePublicChildKeyArgs): Promise<SLIP10Node> {\n  const { publicKey: childPublicKey, chainCode: childChainCode } =\n    generatePublicKey({\n      publicKey,\n      entropy,\n      curve,\n    });\n\n  return await SLIP10Node.fromExtendedKey({\n    publicKey: childPublicKey,\n    chainCode: childChainCode,\n    depth: depth + 1,\n    masterFingerprint,\n    parentFingerprint,\n    index: childIndex,\n    curve: curve.name,\n  });\n}\n\n/**\n * Add a tweak to the private key: `(privateKey + tweak) % n`.\n *\n * @param privateKeyBytes - The private key as 32 byte Uint8Array.\n * @param tweakBytes - The tweak as 32 byte Uint8Array.\n * @param curve - The curve to use.\n * @throws If the private key or tweak is invalid.\n * @returns The private key with the tweak added to it.\n */\nexport function privateAdd(\n  privateKeyBytes: Uint8Array,\n  tweakBytes: Uint8Array,\n  curve: Curve,\n): Uint8Array {\n  assert(\n    isValidBytesKey(tweakBytes, 32),\n    'Invalid tweak: Tweak must be a non-zero 32-byte Uint8Array.',\n  );\n\n  const privateKey = bytesToBigInt(privateKeyBytes);\n  const tweak = bytesToBigInt(tweakBytes);\n\n  if (tweak >= curve.curve.n) {\n    throw new Error('Invalid tweak: Tweak is larger than the curve order.');\n  }\n\n  const added = mod(privateKey + tweak, curve.curve.n);\n  const bytes = hexToBytes(added.toString(16).padStart(64, '0'));\n\n  if (!curve.isValidPrivateKey(bytes)) {\n    throw new Error(\n      'Invalid private key or tweak: The resulting private key is invalid.',\n    );\n  }\n\n  return bytes;\n}\n\ntype GenerateEntropyArgs = {\n  chainCode: Uint8Array;\n  extension: Uint8Array;\n};\n\n/**\n * Generate 64 bytes of (deterministic) entropy from a chain code and secret\n * extension.\n *\n * @param args - The arguments for generating entropy.\n * @param args.chainCode - The parent chain code bytes.\n * @param args.extension - The extension bytes.\n * @returns The generated entropy bytes.\n */\nexport function generateEntropy({ chainCode, extension }: GenerateEntropyArgs) {\n  return hmac(sha512, chainCode, extension);\n}\n\n/**\n * Validate that a node is specified.\n *\n * @param node - The node to validate.\n * @throws If the node is not specified.\n */\nexport function validateNode(node?: SLIP10Node): asserts node is SLIP10Node {\n  assert(node, 'Invalid parameters: Must specify a node to derive from.');\n}\n\n/**\n * Validate a path.\n *\n * @param path - The path to validate.\n * @param node - The node to validate the path against.\n * @param curve - The curve to validate the path against.\n * @throws If the path is invalid.\n */\nfunction validatePath(\n  path: string | Uint8Array,\n  node: SLIP10Node,\n  curve: Curve,\n): asserts path is string {\n  assert(typeof path === 'string', 'Invalid path: Must be a string.');\n\n  const isHardened = path.endsWith(`'`);\n  assert(\n    !isHardened || node.privateKey,\n    'Invalid parameters: Cannot derive hardened child keys without a private key.',\n  );\n  assert(\n    isHardened || curve.deriveUnhardenedKeys,\n    `Invalid path: Cannot derive unhardened child keys with ${curve.name}.`,\n  );\n}\n\n/**\n * Validate a path and return the child index and whether it is hardened.\n *\n * @param path - The path to validate.\n * @param node - The node to validate the path against.\n * @param curve - The curve to validate the path against.\n * @returns The child index and whether it is hardened.\n */\nexport function getValidatedPath(\n  path: string | Uint8Array,\n  node: SLIP10Node,\n  curve: Curve,\n) {\n  validatePath(path, node, curve);\n\n  const indexPart = path.split(`'`)[0];\n\n  assert(indexPart);\n  const childIndex = parseInt(indexPart, 10);\n\n  if (\n    !UNPREFIXED_PATH_REGEX.test(indexPart) ||\n    !Number.isInteger(childIndex) ||\n    childIndex < 0 ||\n    childIndex >= BIP_32_HARDENED_OFFSET\n  ) {\n    throw new Error(\n      `Invalid path: The index must be a non-negative decimal integer less than ${BIP_32_HARDENED_OFFSET}.`,\n    );\n  }\n\n  return { childIndex, isHardened: path.includes(`'`) };\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"shared.cjs","sourceRoot":"","sources":["../../src/derivers/shared.ts"],"names":[],"mappings":";;;AAAA,2CAKyB;AAGzB,gDAA6E;AAE7E,sDAA6C;AAE7C,gDAAgC;AAChC,kDAA2C;AAC3C,wCAA2D;AAQ3D;;;;;;;;;;;;;;;GAeG;AACI,KAAK,UAAU,cAAc,CAClC,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAsB,EACzC,WAAyB,EACzB,sBAA+C;IAE/C,YAAY,CAAC,IAAI,CAAC,CAAC;IAEnB,MAAM,EAAE,UAAU,EAAE,UAAU,EAAE,GAAG,gBAAgB,CAAC,IAAI,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;IAEvE,MAAM,IAAI,GAAG;QACX,SAAS,EAAE,IAAI,CAAC,cAAc;QAC9B,UAAU;QACV,UAAU;QACV,KAAK,EAAE,IAAI,CAAC,KAAK;QACjB,iBAAiB,EAAE,IAAI,CAAC,WAAW;QACnC,iBAAiB,EAAE,IAAI,CAAC,iBAAiB;QACzC,KAAK;KACN,CAAC;IAEF,IAAI,IAAI,CAAC,eAAe,EAAE,CAAC;QACzB,MAAM,eAAe,GAAG,MAAM,qBAAqB,CAAC;YAClD,UAAU,EAAE,IAAI,CAAC,eAAe;YAChC,UAAU;YACV,UAAU;YACV,KAAK;SACN,CAAC,CAAC;QAEH,MAAM,OAAO,GAAG,MAAM,eAAe,CACnC;YACE,SAAS,EAAE,IAAI,CAAC,cAAc;YAC9B,SAAS,EAAE,eAAe;SAC3B,EACD,sBAAsB,CACvB,CAAC;QAEF,OAAO,MAAM,UAAU,CACrB;YACE,UAAU,EAAE,IAAI,CAAC,eAAe;YAChC,OAAO;YACP,GAAG,IAAI;SACR,EACD,WAAW,EACX,sBAAsB,CACvB,CAAC;IACJ,CAAC;IAED,MAAM,eAAe,GAAG,qBAAqB,CAAC;QAC5C,eAAe,EAAE,IAAI,CAAC,wBAAwB;QAC9C,UAAU;KACX,CAAC,CAAC;IAEH,MAAM,OAAO,GAAG,MAAM,eAAe,CACnC;QACE,SAAS,EAAE,IAAI,CAAC,cAAc;QAC9B,SAAS,EAAE,eAAe;KAC3B,EACD,sBAAsB,CACvB,CAAC;IAEF,OAAO,MAAM,UAAU,CACrB;QACE,SAAS,EAAE,IAAI,CAAC,wBAAwB;QACxC,OAAO;QACP,GAAG,IAAI;KACR,EACD,WAAW,EACX,sBAAsB,CACvB,CAAC;AACJ,CAAC;AApED,wCAoEC;AAgCD;;;;;;;;;;;;;;;;;;GAkBG;AACH,KAAK,UAAU,UAAU,CACvB,OAAuB,EACvB,WAAyB,EACzB,sBAA+C;IAE/C,MAAM,EACJ,UAAU,EACV,SAAS,EACT,OAAO,EACP,UAAU,EACV,UAAU,EACV,KAAK,EACL,iBAAiB,EACjB,iBAAiB,EACjB,KAAK,GACN,GAAG,OAAO,CAAC;IAEZ,IAAI,CAAC;QACH,IAAI,UAAU,EAAE,CAAC;YACf,OAAO,MAAM,qBAAqB,CAChC;gBACE,OAAO;gBACP,UAAU;gBACV,KAAK;gBACL,iBAAiB;gBACjB,iBAAiB;gBACjB,UAAU;gBACV,UAAU;gBACV,KAAK;aACN,EACD,sBAAsB,CACvB,CAAC;QACJ,CAAC;QAED,OAAO,MAAM,oBAAoB,CAC/B;YACE,OAAO;YACP,SAAS;YACT,KAAK;YACL,iBAAiB;YACjB,iBAAiB;YACjB,UAAU;YACV,KAAK;SACN,EACD,sBAAsB,CACvB,CAAC;IACJ,CAAC;IAAC,OAAO,KAAK,EAAE,CAAC;QACf,OAAO,MAAM,UAAU,CACrB,MAAM,WAAW,CAAC,KAAK,EAAE,OAAO,EAAE,sBAAsB,CAAC,EACzD,WAAW,EACX,sBAAsB,CACvB,CAAC;IACJ,CAAC;AACH,CAAC;AAED;;;;;;;;;GASG;AACI,KAAK,UAAU,qBAAqB,CAAC,EAC1C,UAAU,EACV,UAAU,EACV,UAAU,EACV,KAAK,GACqB;IAC1B,IAAI,UAAU,EAAE,CAAC;QACf,iBAAiB;QACjB,OAAO,IAAA,mBAAW,EAAC;YACjB,IAAI,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;YACnB,UAAU;YACV,IAAA,sBAAc,EAAC,UAAU,GAAG,kCAAsB,CAAC;SACpD,CAAC,CAAC;IACL,CAAC;IAED,eAAe;IACf,MAAM,eAAe,GAAG,MAAM,KAAK,CAAC,YAAY,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC;IACnE,OAAO,qBAAqB,CAAC,EAAE,eAAe,EAAE,UAAU,EAAE,CAAC,CAAC;AAChE,CAAC;AAlBD,sDAkBC;AAOD;;;;;;;GAOG;AACH,SAAgB,qBAAqB,CAAC,EACpC,eAAe,EACf,UAAU,GACgB;IAC1B,OAAO,IAAA,mBAAW,EAAC,CAAC,eAAe,EAAE,IAAA,sBAAc,EAAC,UAAU,CAAC,CAAC,CAAC,CAAC;AACpE,CAAC;AALD,sDAKC;AAQD;;;;;;;;GAQG;AACH,KAAK,UAAU,WAAW,CAAC,EACzB,UAAU,EACV,OAAO,EACP,KAAK,GACW;IAChB,MAAM,WAAW,GAAG,OAAO,CAAC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;IACzC,MAAM,cAAc,GAAG,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;IAEzC,kEAAkE;IAClE,wIAAwI;IACxI,IAAI,KAAK,CAAC,IAAI,KAAK,SAAS,EAAE,CAAC;QAC7B,MAAM,SAAS,GAAG,MAAM,KAAK,CAAC,YAAY,CAAC,WAAW,CAAC,CAAC;QACxD,OAAO,EAAE,UAAU,EAAE,WAAW,EAAE,SAAS,EAAE,SAAS,EAAE,cAAc,EAAE,CAAC;IAC3E,CAAC;IAED,MAAM,eAAe,GAAG,UAAU,CAAC,UAAU,EAAE,WAAW,EAAE,KAAK,CAAC,CAAC;IACnE,MAAM,SAAS,GAAG,MAAM,KAAK,CAAC,YAAY,CAAC,eAAe,CAAC,CAAC;IAE5D,OAAO,EAAE,UAAU,EAAE,eAAe,EAAE,SAAS,EAAE,SAAS,EAAE,cAAc,EAAE,CAAC;AAC/E,CAAC;AAaD;;;;;;;;;;;;;;;GAeG;AACH,KAAK,UAAU,qBAAqB,CAClC,EACE,OAAO,EACP,UAAU,EACV,KAAK,EACL,iBAAiB,EACjB,iBAAiB,EACjB,UAAU,EACV,UAAU,EACV,KAAK,GACqB,EAC5B,sBAA+C;IAE/C,MAAM,gBAAgB,GACpB,UAAU,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC,kCAAsB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAEzD,MAAM,EAAE,UAAU,EAAE,eAAe,EAAE,SAAS,EAAE,cAAc,EAAE,GAC9D,MAAM,WAAW,CAAC;QAChB,UAAU;QACV,OAAO;QACP,KAAK;KACN,CAAC,CAAC;IAEL,OAAO,MAAM,uBAAU,CAAC,eAAe,CACrC;QACE,UAAU,EAAE,eAAe;QAC3B,SAAS,EAAE,cAAc;QACzB,KAAK,EAAE,KAAK,GAAG,CAAC;QAChB,iBAAiB;QACjB,iBAAiB;QACjB,KAAK,EAAE,gBAAgB;QACvB,KAAK,EAAE,KAAK,CAAC,IAAI;KAClB,EACD,sBAAsB,CACvB,CAAC;AACJ,CAAC;AAQD;;;;;;;;GAQG;AACH,SAAS,iBAAiB,CAAC,EACzB,SAAS,EACT,OAAO,EACP,KAAK,GACiB;IACtB,MAAM,WAAW,GAAG,OAAO,CAAC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;IACzC,MAAM,cAAc,GAAG,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;IAEzC,0DAA0D;IAC1D,MAAM,cAAc,GAAG,KAAK,CAAC,SAAS,CAAC,SAAS,EAAE,WAAW,CAAC,CAAC;IAE/D,OAAO;QACL,SAAS,EAAE,cAAc;QACzB,SAAS,EAAE,cAAc;KAC1B,CAAC;AACJ,CAAC;AAYD;;;;;;;;;;;;;;GAcG;AACI,KAAK,UAAU,oBAAoB,CACxC,EACE,OAAO,EACP,SAAS,EACT,KAAK,EACL,iBAAiB,EACjB,iBAAiB,EACjB,UAAU,EACV,KAAK,GACoB,EAC3B,sBAA+C;IAE/C,MAAM,EAAE,SAAS,EAAE,cAAc,EAAE,SAAS,EAAE,cAAc,EAAE,GAC5D,iBAAiB,CAAC;QAChB,SAAS;QACT,OAAO;QACP,KAAK;KACN,CAAC,CAAC;IAEL,OAAO,MAAM,uBAAU,CAAC,eAAe,CACrC;QACE,SAAS,EAAE,cAAc;QACzB,SAAS,EAAE,cAAc;QACzB,KAAK,EAAE,KAAK,GAAG,CAAC;QAChB,iBAAiB;QACjB,iBAAiB;QACjB,KAAK,EAAE,UAAU;QACjB,KAAK,EAAE,KAAK,CAAC,IAAI;KAClB,EACD,sBAAsB,CACvB,CAAC;AACJ,CAAC;AA/BD,oDA+BC;AAED;;;;;;;;GAQG;AACH,SAAgB,UAAU,CACxB,eAA2B,EAC3B,UAAsB,EACtB,KAAY;IAEZ,IAAA,cAAM,EACJ,IAAA,uBAAe,EAAC,UAAU,EAAE,EAAE,CAAC,EAC/B,6DAA6D,CAC9D,CAAC;IAEF,MAAM,UAAU,GAAG,IAAA,qBAAa,EAAC,eAAe,CAAC,CAAC;IAClD,MAAM,KAAK,GAAG,IAAA,qBAAa,EAAC,UAAU,CAAC,CAAC;IAExC,IAAI,KAAK,IAAI,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC;QAC3B,MAAM,IAAI,KAAK,CAAC,sDAAsD,CAAC,CAAC;IAC1E,CAAC;IAED,MAAM,KAAK,GAAG,IAAA,YAAG,EAAC,UAAU,GAAG,KAAK,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;IACrD,MAAM,KAAK,GAAG,IAAA,kBAAU,EAAC,KAAK,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC,CAAC;IAE/D,IAAI,CAAC,KAAK,CAAC,iBAAiB,CAAC,KAAK,CAAC,EAAE,CAAC;QACpC,MAAM,IAAI,KAAK,CACb,qEAAqE,CACtE,CAAC;IACJ,CAAC;IAED,OAAO,KAAK,CAAC;AACf,CAAC;AA3BD,gCA2BC;AAOD;;;;;;;;;;GAUG;AACI,KAAK,UAAU,eAAe,CACnC,EAAE,SAAS,EAAE,SAAS,EAAuB,EAC7C,sBAA+C;IAE/C,OAAO,MAAM,IAAA,yBAAU,EAAC,SAAS,EAAE,SAAS,EAAE,sBAAsB,CAAC,CAAC;AACxE,CAAC;AALD,0CAKC;AAED;;;;;GAKG;AACH,SAAgB,YAAY,CAAC,IAAiB;IAC5C,IAAA,cAAM,EAAC,IAAI,EAAE,yDAAyD,CAAC,CAAC;AAC1E,CAAC;AAFD,oCAEC;AAED;;;;;;;GAOG;AACH,SAAS,YAAY,CACnB,IAAyB,EACzB,IAAgB,EAChB,KAAY;IAEZ,IAAA,cAAM,EAAC,OAAO,IAAI,KAAK,QAAQ,EAAE,iCAAiC,CAAC,CAAC;IAEpE,MAAM,UAAU,GAAG,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;IACtC,IAAA,cAAM,EACJ,CAAC,UAAU,IAAI,IAAI,CAAC,UAAU,EAC9B,8EAA8E,CAC/E,CAAC;IACF,IAAA,cAAM,EACJ,UAAU,IAAI,KAAK,CAAC,oBAAoB,EACxC,0DAA0D,KAAK,CAAC,IAAI,GAAG,CACxE,CAAC;AACJ,CAAC;AAED;;;;;;;GAOG;AACH,SAAgB,gBAAgB,CAC9B,IAAyB,EACzB,IAAgB,EAChB,KAAY;IAEZ,YAAY,CAAC,IAAI,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;IAEhC,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;IAErC,IAAA,cAAM,EAAC,SAAS,CAAC,CAAC;IAClB,MAAM,UAAU,GAAG,QAAQ,CAAC,SAAS,EAAE,EAAE,CAAC,CAAC;IAE3C,IACE,CAAC,iCAAqB,CAAC,IAAI,CAAC,SAAS,CAAC;QACtC,CAAC,MAAM,CAAC,SAAS,CAAC,UAAU,CAAC;QAC7B,UAAU,GAAG,CAAC;QACd,UAAU,IAAI,kCAAsB,EACpC,CAAC;QACD,MAAM,IAAI,KAAK,CACb,4EAA4E,kCAAsB,GAAG,CACtG,CAAC;IACJ,CAAC;IAED,OAAO,EAAE,UAAU,EAAE,UAAU,EAAE,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE,CAAC;AACxD,CAAC;AAxBD,4CAwBC","sourcesContent":["import {\n  assert,\n  bytesToBigInt,\n  concatBytes,\n  hexToBytes,\n} from '@metamask/utils';\n\nimport type { DeriveChildKeyArgs, DerivedKeys } from '.';\nimport { BIP_32_HARDENED_OFFSET, UNPREFIXED_PATH_REGEX } from '../constants';\nimport type { CryptographicFunctions } from '../cryptography';\nimport { hmacSha512 } from '../cryptography';\nimport type { Curve } from '../curves';\nimport { mod } from '../curves';\nimport { SLIP10Node } from '../SLIP10Node';\nimport { isValidBytesKey, numberToUint32 } from '../utils';\n\ntype ErrorHandler = (\n  error: unknown,\n  options: DeriveNodeArgs,\n  cryptographicFunctions?: CryptographicFunctions,\n) => Promise<DeriveNodeArgs>;\n\n/**\n * Derive a BIP-32 or SLIP-10 child key with a given path from a parent key.\n *\n * Since BIP-32 and SLIP-10 are very similar, this function can be used to\n * derive both types of keys.\n *\n * @param options - The options for deriving a child key.\n * @param options.path - The derivation path part to derive.\n * @param options.node - The node to derive from.\n * @param options.curve - The curve to use for derivation.\n * @param handleError - A function that can handle errors that occur during\n * derivation.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The derived node.\n */\nexport async function deriveChildKey(\n  { path, node, curve }: DeriveChildKeyArgs,\n  handleError: ErrorHandler,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<SLIP10Node> {\n  validateNode(node);\n\n  const { childIndex, isHardened } = getValidatedPath(path, node, curve);\n\n  const args = {\n    chainCode: node.chainCodeBytes,\n    childIndex,\n    isHardened,\n    depth: node.depth,\n    parentFingerprint: node.fingerprint,\n    masterFingerprint: node.masterFingerprint,\n    curve,\n  };\n\n  if (node.privateKeyBytes) {\n    const secretExtension = await deriveSecretExtension({\n      privateKey: node.privateKeyBytes,\n      childIndex,\n      isHardened,\n      curve,\n    });\n\n    const entropy = await generateEntropy(\n      {\n        chainCode: node.chainCodeBytes,\n        extension: secretExtension,\n      },\n      cryptographicFunctions,\n    );\n\n    return await deriveNode(\n      {\n        privateKey: node.privateKeyBytes,\n        entropy,\n        ...args,\n      },\n      handleError,\n      cryptographicFunctions,\n    );\n  }\n\n  const publicExtension = derivePublicExtension({\n    parentPublicKey: node.compressedPublicKeyBytes,\n    childIndex,\n  });\n\n  const entropy = await generateEntropy(\n    {\n      chainCode: node.chainCodeBytes,\n      extension: publicExtension,\n    },\n    cryptographicFunctions,\n  );\n\n  return await deriveNode(\n    {\n      publicKey: node.compressedPublicKeyBytes,\n      entropy,\n      ...args,\n    },\n    handleError,\n    cryptographicFunctions,\n  );\n}\n\ntype BaseDeriveNodeArgs = {\n  entropy: Uint8Array;\n  chainCode: Uint8Array;\n  childIndex: number;\n  isHardened: boolean;\n  depth: number;\n  parentFingerprint: number;\n  masterFingerprint?: number | undefined;\n  curve: Curve;\n};\n\ntype DerivePrivateKeyArgs = BaseDeriveNodeArgs & {\n  privateKey: Uint8Array;\n  publicKey?: never | undefined;\n};\n\ntype DerivePublicKeyArgs = BaseDeriveNodeArgs & {\n  publicKey: Uint8Array;\n  privateKey?: never | undefined;\n};\n\nexport type DeriveNodeArgs = DerivePrivateKeyArgs | DerivePublicKeyArgs;\n\ntype DeriveSecretExtensionArgs = {\n  privateKey: Uint8Array;\n  childIndex: number;\n  isHardened: boolean;\n  curve: Curve;\n};\n\n/**\n * Derive a SLIP-10 child key from a parent key.\n *\n * @param options - The options for deriving a child key.\n * @param options.privateKey - The private key to derive from.\n * @param options.publicKey - The public key to derive from.\n * @param options.entropy - The entropy to use for deriving the child key.\n * @param options.chainCode - The chain code to use for deriving the child key.\n * @param options.childIndex - The child index to use for deriving the child key.\n * @param options.isHardened - Whether the child key is hardened.\n * @param options.depth - The depth of the child key.\n * @param options.parentFingerprint - The fingerprint of the parent key.\n * @param options.masterFingerprint - The fingerprint of the master key.\n * @param options.curve - The curve to use for deriving the child key.\n * @param handleError - A function to handle errors during derivation.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The derived child key as {@link SLIP10Node}.\n */\nasync function deriveNode(\n  options: DeriveNodeArgs,\n  handleError: ErrorHandler,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<SLIP10Node> {\n  const {\n    privateKey,\n    publicKey,\n    entropy,\n    childIndex,\n    isHardened,\n    depth,\n    parentFingerprint,\n    masterFingerprint,\n    curve,\n  } = options;\n\n  try {\n    if (privateKey) {\n      return await derivePrivateChildKey(\n        {\n          entropy,\n          privateKey,\n          depth,\n          masterFingerprint,\n          parentFingerprint,\n          childIndex,\n          isHardened,\n          curve,\n        },\n        cryptographicFunctions,\n      );\n    }\n\n    return await derivePublicChildKey(\n      {\n        entropy,\n        publicKey,\n        depth,\n        masterFingerprint,\n        parentFingerprint,\n        childIndex,\n        curve,\n      },\n      cryptographicFunctions,\n    );\n  } catch (error) {\n    return await deriveNode(\n      await handleError(error, options, cryptographicFunctions),\n      handleError,\n      cryptographicFunctions,\n    );\n  }\n}\n\n/**\n * Derive a BIP-32 secret extension from a parent key and child index.\n *\n * @param options - The options for deriving a secret extension.\n * @param options.privateKey - The parent private key bytes.\n * @param options.childIndex - The child index to derive.\n * @param options.isHardened - Whether the child index is hardened.\n * @param options.curve - The curve to use for derivation.\n * @returns The secret extension bytes.\n */\nexport async function deriveSecretExtension({\n  privateKey,\n  childIndex,\n  isHardened,\n  curve,\n}: DeriveSecretExtensionArgs): Promise<Uint8Array> {\n  if (isHardened) {\n    // Hardened child\n    return concatBytes([\n      new Uint8Array([0]),\n      privateKey,\n      numberToUint32(childIndex + BIP_32_HARDENED_OFFSET),\n    ]);\n  }\n\n  // Normal child\n  const parentPublicKey = await curve.getPublicKey(privateKey, true);\n  return derivePublicExtension({ parentPublicKey, childIndex });\n}\n\ntype DerivePublicExtensionArgs = {\n  parentPublicKey: Uint8Array;\n  childIndex: number;\n};\n\n/**\n * Derive a BIP-32 public extension from a parent key and child index.\n *\n * @param options - The options for deriving a public extension.\n * @param options.parentPublicKey - The parent public key bytes.\n * @param options.childIndex - The child index to derive.\n * @returns The public extension bytes.\n */\nexport function derivePublicExtension({\n  parentPublicKey,\n  childIndex,\n}: DerivePublicExtensionArgs): Uint8Array {\n  return concatBytes([parentPublicKey, numberToUint32(childIndex)]);\n}\n\ntype GenerateKeyArgs = {\n  privateKey: Uint8Array;\n  entropy: Uint8Array;\n  curve: Curve;\n};\n\n/**\n * Derive a BIP-32 key from a parent key and secret extension.\n *\n * @param options - The options for deriving a key.\n * @param options.privateKey - The parent private key bytes.\n * @param options.entropy - The entropy bytes.\n * @param options.curve - The curve to use for derivation.\n * @returns The derived key.\n */\nasync function generateKey({\n  privateKey,\n  entropy,\n  curve,\n}: GenerateKeyArgs): Promise<DerivedKeys & { privateKey: Uint8Array }> {\n  const keyMaterial = entropy.slice(0, 32);\n  const childChainCode = entropy.slice(32);\n\n  // If curve is ed25519: The returned child key ki is parse256(IL).\n  // https://github.com/satoshilabs/slips/blob/133ea52a8e43d338b98be208907e144277e44c0e/slip-0010.md#private-parent-key--private-child-key\n  if (curve.name === 'ed25519') {\n    const publicKey = await curve.getPublicKey(keyMaterial);\n    return { privateKey: keyMaterial, publicKey, chainCode: childChainCode };\n  }\n\n  const childPrivateKey = privateAdd(privateKey, keyMaterial, curve);\n  const publicKey = await curve.getPublicKey(childPrivateKey);\n\n  return { privateKey: childPrivateKey, publicKey, chainCode: childChainCode };\n}\n\ntype DerivePrivateChildKeyArgs = {\n  entropy: Uint8Array;\n  privateKey: Uint8Array;\n  depth: number;\n  masterFingerprint?: number | undefined;\n  parentFingerprint: number;\n  childIndex: number;\n  isHardened: boolean;\n  curve: Curve;\n};\n\n/**\n * Derive a BIP-32 private child key with a given path from a parent key.\n *\n * @param args - The arguments for deriving a private child key.\n * @param args.entropy - The entropy to use for derivation.\n * @param args.privateKey - The parent private key to use for derivation.\n * @param args.depth - The depth of the parent node.\n * @param args.masterFingerprint - The fingerprint of the master node.\n * @param args.parentFingerprint - The fingerprint of the parent node.\n * @param args.childIndex - The child index to derive.\n * @param args.isHardened - Whether the child index is hardened.\n * @param args.curve - The curve to use for derivation.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The derived {@link SLIP10Node}.\n */\nasync function derivePrivateChildKey(\n  {\n    entropy,\n    privateKey,\n    depth,\n    masterFingerprint,\n    parentFingerprint,\n    childIndex,\n    isHardened,\n    curve,\n  }: DerivePrivateChildKeyArgs,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<SLIP10Node> {\n  const actualChildIndex =\n    childIndex + (isHardened ? BIP_32_HARDENED_OFFSET : 0);\n\n  const { privateKey: childPrivateKey, chainCode: childChainCode } =\n    await generateKey({\n      privateKey,\n      entropy,\n      curve,\n    });\n\n  return await SLIP10Node.fromExtendedKey(\n    {\n      privateKey: childPrivateKey,\n      chainCode: childChainCode,\n      depth: depth + 1,\n      masterFingerprint,\n      parentFingerprint,\n      index: actualChildIndex,\n      curve: curve.name,\n    },\n    cryptographicFunctions,\n  );\n}\n\ntype GeneratePublicKeyArgs = {\n  publicKey: Uint8Array;\n  entropy: Uint8Array;\n  curve: Curve;\n};\n\n/**\n * Derive a BIP-32 public key from a parent key and public extension.\n *\n * @param options - The options for deriving a public key.\n * @param options.publicKey - The parent public key bytes.\n * @param options.entropy - The entropy bytes.\n * @param options.curve - The curve to use for derivation.\n * @returns The derived public key.\n */\nfunction generatePublicKey({\n  publicKey,\n  entropy,\n  curve,\n}: GeneratePublicKeyArgs): DerivedKeys {\n  const keyMaterial = entropy.slice(0, 32);\n  const childChainCode = entropy.slice(32);\n\n  // This function may fail if the resulting key is invalid.\n  const childPublicKey = curve.publicAdd(publicKey, keyMaterial);\n\n  return {\n    publicKey: childPublicKey,\n    chainCode: childChainCode,\n  };\n}\n\ntype DerivePublicChildKeyArgs = {\n  entropy: Uint8Array;\n  publicKey: Uint8Array;\n  depth: number;\n  masterFingerprint?: number | undefined;\n  parentFingerprint: number;\n  childIndex: number;\n  curve: Curve;\n};\n\n/**\n * Derive a BIP-32 public child key with a given path from a parent key.\n *\n * @param args - The arguments for deriving a public child key.\n * @param args.entropy - The entropy to use for derivation.\n * @param args.publicKey - The parent public key to use for derivation.\n * @param args.depth - The depth of the parent node.\n * @param args.masterFingerprint - The fingerprint of the master node.\n * @param args.parentFingerprint - The fingerprint of the parent node.\n * @param args.childIndex - The child index to derive.\n * @param args.curve - The curve to use for derivation.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The derived {@link SLIP10Node}.\n */\nexport async function derivePublicChildKey(\n  {\n    entropy,\n    publicKey,\n    depth,\n    masterFingerprint,\n    parentFingerprint,\n    childIndex,\n    curve,\n  }: DerivePublicChildKeyArgs,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<SLIP10Node> {\n  const { publicKey: childPublicKey, chainCode: childChainCode } =\n    generatePublicKey({\n      publicKey,\n      entropy,\n      curve,\n    });\n\n  return await SLIP10Node.fromExtendedKey(\n    {\n      publicKey: childPublicKey,\n      chainCode: childChainCode,\n      depth: depth + 1,\n      masterFingerprint,\n      parentFingerprint,\n      index: childIndex,\n      curve: curve.name,\n    },\n    cryptographicFunctions,\n  );\n}\n\n/**\n * Add a tweak to the private key: `(privateKey + tweak) % n`.\n *\n * @param privateKeyBytes - The private key as 32 byte Uint8Array.\n * @param tweakBytes - The tweak as 32 byte Uint8Array.\n * @param curve - The curve to use.\n * @throws If the private key or tweak is invalid.\n * @returns The private key with the tweak added to it.\n */\nexport function privateAdd(\n  privateKeyBytes: Uint8Array,\n  tweakBytes: Uint8Array,\n  curve: Curve,\n): Uint8Array {\n  assert(\n    isValidBytesKey(tweakBytes, 32),\n    'Invalid tweak: Tweak must be a non-zero 32-byte Uint8Array.',\n  );\n\n  const privateKey = bytesToBigInt(privateKeyBytes);\n  const tweak = bytesToBigInt(tweakBytes);\n\n  if (tweak >= curve.curve.n) {\n    throw new Error('Invalid tweak: Tweak is larger than the curve order.');\n  }\n\n  const added = mod(privateKey + tweak, curve.curve.n);\n  const bytes = hexToBytes(added.toString(16).padStart(64, '0'));\n\n  if (!curve.isValidPrivateKey(bytes)) {\n    throw new Error(\n      'Invalid private key or tweak: The resulting private key is invalid.',\n    );\n  }\n\n  return bytes;\n}\n\ntype GenerateEntropyArgs = {\n  chainCode: Uint8Array;\n  extension: Uint8Array;\n};\n\n/**\n * Generate 64 bytes of (deterministic) entropy from a chain code and secret\n * extension.\n *\n * @param args - The arguments for generating entropy.\n * @param args.chainCode - The parent chain code bytes.\n * @param args.extension - The extension bytes.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The generated entropy bytes.\n */\nexport async function generateEntropy(\n  { chainCode, extension }: GenerateEntropyArgs,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<Uint8Array> {\n  return await hmacSha512(chainCode, extension, cryptographicFunctions);\n}\n\n/**\n * Validate that a node is specified.\n *\n * @param node - The node to validate.\n * @throws If the node is not specified.\n */\nexport function validateNode(node?: SLIP10Node): asserts node is SLIP10Node {\n  assert(node, 'Invalid parameters: Must specify a node to derive from.');\n}\n\n/**\n * Validate a path.\n *\n * @param path - The path to validate.\n * @param node - The node to validate the path against.\n * @param curve - The curve to validate the path against.\n * @throws If the path is invalid.\n */\nfunction validatePath(\n  path: string | Uint8Array,\n  node: SLIP10Node,\n  curve: Curve,\n): asserts path is string {\n  assert(typeof path === 'string', 'Invalid path: Must be a string.');\n\n  const isHardened = path.endsWith(`'`);\n  assert(\n    !isHardened || node.privateKey,\n    'Invalid parameters: Cannot derive hardened child keys without a private key.',\n  );\n  assert(\n    isHardened || curve.deriveUnhardenedKeys,\n    `Invalid path: Cannot derive unhardened child keys with ${curve.name}.`,\n  );\n}\n\n/**\n * Validate a path and return the child index and whether it is hardened.\n *\n * @param path - The path to validate.\n * @param node - The node to validate the path against.\n * @param curve - The curve to validate the path against.\n * @returns The child index and whether it is hardened.\n */\nexport function getValidatedPath(\n  path: string | Uint8Array,\n  node: SLIP10Node,\n  curve: Curve,\n): { childIndex: number; isHardened: boolean } {\n  validatePath(path, node, curve);\n\n  const indexPart = path.split(`'`)[0];\n\n  assert(indexPart);\n  const childIndex = parseInt(indexPart, 10);\n\n  if (\n    !UNPREFIXED_PATH_REGEX.test(indexPart) ||\n    !Number.isInteger(childIndex) ||\n    childIndex < 0 ||\n    childIndex >= BIP_32_HARDENED_OFFSET\n  ) {\n    throw new Error(\n      `Invalid path: The index must be a non-negative decimal integer less than ${BIP_32_HARDENED_OFFSET}.`,\n    );\n  }\n\n  return { childIndex, isHardened: path.includes(`'`) };\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/derivers/shared.d.cts b/node_modules/@metamask/key-tree/dist/derivers/shared.d.cts
index ad4839b..523518c 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/shared.d.cts
+++ b/node_modules/@metamask/key-tree/dist/derivers/shared.d.cts
@@ -1,7 +1,8 @@
 import type { DeriveChildKeyArgs } from "./index.cjs";
+import type { CryptographicFunctions } from "../cryptography.cjs";
 import type { Curve } from "../curves/index.cjs";
 import { SLIP10Node } from "../SLIP10Node.cjs";
-declare type ErrorHandler = (error: unknown, options: DeriveNodeArgs) => Promise<DeriveNodeArgs>;
+type ErrorHandler = (error: unknown, options: DeriveNodeArgs, cryptographicFunctions?: CryptographicFunctions) => Promise<DeriveNodeArgs>;
 /**
  * Derive a BIP-32 or SLIP-10 child key with a given path from a parent key.
  *
@@ -14,10 +15,12 @@ declare type ErrorHandler = (error: unknown, options: DeriveNodeArgs) => Promise
  * @param options.curve - The curve to use for derivation.
  * @param handleError - A function that can handle errors that occur during
  * derivation.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The derived node.
  */
-export declare function deriveChildKey({ path, node, curve }: DeriveChildKeyArgs, handleError: ErrorHandler): Promise<SLIP10Node>;
-declare type BaseDeriveNodeArgs = {
+export declare function deriveChildKey({ path, node, curve }: DeriveChildKeyArgs, handleError: ErrorHandler, cryptographicFunctions?: CryptographicFunctions): Promise<SLIP10Node>;
+type BaseDeriveNodeArgs = {
     entropy: Uint8Array;
     chainCode: Uint8Array;
     childIndex: number;
@@ -27,16 +30,16 @@ declare type BaseDeriveNodeArgs = {
     masterFingerprint?: number | undefined;
     curve: Curve;
 };
-declare type DerivePrivateKeyArgs = BaseDeriveNodeArgs & {
+type DerivePrivateKeyArgs = BaseDeriveNodeArgs & {
     privateKey: Uint8Array;
     publicKey?: never | undefined;
 };
-declare type DerivePublicKeyArgs = BaseDeriveNodeArgs & {
+type DerivePublicKeyArgs = BaseDeriveNodeArgs & {
     publicKey: Uint8Array;
     privateKey?: never | undefined;
 };
-export declare type DeriveNodeArgs = DerivePrivateKeyArgs | DerivePublicKeyArgs;
-declare type DeriveSecretExtensionArgs = {
+export type DeriveNodeArgs = DerivePrivateKeyArgs | DerivePublicKeyArgs;
+type DeriveSecretExtensionArgs = {
     privateKey: Uint8Array;
     childIndex: number;
     isHardened: boolean;
@@ -53,7 +56,7 @@ declare type DeriveSecretExtensionArgs = {
  * @returns The secret extension bytes.
  */
 export declare function deriveSecretExtension({ privateKey, childIndex, isHardened, curve, }: DeriveSecretExtensionArgs): Promise<Uint8Array>;
-declare type DerivePublicExtensionArgs = {
+type DerivePublicExtensionArgs = {
     parentPublicKey: Uint8Array;
     childIndex: number;
 };
@@ -66,7 +69,7 @@ declare type DerivePublicExtensionArgs = {
  * @returns The public extension bytes.
  */
 export declare function derivePublicExtension({ parentPublicKey, childIndex, }: DerivePublicExtensionArgs): Uint8Array;
-declare type DerivePublicChildKeyArgs = {
+type DerivePublicChildKeyArgs = {
     entropy: Uint8Array;
     publicKey: Uint8Array;
     depth: number;
@@ -86,9 +89,11 @@ declare type DerivePublicChildKeyArgs = {
  * @param args.parentFingerprint - The fingerprint of the parent node.
  * @param args.childIndex - The child index to derive.
  * @param args.curve - The curve to use for derivation.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The derived {@link SLIP10Node}.
  */
-export declare function derivePublicChildKey({ entropy, publicKey, depth, masterFingerprint, parentFingerprint, childIndex, curve, }: DerivePublicChildKeyArgs): Promise<SLIP10Node>;
+export declare function derivePublicChildKey({ entropy, publicKey, depth, masterFingerprint, parentFingerprint, childIndex, curve, }: DerivePublicChildKeyArgs, cryptographicFunctions?: CryptographicFunctions): Promise<SLIP10Node>;
 /**
  * Add a tweak to the private key: `(privateKey + tweak) % n`.
  *
@@ -99,7 +104,7 @@ export declare function derivePublicChildKey({ entropy, publicKey, depth, master
  * @returns The private key with the tweak added to it.
  */
 export declare function privateAdd(privateKeyBytes: Uint8Array, tweakBytes: Uint8Array, curve: Curve): Uint8Array;
-declare type GenerateEntropyArgs = {
+type GenerateEntropyArgs = {
     chainCode: Uint8Array;
     extension: Uint8Array;
 };
@@ -110,9 +115,11 @@ declare type GenerateEntropyArgs = {
  * @param args - The arguments for generating entropy.
  * @param args.chainCode - The parent chain code bytes.
  * @param args.extension - The extension bytes.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The generated entropy bytes.
  */
-export declare function generateEntropy({ chainCode, extension }: GenerateEntropyArgs): Uint8Array;
+export declare function generateEntropy({ chainCode, extension }: GenerateEntropyArgs, cryptographicFunctions?: CryptographicFunctions): Promise<Uint8Array>;
 /**
  * Validate that a node is specified.
  *
diff --git a/node_modules/@metamask/key-tree/dist/derivers/shared.d.cts.map b/node_modules/@metamask/key-tree/dist/derivers/shared.d.cts.map
index a2c787d..f11403f 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/shared.d.cts.map
+++ b/node_modules/@metamask/key-tree/dist/derivers/shared.d.cts.map
@@ -1 +1 @@
-{"version":3,"file":"shared.d.cts","sourceRoot":"","sources":["../../src/derivers/shared.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"shared.d.cts","sourceRoot":"","sources":["../../src/derivers/shared.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/derivers/shared.d.mts b/node_modules/@metamask/key-tree/dist/derivers/shared.d.mts
index 1bed4fd..dfe5a59 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/shared.d.mts
+++ b/node_modules/@metamask/key-tree/dist/derivers/shared.d.mts
@@ -1,7 +1,8 @@
 import type { DeriveChildKeyArgs } from "./index.mjs";
+import type { CryptographicFunctions } from "../cryptography.mjs";
 import type { Curve } from "../curves/index.mjs";
 import { SLIP10Node } from "../SLIP10Node.mjs";
-declare type ErrorHandler = (error: unknown, options: DeriveNodeArgs) => Promise<DeriveNodeArgs>;
+type ErrorHandler = (error: unknown, options: DeriveNodeArgs, cryptographicFunctions?: CryptographicFunctions) => Promise<DeriveNodeArgs>;
 /**
  * Derive a BIP-32 or SLIP-10 child key with a given path from a parent key.
  *
@@ -14,10 +15,12 @@ declare type ErrorHandler = (error: unknown, options: DeriveNodeArgs) => Promise
  * @param options.curve - The curve to use for derivation.
  * @param handleError - A function that can handle errors that occur during
  * derivation.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The derived node.
  */
-export declare function deriveChildKey({ path, node, curve }: DeriveChildKeyArgs, handleError: ErrorHandler): Promise<SLIP10Node>;
-declare type BaseDeriveNodeArgs = {
+export declare function deriveChildKey({ path, node, curve }: DeriveChildKeyArgs, handleError: ErrorHandler, cryptographicFunctions?: CryptographicFunctions): Promise<SLIP10Node>;
+type BaseDeriveNodeArgs = {
     entropy: Uint8Array;
     chainCode: Uint8Array;
     childIndex: number;
@@ -27,16 +30,16 @@ declare type BaseDeriveNodeArgs = {
     masterFingerprint?: number | undefined;
     curve: Curve;
 };
-declare type DerivePrivateKeyArgs = BaseDeriveNodeArgs & {
+type DerivePrivateKeyArgs = BaseDeriveNodeArgs & {
     privateKey: Uint8Array;
     publicKey?: never | undefined;
 };
-declare type DerivePublicKeyArgs = BaseDeriveNodeArgs & {
+type DerivePublicKeyArgs = BaseDeriveNodeArgs & {
     publicKey: Uint8Array;
     privateKey?: never | undefined;
 };
-export declare type DeriveNodeArgs = DerivePrivateKeyArgs | DerivePublicKeyArgs;
-declare type DeriveSecretExtensionArgs = {
+export type DeriveNodeArgs = DerivePrivateKeyArgs | DerivePublicKeyArgs;
+type DeriveSecretExtensionArgs = {
     privateKey: Uint8Array;
     childIndex: number;
     isHardened: boolean;
@@ -53,7 +56,7 @@ declare type DeriveSecretExtensionArgs = {
  * @returns The secret extension bytes.
  */
 export declare function deriveSecretExtension({ privateKey, childIndex, isHardened, curve, }: DeriveSecretExtensionArgs): Promise<Uint8Array>;
-declare type DerivePublicExtensionArgs = {
+type DerivePublicExtensionArgs = {
     parentPublicKey: Uint8Array;
     childIndex: number;
 };
@@ -66,7 +69,7 @@ declare type DerivePublicExtensionArgs = {
  * @returns The public extension bytes.
  */
 export declare function derivePublicExtension({ parentPublicKey, childIndex, }: DerivePublicExtensionArgs): Uint8Array;
-declare type DerivePublicChildKeyArgs = {
+type DerivePublicChildKeyArgs = {
     entropy: Uint8Array;
     publicKey: Uint8Array;
     depth: number;
@@ -86,9 +89,11 @@ declare type DerivePublicChildKeyArgs = {
  * @param args.parentFingerprint - The fingerprint of the parent node.
  * @param args.childIndex - The child index to derive.
  * @param args.curve - The curve to use for derivation.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The derived {@link SLIP10Node}.
  */
-export declare function derivePublicChildKey({ entropy, publicKey, depth, masterFingerprint, parentFingerprint, childIndex, curve, }: DerivePublicChildKeyArgs): Promise<SLIP10Node>;
+export declare function derivePublicChildKey({ entropy, publicKey, depth, masterFingerprint, parentFingerprint, childIndex, curve, }: DerivePublicChildKeyArgs, cryptographicFunctions?: CryptographicFunctions): Promise<SLIP10Node>;
 /**
  * Add a tweak to the private key: `(privateKey + tweak) % n`.
  *
@@ -99,7 +104,7 @@ export declare function derivePublicChildKey({ entropy, publicKey, depth, master
  * @returns The private key with the tweak added to it.
  */
 export declare function privateAdd(privateKeyBytes: Uint8Array, tweakBytes: Uint8Array, curve: Curve): Uint8Array;
-declare type GenerateEntropyArgs = {
+type GenerateEntropyArgs = {
     chainCode: Uint8Array;
     extension: Uint8Array;
 };
@@ -110,9 +115,11 @@ declare type GenerateEntropyArgs = {
  * @param args - The arguments for generating entropy.
  * @param args.chainCode - The parent chain code bytes.
  * @param args.extension - The extension bytes.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The generated entropy bytes.
  */
-export declare function generateEntropy({ chainCode, extension }: GenerateEntropyArgs): Uint8Array;
+export declare function generateEntropy({ chainCode, extension }: GenerateEntropyArgs, cryptographicFunctions?: CryptographicFunctions): Promise<Uint8Array>;
 /**
  * Validate that a node is specified.
  *
diff --git a/node_modules/@metamask/key-tree/dist/derivers/shared.d.mts.map b/node_modules/@metamask/key-tree/dist/derivers/shared.d.mts.map
index 3e4e68f..67fce38 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/shared.d.mts.map
+++ b/node_modules/@metamask/key-tree/dist/derivers/shared.d.mts.map
@@ -1 +1 @@
-{"version":3,"file":"shared.d.mts","sourceRoot":"","sources":["../../src/derivers/shared.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"shared.d.mts","sourceRoot":"","sources":["../../src/derivers/shared.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/derivers/shared.mjs b/node_modules/@metamask/key-tree/dist/derivers/shared.mjs
index 05484c0..52fe9e9 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/shared.mjs
+++ b/node_modules/@metamask/key-tree/dist/derivers/shared.mjs
@@ -1,7 +1,6 @@
 import { assert, bytesToBigInt, concatBytes, hexToBytes } from "@metamask/utils";
-import { hmac } from "@noble/hashes/hmac";
-import { sha512 } from "@noble/hashes/sha512";
 import { BIP_32_HARDENED_OFFSET, UNPREFIXED_PATH_REGEX } from "../constants.mjs";
+import { hmacSha512 } from "../cryptography.mjs";
 import { mod } from "../curves/index.mjs";
 import { SLIP10Node } from "../SLIP10Node.mjs";
 import { isValidBytesKey, numberToUint32 } from "../utils.mjs";
@@ -17,9 +16,11 @@ import { isValidBytesKey, numberToUint32 } from "../utils.mjs";
  * @param options.curve - The curve to use for derivation.
  * @param handleError - A function that can handle errors that occur during
  * derivation.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The derived node.
  */
-export async function deriveChildKey({ path, node, curve }, handleError) {
+export async function deriveChildKey({ path, node, curve }, handleError, cryptographicFunctions) {
     validateNode(node);
     const { childIndex, isHardened } = getValidatedPath(path, node, curve);
     const args = {
@@ -38,29 +39,29 @@ export async function deriveChildKey({ path, node, curve }, handleError) {
             isHardened,
             curve,
         });
-        const entropy = generateEntropy({
+        const entropy = await generateEntropy({
             chainCode: node.chainCodeBytes,
             extension: secretExtension,
-        });
+        }, cryptographicFunctions);
         return await deriveNode({
             privateKey: node.privateKeyBytes,
             entropy,
             ...args,
-        }, handleError);
+        }, handleError, cryptographicFunctions);
     }
     const publicExtension = derivePublicExtension({
         parentPublicKey: node.compressedPublicKeyBytes,
         childIndex,
     });
-    const entropy = generateEntropy({
+    const entropy = await generateEntropy({
         chainCode: node.chainCodeBytes,
         extension: publicExtension,
-    });
+    }, cryptographicFunctions);
     return await deriveNode({
         publicKey: node.compressedPublicKeyBytes,
         entropy,
         ...args,
-    }, handleError);
+    }, handleError, cryptographicFunctions);
 }
 /**
  * Derive a SLIP-10 child key from a parent key.
@@ -77,9 +78,11 @@ export async function deriveChildKey({ path, node, curve }, handleError) {
  * @param options.masterFingerprint - The fingerprint of the master key.
  * @param options.curve - The curve to use for deriving the child key.
  * @param handleError - A function to handle errors during derivation.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The derived child key as {@link SLIP10Node}.
  */
-async function deriveNode(options, handleError) {
+async function deriveNode(options, handleError, cryptographicFunctions) {
     const { privateKey, publicKey, entropy, childIndex, isHardened, depth, parentFingerprint, masterFingerprint, curve, } = options;
     try {
         if (privateKey) {
@@ -92,7 +95,7 @@ async function deriveNode(options, handleError) {
                 childIndex,
                 isHardened,
                 curve,
-            });
+            }, cryptographicFunctions);
         }
         return await derivePublicChildKey({
             entropy,
@@ -102,10 +105,10 @@ async function deriveNode(options, handleError) {
             parentFingerprint,
             childIndex,
             curve,
-        });
+        }, cryptographicFunctions);
     }
     catch (error) {
-        return await deriveNode(await handleError(error, options), handleError);
+        return await deriveNode(await handleError(error, options, cryptographicFunctions), handleError, cryptographicFunctions);
     }
 }
 /**
@@ -176,9 +179,11 @@ async function generateKey({ privateKey, entropy, curve, }) {
  * @param args.childIndex - The child index to derive.
  * @param args.isHardened - Whether the child index is hardened.
  * @param args.curve - The curve to use for derivation.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The derived {@link SLIP10Node}.
  */
-async function derivePrivateChildKey({ entropy, privateKey, depth, masterFingerprint, parentFingerprint, childIndex, isHardened, curve, }) {
+async function derivePrivateChildKey({ entropy, privateKey, depth, masterFingerprint, parentFingerprint, childIndex, isHardened, curve, }, cryptographicFunctions) {
     const actualChildIndex = childIndex + (isHardened ? BIP_32_HARDENED_OFFSET : 0);
     const { privateKey: childPrivateKey, chainCode: childChainCode } = await generateKey({
         privateKey,
@@ -193,7 +198,7 @@ async function derivePrivateChildKey({ entropy, privateKey, depth, masterFingerp
         parentFingerprint,
         index: actualChildIndex,
         curve: curve.name,
-    });
+    }, cryptographicFunctions);
 }
 /**
  * Derive a BIP-32 public key from a parent key and public extension.
@@ -225,9 +230,11 @@ function generatePublicKey({ publicKey, entropy, curve, }) {
  * @param args.parentFingerprint - The fingerprint of the parent node.
  * @param args.childIndex - The child index to derive.
  * @param args.curve - The curve to use for derivation.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The derived {@link SLIP10Node}.
  */
-export async function derivePublicChildKey({ entropy, publicKey, depth, masterFingerprint, parentFingerprint, childIndex, curve, }) {
+export async function derivePublicChildKey({ entropy, publicKey, depth, masterFingerprint, parentFingerprint, childIndex, curve, }, cryptographicFunctions) {
     const { publicKey: childPublicKey, chainCode: childChainCode } = generatePublicKey({
         publicKey,
         entropy,
@@ -241,7 +248,7 @@ export async function derivePublicChildKey({ entropy, publicKey, depth, masterFi
         parentFingerprint,
         index: childIndex,
         curve: curve.name,
-    });
+    }, cryptographicFunctions);
 }
 /**
  * Add a tweak to the private key: `(privateKey + tweak) % n`.
@@ -273,10 +280,12 @@ export function privateAdd(privateKeyBytes, tweakBytes, curve) {
  * @param args - The arguments for generating entropy.
  * @param args.chainCode - The parent chain code bytes.
  * @param args.extension - The extension bytes.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The generated entropy bytes.
  */
-export function generateEntropy({ chainCode, extension }) {
-    return hmac(sha512, chainCode, extension);
+export async function generateEntropy({ chainCode, extension }, cryptographicFunctions) {
+    return await hmacSha512(chainCode, extension, cryptographicFunctions);
 }
 /**
  * Validate that a node is specified.
diff --git a/node_modules/@metamask/key-tree/dist/derivers/shared.mjs.map b/node_modules/@metamask/key-tree/dist/derivers/shared.mjs.map
index 92212f9..3a5aa29 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/shared.mjs.map
+++ b/node_modules/@metamask/key-tree/dist/derivers/shared.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"shared.mjs","sourceRoot":"","sources":["../../src/derivers/shared.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  assert,\n  bytesToBigInt,\n  concatBytes,\n  hexToBytes,\n} from '@metamask/utils';\nimport { hmac } from '@noble/hashes/hmac';\nimport { sha512 } from '@noble/hashes/sha512';\n\nimport type { DeriveChildKeyArgs, DerivedKeys } from '.';\nimport { BIP_32_HARDENED_OFFSET, UNPREFIXED_PATH_REGEX } from '../constants';\nimport type { Curve } from '../curves';\nimport { mod } from '../curves';\nimport { SLIP10Node } from '../SLIP10Node';\nimport { isValidBytesKey, numberToUint32 } from '../utils';\n\ntype ErrorHandler = (\n  error: unknown,\n  options: DeriveNodeArgs,\n) => Promise<DeriveNodeArgs>;\n\n/**\n * Derive a BIP-32 or SLIP-10 child key with a given path from a parent key.\n *\n * Since BIP-32 and SLIP-10 are very similar, this function can be used to\n * derive both types of keys.\n *\n * @param options - The options for deriving a child key.\n * @param options.path - The derivation path part to derive.\n * @param options.node - The node to derive from.\n * @param options.curve - The curve to use for derivation.\n * @param handleError - A function that can handle errors that occur during\n * derivation.\n * @returns The derived node.\n */\nexport async function deriveChildKey(\n  { path, node, curve }: DeriveChildKeyArgs,\n  handleError: ErrorHandler,\n) {\n  validateNode(node);\n\n  const { childIndex, isHardened } = getValidatedPath(path, node, curve);\n\n  const args = {\n    chainCode: node.chainCodeBytes,\n    childIndex,\n    isHardened,\n    depth: node.depth,\n    parentFingerprint: node.fingerprint,\n    masterFingerprint: node.masterFingerprint,\n    curve,\n  };\n\n  if (node.privateKeyBytes) {\n    const secretExtension = await deriveSecretExtension({\n      privateKey: node.privateKeyBytes,\n      childIndex,\n      isHardened,\n      curve,\n    });\n\n    const entropy = generateEntropy({\n      chainCode: node.chainCodeBytes,\n      extension: secretExtension,\n    });\n\n    return await deriveNode(\n      {\n        privateKey: node.privateKeyBytes,\n        entropy,\n        ...args,\n      },\n      handleError,\n    );\n  }\n\n  const publicExtension = derivePublicExtension({\n    parentPublicKey: node.compressedPublicKeyBytes,\n    childIndex,\n  });\n\n  const entropy = generateEntropy({\n    chainCode: node.chainCodeBytes,\n    extension: publicExtension,\n  });\n\n  return await deriveNode(\n    {\n      publicKey: node.compressedPublicKeyBytes,\n      entropy,\n      ...args,\n    },\n    handleError,\n  );\n}\n\ntype BaseDeriveNodeArgs = {\n  entropy: Uint8Array;\n  chainCode: Uint8Array;\n  childIndex: number;\n  isHardened: boolean;\n  depth: number;\n  parentFingerprint: number;\n  masterFingerprint?: number | undefined;\n  curve: Curve;\n};\n\ntype DerivePrivateKeyArgs = BaseDeriveNodeArgs & {\n  privateKey: Uint8Array;\n  publicKey?: never | undefined;\n};\n\ntype DerivePublicKeyArgs = BaseDeriveNodeArgs & {\n  publicKey: Uint8Array;\n  privateKey?: never | undefined;\n};\n\nexport type DeriveNodeArgs = DerivePrivateKeyArgs | DerivePublicKeyArgs;\n\ntype DeriveSecretExtensionArgs = {\n  privateKey: Uint8Array;\n  childIndex: number;\n  isHardened: boolean;\n  curve: Curve;\n};\n\n/**\n * Derive a SLIP-10 child key from a parent key.\n *\n * @param options - The options for deriving a child key.\n * @param options.privateKey - The private key to derive from.\n * @param options.publicKey - The public key to derive from.\n * @param options.entropy - The entropy to use for deriving the child key.\n * @param options.chainCode - The chain code to use for deriving the child key.\n * @param options.childIndex - The child index to use for deriving the child key.\n * @param options.isHardened - Whether the child key is hardened.\n * @param options.depth - The depth of the child key.\n * @param options.parentFingerprint - The fingerprint of the parent key.\n * @param options.masterFingerprint - The fingerprint of the master key.\n * @param options.curve - The curve to use for deriving the child key.\n * @param handleError - A function to handle errors during derivation.\n * @returns The derived child key as {@link SLIP10Node}.\n */\nasync function deriveNode(\n  options: DeriveNodeArgs,\n  handleError: (\n    error: unknown,\n    args: DeriveNodeArgs,\n  ) => Promise<DeriveNodeArgs>,\n): Promise<SLIP10Node> {\n  const {\n    privateKey,\n    publicKey,\n    entropy,\n    childIndex,\n    isHardened,\n    depth,\n    parentFingerprint,\n    masterFingerprint,\n    curve,\n  } = options;\n\n  try {\n    if (privateKey) {\n      return await derivePrivateChildKey({\n        entropy,\n        privateKey,\n        depth,\n        masterFingerprint,\n        parentFingerprint,\n        childIndex,\n        isHardened,\n        curve,\n      });\n    }\n\n    return await derivePublicChildKey({\n      entropy,\n      publicKey,\n      depth,\n      masterFingerprint,\n      parentFingerprint,\n      childIndex,\n      curve,\n    });\n  } catch (error) {\n    return await deriveNode(await handleError(error, options), handleError);\n  }\n}\n\n/**\n * Derive a BIP-32 secret extension from a parent key and child index.\n *\n * @param options - The options for deriving a secret extension.\n * @param options.privateKey - The parent private key bytes.\n * @param options.childIndex - The child index to derive.\n * @param options.isHardened - Whether the child index is hardened.\n * @param options.curve - The curve to use for derivation.\n * @returns The secret extension bytes.\n */\nexport async function deriveSecretExtension({\n  privateKey,\n  childIndex,\n  isHardened,\n  curve,\n}: DeriveSecretExtensionArgs) {\n  if (isHardened) {\n    // Hardened child\n    return concatBytes([\n      new Uint8Array([0]),\n      privateKey,\n      numberToUint32(childIndex + BIP_32_HARDENED_OFFSET),\n    ]);\n  }\n\n  // Normal child\n  const parentPublicKey = await curve.getPublicKey(privateKey, true);\n  return derivePublicExtension({ parentPublicKey, childIndex });\n}\n\ntype DerivePublicExtensionArgs = {\n  parentPublicKey: Uint8Array;\n  childIndex: number;\n};\n\n/**\n * Derive a BIP-32 public extension from a parent key and child index.\n *\n * @param options - The options for deriving a public extension.\n * @param options.parentPublicKey - The parent public key bytes.\n * @param options.childIndex - The child index to derive.\n * @returns The public extension bytes.\n */\nexport function derivePublicExtension({\n  parentPublicKey,\n  childIndex,\n}: DerivePublicExtensionArgs) {\n  return concatBytes([parentPublicKey, numberToUint32(childIndex)]);\n}\n\ntype GenerateKeyArgs = {\n  privateKey: Uint8Array;\n  entropy: Uint8Array;\n  curve: Curve;\n};\n\n/**\n * Derive a BIP-32 key from a parent key and secret extension.\n *\n * @param options - The options for deriving a key.\n * @param options.privateKey - The parent private key bytes.\n * @param options.entropy - The entropy bytes.\n * @param options.curve - The curve to use for derivation.\n * @returns The derived key.\n */\nasync function generateKey({\n  privateKey,\n  entropy,\n  curve,\n}: GenerateKeyArgs): Promise<DerivedKeys & { privateKey: Uint8Array }> {\n  const keyMaterial = entropy.slice(0, 32);\n  const childChainCode = entropy.slice(32);\n\n  // If curve is ed25519: The returned child key ki is parse256(IL).\n  // https://github.com/satoshilabs/slips/blob/133ea52a8e43d338b98be208907e144277e44c0e/slip-0010.md#private-parent-key--private-child-key\n  if (curve.name === 'ed25519') {\n    const publicKey = await curve.getPublicKey(keyMaterial);\n    return { privateKey: keyMaterial, publicKey, chainCode: childChainCode };\n  }\n\n  const childPrivateKey = privateAdd(privateKey, keyMaterial, curve);\n  const publicKey = await curve.getPublicKey(childPrivateKey);\n\n  return { privateKey: childPrivateKey, publicKey, chainCode: childChainCode };\n}\n\ntype DerivePrivateChildKeyArgs = {\n  entropy: Uint8Array;\n  privateKey: Uint8Array;\n  depth: number;\n  masterFingerprint?: number | undefined;\n  parentFingerprint: number;\n  childIndex: number;\n  isHardened: boolean;\n  curve: Curve;\n};\n\n/**\n * Derive a BIP-32 private child key with a given path from a parent key.\n *\n * @param args - The arguments for deriving a private child key.\n * @param args.entropy - The entropy to use for derivation.\n * @param args.privateKey - The parent private key to use for derivation.\n * @param args.depth - The depth of the parent node.\n * @param args.masterFingerprint - The fingerprint of the master node.\n * @param args.parentFingerprint - The fingerprint of the parent node.\n * @param args.childIndex - The child index to derive.\n * @param args.isHardened - Whether the child index is hardened.\n * @param args.curve - The curve to use for derivation.\n * @returns The derived {@link SLIP10Node}.\n */\nasync function derivePrivateChildKey({\n  entropy,\n  privateKey,\n  depth,\n  masterFingerprint,\n  parentFingerprint,\n  childIndex,\n  isHardened,\n  curve,\n}: DerivePrivateChildKeyArgs): Promise<SLIP10Node> {\n  const actualChildIndex =\n    childIndex + (isHardened ? BIP_32_HARDENED_OFFSET : 0);\n\n  const { privateKey: childPrivateKey, chainCode: childChainCode } =\n    await generateKey({\n      privateKey,\n      entropy,\n      curve,\n    });\n\n  return await SLIP10Node.fromExtendedKey({\n    privateKey: childPrivateKey,\n    chainCode: childChainCode,\n    depth: depth + 1,\n    masterFingerprint,\n    parentFingerprint,\n    index: actualChildIndex,\n    curve: curve.name,\n  });\n}\n\ntype GeneratePublicKeyArgs = {\n  publicKey: Uint8Array;\n  entropy: Uint8Array;\n  curve: Curve;\n};\n\n/**\n * Derive a BIP-32 public key from a parent key and public extension.\n *\n * @param options - The options for deriving a public key.\n * @param options.publicKey - The parent public key bytes.\n * @param options.entropy - The entropy bytes.\n * @param options.curve - The curve to use for derivation.\n * @returns The derived public key.\n */\nfunction generatePublicKey({\n  publicKey,\n  entropy,\n  curve,\n}: GeneratePublicKeyArgs): DerivedKeys {\n  const keyMaterial = entropy.slice(0, 32);\n  const childChainCode = entropy.slice(32);\n\n  // This function may fail if the resulting key is invalid.\n  const childPublicKey = curve.publicAdd(publicKey, keyMaterial);\n\n  return {\n    publicKey: childPublicKey,\n    chainCode: childChainCode,\n  };\n}\n\ntype DerivePublicChildKeyArgs = {\n  entropy: Uint8Array;\n  publicKey: Uint8Array;\n  depth: number;\n  masterFingerprint?: number | undefined;\n  parentFingerprint: number;\n  childIndex: number;\n  curve: Curve;\n};\n\n/**\n * Derive a BIP-32 public child key with a given path from a parent key.\n *\n * @param args - The arguments for deriving a public child key.\n * @param args.entropy - The entropy to use for derivation.\n * @param args.publicKey - The parent public key to use for derivation.\n * @param args.depth - The depth of the parent node.\n * @param args.masterFingerprint - The fingerprint of the master node.\n * @param args.parentFingerprint - The fingerprint of the parent node.\n * @param args.childIndex - The child index to derive.\n * @param args.curve - The curve to use for derivation.\n * @returns The derived {@link SLIP10Node}.\n */\nexport async function derivePublicChildKey({\n  entropy,\n  publicKey,\n  depth,\n  masterFingerprint,\n  parentFingerprint,\n  childIndex,\n  curve,\n}: DerivePublicChildKeyArgs): Promise<SLIP10Node> {\n  const { publicKey: childPublicKey, chainCode: childChainCode } =\n    generatePublicKey({\n      publicKey,\n      entropy,\n      curve,\n    });\n\n  return await SLIP10Node.fromExtendedKey({\n    publicKey: childPublicKey,\n    chainCode: childChainCode,\n    depth: depth + 1,\n    masterFingerprint,\n    parentFingerprint,\n    index: childIndex,\n    curve: curve.name,\n  });\n}\n\n/**\n * Add a tweak to the private key: `(privateKey + tweak) % n`.\n *\n * @param privateKeyBytes - The private key as 32 byte Uint8Array.\n * @param tweakBytes - The tweak as 32 byte Uint8Array.\n * @param curve - The curve to use.\n * @throws If the private key or tweak is invalid.\n * @returns The private key with the tweak added to it.\n */\nexport function privateAdd(\n  privateKeyBytes: Uint8Array,\n  tweakBytes: Uint8Array,\n  curve: Curve,\n): Uint8Array {\n  assert(\n    isValidBytesKey(tweakBytes, 32),\n    'Invalid tweak: Tweak must be a non-zero 32-byte Uint8Array.',\n  );\n\n  const privateKey = bytesToBigInt(privateKeyBytes);\n  const tweak = bytesToBigInt(tweakBytes);\n\n  if (tweak >= curve.curve.n) {\n    throw new Error('Invalid tweak: Tweak is larger than the curve order.');\n  }\n\n  const added = mod(privateKey + tweak, curve.curve.n);\n  const bytes = hexToBytes(added.toString(16).padStart(64, '0'));\n\n  if (!curve.isValidPrivateKey(bytes)) {\n    throw new Error(\n      'Invalid private key or tweak: The resulting private key is invalid.',\n    );\n  }\n\n  return bytes;\n}\n\ntype GenerateEntropyArgs = {\n  chainCode: Uint8Array;\n  extension: Uint8Array;\n};\n\n/**\n * Generate 64 bytes of (deterministic) entropy from a chain code and secret\n * extension.\n *\n * @param args - The arguments for generating entropy.\n * @param args.chainCode - The parent chain code bytes.\n * @param args.extension - The extension bytes.\n * @returns The generated entropy bytes.\n */\nexport function generateEntropy({ chainCode, extension }: GenerateEntropyArgs) {\n  return hmac(sha512, chainCode, extension);\n}\n\n/**\n * Validate that a node is specified.\n *\n * @param node - The node to validate.\n * @throws If the node is not specified.\n */\nexport function validateNode(node?: SLIP10Node): asserts node is SLIP10Node {\n  assert(node, 'Invalid parameters: Must specify a node to derive from.');\n}\n\n/**\n * Validate a path.\n *\n * @param path - The path to validate.\n * @param node - The node to validate the path against.\n * @param curve - The curve to validate the path against.\n * @throws If the path is invalid.\n */\nfunction validatePath(\n  path: string | Uint8Array,\n  node: SLIP10Node,\n  curve: Curve,\n): asserts path is string {\n  assert(typeof path === 'string', 'Invalid path: Must be a string.');\n\n  const isHardened = path.endsWith(`'`);\n  assert(\n    !isHardened || node.privateKey,\n    'Invalid parameters: Cannot derive hardened child keys without a private key.',\n  );\n  assert(\n    isHardened || curve.deriveUnhardenedKeys,\n    `Invalid path: Cannot derive unhardened child keys with ${curve.name}.`,\n  );\n}\n\n/**\n * Validate a path and return the child index and whether it is hardened.\n *\n * @param path - The path to validate.\n * @param node - The node to validate the path against.\n * @param curve - The curve to validate the path against.\n * @returns The child index and whether it is hardened.\n */\nexport function getValidatedPath(\n  path: string | Uint8Array,\n  node: SLIP10Node,\n  curve: Curve,\n) {\n  validatePath(path, node, curve);\n\n  const indexPart = path.split(`'`)[0];\n\n  assert(indexPart);\n  const childIndex = parseInt(indexPart, 10);\n\n  if (\n    !UNPREFIXED_PATH_REGEX.test(indexPart) ||\n    !Number.isInteger(childIndex) ||\n    childIndex < 0 ||\n    childIndex >= BIP_32_HARDENED_OFFSET\n  ) {\n    throw new Error(\n      `Invalid path: The index must be a non-negative decimal integer less than ${BIP_32_HARDENED_OFFSET}.`,\n    );\n  }\n\n  return { childIndex, isHardened: path.includes(`'`) };\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"shared.mjs","sourceRoot":"","sources":["../../src/derivers/shared.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  assert,\n  bytesToBigInt,\n  concatBytes,\n  hexToBytes,\n} from '@metamask/utils';\n\nimport type { DeriveChildKeyArgs, DerivedKeys } from '.';\nimport { BIP_32_HARDENED_OFFSET, UNPREFIXED_PATH_REGEX } from '../constants';\nimport type { CryptographicFunctions } from '../cryptography';\nimport { hmacSha512 } from '../cryptography';\nimport type { Curve } from '../curves';\nimport { mod } from '../curves';\nimport { SLIP10Node } from '../SLIP10Node';\nimport { isValidBytesKey, numberToUint32 } from '../utils';\n\ntype ErrorHandler = (\n  error: unknown,\n  options: DeriveNodeArgs,\n  cryptographicFunctions?: CryptographicFunctions,\n) => Promise<DeriveNodeArgs>;\n\n/**\n * Derive a BIP-32 or SLIP-10 child key with a given path from a parent key.\n *\n * Since BIP-32 and SLIP-10 are very similar, this function can be used to\n * derive both types of keys.\n *\n * @param options - The options for deriving a child key.\n * @param options.path - The derivation path part to derive.\n * @param options.node - The node to derive from.\n * @param options.curve - The curve to use for derivation.\n * @param handleError - A function that can handle errors that occur during\n * derivation.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The derived node.\n */\nexport async function deriveChildKey(\n  { path, node, curve }: DeriveChildKeyArgs,\n  handleError: ErrorHandler,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<SLIP10Node> {\n  validateNode(node);\n\n  const { childIndex, isHardened } = getValidatedPath(path, node, curve);\n\n  const args = {\n    chainCode: node.chainCodeBytes,\n    childIndex,\n    isHardened,\n    depth: node.depth,\n    parentFingerprint: node.fingerprint,\n    masterFingerprint: node.masterFingerprint,\n    curve,\n  };\n\n  if (node.privateKeyBytes) {\n    const secretExtension = await deriveSecretExtension({\n      privateKey: node.privateKeyBytes,\n      childIndex,\n      isHardened,\n      curve,\n    });\n\n    const entropy = await generateEntropy(\n      {\n        chainCode: node.chainCodeBytes,\n        extension: secretExtension,\n      },\n      cryptographicFunctions,\n    );\n\n    return await deriveNode(\n      {\n        privateKey: node.privateKeyBytes,\n        entropy,\n        ...args,\n      },\n      handleError,\n      cryptographicFunctions,\n    );\n  }\n\n  const publicExtension = derivePublicExtension({\n    parentPublicKey: node.compressedPublicKeyBytes,\n    childIndex,\n  });\n\n  const entropy = await generateEntropy(\n    {\n      chainCode: node.chainCodeBytes,\n      extension: publicExtension,\n    },\n    cryptographicFunctions,\n  );\n\n  return await deriveNode(\n    {\n      publicKey: node.compressedPublicKeyBytes,\n      entropy,\n      ...args,\n    },\n    handleError,\n    cryptographicFunctions,\n  );\n}\n\ntype BaseDeriveNodeArgs = {\n  entropy: Uint8Array;\n  chainCode: Uint8Array;\n  childIndex: number;\n  isHardened: boolean;\n  depth: number;\n  parentFingerprint: number;\n  masterFingerprint?: number | undefined;\n  curve: Curve;\n};\n\ntype DerivePrivateKeyArgs = BaseDeriveNodeArgs & {\n  privateKey: Uint8Array;\n  publicKey?: never | undefined;\n};\n\ntype DerivePublicKeyArgs = BaseDeriveNodeArgs & {\n  publicKey: Uint8Array;\n  privateKey?: never | undefined;\n};\n\nexport type DeriveNodeArgs = DerivePrivateKeyArgs | DerivePublicKeyArgs;\n\ntype DeriveSecretExtensionArgs = {\n  privateKey: Uint8Array;\n  childIndex: number;\n  isHardened: boolean;\n  curve: Curve;\n};\n\n/**\n * Derive a SLIP-10 child key from a parent key.\n *\n * @param options - The options for deriving a child key.\n * @param options.privateKey - The private key to derive from.\n * @param options.publicKey - The public key to derive from.\n * @param options.entropy - The entropy to use for deriving the child key.\n * @param options.chainCode - The chain code to use for deriving the child key.\n * @param options.childIndex - The child index to use for deriving the child key.\n * @param options.isHardened - Whether the child key is hardened.\n * @param options.depth - The depth of the child key.\n * @param options.parentFingerprint - The fingerprint of the parent key.\n * @param options.masterFingerprint - The fingerprint of the master key.\n * @param options.curve - The curve to use for deriving the child key.\n * @param handleError - A function to handle errors during derivation.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The derived child key as {@link SLIP10Node}.\n */\nasync function deriveNode(\n  options: DeriveNodeArgs,\n  handleError: ErrorHandler,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<SLIP10Node> {\n  const {\n    privateKey,\n    publicKey,\n    entropy,\n    childIndex,\n    isHardened,\n    depth,\n    parentFingerprint,\n    masterFingerprint,\n    curve,\n  } = options;\n\n  try {\n    if (privateKey) {\n      return await derivePrivateChildKey(\n        {\n          entropy,\n          privateKey,\n          depth,\n          masterFingerprint,\n          parentFingerprint,\n          childIndex,\n          isHardened,\n          curve,\n        },\n        cryptographicFunctions,\n      );\n    }\n\n    return await derivePublicChildKey(\n      {\n        entropy,\n        publicKey,\n        depth,\n        masterFingerprint,\n        parentFingerprint,\n        childIndex,\n        curve,\n      },\n      cryptographicFunctions,\n    );\n  } catch (error) {\n    return await deriveNode(\n      await handleError(error, options, cryptographicFunctions),\n      handleError,\n      cryptographicFunctions,\n    );\n  }\n}\n\n/**\n * Derive a BIP-32 secret extension from a parent key and child index.\n *\n * @param options - The options for deriving a secret extension.\n * @param options.privateKey - The parent private key bytes.\n * @param options.childIndex - The child index to derive.\n * @param options.isHardened - Whether the child index is hardened.\n * @param options.curve - The curve to use for derivation.\n * @returns The secret extension bytes.\n */\nexport async function deriveSecretExtension({\n  privateKey,\n  childIndex,\n  isHardened,\n  curve,\n}: DeriveSecretExtensionArgs): Promise<Uint8Array> {\n  if (isHardened) {\n    // Hardened child\n    return concatBytes([\n      new Uint8Array([0]),\n      privateKey,\n      numberToUint32(childIndex + BIP_32_HARDENED_OFFSET),\n    ]);\n  }\n\n  // Normal child\n  const parentPublicKey = await curve.getPublicKey(privateKey, true);\n  return derivePublicExtension({ parentPublicKey, childIndex });\n}\n\ntype DerivePublicExtensionArgs = {\n  parentPublicKey: Uint8Array;\n  childIndex: number;\n};\n\n/**\n * Derive a BIP-32 public extension from a parent key and child index.\n *\n * @param options - The options for deriving a public extension.\n * @param options.parentPublicKey - The parent public key bytes.\n * @param options.childIndex - The child index to derive.\n * @returns The public extension bytes.\n */\nexport function derivePublicExtension({\n  parentPublicKey,\n  childIndex,\n}: DerivePublicExtensionArgs): Uint8Array {\n  return concatBytes([parentPublicKey, numberToUint32(childIndex)]);\n}\n\ntype GenerateKeyArgs = {\n  privateKey: Uint8Array;\n  entropy: Uint8Array;\n  curve: Curve;\n};\n\n/**\n * Derive a BIP-32 key from a parent key and secret extension.\n *\n * @param options - The options for deriving a key.\n * @param options.privateKey - The parent private key bytes.\n * @param options.entropy - The entropy bytes.\n * @param options.curve - The curve to use for derivation.\n * @returns The derived key.\n */\nasync function generateKey({\n  privateKey,\n  entropy,\n  curve,\n}: GenerateKeyArgs): Promise<DerivedKeys & { privateKey: Uint8Array }> {\n  const keyMaterial = entropy.slice(0, 32);\n  const childChainCode = entropy.slice(32);\n\n  // If curve is ed25519: The returned child key ki is parse256(IL).\n  // https://github.com/satoshilabs/slips/blob/133ea52a8e43d338b98be208907e144277e44c0e/slip-0010.md#private-parent-key--private-child-key\n  if (curve.name === 'ed25519') {\n    const publicKey = await curve.getPublicKey(keyMaterial);\n    return { privateKey: keyMaterial, publicKey, chainCode: childChainCode };\n  }\n\n  const childPrivateKey = privateAdd(privateKey, keyMaterial, curve);\n  const publicKey = await curve.getPublicKey(childPrivateKey);\n\n  return { privateKey: childPrivateKey, publicKey, chainCode: childChainCode };\n}\n\ntype DerivePrivateChildKeyArgs = {\n  entropy: Uint8Array;\n  privateKey: Uint8Array;\n  depth: number;\n  masterFingerprint?: number | undefined;\n  parentFingerprint: number;\n  childIndex: number;\n  isHardened: boolean;\n  curve: Curve;\n};\n\n/**\n * Derive a BIP-32 private child key with a given path from a parent key.\n *\n * @param args - The arguments for deriving a private child key.\n * @param args.entropy - The entropy to use for derivation.\n * @param args.privateKey - The parent private key to use for derivation.\n * @param args.depth - The depth of the parent node.\n * @param args.masterFingerprint - The fingerprint of the master node.\n * @param args.parentFingerprint - The fingerprint of the parent node.\n * @param args.childIndex - The child index to derive.\n * @param args.isHardened - Whether the child index is hardened.\n * @param args.curve - The curve to use for derivation.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The derived {@link SLIP10Node}.\n */\nasync function derivePrivateChildKey(\n  {\n    entropy,\n    privateKey,\n    depth,\n    masterFingerprint,\n    parentFingerprint,\n    childIndex,\n    isHardened,\n    curve,\n  }: DerivePrivateChildKeyArgs,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<SLIP10Node> {\n  const actualChildIndex =\n    childIndex + (isHardened ? BIP_32_HARDENED_OFFSET : 0);\n\n  const { privateKey: childPrivateKey, chainCode: childChainCode } =\n    await generateKey({\n      privateKey,\n      entropy,\n      curve,\n    });\n\n  return await SLIP10Node.fromExtendedKey(\n    {\n      privateKey: childPrivateKey,\n      chainCode: childChainCode,\n      depth: depth + 1,\n      masterFingerprint,\n      parentFingerprint,\n      index: actualChildIndex,\n      curve: curve.name,\n    },\n    cryptographicFunctions,\n  );\n}\n\ntype GeneratePublicKeyArgs = {\n  publicKey: Uint8Array;\n  entropy: Uint8Array;\n  curve: Curve;\n};\n\n/**\n * Derive a BIP-32 public key from a parent key and public extension.\n *\n * @param options - The options for deriving a public key.\n * @param options.publicKey - The parent public key bytes.\n * @param options.entropy - The entropy bytes.\n * @param options.curve - The curve to use for derivation.\n * @returns The derived public key.\n */\nfunction generatePublicKey({\n  publicKey,\n  entropy,\n  curve,\n}: GeneratePublicKeyArgs): DerivedKeys {\n  const keyMaterial = entropy.slice(0, 32);\n  const childChainCode = entropy.slice(32);\n\n  // This function may fail if the resulting key is invalid.\n  const childPublicKey = curve.publicAdd(publicKey, keyMaterial);\n\n  return {\n    publicKey: childPublicKey,\n    chainCode: childChainCode,\n  };\n}\n\ntype DerivePublicChildKeyArgs = {\n  entropy: Uint8Array;\n  publicKey: Uint8Array;\n  depth: number;\n  masterFingerprint?: number | undefined;\n  parentFingerprint: number;\n  childIndex: number;\n  curve: Curve;\n};\n\n/**\n * Derive a BIP-32 public child key with a given path from a parent key.\n *\n * @param args - The arguments for deriving a public child key.\n * @param args.entropy - The entropy to use for derivation.\n * @param args.publicKey - The parent public key to use for derivation.\n * @param args.depth - The depth of the parent node.\n * @param args.masterFingerprint - The fingerprint of the master node.\n * @param args.parentFingerprint - The fingerprint of the parent node.\n * @param args.childIndex - The child index to derive.\n * @param args.curve - The curve to use for derivation.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The derived {@link SLIP10Node}.\n */\nexport async function derivePublicChildKey(\n  {\n    entropy,\n    publicKey,\n    depth,\n    masterFingerprint,\n    parentFingerprint,\n    childIndex,\n    curve,\n  }: DerivePublicChildKeyArgs,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<SLIP10Node> {\n  const { publicKey: childPublicKey, chainCode: childChainCode } =\n    generatePublicKey({\n      publicKey,\n      entropy,\n      curve,\n    });\n\n  return await SLIP10Node.fromExtendedKey(\n    {\n      publicKey: childPublicKey,\n      chainCode: childChainCode,\n      depth: depth + 1,\n      masterFingerprint,\n      parentFingerprint,\n      index: childIndex,\n      curve: curve.name,\n    },\n    cryptographicFunctions,\n  );\n}\n\n/**\n * Add a tweak to the private key: `(privateKey + tweak) % n`.\n *\n * @param privateKeyBytes - The private key as 32 byte Uint8Array.\n * @param tweakBytes - The tweak as 32 byte Uint8Array.\n * @param curve - The curve to use.\n * @throws If the private key or tweak is invalid.\n * @returns The private key with the tweak added to it.\n */\nexport function privateAdd(\n  privateKeyBytes: Uint8Array,\n  tweakBytes: Uint8Array,\n  curve: Curve,\n): Uint8Array {\n  assert(\n    isValidBytesKey(tweakBytes, 32),\n    'Invalid tweak: Tweak must be a non-zero 32-byte Uint8Array.',\n  );\n\n  const privateKey = bytesToBigInt(privateKeyBytes);\n  const tweak = bytesToBigInt(tweakBytes);\n\n  if (tweak >= curve.curve.n) {\n    throw new Error('Invalid tweak: Tweak is larger than the curve order.');\n  }\n\n  const added = mod(privateKey + tweak, curve.curve.n);\n  const bytes = hexToBytes(added.toString(16).padStart(64, '0'));\n\n  if (!curve.isValidPrivateKey(bytes)) {\n    throw new Error(\n      'Invalid private key or tweak: The resulting private key is invalid.',\n    );\n  }\n\n  return bytes;\n}\n\ntype GenerateEntropyArgs = {\n  chainCode: Uint8Array;\n  extension: Uint8Array;\n};\n\n/**\n * Generate 64 bytes of (deterministic) entropy from a chain code and secret\n * extension.\n *\n * @param args - The arguments for generating entropy.\n * @param args.chainCode - The parent chain code bytes.\n * @param args.extension - The extension bytes.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The generated entropy bytes.\n */\nexport async function generateEntropy(\n  { chainCode, extension }: GenerateEntropyArgs,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<Uint8Array> {\n  return await hmacSha512(chainCode, extension, cryptographicFunctions);\n}\n\n/**\n * Validate that a node is specified.\n *\n * @param node - The node to validate.\n * @throws If the node is not specified.\n */\nexport function validateNode(node?: SLIP10Node): asserts node is SLIP10Node {\n  assert(node, 'Invalid parameters: Must specify a node to derive from.');\n}\n\n/**\n * Validate a path.\n *\n * @param path - The path to validate.\n * @param node - The node to validate the path against.\n * @param curve - The curve to validate the path against.\n * @throws If the path is invalid.\n */\nfunction validatePath(\n  path: string | Uint8Array,\n  node: SLIP10Node,\n  curve: Curve,\n): asserts path is string {\n  assert(typeof path === 'string', 'Invalid path: Must be a string.');\n\n  const isHardened = path.endsWith(`'`);\n  assert(\n    !isHardened || node.privateKey,\n    'Invalid parameters: Cannot derive hardened child keys without a private key.',\n  );\n  assert(\n    isHardened || curve.deriveUnhardenedKeys,\n    `Invalid path: Cannot derive unhardened child keys with ${curve.name}.`,\n  );\n}\n\n/**\n * Validate a path and return the child index and whether it is hardened.\n *\n * @param path - The path to validate.\n * @param node - The node to validate the path against.\n * @param curve - The curve to validate the path against.\n * @returns The child index and whether it is hardened.\n */\nexport function getValidatedPath(\n  path: string | Uint8Array,\n  node: SLIP10Node,\n  curve: Curve,\n): { childIndex: number; isHardened: boolean } {\n  validatePath(path, node, curve);\n\n  const indexPart = path.split(`'`)[0];\n\n  assert(indexPart);\n  const childIndex = parseInt(indexPart, 10);\n\n  if (\n    !UNPREFIXED_PATH_REGEX.test(indexPart) ||\n    !Number.isInteger(childIndex) ||\n    childIndex < 0 ||\n    childIndex >= BIP_32_HARDENED_OFFSET\n  ) {\n    throw new Error(\n      `Invalid path: The index must be a non-negative decimal integer less than ${BIP_32_HARDENED_OFFSET}.`,\n    );\n  }\n\n  return { childIndex, isHardened: path.includes(`'`) };\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/derivers/slip10.cjs b/node_modules/@metamask/key-tree/dist/derivers/slip10.cjs
index 3062d94..dde17c5 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/slip10.cjs
+++ b/node_modules/@metamask/key-tree/dist/derivers/slip10.cjs
@@ -2,18 +2,20 @@
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.deriveChildKey = void 0;
 const utils_1 = require("@metamask/utils");
+const shared_1 = require("./shared.cjs");
 const constants_1 = require("../constants.cjs");
 const utils_2 = require("../utils.cjs");
-const shared_1 = require("./shared.cjs");
 /**
  * Derive a SLIP-10 child key with a given path from a parent key.
  *
  * @param options - The options for deriving a child key.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns A tuple containing the derived private key, public key and chain
  * code.
  */
-async function deriveChildKey(options) {
-    return await (0, shared_1.deriveChildKey)(options, handleError);
+async function deriveChildKey(options, cryptographicFunctions) {
+    return await (0, shared_1.deriveChildKey)(options, handleError, cryptographicFunctions);
 }
 exports.deriveChildKey = deriveChildKey;
 /**
@@ -21,9 +23,11 @@ exports.deriveChildKey = deriveChildKey;
  *
  * @param error - The error that occurred.
  * @param options - The options that were used for derivation.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The new options to use for derivation.
  */
-async function handleError(error, options) {
+async function handleError(error, options, cryptographicFunctions) {
     const { curve, isHardened, childIndex, entropy, chainCode } = options;
     // `ed25519` keys are always valid, so this error should never be thrown. If
     // it is, we re-throw it.
@@ -37,14 +41,14 @@ async function handleError(error, options) {
     // generated as follows:
     // Key material (32 bytes), child chain code (32 bytes) =
     //   HMAC-SHA512(parent chain code, 0x01 || chain code from invalid key || index).
-    const newEntropy = (0, shared_1.generateEntropy)({
+    const newEntropy = await (0, shared_1.generateEntropy)({
         chainCode,
         extension: (0, utils_1.concatBytes)([
             0x01,
             entropy.slice(32, 64),
             (0, utils_2.numberToUint32)(actualChildIndex),
         ]),
-    });
+    }, cryptographicFunctions);
     return {
         ...options,
         entropy: newEntropy,
diff --git a/node_modules/@metamask/key-tree/dist/derivers/slip10.cjs.map b/node_modules/@metamask/key-tree/dist/derivers/slip10.cjs.map
index 082904f..9ca1298 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/slip10.cjs.map
+++ b/node_modules/@metamask/key-tree/dist/derivers/slip10.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"slip10.cjs","sourceRoot":"","sources":["../../src/derivers/slip10.ts"],"names":[],"mappings":";;;AAAA,2CAA8C;AAG9C,gDAAsD;AAEtD,wCAA0C;AAC1C,yCAGkB;AAGlB;;;;;;GAMG;AACI,KAAK,UAAU,cAAc,CAClC,OAA2B;IAE3B,OAAO,MAAM,IAAA,uBAAoB,EAAC,OAAO,EAAE,WAAW,CAAC,CAAC;AAC1D,CAAC;AAJD,wCAIC;AAED;;;;;;GAMG;AACH,KAAK,UAAU,WAAW,CACxB,KAAc,EACd,OAAuB;IAEvB,MAAM,EAAE,KAAK,EAAE,UAAU,EAAE,UAAU,EAAE,OAAO,EAAE,SAAS,EAAE,GAAG,OAAO,CAAC;IAEtE,4EAA4E;IAC5E,yBAAyB;IACzB,IAAI,KAAK,CAAC,IAAI,KAAK,SAAS,EAAE;QAC5B,MAAM,KAAK,CAAC;KACb;IAED,MAAM,gBAAgB,GAAG,UAAU;QACjC,CAAC,CAAC,UAAU,GAAG,kCAAsB;QACrC,CAAC,CAAC,UAAU,CAAC;IAEf,sEAAsE;IACtE,wBAAwB;IACxB,yDAAyD;IACzD,kFAAkF;IAClF,MAAM,UAAU,GAAG,IAAA,wBAAe,EAAC;QACjC,SAAS;QACT,SAAS,EAAE,IAAA,mBAAW,EAAC;YACrB,IAAI;YACJ,OAAO,CAAC,KAAK,CAAC,EAAE,EAAE,EAAE,CAAC;YACrB,IAAA,sBAAc,EAAC,gBAAgB,CAAC;SACjC,CAAC;KACH,CAAC,CAAC;IAEH,OAAO;QACL,GAAG,OAAO;QACV,OAAO,EAAE,UAAU;KACpB,CAAC;AACJ,CAAC","sourcesContent":["import { concatBytes } from '@metamask/utils';\n\nimport type { DeriveChildKeyArgs } from '.';\nimport { BIP_32_HARDENED_OFFSET } from '../constants';\nimport type { SLIP10Node } from '../SLIP10Node';\nimport { numberToUint32 } from '../utils';\nimport {\n  generateEntropy,\n  deriveChildKey as sharedDeriveChildKey,\n} from './shared';\nimport type { DeriveNodeArgs } from './shared';\n\n/**\n * Derive a SLIP-10 child key with a given path from a parent key.\n *\n * @param options - The options for deriving a child key.\n * @returns A tuple containing the derived private key, public key and chain\n * code.\n */\nexport async function deriveChildKey(\n  options: DeriveChildKeyArgs,\n): Promise<SLIP10Node> {\n  return await sharedDeriveChildKey(options, handleError);\n}\n\n/**\n * Handle an error that occurs during SLIP-10 derivation.\n *\n * @param error - The error that occurred.\n * @param options - The options that were used for derivation.\n * @returns The new options to use for derivation.\n */\nasync function handleError(\n  error: unknown,\n  options: DeriveNodeArgs,\n): Promise<DeriveNodeArgs> {\n  const { curve, isHardened, childIndex, entropy, chainCode } = options;\n\n  // `ed25519` keys are always valid, so this error should never be thrown. If\n  // it is, we re-throw it.\n  if (curve.name === 'ed25519') {\n    throw error;\n  }\n\n  const actualChildIndex = isHardened\n    ? childIndex + BIP_32_HARDENED_OFFSET\n    : childIndex;\n\n  // As per SLIP-10, if the resulting key is invalid, the new entropy is\n  // generated as follows:\n  // Key material (32 bytes), child chain code (32 bytes) =\n  //   HMAC-SHA512(parent chain code, 0x01 || chain code from invalid key || index).\n  const newEntropy = generateEntropy({\n    chainCode,\n    extension: concatBytes([\n      0x01,\n      entropy.slice(32, 64),\n      numberToUint32(actualChildIndex),\n    ]),\n  });\n\n  return {\n    ...options,\n    entropy: newEntropy,\n  };\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"slip10.cjs","sourceRoot":"","sources":["../../src/derivers/slip10.ts"],"names":[],"mappings":";;;AAAA,2CAA8C;AAG9C,yCAGkB;AAElB,gDAAsD;AAGtD,wCAA0C;AAE1C;;;;;;;;GAQG;AACI,KAAK,UAAU,cAAc,CAClC,OAA2B,EAC3B,sBAA+C;IAE/C,OAAO,MAAM,IAAA,uBAAoB,EAC/B,OAAO,EACP,WAAW,EACX,sBAAsB,CACvB,CAAC;AACJ,CAAC;AATD,wCASC;AAED;;;;;;;;GAQG;AACH,KAAK,UAAU,WAAW,CACxB,KAAc,EACd,OAAuB,EACvB,sBAA+C;IAE/C,MAAM,EAAE,KAAK,EAAE,UAAU,EAAE,UAAU,EAAE,OAAO,EAAE,SAAS,EAAE,GAAG,OAAO,CAAC;IAEtE,4EAA4E;IAC5E,yBAAyB;IACzB,IAAI,KAAK,CAAC,IAAI,KAAK,SAAS,EAAE,CAAC;QAC7B,MAAM,KAAK,CAAC;IACd,CAAC;IAED,MAAM,gBAAgB,GAAG,UAAU;QACjC,CAAC,CAAC,UAAU,GAAG,kCAAsB;QACrC,CAAC,CAAC,UAAU,CAAC;IAEf,sEAAsE;IACtE,wBAAwB;IACxB,yDAAyD;IACzD,kFAAkF;IAClF,MAAM,UAAU,GAAG,MAAM,IAAA,wBAAe,EACtC;QACE,SAAS;QACT,SAAS,EAAE,IAAA,mBAAW,EAAC;YACrB,IAAI;YACJ,OAAO,CAAC,KAAK,CAAC,EAAE,EAAE,EAAE,CAAC;YACrB,IAAA,sBAAc,EAAC,gBAAgB,CAAC;SACjC,CAAC;KACH,EACD,sBAAsB,CACvB,CAAC;IAEF,OAAO;QACL,GAAG,OAAO;QACV,OAAO,EAAE,UAAU;KACpB,CAAC;AACJ,CAAC","sourcesContent":["import { concatBytes } from '@metamask/utils';\n\nimport type { DeriveChildKeyArgs } from '.';\nimport {\n  generateEntropy,\n  deriveChildKey as sharedDeriveChildKey,\n} from './shared';\nimport type { DeriveNodeArgs } from './shared';\nimport { BIP_32_HARDENED_OFFSET } from '../constants';\nimport type { CryptographicFunctions } from '../cryptography';\nimport type { SLIP10Node } from '../SLIP10Node';\nimport { numberToUint32 } from '../utils';\n\n/**\n * Derive a SLIP-10 child key with a given path from a parent key.\n *\n * @param options - The options for deriving a child key.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns A tuple containing the derived private key, public key and chain\n * code.\n */\nexport async function deriveChildKey(\n  options: DeriveChildKeyArgs,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<SLIP10Node> {\n  return await sharedDeriveChildKey(\n    options,\n    handleError,\n    cryptographicFunctions,\n  );\n}\n\n/**\n * Handle an error that occurs during SLIP-10 derivation.\n *\n * @param error - The error that occurred.\n * @param options - The options that were used for derivation.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The new options to use for derivation.\n */\nasync function handleError(\n  error: unknown,\n  options: DeriveNodeArgs,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<DeriveNodeArgs> {\n  const { curve, isHardened, childIndex, entropy, chainCode } = options;\n\n  // `ed25519` keys are always valid, so this error should never be thrown. If\n  // it is, we re-throw it.\n  if (curve.name === 'ed25519') {\n    throw error;\n  }\n\n  const actualChildIndex = isHardened\n    ? childIndex + BIP_32_HARDENED_OFFSET\n    : childIndex;\n\n  // As per SLIP-10, if the resulting key is invalid, the new entropy is\n  // generated as follows:\n  // Key material (32 bytes), child chain code (32 bytes) =\n  //   HMAC-SHA512(parent chain code, 0x01 || chain code from invalid key || index).\n  const newEntropy = await generateEntropy(\n    {\n      chainCode,\n      extension: concatBytes([\n        0x01,\n        entropy.slice(32, 64),\n        numberToUint32(actualChildIndex),\n      ]),\n    },\n    cryptographicFunctions,\n  );\n\n  return {\n    ...options,\n    entropy: newEntropy,\n  };\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/derivers/slip10.d.cts b/node_modules/@metamask/key-tree/dist/derivers/slip10.d.cts
index e2a6c30..ebb5f1c 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/slip10.d.cts
+++ b/node_modules/@metamask/key-tree/dist/derivers/slip10.d.cts
@@ -1,11 +1,14 @@
 import type { DeriveChildKeyArgs } from "./index.cjs";
+import type { CryptographicFunctions } from "../cryptography.cjs";
 import type { SLIP10Node } from "../SLIP10Node.cjs";
 /**
  * Derive a SLIP-10 child key with a given path from a parent key.
  *
  * @param options - The options for deriving a child key.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns A tuple containing the derived private key, public key and chain
  * code.
  */
-export declare function deriveChildKey(options: DeriveChildKeyArgs): Promise<SLIP10Node>;
+export declare function deriveChildKey(options: DeriveChildKeyArgs, cryptographicFunctions?: CryptographicFunctions): Promise<SLIP10Node>;
 //# sourceMappingURL=slip10.d.cts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/derivers/slip10.d.cts.map b/node_modules/@metamask/key-tree/dist/derivers/slip10.d.cts.map
index 9752988..5dcf4f7 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/slip10.d.cts.map
+++ b/node_modules/@metamask/key-tree/dist/derivers/slip10.d.cts.map
@@ -1 +1 @@
-{"version":3,"file":"slip10.d.cts","sourceRoot":"","sources":["../../src/derivers/slip10.ts"],"names":[],"mappings":"AAEA,OAAO,KAAK,EAAE,kBAAkB,EAAE,oBAAU;AAE5C,OAAO,KAAK,EAAE,UAAU,EAAE,0BAAsB;AAQhD;;;;;;GAMG;AACH,wBAAsB,cAAc,CAClC,OAAO,EAAE,kBAAkB,GAC1B,OAAO,CAAC,UAAU,CAAC,CAErB"}
\ No newline at end of file
+{"version":3,"file":"slip10.d.cts","sourceRoot":"","sources":["../../src/derivers/slip10.ts"],"names":[],"mappings":"AAEA,OAAO,KAAK,EAAE,kBAAkB,EAAE,oBAAU;AAO5C,OAAO,KAAK,EAAE,sBAAsB,EAAE,4BAAwB;AAC9D,OAAO,KAAK,EAAE,UAAU,EAAE,0BAAsB;AAGhD;;;;;;;;GAQG;AACH,wBAAsB,cAAc,CAClC,OAAO,EAAE,kBAAkB,EAC3B,sBAAsB,CAAC,EAAE,sBAAsB,GAC9C,OAAO,CAAC,UAAU,CAAC,CAMrB"}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/derivers/slip10.d.mts b/node_modules/@metamask/key-tree/dist/derivers/slip10.d.mts
index e78c274..455244e 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/slip10.d.mts
+++ b/node_modules/@metamask/key-tree/dist/derivers/slip10.d.mts
@@ -1,11 +1,14 @@
 import type { DeriveChildKeyArgs } from "./index.mjs";
+import type { CryptographicFunctions } from "../cryptography.mjs";
 import type { SLIP10Node } from "../SLIP10Node.mjs";
 /**
  * Derive a SLIP-10 child key with a given path from a parent key.
  *
  * @param options - The options for deriving a child key.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns A tuple containing the derived private key, public key and chain
  * code.
  */
-export declare function deriveChildKey(options: DeriveChildKeyArgs): Promise<SLIP10Node>;
+export declare function deriveChildKey(options: DeriveChildKeyArgs, cryptographicFunctions?: CryptographicFunctions): Promise<SLIP10Node>;
 //# sourceMappingURL=slip10.d.mts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/derivers/slip10.d.mts.map b/node_modules/@metamask/key-tree/dist/derivers/slip10.d.mts.map
index ceba479..40486e3 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/slip10.d.mts.map
+++ b/node_modules/@metamask/key-tree/dist/derivers/slip10.d.mts.map
@@ -1 +1 @@
-{"version":3,"file":"slip10.d.mts","sourceRoot":"","sources":["../../src/derivers/slip10.ts"],"names":[],"mappings":"AAEA,OAAO,KAAK,EAAE,kBAAkB,EAAE,oBAAU;AAE5C,OAAO,KAAK,EAAE,UAAU,EAAE,0BAAsB;AAQhD;;;;;;GAMG;AACH,wBAAsB,cAAc,CAClC,OAAO,EAAE,kBAAkB,GAC1B,OAAO,CAAC,UAAU,CAAC,CAErB"}
\ No newline at end of file
+{"version":3,"file":"slip10.d.mts","sourceRoot":"","sources":["../../src/derivers/slip10.ts"],"names":[],"mappings":"AAEA,OAAO,KAAK,EAAE,kBAAkB,EAAE,oBAAU;AAO5C,OAAO,KAAK,EAAE,sBAAsB,EAAE,4BAAwB;AAC9D,OAAO,KAAK,EAAE,UAAU,EAAE,0BAAsB;AAGhD;;;;;;;;GAQG;AACH,wBAAsB,cAAc,CAClC,OAAO,EAAE,kBAAkB,EAC3B,sBAAsB,CAAC,EAAE,sBAAsB,GAC9C,OAAO,CAAC,UAAU,CAAC,CAMrB"}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/derivers/slip10.mjs b/node_modules/@metamask/key-tree/dist/derivers/slip10.mjs
index 118144b..4202439 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/slip10.mjs
+++ b/node_modules/@metamask/key-tree/dist/derivers/slip10.mjs
@@ -1,25 +1,29 @@
 import { concatBytes } from "@metamask/utils";
+import { generateEntropy, deriveChildKey as sharedDeriveChildKey } from "./shared.mjs";
 import { BIP_32_HARDENED_OFFSET } from "../constants.mjs";
 import { numberToUint32 } from "../utils.mjs";
-import { generateEntropy, deriveChildKey as sharedDeriveChildKey } from "./shared.mjs";
 /**
  * Derive a SLIP-10 child key with a given path from a parent key.
  *
  * @param options - The options for deriving a child key.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns A tuple containing the derived private key, public key and chain
  * code.
  */
-export async function deriveChildKey(options) {
-    return await sharedDeriveChildKey(options, handleError);
+export async function deriveChildKey(options, cryptographicFunctions) {
+    return await sharedDeriveChildKey(options, handleError, cryptographicFunctions);
 }
 /**
  * Handle an error that occurs during SLIP-10 derivation.
  *
  * @param error - The error that occurred.
  * @param options - The options that were used for derivation.
+ * @param cryptographicFunctions - The cryptographic functions to use. If
+ * provided, these will be used instead of the built-in implementations.
  * @returns The new options to use for derivation.
  */
-async function handleError(error, options) {
+async function handleError(error, options, cryptographicFunctions) {
     const { curve, isHardened, childIndex, entropy, chainCode } = options;
     // `ed25519` keys are always valid, so this error should never be thrown. If
     // it is, we re-throw it.
@@ -33,14 +37,14 @@ async function handleError(error, options) {
     // generated as follows:
     // Key material (32 bytes), child chain code (32 bytes) =
     //   HMAC-SHA512(parent chain code, 0x01 || chain code from invalid key || index).
-    const newEntropy = generateEntropy({
+    const newEntropy = await generateEntropy({
         chainCode,
         extension: concatBytes([
             0x01,
             entropy.slice(32, 64),
             numberToUint32(actualChildIndex),
         ]),
-    });
+    }, cryptographicFunctions);
     return {
         ...options,
         entropy: newEntropy,
diff --git a/node_modules/@metamask/key-tree/dist/derivers/slip10.mjs.map b/node_modules/@metamask/key-tree/dist/derivers/slip10.mjs.map
index d84c878..e5d10a9 100644
--- a/node_modules/@metamask/key-tree/dist/derivers/slip10.mjs.map
+++ b/node_modules/@metamask/key-tree/dist/derivers/slip10.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"slip10.mjs","sourceRoot":"","sources":["../../src/derivers/slip10.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,WAAW,EAAE,wBAAwB;AAG9C,OAAO,EAAE,sBAAsB,EAAE,yBAAqB;AAEtD,OAAO,EAAE,cAAc,EAAE,qBAAiB;AAC1C,OAAO,EACL,eAAe,EACf,cAAc,IAAI,oBAAoB,EACvC,qBAAiB;AAGlB;;;;;;GAMG;AACH,MAAM,CAAC,KAAK,UAAU,cAAc,CAClC,OAA2B;IAE3B,OAAO,MAAM,oBAAoB,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;AAC1D,CAAC;AAED;;;;;;GAMG;AACH,KAAK,UAAU,WAAW,CACxB,KAAc,EACd,OAAuB;IAEvB,MAAM,EAAE,KAAK,EAAE,UAAU,EAAE,UAAU,EAAE,OAAO,EAAE,SAAS,EAAE,GAAG,OAAO,CAAC;IAEtE,4EAA4E;IAC5E,yBAAyB;IACzB,IAAI,KAAK,CAAC,IAAI,KAAK,SAAS,EAAE;QAC5B,MAAM,KAAK,CAAC;KACb;IAED,MAAM,gBAAgB,GAAG,UAAU;QACjC,CAAC,CAAC,UAAU,GAAG,sBAAsB;QACrC,CAAC,CAAC,UAAU,CAAC;IAEf,sEAAsE;IACtE,wBAAwB;IACxB,yDAAyD;IACzD,kFAAkF;IAClF,MAAM,UAAU,GAAG,eAAe,CAAC;QACjC,SAAS;QACT,SAAS,EAAE,WAAW,CAAC;YACrB,IAAI;YACJ,OAAO,CAAC,KAAK,CAAC,EAAE,EAAE,EAAE,CAAC;YACrB,cAAc,CAAC,gBAAgB,CAAC;SACjC,CAAC;KACH,CAAC,CAAC;IAEH,OAAO;QACL,GAAG,OAAO;QACV,OAAO,EAAE,UAAU;KACpB,CAAC;AACJ,CAAC","sourcesContent":["import { concatBytes } from '@metamask/utils';\n\nimport type { DeriveChildKeyArgs } from '.';\nimport { BIP_32_HARDENED_OFFSET } from '../constants';\nimport type { SLIP10Node } from '../SLIP10Node';\nimport { numberToUint32 } from '../utils';\nimport {\n  generateEntropy,\n  deriveChildKey as sharedDeriveChildKey,\n} from './shared';\nimport type { DeriveNodeArgs } from './shared';\n\n/**\n * Derive a SLIP-10 child key with a given path from a parent key.\n *\n * @param options - The options for deriving a child key.\n * @returns A tuple containing the derived private key, public key and chain\n * code.\n */\nexport async function deriveChildKey(\n  options: DeriveChildKeyArgs,\n): Promise<SLIP10Node> {\n  return await sharedDeriveChildKey(options, handleError);\n}\n\n/**\n * Handle an error that occurs during SLIP-10 derivation.\n *\n * @param error - The error that occurred.\n * @param options - The options that were used for derivation.\n * @returns The new options to use for derivation.\n */\nasync function handleError(\n  error: unknown,\n  options: DeriveNodeArgs,\n): Promise<DeriveNodeArgs> {\n  const { curve, isHardened, childIndex, entropy, chainCode } = options;\n\n  // `ed25519` keys are always valid, so this error should never be thrown. If\n  // it is, we re-throw it.\n  if (curve.name === 'ed25519') {\n    throw error;\n  }\n\n  const actualChildIndex = isHardened\n    ? childIndex + BIP_32_HARDENED_OFFSET\n    : childIndex;\n\n  // As per SLIP-10, if the resulting key is invalid, the new entropy is\n  // generated as follows:\n  // Key material (32 bytes), child chain code (32 bytes) =\n  //   HMAC-SHA512(parent chain code, 0x01 || chain code from invalid key || index).\n  const newEntropy = generateEntropy({\n    chainCode,\n    extension: concatBytes([\n      0x01,\n      entropy.slice(32, 64),\n      numberToUint32(actualChildIndex),\n    ]),\n  });\n\n  return {\n    ...options,\n    entropy: newEntropy,\n  };\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"slip10.mjs","sourceRoot":"","sources":["../../src/derivers/slip10.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,WAAW,EAAE,wBAAwB;AAG9C,OAAO,EACL,eAAe,EACf,cAAc,IAAI,oBAAoB,EACvC,qBAAiB;AAElB,OAAO,EAAE,sBAAsB,EAAE,yBAAqB;AAGtD,OAAO,EAAE,cAAc,EAAE,qBAAiB;AAE1C;;;;;;;;GAQG;AACH,MAAM,CAAC,KAAK,UAAU,cAAc,CAClC,OAA2B,EAC3B,sBAA+C;IAE/C,OAAO,MAAM,oBAAoB,CAC/B,OAAO,EACP,WAAW,EACX,sBAAsB,CACvB,CAAC;AACJ,CAAC;AAED;;;;;;;;GAQG;AACH,KAAK,UAAU,WAAW,CACxB,KAAc,EACd,OAAuB,EACvB,sBAA+C;IAE/C,MAAM,EAAE,KAAK,EAAE,UAAU,EAAE,UAAU,EAAE,OAAO,EAAE,SAAS,EAAE,GAAG,OAAO,CAAC;IAEtE,4EAA4E;IAC5E,yBAAyB;IACzB,IAAI,KAAK,CAAC,IAAI,KAAK,SAAS,EAAE,CAAC;QAC7B,MAAM,KAAK,CAAC;IACd,CAAC;IAED,MAAM,gBAAgB,GAAG,UAAU;QACjC,CAAC,CAAC,UAAU,GAAG,sBAAsB;QACrC,CAAC,CAAC,UAAU,CAAC;IAEf,sEAAsE;IACtE,wBAAwB;IACxB,yDAAyD;IACzD,kFAAkF;IAClF,MAAM,UAAU,GAAG,MAAM,eAAe,CACtC;QACE,SAAS;QACT,SAAS,EAAE,WAAW,CAAC;YACrB,IAAI;YACJ,OAAO,CAAC,KAAK,CAAC,EAAE,EAAE,EAAE,CAAC;YACrB,cAAc,CAAC,gBAAgB,CAAC;SACjC,CAAC;KACH,EACD,sBAAsB,CACvB,CAAC;IAEF,OAAO;QACL,GAAG,OAAO;QACV,OAAO,EAAE,UAAU;KACpB,CAAC;AACJ,CAAC","sourcesContent":["import { concatBytes } from '@metamask/utils';\n\nimport type { DeriveChildKeyArgs } from '.';\nimport {\n  generateEntropy,\n  deriveChildKey as sharedDeriveChildKey,\n} from './shared';\nimport type { DeriveNodeArgs } from './shared';\nimport { BIP_32_HARDENED_OFFSET } from '../constants';\nimport type { CryptographicFunctions } from '../cryptography';\nimport type { SLIP10Node } from '../SLIP10Node';\nimport { numberToUint32 } from '../utils';\n\n/**\n * Derive a SLIP-10 child key with a given path from a parent key.\n *\n * @param options - The options for deriving a child key.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns A tuple containing the derived private key, public key and chain\n * code.\n */\nexport async function deriveChildKey(\n  options: DeriveChildKeyArgs,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<SLIP10Node> {\n  return await sharedDeriveChildKey(\n    options,\n    handleError,\n    cryptographicFunctions,\n  );\n}\n\n/**\n * Handle an error that occurs during SLIP-10 derivation.\n *\n * @param error - The error that occurred.\n * @param options - The options that were used for derivation.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The new options to use for derivation.\n */\nasync function handleError(\n  error: unknown,\n  options: DeriveNodeArgs,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<DeriveNodeArgs> {\n  const { curve, isHardened, childIndex, entropy, chainCode } = options;\n\n  // `ed25519` keys are always valid, so this error should never be thrown. If\n  // it is, we re-throw it.\n  if (curve.name === 'ed25519') {\n    throw error;\n  }\n\n  const actualChildIndex = isHardened\n    ? childIndex + BIP_32_HARDENED_OFFSET\n    : childIndex;\n\n  // As per SLIP-10, if the resulting key is invalid, the new entropy is\n  // generated as follows:\n  // Key material (32 bytes), child chain code (32 bytes) =\n  //   HMAC-SHA512(parent chain code, 0x01 || chain code from invalid key || index).\n  const newEntropy = await generateEntropy(\n    {\n      chainCode,\n      extension: concatBytes([\n        0x01,\n        entropy.slice(32, 64),\n        numberToUint32(actualChildIndex),\n      ]),\n    },\n    cryptographicFunctions,\n  );\n\n  return {\n    ...options,\n    entropy: newEntropy,\n  };\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/extended-keys.cjs b/node_modules/@metamask/key-tree/dist/extended-keys.cjs
index dd29eb6..6870041 100644
--- a/node_modules/@metamask/key-tree/dist/extended-keys.cjs
+++ b/node_modules/@metamask/key-tree/dist/extended-keys.cjs
@@ -9,8 +9,8 @@ const utils_2 = require("./utils.cjs");
 exports.PUBLIC_KEY_VERSION = 0x0488b21e;
 exports.PRIVATE_KEY_VERSION = 0x0488ade4;
 /**
- * Decodes an extended public or private key. In the case of an extended public key, the public key
- * is returned in the uncompressed form.
+ * Decode an extended public or private key. In the case of an extended public
+ * key, the public key is returned in the uncompressed form.
  *
  * Throws an error if the extended key is invalid.
  *
diff --git a/node_modules/@metamask/key-tree/dist/extended-keys.cjs.map b/node_modules/@metamask/key-tree/dist/extended-keys.cjs.map
index 93e4bb7..11a183a 100644
--- a/node_modules/@metamask/key-tree/dist/extended-keys.cjs.map
+++ b/node_modules/@metamask/key-tree/dist/extended-keys.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"extended-keys.cjs","sourceRoot":"","sources":["../src/extended-keys.ts"],"names":[],"mappings":"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","sourcesContent":["import { createDataView } from '@metamask/utils';\n\nimport { validateBIP44Depth } from './BIP44Node';\nimport { compressPublicKey, decompressPublicKey } from './curves/secp256k1';\nimport { decodeBase58check, encodeBase58check, isValidBytesKey } from './utils';\n\n// https://github.com/bitcoin/bips/blob/274fa400d630ba757bec0c03b35ebe2345197108/bip-0032.mediawiki#Serialization_format\nexport const PUBLIC_KEY_VERSION = 0x0488b21e;\nexport const PRIVATE_KEY_VERSION = 0x0488ade4;\n\nexport type ExtendedKeyVersion =\n  | typeof PUBLIC_KEY_VERSION\n  | typeof PRIVATE_KEY_VERSION;\n\n/**\n * An extended public or private key. Contains either a public or private key,\n * depending on the version.\n */\ntype ExtendedKeyLike = {\n  version: ExtendedKeyVersion;\n  depth: number;\n  parentFingerprint: number;\n  index: number;\n  chainCode: Uint8Array;\n};\n\ntype ExtendedPublicKey = ExtendedKeyLike & {\n  version: typeof PUBLIC_KEY_VERSION;\n  publicKey: Uint8Array;\n};\n\ntype ExtendedPrivateKey = ExtendedKeyLike & {\n  version: typeof PRIVATE_KEY_VERSION;\n  privateKey: Uint8Array;\n};\n\nexport type ExtendedKey = ExtendedPublicKey | ExtendedPrivateKey;\n\n/**\n * Decodes an extended public or private key. In the case of an extended public key, the public key\n * is returned in the uncompressed form.\n *\n * Throws an error if the extended key is invalid.\n *\n * @param extendedKey - The extended key string to attempt to decode.\n * @returns The decoded extended key.\n */\nexport const decodeExtendedKey = (extendedKey: string): ExtendedKey => {\n  const bytes = decodeBase58check(extendedKey);\n\n  if (bytes.length !== 78) {\n    throw new Error(\n      `Invalid extended key: Expected a length of 78, got ${bytes.length}.`,\n    );\n  }\n\n  const view = createDataView(bytes);\n\n  const version = view.getUint32(0, false);\n  const depth = view.getUint8(4);\n  validateBIP44Depth(depth);\n\n  const parentFingerprint = view.getUint32(5, false);\n  const index = view.getUint32(9, false);\n\n  const chainCode = bytes.slice(13, 45);\n  if (!isValidBytesKey(chainCode, 32)) {\n    throw new Error(\n      `Invalid extended key: Chain code must be a 32-byte non-zero byte array.`,\n    );\n  }\n\n  const key = bytes.slice(45, 78);\n  if (!isValidBytesKey(key, 33)) {\n    throw new Error(\n      `Invalid extended key: Key must be a 33-byte non-zero byte array.`,\n    );\n  }\n\n  const keyView = createDataView(key);\n\n  if (version === PUBLIC_KEY_VERSION) {\n    if (keyView.getUint8(0) !== 0x02 && keyView.getUint8(0) !== 0x03) {\n      throw new Error(\n        `Invalid extended key: Public key must start with 0x02 or 0x03.`,\n      );\n    }\n\n    return {\n      version,\n      depth,\n      parentFingerprint,\n      index,\n      chainCode,\n      publicKey: decompressPublicKey(key),\n    };\n  }\n\n  if (version === PRIVATE_KEY_VERSION) {\n    if (keyView.getUint8(0) !== 0x00) {\n      throw new Error(\n        `Invalid extended key: Private key must start with 0x00.`,\n      );\n    }\n\n    return {\n      version,\n      depth,\n      parentFingerprint,\n      index,\n      chainCode,\n      privateKey: key.slice(1),\n    };\n  }\n\n  throw new Error(\n    `Invalid extended key: Expected a public (xpub) or private key (xprv) version.`,\n  );\n};\n\n/**\n * Encodes an extended public or private key. Assumes that all the inputs are verified beforehand.\n *\n * @param extendedKey - The extended key data to encode.\n * @returns The encoded extended key.\n */\nexport const encodeExtendedKey = (extendedKey: ExtendedKey): string => {\n  const { version, depth, parentFingerprint, index, chainCode } = extendedKey;\n\n  const bytes = new Uint8Array(78);\n\n  const view = createDataView(bytes);\n\n  view.setUint32(0, version, false);\n  view.setUint8(4, depth);\n  view.setUint32(5, parentFingerprint, false);\n  view.setUint32(9, index, false);\n\n  bytes.set(chainCode, 13);\n\n  if (extendedKey.version === PUBLIC_KEY_VERSION) {\n    const { publicKey } = extendedKey;\n    const compressedPublicKey = compressPublicKey(publicKey);\n\n    bytes.set(compressedPublicKey, 45);\n  }\n\n  if (extendedKey.version === PRIVATE_KEY_VERSION) {\n    const { privateKey } = extendedKey;\n    bytes.set(privateKey, 46);\n  }\n\n  return encodeBase58check(bytes);\n};\n"]}
\ No newline at end of file
+{"version":3,"file":"extended-keys.cjs","sourceRoot":"","sources":["../src/extended-keys.ts"],"names":[],"mappings":"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","sourcesContent":["import { createDataView } from '@metamask/utils';\n\nimport { validateBIP44Depth } from './BIP44Node';\nimport { compressPublicKey, decompressPublicKey } from './curves/secp256k1';\nimport { decodeBase58check, encodeBase58check, isValidBytesKey } from './utils';\n\n// https://github.com/bitcoin/bips/blob/274fa400d630ba757bec0c03b35ebe2345197108/bip-0032.mediawiki#Serialization_format\nexport const PUBLIC_KEY_VERSION = 0x0488b21e;\nexport const PRIVATE_KEY_VERSION = 0x0488ade4;\n\nexport type ExtendedKeyVersion =\n  | typeof PUBLIC_KEY_VERSION\n  | typeof PRIVATE_KEY_VERSION;\n\n/**\n * An extended public or private key. Contains either a public or private key,\n * depending on the version.\n */\ntype ExtendedKeyLike = {\n  version: ExtendedKeyVersion;\n  depth: number;\n  parentFingerprint: number;\n  index: number;\n  chainCode: Uint8Array;\n};\n\ntype ExtendedPublicKey = ExtendedKeyLike & {\n  version: typeof PUBLIC_KEY_VERSION;\n  publicKey: Uint8Array;\n};\n\ntype ExtendedPrivateKey = ExtendedKeyLike & {\n  version: typeof PRIVATE_KEY_VERSION;\n  privateKey: Uint8Array;\n};\n\nexport type ExtendedKey = ExtendedPublicKey | ExtendedPrivateKey;\n\n/**\n * Decode an extended public or private key. In the case of an extended public\n * key, the public key is returned in the uncompressed form.\n *\n * Throws an error if the extended key is invalid.\n *\n * @param extendedKey - The extended key string to attempt to decode.\n * @returns The decoded extended key.\n */\nexport const decodeExtendedKey = (extendedKey: string): ExtendedKey => {\n  const bytes = decodeBase58check(extendedKey);\n\n  if (bytes.length !== 78) {\n    throw new Error(\n      `Invalid extended key: Expected a length of 78, got ${bytes.length}.`,\n    );\n  }\n\n  const view = createDataView(bytes);\n\n  const version = view.getUint32(0, false);\n  const depth = view.getUint8(4);\n  validateBIP44Depth(depth);\n\n  const parentFingerprint = view.getUint32(5, false);\n  const index = view.getUint32(9, false);\n\n  const chainCode = bytes.slice(13, 45);\n  if (!isValidBytesKey(chainCode, 32)) {\n    throw new Error(\n      `Invalid extended key: Chain code must be a 32-byte non-zero byte array.`,\n    );\n  }\n\n  const key = bytes.slice(45, 78);\n  if (!isValidBytesKey(key, 33)) {\n    throw new Error(\n      `Invalid extended key: Key must be a 33-byte non-zero byte array.`,\n    );\n  }\n\n  const keyView = createDataView(key);\n\n  if (version === PUBLIC_KEY_VERSION) {\n    if (keyView.getUint8(0) !== 0x02 && keyView.getUint8(0) !== 0x03) {\n      throw new Error(\n        `Invalid extended key: Public key must start with 0x02 or 0x03.`,\n      );\n    }\n\n    return {\n      version,\n      depth,\n      parentFingerprint,\n      index,\n      chainCode,\n      publicKey: decompressPublicKey(key),\n    };\n  }\n\n  if (version === PRIVATE_KEY_VERSION) {\n    if (keyView.getUint8(0) !== 0x00) {\n      throw new Error(\n        `Invalid extended key: Private key must start with 0x00.`,\n      );\n    }\n\n    return {\n      version,\n      depth,\n      parentFingerprint,\n      index,\n      chainCode,\n      privateKey: key.slice(1),\n    };\n  }\n\n  throw new Error(\n    `Invalid extended key: Expected a public (xpub) or private key (xprv) version.`,\n  );\n};\n\n/**\n * Encodes an extended public or private key. Assumes that all the inputs are verified beforehand.\n *\n * @param extendedKey - The extended key data to encode.\n * @returns The encoded extended key.\n */\nexport const encodeExtendedKey = (extendedKey: ExtendedKey): string => {\n  const { version, depth, parentFingerprint, index, chainCode } = extendedKey;\n\n  const bytes = new Uint8Array(78);\n\n  const view = createDataView(bytes);\n\n  view.setUint32(0, version, false);\n  view.setUint8(4, depth);\n  view.setUint32(5, parentFingerprint, false);\n  view.setUint32(9, index, false);\n\n  bytes.set(chainCode, 13);\n\n  if (extendedKey.version === PUBLIC_KEY_VERSION) {\n    const { publicKey } = extendedKey;\n    const compressedPublicKey = compressPublicKey(publicKey);\n\n    bytes.set(compressedPublicKey, 45);\n  }\n\n  if (extendedKey.version === PRIVATE_KEY_VERSION) {\n    const { privateKey } = extendedKey;\n    bytes.set(privateKey, 46);\n  }\n\n  return encodeBase58check(bytes);\n};\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/extended-keys.d.cts b/node_modules/@metamask/key-tree/dist/extended-keys.d.cts
index 435882b..b9603b7 100644
--- a/node_modules/@metamask/key-tree/dist/extended-keys.d.cts
+++ b/node_modules/@metamask/key-tree/dist/extended-keys.d.cts
@@ -1,29 +1,29 @@
 export declare const PUBLIC_KEY_VERSION = 76067358;
 export declare const PRIVATE_KEY_VERSION = 76066276;
-export declare type ExtendedKeyVersion = typeof PUBLIC_KEY_VERSION | typeof PRIVATE_KEY_VERSION;
+export type ExtendedKeyVersion = typeof PUBLIC_KEY_VERSION | typeof PRIVATE_KEY_VERSION;
 /**
  * An extended public or private key. Contains either a public or private key,
  * depending on the version.
  */
-declare type ExtendedKeyLike = {
+type ExtendedKeyLike = {
     version: ExtendedKeyVersion;
     depth: number;
     parentFingerprint: number;
     index: number;
     chainCode: Uint8Array;
 };
-declare type ExtendedPublicKey = ExtendedKeyLike & {
+type ExtendedPublicKey = ExtendedKeyLike & {
     version: typeof PUBLIC_KEY_VERSION;
     publicKey: Uint8Array;
 };
-declare type ExtendedPrivateKey = ExtendedKeyLike & {
+type ExtendedPrivateKey = ExtendedKeyLike & {
     version: typeof PRIVATE_KEY_VERSION;
     privateKey: Uint8Array;
 };
-export declare type ExtendedKey = ExtendedPublicKey | ExtendedPrivateKey;
+export type ExtendedKey = ExtendedPublicKey | ExtendedPrivateKey;
 /**
- * Decodes an extended public or private key. In the case of an extended public key, the public key
- * is returned in the uncompressed form.
+ * Decode an extended public or private key. In the case of an extended public
+ * key, the public key is returned in the uncompressed form.
  *
  * Throws an error if the extended key is invalid.
  *
diff --git a/node_modules/@metamask/key-tree/dist/extended-keys.d.cts.map b/node_modules/@metamask/key-tree/dist/extended-keys.d.cts.map
index 8db7c9f..94fb79c 100644
--- a/node_modules/@metamask/key-tree/dist/extended-keys.d.cts.map
+++ b/node_modules/@metamask/key-tree/dist/extended-keys.d.cts.map
@@ -1 +1 @@
-{"version":3,"file":"extended-keys.d.cts","sourceRoot":"","sources":["../src/extended-keys.ts"],"names":[],"mappings":"AAOA,eAAO,MAAM,kBAAkB,WAAa,CAAC;AAC7C,eAAO,MAAM,mBAAmB,WAAa,CAAC;AAE9C,oBAAY,kBAAkB,GAC1B,OAAO,kBAAkB,GACzB,OAAO,mBAAmB,CAAC;AAE/B;;;GAGG;AACH,aAAK,eAAe,GAAG;IACrB,OAAO,EAAE,kBAAkB,CAAC;IAC5B,KAAK,EAAE,MAAM,CAAC;IACd,iBAAiB,EAAE,MAAM,CAAC;IAC1B,KAAK,EAAE,MAAM,CAAC;IACd,SAAS,EAAE,UAAU,CAAC;CACvB,CAAC;AAEF,aAAK,iBAAiB,GAAG,eAAe,GAAG;IACzC,OAAO,EAAE,OAAO,kBAAkB,CAAC;IACnC,SAAS,EAAE,UAAU,CAAC;CACvB,CAAC;AAEF,aAAK,kBAAkB,GAAG,eAAe,GAAG;IAC1C,OAAO,EAAE,OAAO,mBAAmB,CAAC;IACpC,UAAU,EAAE,UAAU,CAAC;CACxB,CAAC;AAEF,oBAAY,WAAW,GAAG,iBAAiB,GAAG,kBAAkB,CAAC;AAEjE;;;;;;;;GAQG;AACH,eAAO,MAAM,iBAAiB,gBAAiB,MAAM,KAAG,WAuEvD,CAAC;AAEF;;;;;GAKG;AACH,eAAO,MAAM,iBAAiB,gBAAiB,WAAW,KAAG,MA2B5D,CAAC"}
\ No newline at end of file
+{"version":3,"file":"extended-keys.d.cts","sourceRoot":"","sources":["../src/extended-keys.ts"],"names":[],"mappings":"AAOA,eAAO,MAAM,kBAAkB,WAAa,CAAC;AAC7C,eAAO,MAAM,mBAAmB,WAAa,CAAC;AAE9C,MAAM,MAAM,kBAAkB,GAC1B,OAAO,kBAAkB,GACzB,OAAO,mBAAmB,CAAC;AAE/B;;;GAGG;AACH,KAAK,eAAe,GAAG;IACrB,OAAO,EAAE,kBAAkB,CAAC;IAC5B,KAAK,EAAE,MAAM,CAAC;IACd,iBAAiB,EAAE,MAAM,CAAC;IAC1B,KAAK,EAAE,MAAM,CAAC;IACd,SAAS,EAAE,UAAU,CAAC;CACvB,CAAC;AAEF,KAAK,iBAAiB,GAAG,eAAe,GAAG;IACzC,OAAO,EAAE,OAAO,kBAAkB,CAAC;IACnC,SAAS,EAAE,UAAU,CAAC;CACvB,CAAC;AAEF,KAAK,kBAAkB,GAAG,eAAe,GAAG;IAC1C,OAAO,EAAE,OAAO,mBAAmB,CAAC;IACpC,UAAU,EAAE,UAAU,CAAC;CACxB,CAAC;AAEF,MAAM,MAAM,WAAW,GAAG,iBAAiB,GAAG,kBAAkB,CAAC;AAEjE;;;;;;;;GAQG;AACH,eAAO,MAAM,iBAAiB,gBAAiB,MAAM,KAAG,WAuEvD,CAAC;AAEF;;;;;GAKG;AACH,eAAO,MAAM,iBAAiB,gBAAiB,WAAW,KAAG,MA2B5D,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/extended-keys.d.mts b/node_modules/@metamask/key-tree/dist/extended-keys.d.mts
index 6bc5488..8eeca8a 100644
--- a/node_modules/@metamask/key-tree/dist/extended-keys.d.mts
+++ b/node_modules/@metamask/key-tree/dist/extended-keys.d.mts
@@ -1,29 +1,29 @@
 export declare const PUBLIC_KEY_VERSION = 76067358;
 export declare const PRIVATE_KEY_VERSION = 76066276;
-export declare type ExtendedKeyVersion = typeof PUBLIC_KEY_VERSION | typeof PRIVATE_KEY_VERSION;
+export type ExtendedKeyVersion = typeof PUBLIC_KEY_VERSION | typeof PRIVATE_KEY_VERSION;
 /**
  * An extended public or private key. Contains either a public or private key,
  * depending on the version.
  */
-declare type ExtendedKeyLike = {
+type ExtendedKeyLike = {
     version: ExtendedKeyVersion;
     depth: number;
     parentFingerprint: number;
     index: number;
     chainCode: Uint8Array;
 };
-declare type ExtendedPublicKey = ExtendedKeyLike & {
+type ExtendedPublicKey = ExtendedKeyLike & {
     version: typeof PUBLIC_KEY_VERSION;
     publicKey: Uint8Array;
 };
-declare type ExtendedPrivateKey = ExtendedKeyLike & {
+type ExtendedPrivateKey = ExtendedKeyLike & {
     version: typeof PRIVATE_KEY_VERSION;
     privateKey: Uint8Array;
 };
-export declare type ExtendedKey = ExtendedPublicKey | ExtendedPrivateKey;
+export type ExtendedKey = ExtendedPublicKey | ExtendedPrivateKey;
 /**
- * Decodes an extended public or private key. In the case of an extended public key, the public key
- * is returned in the uncompressed form.
+ * Decode an extended public or private key. In the case of an extended public
+ * key, the public key is returned in the uncompressed form.
  *
  * Throws an error if the extended key is invalid.
  *
diff --git a/node_modules/@metamask/key-tree/dist/extended-keys.d.mts.map b/node_modules/@metamask/key-tree/dist/extended-keys.d.mts.map
index 7d5ff2a..4200b58 100644
--- a/node_modules/@metamask/key-tree/dist/extended-keys.d.mts.map
+++ b/node_modules/@metamask/key-tree/dist/extended-keys.d.mts.map
@@ -1 +1 @@
-{"version":3,"file":"extended-keys.d.mts","sourceRoot":"","sources":["../src/extended-keys.ts"],"names":[],"mappings":"AAOA,eAAO,MAAM,kBAAkB,WAAa,CAAC;AAC7C,eAAO,MAAM,mBAAmB,WAAa,CAAC;AAE9C,oBAAY,kBAAkB,GAC1B,OAAO,kBAAkB,GACzB,OAAO,mBAAmB,CAAC;AAE/B;;;GAGG;AACH,aAAK,eAAe,GAAG;IACrB,OAAO,EAAE,kBAAkB,CAAC;IAC5B,KAAK,EAAE,MAAM,CAAC;IACd,iBAAiB,EAAE,MAAM,CAAC;IAC1B,KAAK,EAAE,MAAM,CAAC;IACd,SAAS,EAAE,UAAU,CAAC;CACvB,CAAC;AAEF,aAAK,iBAAiB,GAAG,eAAe,GAAG;IACzC,OAAO,EAAE,OAAO,kBAAkB,CAAC;IACnC,SAAS,EAAE,UAAU,CAAC;CACvB,CAAC;AAEF,aAAK,kBAAkB,GAAG,eAAe,GAAG;IAC1C,OAAO,EAAE,OAAO,mBAAmB,CAAC;IACpC,UAAU,EAAE,UAAU,CAAC;CACxB,CAAC;AAEF,oBAAY,WAAW,GAAG,iBAAiB,GAAG,kBAAkB,CAAC;AAEjE;;;;;;;;GAQG;AACH,eAAO,MAAM,iBAAiB,gBAAiB,MAAM,KAAG,WAuEvD,CAAC;AAEF;;;;;GAKG;AACH,eAAO,MAAM,iBAAiB,gBAAiB,WAAW,KAAG,MA2B5D,CAAC"}
\ No newline at end of file
+{"version":3,"file":"extended-keys.d.mts","sourceRoot":"","sources":["../src/extended-keys.ts"],"names":[],"mappings":"AAOA,eAAO,MAAM,kBAAkB,WAAa,CAAC;AAC7C,eAAO,MAAM,mBAAmB,WAAa,CAAC;AAE9C,MAAM,MAAM,kBAAkB,GAC1B,OAAO,kBAAkB,GACzB,OAAO,mBAAmB,CAAC;AAE/B;;;GAGG;AACH,KAAK,eAAe,GAAG;IACrB,OAAO,EAAE,kBAAkB,CAAC;IAC5B,KAAK,EAAE,MAAM,CAAC;IACd,iBAAiB,EAAE,MAAM,CAAC;IAC1B,KAAK,EAAE,MAAM,CAAC;IACd,SAAS,EAAE,UAAU,CAAC;CACvB,CAAC;AAEF,KAAK,iBAAiB,GAAG,eAAe,GAAG;IACzC,OAAO,EAAE,OAAO,kBAAkB,CAAC;IACnC,SAAS,EAAE,UAAU,CAAC;CACvB,CAAC;AAEF,KAAK,kBAAkB,GAAG,eAAe,GAAG;IAC1C,OAAO,EAAE,OAAO,mBAAmB,CAAC;IACpC,UAAU,EAAE,UAAU,CAAC;CACxB,CAAC;AAEF,MAAM,MAAM,WAAW,GAAG,iBAAiB,GAAG,kBAAkB,CAAC;AAEjE;;;;;;;;GAQG;AACH,eAAO,MAAM,iBAAiB,gBAAiB,MAAM,KAAG,WAuEvD,CAAC;AAEF;;;;;GAKG;AACH,eAAO,MAAM,iBAAiB,gBAAiB,WAAW,KAAG,MA2B5D,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/extended-keys.mjs b/node_modules/@metamask/key-tree/dist/extended-keys.mjs
index 15d2aab..a0c493f 100644
--- a/node_modules/@metamask/key-tree/dist/extended-keys.mjs
+++ b/node_modules/@metamask/key-tree/dist/extended-keys.mjs
@@ -6,8 +6,8 @@ import { decodeBase58check, encodeBase58check, isValidBytesKey } from "./utils.m
 export const PUBLIC_KEY_VERSION = 0x0488b21e;
 export const PRIVATE_KEY_VERSION = 0x0488ade4;
 /**
- * Decodes an extended public or private key. In the case of an extended public key, the public key
- * is returned in the uncompressed form.
+ * Decode an extended public or private key. In the case of an extended public
+ * key, the public key is returned in the uncompressed form.
  *
  * Throws an error if the extended key is invalid.
  *
diff --git a/node_modules/@metamask/key-tree/dist/extended-keys.mjs.map b/node_modules/@metamask/key-tree/dist/extended-keys.mjs.map
index 7df4384..df8b218 100644
--- a/node_modules/@metamask/key-tree/dist/extended-keys.mjs.map
+++ b/node_modules/@metamask/key-tree/dist/extended-keys.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"extended-keys.mjs","sourceRoot":"","sources":["../src/extended-keys.ts"],"names":[],"mappings":"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","sourcesContent":["import { createDataView } from '@metamask/utils';\n\nimport { validateBIP44Depth } from './BIP44Node';\nimport { compressPublicKey, decompressPublicKey } from './curves/secp256k1';\nimport { decodeBase58check, encodeBase58check, isValidBytesKey } from './utils';\n\n// https://github.com/bitcoin/bips/blob/274fa400d630ba757bec0c03b35ebe2345197108/bip-0032.mediawiki#Serialization_format\nexport const PUBLIC_KEY_VERSION = 0x0488b21e;\nexport const PRIVATE_KEY_VERSION = 0x0488ade4;\n\nexport type ExtendedKeyVersion =\n  | typeof PUBLIC_KEY_VERSION\n  | typeof PRIVATE_KEY_VERSION;\n\n/**\n * An extended public or private key. Contains either a public or private key,\n * depending on the version.\n */\ntype ExtendedKeyLike = {\n  version: ExtendedKeyVersion;\n  depth: number;\n  parentFingerprint: number;\n  index: number;\n  chainCode: Uint8Array;\n};\n\ntype ExtendedPublicKey = ExtendedKeyLike & {\n  version: typeof PUBLIC_KEY_VERSION;\n  publicKey: Uint8Array;\n};\n\ntype ExtendedPrivateKey = ExtendedKeyLike & {\n  version: typeof PRIVATE_KEY_VERSION;\n  privateKey: Uint8Array;\n};\n\nexport type ExtendedKey = ExtendedPublicKey | ExtendedPrivateKey;\n\n/**\n * Decodes an extended public or private key. In the case of an extended public key, the public key\n * is returned in the uncompressed form.\n *\n * Throws an error if the extended key is invalid.\n *\n * @param extendedKey - The extended key string to attempt to decode.\n * @returns The decoded extended key.\n */\nexport const decodeExtendedKey = (extendedKey: string): ExtendedKey => {\n  const bytes = decodeBase58check(extendedKey);\n\n  if (bytes.length !== 78) {\n    throw new Error(\n      `Invalid extended key: Expected a length of 78, got ${bytes.length}.`,\n    );\n  }\n\n  const view = createDataView(bytes);\n\n  const version = view.getUint32(0, false);\n  const depth = view.getUint8(4);\n  validateBIP44Depth(depth);\n\n  const parentFingerprint = view.getUint32(5, false);\n  const index = view.getUint32(9, false);\n\n  const chainCode = bytes.slice(13, 45);\n  if (!isValidBytesKey(chainCode, 32)) {\n    throw new Error(\n      `Invalid extended key: Chain code must be a 32-byte non-zero byte array.`,\n    );\n  }\n\n  const key = bytes.slice(45, 78);\n  if (!isValidBytesKey(key, 33)) {\n    throw new Error(\n      `Invalid extended key: Key must be a 33-byte non-zero byte array.`,\n    );\n  }\n\n  const keyView = createDataView(key);\n\n  if (version === PUBLIC_KEY_VERSION) {\n    if (keyView.getUint8(0) !== 0x02 && keyView.getUint8(0) !== 0x03) {\n      throw new Error(\n        `Invalid extended key: Public key must start with 0x02 or 0x03.`,\n      );\n    }\n\n    return {\n      version,\n      depth,\n      parentFingerprint,\n      index,\n      chainCode,\n      publicKey: decompressPublicKey(key),\n    };\n  }\n\n  if (version === PRIVATE_KEY_VERSION) {\n    if (keyView.getUint8(0) !== 0x00) {\n      throw new Error(\n        `Invalid extended key: Private key must start with 0x00.`,\n      );\n    }\n\n    return {\n      version,\n      depth,\n      parentFingerprint,\n      index,\n      chainCode,\n      privateKey: key.slice(1),\n    };\n  }\n\n  throw new Error(\n    `Invalid extended key: Expected a public (xpub) or private key (xprv) version.`,\n  );\n};\n\n/**\n * Encodes an extended public or private key. Assumes that all the inputs are verified beforehand.\n *\n * @param extendedKey - The extended key data to encode.\n * @returns The encoded extended key.\n */\nexport const encodeExtendedKey = (extendedKey: ExtendedKey): string => {\n  const { version, depth, parentFingerprint, index, chainCode } = extendedKey;\n\n  const bytes = new Uint8Array(78);\n\n  const view = createDataView(bytes);\n\n  view.setUint32(0, version, false);\n  view.setUint8(4, depth);\n  view.setUint32(5, parentFingerprint, false);\n  view.setUint32(9, index, false);\n\n  bytes.set(chainCode, 13);\n\n  if (extendedKey.version === PUBLIC_KEY_VERSION) {\n    const { publicKey } = extendedKey;\n    const compressedPublicKey = compressPublicKey(publicKey);\n\n    bytes.set(compressedPublicKey, 45);\n  }\n\n  if (extendedKey.version === PRIVATE_KEY_VERSION) {\n    const { privateKey } = extendedKey;\n    bytes.set(privateKey, 46);\n  }\n\n  return encodeBase58check(bytes);\n};\n"]}
\ No newline at end of file
+{"version":3,"file":"extended-keys.mjs","sourceRoot":"","sources":["../src/extended-keys.ts"],"names":[],"mappings":"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","sourcesContent":["import { createDataView } from '@metamask/utils';\n\nimport { validateBIP44Depth } from './BIP44Node';\nimport { compressPublicKey, decompressPublicKey } from './curves/secp256k1';\nimport { decodeBase58check, encodeBase58check, isValidBytesKey } from './utils';\n\n// https://github.com/bitcoin/bips/blob/274fa400d630ba757bec0c03b35ebe2345197108/bip-0032.mediawiki#Serialization_format\nexport const PUBLIC_KEY_VERSION = 0x0488b21e;\nexport const PRIVATE_KEY_VERSION = 0x0488ade4;\n\nexport type ExtendedKeyVersion =\n  | typeof PUBLIC_KEY_VERSION\n  | typeof PRIVATE_KEY_VERSION;\n\n/**\n * An extended public or private key. Contains either a public or private key,\n * depending on the version.\n */\ntype ExtendedKeyLike = {\n  version: ExtendedKeyVersion;\n  depth: number;\n  parentFingerprint: number;\n  index: number;\n  chainCode: Uint8Array;\n};\n\ntype ExtendedPublicKey = ExtendedKeyLike & {\n  version: typeof PUBLIC_KEY_VERSION;\n  publicKey: Uint8Array;\n};\n\ntype ExtendedPrivateKey = ExtendedKeyLike & {\n  version: typeof PRIVATE_KEY_VERSION;\n  privateKey: Uint8Array;\n};\n\nexport type ExtendedKey = ExtendedPublicKey | ExtendedPrivateKey;\n\n/**\n * Decode an extended public or private key. In the case of an extended public\n * key, the public key is returned in the uncompressed form.\n *\n * Throws an error if the extended key is invalid.\n *\n * @param extendedKey - The extended key string to attempt to decode.\n * @returns The decoded extended key.\n */\nexport const decodeExtendedKey = (extendedKey: string): ExtendedKey => {\n  const bytes = decodeBase58check(extendedKey);\n\n  if (bytes.length !== 78) {\n    throw new Error(\n      `Invalid extended key: Expected a length of 78, got ${bytes.length}.`,\n    );\n  }\n\n  const view = createDataView(bytes);\n\n  const version = view.getUint32(0, false);\n  const depth = view.getUint8(4);\n  validateBIP44Depth(depth);\n\n  const parentFingerprint = view.getUint32(5, false);\n  const index = view.getUint32(9, false);\n\n  const chainCode = bytes.slice(13, 45);\n  if (!isValidBytesKey(chainCode, 32)) {\n    throw new Error(\n      `Invalid extended key: Chain code must be a 32-byte non-zero byte array.`,\n    );\n  }\n\n  const key = bytes.slice(45, 78);\n  if (!isValidBytesKey(key, 33)) {\n    throw new Error(\n      `Invalid extended key: Key must be a 33-byte non-zero byte array.`,\n    );\n  }\n\n  const keyView = createDataView(key);\n\n  if (version === PUBLIC_KEY_VERSION) {\n    if (keyView.getUint8(0) !== 0x02 && keyView.getUint8(0) !== 0x03) {\n      throw new Error(\n        `Invalid extended key: Public key must start with 0x02 or 0x03.`,\n      );\n    }\n\n    return {\n      version,\n      depth,\n      parentFingerprint,\n      index,\n      chainCode,\n      publicKey: decompressPublicKey(key),\n    };\n  }\n\n  if (version === PRIVATE_KEY_VERSION) {\n    if (keyView.getUint8(0) !== 0x00) {\n      throw new Error(\n        `Invalid extended key: Private key must start with 0x00.`,\n      );\n    }\n\n    return {\n      version,\n      depth,\n      parentFingerprint,\n      index,\n      chainCode,\n      privateKey: key.slice(1),\n    };\n  }\n\n  throw new Error(\n    `Invalid extended key: Expected a public (xpub) or private key (xprv) version.`,\n  );\n};\n\n/**\n * Encodes an extended public or private key. Assumes that all the inputs are verified beforehand.\n *\n * @param extendedKey - The extended key data to encode.\n * @returns The encoded extended key.\n */\nexport const encodeExtendedKey = (extendedKey: ExtendedKey): string => {\n  const { version, depth, parentFingerprint, index, chainCode } = extendedKey;\n\n  const bytes = new Uint8Array(78);\n\n  const view = createDataView(bytes);\n\n  view.setUint32(0, version, false);\n  view.setUint8(4, depth);\n  view.setUint32(5, parentFingerprint, false);\n  view.setUint32(9, index, false);\n\n  bytes.set(chainCode, 13);\n\n  if (extendedKey.version === PUBLIC_KEY_VERSION) {\n    const { publicKey } = extendedKey;\n    const compressedPublicKey = compressPublicKey(publicKey);\n\n    bytes.set(compressedPublicKey, 45);\n  }\n\n  if (extendedKey.version === PRIVATE_KEY_VERSION) {\n    const { privateKey } = extendedKey;\n    bytes.set(privateKey, 46);\n  }\n\n  return encodeBase58check(bytes);\n};\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/index.cjs b/node_modules/@metamask/key-tree/dist/index.cjs
index 1dd28e5..1ae6beb 100644
--- a/node_modules/@metamask/key-tree/dist/index.cjs
+++ b/node_modules/@metamask/key-tree/dist/index.cjs
@@ -14,7 +14,7 @@ var __exportStar = (this && this.__exportStar) || function(m, exports) {
     for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
 };
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.createBip39KeyFromSeed = exports.mnemonicPhraseToBytes = exports.isValidBIP32PathSegment = exports.getBIP44CoinTypeToAddressPathTuple = exports.getBIP44AddressKeyDeriver = exports.deriveBIP44AddressKey = exports.BIP_44_COIN_TYPE_DEPTH = exports.BIP44CoinTypeNode = exports.ed25519Bip32 = exports.ed25519 = exports.secp256k1 = exports.SLIP10Node = exports.BIP44Node = void 0;
+exports.mnemonicToSeed = exports.createBip39KeyFromSeed = exports.mnemonicPhraseToBytes = exports.isValidBIP32PathSegment = exports.getBIP44CoinTypeToAddressPathTuple = exports.getBIP44AddressKeyDeriver = exports.deriveBIP44AddressKey = exports.BIP_44_COIN_TYPE_DEPTH = exports.BIP44CoinTypeNode = exports.ed25519Bip32 = exports.ed25519 = exports.secp256k1 = exports.SLIP10Node = exports.BIP44Node = void 0;
 var BIP44Node_1 = require("./BIP44Node.cjs");
 Object.defineProperty(exports, "BIP44Node", { enumerable: true, get: function () { return BIP44Node_1.BIP44Node; } });
 var SLIP10Node_1 = require("./SLIP10Node.cjs");
@@ -35,4 +35,5 @@ Object.defineProperty(exports, "isValidBIP32PathSegment", { enumerable: true, ge
 Object.defineProperty(exports, "mnemonicPhraseToBytes", { enumerable: true, get: function () { return utils_1.mnemonicPhraseToBytes; } });
 var derivers_1 = require("./derivers/index.cjs");
 Object.defineProperty(exports, "createBip39KeyFromSeed", { enumerable: true, get: function () { return derivers_1.createBip39KeyFromSeed; } });
+Object.defineProperty(exports, "mnemonicToSeed", { enumerable: true, get: function () { return derivers_1.mnemonicToSeed; } });
 //# sourceMappingURL=index.cjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/index.cjs.map b/node_modules/@metamask/key-tree/dist/index.cjs.map
index 5249712..3466265 100644
--- a/node_modules/@metamask/key-tree/dist/index.cjs.map
+++ b/node_modules/@metamask/key-tree/dist/index.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"index.cjs","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAMA,6CAAwC;AAA/B,sGAAA,SAAS,OAAA;AAQlB,+CAA0C;AAAjC,wGAAA,UAAU,OAAA;AAEnB,6CAA4D;AAAnD,mGAAA,SAAS,OAAA;AAAE,iGAAA,OAAO,OAAA;AAAE,sGAAA,YAAY,OAAA;AAOzC,6DAK6B;AAJ3B,sHAAA,iBAAiB,OAAA;AACjB,2HAAA,sBAAsB,OAAA;AACtB,0HAAA,qBAAqB,OAAA;AACrB,8HAAA,yBAAyB,OAAA;AAE3B,kDAA4B;AAE5B,qCAIiB;AAHf,2HAAA,kCAAkC,OAAA;AAClC,gHAAA,uBAAuB,OAAA;AACvB,8GAAA,qBAAqB,OAAA;AAEvB,iDAAoD;AAA3C,kHAAA,sBAAsB,OAAA","sourcesContent":["export type {\n  BIP44NodeInterface,\n  JsonBIP44Node,\n  BIP44ExtendedKeyOptions,\n  BIP44DerivationPathOptions,\n} from './BIP44Node';\nexport { BIP44Node } from './BIP44Node';\nexport type {\n  SLIP10NodeInterface,\n  JsonSLIP10Node,\n  SLIP10NodeConstructorOptions,\n  SLIP10ExtendedKeyOptions,\n  SLIP10DerivationPathOptions,\n} from './SLIP10Node';\nexport { SLIP10Node } from './SLIP10Node';\nexport type { SupportedCurve } from './curves';\nexport { secp256k1, ed25519, ed25519Bip32 } from './curves';\nexport type {\n  BIP44CoinTypeNodeInterface,\n  CoinTypeHDPathTuple,\n  JsonBIP44CoinTypeNode,\n  BIP44AddressKeyDeriver,\n} from './BIP44CoinTypeNode';\nexport {\n  BIP44CoinTypeNode,\n  BIP_44_COIN_TYPE_DEPTH,\n  deriveBIP44AddressKey,\n  getBIP44AddressKeyDeriver,\n} from './BIP44CoinTypeNode';\nexport * from './constants';\nexport type { CoinTypeToAddressIndices } from './utils';\nexport {\n  getBIP44CoinTypeToAddressPathTuple,\n  isValidBIP32PathSegment,\n  mnemonicPhraseToBytes,\n} from './utils';\nexport { createBip39KeyFromSeed } from './derivers';\n"]}
\ No newline at end of file
+{"version":3,"file":"index.cjs","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAMA,6CAAwC;AAA/B,sGAAA,SAAS,OAAA;AAQlB,+CAA0C;AAAjC,wGAAA,UAAU,OAAA;AAEnB,6CAA4D;AAAnD,mGAAA,SAAS,OAAA;AAAE,iGAAA,OAAO,OAAA;AAAE,sGAAA,YAAY,OAAA;AAOzC,6DAK6B;AAJ3B,sHAAA,iBAAiB,OAAA;AACjB,2HAAA,sBAAsB,OAAA;AACtB,0HAAA,qBAAqB,OAAA;AACrB,8HAAA,yBAAyB,OAAA;AAE3B,kDAA4B;AAE5B,qCAIiB;AAHf,2HAAA,kCAAkC,OAAA;AAClC,gHAAA,uBAAuB,OAAA;AACvB,8GAAA,qBAAqB,OAAA;AAEvB,iDAAoE;AAA3D,kHAAA,sBAAsB,OAAA;AAAE,0GAAA,cAAc,OAAA","sourcesContent":["export type {\n  BIP44NodeInterface,\n  JsonBIP44Node,\n  BIP44ExtendedKeyOptions,\n  BIP44DerivationPathOptions,\n} from './BIP44Node';\nexport { BIP44Node } from './BIP44Node';\nexport type {\n  SLIP10NodeInterface,\n  JsonSLIP10Node,\n  SLIP10NodeConstructorOptions,\n  SLIP10ExtendedKeyOptions,\n  SLIP10DerivationPathOptions,\n} from './SLIP10Node';\nexport { SLIP10Node } from './SLIP10Node';\nexport type { SupportedCurve } from './curves';\nexport { secp256k1, ed25519, ed25519Bip32 } from './curves';\nexport type {\n  BIP44CoinTypeNodeInterface,\n  CoinTypeHDPathTuple,\n  JsonBIP44CoinTypeNode,\n  BIP44AddressKeyDeriver,\n} from './BIP44CoinTypeNode';\nexport {\n  BIP44CoinTypeNode,\n  BIP_44_COIN_TYPE_DEPTH,\n  deriveBIP44AddressKey,\n  getBIP44AddressKeyDeriver,\n} from './BIP44CoinTypeNode';\nexport * from './constants';\nexport type { CoinTypeToAddressIndices } from './utils';\nexport {\n  getBIP44CoinTypeToAddressPathTuple,\n  isValidBIP32PathSegment,\n  mnemonicPhraseToBytes,\n} from './utils';\nexport { createBip39KeyFromSeed, mnemonicToSeed } from './derivers';\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/index.d.cts b/node_modules/@metamask/key-tree/dist/index.d.cts
index 59e6c42..2e81cbf 100644
--- a/node_modules/@metamask/key-tree/dist/index.d.cts
+++ b/node_modules/@metamask/key-tree/dist/index.d.cts
@@ -9,5 +9,5 @@ export { BIP44CoinTypeNode, BIP_44_COIN_TYPE_DEPTH, deriveBIP44AddressKey, getBI
 export * from "./constants.cjs";
 export type { CoinTypeToAddressIndices } from "./utils.cjs";
 export { getBIP44CoinTypeToAddressPathTuple, isValidBIP32PathSegment, mnemonicPhraseToBytes, } from "./utils.cjs";
-export { createBip39KeyFromSeed } from "./derivers/index.cjs";
+export { createBip39KeyFromSeed, mnemonicToSeed } from "./derivers/index.cjs";
 //# sourceMappingURL=index.d.cts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/index.d.cts.map b/node_modules/@metamask/key-tree/dist/index.d.cts.map
index 146f37d..38a7f7c 100644
--- a/node_modules/@metamask/key-tree/dist/index.d.cts.map
+++ b/node_modules/@metamask/key-tree/dist/index.d.cts.map
@@ -1 +1 @@
-{"version":3,"file":"index.d.cts","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"AAAA,YAAY,EACV,kBAAkB,EAClB,aAAa,EACb,uBAAuB,EACvB,0BAA0B,GAC3B,wBAAoB;AACrB,OAAO,EAAE,SAAS,EAAE,wBAAoB;AACxC,YAAY,EACV,mBAAmB,EACnB,cAAc,EACd,4BAA4B,EAC5B,wBAAwB,EACxB,2BAA2B,GAC5B,yBAAqB;AACtB,OAAO,EAAE,UAAU,EAAE,yBAAqB;AAC1C,YAAY,EAAE,cAAc,EAAE,2BAAiB;AAC/C,OAAO,EAAE,SAAS,EAAE,OAAO,EAAE,YAAY,EAAE,2BAAiB;AAC5D,YAAY,EACV,0BAA0B,EAC1B,mBAAmB,EACnB,qBAAqB,EACrB,sBAAsB,GACvB,gCAA4B;AAC7B,OAAO,EACL,iBAAiB,EACjB,sBAAsB,EACtB,qBAAqB,EACrB,yBAAyB,GAC1B,gCAA4B;AAC7B,gCAA4B;AAC5B,YAAY,EAAE,wBAAwB,EAAE,oBAAgB;AACxD,OAAO,EACL,kCAAkC,EAClC,uBAAuB,EACvB,qBAAqB,GACtB,oBAAgB;AACjB,OAAO,EAAE,sBAAsB,EAAE,6BAAmB"}
\ No newline at end of file
+{"version":3,"file":"index.d.cts","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"AAAA,YAAY,EACV,kBAAkB,EAClB,aAAa,EACb,uBAAuB,EACvB,0BAA0B,GAC3B,wBAAoB;AACrB,OAAO,EAAE,SAAS,EAAE,wBAAoB;AACxC,YAAY,EACV,mBAAmB,EACnB,cAAc,EACd,4BAA4B,EAC5B,wBAAwB,EACxB,2BAA2B,GAC5B,yBAAqB;AACtB,OAAO,EAAE,UAAU,EAAE,yBAAqB;AAC1C,YAAY,EAAE,cAAc,EAAE,2BAAiB;AAC/C,OAAO,EAAE,SAAS,EAAE,OAAO,EAAE,YAAY,EAAE,2BAAiB;AAC5D,YAAY,EACV,0BAA0B,EAC1B,mBAAmB,EACnB,qBAAqB,EACrB,sBAAsB,GACvB,gCAA4B;AAC7B,OAAO,EACL,iBAAiB,EACjB,sBAAsB,EACtB,qBAAqB,EACrB,yBAAyB,GAC1B,gCAA4B;AAC7B,gCAA4B;AAC5B,YAAY,EAAE,wBAAwB,EAAE,oBAAgB;AACxD,OAAO,EACL,kCAAkC,EAClC,uBAAuB,EACvB,qBAAqB,GACtB,oBAAgB;AACjB,OAAO,EAAE,sBAAsB,EAAE,cAAc,EAAE,6BAAmB"}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/index.d.mts b/node_modules/@metamask/key-tree/dist/index.d.mts
index 1e01a7a..1829788 100644
--- a/node_modules/@metamask/key-tree/dist/index.d.mts
+++ b/node_modules/@metamask/key-tree/dist/index.d.mts
@@ -9,5 +9,5 @@ export { BIP44CoinTypeNode, BIP_44_COIN_TYPE_DEPTH, deriveBIP44AddressKey, getBI
 export * from "./constants.mjs";
 export type { CoinTypeToAddressIndices } from "./utils.mjs";
 export { getBIP44CoinTypeToAddressPathTuple, isValidBIP32PathSegment, mnemonicPhraseToBytes, } from "./utils.mjs";
-export { createBip39KeyFromSeed } from "./derivers/index.mjs";
+export { createBip39KeyFromSeed, mnemonicToSeed } from "./derivers/index.mjs";
 //# sourceMappingURL=index.d.mts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/index.d.mts.map b/node_modules/@metamask/key-tree/dist/index.d.mts.map
index 7343c58..53eda54 100644
--- a/node_modules/@metamask/key-tree/dist/index.d.mts.map
+++ b/node_modules/@metamask/key-tree/dist/index.d.mts.map
@@ -1 +1 @@
-{"version":3,"file":"index.d.mts","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"AAAA,YAAY,EACV,kBAAkB,EAClB,aAAa,EACb,uBAAuB,EACvB,0BAA0B,GAC3B,wBAAoB;AACrB,OAAO,EAAE,SAAS,EAAE,wBAAoB;AACxC,YAAY,EACV,mBAAmB,EACnB,cAAc,EACd,4BAA4B,EAC5B,wBAAwB,EACxB,2BAA2B,GAC5B,yBAAqB;AACtB,OAAO,EAAE,UAAU,EAAE,yBAAqB;AAC1C,YAAY,EAAE,cAAc,EAAE,2BAAiB;AAC/C,OAAO,EAAE,SAAS,EAAE,OAAO,EAAE,YAAY,EAAE,2BAAiB;AAC5D,YAAY,EACV,0BAA0B,EAC1B,mBAAmB,EACnB,qBAAqB,EACrB,sBAAsB,GACvB,gCAA4B;AAC7B,OAAO,EACL,iBAAiB,EACjB,sBAAsB,EACtB,qBAAqB,EACrB,yBAAyB,GAC1B,gCAA4B;AAC7B,gCAA4B;AAC5B,YAAY,EAAE,wBAAwB,EAAE,oBAAgB;AACxD,OAAO,EACL,kCAAkC,EAClC,uBAAuB,EACvB,qBAAqB,GACtB,oBAAgB;AACjB,OAAO,EAAE,sBAAsB,EAAE,6BAAmB"}
\ No newline at end of file
+{"version":3,"file":"index.d.mts","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"AAAA,YAAY,EACV,kBAAkB,EAClB,aAAa,EACb,uBAAuB,EACvB,0BAA0B,GAC3B,wBAAoB;AACrB,OAAO,EAAE,SAAS,EAAE,wBAAoB;AACxC,YAAY,EACV,mBAAmB,EACnB,cAAc,EACd,4BAA4B,EAC5B,wBAAwB,EACxB,2BAA2B,GAC5B,yBAAqB;AACtB,OAAO,EAAE,UAAU,EAAE,yBAAqB;AAC1C,YAAY,EAAE,cAAc,EAAE,2BAAiB;AAC/C,OAAO,EAAE,SAAS,EAAE,OAAO,EAAE,YAAY,EAAE,2BAAiB;AAC5D,YAAY,EACV,0BAA0B,EAC1B,mBAAmB,EACnB,qBAAqB,EACrB,sBAAsB,GACvB,gCAA4B;AAC7B,OAAO,EACL,iBAAiB,EACjB,sBAAsB,EACtB,qBAAqB,EACrB,yBAAyB,GAC1B,gCAA4B;AAC7B,gCAA4B;AAC5B,YAAY,EAAE,wBAAwB,EAAE,oBAAgB;AACxD,OAAO,EACL,kCAAkC,EAClC,uBAAuB,EACvB,qBAAqB,GACtB,oBAAgB;AACjB,OAAO,EAAE,sBAAsB,EAAE,cAAc,EAAE,6BAAmB"}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/index.mjs b/node_modules/@metamask/key-tree/dist/index.mjs
index 60b77a9..a2ddc89 100644
--- a/node_modules/@metamask/key-tree/dist/index.mjs
+++ b/node_modules/@metamask/key-tree/dist/index.mjs
@@ -4,5 +4,5 @@ export { secp256k1, ed25519, ed25519Bip32 } from "./curves/index.mjs";
 export { BIP44CoinTypeNode, BIP_44_COIN_TYPE_DEPTH, deriveBIP44AddressKey, getBIP44AddressKeyDeriver } from "./BIP44CoinTypeNode.mjs";
 export * from "./constants.mjs";
 export { getBIP44CoinTypeToAddressPathTuple, isValidBIP32PathSegment, mnemonicPhraseToBytes } from "./utils.mjs";
-export { createBip39KeyFromSeed } from "./derivers/index.mjs";
+export { createBip39KeyFromSeed, mnemonicToSeed } from "./derivers/index.mjs";
 //# sourceMappingURL=index.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/index.mjs.map b/node_modules/@metamask/key-tree/dist/index.mjs.map
index 03e7106..a28b3fb 100644
--- a/node_modules/@metamask/key-tree/dist/index.mjs.map
+++ b/node_modules/@metamask/key-tree/dist/index.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"index.mjs","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"AAMA,OAAO,EAAE,SAAS,EAAE,wBAAoB;AAQxC,OAAO,EAAE,UAAU,EAAE,yBAAqB;AAE1C,OAAO,EAAE,SAAS,EAAE,OAAO,EAAE,YAAY,EAAE,2BAAiB;AAO5D,OAAO,EACL,iBAAiB,EACjB,sBAAsB,EACtB,qBAAqB,EACrB,yBAAyB,EAC1B,gCAA4B;AAC7B,gCAA4B;AAE5B,OAAO,EACL,kCAAkC,EAClC,uBAAuB,EACvB,qBAAqB,EACtB,oBAAgB;AACjB,OAAO,EAAE,sBAAsB,EAAE,6BAAmB","sourcesContent":["export type {\n  BIP44NodeInterface,\n  JsonBIP44Node,\n  BIP44ExtendedKeyOptions,\n  BIP44DerivationPathOptions,\n} from './BIP44Node';\nexport { BIP44Node } from './BIP44Node';\nexport type {\n  SLIP10NodeInterface,\n  JsonSLIP10Node,\n  SLIP10NodeConstructorOptions,\n  SLIP10ExtendedKeyOptions,\n  SLIP10DerivationPathOptions,\n} from './SLIP10Node';\nexport { SLIP10Node } from './SLIP10Node';\nexport type { SupportedCurve } from './curves';\nexport { secp256k1, ed25519, ed25519Bip32 } from './curves';\nexport type {\n  BIP44CoinTypeNodeInterface,\n  CoinTypeHDPathTuple,\n  JsonBIP44CoinTypeNode,\n  BIP44AddressKeyDeriver,\n} from './BIP44CoinTypeNode';\nexport {\n  BIP44CoinTypeNode,\n  BIP_44_COIN_TYPE_DEPTH,\n  deriveBIP44AddressKey,\n  getBIP44AddressKeyDeriver,\n} from './BIP44CoinTypeNode';\nexport * from './constants';\nexport type { CoinTypeToAddressIndices } from './utils';\nexport {\n  getBIP44CoinTypeToAddressPathTuple,\n  isValidBIP32PathSegment,\n  mnemonicPhraseToBytes,\n} from './utils';\nexport { createBip39KeyFromSeed } from './derivers';\n"]}
\ No newline at end of file
+{"version":3,"file":"index.mjs","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"AAMA,OAAO,EAAE,SAAS,EAAE,wBAAoB;AAQxC,OAAO,EAAE,UAAU,EAAE,yBAAqB;AAE1C,OAAO,EAAE,SAAS,EAAE,OAAO,EAAE,YAAY,EAAE,2BAAiB;AAO5D,OAAO,EACL,iBAAiB,EACjB,sBAAsB,EACtB,qBAAqB,EACrB,yBAAyB,EAC1B,gCAA4B;AAC7B,gCAA4B;AAE5B,OAAO,EACL,kCAAkC,EAClC,uBAAuB,EACvB,qBAAqB,EACtB,oBAAgB;AACjB,OAAO,EAAE,sBAAsB,EAAE,cAAc,EAAE,6BAAmB","sourcesContent":["export type {\n  BIP44NodeInterface,\n  JsonBIP44Node,\n  BIP44ExtendedKeyOptions,\n  BIP44DerivationPathOptions,\n} from './BIP44Node';\nexport { BIP44Node } from './BIP44Node';\nexport type {\n  SLIP10NodeInterface,\n  JsonSLIP10Node,\n  SLIP10NodeConstructorOptions,\n  SLIP10ExtendedKeyOptions,\n  SLIP10DerivationPathOptions,\n} from './SLIP10Node';\nexport { SLIP10Node } from './SLIP10Node';\nexport type { SupportedCurve } from './curves';\nexport { secp256k1, ed25519, ed25519Bip32 } from './curves';\nexport type {\n  BIP44CoinTypeNodeInterface,\n  CoinTypeHDPathTuple,\n  JsonBIP44CoinTypeNode,\n  BIP44AddressKeyDeriver,\n} from './BIP44CoinTypeNode';\nexport {\n  BIP44CoinTypeNode,\n  BIP_44_COIN_TYPE_DEPTH,\n  deriveBIP44AddressKey,\n  getBIP44AddressKeyDeriver,\n} from './BIP44CoinTypeNode';\nexport * from './constants';\nexport type { CoinTypeToAddressIndices } from './utils';\nexport {\n  getBIP44CoinTypeToAddressPathTuple,\n  isValidBIP32PathSegment,\n  mnemonicPhraseToBytes,\n} from './utils';\nexport { createBip39KeyFromSeed, mnemonicToSeed } from './derivers';\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/utils.cjs b/node_modules/@metamask/key-tree/dist/utils.cjs
index 3bdc7b3..4f1df53 100644
--- a/node_modules/@metamask/key-tree/dist/utils.cjs
+++ b/node_modules/@metamask/key-tree/dist/utils.cjs
@@ -1,12 +1,11 @@
 "use strict";
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.numberToUint32 = exports.validateCurve = exports.mnemonicPhraseToBytes = exports.getFingerprint = exports.encodeBase58check = exports.decodeBase58check = exports.getBytesUnsafe = exports.getBytes = exports.isValidInteger = exports.isValidBytesKey = exports.nullableHexStringToBytes = exports.hexStringToBytes = exports.isHardened = exports.isValidBIP32PathSegment = exports.isValidBIP32Index = exports.validateBIP32Index = exports.getBIP32NodeToken = exports.getUnhardenedBIP32NodeToken = exports.getHardenedBIP32NodeToken = exports.getBIP44CoinTypeToAddressPathTuple = exports.getBIP44ChangePathString = exports.getBIP44CoinTypePathString = void 0;
+exports.isWebCryptoSupported = exports.numberToUint32 = exports.validateCurve = exports.mnemonicPhraseToBytes = exports.getFingerprint = exports.encodeBase58check = exports.decodeBase58check = exports.getBytesUnsafe = exports.getBytes = exports.isValidInteger = exports.isValidBytesKey = exports.nullableHexStringToBytes = exports.hexStringToBytes = exports.isHardened = exports.isValidBIP32PathSegment = exports.isValidBIP32Index = exports.validateBIP32Index = exports.getBIP32NodeToken = exports.getUnhardenedBIP32NodeToken = exports.getHardenedBIP32NodeToken = exports.getBIP44CoinTypeToAddressPathTuple = exports.getBIP44ChangePathString = exports.getBIP44CoinTypePathString = void 0;
 const english_1 = require("@metamask/scure-bip39/dist/wordlists/english.js");
 const utils_1 = require("@metamask/utils");
-const ripemd160_1 = require("@noble/hashes/ripemd160");
-const sha256_1 = require("@noble/hashes/sha256");
 const base_1 = require("@scure/base");
 const constants_1 = require("./constants.cjs");
+const cryptography_1 = require("./cryptography.cjs");
 const curves_1 = require("./curves/index.cjs");
 /**
  * Gets a string representation of a BIP-44 path of depth 2, i.e.:
@@ -274,7 +273,7 @@ function validateBytes(bytes, length) {
     }
 }
 const decodeBase58check = (value) => {
-    const base58Check = (0, base_1.base58check)(sha256_1.sha256);
+    const base58Check = (0, base_1.base58check)(cryptography_1.sha256);
     try {
         return base58Check.decode(value);
     }
@@ -284,7 +283,7 @@ const decodeBase58check = (value) => {
 };
 exports.decodeBase58check = decodeBase58check;
 const encodeBase58check = (value) => {
-    const base58Check = (0, base_1.base58check)(sha256_1.sha256);
+    const base58Check = (0, base_1.base58check)(cryptography_1.sha256);
     return base58Check.encode(value);
 };
 exports.encodeBase58check = encodeBase58check;
@@ -299,7 +298,7 @@ const getFingerprint = (publicKey, compressedPublicKeyLength) => {
     if (!isValidBytesKey(publicKey, compressedPublicKeyLength)) {
         throw new Error(`Invalid public key: The key must be a ${compressedPublicKeyLength}-byte, non-zero byte array.`);
     }
-    const bytes = (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(publicKey));
+    const bytes = (0, cryptography_1.ripemd160)((0, cryptography_1.sha256)(publicKey));
     const view = (0, utils_1.createDataView)(bytes);
     return view.getUint32(0, false);
 };
@@ -352,4 +351,14 @@ function numberToUint32(value, littleEndian = false) {
     return bytes;
 }
 exports.numberToUint32 = numberToUint32;
+/**
+ * A utility function to check if the Web Crypto API is supported in the current
+ * environment.
+ *
+ * @returns Whether the Web Crypto API is supported.
+ */
+function isWebCryptoSupported() {
+    return Boolean(globalThis.crypto?.subtle);
+}
+exports.isWebCryptoSupported = isWebCryptoSupported;
 //# sourceMappingURL=utils.cjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/utils.cjs.map b/node_modules/@metamask/key-tree/dist/utils.cjs.map
index d1a6e38..080f791 100644
--- a/node_modules/@metamask/key-tree/dist/utils.cjs.map
+++ b/node_modules/@metamask/key-tree/dist/utils.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"utils.cjs","sourceRoot":"","sources":["../src/utils.ts"],"names":[],"mappings":";;;AAAA,6EAA2F;AAC3F,2CAAqE;AACrE,uDAAoD;AACpD,iDAA8C;AAC9C,sCAA8D;AAW9D,+CAKqB;AAErB,+CAAkC;AAElC;;;;;;;;GAQG;AACH,SAAgB,0BAA0B,CACxC,SAAiB;IAEjB,OAAO,OAAO,iCAAqB,MAAM,yBAAyB,CAChE,SAAS,CACV,EAAE,CAAC;AACN,CAAC;AAND,gEAMC;AAgBD;;;;;;;;;;GAUG;AACH,SAAgB,wBAAwB,CACtC,YAAkC,EAClC,OAAwD;IAExD,OAAO,GAAG,YAAY,MAAM,yBAAyB,CACnD,OAAO,CAAC,OAAO,IAAI,CAAC,CACrB,MAAM,iBAAiB,CAAC,OAAO,CAAC,MAAM,IAAI,CAAC,CAAC,EAAE,CAAC;AAClD,CAAC;AAPD,4DAOC;AAED;;;;;;;;;;GAUG;AACH,SAAgB,kCAAkC,CAAC,EACjD,OAAO,GAAG,CAAC,EACX,MAAM,GAAG,CAAC,EACV,aAAa,GACY;IACzB,OAAO;QACL,yBAAyB,CAAC,OAAO,CAAC;QAClC,iBAAiB,CAAC,MAAM,CAAC;QACzB,iBAAiB,CAAC,aAAa,CAAC;KACxB,CAAC;AACb,CAAC;AAVD,gFAUC;AAED;;;;;;;GAOG;AACH,SAAgB,yBAAyB,CAAC,KAAa;IACrD,kBAAkB,CAAC,KAAK,CAAC,CAAC;IAC1B,OAAO,GAAG,2BAA2B,CAAC,KAAK,CAAC,GAAG,CAAC;AAClD,CAAC;AAHD,8DAGC;AAED;;;;;;;GAOG;AACH,SAAgB,2BAA2B,CACzC,KAAa;IAEb,kBAAkB,CAAC,KAAK,CAAC,CAAC;IAC1B,OAAO,SAAS,KAAK,EAAE,CAAC;AAC1B,CAAC;AALD,kEAKC;AAED;;;;;;;GAOG;AACH,SAAgB,iBAAiB,CAAC,KAAqB;IACrD,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;QAC7B,OAAO,2BAA2B,CAAC,KAAK,CAAC,CAAC;KAC3C;IAED,IACE,CAAC,KAAK;QACN,CAAC,MAAM,CAAC,SAAS,CAAC,KAAK,CAAC,KAAK,CAAC;QAC9B,OAAO,KAAK,CAAC,QAAQ,KAAK,SAAS,EACnC;QACA,MAAM,IAAI,KAAK,CACb,0FAA0F,CAC3F,CAAC;KACH;IAED,IAAI,KAAK,CAAC,QAAQ,EAAE;QAClB,OAAO,yBAAyB,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;KAC/C;IAED,OAAO,2BAA2B,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;AAClD,CAAC;AApBD,8CAoBC;AAED;;;;;GAKG;AACH,SAAgB,kBAAkB,CAAC,YAAoB;IACrD,IAAI,CAAC,iBAAiB,CAAC,YAAY,CAAC,EAAE;QACpC,MAAM,IAAI,KAAK,CAAC,uDAAuD,CAAC,CAAC;KAC1E;AACH,CAAC;AAJD,gDAIC;AAED;;;;;GAKG;AACH,SAAgB,iBAAiB,CAAC,KAAa;IAC7C,OAAO,cAAc,CAAC,KAAK,CAAC,IAAI,KAAK,IAAI,4BAAgB,CAAC;AAC5D,CAAC;AAFD,8CAEC;AAED;;;;;;GAMG;AACH,SAAgB,uBAAuB,CACrC,OAAe;IAEf,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE;QAC/B,OAAO,KAAK,CAAC;KACd;IAED,MAAM,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC,wCAA4B,CAAC,CAAC;IAC1D,IAAI,OAAO,KAAK,EAAE,MAAM,EAAE,KAAK,KAAK,WAAW,EAAE;QAC/C,OAAO,KAAK,CAAC;KACd;IAED,MAAM,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;IAC/C,OAAO,cAAc,CAAC,KAAK,CAAC,IAAI,KAAK,IAAI,uCAA2B,CAAC;AACvE,CAAC;AAdD,0DAcC;AAED;;;;;;;GAOG;AACH,SAAgB,UAAU,CAAC,UAAkB;IAC3C,OAAO,UAAU,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;AAClC,CAAC;AAFD,gCAEC;AAED;;;;;;;GAOG;AACH,SAAgB,gBAAgB,CAAC,SAA8B;IAC7D,IAAI,SAAS,YAAY,UAAU,EAAE;QACnC,OAAO,SAAS,CAAC;KAClB;IAED,OAAO,IAAA,kBAAU,EAAC,SAAS,CAAC,CAAC;AAC/B,CAAC;AAND,4CAMC;AAED;;;;;;GAMG;AACH,SAAgB,wBAAwB,CACtC,SAA+B;IAE/B,IAAI,SAAS,KAAK,SAAS,EAAE;QAC3B,OAAO,gBAAgB,CAAC,SAAS,CAAC,CAAC;KACpC;IAED,OAAO,SAAS,CAAC;AACnB,CAAC;AARD,4DAQC;AAED;;;;;;;GAOG;AACH,SAAgB,eAAe,CAC7B,KAAiB,EACjB,cAAsB;IAEtB,IAAI,KAAK,CAAC,MAAM,KAAK,cAAc,EAAE;QACnC,OAAO,KAAK,CAAC;KACd;IAED,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE;QACxB,IAAI,IAAI,KAAK,CAAC,EAAE;YACd,OAAO,IAAI,CAAC;SACb;KACF;IACD,OAAO,KAAK,CAAC;AACf,CAAC;AAdD,0CAcC;AAED;;;;;GAKG;AACH,SAAgB,cAAc,CAAC,KAAc;IAC3C,OAAO,OAAO,KAAK,KAAK,QAAQ,IAAI,MAAM,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,KAAK,IAAI,CAAC,CAAC;AAC5E,CAAC;AAFD,wCAEC;AAED;;;;;;;;GAQG;AACH,SAAgB,QAAQ,CAAC,KAAc,EAAE,MAAc;IACrD,IAAI,KAAK,YAAY,UAAU,EAAE;QAC/B,aAAa,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;QAE7B,OAAO,KAAK,CAAC;KACd;IAED,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;QAC7B,MAAM,KAAK,GAAG,IAAA,kBAAU,EAAC,KAAK,CAAC,CAAC;QAChC,aAAa,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;QAE7B,OAAO,KAAK,CAAC;KACd;IAED,MAAM,IAAI,KAAK,CACb,0EAA0E,CAC3E,CAAC;AACJ,CAAC;AAjBD,4BAiBC;AAED;;;;;;;;;;GAUG;AACH,SAAgB,cAAc,CAAC,KAAc,EAAE,MAAc;IAC3D,IAAI,KAAK,YAAY,UAAU,EAAE;QAC/B,IAAA,cAAM,EACJ,KAAK,CAAC,MAAM,KAAK,MAAM,EACvB,4BAA4B,MAAM,mBAAmB,CACtD,CAAC;QACF,OAAO,KAAK,CAAC;KACd;IAED,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;QAC7B,OAAO,cAAc,CAAC,IAAA,kBAAU,EAAC,KAAK,CAAC,EAAE,MAAM,CAAC,CAAC;KAClD;IAED,MAAM,IAAI,KAAK,CACb,0EAA0E,CAC3E,CAAC;AACJ,CAAC;AAhBD,wCAgBC;AAED;;;;;;;GAOG;AACH,SAAS,aAAa,CACpB,KAAiB,EACjB,MAAc;IAEd,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,MAAM,CAAC,EAAE;QACnC,MAAM,IAAI,KAAK,CACb,qCAAqC,MAAM,mBAAmB,CAC/D,CAAC;KACH;AACH,CAAC;AAEM,MAAM,iBAAiB,GAAG,CAAC,KAAa,EAAc,EAAE;IAC7D,MAAM,WAAW,GAAG,IAAA,kBAAgB,EAAC,eAAM,CAAC,CAAC;IAE7C,IAAI;QACF,OAAO,WAAW,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;KAClC;IAAC,MAAM;QACN,MAAM,IAAI,KAAK,CACb,gFAAgF,CACjF,CAAC;KACH;AACH,CAAC,CAAC;AAVW,QAAA,iBAAiB,qBAU5B;AAEK,MAAM,iBAAiB,GAAG,CAAC,KAAiB,EAAU,EAAE;IAC7D,MAAM,WAAW,GAAG,IAAA,kBAAgB,EAAC,eAAM,CAAC,CAAC;IAE7C,OAAO,WAAW,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;AACnC,CAAC,CAAC;AAJW,QAAA,iBAAiB,qBAI5B;AAEF;;;;;;GAMG;AACI,MAAM,cAAc,GAAG,CAC5B,SAAqB,EACrB,yBAAiC,EACzB,EAAE;IACV,IAAI,CAAC,eAAe,CAAC,SAAS,EAAE,yBAAyB,CAAC,EAAE;QAC1D,MAAM,IAAI,KAAK,CACb,yCAAyC,yBAAyB,6BAA6B,CAChG,CAAC;KACH;IAED,MAAM,KAAK,GAAG,IAAA,qBAAS,EAAC,IAAA,eAAM,EAAC,SAAS,CAAC,CAAC,CAAC;IAC3C,MAAM,IAAI,GAAG,IAAA,sBAAc,EAAC,KAAK,CAAC,CAAC;IAEnC,OAAO,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC;AAClC,CAAC,CAAC;AAdW,QAAA,cAAc,kBAczB;AAEF;;;;;;;;;GASG;AACH,SAAgB,qBAAqB,CAAC,cAAsB;IAC1D,MAAM,KAAK,GAAG,cAAc,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IACxC,MAAM,OAAO,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE;QACjC,MAAM,KAAK,GAAG,kBAAe,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;QAC5C,IAAA,cAAM,EAAC,KAAK,KAAK,CAAC,CAAC,EAAE,0CAA0C,IAAI,IAAI,CAAC,CAAC;QAEzE,OAAO,KAAK,CAAC;IACf,CAAC,CAAC,CAAC;IAEH,OAAO,IAAI,UAAU,CAAC,IAAI,WAAW,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC,CAAC;AACzD,CAAC;AAVD,sDAUC;AAED;;;;GAIG;AACH,SAAgB,aAAa,CAC3B,SAAkB;IAElB,IAAI,CAAC,SAAS,IAAI,OAAO,SAAS,KAAK,QAAQ,EAAE;QAC/C,MAAM,IAAI,KAAK,CAAC,sCAAsC,CAAC,CAAC;KACzD;IAED,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,eAAM,CAAC,CAAC,QAAQ,CAAC,SAAS,CAAC,EAAE;QAC5C,MAAM,IAAI,KAAK,CACb,2DAA2D,MAAM,CAAC,IAAI,CACpE,eAAM,CACP,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAChB,CAAC;KACH;AACH,CAAC;AAdD,sCAcC;AAED;;;;;;GAMG;AACH,SAAgB,cAAc,CAAC,KAAa,EAAE,YAAY,GAAG,KAAK;IAChE,MAAM,KAAK,GAAG,IAAI,UAAU,CAAC,CAAC,CAAC,CAAC;IAChC,MAAM,IAAI,GAAG,IAAA,sBAAc,EAAC,KAAK,CAAC,CAAC;IAEnC,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,KAAK,EAAE,YAAY,CAAC,CAAC;IAEvC,OAAO,KAAK,CAAC;AACf,CAAC;AAPD,wCAOC","sourcesContent":["import { wordlist as englishWordlist } from '@metamask/scure-bip39/dist/wordlists/english';\nimport { assert, createDataView, hexToBytes } from '@metamask/utils';\nimport { ripemd160 } from '@noble/hashes/ripemd160';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { base58check as scureBase58check } from '@scure/base';\n\nimport type {\n  BIP32Node,\n  ChangeHDPathString,\n  CoinTypeHDPathString,\n  CoinTypeToAddressTuple,\n  HardenedBIP32Node,\n  UnhardenedBIP32Node,\n  UnprefixedNode,\n} from './constants';\nimport {\n  BIP44PurposeNodeToken,\n  MAX_BIP_32_INDEX,\n  MAX_UNHARDENED_BIP_32_INDEX,\n  UNPREFIXED_BIP_32_PATH_REGEX,\n} from './constants';\nimport type { SupportedCurve } from './curves';\nimport { curves } from './curves';\n\n/**\n * Gets a string representation of a BIP-44 path of depth 2, i.e.:\n * `m / 44' / coin_type'`\n *\n * For display purposes only.\n *\n * @param coin_type - The `coin_type` index to create a path visualization for.\n * @returns The visualization of the BIP-44 path for thte specified `coin_type`.\n */\nexport function getBIP44CoinTypePathString(\n  coin_type: number,\n): CoinTypeHDPathString {\n  return `m / ${BIP44PurposeNodeToken} / ${getHardenedBIP32NodeToken(\n    coin_type,\n  )}`;\n}\n\ntype BIP44PathIndex = number | { index: number; hardened: boolean };\n\ntype BIP44PathIndices = {\n  coin_type: number;\n  account?: number;\n  change?: BIP44PathIndex;\n  address_index: BIP44PathIndex;\n};\n\nexport type CoinTypeToAddressIndices = Pick<\n  BIP44PathIndices,\n  'account' | 'change' | 'address_index'\n>;\n\n/**\n * Gets a string representation of a BIP-44 path of depth 4, i.e.:\n * `m / 44' / coin_type' / account' / change`\n *\n * For display purposes only.\n *\n * @param coinTypePath - The parent `coin_type` path.\n * @param indices - The `account` and `change` index to create a path visualization for.\n * @returns The visualization of the BIP-44 path for the specified `coin_type`\n * and `change` indices.\n */\nexport function getBIP44ChangePathString(\n  coinTypePath: CoinTypeHDPathString,\n  indices: Omit<CoinTypeToAddressIndices, 'address_index'>,\n): ChangeHDPathString {\n  return `${coinTypePath} / ${getHardenedBIP32NodeToken(\n    indices.account ?? 0,\n  )} / ${getBIP32NodeToken(indices.change ?? 0)}`;\n}\n\n/**\n * Gets a BIP-44 path tuple of the form `account' / change / address_index`,\n * which can be used to derive address keys together with a `coin_type` key.\n *\n * @param indices - The BIP-44 derivation index values.\n * @param indices.account - The `account` index value.\n * @param indices.change - The `change` index value.\n * @param indices.address_index - The `address_index` index value.\n * @returns The `account' / change / address_index` path corresponding to the\n * specified indices.\n */\nexport function getBIP44CoinTypeToAddressPathTuple({\n  account = 0,\n  change = 0,\n  address_index,\n}: CoinTypeToAddressIndices): CoinTypeToAddressTuple {\n  return [\n    getHardenedBIP32NodeToken(account),\n    getBIP32NodeToken(change),\n    getBIP32NodeToken(address_index),\n  ] as const;\n}\n\n/**\n * A hardened BIP-32 node token, e.g. `bip32:0'`.\n * Validates that the index is a non-negative integer number, and throws an\n * error if validation fails.\n *\n * @param index - The index of the node.\n * @returns The hardened BIP-32 node token.\n */\nexport function getHardenedBIP32NodeToken(index: number): HardenedBIP32Node {\n  validateBIP32Index(index);\n  return `${getUnhardenedBIP32NodeToken(index)}'`;\n}\n\n/**\n * An unhardened BIP-32 node token, e.g. `bip32:0`.\n * Validates that the index is a non-negative integer number, and throws an\n * error if validation fails.\n *\n * @param index - The index of the node.\n * @returns The unhardened BIP-32 node token.\n */\nexport function getUnhardenedBIP32NodeToken(\n  index: number,\n): UnhardenedBIP32Node {\n  validateBIP32Index(index);\n  return `bip32:${index}`;\n}\n\n/**\n * A hardened or unhardened BIP-32 node token, e.g. `bip32:0` or `bip32:0'`.\n * Validates that the index is a non-negative integer number, and throws an\n * error if validation fails.\n *\n * @param index - The index of the node.\n * @returns The hardened or unhardened BIP-32 node token.\n */\nexport function getBIP32NodeToken(index: BIP44PathIndex): BIP32Node {\n  if (typeof index === 'number') {\n    return getUnhardenedBIP32NodeToken(index);\n  }\n\n  if (\n    !index ||\n    !Number.isInteger(index.index) ||\n    typeof index.hardened !== 'boolean'\n  ) {\n    throw new Error(\n      'Invalid BIP-32 index: Must be an object containing the index and whether it is hardened.',\n    );\n  }\n\n  if (index.hardened) {\n    return getHardenedBIP32NodeToken(index.index);\n  }\n\n  return getUnhardenedBIP32NodeToken(index.index);\n}\n\n/**\n * Validates that the index is a non-negative integer number. Throws an\n * error if validation fails.\n *\n * @param addressIndex - The index to validate.\n */\nexport function validateBIP32Index(addressIndex: number) {\n  if (!isValidBIP32Index(addressIndex)) {\n    throw new Error(`Invalid BIP-32 index: Must be a non-negative integer.`);\n  }\n}\n\n/**\n * Check if the index is a valid BIP-32 index.\n *\n * @param index - The BIP-32 index to test.\n * @returns Whether the index is a non-negative integer number.\n */\nexport function isValidBIP32Index(index: number): boolean {\n  return isValidInteger(index) && index <= MAX_BIP_32_INDEX;\n}\n\n/**\n * Check if the value is a valid BIP-32 path segment, i.e., a string of the form\n * `0'`.\n *\n * @param segment - The BIP-32 path segment to test.\n * @returns Whether the path segment is a valid BIP-32 path segment.\n */\nexport function isValidBIP32PathSegment(\n  segment: string,\n): segment is UnprefixedNode {\n  if (typeof segment !== 'string') {\n    return false;\n  }\n\n  const match = segment.match(UNPREFIXED_BIP_32_PATH_REGEX);\n  if (typeof match?.groups?.index === 'undefined') {\n    return false;\n  }\n\n  const index = parseInt(match.groups.index, 10);\n  return isValidInteger(index) && index <= MAX_UNHARDENED_BIP_32_INDEX;\n}\n\n/**\n * Check if the value is a hardened BIP-32 index. This only checks if the value\n * ends with a `'` character, and does not validate that the index is a valid\n * BIP-32 index.\n *\n * @param bip32Token - The token to test.\n * @returns Whether the token is hardened, i.e. ends with `'`.\n */\nexport function isHardened(bip32Token: string): boolean {\n  return bip32Token.endsWith(`'`);\n}\n\n/**\n * Get a `Uint8Array` from a hexadecimal string or a `Uint8Array`. If the input\n * is a hexadecimal string, it is converted to a `Uint8Array`. If the input is\n * a `Uint8Array`, it is returned as-is.\n *\n * @param hexString - The hexadecimal string to convert.\n * @returns The `Uint8Array` corresponding to the hexadecimal string.\n */\nexport function hexStringToBytes(hexString: string | Uint8Array): Uint8Array {\n  if (hexString instanceof Uint8Array) {\n    return hexString;\n  }\n\n  return hexToBytes(hexString);\n}\n\n/**\n * The same as {@link hexStringToBytes}, but returns `undefined` if the input\n * is `undefined`.\n *\n * @param hexString - The hexadecimal string to convert.\n * @returns The `Uint8Array` corresponding to the hexadecimal string.\n */\nexport function nullableHexStringToBytes(\n  hexString?: string | Uint8Array,\n): Uint8Array | undefined {\n  if (hexString !== undefined) {\n    return hexStringToBytes(hexString);\n  }\n\n  return undefined;\n}\n\n/**\n * Tests whether the specified `Uint8Array` is a valid BIP-32 key.\n * A valid bytes key is 64 bytes long and has at least one non-zero byte.\n *\n * @param bytes - The `Uint8Array` to test.\n * @param expectedLength - The expected length of the Uint8Array.\n * @returns Whether the Uint8Array represents a valid BIP-32 key.\n */\nexport function isValidBytesKey(\n  bytes: Uint8Array,\n  expectedLength: number,\n): boolean {\n  if (bytes.length !== expectedLength) {\n    return false;\n  }\n\n  for (const byte of bytes) {\n    if (byte !== 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Tests whether the specified number is a valid integer equal to or greater than 0.\n *\n * @param value - The number to test.\n * @returns Whether the number is a valid integer.\n */\nexport function isValidInteger(value: unknown): value is number {\n  return typeof value === 'number' && Number.isInteger(value) && value >= 0;\n}\n\n/**\n * Get a `Uint8Array` from a hexadecimal string or `Uint8Array`. Validates that the\n * length of the `Uint8Array` matches the specified length, and that the `Uint8Array`\n * is not empty.\n *\n * @param value - The value to convert to a `Uint8Array`.\n * @param length - The length to validate the `Uint8Array` against.\n * @returns The `Uint8Array` corresponding to the hexadecimal string.\n */\nexport function getBytes(value: unknown, length: number): Uint8Array {\n  if (value instanceof Uint8Array) {\n    validateBytes(value, length);\n\n    return value;\n  }\n\n  if (typeof value === 'string') {\n    const bytes = hexToBytes(value);\n    validateBytes(bytes, length);\n\n    return bytes;\n  }\n\n  throw new Error(\n    `Invalid value: Expected an instance of Uint8Array or hexadecimal string.`,\n  );\n}\n\n/**\n * Get a `Uint8Array` from a hexadecimal string or `Uint8Array`. Validates that\n * the length of the `Uint8Array` matches the specified length.\n *\n * This function is \"unsafe,\" in the sense that it does not validate that the\n * `Uint8Array` is not empty (i.e., all bytes are zero).\n *\n * @param value - The value to convert to a `Uint8Array`.\n * @param length - The length to validate the `Uint8Array` against.\n * @returns The `Uint8Array` corresponding to the hexadecimal string.\n */\nexport function getBytesUnsafe(value: unknown, length: number): Uint8Array {\n  if (value instanceof Uint8Array) {\n    assert(\n      value.length === length,\n      `Invalid value: Must be a ${length}-byte byte array.`,\n    );\n    return value;\n  }\n\n  if (typeof value === 'string') {\n    return getBytesUnsafe(hexToBytes(value), length);\n  }\n\n  throw new Error(\n    `Invalid value: Expected an instance of Uint8Array or hexadecimal string.`,\n  );\n}\n\n/**\n * Validate that the specified `Uint8Array` is not empty and has the specified\n * length.\n *\n * @param bytes - The `Uint8Array` to validate.\n * @param length - The length to validate the `Uint8Array` against.\n * @throws An error if the `Uint8Array` is empty or has the wrong length.\n */\nfunction validateBytes(\n  bytes: Uint8Array,\n  length: number,\n): asserts bytes is Uint8Array {\n  if (!isValidBytesKey(bytes, length)) {\n    throw new Error(\n      `Invalid value: Must be a non-zero ${length}-byte byte array.`,\n    );\n  }\n}\n\nexport const decodeBase58check = (value: string): Uint8Array => {\n  const base58Check = scureBase58check(sha256);\n\n  try {\n    return base58Check.decode(value);\n  } catch {\n    throw new Error(\n      `Invalid extended key: Value is not base58-encoded, or the checksum is invalid.`,\n    );\n  }\n};\n\nexport const encodeBase58check = (value: Uint8Array): string => {\n  const base58Check = scureBase58check(sha256);\n\n  return base58Check.encode(value);\n};\n\n/**\n * Get the fingerprint of a compressed public key as number.\n *\n * @param publicKey - The compressed public key to get the fingerprint for.\n * @param compressedPublicKeyLength - The length of the compressed public key.\n * @returns The fingerprint of the public key.\n */\nexport const getFingerprint = (\n  publicKey: Uint8Array,\n  compressedPublicKeyLength: number,\n): number => {\n  if (!isValidBytesKey(publicKey, compressedPublicKeyLength)) {\n    throw new Error(\n      `Invalid public key: The key must be a ${compressedPublicKeyLength}-byte, non-zero byte array.`,\n    );\n  }\n\n  const bytes = ripemd160(sha256(publicKey));\n  const view = createDataView(bytes);\n\n  return view.getUint32(0, false);\n};\n\n/**\n * Get a secret recovery phrase (or mnemonic phrase) in string form as a\n * `Uint8Array`. The secret recovery phrase is split into words, and each word\n * is converted to a number using the BIP-39 word list. The numbers are then\n * converted to bytes, and the bytes are concatenated into a single\n * `Uint8Array`.\n *\n * @param mnemonicPhrase - The secret recovery phrase to convert.\n * @returns The `Uint8Array` corresponding to the secret recovery phrase.\n */\nexport function mnemonicPhraseToBytes(mnemonicPhrase: string): Uint8Array {\n  const words = mnemonicPhrase.split(' ');\n  const indices = words.map((word) => {\n    const index = englishWordlist.indexOf(word);\n    assert(index !== -1, `Invalid mnemonic phrase: Unknown word \"${word}\".`);\n\n    return index;\n  });\n\n  return new Uint8Array(new Uint16Array(indices).buffer);\n}\n\n/**\n * Validates the curve name.\n *\n * @param curveName - The name of the curve to validate.\n */\nexport function validateCurve(\n  curveName: unknown,\n): asserts curveName is SupportedCurve {\n  if (!curveName || typeof curveName !== 'string') {\n    throw new Error('Invalid curve: Must specify a curve.');\n  }\n\n  if (!Object.keys(curves).includes(curveName)) {\n    throw new Error(\n      `Invalid curve: Only the following curves are supported: ${Object.keys(\n        curves,\n      ).join(', ')}.`,\n    );\n  }\n}\n\n/**\n * Get a 4-byte-long `Uint8Array` from a numeric value.\n *\n * @param value - The value to convert to a `Uint8Array`.\n * @param littleEndian - Whether to use little endian byte order.\n * @returns The `Uint8Array` corresponding to the `bigint` value.\n */\nexport function numberToUint32(value: number, littleEndian = false) {\n  const bytes = new Uint8Array(4);\n  const view = createDataView(bytes);\n\n  view.setUint32(0, value, littleEndian);\n\n  return bytes;\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"utils.cjs","sourceRoot":"","sources":["../src/utils.ts"],"names":[],"mappings":"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","sourcesContent":["import { wordlist as englishWordlist } from '@metamask/scure-bip39/dist/wordlists/english';\nimport { assert, createDataView, hexToBytes } from '@metamask/utils';\nimport { base58check as scureBase58check } from '@scure/base';\n\nimport type {\n  BIP32Node,\n  ChangeHDPathString,\n  CoinTypeHDPathString,\n  CoinTypeToAddressTuple,\n  HardenedBIP32Node,\n  UnhardenedBIP32Node,\n  UnprefixedNode,\n} from './constants';\nimport {\n  BIP44PurposeNodeToken,\n  MAX_BIP_32_INDEX,\n  MAX_UNHARDENED_BIP_32_INDEX,\n  UNPREFIXED_BIP_32_PATH_REGEX,\n} from './constants';\nimport { ripemd160, sha256 } from './cryptography';\nimport type { SupportedCurve } from './curves';\nimport { curves } from './curves';\n\n/**\n * Gets a string representation of a BIP-44 path of depth 2, i.e.:\n * `m / 44' / coin_type'`\n *\n * For display purposes only.\n *\n * @param coin_type - The `coin_type` index to create a path visualization for.\n * @returns The visualization of the BIP-44 path for thte specified `coin_type`.\n */\nexport function getBIP44CoinTypePathString(\n  coin_type: number,\n): CoinTypeHDPathString {\n  return `m / ${BIP44PurposeNodeToken} / ${getHardenedBIP32NodeToken(\n    coin_type,\n  )}`;\n}\n\ntype BIP44PathIndex = number | { index: number; hardened: boolean };\n\ntype BIP44PathIndices = {\n  coin_type: number;\n  account?: number;\n  change?: BIP44PathIndex;\n  address_index: BIP44PathIndex;\n};\n\nexport type CoinTypeToAddressIndices = Pick<\n  BIP44PathIndices,\n  'account' | 'change' | 'address_index'\n>;\n\n/**\n * Gets a string representation of a BIP-44 path of depth 4, i.e.:\n * `m / 44' / coin_type' / account' / change`\n *\n * For display purposes only.\n *\n * @param coinTypePath - The parent `coin_type` path.\n * @param indices - The `account` and `change` index to create a path visualization for.\n * @returns The visualization of the BIP-44 path for the specified `coin_type`\n * and `change` indices.\n */\nexport function getBIP44ChangePathString(\n  coinTypePath: CoinTypeHDPathString,\n  indices: Omit<CoinTypeToAddressIndices, 'address_index'>,\n): ChangeHDPathString {\n  return `${coinTypePath} / ${getHardenedBIP32NodeToken(\n    indices.account ?? 0,\n  )} / ${getBIP32NodeToken(indices.change ?? 0)}`;\n}\n\n/**\n * Gets a BIP-44 path tuple of the form `account' / change / address_index`,\n * which can be used to derive address keys together with a `coin_type` key.\n *\n * @param indices - The BIP-44 derivation index values.\n * @param indices.account - The `account` index value.\n * @param indices.change - The `change` index value.\n * @param indices.address_index - The `address_index` index value.\n * @returns The `account' / change / address_index` path corresponding to the\n * specified indices.\n */\nexport function getBIP44CoinTypeToAddressPathTuple({\n  account = 0,\n  change = 0,\n  address_index,\n}: CoinTypeToAddressIndices): CoinTypeToAddressTuple {\n  return [\n    getHardenedBIP32NodeToken(account),\n    getBIP32NodeToken(change),\n    getBIP32NodeToken(address_index),\n  ] as const;\n}\n\n/**\n * A hardened BIP-32 node token, e.g. `bip32:0'`.\n * Validates that the index is a non-negative integer number, and throws an\n * error if validation fails.\n *\n * @param index - The index of the node.\n * @returns The hardened BIP-32 node token.\n */\nexport function getHardenedBIP32NodeToken(index: number): HardenedBIP32Node {\n  validateBIP32Index(index);\n  return `${getUnhardenedBIP32NodeToken(index)}'`;\n}\n\n/**\n * An unhardened BIP-32 node token, e.g. `bip32:0`.\n * Validates that the index is a non-negative integer number, and throws an\n * error if validation fails.\n *\n * @param index - The index of the node.\n * @returns The unhardened BIP-32 node token.\n */\nexport function getUnhardenedBIP32NodeToken(\n  index: number,\n): UnhardenedBIP32Node {\n  validateBIP32Index(index);\n  return `bip32:${index}`;\n}\n\n/**\n * A hardened or unhardened BIP-32 node token, e.g. `bip32:0` or `bip32:0'`.\n * Validates that the index is a non-negative integer number, and throws an\n * error if validation fails.\n *\n * @param index - The index of the node.\n * @returns The hardened or unhardened BIP-32 node token.\n */\nexport function getBIP32NodeToken(index: BIP44PathIndex): BIP32Node {\n  if (typeof index === 'number') {\n    return getUnhardenedBIP32NodeToken(index);\n  }\n\n  if (\n    !index ||\n    !Number.isInteger(index.index) ||\n    typeof index.hardened !== 'boolean'\n  ) {\n    throw new Error(\n      'Invalid BIP-32 index: Must be an object containing the index and whether it is hardened.',\n    );\n  }\n\n  if (index.hardened) {\n    return getHardenedBIP32NodeToken(index.index);\n  }\n\n  return getUnhardenedBIP32NodeToken(index.index);\n}\n\n/**\n * Validates that the index is a non-negative integer number. Throws an\n * error if validation fails.\n *\n * @param addressIndex - The index to validate.\n */\nexport function validateBIP32Index(addressIndex: number): void {\n  if (!isValidBIP32Index(addressIndex)) {\n    throw new Error(`Invalid BIP-32 index: Must be a non-negative integer.`);\n  }\n}\n\n/**\n * Check if the index is a valid BIP-32 index.\n *\n * @param index - The BIP-32 index to test.\n * @returns Whether the index is a non-negative integer number.\n */\nexport function isValidBIP32Index(index: number): boolean {\n  return isValidInteger(index) && index <= MAX_BIP_32_INDEX;\n}\n\n/**\n * Check if the value is a valid BIP-32 path segment, i.e., a string of the form\n * `0'`.\n *\n * @param segment - The BIP-32 path segment to test.\n * @returns Whether the path segment is a valid BIP-32 path segment.\n */\nexport function isValidBIP32PathSegment(\n  segment: string,\n): segment is UnprefixedNode {\n  if (typeof segment !== 'string') {\n    return false;\n  }\n\n  const match = segment.match(UNPREFIXED_BIP_32_PATH_REGEX);\n  if (typeof match?.groups?.index === 'undefined') {\n    return false;\n  }\n\n  const index = parseInt(match.groups.index, 10);\n  return isValidInteger(index) && index <= MAX_UNHARDENED_BIP_32_INDEX;\n}\n\n/**\n * Check if the value is a hardened BIP-32 index. This only checks if the value\n * ends with a `'` character, and does not validate that the index is a valid\n * BIP-32 index.\n *\n * @param bip32Token - The token to test.\n * @returns Whether the token is hardened, i.e. ends with `'`.\n */\nexport function isHardened(bip32Token: string): boolean {\n  return bip32Token.endsWith(`'`);\n}\n\n/**\n * Get a `Uint8Array` from a hexadecimal string or a `Uint8Array`. If the input\n * is a hexadecimal string, it is converted to a `Uint8Array`. If the input is\n * a `Uint8Array`, it is returned as-is.\n *\n * @param hexString - The hexadecimal string to convert.\n * @returns The `Uint8Array` corresponding to the hexadecimal string.\n */\nexport function hexStringToBytes(hexString: string | Uint8Array): Uint8Array {\n  if (hexString instanceof Uint8Array) {\n    return hexString;\n  }\n\n  return hexToBytes(hexString);\n}\n\n/**\n * The same as {@link hexStringToBytes}, but returns `undefined` if the input\n * is `undefined`.\n *\n * @param hexString - The hexadecimal string to convert.\n * @returns The `Uint8Array` corresponding to the hexadecimal string.\n */\nexport function nullableHexStringToBytes(\n  hexString?: string | Uint8Array,\n): Uint8Array | undefined {\n  if (hexString !== undefined) {\n    return hexStringToBytes(hexString);\n  }\n\n  return undefined;\n}\n\n/**\n * Tests whether the specified `Uint8Array` is a valid BIP-32 key.\n * A valid bytes key is 64 bytes long and has at least one non-zero byte.\n *\n * @param bytes - The `Uint8Array` to test.\n * @param expectedLength - The expected length of the Uint8Array.\n * @returns Whether the Uint8Array represents a valid BIP-32 key.\n */\nexport function isValidBytesKey(\n  bytes: Uint8Array,\n  expectedLength: number,\n): boolean {\n  if (bytes.length !== expectedLength) {\n    return false;\n  }\n\n  for (const byte of bytes) {\n    if (byte !== 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Tests whether the specified number is a valid integer equal to or greater than 0.\n *\n * @param value - The number to test.\n * @returns Whether the number is a valid integer.\n */\nexport function isValidInteger(value: unknown): value is number {\n  return typeof value === 'number' && Number.isInteger(value) && value >= 0;\n}\n\n/**\n * Get a `Uint8Array` from a hexadecimal string or `Uint8Array`. Validates that the\n * length of the `Uint8Array` matches the specified length, and that the `Uint8Array`\n * is not empty.\n *\n * @param value - The value to convert to a `Uint8Array`.\n * @param length - The length to validate the `Uint8Array` against.\n * @returns The `Uint8Array` corresponding to the hexadecimal string.\n */\nexport function getBytes(value: unknown, length: number): Uint8Array {\n  if (value instanceof Uint8Array) {\n    validateBytes(value, length);\n\n    return value;\n  }\n\n  if (typeof value === 'string') {\n    const bytes = hexToBytes(value);\n    validateBytes(bytes, length);\n\n    return bytes;\n  }\n\n  throw new Error(\n    `Invalid value: Expected an instance of Uint8Array or hexadecimal string.`,\n  );\n}\n\n/**\n * Get a `Uint8Array` from a hexadecimal string or `Uint8Array`. Validates that\n * the length of the `Uint8Array` matches the specified length.\n *\n * This function is \"unsafe,\" in the sense that it does not validate that the\n * `Uint8Array` is not empty (i.e., all bytes are zero).\n *\n * @param value - The value to convert to a `Uint8Array`.\n * @param length - The length to validate the `Uint8Array` against.\n * @returns The `Uint8Array` corresponding to the hexadecimal string.\n */\nexport function getBytesUnsafe(value: unknown, length: number): Uint8Array {\n  if (value instanceof Uint8Array) {\n    assert(\n      value.length === length,\n      `Invalid value: Must be a ${length}-byte byte array.`,\n    );\n    return value;\n  }\n\n  if (typeof value === 'string') {\n    return getBytesUnsafe(hexToBytes(value), length);\n  }\n\n  throw new Error(\n    `Invalid value: Expected an instance of Uint8Array or hexadecimal string.`,\n  );\n}\n\n/**\n * Validate that the specified `Uint8Array` is not empty and has the specified\n * length.\n *\n * @param bytes - The `Uint8Array` to validate.\n * @param length - The length to validate the `Uint8Array` against.\n * @throws An error if the `Uint8Array` is empty or has the wrong length.\n */\nfunction validateBytes(\n  bytes: Uint8Array,\n  length: number,\n): asserts bytes is Uint8Array {\n  if (!isValidBytesKey(bytes, length)) {\n    throw new Error(\n      `Invalid value: Must be a non-zero ${length}-byte byte array.`,\n    );\n  }\n}\n\nexport const decodeBase58check = (value: string): Uint8Array => {\n  const base58Check = scureBase58check(sha256);\n\n  try {\n    return base58Check.decode(value);\n  } catch {\n    throw new Error(\n      `Invalid extended key: Value is not base58-encoded, or the checksum is invalid.`,\n    );\n  }\n};\n\nexport const encodeBase58check = (value: Uint8Array): string => {\n  const base58Check = scureBase58check(sha256);\n\n  return base58Check.encode(value);\n};\n\n/**\n * Get the fingerprint of a compressed public key as number.\n *\n * @param publicKey - The compressed public key to get the fingerprint for.\n * @param compressedPublicKeyLength - The length of the compressed public key.\n * @returns The fingerprint of the public key.\n */\nexport const getFingerprint = (\n  publicKey: Uint8Array,\n  compressedPublicKeyLength: number,\n): number => {\n  if (!isValidBytesKey(publicKey, compressedPublicKeyLength)) {\n    throw new Error(\n      `Invalid public key: The key must be a ${compressedPublicKeyLength}-byte, non-zero byte array.`,\n    );\n  }\n\n  const bytes = ripemd160(sha256(publicKey));\n  const view = createDataView(bytes);\n\n  return view.getUint32(0, false);\n};\n\n/**\n * Get a secret recovery phrase (or mnemonic phrase) in string form as a\n * `Uint8Array`. The secret recovery phrase is split into words, and each word\n * is converted to a number using the BIP-39 word list. The numbers are then\n * converted to bytes, and the bytes are concatenated into a single\n * `Uint8Array`.\n *\n * @param mnemonicPhrase - The secret recovery phrase to convert.\n * @returns The `Uint8Array` corresponding to the secret recovery phrase.\n */\nexport function mnemonicPhraseToBytes(mnemonicPhrase: string): Uint8Array {\n  const words = mnemonicPhrase.split(' ');\n  const indices = words.map((word) => {\n    const index = englishWordlist.indexOf(word);\n    assert(index !== -1, `Invalid mnemonic phrase: Unknown word \"${word}\".`);\n\n    return index;\n  });\n\n  return new Uint8Array(new Uint16Array(indices).buffer);\n}\n\n/**\n * Validates the curve name.\n *\n * @param curveName - The name of the curve to validate.\n */\nexport function validateCurve(\n  curveName: unknown,\n): asserts curveName is SupportedCurve {\n  if (!curveName || typeof curveName !== 'string') {\n    throw new Error('Invalid curve: Must specify a curve.');\n  }\n\n  if (!Object.keys(curves).includes(curveName)) {\n    throw new Error(\n      `Invalid curve: Only the following curves are supported: ${Object.keys(\n        curves,\n      ).join(', ')}.`,\n    );\n  }\n}\n\n/**\n * Get a 4-byte-long `Uint8Array` from a numeric value.\n *\n * @param value - The value to convert to a `Uint8Array`.\n * @param littleEndian - Whether to use little endian byte order.\n * @returns The `Uint8Array` corresponding to the `bigint` value.\n */\nexport function numberToUint32(\n  value: number,\n  littleEndian = false,\n): Uint8Array {\n  const bytes = new Uint8Array(4);\n  const view = createDataView(bytes);\n\n  view.setUint32(0, value, littleEndian);\n\n  return bytes;\n}\n\n/**\n * A utility function to check if the Web Crypto API is supported in the current\n * environment.\n *\n * @returns Whether the Web Crypto API is supported.\n */\nexport function isWebCryptoSupported(): boolean {\n  return Boolean(globalThis.crypto?.subtle);\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/utils.d.cts b/node_modules/@metamask/key-tree/dist/utils.d.cts
index aa47c03..c3014dc 100644
--- a/node_modules/@metamask/key-tree/dist/utils.d.cts
+++ b/node_modules/@metamask/key-tree/dist/utils.d.cts
@@ -10,17 +10,17 @@ import type { SupportedCurve } from "./curves/index.cjs";
  * @returns The visualization of the BIP-44 path for thte specified `coin_type`.
  */
 export declare function getBIP44CoinTypePathString(coin_type: number): CoinTypeHDPathString;
-declare type BIP44PathIndex = number | {
+type BIP44PathIndex = number | {
     index: number;
     hardened: boolean;
 };
-declare type BIP44PathIndices = {
+type BIP44PathIndices = {
     coin_type: number;
     account?: number;
     change?: BIP44PathIndex;
     address_index: BIP44PathIndex;
 };
-export declare type CoinTypeToAddressIndices = Pick<BIP44PathIndices, 'account' | 'change' | 'address_index'>;
+export type CoinTypeToAddressIndices = Pick<BIP44PathIndices, 'account' | 'change' | 'address_index'>;
 /**
  * Gets a string representation of a BIP-44 path of depth 4, i.e.:
  * `m / 44' / coin_type' / account' / change`
@@ -193,5 +193,12 @@ export declare function validateCurve(curveName: unknown): asserts curveName is
  * @returns The `Uint8Array` corresponding to the `bigint` value.
  */
 export declare function numberToUint32(value: number, littleEndian?: boolean): Uint8Array;
+/**
+ * A utility function to check if the Web Crypto API is supported in the current
+ * environment.
+ *
+ * @returns Whether the Web Crypto API is supported.
+ */
+export declare function isWebCryptoSupported(): boolean;
 export {};
 //# sourceMappingURL=utils.d.cts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/utils.d.cts.map b/node_modules/@metamask/key-tree/dist/utils.d.cts.map
index 4c5c803..8fb6eb0 100644
--- a/node_modules/@metamask/key-tree/dist/utils.d.cts.map
+++ b/node_modules/@metamask/key-tree/dist/utils.d.cts.map
@@ -1 +1 @@
-{"version":3,"file":"utils.d.cts","sourceRoot":"","sources":["../src/utils.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"utils.d.cts","sourceRoot":"","sources":["../src/utils.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/utils.d.mts b/node_modules/@metamask/key-tree/dist/utils.d.mts
index 87b2128..34474fd 100644
--- a/node_modules/@metamask/key-tree/dist/utils.d.mts
+++ b/node_modules/@metamask/key-tree/dist/utils.d.mts
@@ -10,17 +10,17 @@ import type { SupportedCurve } from "./curves/index.mjs";
  * @returns The visualization of the BIP-44 path for thte specified `coin_type`.
  */
 export declare function getBIP44CoinTypePathString(coin_type: number): CoinTypeHDPathString;
-declare type BIP44PathIndex = number | {
+type BIP44PathIndex = number | {
     index: number;
     hardened: boolean;
 };
-declare type BIP44PathIndices = {
+type BIP44PathIndices = {
     coin_type: number;
     account?: number;
     change?: BIP44PathIndex;
     address_index: BIP44PathIndex;
 };
-export declare type CoinTypeToAddressIndices = Pick<BIP44PathIndices, 'account' | 'change' | 'address_index'>;
+export type CoinTypeToAddressIndices = Pick<BIP44PathIndices, 'account' | 'change' | 'address_index'>;
 /**
  * Gets a string representation of a BIP-44 path of depth 4, i.e.:
  * `m / 44' / coin_type' / account' / change`
@@ -193,5 +193,12 @@ export declare function validateCurve(curveName: unknown): asserts curveName is
  * @returns The `Uint8Array` corresponding to the `bigint` value.
  */
 export declare function numberToUint32(value: number, littleEndian?: boolean): Uint8Array;
+/**
+ * A utility function to check if the Web Crypto API is supported in the current
+ * environment.
+ *
+ * @returns Whether the Web Crypto API is supported.
+ */
+export declare function isWebCryptoSupported(): boolean;
 export {};
 //# sourceMappingURL=utils.d.mts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/utils.d.mts.map b/node_modules/@metamask/key-tree/dist/utils.d.mts.map
index bdac9aa..6665829 100644
--- a/node_modules/@metamask/key-tree/dist/utils.d.mts.map
+++ b/node_modules/@metamask/key-tree/dist/utils.d.mts.map
@@ -1 +1 @@
-{"version":3,"file":"utils.d.mts","sourceRoot":"","sources":["../src/utils.ts"],"names":[],"mappings":"AAMA,OAAO,KAAK,EACV,SAAS,EACT,kBAAkB,EAClB,oBAAoB,EACpB,sBAAsB,EACtB,iBAAiB,EACjB,mBAAmB,EACnB,cAAc,EACf,wBAAoB;AAOrB,OAAO,KAAK,EAAE,cAAc,EAAE,2BAAiB;AAG/C;;;;;;;;GAQG;AACH,wBAAgB,0BAA0B,CACxC,SAAS,EAAE,MAAM,GAChB,oBAAoB,CAItB;AAED,aAAK,cAAc,GAAG,MAAM,GAAG;IAAE,KAAK,EAAE,MAAM,CAAC;IAAC,QAAQ,EAAE,OAAO,CAAA;CAAE,CAAC;AAEpE,aAAK,gBAAgB,GAAG;IACtB,SAAS,EAAE,MAAM,CAAC;IAClB,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB,MAAM,CAAC,EAAE,cAAc,CAAC;IACxB,aAAa,EAAE,cAAc,CAAC;CAC/B,CAAC;AAEF,oBAAY,wBAAwB,GAAG,IAAI,CACzC,gBAAgB,EAChB,SAAS,GAAG,QAAQ,GAAG,eAAe,CACvC,CAAC;AAEF;;;;;;;;;;GAUG;AACH,wBAAgB,wBAAwB,CACtC,YAAY,EAAE,oBAAoB,EAClC,OAAO,EAAE,IAAI,CAAC,wBAAwB,EAAE,eAAe,CAAC,GACvD,kBAAkB,CAIpB;AAED;;;;;;;;;;GAUG;AACH,wBAAgB,kCAAkC,CAAC,EACjD,OAAW,EACX,MAAU,EACV,aAAa,GACd,EAAE,wBAAwB,GAAG,sBAAsB,CAMnD;AAED;;;;;;;GAOG;AACH,wBAAgB,yBAAyB,CAAC,KAAK,EAAE,MAAM,GAAG,iBAAiB,CAG1E;AAED;;;;;;;GAOG;AACH,wBAAgB,2BAA2B,CACzC,KAAK,EAAE,MAAM,GACZ,mBAAmB,CAGrB;AAED;;;;;;;GAOG;AACH,wBAAgB,iBAAiB,CAAC,KAAK,EAAE,cAAc,GAAG,SAAS,CAoBlE;AAED;;;;;GAKG;AACH,wBAAgB,kBAAkB,CAAC,YAAY,EAAE,MAAM,QAItD;AAED;;;;;GAKG;AACH,wBAAgB,iBAAiB,CAAC,KAAK,EAAE,MAAM,GAAG,OAAO,CAExD;AAED;;;;;;GAMG;AACH,wBAAgB,uBAAuB,CACrC,OAAO,EAAE,MAAM,GACd,OAAO,IAAI,cAAc,CAY3B;AAED;;;;;;;GAOG;AACH,wBAAgB,UAAU,CAAC,UAAU,EAAE,MAAM,GAAG,OAAO,CAEtD;AAED;;;;;;;GAOG;AACH,wBAAgB,gBAAgB,CAAC,SAAS,EAAE,MAAM,GAAG,UAAU,GAAG,UAAU,CAM3E;AAED;;;;;;GAMG;AACH,wBAAgB,wBAAwB,CACtC,SAAS,CAAC,EAAE,MAAM,GAAG,UAAU,GAC9B,UAAU,GAAG,SAAS,CAMxB;AAED;;;;;;;GAOG;AACH,wBAAgB,eAAe,CAC7B,KAAK,EAAE,UAAU,EACjB,cAAc,EAAE,MAAM,GACrB,OAAO,CAWT;AAED;;;;;GAKG;AACH,wBAAgB,cAAc,CAAC,KAAK,EAAE,OAAO,GAAG,KAAK,IAAI,MAAM,CAE9D;AAED;;;;;;;;GAQG;AACH,wBAAgB,QAAQ,CAAC,KAAK,EAAE,OAAO,EAAE,MAAM,EAAE,MAAM,GAAG,UAAU,CAiBnE;AAED;;;;;;;;;;GAUG;AACH,wBAAgB,cAAc,CAAC,KAAK,EAAE,OAAO,EAAE,MAAM,EAAE,MAAM,GAAG,UAAU,CAgBzE;AAqBD,eAAO,MAAM,iBAAiB,UAAW,MAAM,KAAG,UAUjD,CAAC;AAEF,eAAO,MAAM,iBAAiB,UAAW,UAAU,KAAG,MAIrD,CAAC;AAEF;;;;;;GAMG;AACH,eAAO,MAAM,cAAc,cACd,UAAU,6BACM,MAAM,KAChC,MAWF,CAAC;AAEF;;;;;;;;;GASG;AACH,wBAAgB,qBAAqB,CAAC,cAAc,EAAE,MAAM,GAAG,UAAU,CAUxE;AAED;;;;GAIG;AACH,wBAAgB,aAAa,CAC3B,SAAS,EAAE,OAAO,GACjB,OAAO,CAAC,SAAS,IAAI,cAAc,CAYrC;AAED;;;;;;GAMG;AACH,wBAAgB,cAAc,CAAC,KAAK,EAAE,MAAM,EAAE,YAAY,UAAQ,cAOjE"}
\ No newline at end of file
+{"version":3,"file":"utils.d.mts","sourceRoot":"","sources":["../src/utils.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/utils.mjs b/node_modules/@metamask/key-tree/dist/utils.mjs
index c572f7f..852bba8 100644
--- a/node_modules/@metamask/key-tree/dist/utils.mjs
+++ b/node_modules/@metamask/key-tree/dist/utils.mjs
@@ -1,9 +1,8 @@
 import { wordlist as englishWordlist } from "@metamask/scure-bip39/dist/wordlists/english.js";
 import { assert, createDataView, hexToBytes } from "@metamask/utils";
-import { ripemd160 } from "@noble/hashes/ripemd160";
-import { sha256 } from "@noble/hashes/sha256";
 import { base58check as scureBase58check } from "@scure/base";
 import { BIP44PurposeNodeToken, MAX_BIP_32_INDEX, MAX_UNHARDENED_BIP_32_INDEX, UNPREFIXED_BIP_32_PATH_REGEX } from "./constants.mjs";
+import { ripemd160, sha256 } from "./cryptography.mjs";
 import { curves } from "./curves/index.mjs";
 /**
  * Gets a string representation of a BIP-44 path of depth 2, i.e.:
@@ -327,4 +326,13 @@ export function numberToUint32(value, littleEndian = false) {
     view.setUint32(0, value, littleEndian);
     return bytes;
 }
+/**
+ * A utility function to check if the Web Crypto API is supported in the current
+ * environment.
+ *
+ * @returns Whether the Web Crypto API is supported.
+ */
+export function isWebCryptoSupported() {
+    return Boolean(globalThis.crypto?.subtle);
+}
 //# sourceMappingURL=utils.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/key-tree/dist/utils.mjs.map b/node_modules/@metamask/key-tree/dist/utils.mjs.map
index 21c17dc..698968c 100644
--- a/node_modules/@metamask/key-tree/dist/utils.mjs.map
+++ b/node_modules/@metamask/key-tree/dist/utils.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"utils.mjs","sourceRoot":"","sources":["../src/utils.ts"],"names":[],"mappings":"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","sourcesContent":["import { wordlist as englishWordlist } from '@metamask/scure-bip39/dist/wordlists/english';\nimport { assert, createDataView, hexToBytes } from '@metamask/utils';\nimport { ripemd160 } from '@noble/hashes/ripemd160';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { base58check as scureBase58check } from '@scure/base';\n\nimport type {\n  BIP32Node,\n  ChangeHDPathString,\n  CoinTypeHDPathString,\n  CoinTypeToAddressTuple,\n  HardenedBIP32Node,\n  UnhardenedBIP32Node,\n  UnprefixedNode,\n} from './constants';\nimport {\n  BIP44PurposeNodeToken,\n  MAX_BIP_32_INDEX,\n  MAX_UNHARDENED_BIP_32_INDEX,\n  UNPREFIXED_BIP_32_PATH_REGEX,\n} from './constants';\nimport type { SupportedCurve } from './curves';\nimport { curves } from './curves';\n\n/**\n * Gets a string representation of a BIP-44 path of depth 2, i.e.:\n * `m / 44' / coin_type'`\n *\n * For display purposes only.\n *\n * @param coin_type - The `coin_type` index to create a path visualization for.\n * @returns The visualization of the BIP-44 path for thte specified `coin_type`.\n */\nexport function getBIP44CoinTypePathString(\n  coin_type: number,\n): CoinTypeHDPathString {\n  return `m / ${BIP44PurposeNodeToken} / ${getHardenedBIP32NodeToken(\n    coin_type,\n  )}`;\n}\n\ntype BIP44PathIndex = number | { index: number; hardened: boolean };\n\ntype BIP44PathIndices = {\n  coin_type: number;\n  account?: number;\n  change?: BIP44PathIndex;\n  address_index: BIP44PathIndex;\n};\n\nexport type CoinTypeToAddressIndices = Pick<\n  BIP44PathIndices,\n  'account' | 'change' | 'address_index'\n>;\n\n/**\n * Gets a string representation of a BIP-44 path of depth 4, i.e.:\n * `m / 44' / coin_type' / account' / change`\n *\n * For display purposes only.\n *\n * @param coinTypePath - The parent `coin_type` path.\n * @param indices - The `account` and `change` index to create a path visualization for.\n * @returns The visualization of the BIP-44 path for the specified `coin_type`\n * and `change` indices.\n */\nexport function getBIP44ChangePathString(\n  coinTypePath: CoinTypeHDPathString,\n  indices: Omit<CoinTypeToAddressIndices, 'address_index'>,\n): ChangeHDPathString {\n  return `${coinTypePath} / ${getHardenedBIP32NodeToken(\n    indices.account ?? 0,\n  )} / ${getBIP32NodeToken(indices.change ?? 0)}`;\n}\n\n/**\n * Gets a BIP-44 path tuple of the form `account' / change / address_index`,\n * which can be used to derive address keys together with a `coin_type` key.\n *\n * @param indices - The BIP-44 derivation index values.\n * @param indices.account - The `account` index value.\n * @param indices.change - The `change` index value.\n * @param indices.address_index - The `address_index` index value.\n * @returns The `account' / change / address_index` path corresponding to the\n * specified indices.\n */\nexport function getBIP44CoinTypeToAddressPathTuple({\n  account = 0,\n  change = 0,\n  address_index,\n}: CoinTypeToAddressIndices): CoinTypeToAddressTuple {\n  return [\n    getHardenedBIP32NodeToken(account),\n    getBIP32NodeToken(change),\n    getBIP32NodeToken(address_index),\n  ] as const;\n}\n\n/**\n * A hardened BIP-32 node token, e.g. `bip32:0'`.\n * Validates that the index is a non-negative integer number, and throws an\n * error if validation fails.\n *\n * @param index - The index of the node.\n * @returns The hardened BIP-32 node token.\n */\nexport function getHardenedBIP32NodeToken(index: number): HardenedBIP32Node {\n  validateBIP32Index(index);\n  return `${getUnhardenedBIP32NodeToken(index)}'`;\n}\n\n/**\n * An unhardened BIP-32 node token, e.g. `bip32:0`.\n * Validates that the index is a non-negative integer number, and throws an\n * error if validation fails.\n *\n * @param index - The index of the node.\n * @returns The unhardened BIP-32 node token.\n */\nexport function getUnhardenedBIP32NodeToken(\n  index: number,\n): UnhardenedBIP32Node {\n  validateBIP32Index(index);\n  return `bip32:${index}`;\n}\n\n/**\n * A hardened or unhardened BIP-32 node token, e.g. `bip32:0` or `bip32:0'`.\n * Validates that the index is a non-negative integer number, and throws an\n * error if validation fails.\n *\n * @param index - The index of the node.\n * @returns The hardened or unhardened BIP-32 node token.\n */\nexport function getBIP32NodeToken(index: BIP44PathIndex): BIP32Node {\n  if (typeof index === 'number') {\n    return getUnhardenedBIP32NodeToken(index);\n  }\n\n  if (\n    !index ||\n    !Number.isInteger(index.index) ||\n    typeof index.hardened !== 'boolean'\n  ) {\n    throw new Error(\n      'Invalid BIP-32 index: Must be an object containing the index and whether it is hardened.',\n    );\n  }\n\n  if (index.hardened) {\n    return getHardenedBIP32NodeToken(index.index);\n  }\n\n  return getUnhardenedBIP32NodeToken(index.index);\n}\n\n/**\n * Validates that the index is a non-negative integer number. Throws an\n * error if validation fails.\n *\n * @param addressIndex - The index to validate.\n */\nexport function validateBIP32Index(addressIndex: number) {\n  if (!isValidBIP32Index(addressIndex)) {\n    throw new Error(`Invalid BIP-32 index: Must be a non-negative integer.`);\n  }\n}\n\n/**\n * Check if the index is a valid BIP-32 index.\n *\n * @param index - The BIP-32 index to test.\n * @returns Whether the index is a non-negative integer number.\n */\nexport function isValidBIP32Index(index: number): boolean {\n  return isValidInteger(index) && index <= MAX_BIP_32_INDEX;\n}\n\n/**\n * Check if the value is a valid BIP-32 path segment, i.e., a string of the form\n * `0'`.\n *\n * @param segment - The BIP-32 path segment to test.\n * @returns Whether the path segment is a valid BIP-32 path segment.\n */\nexport function isValidBIP32PathSegment(\n  segment: string,\n): segment is UnprefixedNode {\n  if (typeof segment !== 'string') {\n    return false;\n  }\n\n  const match = segment.match(UNPREFIXED_BIP_32_PATH_REGEX);\n  if (typeof match?.groups?.index === 'undefined') {\n    return false;\n  }\n\n  const index = parseInt(match.groups.index, 10);\n  return isValidInteger(index) && index <= MAX_UNHARDENED_BIP_32_INDEX;\n}\n\n/**\n * Check if the value is a hardened BIP-32 index. This only checks if the value\n * ends with a `'` character, and does not validate that the index is a valid\n * BIP-32 index.\n *\n * @param bip32Token - The token to test.\n * @returns Whether the token is hardened, i.e. ends with `'`.\n */\nexport function isHardened(bip32Token: string): boolean {\n  return bip32Token.endsWith(`'`);\n}\n\n/**\n * Get a `Uint8Array` from a hexadecimal string or a `Uint8Array`. If the input\n * is a hexadecimal string, it is converted to a `Uint8Array`. If the input is\n * a `Uint8Array`, it is returned as-is.\n *\n * @param hexString - The hexadecimal string to convert.\n * @returns The `Uint8Array` corresponding to the hexadecimal string.\n */\nexport function hexStringToBytes(hexString: string | Uint8Array): Uint8Array {\n  if (hexString instanceof Uint8Array) {\n    return hexString;\n  }\n\n  return hexToBytes(hexString);\n}\n\n/**\n * The same as {@link hexStringToBytes}, but returns `undefined` if the input\n * is `undefined`.\n *\n * @param hexString - The hexadecimal string to convert.\n * @returns The `Uint8Array` corresponding to the hexadecimal string.\n */\nexport function nullableHexStringToBytes(\n  hexString?: string | Uint8Array,\n): Uint8Array | undefined {\n  if (hexString !== undefined) {\n    return hexStringToBytes(hexString);\n  }\n\n  return undefined;\n}\n\n/**\n * Tests whether the specified `Uint8Array` is a valid BIP-32 key.\n * A valid bytes key is 64 bytes long and has at least one non-zero byte.\n *\n * @param bytes - The `Uint8Array` to test.\n * @param expectedLength - The expected length of the Uint8Array.\n * @returns Whether the Uint8Array represents a valid BIP-32 key.\n */\nexport function isValidBytesKey(\n  bytes: Uint8Array,\n  expectedLength: number,\n): boolean {\n  if (bytes.length !== expectedLength) {\n    return false;\n  }\n\n  for (const byte of bytes) {\n    if (byte !== 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Tests whether the specified number is a valid integer equal to or greater than 0.\n *\n * @param value - The number to test.\n * @returns Whether the number is a valid integer.\n */\nexport function isValidInteger(value: unknown): value is number {\n  return typeof value === 'number' && Number.isInteger(value) && value >= 0;\n}\n\n/**\n * Get a `Uint8Array` from a hexadecimal string or `Uint8Array`. Validates that the\n * length of the `Uint8Array` matches the specified length, and that the `Uint8Array`\n * is not empty.\n *\n * @param value - The value to convert to a `Uint8Array`.\n * @param length - The length to validate the `Uint8Array` against.\n * @returns The `Uint8Array` corresponding to the hexadecimal string.\n */\nexport function getBytes(value: unknown, length: number): Uint8Array {\n  if (value instanceof Uint8Array) {\n    validateBytes(value, length);\n\n    return value;\n  }\n\n  if (typeof value === 'string') {\n    const bytes = hexToBytes(value);\n    validateBytes(bytes, length);\n\n    return bytes;\n  }\n\n  throw new Error(\n    `Invalid value: Expected an instance of Uint8Array or hexadecimal string.`,\n  );\n}\n\n/**\n * Get a `Uint8Array` from a hexadecimal string or `Uint8Array`. Validates that\n * the length of the `Uint8Array` matches the specified length.\n *\n * This function is \"unsafe,\" in the sense that it does not validate that the\n * `Uint8Array` is not empty (i.e., all bytes are zero).\n *\n * @param value - The value to convert to a `Uint8Array`.\n * @param length - The length to validate the `Uint8Array` against.\n * @returns The `Uint8Array` corresponding to the hexadecimal string.\n */\nexport function getBytesUnsafe(value: unknown, length: number): Uint8Array {\n  if (value instanceof Uint8Array) {\n    assert(\n      value.length === length,\n      `Invalid value: Must be a ${length}-byte byte array.`,\n    );\n    return value;\n  }\n\n  if (typeof value === 'string') {\n    return getBytesUnsafe(hexToBytes(value), length);\n  }\n\n  throw new Error(\n    `Invalid value: Expected an instance of Uint8Array or hexadecimal string.`,\n  );\n}\n\n/**\n * Validate that the specified `Uint8Array` is not empty and has the specified\n * length.\n *\n * @param bytes - The `Uint8Array` to validate.\n * @param length - The length to validate the `Uint8Array` against.\n * @throws An error if the `Uint8Array` is empty or has the wrong length.\n */\nfunction validateBytes(\n  bytes: Uint8Array,\n  length: number,\n): asserts bytes is Uint8Array {\n  if (!isValidBytesKey(bytes, length)) {\n    throw new Error(\n      `Invalid value: Must be a non-zero ${length}-byte byte array.`,\n    );\n  }\n}\n\nexport const decodeBase58check = (value: string): Uint8Array => {\n  const base58Check = scureBase58check(sha256);\n\n  try {\n    return base58Check.decode(value);\n  } catch {\n    throw new Error(\n      `Invalid extended key: Value is not base58-encoded, or the checksum is invalid.`,\n    );\n  }\n};\n\nexport const encodeBase58check = (value: Uint8Array): string => {\n  const base58Check = scureBase58check(sha256);\n\n  return base58Check.encode(value);\n};\n\n/**\n * Get the fingerprint of a compressed public key as number.\n *\n * @param publicKey - The compressed public key to get the fingerprint for.\n * @param compressedPublicKeyLength - The length of the compressed public key.\n * @returns The fingerprint of the public key.\n */\nexport const getFingerprint = (\n  publicKey: Uint8Array,\n  compressedPublicKeyLength: number,\n): number => {\n  if (!isValidBytesKey(publicKey, compressedPublicKeyLength)) {\n    throw new Error(\n      `Invalid public key: The key must be a ${compressedPublicKeyLength}-byte, non-zero byte array.`,\n    );\n  }\n\n  const bytes = ripemd160(sha256(publicKey));\n  const view = createDataView(bytes);\n\n  return view.getUint32(0, false);\n};\n\n/**\n * Get a secret recovery phrase (or mnemonic phrase) in string form as a\n * `Uint8Array`. The secret recovery phrase is split into words, and each word\n * is converted to a number using the BIP-39 word list. The numbers are then\n * converted to bytes, and the bytes are concatenated into a single\n * `Uint8Array`.\n *\n * @param mnemonicPhrase - The secret recovery phrase to convert.\n * @returns The `Uint8Array` corresponding to the secret recovery phrase.\n */\nexport function mnemonicPhraseToBytes(mnemonicPhrase: string): Uint8Array {\n  const words = mnemonicPhrase.split(' ');\n  const indices = words.map((word) => {\n    const index = englishWordlist.indexOf(word);\n    assert(index !== -1, `Invalid mnemonic phrase: Unknown word \"${word}\".`);\n\n    return index;\n  });\n\n  return new Uint8Array(new Uint16Array(indices).buffer);\n}\n\n/**\n * Validates the curve name.\n *\n * @param curveName - The name of the curve to validate.\n */\nexport function validateCurve(\n  curveName: unknown,\n): asserts curveName is SupportedCurve {\n  if (!curveName || typeof curveName !== 'string') {\n    throw new Error('Invalid curve: Must specify a curve.');\n  }\n\n  if (!Object.keys(curves).includes(curveName)) {\n    throw new Error(\n      `Invalid curve: Only the following curves are supported: ${Object.keys(\n        curves,\n      ).join(', ')}.`,\n    );\n  }\n}\n\n/**\n * Get a 4-byte-long `Uint8Array` from a numeric value.\n *\n * @param value - The value to convert to a `Uint8Array`.\n * @param littleEndian - Whether to use little endian byte order.\n * @returns The `Uint8Array` corresponding to the `bigint` value.\n */\nexport function numberToUint32(value: number, littleEndian = false) {\n  const bytes = new Uint8Array(4);\n  const view = createDataView(bytes);\n\n  view.setUint32(0, value, littleEndian);\n\n  return bytes;\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"utils.mjs","sourceRoot":"","sources":["../src/utils.ts"],"names":[],"mappings":"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","sourcesContent":["import { wordlist as englishWordlist } from '@metamask/scure-bip39/dist/wordlists/english';\nimport { assert, createDataView, hexToBytes } from '@metamask/utils';\nimport { base58check as scureBase58check } from '@scure/base';\n\nimport type {\n  BIP32Node,\n  ChangeHDPathString,\n  CoinTypeHDPathString,\n  CoinTypeToAddressTuple,\n  HardenedBIP32Node,\n  UnhardenedBIP32Node,\n  UnprefixedNode,\n} from './constants';\nimport {\n  BIP44PurposeNodeToken,\n  MAX_BIP_32_INDEX,\n  MAX_UNHARDENED_BIP_32_INDEX,\n  UNPREFIXED_BIP_32_PATH_REGEX,\n} from './constants';\nimport { ripemd160, sha256 } from './cryptography';\nimport type { SupportedCurve } from './curves';\nimport { curves } from './curves';\n\n/**\n * Gets a string representation of a BIP-44 path of depth 2, i.e.:\n * `m / 44' / coin_type'`\n *\n * For display purposes only.\n *\n * @param coin_type - The `coin_type` index to create a path visualization for.\n * @returns The visualization of the BIP-44 path for thte specified `coin_type`.\n */\nexport function getBIP44CoinTypePathString(\n  coin_type: number,\n): CoinTypeHDPathString {\n  return `m / ${BIP44PurposeNodeToken} / ${getHardenedBIP32NodeToken(\n    coin_type,\n  )}`;\n}\n\ntype BIP44PathIndex = number | { index: number; hardened: boolean };\n\ntype BIP44PathIndices = {\n  coin_type: number;\n  account?: number;\n  change?: BIP44PathIndex;\n  address_index: BIP44PathIndex;\n};\n\nexport type CoinTypeToAddressIndices = Pick<\n  BIP44PathIndices,\n  'account' | 'change' | 'address_index'\n>;\n\n/**\n * Gets a string representation of a BIP-44 path of depth 4, i.e.:\n * `m / 44' / coin_type' / account' / change`\n *\n * For display purposes only.\n *\n * @param coinTypePath - The parent `coin_type` path.\n * @param indices - The `account` and `change` index to create a path visualization for.\n * @returns The visualization of the BIP-44 path for the specified `coin_type`\n * and `change` indices.\n */\nexport function getBIP44ChangePathString(\n  coinTypePath: CoinTypeHDPathString,\n  indices: Omit<CoinTypeToAddressIndices, 'address_index'>,\n): ChangeHDPathString {\n  return `${coinTypePath} / ${getHardenedBIP32NodeToken(\n    indices.account ?? 0,\n  )} / ${getBIP32NodeToken(indices.change ?? 0)}`;\n}\n\n/**\n * Gets a BIP-44 path tuple of the form `account' / change / address_index`,\n * which can be used to derive address keys together with a `coin_type` key.\n *\n * @param indices - The BIP-44 derivation index values.\n * @param indices.account - The `account` index value.\n * @param indices.change - The `change` index value.\n * @param indices.address_index - The `address_index` index value.\n * @returns The `account' / change / address_index` path corresponding to the\n * specified indices.\n */\nexport function getBIP44CoinTypeToAddressPathTuple({\n  account = 0,\n  change = 0,\n  address_index,\n}: CoinTypeToAddressIndices): CoinTypeToAddressTuple {\n  return [\n    getHardenedBIP32NodeToken(account),\n    getBIP32NodeToken(change),\n    getBIP32NodeToken(address_index),\n  ] as const;\n}\n\n/**\n * A hardened BIP-32 node token, e.g. `bip32:0'`.\n * Validates that the index is a non-negative integer number, and throws an\n * error if validation fails.\n *\n * @param index - The index of the node.\n * @returns The hardened BIP-32 node token.\n */\nexport function getHardenedBIP32NodeToken(index: number): HardenedBIP32Node {\n  validateBIP32Index(index);\n  return `${getUnhardenedBIP32NodeToken(index)}'`;\n}\n\n/**\n * An unhardened BIP-32 node token, e.g. `bip32:0`.\n * Validates that the index is a non-negative integer number, and throws an\n * error if validation fails.\n *\n * @param index - The index of the node.\n * @returns The unhardened BIP-32 node token.\n */\nexport function getUnhardenedBIP32NodeToken(\n  index: number,\n): UnhardenedBIP32Node {\n  validateBIP32Index(index);\n  return `bip32:${index}`;\n}\n\n/**\n * A hardened or unhardened BIP-32 node token, e.g. `bip32:0` or `bip32:0'`.\n * Validates that the index is a non-negative integer number, and throws an\n * error if validation fails.\n *\n * @param index - The index of the node.\n * @returns The hardened or unhardened BIP-32 node token.\n */\nexport function getBIP32NodeToken(index: BIP44PathIndex): BIP32Node {\n  if (typeof index === 'number') {\n    return getUnhardenedBIP32NodeToken(index);\n  }\n\n  if (\n    !index ||\n    !Number.isInteger(index.index) ||\n    typeof index.hardened !== 'boolean'\n  ) {\n    throw new Error(\n      'Invalid BIP-32 index: Must be an object containing the index and whether it is hardened.',\n    );\n  }\n\n  if (index.hardened) {\n    return getHardenedBIP32NodeToken(index.index);\n  }\n\n  return getUnhardenedBIP32NodeToken(index.index);\n}\n\n/**\n * Validates that the index is a non-negative integer number. Throws an\n * error if validation fails.\n *\n * @param addressIndex - The index to validate.\n */\nexport function validateBIP32Index(addressIndex: number): void {\n  if (!isValidBIP32Index(addressIndex)) {\n    throw new Error(`Invalid BIP-32 index: Must be a non-negative integer.`);\n  }\n}\n\n/**\n * Check if the index is a valid BIP-32 index.\n *\n * @param index - The BIP-32 index to test.\n * @returns Whether the index is a non-negative integer number.\n */\nexport function isValidBIP32Index(index: number): boolean {\n  return isValidInteger(index) && index <= MAX_BIP_32_INDEX;\n}\n\n/**\n * Check if the value is a valid BIP-32 path segment, i.e., a string of the form\n * `0'`.\n *\n * @param segment - The BIP-32 path segment to test.\n * @returns Whether the path segment is a valid BIP-32 path segment.\n */\nexport function isValidBIP32PathSegment(\n  segment: string,\n): segment is UnprefixedNode {\n  if (typeof segment !== 'string') {\n    return false;\n  }\n\n  const match = segment.match(UNPREFIXED_BIP_32_PATH_REGEX);\n  if (typeof match?.groups?.index === 'undefined') {\n    return false;\n  }\n\n  const index = parseInt(match.groups.index, 10);\n  return isValidInteger(index) && index <= MAX_UNHARDENED_BIP_32_INDEX;\n}\n\n/**\n * Check if the value is a hardened BIP-32 index. This only checks if the value\n * ends with a `'` character, and does not validate that the index is a valid\n * BIP-32 index.\n *\n * @param bip32Token - The token to test.\n * @returns Whether the token is hardened, i.e. ends with `'`.\n */\nexport function isHardened(bip32Token: string): boolean {\n  return bip32Token.endsWith(`'`);\n}\n\n/**\n * Get a `Uint8Array` from a hexadecimal string or a `Uint8Array`. If the input\n * is a hexadecimal string, it is converted to a `Uint8Array`. If the input is\n * a `Uint8Array`, it is returned as-is.\n *\n * @param hexString - The hexadecimal string to convert.\n * @returns The `Uint8Array` corresponding to the hexadecimal string.\n */\nexport function hexStringToBytes(hexString: string | Uint8Array): Uint8Array {\n  if (hexString instanceof Uint8Array) {\n    return hexString;\n  }\n\n  return hexToBytes(hexString);\n}\n\n/**\n * The same as {@link hexStringToBytes}, but returns `undefined` if the input\n * is `undefined`.\n *\n * @param hexString - The hexadecimal string to convert.\n * @returns The `Uint8Array` corresponding to the hexadecimal string.\n */\nexport function nullableHexStringToBytes(\n  hexString?: string | Uint8Array,\n): Uint8Array | undefined {\n  if (hexString !== undefined) {\n    return hexStringToBytes(hexString);\n  }\n\n  return undefined;\n}\n\n/**\n * Tests whether the specified `Uint8Array` is a valid BIP-32 key.\n * A valid bytes key is 64 bytes long and has at least one non-zero byte.\n *\n * @param bytes - The `Uint8Array` to test.\n * @param expectedLength - The expected length of the Uint8Array.\n * @returns Whether the Uint8Array represents a valid BIP-32 key.\n */\nexport function isValidBytesKey(\n  bytes: Uint8Array,\n  expectedLength: number,\n): boolean {\n  if (bytes.length !== expectedLength) {\n    return false;\n  }\n\n  for (const byte of bytes) {\n    if (byte !== 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Tests whether the specified number is a valid integer equal to or greater than 0.\n *\n * @param value - The number to test.\n * @returns Whether the number is a valid integer.\n */\nexport function isValidInteger(value: unknown): value is number {\n  return typeof value === 'number' && Number.isInteger(value) && value >= 0;\n}\n\n/**\n * Get a `Uint8Array` from a hexadecimal string or `Uint8Array`. Validates that the\n * length of the `Uint8Array` matches the specified length, and that the `Uint8Array`\n * is not empty.\n *\n * @param value - The value to convert to a `Uint8Array`.\n * @param length - The length to validate the `Uint8Array` against.\n * @returns The `Uint8Array` corresponding to the hexadecimal string.\n */\nexport function getBytes(value: unknown, length: number): Uint8Array {\n  if (value instanceof Uint8Array) {\n    validateBytes(value, length);\n\n    return value;\n  }\n\n  if (typeof value === 'string') {\n    const bytes = hexToBytes(value);\n    validateBytes(bytes, length);\n\n    return bytes;\n  }\n\n  throw new Error(\n    `Invalid value: Expected an instance of Uint8Array or hexadecimal string.`,\n  );\n}\n\n/**\n * Get a `Uint8Array` from a hexadecimal string or `Uint8Array`. Validates that\n * the length of the `Uint8Array` matches the specified length.\n *\n * This function is \"unsafe,\" in the sense that it does not validate that the\n * `Uint8Array` is not empty (i.e., all bytes are zero).\n *\n * @param value - The value to convert to a `Uint8Array`.\n * @param length - The length to validate the `Uint8Array` against.\n * @returns The `Uint8Array` corresponding to the hexadecimal string.\n */\nexport function getBytesUnsafe(value: unknown, length: number): Uint8Array {\n  if (value instanceof Uint8Array) {\n    assert(\n      value.length === length,\n      `Invalid value: Must be a ${length}-byte byte array.`,\n    );\n    return value;\n  }\n\n  if (typeof value === 'string') {\n    return getBytesUnsafe(hexToBytes(value), length);\n  }\n\n  throw new Error(\n    `Invalid value: Expected an instance of Uint8Array or hexadecimal string.`,\n  );\n}\n\n/**\n * Validate that the specified `Uint8Array` is not empty and has the specified\n * length.\n *\n * @param bytes - The `Uint8Array` to validate.\n * @param length - The length to validate the `Uint8Array` against.\n * @throws An error if the `Uint8Array` is empty or has the wrong length.\n */\nfunction validateBytes(\n  bytes: Uint8Array,\n  length: number,\n): asserts bytes is Uint8Array {\n  if (!isValidBytesKey(bytes, length)) {\n    throw new Error(\n      `Invalid value: Must be a non-zero ${length}-byte byte array.`,\n    );\n  }\n}\n\nexport const decodeBase58check = (value: string): Uint8Array => {\n  const base58Check = scureBase58check(sha256);\n\n  try {\n    return base58Check.decode(value);\n  } catch {\n    throw new Error(\n      `Invalid extended key: Value is not base58-encoded, or the checksum is invalid.`,\n    );\n  }\n};\n\nexport const encodeBase58check = (value: Uint8Array): string => {\n  const base58Check = scureBase58check(sha256);\n\n  return base58Check.encode(value);\n};\n\n/**\n * Get the fingerprint of a compressed public key as number.\n *\n * @param publicKey - The compressed public key to get the fingerprint for.\n * @param compressedPublicKeyLength - The length of the compressed public key.\n * @returns The fingerprint of the public key.\n */\nexport const getFingerprint = (\n  publicKey: Uint8Array,\n  compressedPublicKeyLength: number,\n): number => {\n  if (!isValidBytesKey(publicKey, compressedPublicKeyLength)) {\n    throw new Error(\n      `Invalid public key: The key must be a ${compressedPublicKeyLength}-byte, non-zero byte array.`,\n    );\n  }\n\n  const bytes = ripemd160(sha256(publicKey));\n  const view = createDataView(bytes);\n\n  return view.getUint32(0, false);\n};\n\n/**\n * Get a secret recovery phrase (or mnemonic phrase) in string form as a\n * `Uint8Array`. The secret recovery phrase is split into words, and each word\n * is converted to a number using the BIP-39 word list. The numbers are then\n * converted to bytes, and the bytes are concatenated into a single\n * `Uint8Array`.\n *\n * @param mnemonicPhrase - The secret recovery phrase to convert.\n * @returns The `Uint8Array` corresponding to the secret recovery phrase.\n */\nexport function mnemonicPhraseToBytes(mnemonicPhrase: string): Uint8Array {\n  const words = mnemonicPhrase.split(' ');\n  const indices = words.map((word) => {\n    const index = englishWordlist.indexOf(word);\n    assert(index !== -1, `Invalid mnemonic phrase: Unknown word \"${word}\".`);\n\n    return index;\n  });\n\n  return new Uint8Array(new Uint16Array(indices).buffer);\n}\n\n/**\n * Validates the curve name.\n *\n * @param curveName - The name of the curve to validate.\n */\nexport function validateCurve(\n  curveName: unknown,\n): asserts curveName is SupportedCurve {\n  if (!curveName || typeof curveName !== 'string') {\n    throw new Error('Invalid curve: Must specify a curve.');\n  }\n\n  if (!Object.keys(curves).includes(curveName)) {\n    throw new Error(\n      `Invalid curve: Only the following curves are supported: ${Object.keys(\n        curves,\n      ).join(', ')}.`,\n    );\n  }\n}\n\n/**\n * Get a 4-byte-long `Uint8Array` from a numeric value.\n *\n * @param value - The value to convert to a `Uint8Array`.\n * @param littleEndian - Whether to use little endian byte order.\n * @returns The `Uint8Array` corresponding to the `bigint` value.\n */\nexport function numberToUint32(\n  value: number,\n  littleEndian = false,\n): Uint8Array {\n  const bytes = new Uint8Array(4);\n  const view = createDataView(bytes);\n\n  view.setUint32(0, value, littleEndian);\n\n  return bytes;\n}\n\n/**\n * A utility function to check if the Web Crypto API is supported in the current\n * environment.\n *\n * @returns Whether the Web Crypto API is supported.\n */\nexport function isWebCryptoSupported(): boolean {\n  return Boolean(globalThis.crypto?.subtle);\n}\n"]}
\ No newline at end of file
