diff --git a/node_modules/@metamask/assets-controllers/dist/.patch.txt b/node_modules/@metamask/assets-controllers/dist/.patch.txt
new file mode 100644
index 0000000..550de56
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/.patch.txt
@@ -0,0 +1,14 @@
+PATCH GENERATED FROM MetaMask/core branch: patch/mobile-assets-controllers-v-12-0-0
+This patch backports various assets controllers features from the main branch of MetaMask/core
+Steps to update patch:
+* Create a new core branch from: patch/mobile-assets-controllers-v-12-0-0
+* Run "yarn build" in the core monorepo
+* Run "yarn patch:assets <core-directory>" in the mobile repo
+* If you have changes also add them to the branch: patch/mobile-assets-controllers-v-12-0-0
+* Steps to update the assets-controllers version
+* Create a new core branch from the next assets-controllers version
+* Merge the branch patch/mobile-assets-controllers-v-12-0-0
+* Solve the conflicts and review changes accordingly the changelog
+* Run "yarn build" in the core monorepo
+* Run "yarn patch:assets <core-directory>" in the mobile repo
+* If you have changes also add them to the branch: patch/mobile-assets-controllers-v-12-0-0
diff --git a/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.d.ts b/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.d.ts
index 41bf5fe..7b4be39 100644
--- a/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.d.ts
@@ -1,5 +1,5 @@
-import type { BaseConfig, BaseState } from '@metamask/base-controller';
-import { BaseController } from '@metamask/base-controller';
+import { BaseConfig, BaseController, BaseState } from '@metamask/base-controller';
+import { NetworkState } from '@metamask/network-controller';
 import type { Provider } from '@metamask/eth-query';
 import type { PreferencesState } from '@metamask/preferences-controller';
 /**
@@ -31,22 +31,26 @@ export interface AccountTrackerState extends BaseState {
     accounts: {
         [address: string]: AccountInformation;
     };
+    accountsByChainId: Record<string, {
+        [address: string]: AccountInformation;
+    }>;
 }
 /**
  * Controller that tracks the network balances for all user accounts.
  */
 export declare class AccountTrackerController extends BaseController<AccountTrackerConfig, AccountTrackerState> {
     private ethQuery?;
-    private readonly mutex;
+    private mutex;
     private handle?;
     private syncAccounts;
     /**
      * Name of this controller used during composition
      */
     name: string;
-    private readonly getIdentities;
-    private readonly getSelectedAddress;
-    private readonly getMultiAccountBalancesEnabled;
+    private getIdentities;
+    private getSelectedAddress;
+    private getMultiAccountBalancesEnabled;
+    getCurrentChainId: () => NetworkState['providerConfig']['chainId'];
     /**
      * Creates an AccountTracker instance.
      *
@@ -55,14 +59,16 @@ export declare class AccountTrackerController extends BaseController<AccountTrac
      * @param options.getIdentities - Gets the identities from the Preferences store.
      * @param options.getSelectedAddress - Gets the selected address from the Preferences store.
      * @param options.getMultiAccountBalancesEnabled - Gets the multi account balances enabled flag from the Preferences store.
+     * @param options.getCurrentChainId - Gets the chain ID for the current network from the Network store.
      * @param config - Initial options used to configure this controller.
      * @param state - Initial state to set on this controller.
      */
-    constructor({ onPreferencesStateChange, getIdentities, getSelectedAddress, getMultiAccountBalancesEnabled, }: {
+    constructor({ onPreferencesStateChange, getIdentities, getSelectedAddress, getMultiAccountBalancesEnabled, getCurrentChainId, }: {
         onPreferencesStateChange: (listener: (preferencesState: PreferencesState) => void) => void;
         getIdentities: () => PreferencesState['identities'];
         getSelectedAddress: () => PreferencesState['selectedAddress'];
         getMultiAccountBalancesEnabled: () => PreferencesState['isMultiAccountBalancesEnabled'];
+        getCurrentChainId: () => NetworkState['providerConfig']['chainId'];
     }, config?: Partial<AccountTrackerConfig>, state?: Partial<AccountTrackerState>);
     /**
      * Sets a new provider.
@@ -83,6 +89,8 @@ export declare class AccountTrackerController extends BaseController<AccountTrac
      * Refreshes the balances of the accounts depending on the multi-account setting.
      * If multi-account is disabled, only updates the selected account balance.
      * If multi-account is enabled, updates balances for all accounts.
+     *
+     * @async
      */
     refresh: () => Promise<void>;
     /**
diff --git a/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.d.ts.map b/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.d.ts.map
index 55c0d9e..9943e30 100644
--- a/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.d.ts.map
+++ b/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"AccountTrackerController.d.ts","sourceRoot":"","sources":["../src/AccountTrackerController.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,UAAU,EAAE,SAAS,EAAE,MAAM,2BAA2B,CAAC;AACvE,OAAO,EAAE,cAAc,EAAE,MAAM,2BAA2B,CAAC;AAO3D,OAAO,KAAK,EAAE,QAAQ,EAAE,MAAM,qBAAqB,CAAC;AACpD,OAAO,KAAK,EAAE,gBAAgB,EAAE,MAAM,kCAAkC,CAAC;AAIzE;;;;;GAKG;AACH,MAAM,WAAW,kBAAkB;IACjC,OAAO,EAAE,MAAM,CAAC;CACjB;AAED;;;;;GAKG;AACH,MAAM,WAAW,oBAAqB,SAAQ,UAAU;IACtD,QAAQ,EAAE,MAAM,CAAC;IACjB,QAAQ,CAAC,EAAE,QAAQ,CAAC;CACrB;AAED;;;;;GAKG;AACH,MAAM,WAAW,mBAAoB,SAAQ,SAAS;IACpD,QAAQ,EAAE;QAAE,CAAC,OAAO,EAAE,MAAM,GAAG,kBAAkB,CAAA;KAAE,CAAC;CACrD;AAED;;GAEG;AACH,qBAAa,wBAAyB,SAAQ,cAAc,CAC1D,oBAAoB,EACpB,mBAAmB,CACpB;IACC,OAAO,CAAC,QAAQ,CAAC,CAAW;IAE5B,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAe;IAErC,OAAO,CAAC,MAAM,CAAC,CAAgC;IAE/C,OAAO,CAAC,YAAY;IAoBpB;;OAEG;IACM,IAAI,SAA8B;IAE3C,OAAO,CAAC,QAAQ,CAAC,aAAa,CAAuC;IAErE,OAAO,CAAC,QAAQ,CAAC,kBAAkB,CAA4C;IAE/E,OAAO,CAAC,QAAQ,CAAC,8BAA8B,CAA0D;IAEzG;;;;;;;;;;OAUG;gBAED,EACE,wBAAwB,EACxB,aAAa,EACb,kBAAkB,EAClB,8BAA8B,GAC/B,EAAE;QACD,wBAAwB,EAAE,CACxB,QAAQ,EAAE,CAAC,gBAAgB,EAAE,gBAAgB,KAAK,IAAI,KACnD,IAAI,CAAC;QACV,aAAa,EAAE,MAAM,gBAAgB,CAAC,YAAY,CAAC,CAAC;QACpD,kBAAkB,EAAE,MAAM,gBAAgB,CAAC,iBAAiB,CAAC,CAAC;QAC9D,8BAA8B,EAAE,MAAM,gBAAgB,CAAC,+BAA+B,CAAC,CAAC;KACzF,EACD,MAAM,CAAC,EAAE,OAAO,CAAC,oBAAoB,CAAC,EACtC,KAAK,CAAC,EAAE,OAAO,CAAC,mBAAmB,CAAC;IAiBtC;;;;;;OAMG;IACH,IAAI,QAAQ,CAAC,QAAQ,EAAE,QAAQ,EAE9B;IAED,IAAI,QAAQ,IAJW,QAAQ,CAM9B;IAED;;;;OAIG;IACG,IAAI,CAAC,QAAQ,CAAC,EAAE,MAAM,GAAG,OAAO,CAAC,IAAI,CAAC;IAW5C;;;;OAIG;IACH,OAAO,sBAgBL;IAEF;;;;;OAKG;YACW,mBAAmB;IASjC;;;;;OAKG;IACG,wBAAwB,CAC5B,SAAS,EAAE,MAAM,EAAE,GAClB,OAAO,CAAC,MAAM,CAAC,MAAM,EAAE;QAAE,OAAO,EAAE,MAAM,CAAA;KAAE,CAAC,CAAC;CAyBhD;AAED,eAAe,wBAAwB,CAAC"}
\ No newline at end of file
+{"version":3,"file":"AccountTrackerController.d.ts","sourceRoot":"","sources":["../src/AccountTrackerController.ts"],"names":[],"mappings":"AAAA,OAAO,EACL,UAAU,EACV,cAAc,EACd,SAAS,EACV,MAAM,2BAA2B,CAAC;AAMnC,OAAO,EAAE,YAAY,EAAE,MAAM,8BAA8B,CAAC;AAG5D,OAAO,KAAK,EAAE,QAAQ,EAAE,MAAM,qBAAqB,CAAC;AACpD,OAAO,KAAK,EAAE,gBAAgB,EAAE,MAAM,kCAAkC,CAAC;AAIzE;;;;;GAKG;AACH,MAAM,WAAW,kBAAkB;IACjC,OAAO,EAAE,MAAM,CAAC;CACjB;AAED;;;;;GAKG;AACH,MAAM,WAAW,oBAAqB,SAAQ,UAAU;IACtD,QAAQ,EAAE,MAAM,CAAC;IACjB,QAAQ,CAAC,EAAE,QAAQ,CAAC;CACrB;AAED;;;;;GAKG;AACH,MAAM,WAAW,mBAAoB,SAAQ,SAAS;IACpD,QAAQ,EAAE;QAAE,CAAC,OAAO,EAAE,MAAM,GAAG,kBAAkB,CAAA;KAAE,CAAC;IACpD,iBAAiB,EAAE,MAAM,CACvB,MAAM,EACN;QACE,CAAC,OAAO,EAAE,MAAM,GAAG,kBAAkB,CAAC;KACvC,CACF,CAAC;CACH;AAED;;GAEG;AACH,qBAAa,wBAAyB,SAAQ,cAAc,CAC1D,oBAAoB,EACpB,mBAAmB,CACpB;IACC,OAAO,CAAC,QAAQ,CAAC,CAAW;IAE5B,OAAO,CAAC,KAAK,CAAe;IAE5B,OAAO,CAAC,MAAM,CAAC,CAAgC;IAE/C,OAAO,CAAC,YAAY;IAuCpB;;OAEG;IACM,IAAI,SAA8B;IAE3C,OAAO,CAAC,aAAa,CAAuC;IAE5D,OAAO,CAAC,kBAAkB,CAA4C;IAEtE,OAAO,CAAC,8BAA8B,CAA0D;IAEhG,iBAAiB,EAAE,MAAM,YAAY,CAAC,gBAAgB,CAAC,CAAC,SAAS,CAAC,CAAC;IAEnE;;;;;;;;;;;OAWG;gBAED,EACE,wBAAwB,EACxB,aAAa,EACb,kBAAkB,EAClB,8BAA8B,EAC9B,iBAAiB,GAClB,EAAE;QACD,wBAAwB,EAAE,CACxB,QAAQ,EAAE,CAAC,gBAAgB,EAAE,gBAAgB,KAAK,IAAI,KACnD,IAAI,CAAC;QACV,aAAa,EAAE,MAAM,gBAAgB,CAAC,YAAY,CAAC,CAAC;QACpD,kBAAkB,EAAE,MAAM,gBAAgB,CAAC,iBAAiB,CAAC,CAAC;QAC9D,8BAA8B,EAAE,MAAM,gBAAgB,CAAC,+BAA+B,CAAC,CAAC;QACxF,iBAAiB,EAAE,MAAM,YAAY,CAAC,gBAAgB,CAAC,CAAC,SAAS,CAAC,CAAC;KACpE,EACD,MAAM,CAAC,EAAE,OAAO,CAAC,oBAAoB,CAAC,EACtC,KAAK,CAAC,EAAE,OAAO,CAAC,mBAAmB,CAAC;IAuBtC;;;;;;OAMG;IACH,IAAI,QAAQ,CAAC,QAAQ,EAAE,QAAQ,EAE9B;IAED,IAAI,QAAQ,IAJW,QAAQ,CAM9B;IAED;;;;OAIG;IACG,IAAI,CAAC,QAAQ,CAAC,EAAE,MAAM,GAAG,OAAO,CAAC,IAAI,CAAC;IAW5C;;;;;;OAMG;IACH,OAAO,sBAgCL;IAEF;;;;;OAKG;YACW,mBAAmB;IASjC;;;;;OAKG;IACG,wBAAwB,CAC5B,SAAS,EAAE,MAAM,EAAE,GAClB,OAAO,CAAC,MAAM,CAAC,MAAM,EAAE;QAAE,OAAO,EAAE,MAAM,CAAA;KAAE,CAAC,CAAC;CAyBhD;AAED,eAAe,wBAAwB,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.js b/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.js
index 4092a67..245bfbd 100644
--- a/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.js
+++ b/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.js
@@ -15,6 +15,7 @@ Object.defineProperty(exports, "__esModule", { value: true });
 exports.AccountTrackerController = void 0;
 const base_controller_1 = require("@metamask/base-controller");
 const controller_utils_1 = require("@metamask/controller-utils");
+const lodash_1 = require("lodash");
 const eth_query_1 = __importDefault(require("@metamask/eth-query"));
 const utils_1 = require("@metamask/utils");
 const async_mutex_1 = require("async-mutex");
@@ -30,10 +31,11 @@ class AccountTrackerController extends base_controller_1.BaseController {
      * @param options.getIdentities - Gets the identities from the Preferences store.
      * @param options.getSelectedAddress - Gets the selected address from the Preferences store.
      * @param options.getMultiAccountBalancesEnabled - Gets the multi account balances enabled flag from the Preferences store.
+     * @param options.getCurrentChainId - Gets the chain ID for the current network from the Network store.
      * @param config - Initial options used to configure this controller.
      * @param state - Initial state to set on this controller.
      */
-    constructor({ onPreferencesStateChange, getIdentities, getSelectedAddress, getMultiAccountBalancesEnabled, }, config, state) {
+    constructor({ onPreferencesStateChange, getIdentities, getSelectedAddress, getMultiAccountBalancesEnabled, getCurrentChainId, }, config, state) {
         super(config, state);
         this.mutex = new async_mutex_1.Mutex();
         /**
@@ -44,25 +46,48 @@ class AccountTrackerController extends base_controller_1.BaseController {
          * Refreshes the balances of the accounts depending on the multi-account setting.
          * If multi-account is disabled, only updates the selected account balance.
          * If multi-account is enabled, updates balances for all accounts.
+         *
+         * @async
          */
         this.refresh = () => __awaiter(this, void 0, void 0, function* () {
-            this.syncAccounts();
+            const chainId = this.getCurrentChainId();
+            this.syncAccounts(chainId);
             const accounts = Object.assign({}, this.state.accounts);
+            const accountsByChainId = Object.assign({}, this.state.accountsByChainId);
+            const accountsForChain = Object.assign({}, accountsByChainId[chainId]);
             const isMultiAccountBalancesEnabled = this.getMultiAccountBalancesEnabled();
             const accountsToUpdate = isMultiAccountBalancesEnabled
                 ? Object.keys(accounts)
                 : [this.getSelectedAddress()];
             for (const address of accountsToUpdate) {
+                const balance = yield this.getBalanceFromChain(address);
+                if (!balance) {
+                    continue;
+                }
+                const hexBalance = (0, controller_utils_1.BNToHex)(balance);
                 accounts[address] = {
-                    balance: (0, controller_utils_1.BNToHex)(yield this.getBalanceFromChain(address)),
+                    balance: hexBalance,
+                };
+                accountsForChain[address] = {
+                    balance: hexBalance,
                 };
             }
-            this.update({ accounts });
+            this.update({
+                accounts,
+                accountsByChainId: Object.assign(Object.assign({}, accountsByChainId), {
+                    [chainId]: accountsForChain,
+                }),
+            });
         });
         this.defaultConfig = {
             interval: 10000,
         };
-        this.defaultState = { accounts: {} };
+        this.defaultState = {
+            accounts: {},
+            accountsByChainId: {
+                [getCurrentChainId()]: {},
+            },
+        };
         this.initialize();
         this.getIdentities = getIdentities;
         this.getSelectedAddress = getSelectedAddress;
@@ -70,21 +95,41 @@ class AccountTrackerController extends base_controller_1.BaseController {
         onPreferencesStateChange(() => {
             this.refresh();
         });
+        this.getCurrentChainId = getCurrentChainId;
         this.poll();
     }
-    syncAccounts() {
+    syncAccounts(newChainId) {
         const { accounts } = this.state;
+        const accountsByChainId = (0, lodash_1.cloneDeep)(this.state.accountsByChainId);
         const addresses = Object.keys(this.getIdentities());
         const existing = Object.keys(accounts);
-        const newAddresses = addresses.filter((address) => !existing.includes(address));
-        const oldAddresses = existing.filter((address) => !addresses.includes(address));
+        if (!accountsByChainId[newChainId]) {
+            accountsByChainId[newChainId] = {};
+            existing.forEach((address) => {
+                accountsByChainId[newChainId][address] = { balance: '0x0' };
+            });
+        }
+        const newAddresses = addresses.filter((address) => existing.indexOf(address) === -1);
+        const oldAddresses = existing.filter((address) => addresses.indexOf(address) === -1);
         newAddresses.forEach((address) => {
             accounts[address] = { balance: '0x0' };
         });
+        Object.keys(accountsByChainId).forEach((chainId) => {
+            newAddresses.forEach((address) => {
+                accountsByChainId[chainId][address] = {
+                    balance: '0x0',
+                };
+            });
+        });
         oldAddresses.forEach((address) => {
             delete accounts[address];
         });
-        this.update({ accounts: Object.assign({}, accounts) });
+        Object.keys(accountsByChainId).forEach((chainId) => {
+            oldAddresses.forEach((address) => {
+                delete accountsByChainId[chainId][address];
+            });
+        });
+        this.update({ accounts: Object.assign({}, accounts), accountsByChainId });
     }
     /**
      * Sets a new provider.
diff --git a/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.js.map b/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.js.map
index 513cb8e..da0b10d 100644
--- a/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.js.map
+++ b/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.js.map
@@ -1 +1 @@
-{"version":3,"file":"AccountTrackerController.js","sourceRoot":"","sources":["../src/AccountTrackerController.ts"],"names":[],"mappings":"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","sourcesContent":["import type { BaseConfig, BaseState } from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport {\n  BNToHex,\n  query,\n  safelyExecuteWithTimeout,\n} from '@metamask/controller-utils';\nimport EthQuery from '@metamask/eth-query';\nimport type { Provider } from '@metamask/eth-query';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport { assert } from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\n\n/**\n * @type AccountInformation\n *\n * Account information object\n * @property balance - Hex string of an account balancec in wei\n */\nexport interface AccountInformation {\n  balance: string;\n}\n\n/**\n * @type AccountTrackerConfig\n *\n * Account tracker controller configuration\n * @property provider - Provider used to create a new underlying EthQuery instance\n */\nexport interface AccountTrackerConfig extends BaseConfig {\n  interval: number;\n  provider?: Provider;\n}\n\n/**\n * @type AccountTrackerState\n *\n * Account tracker controller state\n * @property accounts - Map of addresses to account information\n */\nexport interface AccountTrackerState extends BaseState {\n  accounts: { [address: string]: AccountInformation };\n}\n\n/**\n * Controller that tracks the network balances for all user accounts.\n */\nexport class AccountTrackerController extends BaseController<\n  AccountTrackerConfig,\n  AccountTrackerState\n> {\n  private ethQuery?: EthQuery;\n\n  private readonly mutex = new Mutex();\n\n  private handle?: ReturnType<typeof setTimeout>;\n\n  private syncAccounts() {\n    const { accounts } = this.state;\n    const addresses = Object.keys(this.getIdentities());\n    const existing = Object.keys(accounts);\n    const newAddresses = addresses.filter(\n      (address) => !existing.includes(address),\n    );\n    const oldAddresses = existing.filter(\n      (address) => !addresses.includes(address),\n    );\n    newAddresses.forEach((address) => {\n      accounts[address] = { balance: '0x0' };\n    });\n\n    oldAddresses.forEach((address) => {\n      delete accounts[address];\n    });\n    this.update({ accounts: { ...accounts } });\n  }\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'AccountTrackerController';\n\n  private readonly getIdentities: () => PreferencesState['identities'];\n\n  private readonly getSelectedAddress: () => PreferencesState['selectedAddress'];\n\n  private readonly getMultiAccountBalancesEnabled: () => PreferencesState['isMultiAccountBalancesEnabled'];\n\n  /**\n   * Creates an AccountTracker instance.\n   *\n   * @param options - The controller options.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.getIdentities - Gets the identities from the Preferences store.\n   * @param options.getSelectedAddress - Gets the selected address from the Preferences store.\n   * @param options.getMultiAccountBalancesEnabled - Gets the multi account balances enabled flag from the Preferences store.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      onPreferencesStateChange,\n      getIdentities,\n      getSelectedAddress,\n      getMultiAccountBalancesEnabled,\n    }: {\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      getIdentities: () => PreferencesState['identities'];\n      getSelectedAddress: () => PreferencesState['selectedAddress'];\n      getMultiAccountBalancesEnabled: () => PreferencesState['isMultiAccountBalancesEnabled'];\n    },\n    config?: Partial<AccountTrackerConfig>,\n    state?: Partial<AccountTrackerState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      interval: 10000,\n    };\n    this.defaultState = { accounts: {} };\n    this.initialize();\n    this.getIdentities = getIdentities;\n    this.getSelectedAddress = getSelectedAddress;\n    this.getMultiAccountBalancesEnabled = getMultiAccountBalancesEnabled;\n    onPreferencesStateChange(() => {\n      this.refresh();\n    });\n    this.poll();\n  }\n\n  /**\n   * Sets a new provider.\n   *\n   * TODO: Replace this wth a method.\n   *\n   * @param provider - Provider used to create a new underlying EthQuery instance.\n   */\n  set provider(provider: Provider) {\n    this.ethQuery = new EthQuery(provider);\n  }\n\n  get provider() {\n    throw new Error('Property only used for setting');\n  }\n\n  /**\n   * Starts a new polling interval.\n   *\n   * @param interval - Polling interval trigger a 'refresh'.\n   */\n  async poll(interval?: number): Promise<void> {\n    const releaseLock = await this.mutex.acquire();\n    interval && this.configure({ interval }, false, false);\n    this.handle && clearTimeout(this.handle);\n    await this.refresh();\n    this.handle = setTimeout(() => {\n      releaseLock();\n      this.poll(this.config.interval);\n    }, this.config.interval);\n  }\n\n  /**\n   * Refreshes the balances of the accounts depending on the multi-account setting.\n   * If multi-account is disabled, only updates the selected account balance.\n   * If multi-account is enabled, updates balances for all accounts.\n   */\n  refresh = async () => {\n    this.syncAccounts();\n    const accounts = { ...this.state.accounts };\n    const isMultiAccountBalancesEnabled = this.getMultiAccountBalancesEnabled();\n\n    const accountsToUpdate = isMultiAccountBalancesEnabled\n      ? Object.keys(accounts)\n      : [this.getSelectedAddress()];\n\n    for (const address of accountsToUpdate) {\n      accounts[address] = {\n        balance: BNToHex(await this.getBalanceFromChain(address)),\n      };\n    }\n\n    this.update({ accounts });\n  };\n\n  /**\n   * Fetches the balance of a given address from the blockchain.\n   *\n   * @param address - The account address to fetch the balance for.\n   * @returns A promise that resolves to the balance in a hex string format.\n   */\n  private async getBalanceFromChain(\n    address: string,\n  ): Promise<string | undefined> {\n    return await safelyExecuteWithTimeout(async () => {\n      assert(this.ethQuery, 'Provider not set.');\n      return await query(this.ethQuery, 'getBalance', [address]);\n    });\n  }\n\n  /**\n   * Sync accounts balances with some additional addresses.\n   *\n   * @param addresses - the additional addresses, may be hardware wallet addresses.\n   * @returns accounts - addresses with synced balance\n   */\n  async syncBalanceWithAddresses(\n    addresses: string[],\n  ): Promise<Record<string, { balance: string }>> {\n    return await Promise.all(\n      addresses.map((address): Promise<[string, string] | undefined> => {\n        return safelyExecuteWithTimeout(async () => {\n          assert(this.ethQuery, 'Provider not set.');\n          const balance = await query(this.ethQuery, 'getBalance', [address]);\n          return [address, balance];\n        });\n      }),\n    ).then((value) => {\n      return value.reduce((obj, item) => {\n        if (!item) {\n          return obj;\n        }\n\n        const [address, balance] = item;\n        return {\n          ...obj,\n          [address]: {\n            balance,\n          },\n        };\n      }, {});\n    });\n  }\n}\n\nexport default AccountTrackerController;\n"]}
\ No newline at end of file
+{"version":3,"file":"AccountTrackerController.js","sourceRoot":"","sources":["../src/AccountTrackerController.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  BaseConfig,\n  BaseController,\n  BaseState,\n} from '@metamask/base-controller';\nimport {\n  BNToHex,\n  query,\n  safelyExecuteWithTimeout,\n} from '@metamask/controller-utils';\nimport { NetworkState } from '@metamask/network-controller';\nimport { cloneDeep } from 'lodash';\nimport EthQuery from '@metamask/eth-query';\nimport type { Provider } from '@metamask/eth-query';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport { Hex, assert } from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\n\n/**\n * @type AccountInformation\n *\n * Account information object\n * @property balance - Hex string of an account balancec in wei\n */\nexport interface AccountInformation {\n  balance: string;\n}\n\n/**\n * @type AccountTrackerConfig\n *\n * Account tracker controller configuration\n * @property provider - Provider used to create a new underlying EthQuery instance\n */\nexport interface AccountTrackerConfig extends BaseConfig {\n  interval: number;\n  provider?: Provider;\n}\n\n/**\n * @type AccountTrackerState\n *\n * Account tracker controller state\n * @property accounts - Map of addresses to account information\n */\nexport interface AccountTrackerState extends BaseState {\n  accounts: { [address: string]: AccountInformation };\n  accountsByChainId: Record<\n    string,\n    {\n      [address: string]: AccountInformation;\n    }\n  >;\n}\n\n/**\n * Controller that tracks the network balances for all user accounts.\n */\nexport class AccountTrackerController extends BaseController<\n  AccountTrackerConfig,\n  AccountTrackerState\n> {\n  private ethQuery?: EthQuery;\n\n  private mutex = new Mutex();\n\n  private handle?: ReturnType<typeof setTimeout>;\n\n  private syncAccounts(newChainId: Hex) {\n    const { accounts } = this.state;\n    const accountsByChainId = cloneDeep(this.state.accountsByChainId);\n    const addresses = Object.keys(this.getIdentities());\n    const existing = Object.keys(accounts);\n    if (!accountsByChainId[newChainId]) {\n      accountsByChainId[newChainId] = {};\n      existing.forEach((address) => {\n        accountsByChainId[newChainId][address] = { balance: '0x0' };\n      });\n    }\n\n    const newAddresses = addresses.filter(\n      (address) => existing.indexOf(address) === -1,\n    );\n    const oldAddresses = existing.filter(\n      (address) => addresses.indexOf(address) === -1,\n    );\n    newAddresses.forEach((address) => {\n      accounts[address] = { balance: '0x0' };\n    });\n    Object.keys(accountsByChainId).forEach((chainId) => {\n      newAddresses.forEach((address) => {\n        accountsByChainId[chainId][address] = {\n          balance: '0x0',\n        };\n      });\n    });\n    oldAddresses.forEach((address) => {\n      delete accounts[address];\n    });\n    Object.keys(accountsByChainId).forEach((chainId) => {\n      oldAddresses.forEach((address) => {\n        delete accountsByChainId[chainId][address];\n      });\n    });\n    this.update({ accounts: { ...accounts }, accountsByChainId });\n  }\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'AccountTrackerController';\n\n  private getIdentities: () => PreferencesState['identities'];\n\n  private getSelectedAddress: () => PreferencesState['selectedAddress'];\n\n  private getMultiAccountBalancesEnabled: () => PreferencesState['isMultiAccountBalancesEnabled'];\n\n  getCurrentChainId: () => NetworkState['providerConfig']['chainId'];\n\n  /**\n   * Creates an AccountTracker instance.\n   *\n   * @param options - The controller options.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.getIdentities - Gets the identities from the Preferences store.\n   * @param options.getSelectedAddress - Gets the selected address from the Preferences store.\n   * @param options.getMultiAccountBalancesEnabled - Gets the multi account balances enabled flag from the Preferences store.\n   * @param options.getCurrentChainId - Gets the chain ID for the current network from the Network store.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      onPreferencesStateChange,\n      getIdentities,\n      getSelectedAddress,\n      getMultiAccountBalancesEnabled,\n      getCurrentChainId,\n    }: {\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      getIdentities: () => PreferencesState['identities'];\n      getSelectedAddress: () => PreferencesState['selectedAddress'];\n      getMultiAccountBalancesEnabled: () => PreferencesState['isMultiAccountBalancesEnabled'];\n      getCurrentChainId: () => NetworkState['providerConfig']['chainId'];\n    },\n    config?: Partial<AccountTrackerConfig>,\n    state?: Partial<AccountTrackerState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      interval: 10000,\n    };\n    this.defaultState = {\n      accounts: {},\n      accountsByChainId: {\n        [getCurrentChainId()]: {},\n      },\n    };\n    this.initialize();\n    this.getIdentities = getIdentities;\n    this.getSelectedAddress = getSelectedAddress;\n    this.getMultiAccountBalancesEnabled = getMultiAccountBalancesEnabled;\n    onPreferencesStateChange(() => {\n      this.refresh();\n    });\n    this.getCurrentChainId = getCurrentChainId;\n    this.poll();\n  }\n\n  /**\n   * Sets a new provider.\n   *\n   * TODO: Replace this wth a method.\n   *\n   * @param provider - Provider used to create a new underlying EthQuery instance.\n   */\n  set provider(provider: Provider) {\n    this.ethQuery = new EthQuery(provider);\n  }\n\n  get provider() {\n    throw new Error('Property only used for setting');\n  }\n\n  /**\n   * Starts a new polling interval.\n   *\n   * @param interval - Polling interval trigger a 'refresh'.\n   */\n  async poll(interval?: number): Promise<void> {\n    const releaseLock = await this.mutex.acquire();\n    interval && this.configure({ interval }, false, false);\n    this.handle && clearTimeout(this.handle);\n    await this.refresh();\n    this.handle = setTimeout(() => {\n      releaseLock();\n      this.poll(this.config.interval);\n    }, this.config.interval);\n  }\n\n  /**\n   * Refreshes the balances of the accounts depending on the multi-account setting.\n   * If multi-account is disabled, only updates the selected account balance.\n   * If multi-account is enabled, updates balances for all accounts.\n   *\n   * @async\n   */\n  refresh = async () => {\n    const chainId = this.getCurrentChainId();\n    this.syncAccounts(chainId);\n    const accounts = { ...this.state.accounts };\n    const accountsByChainId = Object.assign({}, this.state.accountsByChainId);\n    const accountsForChain = Object.assign({}, accountsByChainId[chainId]);\n    const isMultiAccountBalancesEnabled = this.getMultiAccountBalancesEnabled();\n\n    const accountsToUpdate = isMultiAccountBalancesEnabled\n      ? Object.keys(accounts)\n      : [this.getSelectedAddress()];\n\n    for (const address of accountsToUpdate) {\n      const balance = await this.getBalanceFromChain(address);\n      if (!balance) {\n        continue;\n      }\n      const hexBalance = BNToHex(balance);\n      accounts[address] = {\n        balance: hexBalance,\n      };\n      accountsForChain[address] = {\n        balance: hexBalance,\n      };\n    }\n\n    this.update({\n      accounts,\n      accountsByChainId: Object.assign(Object.assign({}, accountsByChainId), {\n        [chainId]: accountsForChain,\n      }),\n    });\n  };\n\n  /**\n   * Fetches the balance of a given address from the blockchain.\n   *\n   * @param address - The account address to fetch the balance for.\n   * @returns A promise that resolves to the balance in a hex string format.\n   */\n  private async getBalanceFromChain(\n    address: string,\n  ): Promise<string | undefined> {\n    return await safelyExecuteWithTimeout(async () => {\n      assert(this.ethQuery, 'Provider not set.');\n      return await query(this.ethQuery, 'getBalance', [address]);\n    });\n  }\n\n  /**\n   * Sync accounts balances with some additional addresses.\n   *\n   * @param addresses - the additional addresses, may be hardware wallet addresses.\n   * @returns accounts - addresses with synced balance\n   */\n  async syncBalanceWithAddresses(\n    addresses: string[],\n  ): Promise<Record<string, { balance: string }>> {\n    return await Promise.all(\n      addresses.map((address): Promise<[string, string] | undefined> => {\n        return safelyExecuteWithTimeout(async () => {\n          assert(this.ethQuery, 'Provider not set.');\n          const balance = await query(this.ethQuery, 'getBalance', [address]);\n          return [address, balance];\n        });\n      }),\n    ).then((value) => {\n      return value.reduce((obj, item) => {\n        if (!item) {\n          return obj;\n        }\n\n        const [address, balance] = item;\n        return {\n          ...obj,\n          [address]: {\n            balance,\n          },\n        };\n      }, {});\n    });\n  }\n}\n\nexport default AccountTrackerController;\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.mjs b/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.mjs
new file mode 100644
index 0000000..b3b8ea6
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.mjs
@@ -0,0 +1,10 @@
+import {
+  AccountTrackerController,
+  AccountTrackerController_default
+} from "./chunk-PAJTKWEC.mjs";
+import "./chunk-XUI43LEZ.mjs";
+export {
+  AccountTrackerController,
+  AccountTrackerController_default as default
+};
+//# sourceMappingURL=AccountTrackerController.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.mjs.map b/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.mjs.map
new file mode 100644
index 0000000..84c51b2
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/AccountTrackerController.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":[],"sourcesContent":[],"mappings":"","names":[]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/AssetsContractController.d.ts b/node_modules/@metamask/assets-controllers/dist/AssetsContractController.d.ts
index 1d65d48..2f865d2 100644
--- a/node_modules/@metamask/assets-controllers/dist/AssetsContractController.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/AssetsContractController.d.ts
@@ -1,14 +1,13 @@
 /// <reference types="bn.js" />
+import { BN } from 'ethereumjs-util';
 import { Web3Provider } from '@ethersproject/providers';
-import type { BaseConfig, BaseState } from '@metamask/base-controller';
-import { BaseController } from '@metamask/base-controller';
 import type { NetworkClientId, NetworkState, NetworkController } from '@metamask/network-controller';
-import type { PreferencesState } from '@metamask/preferences-controller';
 import type { Hex } from '@metamask/utils';
-import type { BN } from 'ethereumjs-util';
-import { ERC20Standard } from './Standards/ERC20Standard';
-import { ERC1155Standard } from './Standards/NftStandards/ERC1155/ERC1155Standard';
+import { BaseController, BaseConfig, BaseState } from '@metamask/base-controller';
+import type { PreferencesState } from '@metamask/preferences-controller';
 import { ERC721Standard } from './Standards/NftStandards/ERC721/ERC721Standard';
+import { ERC1155Standard } from './Standards/NftStandards/ERC1155/ERC1155Standard';
+import { ERC20Standard } from './Standards/ERC20Standard';
 /**
  * Check if token detection is enabled for certain networks
  *
diff --git a/node_modules/@metamask/assets-controllers/dist/AssetsContractController.d.ts.map b/node_modules/@metamask/assets-controllers/dist/AssetsContractController.d.ts.map
index 5f17118..b70ded6 100644
--- a/node_modules/@metamask/assets-controllers/dist/AssetsContractController.d.ts.map
+++ b/node_modules/@metamask/assets-controllers/dist/AssetsContractController.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"AssetsContractController.d.ts","sourceRoot":"","sources":["../src/AssetsContractController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"AssetsContractController.d.ts","sourceRoot":"","sources":["../src/AssetsContractController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/AssetsContractController.js b/node_modules/@metamask/assets-controllers/dist/AssetsContractController.js
index 8b34ffd..9b2ab2e 100644
--- a/node_modules/@metamask/assets-controllers/dist/AssetsContractController.js
+++ b/node_modules/@metamask/assets-controllers/dist/AssetsContractController.js
@@ -13,15 +13,15 @@ var __importDefault = (this && this.__importDefault) || function (mod) {
 };
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.AssetsContractController = exports.MISSING_PROVIDER_ERROR = exports.SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID = void 0;
+const single_call_balance_checker_abi_1 = __importDefault(require("single-call-balance-checker-abi"));
 const contracts_1 = require("@ethersproject/contracts");
 const providers_1 = require("@ethersproject/providers");
 const base_controller_1 = require("@metamask/base-controller");
 const controller_utils_1 = require("@metamask/controller-utils");
-const single_call_balance_checker_abi_1 = __importDefault(require("single-call-balance-checker-abi"));
 const assetsUtil_1 = require("./assetsUtil");
-const ERC20Standard_1 = require("./Standards/ERC20Standard");
-const ERC1155Standard_1 = require("./Standards/NftStandards/ERC1155/ERC1155Standard");
 const ERC721Standard_1 = require("./Standards/NftStandards/ERC721/ERC721Standard");
+const ERC1155Standard_1 = require("./Standards/NftStandards/ERC1155/ERC1155Standard");
+const ERC20Standard_1 = require("./Standards/ERC20Standard");
 /**
  * Check if token detection is enabled for certain networks
  *
@@ -34,6 +34,12 @@ exports.SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID = {
     [assetsUtil_1.SupportedTokenDetectionNetworks.polygon]: '0x2352c63A83f9Fd126af8676146721Fa00924d7e4',
     [assetsUtil_1.SupportedTokenDetectionNetworks.avax]: '0xD023D153a0DFa485130ECFdE2FAA7e612EF94818',
     [assetsUtil_1.SupportedTokenDetectionNetworks.aurora]: '0x1286415D333855237f89Df27D388127181448538',
+    [assetsUtil_1.SupportedTokenDetectionNetworks.linea_goerli]: '0x10dAd7Ca3921471f616db788D9300DC97Db01783',
+    [assetsUtil_1.SupportedTokenDetectionNetworks.linea_mainnet]: '0xF62e6a41561b3650a69Bb03199C735e3E3328c0D',
+    [assetsUtil_1.SupportedTokenDetectionNetworks.arbitrum]: '0x151E24A486D7258dd7C33Fb67E4bB01919B7B32c',
+    [assetsUtil_1.SupportedTokenDetectionNetworks.optimism]: '0xB1c568e9C3E6bdaf755A60c7418C269eb11524FC',
+    [assetsUtil_1.SupportedTokenDetectionNetworks.base]: '0x6AA75276052D96696134252587894ef5FFA520af',
+    [assetsUtil_1.SupportedTokenDetectionNetworks.zksync]: '0x458fEd3144680a5b8bcfaa0F9594aa19B4Ea2D34',
 };
 exports.MISSING_PROVIDER_ERROR = 'AssetsContractController failed to set the provider correctly. A provider must be set for this method to be available';
 /**
diff --git a/node_modules/@metamask/assets-controllers/dist/AssetsContractController.js.map b/node_modules/@metamask/assets-controllers/dist/AssetsContractController.js.map
index bd7810e..63befed 100644
--- a/node_modules/@metamask/assets-controllers/dist/AssetsContractController.js.map
+++ b/node_modules/@metamask/assets-controllers/dist/AssetsContractController.js.map
@@ -1 +1 @@
-{"version":3,"file":"AssetsContractController.js","sourceRoot":"","sources":["../src/AssetsContractController.ts"],"names":[],"mappings":"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","sourcesContent":["import { Contract } from '@ethersproject/contracts';\nimport { Web3Provider } from '@ethersproject/providers';\nimport type { BaseConfig, BaseState } from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport { IPFS_DEFAULT_GATEWAY_URL } from '@metamask/controller-utils';\nimport type {\n  NetworkClientId,\n  NetworkState,\n  NetworkController,\n} from '@metamask/network-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport type { Hex } from '@metamask/utils';\nimport type { BN } from 'ethereumjs-util';\nimport abiSingleCallBalancesContract from 'single-call-balance-checker-abi';\n\nimport { SupportedTokenDetectionNetworks } from './assetsUtil';\nimport { ERC20Standard } from './Standards/ERC20Standard';\nimport { ERC1155Standard } from './Standards/NftStandards/ERC1155/ERC1155Standard';\nimport { ERC721Standard } from './Standards/NftStandards/ERC721/ERC721Standard';\n\n/**\n * Check if token detection is enabled for certain networks\n *\n * @param chainId - ChainID of network\n * @returns Whether the current network supports token detection\n */\nexport const SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID: Record<Hex, string> = {\n  [SupportedTokenDetectionNetworks.mainnet]:\n    '0xb1f8e55c7f64d203c1400b9d8555d050f94adf39',\n  [SupportedTokenDetectionNetworks.bsc]:\n    '0x2352c63A83f9Fd126af8676146721Fa00924d7e4',\n  [SupportedTokenDetectionNetworks.polygon]:\n    '0x2352c63A83f9Fd126af8676146721Fa00924d7e4',\n  [SupportedTokenDetectionNetworks.avax]:\n    '0xD023D153a0DFa485130ECFdE2FAA7e612EF94818',\n  [SupportedTokenDetectionNetworks.aurora]:\n    '0x1286415D333855237f89Df27D388127181448538',\n};\n\nexport const MISSING_PROVIDER_ERROR =\n  'AssetsContractController failed to set the provider correctly. A provider must be set for this method to be available';\n\n/**\n * @type AssetsContractConfig\n *\n * Assets Contract controller configuration\n * @property provider - Provider used to create a new web3 instance\n */\nexport interface AssetsContractConfig extends BaseConfig {\n  provider: any;\n  ipfsGateway: string;\n  chainId: Hex;\n}\n\n/**\n * @type BalanceMap\n *\n * Key value object containing the balance for each tokenAddress\n * @property [tokenAddress] - Address of the token\n */\nexport interface BalanceMap {\n  [tokenAddress: string]: BN;\n}\n\n/**\n * Controller that interacts with contracts on mainnet through web3\n */\nexport class AssetsContractController extends BaseController<\n  AssetsContractConfig,\n  BaseState\n> {\n  private _provider?: any;\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'AssetsContractController';\n\n  private readonly getNetworkClientById: NetworkController['getNetworkClientById'];\n\n  /**\n   * Creates a AssetsContractController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param options.getNetworkClientById - Gets the network client with the given id from the NetworkController.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      chainId: initialChainId,\n      onPreferencesStateChange,\n      onNetworkStateChange,\n      getNetworkClientById,\n    }: {\n      chainId: Hex;\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      getNetworkClientById: NetworkController['getNetworkClientById'];\n    },\n    config?: Partial<AssetsContractConfig>,\n    state?: Partial<BaseState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      provider: undefined,\n      ipfsGateway: IPFS_DEFAULT_GATEWAY_URL,\n      chainId: initialChainId,\n    };\n    this.initialize();\n    this.getNetworkClientById = getNetworkClientById;\n\n    onPreferencesStateChange(({ ipfsGateway }) => {\n      this.configure({ ipfsGateway });\n    });\n\n    onNetworkStateChange((networkState) => {\n      if (this.config.chainId !== networkState.providerConfig.chainId) {\n        this.configure({\n          chainId: networkState.providerConfig.chainId,\n        });\n      }\n    });\n  }\n\n  /**\n   * Sets a new provider.\n   *\n   * TODO: Replace this wth a method.\n   *\n   * @property provider - Provider used to create a new underlying Web3 instance\n   */\n  set provider(provider: any) {\n    this._provider = provider;\n  }\n\n  get provider() {\n    throw new Error('Property only used for setting');\n  }\n\n  /**\n   * Get the relevant provider instance.\n   *\n   * @param networkClientId - Network Client ID.\n   * @returns Web3Provider instance.\n   */\n  getProvider(networkClientId?: NetworkClientId): Web3Provider {\n    const provider = networkClientId\n      ? this.getNetworkClientById(networkClientId).provider\n      : this._provider;\n\n    if (provider === undefined) {\n      throw new Error(MISSING_PROVIDER_ERROR);\n    }\n\n    return new Web3Provider(provider);\n  }\n\n  /**\n   * Get the relevant chain ID.\n   *\n   * @param networkClientId - Network Client ID used to get the provider.\n   * @returns Hex chain ID.\n   */\n  getChainId(networkClientId?: NetworkClientId): Hex {\n    return networkClientId\n      ? this.getNetworkClientById(networkClientId).configuration.chainId\n      : this.config.chainId;\n  }\n\n  /**\n   * Get a ERC20Standard instance using the relevant provider instance.\n   *\n   * @param networkClientId - Network Client ID used to get the provider.\n   * @returns ERC20Standard instance.\n   */\n  getERC20Standard(networkClientId?: NetworkClientId): ERC20Standard {\n    const provider = this.getProvider(networkClientId);\n    return new ERC20Standard(provider);\n  }\n\n  /**\n   * Get a ERC721Standard instance using the relevant provider instance.\n   *\n   * @param networkClientId - Network Client ID used to get the provider.\n   * @returns ERC721Standard instance.\n   */\n  getERC721Standard(networkClientId?: NetworkClientId): ERC721Standard {\n    const provider = this.getProvider(networkClientId);\n    return new ERC721Standard(provider);\n  }\n\n  /**\n   * Get a ERC1155Standard instance using the relevant provider instance.\n   *\n   * @param networkClientId - Network Client ID used to get the provider.\n   * @returns ERC1155Standard instance.\n   */\n  getERC1155Standard(networkClientId?: NetworkClientId): ERC1155Standard {\n    const provider = this.getProvider(networkClientId);\n    return new ERC1155Standard(provider);\n  }\n\n  /**\n   * Get balance or count for current account on specific asset contract.\n   *\n   * @param address - Asset ERC20 contract address.\n   * @param selectedAddress - Current account public address.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to BN object containing balance for current account on specific asset contract.\n   */\n  async getERC20BalanceOf(\n    address: string,\n    selectedAddress: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<BN> {\n    const erc20Standard = this.getERC20Standard(networkClientId);\n    return erc20Standard.getBalanceOf(address, selectedAddress);\n  }\n\n  /**\n   * Query for the decimals for a given ERC20 asset.\n   *\n   * @param address - ERC20 asset contract address.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'decimals'.\n   */\n  async getERC20TokenDecimals(\n    address: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc20Standard = this.getERC20Standard(networkClientId);\n    return erc20Standard.getTokenDecimals(address);\n  }\n\n  /**\n   * Query for the name for a given ERC20 asset.\n   *\n   * @param address - ERC20 asset contract address.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'decimals'.\n   */\n  async getERC20TokenName(\n    address: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc20Standard = this.getERC20Standard(networkClientId);\n    return erc20Standard.getTokenName(address);\n  }\n\n  /**\n   * Enumerate assets assigned to an owner.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param selectedAddress - Current account public address.\n   * @param index - An NFT counter less than `balanceOf(selectedAddress)`.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to token identifier for the 'index'th asset assigned to 'selectedAddress'.\n   */\n  getERC721NftTokenId(\n    address: string,\n    selectedAddress: string,\n    index: number,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc721Standard = this.getERC721Standard(networkClientId);\n    return erc721Standard.getNftTokenId(address, selectedAddress, index);\n  }\n\n  /**\n   * Enumerate assets assigned to an owner.\n   *\n   * @param tokenAddress - ERC721 asset contract address.\n   * @param userAddress - Current account public address.\n   * @param tokenId - ERC721 asset identifier.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to an object containing the token standard and a set of details which depend on which standard the token supports.\n   */\n  async getTokenStandardAndDetails(\n    tokenAddress: string,\n    userAddress?: string,\n    tokenId?: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<{\n    standard: string;\n    tokenURI?: string | undefined;\n    symbol?: string | undefined;\n    name?: string | undefined;\n    decimals?: string | undefined;\n    balance?: BN | undefined;\n  }> {\n    // Asserts provider is available\n    this.getProvider(networkClientId);\n\n    const { ipfsGateway } = this.config;\n\n    // ERC721\n    try {\n      const erc721Standard = this.getERC721Standard(networkClientId);\n      return {\n        ...(await erc721Standard.getDetails(\n          tokenAddress,\n          ipfsGateway,\n          tokenId,\n        )),\n      };\n    } catch {\n      // Ignore\n    }\n\n    // ERC1155\n    try {\n      const erc1155Standard = this.getERC1155Standard(networkClientId);\n      return {\n        ...(await erc1155Standard.getDetails(\n          tokenAddress,\n          ipfsGateway,\n          tokenId,\n        )),\n      };\n    } catch {\n      // Ignore\n    }\n\n    // ERC20\n    try {\n      const erc20Standard = this.getERC20Standard(networkClientId);\n      return {\n        ...(await erc20Standard.getDetails(tokenAddress, userAddress)),\n      };\n    } catch {\n      // Ignore\n    }\n\n    throw new Error('Unable to determine contract standard');\n  }\n\n  /**\n   * Query for tokenURI for a given ERC721 asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param tokenId - ERC721 asset identifier.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'tokenURI'.\n   */\n  async getERC721TokenURI(\n    address: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc721Standard = this.getERC721Standard(networkClientId);\n    return erc721Standard.getTokenURI(address, tokenId);\n  }\n\n  /**\n   * Query for name for a given asset.\n   *\n   * @param address - ERC721 or ERC20 asset contract address.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'name'.\n   */\n  async getERC721AssetName(\n    address: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc721Standard = this.getERC721Standard(networkClientId);\n    return erc721Standard.getAssetName(address);\n  }\n\n  /**\n   * Query for symbol for a given asset.\n   *\n   * @param address - ERC721 or ERC20 asset contract address.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'symbol'.\n   */\n  async getERC721AssetSymbol(\n    address: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc721Standard = this.getERC721Standard(networkClientId);\n    return erc721Standard.getAssetSymbol(address);\n  }\n\n  /**\n   * Query for owner for a given ERC721 asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param tokenId - ERC721 asset identifier.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the owner address.\n   */\n  async getERC721OwnerOf(\n    address: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc721Standard = this.getERC721Standard(networkClientId);\n    return erc721Standard.getOwnerOf(address, tokenId);\n  }\n\n  /**\n   * Query for tokenURI for a given asset.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @param tokenId - ERC1155 asset identifier.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'tokenURI'.\n   */\n  async getERC1155TokenURI(\n    address: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc1155Standard = this.getERC1155Standard(networkClientId);\n    return erc1155Standard.getTokenURI(address, tokenId);\n  }\n\n  /**\n   * Query for balance of a given ERC 1155 token.\n   *\n   * @param userAddress - Wallet public address.\n   * @param nftAddress - ERC1155 asset contract address.\n   * @param nftId - ERC1155 asset identifier.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'balanceOf'.\n   */\n  async getERC1155BalanceOf(\n    userAddress: string,\n    nftAddress: string,\n    nftId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<BN> {\n    const erc1155Standard = this.getERC1155Standard(networkClientId);\n    return erc1155Standard.getBalanceOf(nftAddress, userAddress, nftId);\n  }\n\n  /**\n   * Transfer single ERC1155 token.\n   *\n   * @param nftAddress - ERC1155 token address.\n   * @param senderAddress - ERC1155 token sender.\n   * @param recipientAddress - ERC1155 token recipient.\n   * @param nftId - ERC1155 token id.\n   * @param qty - Quantity of tokens to be sent.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'transferSingle' ERC1155 token.\n   */\n  async transferSingleERC1155(\n    nftAddress: string,\n    senderAddress: string,\n    recipientAddress: string,\n    nftId: string,\n    qty: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<void> {\n    const erc1155Standard = this.getERC1155Standard(networkClientId);\n    return erc1155Standard.transferSingle(\n      nftAddress,\n      senderAddress,\n      recipientAddress,\n      nftId,\n      qty,\n    );\n  }\n\n  /**\n   * Get the token balance for a list of token addresses in a single call. Only non-zero balances\n   * are returned.\n   *\n   * @param selectedAddress - The address to check token balances for.\n   * @param tokensToDetect - The token addresses to detect balances for.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns The list of non-zero token balances.\n   */\n  async getBalancesInSingleCall(\n    selectedAddress: string,\n    tokensToDetect: string[],\n    networkClientId?: NetworkClientId,\n  ) {\n    const chainId = this.getChainId(networkClientId);\n    const provider = this.getProvider(networkClientId);\n    if (!(chainId in SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID)) {\n      // Only fetch balance if contract address exists\n      return {};\n    }\n    const contractAddress = SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID[chainId];\n\n    const contract = new Contract(\n      contractAddress,\n      abiSingleCallBalancesContract,\n      provider,\n    );\n    const result = await contract.balances([selectedAddress], tokensToDetect);\n    const nonZeroBalances: BalanceMap = {};\n    /* istanbul ignore else */\n    if (result.length > 0) {\n      tokensToDetect.forEach((tokenAddress, index) => {\n        const balance: BN = result[index];\n        /* istanbul ignore else */\n        if (String(balance) !== '0') {\n          nonZeroBalances[tokenAddress] = balance;\n        }\n      });\n    }\n    return nonZeroBalances;\n  }\n}\n\nexport default AssetsContractController;\n"]}
\ No newline at end of file
+{"version":3,"file":"AssetsContractController.js","sourceRoot":"","sources":["../src/AssetsContractController.ts"],"names":[],"mappings":"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","sourcesContent":["import { BN } from 'ethereumjs-util';\nimport abiSingleCallBalancesContract from 'single-call-balance-checker-abi';\nimport { Contract } from '@ethersproject/contracts';\nimport { Web3Provider } from '@ethersproject/providers';\nimport type {\n  NetworkClientId,\n  NetworkState,\n  NetworkController,\n} from '@metamask/network-controller';\nimport type { Hex } from '@metamask/utils';\nimport {\n  BaseController,\n  BaseConfig,\n  BaseState,\n} from '@metamask/base-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport { IPFS_DEFAULT_GATEWAY_URL } from '@metamask/controller-utils';\nimport { SupportedTokenDetectionNetworks } from './assetsUtil';\nimport { ERC721Standard } from './Standards/NftStandards/ERC721/ERC721Standard';\nimport { ERC1155Standard } from './Standards/NftStandards/ERC1155/ERC1155Standard';\nimport { ERC20Standard } from './Standards/ERC20Standard';\n\n/**\n * Check if token detection is enabled for certain networks\n *\n * @param chainId - ChainID of network\n * @returns Whether the current network supports token detection\n */\nexport const SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID: Record<Hex, string> = {\n  [SupportedTokenDetectionNetworks.mainnet]:\n    '0xb1f8e55c7f64d203c1400b9d8555d050f94adf39',\n  [SupportedTokenDetectionNetworks.bsc]:\n    '0x2352c63A83f9Fd126af8676146721Fa00924d7e4',\n  [SupportedTokenDetectionNetworks.polygon]:\n    '0x2352c63A83f9Fd126af8676146721Fa00924d7e4',\n  [SupportedTokenDetectionNetworks.avax]:\n    '0xD023D153a0DFa485130ECFdE2FAA7e612EF94818',\n  [SupportedTokenDetectionNetworks.aurora]:\n    '0x1286415D333855237f89Df27D388127181448538',\n  [SupportedTokenDetectionNetworks.linea_goerli]:\n    '0x10dAd7Ca3921471f616db788D9300DC97Db01783',\n  [SupportedTokenDetectionNetworks.linea_mainnet]:\n    '0xF62e6a41561b3650a69Bb03199C735e3E3328c0D',\n  [SupportedTokenDetectionNetworks.arbitrum]:\n    '0x151E24A486D7258dd7C33Fb67E4bB01919B7B32c',\n  [SupportedTokenDetectionNetworks.optimism]:\n    '0xB1c568e9C3E6bdaf755A60c7418C269eb11524FC',\n  [SupportedTokenDetectionNetworks.base]:\n    '0x6AA75276052D96696134252587894ef5FFA520af',\n  [SupportedTokenDetectionNetworks.zksync]:\n    '0x458fEd3144680a5b8bcfaa0F9594aa19B4Ea2D34',\n};\n\nexport const MISSING_PROVIDER_ERROR =\n  'AssetsContractController failed to set the provider correctly. A provider must be set for this method to be available';\n\n/**\n * @type AssetsContractConfig\n *\n * Assets Contract controller configuration\n * @property provider - Provider used to create a new web3 instance\n */\nexport interface AssetsContractConfig extends BaseConfig {\n  provider: any;\n  ipfsGateway: string;\n  chainId: Hex;\n}\n\n/**\n * @type BalanceMap\n *\n * Key value object containing the balance for each tokenAddress\n * @property [tokenAddress] - Address of the token\n */\nexport interface BalanceMap {\n  [tokenAddress: string]: BN;\n}\n\n/**\n * Controller that interacts with contracts on mainnet through web3\n */\nexport class AssetsContractController extends BaseController<\n  AssetsContractConfig,\n  BaseState\n> {\n  private _provider?: any;\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'AssetsContractController';\n\n  private readonly getNetworkClientById: NetworkController['getNetworkClientById'];\n\n  /**\n   * Creates a AssetsContractController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param options.getNetworkClientById - Gets the network client with the given id from the NetworkController.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      chainId: initialChainId,\n      onPreferencesStateChange,\n      onNetworkStateChange,\n      getNetworkClientById,\n    }: {\n      chainId: Hex;\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      getNetworkClientById: NetworkController['getNetworkClientById'];\n    },\n    config?: Partial<AssetsContractConfig>,\n    state?: Partial<BaseState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      provider: undefined,\n      ipfsGateway: IPFS_DEFAULT_GATEWAY_URL,\n      chainId: initialChainId,\n    };\n    this.initialize();\n    this.getNetworkClientById = getNetworkClientById;\n\n    onPreferencesStateChange(({ ipfsGateway }) => {\n      this.configure({ ipfsGateway });\n    });\n\n    onNetworkStateChange((networkState) => {\n      if (this.config.chainId !== networkState.providerConfig.chainId) {\n        this.configure({\n          chainId: networkState.providerConfig.chainId,\n        });\n      }\n    });\n  }\n\n  /**\n   * Sets a new provider.\n   *\n   * TODO: Replace this wth a method.\n   *\n   * @property provider - Provider used to create a new underlying Web3 instance\n   */\n  set provider(provider: any) {\n    this._provider = provider;\n  }\n\n  get provider() {\n    throw new Error('Property only used for setting');\n  }\n\n  /**\n   * Get the relevant provider instance.\n   *\n   * @param networkClientId - Network Client ID.\n   * @returns Web3Provider instance.\n   */\n  getProvider(networkClientId?: NetworkClientId): Web3Provider {\n    const provider = networkClientId\n      ? this.getNetworkClientById(networkClientId).provider\n      : this._provider;\n\n    if (provider === undefined) {\n      throw new Error(MISSING_PROVIDER_ERROR);\n    }\n\n    return new Web3Provider(provider);\n  }\n\n  /**\n   * Get the relevant chain ID.\n   *\n   * @param networkClientId - Network Client ID used to get the provider.\n   * @returns Hex chain ID.\n   */\n  getChainId(networkClientId?: NetworkClientId): Hex {\n    return networkClientId\n      ? this.getNetworkClientById(networkClientId).configuration.chainId\n      : this.config.chainId;\n  }\n\n  /**\n   * Get a ERC20Standard instance using the relevant provider instance.\n   *\n   * @param networkClientId - Network Client ID used to get the provider.\n   * @returns ERC20Standard instance.\n   */\n  getERC20Standard(networkClientId?: NetworkClientId): ERC20Standard {\n    const provider = this.getProvider(networkClientId);\n    return new ERC20Standard(provider);\n  }\n\n  /**\n   * Get a ERC721Standard instance using the relevant provider instance.\n   *\n   * @param networkClientId - Network Client ID used to get the provider.\n   * @returns ERC721Standard instance.\n   */\n  getERC721Standard(networkClientId?: NetworkClientId): ERC721Standard {\n    const provider = this.getProvider(networkClientId);\n    return new ERC721Standard(provider);\n  }\n\n  /**\n   * Get a ERC1155Standard instance using the relevant provider instance.\n   *\n   * @param networkClientId - Network Client ID used to get the provider.\n   * @returns ERC1155Standard instance.\n   */\n  getERC1155Standard(networkClientId?: NetworkClientId): ERC1155Standard {\n    const provider = this.getProvider(networkClientId);\n    return new ERC1155Standard(provider);\n  }\n\n  /**\n   * Get balance or count for current account on specific asset contract.\n   *\n   * @param address - Asset ERC20 contract address.\n   * @param selectedAddress - Current account public address.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to BN object containing balance for current account on specific asset contract.\n   */\n  async getERC20BalanceOf(\n    address: string,\n    selectedAddress: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<BN> {\n    const erc20Standard = this.getERC20Standard(networkClientId);\n    return erc20Standard.getBalanceOf(address, selectedAddress);\n  }\n\n  /**\n   * Query for the decimals for a given ERC20 asset.\n   *\n   * @param address - ERC20 asset contract address.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'decimals'.\n   */\n  async getERC20TokenDecimals(\n    address: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc20Standard = this.getERC20Standard(networkClientId);\n    return erc20Standard.getTokenDecimals(address);\n  }\n\n  /**\n   * Query for the name for a given ERC20 asset.\n   *\n   * @param address - ERC20 asset contract address.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'decimals'.\n   */\n  async getERC20TokenName(\n    address: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc20Standard = this.getERC20Standard(networkClientId);\n    return erc20Standard.getTokenName(address);\n  }\n\n  /**\n   * Enumerate assets assigned to an owner.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param selectedAddress - Current account public address.\n   * @param index - An NFT counter less than `balanceOf(selectedAddress)`.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to token identifier for the 'index'th asset assigned to 'selectedAddress'.\n   */\n  getERC721NftTokenId(\n    address: string,\n    selectedAddress: string,\n    index: number,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc721Standard = this.getERC721Standard(networkClientId);\n    return erc721Standard.getNftTokenId(address, selectedAddress, index);\n  }\n\n  /**\n   * Enumerate assets assigned to an owner.\n   *\n   * @param tokenAddress - ERC721 asset contract address.\n   * @param userAddress - Current account public address.\n   * @param tokenId - ERC721 asset identifier.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to an object containing the token standard and a set of details which depend on which standard the token supports.\n   */\n  async getTokenStandardAndDetails(\n    tokenAddress: string,\n    userAddress?: string,\n    tokenId?: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<{\n    standard: string;\n    tokenURI?: string | undefined;\n    symbol?: string | undefined;\n    name?: string | undefined;\n    decimals?: string | undefined;\n    balance?: BN | undefined;\n  }> {\n    // Asserts provider is available\n    this.getProvider(networkClientId);\n\n    const { ipfsGateway } = this.config;\n\n    // ERC721\n    try {\n      const erc721Standard = this.getERC721Standard(networkClientId);\n      return {\n        ...(await erc721Standard.getDetails(\n          tokenAddress,\n          ipfsGateway,\n          tokenId,\n        )),\n      };\n    } catch {\n      // Ignore\n    }\n\n    // ERC1155\n    try {\n      const erc1155Standard = this.getERC1155Standard(networkClientId);\n      return {\n        ...(await erc1155Standard.getDetails(\n          tokenAddress,\n          ipfsGateway,\n          tokenId,\n        )),\n      };\n    } catch {\n      // Ignore\n    }\n\n    // ERC20\n    try {\n      const erc20Standard = this.getERC20Standard(networkClientId);\n      return {\n        ...(await erc20Standard.getDetails(tokenAddress, userAddress)),\n      };\n    } catch {\n      // Ignore\n    }\n\n    throw new Error('Unable to determine contract standard');\n  }\n\n  /**\n   * Query for tokenURI for a given ERC721 asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param tokenId - ERC721 asset identifier.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'tokenURI'.\n   */\n  async getERC721TokenURI(\n    address: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc721Standard = this.getERC721Standard(networkClientId);\n    return erc721Standard.getTokenURI(address, tokenId);\n  }\n\n  /**\n   * Query for name for a given asset.\n   *\n   * @param address - ERC721 or ERC20 asset contract address.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'name'.\n   */\n  async getERC721AssetName(\n    address: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc721Standard = this.getERC721Standard(networkClientId);\n    return erc721Standard.getAssetName(address);\n  }\n\n  /**\n   * Query for symbol for a given asset.\n   *\n   * @param address - ERC721 or ERC20 asset contract address.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'symbol'.\n   */\n  async getERC721AssetSymbol(\n    address: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc721Standard = this.getERC721Standard(networkClientId);\n    return erc721Standard.getAssetSymbol(address);\n  }\n\n  /**\n   * Query for owner for a given ERC721 asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param tokenId - ERC721 asset identifier.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the owner address.\n   */\n  async getERC721OwnerOf(\n    address: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc721Standard = this.getERC721Standard(networkClientId);\n    return erc721Standard.getOwnerOf(address, tokenId);\n  }\n\n  /**\n   * Query for tokenURI for a given asset.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @param tokenId - ERC1155 asset identifier.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'tokenURI'.\n   */\n  async getERC1155TokenURI(\n    address: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc1155Standard = this.getERC1155Standard(networkClientId);\n    return erc1155Standard.getTokenURI(address, tokenId);\n  }\n\n  /**\n   * Query for balance of a given ERC 1155 token.\n   *\n   * @param userAddress - Wallet public address.\n   * @param nftAddress - ERC1155 asset contract address.\n   * @param nftId - ERC1155 asset identifier.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'balanceOf'.\n   */\n  async getERC1155BalanceOf(\n    userAddress: string,\n    nftAddress: string,\n    nftId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<BN> {\n    const erc1155Standard = this.getERC1155Standard(networkClientId);\n    return erc1155Standard.getBalanceOf(nftAddress, userAddress, nftId);\n  }\n\n  /**\n   * Transfer single ERC1155 token.\n   *\n   * @param nftAddress - ERC1155 token address.\n   * @param senderAddress - ERC1155 token sender.\n   * @param recipientAddress - ERC1155 token recipient.\n   * @param nftId - ERC1155 token id.\n   * @param qty - Quantity of tokens to be sent.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'transferSingle' ERC1155 token.\n   */\n  async transferSingleERC1155(\n    nftAddress: string,\n    senderAddress: string,\n    recipientAddress: string,\n    nftId: string,\n    qty: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<void> {\n    const erc1155Standard = this.getERC1155Standard(networkClientId);\n    return erc1155Standard.transferSingle(\n      nftAddress,\n      senderAddress,\n      recipientAddress,\n      nftId,\n      qty,\n    );\n  }\n\n  /**\n   * Get the token balance for a list of token addresses in a single call. Only non-zero balances\n   * are returned.\n   *\n   * @param selectedAddress - The address to check token balances for.\n   * @param tokensToDetect - The token addresses to detect balances for.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns The list of non-zero token balances.\n   */\n  async getBalancesInSingleCall(\n    selectedAddress: string,\n    tokensToDetect: string[],\n    networkClientId?: NetworkClientId,\n  ) {\n    const chainId = this.getChainId(networkClientId);\n    const provider = this.getProvider(networkClientId);\n    if (!(chainId in SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID)) {\n      // Only fetch balance if contract address exists\n      return {};\n    }\n    const contractAddress = SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID[chainId];\n\n    const contract = new Contract(\n      contractAddress,\n      abiSingleCallBalancesContract,\n      provider,\n    );\n    const result = await contract.balances([selectedAddress], tokensToDetect);\n    const nonZeroBalances: BalanceMap = {};\n    /* istanbul ignore else */\n    if (result.length > 0) {\n      tokensToDetect.forEach((tokenAddress, index) => {\n        const balance: BN = result[index];\n        /* istanbul ignore else */\n        if (String(balance) !== '0') {\n          nonZeroBalances[tokenAddress] = balance;\n        }\n      });\n    }\n    return nonZeroBalances;\n  }\n}\n\nexport default AssetsContractController;\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/AssetsContractController.mjs b/node_modules/@metamask/assets-controllers/dist/AssetsContractController.mjs
new file mode 100644
index 0000000..1b1b09c
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/AssetsContractController.mjs
@@ -0,0 +1,18 @@
+import {
+  AssetsContractController,
+  AssetsContractController_default,
+  MISSING_PROVIDER_ERROR,
+  SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID
+} from "./chunk-KCUSDOIE.mjs";
+import "./chunk-WIVSZVF4.mjs";
+import "./chunk-CEENXWOB.mjs";
+import "./chunk-MQ7TIWBK.mjs";
+import "./chunk-E5PIGGYR.mjs";
+import "./chunk-XUI43LEZ.mjs";
+export {
+  AssetsContractController,
+  MISSING_PROVIDER_ERROR,
+  SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID,
+  AssetsContractController_default as default
+};
+//# sourceMappingURL=AssetsContractController.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/AssetsContractController.mjs.map b/node_modules/@metamask/assets-controllers/dist/AssetsContractController.mjs.map
new file mode 100644
index 0000000..84c51b2
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/AssetsContractController.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":[],"sourcesContent":[],"mappings":"","names":[]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/CurrencyRateController.d.ts b/node_modules/@metamask/assets-controllers/dist/CurrencyRateController.d.ts
index 02fe211..e2658b8 100644
--- a/node_modules/@metamask/assets-controllers/dist/CurrencyRateController.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/CurrencyRateController.d.ts
@@ -1,6 +1,5 @@
-import type { RestrictedControllerMessenger } from '@metamask/base-controller';
-import { BaseControllerV2 } from '@metamask/base-controller';
 import type { Patch } from 'immer';
+import { BaseControllerV2, RestrictedControllerMessenger } from '@metamask/base-controller';
 import { fetchExchangeRate as defaultFetchExchangeRate } from './crypto-compare';
 /**
  * @type CurrencyRateState
@@ -37,11 +36,11 @@ declare type CurrencyRateMessenger = RestrictedControllerMessenger<typeof name,
  */
 export declare class CurrencyRateController extends BaseControllerV2<typeof name, CurrencyRateState, CurrencyRateMessenger> {
     #private;
-    private readonly mutex;
+    private mutex;
     private intervalId?;
-    private readonly intervalDelay;
-    private readonly fetchExchangeRate;
-    private readonly includeUsdRate;
+    private intervalDelay;
+    private fetchExchangeRate;
+    private includeUsdRate;
     /**
      * Creates a CurrencyRateController instance.
      *
diff --git a/node_modules/@metamask/assets-controllers/dist/CurrencyRateController.d.ts.map b/node_modules/@metamask/assets-controllers/dist/CurrencyRateController.d.ts.map
index d95d129..8af66c4 100644
--- a/node_modules/@metamask/assets-controllers/dist/CurrencyRateController.d.ts.map
+++ b/node_modules/@metamask/assets-controllers/dist/CurrencyRateController.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"CurrencyRateController.d.ts","sourceRoot":"","sources":["../src/CurrencyRateController.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,6BAA6B,EAAE,MAAM,2BAA2B,CAAC;AAC/E,OAAO,EAAE,gBAAgB,EAAE,MAAM,2BAA2B,CAAC;AAO7D,OAAO,KAAK,EAAE,KAAK,EAAE,MAAM,OAAO,CAAC;AAEnC,OAAO,EAAE,iBAAiB,IAAI,wBAAwB,EAAE,MAAM,kBAAkB,CAAC;AAEjF;;;;;;;;;GASG;AACH,oBAAY,iBAAiB,GAAG;IAC9B,cAAc,EAAE,MAAM,GAAG,IAAI,CAAC;IAC9B,cAAc,EAAE,MAAM,GAAG,IAAI,CAAC;IAC9B,eAAe,EAAE,MAAM,CAAC;IACxB,cAAc,EAAE,MAAM,CAAC;IACvB,sBAAsB,EAAE,MAAM,GAAG,IAAI,CAAC;IACtC,qBAAqB,EAAE,MAAM,GAAG,IAAI,CAAC;IACrC,iBAAiB,EAAE,MAAM,GAAG,IAAI,CAAC;CAClC,CAAC;AAEF,QAAA,MAAM,IAAI,2BAA2B,CAAC;AAEtC,oBAAY,uBAAuB,GAAG;IACpC,IAAI,EAAE,GAAG,OAAO,IAAI,cAAc,CAAC;IACnC,OAAO,EAAE,CAAC,iBAAiB,EAAE,KAAK,EAAE,CAAC,CAAC;CACvC,CAAC;AAEF,oBAAY,oBAAoB,GAAG;IACjC,IAAI,EAAE,GAAG,OAAO,IAAI,WAAW,CAAC;IAChC,OAAO,EAAE,MAAM,iBAAiB,CAAC;CAClC,CAAC;AAEF,aAAK,qBAAqB,GAAG,6BAA6B,CACxD,OAAO,IAAI,EACX,oBAAoB,EACpB,uBAAuB,EACvB,KAAK,EACL,KAAK,CACN,CAAC;AAsBF;;;GAGG;AACH,qBAAa,sBAAuB,SAAQ,gBAAgB,CAC1D,OAAO,IAAI,EACX,iBAAiB,EACjB,qBAAqB,CACtB;;IACC,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAe;IAErC,OAAO,CAAC,UAAU,CAAC,CAAgC;IAEnD,OAAO,CAAC,QAAQ,CAAC,aAAa,CAAC;IAE/B,OAAO,CAAC,QAAQ,CAAC,iBAAiB,CAAC;IAEnC,OAAO,CAAC,QAAQ,CAAC,cAAc,CAAC;IAOhC;;;;;;;;;OASG;gBACS,EACV,cAAsB,EACtB,QAAiB,EACjB,SAAS,EACT,KAAK,EACL,iBAA4C,GAC7C,EAAE;QACD,cAAc,CAAC,EAAE,OAAO,CAAC;QACzB,QAAQ,CAAC,EAAE,MAAM,CAAC;QAClB,SAAS,EAAE,qBAAqB,CAAC;QACjC,KAAK,CAAC,EAAE,OAAO,CAAC,iBAAiB,CAAC,CAAC;QACnC,iBAAiB,CAAC,EAAE,OAAO,wBAAwB,CAAC;KACrD;IAaD;;OAEG;IACG,KAAK;IAMX;;OAEG;IACH,IAAI;IAMJ;;;;OAIG;IACM,OAAO;IAKhB;;;;OAIG;IACG,kBAAkB,CAAC,eAAe,EAAE,MAAM;IAOhD;;;;OAIG;IACG,iBAAiB,CAAC,MAAM,EAAE,MAAM;IAOtC,OAAO,CAAC,WAAW;IAMnB;;OAEG;YACW,YAAY;IAW1B;;;;OAIG;IACG,kBAAkB,IAAI,OAAO,CAAC,iBAAiB,GAAG,IAAI,CAAC;CA+E9D;AAED,eAAe,sBAAsB,CAAC"}
\ No newline at end of file
+{"version":3,"file":"CurrencyRateController.d.ts","sourceRoot":"","sources":["../src/CurrencyRateController.ts"],"names":[],"mappings":"AACA,OAAO,KAAK,EAAE,KAAK,EAAE,MAAM,OAAO,CAAC;AACnC,OAAO,EACL,gBAAgB,EAChB,6BAA6B,EAC9B,MAAM,2BAA2B,CAAC;AAMnC,OAAO,EAAE,iBAAiB,IAAI,wBAAwB,EAAE,MAAM,kBAAkB,CAAC;AAEjF;;;;;;;;;GASG;AACH,oBAAY,iBAAiB,GAAG;IAC9B,cAAc,EAAE,MAAM,GAAG,IAAI,CAAC;IAC9B,cAAc,EAAE,MAAM,GAAG,IAAI,CAAC;IAC9B,eAAe,EAAE,MAAM,CAAC;IACxB,cAAc,EAAE,MAAM,CAAC;IACvB,sBAAsB,EAAE,MAAM,GAAG,IAAI,CAAC;IACtC,qBAAqB,EAAE,MAAM,GAAG,IAAI,CAAC;IACrC,iBAAiB,EAAE,MAAM,GAAG,IAAI,CAAC;CAClC,CAAC;AAEF,QAAA,MAAM,IAAI,2BAA2B,CAAC;AAEtC,oBAAY,uBAAuB,GAAG;IACpC,IAAI,EAAE,GAAG,OAAO,IAAI,cAAc,CAAC;IACnC,OAAO,EAAE,CAAC,iBAAiB,EAAE,KAAK,EAAE,CAAC,CAAC;CACvC,CAAC;AAEF,oBAAY,oBAAoB,GAAG;IACjC,IAAI,EAAE,GAAG,OAAO,IAAI,WAAW,CAAC;IAChC,OAAO,EAAE,MAAM,iBAAiB,CAAC;CAClC,CAAC;AAEF,aAAK,qBAAqB,GAAG,6BAA6B,CACxD,OAAO,IAAI,EACX,oBAAoB,EACpB,uBAAuB,EACvB,KAAK,EACL,KAAK,CACN,CAAC;AAsBF;;;GAGG;AACH,qBAAa,sBAAuB,SAAQ,gBAAgB,CAC1D,OAAO,IAAI,EACX,iBAAiB,EACjB,qBAAqB,CACtB;;IACC,OAAO,CAAC,KAAK,CAAe;IAE5B,OAAO,CAAC,UAAU,CAAC,CAAgC;IAEnD,OAAO,CAAC,aAAa,CAAC;IAEtB,OAAO,CAAC,iBAAiB,CAAC;IAE1B,OAAO,CAAC,cAAc,CAAC;IAOvB;;;;;;;;;OASG;gBACS,EACV,cAAsB,EACtB,QAAiB,EACjB,SAAS,EACT,KAAK,EACL,iBAA4C,GAC7C,EAAE;QACD,cAAc,CAAC,EAAE,OAAO,CAAC;QACzB,QAAQ,CAAC,EAAE,MAAM,CAAC;QAClB,SAAS,EAAE,qBAAqB,CAAC;QACjC,KAAK,CAAC,EAAE,OAAO,CAAC,iBAAiB,CAAC,CAAC;QACnC,iBAAiB,CAAC,EAAE,OAAO,wBAAwB,CAAC;KACrD;IAaD;;OAEG;IACG,KAAK;IAMX;;OAEG;IACH,IAAI;IAMJ;;;;OAIG;IACM,OAAO;IAKhB;;;;OAIG;IACG,kBAAkB,CAAC,eAAe,EAAE,MAAM;IAOhD;;;;OAIG;IACG,iBAAiB,CAAC,MAAM,EAAE,MAAM;IAOtC,OAAO,CAAC,WAAW;IAMnB;;OAEG;YACW,YAAY;IAW1B;;;;OAIG;IACG,kBAAkB,IAAI,OAAO,CAAC,iBAAiB,GAAG,IAAI,CAAC;CA+E9D;AAED,eAAe,sBAAsB,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/CurrencyRateController.js b/node_modules/@metamask/assets-controllers/dist/CurrencyRateController.js
index 10de45d..cf5caed 100644
--- a/node_modules/@metamask/assets-controllers/dist/CurrencyRateController.js
+++ b/node_modules/@metamask/assets-controllers/dist/CurrencyRateController.js
@@ -22,9 +22,9 @@ var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (
 var _CurrencyRateController_enabled;
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.CurrencyRateController = void 0;
+const async_mutex_1 = require("async-mutex");
 const base_controller_1 = require("@metamask/base-controller");
 const controller_utils_1 = require("@metamask/controller-utils");
-const async_mutex_1 = require("async-mutex");
 const crypto_compare_1 = require("./crypto-compare");
 const name = 'CurrencyRateController';
 const metadata = {
diff --git a/node_modules/@metamask/assets-controllers/dist/CurrencyRateController.js.map b/node_modules/@metamask/assets-controllers/dist/CurrencyRateController.js.map
index 19038c2..7de82d8 100644
--- a/node_modules/@metamask/assets-controllers/dist/CurrencyRateController.js.map
+++ b/node_modules/@metamask/assets-controllers/dist/CurrencyRateController.js.map
@@ -1 +1 @@
-{"version":3,"file":"CurrencyRateController.js","sourceRoot":"","sources":["../src/CurrencyRateController.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AACA,+DAA6D;AAC7D,iEAIoC;AACpC,6CAAoC;AAGpC,qDAAiF;AAsBjF,MAAM,IAAI,GAAG,wBAAwB,CAAC;AAoBtC,MAAM,QAAQ,GAAG;IACf,cAAc,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAE;IAClD,cAAc,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAE;IAClD,eAAe,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAE;IACnD,cAAc,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAE;IAClD,sBAAsB,EAAE,EAAE,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,IAAI,EAAE;IAC3D,qBAAqB,EAAE,EAAE,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,IAAI,EAAE;IAC1D,iBAAiB,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAE;CACtD,CAAC;AAEF,MAAM,YAAY,GAAG;IACnB,cAAc,EAAE,CAAC;IACjB,cAAc,EAAE,CAAC;IACjB,eAAe,EAAE,KAAK;IACtB,cAAc,EAAE,KAAK;IACrB,sBAAsB,EAAE,IAAI;IAC5B,qBAAqB,EAAE,IAAI;IAC3B,iBAAiB,EAAE,IAAI;CACxB,CAAC;AAEF;;;GAGG;AACH,MAAa,sBAAuB,SAAQ,kCAI3C;IAgBC;;;;;;;;;OASG;IACH,YAAY,EACV,cAAc,GAAG,KAAK,EACtB,QAAQ,GAAG,MAAM,EACjB,SAAS,EACT,KAAK,EACL,iBAAiB,GAAG,kCAAwB,GAO7C;QACC,KAAK,CAAC;YACJ,IAAI;YACJ,QAAQ;YACR,SAAS;YACT,KAAK,kCAAO,YAAY,GAAK,KAAK,CAAE;SACrC,CAAC,CAAC;QA3CY,UAAK,GAAG,IAAI,mBAAK,EAAE,CAAC;QAUrC;;WAEG;QACH,kDAAS;QA+BP,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC;QACrC,IAAI,CAAC,aAAa,GAAG,QAAQ,CAAC;QAC9B,IAAI,CAAC,iBAAiB,GAAG,iBAAiB,CAAC;QAC3C,uBAAA,IAAI,mCAAY,KAAK,MAAA,CAAC;IACxB,CAAC;IAED;;OAEG;IACG,KAAK;;YACT,uBAAA,IAAI,mCAAY,IAAI,MAAA,CAAC;YAErB,MAAM,IAAI,CAAC,YAAY,EAAE,CAAC;QAC5B,CAAC;KAAA;IAED;;OAEG;IACH,IAAI;QACF,uBAAA,IAAI,mCAAY,KAAK,MAAA,CAAC;QAEtB,IAAI,CAAC,WAAW,EAAE,CAAC;IACrB,CAAC;IAED;;;;OAIG;IACM,OAAO;QACd,KAAK,CAAC,OAAO,EAAE,CAAC;QAChB,IAAI,CAAC,WAAW,EAAE,CAAC;IACrB,CAAC;IAED;;;;OAIG;IACG,kBAAkB,CAAC,eAAuB;;YAC9C,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,EAAE;gBACpB,KAAK,CAAC,sBAAsB,GAAG,eAAe,CAAC;YACjD,CAAC,CAAC,CAAC;YACH,MAAM,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAClC,CAAC;KAAA;IAED;;;;OAIG;IACG,iBAAiB,CAAC,MAAc;;YACpC,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,EAAE;gBACpB,KAAK,CAAC,qBAAqB,GAAG,MAAM,CAAC;YACvC,CAAC,CAAC,CAAC;YACH,MAAM,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAClC,CAAC;KAAA;IAEO,WAAW;QACjB,IAAI,IAAI,CAAC,UAAU,EAAE;YACnB,aAAa,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;SAChC;IACH,CAAC;IAED;;OAEG;IACW,YAAY;;YACxB,IAAI,CAAC,WAAW,EAAE,CAAC;YACnB,mDAAmD;YAEnD,MAAM,IAAA,gCAAa,EAAC,GAAS,EAAE,gDAAC,OAAA,MAAM,IAAI,CAAC,kBAAkB,EAAE,CAAA,GAAA,CAAC,CAAC;YAEjE,IAAI,CAAC,UAAU,GAAG,WAAW,CAAC,GAAS,EAAE;gBACvC,MAAM,IAAA,gCAAa,EAAC,GAAS,EAAE,gDAAC,OAAA,MAAM,IAAI,CAAC,kBAAkB,EAAE,CAAA,GAAA,CAAC,CAAC;YACnE,CAAC,CAAA,EAAE,IAAI,CAAC,aAAa,CAAC,CAAC;QACzB,CAAC;KAAA;IAED;;;;OAIG;IACG,kBAAkB;;YACtB,IAAI,CAAC,uBAAA,IAAI,uCAAS,EAAE;gBAClB,OAAO,CAAC,IAAI,CACV,+FAA+F,CAChG,CAAC;gBACF,OAAO,IAAI,CAAC,KAAK,CAAC;aACnB;YACD,MAAM,WAAW,GAAG,MAAM,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,CAAC;YAC/C,MAAM,EACJ,eAAe,EAAE,oBAAoB,EACrC,cAAc,EAAE,mBAAmB,EACnC,sBAAsB,EACtB,qBAAqB,GACtB,GAAG,IAAI,CAAC,KAAK,CAAC;YAEf,IAAI,cAAc,GAAkB,IAAI,CAAC;YACzC,IAAI,cAAc,GAAkB,IAAI,CAAC;YACzC,IAAI,iBAAiB,GAAkB,IAAI,CAAC;YAC5C,MAAM,eAAe,GAAG,sBAAsB,aAAtB,sBAAsB,cAAtB,sBAAsB,GAAI,oBAAoB,CAAC;YACvE,MAAM,cAAc,GAAG,qBAAqB,aAArB,qBAAqB,cAArB,qBAAqB,GAAI,mBAAmB,CAAC;YAEpE,wFAAwF;YACxF,MAAM,6BAA6B,GAAG,MAAM,CAAC,MAAM,CACjD,yCAAsB,CACvB,CAAC,QAAQ,CAAC,cAAc,CAAC;gBACxB,CAAC,CAAC,wCAAqB,CAAC,MAAM;gBAC9B,CAAC,CAAC,cAAc,CAAC;YAEnB,IAAI;gBACF,IACE,eAAe;oBACf,cAAc;oBACd,mEAAmE;oBACnE,iEAAiE;oBACjE,oCAAoC;oBACpC,eAAe,KAAK,EAAE;oBACtB,cAAc,KAAK,EAAE,EACrB;oBACA,MAAM,yBAAyB,GAAG,MAAM,IAAI,CAAC,iBAAiB,CAC5D,eAAe,EACf,6BAA6B,EAC7B,IAAI,CAAC,cAAc,CACpB,CAAC;oBAEF,cAAc,GAAG,yBAAyB,CAAC,cAAc,CAAC;oBAC1D,iBAAiB,GAAG,yBAAyB,CAAC,iBAAiB,CAAC;oBAChE,cAAc,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC;iBACpC;aACF;YAAC,OAAO,KAAK,EAAE;gBACd,IACE,CAAC,CACC,KAAK,YAAY,KAAK;oBACtB,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,0CAA0C,CAAC,CACnE,EACD;oBACA,MAAM,KAAK,CAAC;iBACb;aACF;oBAAS;gBACR,IAAI;oBACF,IAAI,CAAC,MAAM,CAAC,GAAG,EAAE;wBACf,OAAO;4BACL,cAAc;4BACd,cAAc;4BACd,0EAA0E;4BAC1E,oFAAoF;4BACpF,uFAAuF;4BACvF,cAAc;4BACd,eAAe;4BACf,sBAAsB,EAAE,IAAI;4BAC5B,qBAAqB,EAAE,IAAI;4BAC3B,iBAAiB;yBAClB,CAAC;oBACJ,CAAC,CAAC,CAAC;iBACJ;wBAAS;oBACR,WAAW,EAAE,CAAC;iBACf;aACF;YACD,OAAO,IAAI,CAAC,KAAK,CAAC;QACpB,CAAC;KAAA;CACF;AAnND,wDAmNC;;AAED,kBAAe,sBAAsB,CAAC","sourcesContent":["import type { RestrictedControllerMessenger } from '@metamask/base-controller';\nimport { BaseControllerV2 } from '@metamask/base-controller';\nimport {\n  TESTNET_TICKER_SYMBOLS,\n  FALL_BACK_VS_CURRENCY,\n  safelyExecute,\n} from '@metamask/controller-utils';\nimport { Mutex } from 'async-mutex';\nimport type { Patch } from 'immer';\n\nimport { fetchExchangeRate as defaultFetchExchangeRate } from './crypto-compare';\n\n/**\n * @type CurrencyRateState\n * @property conversionDate - Timestamp of conversion rate expressed in ms since UNIX epoch\n * @property conversionRate - Conversion rate from current base asset to the current currency\n * @property currentCurrency - Currently-active ISO 4217 currency code\n * @property nativeCurrency - Symbol for the base asset used for conversion\n * @property pendingCurrentCurrency - The currency being switched to\n * @property pendingNativeCurrency - The base asset currency being switched to\n * @property usdConversionRate - Conversion rate from usd to the current currency\n */\nexport type CurrencyRateState = {\n  conversionDate: number | null;\n  conversionRate: number | null;\n  currentCurrency: string;\n  nativeCurrency: string;\n  pendingCurrentCurrency: string | null;\n  pendingNativeCurrency: string | null;\n  usdConversionRate: number | null;\n};\n\nconst name = 'CurrencyRateController';\n\nexport type CurrencyRateStateChange = {\n  type: `${typeof name}:stateChange`;\n  payload: [CurrencyRateState, Patch[]];\n};\n\nexport type GetCurrencyRateState = {\n  type: `${typeof name}:getState`;\n  handler: () => CurrencyRateState;\n};\n\ntype CurrencyRateMessenger = RestrictedControllerMessenger<\n  typeof name,\n  GetCurrencyRateState,\n  CurrencyRateStateChange,\n  never,\n  never\n>;\n\nconst metadata = {\n  conversionDate: { persist: true, anonymous: true },\n  conversionRate: { persist: true, anonymous: true },\n  currentCurrency: { persist: true, anonymous: true },\n  nativeCurrency: { persist: true, anonymous: true },\n  pendingCurrentCurrency: { persist: false, anonymous: true },\n  pendingNativeCurrency: { persist: false, anonymous: true },\n  usdConversionRate: { persist: true, anonymous: true },\n};\n\nconst defaultState = {\n  conversionDate: 0,\n  conversionRate: 0,\n  currentCurrency: 'usd',\n  nativeCurrency: 'ETH',\n  pendingCurrentCurrency: null,\n  pendingNativeCurrency: null,\n  usdConversionRate: null,\n};\n\n/**\n * Controller that passively polls on a set interval for an exchange rate from the current network\n * asset to the user's preferred currency.\n */\nexport class CurrencyRateController extends BaseControllerV2<\n  typeof name,\n  CurrencyRateState,\n  CurrencyRateMessenger\n> {\n  private readonly mutex = new Mutex();\n\n  private intervalId?: ReturnType<typeof setTimeout>;\n\n  private readonly intervalDelay;\n\n  private readonly fetchExchangeRate;\n\n  private readonly includeUsdRate;\n\n  /**\n   * A boolean that controls whether or not network requests can be made by the controller\n   */\n  #enabled;\n\n  /**\n   * Creates a CurrencyRateController instance.\n   *\n   * @param options - Constructor options.\n   * @param options.includeUsdRate - Keep track of the USD rate in addition to the current currency rate.\n   * @param options.interval - The polling interval, in milliseconds.\n   * @param options.messenger - A reference to the messaging system.\n   * @param options.state - Initial state to set on this controller.\n   * @param options.fetchExchangeRate - Fetches the exchange rate from an external API. This option is primarily meant for use in unit tests.\n   */\n  constructor({\n    includeUsdRate = false,\n    interval = 180000,\n    messenger,\n    state,\n    fetchExchangeRate = defaultFetchExchangeRate,\n  }: {\n    includeUsdRate?: boolean;\n    interval?: number;\n    messenger: CurrencyRateMessenger;\n    state?: Partial<CurrencyRateState>;\n    fetchExchangeRate?: typeof defaultFetchExchangeRate;\n  }) {\n    super({\n      name,\n      metadata,\n      messenger,\n      state: { ...defaultState, ...state },\n    });\n    this.includeUsdRate = includeUsdRate;\n    this.intervalDelay = interval;\n    this.fetchExchangeRate = fetchExchangeRate;\n    this.#enabled = false;\n  }\n\n  /**\n   * Start polling for the currency rate.\n   */\n  async start() {\n    this.#enabled = true;\n\n    await this.startPolling();\n  }\n\n  /**\n   * Stop polling for the currency rate.\n   */\n  stop() {\n    this.#enabled = false;\n\n    this.stopPolling();\n  }\n\n  /**\n   * Prepare to discard this controller.\n   *\n   * This stops any active polling.\n   */\n  override destroy() {\n    super.destroy();\n    this.stopPolling();\n  }\n\n  /**\n   * Sets a currency to track.\n   *\n   * @param currentCurrency - ISO 4217 currency code.\n   */\n  async setCurrentCurrency(currentCurrency: string) {\n    this.update((state) => {\n      state.pendingCurrentCurrency = currentCurrency;\n    });\n    await this.updateExchangeRate();\n  }\n\n  /**\n   * Sets a new native currency.\n   *\n   * @param symbol - Symbol for the base asset.\n   */\n  async setNativeCurrency(symbol: string) {\n    this.update((state) => {\n      state.pendingNativeCurrency = symbol;\n    });\n    await this.updateExchangeRate();\n  }\n\n  private stopPolling() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n  }\n\n  /**\n   * Starts a new polling interval.\n   */\n  private async startPolling(): Promise<void> {\n    this.stopPolling();\n    // TODO: Expose polling currency rate update errors\n\n    await safelyExecute(async () => await this.updateExchangeRate());\n\n    this.intervalId = setInterval(async () => {\n      await safelyExecute(async () => await this.updateExchangeRate());\n    }, this.intervalDelay);\n  }\n\n  /**\n   * Updates exchange rate for the current currency.\n   *\n   * @returns The controller state.\n   */\n  async updateExchangeRate(): Promise<CurrencyRateState | void> {\n    if (!this.#enabled) {\n      console.info(\n        '[CurrencyRateController] Not updating exchange rate since network requests have been disabled',\n      );\n      return this.state;\n    }\n    const releaseLock = await this.mutex.acquire();\n    const {\n      currentCurrency: stateCurrentCurrency,\n      nativeCurrency: stateNativeCurrency,\n      pendingCurrentCurrency,\n      pendingNativeCurrency,\n    } = this.state;\n\n    let conversionDate: number | null = null;\n    let conversionRate: number | null = null;\n    let usdConversionRate: number | null = null;\n    const currentCurrency = pendingCurrentCurrency ?? stateCurrentCurrency;\n    const nativeCurrency = pendingNativeCurrency ?? stateNativeCurrency;\n\n    // For preloaded testnets (Goerli, Sepolia) we want to fetch exchange rate for real ETH.\n    const nativeCurrencyForExchangeRate = Object.values(\n      TESTNET_TICKER_SYMBOLS,\n    ).includes(nativeCurrency)\n      ? FALL_BACK_VS_CURRENCY // ETH\n      : nativeCurrency;\n\n    try {\n      if (\n        currentCurrency &&\n        nativeCurrency &&\n        // if either currency is an empty string we can skip the comparison\n        // because it will result in an error from the api and ultimately\n        // a null conversionRate either way.\n        currentCurrency !== '' &&\n        nativeCurrency !== ''\n      ) {\n        const fetchExchangeRateResponse = await this.fetchExchangeRate(\n          currentCurrency,\n          nativeCurrencyForExchangeRate,\n          this.includeUsdRate,\n        );\n\n        conversionRate = fetchExchangeRateResponse.conversionRate;\n        usdConversionRate = fetchExchangeRateResponse.usdConversionRate;\n        conversionDate = Date.now() / 1000;\n      }\n    } catch (error) {\n      if (\n        !(\n          error instanceof Error &&\n          error.message.includes('market does not exist for this coin pair')\n        )\n      ) {\n        throw error;\n      }\n    } finally {\n      try {\n        this.update(() => {\n          return {\n            conversionDate,\n            conversionRate,\n            // we currently allow and handle an empty string as a valid nativeCurrency\n            // in cases where a user has not entered a native ticker symbol for a custom network\n            // currentCurrency is not from user input but this protects us from unexpected changes.\n            nativeCurrency,\n            currentCurrency,\n            pendingCurrentCurrency: null,\n            pendingNativeCurrency: null,\n            usdConversionRate,\n          };\n        });\n      } finally {\n        releaseLock();\n      }\n    }\n    return this.state;\n  }\n}\n\nexport default CurrencyRateController;\n"]}
\ No newline at end of file
+{"version":3,"file":"CurrencyRateController.js","sourceRoot":"","sources":["../src/CurrencyRateController.ts"],"names":[],"mappings":"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","sourcesContent":["import { Mutex } from 'async-mutex';\nimport type { Patch } from 'immer';\nimport {\n  BaseControllerV2,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport {\n  TESTNET_TICKER_SYMBOLS,\n  FALL_BACK_VS_CURRENCY,\n  safelyExecute,\n} from '@metamask/controller-utils';\nimport { fetchExchangeRate as defaultFetchExchangeRate } from './crypto-compare';\n\n/**\n * @type CurrencyRateState\n * @property conversionDate - Timestamp of conversion rate expressed in ms since UNIX epoch\n * @property conversionRate - Conversion rate from current base asset to the current currency\n * @property currentCurrency - Currently-active ISO 4217 currency code\n * @property nativeCurrency - Symbol for the base asset used for conversion\n * @property pendingCurrentCurrency - The currency being switched to\n * @property pendingNativeCurrency - The base asset currency being switched to\n * @property usdConversionRate - Conversion rate from usd to the current currency\n */\nexport type CurrencyRateState = {\n  conversionDate: number | null;\n  conversionRate: number | null;\n  currentCurrency: string;\n  nativeCurrency: string;\n  pendingCurrentCurrency: string | null;\n  pendingNativeCurrency: string | null;\n  usdConversionRate: number | null;\n};\n\nconst name = 'CurrencyRateController';\n\nexport type CurrencyRateStateChange = {\n  type: `${typeof name}:stateChange`;\n  payload: [CurrencyRateState, Patch[]];\n};\n\nexport type GetCurrencyRateState = {\n  type: `${typeof name}:getState`;\n  handler: () => CurrencyRateState;\n};\n\ntype CurrencyRateMessenger = RestrictedControllerMessenger<\n  typeof name,\n  GetCurrencyRateState,\n  CurrencyRateStateChange,\n  never,\n  never\n>;\n\nconst metadata = {\n  conversionDate: { persist: true, anonymous: true },\n  conversionRate: { persist: true, anonymous: true },\n  currentCurrency: { persist: true, anonymous: true },\n  nativeCurrency: { persist: true, anonymous: true },\n  pendingCurrentCurrency: { persist: false, anonymous: true },\n  pendingNativeCurrency: { persist: false, anonymous: true },\n  usdConversionRate: { persist: true, anonymous: true },\n};\n\nconst defaultState = {\n  conversionDate: 0,\n  conversionRate: 0,\n  currentCurrency: 'usd',\n  nativeCurrency: 'ETH',\n  pendingCurrentCurrency: null,\n  pendingNativeCurrency: null,\n  usdConversionRate: null,\n};\n\n/**\n * Controller that passively polls on a set interval for an exchange rate from the current network\n * asset to the user's preferred currency.\n */\nexport class CurrencyRateController extends BaseControllerV2<\n  typeof name,\n  CurrencyRateState,\n  CurrencyRateMessenger\n> {\n  private mutex = new Mutex();\n\n  private intervalId?: ReturnType<typeof setTimeout>;\n\n  private intervalDelay;\n\n  private fetchExchangeRate;\n\n  private includeUsdRate;\n\n  /**\n   * A boolean that controls whether or not network requests can be made by the controller\n   */\n  #enabled;\n\n  /**\n   * Creates a CurrencyRateController instance.\n   *\n   * @param options - Constructor options.\n   * @param options.includeUsdRate - Keep track of the USD rate in addition to the current currency rate.\n   * @param options.interval - The polling interval, in milliseconds.\n   * @param options.messenger - A reference to the messaging system.\n   * @param options.state - Initial state to set on this controller.\n   * @param options.fetchExchangeRate - Fetches the exchange rate from an external API. This option is primarily meant for use in unit tests.\n   */\n  constructor({\n    includeUsdRate = false,\n    interval = 180000,\n    messenger,\n    state,\n    fetchExchangeRate = defaultFetchExchangeRate,\n  }: {\n    includeUsdRate?: boolean;\n    interval?: number;\n    messenger: CurrencyRateMessenger;\n    state?: Partial<CurrencyRateState>;\n    fetchExchangeRate?: typeof defaultFetchExchangeRate;\n  }) {\n    super({\n      name,\n      metadata,\n      messenger,\n      state: { ...defaultState, ...state },\n    });\n    this.includeUsdRate = includeUsdRate;\n    this.intervalDelay = interval;\n    this.fetchExchangeRate = fetchExchangeRate;\n    this.#enabled = false;\n  }\n\n  /**\n   * Start polling for the currency rate.\n   */\n  async start() {\n    this.#enabled = true;\n\n    await this.startPolling();\n  }\n\n  /**\n   * Stop polling for the currency rate.\n   */\n  stop() {\n    this.#enabled = false;\n\n    this.stopPolling();\n  }\n\n  /**\n   * Prepare to discard this controller.\n   *\n   * This stops any active polling.\n   */\n  override destroy() {\n    super.destroy();\n    this.stopPolling();\n  }\n\n  /**\n   * Sets a currency to track.\n   *\n   * @param currentCurrency - ISO 4217 currency code.\n   */\n  async setCurrentCurrency(currentCurrency: string) {\n    this.update((state) => {\n      state.pendingCurrentCurrency = currentCurrency;\n    });\n    await this.updateExchangeRate();\n  }\n\n  /**\n   * Sets a new native currency.\n   *\n   * @param symbol - Symbol for the base asset.\n   */\n  async setNativeCurrency(symbol: string) {\n    this.update((state) => {\n      state.pendingNativeCurrency = symbol;\n    });\n    await this.updateExchangeRate();\n  }\n\n  private stopPolling() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n  }\n\n  /**\n   * Starts a new polling interval.\n   */\n  private async startPolling(): Promise<void> {\n    this.stopPolling();\n    // TODO: Expose polling currency rate update errors\n\n    await safelyExecute(async () => await this.updateExchangeRate());\n\n    this.intervalId = setInterval(async () => {\n      await safelyExecute(async () => await this.updateExchangeRate());\n    }, this.intervalDelay);\n  }\n\n  /**\n   * Updates exchange rate for the current currency.\n   *\n   * @returns The controller state.\n   */\n  async updateExchangeRate(): Promise<CurrencyRateState | void> {\n    if (!this.#enabled) {\n      console.info(\n        '[CurrencyRateController] Not updating exchange rate since network requests have been disabled',\n      );\n      return this.state;\n    }\n    const releaseLock = await this.mutex.acquire();\n    const {\n      currentCurrency: stateCurrentCurrency,\n      nativeCurrency: stateNativeCurrency,\n      pendingCurrentCurrency,\n      pendingNativeCurrency,\n    } = this.state;\n\n    let conversionDate: number | null = null;\n    let conversionRate: number | null = null;\n    let usdConversionRate: number | null = null;\n    const currentCurrency = pendingCurrentCurrency ?? stateCurrentCurrency;\n    const nativeCurrency = pendingNativeCurrency ?? stateNativeCurrency;\n\n    // For preloaded testnets (Goerli, Sepolia) we want to fetch exchange rate for real ETH.\n    const nativeCurrencyForExchangeRate = Object.values(\n      TESTNET_TICKER_SYMBOLS,\n    ).includes(nativeCurrency)\n      ? FALL_BACK_VS_CURRENCY // ETH\n      : nativeCurrency;\n\n    try {\n      if (\n        currentCurrency &&\n        nativeCurrency &&\n        // if either currency is an empty string we can skip the comparison\n        // because it will result in an error from the api and ultimately\n        // a null conversionRate either way.\n        currentCurrency !== '' &&\n        nativeCurrency !== ''\n      ) {\n        const fetchExchangeRateResponse = await this.fetchExchangeRate(\n          currentCurrency,\n          nativeCurrencyForExchangeRate,\n          this.includeUsdRate,\n        );\n\n        conversionRate = fetchExchangeRateResponse.conversionRate;\n        usdConversionRate = fetchExchangeRateResponse.usdConversionRate;\n        conversionDate = Date.now() / 1000;\n      }\n    } catch (error) {\n      if (\n        !(\n          error instanceof Error &&\n          error.message.includes('market does not exist for this coin pair')\n        )\n      ) {\n        throw error;\n      }\n    } finally {\n      try {\n        this.update(() => {\n          return {\n            conversionDate,\n            conversionRate,\n            // we currently allow and handle an empty string as a valid nativeCurrency\n            // in cases where a user has not entered a native ticker symbol for a custom network\n            // currentCurrency is not from user input but this protects us from unexpected changes.\n            nativeCurrency,\n            currentCurrency,\n            pendingCurrentCurrency: null,\n            pendingNativeCurrency: null,\n            usdConversionRate,\n          };\n        });\n      } finally {\n        releaseLock();\n      }\n    }\n    return this.state;\n  }\n}\n\nexport default CurrencyRateController;\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/CurrencyRateController.mjs b/node_modules/@metamask/assets-controllers/dist/CurrencyRateController.mjs
new file mode 100644
index 0000000..5871117
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/CurrencyRateController.mjs
@@ -0,0 +1,11 @@
+import {
+  CurrencyRateController,
+  CurrencyRateController_default
+} from "./chunk-23F5W3A2.mjs";
+import "./chunk-TCO22VIO.mjs";
+import "./chunk-XUI43LEZ.mjs";
+export {
+  CurrencyRateController,
+  CurrencyRateController_default as default
+};
+//# sourceMappingURL=CurrencyRateController.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/CurrencyRateController.mjs.map b/node_modules/@metamask/assets-controllers/dist/CurrencyRateController.mjs.map
new file mode 100644
index 0000000..84c51b2
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/CurrencyRateController.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":[],"sourcesContent":[],"mappings":"","names":[]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/NftController.d.ts b/node_modules/@metamask/assets-controllers/dist/NftController.d.ts
index b322b8b..fdc241f 100644
--- a/node_modules/@metamask/assets-controllers/dist/NftController.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/NftController.d.ts
@@ -2,13 +2,13 @@
 import type { AddApprovalRequest } from '@metamask/approval-controller';
 import type { BaseConfig, BaseState, RestrictedControllerMessenger } from '@metamask/base-controller';
 import { BaseController } from '@metamask/base-controller';
-import type { NetworkState } from '@metamask/network-controller';
+import type { NetworkClientId, NetworkController, NetworkState } from '@metamask/network-controller';
 import type { PreferencesState } from '@metamask/preferences-controller';
 import type { Hex } from '@metamask/utils';
 import { EventEmitter } from 'events';
 import type { AssetsContractController } from './AssetsContractController';
 import { Source } from './constants';
-import type { ApiNftCreator, ApiNftLastSale } from './NftDetectionController';
+import type { Collection, Attributes, LastSale } from './NftDetectionController';
 declare type NFTStandardType = 'ERC721' | 'ERC1155';
 declare type SuggestedNftMeta = {
     asset: {
@@ -106,14 +106,14 @@ export interface NftMetadata {
     animation?: string;
     animationOriginal?: string;
     externalLink?: string;
-    creator?: ApiNftCreator;
-    lastSale?: ApiNftLastSale;
+    creator?: string;
     transactionId?: string;
     tokenURI?: string | null;
-}
-interface AccountParams {
-    userAddress: string;
-    chainId: Hex;
+    collection?: Collection;
+    address?: string;
+    attributes?: Attributes;
+    lastSale?: LastSale;
+    rarityRank?: string;
 }
 /**
  * @type NftConfig
@@ -125,9 +125,9 @@ export interface NftConfig extends BaseConfig {
     selectedAddress: string;
     chainId: Hex;
     ipfsGateway: string;
-    openSeaEnabled: boolean;
-    useIPFSSubdomains: boolean;
     isIpfsGatewayEnabled: boolean;
+    displayNftMedia: boolean;
+    useIPFSSubdomains: boolean;
 }
 /**
  * @type NftState
@@ -166,14 +166,14 @@ declare type AllowedActions = AddApprovalRequest;
  * The messenger of the {@link NftController}.
  */
 export declare type NftControllerMessenger = RestrictedControllerMessenger<typeof controllerName, AllowedActions, never, AllowedActions['type'], never>;
+export declare const getDefaultNftState: () => NftState;
 /**
  * Controller that stores assets and exposes convenience methods
  */
 export declare class NftController extends BaseController<NftConfig, NftState> {
     private readonly mutex;
     private readonly messagingSystem;
-    private getNftApi;
-    private getNftContractInformationApi;
+    getNftApi(): string;
     /**
      * Helper method to update nested state for allNfts and allNftContracts.
      *
@@ -185,7 +185,7 @@ export declare class NftController extends BaseController<NftConfig, NftState> {
      */
     private updateNestedNftState;
     /**
-     * Request individual NFT information from OpenSea API.
+     * Request individual NFT information from NFT API.
      *
      * @param contractAddress - Hex address of the NFT contract.
      * @param tokenId - The NFT identifier.
@@ -197,6 +197,7 @@ export declare class NftController extends BaseController<NftConfig, NftState> {
      *
      * @param contractAddress - Hex address of the NFT contract.
      * @param tokenId - The NFT identifier.
+     * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
      * @returns Promise resolving to the current NFT name and image.
      */
     private getNftInformationFromTokenURI;
@@ -205,6 +206,7 @@ export declare class NftController extends BaseController<NftConfig, NftState> {
      *
      * @param contractAddress - NFT contract address.
      * @param tokenId - NFT token id.
+     * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
      * @returns Promise resolving NFT uri and token standard.
      */
     private getNftURIAndStandard;
@@ -213,38 +215,36 @@ export declare class NftController extends BaseController<NftConfig, NftState> {
      *
      * @param contractAddress - Hex address of the NFT contract.
      * @param tokenId - The NFT identifier.
+     * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
      * @returns Promise resolving to the current NFT name and image.
      */
     private getNftInformation;
-    /**
-     * Request NFT contract information from OpenSea API.
-     *
-     * @param contractAddress - Hex address of the NFT contract.
-     * @returns Promise resolving to the current NFT name and image.
-     */
-    private getNftContractInformationFromApi;
     /**
      * Request NFT contract information from the contract itself.
      *
      * @param contractAddress - Hex address of the NFT contract.
+     * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
      * @returns Promise resolving to the current NFT name and image.
      */
     private getNftContractInformationFromContract;
     /**
-     * Request NFT contract information from OpenSea API.
+     * Request NFT contract information from Blockchain and aggregate with received data from NFTMetadata.
      *
      * @param contractAddress - Hex address of the NFT contract.
+     * @param nftMetadataFromApi - Received NFT information to be aggregated with blockchain contract information.
+     * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
      * @returns Promise resolving to the NFT contract name, image and description.
      */
     private getNftContractInformation;
     /**
      * Adds an individual NFT to the stored NFT list.
      *
-     * @param address - Hex address of the NFT contract.
+     * @param tokenAddress - Hex address of the NFT contract.
      * @param tokenId - The NFT identifier.
      * @param nftMetadata - NFT optional information (name, image and description).
      * @param nftContract - An object containing contract data of the NFT being added.
-     * @param accountParams - The chain ID and address of network and account to which the nftContract should be added.
+     * @param chainId - The chainId of the network where the NFT is being added.
+     * @param userAddress - The address of the account where the NFT is being added.
      * @param source - Whether the NFT was detected, added manually or suggested by a dapp.
      * @returns Promise resolving to the current NFT list.
      */
@@ -252,9 +252,12 @@ export declare class NftController extends BaseController<NftConfig, NftState> {
     /**
      * Adds an NFT contract to the stored NFT contracts list.
      *
-     * @param address - Hex address of the NFT contract.
-     * @param accountParams - The chain ID and address of network and account to which the nftContract should be added.
-     * @param source - Whether the NFT was detected, added manually or suggested by a dapp.
+     * @param options - options.
+     * @param options.tokenAddress - Hex address of the NFT contract.
+     * @param options.userAddress - The address of the account where the NFT is being added.
+     * @param options.nftMetadata - The retrieved NFTMetadata from API.
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.
      * @returns Promise resolving to the current NFT contracts list.
      */
     private addNftContract;
@@ -263,6 +266,9 @@ export declare class NftController extends BaseController<NftConfig, NftState> {
      *
      * @param address - Hex address of the NFT contract.
      * @param tokenId - Token identifier of the NFT.
+     * @param options - options.
+     * @param options.chainId - The chainId of the network where the NFT is being removed.
+     * @param options.userAddress - The address of the account where the NFT is being removed.
      */
     private removeAndIgnoreIndividualNft;
     /**
@@ -270,12 +276,18 @@ export declare class NftController extends BaseController<NftConfig, NftState> {
      *
      * @param address - Hex address of the NFT contract.
      * @param tokenId - Token identifier of the NFT.
+     * @param options - options.
+     * @param options.chainId - The chainId of the network where the NFT is being removed.
+     * @param options.userAddress - The address of the account where the NFT is being removed.
      */
     private removeIndividualNft;
     /**
      * Removes an NFT contract to the stored NFT contracts list.
      *
      * @param address - Hex address of the NFT contract.
+     * @param options - options.
+     * @param options.chainId - The chainId of the network where the NFT is being removed.
+     * @param options.userAddress - The address of the account where the NFT is being removed.
      * @returns Promise resolving to the current NFT contracts list.
      */
     private removeNftContract;
@@ -297,6 +309,7 @@ export declare class NftController extends BaseController<NftConfig, NftState> {
     private readonly getERC721OwnerOf;
     private readonly getERC1155BalanceOf;
     private readonly getERC1155TokenURI;
+    private readonly getNetworkClientById;
     private readonly onNftAdded?;
     /**
      * Creates an NftController instance.
@@ -311,13 +324,14 @@ export declare class NftController extends BaseController<NftConfig, NftState> {
      * @param options.getERC721OwnerOf - Get the owner of a ERC-721 NFT.
      * @param options.getERC1155BalanceOf - Gets balance of a ERC-1155 NFT.
      * @param options.getERC1155TokenURI - Gets the URI of the ERC1155 token at the given address, with the given ID.
+     * @param options.getNetworkClientById - Gets the network client for the given networkClientId.
      * @param options.onNftAdded - Callback that is called when an NFT is added. Currently used pass data
      * for tracking the NFT added event.
      * @param options.messenger - The controller messenger.
      * @param config - Initial options used to configure this controller.
      * @param state - Initial state to set on this controller.
      */
-    constructor({ chainId: initialChainId, onPreferencesStateChange, onNetworkStateChange, getERC721AssetName, getERC721AssetSymbol, getERC721TokenURI, getERC721OwnerOf, getERC1155BalanceOf, getERC1155TokenURI, onNftAdded, messenger, }: {
+    constructor({ chainId: initialChainId, onPreferencesStateChange, onNetworkStateChange, getERC721AssetName, getERC721AssetSymbol, getERC721TokenURI, getERC721OwnerOf, getERC1155BalanceOf, getERC1155TokenURI, getNetworkClientById, onNftAdded, messenger, }: {
         chainId: Hex;
         onPreferencesStateChange: (listener: (preferencesState: PreferencesState) => void) => void;
         onNetworkStateChange: (listener: (networkState: NetworkState) => void) => void;
@@ -327,6 +341,7 @@ export declare class NftController extends BaseController<NftConfig, NftState> {
         getERC721OwnerOf: AssetsContractController['getERC721OwnerOf'];
         getERC1155BalanceOf: AssetsContractController['getERC1155BalanceOf'];
         getERC1155TokenURI: AssetsContractController['getERC1155TokenURI'];
+        getNetworkClientById: NetworkController['getNetworkClientById'];
         onNftAdded?: (data: {
             address: string;
             symbol: string | undefined;
@@ -336,7 +351,8 @@ export declare class NftController extends BaseController<NftConfig, NftState> {
         }) => void;
         messenger: NftControllerMessenger;
     }, config?: Partial<BaseConfig>, state?: Partial<NftState>);
-    validateWatchNft(asset: NftAsset, type: NFTStandardType, accountAddress: string): Promise<void>;
+    private validateWatchNft;
+    private getCorrectChainId;
     /**
      * Adds a new suggestedAsset to state. Parameters will be validated according to
      * asset type being watched. A `<suggestedNftMeta.id>:pending` hub event will be emitted once added.
@@ -346,9 +362,15 @@ export declare class NftController extends BaseController<NftConfig, NftState> {
      * @param asset.tokenId - The ID of the asset.
      * @param type - The asset type.
      * @param origin - Domain origin to register the asset from.
+     * @param options - Options bag.
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @param options.userAddress - The address of the account where the NFT is being added.
      * @returns Object containing a Promise resolving to the suggestedAsset address if accepted.
      */
-    watchNft(asset: NftAsset, type: NFTStandardType, origin: string): Promise<void>;
+    watchNft(asset: NftAsset, type: NFTStandardType, origin: string, { networkClientId, userAddress, }?: {
+        networkClientId?: NetworkClientId;
+        userAddress?: string;
+    }): Promise<void>;
     /**
      * Sets an OpenSea API key to retrieve NFT information.
      *
@@ -360,43 +382,87 @@ export declare class NftController extends BaseController<NftConfig, NftState> {
      *
      * @param ownerAddress - User public address.
      * @param nftAddress - NFT contract address.
-     * @param nftId - NFT token ID.
+     * @param tokenId - NFT token ID.
+     * @param options - Options bag.
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
      * @returns Promise resolving the NFT ownership.
      */
-    isNftOwner(ownerAddress: string, nftAddress: string, nftId: string): Promise<boolean>;
+    isNftOwner(ownerAddress: string, nftAddress: string, tokenId: string, { networkClientId, }?: {
+        networkClientId?: NetworkClientId;
+    }): Promise<boolean>;
     /**
      * Verifies currently selected address owns entered NFT address/tokenId combo and
      * adds the NFT and respective NFT contract to the stored NFT and NFT contracts lists.
      *
      * @param address - Hex address of the NFT contract.
      * @param tokenId - The NFT identifier.
+     * @param options - an object of arguments
+     * @param options.userAddress - The address of the current user.
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.
      */
-    addNftVerifyOwnership(address: string, tokenId: string): Promise<void>;
+    addNftVerifyOwnership(address: string, tokenId: string, { userAddress, networkClientId, source, }?: {
+        userAddress?: string;
+        networkClientId?: NetworkClientId;
+        source?: Source;
+    }): Promise<void>;
     /**
      * Adds an NFT and respective NFT contract to the stored NFT and NFT contracts lists.
      *
-     * @param address - Hex address of the NFT contract.
+     * @param tokenAddress - Hex address of the NFT contract.
      * @param tokenId - The NFT identifier.
-     * @param nftMetadata - NFT optional metadata.
-     * @param accountParams - The chain ID and address of network and account to which the nftContract should be added.
-     * @param source - Whether the NFT was detected, added manually or suggested by a dapp.
+     * @param options - an object of arguments
+     * @param options.nftMetadata - NFT optional metadata.
+     * @param options.userAddress - The address of the current user.
+     * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
      * @returns Promise resolving to the current NFT list.
      */
-    addNft(address: string, tokenId: string, nftMetadata?: NftMetadata, accountParams?: AccountParams, source?: Source): Promise<void>;
+    addNft(tokenAddress: string, tokenId: string, { nftMetadata, userAddress, source, networkClientId, }?: {
+        nftMetadata?: NftMetadata;
+        userAddress?: string;
+        source?: Source;
+        networkClientId?: NetworkClientId;
+    }): Promise<void>;
+    /**
+     * Refetches NFT metadata and updates the state
+     *
+     * @param options - Options for refetching NFT metadata
+     * @param options.nfts - Array of nfts
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @param options.userAddress - The current user address
+     */
+    updateNftMetadata({ nfts, networkClientId, userAddress, }: {
+        nfts: Nft[];
+        networkClientId?: NetworkClientId;
+        userAddress?: string;
+    }): Promise<void>;
     /**
      * Removes an NFT from the stored token list.
      *
      * @param address - Hex address of the NFT contract.
      * @param tokenId - Token identifier of the NFT.
+     * @param options - an object of arguments
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @param options.userAddress - The address of the account where the NFT is being removed.
      */
-    removeNft(address: string, tokenId: string): void;
+    removeNft(address: string, tokenId: string, { networkClientId, userAddress, }?: {
+        networkClientId?: NetworkClientId;
+        userAddress?: string;
+    }): void;
     /**
      * Removes an NFT from the stored token list and saves it in ignored NFTs list.
      *
      * @param address - Hex address of the NFT contract.
      * @param tokenId - Token identifier of the NFT.
+     * @param options - an object of arguments
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @param options.userAddress - The address of the account where the NFT is being removed.
      */
-    removeAndIgnoreNft(address: string, tokenId: string): void;
+    removeAndIgnoreNft(address: string, tokenId: string, { networkClientId, userAddress, }?: {
+        networkClientId?: NetworkClientId;
+        userAddress?: string;
+    }): void;
     /**
      * Removes all NFTs from the ignored list.
      */
@@ -409,26 +475,38 @@ export declare class NftController extends BaseController<NftConfig, NftState> {
      * @param batch - A boolean indicating whether this method is being called as part of a batch or single update.
      * @param accountParams - The userAddress and chainId to check ownership against
      * @param accountParams.userAddress - the address passed through the confirmed transaction flow to ensure assets are stored to the correct account
-     * @param accountParams.chainId - the chainId passed through the confirmed transaction flow to ensure assets are stored to the correct account
+     * @param accountParams.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
      * @returns the NFT with the updated isCurrentlyOwned value
      */
-    checkAndUpdateSingleNftOwnershipStatus(nft: Nft, batch: boolean, { userAddress, chainId }?: {
-        userAddress: string;
-        chainId: `0x${string}`;
+    checkAndUpdateSingleNftOwnershipStatus(nft: Nft, batch: boolean, { userAddress, networkClientId, }?: {
+        networkClientId?: NetworkClientId;
+        userAddress?: string;
     }): Promise<Nft>;
     /**
      * Checks whether NFTs associated with current selectedAddress/chainId combination are still owned by the user
      * And updates the isCurrentlyOwned value on each accordingly.
+     * @param options - an object of arguments
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @param options.userAddress - The address of the account where the NFT ownership status is checked/updated.
      */
-    checkAndUpdateAllNftsOwnershipStatus(): Promise<void>;
+    checkAndUpdateAllNftsOwnershipStatus({ networkClientId, userAddress, }?: {
+        networkClientId?: NetworkClientId;
+        userAddress?: string;
+    }): Promise<void>;
     /**
      * Update NFT favorite status.
      *
      * @param address - Hex address of the NFT contract.
      * @param tokenId - Hex address of the NFT contract.
      * @param favorite - NFT new favorite status.
+     * @param options - an object of arguments
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @param options.userAddress - The address of the account where the NFT is being removed.
      */
-    updateNftFavoriteStatus(address: string, tokenId: string, favorite: boolean): void;
+    updateNftFavoriteStatus(address: string, tokenId: string, favorite: boolean, { networkClientId, userAddress, }?: {
+        networkClientId?: NetworkClientId;
+        userAddress?: string;
+    }): void;
     /**
      * Returns an NFT by the address and token id.
      *
@@ -457,7 +535,7 @@ export declare class NftController extends BaseController<NftConfig, NftState> {
      * @param transactionId - NFT transaction id.
      * @param selectedAddress - Hex address of the user account.
      * @param chainId - Id of the current network.
-     * @returns a boolean indicating if the reset was well succeded or not
+     * @returns a boolean indicating if the reset was well succeeded or not
      */
     resetNftTransactionStatusByTransactionId(transactionId: string, selectedAddress: string, chainId: Hex): boolean;
     _requestApproval(suggestedNftMeta: SuggestedNftMeta): Promise<unknown>;
diff --git a/node_modules/@metamask/assets-controllers/dist/NftController.d.ts.map b/node_modules/@metamask/assets-controllers/dist/NftController.d.ts.map
index a51fdf7..0d6aa36 100644
--- a/node_modules/@metamask/assets-controllers/dist/NftController.d.ts.map
+++ b/node_modules/@metamask/assets-controllers/dist/NftController.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"NftController.d.ts","sourceRoot":"","sources":["../src/NftController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"NftController.d.ts","sourceRoot":"","sources":["../src/NftController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/NftController.js b/node_modules/@metamask/assets-controllers/dist/NftController.js
index 3d65ff2..12fc1c8 100644
--- a/node_modules/@metamask/assets-controllers/dist/NftController.js
+++ b/node_modules/@metamask/assets-controllers/dist/NftController.js
@@ -8,14 +8,18 @@ var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, ge
         step((generator = generator.apply(thisArg, _arguments || [])).next());
     });
 };
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.NftController = void 0;
+exports.NftController = exports.getDefaultNftState = void 0;
 const address_1 = require("@ethersproject/address");
 const base_controller_1 = require("@metamask/base-controller");
 const controller_utils_1 = require("@metamask/controller-utils");
 const rpc_errors_1 = require("@metamask/rpc-errors");
+const utils_1 = require("@metamask/utils");
 const async_mutex_1 = require("async-mutex");
-const ethereumjs_util_1 = require("ethereumjs-util");
+const bn_js_1 = __importDefault(require("bn.js"));
 const events_1 = require("events");
 const uuid_1 = require("uuid");
 const assetsUtil_1 = require("./assetsUtil");
@@ -26,6 +30,14 @@ const ALL_NFTS_CONTRACTS_STATE_KEY = 'allNftContracts';
  * The name of the {@link NftController}.
  */
 const controllerName = 'NftController';
+const getDefaultNftState = () => {
+    return {
+        allNftContracts: {},
+        allNfts: {},
+        ignoredNfts: [],
+    };
+};
+exports.getDefaultNftState = getDefaultNftState;
 /**
  * Controller that stores assets and exposes convenience methods
  */
@@ -43,13 +55,14 @@ class NftController extends base_controller_1.BaseController {
      * @param options.getERC721OwnerOf - Get the owner of a ERC-721 NFT.
      * @param options.getERC1155BalanceOf - Gets balance of a ERC-1155 NFT.
      * @param options.getERC1155TokenURI - Gets the URI of the ERC1155 token at the given address, with the given ID.
+     * @param options.getNetworkClientById - Gets the network client for the given networkClientId.
      * @param options.onNftAdded - Callback that is called when an NFT is added. Currently used pass data
      * for tracking the NFT added event.
      * @param options.messenger - The controller messenger.
      * @param config - Initial options used to configure this controller.
      * @param state - Initial state to set on this controller.
      */
-    constructor({ chainId: initialChainId, onPreferencesStateChange, onNetworkStateChange, getERC721AssetName, getERC721AssetSymbol, getERC721TokenURI, getERC721OwnerOf, getERC1155BalanceOf, getERC1155TokenURI, onNftAdded, messenger, }, config, state) {
+    constructor({ chainId: initialChainId, onPreferencesStateChange, onNetworkStateChange, getERC721AssetName, getERC721AssetSymbol, getERC721TokenURI, getERC721OwnerOf, getERC1155BalanceOf, getERC1155TokenURI, getNetworkClientById, onNftAdded, messenger, }, config, state) {
         super(config, state);
         this.mutex = new async_mutex_1.Mutex();
         /**
@@ -64,15 +77,11 @@ class NftController extends base_controller_1.BaseController {
             selectedAddress: '',
             chainId: initialChainId,
             ipfsGateway: controller_utils_1.IPFS_DEFAULT_GATEWAY_URL,
-            openSeaEnabled: false,
+            displayNftMedia: true,
             useIPFSSubdomains: true,
             isIpfsGatewayEnabled: true,
         };
-        this.defaultState = {
-            allNftContracts: {},
-            allNfts: {},
-            ignoredNfts: [],
-        };
+        this.defaultState = (0, exports.getDefaultNftState)();
         this.initialize();
         this.getERC721AssetName = getERC721AssetName;
         this.getERC721AssetSymbol = getERC721AssetSymbol;
@@ -80,13 +89,14 @@ class NftController extends base_controller_1.BaseController {
         this.getERC721OwnerOf = getERC721OwnerOf;
         this.getERC1155BalanceOf = getERC1155BalanceOf;
         this.getERC1155TokenURI = getERC1155TokenURI;
+        this.getNetworkClientById = getNetworkClientById;
         this.onNftAdded = onNftAdded;
         this.messagingSystem = messenger;
-        onPreferencesStateChange(({ selectedAddress, ipfsGateway, openSeaEnabled, isIpfsGatewayEnabled, }) => {
+        onPreferencesStateChange(({ selectedAddress, ipfsGateway, displayNftMedia, isIpfsGatewayEnabled, }) => {
             this.configure({
                 selectedAddress,
                 ipfsGateway,
-                openSeaEnabled,
+                displayNftMedia,
                 isIpfsGatewayEnabled,
             });
         });
@@ -95,11 +105,8 @@ class NftController extends base_controller_1.BaseController {
             this.configure({ chainId });
         });
     }
-    getNftApi({ contractAddress, tokenId, }) {
-        return `${controller_utils_1.OPENSEA_PROXY_URL}/asset/${contractAddress}/${tokenId}`;
-    }
-    getNftContractInformationApi({ contractAddress, }) {
-        return `${controller_utils_1.OPENSEA_PROXY_URL}/asset_contract/${contractAddress}`;
+    getNftApi() {
+        return `${controller_utils_1.NFT_API_BASE_URL}/tokens`;
     }
     /**
      * Helper method to update nested state for allNfts and allNftContracts.
@@ -110,10 +117,7 @@ class NftController extends base_controller_1.BaseController {
      * @param passedConfig.userAddress - the address passed through the NFT detection flow to ensure assets are stored to the correct account
      * @param passedConfig.chainId - the chainId passed through the NFT detection flow to ensure assets are stored to the correct account
      */
-    updateNestedNftState(newCollection, baseStateKey, { userAddress, chainId } = {
-        userAddress: this.config.selectedAddress,
-        chainId: this.config.chainId,
-    }) {
+    updateNestedNftState(newCollection, baseStateKey, { userAddress, chainId }) {
         const { [baseStateKey]: oldState } = this.state;
         const addressState = oldState[userAddress];
         const newAddressState = Object.assign(Object.assign({}, addressState), { [chainId]: newCollection });
@@ -123,23 +127,34 @@ class NftController extends base_controller_1.BaseController {
         });
     }
     /**
-     * Request individual NFT information from OpenSea API.
+     * Request individual NFT information from NFT API.
      *
      * @param contractAddress - Hex address of the NFT contract.
      * @param tokenId - The NFT identifier.
      * @returns Promise resolving to the current NFT name and image.
      */
     getNftInformationFromApi(contractAddress, tokenId) {
+        var _a, _b, _c, _d;
         return __awaiter(this, void 0, void 0, function* () {
-            // Attempt to fetch the data with the proxy
+            // TODO Parameterize this by chainId for non-mainnet token detection
+            // Attempt to fetch the data with the nft-api
+            const urlParams = new URLSearchParams({
+                chainIds: '1',
+                tokens: `${contractAddress}:${tokenId}`,
+                includeTopBid: 'true',
+                includeAttributes: 'true',
+                includeLastSale: 'true',
+            }).toString();
             const nftInformation = yield (0, controller_utils_1.fetchWithErrorHandling)({
-                url: this.getNftApi({
-                    contractAddress,
-                    tokenId,
-                }),
+                url: `${this.getNftApi()}?${urlParams}`,
+                options: {
+                    headers: {
+                        Version: '1',
+                    },
+                },
             });
             // if we were still unable to fetch the data we return out the default/null of `NftMetadata`
-            if (!nftInformation) {
+            if (!((_b = (_a = nftInformation === null || nftInformation === void 0 ? void 0 : nftInformation.tokens) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.token)) {
                 return {
                     name: null,
                     description: null,
@@ -149,11 +164,11 @@ class NftController extends base_controller_1.BaseController {
             }
             // if we've reached this point, we have successfully fetched some data for nftInformation
             // now we reconfigure the data to conform to the `NftMetadata` type for storage.
-            const { num_sales, background_color, image_url, image_preview_url, image_thumbnail_url, image_original_url, animation_url, animation_original_url, name, description, external_link, creator, last_sale, asset_contract: { schema_name }, } = nftInformation;
+            const { image, metadata: { imageOriginal } = {}, name, description, collection, kind, rarityRank, rarity, attributes, lastSale, imageSmall, } = nftInformation.tokens[0].token;
             /* istanbul ignore next */
-            const nftMetadata = Object.assign({}, { name: name || null }, { description: description || null }, { image: image_url || null }, creator && { creator }, num_sales && { numberOfSales: num_sales }, background_color && { backgroundColor: background_color }, image_preview_url && { imagePreview: image_preview_url }, image_thumbnail_url && { imageThumbnail: image_thumbnail_url }, image_original_url && { imageOriginal: image_original_url }, animation_url && { animation: animation_url }, animation_original_url && {
-                animationOriginal: animation_original_url,
-            }, external_link && { externalLink: external_link }, last_sale && { lastSale: last_sale }, schema_name && { standard: schema_name });
+            const nftMetadata = Object.assign({}, { name: name || null }, { description: description || null }, { image: image || null }, (collection === null || collection === void 0 ? void 0 : collection.creator) && { creator: collection.creator }, imageOriginal && { imageOriginal }, imageSmall && { imageThumbnail: imageSmall }, kind && { standard: kind.toUpperCase() }, lastSale && { lastSale }, attributes && { attributes }, ((_c = nftInformation.tokens[0].market) === null || _c === void 0 ? void 0 : _c.topBid) && {
+                topBid: (_d = nftInformation.tokens[0].market) === null || _d === void 0 ? void 0 : _d.topBid,
+            }, rarityRank && { rarityRank }, rarity && { rarity }, collection && { collection });
             return nftMetadata;
         });
     }
@@ -162,12 +177,13 @@ class NftController extends base_controller_1.BaseController {
      *
      * @param contractAddress - Hex address of the NFT contract.
      * @param tokenId - The NFT identifier.
+     * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
      * @returns Promise resolving to the current NFT name and image.
      */
-    getNftInformationFromTokenURI(contractAddress, tokenId) {
+    getNftInformationFromTokenURI(contractAddress, tokenId, networkClientId) {
         return __awaiter(this, void 0, void 0, function* () {
-            const { ipfsGateway, useIPFSSubdomains, isIpfsGatewayEnabled } = this.config;
-            const result = yield this.getNftURIAndStandard(contractAddress, tokenId);
+            const { ipfsGateway, useIPFSSubdomains, isIpfsGatewayEnabled, displayNftMedia, } = this.config;
+            const result = yield this.getNftURIAndStandard(contractAddress, tokenId, networkClientId);
             let tokenURI = result[0];
             const standard = result[1];
             const hasIpfsTokenURI = tokenURI.startsWith('ipfs://');
@@ -181,6 +197,16 @@ class NftController extends base_controller_1.BaseController {
                     tokenURI: tokenURI !== null && tokenURI !== void 0 ? tokenURI : null,
                 };
             }
+            if (!hasIpfsTokenURI && !displayNftMedia) {
+                return {
+                    image: null,
+                    name: null,
+                    description: null,
+                    standard: standard || null,
+                    favorite: false,
+                    tokenURI: tokenURI !== null && tokenURI !== void 0 ? tokenURI : null,
+                };
+            }
             if (hasIpfsTokenURI) {
                 tokenURI = (0, assetsUtil_1.getFormattedIpfsUrl)(ipfsGateway, tokenURI, useIPFSSubdomains);
             }
@@ -216,13 +242,14 @@ class NftController extends base_controller_1.BaseController {
      *
      * @param contractAddress - NFT contract address.
      * @param tokenId - NFT token id.
+     * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
      * @returns Promise resolving NFT uri and token standard.
      */
-    getNftURIAndStandard(contractAddress, tokenId) {
+    getNftURIAndStandard(contractAddress, tokenId, networkClientId) {
         return __awaiter(this, void 0, void 0, function* () {
             // try ERC721 uri
             try {
-                const uri = yield this.getERC721TokenURI(contractAddress, tokenId);
+                const uri = yield this.getERC721TokenURI(contractAddress, tokenId, networkClientId);
                 return [uri, controller_utils_1.ERC721];
             }
             catch (_a) {
@@ -230,7 +257,7 @@ class NftController extends base_controller_1.BaseController {
             }
             // try ERC1155 uri
             try {
-                const tokenURI = yield this.getERC1155TokenURI(contractAddress, tokenId);
+                const tokenURI = yield this.getERC1155TokenURI(contractAddress, tokenId, networkClientId);
                 /**
                  * According to EIP1155 the URI value allows for ID substitution
                  * in case the string `{id}` exists.
@@ -239,7 +266,7 @@ class NftController extends base_controller_1.BaseController {
                 if (!tokenURI.includes('{id}')) {
                     return [tokenURI, controller_utils_1.ERC1155];
                 }
-                const hexTokenId = (0, ethereumjs_util_1.stripHexPrefix)((0, controller_utils_1.BNToHex)(new ethereumjs_util_1.BN(tokenId)))
+                const hexTokenId = (0, utils_1.remove0x)((0, controller_utils_1.BNToHex)(new bn_js_1.default(tokenId)))
                     .padStart(64, '0')
                     .toLowerCase();
                 return [tokenURI.replace('{id}', hexTokenId), controller_utils_1.ERC1155];
@@ -255,69 +282,37 @@ class NftController extends base_controller_1.BaseController {
      *
      * @param contractAddress - Hex address of the NFT contract.
      * @param tokenId - The NFT identifier.
+     * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
      * @returns Promise resolving to the current NFT name and image.
      */
-    getNftInformation(contractAddress, tokenId) {
+    getNftInformation(contractAddress, tokenId, networkClientId) {
         var _a, _b, _c, _d, _e, _f, _g, _h, _j;
         return __awaiter(this, void 0, void 0, function* () {
-            const blockchainMetadata = yield (0, controller_utils_1.safelyExecute)(() => __awaiter(this, void 0, void 0, function* () {
-                return yield this.getNftInformationFromTokenURI(contractAddress, tokenId);
-            }));
-            let openSeaMetadata;
-            if (this.config.openSeaEnabled) {
-                openSeaMetadata = yield (0, controller_utils_1.safelyExecute)(() => __awaiter(this, void 0, void 0, function* () {
-                    return yield this.getNftInformationFromApi(contractAddress, tokenId);
-                }));
-            }
-            return Object.assign(Object.assign({}, openSeaMetadata), { name: (_b = (_a = blockchainMetadata.name) !== null && _a !== void 0 ? _a : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.name) !== null && _b !== void 0 ? _b : null, description: (_d = (_c = blockchainMetadata.description) !== null && _c !== void 0 ? _c : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.description) !== null && _d !== void 0 ? _d : null, image: (_f = (_e = blockchainMetadata.image) !== null && _e !== void 0 ? _e : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.image) !== null && _f !== void 0 ? _f : null, standard: (_h = (_g = blockchainMetadata.standard) !== null && _g !== void 0 ? _g : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.standard) !== null && _h !== void 0 ? _h : null, tokenURI: (_j = blockchainMetadata.tokenURI) !== null && _j !== void 0 ? _j : null });
-        });
-    }
-    /**
-     * Request NFT contract information from OpenSea API.
-     *
-     * @param contractAddress - Hex address of the NFT contract.
-     * @returns Promise resolving to the current NFT name and image.
-     */
-    getNftContractInformationFromApi(contractAddress) {
-        return __awaiter(this, void 0, void 0, function* () {
-            /* istanbul ignore if */
-            const apiNftContractObject = yield (0, controller_utils_1.fetchWithErrorHandling)({
-                url: this.getNftContractInformationApi({
-                    contractAddress,
-                }),
+            const chainId = this.getCorrectChainId({
+                networkClientId,
             });
-            // if we successfully fetched return the fetched data immediately
-            if (apiNftContractObject) {
-                return apiNftContractObject;
-            }
-            // If we've reached this point we were unable to fetch data from either the proxy or opensea so we return
-            // the default/null of ApiNftContract
-            return {
-                address: contractAddress,
-                asset_contract_type: null,
-                created_date: null,
-                schema_name: null,
-                symbol: null,
-                total_supply: null,
-                description: null,
-                external_link: null,
-                collection: {
-                    name: null,
-                    image_url: null,
-                },
-            };
+            const [blockchainMetadata, nftApiMetadata] = yield Promise.all([
+                (0, controller_utils_1.safelyExecute)(() => this.getNftInformationFromTokenURI(contractAddress, tokenId, networkClientId)),
+                this.config.displayNftMedia && chainId === '0x1'
+                    ? (0, controller_utils_1.safelyExecute)(() => this.getNftInformationFromApi(contractAddress, tokenId))
+                    : undefined,
+            ]);
+            return Object.assign(Object.assign({}, nftApiMetadata), { name: (_b = (_a = blockchainMetadata === null || blockchainMetadata === void 0 ? void 0 : blockchainMetadata.name) !== null && _a !== void 0 ? _a : nftApiMetadata === null || nftApiMetadata === void 0 ? void 0 : nftApiMetadata.name) !== null && _b !== void 0 ? _b : null, description: (_d = (_c = blockchainMetadata === null || blockchainMetadata === void 0 ? void 0 : blockchainMetadata.description) !== null && _c !== void 0 ? _c : nftApiMetadata === null || nftApiMetadata === void 0 ? void 0 : nftApiMetadata.description) !== null && _d !== void 0 ? _d : null, image: (_f = (_e = blockchainMetadata === null || blockchainMetadata === void 0 ? void 0 : blockchainMetadata.image) !== null && _e !== void 0 ? _e : nftApiMetadata === null || nftApiMetadata === void 0 ? void 0 : nftApiMetadata.image) !== null && _f !== void 0 ? _f : null, standard: (_h = (_g = blockchainMetadata === null || blockchainMetadata === void 0 ? void 0 : blockchainMetadata.standard) !== null && _g !== void 0 ? _g : nftApiMetadata === null || nftApiMetadata === void 0 ? void 0 : nftApiMetadata.standard) !== null && _h !== void 0 ? _h : null, tokenURI: (_j = blockchainMetadata === null || blockchainMetadata === void 0 ? void 0 : blockchainMetadata.tokenURI) !== null && _j !== void 0 ? _j : null });
         });
     }
     /**
      * Request NFT contract information from the contract itself.
      *
      * @param contractAddress - Hex address of the NFT contract.
+     * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
      * @returns Promise resolving to the current NFT name and image.
      */
-    getNftContractInformationFromContract(contractAddress) {
+    getNftContractInformationFromContract(contractAddress, networkClientId) {
         return __awaiter(this, void 0, void 0, function* () {
-            const name = yield this.getERC721AssetName(contractAddress);
-            const symbol = yield this.getERC721AssetSymbol(contractAddress);
+            const [name, symbol] = yield Promise.all([
+                this.getERC721AssetName(contractAddress, networkClientId),
+                this.getERC721AssetSymbol(contractAddress, networkClientId),
+            ]);
             return {
                 collection: { name },
                 symbol,
@@ -326,24 +321,20 @@ class NftController extends base_controller_1.BaseController {
         });
     }
     /**
-     * Request NFT contract information from OpenSea API.
+     * Request NFT contract information from Blockchain and aggregate with received data from NFTMetadata.
      *
      * @param contractAddress - Hex address of the NFT contract.
+     * @param nftMetadataFromApi - Received NFT information to be aggregated with blockchain contract information.
+     * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
      * @returns Promise resolving to the NFT contract name, image and description.
      */
-    getNftContractInformation(contractAddress) {
+    getNftContractInformation(contractAddress, nftMetadataFromApi, networkClientId) {
+        var _a, _b, _c, _d, _e, _f, _g;
         return __awaiter(this, void 0, void 0, function* () {
-            const blockchainContractData = yield (0, controller_utils_1.safelyExecute)(() => __awaiter(this, void 0, void 0, function* () {
-                return yield this.getNftContractInformationFromContract(contractAddress);
-            }));
-            let openSeaContractData;
-            if (this.config.openSeaEnabled) {
-                openSeaContractData = yield (0, controller_utils_1.safelyExecute)(() => __awaiter(this, void 0, void 0, function* () {
-                    return yield this.getNftContractInformationFromApi(contractAddress);
-                }));
-            }
-            if (blockchainContractData || openSeaContractData) {
-                return Object.assign(Object.assign(Object.assign({}, openSeaContractData), blockchainContractData), { collection: Object.assign(Object.assign({ image_url: null }, openSeaContractData === null || openSeaContractData === void 0 ? void 0 : openSeaContractData.collection), blockchainContractData === null || blockchainContractData === void 0 ? void 0 : blockchainContractData.collection) });
+            const blockchainContractData = yield (0, controller_utils_1.safelyExecute)(() => this.getNftContractInformationFromContract(contractAddress, networkClientId));
+            if (blockchainContractData ||
+                !Object.values(nftMetadataFromApi).every((value) => value === null)) {
+                return Object.assign(Object.assign({ address: contractAddress }, blockchainContractData), { schema_name: (_a = nftMetadataFromApi === null || nftMetadataFromApi === void 0 ? void 0 : nftMetadataFromApi.standard) !== null && _a !== void 0 ? _a : null, collection: Object.assign(Object.assign({ name: null, image_url: (_e = (_c = (_b = nftMetadataFromApi === null || nftMetadataFromApi === void 0 ? void 0 : nftMetadataFromApi.collection) === null || _b === void 0 ? void 0 : _b.image) !== null && _c !== void 0 ? _c : (_d = nftMetadataFromApi === null || nftMetadataFromApi === void 0 ? void 0 : nftMetadataFromApi.collection) === null || _d === void 0 ? void 0 : _d.imageUrl) !== null && _e !== void 0 ? _e : null, tokenCount: (_g = (_f = nftMetadataFromApi === null || nftMetadataFromApi === void 0 ? void 0 : nftMetadataFromApi.collection) === null || _f === void 0 ? void 0 : _f.tokenCount) !== null && _g !== void 0 ? _g : null }, nftMetadataFromApi === null || nftMetadataFromApi === void 0 ? void 0 : nftMetadataFromApi.collection), blockchainContractData === null || blockchainContractData === void 0 ? void 0 : blockchainContractData.collection) });
             }
             /* istanbul ignore next */
             return {
@@ -362,39 +353,31 @@ class NftController extends base_controller_1.BaseController {
     /**
      * Adds an individual NFT to the stored NFT list.
      *
-     * @param address - Hex address of the NFT contract.
+     * @param tokenAddress - Hex address of the NFT contract.
      * @param tokenId - The NFT identifier.
      * @param nftMetadata - NFT optional information (name, image and description).
      * @param nftContract - An object containing contract data of the NFT being added.
-     * @param accountParams - The chain ID and address of network and account to which the nftContract should be added.
+     * @param chainId - The chainId of the network where the NFT is being added.
+     * @param userAddress - The address of the account where the NFT is being added.
      * @param source - Whether the NFT was detected, added manually or suggested by a dapp.
      * @returns Promise resolving to the current NFT list.
      */
-    addIndividualNft(address, tokenId, nftMetadata, nftContract, accountParams, source = constants_1.Source.Custom) {
+    addIndividualNft(tokenAddress, tokenId, nftMetadata, nftContract, chainId, userAddress, source) {
         var _a;
         return __awaiter(this, void 0, void 0, function* () {
             // TODO: Remove unused return
             const releaseLock = yield this.mutex.acquire();
             try {
-                address = (0, controller_utils_1.toChecksumHexAddress)(address);
+                tokenAddress = (0, controller_utils_1.toChecksumHexAddress)(tokenAddress);
                 const { allNfts } = this.state;
-                let chainId, selectedAddress;
-                if (accountParams) {
-                    chainId = accountParams.chainId;
-                    selectedAddress = accountParams.userAddress;
-                }
-                else {
-                    chainId = this.config.chainId;
-                    selectedAddress = this.config.selectedAddress;
-                }
-                const nfts = ((_a = allNfts[selectedAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
-                const existingEntry = nfts.find((nft) => nft.address.toLowerCase() === address.toLowerCase() &&
+                const nfts = ((_a = allNfts[userAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
+                const existingEntry = nfts.find((nft) => nft.address.toLowerCase() === tokenAddress.toLowerCase() &&
                     nft.tokenId === tokenId);
                 if (existingEntry) {
                     const differentMetadata = (0, assetsUtil_1.compareNftMetadata)(nftMetadata, existingEntry);
                     if (differentMetadata || !existingEntry.isCurrentlyOwned) {
                         // TODO: Switch to indexToUpdate
-                        const indexToRemove = nfts.findIndex((nft) => nft.address.toLowerCase() === address.toLowerCase() &&
+                        const indexToRemove = nfts.findIndex((nft) => nft.address.toLowerCase() === tokenAddress.toLowerCase() &&
                             nft.tokenId === tokenId);
                         /* istanbul ignore next */
                         if (indexToRemove !== -1) {
@@ -405,16 +388,15 @@ class NftController extends base_controller_1.BaseController {
                         return nfts;
                     }
                 }
-                const newEntry = Object.assign({ address,
-                    tokenId, favorite: (existingEntry === null || existingEntry === void 0 ? void 0 : existingEntry.favorite) || false, isCurrentlyOwned: true }, nftMetadata);
+                const newEntry = Object.assign({ address: tokenAddress, tokenId, favorite: (existingEntry === null || existingEntry === void 0 ? void 0 : existingEntry.favorite) || false, isCurrentlyOwned: true }, nftMetadata);
                 const newNfts = [...nfts, newEntry];
                 this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {
                     chainId,
-                    userAddress: selectedAddress,
+                    userAddress,
                 });
                 if (this.onNftAdded) {
                     this.onNftAdded({
-                        address,
+                        address: tokenAddress,
                         symbol: nftContract.symbol,
                         tokenId: tokenId.toString(),
                         standard: nftMetadata.standard,
@@ -431,55 +413,54 @@ class NftController extends base_controller_1.BaseController {
     /**
      * Adds an NFT contract to the stored NFT contracts list.
      *
-     * @param address - Hex address of the NFT contract.
-     * @param accountParams - The chain ID and address of network and account to which the nftContract should be added.
-     * @param source - Whether the NFT was detected, added manually or suggested by a dapp.
+     * @param options - options.
+     * @param options.tokenAddress - Hex address of the NFT contract.
+     * @param options.userAddress - The address of the account where the NFT is being added.
+     * @param options.nftMetadata - The retrieved NFTMetadata from API.
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.
      * @returns Promise resolving to the current NFT contracts list.
      */
-    addNftContract(address, accountParams, source) {
+    addNftContract({ tokenAddress, userAddress, networkClientId, source, nftMetadata, }) {
         var _a;
         return __awaiter(this, void 0, void 0, function* () {
             const releaseLock = yield this.mutex.acquire();
             try {
-                address = (0, controller_utils_1.toChecksumHexAddress)(address);
+                tokenAddress = (0, controller_utils_1.toChecksumHexAddress)(tokenAddress);
                 const { allNftContracts } = this.state;
-                let chainId, selectedAddress;
-                if (accountParams) {
-                    chainId = accountParams.chainId;
-                    selectedAddress = accountParams.userAddress;
-                }
-                else {
-                    chainId = this.config.chainId;
-                    selectedAddress = this.config.selectedAddress;
-                }
-                const nftContracts = ((_a = allNftContracts[selectedAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
-                const existingEntry = nftContracts.find((nftContract) => nftContract.address.toLowerCase() === address.toLowerCase());
+                const chainId = this.getCorrectChainId({
+                    networkClientId,
+                });
+                const nftContracts = ((_a = allNftContracts[userAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
+                const existingEntry = nftContracts.find((nftContract) => nftContract.address.toLowerCase() === tokenAddress.toLowerCase());
                 if (existingEntry) {
                     return nftContracts;
                 }
-                const contractInformation = yield this.getNftContractInformation(address);
-                const { asset_contract_type, created_date, schema_name, symbol, total_supply, description, external_link, collection: { name, image_url }, } = contractInformation;
+                // this doesn't work currently for detection if the user switches networks while the detection is processing
+                // will be fixed once detection uses networkClientIds
+                // get name and symbol if ERC721 then put together the metadata
+                const contractInformation = yield this.getNftContractInformation(tokenAddress, nftMetadata, networkClientId);
+                const { asset_contract_type, created_date, symbol, description, external_link, schema_name, collection: { name, image_url, tokenCount }, } = contractInformation;
                 // If the nft is auto-detected we want some valid metadata to be present
                 if (source === constants_1.Source.Detected &&
-                    Object.entries(contractInformation).every(([k, v]) => {
-                        if (k === 'address') {
-                            return true; // address will always be present
-                        }
-                        // collection will always be an object, we need to check the internal values
-                        if (k === 'collection') {
-                            return (v === null || v === void 0 ? void 0 : v.name) === null && (v === null || v === void 0 ? void 0 : v.image_url) === null;
-                        }
-                        return !v;
+                    'address' in contractInformation &&
+                    typeof contractInformation.address === 'string' &&
+                    'collection' in contractInformation &&
+                    contractInformation.collection.name === null &&
+                    'image_url' in contractInformation.collection &&
+                    contractInformation.collection.image_url === null &&
+                    Object.entries(contractInformation).every(([key, value]) => {
+                        return key === 'address' || key === 'collection' || !value;
                     })) {
                     return nftContracts;
                 }
                 /* istanbul ignore next */
-                const newEntry = Object.assign({}, { address }, description && { description }, name && { name }, image_url && { logo: image_url }, symbol && { symbol }, total_supply !== null &&
-                    typeof total_supply !== 'undefined' && { totalSupply: total_supply }, asset_contract_type && { assetContractType: asset_contract_type }, created_date && { createdDate: created_date }, schema_name && { schemaName: schema_name }, external_link && { externalLink: external_link });
+                const newEntry = Object.assign({}, { address: tokenAddress }, description && { description }, name && { name }, image_url && { logo: image_url }, symbol && { symbol }, tokenCount !== null &&
+                    typeof tokenCount !== 'undefined' && { totalSupply: tokenCount }, asset_contract_type && { assetContractType: asset_contract_type }, created_date && { createdDate: created_date }, schema_name && { schemaName: schema_name }, external_link && { externalLink: external_link });
                 const newNftContracts = [...nftContracts, newEntry];
                 this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY, {
                     chainId,
-                    userAddress: selectedAddress,
+                    userAddress,
                 });
                 return newNftContracts;
             }
@@ -493,14 +474,16 @@ class NftController extends base_controller_1.BaseController {
      *
      * @param address - Hex address of the NFT contract.
      * @param tokenId - Token identifier of the NFT.
+     * @param options - options.
+     * @param options.chainId - The chainId of the network where the NFT is being removed.
+     * @param options.userAddress - The address of the account where the NFT is being removed.
      */
-    removeAndIgnoreIndividualNft(address, tokenId) {
+    removeAndIgnoreIndividualNft(address, tokenId, { chainId, userAddress, }) {
         var _a;
         address = (0, controller_utils_1.toChecksumHexAddress)(address);
         const { allNfts, ignoredNfts } = this.state;
-        const { chainId, selectedAddress } = this.config;
         const newIgnoredNfts = [...ignoredNfts];
-        const nfts = ((_a = allNfts[selectedAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
+        const nfts = ((_a = allNfts[userAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
         const newNfts = nfts.filter((nft) => {
             if (nft.address.toLowerCase() === address.toLowerCase() &&
                 nft.tokenId === tokenId) {
@@ -510,7 +493,10 @@ class NftController extends base_controller_1.BaseController {
             }
             return true;
         });
-        this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY);
+        this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {
+            userAddress,
+            chainId,
+        });
         this.update({
             ignoredNfts: newIgnoredNfts,
         });
@@ -520,34 +506,44 @@ class NftController extends base_controller_1.BaseController {
      *
      * @param address - Hex address of the NFT contract.
      * @param tokenId - Token identifier of the NFT.
+     * @param options - options.
+     * @param options.chainId - The chainId of the network where the NFT is being removed.
+     * @param options.userAddress - The address of the account where the NFT is being removed.
      */
-    removeIndividualNft(address, tokenId) {
+    removeIndividualNft(address, tokenId, { chainId, userAddress }) {
         var _a;
         address = (0, controller_utils_1.toChecksumHexAddress)(address);
         const { allNfts } = this.state;
-        const { chainId, selectedAddress } = this.config;
-        const nfts = ((_a = allNfts[selectedAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
+        const nfts = ((_a = allNfts[userAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
         const newNfts = nfts.filter((nft) => !(nft.address.toLowerCase() === address.toLowerCase() &&
             nft.tokenId === tokenId));
-        this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY);
+        this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {
+            userAddress,
+            chainId,
+        });
     }
     /**
      * Removes an NFT contract to the stored NFT contracts list.
      *
      * @param address - Hex address of the NFT contract.
+     * @param options - options.
+     * @param options.chainId - The chainId of the network where the NFT is being removed.
+     * @param options.userAddress - The address of the account where the NFT is being removed.
      * @returns Promise resolving to the current NFT contracts list.
      */
-    removeNftContract(address) {
+    removeNftContract(address, { chainId, userAddress }) {
         var _a;
         address = (0, controller_utils_1.toChecksumHexAddress)(address);
         const { allNftContracts } = this.state;
-        const { chainId, selectedAddress } = this.config;
-        const nftContracts = ((_a = allNftContracts[selectedAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
+        const nftContracts = ((_a = allNftContracts[userAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
         const newNftContracts = nftContracts.filter((nftContract) => !(nftContract.address.toLowerCase() === address.toLowerCase()));
-        this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY);
+        this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY, {
+            chainId,
+            userAddress,
+        });
         return newNftContracts;
     }
-    validateWatchNft(asset, type, accountAddress) {
+    validateWatchNft(asset, type, userAddress, { networkClientId } = {}) {
         return __awaiter(this, void 0, void 0, function* () {
             const { address: contractAddress, tokenId } = asset;
             // Validate parameters
@@ -568,17 +564,28 @@ class NftController extends base_controller_1.BaseController {
             }
             // Check if the user owns the suggested NFT
             try {
-                const isOwner = yield this.isNftOwner(accountAddress, contractAddress, tokenId);
+                const isOwner = yield this.isNftOwner(userAddress, contractAddress, tokenId, { networkClientId });
                 if (!isOwner) {
                     throw rpc_errors_1.rpcErrors.invalidInput('Suggested NFT is not owned by the selected account');
                 }
             }
             catch (error) {
                 // error thrown here: "Unable to verify ownership. Possibly because the standard is not supported or the user's currently selected network does not match the chain of the asset in question."
-                throw rpc_errors_1.rpcErrors.resourceUnavailable(error.message);
+                if (error instanceof Error) {
+                    throw rpc_errors_1.rpcErrors.resourceUnavailable(error.message);
+                }
+                throw error;
             }
         });
     }
+    // temporary method to get the correct chainId until we remove chainId from the config & the chainId arg from the detection logic
+    // Just a helper method to prefer the networkClient chainId first then the chainId argument and then finally the config chainId
+    getCorrectChainId({ networkClientId, }) {
+        if (networkClientId) {
+            return this.getNetworkClientById(networkClientId).configuration.chainId;
+        }
+        return this.config.chainId;
+    }
     /**
      * Adds a new suggestedAsset to state. Parameters will be validated according to
      * asset type being watched. A `<suggestedNftMeta.id>:pending` hub event will be emitted once added.
@@ -588,13 +595,17 @@ class NftController extends base_controller_1.BaseController {
      * @param asset.tokenId - The ID of the asset.
      * @param type - The asset type.
      * @param origin - Domain origin to register the asset from.
+     * @param options - Options bag.
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @param options.userAddress - The address of the account where the NFT is being added.
      * @returns Object containing a Promise resolving to the suggestedAsset address if accepted.
      */
-    watchNft(asset, type, origin) {
+    watchNft(asset, type, origin, { networkClientId, userAddress = this.config.selectedAddress, } = {
+        userAddress: this.config.selectedAddress,
+    }) {
         return __awaiter(this, void 0, void 0, function* () {
-            const { selectedAddress, chainId } = this.config;
-            yield this.validateWatchNft(asset, type, selectedAddress);
-            const nftMetadata = yield this.getNftInformation(asset.address, asset.tokenId);
+            yield this.validateWatchNft(asset, type, userAddress);
+            const nftMetadata = yield this.getNftInformation(asset.address, asset.tokenId, networkClientId);
             if (nftMetadata.standard && nftMetadata.standard !== type) {
                 throw rpc_errors_1.rpcErrors.invalidInput(`Suggested NFT of type ${nftMetadata.standard} does not match received type ${type}`);
             }
@@ -603,21 +614,23 @@ class NftController extends base_controller_1.BaseController {
                 type,
                 id: (0, uuid_1.v4)(),
                 time: Date.now(),
-                interactingAddress: selectedAddress,
+                interactingAddress: userAddress,
                 origin,
             };
             yield this._requestApproval(suggestedNftMeta);
             const { address, tokenId } = asset;
             const { name, standard, description, image } = nftMetadata;
             yield this.addNft(address, tokenId, {
-                name: name !== null && name !== void 0 ? name : null,
-                description: description !== null && description !== void 0 ? description : null,
-                image: image !== null && image !== void 0 ? image : null,
-                standard: standard !== null && standard !== void 0 ? standard : null,
-            }, {
-                chainId,
-                userAddress: selectedAddress,
-            }, constants_1.Source.Dapp);
+                nftMetadata: {
+                    name: name !== null && name !== void 0 ? name : null,
+                    description: description !== null && description !== void 0 ? description : null,
+                    image: image !== null && image !== void 0 ? image : null,
+                    standard: standard !== null && standard !== void 0 ? standard : null,
+                },
+                userAddress,
+                source: constants_1.Source.Dapp,
+                networkClientId,
+            });
         });
     }
     /**
@@ -633,14 +646,16 @@ class NftController extends base_controller_1.BaseController {
      *
      * @param ownerAddress - User public address.
      * @param nftAddress - NFT contract address.
-     * @param nftId - NFT token ID.
+     * @param tokenId - NFT token ID.
+     * @param options - Options bag.
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
      * @returns Promise resolving the NFT ownership.
      */
-    isNftOwner(ownerAddress, nftAddress, nftId) {
+    isNftOwner(ownerAddress, nftAddress, tokenId, { networkClientId, } = {}) {
         return __awaiter(this, void 0, void 0, function* () {
             // Checks the ownership for ERC-721.
             try {
-                const owner = yield this.getERC721OwnerOf(nftAddress, nftId);
+                const owner = yield this.getERC721OwnerOf(nftAddress, tokenId, networkClientId);
                 return ownerAddress.toLowerCase() === owner.toLowerCase();
                 // eslint-disable-next-line no-empty
             }
@@ -649,7 +664,7 @@ class NftController extends base_controller_1.BaseController {
             }
             // Checks the ownership for ERC-1155.
             try {
-                const balance = yield this.getERC1155BalanceOf(ownerAddress, nftAddress, nftId);
+                const balance = yield this.getERC1155BalanceOf(ownerAddress, nftAddress, tokenId, networkClientId);
                 return !balance.isZero();
                 // eslint-disable-next-line no-empty
             }
@@ -665,56 +680,108 @@ class NftController extends base_controller_1.BaseController {
      *
      * @param address - Hex address of the NFT contract.
      * @param tokenId - The NFT identifier.
+     * @param options - an object of arguments
+     * @param options.userAddress - The address of the current user.
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.
      */
-    addNftVerifyOwnership(address, tokenId) {
+    addNftVerifyOwnership(address, tokenId, { userAddress = this.config.selectedAddress, networkClientId, source, } = {
+        userAddress: this.config.selectedAddress,
+    }) {
         return __awaiter(this, void 0, void 0, function* () {
-            const { selectedAddress } = this.config;
-            if (!(yield this.isNftOwner(selectedAddress, address, tokenId))) {
+            if (!(yield this.isNftOwner(userAddress, address, tokenId, {
+                networkClientId,
+            }))) {
                 throw new Error('This NFT is not owned by the user');
             }
-            yield this.addNft(address, tokenId);
+            yield this.addNft(address, tokenId, {
+                networkClientId,
+                userAddress,
+                source,
+            });
         });
     }
     /**
      * Adds an NFT and respective NFT contract to the stored NFT and NFT contracts lists.
      *
-     * @param address - Hex address of the NFT contract.
+     * @param tokenAddress - Hex address of the NFT contract.
      * @param tokenId - The NFT identifier.
-     * @param nftMetadata - NFT optional metadata.
-     * @param accountParams - The chain ID and address of network and account to which the nftContract should be added.
-     * @param source - Whether the NFT was detected, added manually or suggested by a dapp.
+     * @param options - an object of arguments
+     * @param options.nftMetadata - NFT optional metadata.
+     * @param options.userAddress - The address of the current user.
+     * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
      * @returns Promise resolving to the current NFT list.
      */
-    addNft(address, tokenId, nftMetadata, accountParams, source = constants_1.Source.Custom) {
+    addNft(tokenAddress, tokenId, { nftMetadata, userAddress = this.config.selectedAddress, source = constants_1.Source.Custom, networkClientId, } = { userAddress: this.config.selectedAddress }) {
         return __awaiter(this, void 0, void 0, function* () {
-            address = (0, controller_utils_1.toChecksumHexAddress)(address);
-            const newNftContracts = yield this.addNftContract(address, accountParams, source);
+            tokenAddress = (0, controller_utils_1.toChecksumHexAddress)(tokenAddress);
+            const chainId = this.getCorrectChainId({ networkClientId });
             nftMetadata =
-                nftMetadata || (yield this.getNftInformation(address, tokenId));
+                nftMetadata ||
+                    (yield this.getNftInformation(tokenAddress, tokenId, networkClientId));
+            const newNftContracts = yield this.addNftContract({
+                tokenAddress,
+                userAddress,
+                networkClientId,
+                source,
+                nftMetadata,
+            });
             // If NFT contract was not added, do not add individual NFT
-            const nftContract = newNftContracts.find((contract) => contract.address.toLowerCase() === address.toLowerCase());
+            const nftContract = newNftContracts.find((contract) => contract.address.toLowerCase() === tokenAddress.toLowerCase());
             // If NFT contract information, add individual NFT
             if (nftContract) {
-                yield this.addIndividualNft(address, tokenId, nftMetadata, nftContract, accountParams, source);
+                yield this.addIndividualNft(tokenAddress, tokenId, nftMetadata, nftContract, chainId, userAddress, source);
             }
         });
     }
+    /**
+     * Refetches NFT metadata and updates the state
+     *
+     * @param options - Options for refetching NFT metadata
+     * @param options.nfts - Array of nfts
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @param options.userAddress - The current user address
+     */
+    updateNftMetadata({ nfts, networkClientId, userAddress = this.config.selectedAddress, }) {
+        return __awaiter(this, void 0, void 0, function* () {
+            const chainId = this.getCorrectChainId({ networkClientId });
+            const nftsWithChecksumAdr = nfts.map((nft) => {
+                return Object.assign(Object.assign({}, nft), { address: (0, controller_utils_1.toChecksumHexAddress)(nft.address) });
+            });
+            const nftMetadataResults = yield Promise.allSettled(nftsWithChecksumAdr.map((nft) => __awaiter(this, void 0, void 0, function* () {
+                const resMetadata = yield this.getNftInformation(nft.address, nft.tokenId, networkClientId);
+                return {
+                    nft,
+                    newMetadata: resMetadata,
+                };
+            })));
+            nftMetadataResults
+                .filter((result) => result.status === 'fulfilled')
+                .forEach((elm) => this.updateNft(elm.value.nft, elm.value.newMetadata, userAddress, chainId));
+        });
+    }
     /**
      * Removes an NFT from the stored token list.
      *
      * @param address - Hex address of the NFT contract.
      * @param tokenId - Token identifier of the NFT.
+     * @param options - an object of arguments
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @param options.userAddress - The address of the account where the NFT is being removed.
      */
-    removeNft(address, tokenId) {
+    removeNft(address, tokenId, { networkClientId, userAddress = this.config.selectedAddress, } = {
+        userAddress: this.config.selectedAddress,
+    }) {
         var _a;
+        const chainId = this.getCorrectChainId({ networkClientId });
         address = (0, controller_utils_1.toChecksumHexAddress)(address);
-        this.removeIndividualNft(address, tokenId);
+        this.removeIndividualNft(address, tokenId, { chainId, userAddress });
         const { allNfts } = this.state;
-        const { chainId, selectedAddress } = this.config;
-        const nfts = ((_a = allNfts[selectedAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
+        const nfts = ((_a = allNfts[userAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
         const remainingNft = nfts.find((nft) => nft.address.toLowerCase() === address.toLowerCase());
         if (!remainingNft) {
-            this.removeNftContract(address);
+            this.removeNftContract(address, { chainId, userAddress });
         }
     }
     /**
@@ -722,17 +789,25 @@ class NftController extends base_controller_1.BaseController {
      *
      * @param address - Hex address of the NFT contract.
      * @param tokenId - Token identifier of the NFT.
+     * @param options - an object of arguments
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @param options.userAddress - The address of the account where the NFT is being removed.
      */
-    removeAndIgnoreNft(address, tokenId) {
+    removeAndIgnoreNft(address, tokenId, { networkClientId, userAddress = this.config.selectedAddress, } = {
+        userAddress: this.config.selectedAddress,
+    }) {
         var _a;
+        const chainId = this.getCorrectChainId({ networkClientId });
         address = (0, controller_utils_1.toChecksumHexAddress)(address);
-        this.removeAndIgnoreIndividualNft(address, tokenId);
+        this.removeAndIgnoreIndividualNft(address, tokenId, {
+            chainId,
+            userAddress,
+        });
         const { allNfts } = this.state;
-        const { chainId, selectedAddress } = this.config;
-        const nfts = ((_a = allNfts[selectedAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
+        const nfts = ((_a = allNfts[userAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
         const remainingNft = nfts.find((nft) => nft.address.toLowerCase() === address.toLowerCase());
         if (!remainingNft) {
-            this.removeNftContract(address);
+            this.removeNftContract(address, { chainId, userAddress });
         }
     }
     /**
@@ -749,25 +824,26 @@ class NftController extends base_controller_1.BaseController {
      * @param batch - A boolean indicating whether this method is being called as part of a batch or single update.
      * @param accountParams - The userAddress and chainId to check ownership against
      * @param accountParams.userAddress - the address passed through the confirmed transaction flow to ensure assets are stored to the correct account
-     * @param accountParams.chainId - the chainId passed through the confirmed transaction flow to ensure assets are stored to the correct account
+     * @param accountParams.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
      * @returns the NFT with the updated isCurrentlyOwned value
      */
-    checkAndUpdateSingleNftOwnershipStatus(nft, batch, { userAddress, chainId } = {
+    checkAndUpdateSingleNftOwnershipStatus(nft, batch, { userAddress = this.config.selectedAddress, networkClientId, } = {
         userAddress: this.config.selectedAddress,
-        chainId: this.config.chainId,
     }) {
         var _a;
         return __awaiter(this, void 0, void 0, function* () {
+            const chainId = this.getCorrectChainId({ networkClientId });
             const { address, tokenId } = nft;
             let isOwned = nft.isCurrentlyOwned;
             try {
-                isOwned = yield this.isNftOwner(userAddress, address, tokenId);
+                isOwned = yield this.isNftOwner(userAddress, address, tokenId, {
+                    networkClientId,
+                });
             }
-            catch (error) {
-                if (!(error instanceof Error &&
-                    error.message.includes('Unable to verify ownership'))) {
-                    throw error;
-                }
+            catch (_b) {
+                // ignore error
+                // this will only throw an error 'Unable to verify ownership' in which case
+                // we want to keep the current value of isCurrentlyOwned for this flow.
             }
             nft.isCurrentlyOwned = isOwned;
             if (batch) {
@@ -791,18 +867,29 @@ class NftController extends base_controller_1.BaseController {
     /**
      * Checks whether NFTs associated with current selectedAddress/chainId combination are still owned by the user
      * And updates the isCurrentlyOwned value on each accordingly.
+     * @param options - an object of arguments
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @param options.userAddress - The address of the account where the NFT ownership status is checked/updated.
      */
-    checkAndUpdateAllNftsOwnershipStatus() {
+    checkAndUpdateAllNftsOwnershipStatus({ networkClientId, userAddress = this.config.selectedAddress, } = {
+        userAddress: this.config.selectedAddress,
+    }) {
         var _a;
         return __awaiter(this, void 0, void 0, function* () {
+            const chainId = this.getCorrectChainId({ networkClientId });
             const { allNfts } = this.state;
-            const { chainId, selectedAddress } = this.config;
-            const nfts = ((_a = allNfts[selectedAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
+            const nfts = ((_a = allNfts[userAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
             const updatedNfts = yield Promise.all(nfts.map((nft) => __awaiter(this, void 0, void 0, function* () {
                 var _b;
-                return ((_b = (yield this.checkAndUpdateSingleNftOwnershipStatus(nft, true))) !== null && _b !== void 0 ? _b : nft);
+                return ((_b = (yield this.checkAndUpdateSingleNftOwnershipStatus(nft, true, {
+                    networkClientId,
+                    userAddress,
+                }))) !== null && _b !== void 0 ? _b : nft);
             })));
-            this.updateNestedNftState(updatedNfts, ALL_NFTS_STATE_KEY);
+            this.updateNestedNftState(updatedNfts, ALL_NFTS_STATE_KEY, {
+                userAddress,
+                chainId,
+            });
         });
     }
     /**
@@ -811,12 +898,17 @@ class NftController extends base_controller_1.BaseController {
      * @param address - Hex address of the NFT contract.
      * @param tokenId - Hex address of the NFT contract.
      * @param favorite - NFT new favorite status.
+     * @param options - an object of arguments
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @param options.userAddress - The address of the account where the NFT is being removed.
      */
-    updateNftFavoriteStatus(address, tokenId, favorite) {
+    updateNftFavoriteStatus(address, tokenId, favorite, { networkClientId, userAddress = this.config.selectedAddress, } = {
+        userAddress: this.config.selectedAddress,
+    }) {
         var _a;
+        const chainId = this.getCorrectChainId({ networkClientId });
         const { allNfts } = this.state;
-        const { chainId, selectedAddress } = this.config;
-        const nfts = ((_a = allNfts[selectedAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
+        const nfts = ((_a = allNfts[userAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
         const index = nfts.findIndex((nft) => nft.address === address && nft.tokenId === tokenId);
         if (index === -1) {
             return;
@@ -824,7 +916,10 @@ class NftController extends base_controller_1.BaseController {
         const updatedNft = Object.assign(Object.assign({}, nfts[index]), { favorite });
         // Update Nfts array
         nfts[index] = updatedNft;
-        this.updateNestedNftState(nfts, ALL_NFTS_STATE_KEY);
+        this.updateNestedNftState(nfts, ALL_NFTS_STATE_KEY, {
+            chainId,
+            userAddress,
+        });
     }
     /**
      * Returns an NFT by the address and token id.
@@ -868,7 +963,10 @@ class NftController extends base_controller_1.BaseController {
             updatedNft,
             ...nfts.slice(nftInfo.index + 1),
         ];
-        this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY);
+        this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {
+            chainId,
+            userAddress: selectedAddress,
+        });
     }
     /**
      * Resets the transaction status of an NFT.
@@ -876,7 +974,7 @@ class NftController extends base_controller_1.BaseController {
      * @param transactionId - NFT transaction id.
      * @param selectedAddress - Hex address of the user account.
      * @param chainId - Id of the current network.
-     * @returns a boolean indicating if the reset was well succeded or not
+     * @returns a boolean indicating if the reset was well succeeded or not
      */
     resetNftTransactionStatusByTransactionId(transactionId, selectedAddress, chainId) {
         var _a;
@@ -892,7 +990,10 @@ class NftController extends base_controller_1.BaseController {
             updatedNft,
             ...nfts.slice(index + 1),
         ];
-        this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY);
+        this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {
+            chainId,
+            userAddress: selectedAddress,
+        });
         return true;
     }
     _requestApproval(suggestedNftMeta) {
diff --git a/node_modules/@metamask/assets-controllers/dist/NftController.js.map b/node_modules/@metamask/assets-controllers/dist/NftController.js.map
index 90c895d..2b46600 100644
--- a/node_modules/@metamask/assets-controllers/dist/NftController.js.map
+++ b/node_modules/@metamask/assets-controllers/dist/NftController.js.map
@@ -1 +1 @@
-{"version":3,"file":"NftController.js","sourceRoot":"","sources":["../src/NftController.ts"],"names":[],"mappings":"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","sourcesContent":["import { isAddress } from '@ethersproject/address';\nimport type { AddApprovalRequest } from '@metamask/approval-controller';\nimport type {\n  BaseConfig,\n  BaseState,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport {\n  safelyExecute,\n  handleFetch,\n  toChecksumHexAddress,\n  BNToHex,\n  fetchWithErrorHandling,\n  IPFS_DEFAULT_GATEWAY_URL,\n  ERC721,\n  ERC1155,\n  OPENSEA_PROXY_URL,\n  ApprovalType,\n} from '@metamask/controller-utils';\nimport type { NetworkState } from '@metamask/network-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type { Hex } from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\nimport { BN, stripHexPrefix } from 'ethereumjs-util';\nimport { EventEmitter } from 'events';\nimport { v4 as random } from 'uuid';\n\nimport type { AssetsContractController } from './AssetsContractController';\nimport { compareNftMetadata, getFormattedIpfsUrl } from './assetsUtil';\nimport { Source } from './constants';\nimport type {\n  ApiNft,\n  ApiNftCreator,\n  ApiNftContract,\n  ApiNftLastSale,\n} from './NftDetectionController';\n\ntype NFTStandardType = 'ERC721' | 'ERC1155';\n\ntype SuggestedNftMeta = {\n  asset: { address: string; tokenId: string } & NftMetadata;\n  id: string;\n  time: number;\n  type: NFTStandardType;\n  interactingAddress: string;\n  origin: string;\n};\n\n/**\n * @type Nft\n *\n * NFT representation\n * @property address - Hex address of a ERC721 contract\n * @property description - The NFT description\n * @property image - URI of custom NFT image associated with this tokenId\n * @property name - Name associated with this tokenId and contract address\n * @property tokenId - The NFT identifier\n * @property numberOfSales - Number of sales\n * @property backgroundColor - The background color to be displayed with the item\n * @property imagePreview - URI of a smaller image associated with this NFT\n * @property imageThumbnail - URI of a thumbnail image associated with this NFT\n * @property imageOriginal - URI of the original image associated with this NFT\n * @property animation - URI of a animation associated with this NFT\n * @property animationOriginal - URI of the original animation associated with this NFT\n * @property externalLink - External link containing additional information\n * @property creator - The NFT owner information object\n * @property isCurrentlyOwned - Boolean indicating whether the address/chainId combination where it's currently stored currently owns this NFT\n * @property transactionId - Transaction Id associated with the NFT\n */\nexport interface Nft extends NftMetadata {\n  tokenId: string;\n  address: string;\n  isCurrentlyOwned?: boolean;\n}\n\n/**\n * @type NftContract\n *\n * NFT contract information representation\n * @property name - Contract name\n * @property logo - Contract logo\n * @property address - Contract address\n * @property symbol - Contract symbol\n * @property description - Contract description\n * @property totalSupply - Total supply of NFTs\n * @property assetContractType - The NFT type, it could be `semi-fungible` or `non-fungible`\n * @property createdDate - Creation date\n * @property schemaName - The schema followed by the contract, it could be `ERC721` or `ERC1155`\n * @property externalLink - External link containing additional information\n */\nexport interface NftContract {\n  name?: string;\n  logo?: string;\n  address: string;\n  symbol?: string;\n  description?: string;\n  totalSupply?: string;\n  assetContractType?: string;\n  createdDate?: string;\n  schemaName?: string;\n  externalLink?: string;\n}\n\n/**\n * @type NftMetadata\n *\n * NFT custom information\n * @property name - NFT custom name\n * @property description - The NFT description\n * @property numberOfSales - Number of sales\n * @property backgroundColor - The background color to be displayed with the item\n * @property image - Image custom image URI\n * @property imagePreview - URI of a smaller image associated with this NFT\n * @property imageThumbnail - URI of a thumbnail image associated with this NFT\n * @property imageOriginal - URI of the original image associated with this NFT\n * @property animation - URI of a animation associated with this NFT\n * @property animationOriginal - URI of the original animation associated with this NFT\n * @property externalLink - External link containing additional information\n * @property creator - The NFT owner information object\n * @property standard - NFT standard name for the NFT, e.g., ERC-721 or ERC-1155\n */\nexport interface NftMetadata {\n  name: string | null;\n  description: string | null;\n  image: string | null;\n  standard: string | null;\n  favorite?: boolean;\n  numberOfSales?: number;\n  backgroundColor?: string;\n  imagePreview?: string;\n  imageThumbnail?: string;\n  imageOriginal?: string;\n  animation?: string;\n  animationOriginal?: string;\n  externalLink?: string;\n  creator?: ApiNftCreator;\n  lastSale?: ApiNftLastSale;\n  transactionId?: string;\n  tokenURI?: string | null;\n}\n\ninterface AccountParams {\n  userAddress: string;\n  chainId: Hex;\n}\n\n/**\n * @type NftConfig\n *\n * NFT controller configuration\n * @property selectedAddress - Vault selected address\n */\nexport interface NftConfig extends BaseConfig {\n  selectedAddress: string;\n  chainId: Hex;\n  ipfsGateway: string;\n  openSeaEnabled: boolean;\n  useIPFSSubdomains: boolean;\n  isIpfsGatewayEnabled: boolean;\n}\n\n/**\n * @type NftState\n *\n * NFT controller state\n * @property allNftContracts - Object containing NFT contract information\n * @property allNfts - Object containing NFTs per account and network\n * @property ignoredNfts - List of NFTs that should be ignored\n */\nexport interface NftState extends BaseState {\n  allNftContracts: {\n    [key: string]: { [chainId: Hex]: NftContract[] };\n  };\n  allNfts: { [key: string]: { [chainId: Hex]: Nft[] } };\n  ignoredNfts: Nft[];\n}\n\nconst ALL_NFTS_STATE_KEY = 'allNfts';\nconst ALL_NFTS_CONTRACTS_STATE_KEY = 'allNftContracts';\n\ninterface NftAsset {\n  address: string;\n  tokenId: string;\n}\n\n/**\n * The name of the {@link NftController}.\n */\nconst controllerName = 'NftController';\n\n/**\n * The external actions available to the {@link NftController}.\n */\ntype AllowedActions = AddApprovalRequest;\n\n/**\n * The messenger of the {@link NftController}.\n */\nexport type NftControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  AllowedActions,\n  never,\n  AllowedActions['type'],\n  never\n>;\n\n/**\n * Controller that stores assets and exposes convenience methods\n */\nexport class NftController extends BaseController<NftConfig, NftState> {\n  private readonly mutex = new Mutex();\n\n  private readonly messagingSystem: NftControllerMessenger;\n\n  private getNftApi({\n    contractAddress,\n    tokenId,\n  }: {\n    contractAddress: string;\n    tokenId: string;\n  }) {\n    return `${OPENSEA_PROXY_URL}/asset/${contractAddress}/${tokenId}`;\n  }\n\n  private getNftContractInformationApi({\n    contractAddress,\n  }: {\n    contractAddress: string;\n  }) {\n    return `${OPENSEA_PROXY_URL}/asset_contract/${contractAddress}`;\n  }\n\n  /**\n   * Helper method to update nested state for allNfts and allNftContracts.\n   *\n   * @param newCollection - the modified piece of state to update in the controller's store\n   * @param baseStateKey - The root key in the store to update.\n   * @param passedConfig - An object containing the selectedAddress and chainId that are passed through the auto-detection flow.\n   * @param passedConfig.userAddress - the address passed through the NFT detection flow to ensure assets are stored to the correct account\n   * @param passedConfig.chainId - the chainId passed through the NFT detection flow to ensure assets are stored to the correct account\n   */\n  private updateNestedNftState(\n    newCollection: Nft[] | NftContract[],\n    baseStateKey: 'allNfts' | 'allNftContracts',\n    { userAddress, chainId } = {\n      userAddress: this.config.selectedAddress,\n      chainId: this.config.chainId,\n    },\n  ) {\n    const { [baseStateKey]: oldState } = this.state;\n\n    const addressState = oldState[userAddress];\n    const newAddressState = {\n      ...addressState,\n      ...{ [chainId]: newCollection },\n    };\n    const newState = {\n      ...oldState,\n      ...{ [userAddress]: newAddressState },\n    };\n\n    this.update({\n      [baseStateKey]: newState,\n    });\n  }\n\n  /**\n   * Request individual NFT information from OpenSea API.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftInformationFromApi(\n    contractAddress: string,\n    tokenId: string,\n  ): Promise<NftMetadata> {\n    // Attempt to fetch the data with the proxy\n    const nftInformation: ApiNft | undefined = await fetchWithErrorHandling({\n      url: this.getNftApi({\n        contractAddress,\n        tokenId,\n      }),\n    });\n\n    // if we were still unable to fetch the data we return out the default/null of `NftMetadata`\n    if (!nftInformation) {\n      return {\n        name: null,\n        description: null,\n        image: null,\n        standard: null,\n      };\n    }\n\n    // if we've reached this point, we have successfully fetched some data for nftInformation\n    // now we reconfigure the data to conform to the `NftMetadata` type for storage.\n    const {\n      num_sales,\n      background_color,\n      image_url,\n      image_preview_url,\n      image_thumbnail_url,\n      image_original_url,\n      animation_url,\n      animation_original_url,\n      name,\n      description,\n      external_link,\n      creator,\n      last_sale,\n      asset_contract: { schema_name },\n    } = nftInformation;\n\n    /* istanbul ignore next */\n    const nftMetadata: NftMetadata = Object.assign(\n      {},\n      { name: name || null },\n      { description: description || null },\n      { image: image_url || null },\n      creator && { creator },\n      num_sales && { numberOfSales: num_sales },\n      background_color && { backgroundColor: background_color },\n      image_preview_url && { imagePreview: image_preview_url },\n      image_thumbnail_url && { imageThumbnail: image_thumbnail_url },\n      image_original_url && { imageOriginal: image_original_url },\n      animation_url && { animation: animation_url },\n      animation_original_url && {\n        animationOriginal: animation_original_url,\n      },\n      external_link && { externalLink: external_link },\n      last_sale && { lastSale: last_sale },\n      schema_name && { standard: schema_name },\n    );\n\n    return nftMetadata;\n  }\n\n  /**\n   * Request individual NFT information from contracts that follows Metadata Interface.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftInformationFromTokenURI(\n    contractAddress: string,\n    tokenId: string,\n  ): Promise<NftMetadata> {\n    const { ipfsGateway, useIPFSSubdomains, isIpfsGatewayEnabled } =\n      this.config;\n    const result = await this.getNftURIAndStandard(contractAddress, tokenId);\n    let tokenURI = result[0];\n    const standard = result[1];\n\n    const hasIpfsTokenURI = tokenURI.startsWith('ipfs://');\n\n    if (hasIpfsTokenURI && !isIpfsGatewayEnabled) {\n      return {\n        image: null,\n        name: null,\n        description: null,\n        standard: standard || null,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    }\n    if (hasIpfsTokenURI) {\n      tokenURI = getFormattedIpfsUrl(ipfsGateway, tokenURI, useIPFSSubdomains);\n    }\n\n    try {\n      const object = await handleFetch(tokenURI);\n      // TODO: Check image_url existence. This is not part of EIP721 nor EIP1155\n      const image = Object.prototype.hasOwnProperty.call(object, 'image')\n        ? 'image'\n        : /* istanbul ignore next */ 'image_url';\n\n      return {\n        image: object[image],\n        name: object.name,\n        description: object.description,\n        standard,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    } catch {\n      return {\n        image: null,\n        name: null,\n        description: null,\n        standard: standard || null,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    }\n  }\n\n  /**\n   * Retrieve NFT uri with  metadata. TODO Update method to use IPFS.\n   *\n   * @param contractAddress - NFT contract address.\n   * @param tokenId - NFT token id.\n   * @returns Promise resolving NFT uri and token standard.\n   */\n  private async getNftURIAndStandard(\n    contractAddress: string,\n    tokenId: string,\n  ): Promise<[string, string]> {\n    // try ERC721 uri\n    try {\n      const uri = await this.getERC721TokenURI(contractAddress, tokenId);\n      return [uri, ERC721];\n    } catch {\n      // Ignore error\n    }\n\n    // try ERC1155 uri\n    try {\n      const tokenURI = await this.getERC1155TokenURI(contractAddress, tokenId);\n\n      /**\n       * According to EIP1155 the URI value allows for ID substitution\n       * in case the string `{id}` exists.\n       * https://eips.ethereum.org/EIPS/eip-1155#metadata\n       */\n\n      if (!tokenURI.includes('{id}')) {\n        return [tokenURI, ERC1155];\n      }\n\n      const hexTokenId = stripHexPrefix(BNToHex(new BN(tokenId)))\n        .padStart(64, '0')\n        .toLowerCase();\n      return [tokenURI.replace('{id}', hexTokenId), ERC1155];\n    } catch {\n      // Ignore error\n    }\n\n    return ['', ''];\n  }\n\n  /**\n   * Request individual NFT information (name, image url and description).\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftInformation(\n    contractAddress: string,\n    tokenId: string,\n  ): Promise<NftMetadata> {\n    const blockchainMetadata = await safelyExecute(async () => {\n      return await this.getNftInformationFromTokenURI(contractAddress, tokenId);\n    });\n\n    let openSeaMetadata;\n    if (this.config.openSeaEnabled) {\n      openSeaMetadata = await safelyExecute(async () => {\n        return await this.getNftInformationFromApi(contractAddress, tokenId);\n      });\n    }\n    return {\n      ...openSeaMetadata,\n      name: blockchainMetadata.name ?? openSeaMetadata?.name ?? null,\n      description:\n        blockchainMetadata.description ?? openSeaMetadata?.description ?? null,\n      image: blockchainMetadata.image ?? openSeaMetadata?.image ?? null,\n      standard:\n        blockchainMetadata.standard ?? openSeaMetadata?.standard ?? null,\n      tokenURI: blockchainMetadata.tokenURI ?? null,\n    };\n  }\n\n  /**\n   * Request NFT contract information from OpenSea API.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftContractInformationFromApi(\n    contractAddress: string,\n  ): Promise<ApiNftContract> {\n    /* istanbul ignore if */\n    const apiNftContractObject: ApiNftContract | undefined =\n      await fetchWithErrorHandling({\n        url: this.getNftContractInformationApi({\n          contractAddress,\n        }),\n      });\n\n    // if we successfully fetched return the fetched data immediately\n    if (apiNftContractObject) {\n      return apiNftContractObject;\n    }\n\n    // If we've reached this point we were unable to fetch data from either the proxy or opensea so we return\n    // the default/null of ApiNftContract\n    return {\n      address: contractAddress,\n      asset_contract_type: null,\n      created_date: null,\n      schema_name: null,\n      symbol: null,\n      total_supply: null,\n      description: null,\n      external_link: null,\n      collection: {\n        name: null,\n        image_url: null,\n      },\n    };\n  }\n\n  /**\n   * Request NFT contract information from the contract itself.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftContractInformationFromContract(\n    contractAddress: string,\n  ): Promise<\n    Partial<ApiNftContract> &\n      Pick<ApiNftContract, 'address'> &\n      Pick<ApiNftContract, 'collection'>\n  > {\n    const name = await this.getERC721AssetName(contractAddress);\n    const symbol = await this.getERC721AssetSymbol(contractAddress);\n    return {\n      collection: { name },\n      symbol,\n      address: contractAddress,\n    };\n  }\n\n  /**\n   * Request NFT contract information from OpenSea API.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @returns Promise resolving to the NFT contract name, image and description.\n   */\n  private async getNftContractInformation(\n    contractAddress: string,\n  ): Promise<\n    Partial<ApiNftContract> &\n      Pick<ApiNftContract, 'address'> &\n      Pick<ApiNftContract, 'collection'>\n  > {\n    const blockchainContractData: Partial<ApiNftContract> &\n      Pick<ApiNftContract, 'address'> &\n      Pick<ApiNftContract, 'collection'> = await safelyExecute(async () => {\n      return await this.getNftContractInformationFromContract(contractAddress);\n    });\n\n    let openSeaContractData: Partial<ApiNftContract> | undefined;\n    if (this.config.openSeaEnabled) {\n      openSeaContractData = await safelyExecute(async () => {\n        return await this.getNftContractInformationFromApi(contractAddress);\n      });\n    }\n\n    if (blockchainContractData || openSeaContractData) {\n      return {\n        ...openSeaContractData,\n        ...blockchainContractData,\n        collection: {\n          image_url: null,\n          ...openSeaContractData?.collection,\n          ...blockchainContractData?.collection,\n        },\n      };\n    }\n\n    /* istanbul ignore next */\n    return {\n      address: contractAddress,\n      asset_contract_type: null,\n      created_date: null,\n      schema_name: null,\n      symbol: null,\n      total_supply: null,\n      description: null,\n      external_link: null,\n      collection: { name: null, image_url: null },\n    };\n  }\n\n  /**\n   * Adds an individual NFT to the stored NFT list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param nftMetadata - NFT optional information (name, image and description).\n   * @param nftContract - An object containing contract data of the NFT being added.\n   * @param accountParams - The chain ID and address of network and account to which the nftContract should be added.\n   * @param source - Whether the NFT was detected, added manually or suggested by a dapp.\n   * @returns Promise resolving to the current NFT list.\n   */\n  private async addIndividualNft(\n    address: string,\n    tokenId: string,\n    nftMetadata: NftMetadata,\n    nftContract: NftContract,\n    accountParams?: AccountParams,\n    source = Source.Custom,\n  ): Promise<Nft[]> {\n    // TODO: Remove unused return\n    const releaseLock = await this.mutex.acquire();\n    try {\n      address = toChecksumHexAddress(address);\n      const { allNfts } = this.state;\n      let chainId, selectedAddress;\n      if (accountParams) {\n        chainId = accountParams.chainId;\n        selectedAddress = accountParams.userAddress;\n      } else {\n        chainId = this.config.chainId;\n        selectedAddress = this.config.selectedAddress;\n      }\n\n      const nfts = allNfts[selectedAddress]?.[chainId] || [];\n\n      const existingEntry: Nft | undefined = nfts.find(\n        (nft) =>\n          nft.address.toLowerCase() === address.toLowerCase() &&\n          nft.tokenId === tokenId,\n      );\n\n      if (existingEntry) {\n        const differentMetadata = compareNftMetadata(\n          nftMetadata,\n          existingEntry,\n        );\n        if (differentMetadata || !existingEntry.isCurrentlyOwned) {\n          // TODO: Switch to indexToUpdate\n          const indexToRemove = nfts.findIndex(\n            (nft) =>\n              nft.address.toLowerCase() === address.toLowerCase() &&\n              nft.tokenId === tokenId,\n          );\n          /* istanbul ignore next */\n          if (indexToRemove !== -1) {\n            nfts.splice(indexToRemove, 1);\n          }\n        } else {\n          return nfts;\n        }\n      }\n\n      const newEntry: Nft = {\n        address,\n        tokenId,\n        favorite: existingEntry?.favorite || false,\n        isCurrentlyOwned: true,\n        ...nftMetadata,\n      };\n\n      const newNfts = [...nfts, newEntry];\n      this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n        chainId,\n        userAddress: selectedAddress,\n      });\n\n      if (this.onNftAdded) {\n        this.onNftAdded({\n          address,\n          symbol: nftContract.symbol,\n          tokenId: tokenId.toString(),\n          standard: nftMetadata.standard,\n          source,\n        });\n      }\n\n      return newNfts;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Adds an NFT contract to the stored NFT contracts list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param accountParams - The chain ID and address of network and account to which the nftContract should be added.\n   * @param source - Whether the NFT was detected, added manually or suggested by a dapp.\n   * @returns Promise resolving to the current NFT contracts list.\n   */\n  private async addNftContract(\n    address: string,\n    accountParams?: AccountParams,\n    source?: Source,\n  ): Promise<NftContract[]> {\n    const releaseLock = await this.mutex.acquire();\n    try {\n      address = toChecksumHexAddress(address);\n      const { allNftContracts } = this.state;\n      let chainId, selectedAddress;\n      if (accountParams) {\n        chainId = accountParams.chainId;\n        selectedAddress = accountParams.userAddress;\n      } else {\n        chainId = this.config.chainId;\n        selectedAddress = this.config.selectedAddress;\n      }\n\n      const nftContracts = allNftContracts[selectedAddress]?.[chainId] || [];\n\n      const existingEntry = nftContracts.find(\n        (nftContract) =>\n          nftContract.address.toLowerCase() === address.toLowerCase(),\n      );\n      if (existingEntry) {\n        return nftContracts;\n      }\n      const contractInformation = await this.getNftContractInformation(address);\n      const {\n        asset_contract_type,\n        created_date,\n        schema_name,\n        symbol,\n        total_supply,\n        description,\n        external_link,\n        collection: { name, image_url },\n      } = contractInformation;\n\n      // If the nft is auto-detected we want some valid metadata to be present\n      if (\n        source === Source.Detected &&\n        Object.entries(contractInformation).every(([k, v]: [string, any]) => {\n          if (k === 'address') {\n            return true; // address will always be present\n          }\n          // collection will always be an object, we need to check the internal values\n          if (k === 'collection') {\n            return v?.name === null && v?.image_url === null;\n          }\n          return !v;\n        })\n      ) {\n        return nftContracts;\n      }\n\n      /* istanbul ignore next */\n      const newEntry: NftContract = Object.assign(\n        {},\n        { address },\n        description && { description },\n        name && { name },\n        image_url && { logo: image_url },\n        symbol && { symbol },\n        total_supply !== null &&\n          typeof total_supply !== 'undefined' && { totalSupply: total_supply },\n        asset_contract_type && { assetContractType: asset_contract_type },\n        created_date && { createdDate: created_date },\n        schema_name && { schemaName: schema_name },\n        external_link && { externalLink: external_link },\n      );\n      const newNftContracts = [...nftContracts, newEntry];\n      this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY, {\n        chainId,\n        userAddress: selectedAddress,\n      });\n\n      return newNftContracts;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Removes an individual NFT from the stored token list and saves it in ignored NFTs list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   */\n  private removeAndIgnoreIndividualNft(address: string, tokenId: string) {\n    address = toChecksumHexAddress(address);\n    const { allNfts, ignoredNfts } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const newIgnoredNfts = [...ignoredNfts];\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const newNfts = nfts.filter((nft) => {\n      if (\n        nft.address.toLowerCase() === address.toLowerCase() &&\n        nft.tokenId === tokenId\n      ) {\n        const alreadyIgnored = newIgnoredNfts.find(\n          (c) => c.address === address && c.tokenId === tokenId,\n        );\n        !alreadyIgnored && newIgnoredNfts.push(nft);\n        return false;\n      }\n      return true;\n    });\n\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY);\n\n    this.update({\n      ignoredNfts: newIgnoredNfts,\n    });\n  }\n\n  /**\n   * Removes an individual NFT from the stored token list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   */\n  private removeIndividualNft(address: string, tokenId: string) {\n    address = toChecksumHexAddress(address);\n    const { allNfts } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const newNfts = nfts.filter(\n      (nft) =>\n        !(\n          nft.address.toLowerCase() === address.toLowerCase() &&\n          nft.tokenId === tokenId\n        ),\n    );\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY);\n  }\n\n  /**\n   * Removes an NFT contract to the stored NFT contracts list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @returns Promise resolving to the current NFT contracts list.\n   */\n  private removeNftContract(address: string): NftContract[] {\n    address = toChecksumHexAddress(address);\n    const { allNftContracts } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const nftContracts = allNftContracts[selectedAddress]?.[chainId] || [];\n\n    const newNftContracts = nftContracts.filter(\n      (nftContract) =>\n        !(nftContract.address.toLowerCase() === address.toLowerCase()),\n    );\n    this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY);\n\n    return newNftContracts;\n  }\n\n  /**\n   * EventEmitter instance used to listen to specific EIP747 events\n   */\n  hub = new EventEmitter();\n\n  /**\n   * Optional API key to use with opensea\n   */\n  openSeaApiKey?: string;\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'NftController';\n\n  private readonly getERC721AssetName: AssetsContractController['getERC721AssetName'];\n\n  private readonly getERC721AssetSymbol: AssetsContractController['getERC721AssetSymbol'];\n\n  private readonly getERC721TokenURI: AssetsContractController['getERC721TokenURI'];\n\n  private readonly getERC721OwnerOf: AssetsContractController['getERC721OwnerOf'];\n\n  private readonly getERC1155BalanceOf: AssetsContractController['getERC1155BalanceOf'];\n\n  private readonly getERC1155TokenURI: AssetsContractController['getERC1155TokenURI'];\n\n  private readonly onNftAdded?: (data: {\n    address: string;\n    symbol: string | undefined;\n    tokenId: string;\n    standard: string | null;\n    source: Source;\n  }) => void;\n\n  /**\n   * Creates an NftController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param options.getERC721AssetName - Gets the name of the asset at the given address.\n   * @param options.getERC721AssetSymbol - Gets the symbol of the asset at the given address.\n   * @param options.getERC721TokenURI - Gets the URI of the ERC721 token at the given address, with the given ID.\n   * @param options.getERC721OwnerOf - Get the owner of a ERC-721 NFT.\n   * @param options.getERC1155BalanceOf - Gets balance of a ERC-1155 NFT.\n   * @param options.getERC1155TokenURI - Gets the URI of the ERC1155 token at the given address, with the given ID.\n   * @param options.onNftAdded - Callback that is called when an NFT is added. Currently used pass data\n   * for tracking the NFT added event.\n   * @param options.messenger - The controller messenger.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      chainId: initialChainId,\n      onPreferencesStateChange,\n      onNetworkStateChange,\n      getERC721AssetName,\n      getERC721AssetSymbol,\n      getERC721TokenURI,\n      getERC721OwnerOf,\n      getERC1155BalanceOf,\n      getERC1155TokenURI,\n      onNftAdded,\n      messenger,\n    }: {\n      chainId: Hex;\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      getERC721AssetName: AssetsContractController['getERC721AssetName'];\n      getERC721AssetSymbol: AssetsContractController['getERC721AssetSymbol'];\n      getERC721TokenURI: AssetsContractController['getERC721TokenURI'];\n      getERC721OwnerOf: AssetsContractController['getERC721OwnerOf'];\n      getERC1155BalanceOf: AssetsContractController['getERC1155BalanceOf'];\n      getERC1155TokenURI: AssetsContractController['getERC1155TokenURI'];\n      onNftAdded?: (data: {\n        address: string;\n        symbol: string | undefined;\n        tokenId: string;\n        standard: string | null;\n        source: string;\n      }) => void;\n      messenger: NftControllerMessenger;\n    },\n    config?: Partial<BaseConfig>,\n    state?: Partial<NftState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      selectedAddress: '',\n      chainId: initialChainId,\n      ipfsGateway: IPFS_DEFAULT_GATEWAY_URL,\n      openSeaEnabled: false,\n      useIPFSSubdomains: true,\n      isIpfsGatewayEnabled: true,\n    };\n\n    this.defaultState = {\n      allNftContracts: {},\n      allNfts: {},\n      ignoredNfts: [],\n    };\n    this.initialize();\n    this.getERC721AssetName = getERC721AssetName;\n    this.getERC721AssetSymbol = getERC721AssetSymbol;\n    this.getERC721TokenURI = getERC721TokenURI;\n    this.getERC721OwnerOf = getERC721OwnerOf;\n    this.getERC1155BalanceOf = getERC1155BalanceOf;\n    this.getERC1155TokenURI = getERC1155TokenURI;\n    this.onNftAdded = onNftAdded;\n    this.messagingSystem = messenger;\n\n    onPreferencesStateChange(\n      ({\n        selectedAddress,\n        ipfsGateway,\n        openSeaEnabled,\n        isIpfsGatewayEnabled,\n      }) => {\n        this.configure({\n          selectedAddress,\n          ipfsGateway,\n          openSeaEnabled,\n          isIpfsGatewayEnabled,\n        });\n      },\n    );\n\n    onNetworkStateChange(({ providerConfig }) => {\n      const { chainId } = providerConfig;\n      this.configure({ chainId });\n    });\n  }\n\n  async validateWatchNft(\n    asset: NftAsset,\n    type: NFTStandardType,\n    accountAddress: string,\n  ) {\n    const { address: contractAddress, tokenId } = asset;\n\n    // Validate parameters\n    if (!type) {\n      throw rpcErrors.invalidParams('Asset type is required');\n    }\n\n    if (type !== ERC721 && type !== ERC1155) {\n      throw rpcErrors.invalidParams(\n        `Non NFT asset type ${type} not supported by watchNft`,\n      );\n    }\n\n    if (!contractAddress || !tokenId) {\n      throw rpcErrors.invalidParams('Both address and tokenId are required');\n    }\n\n    if (!isAddress(contractAddress)) {\n      throw rpcErrors.invalidParams('Invalid address');\n    }\n\n    if (!/^\\d+$/u.test(tokenId)) {\n      throw rpcErrors.invalidParams('Invalid tokenId');\n    }\n\n    // Check if the user owns the suggested NFT\n    try {\n      const isOwner = await this.isNftOwner(\n        accountAddress,\n        contractAddress,\n        tokenId,\n      );\n      if (!isOwner) {\n        throw rpcErrors.invalidInput(\n          'Suggested NFT is not owned by the selected account',\n        );\n      }\n    } catch (error: any) {\n      // error thrown here: \"Unable to verify ownership. Possibly because the standard is not supported or the user's currently selected network does not match the chain of the asset in question.\"\n      throw rpcErrors.resourceUnavailable(error.message);\n    }\n  }\n\n  /**\n   * Adds a new suggestedAsset to state. Parameters will be validated according to\n   * asset type being watched. A `<suggestedNftMeta.id>:pending` hub event will be emitted once added.\n   *\n   * @param asset - The asset to be watched. For now ERC721 and ERC1155 tokens are accepted.\n   * @param asset.address - The address of the asset contract.\n   * @param asset.tokenId - The ID of the asset.\n   * @param type - The asset type.\n   * @param origin - Domain origin to register the asset from.\n   * @returns Object containing a Promise resolving to the suggestedAsset address if accepted.\n   */\n  async watchNft(asset: NftAsset, type: NFTStandardType, origin: string) {\n    const { selectedAddress, chainId } = this.config;\n\n    await this.validateWatchNft(asset, type, selectedAddress);\n\n    const nftMetadata = await this.getNftInformation(\n      asset.address,\n      asset.tokenId,\n    );\n\n    if (nftMetadata.standard && nftMetadata.standard !== type) {\n      throw rpcErrors.invalidInput(\n        `Suggested NFT of type ${nftMetadata.standard} does not match received type ${type}`,\n      );\n    }\n\n    const suggestedNftMeta: SuggestedNftMeta = {\n      asset: { ...asset, ...nftMetadata },\n      type,\n      id: random(),\n      time: Date.now(),\n      interactingAddress: selectedAddress,\n      origin,\n    };\n    await this._requestApproval(suggestedNftMeta);\n    const { address, tokenId } = asset;\n    const { name, standard, description, image } = nftMetadata;\n\n    await this.addNft(\n      address,\n      tokenId,\n      {\n        name: name ?? null,\n        description: description ?? null,\n        image: image ?? null,\n        standard: standard ?? null,\n      },\n      {\n        chainId,\n        userAddress: selectedAddress,\n      },\n      Source.Dapp,\n    );\n  }\n\n  /**\n   * Sets an OpenSea API key to retrieve NFT information.\n   *\n   * @param openSeaApiKey - OpenSea API key.\n   */\n  setApiKey(openSeaApiKey: string) {\n    this.openSeaApiKey = openSeaApiKey;\n  }\n\n  /**\n   * Checks the ownership of a ERC-721 or ERC-1155 NFT for a given address.\n   *\n   * @param ownerAddress - User public address.\n   * @param nftAddress - NFT contract address.\n   * @param nftId - NFT token ID.\n   * @returns Promise resolving the NFT ownership.\n   */\n  async isNftOwner(\n    ownerAddress: string,\n    nftAddress: string,\n    nftId: string,\n  ): Promise<boolean> {\n    // Checks the ownership for ERC-721.\n    try {\n      const owner = await this.getERC721OwnerOf(nftAddress, nftId);\n      return ownerAddress.toLowerCase() === owner.toLowerCase();\n      // eslint-disable-next-line no-empty\n    } catch {\n      // Ignore ERC-721 contract error\n    }\n\n    // Checks the ownership for ERC-1155.\n    try {\n      const balance = await this.getERC1155BalanceOf(\n        ownerAddress,\n        nftAddress,\n        nftId,\n      );\n      return !balance.isZero();\n      // eslint-disable-next-line no-empty\n    } catch {\n      // Ignore ERC-1155 contract error\n    }\n\n    throw new Error(\n      `Unable to verify ownership. Possibly because the standard is not supported or the user's currently selected network does not match the chain of the asset in question.`,\n    );\n  }\n\n  /**\n   * Verifies currently selected address owns entered NFT address/tokenId combo and\n   * adds the NFT and respective NFT contract to the stored NFT and NFT contracts lists.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   */\n  async addNftVerifyOwnership(address: string, tokenId: string) {\n    const { selectedAddress } = this.config;\n    if (!(await this.isNftOwner(selectedAddress, address, tokenId))) {\n      throw new Error('This NFT is not owned by the user');\n    }\n    await this.addNft(address, tokenId);\n  }\n\n  /**\n   * Adds an NFT and respective NFT contract to the stored NFT and NFT contracts lists.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param nftMetadata - NFT optional metadata.\n   * @param accountParams - The chain ID and address of network and account to which the nftContract should be added.\n   * @param source - Whether the NFT was detected, added manually or suggested by a dapp.\n   * @returns Promise resolving to the current NFT list.\n   */\n  async addNft(\n    address: string,\n    tokenId: string,\n    nftMetadata?: NftMetadata,\n    accountParams?: AccountParams,\n    source = Source.Custom,\n  ) {\n    address = toChecksumHexAddress(address);\n    const newNftContracts = await this.addNftContract(\n      address,\n      accountParams,\n      source,\n    );\n    nftMetadata =\n      nftMetadata || (await this.getNftInformation(address, tokenId));\n\n    // If NFT contract was not added, do not add individual NFT\n    const nftContract = newNftContracts.find(\n      (contract) => contract.address.toLowerCase() === address.toLowerCase(),\n    );\n\n    // If NFT contract information, add individual NFT\n    if (nftContract) {\n      await this.addIndividualNft(\n        address,\n        tokenId,\n        nftMetadata,\n        nftContract,\n        accountParams,\n        source,\n      );\n    }\n  }\n\n  /**\n   * Removes an NFT from the stored token list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   */\n  removeNft(address: string, tokenId: string) {\n    address = toChecksumHexAddress(address);\n    this.removeIndividualNft(address, tokenId);\n    const { allNfts } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const remainingNft = nfts.find(\n      (nft) => nft.address.toLowerCase() === address.toLowerCase(),\n    );\n    if (!remainingNft) {\n      this.removeNftContract(address);\n    }\n  }\n\n  /**\n   * Removes an NFT from the stored token list and saves it in ignored NFTs list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   */\n  removeAndIgnoreNft(address: string, tokenId: string) {\n    address = toChecksumHexAddress(address);\n    this.removeAndIgnoreIndividualNft(address, tokenId);\n    const { allNfts } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const remainingNft = nfts.find(\n      (nft) => nft.address.toLowerCase() === address.toLowerCase(),\n    );\n    if (!remainingNft) {\n      this.removeNftContract(address);\n    }\n  }\n\n  /**\n   * Removes all NFTs from the ignored list.\n   */\n  clearIgnoredNfts() {\n    this.update({ ignoredNfts: [] });\n  }\n\n  /**\n   * Checks whether input NFT is still owned by the user\n   * And updates the isCurrentlyOwned value on the NFT object accordingly.\n   *\n   * @param nft - The NFT object to check and update.\n   * @param batch - A boolean indicating whether this method is being called as part of a batch or single update.\n   * @param accountParams - The userAddress and chainId to check ownership against\n   * @param accountParams.userAddress - the address passed through the confirmed transaction flow to ensure assets are stored to the correct account\n   * @param accountParams.chainId - the chainId passed through the confirmed transaction flow to ensure assets are stored to the correct account\n   * @returns the NFT with the updated isCurrentlyOwned value\n   */\n  async checkAndUpdateSingleNftOwnershipStatus(\n    nft: Nft,\n    batch: boolean,\n    { userAddress, chainId } = {\n      userAddress: this.config.selectedAddress,\n      chainId: this.config.chainId,\n    },\n  ) {\n    const { address, tokenId } = nft;\n    let isOwned = nft.isCurrentlyOwned;\n    try {\n      isOwned = await this.isNftOwner(userAddress, address, tokenId);\n    } catch (error) {\n      if (\n        !(\n          error instanceof Error &&\n          error.message.includes('Unable to verify ownership')\n        )\n      ) {\n        throw error;\n      }\n    }\n\n    nft.isCurrentlyOwned = isOwned;\n\n    if (batch) {\n      return nft;\n    }\n\n    // if this is not part of a batched update we update this one NFT in state\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const nftToUpdate = nfts.find(\n      (item) =>\n        item.tokenId === tokenId &&\n        item.address.toLowerCase() === address.toLowerCase(),\n    );\n    if (nftToUpdate) {\n      nftToUpdate.isCurrentlyOwned = isOwned;\n      this.updateNestedNftState(nfts, ALL_NFTS_STATE_KEY, {\n        userAddress,\n        chainId,\n      });\n    }\n    return nft;\n  }\n\n  /**\n   * Checks whether NFTs associated with current selectedAddress/chainId combination are still owned by the user\n   * And updates the isCurrentlyOwned value on each accordingly.\n   */\n  async checkAndUpdateAllNftsOwnershipStatus() {\n    const { allNfts } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const updatedNfts = await Promise.all(\n      nfts.map(async (nft) => {\n        return (\n          (await this.checkAndUpdateSingleNftOwnershipStatus(nft, true)) ?? nft\n        );\n      }),\n    );\n\n    this.updateNestedNftState(updatedNfts, ALL_NFTS_STATE_KEY);\n  }\n\n  /**\n   * Update NFT favorite status.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Hex address of the NFT contract.\n   * @param favorite - NFT new favorite status.\n   */\n  updateNftFavoriteStatus(address: string, tokenId: string, favorite: boolean) {\n    const { allNfts } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const index: number = nfts.findIndex(\n      (nft) => nft.address === address && nft.tokenId === tokenId,\n    );\n\n    if (index === -1) {\n      return;\n    }\n\n    const updatedNft: Nft = {\n      ...nfts[index],\n      favorite,\n    };\n\n    // Update Nfts array\n    nfts[index] = updatedNft;\n\n    this.updateNestedNftState(nfts, ALL_NFTS_STATE_KEY);\n  }\n\n  /**\n   * Returns an NFT by the address and token id.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Number that represents the id of the token.\n   * @param selectedAddress - Hex address of the user account.\n   * @param chainId - Id of the current network.\n   * @returns Object containing the NFT and its position in the array\n   */\n  findNftByAddressAndTokenId(\n    address: string,\n    tokenId: string,\n    selectedAddress: string,\n    chainId: Hex,\n  ): { nft: Nft; index: number } | null {\n    const { allNfts } = this.state;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const index: number = nfts.findIndex(\n      (nft) =>\n        nft.address.toLowerCase() === address.toLowerCase() &&\n        nft.tokenId === tokenId,\n    );\n\n    if (index === -1) {\n      return null;\n    }\n\n    return { nft: nfts[index], index };\n  }\n\n  /**\n   * Update NFT data.\n   *\n   * @param nft - NFT object to find the right NFT to updates.\n   * @param updates - NFT partial object to update properties of the NFT.\n   * @param selectedAddress - Hex address of the user account.\n   * @param chainId - Id of the current network.\n   */\n  updateNft(\n    nft: Nft,\n    updates: Partial<Nft>,\n    selectedAddress: string,\n    chainId: Hex,\n  ) {\n    const { allNfts } = this.state;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const nftInfo = this.findNftByAddressAndTokenId(\n      nft.address,\n      nft.tokenId,\n      selectedAddress,\n      chainId,\n    );\n\n    if (!nftInfo) {\n      return;\n    }\n\n    const updatedNft: Nft = {\n      ...nft,\n      ...updates,\n    };\n\n    const newNfts = [\n      ...nfts.slice(0, nftInfo.index),\n      updatedNft,\n      ...nfts.slice(nftInfo.index + 1),\n    ];\n\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY);\n  }\n\n  /**\n   * Resets the transaction status of an NFT.\n   *\n   * @param transactionId - NFT transaction id.\n   * @param selectedAddress - Hex address of the user account.\n   * @param chainId - Id of the current network.\n   * @returns a boolean indicating if the reset was well succeded or not\n   */\n  resetNftTransactionStatusByTransactionId(\n    transactionId: string,\n    selectedAddress: string,\n    chainId: Hex,\n  ): boolean {\n    const { allNfts } = this.state;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const index: number = nfts.findIndex(\n      (nft) => nft.transactionId === transactionId,\n    );\n\n    if (index === -1) {\n      return false;\n    }\n    const updatedNft: Nft = {\n      ...nfts[index],\n      transactionId: undefined,\n    };\n\n    const newNfts = [\n      ...nfts.slice(0, index),\n      updatedNft,\n      ...nfts.slice(index + 1),\n    ];\n\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY);\n    return true;\n  }\n\n  async _requestApproval(suggestedNftMeta: SuggestedNftMeta) {\n    return this.messagingSystem.call(\n      'ApprovalController:addRequest',\n      {\n        id: suggestedNftMeta.id,\n        origin: suggestedNftMeta.origin,\n        type: ApprovalType.WatchAsset,\n        requestData: {\n          id: suggestedNftMeta.id,\n          interactingAddress: suggestedNftMeta.interactingAddress,\n          asset: {\n            address: suggestedNftMeta.asset.address,\n            tokenId: suggestedNftMeta.asset.tokenId,\n            name: suggestedNftMeta.asset.name,\n            description: suggestedNftMeta.asset.description,\n            image: suggestedNftMeta.asset.image,\n            standard: suggestedNftMeta.asset.standard,\n          },\n        },\n      },\n      true,\n    );\n  }\n}\n\nexport default NftController;\n"]}
\ No newline at end of file
+{"version":3,"file":"NftController.js","sourceRoot":"","sources":["../src/NftController.ts"],"names":[],"mappings":"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","sourcesContent":["import { isAddress } from '@ethersproject/address';\nimport type { AddApprovalRequest } from '@metamask/approval-controller';\nimport type {\n  BaseConfig,\n  BaseState,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport {\n  safelyExecute,\n  handleFetch,\n  toChecksumHexAddress,\n  BNToHex,\n  fetchWithErrorHandling,\n  IPFS_DEFAULT_GATEWAY_URL,\n  ERC721,\n  ERC1155,\n  ApprovalType,\n  NFT_API_BASE_URL,\n} from '@metamask/controller-utils';\nimport type {\n  NetworkClientId,\n  NetworkController,\n  NetworkState,\n} from '@metamask/network-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type { Hex } from '@metamask/utils';\nimport { remove0x } from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\nimport BN from 'bn.js';\nimport { EventEmitter } from 'events';\nimport { v4 as random } from 'uuid';\n\nimport type { AssetsContractController } from './AssetsContractController';\nimport { compareNftMetadata, getFormattedIpfsUrl } from './assetsUtil';\nimport { Source } from './constants';\nimport type {\n  ApiNftContract,\n  ReservoirResponse,\n  Collection,\n  Attributes,\n  LastSale,\n} from './NftDetectionController';\n\ntype NFTStandardType = 'ERC721' | 'ERC1155';\n\ntype SuggestedNftMeta = {\n  asset: { address: string; tokenId: string } & NftMetadata;\n  id: string;\n  time: number;\n  type: NFTStandardType;\n  interactingAddress: string;\n  origin: string;\n};\n\n/**\n * @type Nft\n *\n * NFT representation\n * @property address - Hex address of a ERC721 contract\n * @property description - The NFT description\n * @property image - URI of custom NFT image associated with this tokenId\n * @property name - Name associated with this tokenId and contract address\n * @property tokenId - The NFT identifier\n * @property numberOfSales - Number of sales\n * @property backgroundColor - The background color to be displayed with the item\n * @property imagePreview - URI of a smaller image associated with this NFT\n * @property imageThumbnail - URI of a thumbnail image associated with this NFT\n * @property imageOriginal - URI of the original image associated with this NFT\n * @property animation - URI of a animation associated with this NFT\n * @property animationOriginal - URI of the original animation associated with this NFT\n * @property externalLink - External link containing additional information\n * @property creator - The NFT owner information object\n * @property isCurrentlyOwned - Boolean indicating whether the address/chainId combination where it's currently stored currently owns this NFT\n * @property transactionId - Transaction Id associated with the NFT\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface Nft extends NftMetadata {\n  tokenId: string;\n  address: string;\n  isCurrentlyOwned?: boolean;\n}\n\ntype NftUpdate = {\n  nft: Nft;\n  newMetadata: NftMetadata;\n};\n\n/**\n * @type NftContract\n *\n * NFT contract information representation\n * @property name - Contract name\n * @property logo - Contract logo\n * @property address - Contract address\n * @property symbol - Contract symbol\n * @property description - Contract description\n * @property totalSupply - Total supply of NFTs\n * @property assetContractType - The NFT type, it could be `semi-fungible` or `non-fungible`\n * @property createdDate - Creation date\n * @property schemaName - The schema followed by the contract, it could be `ERC721` or `ERC1155`\n * @property externalLink - External link containing additional information\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface NftContract {\n  name?: string;\n  logo?: string;\n  address: string;\n  symbol?: string;\n  description?: string;\n  totalSupply?: string;\n  assetContractType?: string;\n  createdDate?: string;\n  schemaName?: string;\n  externalLink?: string;\n}\n\n/**\n * @type NftMetadata\n *\n * NFT custom information\n * @property name - NFT custom name\n * @property description - The NFT description\n * @property numberOfSales - Number of sales\n * @property backgroundColor - The background color to be displayed with the item\n * @property image - Image custom image URI\n * @property imagePreview - URI of a smaller image associated with this NFT\n * @property imageThumbnail - URI of a thumbnail image associated with this NFT\n * @property imageOriginal - URI of the original image associated with this NFT\n * @property animation - URI of a animation associated with this NFT\n * @property animationOriginal - URI of the original animation associated with this NFT\n * @property externalLink - External link containing additional information\n * @property creator - The NFT owner information object\n * @property standard - NFT standard name for the NFT, e.g., ERC-721 or ERC-1155\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface NftMetadata {\n  name: string | null;\n  description: string | null;\n  image: string | null;\n  standard: string | null;\n  favorite?: boolean;\n  numberOfSales?: number;\n  backgroundColor?: string;\n  imagePreview?: string;\n  imageThumbnail?: string;\n  imageOriginal?: string;\n  animation?: string;\n  animationOriginal?: string;\n  externalLink?: string;\n  creator?: string;\n  transactionId?: string;\n  tokenURI?: string | null;\n  collection?: Collection;\n  address?: string;\n  attributes?: Attributes;\n  lastSale?: LastSale;\n  rarityRank?: string;\n}\n\n/**\n * @type NftConfig\n *\n * NFT controller configuration\n * @property selectedAddress - Vault selected address\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface NftConfig extends BaseConfig {\n  selectedAddress: string;\n  chainId: Hex;\n  ipfsGateway: string;\n  isIpfsGatewayEnabled: boolean;\n  displayNftMedia: boolean;\n  useIPFSSubdomains: boolean;\n}\n\n/**\n * @type NftState\n *\n * NFT controller state\n * @property allNftContracts - Object containing NFT contract information\n * @property allNfts - Object containing NFTs per account and network\n * @property ignoredNfts - List of NFTs that should be ignored\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface NftState extends BaseState {\n  allNftContracts: {\n    [key: string]: { [chainId: Hex]: NftContract[] };\n  };\n  allNfts: { [key: string]: { [chainId: Hex]: Nft[] } };\n  ignoredNfts: Nft[];\n}\n\nconst ALL_NFTS_STATE_KEY = 'allNfts';\nconst ALL_NFTS_CONTRACTS_STATE_KEY = 'allNftContracts';\n\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\ninterface NftAsset {\n  address: string;\n  tokenId: string;\n}\n\n/**\n * The name of the {@link NftController}.\n */\nconst controllerName = 'NftController';\n\n/**\n * The external actions available to the {@link NftController}.\n */\ntype AllowedActions = AddApprovalRequest;\n\n/**\n * The messenger of the {@link NftController}.\n */\nexport type NftControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  AllowedActions,\n  never,\n  AllowedActions['type'],\n  never\n>;\n\nexport const getDefaultNftState = (): NftState => {\n  return {\n    allNftContracts: {},\n    allNfts: {},\n    ignoredNfts: [],\n  };\n};\n\n/**\n * Controller that stores assets and exposes convenience methods\n */\nexport class NftController extends BaseController<NftConfig, NftState> {\n  private readonly mutex = new Mutex();\n\n  private readonly messagingSystem: NftControllerMessenger;\n\n  getNftApi() {\n    return `${NFT_API_BASE_URL}/tokens`;\n  }\n\n  /**\n   * Helper method to update nested state for allNfts and allNftContracts.\n   * \n   * @param newCollection - the modified piece of state to update in the controller's store\n   * @param baseStateKey - The root key in the store to update.\n   * @param passedConfig - An object containing the selectedAddress and chainId that are passed through the auto-detection flow.\n   * @param passedConfig.userAddress - the address passed through the NFT detection flow to ensure assets are stored to the correct account\n   * @param passedConfig.chainId - the chainId passed through the NFT detection flow to ensure assets are stored to the correct account\n   */\n  private updateNestedNftState(\n    newCollection: Nft[] | NftContract[],\n    baseStateKey: 'allNfts' | 'allNftContracts',\n    { userAddress, chainId }: { userAddress: string; chainId: Hex },\n  ) {\n    const { [baseStateKey]: oldState } = this.state;\n\n    const addressState = oldState[userAddress];\n    const newAddressState = {\n      ...addressState,\n      ...{ [chainId]: newCollection },\n    };\n    const newState = {\n      ...oldState,\n      ...{ [userAddress]: newAddressState },\n    };\n\n    this.update({\n      [baseStateKey]: newState,\n    });\n  }\n\n  /**\n   * Request individual NFT information from NFT API.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftInformationFromApi(\n    contractAddress: string,\n    tokenId: string,\n  ): Promise<NftMetadata> {\n    // TODO Parameterize this by chainId for non-mainnet token detection\n    // Attempt to fetch the data with the nft-api\n    const urlParams = new URLSearchParams({\n      chainIds: '1',\n      tokens: `${contractAddress}:${tokenId}`,\n      includeTopBid: 'true',\n      includeAttributes: 'true',\n      includeLastSale: 'true',\n    }).toString();\n    const nftInformation: ReservoirResponse | undefined =\n      await fetchWithErrorHandling({\n        url: `${this.getNftApi()}?${urlParams}`,\n        options: {\n          headers: {\n            Version: '1',\n          },\n        },\n      });\n    // if we were still unable to fetch the data we return out the default/null of `NftMetadata`\n    if (!nftInformation?.tokens?.[0]?.token) {\n      return {\n        name: null,\n        description: null,\n        image: null,\n        standard: null,\n      };\n    }\n\n    // if we've reached this point, we have successfully fetched some data for nftInformation\n    // now we reconfigure the data to conform to the `NftMetadata` type for storage.\n\n    const {\n      image,\n      metadata: { imageOriginal } = {},\n      name,\n      description,\n      collection,\n      kind,\n      rarityRank,\n      rarity,\n      attributes,\n      lastSale,\n      imageSmall,\n    } = nftInformation.tokens[0].token;\n\n    /* istanbul ignore next */\n    const nftMetadata: NftMetadata = Object.assign(\n      {},\n      { name: name || null },\n      { description: description || null },\n      { image: image || null },\n      collection?.creator && { creator: collection.creator },\n      imageOriginal && { imageOriginal },\n      imageSmall && { imageThumbnail: imageSmall },\n      kind && { standard: kind.toUpperCase() },\n      lastSale && { lastSale },\n      attributes && { attributes },\n      nftInformation.tokens[0].market?.topBid && {\n        topBid: nftInformation.tokens[0].market?.topBid,\n      },\n      rarityRank && { rarityRank },\n      rarity && { rarity },\n      collection && { collection },\n    );\n\n    return nftMetadata;\n  }\n\n  /**\n   * Request individual NFT information from contracts that follows Metadata Interface.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftInformationFromTokenURI(\n    contractAddress: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<NftMetadata> {\n    const {\n      ipfsGateway,\n      useIPFSSubdomains,\n      isIpfsGatewayEnabled,\n      displayNftMedia,\n    } = this.config;\n    const result = await this.getNftURIAndStandard(\n      contractAddress,\n      tokenId,\n      networkClientId,\n    );\n    let tokenURI = result[0];\n    const standard = result[1];\n\n    const hasIpfsTokenURI = tokenURI.startsWith('ipfs://');\n\n    if (hasIpfsTokenURI && !isIpfsGatewayEnabled) {\n      return {\n        image: null,\n        name: null,\n        description: null,\n        standard: standard || null,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    }\n    if (!hasIpfsTokenURI && !displayNftMedia) {\n      return {\n        image: null,\n        name: null,\n        description: null,\n        standard: standard || null,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    }\n\n    if (hasIpfsTokenURI) {\n      tokenURI = getFormattedIpfsUrl(ipfsGateway, tokenURI, useIPFSSubdomains);\n    }\n\n    try {\n      const object = await handleFetch(tokenURI);\n      // TODO: Check image_url existence. This is not part of EIP721 nor EIP1155\n      const image = Object.prototype.hasOwnProperty.call(object, 'image')\n        ? 'image'\n        : /* istanbul ignore next */ 'image_url';\n\n      return {\n        image: object[image],\n        name: object.name,\n        description: object.description,\n        standard,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    } catch {\n      return {\n        image: null,\n        name: null,\n        description: null,\n        standard: standard || null,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    }\n  }\n\n  /**\n   * Retrieve NFT uri with  metadata. TODO Update method to use IPFS.\n   *\n   * @param contractAddress - NFT contract address.\n   * @param tokenId - NFT token id.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving NFT uri and token standard.\n   */\n  private async getNftURIAndStandard(\n    contractAddress: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<[string, string]> {\n    // try ERC721 uri\n    try {\n      const uri = await this.getERC721TokenURI(\n        contractAddress,\n        tokenId,\n        networkClientId,\n      );\n      return [uri, ERC721];\n    } catch {\n      // Ignore error\n    }\n\n    // try ERC1155 uri\n    try {\n      const tokenURI = await this.getERC1155TokenURI(\n        contractAddress,\n        tokenId,\n        networkClientId,\n      );\n\n      /**\n       * According to EIP1155 the URI value allows for ID substitution\n       * in case the string `{id}` exists.\n       * https://eips.ethereum.org/EIPS/eip-1155#metadata\n       */\n\n      if (!tokenURI.includes('{id}')) {\n        return [tokenURI, ERC1155];\n      }\n\n      const hexTokenId = remove0x(BNToHex(new BN(tokenId)))\n        .padStart(64, '0')\n        .toLowerCase();\n      return [tokenURI.replace('{id}', hexTokenId), ERC1155];\n    } catch {\n      // Ignore error\n    }\n\n    return ['', ''];\n  }\n\n  /**\n   * Request individual NFT information (name, image url and description).\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftInformation(\n    contractAddress: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<NftMetadata> {\n    const chainId = this.getCorrectChainId({\n      networkClientId,\n    });\n    const [blockchainMetadata, nftApiMetadata] = await Promise.all([\n      safelyExecute(() =>\n        this.getNftInformationFromTokenURI(\n          contractAddress,\n          tokenId,\n          networkClientId,\n        ),\n      ),\n      this.config.displayNftMedia && chainId === '0x1'\n        ? safelyExecute(() =>\n            this.getNftInformationFromApi(contractAddress, tokenId),\n          )\n        : undefined,\n    ]);\n    return {\n      ...nftApiMetadata,\n      name: blockchainMetadata?.name ?? nftApiMetadata?.name ?? null,\n      description:\n        blockchainMetadata?.description ?? nftApiMetadata?.description ?? null,\n      image: blockchainMetadata?.image ?? nftApiMetadata?.image ?? null,\n      standard:\n        blockchainMetadata?.standard ?? nftApiMetadata?.standard ?? null,\n      tokenURI: blockchainMetadata?.tokenURI ?? null,\n    };\n  }\n\n  /**\n   * Request NFT contract information from the contract itself.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftContractInformationFromContract(\n    contractAddress: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<\n    Partial<ApiNftContract> &\n      Pick<ApiNftContract, 'address'> &\n      Pick<ApiNftContract, 'collection'>\n  > {\n    const [name, symbol] = await Promise.all([\n      this.getERC721AssetName(contractAddress, networkClientId),\n      this.getERC721AssetSymbol(contractAddress, networkClientId),\n    ]);\n\n    return {\n      collection: { name },\n      symbol,\n      address: contractAddress,\n    };\n  }\n\n  /**\n   * Request NFT contract information from Blockchain and aggregate with received data from NFTMetadata.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param nftMetadataFromApi - Received NFT information to be aggregated with blockchain contract information.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the NFT contract name, image and description.\n   */\n  private async getNftContractInformation(\n    contractAddress: string,\n    nftMetadataFromApi: NftMetadata,\n    networkClientId?: NetworkClientId,\n  ): Promise<\n    Partial<ApiNftContract> &\n      Pick<ApiNftContract, 'address'> &\n      Pick<ApiNftContract, 'collection'>\n  > {\n    const blockchainContractData = await safelyExecute(() =>\n      this.getNftContractInformationFromContract(\n        contractAddress,\n        networkClientId,\n      ),\n    );\n\n    if (\n      blockchainContractData ||\n      !Object.values(nftMetadataFromApi).every((value) => value === null)\n    ) {\n      return {\n        address: contractAddress,\n        ...blockchainContractData,\n        schema_name: nftMetadataFromApi?.standard ?? null,\n        collection: {\n          name: null,\n          image_url:\n            nftMetadataFromApi?.collection?.image ??\n            nftMetadataFromApi?.collection?.imageUrl ??\n            null,\n          tokenCount: nftMetadataFromApi?.collection?.tokenCount ?? null,\n          ...nftMetadataFromApi?.collection,\n          ...blockchainContractData?.collection,\n        },\n      };\n    }\n\n    /* istanbul ignore next */\n    return {\n      address: contractAddress,\n      asset_contract_type: null,\n      created_date: null,\n      schema_name: null,\n      symbol: null,\n      total_supply: null,\n      description: null,\n      external_link: null,\n      collection: { name: null, image_url: null },\n    };\n  }\n\n  /**\n   * Adds an individual NFT to the stored NFT list.\n   *\n   * @param tokenAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param nftMetadata - NFT optional information (name, image and description).\n   * @param nftContract - An object containing contract data of the NFT being added.\n   * @param chainId - The chainId of the network where the NFT is being added.\n   * @param userAddress - The address of the account where the NFT is being added.\n   * @param source - Whether the NFT was detected, added manually or suggested by a dapp.\n   * @returns Promise resolving to the current NFT list.\n   */\n  private async addIndividualNft(\n    tokenAddress: string,\n    tokenId: string,\n    nftMetadata: NftMetadata,\n    nftContract: NftContract,\n    chainId: Hex,\n    userAddress: string,\n    source: Source,\n  ): Promise<Nft[]> {\n    // TODO: Remove unused return\n    const releaseLock = await this.mutex.acquire();\n    try {\n      tokenAddress = toChecksumHexAddress(tokenAddress);\n      const { allNfts } = this.state;\n\n      const nfts = allNfts[userAddress]?.[chainId] || [];\n\n      const existingEntry: Nft | undefined = nfts.find(\n        (nft) =>\n          nft.address.toLowerCase() === tokenAddress.toLowerCase() &&\n          nft.tokenId === tokenId,\n      );\n\n      if (existingEntry) {\n        const differentMetadata = compareNftMetadata(\n          nftMetadata,\n          existingEntry,\n        );\n        if (differentMetadata || !existingEntry.isCurrentlyOwned) {\n          // TODO: Switch to indexToUpdate\n          const indexToRemove = nfts.findIndex(\n            (nft) =>\n              nft.address.toLowerCase() === tokenAddress.toLowerCase() &&\n              nft.tokenId === tokenId,\n          );\n          /* istanbul ignore next */\n          if (indexToRemove !== -1) {\n            nfts.splice(indexToRemove, 1);\n          }\n        } else {\n          return nfts;\n        }\n      }\n\n      const newEntry: Nft = {\n        address: tokenAddress,\n        tokenId,\n        favorite: existingEntry?.favorite || false,\n        isCurrentlyOwned: true,\n        ...nftMetadata,\n      };\n\n      const newNfts = [...nfts, newEntry];\n      this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n        chainId,\n        userAddress,\n      });\n\n      if (this.onNftAdded) {\n        this.onNftAdded({\n          address: tokenAddress,\n          symbol: nftContract.symbol,\n          tokenId: tokenId.toString(),\n          standard: nftMetadata.standard,\n          source,\n        });\n      }\n      return newNfts;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Adds an NFT contract to the stored NFT contracts list.\n   *\n   * @param options - options.\n   * @param options.tokenAddress - Hex address of the NFT contract.\n   * @param options.userAddress - The address of the account where the NFT is being added.\n   * @param options.nftMetadata - The retrieved NFTMetadata from API.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.\n   * @returns Promise resolving to the current NFT contracts list.\n   */\n  private async addNftContract({\n    tokenAddress,\n    userAddress,\n    networkClientId,\n    source,\n    nftMetadata,\n  }: {\n    tokenAddress: string;\n    userAddress: string;\n    nftMetadata: NftMetadata;\n    networkClientId?: NetworkClientId;\n    source?: Source;\n  }): Promise<NftContract[]> {\n    const releaseLock = await this.mutex.acquire();\n    try {\n      tokenAddress = toChecksumHexAddress(tokenAddress);\n      const { allNftContracts } = this.state;\n      const chainId = this.getCorrectChainId({\n        networkClientId,\n      });\n\n      const nftContracts = allNftContracts[userAddress]?.[chainId] || [];\n\n      const existingEntry = nftContracts.find(\n        (nftContract) =>\n          nftContract.address.toLowerCase() === tokenAddress.toLowerCase(),\n      );\n      if (existingEntry) {\n        return nftContracts;\n      }\n\n      // this doesn't work currently for detection if the user switches networks while the detection is processing\n      // will be fixed once detection uses networkClientIds\n      // get name and symbol if ERC721 then put together the metadata\n      const contractInformation = await this.getNftContractInformation(\n        tokenAddress,\n        nftMetadata,\n        networkClientId,\n      );\n      const {\n        asset_contract_type,\n        created_date,\n        symbol,\n        description,\n        external_link,\n        schema_name,\n        collection: { name, image_url, tokenCount },\n      } = contractInformation;\n\n      // If the nft is auto-detected we want some valid metadata to be present\n      if (\n        source === Source.Detected &&\n        'address' in contractInformation &&\n        typeof contractInformation.address === 'string' &&\n        'collection' in contractInformation &&\n        contractInformation.collection.name === null &&\n        'image_url' in contractInformation.collection &&\n        contractInformation.collection.image_url === null &&\n        Object.entries(contractInformation).every(([key, value]) => {\n          return key === 'address' || key === 'collection' || !value;\n        })\n      ) {\n        return nftContracts;\n      }\n\n      /* istanbul ignore next */\n      const newEntry: NftContract = Object.assign(\n        {},\n        { address: tokenAddress },\n        description && { description },\n        name && { name },\n        image_url && { logo: image_url },\n        symbol && { symbol },\n        tokenCount !== null &&\n          typeof tokenCount !== 'undefined' && { totalSupply: tokenCount },\n        asset_contract_type && { assetContractType: asset_contract_type },\n        created_date && { createdDate: created_date },\n        schema_name && { schemaName: schema_name },\n        external_link && { externalLink: external_link },\n      );\n      const newNftContracts = [...nftContracts, newEntry];\n      this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY, {\n        chainId,\n        userAddress,\n      });\n\n      return newNftContracts;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Removes an individual NFT from the stored token list and saves it in ignored NFTs list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   * @param options - options.\n   * @param options.chainId - The chainId of the network where the NFT is being removed.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   */\n  private removeAndIgnoreIndividualNft(\n    address: string,\n    tokenId: string,\n    {\n      chainId,\n      userAddress,\n    }: {\n      chainId: Hex;\n      userAddress: string;\n    },\n  ) {\n    address = toChecksumHexAddress(address);\n    const { allNfts, ignoredNfts } = this.state;\n    const newIgnoredNfts = [...ignoredNfts];\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const newNfts = nfts.filter((nft) => {\n      if (\n        nft.address.toLowerCase() === address.toLowerCase() &&\n        nft.tokenId === tokenId\n      ) {\n        const alreadyIgnored = newIgnoredNfts.find(\n          (c) => c.address === address && c.tokenId === tokenId,\n        );\n        !alreadyIgnored && newIgnoredNfts.push(nft);\n        return false;\n      }\n      return true;\n    });\n\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n      userAddress,\n      chainId,\n    });\n\n    this.update({\n      ignoredNfts: newIgnoredNfts,\n    });\n  }\n\n  /**\n   * Removes an individual NFT from the stored token list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   * @param options - options.\n   * @param options.chainId - The chainId of the network where the NFT is being removed.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   */\n  private removeIndividualNft(\n    address: string,\n    tokenId: string,\n    { chainId, userAddress }: { chainId: Hex; userAddress: string },\n  ) {\n    address = toChecksumHexAddress(address);\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const newNfts = nfts.filter(\n      (nft) =>\n        !(\n          nft.address.toLowerCase() === address.toLowerCase() &&\n          nft.tokenId === tokenId\n        ),\n    );\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n      userAddress,\n      chainId,\n    });\n  }\n\n  /**\n   * Removes an NFT contract to the stored NFT contracts list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param options - options.\n   * @param options.chainId - The chainId of the network where the NFT is being removed.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   * @returns Promise resolving to the current NFT contracts list.\n   */\n  private removeNftContract(\n    address: string,\n    { chainId, userAddress }: { chainId: Hex; userAddress: string },\n  ): NftContract[] {\n    address = toChecksumHexAddress(address);\n    const { allNftContracts } = this.state;\n    const nftContracts = allNftContracts[userAddress]?.[chainId] || [];\n\n    const newNftContracts = nftContracts.filter(\n      (nftContract) =>\n        !(nftContract.address.toLowerCase() === address.toLowerCase()),\n    );\n    this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY, {\n      chainId,\n      userAddress,\n    });\n\n    return newNftContracts;\n  }\n\n  /**\n   * EventEmitter instance used to listen to specific EIP747 events\n   */\n  hub = new EventEmitter();\n\n  /**\n   * Optional API key to use with opensea\n   */\n  openSeaApiKey?: string;\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'NftController';\n\n  private readonly getERC721AssetName: AssetsContractController['getERC721AssetName'];\n\n  private readonly getERC721AssetSymbol: AssetsContractController['getERC721AssetSymbol'];\n\n  private readonly getERC721TokenURI: AssetsContractController['getERC721TokenURI'];\n\n  private readonly getERC721OwnerOf: AssetsContractController['getERC721OwnerOf'];\n\n  private readonly getERC1155BalanceOf: AssetsContractController['getERC1155BalanceOf'];\n\n  private readonly getERC1155TokenURI: AssetsContractController['getERC1155TokenURI'];\n\n  private readonly getNetworkClientById: NetworkController['getNetworkClientById'];\n\n  private readonly onNftAdded?: (data: {\n    address: string;\n    symbol: string | undefined;\n    tokenId: string;\n    standard: string | null;\n    source: Source;\n  }) => void;\n\n  /**\n   * Creates an NftController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param options.getERC721AssetName - Gets the name of the asset at the given address.\n   * @param options.getERC721AssetSymbol - Gets the symbol of the asset at the given address.\n   * @param options.getERC721TokenURI - Gets the URI of the ERC721 token at the given address, with the given ID.\n   * @param options.getERC721OwnerOf - Get the owner of a ERC-721 NFT.\n   * @param options.getERC1155BalanceOf - Gets balance of a ERC-1155 NFT.\n   * @param options.getERC1155TokenURI - Gets the URI of the ERC1155 token at the given address, with the given ID.\n   * @param options.getNetworkClientById - Gets the network client for the given networkClientId.\n   * @param options.onNftAdded - Callback that is called when an NFT is added. Currently used pass data\n   * for tracking the NFT added event.\n   * @param options.messenger - The controller messenger.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      chainId: initialChainId,\n      onPreferencesStateChange,\n      onNetworkStateChange,\n      getERC721AssetName,\n      getERC721AssetSymbol,\n      getERC721TokenURI,\n      getERC721OwnerOf,\n      getERC1155BalanceOf,\n      getERC1155TokenURI,\n      getNetworkClientById,\n      onNftAdded,\n      messenger,\n    }: {\n      chainId: Hex;\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      getERC721AssetName: AssetsContractController['getERC721AssetName'];\n      getERC721AssetSymbol: AssetsContractController['getERC721AssetSymbol'];\n      getERC721TokenURI: AssetsContractController['getERC721TokenURI'];\n      getERC721OwnerOf: AssetsContractController['getERC721OwnerOf'];\n      getERC1155BalanceOf: AssetsContractController['getERC1155BalanceOf'];\n      getERC1155TokenURI: AssetsContractController['getERC1155TokenURI'];\n      getNetworkClientById: NetworkController['getNetworkClientById'];\n      onNftAdded?: (data: {\n        address: string;\n        symbol: string | undefined;\n        tokenId: string;\n        standard: string | null;\n        source: string;\n      }) => void;\n      messenger: NftControllerMessenger;\n    },\n    config?: Partial<BaseConfig>,\n    state?: Partial<NftState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      selectedAddress: '',\n      chainId: initialChainId,\n      ipfsGateway: IPFS_DEFAULT_GATEWAY_URL,\n      displayNftMedia: true,\n      useIPFSSubdomains: true,\n      isIpfsGatewayEnabled: true,\n    };\n\n    this.defaultState = getDefaultNftState();\n    this.initialize();\n    this.getERC721AssetName = getERC721AssetName;\n    this.getERC721AssetSymbol = getERC721AssetSymbol;\n    this.getERC721TokenURI = getERC721TokenURI;\n    this.getERC721OwnerOf = getERC721OwnerOf;\n    this.getERC1155BalanceOf = getERC1155BalanceOf;\n    this.getERC1155TokenURI = getERC1155TokenURI;\n    this.getNetworkClientById = getNetworkClientById;\n    this.onNftAdded = onNftAdded;\n    this.messagingSystem = messenger;\n\n    onPreferencesStateChange(\n      ({\n        selectedAddress,\n        ipfsGateway,\n        displayNftMedia,\n        isIpfsGatewayEnabled,\n      }) => {\n        this.configure({\n          selectedAddress,\n          ipfsGateway,\n          displayNftMedia,\n          isIpfsGatewayEnabled,\n        });\n      },\n    );\n\n    onNetworkStateChange(({ providerConfig }) => {\n      const { chainId } = providerConfig;\n      this.configure({ chainId });\n    });\n  }\n\n  private async validateWatchNft(\n    asset: NftAsset,\n    type: NFTStandardType,\n    userAddress: string,\n    { networkClientId }: { networkClientId?: NetworkClientId } = {},\n  ) {\n    const { address: contractAddress, tokenId } = asset;\n\n    // Validate parameters\n    if (!type) {\n      throw rpcErrors.invalidParams('Asset type is required');\n    }\n\n    if (type !== ERC721 && type !== ERC1155) {\n      throw rpcErrors.invalidParams(\n        `Non NFT asset type ${type} not supported by watchNft`,\n      );\n    }\n\n    if (!contractAddress || !tokenId) {\n      throw rpcErrors.invalidParams('Both address and tokenId are required');\n    }\n\n    if (!isAddress(contractAddress)) {\n      throw rpcErrors.invalidParams('Invalid address');\n    }\n\n    if (!/^\\d+$/u.test(tokenId)) {\n      throw rpcErrors.invalidParams('Invalid tokenId');\n    }\n\n    // Check if the user owns the suggested NFT\n    try {\n      const isOwner = await this.isNftOwner(\n        userAddress,\n        contractAddress,\n        tokenId,\n        { networkClientId },\n      );\n      if (!isOwner) {\n        throw rpcErrors.invalidInput(\n          'Suggested NFT is not owned by the selected account',\n        );\n      }\n    } catch (error) {\n      // error thrown here: \"Unable to verify ownership. Possibly because the standard is not supported or the user's currently selected network does not match the chain of the asset in question.\"\n      if (error instanceof Error) {\n        throw rpcErrors.resourceUnavailable(error.message);\n      }\n      throw error;\n    }\n  }\n\n  // temporary method to get the correct chainId until we remove chainId from the config & the chainId arg from the detection logic\n  // Just a helper method to prefer the networkClient chainId first then the chainId argument and then finally the config chainId\n  private getCorrectChainId({\n    networkClientId,\n  }: {\n    networkClientId?: NetworkClientId;\n  }) {\n    if (networkClientId) {\n      return this.getNetworkClientById(networkClientId).configuration.chainId;\n    }\n    return this.config.chainId;\n  }\n\n  /**\n   * Adds a new suggestedAsset to state. Parameters will be validated according to\n   * asset type being watched. A `<suggestedNftMeta.id>:pending` hub event will be emitted once added.\n   *\n   * @param asset - The asset to be watched. For now ERC721 and ERC1155 tokens are accepted.\n   * @param asset.address - The address of the asset contract.\n   * @param asset.tokenId - The ID of the asset.\n   * @param type - The asset type.\n   * @param origin - Domain origin to register the asset from.\n   * @param options - Options bag.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The address of the account where the NFT is being added.\n   * @returns Object containing a Promise resolving to the suggestedAsset address if accepted.\n   */\n  async watchNft(\n    asset: NftAsset,\n    type: NFTStandardType,\n    origin: string,\n    {\n      networkClientId,\n      userAddress = this.config.selectedAddress,\n    }: {\n      networkClientId?: NetworkClientId;\n      userAddress?: string;\n    } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    await this.validateWatchNft(asset, type, userAddress);\n\n    const nftMetadata = await this.getNftInformation(\n      asset.address,\n      asset.tokenId,\n      networkClientId,\n    );\n\n    if (nftMetadata.standard && nftMetadata.standard !== type) {\n      throw rpcErrors.invalidInput(\n        `Suggested NFT of type ${nftMetadata.standard} does not match received type ${type}`,\n      );\n    }\n\n    const suggestedNftMeta: SuggestedNftMeta = {\n      asset: { ...asset, ...nftMetadata },\n      type,\n      id: random(),\n      time: Date.now(),\n      interactingAddress: userAddress,\n      origin,\n    };\n    await this._requestApproval(suggestedNftMeta);\n    const { address, tokenId } = asset;\n    const { name, standard, description, image } = nftMetadata;\n\n    await this.addNft(address, tokenId, {\n      nftMetadata: {\n        name: name ?? null,\n        description: description ?? null,\n        image: image ?? null,\n        standard: standard ?? null,\n      },\n      userAddress,\n      source: Source.Dapp,\n      networkClientId,\n    });\n  }\n\n  /**\n   * Sets an OpenSea API key to retrieve NFT information.\n   *\n   * @param openSeaApiKey - OpenSea API key.\n   */\n  setApiKey(openSeaApiKey: string) {\n    this.openSeaApiKey = openSeaApiKey;\n  }\n\n  /**\n   * Checks the ownership of a ERC-721 or ERC-1155 NFT for a given address.\n   *\n   * @param ownerAddress - User public address.\n   * @param nftAddress - NFT contract address.\n   * @param tokenId - NFT token ID.\n   * @param options - Options bag.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving the NFT ownership.\n   */\n  async isNftOwner(\n    ownerAddress: string,\n    nftAddress: string,\n    tokenId: string,\n    {\n      networkClientId,\n    }: {\n      networkClientId?: NetworkClientId;\n    } = {},\n  ): Promise<boolean> {\n    // Checks the ownership for ERC-721.\n    try {\n      const owner = await this.getERC721OwnerOf(\n        nftAddress,\n        tokenId,\n        networkClientId,\n      );\n      return ownerAddress.toLowerCase() === owner.toLowerCase();\n      // eslint-disable-next-line no-empty\n    } catch {\n      // Ignore ERC-721 contract error\n    }\n\n    // Checks the ownership for ERC-1155.\n    try {\n      const balance = await this.getERC1155BalanceOf(\n        ownerAddress,\n        nftAddress,\n        tokenId,\n        networkClientId,\n      );\n      return !balance.isZero();\n      // eslint-disable-next-line no-empty\n    } catch {\n      // Ignore ERC-1155 contract error\n    }\n\n    throw new Error(\n      `Unable to verify ownership. Possibly because the standard is not supported or the user's currently selected network does not match the chain of the asset in question.`,\n    );\n  }\n\n  /**\n   * Verifies currently selected address owns entered NFT address/tokenId combo and\n   * adds the NFT and respective NFT contract to the stored NFT and NFT contracts lists.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param options - an object of arguments\n   * @param options.userAddress - The address of the current user.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.\n   */\n  async addNftVerifyOwnership(\n    address: string,\n    tokenId: string,\n    {\n      userAddress = this.config.selectedAddress,\n      networkClientId,\n      source,\n    }: {\n      userAddress?: string;\n      networkClientId?: NetworkClientId;\n      source?: Source;\n    } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    if (\n      !(await this.isNftOwner(userAddress, address, tokenId, {\n        networkClientId,\n      }))\n    ) {\n      throw new Error('This NFT is not owned by the user');\n    }\n    await this.addNft(address, tokenId, {\n      networkClientId,\n      userAddress,\n      source,\n    });\n  }\n\n  /**\n   * Adds an NFT and respective NFT contract to the stored NFT and NFT contracts lists.\n   *\n   * @param tokenAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param options - an object of arguments\n   * @param options.nftMetadata - NFT optional metadata.\n   * @param options.userAddress - The address of the current user.\n   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the current NFT list.\n   */\n  async addNft(\n    tokenAddress: string,\n    tokenId: string,\n    {\n      nftMetadata,\n      userAddress = this.config.selectedAddress,\n      source = Source.Custom,\n      networkClientId,\n    }: {\n      nftMetadata?: NftMetadata;\n      userAddress?: string;\n      source?: Source;\n      networkClientId?: NetworkClientId;\n    } = { userAddress: this.config.selectedAddress },\n  ) {\n    tokenAddress = toChecksumHexAddress(tokenAddress);\n\n    const chainId = this.getCorrectChainId({ networkClientId });\n\n    nftMetadata =\n      nftMetadata ||\n      (await this.getNftInformation(tokenAddress, tokenId, networkClientId));\n\n    const newNftContracts = await this.addNftContract({\n      tokenAddress,\n      userAddress,\n      networkClientId,\n      source,\n      nftMetadata,\n    });\n\n    // If NFT contract was not added, do not add individual NFT\n    const nftContract = newNftContracts.find(\n      (contract) =>\n        contract.address.toLowerCase() === tokenAddress.toLowerCase(),\n    );\n\n    // If NFT contract information, add individual NFT\n    if (nftContract) {\n      await this.addIndividualNft(\n        tokenAddress,\n        tokenId,\n        nftMetadata,\n        nftContract,\n        chainId,\n        userAddress,\n        source,\n      );\n    }\n  }\n\n  /**\n   * Refetches NFT metadata and updates the state\n   *\n   * @param options - Options for refetching NFT metadata\n   * @param options.nfts - Array of nfts\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The current user address\n   */\n  async updateNftMetadata({\n    nfts,\n    networkClientId,\n    userAddress = this.config.selectedAddress,\n  }: {\n    nfts: Nft[];\n    networkClientId?: NetworkClientId;\n    userAddress?: string;\n  }) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n    const nftsWithChecksumAdr = nfts.map((nft) => {\n      return {\n        ...nft,\n        address: toChecksumHexAddress(nft.address),\n      };\n    });\n    const nftMetadataResults = await Promise.allSettled(\n      nftsWithChecksumAdr.map(async (nft) => {\n        const resMetadata = await this.getNftInformation(\n          nft.address,\n          nft.tokenId,\n          networkClientId,\n        );\n        return {\n          nft,\n          newMetadata: resMetadata,\n        };\n      }),\n    );\n\n    nftMetadataResults\n      .filter(\n        (result): result is PromiseFulfilledResult<NftUpdate> =>\n          result.status === 'fulfilled',\n      )\n      .forEach((elm) =>\n        this.updateNft(\n          elm.value.nft,\n          elm.value.newMetadata,\n          userAddress,\n          chainId,\n        ),\n      );\n  }\n\n  /**\n   * Removes an NFT from the stored token list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   * @param options - an object of arguments\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   */\n  removeNft(\n    address: string,\n    tokenId: string,\n    {\n      networkClientId,\n      userAddress = this.config.selectedAddress,\n    }: { networkClientId?: NetworkClientId; userAddress?: string } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n    address = toChecksumHexAddress(address);\n    this.removeIndividualNft(address, tokenId, { chainId, userAddress });\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const remainingNft = nfts.find(\n      (nft) => nft.address.toLowerCase() === address.toLowerCase(),\n    );\n\n    if (!remainingNft) {\n      this.removeNftContract(address, { chainId, userAddress });\n    }\n  }\n\n  /**\n   * Removes an NFT from the stored token list and saves it in ignored NFTs list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   * @param options - an object of arguments\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   */\n  removeAndIgnoreNft(\n    address: string,\n    tokenId: string,\n    {\n      networkClientId,\n      userAddress = this.config.selectedAddress,\n    }: { networkClientId?: NetworkClientId; userAddress?: string } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n    address = toChecksumHexAddress(address);\n    this.removeAndIgnoreIndividualNft(address, tokenId, {\n      chainId,\n      userAddress,\n    });\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const remainingNft = nfts.find(\n      (nft) => nft.address.toLowerCase() === address.toLowerCase(),\n    );\n    if (!remainingNft) {\n      this.removeNftContract(address, { chainId, userAddress });\n    }\n  }\n\n  /**\n   * Removes all NFTs from the ignored list.\n   */\n  clearIgnoredNfts() {\n    this.update({ ignoredNfts: [] });\n  }\n\n  /**\n   * Checks whether input NFT is still owned by the user\n   * And updates the isCurrentlyOwned value on the NFT object accordingly.\n   *\n   * @param nft - The NFT object to check and update.\n   * @param batch - A boolean indicating whether this method is being called as part of a batch or single update.\n   * @param accountParams - The userAddress and chainId to check ownership against\n   * @param accountParams.userAddress - the address passed through the confirmed transaction flow to ensure assets are stored to the correct account\n   * @param accountParams.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns the NFT with the updated isCurrentlyOwned value\n   */\n  async checkAndUpdateSingleNftOwnershipStatus(\n    nft: Nft,\n    batch: boolean,\n    {\n      userAddress = this.config.selectedAddress,\n      networkClientId,\n    }: { networkClientId?: NetworkClientId; userAddress?: string } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n    const { address, tokenId } = nft;\n    let isOwned = nft.isCurrentlyOwned;\n    try {\n      isOwned = await this.isNftOwner(userAddress, address, tokenId, {\n        networkClientId,\n      });\n    } catch {\n      // ignore error\n      // this will only throw an error 'Unable to verify ownership' in which case\n      // we want to keep the current value of isCurrentlyOwned for this flow.\n    }\n\n    nft.isCurrentlyOwned = isOwned;\n\n    if (batch) {\n      return nft;\n    }\n\n    // if this is not part of a batched update we update this one NFT in state\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const nftToUpdate = nfts.find(\n      (item) =>\n        item.tokenId === tokenId &&\n        item.address.toLowerCase() === address.toLowerCase(),\n    );\n    if (nftToUpdate) {\n      nftToUpdate.isCurrentlyOwned = isOwned;\n      this.updateNestedNftState(nfts, ALL_NFTS_STATE_KEY, {\n        userAddress,\n        chainId,\n      });\n    }\n    return nft;\n  }\n\n  /**\n   * Checks whether NFTs associated with current selectedAddress/chainId combination are still owned by the user\n   * And updates the isCurrentlyOwned value on each accordingly.\n   * @param options - an object of arguments\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The address of the account where the NFT ownership status is checked/updated.\n   */\n  async checkAndUpdateAllNftsOwnershipStatus(\n    {\n      networkClientId,\n      userAddress = this.config.selectedAddress,\n    }: { networkClientId?: NetworkClientId; userAddress?: string } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const updatedNfts = await Promise.all(\n      nfts.map(async (nft) => {\n        return (\n          (await this.checkAndUpdateSingleNftOwnershipStatus(nft, true, {\n            networkClientId,\n            userAddress,\n          })) ?? nft\n        );\n      }),\n    );\n\n    this.updateNestedNftState(updatedNfts, ALL_NFTS_STATE_KEY, {\n      userAddress,\n      chainId,\n    });\n  }\n\n  /**\n   * Update NFT favorite status.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Hex address of the NFT contract.\n   * @param favorite - NFT new favorite status.\n   * @param options - an object of arguments\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   */\n  updateNftFavoriteStatus(\n    address: string,\n    tokenId: string,\n    favorite: boolean,\n    {\n      networkClientId,\n      userAddress = this.config.selectedAddress,\n    }: {\n      networkClientId?: NetworkClientId;\n      userAddress?: string;\n    } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const index: number = nfts.findIndex(\n      (nft) => nft.address === address && nft.tokenId === tokenId,\n    );\n\n    if (index === -1) {\n      return;\n    }\n\n    const updatedNft: Nft = {\n      ...nfts[index],\n      favorite,\n    };\n\n    // Update Nfts array\n    nfts[index] = updatedNft;\n\n    this.updateNestedNftState(nfts, ALL_NFTS_STATE_KEY, {\n      chainId,\n      userAddress,\n    });\n  }\n\n  /**\n   * Returns an NFT by the address and token id.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Number that represents the id of the token.\n   * @param selectedAddress - Hex address of the user account.\n   * @param chainId - Id of the current network.\n   * @returns Object containing the NFT and its position in the array\n   */\n  findNftByAddressAndTokenId(\n    address: string,\n    tokenId: string,\n    selectedAddress: string,\n    chainId: Hex,\n  ): { nft: Nft; index: number } | null {\n    const { allNfts } = this.state;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const index: number = nfts.findIndex(\n      (nft) =>\n        nft.address.toLowerCase() === address.toLowerCase() &&\n        nft.tokenId === tokenId,\n    );\n\n    if (index === -1) {\n      return null;\n    }\n\n    return { nft: nfts[index], index };\n  }\n\n  /**\n   * Update NFT data.\n   *\n   * @param nft - NFT object to find the right NFT to updates.\n   * @param updates - NFT partial object to update properties of the NFT.\n   * @param selectedAddress - Hex address of the user account.\n   * @param chainId - Id of the current network.\n   */\n  updateNft(\n    nft: Nft,\n    updates: Partial<Nft>,\n    selectedAddress: string,\n    chainId: Hex,\n  ) {\n    const { allNfts } = this.state;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const nftInfo = this.findNftByAddressAndTokenId(\n      nft.address,\n      nft.tokenId,\n      selectedAddress,\n      chainId,\n    );\n\n    if (!nftInfo) {\n      return;\n    }\n\n    const updatedNft: Nft = {\n      ...nft,\n      ...updates,\n    };\n\n    const newNfts = [\n      ...nfts.slice(0, nftInfo.index),\n      updatedNft,\n      ...nfts.slice(nftInfo.index + 1),\n    ];\n\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n      chainId,\n      userAddress: selectedAddress,\n    });\n  }\n\n  /**\n   * Resets the transaction status of an NFT.\n   *\n   * @param transactionId - NFT transaction id.\n   * @param selectedAddress - Hex address of the user account.\n   * @param chainId - Id of the current network.\n   * @returns a boolean indicating if the reset was well succeeded or not\n   */\n  resetNftTransactionStatusByTransactionId(\n    transactionId: string,\n    selectedAddress: string,\n    chainId: Hex,\n  ): boolean {\n    const { allNfts } = this.state;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const index: number = nfts.findIndex(\n      (nft) => nft.transactionId === transactionId,\n    );\n\n    if (index === -1) {\n      return false;\n    }\n    const updatedNft: Nft = {\n      ...nfts[index],\n      transactionId: undefined,\n    };\n\n    const newNfts = [\n      ...nfts.slice(0, index),\n      updatedNft,\n      ...nfts.slice(index + 1),\n    ];\n\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n      chainId,\n      userAddress: selectedAddress,\n    });\n\n    return true;\n  }\n\n  async _requestApproval(suggestedNftMeta: SuggestedNftMeta) {\n    return this.messagingSystem.call(\n      'ApprovalController:addRequest',\n      {\n        id: suggestedNftMeta.id,\n        origin: suggestedNftMeta.origin,\n        type: ApprovalType.WatchAsset,\n        requestData: {\n          id: suggestedNftMeta.id,\n          interactingAddress: suggestedNftMeta.interactingAddress,\n          asset: {\n            address: suggestedNftMeta.asset.address,\n            tokenId: suggestedNftMeta.asset.tokenId,\n            name: suggestedNftMeta.asset.name,\n            description: suggestedNftMeta.asset.description,\n            image: suggestedNftMeta.asset.image,\n            standard: suggestedNftMeta.asset.standard,\n          },\n        },\n      },\n      true,\n    );\n  }\n}\n\nexport default NftController;\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/NftController.mjs b/node_modules/@metamask/assets-controllers/dist/NftController.mjs
new file mode 100644
index 0000000..240f820
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/NftController.mjs
@@ -0,0 +1,16 @@
+import {
+  NftController,
+  NftController_default,
+  OpenSeaV2ChainIds,
+  getDefaultNftState
+} from "./chunk-WTG2VMDL.mjs";
+import "./chunk-CP3HC7AQ.mjs";
+import "./chunk-E5PIGGYR.mjs";
+import "./chunk-XUI43LEZ.mjs";
+export {
+  NftController,
+  OpenSeaV2ChainIds,
+  NftController_default as default,
+  getDefaultNftState
+};
+//# sourceMappingURL=NftController.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/NftController.mjs.map b/node_modules/@metamask/assets-controllers/dist/NftController.mjs.map
new file mode 100644
index 0000000..84c51b2
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/NftController.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":[],"sourcesContent":[],"mappings":"","names":[]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/NftDetectionController.d.ts b/node_modules/@metamask/assets-controllers/dist/NftDetectionController.d.ts
index 60b4330..2064e36 100644
--- a/node_modules/@metamask/assets-controllers/dist/NftDetectionController.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/NftDetectionController.d.ts
@@ -1,9 +1,9 @@
-import type { BaseConfig, BaseState } from '@metamask/base-controller';
-import { BaseController } from '@metamask/base-controller';
-import type { NetworkState } from '@metamask/network-controller';
-import type { PreferencesState } from '@metamask/preferences-controller';
 import type { Hex } from '@metamask/utils';
+import { BaseController, BaseConfig, BaseState } from '@metamask/base-controller';
+import type { NetworkState, NetworkClientId } from '@metamask/network-controller';
+import type { PreferencesState } from '@metamask/preferences-controller';
 import type { NftController, NftState } from './NftController';
+import { Source } from './constants';
 /**
  * @type ApiNft
  *
@@ -67,6 +67,7 @@ export interface ApiNftContract {
     collection: {
         name: string | null;
         image_url?: string | null;
+        tokenCount?: string | null;
     };
 }
 /**
@@ -114,6 +115,188 @@ export interface NftDetectionConfig extends BaseConfig {
     chainId: Hex;
     selectedAddress: string;
 }
+export declare type ReservoirResponse = {
+    tokens: TokensResponse[];
+    continuation?: string;
+};
+export declare type TokensResponse = {
+    token: TokenResponse;
+    ownership: Ownership;
+    market?: Market;
+    blockaidResult?: Blockaid;
+};
+export declare enum BlockaidResultType {
+    Benign = "Benign",
+    Spam = "Spam",
+    Warning = "Warning",
+    Malicious = "Malicious"
+}
+export declare type Blockaid = {
+    contract: string;
+    chainId: number;
+    result_type: BlockaidResultType;
+    malicious_score: string;
+    attack_types: object;
+};
+export declare type Market = {
+    floorAsk?: FloorAsk;
+    topBid?: TopBid;
+};
+export declare type TokenResponse = {
+    chainId: number;
+    contract: string;
+    tokenId: string;
+    kind?: string;
+    name?: string;
+    image?: string;
+    imageSmall?: string;
+    imageLarge?: string;
+    metadata?: Metadata;
+    description?: string;
+    supply?: number;
+    remainingSupply?: number;
+    rarityScore?: number;
+    rarity?: number;
+    rarityRank?: number;
+    media?: string;
+    isFlagged?: boolean;
+    isSpam?: boolean;
+    isNsfw?: boolean;
+    metadataDisabled?: boolean;
+    lastFlagUpdate?: string;
+    lastFlagChange?: string;
+    collection?: Collection;
+    lastSale?: LastSale;
+    topBid?: TopBid;
+    lastAppraisalValue?: number;
+    attributes?: Attributes[];
+};
+export declare type TopBid = {
+    id?: string;
+    price?: Price;
+    source?: {
+        id?: string;
+        domain?: string;
+        name?: string;
+        icon?: string;
+        url?: string;
+    };
+};
+export declare type LastSale = {
+    saleId?: string;
+    token?: {
+        contract?: string;
+        tokenId?: string;
+        name?: string;
+        image?: string;
+        collection?: {
+            id?: string;
+            name?: string;
+        };
+    };
+    orderSource?: string;
+    orderSide?: 'ask' | 'bid';
+    orderKind?: string;
+    orderId?: string;
+    from?: string;
+    to?: string;
+    amount?: string;
+    fillSource?: string;
+    block?: number;
+    txHash?: string;
+    logIndex?: number;
+    batchIndex?: number;
+    timestamp?: number;
+    price?: Price;
+    washTradingScore?: number;
+    royaltyFeeBps?: number;
+    marketplaceFeeBps?: number;
+    paidFullRoyalty?: boolean;
+    feeBreakdown?: FeeBreakdown[];
+    isDeleted?: boolean;
+    createdAt?: string;
+    updatedAt?: string;
+};
+export declare type FeeBreakdown = {
+    kind?: string;
+    bps?: number;
+    recipient?: string;
+    source?: string;
+    rawAmount?: string;
+};
+export declare type Attributes = {
+    key?: string;
+    kind?: string;
+    value: string;
+    tokenCount?: number;
+    onSaleCount?: number;
+    floorAskPrice?: Price | null;
+    topBidValue?: number | null;
+    createdAt?: string;
+};
+export declare type Collection = {
+    id?: string;
+    name?: string;
+    slug?: string;
+    symbol?: string;
+    imageUrl?: string;
+    image?: string;
+    isSpam?: boolean;
+    isNsfw?: boolean;
+    creator?: string;
+    tokenCount?: string;
+    metadataDisabled?: boolean;
+    openseaVerificationStatus?: string;
+    floorAskPrice?: Price;
+    royaltiesBps?: number;
+    royalties?: Royalties[];
+};
+export declare type Royalties = {
+    bps?: number;
+    recipient?: string;
+};
+export declare type Ownership = {
+    tokenCount?: string;
+    onSaleCount?: string;
+    floorAsk?: FloorAsk;
+    acquiredAt?: string;
+};
+export declare type FloorAsk = {
+    id?: string;
+    price?: Price;
+    maker?: string;
+    kind?: string;
+    validFrom?: number;
+    validUntil?: number;
+    source?: Source;
+    rawData?: Metadata;
+    isNativeOffChainCancellable?: boolean;
+};
+export declare type Price = {
+    currency?: {
+        contract?: string;
+        name?: string;
+        symbol?: string;
+        decimals?: number;
+        chainId?: number;
+    };
+    amount?: {
+        raw?: string;
+        decimal?: number;
+        usd?: number;
+        native?: number;
+    };
+    netAmount?: {
+        raw?: string;
+        decimal?: number;
+        usd?: number;
+        native?: number;
+    };
+};
+export declare type Metadata = {
+    imageOriginal?: string;
+    tokenURI?: string;
+};
 /**
  * Controller that passively polls on a set interval for NFT auto detection
  */
@@ -125,9 +308,10 @@ export declare class NftDetectionController extends BaseController<NftDetectionC
      * Name of this controller used during composition
      */
     name: string;
-    private readonly getOpenSeaApiKey;
-    private readonly addNft;
-    private readonly getNftState;
+    private getOpenSeaApiKey;
+    private addNft;
+    private getNftApi;
+    private getNftState;
     /**
      * Creates an NftDetectionController instance.
      *
@@ -138,17 +322,19 @@ export declare class NftDetectionController extends BaseController<NftDetectionC
      * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.
      * @param options.getOpenSeaApiKey - Gets the OpenSea API key, if one is set.
      * @param options.addNft - Add an NFT.
+     * @param options.getNftApi - Gets the URL to fetch an NFT from OpenSea.
      * @param options.getNftState - Gets the current state of the Assets controller.
      * @param config - Initial options used to configure this controller.
      * @param state - Initial state to set on this controller.
      */
-    constructor({ chainId: initialChainId, onPreferencesStateChange, onNetworkStateChange, getOpenSeaApiKey, addNft, getNftState, }: {
+    constructor({ chainId: initialChainId, onPreferencesStateChange, onNetworkStateChange, getOpenSeaApiKey, addNft, getNftApi, getNftState, }: {
         chainId: Hex;
         onNftsStateChange: (listener: (nftsState: NftState) => void) => void;
         onPreferencesStateChange: (listener: (preferencesState: PreferencesState) => void) => void;
         onNetworkStateChange: (listener: (networkState: NetworkState) => void) => void;
         getOpenSeaApiKey: () => string | undefined;
         addNft: NftController['addNft'];
+        getNftApi: NftController['getNftApi'];
         getNftState: () => NftState;
     }, config?: Partial<NftDetectionConfig>, state?: Partial<BaseState>);
     /**
@@ -175,8 +361,15 @@ export declare class NftDetectionController extends BaseController<NftDetectionC
     /**
      * Triggers asset ERC721 token auto detection on mainnet. Any newly detected NFTs are
      * added.
+     *
+     * @param options - Options bag.
+     * @param options.networkClientId - The network client ID to detect NFTs on.
+     * @param options.userAddress - The address to detect NFTs for.
      */
-    detectNfts(): Promise<void>;
+    detectNfts({ networkClientId, userAddress, }?: {
+        networkClientId?: NetworkClientId;
+        userAddress: string;
+    }): Promise<void>;
 }
 export default NftDetectionController;
 //# sourceMappingURL=NftDetectionController.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/NftDetectionController.d.ts.map b/node_modules/@metamask/assets-controllers/dist/NftDetectionController.d.ts.map
index e75c004..a25b28c 100644
--- a/node_modules/@metamask/assets-controllers/dist/NftDetectionController.d.ts.map
+++ b/node_modules/@metamask/assets-controllers/dist/NftDetectionController.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"NftDetectionController.d.ts","sourceRoot":"","sources":["../src/NftDetectionController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"NftDetectionController.d.ts","sourceRoot":"","sources":["../src/NftDetectionController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/NftDetectionController.js b/node_modules/@metamask/assets-controllers/dist/NftDetectionController.js
index f5df1af..e74e94d 100644
--- a/node_modules/@metamask/assets-controllers/dist/NftDetectionController.js
+++ b/node_modules/@metamask/assets-controllers/dist/NftDetectionController.js
@@ -9,11 +9,18 @@ var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, ge
     });
 };
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.NftDetectionController = void 0;
+exports.NftDetectionController = exports.BlockaidResultType = void 0;
 const base_controller_1 = require("@metamask/base-controller");
 const controller_utils_1 = require("@metamask/controller-utils");
 const constants_1 = require("./constants");
 const DEFAULT_INTERVAL = 180000;
+var BlockaidResultType;
+(function (BlockaidResultType) {
+    BlockaidResultType["Benign"] = "Benign";
+    BlockaidResultType["Spam"] = "Spam";
+    BlockaidResultType["Warning"] = "Warning";
+    BlockaidResultType["Malicious"] = "Malicious";
+})(BlockaidResultType = exports.BlockaidResultType || (exports.BlockaidResultType = {}));
 /**
  * Controller that passively polls on a set interval for NFT auto detection
  */
@@ -28,11 +35,12 @@ class NftDetectionController extends base_controller_1.BaseController {
      * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.
      * @param options.getOpenSeaApiKey - Gets the OpenSea API key, if one is set.
      * @param options.addNft - Add an NFT.
+     * @param options.getNftApi - Gets the URL to fetch an NFT from OpenSea.
      * @param options.getNftState - Gets the current state of the Assets controller.
      * @param config - Initial options used to configure this controller.
      * @param state - Initial state to set on this controller.
      */
-    constructor({ chainId: initialChainId, onPreferencesStateChange, onNetworkStateChange, getOpenSeaApiKey, addNft, getNftState, }, config, state) {
+    constructor({ chainId: initialChainId, onPreferencesStateChange, onNetworkStateChange, getOpenSeaApiKey, addNft, getNftApi, getNftState, }, config, state) {
         super(config, state);
         /**
          * Name of this controller used during composition
@@ -74,31 +82,38 @@ class NftDetectionController extends base_controller_1.BaseController {
         });
         this.getOpenSeaApiKey = getOpenSeaApiKey;
         this.addNft = addNft;
+        this.getNftApi = getNftApi;
     }
-    getOwnerNftApi({ address, offset, }) {
-        return `${controller_utils_1.OPENSEA_PROXY_URL}/assets?owner=${address}&offset=${offset}&limit=50`;
+    getOwnerNftApi({ address, next, }) {
+        return `${controller_utils_1.NFT_API_BASE_URL}/users/${address}/tokens?chainIds=1&limit=200&includeTopBid=true&continuation=${next !== null && next !== void 0 ? next : ''}`;
     }
     getOwnerNfts(address) {
-        var _a;
         return __awaiter(this, void 0, void 0, function* () {
             let nftApiResponse;
             let nfts = [];
-            let offset = 0;
-            let pagingFinish = false;
-            /* istanbul ignore if */
+            let next;
             do {
                 nftApiResponse = yield (0, controller_utils_1.fetchWithErrorHandling)({
-                    url: this.getOwnerNftApi({ address, offset }),
+                    url: this.getOwnerNftApi({ address, next }),
+                    options: {
+                        headers: {
+                            Version: '1',
+                        },
+                    },
                     timeout: 15000,
                 });
                 if (!nftApiResponse) {
                     return nfts;
                 }
-                ((_a = nftApiResponse === null || nftApiResponse === void 0 ? void 0 : nftApiResponse.assets) === null || _a === void 0 ? void 0 : _a.length) !== 0
-                    ? (nfts = [...nfts, ...nftApiResponse.assets])
-                    : (pagingFinish = true);
-                offset += 50;
-            } while (!pagingFinish);
+                const newNfts = nftApiResponse.tokens.filter((elm) => {
+                    var _a, _b;
+                    return elm.token.isSpam === false &&
+                        (((_a = elm.blockaidResult) === null || _a === void 0 ? void 0 : _a.result_type)
+                            ? ((_b = elm.blockaidResult) === null || _b === void 0 ? void 0 : _b.result_type) === BlockaidResultType.Benign
+                            : true);
+                });
+                nfts = [...nfts, ...newNfts];
+            } while ((next = nftApiResponse.continuation));
             return nfts;
         });
     }
@@ -142,41 +157,44 @@ class NftDetectionController extends base_controller_1.BaseController {
     /**
      * Triggers asset ERC721 token auto detection on mainnet. Any newly detected NFTs are
      * added.
+     *
+     * @param options - Options bag.
+     * @param options.networkClientId - The network client ID to detect NFTs on.
+     * @param options.userAddress - The address to detect NFTs for.
      */
-    detectNfts() {
+    detectNfts({ networkClientId, userAddress, } = { userAddress: this.config.selectedAddress }) {
         return __awaiter(this, void 0, void 0, function* () {
             /* istanbul ignore if */
             if (!this.isMainnet() || this.disabled) {
                 return;
             }
-            const { selectedAddress, chainId } = this.config;
             /* istanbul ignore else */
-            if (!selectedAddress) {
+            if (!userAddress) {
                 return;
             }
-            const apiNfts = yield this.getOwnerNfts(selectedAddress);
+            const apiNfts = yield this.getOwnerNfts(userAddress);
             const addNftPromises = apiNfts.map((nft) => __awaiter(this, void 0, void 0, function* () {
-                const { token_id, num_sales, background_color, image_url, image_preview_url, image_thumbnail_url, image_original_url, animation_url, animation_original_url, name, description, external_link, creator, asset_contract: { address, schema_name }, last_sale, } = nft;
+                const { tokenId: token_id, contract, kind, image: image_url, imageSmall: image_thumbnail_url, metadata: { imageOriginal: image_original_url } = {}, name, description, attributes, topBid, lastSale, rarityRank, rarityScore, collection, } = nft.token;
                 let ignored;
                 /* istanbul ignore else */
                 const { ignoredNfts } = this.getNftState();
                 if (ignoredNfts.length) {
                     ignored = ignoredNfts.find((c) => {
                         /* istanbul ignore next */
-                        return (c.address === (0, controller_utils_1.toChecksumHexAddress)(address) &&
+                        return (c.address === (0, controller_utils_1.toChecksumHexAddress)(contract) &&
                             c.tokenId === token_id);
                     });
                 }
                 /* istanbul ignore else */
                 if (!ignored) {
                     /* istanbul ignore next */
-                    const nftMetadata = Object.assign({}, { name }, creator && { creator }, description && { description }, image_url && { image: image_url }, num_sales && { numberOfSales: num_sales }, background_color && { backgroundColor: background_color }, image_preview_url && { imagePreview: image_preview_url }, image_thumbnail_url && { imageThumbnail: image_thumbnail_url }, image_original_url && { imageOriginal: image_original_url }, animation_url && { animation: animation_url }, animation_original_url && {
-                        animationOriginal: animation_original_url,
-                    }, schema_name && { standard: schema_name }, external_link && { externalLink: external_link }, last_sale && { lastSale: last_sale });
-                    yield this.addNft(address, token_id, nftMetadata, {
-                        userAddress: selectedAddress,
-                        chainId,
-                    }, constants_1.Source.Detected);
+                    const nftMetadata = Object.assign({}, { name }, description && { description }, image_url && { image: image_url }, image_thumbnail_url && { imageThumbnail: image_thumbnail_url }, image_original_url && { imageOriginal: image_original_url }, kind && { standard: kind.toUpperCase() }, lastSale && { lastSale }, attributes && { attributes }, topBid && { topBid }, rarityRank && { rarityRank }, rarityScore && { rarityScore }, collection && { collection });
+                    yield this.addNft(contract, token_id, {
+                        nftMetadata,
+                        userAddress,
+                        source: constants_1.Source.Detected,
+                        networkClientId,
+                    });
                 }
             }));
             yield Promise.all(addNftPromises);
diff --git a/node_modules/@metamask/assets-controllers/dist/NftDetectionController.js.map b/node_modules/@metamask/assets-controllers/dist/NftDetectionController.js.map
index c1f2598..c3de7cf 100644
--- a/node_modules/@metamask/assets-controllers/dist/NftDetectionController.js.map
+++ b/node_modules/@metamask/assets-controllers/dist/NftDetectionController.js.map
@@ -1 +1 @@
-{"version":3,"file":"NftDetectionController.js","sourceRoot":"","sources":["../src/NftDetectionController.ts"],"names":[],"mappings":"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","sourcesContent":["import type { BaseConfig, BaseState } from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport {\n  OPENSEA_PROXY_URL,\n  fetchWithErrorHandling,\n  toChecksumHexAddress,\n  ChainId,\n} from '@metamask/controller-utils';\nimport type { NetworkState } from '@metamask/network-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport type { Hex } from '@metamask/utils';\n\nimport { Source } from './constants';\nimport type { NftController, NftState, NftMetadata } from './NftController';\n\nconst DEFAULT_INTERVAL = 180000;\n\n/**\n * @type ApiNft\n *\n * NFT object coming from OpenSea api\n * @property token_id - The NFT identifier\n * @property num_sales - Number of sales\n * @property background_color - The background color to be displayed with the item\n * @property image_url - URI of an image associated with this NFT\n * @property image_preview_url - URI of a smaller image associated with this NFT\n * @property image_thumbnail_url - URI of a thumbnail image associated with this NFT\n * @property image_original_url - URI of the original image associated with this NFT\n * @property animation_url - URI of a animation associated with this NFT\n * @property animation_original_url - URI of the original animation associated with this NFT\n * @property name - The NFT name\n * @property description - The NFT description\n * @property external_link - External link containing additional information\n * @property assetContract - The NFT contract information object\n * @property creator - The NFT owner information object\n * @property lastSale - When this item was last sold\n */\nexport interface ApiNft {\n  token_id: string;\n  num_sales: number | null;\n  background_color: string | null;\n  image_url: string | null;\n  image_preview_url: string | null;\n  image_thumbnail_url: string | null;\n  image_original_url: string | null;\n  animation_url: string | null;\n  animation_original_url: string | null;\n  name: string | null;\n  description: string | null;\n  external_link: string | null;\n  asset_contract: ApiNftContract;\n  creator: ApiNftCreator;\n  last_sale: ApiNftLastSale | null;\n}\n\n/**\n * @type ApiNftContract\n *\n * NFT contract object coming from OpenSea api\n * @property address - Address of the NFT contract\n * @property asset_contract_type - The NFT type, it could be `semi-fungible` or `non-fungible`\n * @property created_date - Creation date\n * @property collection - Object containing the contract name and URI of an image associated\n * @property schema_name - The schema followed by the contract, it could be `ERC721` or `ERC1155`\n * @property symbol - The NFT contract symbol\n * @property total_supply - Total supply of NFTs\n * @property description - The NFT contract description\n * @property external_link - External link containing additional information\n */\nexport interface ApiNftContract {\n  address: string;\n  asset_contract_type: string | null;\n  created_date: string | null;\n  schema_name: string | null;\n  symbol: string | null;\n  total_supply: string | null;\n  description: string | null;\n  external_link: string | null;\n  collection: {\n    name: string | null;\n    image_url?: string | null;\n  };\n}\n\n/**\n * @type ApiNftLastSale\n *\n * NFT sale object coming from OpenSea api\n * @property event_timestamp - Object containing a `username`\n * @property total_price - URI of NFT image associated with this owner\n * @property transaction - Object containing transaction_hash and block_hash\n */\nexport interface ApiNftLastSale {\n  event_timestamp: string;\n  total_price: string;\n  transaction: { transaction_hash: string; block_hash: string };\n}\n\n/**\n * @type ApiNftCreator\n *\n * NFT creator object coming from OpenSea api\n * @property user - Object containing a `username`\n * @property profile_img_url - URI of NFT image associated with this owner\n * @property address - The owner address\n */\nexport interface ApiNftCreator {\n  user: { username: string };\n  profile_img_url: string;\n  address: string;\n}\n\n/**\n * @type NftDetectionConfig\n *\n * NftDetection configuration\n * @property interval - Polling interval used to fetch new token rates\n * @property networkType - Network type ID as per net_version\n * @property selectedAddress - Vault selected address\n * @property tokens - List of tokens associated with the active vault\n */\nexport interface NftDetectionConfig extends BaseConfig {\n  interval: number;\n  chainId: Hex;\n  selectedAddress: string;\n}\n\n/**\n * Controller that passively polls on a set interval for NFT auto detection\n */\nexport class NftDetectionController extends BaseController<\n  NftDetectionConfig,\n  BaseState\n> {\n  private intervalId?: ReturnType<typeof setTimeout>;\n\n  private getOwnerNftApi({\n    address,\n    offset,\n  }: {\n    address: string;\n    offset: number;\n  }) {\n    return `${OPENSEA_PROXY_URL}/assets?owner=${address}&offset=${offset}&limit=50`;\n  }\n\n  private async getOwnerNfts(address: string) {\n    let nftApiResponse: { assets: ApiNft[] };\n    let nfts: ApiNft[] = [];\n    let offset = 0;\n    let pagingFinish = false;\n    /* istanbul ignore if */\n    do {\n      nftApiResponse = await fetchWithErrorHandling({\n        url: this.getOwnerNftApi({ address, offset }),\n        timeout: 15000,\n      });\n\n      if (!nftApiResponse) {\n        return nfts;\n      }\n\n      nftApiResponse?.assets?.length !== 0\n        ? (nfts = [...nfts, ...nftApiResponse.assets])\n        : (pagingFinish = true);\n      offset += 50;\n    } while (!pagingFinish);\n\n    return nfts;\n  }\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'NftDetectionController';\n\n  private readonly getOpenSeaApiKey: () => string | undefined;\n\n  private readonly addNft: NftController['addNft'];\n\n  private readonly getNftState: () => NftState;\n\n  /**\n   * Creates an NftDetectionController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.onNftsStateChange - Allows subscribing to assets controller state changes.\n   * @param options.onPreferencesStateChange - Allows subscribing to preferences controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param options.getOpenSeaApiKey - Gets the OpenSea API key, if one is set.\n   * @param options.addNft - Add an NFT.\n   * @param options.getNftState - Gets the current state of the Assets controller.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      chainId: initialChainId,\n      onPreferencesStateChange,\n      onNetworkStateChange,\n      getOpenSeaApiKey,\n      addNft,\n      getNftState,\n    }: {\n      chainId: Hex;\n      onNftsStateChange: (listener: (nftsState: NftState) => void) => void;\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      getOpenSeaApiKey: () => string | undefined;\n      addNft: NftController['addNft'];\n      getNftState: () => NftState;\n    },\n    config?: Partial<NftDetectionConfig>,\n    state?: Partial<BaseState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      interval: DEFAULT_INTERVAL,\n      chainId: initialChainId,\n      selectedAddress: '',\n      disabled: true,\n    };\n    this.initialize();\n    this.getNftState = getNftState;\n    onPreferencesStateChange(({ selectedAddress, useNftDetection }) => {\n      const { selectedAddress: previouslySelectedAddress, disabled } =\n        this.config;\n\n      if (\n        selectedAddress !== previouslySelectedAddress ||\n        !useNftDetection !== disabled\n      ) {\n        this.configure({ selectedAddress, disabled: !useNftDetection });\n      }\n\n      if (useNftDetection !== undefined) {\n        if (useNftDetection) {\n          this.start();\n        } else {\n          this.stop();\n        }\n      }\n    });\n\n    onNetworkStateChange(({ providerConfig }) => {\n      this.configure({\n        chainId: providerConfig.chainId,\n      });\n    });\n    this.getOpenSeaApiKey = getOpenSeaApiKey;\n    this.addNft = addNft;\n  }\n\n  /**\n   * Start polling for the currency rate.\n   */\n  async start() {\n    if (!this.isMainnet() || this.disabled) {\n      return;\n    }\n\n    await this.startPolling();\n  }\n\n  /**\n   * Stop polling for the currency rate.\n   */\n  stop() {\n    this.stopPolling();\n  }\n\n  private stopPolling() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n  }\n\n  /**\n   * Starts a new polling interval.\n   *\n   * @param interval - An interval on which to poll.\n   */\n  private async startPolling(interval?: number): Promise<void> {\n    interval && this.configure({ interval }, false, false);\n    this.stopPolling();\n    await this.detectNfts();\n    this.intervalId = setInterval(async () => {\n      await this.detectNfts();\n    }, this.config.interval);\n  }\n\n  /**\n   * Checks whether network is mainnet or not.\n   *\n   * @returns Whether current network is mainnet.\n   */\n  isMainnet = (): boolean => this.config.chainId === ChainId.mainnet;\n\n  /**\n   * Triggers asset ERC721 token auto detection on mainnet. Any newly detected NFTs are\n   * added.\n   */\n  async detectNfts() {\n    /* istanbul ignore if */\n    if (!this.isMainnet() || this.disabled) {\n      return;\n    }\n    const { selectedAddress, chainId } = this.config;\n\n    /* istanbul ignore else */\n    if (!selectedAddress) {\n      return;\n    }\n\n    const apiNfts = await this.getOwnerNfts(selectedAddress);\n    const addNftPromises = apiNfts.map(async (nft: ApiNft) => {\n      const {\n        token_id,\n        num_sales,\n        background_color,\n        image_url,\n        image_preview_url,\n        image_thumbnail_url,\n        image_original_url,\n        animation_url,\n        animation_original_url,\n        name,\n        description,\n        external_link,\n        creator,\n        asset_contract: { address, schema_name },\n        last_sale,\n      } = nft;\n\n      let ignored;\n      /* istanbul ignore else */\n      const { ignoredNfts } = this.getNftState();\n      if (ignoredNfts.length) {\n        ignored = ignoredNfts.find((c) => {\n          /* istanbul ignore next */\n          return (\n            c.address === toChecksumHexAddress(address) &&\n            c.tokenId === token_id\n          );\n        });\n      }\n\n      /* istanbul ignore else */\n      if (!ignored) {\n        /* istanbul ignore next */\n        const nftMetadata: NftMetadata = Object.assign(\n          {},\n          { name },\n          creator && { creator },\n          description && { description },\n          image_url && { image: image_url },\n          num_sales && { numberOfSales: num_sales },\n          background_color && { backgroundColor: background_color },\n          image_preview_url && { imagePreview: image_preview_url },\n          image_thumbnail_url && { imageThumbnail: image_thumbnail_url },\n          image_original_url && { imageOriginal: image_original_url },\n          animation_url && { animation: animation_url },\n          animation_original_url && {\n            animationOriginal: animation_original_url,\n          },\n          schema_name && { standard: schema_name },\n          external_link && { externalLink: external_link },\n          last_sale && { lastSale: last_sale },\n        );\n\n        await this.addNft(\n          address,\n          token_id,\n          nftMetadata,\n          {\n            userAddress: selectedAddress,\n            chainId,\n          },\n          Source.Detected,\n        );\n      }\n    });\n    await Promise.all(addNftPromises);\n  }\n}\n\nexport default NftDetectionController;\n"]}
\ No newline at end of file
+{"version":3,"file":"NftDetectionController.js","sourceRoot":"","sources":["../src/NftDetectionController.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Hex } from '@metamask/utils';\nimport {\n  BaseController,\n  BaseConfig,\n  BaseState,\n} from '@metamask/base-controller';\nimport type {\n  NetworkState,\n  NetworkClientId,\n} from '@metamask/network-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport {\n  fetchWithErrorHandling,\n  toChecksumHexAddress,\n  ChainId,\n  NFT_API_BASE_URL,\n} from '@metamask/controller-utils';\nimport type { NftController, NftState, NftMetadata } from './NftController';\nimport { Source } from './constants';\n\nconst DEFAULT_INTERVAL = 180000;\n\n/**\n * @type ApiNft\n *\n * NFT object coming from OpenSea api\n * @property token_id - The NFT identifier\n * @property num_sales - Number of sales\n * @property background_color - The background color to be displayed with the item\n * @property image_url - URI of an image associated with this NFT\n * @property image_preview_url - URI of a smaller image associated with this NFT\n * @property image_thumbnail_url - URI of a thumbnail image associated with this NFT\n * @property image_original_url - URI of the original image associated with this NFT\n * @property animation_url - URI of a animation associated with this NFT\n * @property animation_original_url - URI of the original animation associated with this NFT\n * @property name - The NFT name\n * @property description - The NFT description\n * @property external_link - External link containing additional information\n * @property assetContract - The NFT contract information object\n * @property creator - The NFT owner information object\n * @property lastSale - When this item was last sold\n */\nexport interface ApiNft {\n  token_id: string;\n  num_sales: number | null;\n  background_color: string | null;\n  image_url: string | null;\n  image_preview_url: string | null;\n  image_thumbnail_url: string | null;\n  image_original_url: string | null;\n  animation_url: string | null;\n  animation_original_url: string | null;\n  name: string | null;\n  description: string | null;\n  external_link: string | null;\n  asset_contract: ApiNftContract;\n  creator: ApiNftCreator;\n  last_sale: ApiNftLastSale | null;\n}\n\n/**\n * @type ApiNftContract\n *\n * NFT contract object coming from OpenSea api\n * @property address - Address of the NFT contract\n * @property asset_contract_type - The NFT type, it could be `semi-fungible` or `non-fungible`\n * @property created_date - Creation date\n * @property collection - Object containing the contract name and URI of an image associated\n * @property schema_name - The schema followed by the contract, it could be `ERC721` or `ERC1155`\n * @property symbol - The NFT contract symbol\n * @property total_supply - Total supply of NFTs\n * @property description - The NFT contract description\n * @property external_link - External link containing additional information\n */\nexport interface ApiNftContract {\n  address: string;\n  asset_contract_type: string | null;\n  created_date: string | null;\n  schema_name: string | null;\n  symbol: string | null;\n  total_supply: string | null;\n  description: string | null;\n  external_link: string | null;\n  collection: {\n    name: string | null;\n    image_url?: string | null;\n    tokenCount?: string | null;\n  };\n}\n\n/**\n * @type ApiNftLastSale\n *\n * NFT sale object coming from OpenSea api\n * @property event_timestamp - Object containing a `username`\n * @property total_price - URI of NFT image associated with this owner\n * @property transaction - Object containing transaction_hash and block_hash\n */\nexport interface ApiNftLastSale {\n  event_timestamp: string;\n  total_price: string;\n  transaction: { transaction_hash: string; block_hash: string };\n}\n\n/**\n * @type ApiNftCreator\n *\n * NFT creator object coming from OpenSea api\n * @property user - Object containing a `username`\n * @property profile_img_url - URI of NFT image associated with this owner\n * @property address - The owner address\n */\nexport interface ApiNftCreator {\n  user: { username: string };\n  profile_img_url: string;\n  address: string;\n}\n\n/**\n * @type NftDetectionConfig\n *\n * NftDetection configuration\n * @property interval - Polling interval used to fetch new token rates\n * @property networkType - Network type ID as per net_version\n * @property selectedAddress - Vault selected address\n * @property tokens - List of tokens associated with the active vault\n */\nexport interface NftDetectionConfig extends BaseConfig {\n  interval: number;\n  chainId: Hex;\n  selectedAddress: string;\n}\n\nexport type ReservoirResponse = {\n  tokens: TokensResponse[];\n  continuation?: string;\n};\n\nexport type TokensResponse = {\n  token: TokenResponse;\n  ownership: Ownership;\n  market?: Market;\n  blockaidResult?: Blockaid;\n};\n\nexport enum BlockaidResultType {\n  Benign = 'Benign',\n  Spam = 'Spam',\n  Warning = 'Warning',\n  Malicious = 'Malicious',\n}\n\nexport type Blockaid = {\n  contract: string;\n  chainId: number;\n  result_type: BlockaidResultType;\n  malicious_score: string;\n  attack_types: object;\n};\n\nexport type Market = {\n  floorAsk?: FloorAsk;\n  topBid?: TopBid;\n};\n\nexport type TokenResponse = {\n  chainId: number;\n  contract: string;\n  tokenId: string;\n  kind?: string;\n  name?: string;\n  image?: string;\n  imageSmall?: string;\n  imageLarge?: string;\n  metadata?: Metadata;\n  description?: string;\n  supply?: number;\n  remainingSupply?: number;\n  rarityScore?: number;\n  rarity?: number;\n  rarityRank?: number;\n  media?: string;\n  isFlagged?: boolean;\n  isSpam?: boolean;\n  isNsfw?: boolean;\n  metadataDisabled?: boolean;\n  lastFlagUpdate?: string;\n  lastFlagChange?: string;\n  collection?: Collection;\n  lastSale?: LastSale;\n  topBid?: TopBid;\n  lastAppraisalValue?: number;\n  attributes?: Attributes[];\n};\n\nexport type TopBid = {\n  id?: string;\n  price?: Price;\n  source?: {\n    id?: string;\n    domain?: string;\n    name?: string;\n    icon?: string;\n    url?: string;\n  };\n};\n\nexport type LastSale = {\n  saleId?: string;\n  token?: {\n    contract?: string;\n    tokenId?: string;\n    name?: string;\n    image?: string;\n    collection?: {\n      id?: string;\n      name?: string;\n    };\n  };\n  orderSource?: string;\n  orderSide?: 'ask' | 'bid';\n  orderKind?: string;\n  orderId?: string;\n  from?: string;\n  to?: string;\n  amount?: string;\n  fillSource?: string;\n  block?: number;\n  txHash?: string;\n  logIndex?: number;\n  batchIndex?: number;\n  timestamp?: number;\n  price?: Price;\n  washTradingScore?: number;\n  royaltyFeeBps?: number;\n  marketplaceFeeBps?: number;\n  paidFullRoyalty?: boolean;\n  feeBreakdown?: FeeBreakdown[];\n  isDeleted?: boolean;\n  createdAt?: string;\n  updatedAt?: string;\n};\n\nexport type FeeBreakdown = {\n  kind?: string;\n  bps?: number;\n  recipient?: string;\n  source?: string;\n  rawAmount?: string;\n};\n\nexport type Attributes = {\n  key?: string;\n  kind?: string;\n  value: string;\n  tokenCount?: number;\n  onSaleCount?: number;\n  floorAskPrice?: Price | null;\n  topBidValue?: number | null;\n  createdAt?: string;\n};\n\nexport type Collection = {\n  id?: string;\n  name?: string;\n  slug?: string;\n  symbol?: string;\n  imageUrl?: string;\n  image?: string;\n  isSpam?: boolean;\n  isNsfw?: boolean;\n  creator?: string;\n  tokenCount?: string;\n  metadataDisabled?: boolean;\n  openseaVerificationStatus?: string;\n  floorAskPrice?: Price;\n  royaltiesBps?: number;\n  royalties?: Royalties[];\n};\n\nexport type Royalties = {\n  bps?: number;\n  recipient?: string;\n};\n\nexport type Ownership = {\n  tokenCount?: string;\n  onSaleCount?: string;\n  floorAsk?: FloorAsk;\n  acquiredAt?: string;\n};\n\nexport type FloorAsk = {\n  id?: string;\n  price?: Price;\n  maker?: string;\n  kind?: string;\n  validFrom?: number;\n  validUntil?: number;\n  source?: Source;\n  rawData?: Metadata;\n  isNativeOffChainCancellable?: boolean;\n};\n\nexport type Price = {\n  currency?: {\n    contract?: string;\n    name?: string;\n    symbol?: string;\n    decimals?: number;\n    chainId?: number;\n  };\n  amount?: {\n    raw?: string;\n    decimal?: number;\n    usd?: number;\n    native?: number;\n  };\n  netAmount?: {\n    raw?: string;\n    decimal?: number;\n    usd?: number;\n    native?: number;\n  };\n};\n\nexport type Metadata = {\n  imageOriginal?: string;\n  tokenURI?: string;\n};\n\n/**\n * Controller that passively polls on a set interval for NFT auto detection\n */\nexport class NftDetectionController extends BaseController<\n  NftDetectionConfig,\n  BaseState\n> {\n  private intervalId?: ReturnType<typeof setTimeout>;\n\n  private getOwnerNftApi({\n    address,\n    next,\n  }: {\n    address: string;\n    next?: string;\n  }) {\n    return `${NFT_API_BASE_URL}/users/${address}/tokens?chainIds=1&limit=200&includeTopBid=true&continuation=${\n      next ?? ''\n    }`;\n  }\n\n  private async getOwnerNfts(address: string) {\n    let nftApiResponse: ReservoirResponse;\n    let nfts: TokensResponse[] = [];\n    let next;\n\n    do {\n      nftApiResponse = await fetchWithErrorHandling({\n        url: this.getOwnerNftApi({ address, next }),\n        options: {\n          headers: {\n            Version: '1',\n          },\n        },\n        timeout: 15000,\n      });\n\n      if (!nftApiResponse) {\n        return nfts;\n      }\n\n      const newNfts = nftApiResponse.tokens.filter(\n        (elm) =>\n          elm.token.isSpam === false &&\n          (elm.blockaidResult?.result_type\n            ? elm.blockaidResult?.result_type === BlockaidResultType.Benign\n            : true),\n      );\n\n      nfts = [...nfts, ...newNfts];\n    } while ((next = nftApiResponse.continuation));\n\n    return nfts;\n  }\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'NftDetectionController';\n\n  private getOpenSeaApiKey: () => string | undefined;\n\n  private addNft: NftController['addNft'];\n\n  private getNftApi: NftController['getNftApi'];\n\n  private getNftState: () => NftState;\n\n  /**\n   * Creates an NftDetectionController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.onNftsStateChange - Allows subscribing to assets controller state changes.\n   * @param options.onPreferencesStateChange - Allows subscribing to preferences controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param options.getOpenSeaApiKey - Gets the OpenSea API key, if one is set.\n   * @param options.addNft - Add an NFT.\n   * @param options.getNftApi - Gets the URL to fetch an NFT from OpenSea.\n   * @param options.getNftState - Gets the current state of the Assets controller.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      chainId: initialChainId,\n      onPreferencesStateChange,\n      onNetworkStateChange,\n      getOpenSeaApiKey,\n      addNft,\n      getNftApi,\n      getNftState,\n    }: {\n      chainId: Hex;\n      onNftsStateChange: (listener: (nftsState: NftState) => void) => void;\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      getOpenSeaApiKey: () => string | undefined;\n      addNft: NftController['addNft'];\n      getNftApi: NftController['getNftApi'];\n      getNftState: () => NftState;\n    },\n    config?: Partial<NftDetectionConfig>,\n    state?: Partial<BaseState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      interval: DEFAULT_INTERVAL,\n      chainId: initialChainId,\n      selectedAddress: '',\n      disabled: true,\n    };\n    this.initialize();\n    this.getNftState = getNftState;\n    onPreferencesStateChange(({ selectedAddress, useNftDetection }) => {\n      const { selectedAddress: previouslySelectedAddress, disabled } =\n        this.config;\n\n      if (\n        selectedAddress !== previouslySelectedAddress ||\n        !useNftDetection !== disabled\n      ) {\n        this.configure({ selectedAddress, disabled: !useNftDetection });\n      }\n\n      if (useNftDetection !== undefined) {\n        if (useNftDetection) {\n          this.start();\n        } else {\n          this.stop();\n        }\n      }\n    });\n\n    onNetworkStateChange(({ providerConfig }) => {\n      this.configure({\n        chainId: providerConfig.chainId,\n      });\n    });\n    this.getOpenSeaApiKey = getOpenSeaApiKey;\n    this.addNft = addNft;\n    this.getNftApi = getNftApi;\n  }\n\n  /**\n   * Start polling for the currency rate.\n   */\n  async start() {\n    if (!this.isMainnet() || this.disabled) {\n      return;\n    }\n\n    await this.startPolling();\n  }\n\n  /**\n   * Stop polling for the currency rate.\n   */\n  stop() {\n    this.stopPolling();\n  }\n\n  private stopPolling() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n  }\n\n  /**\n   * Starts a new polling interval.\n   *\n   * @param interval - An interval on which to poll.\n   */\n  private async startPolling(interval?: number): Promise<void> {\n    interval && this.configure({ interval }, false, false);\n    this.stopPolling();\n    await this.detectNfts();\n    this.intervalId = setInterval(async () => {\n      await this.detectNfts();\n    }, this.config.interval);\n  }\n\n  /**\n   * Checks whether network is mainnet or not.\n   *\n   * @returns Whether current network is mainnet.\n   */\n  isMainnet = (): boolean => this.config.chainId === ChainId.mainnet;\n\n  /**\n   * Triggers asset ERC721 token auto detection on mainnet. Any newly detected NFTs are\n   * added.\n   *\n   * @param options - Options bag.\n   * @param options.networkClientId - The network client ID to detect NFTs on.\n   * @param options.userAddress - The address to detect NFTs for.\n   */\n  async detectNfts(\n    {\n      networkClientId,\n      userAddress,\n    }: {\n      networkClientId?: NetworkClientId;\n      userAddress: string;\n    } = { userAddress: this.config.selectedAddress },\n  ) {\n    /* istanbul ignore if */\n    if (!this.isMainnet() || this.disabled) {\n      return;\n    }\n    /* istanbul ignore else */\n    if (!userAddress) {\n      return;\n    }\n\n    const apiNfts = await this.getOwnerNfts(userAddress);\n    const addNftPromises = apiNfts.map(async (nft) => {\n      const {\n        tokenId: token_id,\n        contract,\n        kind,\n        image: image_url,\n        imageSmall: image_thumbnail_url,\n        metadata: { imageOriginal: image_original_url } = {},\n        name,\n        description,\n        attributes,\n        topBid,\n        lastSale,\n        rarityRank,\n        rarityScore,\n        collection,\n      } = nft.token;\n\n      let ignored;\n      /* istanbul ignore else */\n      const { ignoredNfts } = this.getNftState();\n      if (ignoredNfts.length) {\n        ignored = ignoredNfts.find((c) => {\n          /* istanbul ignore next */\n          return (\n            c.address === toChecksumHexAddress(contract) &&\n            c.tokenId === token_id\n          );\n        });\n      }\n\n      /* istanbul ignore else */\n      if (!ignored) {\n        /* istanbul ignore next */\n        const nftMetadata: NftMetadata = Object.assign(\n          {},\n          { name },\n          description && { description },\n          image_url && { image: image_url },\n          image_thumbnail_url && { imageThumbnail: image_thumbnail_url },\n          image_original_url && { imageOriginal: image_original_url },\n          kind && { standard: kind.toUpperCase() },\n          lastSale && { lastSale },\n          attributes && { attributes },\n          topBid && { topBid },\n          rarityRank && { rarityRank },\n          rarityScore && { rarityScore },\n          collection && { collection },\n        );\n\n        await this.addNft(contract, token_id, {\n          nftMetadata,\n          userAddress,\n          source: Source.Detected,\n          networkClientId,\n        });\n      }\n    });\n    await Promise.all(addNftPromises);\n  }\n}\n\nexport default NftDetectionController;\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/NftDetectionController.mjs b/node_modules/@metamask/assets-controllers/dist/NftDetectionController.mjs
new file mode 100644
index 0000000..21b3971
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/NftDetectionController.mjs
@@ -0,0 +1,13 @@
+import {
+  NftDetectionController,
+  NftDetectionController_default
+} from "./chunk-GLZ66IRX.mjs";
+import "./chunk-WTG2VMDL.mjs";
+import "./chunk-CP3HC7AQ.mjs";
+import "./chunk-E5PIGGYR.mjs";
+import "./chunk-XUI43LEZ.mjs";
+export {
+  NftDetectionController,
+  NftDetectionController_default as default
+};
+//# sourceMappingURL=NftDetectionController.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/NftDetectionController.mjs.map b/node_modules/@metamask/assets-controllers/dist/NftDetectionController.mjs.map
new file mode 100644
index 0000000..84c51b2
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/NftDetectionController.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":[],"sourcesContent":[],"mappings":"","names":[]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.d.ts b/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.d.ts
index f3983c1..0175a5a 100644
--- a/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.d.ts
@@ -1,8 +1,8 @@
 /// <reference types="bn.js" />
-import type { Web3Provider } from '@ethersproject/providers';
-import type { BN } from 'ethereumjs-util';
+import { BN } from 'ethereumjs-util';
+import { Web3Provider } from '@ethersproject/providers';
 export declare class ERC20Standard {
-    private readonly provider;
+    private provider;
     constructor(provider: Web3Provider);
     /**
      * Get balance or count for current account on specific asset contract.
diff --git a/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.d.ts.map b/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.d.ts.map
index ce6da11..863f09f 100644
--- a/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.d.ts.map
+++ b/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"ERC20Standard.d.ts","sourceRoot":"","sources":["../../src/Standards/ERC20Standard.ts"],"names":[],"mappings":";AACA,OAAO,KAAK,EAAE,YAAY,EAAE,MAAM,0BAA0B,CAAC;AAM7D,OAAO,KAAK,EAAE,EAAE,EAAE,MAAM,iBAAiB,CAAC;AAI1C,qBAAa,aAAa;IACxB,OAAO,CAAC,QAAQ,CAAC,QAAQ,CAAe;gBAE5B,QAAQ,EAAE,YAAY;IAIlC;;;;;;OAMG;IACG,YAAY,CAAC,OAAO,EAAE,MAAM,EAAE,eAAe,EAAE,MAAM,GAAG,OAAO,CAAC,EAAE,CAAC;IAMzE;;;;;OAKG;IACG,gBAAgB,CAAC,OAAO,EAAE,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;IAcxD;;;;;OAKG;IACG,YAAY,CAAC,OAAO,EAAE,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;IAcpD;;;;;OAKG;IACG,cAAc,CAAC,OAAO,EAAE,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;IA4BtD;;;;;;OAMG;IACG,UAAU,CACd,OAAO,EAAE,MAAM,EACf,WAAW,CAAC,EAAE,MAAM,GACnB,OAAO,CAAC;QACT,QAAQ,EAAE,MAAM,CAAC;QACjB,MAAM,EAAE,MAAM,GAAG,SAAS,CAAC;QAC3B,QAAQ,EAAE,MAAM,GAAG,SAAS,CAAC;QAC7B,OAAO,EAAE,EAAE,GAAG,SAAS,CAAC;KACzB,CAAC;CAgBH"}
\ No newline at end of file
+{"version":3,"file":"ERC20Standard.d.ts","sourceRoot":"","sources":["../../src/Standards/ERC20Standard.ts"],"names":[],"mappings":";AAEA,OAAO,EAAE,EAAE,EAAU,MAAM,iBAAiB,CAAC;AAG7C,OAAO,EAAE,YAAY,EAAE,MAAM,0BAA0B,CAAC;AAKxD,qBAAa,aAAa;IACxB,OAAO,CAAC,QAAQ,CAAe;gBAEnB,QAAQ,EAAE,YAAY;IAIlC;;;;;;OAMG;IACG,YAAY,CAAC,OAAO,EAAE,MAAM,EAAE,eAAe,EAAE,MAAM,GAAG,OAAO,CAAC,EAAE,CAAC;IAMzE;;;;;OAKG;IACG,gBAAgB,CAAC,OAAO,EAAE,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;IAcxD;;;;;OAKG;IACG,YAAY,CAAC,OAAO,EAAE,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;IAcpD;;;;;OAKG;IACG,cAAc,CAAC,OAAO,EAAE,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;IA6BtD;;;;;;OAMG;IACG,UAAU,CACd,OAAO,EAAE,MAAM,EACf,WAAW,CAAC,EAAE,MAAM,GACnB,OAAO,CAAC;QACT,QAAQ,EAAE,MAAM,CAAC;QACjB,MAAM,EAAE,MAAM,GAAG,SAAS,CAAC;QAC3B,QAAQ,EAAE,MAAM,GAAG,SAAS,CAAC;QAC7B,OAAO,EAAE,EAAE,GAAG,SAAS,CAAC;KACzB,CAAC;CAgBH"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.js b/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.js
index ea9c4e3..02c5f13 100644
--- a/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.js
+++ b/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.js
@@ -11,11 +11,11 @@ var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, ge
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.ERC20Standard = void 0;
 const contracts_1 = require("@ethersproject/contracts");
+const metamask_eth_abis_1 = require("@metamask/metamask-eth-abis");
+const ethereumjs_util_1 = require("ethereumjs-util");
 const abi_utils_1 = require("@metamask/abi-utils");
 const controller_utils_1 = require("@metamask/controller-utils");
-const metamask_eth_abis_1 = require("@metamask/metamask-eth-abis");
 const utils_1 = require("@metamask/utils");
-const ethereumjs_util_1 = require("ethereumjs-util");
 const assetsUtil_1 = require("../assetsUtil");
 class ERC20Standard {
     constructor(provider) {
@@ -105,7 +105,8 @@ class ERC20Standard {
             try {
                 const utf8 = (0, ethereumjs_util_1.toUtf8)(result);
                 if (utf8.length > 0) {
-                    return utf8;
+                    // This utf8 returns unicode characters, wee need to replace it
+                    return utf8.replace(/[\u0000\u0003\u0020]/g, '');
                 }
             }
             catch (_b) {
diff --git a/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.js.map b/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.js.map
index 6d91cf3..2fce3ad 100644
--- a/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.js.map
+++ b/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.js.map
@@ -1 +1 @@
-{"version":3,"file":"ERC20Standard.js","sourceRoot":"","sources":["../../src/Standards/ERC20Standard.ts"],"names":[],"mappings":"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","sourcesContent":["import { Contract } from '@ethersproject/contracts';\nimport type { Web3Provider } from '@ethersproject/providers';\nimport { decodeSingle } from '@metamask/abi-utils';\nimport { ERC20 } from '@metamask/controller-utils';\nimport { abiERC20 } from '@metamask/metamask-eth-abis';\nimport { assertIsStrictHexString } from '@metamask/utils';\nimport { toUtf8 } from 'ethereumjs-util';\nimport type { BN } from 'ethereumjs-util';\n\nimport { ethersBigNumberToBN } from '../assetsUtil';\n\nexport class ERC20Standard {\n  private readonly provider: Web3Provider;\n\n  constructor(provider: Web3Provider) {\n    this.provider = provider;\n  }\n\n  /**\n   * Get balance or count for current account on specific asset contract.\n   *\n   * @param address - Asset ERC20 contract address.\n   * @param selectedAddress - Current account public address.\n   * @returns Promise resolving to BN object containing balance for current account on specific asset contract.\n   */\n  async getBalanceOf(address: string, selectedAddress: string): Promise<BN> {\n    const contract = new Contract(address, abiERC20, this.provider);\n    const balance = await contract.balanceOf(selectedAddress);\n    return ethersBigNumberToBN(balance);\n  }\n\n  /**\n   * Query for the decimals for a given ERC20 asset.\n   *\n   * @param address - ERC20 asset contract string.\n   * @returns Promise resolving to the 'decimals'.\n   */\n  async getTokenDecimals(address: string): Promise<string> {\n    const contract = new Contract(address, abiERC20, this.provider);\n    try {\n      const decimals = await contract.decimals();\n      return decimals.toString();\n    } catch (err: any) {\n      // Mirror previous implementation\n      if (err.message.includes('call revert exception')) {\n        throw new Error('Failed to parse token decimals');\n      }\n      throw err;\n    }\n  }\n\n  /**\n   * Query for the name for a given ERC20 asset.\n   *\n   * @param address - ERC20 asset contract string.\n   * @returns Promise resolving to the 'name'.\n   */\n  async getTokenName(address: string): Promise<string> {\n    const contract = new Contract(address, abiERC20, this.provider);\n    try {\n      const name = await contract.name();\n      return name.toString();\n    } catch (err: any) {\n      // Mirror previous implementation\n      if (err.message.includes('call revert exception')) {\n        throw new Error('Failed to parse token name');\n      }\n      throw err;\n    }\n  }\n\n  /**\n   * Query for symbol for a given ERC20 asset.\n   *\n   * @param address - ERC20 asset contract address.\n   * @returns Promise resolving to the 'symbol'.\n   */\n  async getTokenSymbol(address: string): Promise<string> {\n    // Signature for calling `symbol()`\n    const payload = { to: address, data: '0x95d89b41' };\n    const result = await this.provider.call(payload);\n    assertIsStrictHexString(result);\n    // Parse as string - treat empty string as failure\n    try {\n      const decoded = decodeSingle('string', result);\n      if (decoded?.length > 0) {\n        return decoded;\n      }\n    } catch {\n      // Ignore error\n    }\n\n    // Parse as bytes - treat empty string as failure\n    try {\n      const utf8 = toUtf8(result);\n      if (utf8.length > 0) {\n        return utf8;\n      }\n    } catch {\n      // Ignore error\n    }\n\n    throw new Error('Failed to parse token symbol');\n  }\n\n  /**\n   * Query if a contract implements an interface.\n   *\n   * @param address - Asset contract address.\n   * @param userAddress - The public address for the currently active user's account.\n   * @returns Promise resolving an object containing the standard, decimals, symbol and balance of the given contract/userAddress pair.\n   */\n  async getDetails(\n    address: string,\n    userAddress?: string,\n  ): Promise<{\n    standard: string;\n    symbol: string | undefined;\n    decimals: string | undefined;\n    balance: BN | undefined;\n  }> {\n    const [decimals, symbol] = await Promise.all([\n      this.getTokenDecimals(address),\n      this.getTokenSymbol(address),\n    ]);\n    let balance;\n    if (userAddress) {\n      balance = await this.getBalanceOf(address, userAddress);\n    }\n    return {\n      decimals,\n      symbol,\n      balance,\n      standard: ERC20,\n    };\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"ERC20Standard.js","sourceRoot":"","sources":["../../src/Standards/ERC20Standard.ts"],"names":[],"mappings":"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","sourcesContent":["import { Contract } from '@ethersproject/contracts';\nimport { abiERC20 } from '@metamask/metamask-eth-abis';\nimport { BN, toUtf8 } from 'ethereumjs-util';\nimport { decodeSingle } from '@metamask/abi-utils';\n\nimport { Web3Provider } from '@ethersproject/providers';\nimport { ERC20 } from '@metamask/controller-utils';\nimport { assertIsStrictHexString } from '@metamask/utils';\nimport { ethersBigNumberToBN } from '../assetsUtil';\n\nexport class ERC20Standard {\n  private provider: Web3Provider;\n\n  constructor(provider: Web3Provider) {\n    this.provider = provider;\n  }\n\n  /**\n   * Get balance or count for current account on specific asset contract.\n   *\n   * @param address - Asset ERC20 contract address.\n   * @param selectedAddress - Current account public address.\n   * @returns Promise resolving to BN object containing balance for current account on specific asset contract.\n   */\n  async getBalanceOf(address: string, selectedAddress: string): Promise<BN> {\n    const contract = new Contract(address, abiERC20, this.provider);\n    const balance = await contract.balanceOf(selectedAddress);\n    return ethersBigNumberToBN(balance);\n  }\n\n  /**\n   * Query for the decimals for a given ERC20 asset.\n   *\n   * @param address - ERC20 asset contract string.\n   * @returns Promise resolving to the 'decimals'.\n   */\n  async getTokenDecimals(address: string): Promise<string> {\n    const contract = new Contract(address, abiERC20, this.provider);\n    try {\n      const decimals = await contract.decimals();\n      return decimals.toString();\n    } catch (err: any) {\n      // Mirror previous implementation\n      if (err.message.includes('call revert exception')) {\n        throw new Error('Failed to parse token decimals');\n      }\n      throw err;\n    }\n  }\n\n  /**\n   * Query for the name for a given ERC20 asset.\n   *\n   * @param address - ERC20 asset contract string.\n   * @returns Promise resolving to the 'name'.\n   */\n  async getTokenName(address: string): Promise<string> {\n    const contract = new Contract(address, abiERC20, this.provider);\n    try {\n      const name = await contract.name();\n      return name.toString();\n    } catch (err: any) {\n      // Mirror previous implementation\n      if (err.message.includes('call revert exception')) {\n        throw new Error('Failed to parse token name');\n      }\n      throw err;\n    }\n  }\n\n  /**\n   * Query for symbol for a given ERC20 asset.\n   *\n   * @param address - ERC20 asset contract address.\n   * @returns Promise resolving to the 'symbol'.\n   */\n  async getTokenSymbol(address: string): Promise<string> {\n    // Signature for calling `symbol()`\n    const payload = { to: address, data: '0x95d89b41' };\n    const result = await this.provider.call(payload);\n    assertIsStrictHexString(result);\n    // Parse as string - treat empty string as failure\n    try {\n      const decoded = decodeSingle('string', result);\n      if (decoded?.length > 0) {\n        return decoded;\n      }\n    } catch {\n      // Ignore error\n    }\n\n    // Parse as bytes - treat empty string as failure\n    try {\n      const utf8 = toUtf8(result);\n      if (utf8.length > 0) {\n        // This utf8 returns unicode characters, wee need to replace it\n        return utf8.replace(/[\\u0000\\u0003\\u0020]/g, '');\n      }\n    } catch {\n      // Ignore error\n    }\n\n    throw new Error('Failed to parse token symbol');\n  }\n\n  /**\n   * Query if a contract implements an interface.\n   *\n   * @param address - Asset contract address.\n   * @param userAddress - The public address for the currently active user's account.\n   * @returns Promise resolving an object containing the standard, decimals, symbol and balance of the given contract/userAddress pair.\n   */\n  async getDetails(\n    address: string,\n    userAddress?: string,\n  ): Promise<{\n    standard: string;\n    symbol: string | undefined;\n    decimals: string | undefined;\n    balance: BN | undefined;\n  }> {\n    const [decimals, symbol] = await Promise.all([\n      this.getTokenDecimals(address),\n      this.getTokenSymbol(address),\n    ]);\n    let balance;\n    if (userAddress) {\n      balance = await this.getBalanceOf(address, userAddress);\n    }\n    return {\n      decimals,\n      symbol,\n      balance,\n      standard: ERC20,\n    };\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.mjs b/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.mjs
new file mode 100644
index 0000000..31ff326
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.mjs
@@ -0,0 +1,9 @@
+import {
+  ERC20Standard
+} from "../chunk-MQ7TIWBK.mjs";
+import "../chunk-E5PIGGYR.mjs";
+import "../chunk-XUI43LEZ.mjs";
+export {
+  ERC20Standard
+};
+//# sourceMappingURL=ERC20Standard.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.mjs.map b/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.mjs.map
new file mode 100644
index 0000000..84c51b2
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/Standards/ERC20Standard.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":[],"sourcesContent":[],"mappings":"","names":[]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC1155/ERC1155Standard.d.ts b/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC1155/ERC1155Standard.d.ts
index 447aba6..255c4c9 100644
--- a/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC1155/ERC1155Standard.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC1155/ERC1155Standard.d.ts
@@ -1,7 +1,7 @@
-import type { Web3Provider } from '@ethersproject/providers';
-import type { BN } from 'ethereumjs-util';
+import { BN } from 'ethereumjs-util';
+import { Web3Provider } from '@ethersproject/providers';
 export declare class ERC1155Standard {
-    private readonly provider;
+    private provider;
     constructor(provider: Web3Provider);
     /**
      * Query if contract implements ERC1155 URI Metadata interface.
@@ -61,7 +61,7 @@ export declare class ERC1155Standard {
      * @param interfaceId - Interface identifier.
      * @returns Promise resolving to whether the contract implements `interfaceID`.
      */
-    private readonly contractSupportsInterface;
+    private contractSupportsInterface;
     /**
      * Query if a contract implements an interface.
      *
diff --git a/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC1155/ERC1155Standard.d.ts.map b/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC1155/ERC1155Standard.d.ts.map
index fe8a227..a10d3d3 100644
--- a/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC1155/ERC1155Standard.d.ts.map
+++ b/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC1155/ERC1155Standard.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"ERC1155Standard.d.ts","sourceRoot":"","sources":["../../../../src/Standards/NftStandards/ERC1155/ERC1155Standard.ts"],"names":[],"mappings":"AACA,OAAO,KAAK,EAAE,YAAY,EAAE,MAAM,0BAA0B,CAAC;AAS7D,OAAO,KAAK,EAAE,EAAE,EAAE,MAAM,iBAAiB,CAAC;AAI1C,qBAAa,eAAe;IAC1B,OAAO,CAAC,QAAQ,CAAC,QAAQ,CAAe;gBAE5B,QAAQ,EAAE,YAAY;IAIlC;;;;;OAKG;IACH,oCAAoC,YACzB,MAAM,KACd,QAAQ,OAAO,CAAC,CAKjB;IAEF;;;;;OAKG;IACH,sCAAsC,YAC3B,MAAM,KACd,QAAQ,OAAO,CAAC,CAKjB;IAEF;;;;;OAKG;IACH,iCAAiC,YACtB,MAAM,KACd,QAAQ,OAAO,CAAC,CAEjB;IAEF;;;;;;OAMG;IACH,WAAW,YAAmB,MAAM,WAAW,MAAM,KAAG,QAAQ,MAAM,CAAC,CAGrE;IAEF;;;;;;;OAOG;IACH,YAAY,oBACO,MAAM,WACd,MAAM,WACN,MAAM,KACd,QAAQ,EAAE,CAAC,CAIZ;IAEF;;;;;;;;;;;OAWG;IACH,cAAc,aACF,MAAM,QACV,MAAM,MACR,MAAM,MACN,MAAM,SACH,MAAM,KACZ,QAAQ,IAAI,CAAC,CAmBd;IAEF;;;;;;OAMG;IACH,OAAO,CAAC,QAAQ,CAAC,yBAAyB,CAMxC;IAEF;;;;;;;OAOG;IACH,UAAU,YACC,MAAM,eACF,MAAM;kBAGT,MAAM;kBACN,MAAM,GAAG,SAAS;eACrB,MAAM,GAAG,SAAS;OAiCzB;CACH"}
\ No newline at end of file
+{"version":3,"file":"ERC1155Standard.d.ts","sourceRoot":"","sources":["../../../../src/Standards/NftStandards/ERC1155/ERC1155Standard.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,EAAE,EAAE,MAAM,iBAAiB,CAAC;AACrC,OAAO,EAAE,YAAY,EAAE,MAAM,0BAA0B,CAAC;AAUxD,qBAAa,eAAe;IAC1B,OAAO,CAAC,QAAQ,CAAe;gBAEnB,QAAQ,EAAE,YAAY;IAIlC;;;;;OAKG;IACH,oCAAoC,YACzB,MAAM,KACd,QAAQ,OAAO,CAAC,CAKjB;IAEF;;;;;OAKG;IACH,sCAAsC,YAC3B,MAAM,KACd,QAAQ,OAAO,CAAC,CAKjB;IAEF;;;;;OAKG;IACH,iCAAiC,YACtB,MAAM,KACd,QAAQ,OAAO,CAAC,CAEjB;IAEF;;;;;;OAMG;IACH,WAAW,YAAmB,MAAM,WAAW,MAAM,KAAG,QAAQ,MAAM,CAAC,CAGrE;IAEF;;;;;;;OAOG;IACH,YAAY,oBACO,MAAM,WACd,MAAM,WACN,MAAM,KACd,QAAQ,EAAE,CAAC,CAIZ;IAEF;;;;;;;;;;;OAWG;IACH,cAAc,aACF,MAAM,QACV,MAAM,MACR,MAAM,MACN,MAAM,SACH,MAAM,KACZ,QAAQ,IAAI,CAAC,CAmBd;IAEF;;;;;;OAMG;IACH,OAAO,CAAC,yBAAyB,CAM/B;IAEF;;;;;;;OAOG;IACH,UAAU,YACC,MAAM,eACF,MAAM;kBAGT,MAAM;kBACN,MAAM,GAAG,SAAS;eACrB,MAAM,GAAG,SAAS;OAiCzB;CACH"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC1155/ERC1155Standard.js b/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC1155/ERC1155Standard.js
index ad7fc54..3d3fa29 100644
--- a/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC1155/ERC1155Standard.js
+++ b/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC1155/ERC1155Standard.js
@@ -10,9 +10,9 @@ var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, ge
 };
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.ERC1155Standard = void 0;
+const metamask_eth_abis_1 = require("@metamask/metamask-eth-abis");
 const contracts_1 = require("@ethersproject/contracts");
 const controller_utils_1 = require("@metamask/controller-utils");
-const metamask_eth_abis_1 = require("@metamask/metamask-eth-abis");
 const assetsUtil_1 = require("../../../assetsUtil");
 class ERC1155Standard {
     constructor(provider) {
diff --git a/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC1155/ERC1155Standard.js.map b/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC1155/ERC1155Standard.js.map
index 48cc4d5..804f8f0 100644
--- a/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC1155/ERC1155Standard.js.map
+++ b/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC1155/ERC1155Standard.js.map
@@ -1 +1 @@
-{"version":3,"file":"ERC1155Standard.js","sourceRoot":"","sources":["../../../../src/Standards/NftStandards/ERC1155/ERC1155Standard.ts"],"names":[],"mappings":"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","sourcesContent":["import { Contract } from '@ethersproject/contracts';\nimport type { Web3Provider } from '@ethersproject/providers';\nimport {\n  ERC1155,\n  ERC1155_INTERFACE_ID,\n  ERC1155_METADATA_URI_INTERFACE_ID,\n  ERC1155_TOKEN_RECEIVER_INTERFACE_ID,\n  timeoutFetch,\n} from '@metamask/controller-utils';\nimport { abiERC1155 } from '@metamask/metamask-eth-abis';\nimport type { BN } from 'ethereumjs-util';\n\nimport { getFormattedIpfsUrl, ethersBigNumberToBN } from '../../../assetsUtil';\n\nexport class ERC1155Standard {\n  private readonly provider: Web3Provider;\n\n  constructor(provider: Web3Provider) {\n    this.provider = provider;\n  }\n\n  /**\n   * Query if contract implements ERC1155 URI Metadata interface.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @returns Promise resolving to whether the contract implements ERC1155 URI Metadata interface.\n   */\n  contractSupportsURIMetadataInterface = async (\n    address: string,\n  ): Promise<boolean> => {\n    return this.contractSupportsInterface(\n      address,\n      ERC1155_METADATA_URI_INTERFACE_ID,\n    );\n  };\n\n  /**\n   * Query if contract implements ERC1155 Token Receiver interface.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @returns Promise resolving to whether the contract implements ERC1155 Token Receiver interface.\n   */\n  contractSupportsTokenReceiverInterface = async (\n    address: string,\n  ): Promise<boolean> => {\n    return this.contractSupportsInterface(\n      address,\n      ERC1155_TOKEN_RECEIVER_INTERFACE_ID,\n    );\n  };\n\n  /**\n   * Query if contract implements ERC1155 interface.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @returns Promise resolving to whether the contract implements the base ERC1155 interface.\n   */\n  contractSupportsBase1155Interface = async (\n    address: string,\n  ): Promise<boolean> => {\n    return this.contractSupportsInterface(address, ERC1155_INTERFACE_ID);\n  };\n\n  /**\n   * Query for tokenURI for a given asset.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @param tokenId - ERC1155 asset identifier.\n   * @returns Promise resolving to the 'tokenURI'.\n   */\n  getTokenURI = async (address: string, tokenId: string): Promise<string> => {\n    const contract = new Contract(address, abiERC1155, this.provider);\n    return contract.uri(tokenId);\n  };\n\n  /**\n   * Query for balance of a given ERC1155 token.\n   *\n   * @param contractAddress - ERC1155 asset contract address.\n   * @param address - Wallet public address.\n   * @param tokenId - ERC1155 asset identifier.\n   * @returns Promise resolving to the 'balanceOf'.\n   */\n  getBalanceOf = async (\n    contractAddress: string,\n    address: string,\n    tokenId: string,\n  ): Promise<BN> => {\n    const contract = new Contract(contractAddress, abiERC1155, this.provider);\n    const balance = await contract.balanceOf(address, tokenId);\n    return ethersBigNumberToBN(balance);\n  };\n\n  /**\n   * Transfer single ERC1155 token.\n   * When minting/creating tokens, the from arg MUST be set to 0x0 (i.e. zero address).\n   * When burning/destroying tokens, the to arg MUST be set to 0x0 (i.e. zero address).\n   *\n   * @param operator - ERC1155 token address.\n   * @param from - ERC1155 token holder.\n   * @param to - ERC1155 token recipient.\n   * @param id - ERC1155 token id.\n   * @param value - Number of tokens to be sent.\n   * @returns Promise resolving to the 'transferSingle'.\n   */\n  transferSingle = async (\n    operator: string,\n    from: string,\n    to: string,\n    id: string,\n    value: string,\n  ): Promise<void> => {\n    const contract = new Contract(operator, abiERC1155, this.provider);\n    return new Promise<void>((resolve, reject) => {\n      contract.transferSingle(\n        operator,\n        from,\n        to,\n        id,\n        value,\n        (error: Error, result: void) => {\n          /* istanbul ignore if */\n          if (error) {\n            reject(error);\n            return;\n          }\n          resolve(result);\n        },\n      );\n    });\n  };\n\n  /**\n   * Query if a contract implements an interface.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @param interfaceId - Interface identifier.\n   * @returns Promise resolving to whether the contract implements `interfaceID`.\n   */\n  private readonly contractSupportsInterface = async (\n    address: string,\n    interfaceId: string,\n  ): Promise<boolean> => {\n    const contract = new Contract(address, abiERC1155, this.provider);\n    return contract.supportsInterface(interfaceId);\n  };\n\n  /**\n   * Query if a contract implements an interface.\n   *\n   * @param address - Asset contract address.\n   * @param ipfsGateway - The user's preferred IPFS gateway.\n   * @param tokenId - tokenId of a given token in the contract.\n   * @returns Promise resolving an object containing the standard, tokenURI, symbol and name of the given contract/tokenId pair.\n   */\n  getDetails = async (\n    address: string,\n    ipfsGateway: string,\n    tokenId?: string,\n  ): Promise<{\n    standard: string;\n    tokenURI: string | undefined;\n    image: string | undefined;\n  }> => {\n    const isERC1155 = await this.contractSupportsBase1155Interface(address);\n\n    if (!isERC1155) {\n      throw new Error(\"This isn't a valid ERC1155 contract\");\n    }\n    let tokenURI, image;\n\n    if (tokenId) {\n      tokenURI = await this.getTokenURI(address, tokenId);\n      if (tokenURI.startsWith('ipfs://')) {\n        tokenURI = getFormattedIpfsUrl(ipfsGateway, tokenURI, true);\n      }\n\n      try {\n        const response = await timeoutFetch(tokenURI);\n        const object = await response.json();\n        image = object?.image;\n        if (image?.startsWith('ipfs://')) {\n          image = getFormattedIpfsUrl(ipfsGateway, image, true);\n        }\n      } catch {\n        // ignore\n      }\n    }\n\n    // TODO consider querying to the metadata to get name.\n    return {\n      standard: ERC1155,\n      tokenURI,\n      image,\n    };\n  };\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"ERC1155Standard.js","sourceRoot":"","sources":["../../../../src/Standards/NftStandards/ERC1155/ERC1155Standard.ts"],"names":[],"mappings":"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","sourcesContent":["import { abiERC1155 } from '@metamask/metamask-eth-abis';\nimport { Contract } from '@ethersproject/contracts';\nimport { BN } from 'ethereumjs-util';\nimport { Web3Provider } from '@ethersproject/providers';\nimport {\n  ERC1155,\n  ERC1155_INTERFACE_ID,\n  ERC1155_METADATA_URI_INTERFACE_ID,\n  ERC1155_TOKEN_RECEIVER_INTERFACE_ID,\n  timeoutFetch,\n} from '@metamask/controller-utils';\nimport { getFormattedIpfsUrl, ethersBigNumberToBN } from '../../../assetsUtil';\n\nexport class ERC1155Standard {\n  private provider: Web3Provider;\n\n  constructor(provider: Web3Provider) {\n    this.provider = provider;\n  }\n\n  /**\n   * Query if contract implements ERC1155 URI Metadata interface.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @returns Promise resolving to whether the contract implements ERC1155 URI Metadata interface.\n   */\n  contractSupportsURIMetadataInterface = async (\n    address: string,\n  ): Promise<boolean> => {\n    return this.contractSupportsInterface(\n      address,\n      ERC1155_METADATA_URI_INTERFACE_ID,\n    );\n  };\n\n  /**\n   * Query if contract implements ERC1155 Token Receiver interface.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @returns Promise resolving to whether the contract implements ERC1155 Token Receiver interface.\n   */\n  contractSupportsTokenReceiverInterface = async (\n    address: string,\n  ): Promise<boolean> => {\n    return this.contractSupportsInterface(\n      address,\n      ERC1155_TOKEN_RECEIVER_INTERFACE_ID,\n    );\n  };\n\n  /**\n   * Query if contract implements ERC1155 interface.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @returns Promise resolving to whether the contract implements the base ERC1155 interface.\n   */\n  contractSupportsBase1155Interface = async (\n    address: string,\n  ): Promise<boolean> => {\n    return this.contractSupportsInterface(address, ERC1155_INTERFACE_ID);\n  };\n\n  /**\n   * Query for tokenURI for a given asset.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @param tokenId - ERC1155 asset identifier.\n   * @returns Promise resolving to the 'tokenURI'.\n   */\n  getTokenURI = async (address: string, tokenId: string): Promise<string> => {\n    const contract = new Contract(address, abiERC1155, this.provider);\n    return contract.uri(tokenId);\n  };\n\n  /**\n   * Query for balance of a given ERC1155 token.\n   *\n   * @param contractAddress - ERC1155 asset contract address.\n   * @param address - Wallet public address.\n   * @param tokenId - ERC1155 asset identifier.\n   * @returns Promise resolving to the 'balanceOf'.\n   */\n  getBalanceOf = async (\n    contractAddress: string,\n    address: string,\n    tokenId: string,\n  ): Promise<BN> => {\n    const contract = new Contract(contractAddress, abiERC1155, this.provider);\n    const balance = await contract.balanceOf(address, tokenId);\n    return ethersBigNumberToBN(balance);\n  };\n\n  /**\n   * Transfer single ERC1155 token.\n   * When minting/creating tokens, the from arg MUST be set to 0x0 (i.e. zero address).\n   * When burning/destroying tokens, the to arg MUST be set to 0x0 (i.e. zero address).\n   *\n   * @param operator - ERC1155 token address.\n   * @param from - ERC1155 token holder.\n   * @param to - ERC1155 token recipient.\n   * @param id - ERC1155 token id.\n   * @param value - Number of tokens to be sent.\n   * @returns Promise resolving to the 'transferSingle'.\n   */\n  transferSingle = async (\n    operator: string,\n    from: string,\n    to: string,\n    id: string,\n    value: string,\n  ): Promise<void> => {\n    const contract = new Contract(operator, abiERC1155, this.provider);\n    return new Promise<void>((resolve, reject) => {\n      contract.transferSingle(\n        operator,\n        from,\n        to,\n        id,\n        value,\n        (error: Error, result: void) => {\n          /* istanbul ignore if */\n          if (error) {\n            reject(error);\n            return;\n          }\n          resolve(result);\n        },\n      );\n    });\n  };\n\n  /**\n   * Query if a contract implements an interface.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @param interfaceId - Interface identifier.\n   * @returns Promise resolving to whether the contract implements `interfaceID`.\n   */\n  private contractSupportsInterface = async (\n    address: string,\n    interfaceId: string,\n  ): Promise<boolean> => {\n    const contract = new Contract(address, abiERC1155, this.provider);\n    return contract.supportsInterface(interfaceId);\n  };\n\n  /**\n   * Query if a contract implements an interface.\n   *\n   * @param address - Asset contract address.\n   * @param ipfsGateway - The user's preferred IPFS gateway.\n   * @param tokenId - tokenId of a given token in the contract.\n   * @returns Promise resolving an object containing the standard, tokenURI, symbol and name of the given contract/tokenId pair.\n   */\n  getDetails = async (\n    address: string,\n    ipfsGateway: string,\n    tokenId?: string,\n  ): Promise<{\n    standard: string;\n    tokenURI: string | undefined;\n    image: string | undefined;\n  }> => {\n    const isERC1155 = await this.contractSupportsBase1155Interface(address);\n\n    if (!isERC1155) {\n      throw new Error(\"This isn't a valid ERC1155 contract\");\n    }\n    let tokenURI, image;\n\n    if (tokenId) {\n      tokenURI = await this.getTokenURI(address, tokenId);\n      if (tokenURI.startsWith('ipfs://')) {\n        tokenURI = getFormattedIpfsUrl(ipfsGateway, tokenURI, true);\n      }\n\n      try {\n        const response = await timeoutFetch(tokenURI);\n        const object = await response.json();\n        image = object?.image;\n        if (image?.startsWith('ipfs://')) {\n          image = getFormattedIpfsUrl(ipfsGateway, image, true);\n        }\n      } catch {\n        // ignore\n      }\n    }\n\n    // TODO consider querying to the metadata to get name.\n    return {\n      standard: ERC1155,\n      tokenURI,\n      image,\n    };\n  };\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC1155/ERC1155Standard.mjs b/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC1155/ERC1155Standard.mjs
new file mode 100644
index 0000000..95f60e2
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC1155/ERC1155Standard.mjs
@@ -0,0 +1,9 @@
+import {
+  ERC1155Standard
+} from "../../../chunk-CEENXWOB.mjs";
+import "../../../chunk-E5PIGGYR.mjs";
+import "../../../chunk-XUI43LEZ.mjs";
+export {
+  ERC1155Standard
+};
+//# sourceMappingURL=ERC1155Standard.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC1155/ERC1155Standard.mjs.map b/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC1155/ERC1155Standard.mjs.map
new file mode 100644
index 0000000..84c51b2
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC1155/ERC1155Standard.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":[],"sourcesContent":[],"mappings":"","names":[]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC721/ERC721Standard.d.ts b/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC721/ERC721Standard.d.ts
index 99ceff0..28133f1 100644
--- a/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC721/ERC721Standard.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC721/ERC721Standard.d.ts
@@ -1,6 +1,6 @@
-import type { Web3Provider } from '@ethersproject/providers';
+import { Web3Provider } from '@ethersproject/providers';
 export declare class ERC721Standard {
-    private readonly provider;
+    private provider;
     constructor(provider: Web3Provider);
     /**
      * Query if contract implements ERC721Metadata interface.
@@ -69,7 +69,7 @@ export declare class ERC721Standard {
      * @param interfaceId - Interface identifier.
      * @returns Promise resolving to whether the contract implements `interfaceID`.
      */
-    private readonly contractSupportsInterface;
+    private contractSupportsInterface;
     /**
      * Query if a contract implements an interface.
      *
diff --git a/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC721/ERC721Standard.d.ts.map b/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC721/ERC721Standard.d.ts.map
index d23ef42..e80b482 100644
--- a/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC721/ERC721Standard.d.ts.map
+++ b/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC721/ERC721Standard.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"ERC721Standard.d.ts","sourceRoot":"","sources":["../../../../src/Standards/NftStandards/ERC721/ERC721Standard.ts"],"names":[],"mappings":"AACA,OAAO,KAAK,EAAE,YAAY,EAAE,MAAM,0BAA0B,CAAC;AAY7D,qBAAa,cAAc;IACzB,OAAO,CAAC,QAAQ,CAAC,QAAQ,CAAe;gBAE5B,QAAQ,EAAE,YAAY;IAIlC;;;;;OAKG;IACH,iCAAiC,YACtB,MAAM,KACd,QAAQ,OAAO,CAAC,CAKjB;IAEF;;;;;OAKG;IACH,mCAAmC,YACxB,MAAM,KACd,QAAQ,OAAO,CAAC,CAKjB;IAEF;;;;;OAKG;IACH,gCAAgC,YACrB,MAAM,KACd,QAAQ,OAAO,CAAC,CAEjB;IAEF;;;;;;;OAOG;IACH,aAAa,YACF,MAAM,mBACE,MAAM,SAChB,MAAM,KACZ,QAAQ,MAAM,CAAC,CAGhB;IAEF;;;;;;OAMG;IACH,WAAW,YAAmB,MAAM,WAAW,MAAM,KAAG,QAAQ,MAAM,CAAC,CASrE;IAEF;;;;;OAKG;IACH,YAAY,YAAmB,MAAM,KAAG,QAAQ,MAAM,CAAC,CAGrD;IAEF;;;;;OAKG;IACH,cAAc,YAAmB,MAAM,KAAG,QAAQ,MAAM,CAAC,CAGvD;IAEF;;;;;;OAMG;IACG,UAAU,CAAC,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;IAKnE;;;;;;OAMG;IACH,OAAO,CAAC,QAAQ,CAAC,yBAAyB,CAcxC;IAEF;;;;;;;OAOG;IACH,UAAU,YACC,MAAM,eACF,MAAM;kBAGT,MAAM;kBACN,MAAM,GAAG,SAAS;gBACpB,MAAM,GAAG,SAAS;cACpB,MAAM,GAAG,SAAS;eACjB,MAAM,GAAG,SAAS;OA+CzB;CACH"}
\ No newline at end of file
+{"version":3,"file":"ERC721Standard.d.ts","sourceRoot":"","sources":["../../../../src/Standards/NftStandards/ERC721/ERC721Standard.ts"],"names":[],"mappings":"AASA,OAAO,EAAE,YAAY,EAAE,MAAM,0BAA0B,CAAC;AAGxD,qBAAa,cAAc;IACzB,OAAO,CAAC,QAAQ,CAAe;gBAEnB,QAAQ,EAAE,YAAY;IAIlC;;;;;OAKG;IACH,iCAAiC,YACtB,MAAM,KACd,QAAQ,OAAO,CAAC,CAKjB;IAEF;;;;;OAKG;IACH,mCAAmC,YACxB,MAAM,KACd,QAAQ,OAAO,CAAC,CAKjB;IAEF;;;;;OAKG;IACH,gCAAgC,YACrB,MAAM,KACd,QAAQ,OAAO,CAAC,CAEjB;IAEF;;;;;;;OAOG;IACH,aAAa,YACF,MAAM,mBACE,MAAM,SAChB,MAAM,KACZ,QAAQ,MAAM,CAAC,CAGhB;IAEF;;;;;;OAMG;IACH,WAAW,YAAmB,MAAM,WAAW,MAAM,KAAG,QAAQ,MAAM,CAAC,CASrE;IAEF;;;;;OAKG;IACH,YAAY,YAAmB,MAAM,KAAG,QAAQ,MAAM,CAAC,CAGrD;IAEF;;;;;OAKG;IACH,cAAc,YAAmB,MAAM,KAAG,QAAQ,MAAM,CAAC,CAGvD;IAEF;;;;;;OAMG;IACG,UAAU,CAAC,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;IAKnE;;;;;;OAMG;IACH,OAAO,CAAC,yBAAyB,CAc/B;IAEF;;;;;;;OAOG;IACH,UAAU,YACC,MAAM,eACF,MAAM;kBAGT,MAAM;kBACN,MAAM,GAAG,SAAS;gBACpB,MAAM,GAAG,SAAS;cACpB,MAAM,GAAG,SAAS;eACjB,MAAM,GAAG,SAAS;OA+CzB;CACH"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC721/ERC721Standard.js b/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC721/ERC721Standard.js
index 5ffdcd6..d267402 100644
--- a/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC721/ERC721Standard.js
+++ b/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC721/ERC721Standard.js
@@ -10,9 +10,9 @@ var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, ge
 };
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.ERC721Standard = void 0;
+const metamask_eth_abis_1 = require("@metamask/metamask-eth-abis");
 const contracts_1 = require("@ethersproject/contracts");
 const controller_utils_1 = require("@metamask/controller-utils");
-const metamask_eth_abis_1 = require("@metamask/metamask-eth-abis");
 const assetsUtil_1 = require("../../../assetsUtil");
 class ERC721Standard {
     constructor(provider) {
diff --git a/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC721/ERC721Standard.js.map b/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC721/ERC721Standard.js.map
index 705b1b2..7453d27 100644
--- a/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC721/ERC721Standard.js.map
+++ b/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC721/ERC721Standard.js.map
@@ -1 +1 @@
-{"version":3,"file":"ERC721Standard.js","sourceRoot":"","sources":["../../../../src/Standards/NftStandards/ERC721/ERC721Standard.ts"],"names":[],"mappings":"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","sourcesContent":["import { Contract } from '@ethersproject/contracts';\nimport type { Web3Provider } from '@ethersproject/providers';\nimport {\n  timeoutFetch,\n  ERC721_INTERFACE_ID,\n  ERC721_METADATA_INTERFACE_ID,\n  ERC721_ENUMERABLE_INTERFACE_ID,\n  ERC721,\n} from '@metamask/controller-utils';\nimport { abiERC721 } from '@metamask/metamask-eth-abis';\n\nimport { getFormattedIpfsUrl } from '../../../assetsUtil';\n\nexport class ERC721Standard {\n  private readonly provider: Web3Provider;\n\n  constructor(provider: Web3Provider) {\n    this.provider = provider;\n  }\n\n  /**\n   * Query if contract implements ERC721Metadata interface.\n   *\n   * @param address - ERC721 asset contract address.\n   * @returns Promise resolving to whether the contract implements ERC721Metadata interface.\n   */\n  contractSupportsMetadataInterface = async (\n    address: string,\n  ): Promise<boolean> => {\n    return this.contractSupportsInterface(\n      address,\n      ERC721_METADATA_INTERFACE_ID,\n    );\n  };\n\n  /**\n   * Query if contract implements ERC721Enumerable interface.\n   *\n   * @param address - ERC721 asset contract address.\n   * @returns Promise resolving to whether the contract implements ERC721Enumerable interface.\n   */\n  contractSupportsEnumerableInterface = async (\n    address: string,\n  ): Promise<boolean> => {\n    return this.contractSupportsInterface(\n      address,\n      ERC721_ENUMERABLE_INTERFACE_ID,\n    );\n  };\n\n  /**\n   * Query if contract implements ERC721 interface.\n   *\n   * @param address - ERC721 asset contract address.\n   * @returns Promise resolving to whether the contract implements ERC721 interface.\n   */\n  contractSupportsBase721Interface = async (\n    address: string,\n  ): Promise<boolean> => {\n    return this.contractSupportsInterface(address, ERC721_INTERFACE_ID);\n  };\n\n  /**\n   * Enumerate assets assigned to an owner.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param selectedAddress - Current account public address.\n   * @param index - An NFT counter less than `balanceOf(selectedAddress)`.\n   * @returns Promise resolving to token identifier for the 'index'th asset assigned to 'selectedAddress'.\n   */\n  getNftTokenId = async (\n    address: string,\n    selectedAddress: string,\n    index: number,\n  ): Promise<string> => {\n    const contract = new Contract(address, abiERC721, this.provider);\n    return contract.tokenOfOwnerByIndex(selectedAddress, index);\n  };\n\n  /**\n   * Query for tokenURI for a given asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param tokenId - ERC721 asset identifier.\n   * @returns Promise resolving to the 'tokenURI'.\n   */\n  getTokenURI = async (address: string, tokenId: string): Promise<string> => {\n    const contract = new Contract(address, abiERC721, this.provider);\n    const supportsMetadata = await this.contractSupportsMetadataInterface(\n      address,\n    );\n    if (!supportsMetadata) {\n      throw new Error('Contract does not support ERC721 metadata interface.');\n    }\n    return contract.tokenURI(tokenId);\n  };\n\n  /**\n   * Query for name for a given asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @returns Promise resolving to the 'name'.\n   */\n  getAssetName = async (address: string): Promise<string> => {\n    const contract = new Contract(address, abiERC721, this.provider);\n    return contract.name();\n  };\n\n  /**\n   * Query for symbol for a given asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @returns Promise resolving to the 'symbol'.\n   */\n  getAssetSymbol = async (address: string): Promise<string> => {\n    const contract = new Contract(address, abiERC721, this.provider);\n    return contract.symbol();\n  };\n\n  /**\n   * Query for owner for a given ERC721 asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param tokenId - ERC721 asset identifier.\n   * @returns Promise resolving to the owner address.\n   */\n  async getOwnerOf(address: string, tokenId: string): Promise<string> {\n    const contract = new Contract(address, abiERC721, this.provider);\n    return contract.ownerOf(tokenId);\n  }\n\n  /**\n   * Query if a contract implements an interface.\n   *\n   * @param address - Asset contract address.\n   * @param interfaceId - Interface identifier.\n   * @returns Promise resolving to whether the contract implements `interfaceID`.\n   */\n  private readonly contractSupportsInterface = async (\n    address: string,\n    interfaceId: string,\n  ): Promise<boolean> => {\n    const contract = new Contract(address, abiERC721, this.provider);\n    try {\n      return await contract.supportsInterface(interfaceId);\n    } catch (err: any) {\n      // Mirror previous implementation\n      if (err.message.includes('call revert exception')) {\n        return false;\n      }\n      throw err;\n    }\n  };\n\n  /**\n   * Query if a contract implements an interface.\n   *\n   * @param address - Asset contract address.\n   * @param ipfsGateway - The user's preferred IPFS gateway.\n   * @param tokenId - tokenId of a given token in the contract.\n   * @returns Promise resolving an object containing the standard, tokenURI, symbol and name of the given contract/tokenId pair.\n   */\n  getDetails = async (\n    address: string,\n    ipfsGateway: string,\n    tokenId?: string,\n  ): Promise<{\n    standard: string;\n    tokenURI: string | undefined;\n    symbol: string | undefined;\n    name: string | undefined;\n    image: string | undefined;\n  }> => {\n    const isERC721 = await this.contractSupportsBase721Interface(address);\n    if (!isERC721) {\n      throw new Error(\"This isn't a valid ERC721 contract\");\n    }\n\n    let tokenURI, image, symbol, name;\n\n    // TODO upgrade to use Promise.allSettled for name/symbol when we can refactor to use es2020 in tsconfig\n    try {\n      symbol = await this.getAssetSymbol(address);\n    } catch {\n      // ignore\n    }\n\n    try {\n      name = await this.getAssetName(address);\n    } catch {\n      // ignore\n    }\n\n    if (tokenId) {\n      try {\n        tokenURI = await this.getTokenURI(address, tokenId);\n        if (tokenURI.startsWith('ipfs://')) {\n          tokenURI = getFormattedIpfsUrl(ipfsGateway, tokenURI, true);\n        }\n\n        const response = await timeoutFetch(tokenURI);\n        const object = await response.json();\n        image = object?.image;\n        if (image?.startsWith('ipfs://')) {\n          image = getFormattedIpfsUrl(ipfsGateway, image, true);\n        }\n      } catch {\n        // ignore\n      }\n    }\n\n    return {\n      standard: ERC721,\n      tokenURI,\n      symbol,\n      name,\n      image,\n    };\n  };\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"ERC721Standard.js","sourceRoot":"","sources":["../../../../src/Standards/NftStandards/ERC721/ERC721Standard.ts"],"names":[],"mappings":"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","sourcesContent":["import { abiERC721 } from '@metamask/metamask-eth-abis';\nimport { Contract } from '@ethersproject/contracts';\nimport {\n  timeoutFetch,\n  ERC721_INTERFACE_ID,\n  ERC721_METADATA_INTERFACE_ID,\n  ERC721_ENUMERABLE_INTERFACE_ID,\n  ERC721,\n} from '@metamask/controller-utils';\nimport { Web3Provider } from '@ethersproject/providers';\nimport { getFormattedIpfsUrl } from '../../../assetsUtil';\n\nexport class ERC721Standard {\n  private provider: Web3Provider;\n\n  constructor(provider: Web3Provider) {\n    this.provider = provider;\n  }\n\n  /**\n   * Query if contract implements ERC721Metadata interface.\n   *\n   * @param address - ERC721 asset contract address.\n   * @returns Promise resolving to whether the contract implements ERC721Metadata interface.\n   */\n  contractSupportsMetadataInterface = async (\n    address: string,\n  ): Promise<boolean> => {\n    return this.contractSupportsInterface(\n      address,\n      ERC721_METADATA_INTERFACE_ID,\n    );\n  };\n\n  /**\n   * Query if contract implements ERC721Enumerable interface.\n   *\n   * @param address - ERC721 asset contract address.\n   * @returns Promise resolving to whether the contract implements ERC721Enumerable interface.\n   */\n  contractSupportsEnumerableInterface = async (\n    address: string,\n  ): Promise<boolean> => {\n    return this.contractSupportsInterface(\n      address,\n      ERC721_ENUMERABLE_INTERFACE_ID,\n    );\n  };\n\n  /**\n   * Query if contract implements ERC721 interface.\n   *\n   * @param address - ERC721 asset contract address.\n   * @returns Promise resolving to whether the contract implements ERC721 interface.\n   */\n  contractSupportsBase721Interface = async (\n    address: string,\n  ): Promise<boolean> => {\n    return this.contractSupportsInterface(address, ERC721_INTERFACE_ID);\n  };\n\n  /**\n   * Enumerate assets assigned to an owner.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param selectedAddress - Current account public address.\n   * @param index - An NFT counter less than `balanceOf(selectedAddress)`.\n   * @returns Promise resolving to token identifier for the 'index'th asset assigned to 'selectedAddress'.\n   */\n  getNftTokenId = async (\n    address: string,\n    selectedAddress: string,\n    index: number,\n  ): Promise<string> => {\n    const contract = new Contract(address, abiERC721, this.provider);\n    return contract.tokenOfOwnerByIndex(selectedAddress, index);\n  };\n\n  /**\n   * Query for tokenURI for a given asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param tokenId - ERC721 asset identifier.\n   * @returns Promise resolving to the 'tokenURI'.\n   */\n  getTokenURI = async (address: string, tokenId: string): Promise<string> => {\n    const contract = new Contract(address, abiERC721, this.provider);\n    const supportsMetadata = await this.contractSupportsMetadataInterface(\n      address,\n    );\n    if (!supportsMetadata) {\n      throw new Error('Contract does not support ERC721 metadata interface.');\n    }\n    return contract.tokenURI(tokenId);\n  };\n\n  /**\n   * Query for name for a given asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @returns Promise resolving to the 'name'.\n   */\n  getAssetName = async (address: string): Promise<string> => {\n    const contract = new Contract(address, abiERC721, this.provider);\n    return contract.name();\n  };\n\n  /**\n   * Query for symbol for a given asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @returns Promise resolving to the 'symbol'.\n   */\n  getAssetSymbol = async (address: string): Promise<string> => {\n    const contract = new Contract(address, abiERC721, this.provider);\n    return contract.symbol();\n  };\n\n  /**\n   * Query for owner for a given ERC721 asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param tokenId - ERC721 asset identifier.\n   * @returns Promise resolving to the owner address.\n   */\n  async getOwnerOf(address: string, tokenId: string): Promise<string> {\n    const contract = new Contract(address, abiERC721, this.provider);\n    return contract.ownerOf(tokenId);\n  }\n\n  /**\n   * Query if a contract implements an interface.\n   *\n   * @param address - Asset contract address.\n   * @param interfaceId - Interface identifier.\n   * @returns Promise resolving to whether the contract implements `interfaceID`.\n   */\n  private contractSupportsInterface = async (\n    address: string,\n    interfaceId: string,\n  ): Promise<boolean> => {\n    const contract = new Contract(address, abiERC721, this.provider);\n    try {\n      return await contract.supportsInterface(interfaceId);\n    } catch (err: any) {\n      // Mirror previous implementation\n      if (err.message.includes('call revert exception')) {\n        return false;\n      }\n      throw err;\n    }\n  };\n\n  /**\n   * Query if a contract implements an interface.\n   *\n   * @param address - Asset contract address.\n   * @param ipfsGateway - The user's preferred IPFS gateway.\n   * @param tokenId - tokenId of a given token in the contract.\n   * @returns Promise resolving an object containing the standard, tokenURI, symbol and name of the given contract/tokenId pair.\n   */\n  getDetails = async (\n    address: string,\n    ipfsGateway: string,\n    tokenId?: string,\n  ): Promise<{\n    standard: string;\n    tokenURI: string | undefined;\n    symbol: string | undefined;\n    name: string | undefined;\n    image: string | undefined;\n  }> => {\n    const isERC721 = await this.contractSupportsBase721Interface(address);\n    if (!isERC721) {\n      throw new Error(\"This isn't a valid ERC721 contract\");\n    }\n\n    let tokenURI, image, symbol, name;\n\n    // TODO upgrade to use Promise.allSettled for name/symbol when we can refactor to use es2020 in tsconfig\n    try {\n      symbol = await this.getAssetSymbol(address);\n    } catch {\n      // ignore\n    }\n\n    try {\n      name = await this.getAssetName(address);\n    } catch {\n      // ignore\n    }\n\n    if (tokenId) {\n      try {\n        tokenURI = await this.getTokenURI(address, tokenId);\n        if (tokenURI.startsWith('ipfs://')) {\n          tokenURI = getFormattedIpfsUrl(ipfsGateway, tokenURI, true);\n        }\n\n        const response = await timeoutFetch(tokenURI);\n        const object = await response.json();\n        image = object?.image;\n        if (image?.startsWith('ipfs://')) {\n          image = getFormattedIpfsUrl(ipfsGateway, image, true);\n        }\n      } catch {\n        // ignore\n      }\n    }\n\n    return {\n      standard: ERC721,\n      tokenURI,\n      symbol,\n      name,\n      image,\n    };\n  };\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC721/ERC721Standard.mjs b/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC721/ERC721Standard.mjs
new file mode 100644
index 0000000..2fb6f88
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC721/ERC721Standard.mjs
@@ -0,0 +1,9 @@
+import {
+  ERC721Standard
+} from "../../../chunk-WIVSZVF4.mjs";
+import "../../../chunk-E5PIGGYR.mjs";
+import "../../../chunk-XUI43LEZ.mjs";
+export {
+  ERC721Standard
+};
+//# sourceMappingURL=ERC721Standard.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC721/ERC721Standard.mjs.map b/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC721/ERC721Standard.mjs.map
new file mode 100644
index 0000000..84c51b2
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/Standards/NftStandards/ERC721/ERC721Standard.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":[],"sourcesContent":[],"mappings":"","names":[]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/Standards/standards-types.d.ts b/node_modules/@metamask/assets-controllers/dist/Standards/standards-types.d.ts
index 75dcf23..309ab00 100644
--- a/node_modules/@metamask/assets-controllers/dist/Standards/standards-types.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/Standards/standards-types.d.ts
@@ -1,4 +1,4 @@
-import type { abiERC20, abiERC1155, abiERC721 } from '@metamask/metamask-eth-abis';
+import { abiERC20, abiERC1155, abiERC721 } from '@metamask/metamask-eth-abis';
 declare type Contract = {
     at(address: string): any;
 };
diff --git a/node_modules/@metamask/assets-controllers/dist/Standards/standards-types.d.ts.map b/node_modules/@metamask/assets-controllers/dist/Standards/standards-types.d.ts.map
index 8337515..f431cd7 100644
--- a/node_modules/@metamask/assets-controllers/dist/Standards/standards-types.d.ts.map
+++ b/node_modules/@metamask/assets-controllers/dist/Standards/standards-types.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"standards-types.d.ts","sourceRoot":"","sources":["../../src/Standards/standards-types.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EACV,QAAQ,EACR,UAAU,EACV,SAAS,EACV,MAAM,6BAA6B,CAAC;AAErC,aAAK,QAAQ,GAAG;IACd,EAAE,CAAC,OAAO,EAAE,MAAM,GAAG,GAAG,CAAC;CAC1B,CAAC;AAEF,oBAAY,IAAI,GAAG;IACjB,GAAG,EAAE;QACH,IAAI,CACF,OAAO,EAAE;YAAE,EAAE,EAAE,MAAM,CAAC;YAAC,IAAI,EAAE,MAAM,CAAA;SAAE,EACrC,KAAK,EAAE,SAAS,EAChB,QAAQ,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,KAAK,IAAI,GAC/C,IAAI,CAAC;QACR,QAAQ,CACN,GAAG,EAAE,OAAO,QAAQ,GAAG,OAAO,SAAS,GAAG,OAAO,UAAU,GAC1D,QAAQ,CAAC;KACb,CAAC;CACH,CAAC"}
\ No newline at end of file
+{"version":3,"file":"standards-types.d.ts","sourceRoot":"","sources":["../../src/Standards/standards-types.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,QAAQ,EAAE,UAAU,EAAE,SAAS,EAAE,MAAM,6BAA6B,CAAC;AAE9E,aAAK,QAAQ,GAAG;IACd,EAAE,CAAC,OAAO,EAAE,MAAM,GAAG,GAAG,CAAC;CAC1B,CAAC;AAEF,oBAAY,IAAI,GAAG;IACjB,GAAG,EAAE;QACH,IAAI,CACF,OAAO,EAAE;YAAE,EAAE,EAAE,MAAM,CAAC;YAAC,IAAI,EAAE,MAAM,CAAA;SAAE,EACrC,KAAK,EAAE,SAAS,EAChB,QAAQ,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,KAAK,IAAI,GAC/C,IAAI,CAAC;QACR,QAAQ,CACN,GAAG,EAAE,OAAO,QAAQ,GAAG,OAAO,SAAS,GAAG,OAAO,UAAU,GAC1D,QAAQ,CAAC;KACb,CAAC;CACH,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/Standards/standards-types.js.map b/node_modules/@metamask/assets-controllers/dist/Standards/standards-types.js.map
index 5ecf0b5..1eaa1b1 100644
--- a/node_modules/@metamask/assets-controllers/dist/Standards/standards-types.js.map
+++ b/node_modules/@metamask/assets-controllers/dist/Standards/standards-types.js.map
@@ -1 +1 @@
-{"version":3,"file":"standards-types.js","sourceRoot":"","sources":["../../src/Standards/standards-types.ts"],"names":[],"mappings":"","sourcesContent":["import type {\n  abiERC20,\n  abiERC1155,\n  abiERC721,\n} from '@metamask/metamask-eth-abis';\n\ntype Contract = {\n  at(address: string): any;\n};\n\nexport type Web3 = {\n  eth: {\n    call(\n      payload: { to: string; data: string },\n      block: undefined,\n      callback: (error: Error, result: string) => void,\n    ): void;\n    contract(\n      abi: typeof abiERC20 | typeof abiERC721 | typeof abiERC1155,\n    ): Contract;\n  };\n};\n"]}
\ No newline at end of file
+{"version":3,"file":"standards-types.js","sourceRoot":"","sources":["../../src/Standards/standards-types.ts"],"names":[],"mappings":"","sourcesContent":["import { abiERC20, abiERC1155, abiERC721 } from '@metamask/metamask-eth-abis';\n\ntype Contract = {\n  at(address: string): any;\n};\n\nexport type Web3 = {\n  eth: {\n    call(\n      payload: { to: string; data: string },\n      block: undefined,\n      callback: (error: Error, result: string) => void,\n    ): void;\n    contract(\n      abi: typeof abiERC20 | typeof abiERC721 | typeof abiERC1155,\n    ): Contract;\n  };\n};\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.d.ts b/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.d.ts
index 315e7c8..1563e60 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.d.ts
@@ -1,11 +1,10 @@
 /// <reference types="bn.js" />
-import type { BaseConfig, BaseState } from '@metamask/base-controller';
-import { BaseController } from '@metamask/base-controller';
-import type { PreferencesState } from '@metamask/preferences-controller';
 import { BN } from 'ethereumjs-util';
+import { BaseController, BaseConfig, BaseState } from '@metamask/base-controller';
+import type { PreferencesState } from '@metamask/preferences-controller';
+import { Token } from './TokenRatesController';
+import { TokensState } from './TokensController';
 import type { AssetsContractController } from './AssetsContractController';
-import type { Token } from './TokenRatesController';
-import type { TokensState } from './TokensController';
 export { BN };
 /**
  * @type TokenBalancesConfig
@@ -39,8 +38,8 @@ export declare class TokenBalancesController extends BaseController<TokenBalance
      * Name of this controller used during composition
      */
     name: string;
-    private readonly getSelectedAddress;
-    private readonly getERC20BalanceOf;
+    private getSelectedAddress;
+    private getERC20BalanceOf;
     /**
      * Creates a TokenBalancesController instance.
      *
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.d.ts.map b/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.d.ts.map
index d26a5e1..d8205a1 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.d.ts.map
+++ b/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"TokenBalancesController.d.ts","sourceRoot":"","sources":["../src/TokenBalancesController.ts"],"names":[],"mappings":";AAAA,OAAO,KAAK,EAAE,UAAU,EAAE,SAAS,EAAE,MAAM,2BAA2B,CAAC;AACvE,OAAO,EAAE,cAAc,EAAE,MAAM,2BAA2B,CAAC;AAE3D,OAAO,KAAK,EAAE,gBAAgB,EAAE,MAAM,kCAAkC,CAAC;AACzE,OAAO,EAAE,EAAE,EAAE,MAAM,iBAAiB,CAAC;AAErC,OAAO,KAAK,EAAE,wBAAwB,EAAE,MAAM,4BAA4B,CAAC;AAC3E,OAAO,KAAK,EAAE,KAAK,EAAE,MAAM,wBAAwB,CAAC;AACpD,OAAO,KAAK,EAAE,WAAW,EAAE,MAAM,oBAAoB,CAAC;AAGtD,OAAO,EAAE,EAAE,EAAE,CAAC;AAEd;;;;;;GAMG;AACH,MAAM,WAAW,mBAAoB,SAAQ,UAAU;IACrD,QAAQ,EAAE,MAAM,CAAC;IACjB,MAAM,EAAE,KAAK,EAAE,CAAC;CACjB;AAED;;;;;GAKG;AACH,MAAM,WAAW,kBAAmB,SAAQ,SAAS;IACnD,gBAAgB,EAAE;QAAE,CAAC,OAAO,EAAE,MAAM,GAAG,EAAE,CAAA;KAAE,CAAC;CAC7C;AAED;;;GAGG;AACH,qBAAa,uBAAwB,SAAQ,cAAc,CACzD,mBAAmB,EACnB,kBAAkB,CACnB;IACC,OAAO,CAAC,MAAM,CAAC,CAAgC;IAE/C;;OAEG;IACM,IAAI,SAA6B;IAE1C,OAAO,CAAC,QAAQ,CAAC,kBAAkB,CAA4C;IAE/E,OAAO,CAAC,QAAQ,CAAC,iBAAiB,CAAgD;IAElF;;;;;;;;;OASG;gBAED,EACE,mBAAmB,EACnB,kBAAkB,EAClB,iBAAiB,GAClB,EAAE;QACD,mBAAmB,EAAE,CACnB,QAAQ,EAAE,CAAC,UAAU,EAAE,WAAW,KAAK,IAAI,KACxC,IAAI,CAAC;QACV,kBAAkB,EAAE,MAAM,gBAAgB,CAAC,iBAAiB,CAAC,CAAC;QAC9D,iBAAiB,EAAE,wBAAwB,CAAC,mBAAmB,CAAC,CAAC;KAClE,EACD,MAAM,CAAC,EAAE,OAAO,CAAC,mBAAmB,CAAC,EACrC,KAAK,CAAC,EAAE,OAAO,CAAC,kBAAkB,CAAC;IAkBrC;;;;OAIG;IACG,IAAI,CAAC,QAAQ,CAAC,EAAE,MAAM,GAAG,OAAO,CAAC,IAAI,CAAC;IAS5C;;OAEG;IACG,cAAc;CAqBrB;AAED,eAAe,uBAAuB,CAAC"}
\ No newline at end of file
+{"version":3,"file":"TokenBalancesController.d.ts","sourceRoot":"","sources":["../src/TokenBalancesController.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,EAAE,EAAE,MAAM,iBAAiB,CAAC;AACrC,OAAO,EACL,cAAc,EACd,UAAU,EACV,SAAS,EACV,MAAM,2BAA2B,CAAC;AAEnC,OAAO,KAAK,EAAE,gBAAgB,EAAE,MAAM,kCAAkC,CAAC;AACzE,OAAO,EAAE,KAAK,EAAE,MAAM,wBAAwB,CAAC;AAC/C,OAAO,EAAE,WAAW,EAAE,MAAM,oBAAoB,CAAC;AACjD,OAAO,KAAK,EAAE,wBAAwB,EAAE,MAAM,4BAA4B,CAAC;AAG3E,OAAO,EAAE,EAAE,EAAE,CAAC;AAEd;;;;;;GAMG;AACH,MAAM,WAAW,mBAAoB,SAAQ,UAAU;IACrD,QAAQ,EAAE,MAAM,CAAC;IACjB,MAAM,EAAE,KAAK,EAAE,CAAC;CACjB;AAED;;;;;GAKG;AACH,MAAM,WAAW,kBAAmB,SAAQ,SAAS;IACnD,gBAAgB,EAAE;QAAE,CAAC,OAAO,EAAE,MAAM,GAAG,EAAE,CAAA;KAAE,CAAC;CAC7C;AAED;;;GAGG;AACH,qBAAa,uBAAwB,SAAQ,cAAc,CACzD,mBAAmB,EACnB,kBAAkB,CACnB;IACC,OAAO,CAAC,MAAM,CAAC,CAAgC;IAE/C;;OAEG;IACM,IAAI,SAA6B;IAE1C,OAAO,CAAC,kBAAkB,CAA4C;IAEtE,OAAO,CAAC,iBAAiB,CAAgD;IAEzE;;;;;;;;;OASG;gBAED,EACE,mBAAmB,EACnB,kBAAkB,EAClB,iBAAiB,GAClB,EAAE;QACD,mBAAmB,EAAE,CACnB,QAAQ,EAAE,CAAC,UAAU,EAAE,WAAW,KAAK,IAAI,KACxC,IAAI,CAAC;QACV,kBAAkB,EAAE,MAAM,gBAAgB,CAAC,iBAAiB,CAAC,CAAC;QAC9D,iBAAiB,EAAE,wBAAwB,CAAC,mBAAmB,CAAC,CAAC;KAClE,EACD,MAAM,CAAC,EAAE,OAAO,CAAC,mBAAmB,CAAC,EACrC,KAAK,CAAC,EAAE,OAAO,CAAC,kBAAkB,CAAC;IAkBrC;;;;OAIG;IACG,IAAI,CAAC,QAAQ,CAAC,EAAE,MAAM,GAAG,OAAO,CAAC,IAAI,CAAC;IAS5C;;OAEG;IACG,cAAc;CAqBrB;AAED,eAAe,uBAAuB,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.js b/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.js
index 0a7481d..525ad76 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.js
+++ b/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.js
@@ -10,10 +10,10 @@ var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, ge
 };
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.TokenBalancesController = exports.BN = void 0;
-const base_controller_1 = require("@metamask/base-controller");
-const controller_utils_1 = require("@metamask/controller-utils");
 const ethereumjs_util_1 = require("ethereumjs-util");
 Object.defineProperty(exports, "BN", { enumerable: true, get: function () { return ethereumjs_util_1.BN; } });
+const base_controller_1 = require("@metamask/base-controller");
+const controller_utils_1 = require("@metamask/controller-utils");
 /**
  * Controller that passively polls on a set interval token balances
  * for tokens stored in the TokensController
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.js.map b/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.js.map
index 5b8da85..7959e93 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.js.map
+++ b/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.js.map
@@ -1 +1 @@
-{"version":3,"file":"TokenBalancesController.js","sourceRoot":"","sources":["../src/TokenBalancesController.ts"],"names":[],"mappings":";;;;;;;;;;;;AACA,+DAA2D;AAC3D,iEAA2D;AAE3D,qDAAqC;AAO5B,mFAPA,oBAAE,OAOA;AAwBX;;;GAGG;AACH,MAAa,uBAAwB,SAAQ,gCAG5C;IAYC;;;;;;;;;OASG;IACH,YACE,EACE,mBAAmB,EACnB,kBAAkB,EAClB,iBAAiB,GAOlB,EACD,MAAqC,EACrC,KAAmC;QAEnC,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;QAlCvB;;WAEG;QACM,SAAI,GAAG,yBAAyB,CAAC;QAgCxC,IAAI,CAAC,aAAa,GAAG;YACnB,QAAQ,EAAE,MAAM;YAChB,MAAM,EAAE,EAAE;SACX,CAAC;QACF,IAAI,CAAC,YAAY,GAAG,EAAE,gBAAgB,EAAE,EAAE,EAAE,CAAC;QAC7C,IAAI,CAAC,UAAU,EAAE,CAAC;QAClB,mBAAmB,CAAC,CAAC,EAAE,MAAM,EAAE,cAAc,EAAE,EAAE,EAAE;YACjD,IAAI,CAAC,SAAS,CAAC,EAAE,MAAM,EAAE,CAAC,GAAG,MAAM,EAAE,GAAG,cAAc,CAAC,EAAE,CAAC,CAAC;YAC3D,IAAI,CAAC,cAAc,EAAE,CAAC;QACxB,CAAC,CAAC,CAAC;QACH,IAAI,CAAC,kBAAkB,GAAG,kBAAkB,CAAC;QAC7C,IAAI,CAAC,iBAAiB,GAAG,iBAAiB,CAAC;QAC3C,IAAI,CAAC,IAAI,EAAE,CAAC;IACd,CAAC;IAED;;;;OAIG;IACG,IAAI,CAAC,QAAiB;;YAC1B,QAAQ,IAAI,IAAI,CAAC,SAAS,CAAC,EAAE,QAAQ,EAAE,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;YACvD,IAAI,CAAC,MAAM,IAAI,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YACzC,MAAM,IAAA,gCAAa,EAAC,GAAG,EAAE,CAAC,IAAI,CAAC,cAAc,EAAE,CAAC,CAAC;YACjD,IAAI,CAAC,MAAM,GAAG,UAAU,CAAC,GAAG,EAAE;gBAC5B,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;YAClC,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;QAC3B,CAAC;KAAA;IAED;;OAEG;IACG,cAAc;;YAClB,IAAI,IAAI,CAAC,QAAQ,EAAE;gBACjB,OAAO;aACR;YACD,MAAM,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC;YAC/B,MAAM,mBAAmB,GAA8B,EAAE,CAAC;YAC1D,KAAK,MAAM,CAAC,IAAI,MAAM,EAAE;gBACtB,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;gBAC9B,IAAI;oBACF,mBAAmB,CAAC,OAAO,CAAC,GAAG,MAAM,IAAI,CAAC,iBAAiB,CACzD,OAAO,EACP,IAAI,CAAC,kBAAkB,EAAE,CAC1B,CAAC;oBACF,MAAM,CAAC,CAAC,CAAC,CAAC,YAAY,GAAG,IAAI,CAAC;iBAC/B;gBAAC,OAAO,KAAK,EAAE;oBACd,mBAAmB,CAAC,OAAO,CAAC,GAAG,IAAI,oBAAE,CAAC,CAAC,CAAC,CAAC;oBACzC,MAAM,CAAC,CAAC,CAAC,CAAC,YAAY,GAAG,KAAK,CAAC;iBAChC;aACF;YACD,IAAI,CAAC,MAAM,CAAC,EAAE,gBAAgB,EAAE,mBAAmB,EAAE,CAAC,CAAC;QACzD,CAAC;KAAA;CACF;AA9FD,0DA8FC;AAED,kBAAe,uBAAuB,CAAC","sourcesContent":["import type { BaseConfig, BaseState } from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport { safelyExecute } from '@metamask/controller-utils';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport { BN } from 'ethereumjs-util';\n\nimport type { AssetsContractController } from './AssetsContractController';\nimport type { Token } from './TokenRatesController';\nimport type { TokensState } from './TokensController';\n\n// TODO: Remove this export in the next major release\nexport { BN };\n\n/**\n * @type TokenBalancesConfig\n *\n * Token balances controller configuration\n * @property interval - Polling interval used to fetch new token balances\n * @property tokens - List of tokens to track balances for\n */\nexport interface TokenBalancesConfig extends BaseConfig {\n  interval: number;\n  tokens: Token[];\n}\n\n/**\n * @type TokenBalancesState\n *\n * Token balances controller state\n * @property contractBalances - Hash of token contract addresses to balances\n */\nexport interface TokenBalancesState extends BaseState {\n  contractBalances: { [address: string]: BN };\n}\n\n/**\n * Controller that passively polls on a set interval token balances\n * for tokens stored in the TokensController\n */\nexport class TokenBalancesController extends BaseController<\n  TokenBalancesConfig,\n  TokenBalancesState\n> {\n  private handle?: ReturnType<typeof setTimeout>;\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'TokenBalancesController';\n\n  private readonly getSelectedAddress: () => PreferencesState['selectedAddress'];\n\n  private readonly getERC20BalanceOf: AssetsContractController['getERC20BalanceOf'];\n\n  /**\n   * Creates a TokenBalancesController instance.\n   *\n   * @param options - The controller options.\n   * @param options.onTokensStateChange - Allows subscribing to assets controller state changes.\n   * @param options.getSelectedAddress - Gets the current selected address.\n   * @param options.getERC20BalanceOf - Gets the balance of the given account at the given contract address.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      onTokensStateChange,\n      getSelectedAddress,\n      getERC20BalanceOf,\n    }: {\n      onTokensStateChange: (\n        listener: (tokenState: TokensState) => void,\n      ) => void;\n      getSelectedAddress: () => PreferencesState['selectedAddress'];\n      getERC20BalanceOf: AssetsContractController['getERC20BalanceOf'];\n    },\n    config?: Partial<TokenBalancesConfig>,\n    state?: Partial<TokenBalancesState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      interval: 180000,\n      tokens: [],\n    };\n    this.defaultState = { contractBalances: {} };\n    this.initialize();\n    onTokensStateChange(({ tokens, detectedTokens }) => {\n      this.configure({ tokens: [...tokens, ...detectedTokens] });\n      this.updateBalances();\n    });\n    this.getSelectedAddress = getSelectedAddress;\n    this.getERC20BalanceOf = getERC20BalanceOf;\n    this.poll();\n  }\n\n  /**\n   * Starts a new polling interval.\n   *\n   * @param interval - Polling interval used to fetch new token balances.\n   */\n  async poll(interval?: number): Promise<void> {\n    interval && this.configure({ interval }, false, false);\n    this.handle && clearTimeout(this.handle);\n    await safelyExecute(() => this.updateBalances());\n    this.handle = setTimeout(() => {\n      this.poll(this.config.interval);\n    }, this.config.interval);\n  }\n\n  /**\n   * Updates balances for all tokens.\n   */\n  async updateBalances() {\n    if (this.disabled) {\n      return;\n    }\n    const { tokens } = this.config;\n    const newContractBalances: { [address: string]: BN } = {};\n    for (const i in tokens) {\n      const { address } = tokens[i];\n      try {\n        newContractBalances[address] = await this.getERC20BalanceOf(\n          address,\n          this.getSelectedAddress(),\n        );\n        tokens[i].balanceError = null;\n      } catch (error) {\n        newContractBalances[address] = new BN(0);\n        tokens[i].balanceError = error;\n      }\n    }\n    this.update({ contractBalances: newContractBalances });\n  }\n}\n\nexport default TokenBalancesController;\n"]}
\ No newline at end of file
+{"version":3,"file":"TokenBalancesController.js","sourceRoot":"","sources":["../src/TokenBalancesController.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,qDAAqC;AAa5B,mFAbA,oBAAE,OAaA;AAZX,+DAImC;AACnC,iEAA2D;AA+B3D;;;GAGG;AACH,MAAa,uBAAwB,SAAQ,gCAG5C;IAYC;;;;;;;;;OASG;IACH,YACE,EACE,mBAAmB,EACnB,kBAAkB,EAClB,iBAAiB,GAOlB,EACD,MAAqC,EACrC,KAAmC;QAEnC,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;QAlCvB;;WAEG;QACM,SAAI,GAAG,yBAAyB,CAAC;QAgCxC,IAAI,CAAC,aAAa,GAAG;YACnB,QAAQ,EAAE,MAAM;YAChB,MAAM,EAAE,EAAE;SACX,CAAC;QACF,IAAI,CAAC,YAAY,GAAG,EAAE,gBAAgB,EAAE,EAAE,EAAE,CAAC;QAC7C,IAAI,CAAC,UAAU,EAAE,CAAC;QAClB,mBAAmB,CAAC,CAAC,EAAE,MAAM,EAAE,cAAc,EAAE,EAAE,EAAE;YACjD,IAAI,CAAC,SAAS,CAAC,EAAE,MAAM,EAAE,CAAC,GAAG,MAAM,EAAE,GAAG,cAAc,CAAC,EAAE,CAAC,CAAC;YAC3D,IAAI,CAAC,cAAc,EAAE,CAAC;QACxB,CAAC,CAAC,CAAC;QACH,IAAI,CAAC,kBAAkB,GAAG,kBAAkB,CAAC;QAC7C,IAAI,CAAC,iBAAiB,GAAG,iBAAiB,CAAC;QAC3C,IAAI,CAAC,IAAI,EAAE,CAAC;IACd,CAAC;IAED;;;;OAIG;IACG,IAAI,CAAC,QAAiB;;YAC1B,QAAQ,IAAI,IAAI,CAAC,SAAS,CAAC,EAAE,QAAQ,EAAE,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;YACvD,IAAI,CAAC,MAAM,IAAI,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YACzC,MAAM,IAAA,gCAAa,EAAC,GAAG,EAAE,CAAC,IAAI,CAAC,cAAc,EAAE,CAAC,CAAC;YACjD,IAAI,CAAC,MAAM,GAAG,UAAU,CAAC,GAAG,EAAE;gBAC5B,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;YAClC,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;QAC3B,CAAC;KAAA;IAED;;OAEG;IACG,cAAc;;YAClB,IAAI,IAAI,CAAC,QAAQ,EAAE;gBACjB,OAAO;aACR;YACD,MAAM,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC;YAC/B,MAAM,mBAAmB,GAA8B,EAAE,CAAC;YAC1D,KAAK,MAAM,CAAC,IAAI,MAAM,EAAE;gBACtB,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;gBAC9B,IAAI;oBACF,mBAAmB,CAAC,OAAO,CAAC,GAAG,MAAM,IAAI,CAAC,iBAAiB,CACzD,OAAO,EACP,IAAI,CAAC,kBAAkB,EAAE,CAC1B,CAAC;oBACF,MAAM,CAAC,CAAC,CAAC,CAAC,YAAY,GAAG,IAAI,CAAC;iBAC/B;gBAAC,OAAO,KAAK,EAAE;oBACd,mBAAmB,CAAC,OAAO,CAAC,GAAG,IAAI,oBAAE,CAAC,CAAC,CAAC,CAAC;oBACzC,MAAM,CAAC,CAAC,CAAC,CAAC,YAAY,GAAG,KAAK,CAAC;iBAChC;aACF;YACD,IAAI,CAAC,MAAM,CAAC,EAAE,gBAAgB,EAAE,mBAAmB,EAAE,CAAC,CAAC;QACzD,CAAC;KAAA;CACF;AA9FD,0DA8FC;AAED,kBAAe,uBAAuB,CAAC","sourcesContent":["import { BN } from 'ethereumjs-util';\nimport {\n  BaseController,\n  BaseConfig,\n  BaseState,\n} from '@metamask/base-controller';\nimport { safelyExecute } from '@metamask/controller-utils';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport { Token } from './TokenRatesController';\nimport { TokensState } from './TokensController';\nimport type { AssetsContractController } from './AssetsContractController';\n\n// TODO: Remove this export in the next major release\nexport { BN };\n\n/**\n * @type TokenBalancesConfig\n *\n * Token balances controller configuration\n * @property interval - Polling interval used to fetch new token balances\n * @property tokens - List of tokens to track balances for\n */\nexport interface TokenBalancesConfig extends BaseConfig {\n  interval: number;\n  tokens: Token[];\n}\n\n/**\n * @type TokenBalancesState\n *\n * Token balances controller state\n * @property contractBalances - Hash of token contract addresses to balances\n */\nexport interface TokenBalancesState extends BaseState {\n  contractBalances: { [address: string]: BN };\n}\n\n/**\n * Controller that passively polls on a set interval token balances\n * for tokens stored in the TokensController\n */\nexport class TokenBalancesController extends BaseController<\n  TokenBalancesConfig,\n  TokenBalancesState\n> {\n  private handle?: ReturnType<typeof setTimeout>;\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'TokenBalancesController';\n\n  private getSelectedAddress: () => PreferencesState['selectedAddress'];\n\n  private getERC20BalanceOf: AssetsContractController['getERC20BalanceOf'];\n\n  /**\n   * Creates a TokenBalancesController instance.\n   *\n   * @param options - The controller options.\n   * @param options.onTokensStateChange - Allows subscribing to assets controller state changes.\n   * @param options.getSelectedAddress - Gets the current selected address.\n   * @param options.getERC20BalanceOf - Gets the balance of the given account at the given contract address.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      onTokensStateChange,\n      getSelectedAddress,\n      getERC20BalanceOf,\n    }: {\n      onTokensStateChange: (\n        listener: (tokenState: TokensState) => void,\n      ) => void;\n      getSelectedAddress: () => PreferencesState['selectedAddress'];\n      getERC20BalanceOf: AssetsContractController['getERC20BalanceOf'];\n    },\n    config?: Partial<TokenBalancesConfig>,\n    state?: Partial<TokenBalancesState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      interval: 180000,\n      tokens: [],\n    };\n    this.defaultState = { contractBalances: {} };\n    this.initialize();\n    onTokensStateChange(({ tokens, detectedTokens }) => {\n      this.configure({ tokens: [...tokens, ...detectedTokens] });\n      this.updateBalances();\n    });\n    this.getSelectedAddress = getSelectedAddress;\n    this.getERC20BalanceOf = getERC20BalanceOf;\n    this.poll();\n  }\n\n  /**\n   * Starts a new polling interval.\n   *\n   * @param interval - Polling interval used to fetch new token balances.\n   */\n  async poll(interval?: number): Promise<void> {\n    interval && this.configure({ interval }, false, false);\n    this.handle && clearTimeout(this.handle);\n    await safelyExecute(() => this.updateBalances());\n    this.handle = setTimeout(() => {\n      this.poll(this.config.interval);\n    }, this.config.interval);\n  }\n\n  /**\n   * Updates balances for all tokens.\n   */\n  async updateBalances() {\n    if (this.disabled) {\n      return;\n    }\n    const { tokens } = this.config;\n    const newContractBalances: { [address: string]: BN } = {};\n    for (const i in tokens) {\n      const { address } = tokens[i];\n      try {\n        newContractBalances[address] = await this.getERC20BalanceOf(\n          address,\n          this.getSelectedAddress(),\n        );\n        tokens[i].balanceError = null;\n      } catch (error) {\n        newContractBalances[address] = new BN(0);\n        tokens[i].balanceError = error;\n      }\n    }\n    this.update({ contractBalances: newContractBalances });\n  }\n}\n\nexport default TokenBalancesController;\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.mjs b/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.mjs
new file mode 100644
index 0000000..76fa250
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.mjs
@@ -0,0 +1,12 @@
+import {
+  TokenBalancesController,
+  TokenBalancesController_default,
+  getDefaultTokenBalancesState
+} from "./chunk-4LY47RPI.mjs";
+import "./chunk-XUI43LEZ.mjs";
+export {
+  TokenBalancesController,
+  TokenBalancesController_default as default,
+  getDefaultTokenBalancesState
+};
+//# sourceMappingURL=TokenBalancesController.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.mjs.map b/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.mjs.map
new file mode 100644
index 0000000..84c51b2
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/TokenBalancesController.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":[],"sourcesContent":[],"mappings":"","names":[]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.d.ts b/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.d.ts
index 5a68639..19ce677 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.d.ts
@@ -1,11 +1,10 @@
-import type { BaseConfig, BaseState } from '@metamask/base-controller';
-import { BaseController } from '@metamask/base-controller';
+import type { Hex } from '@metamask/utils';
+import { BaseController, BaseConfig, BaseState } from '@metamask/base-controller';
 import type { NetworkState } from '@metamask/network-controller';
 import type { PreferencesState } from '@metamask/preferences-controller';
-import type { Hex } from '@metamask/utils';
+import { TokensController, TokensState } from './TokensController';
 import type { AssetsContractController } from './AssetsContractController';
-import type { TokenListState } from './TokenListController';
-import type { TokensController, TokensState } from './TokensController';
+import { TokenListState } from './TokenListController';
 /**
  * @type TokenDetectionConfig
  *
@@ -32,10 +31,10 @@ export declare class TokenDetectionController extends BaseController<TokenDetect
      * Name of this controller used during composition
      */
     name: string;
-    private readonly getBalancesInSingleCall;
-    private readonly addDetectedTokens;
-    private readonly getTokensState;
-    private readonly getTokenListState;
+    private getBalancesInSingleCall;
+    private addDetectedTokens;
+    private getTokensState;
+    private getTokenListState;
     /**
      * Creates a TokenDetectionController instance.
      *
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.d.ts.map b/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.d.ts.map
index b409aa1..5b22dbb 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.d.ts.map
+++ b/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"TokenDetectionController.d.ts","sourceRoot":"","sources":["../src/TokenDetectionController.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,UAAU,EAAE,SAAS,EAAE,MAAM,2BAA2B,CAAC;AACvE,OAAO,EAAE,cAAc,EAAE,MAAM,2BAA2B,CAAC;AAK3D,OAAO,KAAK,EAAE,YAAY,EAAE,MAAM,8BAA8B,CAAC;AACjE,OAAO,KAAK,EAAE,gBAAgB,EAAE,MAAM,kCAAkC,CAAC;AACzE,OAAO,KAAK,EAAE,GAAG,EAAE,MAAM,iBAAiB,CAAC;AAE3C,OAAO,KAAK,EAAE,wBAAwB,EAAE,MAAM,4BAA4B,CAAC;AAE3E,OAAO,KAAK,EAAE,cAAc,EAAE,MAAM,uBAAuB,CAAC;AAE5D,OAAO,KAAK,EAAE,gBAAgB,EAAE,WAAW,EAAE,MAAM,oBAAoB,CAAC;AAIxE;;;;;;;;;GASG;AACH,MAAM,WAAW,oBAAqB,SAAQ,UAAU;IACtD,QAAQ,EAAE,MAAM,CAAC;IACjB,eAAe,EAAE,MAAM,CAAC;IACxB,OAAO,EAAE,GAAG,CAAC;IACb,iCAAiC,EAAE,OAAO,CAAC;IAC3C,4BAA4B,EAAE,OAAO,CAAC;CACvC;AAED;;GAEG;AACH,qBAAa,wBAAyB,SAAQ,cAAc,CAC1D,oBAAoB,EACpB,SAAS,CACV;IACC,OAAO,CAAC,UAAU,CAAC,CAAgC;IAEnD;;OAEG;IACM,IAAI,SAA8B;IAE3C,OAAO,CAAC,QAAQ,CAAC,uBAAuB,CAAsD;IAE9F,OAAO,CAAC,QAAQ,CAAC,iBAAiB,CAAwC;IAE1E,OAAO,CAAC,QAAQ,CAAC,cAAc,CAAoB;IAEnD,OAAO,CAAC,QAAQ,CAAC,iBAAiB,CAAuB;IAEzD;;;;;;;;;;;;;;;OAeG;gBAED,EACE,wBAAwB,EACxB,oBAAoB,EACpB,sBAAsB,EACtB,uBAAuB,EACvB,iBAAiB,EACjB,iBAAiB,EACjB,cAAc,EACd,eAAe,EACf,mBAAmB,GACpB,EAAE;QACD,wBAAwB,EAAE,CACxB,QAAQ,EAAE,CAAC,gBAAgB,EAAE,gBAAgB,KAAK,IAAI,KACnD,IAAI,CAAC;QACV,oBAAoB,EAAE,CACpB,QAAQ,EAAE,CAAC,YAAY,EAAE,YAAY,KAAK,IAAI,KAC3C,IAAI,CAAC;QACV,sBAAsB,EAAE,CACtB,QAAQ,EAAE,CAAC,cAAc,EAAE,cAAc,KAAK,IAAI,KAC/C,IAAI,CAAC;QACV,uBAAuB,EAAE,wBAAwB,CAAC,yBAAyB,CAAC,CAAC;QAC7E,iBAAiB,EAAE,gBAAgB,CAAC,mBAAmB,CAAC,CAAC;QACzD,iBAAiB,EAAE,MAAM,cAAc,CAAC;QACxC,cAAc,EAAE,MAAM,WAAW,CAAC;QAClC,eAAe,EAAE,MAAM,YAAY,CAAC;QACpC,mBAAmB,EAAE,MAAM,gBAAgB,CAAC;KAC7C,EACD,MAAM,CAAC,EAAE,OAAO,CAAC,oBAAoB,CAAC,EACtC,KAAK,CAAC,EAAE,OAAO,CAAC,SAAS,CAAC;IA0E5B;;OAEG;IACG,KAAK;IAKX;;OAEG;IACH,IAAI;IAKJ,OAAO,CAAC,WAAW;IAMnB;;;;OAIG;YACW,YAAY;IAS1B;;OAEG;IACG,YAAY;CAwFnB;AAED,eAAe,wBAAwB,CAAC"}
\ No newline at end of file
+{"version":3,"file":"TokenDetectionController.d.ts","sourceRoot":"","sources":["../src/TokenDetectionController.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,GAAG,EAAE,MAAM,iBAAiB,CAAC;AAC3C,OAAO,EACL,cAAc,EACd,UAAU,EACV,SAAS,EACV,MAAM,2BAA2B,CAAC;AACnC,OAAO,KAAK,EAAE,YAAY,EAAE,MAAM,8BAA8B,CAAC;AACjE,OAAO,KAAK,EAAE,gBAAgB,EAAE,MAAM,kCAAkC,CAAC;AAMzE,OAAO,EAAE,gBAAgB,EAAE,WAAW,EAAE,MAAM,oBAAoB,CAAC;AACnE,OAAO,KAAK,EAAE,wBAAwB,EAAE,MAAM,4BAA4B,CAAC;AAE3E,OAAO,EAAE,cAAc,EAAE,MAAM,uBAAuB,CAAC;AAIvD;;;;;;;;;GASG;AACH,MAAM,WAAW,oBAAqB,SAAQ,UAAU;IACtD,QAAQ,EAAE,MAAM,CAAC;IACjB,eAAe,EAAE,MAAM,CAAC;IACxB,OAAO,EAAE,GAAG,CAAC;IACb,iCAAiC,EAAE,OAAO,CAAC;IAC3C,4BAA4B,EAAE,OAAO,CAAC;CACvC;AAED;;GAEG;AACH,qBAAa,wBAAyB,SAAQ,cAAc,CAC1D,oBAAoB,EACpB,SAAS,CACV;IACC,OAAO,CAAC,UAAU,CAAC,CAAgC;IAEnD;;OAEG;IACM,IAAI,SAA8B;IAE3C,OAAO,CAAC,uBAAuB,CAAsD;IAErF,OAAO,CAAC,iBAAiB,CAAwC;IAEjE,OAAO,CAAC,cAAc,CAAoB;IAE1C,OAAO,CAAC,iBAAiB,CAAuB;IAEhD;;;;;;;;;;;;;;;OAeG;gBAED,EACE,wBAAwB,EACxB,oBAAoB,EACpB,sBAAsB,EACtB,uBAAuB,EACvB,iBAAiB,EACjB,iBAAiB,EACjB,cAAc,EACd,eAAe,EACf,mBAAmB,GACpB,EAAE;QACD,wBAAwB,EAAE,CACxB,QAAQ,EAAE,CAAC,gBAAgB,EAAE,gBAAgB,KAAK,IAAI,KACnD,IAAI,CAAC;QACV,oBAAoB,EAAE,CACpB,QAAQ,EAAE,CAAC,YAAY,EAAE,YAAY,KAAK,IAAI,KAC3C,IAAI,CAAC;QACV,sBAAsB,EAAE,CACtB,QAAQ,EAAE,CAAC,cAAc,EAAE,cAAc,KAAK,IAAI,KAC/C,IAAI,CAAC;QACV,uBAAuB,EAAE,wBAAwB,CAAC,yBAAyB,CAAC,CAAC;QAC7E,iBAAiB,EAAE,gBAAgB,CAAC,mBAAmB,CAAC,CAAC;QACzD,iBAAiB,EAAE,MAAM,cAAc,CAAC;QACxC,cAAc,EAAE,MAAM,WAAW,CAAC;QAClC,eAAe,EAAE,MAAM,YAAY,CAAC;QACpC,mBAAmB,EAAE,MAAM,gBAAgB,CAAC;KAC7C,EACD,MAAM,CAAC,EAAE,OAAO,CAAC,oBAAoB,CAAC,EACtC,KAAK,CAAC,EAAE,OAAO,CAAC,SAAS,CAAC;IA0E5B;;OAEG;IACG,KAAK;IAKX;;OAEG;IACH,IAAI;IAKJ,OAAO,CAAC,WAAW;IAMnB;;;;OAIG;YACW,YAAY;IAS1B;;OAEG;IACG,YAAY;CAwFnB;AAED,eAAe,wBAAwB,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.js.map b/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.js.map
index a268d3b..402d52b 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.js.map
+++ b/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.js.map
@@ -1 +1 @@
-{"version":3,"file":"TokenDetectionController.js","sourceRoot":"","sources":["../src/TokenDetectionController.ts"],"names":[],"mappings":"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","sourcesContent":["import type { BaseConfig, BaseState } from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport {\n  safelyExecute,\n  toChecksumHexAddress,\n} from '@metamask/controller-utils';\nimport type { NetworkState } from '@metamask/network-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport type { Hex } from '@metamask/utils';\n\nimport type { AssetsContractController } from './AssetsContractController';\nimport { isTokenDetectionSupportedForNetwork } from './assetsUtil';\nimport type { TokenListState } from './TokenListController';\nimport type { Token } from './TokenRatesController';\nimport type { TokensController, TokensState } from './TokensController';\n\nconst DEFAULT_INTERVAL = 180000;\n\n/**\n * @type TokenDetectionConfig\n *\n * TokenDetection configuration\n * @property interval - Polling interval used to fetch new token rates\n * @property selectedAddress - Vault selected address\n * @property chainId - The chain ID of the current network\n * @property isDetectionEnabledFromPreferences - Boolean to track if detection is enabled from PreferencesController\n * @property isDetectionEnabledForNetwork - Boolean to track if detected is enabled for current network\n */\nexport interface TokenDetectionConfig extends BaseConfig {\n  interval: number;\n  selectedAddress: string;\n  chainId: Hex;\n  isDetectionEnabledFromPreferences: boolean;\n  isDetectionEnabledForNetwork: boolean;\n}\n\n/**\n * Controller that passively polls on a set interval for Tokens auto detection\n */\nexport class TokenDetectionController extends BaseController<\n  TokenDetectionConfig,\n  BaseState\n> {\n  private intervalId?: ReturnType<typeof setTimeout>;\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'TokenDetectionController';\n\n  private readonly getBalancesInSingleCall: AssetsContractController['getBalancesInSingleCall'];\n\n  private readonly addDetectedTokens: TokensController['addDetectedTokens'];\n\n  private readonly getTokensState: () => TokensState;\n\n  private readonly getTokenListState: () => TokenListState;\n\n  /**\n   * Creates a TokenDetectionController instance.\n   *\n   * @param options - The controller options.\n   * @param options.onPreferencesStateChange - Allows subscribing to preferences controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param options.onTokenListStateChange - Allows subscribing to token list controller state changes.\n   * @param options.getBalancesInSingleCall - Gets the balances of a list of tokens for the given address.\n   * @param options.addDetectedTokens - Add a list of detected tokens.\n   * @param options.getTokenListState - Gets the current state of the TokenList controller.\n   * @param options.getTokensState - Gets the current state of the Tokens controller.\n   * @param options.getNetworkState - Gets the state of the network controller.\n   * @param options.getPreferencesState - Gets the state of the preferences controller.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      onPreferencesStateChange,\n      onNetworkStateChange,\n      onTokenListStateChange,\n      getBalancesInSingleCall,\n      addDetectedTokens,\n      getTokenListState,\n      getTokensState,\n      getNetworkState,\n      getPreferencesState,\n    }: {\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      onTokenListStateChange: (\n        listener: (tokenListState: TokenListState) => void,\n      ) => void;\n      getBalancesInSingleCall: AssetsContractController['getBalancesInSingleCall'];\n      addDetectedTokens: TokensController['addDetectedTokens'];\n      getTokenListState: () => TokenListState;\n      getTokensState: () => TokensState;\n      getNetworkState: () => NetworkState;\n      getPreferencesState: () => PreferencesState;\n    },\n    config?: Partial<TokenDetectionConfig>,\n    state?: Partial<BaseState>,\n  ) {\n    const {\n      providerConfig: { chainId: defaultChainId },\n    } = getNetworkState();\n    const { useTokenDetection: defaultUseTokenDetection } =\n      getPreferencesState();\n\n    super(config, state);\n    this.defaultConfig = {\n      interval: DEFAULT_INTERVAL,\n      selectedAddress: '',\n      disabled: true,\n      chainId: defaultChainId,\n      isDetectionEnabledFromPreferences: defaultUseTokenDetection,\n      isDetectionEnabledForNetwork:\n        isTokenDetectionSupportedForNetwork(defaultChainId),\n      ...config,\n    };\n\n    this.initialize();\n    this.getTokensState = getTokensState;\n    this.getTokenListState = getTokenListState;\n    this.addDetectedTokens = addDetectedTokens;\n    this.getBalancesInSingleCall = getBalancesInSingleCall;\n\n    onTokenListStateChange(({ tokenList }) => {\n      const hasTokens = Object.keys(tokenList).length;\n\n      if (hasTokens) {\n        this.detectTokens();\n      }\n    });\n\n    onPreferencesStateChange(({ selectedAddress, useTokenDetection }) => {\n      const {\n        selectedAddress: currentSelectedAddress,\n        isDetectionEnabledFromPreferences,\n      } = this.config;\n      const isSelectedAddressChanged =\n        selectedAddress !== currentSelectedAddress;\n      const isDetectionChangedFromPreferences =\n        isDetectionEnabledFromPreferences !== useTokenDetection;\n\n      this.configure({\n        isDetectionEnabledFromPreferences: useTokenDetection,\n        selectedAddress,\n      });\n\n      if (\n        useTokenDetection &&\n        (isSelectedAddressChanged || isDetectionChangedFromPreferences)\n      ) {\n        this.detectTokens();\n      }\n    });\n\n    onNetworkStateChange(({ providerConfig: { chainId } }) => {\n      const { chainId: currentChainId } = this.config;\n      const isDetectionEnabledForNetwork =\n        isTokenDetectionSupportedForNetwork(chainId);\n      const isChainIdChanged = currentChainId !== chainId;\n\n      this.configure({\n        chainId,\n        isDetectionEnabledForNetwork,\n      });\n\n      if (isDetectionEnabledForNetwork && isChainIdChanged) {\n        this.detectTokens();\n      }\n    });\n  }\n\n  /**\n   * Start polling for detected tokens.\n   */\n  async start() {\n    this.configure({ disabled: false });\n    await this.startPolling();\n  }\n\n  /**\n   * Stop polling for detected tokens.\n   */\n  stop() {\n    this.configure({ disabled: true });\n    this.stopPolling();\n  }\n\n  private stopPolling() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n  }\n\n  /**\n   * Starts a new polling interval.\n   *\n   * @param interval - An interval on which to poll.\n   */\n  private async startPolling(interval?: number): Promise<void> {\n    interval && this.configure({ interval }, false, false);\n    this.stopPolling();\n    await this.detectTokens();\n    this.intervalId = setInterval(async () => {\n      await this.detectTokens();\n    }, this.config.interval);\n  }\n\n  /**\n   * Triggers asset ERC20 token auto detection for each contract address in contract metadata on mainnet.\n   */\n  async detectTokens() {\n    const {\n      disabled,\n      isDetectionEnabledForNetwork,\n      isDetectionEnabledFromPreferences,\n    } = this.config;\n    if (\n      disabled ||\n      !isDetectionEnabledForNetwork ||\n      !isDetectionEnabledFromPreferences\n    ) {\n      return;\n    }\n    const { tokens } = this.getTokensState();\n    const { selectedAddress, chainId } = this.config;\n\n    const tokensAddresses = tokens.map(\n      /* istanbul ignore next*/ (token) => token.address.toLowerCase(),\n    );\n    const { tokenList } = this.getTokenListState();\n    const tokensToDetect: string[] = [];\n    for (const address in tokenList) {\n      if (!tokensAddresses.includes(address)) {\n        tokensToDetect.push(address);\n      }\n    }\n    const sliceOfTokensToDetect = [];\n    sliceOfTokensToDetect[0] = tokensToDetect.slice(0, 1000);\n    sliceOfTokensToDetect[1] = tokensToDetect.slice(\n      1000,\n      tokensToDetect.length - 1,\n    );\n\n    /* istanbul ignore else */\n    if (!selectedAddress) {\n      return;\n    }\n\n    for (const tokensSlice of sliceOfTokensToDetect) {\n      if (tokensSlice.length === 0) {\n        break;\n      }\n\n      await safelyExecute(async () => {\n        const balances = await this.getBalancesInSingleCall(\n          selectedAddress,\n          tokensSlice,\n        );\n        const tokensToAdd: Token[] = [];\n        for (const tokenAddress in balances) {\n          let ignored;\n          /* istanbul ignore else */\n          const { ignoredTokens } = this.getTokensState();\n          if (ignoredTokens.length) {\n            ignored = ignoredTokens.find(\n              (ignoredTokenAddress) =>\n                ignoredTokenAddress === toChecksumHexAddress(tokenAddress),\n            );\n          }\n          const caseInsensitiveTokenKey =\n            Object.keys(tokenList).find(\n              (i) => i.toLowerCase() === tokenAddress.toLowerCase(),\n            ) || '';\n\n          if (ignored === undefined) {\n            const { decimals, symbol, aggregators, iconUrl, name } =\n              tokenList[caseInsensitiveTokenKey];\n            tokensToAdd.push({\n              address: tokenAddress,\n              decimals,\n              symbol,\n              aggregators,\n              image: iconUrl,\n              isERC721: false,\n              name,\n            });\n          }\n        }\n\n        if (tokensToAdd.length) {\n          await this.addDetectedTokens(tokensToAdd, {\n            selectedAddress,\n            chainId,\n          });\n        }\n      });\n    }\n  }\n}\n\nexport default TokenDetectionController;\n"]}
\ No newline at end of file
+{"version":3,"file":"TokenDetectionController.js","sourceRoot":"","sources":["../src/TokenDetectionController.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Hex } from '@metamask/utils';\nimport {\n  BaseController,\n  BaseConfig,\n  BaseState,\n} from '@metamask/base-controller';\nimport type { NetworkState } from '@metamask/network-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport {\n  safelyExecute,\n  toChecksumHexAddress,\n} from '@metamask/controller-utils';\nimport { isTokenDetectionSupportedForNetwork } from './assetsUtil';\nimport { TokensController, TokensState } from './TokensController';\nimport type { AssetsContractController } from './AssetsContractController';\nimport { Token } from './TokenRatesController';\nimport { TokenListState } from './TokenListController';\n\nconst DEFAULT_INTERVAL = 180000;\n\n/**\n * @type TokenDetectionConfig\n *\n * TokenDetection configuration\n * @property interval - Polling interval used to fetch new token rates\n * @property selectedAddress - Vault selected address\n * @property chainId - The chain ID of the current network\n * @property isDetectionEnabledFromPreferences - Boolean to track if detection is enabled from PreferencesController\n * @property isDetectionEnabledForNetwork - Boolean to track if detected is enabled for current network\n */\nexport interface TokenDetectionConfig extends BaseConfig {\n  interval: number;\n  selectedAddress: string;\n  chainId: Hex;\n  isDetectionEnabledFromPreferences: boolean;\n  isDetectionEnabledForNetwork: boolean;\n}\n\n/**\n * Controller that passively polls on a set interval for Tokens auto detection\n */\nexport class TokenDetectionController extends BaseController<\n  TokenDetectionConfig,\n  BaseState\n> {\n  private intervalId?: ReturnType<typeof setTimeout>;\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'TokenDetectionController';\n\n  private getBalancesInSingleCall: AssetsContractController['getBalancesInSingleCall'];\n\n  private addDetectedTokens: TokensController['addDetectedTokens'];\n\n  private getTokensState: () => TokensState;\n\n  private getTokenListState: () => TokenListState;\n\n  /**\n   * Creates a TokenDetectionController instance.\n   *\n   * @param options - The controller options.\n   * @param options.onPreferencesStateChange - Allows subscribing to preferences controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param options.onTokenListStateChange - Allows subscribing to token list controller state changes.\n   * @param options.getBalancesInSingleCall - Gets the balances of a list of tokens for the given address.\n   * @param options.addDetectedTokens - Add a list of detected tokens.\n   * @param options.getTokenListState - Gets the current state of the TokenList controller.\n   * @param options.getTokensState - Gets the current state of the Tokens controller.\n   * @param options.getNetworkState - Gets the state of the network controller.\n   * @param options.getPreferencesState - Gets the state of the preferences controller.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      onPreferencesStateChange,\n      onNetworkStateChange,\n      onTokenListStateChange,\n      getBalancesInSingleCall,\n      addDetectedTokens,\n      getTokenListState,\n      getTokensState,\n      getNetworkState,\n      getPreferencesState,\n    }: {\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      onTokenListStateChange: (\n        listener: (tokenListState: TokenListState) => void,\n      ) => void;\n      getBalancesInSingleCall: AssetsContractController['getBalancesInSingleCall'];\n      addDetectedTokens: TokensController['addDetectedTokens'];\n      getTokenListState: () => TokenListState;\n      getTokensState: () => TokensState;\n      getNetworkState: () => NetworkState;\n      getPreferencesState: () => PreferencesState;\n    },\n    config?: Partial<TokenDetectionConfig>,\n    state?: Partial<BaseState>,\n  ) {\n    const {\n      providerConfig: { chainId: defaultChainId },\n    } = getNetworkState();\n    const { useTokenDetection: defaultUseTokenDetection } =\n      getPreferencesState();\n\n    super(config, state);\n    this.defaultConfig = {\n      interval: DEFAULT_INTERVAL,\n      selectedAddress: '',\n      disabled: true,\n      chainId: defaultChainId,\n      isDetectionEnabledFromPreferences: defaultUseTokenDetection,\n      isDetectionEnabledForNetwork:\n        isTokenDetectionSupportedForNetwork(defaultChainId),\n      ...config,\n    };\n\n    this.initialize();\n    this.getTokensState = getTokensState;\n    this.getTokenListState = getTokenListState;\n    this.addDetectedTokens = addDetectedTokens;\n    this.getBalancesInSingleCall = getBalancesInSingleCall;\n\n    onTokenListStateChange(({ tokenList }) => {\n      const hasTokens = Object.keys(tokenList).length;\n\n      if (hasTokens) {\n        this.detectTokens();\n      }\n    });\n\n    onPreferencesStateChange(({ selectedAddress, useTokenDetection }) => {\n      const {\n        selectedAddress: currentSelectedAddress,\n        isDetectionEnabledFromPreferences,\n      } = this.config;\n      const isSelectedAddressChanged =\n        selectedAddress !== currentSelectedAddress;\n      const isDetectionChangedFromPreferences =\n        isDetectionEnabledFromPreferences !== useTokenDetection;\n\n      this.configure({\n        isDetectionEnabledFromPreferences: useTokenDetection,\n        selectedAddress,\n      });\n\n      if (\n        useTokenDetection &&\n        (isSelectedAddressChanged || isDetectionChangedFromPreferences)\n      ) {\n        this.detectTokens();\n      }\n    });\n\n    onNetworkStateChange(({ providerConfig: { chainId } }) => {\n      const { chainId: currentChainId } = this.config;\n      const isDetectionEnabledForNetwork =\n        isTokenDetectionSupportedForNetwork(chainId);\n      const isChainIdChanged = currentChainId !== chainId;\n\n      this.configure({\n        chainId,\n        isDetectionEnabledForNetwork,\n      });\n\n      if (isDetectionEnabledForNetwork && isChainIdChanged) {\n        this.detectTokens();\n      }\n    });\n  }\n\n  /**\n   * Start polling for detected tokens.\n   */\n  async start() {\n    this.configure({ disabled: false });\n    await this.startPolling();\n  }\n\n  /**\n   * Stop polling for detected tokens.\n   */\n  stop() {\n    this.configure({ disabled: true });\n    this.stopPolling();\n  }\n\n  private stopPolling() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n  }\n\n  /**\n   * Starts a new polling interval.\n   *\n   * @param interval - An interval on which to poll.\n   */\n  private async startPolling(interval?: number): Promise<void> {\n    interval && this.configure({ interval }, false, false);\n    this.stopPolling();\n    await this.detectTokens();\n    this.intervalId = setInterval(async () => {\n      await this.detectTokens();\n    }, this.config.interval);\n  }\n\n  /**\n   * Triggers asset ERC20 token auto detection for each contract address in contract metadata on mainnet.\n   */\n  async detectTokens() {\n    const {\n      disabled,\n      isDetectionEnabledForNetwork,\n      isDetectionEnabledFromPreferences,\n    } = this.config;\n    if (\n      disabled ||\n      !isDetectionEnabledForNetwork ||\n      !isDetectionEnabledFromPreferences\n    ) {\n      return;\n    }\n    const { tokens } = this.getTokensState();\n    const { selectedAddress, chainId } = this.config;\n\n    const tokensAddresses = tokens.map(\n      /* istanbul ignore next*/ (token) => token.address.toLowerCase(),\n    );\n    const { tokenList } = this.getTokenListState();\n    const tokensToDetect: string[] = [];\n    for (const address in tokenList) {\n      if (!tokensAddresses.includes(address)) {\n        tokensToDetect.push(address);\n      }\n    }\n    const sliceOfTokensToDetect = [];\n    sliceOfTokensToDetect[0] = tokensToDetect.slice(0, 1000);\n    sliceOfTokensToDetect[1] = tokensToDetect.slice(\n      1000,\n      tokensToDetect.length - 1,\n    );\n\n    /* istanbul ignore else */\n    if (!selectedAddress) {\n      return;\n    }\n\n    for (const tokensSlice of sliceOfTokensToDetect) {\n      if (tokensSlice.length === 0) {\n        break;\n      }\n\n      await safelyExecute(async () => {\n        const balances = await this.getBalancesInSingleCall(\n          selectedAddress,\n          tokensSlice,\n        );\n        const tokensToAdd: Token[] = [];\n        for (const tokenAddress in balances) {\n          let ignored;\n          /* istanbul ignore else */\n          const { ignoredTokens } = this.getTokensState();\n          if (ignoredTokens.length) {\n            ignored = ignoredTokens.find(\n              (ignoredTokenAddress) =>\n                ignoredTokenAddress === toChecksumHexAddress(tokenAddress),\n            );\n          }\n          const caseInsensitiveTokenKey =\n            Object.keys(tokenList).find(\n              (i) => i.toLowerCase() === tokenAddress.toLowerCase(),\n            ) || '';\n\n          if (ignored === undefined) {\n            const { decimals, symbol, aggregators, iconUrl, name } =\n              tokenList[caseInsensitiveTokenKey];\n            tokensToAdd.push({\n              address: tokenAddress,\n              decimals,\n              symbol,\n              aggregators,\n              image: iconUrl,\n              isERC721: false,\n              name,\n            });\n          }\n        }\n\n        if (tokensToAdd.length) {\n          await this.addDetectedTokens(tokensToAdd, {\n            selectedAddress,\n            chainId,\n          });\n        }\n      });\n    }\n  }\n}\n\nexport default TokenDetectionController;\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.mjs b/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.mjs
new file mode 100644
index 0000000..7180d6f
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.mjs
@@ -0,0 +1,17 @@
+import {
+  STATIC_MAINNET_TOKEN_LIST,
+  TokenDetectionController,
+  TokenDetectionController_default,
+  controllerName,
+  isEqualCaseInsensitive
+} from "./chunk-ZKJSG4TA.mjs";
+import "./chunk-E5PIGGYR.mjs";
+import "./chunk-XUI43LEZ.mjs";
+export {
+  STATIC_MAINNET_TOKEN_LIST,
+  TokenDetectionController,
+  controllerName,
+  TokenDetectionController_default as default,
+  isEqualCaseInsensitive
+};
+//# sourceMappingURL=TokenDetectionController.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.mjs.map b/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.mjs.map
new file mode 100644
index 0000000..84c51b2
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/TokenDetectionController.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":[],"sourcesContent":[],"mappings":"","names":[]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenListController.d.ts b/node_modules/@metamask/assets-controllers/dist/TokenListController.d.ts
index f5a45d2..0b89d72 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenListController.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/TokenListController.d.ts
@@ -1,8 +1,7 @@
-import type { RestrictedControllerMessenger } from '@metamask/base-controller';
-import { BaseControllerV2 } from '@metamask/base-controller';
-import type { NetworkControllerStateChangeEvent, NetworkState } from '@metamask/network-controller';
-import type { Hex } from '@metamask/utils';
 import type { Patch } from 'immer';
+import type { Hex } from '@metamask/utils';
+import { BaseControllerV2, RestrictedControllerMessenger } from '@metamask/base-controller';
+import { NetworkControllerStateChangeEvent, NetworkState } from '@metamask/network-controller';
 declare const name = "TokenListController";
 export declare type TokenListToken = {
     name: string;
@@ -40,10 +39,10 @@ declare type TokenListMessenger = RestrictedControllerMessenger<typeof name, Get
  */
 export declare class TokenListController extends BaseControllerV2<typeof name, TokenListState, TokenListMessenger> {
     #private;
-    private readonly mutex;
+    private mutex;
     private intervalId?;
-    private readonly intervalDelay;
-    private readonly cacheRefreshThreshold;
+    private intervalDelay;
+    private cacheRefreshThreshold;
     private chainId;
     private abortController;
     /**
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenListController.d.ts.map b/node_modules/@metamask/assets-controllers/dist/TokenListController.d.ts.map
index 5b7e566..a71c7bd 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenListController.d.ts.map
+++ b/node_modules/@metamask/assets-controllers/dist/TokenListController.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"TokenListController.d.ts","sourceRoot":"","sources":["../src/TokenListController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"TokenListController.d.ts","sourceRoot":"","sources":["../src/TokenListController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenListController.js b/node_modules/@metamask/assets-controllers/dist/TokenListController.js
index 8db4912..a5cb35d 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenListController.js
+++ b/node_modules/@metamask/assets-controllers/dist/TokenListController.js
@@ -16,10 +16,10 @@ var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (
 var _TokenListController_instances, _TokenListController_onNetworkControllerStateChange;
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.TokenListController = void 0;
+const async_mutex_1 = require("async-mutex");
+const abort_controller_1 = require("abort-controller");
 const base_controller_1 = require("@metamask/base-controller");
 const controller_utils_1 = require("@metamask/controller-utils");
-const abort_controller_1 = require("abort-controller");
-const async_mutex_1 = require("async-mutex");
 const assetsUtil_1 = require("./assetsUtil");
 const token_service_1 = require("./token-service");
 const DEFAULT_INTERVAL = 24 * 60 * 60 * 1000;
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenListController.js.map b/node_modules/@metamask/assets-controllers/dist/TokenListController.js.map
index c7d8ce1..133c5fe 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenListController.js.map
+++ b/node_modules/@metamask/assets-controllers/dist/TokenListController.js.map
@@ -1 +1 @@
-{"version":3,"file":"TokenListController.js","sourceRoot":"","sources":["../src/TokenListController.ts"],"names":[],"mappings":"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","sourcesContent":["import type { RestrictedControllerMessenger } from '@metamask/base-controller';\nimport { BaseControllerV2 } from '@metamask/base-controller';\nimport { safelyExecute } from '@metamask/controller-utils';\nimport type {\n  NetworkControllerStateChangeEvent,\n  NetworkState,\n} from '@metamask/network-controller';\nimport type { Hex } from '@metamask/utils';\nimport { AbortController as WhatwgAbortController } from 'abort-controller';\nimport { Mutex } from 'async-mutex';\nimport type { Patch } from 'immer';\n\nimport {\n  isTokenListSupportedForNetwork,\n  formatAggregatorNames,\n  formatIconUrlWithProxy,\n} from './assetsUtil';\nimport { fetchTokenList } from './token-service';\n\nconst DEFAULT_INTERVAL = 24 * 60 * 60 * 1000;\nconst DEFAULT_THRESHOLD = 24 * 60 * 60 * 1000;\n\nconst name = 'TokenListController';\n\nexport type TokenListToken = {\n  name: string;\n  symbol: string;\n  decimals: number;\n  address: string;\n  occurrences: number;\n  aggregators: string[];\n  iconUrl: string;\n};\n\nexport type TokenListMap = Record<string, TokenListToken>;\n\ntype DataCache = {\n  timestamp: number;\n  data: TokenListMap;\n};\ntype TokensChainsCache = {\n  [chainId: Hex]: DataCache;\n};\n\nexport type TokenListState = {\n  tokenList: TokenListMap;\n  tokensChainsCache: TokensChainsCache;\n  preventPollingOnNetworkRestart: boolean;\n};\n\nexport type TokenListStateChange = {\n  type: `${typeof name}:stateChange`;\n  payload: [TokenListState, Patch[]];\n};\n\nexport type GetTokenListState = {\n  type: `${typeof name}:getState`;\n  handler: () => TokenListState;\n};\n\ntype TokenListMessenger = RestrictedControllerMessenger<\n  typeof name,\n  GetTokenListState,\n  TokenListStateChange | NetworkControllerStateChangeEvent,\n  never,\n  TokenListStateChange['type'] | NetworkControllerStateChangeEvent['type']\n>;\n\nconst metadata = {\n  tokenList: { persist: true, anonymous: true },\n  tokensChainsCache: { persist: true, anonymous: true },\n  preventPollingOnNetworkRestart: { persist: true, anonymous: true },\n};\n\nconst defaultState: TokenListState = {\n  tokenList: {},\n  tokensChainsCache: {},\n  preventPollingOnNetworkRestart: false,\n};\n\n/**\n * Controller that passively polls on a set interval for the list of tokens from metaswaps api\n */\nexport class TokenListController extends BaseControllerV2<\n  typeof name,\n  TokenListState,\n  TokenListMessenger\n> {\n  private readonly mutex = new Mutex();\n\n  private intervalId?: ReturnType<typeof setTimeout>;\n\n  private readonly intervalDelay: number;\n\n  private readonly cacheRefreshThreshold: number;\n\n  private chainId: Hex;\n\n  private abortController: WhatwgAbortController;\n\n  /**\n   * Creates a TokenListController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.onNetworkStateChange - A function for registering an event handler for network state changes.\n   * @param options.interval - The polling interval, in milliseconds.\n   * @param options.cacheRefreshThreshold - The token cache expiry time, in milliseconds.\n   * @param options.messenger - A restricted controller messenger.\n   * @param options.state - Initial state to set on this controller.\n   * @param options.preventPollingOnNetworkRestart - Determines whether to prevent poilling on network restart in extension.\n   */\n  constructor({\n    chainId,\n    preventPollingOnNetworkRestart = false,\n    onNetworkStateChange,\n    interval = DEFAULT_INTERVAL,\n    cacheRefreshThreshold = DEFAULT_THRESHOLD,\n    messenger,\n    state,\n  }: {\n    chainId: Hex;\n    preventPollingOnNetworkRestart?: boolean;\n    onNetworkStateChange?: (\n      listener: (networkState: NetworkState) => void,\n    ) => void;\n    interval?: number;\n    cacheRefreshThreshold?: number;\n    messenger: TokenListMessenger;\n    state?: Partial<TokenListState>;\n  }) {\n    super({\n      name,\n      metadata,\n      messenger,\n      state: { ...defaultState, ...state },\n    });\n    this.intervalDelay = interval;\n    this.cacheRefreshThreshold = cacheRefreshThreshold;\n    this.chainId = chainId;\n    this.updatePreventPollingOnNetworkRestart(preventPollingOnNetworkRestart);\n    this.abortController = new WhatwgAbortController();\n    if (onNetworkStateChange) {\n      onNetworkStateChange(async (networkControllerState) => {\n        await this.#onNetworkControllerStateChange(networkControllerState);\n      });\n    } else {\n      this.messagingSystem.subscribe(\n        'NetworkController:stateChange',\n        async (networkControllerState) => {\n          await this.#onNetworkControllerStateChange(networkControllerState);\n        },\n      );\n    }\n  }\n\n  /**\n   * Updates state and restarts polling on changes to the network controller\n   * state.\n   *\n   * @param networkControllerState - The updated network controller state.\n   */\n  async #onNetworkControllerStateChange(networkControllerState: NetworkState) {\n    if (this.chainId !== networkControllerState.providerConfig.chainId) {\n      this.abortController.abort();\n      this.abortController = new WhatwgAbortController();\n      this.chainId = networkControllerState.providerConfig.chainId;\n      if (this.state.preventPollingOnNetworkRestart) {\n        this.clearingTokenListData();\n      } else {\n        // Ensure tokenList is referencing data from correct network\n        this.update(() => {\n          return {\n            ...this.state,\n            tokenList: this.state.tokensChainsCache[this.chainId]?.data || {},\n          };\n        });\n        await this.restart();\n      }\n    }\n  }\n\n  /**\n   * Start polling for the token list.\n   */\n  async start() {\n    if (!isTokenListSupportedForNetwork(this.chainId)) {\n      return;\n    }\n    await this.startPolling();\n  }\n\n  /**\n   * Restart polling for the token list.\n   */\n  async restart() {\n    this.stopPolling();\n    await this.startPolling();\n  }\n\n  /**\n   * Stop polling for the token list.\n   */\n  stop() {\n    this.stopPolling();\n  }\n\n  /**\n   * Prepare to discard this controller.\n   *\n   * This stops any active polling.\n   */\n  override destroy() {\n    super.destroy();\n    this.stopPolling();\n  }\n\n  private stopPolling() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n  }\n\n  /**\n   * Starts a new polling interval.\n   */\n  private async startPolling(): Promise<void> {\n    await safelyExecute(() => this.fetchTokenList());\n    this.intervalId = setInterval(async () => {\n      await safelyExecute(() => this.fetchTokenList());\n    }, this.intervalDelay);\n  }\n\n  /**\n   * Fetching token list from the Token Service API.\n   */\n  async fetchTokenList(): Promise<void> {\n    const releaseLock = await this.mutex.acquire();\n    try {\n      const { tokensChainsCache } = this.state;\n      let tokenList: TokenListMap = {};\n      const cachedTokens: TokenListMap = await safelyExecute(() =>\n        this.fetchFromCache(),\n      );\n      if (cachedTokens) {\n        // Use non-expired cached tokens\n        tokenList = { ...cachedTokens };\n      } else {\n        // Fetch fresh token list\n        const tokensFromAPI: TokenListToken[] = await safelyExecute(() =>\n          fetchTokenList(this.chainId, this.abortController.signal),\n        );\n\n        if (!tokensFromAPI) {\n          // Fallback to expired cached tokens\n          tokenList = { ...(tokensChainsCache[this.chainId]?.data || {}) };\n\n          this.update(() => {\n            return {\n              ...this.state,\n              tokenList,\n              tokensChainsCache,\n            };\n          });\n          return;\n        }\n        // Filtering out tokens with less than 3 occurrences and native tokens\n        const filteredTokenList = tokensFromAPI.filter(\n          (token) =>\n            token.occurrences &&\n            token.occurrences >= 3 &&\n            token.address !== '0x0000000000000000000000000000000000000000',\n        );\n        // Removing the tokens with symbol conflicts\n        const symbolsList = filteredTokenList.map((token) => token.symbol);\n        const duplicateSymbols = [\n          ...new Set(\n            symbolsList.filter(\n              (symbol, index) => symbolsList.indexOf(symbol) !== index,\n            ),\n          ),\n        ];\n        const uniqueTokenList = filteredTokenList.filter(\n          (token) => !duplicateSymbols.includes(token.symbol),\n        );\n        for (const token of uniqueTokenList) {\n          const formattedToken: TokenListToken = {\n            ...token,\n            aggregators: formatAggregatorNames(token.aggregators),\n            iconUrl: formatIconUrlWithProxy({\n              chainId: this.chainId,\n              tokenAddress: token.address,\n            }),\n          };\n          tokenList[token.address] = formattedToken;\n        }\n      }\n      const updatedTokensChainsCache: TokensChainsCache = {\n        ...tokensChainsCache,\n        [this.chainId]: {\n          timestamp: Date.now(),\n          data: tokenList,\n        },\n      };\n      this.update(() => {\n        return {\n          ...this.state,\n          tokenList,\n          tokensChainsCache: updatedTokensChainsCache,\n        };\n      });\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Checks if the Cache timestamp is valid,\n   * if yes data in cache will be returned\n   * otherwise null will be returned.\n   *\n   * @returns The cached data, or `null` if the cache was expired.\n   */\n  async fetchFromCache(): Promise<TokenListMap | null> {\n    const { tokensChainsCache }: TokenListState = this.state;\n    const dataCache = tokensChainsCache[this.chainId];\n    const now = Date.now();\n    if (\n      dataCache?.data &&\n      now - dataCache?.timestamp < this.cacheRefreshThreshold\n    ) {\n      return dataCache.data;\n    }\n    return null;\n  }\n\n  /**\n   * Clearing tokenList and tokensChainsCache explicitly.\n   */\n  clearingTokenListData(): void {\n    this.update(() => {\n      return {\n        ...this.state,\n        tokenList: {},\n        tokensChainsCache: {},\n      };\n    });\n  }\n\n  /**\n   * Updates preventPollingOnNetworkRestart from extension.\n   *\n   * @param shouldPreventPolling - Determine whether to prevent polling on network change\n   */\n  updatePreventPollingOnNetworkRestart(shouldPreventPolling: boolean): void {\n    this.update(() => {\n      return {\n        ...this.state,\n        preventPollingOnNetworkRestart: shouldPreventPolling,\n      };\n    });\n  }\n}\n\nexport default TokenListController;\n"]}
\ No newline at end of file
+{"version":3,"file":"TokenListController.js","sourceRoot":"","sources":["../src/TokenListController.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Patch } from 'immer';\nimport { Mutex } from 'async-mutex';\nimport { AbortController as WhatwgAbortController } from 'abort-controller';\nimport type { Hex } from '@metamask/utils';\nimport {\n  BaseControllerV2,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport { safelyExecute } from '@metamask/controller-utils';\nimport {\n  NetworkControllerStateChangeEvent,\n  NetworkState,\n} from '@metamask/network-controller';\nimport {\n  isTokenListSupportedForNetwork,\n  formatAggregatorNames,\n  formatIconUrlWithProxy,\n} from './assetsUtil';\nimport { fetchTokenList } from './token-service';\n\nconst DEFAULT_INTERVAL = 24 * 60 * 60 * 1000;\nconst DEFAULT_THRESHOLD = 24 * 60 * 60 * 1000;\n\nconst name = 'TokenListController';\n\nexport type TokenListToken = {\n  name: string;\n  symbol: string;\n  decimals: number;\n  address: string;\n  occurrences: number;\n  aggregators: string[];\n  iconUrl: string;\n};\n\nexport type TokenListMap = Record<string, TokenListToken>;\n\ntype DataCache = {\n  timestamp: number;\n  data: TokenListMap;\n};\ntype TokensChainsCache = {\n  [chainId: Hex]: DataCache;\n};\n\nexport type TokenListState = {\n  tokenList: TokenListMap;\n  tokensChainsCache: TokensChainsCache;\n  preventPollingOnNetworkRestart: boolean;\n};\n\nexport type TokenListStateChange = {\n  type: `${typeof name}:stateChange`;\n  payload: [TokenListState, Patch[]];\n};\n\nexport type GetTokenListState = {\n  type: `${typeof name}:getState`;\n  handler: () => TokenListState;\n};\n\ntype TokenListMessenger = RestrictedControllerMessenger<\n  typeof name,\n  GetTokenListState,\n  TokenListStateChange | NetworkControllerStateChangeEvent,\n  never,\n  TokenListStateChange['type'] | NetworkControllerStateChangeEvent['type']\n>;\n\nconst metadata = {\n  tokenList: { persist: true, anonymous: true },\n  tokensChainsCache: { persist: true, anonymous: true },\n  preventPollingOnNetworkRestart: { persist: true, anonymous: true },\n};\n\nconst defaultState: TokenListState = {\n  tokenList: {},\n  tokensChainsCache: {},\n  preventPollingOnNetworkRestart: false,\n};\n\n/**\n * Controller that passively polls on a set interval for the list of tokens from metaswaps api\n */\nexport class TokenListController extends BaseControllerV2<\n  typeof name,\n  TokenListState,\n  TokenListMessenger\n> {\n  private mutex = new Mutex();\n\n  private intervalId?: ReturnType<typeof setTimeout>;\n\n  private intervalDelay: number;\n\n  private cacheRefreshThreshold: number;\n\n  private chainId: Hex;\n\n  private abortController: WhatwgAbortController;\n\n  /**\n   * Creates a TokenListController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.onNetworkStateChange - A function for registering an event handler for network state changes.\n   * @param options.interval - The polling interval, in milliseconds.\n   * @param options.cacheRefreshThreshold - The token cache expiry time, in milliseconds.\n   * @param options.messenger - A restricted controller messenger.\n   * @param options.state - Initial state to set on this controller.\n   * @param options.preventPollingOnNetworkRestart - Determines whether to prevent poilling on network restart in extension.\n   */\n  constructor({\n    chainId,\n    preventPollingOnNetworkRestart = false,\n    onNetworkStateChange,\n    interval = DEFAULT_INTERVAL,\n    cacheRefreshThreshold = DEFAULT_THRESHOLD,\n    messenger,\n    state,\n  }: {\n    chainId: Hex;\n    preventPollingOnNetworkRestart?: boolean;\n    onNetworkStateChange?: (\n      listener: (networkState: NetworkState) => void,\n    ) => void;\n    interval?: number;\n    cacheRefreshThreshold?: number;\n    messenger: TokenListMessenger;\n    state?: Partial<TokenListState>;\n  }) {\n    super({\n      name,\n      metadata,\n      messenger,\n      state: { ...defaultState, ...state },\n    });\n    this.intervalDelay = interval;\n    this.cacheRefreshThreshold = cacheRefreshThreshold;\n    this.chainId = chainId;\n    this.updatePreventPollingOnNetworkRestart(preventPollingOnNetworkRestart);\n    this.abortController = new WhatwgAbortController();\n    if (onNetworkStateChange) {\n      onNetworkStateChange(async (networkControllerState) => {\n        await this.#onNetworkControllerStateChange(networkControllerState);\n      });\n    } else {\n      this.messagingSystem.subscribe(\n        'NetworkController:stateChange',\n        async (networkControllerState) => {\n          await this.#onNetworkControllerStateChange(networkControllerState);\n        },\n      );\n    }\n  }\n\n  /**\n   * Updates state and restarts polling on changes to the network controller\n   * state.\n   *\n   * @param networkControllerState - The updated network controller state.\n   */\n  async #onNetworkControllerStateChange(networkControllerState: NetworkState) {\n    if (this.chainId !== networkControllerState.providerConfig.chainId) {\n      this.abortController.abort();\n      this.abortController = new WhatwgAbortController();\n      this.chainId = networkControllerState.providerConfig.chainId;\n      if (this.state.preventPollingOnNetworkRestart) {\n        this.clearingTokenListData();\n      } else {\n        // Ensure tokenList is referencing data from correct network\n        this.update(() => {\n          return {\n            ...this.state,\n            tokenList: this.state.tokensChainsCache[this.chainId]?.data || {},\n          };\n        });\n        await this.restart();\n      }\n    }\n  }\n\n  /**\n   * Start polling for the token list.\n   */\n  async start() {\n    if (!isTokenListSupportedForNetwork(this.chainId)) {\n      return;\n    }\n    await this.startPolling();\n  }\n\n  /**\n   * Restart polling for the token list.\n   */\n  async restart() {\n    this.stopPolling();\n    await this.startPolling();\n  }\n\n  /**\n   * Stop polling for the token list.\n   */\n  stop() {\n    this.stopPolling();\n  }\n\n  /**\n   * Prepare to discard this controller.\n   *\n   * This stops any active polling.\n   */\n  override destroy() {\n    super.destroy();\n    this.stopPolling();\n  }\n\n  private stopPolling() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n  }\n\n  /**\n   * Starts a new polling interval.\n   */\n  private async startPolling(): Promise<void> {\n    await safelyExecute(() => this.fetchTokenList());\n    this.intervalId = setInterval(async () => {\n      await safelyExecute(() => this.fetchTokenList());\n    }, this.intervalDelay);\n  }\n\n  /**\n   * Fetching token list from the Token Service API.\n   */\n  async fetchTokenList(): Promise<void> {\n    const releaseLock = await this.mutex.acquire();\n    try {\n      const { tokensChainsCache } = this.state;\n      let tokenList: TokenListMap = {};\n      const cachedTokens: TokenListMap = await safelyExecute(() =>\n        this.fetchFromCache(),\n      );\n      if (cachedTokens) {\n        // Use non-expired cached tokens\n        tokenList = { ...cachedTokens };\n      } else {\n        // Fetch fresh token list\n        const tokensFromAPI: TokenListToken[] = await safelyExecute(() =>\n          fetchTokenList(this.chainId, this.abortController.signal),\n        );\n\n        if (!tokensFromAPI) {\n          // Fallback to expired cached tokens\n          tokenList = { ...(tokensChainsCache[this.chainId]?.data || {}) };\n\n          this.update(() => {\n            return {\n              ...this.state,\n              tokenList,\n              tokensChainsCache,\n            };\n          });\n          return;\n        }\n        // Filtering out tokens with less than 3 occurrences and native tokens\n        const filteredTokenList = tokensFromAPI.filter(\n          (token) =>\n            token.occurrences &&\n            token.occurrences >= 3 &&\n            token.address !== '0x0000000000000000000000000000000000000000',\n        );\n        // Removing the tokens with symbol conflicts\n        const symbolsList = filteredTokenList.map((token) => token.symbol);\n        const duplicateSymbols = [\n          ...new Set(\n            symbolsList.filter(\n              (symbol, index) => symbolsList.indexOf(symbol) !== index,\n            ),\n          ),\n        ];\n        const uniqueTokenList = filteredTokenList.filter(\n          (token) => !duplicateSymbols.includes(token.symbol),\n        );\n        for (const token of uniqueTokenList) {\n          const formattedToken: TokenListToken = {\n            ...token,\n            aggregators: formatAggregatorNames(token.aggregators),\n            iconUrl: formatIconUrlWithProxy({\n              chainId: this.chainId,\n              tokenAddress: token.address,\n            }),\n          };\n          tokenList[token.address] = formattedToken;\n        }\n      }\n      const updatedTokensChainsCache: TokensChainsCache = {\n        ...tokensChainsCache,\n        [this.chainId]: {\n          timestamp: Date.now(),\n          data: tokenList,\n        },\n      };\n      this.update(() => {\n        return {\n          ...this.state,\n          tokenList,\n          tokensChainsCache: updatedTokensChainsCache,\n        };\n      });\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Checks if the Cache timestamp is valid,\n   * if yes data in cache will be returned\n   * otherwise null will be returned.\n   *\n   * @returns The cached data, or `null` if the cache was expired.\n   */\n  async fetchFromCache(): Promise<TokenListMap | null> {\n    const { tokensChainsCache }: TokenListState = this.state;\n    const dataCache = tokensChainsCache[this.chainId];\n    const now = Date.now();\n    if (\n      dataCache?.data &&\n      now - dataCache?.timestamp < this.cacheRefreshThreshold\n    ) {\n      return dataCache.data;\n    }\n    return null;\n  }\n\n  /**\n   * Clearing tokenList and tokensChainsCache explicitly.\n   */\n  clearingTokenListData(): void {\n    this.update(() => {\n      return {\n        ...this.state,\n        tokenList: {},\n        tokensChainsCache: {},\n      };\n    });\n  }\n\n  /**\n   * Updates preventPollingOnNetworkRestart from extension.\n   *\n   * @param shouldPreventPolling - Determine whether to prevent polling on network change\n   */\n  updatePreventPollingOnNetworkRestart(shouldPreventPolling: boolean): void {\n    this.update(() => {\n      return {\n        ...this.state,\n        preventPollingOnNetworkRestart: shouldPreventPolling,\n      };\n    });\n  }\n}\n\nexport default TokenListController;\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenListController.mjs b/node_modules/@metamask/assets-controllers/dist/TokenListController.mjs
new file mode 100644
index 0000000..8f7ae90
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/TokenListController.mjs
@@ -0,0 +1,14 @@
+import {
+  TokenListController,
+  TokenListController_default,
+  getDefaultTokenListState
+} from "./chunk-523YP4Z3.mjs";
+import "./chunk-KRTEFV4Q.mjs";
+import "./chunk-E5PIGGYR.mjs";
+import "./chunk-XUI43LEZ.mjs";
+export {
+  TokenListController,
+  TokenListController_default as default,
+  getDefaultTokenListState
+};
+//# sourceMappingURL=TokenListController.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenListController.mjs.map b/node_modules/@metamask/assets-controllers/dist/TokenListController.mjs.map
new file mode 100644
index 0000000..84c51b2
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/TokenListController.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":[],"sourcesContent":[],"mappings":"","names":[]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenRatesController.d.ts b/node_modules/@metamask/assets-controllers/dist/TokenRatesController.d.ts
index cda8bb7..e8bbc92 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenRatesController.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/TokenRatesController.d.ts
@@ -1,30 +1,10 @@
-import type { BaseConfig, BaseState } from '@metamask/base-controller';
 import { BaseController } from '@metamask/base-controller';
+import type { BaseConfig, BaseState } from '@metamask/base-controller';
 import type { NetworkState } from '@metamask/network-controller';
 import type { PreferencesState } from '@metamask/preferences-controller';
 import type { Hex } from '@metamask/utils';
+import type { AbstractTokenPricesService } from './token-prices-service/abstract-token-prices-service';
 import type { TokensState } from './TokensController';
-/**
- * @type CoinGeckoResponse
- *
- * CoinGecko API response representation
- */
-export interface CoinGeckoResponse {
-    [address: string]: {
-        [currency: string]: number;
-    };
-}
-/**
- * @type CoinGeckoPlatform
- *
- * CoinGecko supported platform API representation
- */
-export interface CoinGeckoPlatform {
-    id: string;
-    chain_identifier: null | number;
-    name: string;
-    shortname: string;
-}
 /**
  * @type Token
  *
@@ -78,11 +58,12 @@ interface ContractExchangeRates {
  * @type TokenRatesState
  *
  * Token rates controller state
- * @property contractExchangeRates - Hash of token contract addresses to exchange rates
- * @property supportedChains - Cached chain data
+ * @property contractExchangeRates - Hash of token contract addresses to exchange rates (single globally selected chain, will be deprecated soon)
+ * @property contractExchangeRatesByChainId - Hash of token contract addresses to exchange rates keyed by chain ID and native currency (ticker)
  */
 export interface TokenRatesState extends BaseState {
     contractExchangeRates: ContractExchangeRates;
+    contractExchangeRatesByChainId: Record<string, Record<string, ContractExchangeRates>>;
 }
 /**
  * Controller that passively polls on a set interval for token-to-fiat exchange rates
@@ -91,9 +72,6 @@ export interface TokenRatesState extends BaseState {
 export declare class TokenRatesController extends BaseController<TokenRatesConfig, TokenRatesState> {
     #private;
     private handle?;
-    private tokenList;
-    private supportedChains;
-    private supportedVsCurrencies;
     /**
      * Name of this controller used during composition
      */
@@ -102,22 +80,28 @@ export declare class TokenRatesController extends BaseController<TokenRatesConfi
      * Creates a TokenRatesController instance.
      *
      * @param options - The controller options.
+     * @param options.interval - The polling interval in ms
+     * @param options.threshold - The duration in ms before metadata fetched from CoinGecko is considered stale
      * @param options.chainId - The chain ID of the current network.
      * @param options.ticker - The ticker for the current network.
      * @param options.selectedAddress - The current selected address.
      * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.
      * @param options.onTokensStateChange - Allows subscribing to token controller state changes.
      * @param options.onNetworkStateChange - Allows subscribing to network state changes.
+     * @param options.tokenPricesService - An object in charge of retrieving token prices.
      * @param config - Initial options used to configure this controller.
      * @param state - Initial state to set on this controller.
      */
-    constructor({ chainId: initialChainId, ticker: initialTicker, selectedAddress: initialSelectedAddress, onPreferencesStateChange, onTokensStateChange, onNetworkStateChange, }: {
+    constructor({ interval, threshold, chainId: initialChainId, ticker: initialTicker, selectedAddress: initialSelectedAddress, onPreferencesStateChange, onTokensStateChange, onNetworkStateChange, tokenPricesService, }: {
+        interval?: number;
+        threshold?: number;
         chainId: Hex;
         ticker: string;
         selectedAddress: string;
         onPreferencesStateChange: (listener: (preferencesState: PreferencesState) => void) => void;
         onTokensStateChange: (listener: (tokensState: TokensState) => void) => void;
         onNetworkStateChange: (listener: (networkState: NetworkState) => void) => void;
+        tokenPricesService: AbstractTokenPricesService;
     }, config?: Partial<TokenRatesConfig>, state?: Partial<TokenRatesState>);
     /**
      * Start (or restart) polling.
@@ -127,46 +111,10 @@ export declare class TokenRatesController extends BaseController<TokenRatesConfi
      * Stop polling.
      */
     stop(): void;
-    /**
-     * Fetches a pairs of token address and native currency.
-     *
-     * @param chainSlug - Chain string identifier.
-     * @param vsCurrency - Query according to tokens in tokenList and native currency.
-     * @returns The exchange rates for the given pairs.
-     */
-    fetchExchangeRate(chainSlug: string, vsCurrency: string): Promise<CoinGeckoResponse>;
-    /**
-     * Checks if the current native currency is a supported vs currency to use
-     * to query for token exchange rates.
-     *
-     * @param nativeCurrency - The native currency of the currently active network.
-     * @returns A boolean indicating whether it's a supported vsCurrency.
-     */
-    private checkIsSupportedVsCurrency;
-    /**
-     * Gets current chain ID slug from cached supported platforms CoinGecko API response.
-     * If cached supported platforms response is stale, fetches and updates it.
-     *
-     * @returns The CoinGecko slug for the current chain ID.
-     */
-    getChainSlug(): Promise<string | null>;
     /**
      * Updates exchange rates for all tokens.
      */
     updateExchangeRates(): Promise<void>;
-    /**
-     * Checks if the active network's native currency is supported by the coingecko API.
-     * If supported, it fetches and maps contractExchange rates to a format to be consumed by the UI.
-     * If not supported, it fetches contractExchange rates and maps them from token/fallback-currency
-     * to token/nativeCurrency.
-     *
-     * @param nativeCurrency - The native currency of the currently active network.
-     * @param slug - The unique slug used to id the chain by the coingecko api
-     * should be used to query token exchange rates.
-     * @returns An object with conversion rates for each token
-     * related to the network's native currency.
-     */
-    fetchAndMapExchangeRates(nativeCurrency: string, slug: string): Promise<ContractExchangeRates>;
 }
 export default TokenRatesController;
 //# sourceMappingURL=TokenRatesController.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenRatesController.d.ts.map b/node_modules/@metamask/assets-controllers/dist/TokenRatesController.d.ts.map
index 8e92171..25d5279 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenRatesController.d.ts.map
+++ b/node_modules/@metamask/assets-controllers/dist/TokenRatesController.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"TokenRatesController.d.ts","sourceRoot":"","sources":["../src/TokenRatesController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"TokenRatesController.d.ts","sourceRoot":"","sources":["../src/TokenRatesController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenRatesController.js b/node_modules/@metamask/assets-controllers/dist/TokenRatesController.js
index c5df5be..ef40b52 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenRatesController.js
+++ b/node_modules/@metamask/assets-controllers/dist/TokenRatesController.js
@@ -8,126 +8,129 @@ var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, ge
         step((generator = generator.apply(thisArg, _arguments || [])).next());
     });
 };
-var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
-    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
-    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
-    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
-};
 var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
     if (kind === "m") throw new TypeError("Private method is not writable");
     if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
     if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
     return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
 };
-var _TokenRatesController_instances, _TokenRatesController_pollState, _TokenRatesController_updateTokenList, _TokenRatesController_stopPoll, _TokenRatesController_poll;
+var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
+    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
+};
+var _TokenRatesController_instances, _TokenRatesController_pollState, _TokenRatesController_tokenPricesService, _TokenRatesController_inProcessExchangeRateUpdates, _TokenRatesController_getTokenAddresses, _TokenRatesController_stopPoll, _TokenRatesController_poll, _TokenRatesController_fetchAndMapExchangeRates, _TokenRatesController_fetchAndMapExchangeRatesForSupportedNativeCurrency, _TokenRatesController_fetchAndMapExchangeRatesForUnsupportedNativeCurrency;
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.TokenRatesController = void 0;
 const base_controller_1 = require("@metamask/base-controller");
 const controller_utils_1 = require("@metamask/controller-utils");
+const lodash_1 = require("lodash");
+const assetsUtil_1 = require("./assetsUtil");
 const crypto_compare_1 = require("./crypto-compare");
 var PollState;
 (function (PollState) {
     PollState["Active"] = "Active";
     PollState["Inactive"] = "Inactive";
 })(PollState || (PollState = {}));
-const CoinGeckoApi = {
-    BASE_URL: 'https://api.coingecko.com/api/v3',
-    getTokenPriceURL(chainSlug, query) {
-        return `${this.BASE_URL}/simple/token_price/${chainSlug}?${query}`;
-    },
-    getPlatformsURL() {
-        return `${this.BASE_URL}/asset_platforms`;
-    },
-    getSupportedVsCurrencies() {
-        return `${this.BASE_URL}/simple/supported_vs_currencies`;
-    },
-};
 /**
- * Finds the chain slug in the data array given a chainId.
+ * The maximum number of token addresses that should be sent to the Price API in
+ * a single request.
+ */
+const TOKEN_PRICES_BATCH_SIZE = 30;
+/**
+ * Uses the CryptoCompare API to fetch the exchange rate between one currency
+ * and another, i.e., the multiplier to apply the amount of one currency in
+ * order to convert it to another.
  *
- * @param chainId - The current chain ID.
- * @param data - A list platforms supported by the CoinGecko API.
- * @returns The CoinGecko slug for the given chain ID, or `null` if the slug was not found.
+ * @param args - The arguments to this function.
+ * @param args.from - The currency to convert from.
+ * @param args.to - The currency to convert to.
+ * @returns The exchange rate between `fromCurrency` to `toCurrency` if one
+ * exists, or null if one does not.
  */
-function findChainSlug(chainId, data) {
-    var _a;
-    if (!data) {
-        return null;
-    }
-    const chain = (_a = data.find(({ chain_identifier }) => chain_identifier !== null && (0, controller_utils_1.toHex)(chain_identifier) === chainId)) !== null && _a !== void 0 ? _a : null;
-    return (chain === null || chain === void 0 ? void 0 : chain.id) || null;
+function getCurrencyConversionRate({ from, to, }) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const includeUSDRate = false;
+        try {
+            const result = yield (0, crypto_compare_1.fetchExchangeRate)(to, from, includeUSDRate);
+            return result.conversionRate;
+        }
+        catch (error) {
+            if (error instanceof Error &&
+                error.message.includes('market does not exist for this coin pair')) {
+                return null;
+            }
+            throw error;
+        }
+    });
 }
 /**
  * Controller that passively polls on a set interval for token-to-fiat exchange rates
  * for tokens stored in the TokensController
  */
+// This is using BaseController on BaseController v3, which relates to BaseController V1
+// When rebase this patch doesn't forget about change this to `BaseController` instead of `BaseControllerV1`
 class TokenRatesController extends base_controller_1.BaseController {
     /**
      * Creates a TokenRatesController instance.
      *
      * @param options - The controller options.
+     * @param options.interval - The polling interval in ms
+     * @param options.threshold - The duration in ms before metadata fetched from CoinGecko is considered stale
      * @param options.chainId - The chain ID of the current network.
      * @param options.ticker - The ticker for the current network.
      * @param options.selectedAddress - The current selected address.
      * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.
      * @param options.onTokensStateChange - Allows subscribing to token controller state changes.
      * @param options.onNetworkStateChange - Allows subscribing to network state changes.
+     * @param options.tokenPricesService - An object in charge of retrieving token prices.
      * @param config - Initial options used to configure this controller.
      * @param state - Initial state to set on this controller.
      */
-    constructor({ chainId: initialChainId, ticker: initialTicker, selectedAddress: initialSelectedAddress, onPreferencesStateChange, onTokensStateChange, onNetworkStateChange, }, config, state) {
+    constructor({ interval = 3 * 60 * 1000, threshold = 6 * 60 * 60 * 1000, chainId: initialChainId, ticker: initialTicker, selectedAddress: initialSelectedAddress, onPreferencesStateChange, onTokensStateChange, onNetworkStateChange, tokenPricesService, }, config, state) {
         super(config, state);
         _TokenRatesController_instances.add(this);
-        this.tokenList = [];
-        this.supportedChains = {
-            timestamp: 0,
-            data: null,
-        };
-        this.supportedVsCurrencies = {
-            timestamp: 0,
-            data: [],
-        };
         _TokenRatesController_pollState.set(this, PollState.Inactive);
+        _TokenRatesController_tokenPricesService.set(this, void 0);
+        _TokenRatesController_inProcessExchangeRateUpdates.set(this, {});
         /**
          * Name of this controller used during composition
          */
         this.name = 'TokenRatesController';
         this.defaultConfig = {
+            interval,
+            threshold,
             disabled: false,
-            interval: 3 * 60 * 1000,
             nativeCurrency: initialTicker,
             chainId: initialChainId,
             selectedAddress: initialSelectedAddress,
             allTokens: {},
             allDetectedTokens: {},
-            threshold: 6 * 60 * 60 * 1000,
         };
         this.defaultState = {
             contractExchangeRates: {},
+            contractExchangeRatesByChainId: {},
         };
         this.initialize();
+        __classPrivateFieldSet(this, _TokenRatesController_tokenPricesService, tokenPricesService, "f");
         if (config === null || config === void 0 ? void 0 : config.disabled) {
             this.configure({ disabled: true }, false, false);
         }
-        __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_updateTokenList).call(this);
         onPreferencesStateChange(({ selectedAddress }) => __awaiter(this, void 0, void 0, function* () {
             if (this.config.selectedAddress !== selectedAddress) {
                 this.configure({ selectedAddress });
-                __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_updateTokenList).call(this);
                 if (__classPrivateFieldGet(this, _TokenRatesController_pollState, "f") === PollState.Active) {
                     yield this.updateExchangeRates();
                 }
             }
         }));
         onTokensStateChange(({ allTokens, allDetectedTokens }) => __awaiter(this, void 0, void 0, function* () {
-            // These two state properties are assumed to be immutable
-            if (this.config.allTokens !== allTokens ||
-                this.config.allDetectedTokens !== allDetectedTokens) {
-                this.configure({ allTokens, allDetectedTokens });
-                __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_updateTokenList).call(this);
-                if (__classPrivateFieldGet(this, _TokenRatesController_pollState, "f") === PollState.Active) {
-                    yield this.updateExchangeRates();
-                }
+            const previousTokenAddresses = __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_getTokenAddresses).call(this, this.config.chainId);
+            this.configure({ allTokens, allDetectedTokens });
+            const newTokenAddresses = __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_getTokenAddresses).call(this, this.config.chainId);
+            if (!(0, lodash_1.isEqual)(previousTokenAddresses, newTokenAddresses) &&
+                __classPrivateFieldGet(this, _TokenRatesController_pollState, "f") === PollState.Active) {
+                yield this.updateExchangeRates();
             }
         }));
         onNetworkStateChange(({ providerConfig }) => __awaiter(this, void 0, void 0, function* () {
@@ -135,8 +138,7 @@ class TokenRatesController extends base_controller_1.BaseController {
             if (this.config.chainId !== chainId ||
                 this.config.nativeCurrency !== ticker) {
                 this.update({ contractExchangeRates: {} });
-                this.configure({ chainId, nativeCurrency: ticker });
-                __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_updateTokenList).call(this);
+                this.configure({ chainId, nativeCurrency: ticker || 'ETH' });
                 if (__classPrivateFieldGet(this, _TokenRatesController_pollState, "f") === PollState.Active) {
                     yield this.updateExchangeRates();
                 }
@@ -160,155 +162,68 @@ class TokenRatesController extends base_controller_1.BaseController {
         __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_stopPoll).call(this);
         __classPrivateFieldSet(this, _TokenRatesController_pollState, PollState.Inactive, "f");
     }
-    /**
-     * Fetches a pairs of token address and native currency.
-     *
-     * @param chainSlug - Chain string identifier.
-     * @param vsCurrency - Query according to tokens in tokenList and native currency.
-     * @returns The exchange rates for the given pairs.
-     */
-    fetchExchangeRate(chainSlug, vsCurrency) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const tokenPairs = this.tokenList.map((token) => token.address).join(',');
-            const query = `contract_addresses=${tokenPairs}&vs_currencies=${vsCurrency.toLowerCase()}`;
-            return (0, controller_utils_1.handleFetch)(CoinGeckoApi.getTokenPriceURL(chainSlug, query));
-        });
-    }
-    /**
-     * Checks if the current native currency is a supported vs currency to use
-     * to query for token exchange rates.
-     *
-     * @param nativeCurrency - The native currency of the currently active network.
-     * @returns A boolean indicating whether it's a supported vsCurrency.
-     */
-    checkIsSupportedVsCurrency(nativeCurrency) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const { threshold } = this.config;
-            const { timestamp, data } = this.supportedVsCurrencies;
-            const now = Date.now();
-            if (now - timestamp > threshold) {
-                const currencies = yield (0, controller_utils_1.handleFetch)(CoinGeckoApi.getSupportedVsCurrencies());
-                this.supportedVsCurrencies = {
-                    data: currencies,
-                    timestamp: Date.now(),
-                };
-                return currencies.includes(nativeCurrency.toLowerCase());
-            }
-            return data.includes(nativeCurrency.toLowerCase());
-        });
-    }
-    /**
-     * Gets current chain ID slug from cached supported platforms CoinGecko API response.
-     * If cached supported platforms response is stale, fetches and updates it.
-     *
-     * @returns The CoinGecko slug for the current chain ID.
-     */
-    getChainSlug() {
-        return __awaiter(this, void 0, void 0, function* () {
-            const { threshold, chainId } = this.config;
-            const { data, timestamp } = this.supportedChains;
-            const now = Date.now();
-            if (now - timestamp > threshold) {
-                const platforms = yield (0, controller_utils_1.handleFetch)(CoinGeckoApi.getPlatformsURL());
-                this.supportedChains = {
-                    data: platforms,
-                    timestamp: Date.now(),
-                };
-                return findChainSlug(chainId, platforms);
-            }
-            return findChainSlug(chainId, data);
-        });
-    }
     /**
      * Updates exchange rates for all tokens.
      */
     updateExchangeRates() {
+        var _a;
         return __awaiter(this, void 0, void 0, function* () {
-            if (this.tokenList.length === 0 || this.disabled) {
+            const { chainId, nativeCurrency } = this.config;
+            if (this.disabled) {
                 return;
             }
-            const slug = yield this.getChainSlug();
-            let newContractExchangeRates = {};
-            if (!slug) {
-                this.tokenList.forEach((token) => {
-                    const address = (0, controller_utils_1.toChecksumHexAddress)(token.address);
-                    newContractExchangeRates[address] = undefined;
-                });
+            const tokenAddresses = __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_getTokenAddresses).call(this, chainId);
+            if (tokenAddresses.length === 0) {
+                return;
             }
-            else {
-                const { nativeCurrency } = this.config;
-                newContractExchangeRates = yield this.fetchAndMapExchangeRates(nativeCurrency, slug);
+            const updateKey = `${chainId}:${nativeCurrency}`;
+            if (updateKey in __classPrivateFieldGet(this, _TokenRatesController_inProcessExchangeRateUpdates, "f")) {
+                // This prevents redundant updates
+                // This promise is resolved after the in-progress update has finished,
+                // and state has been updated.
+                yield __classPrivateFieldGet(this, _TokenRatesController_inProcessExchangeRateUpdates, "f")[updateKey];
+                return;
             }
-            this.update({ contractExchangeRates: newContractExchangeRates });
-        });
-    }
-    /**
-     * Checks if the active network's native currency is supported by the coingecko API.
-     * If supported, it fetches and maps contractExchange rates to a format to be consumed by the UI.
-     * If not supported, it fetches contractExchange rates and maps them from token/fallback-currency
-     * to token/nativeCurrency.
-     *
-     * @param nativeCurrency - The native currency of the currently active network.
-     * @param slug - The unique slug used to id the chain by the coingecko api
-     * should be used to query token exchange rates.
-     * @returns An object with conversion rates for each token
-     * related to the network's native currency.
-     */
-    fetchAndMapExchangeRates(nativeCurrency, slug) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const contractExchangeRates = {};
-            // check if native currency is supported as a vs_currency by the API
-            const nativeCurrencySupported = yield this.checkIsSupportedVsCurrency(nativeCurrency);
-            if (nativeCurrencySupported) {
-                // If it is we can do a simple fetch against the CoinGecko API
-                const prices = yield this.fetchExchangeRate(slug, nativeCurrency);
-                this.tokenList.forEach((token) => {
-                    const price = prices[token.address.toLowerCase()];
-                    contractExchangeRates[(0, controller_utils_1.toChecksumHexAddress)(token.address)] = price
-                        ? price[nativeCurrency.toLowerCase()]
-                        : 0;
+            const { promise: inProgressUpdate, resolve: updateSucceeded, reject: updateFailed, } = createDeferredPromise({ suppressUnhandledRejection: true });
+            __classPrivateFieldGet(this, _TokenRatesController_inProcessExchangeRateUpdates, "f")[updateKey] = inProgressUpdate;
+            try {
+                const newContractExchangeRates = yield __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_fetchAndMapExchangeRates).call(this, {
+                    tokenAddresses,
+                    chainId,
+                    nativeCurrency,
+                });
+                const existingContractExchangeRates = this.state.contractExchangeRates;
+                const updatedContractExchangeRates = chainId === this.config.chainId &&
+                    nativeCurrency === this.config.nativeCurrency
+                    ? newContractExchangeRates
+                    : existingContractExchangeRates;
+                const existingContractExchangeRatesForChainId = (_a = this.state.contractExchangeRatesByChainId[chainId]) !== null && _a !== void 0 ? _a : {};
+                const updatedContractExchangeRatesForChainId = Object.assign(Object.assign({}, this.state.contractExchangeRatesByChainId), { [chainId]: Object.assign(Object.assign({}, existingContractExchangeRatesForChainId), { [nativeCurrency]: Object.assign(Object.assign({}, existingContractExchangeRatesForChainId[nativeCurrency]), newContractExchangeRates) }) });
+                this.update({
+                    contractExchangeRates: updatedContractExchangeRates,
+                    contractExchangeRatesByChainId: updatedContractExchangeRatesForChainId,
                 });
+                updateSucceeded();
             }
-            else {
-                // if native currency is not supported we need to use a fallback vsCurrency, get the exchange rates
-                // in token/fallback-currency format and convert them to expected token/nativeCurrency format.
-                let tokenExchangeRates;
-                let vsCurrencyToNativeCurrencyConversionRate = 0;
-                try {
-                    [
-                        tokenExchangeRates,
-                        { conversionRate: vsCurrencyToNativeCurrencyConversionRate },
-                    ] = yield Promise.all([
-                        this.fetchExchangeRate(slug, controller_utils_1.FALL_BACK_VS_CURRENCY),
-                        (0, crypto_compare_1.fetchExchangeRate)(nativeCurrency, controller_utils_1.FALL_BACK_VS_CURRENCY, false),
-                    ]);
-                }
-                catch (error) {
-                    if (error instanceof Error &&
-                        error.message.includes('market does not exist for this coin pair')) {
-                        return {};
-                    }
-                    throw error;
-                }
-                for (const [tokenAddress, conversion] of Object.entries(tokenExchangeRates)) {
-                    const tokenToVsCurrencyConversionRate = conversion[controller_utils_1.FALL_BACK_VS_CURRENCY.toLowerCase()];
-                    contractExchangeRates[(0, controller_utils_1.toChecksumHexAddress)(tokenAddress)] =
-                        tokenToVsCurrencyConversionRate *
-                            vsCurrencyToNativeCurrencyConversionRate;
-                }
+            catch (error) {
+                updateFailed(error);
+                throw error;
+            }
+            finally {
+                delete __classPrivateFieldGet(this, _TokenRatesController_inProcessExchangeRateUpdates, "f")[updateKey];
             }
-            return contractExchangeRates;
         });
     }
 }
 exports.TokenRatesController = TokenRatesController;
-_TokenRatesController_pollState = new WeakMap(), _TokenRatesController_instances = new WeakSet(), _TokenRatesController_updateTokenList = function _TokenRatesController_updateTokenList() {
+_TokenRatesController_pollState = new WeakMap(), _TokenRatesController_tokenPricesService = new WeakMap(), _TokenRatesController_inProcessExchangeRateUpdates = new WeakMap(), _TokenRatesController_instances = new WeakSet(), _TokenRatesController_getTokenAddresses = function _TokenRatesController_getTokenAddresses(chainId) {
     var _a, _b;
     const { allTokens, allDetectedTokens } = this.config;
-    const tokens = ((_a = allTokens[this.config.chainId]) === null || _a === void 0 ? void 0 : _a[this.config.selectedAddress]) || [];
-    const detectedTokens = ((_b = allDetectedTokens[this.config.chainId]) === null || _b === void 0 ? void 0 : _b[this.config.selectedAddress]) ||
-        [];
-    this.tokenList = [...tokens, ...detectedTokens];
+    const tokens = ((_a = allTokens[chainId]) === null || _a === void 0 ? void 0 : _a[this.config.selectedAddress]) || [];
+    const detectedTokens = ((_b = allDetectedTokens[chainId]) === null || _b === void 0 ? void 0 : _b[this.config.selectedAddress]) || [];
+    return [
+        ...new Set([...tokens, ...detectedTokens].map((token) => (0, controller_utils_1.toHex)((0, controller_utils_1.toChecksumHexAddress)(token.address)))),
+    ].sort();
 }, _TokenRatesController_stopPoll = function _TokenRatesController_stopPoll() {
     if (this.handle) {
         clearTimeout(this.handle);
@@ -322,6 +237,92 @@ _TokenRatesController_pollState = new WeakMap(), _TokenRatesController_instances
             __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_poll).call(this);
         }, this.config.interval);
     });
+}, _TokenRatesController_fetchAndMapExchangeRates = function _TokenRatesController_fetchAndMapExchangeRates({ tokenAddresses, chainId, nativeCurrency, }) {
+    return __awaiter(this, void 0, void 0, function* () {
+        if (!__classPrivateFieldGet(this, _TokenRatesController_tokenPricesService, "f").validateChainIdSupported(chainId)) {
+            return tokenAddresses.reduce((obj, tokenAddress) => {
+                return Object.assign(Object.assign({}, obj), { [tokenAddress]: undefined });
+            }, {});
+        }
+        if (__classPrivateFieldGet(this, _TokenRatesController_tokenPricesService, "f").validateCurrencySupported(nativeCurrency)) {
+            return yield __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_fetchAndMapExchangeRatesForSupportedNativeCurrency).call(this, {
+                tokenAddresses,
+                chainId,
+                nativeCurrency,
+            });
+        }
+        return yield __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_fetchAndMapExchangeRatesForUnsupportedNativeCurrency).call(this, {
+            tokenAddresses,
+            nativeCurrency,
+        });
+    });
+}, _TokenRatesController_fetchAndMapExchangeRatesForSupportedNativeCurrency = function _TokenRatesController_fetchAndMapExchangeRatesForSupportedNativeCurrency({ tokenAddresses, chainId, nativeCurrency, }) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const tokenPricesByTokenAddress = yield (0, assetsUtil_1.reduceInBatchesSerially)({
+            values: [...tokenAddresses].sort(),
+            batchSize: TOKEN_PRICES_BATCH_SIZE,
+            eachBatch: (allTokenPricesByTokenAddress, batch) => __awaiter(this, void 0, void 0, function* () {
+                const tokenPricesByTokenAddressForBatch = yield __classPrivateFieldGet(this, _TokenRatesController_tokenPricesService, "f").fetchTokenPrices({
+                    tokenAddresses: batch,
+                    chainId,
+                    currency: nativeCurrency,
+                });
+                return Object.assign(Object.assign({}, allTokenPricesByTokenAddress), tokenPricesByTokenAddressForBatch);
+            }),
+            initialResult: {},
+        });
+        return Object.entries(tokenPricesByTokenAddress).reduce((obj, [tokenAddress, tokenPrice]) => {
+            return Object.assign(Object.assign({}, obj), { [tokenAddress]: tokenPrice === null || tokenPrice === void 0 ? void 0 : tokenPrice.value });
+        }, {});
+    });
+}, _TokenRatesController_fetchAndMapExchangeRatesForUnsupportedNativeCurrency = function _TokenRatesController_fetchAndMapExchangeRatesForUnsupportedNativeCurrency({ tokenAddresses, nativeCurrency, }) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const [contractExchangeRates, fallbackCurrencyToNativeCurrencyConversionRate,] = yield Promise.all([
+            __classPrivateFieldGet(this, _TokenRatesController_instances, "m", _TokenRatesController_fetchAndMapExchangeRatesForSupportedNativeCurrency).call(this, {
+                tokenAddresses,
+                chainId: this.config.chainId,
+                nativeCurrency: controller_utils_1.FALL_BACK_VS_CURRENCY,
+            }),
+            getCurrencyConversionRate({
+                from: controller_utils_1.FALL_BACK_VS_CURRENCY,
+                to: nativeCurrency,
+            }),
+        ]);
+        if (fallbackCurrencyToNativeCurrencyConversionRate === null) {
+            return {};
+        }
+        return Object.entries(contractExchangeRates).reduce((obj, [tokenAddress, tokenValue]) => {
+            return Object.assign(Object.assign({}, obj), { [tokenAddress]: tokenValue
+                    ? tokenValue * fallbackCurrencyToNativeCurrencyConversionRate
+                    : undefined });
+        }, {});
+    });
 };
+/**
+ * Create a defered Promise.
+ *
+ * TODO: Migrate this to utils
+ *
+ * @param args - The arguments.
+ * @param args.suppressUnhandledRejection - This option adds an empty error handler
+ * to the Promise to suppress the UnhandledPromiseRejection error. This can be
+ * useful if the deferred Promise is sometimes intentionally not used.
+ * @returns A deferred Promise.
+ */
+function createDeferredPromise({ suppressUnhandledRejection = false, }) {
+    let resolve;
+    let reject;
+    const promise = new Promise((innerResolve, innerReject) => {
+        resolve = innerResolve;
+        reject = innerReject;
+    });
+    if (suppressUnhandledRejection) {
+        promise.catch((_error) => {
+            // This handler is used to suppress the UnhandledPromiseRejection error
+        });
+    }
+    // @ts-expect-error We know that these are assigned, but TypeScript doesn't
+    return { promise, resolve, reject };
+}
 exports.default = TokenRatesController;
 //# sourceMappingURL=TokenRatesController.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenRatesController.js.map b/node_modules/@metamask/assets-controllers/dist/TokenRatesController.js.map
index 6a23041..be6fddb 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokenRatesController.js.map
+++ b/node_modules/@metamask/assets-controllers/dist/TokenRatesController.js.map
@@ -1 +1 @@
-{"version":3,"file":"TokenRatesController.js","sourceRoot":"","sources":["../src/TokenRatesController.ts"],"names":[],"mappings":"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","sourcesContent":["import type { BaseConfig, BaseState } from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport {\n  safelyExecute,\n  handleFetch,\n  toChecksumHexAddress,\n  FALL_BACK_VS_CURRENCY,\n  toHex,\n} from '@metamask/controller-utils';\nimport type { NetworkState } from '@metamask/network-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport type { Hex } from '@metamask/utils';\n\nimport { fetchExchangeRate as fetchNativeExchangeRate } from './crypto-compare';\nimport type { TokensState } from './TokensController';\n\n/**\n * @type CoinGeckoResponse\n *\n * CoinGecko API response representation\n */\nexport interface CoinGeckoResponse {\n  [address: string]: {\n    [currency: string]: number;\n  };\n}\n/**\n * @type CoinGeckoPlatform\n *\n * CoinGecko supported platform API representation\n */\nexport interface CoinGeckoPlatform {\n  id: string;\n  chain_identifier: null | number;\n  name: string;\n  shortname: string;\n}\n\n/**\n * @type Token\n *\n * Token representation\n * @property address - Hex address of the token contract\n * @property decimals - Number of decimals the token uses\n * @property symbol - Symbol of the token\n * @property image - Image of the token, url or bit32 image\n */\nexport interface Token {\n  address: string;\n  decimals: number;\n  symbol: string;\n  aggregators?: string[];\n  image?: string;\n  balanceError?: unknown;\n  isERC721?: boolean;\n  name?: string;\n}\n\n/**\n * @type TokenRatesConfig\n *\n * Token rates controller configuration\n * @property interval - Polling interval used to fetch new token rates\n * @property nativeCurrency - Current native currency selected to use base of rates\n * @property chainId - Current network chainId\n * @property tokens - List of tokens to track exchange rates for\n * @property threshold - Threshold to invalidate the supportedChains\n */\nexport interface TokenRatesConfig extends BaseConfig {\n  interval: number;\n  nativeCurrency: string;\n  chainId: Hex;\n  selectedAddress: string;\n  allTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n  allDetectedTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n  threshold: number;\n}\n\ninterface ContractExchangeRates {\n  [address: string]: number | undefined;\n}\n\ninterface SupportedChainsCache {\n  timestamp: number;\n  data: CoinGeckoPlatform[] | null;\n}\n\ninterface SupportedVsCurrenciesCache {\n  timestamp: number;\n  data: string[];\n}\n\nenum PollState {\n  Active = 'Active',\n  Inactive = 'Inactive',\n}\n\n/**\n * @type TokenRatesState\n *\n * Token rates controller state\n * @property contractExchangeRates - Hash of token contract addresses to exchange rates\n * @property supportedChains - Cached chain data\n */\nexport interface TokenRatesState extends BaseState {\n  contractExchangeRates: ContractExchangeRates;\n}\n\nconst CoinGeckoApi = {\n  BASE_URL: 'https://api.coingecko.com/api/v3',\n  getTokenPriceURL(chainSlug: string, query: string) {\n    return `${this.BASE_URL}/simple/token_price/${chainSlug}?${query}`;\n  },\n  getPlatformsURL() {\n    return `${this.BASE_URL}/asset_platforms`;\n  },\n  getSupportedVsCurrencies() {\n    return `${this.BASE_URL}/simple/supported_vs_currencies`;\n  },\n};\n\n/**\n * Finds the chain slug in the data array given a chainId.\n *\n * @param chainId - The current chain ID.\n * @param data - A list platforms supported by the CoinGecko API.\n * @returns The CoinGecko slug for the given chain ID, or `null` if the slug was not found.\n */\nfunction findChainSlug(\n  chainId: Hex,\n  data: CoinGeckoPlatform[] | null,\n): string | null {\n  if (!data) {\n    return null;\n  }\n  const chain =\n    data.find(\n      ({ chain_identifier }) =>\n        chain_identifier !== null && toHex(chain_identifier) === chainId,\n    ) ?? null;\n  return chain?.id || null;\n}\n\n/**\n * Controller that passively polls on a set interval for token-to-fiat exchange rates\n * for tokens stored in the TokensController\n */\nexport class TokenRatesController extends BaseController<\n  TokenRatesConfig,\n  TokenRatesState\n> {\n  private handle?: ReturnType<typeof setTimeout>;\n\n  private tokenList: Token[] = [];\n\n  private supportedChains: SupportedChainsCache = {\n    timestamp: 0,\n    data: null,\n  };\n\n  private supportedVsCurrencies: SupportedVsCurrenciesCache = {\n    timestamp: 0,\n    data: [],\n  };\n\n  #pollState = PollState.Inactive;\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'TokenRatesController';\n\n  /**\n   * Creates a TokenRatesController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.ticker - The ticker for the current network.\n   * @param options.selectedAddress - The current selected address.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.onTokensStateChange - Allows subscribing to token controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network state changes.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      chainId: initialChainId,\n      ticker: initialTicker,\n      selectedAddress: initialSelectedAddress,\n      onPreferencesStateChange,\n      onTokensStateChange,\n      onNetworkStateChange,\n    }: {\n      chainId: Hex;\n      ticker: string;\n      selectedAddress: string;\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onTokensStateChange: (\n        listener: (tokensState: TokensState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n    },\n    config?: Partial<TokenRatesConfig>,\n    state?: Partial<TokenRatesState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      disabled: false,\n      interval: 3 * 60 * 1000,\n      nativeCurrency: initialTicker,\n      chainId: initialChainId,\n      selectedAddress: initialSelectedAddress,\n      allTokens: {}, // TODO: initialize these correctly, maybe as part of BaseControllerV2 migration\n      allDetectedTokens: {},\n      threshold: 6 * 60 * 60 * 1000,\n    };\n\n    this.defaultState = {\n      contractExchangeRates: {},\n    };\n    this.initialize();\n    if (config?.disabled) {\n      this.configure({ disabled: true }, false, false);\n    }\n    this.#updateTokenList();\n\n    onPreferencesStateChange(async ({ selectedAddress }) => {\n      if (this.config.selectedAddress !== selectedAddress) {\n        this.configure({ selectedAddress });\n        this.#updateTokenList();\n        if (this.#pollState === PollState.Active) {\n          await this.updateExchangeRates();\n        }\n      }\n    });\n\n    onTokensStateChange(async ({ allTokens, allDetectedTokens }) => {\n      // These two state properties are assumed to be immutable\n      if (\n        this.config.allTokens !== allTokens ||\n        this.config.allDetectedTokens !== allDetectedTokens\n      ) {\n        this.configure({ allTokens, allDetectedTokens });\n        this.#updateTokenList();\n        if (this.#pollState === PollState.Active) {\n          await this.updateExchangeRates();\n        }\n      }\n    });\n\n    onNetworkStateChange(async ({ providerConfig }) => {\n      const { chainId, ticker } = providerConfig;\n      if (\n        this.config.chainId !== chainId ||\n        this.config.nativeCurrency !== ticker\n      ) {\n        this.update({ contractExchangeRates: {} });\n        this.configure({ chainId, nativeCurrency: ticker });\n        this.#updateTokenList();\n        if (this.#pollState === PollState.Active) {\n          await this.updateExchangeRates();\n        }\n      }\n    });\n  }\n\n  #updateTokenList() {\n    const { allTokens, allDetectedTokens } = this.config;\n    const tokens =\n      allTokens[this.config.chainId]?.[this.config.selectedAddress] || [];\n    const detectedTokens =\n      allDetectedTokens[this.config.chainId]?.[this.config.selectedAddress] ||\n      [];\n    this.tokenList = [...tokens, ...detectedTokens];\n  }\n\n  /**\n   * Start (or restart) polling.\n   */\n  async start() {\n    this.#stopPoll();\n    this.#pollState = PollState.Active;\n    await this.#poll();\n  }\n\n  /**\n   * Stop polling.\n   */\n  stop() {\n    this.#stopPoll();\n    this.#pollState = PollState.Inactive;\n  }\n\n  /**\n   * Clear the active polling timer, if present.\n   */\n  #stopPoll() {\n    if (this.handle) {\n      clearTimeout(this.handle);\n    }\n  }\n\n  /**\n   * Poll for exchange rate updates.\n   */\n  async #poll() {\n    await safelyExecute(() => this.updateExchangeRates());\n\n    // Poll using recursive `setTimeout` instead of `setInterval` so that\n    // requests don't stack if they take longer than the polling interval\n    this.handle = setTimeout(() => {\n      this.#poll();\n    }, this.config.interval);\n  }\n\n  /**\n   * Fetches a pairs of token address and native currency.\n   *\n   * @param chainSlug - Chain string identifier.\n   * @param vsCurrency - Query according to tokens in tokenList and native currency.\n   * @returns The exchange rates for the given pairs.\n   */\n  async fetchExchangeRate(\n    chainSlug: string,\n    vsCurrency: string,\n  ): Promise<CoinGeckoResponse> {\n    const tokenPairs = this.tokenList.map((token) => token.address).join(',');\n    const query = `contract_addresses=${tokenPairs}&vs_currencies=${vsCurrency.toLowerCase()}`;\n    return handleFetch(CoinGeckoApi.getTokenPriceURL(chainSlug, query));\n  }\n\n  /**\n   * Checks if the current native currency is a supported vs currency to use\n   * to query for token exchange rates.\n   *\n   * @param nativeCurrency - The native currency of the currently active network.\n   * @returns A boolean indicating whether it's a supported vsCurrency.\n   */\n  private async checkIsSupportedVsCurrency(nativeCurrency: string) {\n    const { threshold } = this.config;\n    const { timestamp, data } = this.supportedVsCurrencies;\n\n    const now = Date.now();\n\n    if (now - timestamp > threshold) {\n      const currencies = await handleFetch(\n        CoinGeckoApi.getSupportedVsCurrencies(),\n      );\n      this.supportedVsCurrencies = {\n        data: currencies,\n        timestamp: Date.now(),\n      };\n      return currencies.includes(nativeCurrency.toLowerCase());\n    }\n\n    return data.includes(nativeCurrency.toLowerCase());\n  }\n\n  /**\n   * Gets current chain ID slug from cached supported platforms CoinGecko API response.\n   * If cached supported platforms response is stale, fetches and updates it.\n   *\n   * @returns The CoinGecko slug for the current chain ID.\n   */\n  async getChainSlug(): Promise<string | null> {\n    const { threshold, chainId } = this.config;\n    const { data, timestamp } = this.supportedChains;\n\n    const now = Date.now();\n\n    if (now - timestamp > threshold) {\n      const platforms = await handleFetch(CoinGeckoApi.getPlatformsURL());\n      this.supportedChains = {\n        data: platforms,\n        timestamp: Date.now(),\n      };\n      return findChainSlug(chainId, platforms);\n    }\n\n    return findChainSlug(chainId, data);\n  }\n\n  /**\n   * Updates exchange rates for all tokens.\n   */\n  async updateExchangeRates() {\n    if (this.tokenList.length === 0 || this.disabled) {\n      return;\n    }\n    const slug = await this.getChainSlug();\n\n    let newContractExchangeRates: ContractExchangeRates = {};\n    if (!slug) {\n      this.tokenList.forEach((token) => {\n        const address = toChecksumHexAddress(token.address);\n        newContractExchangeRates[address] = undefined;\n      });\n    } else {\n      const { nativeCurrency } = this.config;\n      newContractExchangeRates = await this.fetchAndMapExchangeRates(\n        nativeCurrency,\n        slug,\n      );\n    }\n    this.update({ contractExchangeRates: newContractExchangeRates });\n  }\n\n  /**\n   * Checks if the active network's native currency is supported by the coingecko API.\n   * If supported, it fetches and maps contractExchange rates to a format to be consumed by the UI.\n   * If not supported, it fetches contractExchange rates and maps them from token/fallback-currency\n   * to token/nativeCurrency.\n   *\n   * @param nativeCurrency - The native currency of the currently active network.\n   * @param slug - The unique slug used to id the chain by the coingecko api\n   * should be used to query token exchange rates.\n   * @returns An object with conversion rates for each token\n   * related to the network's native currency.\n   */\n  async fetchAndMapExchangeRates(\n    nativeCurrency: string,\n    slug: string,\n  ): Promise<ContractExchangeRates> {\n    const contractExchangeRates: ContractExchangeRates = {};\n\n    // check if native currency is supported as a vs_currency by the API\n    const nativeCurrencySupported = await this.checkIsSupportedVsCurrency(\n      nativeCurrency,\n    );\n\n    if (nativeCurrencySupported) {\n      // If it is we can do a simple fetch against the CoinGecko API\n      const prices = await this.fetchExchangeRate(slug, nativeCurrency);\n      this.tokenList.forEach((token) => {\n        const price = prices[token.address.toLowerCase()];\n        contractExchangeRates[toChecksumHexAddress(token.address)] = price\n          ? price[nativeCurrency.toLowerCase()]\n          : 0;\n      });\n    } else {\n      // if native currency is not supported we need to use a fallback vsCurrency, get the exchange rates\n      // in token/fallback-currency format and convert them to expected token/nativeCurrency format.\n      let tokenExchangeRates;\n      let vsCurrencyToNativeCurrencyConversionRate = 0;\n      try {\n        [\n          tokenExchangeRates,\n          { conversionRate: vsCurrencyToNativeCurrencyConversionRate },\n        ] = await Promise.all([\n          this.fetchExchangeRate(slug, FALL_BACK_VS_CURRENCY),\n          fetchNativeExchangeRate(nativeCurrency, FALL_BACK_VS_CURRENCY, false),\n        ]);\n      } catch (error) {\n        if (\n          error instanceof Error &&\n          error.message.includes('market does not exist for this coin pair')\n        ) {\n          return {};\n        }\n        throw error;\n      }\n\n      for (const [tokenAddress, conversion] of Object.entries(\n        tokenExchangeRates,\n      )) {\n        const tokenToVsCurrencyConversionRate =\n          conversion[FALL_BACK_VS_CURRENCY.toLowerCase()];\n        contractExchangeRates[toChecksumHexAddress(tokenAddress)] =\n          tokenToVsCurrencyConversionRate *\n          vsCurrencyToNativeCurrencyConversionRate;\n      }\n    }\n\n    return contractExchangeRates;\n  }\n}\n\nexport default TokenRatesController;\n"]}
\ No newline at end of file
+{"version":3,"file":"TokenRatesController.js","sourceRoot":"","sources":["../src/TokenRatesController.ts"],"names":[],"mappings":"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","sourcesContent":["import { BaseController } from '@metamask/base-controller';\nimport type { BaseConfig, BaseState } from '@metamask/base-controller';\nimport {\n  safelyExecute,\n  toChecksumHexAddress,\n  FALL_BACK_VS_CURRENCY,\n  toHex,\n} from '@metamask/controller-utils';\nimport type { NetworkState } from '@metamask/network-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport type { Hex } from '@metamask/utils';\nimport { isEqual } from 'lodash';\n\nimport { reduceInBatchesSerially } from './assetsUtil';\nimport { fetchExchangeRate as fetchNativeCurrencyExchangeRate } from './crypto-compare';\nimport type { AbstractTokenPricesService } from './token-prices-service/abstract-token-prices-service';\nimport type { TokensState } from './TokensController';\n\n/**\n * @type Token\n *\n * Token representation\n * @property address - Hex address of the token contract\n * @property decimals - Number of decimals the token uses\n * @property symbol - Symbol of the token\n * @property image - Image of the token, url or bit32 image\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface Token {\n  address: string;\n  decimals: number;\n  symbol: string;\n  aggregators?: string[];\n  image?: string;\n  balanceError?: unknown;\n  isERC721?: boolean;\n  name?: string;\n}\n\n/**\n * @type TokenRatesConfig\n *\n * Token rates controller configuration\n * @property interval - Polling interval used to fetch new token rates\n * @property nativeCurrency - Current native currency selected to use base of rates\n * @property chainId - Current network chainId\n * @property tokens - List of tokens to track exchange rates for\n * @property threshold - Threshold to invalidate the supportedChains\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface TokenRatesConfig extends BaseConfig {\n  interval: number;\n  nativeCurrency: string;\n  chainId: Hex;\n  selectedAddress: string;\n  allTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n  allDetectedTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n  threshold: number;\n}\n\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\ninterface ContractExchangeRates {\n  [address: string]: number | undefined;\n}\n\nenum PollState {\n  Active = 'Active',\n  Inactive = 'Inactive',\n}\n\n/**\n * @type TokenRatesState\n *\n * Token rates controller state\n * @property contractExchangeRates - Hash of token contract addresses to exchange rates (single globally selected chain, will be deprecated soon)\n * @property contractExchangeRatesByChainId - Hash of token contract addresses to exchange rates keyed by chain ID and native currency (ticker)\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface TokenRatesState extends BaseState {\n  contractExchangeRates: ContractExchangeRates;\n  contractExchangeRatesByChainId: Record<\n    string,\n    Record<string, ContractExchangeRates>\n  >;\n}\n\n/**\n * The maximum number of token addresses that should be sent to the Price API in\n * a single request.\n */\nconst TOKEN_PRICES_BATCH_SIZE = 30;\n\n/**\n * Uses the CryptoCompare API to fetch the exchange rate between one currency\n * and another, i.e., the multiplier to apply the amount of one currency in\n * order to convert it to another.\n *\n * @param args - The arguments to this function.\n * @param args.from - The currency to convert from.\n * @param args.to - The currency to convert to.\n * @returns The exchange rate between `fromCurrency` to `toCurrency` if one\n * exists, or null if one does not.\n */\nasync function getCurrencyConversionRate({\n  from,\n  to,\n}: {\n  from: string;\n  to: string;\n}) {\n  const includeUSDRate = false;\n  try {\n    const result = await fetchNativeCurrencyExchangeRate(\n      to,\n      from,\n      includeUSDRate,\n    );\n    return result.conversionRate;\n  } catch (error) {\n    if (\n      error instanceof Error &&\n      error.message.includes('market does not exist for this coin pair')\n    ) {\n      return null;\n    }\n    throw error;\n  }\n}\n\n/**\n * Controller that passively polls on a set interval for token-to-fiat exchange rates\n * for tokens stored in the TokensController\n */\n// This is using BaseController on BaseController v3, which relates to BaseController V1\n// When rebase this patch doesn't forget about change this to `BaseController` instead of `BaseControllerV1`\nexport class TokenRatesController extends BaseController<\n  TokenRatesConfig,\n  TokenRatesState\n> {\n  private handle?: ReturnType<typeof setTimeout>;\n\n  #pollState = PollState.Inactive;\n\n  #tokenPricesService: AbstractTokenPricesService;\n\n  #inProcessExchangeRateUpdates: Record<`${string}:${string}`, Promise<void>> =\n    {};\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'TokenRatesController';\n\n  /**\n   * Creates a TokenRatesController instance.\n   *\n   * @param options - The controller options.\n   * @param options.interval - The polling interval in ms\n   * @param options.threshold - The duration in ms before metadata fetched from CoinGecko is considered stale\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.ticker - The ticker for the current network.\n   * @param options.selectedAddress - The current selected address.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.onTokensStateChange - Allows subscribing to token controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network state changes.\n   * @param options.tokenPricesService - An object in charge of retrieving token prices.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      interval = 3 * 60 * 1000,\n      threshold = 6 * 60 * 60 * 1000,\n      chainId: initialChainId,\n      ticker: initialTicker,\n      selectedAddress: initialSelectedAddress,\n      onPreferencesStateChange,\n      onTokensStateChange,\n      onNetworkStateChange,\n      tokenPricesService,\n    }: {\n      interval?: number;\n      threshold?: number;\n      chainId: Hex;\n      ticker: string;\n      selectedAddress: string;\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onTokensStateChange: (\n        listener: (tokensState: TokensState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      tokenPricesService: AbstractTokenPricesService;\n    },\n    config?: Partial<TokenRatesConfig>,\n    state?: Partial<TokenRatesState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      interval,\n      threshold,\n      disabled: false,\n      nativeCurrency: initialTicker,\n      chainId: initialChainId,\n      selectedAddress: initialSelectedAddress,\n      allTokens: {}, // TODO: initialize these correctly, maybe as part of BaseControllerV2 migration\n      allDetectedTokens: {},\n    };\n\n    this.defaultState = {\n      contractExchangeRates: {},\n      contractExchangeRatesByChainId: {},\n    };\n    this.initialize();\n    this.#tokenPricesService = tokenPricesService;\n\n    if (config?.disabled) {\n      this.configure({ disabled: true }, false, false);\n    }\n\n    onPreferencesStateChange(async ({ selectedAddress }) => {\n      if (this.config.selectedAddress !== selectedAddress) {\n        this.configure({ selectedAddress });\n        if (this.#pollState === PollState.Active) {\n          await this.updateExchangeRates();\n        }\n      }\n    });\n\n    onTokensStateChange(async ({ allTokens, allDetectedTokens }) => {\n      const previousTokenAddresses = this.#getTokenAddresses(\n        this.config.chainId,\n      );\n      this.configure({ allTokens, allDetectedTokens });\n      const newTokenAddresses = this.#getTokenAddresses(this.config.chainId);\n      if (\n        !isEqual(previousTokenAddresses, newTokenAddresses) &&\n        this.#pollState === PollState.Active\n      ) {\n        await this.updateExchangeRates();\n      }\n    });\n\n    onNetworkStateChange(async ({ providerConfig }) => {\n      const { chainId, ticker } = providerConfig;\n      if (\n        this.config.chainId !== chainId ||\n        this.config.nativeCurrency !== ticker\n      ) {\n        this.update({ contractExchangeRates: {} });\n        this.configure({ chainId, nativeCurrency: ticker || 'ETH' });\n        if (this.#pollState === PollState.Active) {\n          await this.updateExchangeRates();\n        }\n      }\n    });\n  }\n\n  /**\n   * Get the user's tokens for the given chain.\n   *\n   * @param chainId - The chain ID.\n   * @returns The list of tokens addresses for the current chain\n   */\n  #getTokenAddresses(chainId: Hex): Hex[] {\n    const { allTokens, allDetectedTokens } = this.config;\n    const tokens = allTokens[chainId]?.[this.config.selectedAddress] || [];\n    const detectedTokens =\n      allDetectedTokens[chainId]?.[this.config.selectedAddress] || [];\n\n    return [\n      ...new Set(\n        [...tokens, ...detectedTokens].map((token) =>\n          toHex(toChecksumHexAddress(token.address)),\n        ),\n      ),\n    ].sort();\n  }\n\n  /**\n   * Start (or restart) polling.\n   */\n  async start() {\n    this.#stopPoll();\n    this.#pollState = PollState.Active;\n    await this.#poll();\n  }\n\n  /**\n   * Stop polling.\n   */\n  stop() {\n    this.#stopPoll();\n    this.#pollState = PollState.Inactive;\n  }\n\n  /**\n   * Clear the active polling timer, if present.\n   */\n  #stopPoll() {\n    if (this.handle) {\n      clearTimeout(this.handle);\n    }\n  }\n\n  /**\n   * Poll for exchange rate updates.\n   */\n  async #poll() {\n    await safelyExecute(() => this.updateExchangeRates());\n\n    // Poll using recursive `setTimeout` instead of `setInterval` so that\n    // requests don't stack if they take longer than the polling interval\n    this.handle = setTimeout(() => {\n      this.#poll();\n    }, this.config.interval);\n  }\n\n  /**\n   * Updates exchange rates for all tokens.\n   */\n  async updateExchangeRates() {\n    const { chainId, nativeCurrency } = this.config;\n\n    if (this.disabled) {\n      return;\n    }\n\n    const tokenAddresses = this.#getTokenAddresses(chainId);\n    if (tokenAddresses.length === 0) {\n      return;\n    }\n\n    const updateKey: `${string}:${string}` = `${chainId}:${nativeCurrency}`;\n    if (updateKey in this.#inProcessExchangeRateUpdates) {\n      // This prevents redundant updates\n      // This promise is resolved after the in-progress update has finished,\n      // and state has been updated.\n      await this.#inProcessExchangeRateUpdates[updateKey];\n      return;\n    }\n\n    const {\n      promise: inProgressUpdate,\n      resolve: updateSucceeded,\n      reject: updateFailed,\n    } = createDeferredPromise({ suppressUnhandledRejection: true });\n    this.#inProcessExchangeRateUpdates[updateKey] = inProgressUpdate;\n\n    try {\n      const newContractExchangeRates = await this.#fetchAndMapExchangeRates({\n        tokenAddresses,\n        chainId,\n        nativeCurrency,\n      });\n\n      const existingContractExchangeRates = this.state.contractExchangeRates;\n      const updatedContractExchangeRates =\n        chainId === this.config.chainId &&\n        nativeCurrency === this.config.nativeCurrency\n          ? newContractExchangeRates\n          : existingContractExchangeRates;\n\n      const existingContractExchangeRatesForChainId =\n        this.state.contractExchangeRatesByChainId[chainId] ?? {};\n      const updatedContractExchangeRatesForChainId = {\n        ...this.state.contractExchangeRatesByChainId,\n        [chainId]: {\n          ...existingContractExchangeRatesForChainId,\n          [nativeCurrency]: {\n            ...existingContractExchangeRatesForChainId[nativeCurrency],\n            ...newContractExchangeRates,\n          },\n        },\n      };\n\n      this.update({\n        contractExchangeRates: updatedContractExchangeRates,\n        contractExchangeRatesByChainId: updatedContractExchangeRatesForChainId,\n      });\n      updateSucceeded();\n    } catch (error: unknown) {\n      updateFailed(error);\n      throw error;\n    } finally {\n      delete this.#inProcessExchangeRateUpdates[updateKey];\n    }\n  }\n\n  /**\n   * Uses the token prices service to retrieve exchange rates for tokens in a\n   * particular currency.\n   *\n   * If the price API does not support the given chain ID, returns an empty\n   * object.\n   *\n   * If the price API does not support the given currency, retrieves exchange\n   * rates in a known currency instead, then converts those rates using the\n   * exchange rate between the known currency and desired currency.\n   *\n   * @param args - The arguments to this function.\n   * @param args.tokenAddresses - Addresses for tokens.\n   * @param args.chainId - The EIP-155 ID of the chain where the tokens live.\n   * @param args.nativeCurrency - The native currency in which to request\n   * exchange rates.\n   * @returns A map from token address to its exchange rate in the native\n   * currency, or an empty map if no exchange rates can be obtained for the\n   * chain ID.\n   */\n  async #fetchAndMapExchangeRates({\n    tokenAddresses,\n    chainId,\n    nativeCurrency,\n  }: {\n    tokenAddresses: Hex[];\n    chainId: Hex;\n    nativeCurrency: string;\n  }): Promise<ContractExchangeRates> {\n    if (!this.#tokenPricesService.validateChainIdSupported(chainId)) {\n      return tokenAddresses.reduce((obj, tokenAddress) => {\n        return {\n          ...obj,\n          [tokenAddress]: undefined,\n        };\n      }, {});\n    }\n\n    if (this.#tokenPricesService.validateCurrencySupported(nativeCurrency)) {\n      return await this.#fetchAndMapExchangeRatesForSupportedNativeCurrency({\n        tokenAddresses,\n        chainId,\n        nativeCurrency,\n      });\n    }\n\n    return await this.#fetchAndMapExchangeRatesForUnsupportedNativeCurrency({\n      tokenAddresses,\n      nativeCurrency,\n    });\n  }\n\n  /**\n   * Retrieves prices in the given currency for the given tokens on the given\n   * chain. Ensures that token addresses are checksum addresses.\n   *\n   * @param args - The arguments to this function.\n   * @param args.tokenAddresses - Addresses for tokens.\n   * @param args.chainId - The EIP-155 ID of the chain where the tokens live.\n   * @param args.nativeCurrency - The native currency in which to request\n   * prices.\n   * @returns A map of the token addresses (as checksums) to their prices in the\n   * native currency.\n   */\n  async #fetchAndMapExchangeRatesForSupportedNativeCurrency({\n    tokenAddresses,\n    chainId,\n    nativeCurrency,\n  }: {\n    tokenAddresses: Hex[];\n    chainId: Hex;\n    nativeCurrency: string;\n  }): Promise<ContractExchangeRates> {\n    const tokenPricesByTokenAddress = await reduceInBatchesSerially<\n      Hex,\n      Awaited<ReturnType<AbstractTokenPricesService['fetchTokenPrices']>>\n    >({\n      values: [...tokenAddresses].sort(),\n      batchSize: TOKEN_PRICES_BATCH_SIZE,\n      eachBatch: async (allTokenPricesByTokenAddress, batch) => {\n        const tokenPricesByTokenAddressForBatch =\n          await this.#tokenPricesService.fetchTokenPrices({\n            tokenAddresses: batch,\n            chainId,\n            currency: nativeCurrency,\n          });\n\n        return {\n          ...allTokenPricesByTokenAddress,\n          ...tokenPricesByTokenAddressForBatch,\n        };\n      },\n      initialResult: {},\n    });\n\n    return Object.entries(tokenPricesByTokenAddress).reduce(\n      (obj, [tokenAddress, tokenPrice]) => {\n        return {\n          ...obj,\n          [tokenAddress]: tokenPrice?.value,\n        };\n      },\n      {},\n    );\n  }\n\n  /**\n   * If the price API does not support a given native currency, then we need to\n   * convert it to a fallback currency and feed that currency into the price\n   * API, then convert the prices to our desired native currency.\n   *\n   * @param args - The arguments to this function.\n   * @param args.tokenAddresses - Addresses for tokens.\n   * @param args.nativeCurrency - The native currency in which to request\n   * prices.\n   * @returns A map of the token addresses (as checksums) to their prices in the\n   * native currency.\n   */\n  async #fetchAndMapExchangeRatesForUnsupportedNativeCurrency({\n    tokenAddresses,\n    nativeCurrency,\n  }: {\n    tokenAddresses: Hex[];\n    nativeCurrency: string;\n  }): Promise<ContractExchangeRates> {\n    const [\n      contractExchangeRates,\n      fallbackCurrencyToNativeCurrencyConversionRate,\n    ] = await Promise.all([\n      this.#fetchAndMapExchangeRatesForSupportedNativeCurrency({\n        tokenAddresses,\n        chainId: this.config.chainId,\n        nativeCurrency: FALL_BACK_VS_CURRENCY,\n      }),\n      getCurrencyConversionRate({\n        from: FALL_BACK_VS_CURRENCY,\n        to: nativeCurrency,\n      }),\n    ]);\n\n    if (fallbackCurrencyToNativeCurrencyConversionRate === null) {\n      return {};\n    }\n\n    return Object.entries(contractExchangeRates).reduce(\n      (obj, [tokenAddress, tokenValue]) => {\n        return {\n          ...obj,\n          [tokenAddress]: tokenValue\n            ? tokenValue * fallbackCurrencyToNativeCurrencyConversionRate\n            : undefined,\n        };\n      },\n      {},\n    );\n  }\n}\n\n/**\n * A deferred Promise.\n *\n * A deferred Promise is one that can be resolved or rejected independently of\n * the Promise construction.\n */\ntype DeferredPromise = {\n  /**\n   * The Promise that has been deferred.\n   */\n  promise: Promise<void>;\n  /**\n   * A function that resolves the Promise.\n   */\n  resolve: () => void;\n  /**\n   * A function that rejects the Promise.\n   */\n  reject: (error: unknown) => void;\n};\n\n/**\n * Create a defered Promise.\n *\n * TODO: Migrate this to utils\n *\n * @param args - The arguments.\n * @param args.suppressUnhandledRejection - This option adds an empty error handler\n * to the Promise to suppress the UnhandledPromiseRejection error. This can be\n * useful if the deferred Promise is sometimes intentionally not used.\n * @returns A deferred Promise.\n */\nfunction createDeferredPromise({\n  suppressUnhandledRejection = false,\n}: {\n  suppressUnhandledRejection: boolean;\n}): DeferredPromise {\n  let resolve: DeferredPromise['resolve'];\n  let reject: DeferredPromise['reject'];\n  const promise = new Promise<void>(\n    (innerResolve: () => void, innerReject: () => void) => {\n      resolve = innerResolve;\n      reject = innerReject;\n    },\n  );\n\n  if (suppressUnhandledRejection) {\n    promise.catch((_error) => {\n      // This handler is used to suppress the UnhandledPromiseRejection error\n    });\n  }\n\n  // @ts-expect-error We know that these are assigned, but TypeScript doesn't\n  return { promise, resolve, reject };\n}\n\nexport default TokenRatesController;\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenRatesController.mjs b/node_modules/@metamask/assets-controllers/dist/TokenRatesController.mjs
new file mode 100644
index 0000000..ec6eaef
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/TokenRatesController.mjs
@@ -0,0 +1,12 @@
+import {
+  TokenRatesController,
+  TokenRatesController_default
+} from "./chunk-2IZUMKMY.mjs";
+import "./chunk-TCO22VIO.mjs";
+import "./chunk-E5PIGGYR.mjs";
+import "./chunk-XUI43LEZ.mjs";
+export {
+  TokenRatesController,
+  TokenRatesController_default as default
+};
+//# sourceMappingURL=TokenRatesController.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/TokenRatesController.mjs.map b/node_modules/@metamask/assets-controllers/dist/TokenRatesController.mjs.map
new file mode 100644
index 0000000..84c51b2
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/TokenRatesController.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":[],"sourcesContent":[],"mappings":"","names":[]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/TokensController.d.ts b/node_modules/@metamask/assets-controllers/dist/TokensController.d.ts
index d2d6e10..5e4a388 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokensController.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/TokensController.d.ts
@@ -1,15 +1,14 @@
 /// <reference types="node" />
+import { EventEmitter } from 'events';
+import { AddApprovalRequest } from '@metamask/approval-controller';
 import { Contract } from '@ethersproject/contracts';
-import type { AddApprovalRequest } from '@metamask/approval-controller';
-import type { BaseConfig, BaseState, RestrictedControllerMessenger } from '@metamask/base-controller';
-import { BaseController } from '@metamask/base-controller';
-import type { NetworkState } from '@metamask/network-controller';
-import type { PreferencesState } from '@metamask/preferences-controller';
 import type { Hex } from '@metamask/utils';
-import { EventEmitter } from 'events';
-import type { AssetsContractController } from './AssetsContractController';
-import type { TokenListState } from './TokenListController';
+import { BaseController, BaseConfig, BaseState, RestrictedControllerMessenger } from '@metamask/base-controller';
+import type { PreferencesState } from '@metamask/preferences-controller';
+import type { NetworkState } from '@metamask/network-controller';
 import type { Token } from './TokenRatesController';
+import { TokenListState } from './TokenListController';
+import type { AssetsContractController } from './AssetsContractController';
 /**
  * @type TokensConfig
  *
@@ -85,10 +84,11 @@ export declare type TokensControllerMessenger = RestrictedControllerMessenger<ty
  * Controller that stores assets and exposes convenience methods
  */
 export declare class TokensController extends BaseController<TokensConfig, TokensState> {
-    private readonly mutex;
+    private mutex;
     private ethersProvider;
     private abortController;
-    private readonly messagingSystem;
+    private messagingSystem;
+    private getERC20TokenName;
     /**
      * Fetch metadata for a token.
      *
@@ -104,7 +104,6 @@ export declare class TokensController extends BaseController<TokensConfig, Token
      * Name of this controller used during composition
      */
     name: string;
-    private readonly getERC20TokenName;
     /**
      * Creates a TokensController instance.
      *
@@ -117,6 +116,7 @@ export declare class TokensController extends BaseController<TokensConfig, Token
      * @param options.config - Initial options used to configure this controller.
      * @param options.state - Initial state to set on this controller.
      * @param options.messenger - The controller messenger.
+     * @param options.getERC20TokenName - Allows fetch an ERC-20 token name
      */
     constructor({ chainId: initialChainId, onPreferencesStateChange, onNetworkStateChange, onTokenListStateChange, getERC20TokenName, config, state, messenger, }: {
         chainId: Hex;
diff --git a/node_modules/@metamask/assets-controllers/dist/TokensController.d.ts.map b/node_modules/@metamask/assets-controllers/dist/TokensController.d.ts.map
index eb57cc2..dfb5c79 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokensController.d.ts.map
+++ b/node_modules/@metamask/assets-controllers/dist/TokensController.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"TokensController.d.ts","sourceRoot":"","sources":["../src/TokensController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"TokensController.d.ts","sourceRoot":"","sources":["../src/TokensController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/TokensController.js b/node_modules/@metamask/assets-controllers/dist/TokensController.js
index 81d5d4d..d9158fd 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokensController.js
+++ b/node_modules/@metamask/assets-controllers/dist/TokensController.js
@@ -13,16 +13,16 @@ var __importDefault = (this && this.__importDefault) || function (mod) {
 };
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.TokensController = void 0;
+const events_1 = require("events");
+const contract_metadata_1 = __importDefault(require("@metamask/contract-metadata"));
+const metamask_eth_abis_1 = require("@metamask/metamask-eth-abis");
+const uuid_1 = require("uuid");
+const async_mutex_1 = require("async-mutex");
 const contracts_1 = require("@ethersproject/contracts");
 const providers_1 = require("@ethersproject/providers");
+const abort_controller_1 = require("abort-controller");
 const base_controller_1 = require("@metamask/base-controller");
-const contract_metadata_1 = __importDefault(require("@metamask/contract-metadata"));
 const controller_utils_1 = require("@metamask/controller-utils");
-const metamask_eth_abis_1 = require("@metamask/metamask-eth-abis");
-const abort_controller_1 = require("abort-controller");
-const async_mutex_1 = require("async-mutex");
-const events_1 = require("events");
-const uuid_1 = require("uuid");
 const assetsUtil_1 = require("./assetsUtil");
 const token_service_1 = require("./token-service");
 /**
@@ -45,6 +45,7 @@ class TokensController extends base_controller_1.BaseController {
      * @param options.config - Initial options used to configure this controller.
      * @param options.state - Initial state to set on this controller.
      * @param options.messenger - The controller messenger.
+     * @param options.getERC20TokenName - Allows fetch an ERC-20 token name
      */
     constructor({ chainId: initialChainId, onPreferencesStateChange, onNetworkStateChange, onTokenListStateChange, getERC20TokenName, config, state, messenger, }) {
         super(config, state);
diff --git a/node_modules/@metamask/assets-controllers/dist/TokensController.js.map b/node_modules/@metamask/assets-controllers/dist/TokensController.js.map
index 37eb138..f1098f9 100644
--- a/node_modules/@metamask/assets-controllers/dist/TokensController.js.map
+++ b/node_modules/@metamask/assets-controllers/dist/TokensController.js.map
@@ -1 +1 @@
-{"version":3,"file":"TokensController.js","sourceRoot":"","sources":["../src/TokensController.ts"],"names":[],"mappings":"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","sourcesContent":["import { Contract } from '@ethersproject/contracts';\nimport { Web3Provider } from '@ethersproject/providers';\nimport type { AddApprovalRequest } from '@metamask/approval-controller';\nimport type {\n  BaseConfig,\n  BaseState,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport contractsMap from '@metamask/contract-metadata';\nimport {\n  toChecksumHexAddress,\n  ERC721_INTERFACE_ID,\n  ORIGIN_METAMASK,\n  ApprovalType,\n  ERC20,\n} from '@metamask/controller-utils';\nimport { abiERC721 } from '@metamask/metamask-eth-abis';\nimport type { NetworkState } from '@metamask/network-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport type { Hex } from '@metamask/utils';\nimport { AbortController as WhatwgAbortController } from 'abort-controller';\nimport { Mutex } from 'async-mutex';\nimport { EventEmitter } from 'events';\nimport { v1 as random } from 'uuid';\n\nimport type { AssetsContractController } from './AssetsContractController';\nimport {\n  formatAggregatorNames,\n  formatIconUrlWithProxy,\n  validateTokenToWatch,\n} from './assetsUtil';\nimport {\n  fetchTokenMetadata,\n  TOKEN_METADATA_NO_SUPPORT_ERROR,\n} from './token-service';\nimport type {\n  TokenListMap,\n  TokenListState,\n  TokenListToken,\n} from './TokenListController';\nimport type { Token } from './TokenRatesController';\n\n/**\n * @type TokensConfig\n *\n * Tokens controller configuration\n * @property selectedAddress - Vault selected address\n */\nexport interface TokensConfig extends BaseConfig {\n  selectedAddress: string;\n  chainId: Hex;\n  provider: any;\n}\n\n/**\n * @type SuggestedAssetMeta\n *\n * Suggested asset by EIP747 meta data\n * @property id - Generated UUID associated with this suggested asset\n * @property time - Timestamp associated with this this suggested asset\n * @property type - Type type this suggested asset\n * @property asset - Asset suggested object\n * @property interactingAddress - Account address that requested watch asset\n */\ntype SuggestedAssetMeta = {\n  id: string;\n  time: number;\n  type: string;\n  asset: Token;\n  interactingAddress: string;\n};\n\n/**\n * @type TokensState\n *\n * Assets controller state\n * @property tokens - List of tokens associated with the active network and address pair\n * @property ignoredTokens - List of ignoredTokens associated with the active network and address pair\n * @property detectedTokens - List of detected tokens associated with the active network and address pair\n * @property allTokens - Object containing tokens by network and account\n * @property allIgnoredTokens - Object containing hidden/ignored tokens by network and account\n * @property allDetectedTokens - Object containing tokens detected with non-zero balances\n */\nexport interface TokensState extends BaseState {\n  tokens: Token[];\n  ignoredTokens: string[];\n  detectedTokens: Token[];\n  allTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n  allIgnoredTokens: { [chainId: Hex]: { [key: string]: string[] } };\n  allDetectedTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n}\n\n/**\n * The name of the {@link TokensController}.\n */\nconst controllerName = 'TokensController';\n\n/**\n * The external actions available to the {@link TokensController}.\n */\ntype AllowedActions = AddApprovalRequest;\n\n/**\n * The messenger of the {@link TokensController}.\n */\nexport type TokensControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  AllowedActions,\n  never,\n  AllowedActions['type'],\n  never\n>;\n\n/**\n * Controller that stores assets and exposes convenience methods\n */\nexport class TokensController extends BaseController<\n  TokensConfig,\n  TokensState\n> {\n  private readonly mutex = new Mutex();\n\n  private ethersProvider: any;\n\n  private abortController: WhatwgAbortController;\n\n  private readonly messagingSystem: TokensControllerMessenger;\n\n  /**\n   * Fetch metadata for a token.\n   *\n   * @param tokenAddress - The address of the token.\n   * @returns The token metadata.\n   */\n  private async fetchTokenMetadata(\n    tokenAddress: string,\n  ): Promise<TokenListToken | undefined> {\n    try {\n      const token = await fetchTokenMetadata<TokenListToken>(\n        this.config.chainId,\n        tokenAddress,\n        this.abortController.signal,\n      );\n      return token;\n    } catch (error) {\n      if (\n        error instanceof Error &&\n        error.message.includes(TOKEN_METADATA_NO_SUPPORT_ERROR)\n      ) {\n        return undefined;\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * EventEmitter instance used to listen to specific EIP747 events\n   */\n  hub = new EventEmitter();\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'TokensController';\n\n  private readonly getERC20TokenName: AssetsContractController['getERC20TokenName'];\n\n  /**\n   * Creates a TokensController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param options.onTokenListStateChange - Allows subscribing to token list controller state changes.\n   * @param options.getERC20TokenName - Gets the ERC-20 token name.\n   * @param options.config - Initial options used to configure this controller.\n   * @param options.state - Initial state to set on this controller.\n   * @param options.messenger - The controller messenger.\n   */\n  constructor({\n    chainId: initialChainId,\n    onPreferencesStateChange,\n    onNetworkStateChange,\n    onTokenListStateChange,\n    getERC20TokenName,\n    config,\n    state,\n    messenger,\n  }: {\n    chainId: Hex;\n    onPreferencesStateChange: (\n      listener: (preferencesState: PreferencesState) => void,\n    ) => void;\n    onNetworkStateChange: (\n      listener: (networkState: NetworkState) => void,\n    ) => void;\n    onTokenListStateChange: (\n      listener: (tokenListState: TokenListState) => void,\n    ) => void;\n    getERC20TokenName: AssetsContractController['getERC20TokenName'];\n    config?: Partial<TokensConfig>;\n    state?: Partial<TokensState>;\n    messenger: TokensControllerMessenger;\n  }) {\n    super(config, state);\n\n    this.defaultConfig = {\n      selectedAddress: '',\n      chainId: initialChainId,\n      provider: undefined,\n      ...config,\n    };\n\n    this.defaultState = {\n      tokens: [],\n      ignoredTokens: [],\n      detectedTokens: [],\n      allTokens: {},\n      allIgnoredTokens: {},\n      allDetectedTokens: {},\n      ...state,\n    };\n\n    this.initialize();\n    this.abortController = new WhatwgAbortController();\n    this.getERC20TokenName = getERC20TokenName;\n\n    this.messagingSystem = messenger;\n\n    onPreferencesStateChange(({ selectedAddress }) => {\n      const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n      const { chainId } = this.config;\n      this.configure({ selectedAddress });\n      this.update({\n        tokens: allTokens[chainId]?.[selectedAddress] || [],\n        ignoredTokens: allIgnoredTokens[chainId]?.[selectedAddress] || [],\n        detectedTokens: allDetectedTokens[chainId]?.[selectedAddress] || [],\n      });\n    });\n\n    onNetworkStateChange(({ providerConfig }) => {\n      const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n      const { selectedAddress } = this.config;\n      const { chainId } = providerConfig;\n      this.abortController.abort();\n      this.abortController = new WhatwgAbortController();\n      this.configure({ chainId });\n      this.ethersProvider = this._instantiateNewEthersProvider();\n      this.update({\n        tokens: allTokens[chainId]?.[selectedAddress] || [],\n        ignoredTokens: allIgnoredTokens[chainId]?.[selectedAddress] || [],\n        detectedTokens: allDetectedTokens[chainId]?.[selectedAddress] || [],\n      });\n    });\n\n    onTokenListStateChange(({ tokenList }) => {\n      const { tokens } = this.state;\n      if (tokens.length && !tokens[0].name) {\n        this.updateTokensAttribute(tokenList, 'name');\n      }\n    });\n  }\n\n  _instantiateNewEthersProvider(): any {\n    return new Web3Provider(this.config?.provider);\n  }\n\n  /**\n   * Adds a token to the stored token list.\n   *\n   * @param address - Hex address of the token contract.\n   * @param symbol - Symbol of the token.\n   * @param decimals - Number of decimals the token uses.\n   * @param options - Object containing name and image of the token\n   * @param options.name - Name of the token\n   * @param options.image - Image of the token\n   * @param options.interactingAddress - The address of the account to add a token to.\n   * @returns Current token list.\n   */\n  async addToken(\n    address: string,\n    symbol: string,\n    decimals: number,\n    {\n      name,\n      image,\n      interactingAddress,\n    }: { name?: string; image?: string; interactingAddress?: string } = {},\n  ): Promise<Token[]> {\n    const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n    const { chainId: currentChainId, selectedAddress } = this.config;\n    const accountAddress = interactingAddress || selectedAddress;\n    const isInteractingWithWalletAccount = accountAddress === selectedAddress;\n    const releaseLock = await this.mutex.acquire();\n\n    try {\n      address = toChecksumHexAddress(address);\n      const tokens = allTokens[currentChainId]?.[accountAddress] || [];\n      const ignoredTokens =\n        allIgnoredTokens[currentChainId]?.[accountAddress] || [];\n      const detectedTokens =\n        allDetectedTokens[currentChainId]?.[accountAddress] || [];\n      const newTokens: Token[] = [...tokens];\n      const [isERC721, tokenMetadata] = await Promise.all([\n        this._detectIsERC721(address),\n        this.fetchTokenMetadata(address),\n      ]);\n      if (currentChainId !== this.config.chainId) {\n        throw new Error(\n          'TokensController Error: Switched networks while adding token',\n        );\n      }\n      const newEntry: Token = {\n        address,\n        symbol,\n        decimals,\n        image:\n          image ||\n          formatIconUrlWithProxy({\n            chainId: this.config.chainId,\n            tokenAddress: address,\n          }),\n        isERC721,\n        aggregators: formatAggregatorNames(tokenMetadata?.aggregators || []),\n        name,\n      };\n      const previousEntry = newTokens.find(\n        (token) => token.address.toLowerCase() === address.toLowerCase(),\n      );\n      if (previousEntry) {\n        const previousIndex = newTokens.indexOf(previousEntry);\n        newTokens[previousIndex] = newEntry;\n      } else {\n        newTokens.push(newEntry);\n      }\n\n      const newIgnoredTokens = ignoredTokens.filter(\n        (tokenAddress) => tokenAddress.toLowerCase() !== address.toLowerCase(),\n      );\n      const newDetectedTokens = detectedTokens.filter(\n        (token) => token.address.toLowerCase() !== address.toLowerCase(),\n      );\n\n      const { newAllTokens, newAllIgnoredTokens, newAllDetectedTokens } =\n        this._getNewAllTokensState({\n          newTokens,\n          newIgnoredTokens,\n          newDetectedTokens,\n          interactingAddress: accountAddress,\n        });\n\n      let newState: Partial<TokensState> = {\n        allTokens: newAllTokens,\n        allIgnoredTokens: newAllIgnoredTokens,\n        allDetectedTokens: newAllDetectedTokens,\n      };\n\n      // Only update active tokens if user is interacting with their active wallet account.\n      if (isInteractingWithWalletAccount) {\n        newState = {\n          ...newState,\n          tokens: newTokens,\n          ignoredTokens: newIgnoredTokens,\n          detectedTokens: newDetectedTokens,\n        };\n      }\n\n      this.update(newState);\n      return newTokens;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Add a batch of tokens.\n   *\n   * @param tokensToImport - Array of tokens to import.\n   */\n  async addTokens(tokensToImport: Token[]) {\n    const releaseLock = await this.mutex.acquire();\n    const { tokens, detectedTokens, ignoredTokens } = this.state;\n    const importedTokensMap: { [key: string]: true } = {};\n    // Used later to dedupe imported tokens\n    const newTokensMap = tokens.reduce((output, current) => {\n      output[current.address] = current;\n      return output;\n    }, {} as { [address: string]: Token });\n    try {\n      tokensToImport.forEach((tokenToAdd) => {\n        const { address, symbol, decimals, image, aggregators, name } =\n          tokenToAdd;\n        const checksumAddress = toChecksumHexAddress(address);\n        const formattedToken: Token = {\n          address: checksumAddress,\n          symbol,\n          decimals,\n          image,\n          aggregators,\n          name,\n        };\n        newTokensMap[address] = formattedToken;\n        importedTokensMap[address.toLowerCase()] = true;\n        return formattedToken;\n      });\n      const newTokens = Object.values(newTokensMap);\n\n      const newDetectedTokens = detectedTokens.filter(\n        (token) => !importedTokensMap[token.address.toLowerCase()],\n      );\n      const newIgnoredTokens = ignoredTokens.filter(\n        (tokenAddress) => !newTokensMap[tokenAddress.toLowerCase()],\n      );\n\n      const { newAllTokens, newAllDetectedTokens, newAllIgnoredTokens } =\n        this._getNewAllTokensState({\n          newTokens,\n          newDetectedTokens,\n          newIgnoredTokens,\n        });\n\n      this.update({\n        tokens: newTokens,\n        allTokens: newAllTokens,\n        detectedTokens: newDetectedTokens,\n        allDetectedTokens: newAllDetectedTokens,\n        ignoredTokens: newIgnoredTokens,\n        allIgnoredTokens: newAllIgnoredTokens,\n      });\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Ignore a batch of tokens.\n   *\n   * @param tokenAddressesToIgnore - Array of token addresses to ignore.\n   */\n  ignoreTokens(tokenAddressesToIgnore: string[]) {\n    const { ignoredTokens, detectedTokens, tokens } = this.state;\n    const ignoredTokensMap: { [key: string]: true } = {};\n    let newIgnoredTokens: string[] = [...ignoredTokens];\n\n    const checksummedTokenAddresses = tokenAddressesToIgnore.map((address) => {\n      const checksumAddress = toChecksumHexAddress(address);\n      ignoredTokensMap[address.toLowerCase()] = true;\n      return checksumAddress;\n    });\n    newIgnoredTokens = [...ignoredTokens, ...checksummedTokenAddresses];\n    const newDetectedTokens = detectedTokens.filter(\n      (token) => !ignoredTokensMap[token.address.toLowerCase()],\n    );\n    const newTokens = tokens.filter(\n      (token) => !ignoredTokensMap[token.address.toLowerCase()],\n    );\n\n    const { newAllIgnoredTokens, newAllDetectedTokens, newAllTokens } =\n      this._getNewAllTokensState({\n        newIgnoredTokens,\n        newDetectedTokens,\n        newTokens,\n      });\n\n    this.update({\n      ignoredTokens: newIgnoredTokens,\n      tokens: newTokens,\n      detectedTokens: newDetectedTokens,\n      allIgnoredTokens: newAllIgnoredTokens,\n      allDetectedTokens: newAllDetectedTokens,\n      allTokens: newAllTokens,\n    });\n  }\n\n  /**\n   * Adds a batch of detected tokens to the stored token list.\n   *\n   * @param incomingDetectedTokens - Array of detected tokens to be added or updated.\n   * @param detectionDetails - An object containing the chain ID and address of the currently selected network on which the incomingDetectedTokens were detected.\n   * @param detectionDetails.selectedAddress - the account address on which the incomingDetectedTokens were detected.\n   * @param detectionDetails.chainId - the chainId on which the incomingDetectedTokens were detected.\n   */\n  async addDetectedTokens(\n    incomingDetectedTokens: Token[],\n    detectionDetails?: { selectedAddress: string; chainId: Hex },\n  ) {\n    const releaseLock = await this.mutex.acquire();\n    const { tokens, detectedTokens, ignoredTokens } = this.state;\n    const newTokens: Token[] = [...tokens];\n    let newDetectedTokens: Token[] = [...detectedTokens];\n\n    try {\n      incomingDetectedTokens.forEach((tokenToAdd) => {\n        const {\n          address,\n          symbol,\n          decimals,\n          image,\n          aggregators,\n          isERC721,\n          name,\n        } = tokenToAdd;\n        const checksumAddress = toChecksumHexAddress(address);\n        const newEntry: Token = {\n          address: checksumAddress,\n          symbol,\n          decimals,\n          image,\n          isERC721,\n          aggregators,\n          name,\n        };\n        const previousImportedEntry = newTokens.find(\n          (token) =>\n            token.address.toLowerCase() === checksumAddress.toLowerCase(),\n        );\n        if (previousImportedEntry) {\n          // Update existing data of imported token\n          const previousImportedIndex = newTokens.indexOf(\n            previousImportedEntry,\n          );\n          newTokens[previousImportedIndex] = newEntry;\n        } else {\n          const ignoredTokenIndex = ignoredTokens.indexOf(address);\n          if (ignoredTokenIndex === -1) {\n            // Add detected token\n            const previousDetectedEntry = newDetectedTokens.find(\n              (token) =>\n                token.address.toLowerCase() === checksumAddress.toLowerCase(),\n            );\n            if (previousDetectedEntry) {\n              const previousDetectedIndex = newDetectedTokens.indexOf(\n                previousDetectedEntry,\n              );\n              newDetectedTokens[previousDetectedIndex] = newEntry;\n            } else {\n              newDetectedTokens.push(newEntry);\n            }\n          }\n        }\n      });\n\n      const {\n        selectedAddress: interactingAddress,\n        chainId: interactingChainId,\n      } = detectionDetails || {};\n\n      const { newAllTokens, newAllDetectedTokens } = this._getNewAllTokensState(\n        {\n          newTokens,\n          newDetectedTokens,\n          interactingAddress,\n          interactingChainId,\n        },\n      );\n\n      const { chainId, selectedAddress } = this.config;\n      // if the newly added detectedTokens were detected on (and therefore added to) a different chainId/selectedAddress than the currently configured combo\n      // the newDetectedTokens (which should contain the detectedTokens on the current chainId/address combo) needs to be repointed to the current chainId/address pair\n      // if the detectedTokens were detected on the current chainId/address then this won't change anything.\n      newDetectedTokens =\n        newAllDetectedTokens?.[chainId]?.[selectedAddress] || [];\n\n      this.update({\n        tokens: newTokens,\n        allTokens: newAllTokens,\n        detectedTokens: newDetectedTokens,\n        allDetectedTokens: newAllDetectedTokens,\n      });\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Adds isERC721 field to token object. This is called when a user attempts to add tokens that\n   * were previously added which do not yet had isERC721 field.\n   *\n   * @param tokenAddress - The contract address of the token requiring the isERC721 field added.\n   * @returns The new token object with the added isERC721 field.\n   */\n  async updateTokenType(tokenAddress: string) {\n    const isERC721 = await this._detectIsERC721(tokenAddress);\n    const { tokens } = this.state;\n    const tokenIndex = tokens.findIndex((token) => {\n      return token.address.toLowerCase() === tokenAddress.toLowerCase();\n    });\n    tokens[tokenIndex].isERC721 = isERC721;\n    this.update({ tokens });\n    return tokens[tokenIndex];\n  }\n\n  /**\n   * This is a function that updates the tokens name for the tokens name if it is not defined.\n   *\n   * @param tokenList - Represents the fetched token list from service API\n   * @param tokenAttribute - Represents the token attribute that we want to update on the token list\n   */\n  private updateTokensAttribute(\n    tokenList: TokenListMap,\n    tokenAttribute: keyof Token & keyof TokenListToken,\n  ) {\n    const { tokens } = this.state;\n\n    const newTokens = tokens.map((token) => {\n      const newToken = tokenList[token.address.toLowerCase()];\n\n      return !token[tokenAttribute] && newToken?.[tokenAttribute]\n        ? { ...token, [tokenAttribute]: newToken[tokenAttribute] }\n        : { ...token };\n    });\n\n    this.update({ tokens: newTokens });\n  }\n\n  /**\n   * Detects whether or not a token is ERC-721 compatible.\n   *\n   * @param tokenAddress - The token contract address.\n   * @returns A boolean indicating whether the token address passed in supports the EIP-721\n   * interface.\n   */\n  async _detectIsERC721(tokenAddress: string) {\n    const checksumAddress = toChecksumHexAddress(tokenAddress);\n    // if this token is already in our contract metadata map we don't need\n    // to check against the contract\n    if (contractsMap[checksumAddress]?.erc721 === true) {\n      return Promise.resolve(true);\n    } else if (contractsMap[checksumAddress]?.erc20 === true) {\n      return Promise.resolve(false);\n    }\n\n    const tokenContract = this._createEthersContract(\n      tokenAddress,\n      abiERC721,\n      this.ethersProvider,\n    );\n    try {\n      return await tokenContract.supportsInterface(ERC721_INTERFACE_ID);\n    } catch (error: any) {\n      // currently we see a variety of errors across different networks when\n      // token contracts are not ERC721 compatible. We need to figure out a better\n      // way of differentiating token interface types but for now if we get an error\n      // we have to assume the token is not ERC721 compatible.\n      return false;\n    }\n  }\n\n  _createEthersContract(\n    tokenAddress: string,\n    abi: string,\n    ethersProvider: any,\n  ): Contract {\n    const tokenContract = new Contract(tokenAddress, abi, ethersProvider);\n    return tokenContract;\n  }\n\n  _generateRandomId(): string {\n    return random();\n  }\n\n  /**\n   * Adds a new suggestedAsset to the list of watched assets.\n   * Parameters will be validated according to the asset type being watched.\n   *\n   * @param asset - The asset to be watched. For now only ERC20 tokens are accepted.\n   * @param type - The asset type.\n   * @param interactingAddress - The address of the account that is requesting to watch the asset.\n   * @returns Object containing a Promise resolving to the suggestedAsset address if accepted.\n   */\n  async watchAsset(\n    asset: Token,\n    type: string,\n    interactingAddress?: string,\n  ): Promise<void> {\n    if (type !== ERC20) {\n      throw new Error(`Asset of type ${type} not supported`);\n    }\n\n    const { selectedAddress } = this.config;\n\n    const suggestedAssetMeta: SuggestedAssetMeta = {\n      asset,\n      id: this._generateRandomId(),\n      time: Date.now(),\n      type,\n      interactingAddress: interactingAddress || selectedAddress,\n    };\n\n    validateTokenToWatch(asset);\n\n    await this._requestApproval(suggestedAssetMeta);\n\n    let name;\n    try {\n      name = await this.getERC20TokenName(asset.address);\n    } catch (error) {\n      name = undefined;\n    }\n\n    await this.addToken(asset.address, asset.symbol, asset.decimals, {\n      name,\n      image: asset.image,\n      interactingAddress: suggestedAssetMeta.interactingAddress,\n    });\n  }\n\n  /**\n   * Takes a new tokens and ignoredTokens array for the current network/account combination\n   * and returns new allTokens and allIgnoredTokens state to update to.\n   *\n   * @param params - Object that holds token params.\n   * @param params.newTokens - The new tokens to set for the current network and selected account.\n   * @param params.newIgnoredTokens - The new ignored tokens to set for the current network and selected account.\n   * @param params.newDetectedTokens - The new detected tokens to set for the current network and selected account.\n   * @param params.interactingAddress - The account address to use to store the tokens.\n   * @param params.interactingChainId - The chainId to use to store the tokens.\n   * @returns The updated `allTokens` and `allIgnoredTokens` state.\n   */\n  _getNewAllTokensState(params: {\n    newTokens?: Token[];\n    newIgnoredTokens?: string[];\n    newDetectedTokens?: Token[];\n    interactingAddress?: string;\n    interactingChainId?: Hex;\n  }) {\n    const {\n      newTokens,\n      newIgnoredTokens,\n      newDetectedTokens,\n      interactingAddress,\n      interactingChainId,\n    } = params;\n    const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n    const { chainId, selectedAddress } = this.config;\n\n    const userAddressToAddTokens = interactingAddress ?? selectedAddress;\n    const chainIdToAddTokens = interactingChainId ?? chainId;\n\n    let newAllTokens = allTokens;\n    if (\n      newTokens?.length ||\n      (newTokens &&\n        allTokens &&\n        allTokens[chainIdToAddTokens] &&\n        allTokens[chainIdToAddTokens][userAddressToAddTokens])\n    ) {\n      const networkTokens = allTokens[chainIdToAddTokens];\n      const newNetworkTokens = {\n        ...networkTokens,\n        ...{ [userAddressToAddTokens]: newTokens },\n      };\n      newAllTokens = {\n        ...allTokens,\n        ...{ [chainIdToAddTokens]: newNetworkTokens },\n      };\n    }\n\n    let newAllIgnoredTokens = allIgnoredTokens;\n    if (\n      newIgnoredTokens?.length ||\n      (newIgnoredTokens &&\n        allIgnoredTokens &&\n        allIgnoredTokens[chainIdToAddTokens] &&\n        allIgnoredTokens[chainIdToAddTokens][userAddressToAddTokens])\n    ) {\n      const networkIgnoredTokens = allIgnoredTokens[chainIdToAddTokens];\n      const newIgnoredNetworkTokens = {\n        ...networkIgnoredTokens,\n        ...{ [userAddressToAddTokens]: newIgnoredTokens },\n      };\n      newAllIgnoredTokens = {\n        ...allIgnoredTokens,\n        ...{ [chainIdToAddTokens]: newIgnoredNetworkTokens },\n      };\n    }\n\n    let newAllDetectedTokens = allDetectedTokens;\n    if (\n      newDetectedTokens?.length ||\n      (newDetectedTokens &&\n        allDetectedTokens &&\n        allDetectedTokens[chainIdToAddTokens] &&\n        allDetectedTokens[chainIdToAddTokens][userAddressToAddTokens])\n    ) {\n      const networkDetectedTokens = allDetectedTokens[chainIdToAddTokens];\n      const newDetectedNetworkTokens = {\n        ...networkDetectedTokens,\n        ...{ [userAddressToAddTokens]: newDetectedTokens },\n      };\n      newAllDetectedTokens = {\n        ...allDetectedTokens,\n        ...{ [chainIdToAddTokens]: newDetectedNetworkTokens },\n      };\n    }\n    return { newAllTokens, newAllIgnoredTokens, newAllDetectedTokens };\n  }\n\n  /**\n   * Removes all tokens from the ignored list.\n   */\n  clearIgnoredTokens() {\n    this.update({ ignoredTokens: [], allIgnoredTokens: {} });\n  }\n\n  async _requestApproval(suggestedAssetMeta: SuggestedAssetMeta) {\n    return this.messagingSystem.call(\n      'ApprovalController:addRequest',\n      {\n        id: suggestedAssetMeta.id,\n        origin: ORIGIN_METAMASK,\n        type: ApprovalType.WatchAsset,\n        requestData: {\n          id: suggestedAssetMeta.id,\n          interactingAddress: suggestedAssetMeta.interactingAddress,\n          asset: {\n            address: suggestedAssetMeta.asset.address,\n            decimals: suggestedAssetMeta.asset.decimals,\n            symbol: suggestedAssetMeta.asset.symbol,\n            image: suggestedAssetMeta.asset.image || null,\n          },\n        },\n      },\n      true,\n    );\n  }\n}\n\nexport default TokensController;\n"]}
\ No newline at end of file
+{"version":3,"file":"TokensController.js","sourceRoot":"","sources":["../src/TokensController.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from 'events';\nimport { AddApprovalRequest } from '@metamask/approval-controller';\nimport contractsMap from '@metamask/contract-metadata';\nimport { abiERC721 } from '@metamask/metamask-eth-abis';\nimport { v1 as random } from 'uuid';\nimport { Mutex } from 'async-mutex';\nimport { Contract } from '@ethersproject/contracts';\nimport { Web3Provider } from '@ethersproject/providers';\nimport { AbortController as WhatwgAbortController } from 'abort-controller';\nimport type { Hex } from '@metamask/utils';\nimport {\n  BaseController,\n  BaseConfig,\n  BaseState,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport type { NetworkState } from '@metamask/network-controller';\nimport {\n  toChecksumHexAddress,\n  ERC721_INTERFACE_ID,\n  ORIGIN_METAMASK,\n  ApprovalType,\n  ERC20,\n} from '@metamask/controller-utils';\nimport type { Token } from './TokenRatesController';\nimport {\n  TokenListMap,\n  TokenListToken,\n  TokenListState,\n} from './TokenListController';\nimport {\n  formatAggregatorNames,\n  formatIconUrlWithProxy,\n  validateTokenToWatch,\n} from './assetsUtil';\nimport {\n  fetchTokenMetadata,\n  TOKEN_METADATA_NO_SUPPORT_ERROR,\n} from './token-service';\nimport type { AssetsContractController } from './AssetsContractController';\n\n/**\n * @type TokensConfig\n *\n * Tokens controller configuration\n * @property selectedAddress - Vault selected address\n */\nexport interface TokensConfig extends BaseConfig {\n  selectedAddress: string;\n  chainId: Hex;\n  provider: any;\n}\n\n/**\n * @type SuggestedAssetMeta\n *\n * Suggested asset by EIP747 meta data\n * @property id - Generated UUID associated with this suggested asset\n * @property time - Timestamp associated with this this suggested asset\n * @property type - Type type this suggested asset\n * @property asset - Asset suggested object\n * @property interactingAddress - Account address that requested watch asset\n */\ntype SuggestedAssetMeta = {\n  id: string;\n  time: number;\n  type: string;\n  asset: Token;\n  interactingAddress: string;\n};\n\n/**\n * @type TokensState\n *\n * Assets controller state\n * @property tokens - List of tokens associated with the active network and address pair\n * @property ignoredTokens - List of ignoredTokens associated with the active network and address pair\n * @property detectedTokens - List of detected tokens associated with the active network and address pair\n * @property allTokens - Object containing tokens by network and account\n * @property allIgnoredTokens - Object containing hidden/ignored tokens by network and account\n * @property allDetectedTokens - Object containing tokens detected with non-zero balances\n */\nexport interface TokensState extends BaseState {\n  tokens: Token[];\n  ignoredTokens: string[];\n  detectedTokens: Token[];\n  allTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n  allIgnoredTokens: { [chainId: Hex]: { [key: string]: string[] } };\n  allDetectedTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n}\n\n/**\n * The name of the {@link TokensController}.\n */\nconst controllerName = 'TokensController';\n\n/**\n * The external actions available to the {@link TokensController}.\n */\ntype AllowedActions = AddApprovalRequest;\n\n/**\n * The messenger of the {@link TokensController}.\n */\nexport type TokensControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  AllowedActions,\n  never,\n  AllowedActions['type'],\n  never\n>;\n\n/**\n * Controller that stores assets and exposes convenience methods\n */\nexport class TokensController extends BaseController<\n  TokensConfig,\n  TokensState\n> {\n  private mutex = new Mutex();\n\n  private ethersProvider: any;\n\n  private abortController: WhatwgAbortController;\n\n  private messagingSystem: TokensControllerMessenger;\n\n  private getERC20TokenName: AssetsContractController['getERC20TokenName'];\n\n  /**\n   * Fetch metadata for a token.\n   *\n   * @param tokenAddress - The address of the token.\n   * @returns The token metadata.\n   */\n  private async fetchTokenMetadata(\n    tokenAddress: string,\n  ): Promise<TokenListToken | undefined> {\n    try {\n      const token = await fetchTokenMetadata<TokenListToken>(\n        this.config.chainId,\n        tokenAddress,\n        this.abortController.signal,\n      );\n      return token;\n    } catch (error) {\n      if (\n        error instanceof Error &&\n        error.message.includes(TOKEN_METADATA_NO_SUPPORT_ERROR)\n      ) {\n        return undefined;\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * EventEmitter instance used to listen to specific EIP747 events\n   */\n  hub = new EventEmitter();\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'TokensController';\n\n  /**\n   * Creates a TokensController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param options.onTokenListStateChange - Allows subscribing to token list controller state changes.\n   * @param options.getERC20TokenName - Gets the ERC-20 token name.\n   * @param options.config - Initial options used to configure this controller.\n   * @param options.state - Initial state to set on this controller.\n   * @param options.messenger - The controller messenger.\n   * @param options.getERC20TokenName - Allows fetch an ERC-20 token name\n   */\n  constructor({\n    chainId: initialChainId,\n    onPreferencesStateChange,\n    onNetworkStateChange,\n    onTokenListStateChange,\n    getERC20TokenName,\n    config,\n    state,\n    messenger,\n  }: {\n    chainId: Hex;\n    onPreferencesStateChange: (\n      listener: (preferencesState: PreferencesState) => void,\n    ) => void;\n    onNetworkStateChange: (\n      listener: (networkState: NetworkState) => void,\n    ) => void;\n    onTokenListStateChange: (\n      listener: (tokenListState: TokenListState) => void,\n    ) => void;\n    getERC20TokenName: AssetsContractController['getERC20TokenName'];\n    config?: Partial<TokensConfig>;\n    state?: Partial<TokensState>;\n    messenger: TokensControllerMessenger;\n  }) {\n    super(config, state);\n\n    this.defaultConfig = {\n      selectedAddress: '',\n      chainId: initialChainId,\n      provider: undefined,\n      ...config,\n    };\n\n    this.defaultState = {\n      tokens: [],\n      ignoredTokens: [],\n      detectedTokens: [],\n      allTokens: {},\n      allIgnoredTokens: {},\n      allDetectedTokens: {},\n      ...state,\n    };\n\n    this.initialize();\n    this.abortController = new WhatwgAbortController();\n    this.getERC20TokenName = getERC20TokenName;\n\n    this.messagingSystem = messenger;\n\n    onPreferencesStateChange(({ selectedAddress }) => {\n      const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n      const { chainId } = this.config;\n      this.configure({ selectedAddress });\n      this.update({\n        tokens: allTokens[chainId]?.[selectedAddress] || [],\n        ignoredTokens: allIgnoredTokens[chainId]?.[selectedAddress] || [],\n        detectedTokens: allDetectedTokens[chainId]?.[selectedAddress] || [],\n      });\n    });\n\n    onNetworkStateChange(({ providerConfig }) => {\n      const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n      const { selectedAddress } = this.config;\n      const { chainId } = providerConfig;\n      this.abortController.abort();\n      this.abortController = new WhatwgAbortController();\n      this.configure({ chainId });\n      this.ethersProvider = this._instantiateNewEthersProvider();\n      this.update({\n        tokens: allTokens[chainId]?.[selectedAddress] || [],\n        ignoredTokens: allIgnoredTokens[chainId]?.[selectedAddress] || [],\n        detectedTokens: allDetectedTokens[chainId]?.[selectedAddress] || [],\n      });\n    });\n\n    onTokenListStateChange(({ tokenList }) => {\n      const { tokens } = this.state;\n      if (tokens.length && !tokens[0].name) {\n        this.updateTokensAttribute(tokenList, 'name');\n      }\n    });\n  }\n\n  _instantiateNewEthersProvider(): any {\n    return new Web3Provider(this.config?.provider);\n  }\n\n  /**\n   * Adds a token to the stored token list.\n   *\n   * @param address - Hex address of the token contract.\n   * @param symbol - Symbol of the token.\n   * @param decimals - Number of decimals the token uses.\n   * @param options - Object containing name and image of the token\n   * @param options.name - Name of the token\n   * @param options.image - Image of the token\n   * @param options.interactingAddress - The address of the account to add a token to.\n   * @returns Current token list.\n   */\n  async addToken(\n    address: string,\n    symbol: string,\n    decimals: number,\n    {\n      name,\n      image,\n      interactingAddress,\n    }: { name?: string; image?: string; interactingAddress?: string } = {},\n  ): Promise<Token[]> {\n    const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n    const { chainId: currentChainId, selectedAddress } = this.config;\n    const accountAddress = interactingAddress || selectedAddress;\n    const isInteractingWithWalletAccount = accountAddress === selectedAddress;\n    const releaseLock = await this.mutex.acquire();\n\n    try {\n      address = toChecksumHexAddress(address);\n      const tokens = allTokens[currentChainId]?.[accountAddress] || [];\n      const ignoredTokens =\n        allIgnoredTokens[currentChainId]?.[accountAddress] || [];\n      const detectedTokens =\n        allDetectedTokens[currentChainId]?.[accountAddress] || [];\n      const newTokens: Token[] = [...tokens];\n      const [isERC721, tokenMetadata] = await Promise.all([\n        this._detectIsERC721(address),\n        this.fetchTokenMetadata(address),\n      ]);\n      if (currentChainId !== this.config.chainId) {\n        throw new Error(\n          'TokensController Error: Switched networks while adding token',\n        );\n      }\n      const newEntry: Token = {\n        address,\n        symbol,\n        decimals,\n        image:\n          image ||\n          formatIconUrlWithProxy({\n            chainId: this.config.chainId,\n            tokenAddress: address,\n          }),\n        isERC721,\n        aggregators: formatAggregatorNames(tokenMetadata?.aggregators || []),\n        name,\n      };\n      const previousEntry = newTokens.find(\n        (token) => token.address.toLowerCase() === address.toLowerCase(),\n      );\n      if (previousEntry) {\n        const previousIndex = newTokens.indexOf(previousEntry);\n        newTokens[previousIndex] = newEntry;\n      } else {\n        newTokens.push(newEntry);\n      }\n\n      const newIgnoredTokens = ignoredTokens.filter(\n        (tokenAddress) => tokenAddress.toLowerCase() !== address.toLowerCase(),\n      );\n      const newDetectedTokens = detectedTokens.filter(\n        (token) => token.address.toLowerCase() !== address.toLowerCase(),\n      );\n\n      const { newAllTokens, newAllIgnoredTokens, newAllDetectedTokens } =\n        this._getNewAllTokensState({\n          newTokens,\n          newIgnoredTokens,\n          newDetectedTokens,\n          interactingAddress: accountAddress,\n        });\n\n      let newState: Partial<TokensState> = {\n        allTokens: newAllTokens,\n        allIgnoredTokens: newAllIgnoredTokens,\n        allDetectedTokens: newAllDetectedTokens,\n      };\n\n      // Only update active tokens if user is interacting with their active wallet account.\n      if (isInteractingWithWalletAccount) {\n        newState = {\n          ...newState,\n          tokens: newTokens,\n          ignoredTokens: newIgnoredTokens,\n          detectedTokens: newDetectedTokens,\n        };\n      }\n\n      this.update(newState);\n      return newTokens;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Add a batch of tokens.\n   *\n   * @param tokensToImport - Array of tokens to import.\n   */\n  async addTokens(tokensToImport: Token[]) {\n    const releaseLock = await this.mutex.acquire();\n    const { tokens, detectedTokens, ignoredTokens } = this.state;\n    const importedTokensMap: { [key: string]: true } = {};\n    // Used later to dedupe imported tokens\n    const newTokensMap = tokens.reduce((output, current) => {\n      output[current.address] = current;\n      return output;\n    }, {} as { [address: string]: Token });\n    try {\n      tokensToImport.forEach((tokenToAdd) => {\n        const { address, symbol, decimals, image, aggregators, name } =\n          tokenToAdd;\n        const checksumAddress = toChecksumHexAddress(address);\n        const formattedToken: Token = {\n          address: checksumAddress,\n          symbol,\n          decimals,\n          image,\n          aggregators,\n          name,\n        };\n        newTokensMap[address] = formattedToken;\n        importedTokensMap[address.toLowerCase()] = true;\n        return formattedToken;\n      });\n      const newTokens = Object.values(newTokensMap);\n\n      const newDetectedTokens = detectedTokens.filter(\n        (token) => !importedTokensMap[token.address.toLowerCase()],\n      );\n      const newIgnoredTokens = ignoredTokens.filter(\n        (tokenAddress) => !newTokensMap[tokenAddress.toLowerCase()],\n      );\n\n      const { newAllTokens, newAllDetectedTokens, newAllIgnoredTokens } =\n        this._getNewAllTokensState({\n          newTokens,\n          newDetectedTokens,\n          newIgnoredTokens,\n        });\n\n      this.update({\n        tokens: newTokens,\n        allTokens: newAllTokens,\n        detectedTokens: newDetectedTokens,\n        allDetectedTokens: newAllDetectedTokens,\n        ignoredTokens: newIgnoredTokens,\n        allIgnoredTokens: newAllIgnoredTokens,\n      });\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Ignore a batch of tokens.\n   *\n   * @param tokenAddressesToIgnore - Array of token addresses to ignore.\n   */\n  ignoreTokens(tokenAddressesToIgnore: string[]) {\n    const { ignoredTokens, detectedTokens, tokens } = this.state;\n    const ignoredTokensMap: { [key: string]: true } = {};\n    let newIgnoredTokens: string[] = [...ignoredTokens];\n\n    const checksummedTokenAddresses = tokenAddressesToIgnore.map((address) => {\n      const checksumAddress = toChecksumHexAddress(address);\n      ignoredTokensMap[address.toLowerCase()] = true;\n      return checksumAddress;\n    });\n    newIgnoredTokens = [...ignoredTokens, ...checksummedTokenAddresses];\n    const newDetectedTokens = detectedTokens.filter(\n      (token) => !ignoredTokensMap[token.address.toLowerCase()],\n    );\n    const newTokens = tokens.filter(\n      (token) => !ignoredTokensMap[token.address.toLowerCase()],\n    );\n\n    const { newAllIgnoredTokens, newAllDetectedTokens, newAllTokens } =\n      this._getNewAllTokensState({\n        newIgnoredTokens,\n        newDetectedTokens,\n        newTokens,\n      });\n\n    this.update({\n      ignoredTokens: newIgnoredTokens,\n      tokens: newTokens,\n      detectedTokens: newDetectedTokens,\n      allIgnoredTokens: newAllIgnoredTokens,\n      allDetectedTokens: newAllDetectedTokens,\n      allTokens: newAllTokens,\n    });\n  }\n\n  /**\n   * Adds a batch of detected tokens to the stored token list.\n   *\n   * @param incomingDetectedTokens - Array of detected tokens to be added or updated.\n   * @param detectionDetails - An object containing the chain ID and address of the currently selected network on which the incomingDetectedTokens were detected.\n   * @param detectionDetails.selectedAddress - the account address on which the incomingDetectedTokens were detected.\n   * @param detectionDetails.chainId - the chainId on which the incomingDetectedTokens were detected.\n   */\n  async addDetectedTokens(\n    incomingDetectedTokens: Token[],\n    detectionDetails?: { selectedAddress: string; chainId: Hex },\n  ) {\n    const releaseLock = await this.mutex.acquire();\n    const { tokens, detectedTokens, ignoredTokens } = this.state;\n    const newTokens: Token[] = [...tokens];\n    let newDetectedTokens: Token[] = [...detectedTokens];\n\n    try {\n      incomingDetectedTokens.forEach((tokenToAdd) => {\n        const {\n          address,\n          symbol,\n          decimals,\n          image,\n          aggregators,\n          isERC721,\n          name,\n        } = tokenToAdd;\n        const checksumAddress = toChecksumHexAddress(address);\n        const newEntry: Token = {\n          address: checksumAddress,\n          symbol,\n          decimals,\n          image,\n          isERC721,\n          aggregators,\n          name,\n        };\n        const previousImportedEntry = newTokens.find(\n          (token) =>\n            token.address.toLowerCase() === checksumAddress.toLowerCase(),\n        );\n        if (previousImportedEntry) {\n          // Update existing data of imported token\n          const previousImportedIndex = newTokens.indexOf(\n            previousImportedEntry,\n          );\n          newTokens[previousImportedIndex] = newEntry;\n        } else {\n          const ignoredTokenIndex = ignoredTokens.indexOf(address);\n          if (ignoredTokenIndex === -1) {\n            // Add detected token\n            const previousDetectedEntry = newDetectedTokens.find(\n              (token) =>\n                token.address.toLowerCase() === checksumAddress.toLowerCase(),\n            );\n            if (previousDetectedEntry) {\n              const previousDetectedIndex = newDetectedTokens.indexOf(\n                previousDetectedEntry,\n              );\n              newDetectedTokens[previousDetectedIndex] = newEntry;\n            } else {\n              newDetectedTokens.push(newEntry);\n            }\n          }\n        }\n      });\n\n      const {\n        selectedAddress: interactingAddress,\n        chainId: interactingChainId,\n      } = detectionDetails || {};\n\n      const { newAllTokens, newAllDetectedTokens } = this._getNewAllTokensState(\n        {\n          newTokens,\n          newDetectedTokens,\n          interactingAddress,\n          interactingChainId,\n        },\n      );\n\n      const { chainId, selectedAddress } = this.config;\n      // if the newly added detectedTokens were detected on (and therefore added to) a different chainId/selectedAddress than the currently configured combo\n      // the newDetectedTokens (which should contain the detectedTokens on the current chainId/address combo) needs to be repointed to the current chainId/address pair\n      // if the detectedTokens were detected on the current chainId/address then this won't change anything.\n      newDetectedTokens =\n        newAllDetectedTokens?.[chainId]?.[selectedAddress] || [];\n\n      this.update({\n        tokens: newTokens,\n        allTokens: newAllTokens,\n        detectedTokens: newDetectedTokens,\n        allDetectedTokens: newAllDetectedTokens,\n      });\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Adds isERC721 field to token object. This is called when a user attempts to add tokens that\n   * were previously added which do not yet had isERC721 field.\n   *\n   * @param tokenAddress - The contract address of the token requiring the isERC721 field added.\n   * @returns The new token object with the added isERC721 field.\n   */\n  async updateTokenType(tokenAddress: string) {\n    const isERC721 = await this._detectIsERC721(tokenAddress);\n    const { tokens } = this.state;\n    const tokenIndex = tokens.findIndex((token) => {\n      return token.address.toLowerCase() === tokenAddress.toLowerCase();\n    });\n    tokens[tokenIndex].isERC721 = isERC721;\n    this.update({ tokens });\n    return tokens[tokenIndex];\n  }\n\n  /**\n   * This is a function that updates the tokens name for the tokens name if it is not defined.\n   *\n   * @param tokenList - Represents the fetched token list from service API\n   * @param tokenAttribute - Represents the token attribute that we want to update on the token list\n   */\n  private updateTokensAttribute(\n    tokenList: TokenListMap,\n    tokenAttribute: keyof Token & keyof TokenListToken,\n  ) {\n    const { tokens } = this.state;\n\n    const newTokens = tokens.map((token) => {\n      const newToken = tokenList[token.address.toLowerCase()];\n\n      return !token[tokenAttribute] && newToken?.[tokenAttribute]\n        ? { ...token, [tokenAttribute]: newToken[tokenAttribute] }\n        : { ...token };\n    });\n\n    this.update({ tokens: newTokens });\n  }\n\n  /**\n   * Detects whether or not a token is ERC-721 compatible.\n   *\n   * @param tokenAddress - The token contract address.\n   * @returns A boolean indicating whether the token address passed in supports the EIP-721\n   * interface.\n   */\n  async _detectIsERC721(tokenAddress: string) {\n    const checksumAddress = toChecksumHexAddress(tokenAddress);\n    // if this token is already in our contract metadata map we don't need\n    // to check against the contract\n    if (contractsMap[checksumAddress]?.erc721 === true) {\n      return Promise.resolve(true);\n    } else if (contractsMap[checksumAddress]?.erc20 === true) {\n      return Promise.resolve(false);\n    }\n\n    const tokenContract = this._createEthersContract(\n      tokenAddress,\n      abiERC721,\n      this.ethersProvider,\n    );\n    try {\n      return await tokenContract.supportsInterface(ERC721_INTERFACE_ID);\n    } catch (error: any) {\n      // currently we see a variety of errors across different networks when\n      // token contracts are not ERC721 compatible. We need to figure out a better\n      // way of differentiating token interface types but for now if we get an error\n      // we have to assume the token is not ERC721 compatible.\n      return false;\n    }\n  }\n\n  _createEthersContract(\n    tokenAddress: string,\n    abi: string,\n    ethersProvider: any,\n  ): Contract {\n    const tokenContract = new Contract(tokenAddress, abi, ethersProvider);\n    return tokenContract;\n  }\n\n  _generateRandomId(): string {\n    return random();\n  }\n\n  /**\n   * Adds a new suggestedAsset to the list of watched assets.\n   * Parameters will be validated according to the asset type being watched.\n   *\n   * @param asset - The asset to be watched. For now only ERC20 tokens are accepted.\n   * @param type - The asset type.\n   * @param interactingAddress - The address of the account that is requesting to watch the asset.\n   * @returns Object containing a Promise resolving to the suggestedAsset address if accepted.\n   */\n  async watchAsset(\n    asset: Token,\n    type: string,\n    interactingAddress?: string,\n  ): Promise<void> {\n    if (type !== ERC20) {\n      throw new Error(`Asset of type ${type} not supported`);\n    }\n\n    const { selectedAddress } = this.config;\n\n    const suggestedAssetMeta: SuggestedAssetMeta = {\n      asset,\n      id: this._generateRandomId(),\n      time: Date.now(),\n      type,\n      interactingAddress: interactingAddress || selectedAddress,\n    };\n\n    validateTokenToWatch(asset);\n\n    await this._requestApproval(suggestedAssetMeta);\n\n    let name;\n    try {\n      name = await this.getERC20TokenName(asset.address);\n    } catch (error) {\n      name = undefined;\n    }\n\n    await this.addToken(asset.address, asset.symbol, asset.decimals, {\n      name,\n      image: asset.image,\n      interactingAddress: suggestedAssetMeta.interactingAddress,\n    });\n  }\n\n  /**\n   * Takes a new tokens and ignoredTokens array for the current network/account combination\n   * and returns new allTokens and allIgnoredTokens state to update to.\n   *\n   * @param params - Object that holds token params.\n   * @param params.newTokens - The new tokens to set for the current network and selected account.\n   * @param params.newIgnoredTokens - The new ignored tokens to set for the current network and selected account.\n   * @param params.newDetectedTokens - The new detected tokens to set for the current network and selected account.\n   * @param params.interactingAddress - The account address to use to store the tokens.\n   * @param params.interactingChainId - The chainId to use to store the tokens.\n   * @returns The updated `allTokens` and `allIgnoredTokens` state.\n   */\n  _getNewAllTokensState(params: {\n    newTokens?: Token[];\n    newIgnoredTokens?: string[];\n    newDetectedTokens?: Token[];\n    interactingAddress?: string;\n    interactingChainId?: Hex;\n  }) {\n    const {\n      newTokens,\n      newIgnoredTokens,\n      newDetectedTokens,\n      interactingAddress,\n      interactingChainId,\n    } = params;\n    const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n    const { chainId, selectedAddress } = this.config;\n\n    const userAddressToAddTokens = interactingAddress ?? selectedAddress;\n    const chainIdToAddTokens = interactingChainId ?? chainId;\n\n    let newAllTokens = allTokens;\n    if (\n      newTokens?.length ||\n      (newTokens &&\n        allTokens &&\n        allTokens[chainIdToAddTokens] &&\n        allTokens[chainIdToAddTokens][userAddressToAddTokens])\n    ) {\n      const networkTokens = allTokens[chainIdToAddTokens];\n      const newNetworkTokens = {\n        ...networkTokens,\n        ...{ [userAddressToAddTokens]: newTokens },\n      };\n      newAllTokens = {\n        ...allTokens,\n        ...{ [chainIdToAddTokens]: newNetworkTokens },\n      };\n    }\n\n    let newAllIgnoredTokens = allIgnoredTokens;\n    if (\n      newIgnoredTokens?.length ||\n      (newIgnoredTokens &&\n        allIgnoredTokens &&\n        allIgnoredTokens[chainIdToAddTokens] &&\n        allIgnoredTokens[chainIdToAddTokens][userAddressToAddTokens])\n    ) {\n      const networkIgnoredTokens = allIgnoredTokens[chainIdToAddTokens];\n      const newIgnoredNetworkTokens = {\n        ...networkIgnoredTokens,\n        ...{ [userAddressToAddTokens]: newIgnoredTokens },\n      };\n      newAllIgnoredTokens = {\n        ...allIgnoredTokens,\n        ...{ [chainIdToAddTokens]: newIgnoredNetworkTokens },\n      };\n    }\n\n    let newAllDetectedTokens = allDetectedTokens;\n    if (\n      newDetectedTokens?.length ||\n      (newDetectedTokens &&\n        allDetectedTokens &&\n        allDetectedTokens[chainIdToAddTokens] &&\n        allDetectedTokens[chainIdToAddTokens][userAddressToAddTokens])\n    ) {\n      const networkDetectedTokens = allDetectedTokens[chainIdToAddTokens];\n      const newDetectedNetworkTokens = {\n        ...networkDetectedTokens,\n        ...{ [userAddressToAddTokens]: newDetectedTokens },\n      };\n      newAllDetectedTokens = {\n        ...allDetectedTokens,\n        ...{ [chainIdToAddTokens]: newDetectedNetworkTokens },\n      };\n    }\n    return { newAllTokens, newAllIgnoredTokens, newAllDetectedTokens };\n  }\n\n  /**\n   * Removes all tokens from the ignored list.\n   */\n  clearIgnoredTokens() {\n    this.update({ ignoredTokens: [], allIgnoredTokens: {} });\n  }\n\n  async _requestApproval(suggestedAssetMeta: SuggestedAssetMeta) {\n    return this.messagingSystem.call(\n      'ApprovalController:addRequest',\n      {\n        id: suggestedAssetMeta.id,\n        origin: ORIGIN_METAMASK,\n        type: ApprovalType.WatchAsset,\n        requestData: {\n          id: suggestedAssetMeta.id,\n          interactingAddress: suggestedAssetMeta.interactingAddress,\n          asset: {\n            address: suggestedAssetMeta.asset.address,\n            decimals: suggestedAssetMeta.asset.decimals,\n            symbol: suggestedAssetMeta.asset.symbol,\n            image: suggestedAssetMeta.asset.image || null,\n          },\n        },\n      },\n      true,\n    );\n  }\n}\n\nexport default TokensController;\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/TokensController.mjs b/node_modules/@metamask/assets-controllers/dist/TokensController.mjs
new file mode 100644
index 0000000..0b8d2cd
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/TokensController.mjs
@@ -0,0 +1,16 @@
+import {
+  TokensController,
+  TokensController_default,
+  getDefaultTokensState
+} from "./chunk-76KGJJJV.mjs";
+import "./chunk-CEENXWOB.mjs";
+import "./chunk-MQ7TIWBK.mjs";
+import "./chunk-KRTEFV4Q.mjs";
+import "./chunk-E5PIGGYR.mjs";
+import "./chunk-XUI43LEZ.mjs";
+export {
+  TokensController,
+  TokensController_default as default,
+  getDefaultTokensState
+};
+//# sourceMappingURL=TokensController.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/TokensController.mjs.map b/node_modules/@metamask/assets-controllers/dist/TokensController.mjs.map
new file mode 100644
index 0000000..84c51b2
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/TokensController.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":[],"sourcesContent":[],"mappings":"","names":[]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/assetsUtil.d.ts b/node_modules/@metamask/assets-controllers/dist/assetsUtil.d.ts
index f0bdb55..404fcf4 100644
--- a/node_modules/@metamask/assets-controllers/dist/assetsUtil.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/assetsUtil.d.ts
@@ -1,9 +1,9 @@
 /// <reference types="bn.js" />
-import type { BigNumber } from '@ethersproject/bignumber';
 import type { Hex } from '@metamask/utils';
+import { BigNumber } from '@ethersproject/bignumber';
 import { BN } from 'ethereumjs-util';
-import type { Nft, NftMetadata } from './NftController';
-import type { Token } from './TokenRatesController';
+import { Nft, NftMetadata } from './NftController';
+import { Token } from './TokenRatesController';
 /**
  * Compares nft metadata entries to any nft entry.
  * We need this method when comparing a new fetched nft metadata, in case a entry changed to a defined value,
@@ -47,7 +47,13 @@ export declare enum SupportedTokenDetectionNetworks {
     bsc = "0x38",
     polygon = "0x89",
     avax = "0xa86a",
-    aurora = "0x4e454152"
+    aurora = "0x4e454152",
+    linea_goerli = "0xe704",
+    linea_mainnet = "0xe708",
+    arbitrum = "0xa4b1",
+    optimism = "0xa",
+    base = "0x2105",
+    zksync = "0x144"
 }
 /**
  * Check if token detection is enabled for certain networks.
@@ -106,4 +112,37 @@ export declare function addUrlProtocolPrefix(urlString: string): string;
  * @returns A BN object.
  */
 export declare function ethersBigNumberToBN(bigNumber: BigNumber): BN;
+/**
+ * Partitions a list of values into groups that are at most `batchSize` in
+ * length.
+ *
+ * @param values - The list of values.
+ * @param args - The remaining arguments.
+ * @param args.batchSize - The desired maximum number of values per batch.
+ * @returns The list of batches.
+ */
+export declare function divideIntoBatches<Value>(values: Value[], { batchSize }: {
+    batchSize: number;
+}): Value[][];
+/**
+ * Constructs an object from processing batches of the given values
+ * sequentially.
+ *
+ * @param args - The arguments to this function.
+ * @param args.values - A list of values to iterate over.
+ * @param args.batchSize - The maximum number of values in each batch.
+ * @param args.eachBatch - A function to call for each batch. This function is
+ * similar to the function that `Array.prototype.reduce` takes, in that it
+ * receives the object that is being built, each batch in the list of batches
+ * and the index, and should return an updated version of the object.
+ * @param args.initialResult - The initial value of the final data structure,
+ * i.e., the value that will be fed into the first call of `eachBatch`.
+ * @returns The built object.
+ */
+export declare function reduceInBatchesSerially<Value, Result extends Record<PropertyKey, unknown>>({ values, batchSize, eachBatch, initialResult, }: {
+    values: Value[];
+    batchSize: number;
+    eachBatch: (workingResult: Partial<Result>, batch: Value[], index: number) => Partial<Result> | Promise<Partial<Result>>;
+    initialResult: Partial<Result>;
+}): Promise<Result>;
 //# sourceMappingURL=assetsUtil.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/assetsUtil.d.ts.map b/node_modules/@metamask/assets-controllers/dist/assetsUtil.d.ts.map
index 88e81d5..107e955 100644
--- a/node_modules/@metamask/assets-controllers/dist/assetsUtil.d.ts.map
+++ b/node_modules/@metamask/assets-controllers/dist/assetsUtil.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"assetsUtil.d.ts","sourceRoot":"","sources":["../src/assetsUtil.ts"],"names":[],"mappings":";AAAA,OAAO,KAAK,EAAE,SAAS,EAAE,MAAM,0BAA0B,CAAC;AAO1D,OAAO,KAAK,EAAE,GAAG,EAAE,MAAM,iBAAiB,CAAC;AAC3C,OAAO,EAAE,EAAE,EAAkB,MAAM,iBAAiB,CAAC;AAGrD,OAAO,KAAK,EAAE,GAAG,EAAE,WAAW,EAAE,MAAM,iBAAiB,CAAC;AACxD,OAAO,KAAK,EAAE,KAAK,EAAE,MAAM,wBAAwB,CAAC;AAEpD;;;;;;;;GAQG;AACH,wBAAgB,kBAAkB,CAAC,cAAc,EAAE,WAAW,EAAE,GAAG,EAAE,GAAG,WAkBvE;AA+BD;;;;;GAKG;AACH,eAAO,MAAM,qBAAqB,gBAAiB,MAAM,EAAE,aAM1D,CAAC;AAEF;;;;;;;GAOG;AACH,eAAO,MAAM,sBAAsB;aAIxB,GAAG;kBACE,MAAM;YAIrB,CAAC;AAEF;;;;GAIG;AACH,wBAAgB,oBAAoB,CAAC,KAAK,EAAE,KAAK,QA2BhD;AAED;;GAEG;AACH,oBAAY,+BAA+B;IACzC,OAAO,QAAQ;IACf,GAAG,SAAS;IACZ,OAAO,SAAS;IAChB,IAAI,WAAW;IACf,MAAM,eAAe;CACtB;AAED;;;;;GAKG;AACH,wBAAgB,mCAAmC,CAAC,OAAO,EAAE,GAAG,GAAG,OAAO,CAEzE;AAED;;;;;;GAMG;AACH,wBAAgB,8BAA8B,CAAC,OAAO,EAAE,GAAG,GAAG,OAAO,CAIpE;AAED;;;;;;GAMG;AACH,wBAAgB,wBAAwB,CAAC,OAAO,EAAE,MAAM,UAQvD;AAED;;;;;;GAMG;AACH,wBAAgB,mBAAmB,CAAC,OAAO,EAAE,MAAM,GAAG;IACpD,GAAG,EAAE,MAAM,CAAC;IACZ,IAAI,CAAC,EAAE,MAAM,CAAC;CACf,CAeA;AAED;;;;;;;GAOG;AACH,wBAAgB,mBAAmB,CACjC,WAAW,EAAE,MAAM,EACnB,OAAO,EAAE,MAAM,EACf,kBAAkB,EAAE,OAAO,GAC1B,MAAM,CAQR;AAED;;;;;GAKG;AACH,wBAAgB,oBAAoB,CAAC,SAAS,EAAE,MAAM,GAAG,MAAM,CAK9D;AAED;;;;;GAKG;AACH,wBAAgB,mBAAmB,CAAC,SAAS,EAAE,SAAS,GAAG,EAAE,CAE5D"}
\ No newline at end of file
+{"version":3,"file":"assetsUtil.d.ts","sourceRoot":"","sources":["../src/assetsUtil.ts"],"names":[],"mappings":";AAEA,OAAO,KAAK,EAAE,GAAG,EAAE,MAAM,iBAAiB,CAAC;AAM3C,OAAO,EAAE,SAAS,EAAE,MAAM,0BAA0B,CAAC;AACrD,OAAO,EAAE,EAAE,EAAkB,MAAM,iBAAiB,CAAC;AACrD,OAAO,EACL,GAAG,EACH,WAAW,EACZ,MAAM,iBAAiB,CAAC;AACzB,OAAO,EAAE,KAAK,EAAE,MAAM,wBAAwB,CAAC;AAE/C;;;;;;;;GAQG;AACH,wBAAgB,kBAAkB,CAAC,cAAc,EAAE,WAAW,EAAE,GAAG,EAAE,GAAG,WAkBvE;AA+BD;;;;;GAKG;AACH,eAAO,MAAM,qBAAqB,gBAAiB,MAAM,EAAE,aAM1D,CAAC;AAEF;;;;;;;GAOG;AACH,eAAO,MAAM,sBAAsB;aAIxB,GAAG;kBACE,MAAM;YAIrB,CAAC;AAEF;;;;GAIG;AACH,wBAAgB,oBAAoB,CAAC,KAAK,EAAE,KAAK,QA2BhD;AAED;;GAEG;AACH,oBAAY,+BAA+B;IACzC,OAAO,QAAQ;IACf,GAAG,SAAS;IACZ,OAAO,SAAS;IAChB,IAAI,WAAW;IACf,MAAM,eAAe;IACrB,YAAY,WAAW;IACvB,aAAa,WAAW;IACxB,QAAQ,WAAW;IACnB,QAAQ,QAAQ;IAChB,IAAI,WAAW;IACf,MAAM,UAAU;CACjB;AAED;;;;;GAKG;AACH,wBAAgB,mCAAmC,CAAC,OAAO,EAAE,GAAG,GAAG,OAAO,CAEzE;AAED;;;;;;GAMG;AACH,wBAAgB,8BAA8B,CAAC,OAAO,EAAE,GAAG,GAAG,OAAO,CAIpE;AAED;;;;;;GAMG;AACH,wBAAgB,wBAAwB,CAAC,OAAO,EAAE,MAAM,UAQvD;AAED;;;;;;GAMG;AACH,wBAAgB,mBAAmB,CAAC,OAAO,EAAE,MAAM,GAAG;IACpD,GAAG,EAAE,MAAM,CAAC;IACZ,IAAI,CAAC,EAAE,MAAM,CAAC;CACf,CAeA;AAED;;;;;;;GAOG;AACH,wBAAgB,mBAAmB,CACjC,WAAW,EAAE,MAAM,EACnB,OAAO,EAAE,MAAM,EACf,kBAAkB,EAAE,OAAO,GAC1B,MAAM,CAQR;AAED;;;;;GAKG;AACH,wBAAgB,oBAAoB,CAAC,SAAS,EAAE,MAAM,GAAG,MAAM,CAK9D;AAED;;;;;GAKG;AACH,wBAAgB,mBAAmB,CAAC,SAAS,EAAE,SAAS,GAAG,EAAE,CAE5D;AAED;;;;;;;;GAQG;AACH,wBAAgB,iBAAiB,CAAC,KAAK,EACrC,MAAM,EAAE,KAAK,EAAE,EACf,EAAE,SAAS,EAAE,EAAE;IAAE,SAAS,EAAE,MAAM,CAAA;CAAE,GACnC,KAAK,EAAE,EAAE,CAMX;AAED;;;;;;;;;;;;;;GAcG;AACH,wBAAsB,uBAAuB,CAC3C,KAAK,EACL,MAAM,SAAS,MAAM,CAAC,WAAW,EAAE,OAAO,CAAC,EAC3C,EACA,MAAM,EACN,SAAS,EACT,SAAS,EACT,aAAa,GACd,EAAE;IACD,MAAM,EAAE,KAAK,EAAE,CAAC;IAChB,SAAS,EAAE,MAAM,CAAC;IAClB,SAAS,EAAE,CACT,aAAa,EAAE,OAAO,CAAC,MAAM,CAAC,EAC9B,KAAK,EAAE,KAAK,EAAE,EACd,KAAK,EAAE,MAAM,KACV,OAAO,CAAC,MAAM,CAAC,GAAG,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC;IAChD,aAAa,EAAE,OAAO,CAAC,MAAM,CAAC,CAAC;CAChC,GAAG,OAAO,CAAC,MAAM,CAAC,CAUlB"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/assetsUtil.js b/node_modules/@metamask/assets-controllers/dist/assetsUtil.js
index 521fd94..1a7dff9 100644
--- a/node_modules/@metamask/assets-controllers/dist/assetsUtil.js
+++ b/node_modules/@metamask/assets-controllers/dist/assetsUtil.js
@@ -1,10 +1,19 @@
 "use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.ethersBigNumberToBN = exports.addUrlProtocolPrefix = exports.getFormattedIpfsUrl = exports.getIpfsCIDv1AndPath = exports.removeIpfsProtocolPrefix = exports.isTokenListSupportedForNetwork = exports.isTokenDetectionSupportedForNetwork = exports.SupportedTokenDetectionNetworks = exports.validateTokenToWatch = exports.formatIconUrlWithProxy = exports.formatAggregatorNames = exports.compareNftMetadata = void 0;
-const controller_utils_1 = require("@metamask/controller-utils");
+exports.reduceInBatchesSerially = exports.divideIntoBatches = exports.ethersBigNumberToBN = exports.addUrlProtocolPrefix = exports.getFormattedIpfsUrl = exports.getIpfsCIDv1AndPath = exports.removeIpfsProtocolPrefix = exports.isTokenListSupportedForNetwork = exports.isTokenDetectionSupportedForNetwork = exports.SupportedTokenDetectionNetworks = exports.validateTokenToWatch = exports.formatIconUrlWithProxy = exports.formatAggregatorNames = exports.compareNftMetadata = void 0;
 const rpc_errors_1 = require("@metamask/rpc-errors");
-const ethereumjs_util_1 = require("ethereumjs-util");
 const cid_1 = require("multiformats/cid");
+const controller_utils_1 = require("@metamask/controller-utils");
+const ethereumjs_util_1 = require("ethereumjs-util");
 /**
  * Compares nft metadata entries to any nft entry.
  * We need this method when comparing a new fetched nft metadata, in case a entry changed to a defined value,
@@ -121,6 +130,12 @@ var SupportedTokenDetectionNetworks;
     SupportedTokenDetectionNetworks["polygon"] = "0x89";
     SupportedTokenDetectionNetworks["avax"] = "0xa86a";
     SupportedTokenDetectionNetworks["aurora"] = "0x4e454152";
+    SupportedTokenDetectionNetworks["linea_goerli"] = "0xe704";
+    SupportedTokenDetectionNetworks["linea_mainnet"] = "0xe708";
+    SupportedTokenDetectionNetworks["arbitrum"] = "0xa4b1";
+    SupportedTokenDetectionNetworks["optimism"] = "0xa";
+    SupportedTokenDetectionNetworks["base"] = "0x2105";
+    SupportedTokenDetectionNetworks["zksync"] = "0x144";
 })(SupportedTokenDetectionNetworks = exports.SupportedTokenDetectionNetworks || (exports.SupportedTokenDetectionNetworks = {}));
 /**
  * Check if token detection is enabled for certain networks.
@@ -224,4 +239,50 @@ function ethersBigNumberToBN(bigNumber) {
     return new ethereumjs_util_1.BN((0, ethereumjs_util_1.stripHexPrefix)(bigNumber.toHexString()), 'hex');
 }
 exports.ethersBigNumberToBN = ethersBigNumberToBN;
+/**
+ * Partitions a list of values into groups that are at most `batchSize` in
+ * length.
+ *
+ * @param values - The list of values.
+ * @param args - The remaining arguments.
+ * @param args.batchSize - The desired maximum number of values per batch.
+ * @returns The list of batches.
+ */
+function divideIntoBatches(values, { batchSize }) {
+    const batches = [];
+    for (let i = 0; i < values.length; i += batchSize) {
+        batches.push(values.slice(i, i + batchSize));
+    }
+    return batches;
+}
+exports.divideIntoBatches = divideIntoBatches;
+/**
+ * Constructs an object from processing batches of the given values
+ * sequentially.
+ *
+ * @param args - The arguments to this function.
+ * @param args.values - A list of values to iterate over.
+ * @param args.batchSize - The maximum number of values in each batch.
+ * @param args.eachBatch - A function to call for each batch. This function is
+ * similar to the function that `Array.prototype.reduce` takes, in that it
+ * receives the object that is being built, each batch in the list of batches
+ * and the index, and should return an updated version of the object.
+ * @param args.initialResult - The initial value of the final data structure,
+ * i.e., the value that will be fed into the first call of `eachBatch`.
+ * @returns The built object.
+ */
+function reduceInBatchesSerially({ values, batchSize, eachBatch, initialResult, }) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const batches = divideIntoBatches(values, { batchSize });
+        let workingResult = initialResult;
+        for (const [index, batch] of batches.entries()) {
+            workingResult = yield eachBatch(workingResult, batch, index);
+        }
+        // There's no way around this  we have to assume that in the end, the result
+        // matches the intended type.
+        const finalResult = workingResult;
+        return finalResult;
+    });
+}
+exports.reduceInBatchesSerially = reduceInBatchesSerially;
 //# sourceMappingURL=assetsUtil.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/assetsUtil.js.map b/node_modules/@metamask/assets-controllers/dist/assetsUtil.js.map
index 0640431..e675bde 100644
--- a/node_modules/@metamask/assets-controllers/dist/assetsUtil.js.map
+++ b/node_modules/@metamask/assets-controllers/dist/assetsUtil.js.map
@@ -1 +1 @@
-{"version":3,"file":"assetsUtil.js","sourceRoot":"","sources":["../src/assetsUtil.ts"],"names":[],"mappings":"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","sourcesContent":["import type { BigNumber } from '@ethersproject/bignumber';\nimport {\n  convertHexToDecimal,\n  isValidHexAddress,\n  GANACHE_CHAIN_ID,\n} from '@metamask/controller-utils';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type { Hex } from '@metamask/utils';\nimport { BN, stripHexPrefix } from 'ethereumjs-util';\nimport { CID } from 'multiformats/cid';\n\nimport type { Nft, NftMetadata } from './NftController';\nimport type { Token } from './TokenRatesController';\n\n/**\n * Compares nft metadata entries to any nft entry.\n * We need this method when comparing a new fetched nft metadata, in case a entry changed to a defined value,\n * there's a need to update the nft in state.\n *\n * @param newNftMetadata - Nft metadata object.\n * @param nft - Nft object to compare with.\n * @returns Whether there are differences.\n */\nexport function compareNftMetadata(newNftMetadata: NftMetadata, nft: Nft) {\n  const keys: (keyof NftMetadata)[] = [\n    'image',\n    'backgroundColor',\n    'imagePreview',\n    'imageThumbnail',\n    'imageOriginal',\n    'animation',\n    'animationOriginal',\n    'externalLink',\n  ];\n  const differentValues = keys.reduce((value, key) => {\n    if (newNftMetadata[key] && newNftMetadata[key] !== nft[key]) {\n      return value + 1;\n    }\n    return value;\n  }, 0);\n  return differentValues > 0;\n}\n\nconst aggregatorNameByKey: Record<string, string> = {\n  aave: 'Aave',\n  bancor: 'Bancor',\n  cmc: 'CMC',\n  cryptocom: 'Crypto.com',\n  coinGecko: 'CoinGecko',\n  oneInch: '1inch',\n  paraswap: 'Paraswap',\n  pmm: 'PMM',\n  zapper: 'Zapper',\n  zerion: 'Zerion',\n  zeroEx: '0x',\n  synthetix: 'Synthetix',\n  yearn: 'Yearn',\n  apeswap: 'ApeSwap',\n  binanceDex: 'BinanceDex',\n  pancakeTop100: 'PancakeTop100',\n  pancakeExtended: 'PancakeExtended',\n  balancer: 'Balancer',\n  quickswap: 'QuickSwap',\n  matcha: 'Matcha',\n  pangolinDex: 'PangolinDex',\n  pangolinDexStableCoin: 'PangolinDexStableCoin',\n  pangolinDexAvaxBridge: 'PangolinDexAvaxBridge',\n  traderJoe: 'TraderJoe',\n  airswapLight: 'AirswapLight',\n  kleros: 'Kleros',\n};\n\n/**\n * Formats aggregator names to presentable format.\n *\n * @param aggregators - List of token list names in camelcase.\n * @returns Formatted aggregator names.\n */\nexport const formatAggregatorNames = (aggregators: string[]) => {\n  return aggregators.map(\n    (key) =>\n      aggregatorNameByKey[key] ||\n      `${key[0].toUpperCase()}${key.substring(1, key.length)}`,\n  );\n};\n\n/**\n * Format token list assets to use image proxy from Codefi.\n *\n * @param params - Object that contains chainID and tokenAddress.\n * @param params.chainId - ChainID of network in 0x-prefixed hexadecimal format.\n * @param params.tokenAddress - Address of token in mixed or lowercase.\n * @returns Formatted image url\n */\nexport const formatIconUrlWithProxy = ({\n  chainId,\n  tokenAddress,\n}: {\n  chainId: Hex;\n  tokenAddress: string;\n}) => {\n  const chainIdDecimal = convertHexToDecimal(chainId).toString();\n  return `https://static.metafi.codefi.network/api/v1/tokenIcons/${chainIdDecimal}/${tokenAddress.toLowerCase()}.png`;\n};\n\n/**\n * Validates a ERC20 token to be added with EIP747.\n *\n * @param token - Token object to validate.\n */\nexport function validateTokenToWatch(token: Token) {\n  const { address, symbol, decimals } = token;\n  if (!address || !symbol || typeof decimals === 'undefined') {\n    throw rpcErrors.invalidParams(\n      `Must specify address, symbol, and decimals.`,\n    );\n  }\n\n  if (typeof symbol !== 'string') {\n    throw rpcErrors.invalidParams(`Invalid symbol: not a string.`);\n  }\n\n  if (symbol.length > 11) {\n    throw rpcErrors.invalidParams(\n      `Invalid symbol \"${symbol}\": longer than 11 characters.`,\n    );\n  }\n  const numDecimals = parseInt(decimals as unknown as string, 10);\n  if (isNaN(numDecimals) || numDecimals > 36 || numDecimals < 0) {\n    throw rpcErrors.invalidParams(\n      `Invalid decimals \"${decimals}\": must be 0 <= 36.`,\n    );\n  }\n\n  if (!isValidHexAddress(address)) {\n    throw rpcErrors.invalidParams(`Invalid address \"${address}\".`);\n  }\n}\n\n/**\n * Networks where token detection is supported - Values are in decimal format\n */\nexport enum SupportedTokenDetectionNetworks {\n  mainnet = '0x1', // decimal: 1\n  bsc = '0x38', // decimal: 56\n  polygon = '0x89', // decimal: 137\n  avax = '0xa86a', // decimal: 43114\n  aurora = '0x4e454152', // decimal: 1313161554\n}\n\n/**\n * Check if token detection is enabled for certain networks.\n *\n * @param chainId - ChainID of network\n * @returns Whether the current network supports token detection\n */\nexport function isTokenDetectionSupportedForNetwork(chainId: Hex): boolean {\n  return Object.values<Hex>(SupportedTokenDetectionNetworks).includes(chainId);\n}\n\n/**\n * Check if token list polling is enabled for a given network.\n * Currently this method is used to support e2e testing for consumers of this package.\n *\n * @param chainId - ChainID of network\n * @returns Whether the current network supports tokenlists\n */\nexport function isTokenListSupportedForNetwork(chainId: Hex): boolean {\n  return (\n    isTokenDetectionSupportedForNetwork(chainId) || chainId === GANACHE_CHAIN_ID\n  );\n}\n\n/**\n * Removes IPFS protocol prefix from input string.\n *\n * @param ipfsUrl - An IPFS url (e.g. ipfs://{content id})\n * @returns IPFS content identifier and (possibly) path in a string\n * @throws Will throw if the url passed is not IPFS.\n */\nexport function removeIpfsProtocolPrefix(ipfsUrl: string) {\n  if (ipfsUrl.startsWith('ipfs://ipfs/')) {\n    return ipfsUrl.replace('ipfs://ipfs/', '');\n  } else if (ipfsUrl.startsWith('ipfs://')) {\n    return ipfsUrl.replace('ipfs://', '');\n  }\n  // this method should not be used with non-ipfs urls (i.e. startsWith('ipfs://') === true)\n  throw new Error('this method should not be used with non ipfs urls');\n}\n\n/**\n * Extracts content identifier and path from an input string.\n *\n * @param ipfsUrl - An IPFS URL minus the IPFS protocol prefix\n * @returns IFPS content identifier (cid) and sub path as string.\n * @throws Will throw if the url passed is not ipfs.\n */\nexport function getIpfsCIDv1AndPath(ipfsUrl: string): {\n  cid: string;\n  path?: string;\n} {\n  const url = removeIpfsProtocolPrefix(ipfsUrl);\n\n  // check if there is a path\n  // (CID is everything preceding first forward slash, path is everything after)\n  const index = url.indexOf('/');\n  const cid = index !== -1 ? url.substring(0, index) : url;\n  const path = index !== -1 ? url.substring(index) : undefined;\n\n  // We want to ensure that the CID is v1 (https://docs.ipfs.io/concepts/content-addressing/#identifier-formats)\n  // because most cid v0s appear to be incompatible with IPFS subdomains\n  return {\n    cid: CID.parse(cid).toV1().toString(),\n    path,\n  };\n}\n\n/**\n * Formats URL correctly for use retrieving assets hosted on IPFS.\n *\n * @param ipfsGateway - The users preferred IPFS gateway (full URL or just host).\n * @param ipfsUrl - The IFPS URL pointed at the asset.\n * @param subdomainSupported - Boolean indicating whether the URL should be formatted with subdomains or not.\n * @returns A formatted URL, with the user's preferred IPFS gateway and format (subdomain or not), pointing to an asset hosted on IPFS.\n */\nexport function getFormattedIpfsUrl(\n  ipfsGateway: string,\n  ipfsUrl: string,\n  subdomainSupported: boolean,\n): string {\n  const { host, protocol, origin } = new URL(addUrlProtocolPrefix(ipfsGateway));\n  if (subdomainSupported) {\n    const { cid, path } = getIpfsCIDv1AndPath(ipfsUrl);\n    return `${protocol}//${cid}.ipfs.${host}${path ?? ''}`;\n  }\n  const cidAndPath = removeIpfsProtocolPrefix(ipfsUrl);\n  return `${origin}/ipfs/${cidAndPath}`;\n}\n\n/**\n * Adds URL protocol prefix to input URL string if missing.\n *\n * @param urlString - An IPFS URL.\n * @returns A URL with a https:// prepended.\n */\nexport function addUrlProtocolPrefix(urlString: string): string {\n  if (!urlString.match(/(^http:\\/\\/)|(^https:\\/\\/)/u)) {\n    return `https://${urlString}`;\n  }\n  return urlString;\n}\n\n/**\n * Converts an Ethers BigNumber to a BN.\n *\n * @param bigNumber - An Ethers BigNumber instance.\n * @returns A BN object.\n */\nexport function ethersBigNumberToBN(bigNumber: BigNumber): BN {\n  return new BN(stripHexPrefix(bigNumber.toHexString()), 'hex');\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"assetsUtil.js","sourceRoot":"","sources":["../src/assetsUtil.ts"],"names":[],"mappings":"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","sourcesContent":["import { rpcErrors } from '@metamask/rpc-errors';\nimport { CID } from 'multiformats/cid';\nimport type { Hex } from '@metamask/utils';\nimport {\n  convertHexToDecimal,\n  isValidHexAddress,\n  GANACHE_CHAIN_ID,\n} from '@metamask/controller-utils';\nimport { BigNumber } from '@ethersproject/bignumber';\nimport { BN, stripHexPrefix } from 'ethereumjs-util';\nimport {\n  Nft,\n  NftMetadata,\n} from './NftController';\nimport { Token } from './TokenRatesController';\n\n/**\n * Compares nft metadata entries to any nft entry.\n * We need this method when comparing a new fetched nft metadata, in case a entry changed to a defined value,\n * there's a need to update the nft in state.\n *\n * @param newNftMetadata - Nft metadata object.\n * @param nft - Nft object to compare with.\n * @returns Whether there are differences.\n */\nexport function compareNftMetadata(newNftMetadata: NftMetadata, nft: Nft) {\n  const keys: (keyof NftMetadata)[] = [\n    'image',\n    'backgroundColor',\n    'imagePreview',\n    'imageThumbnail',\n    'imageOriginal',\n    'animation',\n    'animationOriginal',\n    'externalLink',\n  ];\n  const differentValues = keys.reduce((value, key) => {\n    if (newNftMetadata[key] && newNftMetadata[key] !== nft[key]) {\n      return value + 1;\n    }\n    return value;\n  }, 0);\n  return differentValues > 0;\n}\n\nconst aggregatorNameByKey: Record<string, string> = {\n  aave: 'Aave',\n  bancor: 'Bancor',\n  cmc: 'CMC',\n  cryptocom: 'Crypto.com',\n  coinGecko: 'CoinGecko',\n  oneInch: '1inch',\n  paraswap: 'Paraswap',\n  pmm: 'PMM',\n  zapper: 'Zapper',\n  zerion: 'Zerion',\n  zeroEx: '0x',\n  synthetix: 'Synthetix',\n  yearn: 'Yearn',\n  apeswap: 'ApeSwap',\n  binanceDex: 'BinanceDex',\n  pancakeTop100: 'PancakeTop100',\n  pancakeExtended: 'PancakeExtended',\n  balancer: 'Balancer',\n  quickswap: 'QuickSwap',\n  matcha: 'Matcha',\n  pangolinDex: 'PangolinDex',\n  pangolinDexStableCoin: 'PangolinDexStableCoin',\n  pangolinDexAvaxBridge: 'PangolinDexAvaxBridge',\n  traderJoe: 'TraderJoe',\n  airswapLight: 'AirswapLight',\n  kleros: 'Kleros',\n};\n\n/**\n * Formats aggregator names to presentable format.\n *\n * @param aggregators - List of token list names in camelcase.\n * @returns Formatted aggregator names.\n */\nexport const formatAggregatorNames = (aggregators: string[]) => {\n  return aggregators.map(\n    (key) =>\n      aggregatorNameByKey[key] ||\n      `${key[0].toUpperCase()}${key.substring(1, key.length)}`,\n  );\n};\n\n/**\n * Format token list assets to use image proxy from Codefi.\n *\n * @param params - Object that contains chainID and tokenAddress.\n * @param params.chainId - ChainID of network in 0x-prefixed hexadecimal format.\n * @param params.tokenAddress - Address of token in mixed or lowercase.\n * @returns Formatted image url\n */\nexport const formatIconUrlWithProxy = ({\n  chainId,\n  tokenAddress,\n}: {\n  chainId: Hex;\n  tokenAddress: string;\n}) => {\n  const chainIdDecimal = convertHexToDecimal(chainId).toString();\n  return `https://static.metafi.codefi.network/api/v1/tokenIcons/${chainIdDecimal}/${tokenAddress.toLowerCase()}.png`;\n};\n\n/**\n * Validates a ERC20 token to be added with EIP747.\n *\n * @param token - Token object to validate.\n */\nexport function validateTokenToWatch(token: Token) {\n  const { address, symbol, decimals } = token;\n  if (!address || !symbol || typeof decimals === 'undefined') {\n    throw rpcErrors.invalidParams(\n      `Must specify address, symbol, and decimals.`,\n    );\n  }\n\n  if (typeof symbol !== 'string') {\n    throw rpcErrors.invalidParams(`Invalid symbol: not a string.`);\n  }\n\n  if (symbol.length > 11) {\n    throw rpcErrors.invalidParams(\n      `Invalid symbol \"${symbol}\": longer than 11 characters.`,\n    );\n  }\n  const numDecimals = parseInt(decimals as unknown as string, 10);\n  if (isNaN(numDecimals) || numDecimals > 36 || numDecimals < 0) {\n    throw rpcErrors.invalidParams(\n      `Invalid decimals \"${decimals}\": must be 0 <= 36.`,\n    );\n  }\n\n  if (!isValidHexAddress(address)) {\n    throw rpcErrors.invalidParams(`Invalid address \"${address}\".`);\n  }\n}\n\n/**\n * Networks where token detection is supported - Values are in decimal format\n */\nexport enum SupportedTokenDetectionNetworks {\n  mainnet = '0x1', // decimal: 1\n  bsc = '0x38', // decimal: 56\n  polygon = '0x89', // decimal: 137\n  avax = '0xa86a', // decimal: 43114\n  aurora = '0x4e454152', // decimal: 1313161554\n  linea_goerli = '0xe704', // decimal: 59140\n  linea_mainnet = '0xe708', // decimal: 59144\n  arbitrum = '0xa4b1', // decimal: 42161\n  optimism = '0xa', // decimal: 10\n  base = '0x2105', // decimal: 8453\n  zksync = '0x144', // decimal: 324\n}\n\n/**\n * Check if token detection is enabled for certain networks.\n *\n * @param chainId - ChainID of network\n * @returns Whether the current network supports token detection\n */\nexport function isTokenDetectionSupportedForNetwork(chainId: Hex): boolean {\n  return Object.values<Hex>(SupportedTokenDetectionNetworks).includes(chainId);\n}\n\n/**\n * Check if token list polling is enabled for a given network.\n * Currently this method is used to support e2e testing for consumers of this package.\n *\n * @param chainId - ChainID of network\n * @returns Whether the current network supports tokenlists\n */\nexport function isTokenListSupportedForNetwork(chainId: Hex): boolean {\n  return (\n    isTokenDetectionSupportedForNetwork(chainId) || chainId === GANACHE_CHAIN_ID\n  );\n}\n\n/**\n * Removes IPFS protocol prefix from input string.\n *\n * @param ipfsUrl - An IPFS url (e.g. ipfs://{content id})\n * @returns IPFS content identifier and (possibly) path in a string\n * @throws Will throw if the url passed is not IPFS.\n */\nexport function removeIpfsProtocolPrefix(ipfsUrl: string) {\n  if (ipfsUrl.startsWith('ipfs://ipfs/')) {\n    return ipfsUrl.replace('ipfs://ipfs/', '');\n  } else if (ipfsUrl.startsWith('ipfs://')) {\n    return ipfsUrl.replace('ipfs://', '');\n  }\n  // this method should not be used with non-ipfs urls (i.e. startsWith('ipfs://') === true)\n  throw new Error('this method should not be used with non ipfs urls');\n}\n\n/**\n * Extracts content identifier and path from an input string.\n *\n * @param ipfsUrl - An IPFS URL minus the IPFS protocol prefix\n * @returns IFPS content identifier (cid) and sub path as string.\n * @throws Will throw if the url passed is not ipfs.\n */\nexport function getIpfsCIDv1AndPath(ipfsUrl: string): {\n  cid: string;\n  path?: string;\n} {\n  const url = removeIpfsProtocolPrefix(ipfsUrl);\n\n  // check if there is a path\n  // (CID is everything preceding first forward slash, path is everything after)\n  const index = url.indexOf('/');\n  const cid = index !== -1 ? url.substring(0, index) : url;\n  const path = index !== -1 ? url.substring(index) : undefined;\n\n  // We want to ensure that the CID is v1 (https://docs.ipfs.io/concepts/content-addressing/#identifier-formats)\n  // because most cid v0s appear to be incompatible with IPFS subdomains\n  return {\n    cid: CID.parse(cid).toV1().toString(),\n    path,\n  };\n}\n\n/**\n * Formats URL correctly for use retrieving assets hosted on IPFS.\n *\n * @param ipfsGateway - The users preferred IPFS gateway (full URL or just host).\n * @param ipfsUrl - The IFPS URL pointed at the asset.\n * @param subdomainSupported - Boolean indicating whether the URL should be formatted with subdomains or not.\n * @returns A formatted URL, with the user's preferred IPFS gateway and format (subdomain or not), pointing to an asset hosted on IPFS.\n */\nexport function getFormattedIpfsUrl(\n  ipfsGateway: string,\n  ipfsUrl: string,\n  subdomainSupported: boolean,\n): string {\n  const { host, protocol, origin } = new URL(addUrlProtocolPrefix(ipfsGateway));\n  if (subdomainSupported) {\n    const { cid, path } = getIpfsCIDv1AndPath(ipfsUrl);\n    return `${protocol}//${cid}.ipfs.${host}${path ?? ''}`;\n  }\n  const cidAndPath = removeIpfsProtocolPrefix(ipfsUrl);\n  return `${origin}/ipfs/${cidAndPath}`;\n}\n\n/**\n * Adds URL protocol prefix to input URL string if missing.\n *\n * @param urlString - An IPFS URL.\n * @returns A URL with a https:// prepended.\n */\nexport function addUrlProtocolPrefix(urlString: string): string {\n  if (!urlString.match(/(^http:\\/\\/)|(^https:\\/\\/)/u)) {\n    return `https://${urlString}`;\n  }\n  return urlString;\n}\n\n/**\n * Converts an Ethers BigNumber to a BN.\n *\n * @param bigNumber - An Ethers BigNumber instance.\n * @returns A BN object.\n */\nexport function ethersBigNumberToBN(bigNumber: BigNumber): BN {\n  return new BN(stripHexPrefix(bigNumber.toHexString()), 'hex');\n}\n\n/**\n * Partitions a list of values into groups that are at most `batchSize` in\n * length.\n *\n * @param values - The list of values.\n * @param args - The remaining arguments.\n * @param args.batchSize - The desired maximum number of values per batch.\n * @returns The list of batches.\n */\nexport function divideIntoBatches<Value>(\n  values: Value[],\n  { batchSize }: { batchSize: number },\n): Value[][] {\n  const batches = [];\n  for (let i = 0; i < values.length; i += batchSize) {\n    batches.push(values.slice(i, i + batchSize));\n  }\n  return batches;\n}\n\n/**\n * Constructs an object from processing batches of the given values\n * sequentially.\n *\n * @param args - The arguments to this function.\n * @param args.values - A list of values to iterate over.\n * @param args.batchSize - The maximum number of values in each batch.\n * @param args.eachBatch - A function to call for each batch. This function is\n * similar to the function that `Array.prototype.reduce` takes, in that it\n * receives the object that is being built, each batch in the list of batches\n * and the index, and should return an updated version of the object.\n * @param args.initialResult - The initial value of the final data structure,\n * i.e., the value that will be fed into the first call of `eachBatch`.\n * @returns The built object.\n */\nexport async function reduceInBatchesSerially<\n  Value,\n  Result extends Record<PropertyKey, unknown>,\n>({\n  values,\n  batchSize,\n  eachBatch,\n  initialResult,\n}: {\n  values: Value[];\n  batchSize: number;\n  eachBatch: (\n    workingResult: Partial<Result>,\n    batch: Value[],\n    index: number,\n  ) => Partial<Result> | Promise<Partial<Result>>;\n  initialResult: Partial<Result>;\n}): Promise<Result> {\n  const batches = divideIntoBatches(values, { batchSize });\n  let workingResult = initialResult;\n  for (const [index, batch] of batches.entries()) {\n    workingResult = await eachBatch(workingResult, batch, index);\n  }\n  // There's no way around this  we have to assume that in the end, the result\n  // matches the intended type.\n  const finalResult = workingResult as Result;\n  return finalResult;\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/assetsUtil.mjs b/node_modules/@metamask/assets-controllers/dist/assetsUtil.mjs
new file mode 100644
index 0000000..bdc1d34
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/assetsUtil.mjs
@@ -0,0 +1,42 @@
+import {
+  SupportedTokenDetectionNetworks,
+  TOKEN_PRICES_BATCH_SIZE,
+  addUrlProtocolPrefix,
+  compareNftMetadata,
+  divideIntoBatches,
+  ethersBigNumberToBN,
+  fetchTokenContractExchangeRates,
+  formatAggregatorNames,
+  formatIconUrlWithProxy,
+  getFormattedIpfsUrl,
+  getIpfsCIDv1AndPath,
+  isTokenDetectionSupportedForNetwork,
+  isTokenListSupportedForNetwork,
+  mapOpenSeaContractV2ToV1,
+  mapOpenSeaDetailedNftV2ToV1,
+  mapOpenSeaNftV2ToV1,
+  reduceInBatchesSerially,
+  removeIpfsProtocolPrefix
+} from "./chunk-E5PIGGYR.mjs";
+import "./chunk-XUI43LEZ.mjs";
+export {
+  SupportedTokenDetectionNetworks,
+  TOKEN_PRICES_BATCH_SIZE,
+  addUrlProtocolPrefix,
+  compareNftMetadata,
+  divideIntoBatches,
+  ethersBigNumberToBN,
+  fetchTokenContractExchangeRates,
+  formatAggregatorNames,
+  formatIconUrlWithProxy,
+  getFormattedIpfsUrl,
+  getIpfsCIDv1AndPath,
+  isTokenDetectionSupportedForNetwork,
+  isTokenListSupportedForNetwork,
+  mapOpenSeaContractV2ToV1,
+  mapOpenSeaDetailedNftV2ToV1,
+  mapOpenSeaNftV2ToV1,
+  reduceInBatchesSerially,
+  removeIpfsProtocolPrefix
+};
+//# sourceMappingURL=assetsUtil.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/assetsUtil.mjs.map b/node_modules/@metamask/assets-controllers/dist/assetsUtil.mjs.map
new file mode 100644
index 0000000..84c51b2
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/assetsUtil.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":[],"sourcesContent":[],"mappings":"","names":[]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-23F5W3A2.mjs b/node_modules/@metamask/assets-controllers/dist/chunk-23F5W3A2.mjs
new file mode 100644
index 0000000..f3463d9
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-23F5W3A2.mjs
@@ -0,0 +1,157 @@
+import {
+  fetchExchangeRate
+} from "./chunk-TCO22VIO.mjs";
+
+// src/CurrencyRateController.ts
+import {
+  TESTNET_TICKER_SYMBOLS,
+  FALL_BACK_VS_CURRENCY
+} from "@metamask/controller-utils";
+import { StaticIntervalPollingController } from "@metamask/polling-controller";
+import { Mutex } from "async-mutex";
+var name = "CurrencyRateController";
+var metadata = {
+  currentCurrency: { persist: true, anonymous: true },
+  currencyRates: { persist: true, anonymous: true }
+};
+var defaultState = {
+  currentCurrency: "usd",
+  currencyRates: {
+    ETH: {
+      conversionDate: 0,
+      conversionRate: 0,
+      usdConversionRate: null
+    }
+  }
+};
+var CurrencyRateController = class extends StaticIntervalPollingController {
+  /**
+   * Creates a CurrencyRateController instance.
+   *
+   * @param options - Constructor options.
+   * @param options.includeUsdRate - Keep track of the USD rate in addition to the current currency rate.
+   * @param options.interval - The polling interval, in milliseconds.
+   * @param options.messenger - A reference to the messaging system.
+   * @param options.state - Initial state to set on this controller.
+   * @param options.fetchExchangeRate - Fetches the exchange rate from an external API. This option is primarily meant for use in unit tests.
+   */
+  constructor({
+    includeUsdRate = false,
+    interval = 18e4,
+    messenger,
+    state,
+    fetchExchangeRate: fetchExchangeRate2 = fetchExchangeRate
+  }) {
+    super({
+      name,
+      metadata,
+      messenger,
+      state: { ...defaultState, ...state }
+    });
+    this.mutex = new Mutex();
+    this.includeUsdRate = includeUsdRate;
+    this.setIntervalLength(interval);
+    this.fetchExchangeRate = fetchExchangeRate2;
+  }
+  /**
+   * Sets a currency to track.
+   *
+   * @param currentCurrency - ISO 4217 currency code.
+   */
+  async setCurrentCurrency(currentCurrency) {
+    const releaseLock = await this.mutex.acquire();
+    const nativeCurrencies = Object.keys(this.state.currencyRates);
+    try {
+      this.update(() => {
+        return {
+          ...defaultState,
+          currentCurrency
+        };
+      });
+    } finally {
+      releaseLock();
+    }
+    nativeCurrencies.forEach(this.updateExchangeRate.bind(this));
+  }
+  /**
+   * Updates the exchange rate for the current currency and native currency pair.
+   *
+   * @param nativeCurrency - The ticker symbol for the chain.
+   */
+  async updateExchangeRate(nativeCurrency) {
+    const releaseLock = await this.mutex.acquire();
+    const { currentCurrency, currencyRates } = this.state;
+    let conversionDate = null;
+    let conversionRate = null;
+    let usdConversionRate = null;
+    const nativeCurrencyForExchangeRate = Object.values(
+      TESTNET_TICKER_SYMBOLS
+    ).includes(nativeCurrency) ? FALL_BACK_VS_CURRENCY : nativeCurrency;
+    try {
+      if (currentCurrency && nativeCurrency && // if either currency is an empty string we can skip the comparison
+      // because it will result in an error from the api and ultimately
+      // a null conversionRate either way.
+      currentCurrency !== "" && nativeCurrency !== "") {
+        const fetchExchangeRateResponse = await this.fetchExchangeRate(
+          currentCurrency,
+          nativeCurrencyForExchangeRate,
+          this.includeUsdRate
+        );
+        conversionRate = fetchExchangeRateResponse.conversionRate;
+        usdConversionRate = fetchExchangeRateResponse.usdConversionRate;
+        conversionDate = Date.now() / 1e3;
+      }
+    } catch (error) {
+      if (!(error instanceof Error && error.message.includes("market does not exist for this coin pair"))) {
+        throw error;
+      }
+    } finally {
+      try {
+        this.update(() => {
+          return {
+            currencyRates: {
+              ...currencyRates,
+              [nativeCurrency]: {
+                conversionDate,
+                conversionRate,
+                usdConversionRate
+              }
+            },
+            currentCurrency
+          };
+        });
+      } finally {
+        releaseLock();
+      }
+    }
+  }
+  /**
+   * Prepare to discard this controller.
+   *
+   * This stops any active polling.
+   */
+  destroy() {
+    super.destroy();
+    this.stopAllPolling();
+  }
+  /**
+   * Updates exchange rate for the current currency.
+   *
+   * @param networkClientId - The network client ID used to get a ticker value.
+   * @returns The controller state.
+   */
+  async _executePoll(networkClientId) {
+    const networkClient = this.messagingSystem.call(
+      "NetworkController:getNetworkClientById",
+      networkClientId
+    );
+    await this.updateExchangeRate(networkClient.configuration.ticker);
+  }
+};
+var CurrencyRateController_default = CurrencyRateController;
+
+export {
+  CurrencyRateController,
+  CurrencyRateController_default
+};
+//# sourceMappingURL=chunk-23F5W3A2.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-23F5W3A2.mjs.map b/node_modules/@metamask/assets-controllers/dist/chunk-23F5W3A2.mjs.map
new file mode 100644
index 0000000..0749871
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-23F5W3A2.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/CurrencyRateController.ts"],"sourcesContent":["import type {\n  RestrictedControllerMessenger,\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n} from '@metamask/base-controller';\nimport {\n  TESTNET_TICKER_SYMBOLS,\n  FALL_BACK_VS_CURRENCY,\n} from '@metamask/controller-utils';\nimport type {\n  NetworkClientId,\n  NetworkControllerGetNetworkClientByIdAction,\n} from '@metamask/network-controller';\nimport { StaticIntervalPollingController } from '@metamask/polling-controller';\nimport { Mutex } from 'async-mutex';\n\nimport { fetchExchangeRate as defaultFetchExchangeRate } from './crypto-compare';\n\n/**\n * @type CurrencyRateState\n * @property currencyRates - Object keyed by native currency\n * @property currencyRates.conversionDate - Timestamp of conversion rate expressed in ms since UNIX epoch\n * @property currencyRates.conversionRate - Conversion rate from current base asset to the current currency\n * @property currentCurrency - Currently-active ISO 4217 currency code\n * @property usdConversionRate - Conversion rate from usd to the current currency\n */\nexport type CurrencyRateState = {\n  currentCurrency: string;\n  currencyRates: Record<\n    string,\n    {\n      conversionDate: number | null;\n      conversionRate: number | null;\n      usdConversionRate: number | null;\n    }\n  >;\n};\n\nconst name = 'CurrencyRateController';\n\nexport type CurrencyRateStateChange = ControllerStateChangeEvent<\n  typeof name,\n  CurrencyRateState\n>;\n\nexport type CurrencyRateControllerEvents = CurrencyRateStateChange;\n\nexport type GetCurrencyRateState = ControllerGetStateAction<\n  typeof name,\n  CurrencyRateState\n>;\n\nexport type CurrencyRateControllerActions = GetCurrencyRateState;\n\ntype AllowedActions = NetworkControllerGetNetworkClientByIdAction;\n\ntype CurrencyRateMessenger = RestrictedControllerMessenger<\n  typeof name,\n  CurrencyRateControllerActions | AllowedActions,\n  CurrencyRateControllerEvents,\n  AllowedActions['type'],\n  never\n>;\n\nconst metadata = {\n  currentCurrency: { persist: true, anonymous: true },\n  currencyRates: { persist: true, anonymous: true },\n};\n\nconst defaultState = {\n  currentCurrency: 'usd',\n  currencyRates: {\n    ETH: {\n      conversionDate: 0,\n      conversionRate: 0,\n      usdConversionRate: null,\n    },\n  },\n};\n\n/**\n * Controller that passively polls on a set interval for an exchange rate from the current network\n * asset to the user's preferred currency.\n */\nexport class CurrencyRateController extends StaticIntervalPollingController<\n  typeof name,\n  CurrencyRateState,\n  CurrencyRateMessenger\n> {\n  private readonly mutex = new Mutex();\n\n  private readonly fetchExchangeRate;\n\n  private readonly includeUsdRate;\n\n  /**\n   * Creates a CurrencyRateController instance.\n   *\n   * @param options - Constructor options.\n   * @param options.includeUsdRate - Keep track of the USD rate in addition to the current currency rate.\n   * @param options.interval - The polling interval, in milliseconds.\n   * @param options.messenger - A reference to the messaging system.\n   * @param options.state - Initial state to set on this controller.\n   * @param options.fetchExchangeRate - Fetches the exchange rate from an external API. This option is primarily meant for use in unit tests.\n   */\n  constructor({\n    includeUsdRate = false,\n    interval = 180000,\n    messenger,\n    state,\n    fetchExchangeRate = defaultFetchExchangeRate,\n  }: {\n    includeUsdRate?: boolean;\n    interval?: number;\n    messenger: CurrencyRateMessenger;\n    state?: Partial<CurrencyRateState>;\n    fetchExchangeRate?: typeof defaultFetchExchangeRate;\n  }) {\n    super({\n      name,\n      metadata,\n      messenger,\n      state: { ...defaultState, ...state },\n    });\n    this.includeUsdRate = includeUsdRate;\n    this.setIntervalLength(interval);\n    this.fetchExchangeRate = fetchExchangeRate;\n  }\n\n  /**\n   * Sets a currency to track.\n   *\n   * @param currentCurrency - ISO 4217 currency code.\n   */\n  async setCurrentCurrency(currentCurrency: string) {\n    const releaseLock = await this.mutex.acquire();\n    const nativeCurrencies = Object.keys(this.state.currencyRates);\n    try {\n      this.update(() => {\n        return {\n          ...defaultState,\n          currentCurrency,\n        };\n      });\n    } finally {\n      releaseLock();\n    }\n    nativeCurrencies.forEach(this.updateExchangeRate.bind(this));\n  }\n\n  /**\n   * Updates the exchange rate for the current currency and native currency pair.\n   *\n   * @param nativeCurrency - The ticker symbol for the chain.\n   */\n  async updateExchangeRate(nativeCurrency: string): Promise<void> {\n    const releaseLock = await this.mutex.acquire();\n    const { currentCurrency, currencyRates } = this.state;\n\n    let conversionDate: number | null = null;\n    let conversionRate: number | null = null;\n    let usdConversionRate: number | null = null;\n\n    // For preloaded testnets (Goerli, Sepolia) we want to fetch exchange rate for real ETH.\n    const nativeCurrencyForExchangeRate = Object.values(\n      TESTNET_TICKER_SYMBOLS,\n    ).includes(nativeCurrency)\n      ? FALL_BACK_VS_CURRENCY // ETH\n      : nativeCurrency;\n\n    try {\n      if (\n        currentCurrency &&\n        nativeCurrency &&\n        // if either currency is an empty string we can skip the comparison\n        // because it will result in an error from the api and ultimately\n        // a null conversionRate either way.\n        currentCurrency !== '' &&\n        nativeCurrency !== ''\n      ) {\n        const fetchExchangeRateResponse = await this.fetchExchangeRate(\n          currentCurrency,\n          nativeCurrencyForExchangeRate,\n          this.includeUsdRate,\n        );\n        conversionRate = fetchExchangeRateResponse.conversionRate;\n        usdConversionRate = fetchExchangeRateResponse.usdConversionRate;\n        conversionDate = Date.now() / 1000;\n      }\n    } catch (error) {\n      if (\n        !(\n          error instanceof Error &&\n          error.message.includes('market does not exist for this coin pair')\n        )\n      ) {\n        throw error;\n      }\n    } finally {\n      try {\n        this.update(() => {\n          return {\n            currencyRates: {\n              ...currencyRates,\n              [nativeCurrency]: {\n                conversionDate,\n                conversionRate,\n                usdConversionRate,\n              },\n            },\n            currentCurrency,\n          };\n        });\n      } finally {\n        releaseLock();\n      }\n    }\n  }\n\n  /**\n   * Prepare to discard this controller.\n   *\n   * This stops any active polling.\n   */\n  override destroy() {\n    super.destroy();\n    this.stopAllPolling();\n  }\n\n  /**\n   * Updates exchange rate for the current currency.\n   *\n   * @param networkClientId - The network client ID used to get a ticker value.\n   * @returns The controller state.\n   */\n  async _executePoll(networkClientId: NetworkClientId): Promise<void> {\n    const networkClient = this.messagingSystem.call(\n      'NetworkController:getNetworkClientById',\n      networkClientId,\n    );\n    await this.updateExchangeRate(networkClient.configuration.ticker);\n  }\n}\n\nexport default CurrencyRateController;\n"],"mappings":"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","names":["fetchExchangeRate"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-27KOXCQK.mjs b/node_modules/@metamask/assets-controllers/dist/chunk-27KOXCQK.mjs
new file mode 100644
index 0000000..049cc12
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-27KOXCQK.mjs
@@ -0,0 +1 @@
+//# sourceMappingURL=chunk-27KOXCQK.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-27KOXCQK.mjs.map b/node_modules/@metamask/assets-controllers/dist/chunk-27KOXCQK.mjs.map
new file mode 100644
index 0000000..84c51b2
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-27KOXCQK.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":[],"sourcesContent":[],"mappings":"","names":[]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-2IZUMKMY.mjs b/node_modules/@metamask/assets-controllers/dist/chunk-2IZUMKMY.mjs
new file mode 100644
index 0000000..21e827a
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-2IZUMKMY.mjs
@@ -0,0 +1,418 @@
+import {
+  fetchExchangeRate
+} from "./chunk-TCO22VIO.mjs";
+import {
+  TOKEN_PRICES_BATCH_SIZE,
+  reduceInBatchesSerially
+} from "./chunk-E5PIGGYR.mjs";
+import {
+  __privateAdd,
+  __privateGet,
+  __privateMethod,
+  __privateSet
+} from "./chunk-XUI43LEZ.mjs";
+
+// src/TokenRatesController.ts
+import {
+  safelyExecute,
+  toChecksumHexAddress,
+  FALL_BACK_VS_CURRENCY,
+  toHex
+} from "@metamask/controller-utils";
+import { StaticIntervalPollingControllerV1 } from "@metamask/polling-controller";
+import { createDeferredPromise } from "@metamask/utils";
+import { isEqual } from "lodash";
+async function getCurrencyConversionRate({
+  from,
+  to
+}) {
+  const includeUSDRate = false;
+  try {
+    const result = await fetchExchangeRate(
+      to,
+      from,
+      includeUSDRate
+    );
+    return result.conversionRate;
+  } catch (error) {
+    if (error instanceof Error && error.message.includes("market does not exist for this coin pair")) {
+      return null;
+    }
+    throw error;
+  }
+}
+var _pollState, _tokenPricesService, _inProcessExchangeRateUpdates, _getTokenAddresses, getTokenAddresses_fn, _stopPoll, stopPoll_fn, _poll, poll_fn, _fetchAndMapExchangeRates, fetchAndMapExchangeRates_fn, _fetchAndMapExchangeRatesForSupportedNativeCurrency, fetchAndMapExchangeRatesForSupportedNativeCurrency_fn, _fetchAndMapExchangeRatesForUnsupportedNativeCurrency, fetchAndMapExchangeRatesForUnsupportedNativeCurrency_fn;
+var TokenRatesController = class extends StaticIntervalPollingControllerV1 {
+  /**
+   * Creates a TokenRatesController instance.
+   *
+   * @param options - The controller options.
+   * @param options.interval - The polling interval in ms
+   * @param options.threshold - The duration in ms before metadata fetched from CoinGecko is considered stale
+   * @param options.getNetworkClientById - Gets the network client with the given id from the NetworkController.
+   * @param options.chainId - The chain ID of the current network.
+   * @param options.ticker - The ticker for the current network.
+   * @param options.selectedAddress - The current selected address.
+   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.
+   * @param options.onTokensStateChange - Allows subscribing to token controller state changes.
+   * @param options.onNetworkStateChange - Allows subscribing to network state changes.
+   * @param options.tokenPricesService - An object in charge of retrieving token prices.
+   * @param config - Initial options used to configure this controller.
+   * @param state - Initial state to set on this controller.
+   */
+  constructor({
+    interval = 3 * 60 * 1e3,
+    threshold = 6 * 60 * 60 * 1e3,
+    getNetworkClientById,
+    chainId: initialChainId,
+    ticker: initialTicker,
+    selectedAddress: initialSelectedAddress,
+    onPreferencesStateChange,
+    onTokensStateChange,
+    onNetworkStateChange,
+    tokenPricesService
+  }, config, state) {
+    super(config, state);
+    /**
+     * Get the user's tokens for the given chain.
+     *
+     * @param chainId - The chain ID.
+     * @returns The list of tokens addresses for the current chain
+     */
+    __privateAdd(this, _getTokenAddresses);
+    /**
+     * Clear the active polling timer, if present.
+     */
+    __privateAdd(this, _stopPoll);
+    /**
+     * Poll for exchange rate updates.
+     */
+    __privateAdd(this, _poll);
+    /**
+     * Uses the token prices service to retrieve exchange rates for tokens in a
+     * particular currency.
+     *
+     * If the price API does not support the given chain ID, returns an empty
+     * object.
+     *
+     * If the price API does not support the given currency, retrieves exchange
+     * rates in a known currency instead, then converts those rates using the
+     * exchange rate between the known currency and desired currency.
+     *
+     * @param args - The arguments to this function.
+     * @param args.tokenAddresses - Addresses for tokens.
+     * @param args.chainId - The EIP-155 ID of the chain where the tokens live.
+     * @param args.nativeCurrency - The native currency in which to request
+     * exchange rates.
+     * @returns A map from token address to its exchange rate in the native
+     * currency, or an empty map if no exchange rates can be obtained for the
+     * chain ID.
+     */
+    __privateAdd(this, _fetchAndMapExchangeRates);
+    /**
+     * Retrieves prices in the given currency for the given tokens on the given
+     * chain. Ensures that token addresses are checksum addresses.
+     *
+     * @param args - The arguments to this function.
+     * @param args.tokenAddresses - Addresses for tokens.
+     * @param args.chainId - The EIP-155 ID of the chain where the tokens live.
+     * @param args.nativeCurrency - The native currency in which to request
+     * prices.
+     * @returns A map of the token addresses (as checksums) to their prices in the
+     * native currency.
+     */
+    __privateAdd(this, _fetchAndMapExchangeRatesForSupportedNativeCurrency);
+    /**
+     * If the price API does not support a given native currency, then we need to
+     * convert it to a fallback currency and feed that currency into the price
+     * API, then convert the prices to our desired native currency.
+     *
+     * @param args - The arguments to this function.
+     * @param args.tokenAddresses - Addresses for tokens.
+     * @param args.nativeCurrency - The native currency in which to request
+     * prices.
+     * @returns A map of the token addresses (as checksums) to their prices in the
+     * native currency.
+     */
+    __privateAdd(this, _fetchAndMapExchangeRatesForUnsupportedNativeCurrency);
+    __privateAdd(this, _pollState, "Inactive" /* Inactive */);
+    __privateAdd(this, _tokenPricesService, void 0);
+    __privateAdd(this, _inProcessExchangeRateUpdates, {});
+    /**
+     * Name of this controller used during composition
+     */
+    this.name = "TokenRatesController";
+    this.defaultConfig = {
+      interval,
+      threshold,
+      disabled: false,
+      nativeCurrency: initialTicker,
+      chainId: initialChainId,
+      selectedAddress: initialSelectedAddress,
+      allTokens: {},
+      // TODO: initialize these correctly, maybe as part of BaseControllerV2 migration
+      allDetectedTokens: {}
+    };
+    this.defaultState = {
+      contractExchangeRates: {},
+      contractExchangeRatesByChainId: {}
+    };
+    this.initialize();
+    this.setIntervalLength(interval);
+    this.getNetworkClientById = getNetworkClientById;
+    __privateSet(this, _tokenPricesService, tokenPricesService);
+    if (config?.disabled) {
+      this.configure({ disabled: true }, false, false);
+    }
+    onPreferencesStateChange(async ({ selectedAddress }) => {
+      if (this.config.selectedAddress !== selectedAddress) {
+        this.configure({ selectedAddress });
+        if (__privateGet(this, _pollState) === "Active" /* Active */) {
+          await this.updateExchangeRates();
+        }
+      }
+    });
+    onTokensStateChange(async ({ allTokens, allDetectedTokens }) => {
+      const previousTokenAddresses = __privateMethod(this, _getTokenAddresses, getTokenAddresses_fn).call(this, this.config.chainId);
+      this.configure({ allTokens, allDetectedTokens });
+      const newTokenAddresses = __privateMethod(this, _getTokenAddresses, getTokenAddresses_fn).call(this, this.config.chainId);
+      if (!isEqual(previousTokenAddresses, newTokenAddresses) && __privateGet(this, _pollState) === "Active" /* Active */) {
+        await this.updateExchangeRates();
+      }
+    });
+    onNetworkStateChange(async ({ providerConfig }) => {
+      const { chainId, ticker } = providerConfig;
+      if (this.config.chainId !== chainId || this.config.nativeCurrency !== ticker) {
+        this.update({ contractExchangeRates: {} });
+        this.configure({ chainId, nativeCurrency: ticker });
+        if (__privateGet(this, _pollState) === "Active" /* Active */) {
+          await this.updateExchangeRates();
+        }
+      }
+    });
+  }
+  /**
+   * Start (or restart) polling.
+   */
+  async start() {
+    __privateMethod(this, _stopPoll, stopPoll_fn).call(this);
+    __privateSet(this, _pollState, "Active" /* Active */);
+    await __privateMethod(this, _poll, poll_fn).call(this);
+  }
+  /**
+   * Stop polling.
+   */
+  stop() {
+    __privateMethod(this, _stopPoll, stopPoll_fn).call(this);
+    __privateSet(this, _pollState, "Inactive" /* Inactive */);
+  }
+  /**
+   * Updates exchange rates for all tokens.
+   */
+  async updateExchangeRates() {
+    const { chainId, nativeCurrency } = this.config;
+    await this.updateExchangeRatesByChainId({
+      chainId,
+      nativeCurrency
+    });
+  }
+  /**
+   * Updates exchange rates for all tokens.
+   *
+   * @param options - The options to fetch exchange rates.
+   * @param options.chainId - The chain ID.
+   * @param options.nativeCurrency - The ticker for the chain.
+   */
+  async updateExchangeRatesByChainId({
+    chainId,
+    nativeCurrency
+  }) {
+    if (this.disabled) {
+      return;
+    }
+    const tokenAddresses = __privateMethod(this, _getTokenAddresses, getTokenAddresses_fn).call(this, chainId);
+    if (tokenAddresses.length === 0) {
+      return;
+    }
+    const updateKey = `${chainId}:${nativeCurrency}`;
+    if (updateKey in __privateGet(this, _inProcessExchangeRateUpdates)) {
+      await __privateGet(this, _inProcessExchangeRateUpdates)[updateKey];
+      return;
+    }
+    const {
+      promise: inProgressUpdate,
+      resolve: updateSucceeded,
+      reject: updateFailed
+    } = createDeferredPromise({ suppressUnhandledRejection: true });
+    __privateGet(this, _inProcessExchangeRateUpdates)[updateKey] = inProgressUpdate;
+    try {
+      const newContractExchangeRates = await __privateMethod(this, _fetchAndMapExchangeRates, fetchAndMapExchangeRates_fn).call(this, {
+        tokenAddresses,
+        chainId,
+        nativeCurrency
+      });
+      const existingContractExchangeRates = this.state.contractExchangeRates;
+      const updatedContractExchangeRates = chainId === this.config.chainId && nativeCurrency === this.config.nativeCurrency ? newContractExchangeRates : existingContractExchangeRates;
+      const existingContractExchangeRatesForChainId = this.state.contractExchangeRatesByChainId[chainId] ?? {};
+      const updatedContractExchangeRatesForChainId = {
+        ...this.state.contractExchangeRatesByChainId,
+        [chainId]: {
+          ...existingContractExchangeRatesForChainId,
+          [nativeCurrency]: {
+            ...existingContractExchangeRatesForChainId[nativeCurrency],
+            ...newContractExchangeRates
+          }
+        }
+      };
+      this.update({
+        contractExchangeRates: updatedContractExchangeRates,
+        contractExchangeRatesByChainId: updatedContractExchangeRatesForChainId
+      });
+      updateSucceeded();
+    } catch (error) {
+      updateFailed(error);
+      throw error;
+    } finally {
+      delete __privateGet(this, _inProcessExchangeRateUpdates)[updateKey];
+    }
+  }
+  /**
+   * Updates token rates for the given networkClientId
+   *
+   * @param networkClientId - The network client ID used to get a ticker value.
+   * @returns The controller state.
+   */
+  async _executePoll(networkClientId) {
+    const networkClient = this.getNetworkClientById(networkClientId);
+    await this.updateExchangeRatesByChainId({
+      chainId: networkClient.configuration.chainId,
+      nativeCurrency: networkClient.configuration.ticker
+    });
+  }
+};
+_pollState = new WeakMap();
+_tokenPricesService = new WeakMap();
+_inProcessExchangeRateUpdates = new WeakMap();
+_getTokenAddresses = new WeakSet();
+getTokenAddresses_fn = function(chainId) {
+  const { allTokens, allDetectedTokens } = this.config;
+  const tokens = allTokens[chainId]?.[this.config.selectedAddress] || [];
+  const detectedTokens = allDetectedTokens[chainId]?.[this.config.selectedAddress] || [];
+  return [
+    ...new Set(
+      [...tokens, ...detectedTokens].map(
+        (token) => toHex(toChecksumHexAddress(token.address))
+      )
+    )
+  ].sort();
+};
+_stopPoll = new WeakSet();
+stopPoll_fn = function() {
+  if (this.handle) {
+    clearTimeout(this.handle);
+  }
+};
+_poll = new WeakSet();
+poll_fn = async function() {
+  await safelyExecute(() => this.updateExchangeRates());
+  this.handle = setTimeout(() => {
+    __privateMethod(this, _poll, poll_fn).call(this);
+  }, this.config.interval);
+};
+_fetchAndMapExchangeRates = new WeakSet();
+fetchAndMapExchangeRates_fn = async function({
+  tokenAddresses,
+  chainId,
+  nativeCurrency
+}) {
+  if (!__privateGet(this, _tokenPricesService).validateChainIdSupported(chainId)) {
+    return tokenAddresses.reduce((obj, tokenAddress) => {
+      return {
+        ...obj,
+        [tokenAddress]: void 0
+      };
+    }, {});
+  }
+  if (__privateGet(this, _tokenPricesService).validateCurrencySupported(nativeCurrency)) {
+    return await __privateMethod(this, _fetchAndMapExchangeRatesForSupportedNativeCurrency, fetchAndMapExchangeRatesForSupportedNativeCurrency_fn).call(this, {
+      tokenAddresses,
+      chainId,
+      nativeCurrency
+    });
+  }
+  return await __privateMethod(this, _fetchAndMapExchangeRatesForUnsupportedNativeCurrency, fetchAndMapExchangeRatesForUnsupportedNativeCurrency_fn).call(this, {
+    tokenAddresses,
+    nativeCurrency
+  });
+};
+_fetchAndMapExchangeRatesForSupportedNativeCurrency = new WeakSet();
+fetchAndMapExchangeRatesForSupportedNativeCurrency_fn = async function({
+  tokenAddresses,
+  chainId,
+  nativeCurrency
+}) {
+  const tokenPricesByTokenAddress = await reduceInBatchesSerially({
+    values: [...tokenAddresses].sort(),
+    batchSize: TOKEN_PRICES_BATCH_SIZE,
+    eachBatch: async (allTokenPricesByTokenAddress, batch) => {
+      const tokenPricesByTokenAddressForBatch = await __privateGet(this, _tokenPricesService).fetchTokenPrices({
+        tokenAddresses: batch,
+        chainId,
+        currency: nativeCurrency
+      });
+      return {
+        ...allTokenPricesByTokenAddress,
+        ...tokenPricesByTokenAddressForBatch
+      };
+    },
+    initialResult: {}
+  });
+  return Object.entries(tokenPricesByTokenAddress).reduce(
+    (obj, [tokenAddress, tokenPrice]) => {
+      return {
+        ...obj,
+        [tokenAddress]: tokenPrice?.value
+      };
+    },
+    {}
+  );
+};
+_fetchAndMapExchangeRatesForUnsupportedNativeCurrency = new WeakSet();
+fetchAndMapExchangeRatesForUnsupportedNativeCurrency_fn = async function({
+  tokenAddresses,
+  nativeCurrency
+}) {
+  const [
+    contractExchangeRates,
+    fallbackCurrencyToNativeCurrencyConversionRate
+  ] = await Promise.all([
+    __privateMethod(this, _fetchAndMapExchangeRatesForSupportedNativeCurrency, fetchAndMapExchangeRatesForSupportedNativeCurrency_fn).call(this, {
+      tokenAddresses,
+      chainId: this.config.chainId,
+      nativeCurrency: FALL_BACK_VS_CURRENCY
+    }),
+    getCurrencyConversionRate({
+      from: FALL_BACK_VS_CURRENCY,
+      to: nativeCurrency
+    })
+  ]);
+  if (fallbackCurrencyToNativeCurrencyConversionRate === null) {
+    return {};
+  }
+  return Object.entries(contractExchangeRates).reduce(
+    (obj, [tokenAddress, tokenValue]) => {
+      return {
+        ...obj,
+        [tokenAddress]: tokenValue ? tokenValue * fallbackCurrencyToNativeCurrencyConversionRate : void 0
+      };
+    },
+    {}
+  );
+};
+var TokenRatesController_default = TokenRatesController;
+
+export {
+  TokenRatesController,
+  TokenRatesController_default
+};
+//# sourceMappingURL=chunk-2IZUMKMY.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-2IZUMKMY.mjs.map b/node_modules/@metamask/assets-controllers/dist/chunk-2IZUMKMY.mjs.map
new file mode 100644
index 0000000..235d04d
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-2IZUMKMY.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/TokenRatesController.ts"],"sourcesContent":["import type { BaseConfig, BaseState } from '@metamask/base-controller';\nimport {\n  safelyExecute,\n  toChecksumHexAddress,\n  FALL_BACK_VS_CURRENCY,\n  toHex,\n} from '@metamask/controller-utils';\nimport type {\n  NetworkClientId,\n  NetworkController,\n  NetworkState,\n} from '@metamask/network-controller';\nimport { StaticIntervalPollingControllerV1 } from '@metamask/polling-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport { createDeferredPromise, type Hex } from '@metamask/utils';\nimport { isEqual } from 'lodash';\n\nimport { reduceInBatchesSerially, TOKEN_PRICES_BATCH_SIZE } from './assetsUtil';\nimport { fetchExchangeRate as fetchNativeCurrencyExchangeRate } from './crypto-compare';\nimport type { AbstractTokenPricesService } from './token-prices-service/abstract-token-prices-service';\nimport type { TokensState } from './TokensController';\n\n/**\n * @type Token\n *\n * Token representation\n * @property address - Hex address of the token contract\n * @property decimals - Number of decimals the token uses\n * @property symbol - Symbol of the token\n * @property image - Image of the token, url or bit32 image\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface Token {\n  address: string;\n  decimals: number;\n  symbol: string;\n  aggregators?: string[];\n  image?: string;\n  balanceError?: unknown;\n  isERC721?: boolean;\n  name?: string;\n}\n\n/**\n * @type TokenRatesConfig\n *\n * Token rates controller configuration\n * @property interval - Polling interval used to fetch new token rates\n * @property nativeCurrency - Current native currency selected to use base of rates\n * @property chainId - Current network chainId\n * @property tokens - List of tokens to track exchange rates for\n * @property threshold - Threshold to invalidate the supportedChains\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface TokenRatesConfig extends BaseConfig {\n  interval: number;\n  nativeCurrency: string;\n  chainId: Hex;\n  selectedAddress: string;\n  allTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n  allDetectedTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n  threshold: number;\n}\n\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface ContractExchangeRates {\n  [address: string]: number | undefined;\n}\n\nenum PollState {\n  Active = 'Active',\n  Inactive = 'Inactive',\n}\n\n/**\n * @type TokenRatesState\n *\n * Token rates controller state\n * @property contractExchangeRates - Hash of token contract addresses to exchange rates (single globally selected chain, will be deprecated soon)\n * @property contractExchangeRatesByChainId - Hash of token contract addresses to exchange rates keyed by chain ID and native currency (ticker)\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface TokenRatesState extends BaseState {\n  contractExchangeRates: ContractExchangeRates;\n  contractExchangeRatesByChainId: Record<\n    Hex,\n    Record<string, ContractExchangeRates>\n  >;\n}\n\n/**\n * Uses the CryptoCompare API to fetch the exchange rate between one currency\n * and another, i.e., the multiplier to apply the amount of one currency in\n * order to convert it to another.\n *\n * @param args - The arguments to this function.\n * @param args.from - The currency to convert from.\n * @param args.to - The currency to convert to.\n * @returns The exchange rate between `fromCurrency` to `toCurrency` if one\n * exists, or null if one does not.\n */\nasync function getCurrencyConversionRate({\n  from,\n  to,\n}: {\n  from: string;\n  to: string;\n}) {\n  const includeUSDRate = false;\n  try {\n    const result = await fetchNativeCurrencyExchangeRate(\n      to,\n      from,\n      includeUSDRate,\n    );\n    return result.conversionRate;\n  } catch (error) {\n    if (\n      error instanceof Error &&\n      error.message.includes('market does not exist for this coin pair')\n    ) {\n      return null;\n    }\n    throw error;\n  }\n}\n\n/**\n * Controller that passively polls on a set interval for token-to-fiat exchange rates\n * for tokens stored in the TokensController\n */\nexport class TokenRatesController extends StaticIntervalPollingControllerV1<\n  TokenRatesConfig,\n  TokenRatesState\n> {\n  private handle?: ReturnType<typeof setTimeout>;\n\n  #pollState = PollState.Inactive;\n\n  #tokenPricesService: AbstractTokenPricesService;\n\n  #inProcessExchangeRateUpdates: Record<`${Hex}:${string}`, Promise<void>> = {};\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'TokenRatesController';\n\n  private readonly getNetworkClientById: NetworkController['getNetworkClientById'];\n\n  /**\n   * Creates a TokenRatesController instance.\n   *\n   * @param options - The controller options.\n   * @param options.interval - The polling interval in ms\n   * @param options.threshold - The duration in ms before metadata fetched from CoinGecko is considered stale\n   * @param options.getNetworkClientById - Gets the network client with the given id from the NetworkController.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.ticker - The ticker for the current network.\n   * @param options.selectedAddress - The current selected address.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.onTokensStateChange - Allows subscribing to token controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network state changes.\n   * @param options.tokenPricesService - An object in charge of retrieving token prices.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      interval = 3 * 60 * 1000,\n      threshold = 6 * 60 * 60 * 1000,\n      getNetworkClientById,\n      chainId: initialChainId,\n      ticker: initialTicker,\n      selectedAddress: initialSelectedAddress,\n      onPreferencesStateChange,\n      onTokensStateChange,\n      onNetworkStateChange,\n      tokenPricesService,\n    }: {\n      interval?: number;\n      threshold?: number;\n      getNetworkClientById: NetworkController['getNetworkClientById'];\n      chainId: Hex;\n      ticker: string;\n      selectedAddress: string;\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onTokensStateChange: (\n        listener: (tokensState: TokensState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      tokenPricesService: AbstractTokenPricesService;\n    },\n    config?: Partial<TokenRatesConfig>,\n    state?: Partial<TokenRatesState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      interval,\n      threshold,\n      disabled: false,\n      nativeCurrency: initialTicker,\n      chainId: initialChainId,\n      selectedAddress: initialSelectedAddress,\n      allTokens: {}, // TODO: initialize these correctly, maybe as part of BaseControllerV2 migration\n      allDetectedTokens: {},\n    };\n\n    this.defaultState = {\n      contractExchangeRates: {},\n      contractExchangeRatesByChainId: {},\n    };\n    this.initialize();\n    this.setIntervalLength(interval);\n    this.getNetworkClientById = getNetworkClientById;\n    this.#tokenPricesService = tokenPricesService;\n\n    if (config?.disabled) {\n      this.configure({ disabled: true }, false, false);\n    }\n\n    onPreferencesStateChange(async ({ selectedAddress }) => {\n      if (this.config.selectedAddress !== selectedAddress) {\n        this.configure({ selectedAddress });\n        if (this.#pollState === PollState.Active) {\n          await this.updateExchangeRates();\n        }\n      }\n    });\n\n    onTokensStateChange(async ({ allTokens, allDetectedTokens }) => {\n      const previousTokenAddresses = this.#getTokenAddresses(\n        this.config.chainId,\n      );\n      this.configure({ allTokens, allDetectedTokens });\n      const newTokenAddresses = this.#getTokenAddresses(this.config.chainId);\n      if (\n        !isEqual(previousTokenAddresses, newTokenAddresses) &&\n        this.#pollState === PollState.Active\n      ) {\n        await this.updateExchangeRates();\n      }\n    });\n\n    onNetworkStateChange(async ({ providerConfig }) => {\n      const { chainId, ticker } = providerConfig;\n      if (\n        this.config.chainId !== chainId ||\n        this.config.nativeCurrency !== ticker\n      ) {\n        this.update({ contractExchangeRates: {} });\n        this.configure({ chainId, nativeCurrency: ticker });\n        if (this.#pollState === PollState.Active) {\n          await this.updateExchangeRates();\n        }\n      }\n    });\n  }\n\n  /**\n   * Get the user's tokens for the given chain.\n   *\n   * @param chainId - The chain ID.\n   * @returns The list of tokens addresses for the current chain\n   */\n  #getTokenAddresses(chainId: Hex): Hex[] {\n    const { allTokens, allDetectedTokens } = this.config;\n    const tokens = allTokens[chainId]?.[this.config.selectedAddress] || [];\n    const detectedTokens =\n      allDetectedTokens[chainId]?.[this.config.selectedAddress] || [];\n\n    return [\n      ...new Set(\n        [...tokens, ...detectedTokens].map((token) =>\n          toHex(toChecksumHexAddress(token.address)),\n        ),\n      ),\n    ].sort();\n  }\n\n  /**\n   * Start (or restart) polling.\n   */\n  async start() {\n    this.#stopPoll();\n    this.#pollState = PollState.Active;\n    await this.#poll();\n  }\n\n  /**\n   * Stop polling.\n   */\n  stop() {\n    this.#stopPoll();\n    this.#pollState = PollState.Inactive;\n  }\n\n  /**\n   * Clear the active polling timer, if present.\n   */\n  #stopPoll() {\n    if (this.handle) {\n      clearTimeout(this.handle);\n    }\n  }\n\n  /**\n   * Poll for exchange rate updates.\n   */\n  async #poll() {\n    await safelyExecute(() => this.updateExchangeRates());\n\n    // Poll using recursive `setTimeout` instead of `setInterval` so that\n    // requests don't stack if they take longer than the polling interval\n    this.handle = setTimeout(() => {\n      this.#poll();\n    }, this.config.interval);\n  }\n\n  /**\n   * Updates exchange rates for all tokens.\n   */\n  async updateExchangeRates() {\n    const { chainId, nativeCurrency } = this.config;\n    await this.updateExchangeRatesByChainId({\n      chainId,\n      nativeCurrency,\n    });\n  }\n\n  /**\n   * Updates exchange rates for all tokens.\n   *\n   * @param options - The options to fetch exchange rates.\n   * @param options.chainId - The chain ID.\n   * @param options.nativeCurrency - The ticker for the chain.\n   */\n  async updateExchangeRatesByChainId({\n    chainId,\n    nativeCurrency,\n  }: {\n    chainId: Hex;\n    nativeCurrency: string;\n  }) {\n    if (this.disabled) {\n      return;\n    }\n\n    const tokenAddresses = this.#getTokenAddresses(chainId);\n    if (tokenAddresses.length === 0) {\n      return;\n    }\n\n    const updateKey: `${Hex}:${string}` = `${chainId}:${nativeCurrency}`;\n    if (updateKey in this.#inProcessExchangeRateUpdates) {\n      // This prevents redundant updates\n      // This promise is resolved after the in-progress update has finished,\n      // and state has been updated.\n      await this.#inProcessExchangeRateUpdates[updateKey];\n      return;\n    }\n\n    const {\n      promise: inProgressUpdate,\n      resolve: updateSucceeded,\n      reject: updateFailed,\n    } = createDeferredPromise({ suppressUnhandledRejection: true });\n    this.#inProcessExchangeRateUpdates[updateKey] = inProgressUpdate;\n\n    try {\n      const newContractExchangeRates = await this.#fetchAndMapExchangeRates({\n        tokenAddresses,\n        chainId,\n        nativeCurrency,\n      });\n\n      const existingContractExchangeRates = this.state.contractExchangeRates;\n      const updatedContractExchangeRates =\n        chainId === this.config.chainId &&\n        nativeCurrency === this.config.nativeCurrency\n          ? newContractExchangeRates\n          : existingContractExchangeRates;\n\n      const existingContractExchangeRatesForChainId =\n        this.state.contractExchangeRatesByChainId[chainId] ?? {};\n      const updatedContractExchangeRatesForChainId = {\n        ...this.state.contractExchangeRatesByChainId,\n        [chainId]: {\n          ...existingContractExchangeRatesForChainId,\n          [nativeCurrency]: {\n            ...existingContractExchangeRatesForChainId[nativeCurrency],\n            ...newContractExchangeRates,\n          },\n        },\n      };\n\n      this.update({\n        contractExchangeRates: updatedContractExchangeRates,\n        contractExchangeRatesByChainId: updatedContractExchangeRatesForChainId,\n      });\n      updateSucceeded();\n    } catch (error: unknown) {\n      updateFailed(error);\n      throw error;\n    } finally {\n      delete this.#inProcessExchangeRateUpdates[updateKey];\n    }\n  }\n\n  /**\n   * Uses the token prices service to retrieve exchange rates for tokens in a\n   * particular currency.\n   *\n   * If the price API does not support the given chain ID, returns an empty\n   * object.\n   *\n   * If the price API does not support the given currency, retrieves exchange\n   * rates in a known currency instead, then converts those rates using the\n   * exchange rate between the known currency and desired currency.\n   *\n   * @param args - The arguments to this function.\n   * @param args.tokenAddresses - Addresses for tokens.\n   * @param args.chainId - The EIP-155 ID of the chain where the tokens live.\n   * @param args.nativeCurrency - The native currency in which to request\n   * exchange rates.\n   * @returns A map from token address to its exchange rate in the native\n   * currency, or an empty map if no exchange rates can be obtained for the\n   * chain ID.\n   */\n  async #fetchAndMapExchangeRates({\n    tokenAddresses,\n    chainId,\n    nativeCurrency,\n  }: {\n    tokenAddresses: Hex[];\n    chainId: Hex;\n    nativeCurrency: string;\n  }): Promise<ContractExchangeRates> {\n    if (!this.#tokenPricesService.validateChainIdSupported(chainId)) {\n      return tokenAddresses.reduce((obj, tokenAddress) => {\n        return {\n          ...obj,\n          [tokenAddress]: undefined,\n        };\n      }, {});\n    }\n\n    if (this.#tokenPricesService.validateCurrencySupported(nativeCurrency)) {\n      return await this.#fetchAndMapExchangeRatesForSupportedNativeCurrency({\n        tokenAddresses,\n        chainId,\n        nativeCurrency,\n      });\n    }\n\n    return await this.#fetchAndMapExchangeRatesForUnsupportedNativeCurrency({\n      tokenAddresses,\n      nativeCurrency,\n    });\n  }\n\n  /**\n   * Updates token rates for the given networkClientId\n   *\n   * @param networkClientId - The network client ID used to get a ticker value.\n   * @returns The controller state.\n   */\n  async _executePoll(networkClientId: NetworkClientId): Promise<void> {\n    const networkClient = this.getNetworkClientById(networkClientId);\n    await this.updateExchangeRatesByChainId({\n      chainId: networkClient.configuration.chainId,\n      nativeCurrency: networkClient.configuration.ticker,\n    });\n  }\n\n  /**\n   * Retrieves prices in the given currency for the given tokens on the given\n   * chain. Ensures that token addresses are checksum addresses.\n   *\n   * @param args - The arguments to this function.\n   * @param args.tokenAddresses - Addresses for tokens.\n   * @param args.chainId - The EIP-155 ID of the chain where the tokens live.\n   * @param args.nativeCurrency - The native currency in which to request\n   * prices.\n   * @returns A map of the token addresses (as checksums) to their prices in the\n   * native currency.\n   */\n  async #fetchAndMapExchangeRatesForSupportedNativeCurrency({\n    tokenAddresses,\n    chainId,\n    nativeCurrency,\n  }: {\n    tokenAddresses: Hex[];\n    chainId: Hex;\n    nativeCurrency: string;\n  }): Promise<ContractExchangeRates> {\n    const tokenPricesByTokenAddress = await reduceInBatchesSerially<\n      Hex,\n      Awaited<ReturnType<AbstractTokenPricesService['fetchTokenPrices']>>\n    >({\n      values: [...tokenAddresses].sort(),\n      batchSize: TOKEN_PRICES_BATCH_SIZE,\n      eachBatch: async (allTokenPricesByTokenAddress, batch) => {\n        const tokenPricesByTokenAddressForBatch =\n          await this.#tokenPricesService.fetchTokenPrices({\n            tokenAddresses: batch,\n            chainId,\n            currency: nativeCurrency,\n          });\n\n        return {\n          ...allTokenPricesByTokenAddress,\n          ...tokenPricesByTokenAddressForBatch,\n        };\n      },\n      initialResult: {},\n    });\n\n    return Object.entries(tokenPricesByTokenAddress).reduce(\n      (obj, [tokenAddress, tokenPrice]) => {\n        return {\n          ...obj,\n          [tokenAddress]: tokenPrice?.value,\n        };\n      },\n      {},\n    );\n  }\n\n  /**\n   * If the price API does not support a given native currency, then we need to\n   * convert it to a fallback currency and feed that currency into the price\n   * API, then convert the prices to our desired native currency.\n   *\n   * @param args - The arguments to this function.\n   * @param args.tokenAddresses - Addresses for tokens.\n   * @param args.nativeCurrency - The native currency in which to request\n   * prices.\n   * @returns A map of the token addresses (as checksums) to their prices in the\n   * native currency.\n   */\n  async #fetchAndMapExchangeRatesForUnsupportedNativeCurrency({\n    tokenAddresses,\n    nativeCurrency,\n  }: {\n    tokenAddresses: Hex[];\n    nativeCurrency: string;\n  }): Promise<ContractExchangeRates> {\n    const [\n      contractExchangeRates,\n      fallbackCurrencyToNativeCurrencyConversionRate,\n    ] = await Promise.all([\n      this.#fetchAndMapExchangeRatesForSupportedNativeCurrency({\n        tokenAddresses,\n        chainId: this.config.chainId,\n        nativeCurrency: FALL_BACK_VS_CURRENCY,\n      }),\n      getCurrencyConversionRate({\n        from: FALL_BACK_VS_CURRENCY,\n        to: nativeCurrency,\n      }),\n    ]);\n\n    if (fallbackCurrencyToNativeCurrencyConversionRate === null) {\n      return {};\n    }\n\n    return Object.entries(contractExchangeRates).reduce(\n      (obj, [tokenAddress, tokenValue]) => {\n        return {\n          ...obj,\n          [tokenAddress]: tokenValue\n            ? tokenValue * fallbackCurrencyToNativeCurrencyConversionRate\n            : undefined,\n        };\n      },\n      {},\n    );\n  }\n}\n\nexport default TokenRatesController;\n"],"mappings":"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","names":[]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-355MWUUQ.js b/node_modules/@metamask/assets-controllers/dist/chunk-355MWUUQ.js
new file mode 100644
index 0000000..485894b
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-355MWUUQ.js
@@ -0,0 +1,115 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});
+
+var _chunkRELRWIJNjs = require('./chunk-RELRWIJN.js');
+
+// src/Standards/ERC20Standard.ts
+var _util = require('@ethereumjs/util');
+var _contracts = require('@ethersproject/contracts');
+var _abiutils = require('@metamask/abi-utils');
+var _controllerutils = require('@metamask/controller-utils');
+var _metamaskethabis = require('@metamask/metamask-eth-abis');
+var _utils = require('@metamask/utils');
+var ERC20Standard = class {
+  constructor(provider) {
+    this.provider = provider;
+  }
+  /**
+   * Get balance or count for current account on specific asset contract.
+   *
+   * @param address - Asset ERC20 contract address.
+   * @param selectedAddress - Current account public address.
+   * @returns Promise resolving to BN object containing balance for current account on specific asset contract.
+   */
+  async getBalanceOf(address, selectedAddress) {
+    const contract = new (0, _contracts.Contract)(address, _metamaskethabis.abiERC20, this.provider);
+    const balance = await contract.balanceOf(selectedAddress);
+    return _chunkRELRWIJNjs.ethersBigNumberToBN.call(void 0, balance);
+  }
+  /**
+   * Query for the decimals for a given ERC20 asset.
+   *
+   * @param address - ERC20 asset contract string.
+   * @returns Promise resolving to the 'decimals'.
+   */
+  async getTokenDecimals(address) {
+    const contract = new (0, _contracts.Contract)(address, _metamaskethabis.abiERC20, this.provider);
+    try {
+      const decimals = await contract.decimals();
+      return decimals.toString();
+    } catch (err) {
+      if (err instanceof Error && err.message.includes("call revert exception")) {
+        throw new Error("Failed to parse token decimals");
+      }
+      throw err;
+    }
+  }
+  /**
+   * Query for the name for a given ERC20 asset.
+   *
+   * @param address - ERC20 asset contract string.
+   * @returns Promise resolving to the 'name'.
+   */
+  async getTokenName(address) {
+    const contract = new (0, _contracts.Contract)(address, _metamaskethabis.abiERC20, this.provider);
+    try {
+      const name = await contract.name();
+      return name.toString();
+    } catch (err) {
+      if (err instanceof Error && err.message.includes("call revert exception")) {
+        throw new Error("Failed to parse token name");
+      }
+      throw err;
+    }
+  }
+  /**
+   * Query for symbol for a given ERC20 asset.
+   *
+   * @param address - ERC20 asset contract address.
+   * @returns Promise resolving to the 'symbol'.
+   */
+  async getTokenSymbol(address) {
+    const payload = { to: address, data: "0x95d89b41" };
+    const result = await this.provider.call(payload);
+    _utils.assertIsStrictHexString.call(void 0, result);
+    try {
+      const decoded = _abiutils.decodeSingle.call(void 0, "string", result);
+      if (decoded?.length > 0) {
+        return decoded;
+      }
+    } catch {
+    }
+    try {
+      const utf8 = _util.toUtf8.call(void 0, result);
+      if (utf8.length > 0) {
+        return utf8;
+      }
+    } catch {
+    }
+    throw new Error("Failed to parse token symbol");
+  }
+  /**
+   * Query if a contract implements an interface.
+   *
+   * @param address - Asset contract address.
+   * @param userAddress - The public address for the currently active user's account.
+   * @returns Promise resolving an object containing the standard, decimals, symbol and balance of the given contract/userAddress pair.
+   */
+  async getDetails(address, userAddress) {
+    const [decimals, symbol, balance] = await Promise.all([
+      this.getTokenDecimals(address),
+      this.getTokenSymbol(address),
+      userAddress ? this.getBalanceOf(address, userAddress) : void 0
+    ]);
+    return {
+      decimals,
+      symbol,
+      balance,
+      standard: _controllerutils.ERC20
+    };
+  }
+};
+
+
+
+exports.ERC20Standard = ERC20Standard;
+//# sourceMappingURL=chunk-355MWUUQ.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-355MWUUQ.js.map b/node_modules/@metamask/assets-controllers/dist/chunk-355MWUUQ.js.map
new file mode 100644
index 0000000..a58564c
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-355MWUUQ.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/Standards/ERC20Standard.ts"],"names":[],"mappings":";;;;;AAAA,SAAS,cAAc;AACvB,SAAS,gBAAgB;AAEzB,SAAS,oBAAoB;AAC7B,SAAS,aAAa;AACtB,SAAS,gBAAgB;AACzB,SAAS,+BAA+B;AAKjC,IAAM,gBAAN,MAAoB;AAAA,EAGzB,YAAY,UAAwB;AAClC,SAAK,WAAW;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,aAAa,SAAiB,iBAAsC;AACxE,UAAM,WAAW,IAAI,SAAS,SAAS,UAAU,KAAK,QAAQ;AAC9D,UAAM,UAAU,MAAM,SAAS,UAAU,eAAe;AACxD,WAAO,oBAAoB,OAAO;AAAA,EACpC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,iBAAiB,SAAkC;AACvD,UAAM,WAAW,IAAI,SAAS,SAAS,UAAU,KAAK,QAAQ;AAC9D,QAAI;AACF,YAAM,WAAW,MAAM,SAAS,SAAS;AACzC,aAAO,SAAS,SAAS;AAAA,IAC3B,SAAS,KAAK;AAEZ,UACE,eAAe,SACf,IAAI,QAAQ,SAAS,uBAAuB,GAC5C;AACA,cAAM,IAAI,MAAM,gCAAgC;AAAA,MAClD;AACA,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,aAAa,SAAkC;AACnD,UAAM,WAAW,IAAI,SAAS,SAAS,UAAU,KAAK,QAAQ;AAC9D,QAAI;AACF,YAAM,OAAO,MAAM,SAAS,KAAK;AACjC,aAAO,KAAK,SAAS;AAAA,IACvB,SAAS,KAAK;AAEZ,UACE,eAAe,SACf,IAAI,QAAQ,SAAS,uBAAuB,GAC5C;AACA,cAAM,IAAI,MAAM,4BAA4B;AAAA,MAC9C;AACA,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,eAAe,SAAkC;AAErD,UAAM,UAAU,EAAE,IAAI,SAAS,MAAM,aAAa;AAClD,UAAM,SAAS,MAAM,KAAK,SAAS,KAAK,OAAO;AAC/C,4BAAwB,MAAM;AAE9B,QAAI;AACF,YAAM,UAAU,aAAa,UAAU,MAAM;AAC7C,UAAI,SAAS,SAAS,GAAG;AACvB,eAAO;AAAA,MACT;AAAA,IACF,QAAQ;AAAA,IAER;AAGA,QAAI;AACF,YAAM,OAAO,OAAO,MAAM;AAC1B,UAAI,KAAK,SAAS,GAAG;AACnB,eAAO;AAAA,MACT;AAAA,IACF,QAAQ;AAAA,IAER;AAEA,UAAM,IAAI,MAAM,8BAA8B;AAAA,EAChD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,WACJ,SACA,aAMC;AACD,UAAM,CAAC,UAAU,QAAQ,OAAO,IAAI,MAAM,QAAQ,IAAI;AAAA,MACpD,KAAK,iBAAiB,OAAO;AAAA,MAC7B,KAAK,eAAe,OAAO;AAAA,MAC3B,cAAc,KAAK,aAAa,SAAS,WAAW,IAAI;AAAA,IAC1D,CAAC;AACD,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA,UAAU;AAAA,IACZ;AAAA,EACF;AACF","sourcesContent":["import { toUtf8 } from '@ethereumjs/util';\nimport { Contract } from '@ethersproject/contracts';\nimport type { Web3Provider } from '@ethersproject/providers';\nimport { decodeSingle } from '@metamask/abi-utils';\nimport { ERC20 } from '@metamask/controller-utils';\nimport { abiERC20 } from '@metamask/metamask-eth-abis';\nimport { assertIsStrictHexString } from '@metamask/utils';\nimport type BN from 'bn.js';\n\nimport { ethersBigNumberToBN } from '../assetsUtil';\n\nexport class ERC20Standard {\n  private readonly provider: Web3Provider;\n\n  constructor(provider: Web3Provider) {\n    this.provider = provider;\n  }\n\n  /**\n   * Get balance or count for current account on specific asset contract.\n   *\n   * @param address - Asset ERC20 contract address.\n   * @param selectedAddress - Current account public address.\n   * @returns Promise resolving to BN object containing balance for current account on specific asset contract.\n   */\n  async getBalanceOf(address: string, selectedAddress: string): Promise<BN> {\n    const contract = new Contract(address, abiERC20, this.provider);\n    const balance = await contract.balanceOf(selectedAddress);\n    return ethersBigNumberToBN(balance);\n  }\n\n  /**\n   * Query for the decimals for a given ERC20 asset.\n   *\n   * @param address - ERC20 asset contract string.\n   * @returns Promise resolving to the 'decimals'.\n   */\n  async getTokenDecimals(address: string): Promise<string> {\n    const contract = new Contract(address, abiERC20, this.provider);\n    try {\n      const decimals = await contract.decimals();\n      return decimals.toString();\n    } catch (err) {\n      // Mirror previous implementation\n      if (\n        err instanceof Error &&\n        err.message.includes('call revert exception')\n      ) {\n        throw new Error('Failed to parse token decimals');\n      }\n      throw err;\n    }\n  }\n\n  /**\n   * Query for the name for a given ERC20 asset.\n   *\n   * @param address - ERC20 asset contract string.\n   * @returns Promise resolving to the 'name'.\n   */\n  async getTokenName(address: string): Promise<string> {\n    const contract = new Contract(address, abiERC20, this.provider);\n    try {\n      const name = await contract.name();\n      return name.toString();\n    } catch (err) {\n      // Mirror previous implementation\n      if (\n        err instanceof Error &&\n        err.message.includes('call revert exception')\n      ) {\n        throw new Error('Failed to parse token name');\n      }\n      throw err;\n    }\n  }\n\n  /**\n   * Query for symbol for a given ERC20 asset.\n   *\n   * @param address - ERC20 asset contract address.\n   * @returns Promise resolving to the 'symbol'.\n   */\n  async getTokenSymbol(address: string): Promise<string> {\n    // Signature for calling `symbol()`\n    const payload = { to: address, data: '0x95d89b41' };\n    const result = await this.provider.call(payload);\n    assertIsStrictHexString(result);\n    // Parse as string - treat empty string as failure\n    try {\n      const decoded = decodeSingle('string', result);\n      if (decoded?.length > 0) {\n        return decoded;\n      }\n    } catch {\n      // Ignore error\n    }\n\n    // Parse as bytes - treat empty string as failure\n    try {\n      const utf8 = toUtf8(result);\n      if (utf8.length > 0) {\n        return utf8;\n      }\n    } catch {\n      // Ignore error\n    }\n\n    throw new Error('Failed to parse token symbol');\n  }\n\n  /**\n   * Query if a contract implements an interface.\n   *\n   * @param address - Asset contract address.\n   * @param userAddress - The public address for the currently active user's account.\n   * @returns Promise resolving an object containing the standard, decimals, symbol and balance of the given contract/userAddress pair.\n   */\n  async getDetails(\n    address: string,\n    userAddress?: string,\n  ): Promise<{\n    standard: string;\n    symbol: string | undefined;\n    decimals: string | undefined;\n    balance: BN | undefined;\n  }> {\n    const [decimals, symbol, balance] = await Promise.all([\n      this.getTokenDecimals(address),\n      this.getTokenSymbol(address),\n      userAddress ? this.getBalanceOf(address, userAddress) : undefined,\n    ]);\n    return {\n      decimals,\n      symbol,\n      balance,\n      standard: ERC20,\n    };\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-4FMVFW2T.js b/node_modules/@metamask/assets-controllers/dist/chunk-4FMVFW2T.js
new file mode 100644
index 0000000..1a99f58
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-4FMVFW2T.js
@@ -0,0 +1,343 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});
+
+
+
+var _chunkZ4BLTVTBjs = require('./chunk-Z4BLTVTB.js');
+
+// src/token-prices-service/codefi-v2.ts
+var _controllerutils = require('@metamask/controller-utils');
+var _utils = require('@metamask/utils');
+
+
+
+
+
+
+
+
+var _cockatiel = require('cockatiel');
+var SUPPORTED_CURRENCIES = [
+  // Bitcoin
+  "btc",
+  // Ether
+  "eth",
+  // Litecoin
+  "ltc",
+  // Bitcoin Cash
+  "bch",
+  // Binance Coin
+  "bnb",
+  // EOS
+  "eos",
+  // XRP
+  "xrp",
+  // Lumens
+  "xlm",
+  // Chainlink
+  "link",
+  // Polkadot
+  "dot",
+  // Yearn.finance
+  "yfi",
+  // US Dollar
+  "usd",
+  // United Arab Emirates Dirham
+  "aed",
+  // Argentine Peso
+  "ars",
+  // Australian Dollar
+  "aud",
+  // Bangladeshi Taka
+  "bdt",
+  // Bahraini Dinar
+  "bhd",
+  // Bermudian Dollar
+  "bmd",
+  // Brazil Real
+  "brl",
+  // Canadian Dollar
+  "cad",
+  // Swiss Franc
+  "chf",
+  // Chilean Peso
+  "clp",
+  // Chinese Yuan
+  "cny",
+  // Czech Koruna
+  "czk",
+  // Danish Krone
+  "dkk",
+  // Euro
+  "eur",
+  // British Pound Sterling
+  "gbp",
+  // Hong Kong Dollar
+  "hkd",
+  // Hungarian Forint
+  "huf",
+  // Indonesian Rupiah
+  "idr",
+  // Israeli New Shekel
+  "ils",
+  // Indian Rupee
+  "inr",
+  // Japanese Yen
+  "jpy",
+  // South Korean Won
+  "krw",
+  // Kuwaiti Dinar
+  "kwd",
+  // Sri Lankan Rupee
+  "lkr",
+  // Burmese Kyat
+  "mmk",
+  // Mexican Peso
+  "mxn",
+  // Malaysian Ringgit
+  "myr",
+  // Nigerian Naira
+  "ngn",
+  // Norwegian Krone
+  "nok",
+  // New Zealand Dollar
+  "nzd",
+  // Philippine Peso
+  "php",
+  // Pakistani Rupee
+  "pkr",
+  // Polish Zloty
+  "pln",
+  // Russian Ruble
+  "rub",
+  // Saudi Riyal
+  "sar",
+  // Swedish Krona
+  "sek",
+  // Singapore Dollar
+  "sgd",
+  // Thai Baht
+  "thb",
+  // Turkish Lira
+  "try",
+  // New Taiwan Dollar
+  "twd",
+  // Ukrainian hryvnia
+  "uah",
+  // Venezuelan bolvar fuerte
+  "vef",
+  // Vietnamese ng
+  "vnd",
+  // South African Rand
+  "zar",
+  // IMF Special Drawing Rights
+  "xdr",
+  // Silver - Troy Ounce
+  "xag",
+  // Gold - Troy Ounce
+  "xau",
+  // Bits
+  "bits",
+  // Satoshi
+  "sats"
+];
+var SUPPORTED_CHAIN_IDS = [
+  // Ethereum Mainnet
+  "0x1",
+  // OP Mainnet
+  "0xa",
+  // Cronos Mainnet
+  "0x19",
+  // BNB Smart Chain Mainnet
+  "0x38",
+  // Syscoin Mainnet
+  "0x39",
+  // OKXChain Mainnet
+  "0x42",
+  // Hoo Smart Chain
+  "0x46",
+  // Meter Mainnet
+  "0x52",
+  // TomoChain
+  "0x58",
+  // Gnosis
+  "0x64",
+  // Velas EVM Mainnet
+  "0x6a",
+  // Fuse Mainnet
+  "0x7a",
+  // Huobi ECO Chain Mainnet
+  "0x80",
+  // Polygon Mainnet
+  "0x89",
+  // Fantom Opera
+  "0xfa",
+  // Boba Network
+  "0x120",
+  // KCC Mainnet
+  "0x141",
+  // zkSync Era Mainnet
+  "0x144",
+  // Theta Mainnet
+  "0x169",
+  // Metis Andromeda Mainnet
+  "0x440",
+  // Moonbeam
+  "0x504",
+  // Moonriver
+  "0x505",
+  // Base
+  "0x2105",
+  // Shiden
+  "0x150",
+  // Smart Bitcoin Cash
+  "0x2710",
+  // Arbitrum One
+  "0xa4b1",
+  // Celo Mainnet
+  "0xa4ec",
+  // Oasis Emerald
+  "0xa516",
+  // Avalanche C-Chain
+  "0xa86a",
+  // Polis Mainnet
+  "0x518af",
+  // Aurora Mainnet
+  "0x4e454152",
+  // Harmony Mainnet Shard 0
+  "0x63564c40",
+  // Linea Mainnet
+  "0xe708"
+];
+var BASE_URL = "https://price-api.metafi.codefi.network/v2";
+var DEFAULT_TOKEN_PRICE_RETRIES = 3;
+var DEFAULT_TOKEN_PRICE_MAX_CONSECUTIVE_FAILURES = (1 + DEFAULT_TOKEN_PRICE_RETRIES) * 3;
+var DEFAULT_DEGRADED_THRESHOLD = 5e3;
+var _tokenPricePolicy;
+var CodefiTokenPricesServiceV2 = class {
+  /**
+   * Construct a Codefi Token Price Service.
+   *
+   * @param options - Constructor options
+   * @param options.degradedThreshold - The threshold between "normal" and "degrated" service,
+   * in milliseconds.
+   * @param options.retries - Number of retry attempts for each token price update.
+   * @param options.maximumConsecutiveFailures - The maximum number of consecutive failures
+   * allowed before breaking the circuit and pausing further updates.
+   * @param options.onBreak - An event handler for when the circuit breaks, useful for capturing
+   * metrics about network failures.
+   * @param options.onDegraded - An event handler for when the circuit remains closed, but requests
+   * are failing or resolving too slowly (i.e. resolving more slowly than the `degradedThreshold).
+   * @param options.circuitBreakDuration - The amount of time to wait when the circuit breaks
+   * from too many consecutive failures.
+   */
+  constructor({
+    degradedThreshold = DEFAULT_DEGRADED_THRESHOLD,
+    retries = DEFAULT_TOKEN_PRICE_RETRIES,
+    maximumConsecutiveFailures = DEFAULT_TOKEN_PRICE_MAX_CONSECUTIVE_FAILURES,
+    onBreak,
+    onDegraded,
+    circuitBreakDuration = 30 * 60 * 1e3
+  } = {}) {
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _tokenPricePolicy, void 0);
+    const retryPolicy = _cockatiel.retry.call(void 0, _cockatiel.handleAll, {
+      maxAttempts: retries,
+      backoff: new (0, _cockatiel.ExponentialBackoff)()
+    });
+    const circuitBreakerPolicy = _cockatiel.circuitBreaker.call(void 0, _cockatiel.handleAll, {
+      halfOpenAfter: circuitBreakDuration,
+      breaker: new (0, _cockatiel.ConsecutiveBreaker)(maximumConsecutiveFailures)
+    });
+    if (onBreak) {
+      circuitBreakerPolicy.onBreak(onBreak);
+    }
+    if (onDegraded) {
+      retryPolicy.onGiveUp(() => {
+        if (circuitBreakerPolicy.state === _cockatiel.CircuitState.Closed) {
+          onDegraded();
+        }
+      });
+      retryPolicy.onSuccess(({ duration }) => {
+        if (circuitBreakerPolicy.state === _cockatiel.CircuitState.Closed && duration > degradedThreshold) {
+          onDegraded();
+        }
+      });
+    }
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _tokenPricePolicy, _cockatiel.wrap.call(void 0, retryPolicy, circuitBreakerPolicy));
+  }
+  /**
+   * Retrieves prices in the given currency for the tokens identified by the
+   * given addresses which are expected to live on the given chain.
+   *
+   * @param args - The arguments to function.
+   * @param args.chainId - An EIP-155 chain ID.
+   * @param args.tokenAddresses - Addresses for tokens that live on the chain.
+   * @param args.currency - The desired currency of the token prices.
+   * @returns The prices for the requested tokens.
+   */
+  async fetchTokenPrices({
+    chainId,
+    tokenAddresses,
+    currency
+  }) {
+    const chainIdAsNumber = _utils.hexToNumber.call(void 0, chainId);
+    const url = new URL(`${BASE_URL}/chains/${chainIdAsNumber}/spot-prices`);
+    url.searchParams.append("tokenAddresses", tokenAddresses.join(","));
+    url.searchParams.append("vsCurrency", currency);
+    const pricesByCurrencyByTokenAddress = await _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _tokenPricePolicy).execute(
+      () => _controllerutils.handleFetch.call(void 0, url, { headers: { "Cache-Control": "no-cache" } })
+    );
+    return tokenAddresses.reduce(
+      (obj, tokenAddress) => {
+        const lowercasedTokenAddress = tokenAddress.toLowerCase();
+        const lowercasedCurrency = currency.toLowerCase();
+        const price = pricesByCurrencyByTokenAddress[lowercasedTokenAddress]?.[lowercasedCurrency];
+        if (!price) {
+          console.error(
+            `Could not find price for "${tokenAddress}" in "${currency}"`
+          );
+        }
+        const tokenPrice = {
+          tokenAddress,
+          value: price,
+          currency
+        };
+        return {
+          ...obj,
+          ...tokenPrice.value !== void 0 ? { [tokenAddress]: tokenPrice } : {}
+        };
+      },
+      {}
+    );
+  }
+  /**
+   * Type guard for whether the API can return token prices for the given chain
+   * ID.
+   *
+   * @param chainId - The chain ID to check.
+   * @returns True if the API supports the chain ID, false otherwise.
+   */
+  validateChainIdSupported(chainId) {
+    const supportedChainIds = SUPPORTED_CHAIN_IDS;
+    return typeof chainId === "string" && supportedChainIds.includes(chainId);
+  }
+  /**
+   * Type guard for whether the API can return token prices in the given
+   * currency.
+   *
+   * @param currency - The currency to check. If a string, can be either
+   * lowercase or uppercase.
+   * @returns True if the API supports the currency, false otherwise.
+   */
+  validateCurrencySupported(currency) {
+    const supportedCurrencies = SUPPORTED_CURRENCIES;
+    return typeof currency === "string" && supportedCurrencies.includes(currency.toLowerCase());
+  }
+};
+_tokenPricePolicy = new WeakMap();
+
+
+
+
+
+exports.SUPPORTED_CURRENCIES = SUPPORTED_CURRENCIES; exports.SUPPORTED_CHAIN_IDS = SUPPORTED_CHAIN_IDS; exports.CodefiTokenPricesServiceV2 = CodefiTokenPricesServiceV2;
+//# sourceMappingURL=chunk-4FMVFW2T.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-4FMVFW2T.js.map b/node_modules/@metamask/assets-controllers/dist/chunk-4FMVFW2T.js.map
new file mode 100644
index 0000000..494bb0d
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-4FMVFW2T.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/token-prices-service/codefi-v2.ts"],"names":[],"mappings":"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","sourcesContent":["import { handleFetch } from '@metamask/controller-utils';\nimport type { Hex } from '@metamask/utils';\nimport { hexToNumber } from '@metamask/utils';\nimport {\n  circuitBreaker,\n  ConsecutiveBreaker,\n  ExponentialBackoff,\n  handleAll,\n  type IPolicy,\n  retry,\n  wrap,\n  CircuitState,\n} from 'cockatiel';\n\nimport type {\n  AbstractTokenPricesService,\n  TokenPrice,\n  TokenPricesByTokenAddress,\n} from './abstract-token-prices-service';\n\n/**\n * The shape of the data that the /spot-prices endpoint returns.\n */\ntype SpotPricesEndpointData<\n  TokenAddress extends Hex,\n  Currency extends string,\n> = Record<TokenAddress, Record<Currency, number>>;\n\n/**\n * The list of currencies that can be supplied as the `vsCurrency` parameter to\n * the `/spot-prices` endpoint, in lowercase form.\n */\nexport const SUPPORTED_CURRENCIES = [\n  // Bitcoin\n  'btc',\n  // Ether\n  'eth',\n  // Litecoin\n  'ltc',\n  // Bitcoin Cash\n  'bch',\n  // Binance Coin\n  'bnb',\n  // EOS\n  'eos',\n  // XRP\n  'xrp',\n  // Lumens\n  'xlm',\n  // Chainlink\n  'link',\n  // Polkadot\n  'dot',\n  // Yearn.finance\n  'yfi',\n  // US Dollar\n  'usd',\n  // United Arab Emirates Dirham\n  'aed',\n  // Argentine Peso\n  'ars',\n  // Australian Dollar\n  'aud',\n  // Bangladeshi Taka\n  'bdt',\n  // Bahraini Dinar\n  'bhd',\n  // Bermudian Dollar\n  'bmd',\n  // Brazil Real\n  'brl',\n  // Canadian Dollar\n  'cad',\n  // Swiss Franc\n  'chf',\n  // Chilean Peso\n  'clp',\n  // Chinese Yuan\n  'cny',\n  // Czech Koruna\n  'czk',\n  // Danish Krone\n  'dkk',\n  // Euro\n  'eur',\n  // British Pound Sterling\n  'gbp',\n  // Hong Kong Dollar\n  'hkd',\n  // Hungarian Forint\n  'huf',\n  // Indonesian Rupiah\n  'idr',\n  // Israeli New Shekel\n  'ils',\n  // Indian Rupee\n  'inr',\n  // Japanese Yen\n  'jpy',\n  // South Korean Won\n  'krw',\n  // Kuwaiti Dinar\n  'kwd',\n  // Sri Lankan Rupee\n  'lkr',\n  // Burmese Kyat\n  'mmk',\n  // Mexican Peso\n  'mxn',\n  // Malaysian Ringgit\n  'myr',\n  // Nigerian Naira\n  'ngn',\n  // Norwegian Krone\n  'nok',\n  // New Zealand Dollar\n  'nzd',\n  // Philippine Peso\n  'php',\n  // Pakistani Rupee\n  'pkr',\n  // Polish Zloty\n  'pln',\n  // Russian Ruble\n  'rub',\n  // Saudi Riyal\n  'sar',\n  // Swedish Krona\n  'sek',\n  // Singapore Dollar\n  'sgd',\n  // Thai Baht\n  'thb',\n  // Turkish Lira\n  'try',\n  // New Taiwan Dollar\n  'twd',\n  // Ukrainian hryvnia\n  'uah',\n  // Venezuelan bolvar fuerte\n  'vef',\n  // Vietnamese ng\n  'vnd',\n  // South African Rand\n  'zar',\n  // IMF Special Drawing Rights\n  'xdr',\n  // Silver - Troy Ounce\n  'xag',\n  // Gold - Troy Ounce\n  'xau',\n  // Bits\n  'bits',\n  // Satoshi\n  'sats',\n] as const;\n\n/**\n * A currency that can be supplied as the `vsCurrency` parameter to\n * the `/spot-prices` endpoint. Covers both uppercase and lowercase versions.\n */\ntype SupportedCurrency =\n  | (typeof SUPPORTED_CURRENCIES)[number]\n  | Uppercase<(typeof SUPPORTED_CURRENCIES)[number]>;\n\n/**\n * The list of chain IDs that can be supplied in the URL for the `/spot-prices`\n * endpoint, but in hexadecimal form (for consistency with how we represent\n * chain IDs in other places).\n * @see Used by {@link CodefiTokenPricesServiceV2} to validate that a given chain ID is supported by V2 of the Codefi Price API.\n */\nexport const SUPPORTED_CHAIN_IDS = [\n  // Ethereum Mainnet\n  '0x1',\n  // OP Mainnet\n  '0xa',\n  // Cronos Mainnet\n  '0x19',\n  // BNB Smart Chain Mainnet\n  '0x38',\n  // Syscoin Mainnet\n  '0x39',\n  // OKXChain Mainnet\n  '0x42',\n  // Hoo Smart Chain\n  '0x46',\n  // Meter Mainnet\n  '0x52',\n  // TomoChain\n  '0x58',\n  // Gnosis\n  '0x64',\n  // Velas EVM Mainnet\n  '0x6a',\n  // Fuse Mainnet\n  '0x7a',\n  // Huobi ECO Chain Mainnet\n  '0x80',\n  // Polygon Mainnet\n  '0x89',\n  // Fantom Opera\n  '0xfa',\n  // Boba Network\n  '0x120',\n  // KCC Mainnet\n  '0x141',\n  // zkSync Era Mainnet\n  '0x144',\n  // Theta Mainnet\n  '0x169',\n  // Metis Andromeda Mainnet\n  '0x440',\n  // Moonbeam\n  '0x504',\n  // Moonriver\n  '0x505',\n  // Base\n  '0x2105',\n  // Shiden\n  '0x150',\n  // Smart Bitcoin Cash\n  '0x2710',\n  // Arbitrum One\n  '0xa4b1',\n  // Celo Mainnet\n  '0xa4ec',\n  // Oasis Emerald\n  '0xa516',\n  // Avalanche C-Chain\n  '0xa86a',\n  // Polis Mainnet\n  '0x518af',\n  // Aurora Mainnet\n  '0x4e454152',\n  // Harmony Mainnet Shard 0\n  '0x63564c40',\n  // Linea Mainnet\n  '0xe708',\n] as const;\n\n/**\n * A chain ID that can be supplied in the URL for the `/spot-prices` endpoint,\n * but in hexadecimal form (for consistency with how we represent chain IDs in\n * other places).\n */\ntype SupportedChainId = (typeof SUPPORTED_CHAIN_IDS)[number];\n\n/**\n * All requests to V2 of the Price API start with this.\n */\nconst BASE_URL = 'https://price-api.metafi.codefi.network/v2';\n\nconst DEFAULT_TOKEN_PRICE_RETRIES = 3;\n// Each update attempt will result (1 + retries) calls if the server is down\nconst DEFAULT_TOKEN_PRICE_MAX_CONSECUTIVE_FAILURES =\n  (1 + DEFAULT_TOKEN_PRICE_RETRIES) * 3;\n\nconst DEFAULT_DEGRADED_THRESHOLD = 5_000;\n\n/**\n * This version of the token prices service uses V2 of the Codefi Price API to\n * fetch token prices.\n */\nexport class CodefiTokenPricesServiceV2\n  implements\n    AbstractTokenPricesService<SupportedChainId, Hex, SupportedCurrency>\n{\n  #tokenPricePolicy: IPolicy;\n\n  /**\n   * Construct a Codefi Token Price Service.\n   *\n   * @param options - Constructor options\n   * @param options.degradedThreshold - The threshold between \"normal\" and \"degrated\" service,\n   * in milliseconds.\n   * @param options.retries - Number of retry attempts for each token price update.\n   * @param options.maximumConsecutiveFailures - The maximum number of consecutive failures\n   * allowed before breaking the circuit and pausing further updates.\n   * @param options.onBreak - An event handler for when the circuit breaks, useful for capturing\n   * metrics about network failures.\n   * @param options.onDegraded - An event handler for when the circuit remains closed, but requests\n   * are failing or resolving too slowly (i.e. resolving more slowly than the `degradedThreshold).\n   * @param options.circuitBreakDuration - The amount of time to wait when the circuit breaks\n   * from too many consecutive failures.\n   */\n  constructor({\n    degradedThreshold = DEFAULT_DEGRADED_THRESHOLD,\n    retries = DEFAULT_TOKEN_PRICE_RETRIES,\n    maximumConsecutiveFailures = DEFAULT_TOKEN_PRICE_MAX_CONSECUTIVE_FAILURES,\n    onBreak,\n    onDegraded,\n    circuitBreakDuration = 30 * 60 * 1000,\n  }: {\n    degradedThreshold?: number;\n    retries?: number;\n    maximumConsecutiveFailures?: number;\n    onBreak?: () => void;\n    onDegraded?: () => void;\n    circuitBreakDuration?: number;\n  } = {}) {\n    // Construct a policy that will retry each update, and halt further updates\n    // for a certain period after too many consecutive failures.\n    const retryPolicy = retry(handleAll, {\n      maxAttempts: retries,\n      backoff: new ExponentialBackoff(),\n    });\n    const circuitBreakerPolicy = circuitBreaker(handleAll, {\n      halfOpenAfter: circuitBreakDuration,\n      breaker: new ConsecutiveBreaker(maximumConsecutiveFailures),\n    });\n    if (onBreak) {\n      circuitBreakerPolicy.onBreak(onBreak);\n    }\n    if (onDegraded) {\n      retryPolicy.onGiveUp(() => {\n        if (circuitBreakerPolicy.state === CircuitState.Closed) {\n          onDegraded();\n        }\n      });\n      retryPolicy.onSuccess(({ duration }) => {\n        if (\n          circuitBreakerPolicy.state === CircuitState.Closed &&\n          duration > degradedThreshold\n        ) {\n          onDegraded();\n        }\n      });\n    }\n    this.#tokenPricePolicy = wrap(retryPolicy, circuitBreakerPolicy);\n  }\n\n  /**\n   * Retrieves prices in the given currency for the tokens identified by the\n   * given addresses which are expected to live on the given chain.\n   *\n   * @param args - The arguments to function.\n   * @param args.chainId - An EIP-155 chain ID.\n   * @param args.tokenAddresses - Addresses for tokens that live on the chain.\n   * @param args.currency - The desired currency of the token prices.\n   * @returns The prices for the requested tokens.\n   */\n  async fetchTokenPrices({\n    chainId,\n    tokenAddresses,\n    currency,\n  }: {\n    chainId: SupportedChainId;\n    tokenAddresses: Hex[];\n    currency: SupportedCurrency;\n  }): Promise<Partial<TokenPricesByTokenAddress<Hex, SupportedCurrency>>> {\n    const chainIdAsNumber = hexToNumber(chainId);\n\n    const url = new URL(`${BASE_URL}/chains/${chainIdAsNumber}/spot-prices`);\n    url.searchParams.append('tokenAddresses', tokenAddresses.join(','));\n    url.searchParams.append('vsCurrency', currency);\n\n    const pricesByCurrencyByTokenAddress: SpotPricesEndpointData<\n      Lowercase<Hex>,\n      Lowercase<SupportedCurrency>\n    > = await this.#tokenPricePolicy.execute(() =>\n      handleFetch(url, { headers: { 'Cache-Control': 'no-cache' } }),\n    );\n\n    return tokenAddresses.reduce(\n      (\n        obj: Partial<TokenPricesByTokenAddress<Hex, SupportedCurrency>>,\n        tokenAddress,\n      ) => {\n        // The Price API lowercases both currency and token addresses, so we have\n        // to keep track of them and make sure we return the original versions.\n        const lowercasedTokenAddress =\n          tokenAddress.toLowerCase() as Lowercase<Hex>;\n        const lowercasedCurrency =\n          currency.toLowerCase() as Lowercase<SupportedCurrency>;\n\n        const price =\n          pricesByCurrencyByTokenAddress[lowercasedTokenAddress]?.[\n            lowercasedCurrency\n          ];\n\n        if (!price) {\n          // console error instead of throwing to not interrupt the fetching of other tokens in case just one fails\n          console.error(\n            `Could not find price for \"${tokenAddress}\" in \"${currency}\"`,\n          );\n        }\n\n        const tokenPrice: TokenPrice<Hex, SupportedCurrency> = {\n          tokenAddress,\n          value: price,\n          currency,\n        };\n\n        return {\n          ...obj,\n          ...(tokenPrice.value !== undefined\n            ? { [tokenAddress]: tokenPrice }\n            : {}),\n        };\n      },\n      {},\n    ) as Partial<TokenPricesByTokenAddress<Hex, SupportedCurrency>>;\n  }\n\n  /**\n   * Type guard for whether the API can return token prices for the given chain\n   * ID.\n   *\n   * @param chainId - The chain ID to check.\n   * @returns True if the API supports the chain ID, false otherwise.\n   */\n  validateChainIdSupported(chainId: unknown): chainId is SupportedChainId {\n    const supportedChainIds: readonly string[] = SUPPORTED_CHAIN_IDS;\n    return typeof chainId === 'string' && supportedChainIds.includes(chainId);\n  }\n\n  /**\n   * Type guard for whether the API can return token prices in the given\n   * currency.\n   *\n   * @param currency - The currency to check. If a string, can be either\n   * lowercase or uppercase.\n   * @returns True if the API supports the currency, false otherwise.\n   */\n  validateCurrencySupported(currency: unknown): currency is SupportedCurrency {\n    const supportedCurrencies: readonly string[] = SUPPORTED_CURRENCIES;\n    return (\n      typeof currency === 'string' &&\n      supportedCurrencies.includes(currency.toLowerCase())\n    );\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-4LY47RPI.mjs b/node_modules/@metamask/assets-controllers/dist/chunk-4LY47RPI.mjs
new file mode 100644
index 0000000..b4fa939
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-4LY47RPI.mjs
@@ -0,0 +1,139 @@
+import {
+  __privateAdd,
+  __privateGet,
+  __privateSet
+} from "./chunk-XUI43LEZ.mjs";
+
+// src/TokenBalancesController.ts
+import {
+  BaseController
+} from "@metamask/base-controller";
+import { safelyExecute, toHex } from "@metamask/controller-utils";
+var DEFAULT_INTERVAL = 18e4;
+var controllerName = "TokenBalancesController";
+var metadata = {
+  contractBalances: { persist: true, anonymous: false }
+};
+function getDefaultTokenBalancesState() {
+  return {
+    contractBalances: {}
+  };
+}
+var _handle, _getERC20BalanceOf, _interval, _tokens, _disabled;
+var TokenBalancesController = class extends BaseController {
+  /**
+   * Construct a Token Balances Controller.
+   *
+   * @param options - The controller options.
+   * @param options.interval - Polling interval used to fetch new token balances.
+   * @param options.tokens - List of tokens to track balances for.
+   * @param options.disabled - If set to true, all tracked tokens contract balances updates are blocked.
+   * @param options.getERC20BalanceOf - Gets the balance of the given account at the given contract address.
+   * @param options.state - Initial state to set on this controller.
+   * @param options.messenger - The controller restricted messenger.
+   */
+  constructor({
+    interval = DEFAULT_INTERVAL,
+    tokens = [],
+    disabled = false,
+    getERC20BalanceOf,
+    messenger,
+    state = {}
+  }) {
+    super({
+      name: controllerName,
+      metadata,
+      messenger,
+      state: {
+        ...getDefaultTokenBalancesState(),
+        ...state
+      }
+    });
+    __privateAdd(this, _handle, void 0);
+    __privateAdd(this, _getERC20BalanceOf, void 0);
+    __privateAdd(this, _interval, void 0);
+    __privateAdd(this, _tokens, void 0);
+    __privateAdd(this, _disabled, void 0);
+    __privateSet(this, _disabled, disabled);
+    __privateSet(this, _interval, interval);
+    __privateSet(this, _tokens, tokens);
+    this.messagingSystem.subscribe(
+      "TokensController:stateChange",
+      ({ tokens: newTokens, detectedTokens }) => {
+        __privateSet(this, _tokens, [...newTokens, ...detectedTokens]);
+        this.updateBalances();
+      }
+    );
+    __privateSet(this, _getERC20BalanceOf, getERC20BalanceOf);
+    this.poll();
+  }
+  /**
+   * Allows controller to update tracked tokens contract balances.
+   */
+  enable() {
+    __privateSet(this, _disabled, false);
+  }
+  /**
+   * Blocks controller from updating tracked tokens contract balances.
+   */
+  disable() {
+    __privateSet(this, _disabled, true);
+  }
+  /**
+   * Starts a new polling interval.
+   *
+   * @param interval - Polling interval used to fetch new token balances.
+   */
+  async poll(interval) {
+    if (interval) {
+      __privateSet(this, _interval, interval);
+    }
+    if (__privateGet(this, _handle)) {
+      clearTimeout(__privateGet(this, _handle));
+    }
+    await safelyExecute(() => this.updateBalances());
+    __privateSet(this, _handle, setTimeout(() => {
+      this.poll(__privateGet(this, _interval));
+    }, __privateGet(this, _interval)));
+  }
+  /**
+   * Updates balances for all tokens.
+   */
+  async updateBalances() {
+    if (__privateGet(this, _disabled)) {
+      return;
+    }
+    const newContractBalances = {};
+    for (const token of __privateGet(this, _tokens)) {
+      const { address } = token;
+      const { selectedAddress } = this.messagingSystem.call(
+        "PreferencesController:getState"
+      );
+      try {
+        newContractBalances[address] = toHex(
+          await __privateGet(this, _getERC20BalanceOf).call(this, address, selectedAddress)
+        );
+        token.balanceError = null;
+      } catch (error) {
+        newContractBalances[address] = toHex(0);
+        token.balanceError = error;
+      }
+    }
+    this.update((state) => {
+      state.contractBalances = newContractBalances;
+    });
+  }
+};
+_handle = new WeakMap();
+_getERC20BalanceOf = new WeakMap();
+_interval = new WeakMap();
+_tokens = new WeakMap();
+_disabled = new WeakMap();
+var TokenBalancesController_default = TokenBalancesController;
+
+export {
+  getDefaultTokenBalancesState,
+  TokenBalancesController,
+  TokenBalancesController_default
+};
+//# sourceMappingURL=chunk-4LY47RPI.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-4LY47RPI.mjs.map b/node_modules/@metamask/assets-controllers/dist/chunk-4LY47RPI.mjs.map
new file mode 100644
index 0000000..8d32251
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-4LY47RPI.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/TokenBalancesController.ts"],"sourcesContent":["import {\n  type RestrictedControllerMessenger,\n  type ControllerGetStateAction,\n  type ControllerStateChangeEvent,\n  BaseController,\n} from '@metamask/base-controller';\nimport { safelyExecute, toHex } from '@metamask/controller-utils';\nimport type { PreferencesControllerGetStateAction } from '@metamask/preferences-controller';\n\nimport type { AssetsContractController } from './AssetsContractController';\nimport type { Token } from './TokenRatesController';\nimport type { TokensControllerStateChangeEvent } from './TokensController';\n\nconst DEFAULT_INTERVAL = 180000;\n\nconst controllerName = 'TokenBalancesController';\n\nconst metadata = {\n  contractBalances: { persist: true, anonymous: false },\n};\n\n/**\n * Token balances controller options\n * @property interval - Polling interval used to fetch new token balances.\n * @property tokens - List of tokens to track balances for.\n * @property disabled - If set to true, all tracked tokens contract balances updates are blocked.\n * @property getERC20BalanceOf - Gets the balance of the given account at the given contract address.\n */\ntype TokenBalancesControllerOptions = {\n  interval?: number;\n  tokens?: Token[];\n  disabled?: boolean;\n  getERC20BalanceOf: AssetsContractController['getERC20BalanceOf'];\n  messenger: TokenBalancesControllerMessenger;\n  state?: Partial<TokenBalancesControllerState>;\n};\n\n/**\n * Represents a mapping of hash token contract addresses to their balances.\n */\ntype ContractBalances = Record<string, string>;\n\n/**\n * Token balances controller state\n * @property contractBalances - Hash of token contract addresses to balances\n */\nexport type TokenBalancesControllerState = {\n  contractBalances: ContractBalances;\n};\n\nexport type TokenBalancesControllerGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  TokenBalancesControllerState\n>;\n\nexport type TokenBalancesControllerActions =\n  TokenBalancesControllerGetStateAction;\n\nexport type AllowedActions = PreferencesControllerGetStateAction;\n\nexport type TokenBalancesControllerStateChangeEvent =\n  ControllerStateChangeEvent<\n    typeof controllerName,\n    TokenBalancesControllerState\n  >;\n\nexport type TokenBalancesControllerEvents =\n  TokenBalancesControllerStateChangeEvent;\n\nexport type AllowedEvents = TokensControllerStateChangeEvent;\n\nexport type TokenBalancesControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  TokenBalancesControllerActions | AllowedActions,\n  TokenBalancesControllerEvents | AllowedEvents,\n  AllowedActions['type'],\n  AllowedEvents['type']\n>;\n\n/**\n * Get the default TokenBalancesController state.\n *\n * @returns The default TokenBalancesController state.\n */\nexport function getDefaultTokenBalancesState(): TokenBalancesControllerState {\n  return {\n    contractBalances: {},\n  };\n}\n\n/**\n * Controller that passively polls on a set interval token balances\n * for tokens stored in the TokensController\n */\nexport class TokenBalancesController extends BaseController<\n  typeof controllerName,\n  TokenBalancesControllerState,\n  TokenBalancesControllerMessenger\n> {\n  #handle?: ReturnType<typeof setTimeout>;\n\n  #getERC20BalanceOf: AssetsContractController['getERC20BalanceOf'];\n\n  #interval: number;\n\n  #tokens: Token[];\n\n  #disabled: boolean;\n\n  /**\n   * Construct a Token Balances Controller.\n   *\n   * @param options - The controller options.\n   * @param options.interval - Polling interval used to fetch new token balances.\n   * @param options.tokens - List of tokens to track balances for.\n   * @param options.disabled - If set to true, all tracked tokens contract balances updates are blocked.\n   * @param options.getERC20BalanceOf - Gets the balance of the given account at the given contract address.\n   * @param options.state - Initial state to set on this controller.\n   * @param options.messenger - The controller restricted messenger.\n   */\n  constructor({\n    interval = DEFAULT_INTERVAL,\n    tokens = [],\n    disabled = false,\n    getERC20BalanceOf,\n    messenger,\n    state = {},\n  }: TokenBalancesControllerOptions) {\n    super({\n      name: controllerName,\n      metadata,\n      messenger,\n      state: {\n        ...getDefaultTokenBalancesState(),\n        ...state,\n      },\n    });\n\n    this.#disabled = disabled;\n    this.#interval = interval;\n    this.#tokens = tokens;\n\n    this.messagingSystem.subscribe(\n      'TokensController:stateChange',\n      ({ tokens: newTokens, detectedTokens }) => {\n        this.#tokens = [...newTokens, ...detectedTokens];\n        this.updateBalances();\n      },\n    );\n\n    this.#getERC20BalanceOf = getERC20BalanceOf;\n\n    this.poll();\n  }\n\n  /**\n   * Allows controller to update tracked tokens contract balances.\n   */\n  enable() {\n    this.#disabled = false;\n  }\n\n  /**\n   * Blocks controller from updating tracked tokens contract balances.\n   */\n  disable() {\n    this.#disabled = true;\n  }\n\n  /**\n   * Starts a new polling interval.\n   *\n   * @param interval - Polling interval used to fetch new token balances.\n   */\n  async poll(interval?: number): Promise<void> {\n    if (interval) {\n      this.#interval = interval;\n    }\n\n    if (this.#handle) {\n      clearTimeout(this.#handle);\n    }\n\n    await safelyExecute(() => this.updateBalances());\n\n    this.#handle = setTimeout(() => {\n      this.poll(this.#interval);\n    }, this.#interval);\n  }\n\n  /**\n   * Updates balances for all tokens.\n   */\n  async updateBalances() {\n    if (this.#disabled) {\n      return;\n    }\n\n    const newContractBalances: ContractBalances = {};\n    for (const token of this.#tokens) {\n      const { address } = token;\n      const { selectedAddress } = this.messagingSystem.call(\n        'PreferencesController:getState',\n      );\n      try {\n        newContractBalances[address] = toHex(\n          await this.#getERC20BalanceOf(address, selectedAddress),\n        );\n        token.balanceError = null;\n      } catch (error) {\n        newContractBalances[address] = toHex(0);\n        token.balanceError = error;\n      }\n    }\n\n    this.update((state) => {\n      state.contractBalances = newContractBalances;\n    });\n  }\n}\n\nexport default TokenBalancesController;\n"],"mappings":";;;;;;;AAAA;AAAA,EAIE;AAAA,OACK;AACP,SAAS,eAAe,aAAa;AAOrC,IAAM,mBAAmB;AAEzB,IAAM,iBAAiB;AAEvB,IAAM,WAAW;AAAA,EACf,kBAAkB,EAAE,SAAS,MAAM,WAAW,MAAM;AACtD;AAiEO,SAAS,+BAA6D;AAC3E,SAAO;AAAA,IACL,kBAAkB,CAAC;AAAA,EACrB;AACF;AAxFA;AA8FO,IAAM,0BAAN,cAAsC,eAI3C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAsBA,YAAY;AAAA,IACV,WAAW;AAAA,IACX,SAAS,CAAC;AAAA,IACV,WAAW;AAAA,IACX;AAAA,IACA;AAAA,IACA,QAAQ,CAAC;AAAA,EACX,GAAmC;AACjC,UAAM;AAAA,MACJ,MAAM;AAAA,MACN;AAAA,MACA;AAAA,MACA,OAAO;AAAA,QACL,GAAG,6BAA6B;AAAA,QAChC,GAAG;AAAA,MACL;AAAA,IACF,CAAC;AArCH;AAEA;AAEA;AAEA;AAEA;AA+BE,uBAAK,WAAY;AACjB,uBAAK,WAAY;AACjB,uBAAK,SAAU;AAEf,SAAK,gBAAgB;AAAA,MACnB;AAAA,MACA,CAAC,EAAE,QAAQ,WAAW,eAAe,MAAM;AACzC,2BAAK,SAAU,CAAC,GAAG,WAAW,GAAG,cAAc;AAC/C,aAAK,eAAe;AAAA,MACtB;AAAA,IACF;AAEA,uBAAK,oBAAqB;AAE1B,SAAK,KAAK;AAAA,EACZ;AAAA;AAAA;AAAA;AAAA,EAKA,SAAS;AACP,uBAAK,WAAY;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA,EAKA,UAAU;AACR,uBAAK,WAAY;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,KAAK,UAAkC;AAC3C,QAAI,UAAU;AACZ,yBAAK,WAAY;AAAA,IACnB;AAEA,QAAI,mBAAK,UAAS;AAChB,mBAAa,mBAAK,QAAO;AAAA,IAC3B;AAEA,UAAM,cAAc,MAAM,KAAK,eAAe,CAAC;AAE/C,uBAAK,SAAU,WAAW,MAAM;AAC9B,WAAK,KAAK,mBAAK,UAAS;AAAA,IAC1B,GAAG,mBAAK,UAAS;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,iBAAiB;AACrB,QAAI,mBAAK,YAAW;AAClB;AAAA,IACF;AAEA,UAAM,sBAAwC,CAAC;AAC/C,eAAW,SAAS,mBAAK,UAAS;AAChC,YAAM,EAAE,QAAQ,IAAI;AACpB,YAAM,EAAE,gBAAgB,IAAI,KAAK,gBAAgB;AAAA,QAC/C;AAAA,MACF;AACA,UAAI;AACF,4BAAoB,OAAO,IAAI;AAAA,UAC7B,MAAM,mBAAK,oBAAL,WAAwB,SAAS;AAAA,QACzC;AACA,cAAM,eAAe;AAAA,MACvB,SAAS,OAAO;AACd,4BAAoB,OAAO,IAAI,MAAM,CAAC;AACtC,cAAM,eAAe;AAAA,MACvB;AAAA,IACF;AAEA,SAAK,OAAO,CAAC,UAAU;AACrB,YAAM,mBAAmB;AAAA,IAC3B,CAAC;AAAA,EACH;AACF;AAxHE;AAEA;AAEA;AAEA;AAEA;AAkHF,IAAO,kCAAQ;","names":[]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-4YU7CT4O.js b/node_modules/@metamask/assets-controllers/dist/chunk-4YU7CT4O.js
new file mode 100644
index 0000000..ec1c8b6
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-4YU7CT4O.js
@@ -0,0 +1,361 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+
+var _chunk6NO7Z5DLjs = require('./chunk-6NO7Z5DL.js');
+
+
+var _chunkVHCPQS4Xjs = require('./chunk-VHCPQS4X.js');
+
+
+var _chunk355MWUUQjs = require('./chunk-355MWUUQ.js');
+
+// src/AssetsContractController.ts
+var _contracts = require('@ethersproject/contracts');
+var _providers = require('@ethersproject/providers');
+var _basecontroller = require('@metamask/base-controller');
+var _controllerutils = require('@metamask/controller-utils');
+var _singlecallbalancecheckerabi = require('single-call-balance-checker-abi'); var _singlecallbalancecheckerabi2 = _interopRequireDefault(_singlecallbalancecheckerabi);
+var SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID = {
+  ["0x1" /* mainnet */]: "0xb1f8e55c7f64d203c1400b9d8555d050f94adf39",
+  ["0x38" /* bsc */]: "0x2352c63A83f9Fd126af8676146721Fa00924d7e4",
+  ["0x89" /* polygon */]: "0x2352c63A83f9Fd126af8676146721Fa00924d7e4",
+  ["0xa86a" /* avax */]: "0xD023D153a0DFa485130ECFdE2FAA7e612EF94818",
+  ["0x4e454152" /* aurora */]: "0x1286415D333855237f89Df27D388127181448538",
+  ["0xe704" /* linea_goerli */]: "0x10dAd7Ca3921471f616db788D9300DC97Db01783",
+  ["0xe708" /* linea_mainnet */]: "0xF62e6a41561b3650a69Bb03199C735e3E3328c0D",
+  ["0xa4b1" /* arbitrum */]: "0x151E24A486D7258dd7C33Fb67E4bB01919B7B32c",
+  ["0xa" /* optimism */]: "0xB1c568e9C3E6bdaf755A60c7418C269eb11524FC",
+  ["0x2105" /* base */]: "0x6AA75276052D96696134252587894ef5FFA520af",
+  ["0x144" /* zksync */]: "0x458fEd3144680a5b8bcfaa0F9594aa19B4Ea2D34"
+};
+var MISSING_PROVIDER_ERROR = "AssetsContractController failed to set the provider correctly. A provider must be set for this method to be available";
+var AssetsContractController = class extends _basecontroller.BaseControllerV1 {
+  /**
+   * Creates a AssetsContractController instance.
+   *
+   * @param options - The controller options.
+   * @param options.chainId - The chain ID of the current network.
+   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.
+   * @param options.onNetworkDidChange - Allows subscribing to network controller networkDidChange events.
+   * @param options.getNetworkClientById - Gets the network client with the given id from the NetworkController.
+   * @param config - Initial options used to configure this controller.
+   * @param state - Initial state to set on this controller.
+   */
+  constructor({
+    chainId: initialChainId,
+    onPreferencesStateChange,
+    onNetworkDidChange,
+    getNetworkClientById
+  }, config, state) {
+    super(config, state);
+    /**
+     * Name of this controller used during composition
+     */
+    this.name = "AssetsContractController";
+    this.defaultConfig = {
+      provider: void 0,
+      ipfsGateway: _controllerutils.IPFS_DEFAULT_GATEWAY_URL,
+      chainId: initialChainId
+    };
+    this.initialize();
+    this.getNetworkClientById = getNetworkClientById;
+    onPreferencesStateChange(({ ipfsGateway }) => {
+      this.configure({ ipfsGateway });
+    });
+    onNetworkDidChange((networkState) => {
+      if (this.config.chainId !== networkState.providerConfig.chainId) {
+        this.configure({
+          chainId: networkState.providerConfig.chainId
+        });
+      }
+    });
+  }
+  /**
+   * Sets a new provider.
+   *
+   * TODO: Replace this wth a method.
+   *
+   * @property provider - Provider used to create a new underlying Web3 instance
+   */
+  set provider(provider) {
+    this._provider = provider;
+  }
+  get provider() {
+    throw new Error("Property only used for setting");
+  }
+  /**
+   * Get the relevant provider instance.
+   *
+   * @param networkClientId - Network Client ID.
+   * @returns Web3Provider instance.
+   */
+  getProvider(networkClientId) {
+    const provider = networkClientId ? this.getNetworkClientById(networkClientId).provider : this._provider;
+    if (provider === void 0) {
+      throw new Error(MISSING_PROVIDER_ERROR);
+    }
+    return new (0, _providers.Web3Provider)(provider);
+  }
+  /**
+   * Get the relevant chain ID.
+   *
+   * @param networkClientId - Network Client ID used to get the provider.
+   * @returns Hex chain ID.
+   */
+  getChainId(networkClientId) {
+    return networkClientId ? this.getNetworkClientById(networkClientId).configuration.chainId : this.config.chainId;
+  }
+  /**
+   * Get a ERC20Standard instance using the relevant provider instance.
+   *
+   * @param networkClientId - Network Client ID used to get the provider.
+   * @returns ERC20Standard instance.
+   */
+  getERC20Standard(networkClientId) {
+    const provider = this.getProvider(networkClientId);
+    return new (0, _chunk355MWUUQjs.ERC20Standard)(provider);
+  }
+  /**
+   * Get a ERC721Standard instance using the relevant provider instance.
+   *
+   * @param networkClientId - Network Client ID used to get the provider.
+   * @returns ERC721Standard instance.
+   */
+  getERC721Standard(networkClientId) {
+    const provider = this.getProvider(networkClientId);
+    return new (0, _chunk6NO7Z5DLjs.ERC721Standard)(provider);
+  }
+  /**
+   * Get a ERC1155Standard instance using the relevant provider instance.
+   *
+   * @param networkClientId - Network Client ID used to get the provider.
+   * @returns ERC1155Standard instance.
+   */
+  getERC1155Standard(networkClientId) {
+    const provider = this.getProvider(networkClientId);
+    return new (0, _chunkVHCPQS4Xjs.ERC1155Standard)(provider);
+  }
+  /**
+   * Get balance or count for current account on specific asset contract.
+   *
+   * @param address - Asset ERC20 contract address.
+   * @param selectedAddress - Current account public address.
+   * @param networkClientId - Network Client ID to fetch the provider with.
+   * @returns Promise resolving to BN object containing balance for current account on specific asset contract.
+   */
+  async getERC20BalanceOf(address, selectedAddress, networkClientId) {
+    const erc20Standard = this.getERC20Standard(networkClientId);
+    return erc20Standard.getBalanceOf(address, selectedAddress);
+  }
+  /**
+   * Query for the decimals for a given ERC20 asset.
+   *
+   * @param address - ERC20 asset contract address.
+   * @param networkClientId - Network Client ID to fetch the provider with.
+   * @returns Promise resolving to the 'decimals'.
+   */
+  async getERC20TokenDecimals(address, networkClientId) {
+    const erc20Standard = this.getERC20Standard(networkClientId);
+    return erc20Standard.getTokenDecimals(address);
+  }
+  /**
+   * Query for the name for a given ERC20 asset.
+   *
+   * @param address - ERC20 asset contract address.
+   * @param networkClientId - Network Client ID to fetch the provider with.
+   * @returns Promise resolving to the 'decimals'.
+   */
+  async getERC20TokenName(address, networkClientId) {
+    const erc20Standard = this.getERC20Standard(networkClientId);
+    return erc20Standard.getTokenName(address);
+  }
+  /**
+   * Enumerate assets assigned to an owner.
+   *
+   * @param address - ERC721 asset contract address.
+   * @param selectedAddress - Current account public address.
+   * @param index - An NFT counter less than `balanceOf(selectedAddress)`.
+   * @param networkClientId - Network Client ID to fetch the provider with.
+   * @returns Promise resolving to token identifier for the 'index'th asset assigned to 'selectedAddress'.
+   */
+  getERC721NftTokenId(address, selectedAddress, index, networkClientId) {
+    const erc721Standard = this.getERC721Standard(networkClientId);
+    return erc721Standard.getNftTokenId(address, selectedAddress, index);
+  }
+  /**
+   * Enumerate assets assigned to an owner.
+   *
+   * @param tokenAddress - ERC721 asset contract address.
+   * @param userAddress - Current account public address.
+   * @param tokenId - ERC721 asset identifier.
+   * @param networkClientId - Network Client ID to fetch the provider with.
+   * @returns Promise resolving to an object containing the token standard and a set of details which depend on which standard the token supports.
+   */
+  async getTokenStandardAndDetails(tokenAddress, userAddress, tokenId, networkClientId) {
+    this.getProvider(networkClientId);
+    const { ipfsGateway } = this.config;
+    try {
+      const erc721Standard = this.getERC721Standard(networkClientId);
+      return {
+        ...await erc721Standard.getDetails(
+          tokenAddress,
+          ipfsGateway,
+          tokenId
+        )
+      };
+    } catch {
+    }
+    try {
+      const erc1155Standard = this.getERC1155Standard(networkClientId);
+      return {
+        ...await erc1155Standard.getDetails(
+          tokenAddress,
+          ipfsGateway,
+          tokenId
+        )
+      };
+    } catch {
+    }
+    try {
+      const erc20Standard = this.getERC20Standard(networkClientId);
+      return {
+        ...await erc20Standard.getDetails(tokenAddress, userAddress)
+      };
+    } catch {
+    }
+    throw new Error("Unable to determine contract standard");
+  }
+  /**
+   * Query for tokenURI for a given ERC721 asset.
+   *
+   * @param address - ERC721 asset contract address.
+   * @param tokenId - ERC721 asset identifier.
+   * @param networkClientId - Network Client ID to fetch the provider with.
+   * @returns Promise resolving to the 'tokenURI'.
+   */
+  async getERC721TokenURI(address, tokenId, networkClientId) {
+    const erc721Standard = this.getERC721Standard(networkClientId);
+    return erc721Standard.getTokenURI(address, tokenId);
+  }
+  /**
+   * Query for name for a given asset.
+   *
+   * @param address - ERC721 or ERC20 asset contract address.
+   * @param networkClientId - Network Client ID to fetch the provider with.
+   * @returns Promise resolving to the 'name'.
+   */
+  async getERC721AssetName(address, networkClientId) {
+    const erc721Standard = this.getERC721Standard(networkClientId);
+    return erc721Standard.getAssetName(address);
+  }
+  /**
+   * Query for symbol for a given asset.
+   *
+   * @param address - ERC721 or ERC20 asset contract address.
+   * @param networkClientId - Network Client ID to fetch the provider with.
+   * @returns Promise resolving to the 'symbol'.
+   */
+  async getERC721AssetSymbol(address, networkClientId) {
+    const erc721Standard = this.getERC721Standard(networkClientId);
+    return erc721Standard.getAssetSymbol(address);
+  }
+  /**
+   * Query for owner for a given ERC721 asset.
+   *
+   * @param address - ERC721 asset contract address.
+   * @param tokenId - ERC721 asset identifier.
+   * @param networkClientId - Network Client ID to fetch the provider with.
+   * @returns Promise resolving to the owner address.
+   */
+  async getERC721OwnerOf(address, tokenId, networkClientId) {
+    const erc721Standard = this.getERC721Standard(networkClientId);
+    return erc721Standard.getOwnerOf(address, tokenId);
+  }
+  /**
+   * Query for tokenURI for a given asset.
+   *
+   * @param address - ERC1155 asset contract address.
+   * @param tokenId - ERC1155 asset identifier.
+   * @param networkClientId - Network Client ID to fetch the provider with.
+   * @returns Promise resolving to the 'tokenURI'.
+   */
+  async getERC1155TokenURI(address, tokenId, networkClientId) {
+    const erc1155Standard = this.getERC1155Standard(networkClientId);
+    return erc1155Standard.getTokenURI(address, tokenId);
+  }
+  /**
+   * Query for balance of a given ERC 1155 token.
+   *
+   * @param userAddress - Wallet public address.
+   * @param nftAddress - ERC1155 asset contract address.
+   * @param nftId - ERC1155 asset identifier.
+   * @param networkClientId - Network Client ID to fetch the provider with.
+   * @returns Promise resolving to the 'balanceOf'.
+   */
+  async getERC1155BalanceOf(userAddress, nftAddress, nftId, networkClientId) {
+    const erc1155Standard = this.getERC1155Standard(networkClientId);
+    return erc1155Standard.getBalanceOf(nftAddress, userAddress, nftId);
+  }
+  /**
+   * Transfer single ERC1155 token.
+   *
+   * @param nftAddress - ERC1155 token address.
+   * @param senderAddress - ERC1155 token sender.
+   * @param recipientAddress - ERC1155 token recipient.
+   * @param nftId - ERC1155 token id.
+   * @param qty - Quantity of tokens to be sent.
+   * @param networkClientId - Network Client ID to fetch the provider with.
+   * @returns Promise resolving to the 'transferSingle' ERC1155 token.
+   */
+  async transferSingleERC1155(nftAddress, senderAddress, recipientAddress, nftId, qty, networkClientId) {
+    const erc1155Standard = this.getERC1155Standard(networkClientId);
+    return erc1155Standard.transferSingle(
+      nftAddress,
+      senderAddress,
+      recipientAddress,
+      nftId,
+      qty
+    );
+  }
+  /**
+   * Get the token balance for a list of token addresses in a single call. Only non-zero balances
+   * are returned.
+   *
+   * @param selectedAddress - The address to check token balances for.
+   * @param tokensToDetect - The token addresses to detect balances for.
+   * @param networkClientId - Network Client ID to fetch the provider with.
+   * @returns The list of non-zero token balances.
+   */
+  async getBalancesInSingleCall(selectedAddress, tokensToDetect, networkClientId) {
+    const chainId = this.getChainId(networkClientId);
+    const provider = this.getProvider(networkClientId);
+    if (!(chainId in SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID)) {
+      return {};
+    }
+    const contractAddress = SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID[chainId];
+    const contract = new (0, _contracts.Contract)(
+      contractAddress,
+      _singlecallbalancecheckerabi2.default,
+      provider
+    );
+    const result = await contract.balances([selectedAddress], tokensToDetect);
+    const nonZeroBalances = {};
+    if (result.length > 0) {
+      tokensToDetect.forEach((tokenAddress, index) => {
+        const balance = result[index];
+        if (String(balance) !== "0") {
+          nonZeroBalances[tokenAddress] = balance;
+        }
+      });
+    }
+    return nonZeroBalances;
+  }
+};
+var AssetsContractController_default = AssetsContractController;
+
+
+
+
+
+
+exports.SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID = SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID; exports.MISSING_PROVIDER_ERROR = MISSING_PROVIDER_ERROR; exports.AssetsContractController = AssetsContractController; exports.AssetsContractController_default = AssetsContractController_default;
+//# sourceMappingURL=chunk-4YU7CT4O.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-4YU7CT4O.js.map b/node_modules/@metamask/assets-controllers/dist/chunk-4YU7CT4O.js.map
new file mode 100644
index 0000000..48f0d1b
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-4YU7CT4O.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/AssetsContractController.ts"],"names":[],"mappings":"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","sourcesContent":["import { Contract } from '@ethersproject/contracts';\nimport { Web3Provider } from '@ethersproject/providers';\nimport type { BaseConfig, BaseState } from '@metamask/base-controller';\nimport { BaseControllerV1 } from '@metamask/base-controller';\nimport { IPFS_DEFAULT_GATEWAY_URL } from '@metamask/controller-utils';\nimport type {\n  NetworkClientId,\n  NetworkState,\n  NetworkController,\n  Provider,\n} from '@metamask/network-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport type { Hex } from '@metamask/utils';\nimport type BN from 'bn.js';\nimport abiSingleCallBalancesContract from 'single-call-balance-checker-abi';\n\nimport { SupportedTokenDetectionNetworks } from './assetsUtil';\nimport { ERC20Standard } from './Standards/ERC20Standard';\nimport { ERC1155Standard } from './Standards/NftStandards/ERC1155/ERC1155Standard';\nimport { ERC721Standard } from './Standards/NftStandards/ERC721/ERC721Standard';\n\n/**\n * Check if token detection is enabled for certain networks\n *\n * @param chainId - ChainID of network\n * @returns Whether the current network supports token detection\n */\nexport const SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID: Record<Hex, string> = {\n  [SupportedTokenDetectionNetworks.mainnet]:\n    '0xb1f8e55c7f64d203c1400b9d8555d050f94adf39',\n  [SupportedTokenDetectionNetworks.bsc]:\n    '0x2352c63A83f9Fd126af8676146721Fa00924d7e4',\n  [SupportedTokenDetectionNetworks.polygon]:\n    '0x2352c63A83f9Fd126af8676146721Fa00924d7e4',\n  [SupportedTokenDetectionNetworks.avax]:\n    '0xD023D153a0DFa485130ECFdE2FAA7e612EF94818',\n  [SupportedTokenDetectionNetworks.aurora]:\n    '0x1286415D333855237f89Df27D388127181448538',\n  [SupportedTokenDetectionNetworks.linea_goerli]:\n    '0x10dAd7Ca3921471f616db788D9300DC97Db01783',\n  [SupportedTokenDetectionNetworks.linea_mainnet]:\n    '0xF62e6a41561b3650a69Bb03199C735e3E3328c0D',\n  [SupportedTokenDetectionNetworks.arbitrum]:\n    '0x151E24A486D7258dd7C33Fb67E4bB01919B7B32c',\n  [SupportedTokenDetectionNetworks.optimism]:\n    '0xB1c568e9C3E6bdaf755A60c7418C269eb11524FC',\n  [SupportedTokenDetectionNetworks.base]:\n    '0x6AA75276052D96696134252587894ef5FFA520af',\n  [SupportedTokenDetectionNetworks.zksync]:\n    '0x458fEd3144680a5b8bcfaa0F9594aa19B4Ea2D34',\n};\n\nexport const MISSING_PROVIDER_ERROR =\n  'AssetsContractController failed to set the provider correctly. A provider must be set for this method to be available';\n\n/**\n * @type AssetsContractConfig\n *\n * Assets Contract controller configuration\n * @property provider - Provider used to create a new web3 instance\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface AssetsContractConfig extends BaseConfig {\n  provider: Provider | undefined;\n  ipfsGateway: string;\n  chainId: Hex;\n}\n\n/**\n * @type BalanceMap\n *\n * Key value object containing the balance for each tokenAddress\n * @property [tokenAddress] - Address of the token\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface BalanceMap {\n  [tokenAddress: string]: BN;\n}\n\n/**\n * Controller that interacts with contracts on mainnet through web3\n */\nexport class AssetsContractController extends BaseControllerV1<\n  AssetsContractConfig,\n  BaseState\n> {\n  private _provider?: Provider;\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'AssetsContractController';\n\n  private readonly getNetworkClientById: NetworkController['getNetworkClientById'];\n\n  /**\n   * Creates a AssetsContractController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.onNetworkDidChange - Allows subscribing to network controller networkDidChange events.\n   * @param options.getNetworkClientById - Gets the network client with the given id from the NetworkController.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      chainId: initialChainId,\n      onPreferencesStateChange,\n      onNetworkDidChange,\n      getNetworkClientById,\n    }: {\n      chainId: Hex;\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onNetworkDidChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      getNetworkClientById: NetworkController['getNetworkClientById'];\n    },\n    config?: Partial<AssetsContractConfig>,\n    state?: Partial<BaseState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      provider: undefined,\n      ipfsGateway: IPFS_DEFAULT_GATEWAY_URL,\n      chainId: initialChainId,\n    };\n    this.initialize();\n    this.getNetworkClientById = getNetworkClientById;\n\n    onPreferencesStateChange(({ ipfsGateway }) => {\n      this.configure({ ipfsGateway });\n    });\n\n    onNetworkDidChange((networkState) => {\n      if (this.config.chainId !== networkState.providerConfig.chainId) {\n        this.configure({\n          chainId: networkState.providerConfig.chainId,\n        });\n      }\n    });\n  }\n\n  /**\n   * Sets a new provider.\n   *\n   * TODO: Replace this wth a method.\n   *\n   * @property provider - Provider used to create a new underlying Web3 instance\n   */\n  set provider(provider: Provider) {\n    this._provider = provider;\n  }\n\n  get provider() {\n    throw new Error('Property only used for setting');\n  }\n\n  /**\n   * Get the relevant provider instance.\n   *\n   * @param networkClientId - Network Client ID.\n   * @returns Web3Provider instance.\n   */\n  getProvider(networkClientId?: NetworkClientId): Web3Provider {\n    const provider = networkClientId\n      ? this.getNetworkClientById(networkClientId).provider\n      : this._provider;\n\n    if (provider === undefined) {\n      throw new Error(MISSING_PROVIDER_ERROR);\n    }\n\n    // @ts-expect-error TODO: remove this annotation once the `Eip1193Provider` class is released\n    return new Web3Provider(provider);\n  }\n\n  /**\n   * Get the relevant chain ID.\n   *\n   * @param networkClientId - Network Client ID used to get the provider.\n   * @returns Hex chain ID.\n   */\n  getChainId(networkClientId?: NetworkClientId): Hex {\n    return networkClientId\n      ? this.getNetworkClientById(networkClientId).configuration.chainId\n      : this.config.chainId;\n  }\n\n  /**\n   * Get a ERC20Standard instance using the relevant provider instance.\n   *\n   * @param networkClientId - Network Client ID used to get the provider.\n   * @returns ERC20Standard instance.\n   */\n  getERC20Standard(networkClientId?: NetworkClientId): ERC20Standard {\n    const provider = this.getProvider(networkClientId);\n    return new ERC20Standard(provider);\n  }\n\n  /**\n   * Get a ERC721Standard instance using the relevant provider instance.\n   *\n   * @param networkClientId - Network Client ID used to get the provider.\n   * @returns ERC721Standard instance.\n   */\n  getERC721Standard(networkClientId?: NetworkClientId): ERC721Standard {\n    const provider = this.getProvider(networkClientId);\n    return new ERC721Standard(provider);\n  }\n\n  /**\n   * Get a ERC1155Standard instance using the relevant provider instance.\n   *\n   * @param networkClientId - Network Client ID used to get the provider.\n   * @returns ERC1155Standard instance.\n   */\n  getERC1155Standard(networkClientId?: NetworkClientId): ERC1155Standard {\n    const provider = this.getProvider(networkClientId);\n    return new ERC1155Standard(provider);\n  }\n\n  /**\n   * Get balance or count for current account on specific asset contract.\n   *\n   * @param address - Asset ERC20 contract address.\n   * @param selectedAddress - Current account public address.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to BN object containing balance for current account on specific asset contract.\n   */\n  async getERC20BalanceOf(\n    address: string,\n    selectedAddress: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<BN> {\n    const erc20Standard = this.getERC20Standard(networkClientId);\n    return erc20Standard.getBalanceOf(address, selectedAddress);\n  }\n\n  /**\n   * Query for the decimals for a given ERC20 asset.\n   *\n   * @param address - ERC20 asset contract address.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'decimals'.\n   */\n  async getERC20TokenDecimals(\n    address: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc20Standard = this.getERC20Standard(networkClientId);\n    return erc20Standard.getTokenDecimals(address);\n  }\n\n  /**\n   * Query for the name for a given ERC20 asset.\n   *\n   * @param address - ERC20 asset contract address.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'decimals'.\n   */\n  async getERC20TokenName(\n    address: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc20Standard = this.getERC20Standard(networkClientId);\n    return erc20Standard.getTokenName(address);\n  }\n\n  /**\n   * Enumerate assets assigned to an owner.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param selectedAddress - Current account public address.\n   * @param index - An NFT counter less than `balanceOf(selectedAddress)`.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to token identifier for the 'index'th asset assigned to 'selectedAddress'.\n   */\n  getERC721NftTokenId(\n    address: string,\n    selectedAddress: string,\n    index: number,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc721Standard = this.getERC721Standard(networkClientId);\n    return erc721Standard.getNftTokenId(address, selectedAddress, index);\n  }\n\n  /**\n   * Enumerate assets assigned to an owner.\n   *\n   * @param tokenAddress - ERC721 asset contract address.\n   * @param userAddress - Current account public address.\n   * @param tokenId - ERC721 asset identifier.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to an object containing the token standard and a set of details which depend on which standard the token supports.\n   */\n  async getTokenStandardAndDetails(\n    tokenAddress: string,\n    userAddress?: string,\n    tokenId?: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<{\n    standard: string;\n    tokenURI?: string | undefined;\n    symbol?: string | undefined;\n    name?: string | undefined;\n    decimals?: string | undefined;\n    balance?: BN | undefined;\n  }> {\n    // Asserts provider is available\n    this.getProvider(networkClientId);\n\n    const { ipfsGateway } = this.config;\n\n    // ERC721\n    try {\n      const erc721Standard = this.getERC721Standard(networkClientId);\n      return {\n        ...(await erc721Standard.getDetails(\n          tokenAddress,\n          ipfsGateway,\n          tokenId,\n        )),\n      };\n    } catch {\n      // Ignore\n    }\n\n    // ERC1155\n    try {\n      const erc1155Standard = this.getERC1155Standard(networkClientId);\n      return {\n        ...(await erc1155Standard.getDetails(\n          tokenAddress,\n          ipfsGateway,\n          tokenId,\n        )),\n      };\n    } catch {\n      // Ignore\n    }\n\n    // ERC20\n    try {\n      const erc20Standard = this.getERC20Standard(networkClientId);\n      return {\n        ...(await erc20Standard.getDetails(tokenAddress, userAddress)),\n      };\n    } catch {\n      // Ignore\n    }\n\n    throw new Error('Unable to determine contract standard');\n  }\n\n  /**\n   * Query for tokenURI for a given ERC721 asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param tokenId - ERC721 asset identifier.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'tokenURI'.\n   */\n  async getERC721TokenURI(\n    address: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc721Standard = this.getERC721Standard(networkClientId);\n    return erc721Standard.getTokenURI(address, tokenId);\n  }\n\n  /**\n   * Query for name for a given asset.\n   *\n   * @param address - ERC721 or ERC20 asset contract address.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'name'.\n   */\n  async getERC721AssetName(\n    address: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc721Standard = this.getERC721Standard(networkClientId);\n    return erc721Standard.getAssetName(address);\n  }\n\n  /**\n   * Query for symbol for a given asset.\n   *\n   * @param address - ERC721 or ERC20 asset contract address.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'symbol'.\n   */\n  async getERC721AssetSymbol(\n    address: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc721Standard = this.getERC721Standard(networkClientId);\n    return erc721Standard.getAssetSymbol(address);\n  }\n\n  /**\n   * Query for owner for a given ERC721 asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param tokenId - ERC721 asset identifier.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the owner address.\n   */\n  async getERC721OwnerOf(\n    address: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc721Standard = this.getERC721Standard(networkClientId);\n    return erc721Standard.getOwnerOf(address, tokenId);\n  }\n\n  /**\n   * Query for tokenURI for a given asset.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @param tokenId - ERC1155 asset identifier.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'tokenURI'.\n   */\n  async getERC1155TokenURI(\n    address: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc1155Standard = this.getERC1155Standard(networkClientId);\n    return erc1155Standard.getTokenURI(address, tokenId);\n  }\n\n  /**\n   * Query for balance of a given ERC 1155 token.\n   *\n   * @param userAddress - Wallet public address.\n   * @param nftAddress - ERC1155 asset contract address.\n   * @param nftId - ERC1155 asset identifier.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'balanceOf'.\n   */\n  async getERC1155BalanceOf(\n    userAddress: string,\n    nftAddress: string,\n    nftId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<BN> {\n    const erc1155Standard = this.getERC1155Standard(networkClientId);\n    return erc1155Standard.getBalanceOf(nftAddress, userAddress, nftId);\n  }\n\n  /**\n   * Transfer single ERC1155 token.\n   *\n   * @param nftAddress - ERC1155 token address.\n   * @param senderAddress - ERC1155 token sender.\n   * @param recipientAddress - ERC1155 token recipient.\n   * @param nftId - ERC1155 token id.\n   * @param qty - Quantity of tokens to be sent.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'transferSingle' ERC1155 token.\n   */\n  async transferSingleERC1155(\n    nftAddress: string,\n    senderAddress: string,\n    recipientAddress: string,\n    nftId: string,\n    qty: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<void> {\n    const erc1155Standard = this.getERC1155Standard(networkClientId);\n    return erc1155Standard.transferSingle(\n      nftAddress,\n      senderAddress,\n      recipientAddress,\n      nftId,\n      qty,\n    );\n  }\n\n  /**\n   * Get the token balance for a list of token addresses in a single call. Only non-zero balances\n   * are returned.\n   *\n   * @param selectedAddress - The address to check token balances for.\n   * @param tokensToDetect - The token addresses to detect balances for.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns The list of non-zero token balances.\n   */\n  async getBalancesInSingleCall(\n    selectedAddress: string,\n    tokensToDetect: string[],\n    networkClientId?: NetworkClientId,\n  ) {\n    const chainId = this.getChainId(networkClientId);\n    const provider = this.getProvider(networkClientId);\n    if (!(chainId in SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID)) {\n      // Only fetch balance if contract address exists\n      return {};\n    }\n    const contractAddress = SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID[chainId];\n\n    const contract = new Contract(\n      contractAddress,\n      abiSingleCallBalancesContract,\n      provider,\n    );\n    const result = await contract.balances([selectedAddress], tokensToDetect);\n    const nonZeroBalances: BalanceMap = {};\n    /* istanbul ignore else */\n    if (result.length > 0) {\n      tokensToDetect.forEach((tokenAddress, index) => {\n        const balance: BN = result[index];\n        /* istanbul ignore else */\n        if (String(balance) !== '0') {\n          nonZeroBalances[tokenAddress] = balance;\n        }\n      });\n    }\n    return nonZeroBalances;\n  }\n}\n\nexport default AssetsContractController;\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-523YP4Z3.mjs b/node_modules/@metamask/assets-controllers/dist/chunk-523YP4Z3.mjs
new file mode 100644
index 0000000..9e0cc2f
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-523YP4Z3.mjs
@@ -0,0 +1,284 @@
+import {
+  fetchTokenListByChainId
+} from "./chunk-KRTEFV4Q.mjs";
+import {
+  formatAggregatorNames,
+  formatIconUrlWithProxy,
+  isTokenListSupportedForNetwork
+} from "./chunk-E5PIGGYR.mjs";
+import {
+  __privateAdd,
+  __privateMethod
+} from "./chunk-XUI43LEZ.mjs";
+
+// src/TokenListController.ts
+import { safelyExecute } from "@metamask/controller-utils";
+import { StaticIntervalPollingController } from "@metamask/polling-controller";
+import { Mutex } from "async-mutex";
+var DEFAULT_INTERVAL = 24 * 60 * 60 * 1e3;
+var DEFAULT_THRESHOLD = 24 * 60 * 60 * 1e3;
+var name = "TokenListController";
+var metadata = {
+  tokenList: { persist: true, anonymous: true },
+  tokensChainsCache: { persist: true, anonymous: true },
+  preventPollingOnNetworkRestart: { persist: true, anonymous: true }
+};
+var getDefaultTokenListState = () => {
+  return {
+    tokenList: {},
+    tokensChainsCache: {},
+    preventPollingOnNetworkRestart: false
+  };
+};
+var _onNetworkControllerStateChange, onNetworkControllerStateChange_fn, _fetchFromCache, fetchFromCache_fn;
+var TokenListController = class extends StaticIntervalPollingController {
+  /**
+   * Creates a TokenListController instance.
+   *
+   * @param options - The controller options.
+   * @param options.chainId - The chain ID of the current network.
+   * @param options.onNetworkStateChange - A function for registering an event handler for network state changes.
+   * @param options.interval - The polling interval, in milliseconds.
+   * @param options.cacheRefreshThreshold - The token cache expiry time, in milliseconds.
+   * @param options.messenger - A restricted controller messenger.
+   * @param options.state - Initial state to set on this controller.
+   * @param options.preventPollingOnNetworkRestart - Determines whether to prevent poilling on network restart in extension.
+   */
+  constructor({
+    chainId,
+    preventPollingOnNetworkRestart = false,
+    onNetworkStateChange,
+    interval = DEFAULT_INTERVAL,
+    cacheRefreshThreshold = DEFAULT_THRESHOLD,
+    messenger,
+    state
+  }) {
+    super({
+      name,
+      metadata,
+      messenger,
+      state: { ...getDefaultTokenListState(), ...state }
+    });
+    /**
+     * Updates state and restarts polling on changes to the network controller
+     * state.
+     *
+     * @param networkControllerState - The updated network controller state.
+     */
+    __privateAdd(this, _onNetworkControllerStateChange);
+    /**
+     * Checks if the Cache timestamp is valid,
+     * if yes data in cache will be returned
+     * otherwise null will be returned.
+     * @param chainId - The chain ID of the network for which to fetch the cache.
+     * @returns The cached data, or `null` if the cache was expired.
+     */
+    __privateAdd(this, _fetchFromCache);
+    this.mutex = new Mutex();
+    this.intervalDelay = interval;
+    this.cacheRefreshThreshold = cacheRefreshThreshold;
+    this.chainId = chainId;
+    this.updatePreventPollingOnNetworkRestart(preventPollingOnNetworkRestart);
+    this.abortController = new AbortController();
+    if (onNetworkStateChange) {
+      onNetworkStateChange(async (networkControllerState) => {
+        await __privateMethod(this, _onNetworkControllerStateChange, onNetworkControllerStateChange_fn).call(this, networkControllerState);
+      });
+    } else {
+      this.messagingSystem.subscribe(
+        "NetworkController:stateChange",
+        async (networkControllerState) => {
+          await __privateMethod(this, _onNetworkControllerStateChange, onNetworkControllerStateChange_fn).call(this, networkControllerState);
+        }
+      );
+    }
+  }
+  /**
+   * Start polling for the token list.
+   */
+  async start() {
+    if (!isTokenListSupportedForNetwork(this.chainId)) {
+      return;
+    }
+    await this.startPolling();
+  }
+  /**
+   * Restart polling for the token list.
+   */
+  async restart() {
+    this.stopPolling();
+    await this.startPolling();
+  }
+  /**
+   * Stop polling for the token list.
+   */
+  stop() {
+    this.stopPolling();
+  }
+  /**
+   * Prepare to discard this controller.
+   *
+   * This stops any active polling.
+   */
+  destroy() {
+    super.destroy();
+    this.stopPolling();
+  }
+  stopPolling() {
+    if (this.intervalId) {
+      clearInterval(this.intervalId);
+    }
+  }
+  /**
+   * Starts a new polling interval.
+   */
+  async startPolling() {
+    await safelyExecute(() => this.fetchTokenList());
+    this.intervalId = setInterval(async () => {
+      await safelyExecute(() => this.fetchTokenList());
+    }, this.intervalDelay);
+  }
+  /**
+   * Fetching token list from the Token Service API.
+   *
+   * @private
+   * @param networkClientId - The ID of the network client triggering the fetch.
+   * @returns A promise that resolves when this operation completes.
+   */
+  async _executePoll(networkClientId) {
+    return this.fetchTokenList(networkClientId);
+  }
+  /**
+   * Fetching token list from the Token Service API.
+   *
+   * @param networkClientId - The ID of the network client triggering the fetch.
+   */
+  async fetchTokenList(networkClientId) {
+    const releaseLock = await this.mutex.acquire();
+    let networkClient;
+    if (networkClientId) {
+      networkClient = this.messagingSystem.call(
+        "NetworkController:getNetworkClientById",
+        networkClientId
+      );
+    }
+    const chainId = networkClient?.configuration.chainId ?? this.chainId;
+    try {
+      const { tokensChainsCache } = this.state;
+      let tokenList = {};
+      const cachedTokens = await safelyExecute(
+        () => __privateMethod(this, _fetchFromCache, fetchFromCache_fn).call(this, chainId)
+      );
+      if (cachedTokens) {
+        tokenList = { ...cachedTokens };
+      } else {
+        const tokensFromAPI = await safelyExecute(
+          () => fetchTokenListByChainId(
+            chainId,
+            this.abortController.signal
+          )
+        );
+        if (!tokensFromAPI) {
+          tokenList = { ...tokensChainsCache[chainId]?.data || {} };
+          this.update(() => {
+            return {
+              ...this.state,
+              tokenList,
+              tokensChainsCache
+            };
+          });
+          return;
+        }
+        for (const token of tokensFromAPI) {
+          const formattedToken = {
+            ...token,
+            aggregators: formatAggregatorNames(token.aggregators),
+            iconUrl: formatIconUrlWithProxy({
+              chainId,
+              tokenAddress: token.address
+            })
+          };
+          tokenList[token.address] = formattedToken;
+        }
+      }
+      const updatedTokensChainsCache = {
+        ...tokensChainsCache,
+        [chainId]: {
+          timestamp: Date.now(),
+          data: tokenList
+        }
+      };
+      this.update(() => {
+        return {
+          ...this.state,
+          tokenList,
+          tokensChainsCache: updatedTokensChainsCache
+        };
+      });
+    } finally {
+      releaseLock();
+    }
+  }
+  /**
+   * Clearing tokenList and tokensChainsCache explicitly.
+   */
+  clearingTokenListData() {
+    this.update(() => {
+      return {
+        ...this.state,
+        tokenList: {},
+        tokensChainsCache: {}
+      };
+    });
+  }
+  /**
+   * Updates preventPollingOnNetworkRestart from extension.
+   *
+   * @param shouldPreventPolling - Determine whether to prevent polling on network change
+   */
+  updatePreventPollingOnNetworkRestart(shouldPreventPolling) {
+    this.update(() => {
+      return {
+        ...this.state,
+        preventPollingOnNetworkRestart: shouldPreventPolling
+      };
+    });
+  }
+};
+_onNetworkControllerStateChange = new WeakSet();
+onNetworkControllerStateChange_fn = async function(networkControllerState) {
+  if (this.chainId !== networkControllerState.providerConfig.chainId) {
+    this.abortController.abort();
+    this.abortController = new AbortController();
+    this.chainId = networkControllerState.providerConfig.chainId;
+    if (this.state.preventPollingOnNetworkRestart) {
+      this.clearingTokenListData();
+    } else {
+      this.update(() => {
+        return {
+          ...this.state,
+          tokenList: this.state.tokensChainsCache[this.chainId]?.data || {}
+        };
+      });
+      await this.restart();
+    }
+  }
+};
+_fetchFromCache = new WeakSet();
+fetchFromCache_fn = async function(chainId) {
+  const { tokensChainsCache } = this.state;
+  const dataCache = tokensChainsCache[chainId];
+  const now = Date.now();
+  if (dataCache?.data && now - dataCache?.timestamp < this.cacheRefreshThreshold) {
+    return dataCache.data;
+  }
+  return null;
+};
+var TokenListController_default = TokenListController;
+
+export {
+  getDefaultTokenListState,
+  TokenListController,
+  TokenListController_default
+};
+//# sourceMappingURL=chunk-523YP4Z3.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-523YP4Z3.mjs.map b/node_modules/@metamask/assets-controllers/dist/chunk-523YP4Z3.mjs.map
new file mode 100644
index 0000000..a05d2fc
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-523YP4Z3.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/TokenListController.ts"],"sourcesContent":["import type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport { safelyExecute } from '@metamask/controller-utils';\nimport type {\n  NetworkClientId,\n  NetworkControllerStateChangeEvent,\n  NetworkState,\n  NetworkControllerGetNetworkClientByIdAction,\n} from '@metamask/network-controller';\nimport { StaticIntervalPollingController } from '@metamask/polling-controller';\nimport type { Hex } from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\n\nimport {\n  isTokenListSupportedForNetwork,\n  formatAggregatorNames,\n  formatIconUrlWithProxy,\n} from './assetsUtil';\nimport { fetchTokenListByChainId } from './token-service';\n\nconst DEFAULT_INTERVAL = 24 * 60 * 60 * 1000;\nconst DEFAULT_THRESHOLD = 24 * 60 * 60 * 1000;\n\nconst name = 'TokenListController';\n\nexport type TokenListToken = {\n  name: string;\n  symbol: string;\n  decimals: number;\n  address: string;\n  occurrences: number;\n  aggregators: string[];\n  iconUrl: string;\n};\n\nexport type TokenListMap = Record<string, TokenListToken>;\n\ntype DataCache = {\n  timestamp: number;\n  data: TokenListMap;\n};\ntype TokensChainsCache = {\n  [chainId: Hex]: DataCache;\n};\n\nexport type TokenListState = {\n  tokenList: TokenListMap;\n  tokensChainsCache: TokensChainsCache;\n  preventPollingOnNetworkRestart: boolean;\n};\n\nexport type TokenListStateChange = ControllerStateChangeEvent<\n  typeof name,\n  TokenListState\n>;\n\nexport type TokenListControllerEvents = TokenListStateChange;\n\nexport type GetTokenListState = ControllerGetStateAction<\n  typeof name,\n  TokenListState\n>;\n\nexport type TokenListControllerActions = GetTokenListState;\n\ntype AllowedActions = NetworkControllerGetNetworkClientByIdAction;\n\ntype AllowedEvents = NetworkControllerStateChangeEvent;\n\nexport type TokenListControllerMessenger = RestrictedControllerMessenger<\n  typeof name,\n  TokenListControllerActions | AllowedActions,\n  TokenListControllerEvents | AllowedEvents,\n  AllowedActions['type'],\n  AllowedEvents['type']\n>;\n\nconst metadata = {\n  tokenList: { persist: true, anonymous: true },\n  tokensChainsCache: { persist: true, anonymous: true },\n  preventPollingOnNetworkRestart: { persist: true, anonymous: true },\n};\n\nexport const getDefaultTokenListState = (): TokenListState => {\n  return {\n    tokenList: {},\n    tokensChainsCache: {},\n    preventPollingOnNetworkRestart: false,\n  };\n};\n\n/**\n * Controller that passively polls on a set interval for the list of tokens from metaswaps api\n */\nexport class TokenListController extends StaticIntervalPollingController<\n  typeof name,\n  TokenListState,\n  TokenListControllerMessenger\n> {\n  private readonly mutex = new Mutex();\n\n  private intervalId?: ReturnType<typeof setTimeout>;\n\n  private readonly intervalDelay: number;\n\n  private readonly cacheRefreshThreshold: number;\n\n  private chainId: Hex;\n\n  private abortController: AbortController;\n\n  /**\n   * Creates a TokenListController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.onNetworkStateChange - A function for registering an event handler for network state changes.\n   * @param options.interval - The polling interval, in milliseconds.\n   * @param options.cacheRefreshThreshold - The token cache expiry time, in milliseconds.\n   * @param options.messenger - A restricted controller messenger.\n   * @param options.state - Initial state to set on this controller.\n   * @param options.preventPollingOnNetworkRestart - Determines whether to prevent poilling on network restart in extension.\n   */\n  constructor({\n    chainId,\n    preventPollingOnNetworkRestart = false,\n    onNetworkStateChange,\n    interval = DEFAULT_INTERVAL,\n    cacheRefreshThreshold = DEFAULT_THRESHOLD,\n    messenger,\n    state,\n  }: {\n    chainId: Hex;\n    preventPollingOnNetworkRestart?: boolean;\n    onNetworkStateChange?: (\n      listener: (networkState: NetworkState) => void,\n    ) => void;\n    interval?: number;\n    cacheRefreshThreshold?: number;\n    messenger: TokenListControllerMessenger;\n    state?: Partial<TokenListState>;\n  }) {\n    super({\n      name,\n      metadata,\n      messenger,\n      state: { ...getDefaultTokenListState(), ...state },\n    });\n    this.intervalDelay = interval;\n    this.cacheRefreshThreshold = cacheRefreshThreshold;\n    this.chainId = chainId;\n    this.updatePreventPollingOnNetworkRestart(preventPollingOnNetworkRestart);\n    this.abortController = new AbortController();\n    if (onNetworkStateChange) {\n      onNetworkStateChange(async (networkControllerState) => {\n        await this.#onNetworkControllerStateChange(networkControllerState);\n      });\n    } else {\n      this.messagingSystem.subscribe(\n        'NetworkController:stateChange',\n        async (networkControllerState) => {\n          await this.#onNetworkControllerStateChange(networkControllerState);\n        },\n      );\n    }\n  }\n\n  /**\n   * Updates state and restarts polling on changes to the network controller\n   * state.\n   *\n   * @param networkControllerState - The updated network controller state.\n   */\n  async #onNetworkControllerStateChange(networkControllerState: NetworkState) {\n    if (this.chainId !== networkControllerState.providerConfig.chainId) {\n      this.abortController.abort();\n      this.abortController = new AbortController();\n      this.chainId = networkControllerState.providerConfig.chainId;\n      if (this.state.preventPollingOnNetworkRestart) {\n        this.clearingTokenListData();\n      } else {\n        // Ensure tokenList is referencing data from correct network\n        this.update(() => {\n          return {\n            ...this.state,\n            tokenList: this.state.tokensChainsCache[this.chainId]?.data || {},\n          };\n        });\n        await this.restart();\n      }\n    }\n  }\n\n  /**\n   * Start polling for the token list.\n   */\n  async start() {\n    if (!isTokenListSupportedForNetwork(this.chainId)) {\n      return;\n    }\n    await this.startPolling();\n  }\n\n  /**\n   * Restart polling for the token list.\n   */\n  async restart() {\n    this.stopPolling();\n    await this.startPolling();\n  }\n\n  /**\n   * Stop polling for the token list.\n   */\n  stop() {\n    this.stopPolling();\n  }\n\n  /**\n   * Prepare to discard this controller.\n   *\n   * This stops any active polling.\n   */\n  override destroy() {\n    super.destroy();\n    this.stopPolling();\n  }\n\n  private stopPolling() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n  }\n\n  /**\n   * Starts a new polling interval.\n   */\n  private async startPolling(): Promise<void> {\n    await safelyExecute(() => this.fetchTokenList());\n    this.intervalId = setInterval(async () => {\n      await safelyExecute(() => this.fetchTokenList());\n    }, this.intervalDelay);\n  }\n\n  /**\n   * Fetching token list from the Token Service API.\n   *\n   * @private\n   * @param networkClientId - The ID of the network client triggering the fetch.\n   * @returns A promise that resolves when this operation completes.\n   */\n  async _executePoll(networkClientId: string): Promise<void> {\n    return this.fetchTokenList(networkClientId);\n  }\n\n  /**\n   * Fetching token list from the Token Service API.\n   *\n   * @param networkClientId - The ID of the network client triggering the fetch.\n   */\n  async fetchTokenList(networkClientId?: NetworkClientId): Promise<void> {\n    const releaseLock = await this.mutex.acquire();\n    let networkClient;\n    if (networkClientId) {\n      networkClient = this.messagingSystem.call(\n        'NetworkController:getNetworkClientById',\n        networkClientId,\n      );\n    }\n    const chainId = networkClient?.configuration.chainId ?? this.chainId;\n    try {\n      const { tokensChainsCache } = this.state;\n      let tokenList: TokenListMap = {};\n      const cachedTokens = await safelyExecute(() =>\n        this.#fetchFromCache(chainId),\n      );\n      if (cachedTokens) {\n        // Use non-expired cached tokens\n        tokenList = { ...cachedTokens };\n      } else {\n        // Fetch fresh token list\n        const tokensFromAPI = await safelyExecute(\n          () =>\n            fetchTokenListByChainId(\n              chainId,\n              this.abortController.signal,\n            ) as Promise<TokenListToken[]>,\n        );\n\n        if (!tokensFromAPI) {\n          // Fallback to expired cached tokens\n          tokenList = { ...(tokensChainsCache[chainId]?.data || {}) };\n          this.update(() => {\n            return {\n              ...this.state,\n              tokenList,\n              tokensChainsCache,\n            };\n          });\n          return;\n        }\n        for (const token of tokensFromAPI) {\n          const formattedToken: TokenListToken = {\n            ...token,\n            aggregators: formatAggregatorNames(token.aggregators),\n            iconUrl: formatIconUrlWithProxy({\n              chainId,\n              tokenAddress: token.address,\n            }),\n          };\n          tokenList[token.address] = formattedToken;\n        }\n      }\n      const updatedTokensChainsCache: TokensChainsCache = {\n        ...tokensChainsCache,\n        [chainId]: {\n          timestamp: Date.now(),\n          data: tokenList,\n        },\n      };\n      this.update(() => {\n        return {\n          ...this.state,\n          tokenList,\n          tokensChainsCache: updatedTokensChainsCache,\n        };\n      });\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Checks if the Cache timestamp is valid,\n   * if yes data in cache will be returned\n   * otherwise null will be returned.\n   * @param chainId - The chain ID of the network for which to fetch the cache.\n   * @returns The cached data, or `null` if the cache was expired.\n   */\n  async #fetchFromCache(chainId: Hex): Promise<TokenListMap | null> {\n    const { tokensChainsCache }: TokenListState = this.state;\n    const dataCache = tokensChainsCache[chainId];\n    const now = Date.now();\n    if (\n      dataCache?.data &&\n      now - dataCache?.timestamp < this.cacheRefreshThreshold\n    ) {\n      return dataCache.data;\n    }\n    return null;\n  }\n\n  /**\n   * Clearing tokenList and tokensChainsCache explicitly.\n   */\n  clearingTokenListData(): void {\n    this.update(() => {\n      return {\n        ...this.state,\n        tokenList: {},\n        tokensChainsCache: {},\n      };\n    });\n  }\n\n  /**\n   * Updates preventPollingOnNetworkRestart from extension.\n   *\n   * @param shouldPreventPolling - Determine whether to prevent polling on network change\n   */\n  updatePreventPollingOnNetworkRestart(shouldPreventPolling: boolean): void {\n    this.update(() => {\n      return {\n        ...this.state,\n        preventPollingOnNetworkRestart: shouldPreventPolling,\n      };\n    });\n  }\n}\n\nexport default TokenListController;\n"],"mappings":"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","names":[]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-6NO7Z5DL.js b/node_modules/@metamask/assets-controllers/dist/chunk-6NO7Z5DL.js
new file mode 100644
index 0000000..b33cb59
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-6NO7Z5DL.js
@@ -0,0 +1,178 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});
+
+var _chunkRELRWIJNjs = require('./chunk-RELRWIJN.js');
+
+// src/Standards/NftStandards/ERC721/ERC721Standard.ts
+var _contracts = require('@ethersproject/contracts');
+
+
+
+
+
+
+
+var _controllerutils = require('@metamask/controller-utils');
+var _metamaskethabis = require('@metamask/metamask-eth-abis');
+var ERC721Standard = class {
+  constructor(provider) {
+    /**
+     * Query if contract implements ERC721Metadata interface.
+     *
+     * @param address - ERC721 asset contract address.
+     * @returns Promise resolving to whether the contract implements ERC721Metadata interface.
+     */
+    this.contractSupportsMetadataInterface = async (address) => {
+      return this.contractSupportsInterface(
+        address,
+        _controllerutils.ERC721_METADATA_INTERFACE_ID
+      );
+    };
+    /**
+     * Query if contract implements ERC721Enumerable interface.
+     *
+     * @param address - ERC721 asset contract address.
+     * @returns Promise resolving to whether the contract implements ERC721Enumerable interface.
+     */
+    this.contractSupportsEnumerableInterface = async (address) => {
+      return this.contractSupportsInterface(
+        address,
+        _controllerutils.ERC721_ENUMERABLE_INTERFACE_ID
+      );
+    };
+    /**
+     * Query if contract implements ERC721 interface.
+     *
+     * @param address - ERC721 asset contract address.
+     * @returns Promise resolving to whether the contract implements ERC721 interface.
+     */
+    this.contractSupportsBase721Interface = async (address) => {
+      return this.contractSupportsInterface(address, _controllerutils.ERC721_INTERFACE_ID);
+    };
+    /**
+     * Enumerate assets assigned to an owner.
+     *
+     * @param address - ERC721 asset contract address.
+     * @param selectedAddress - Current account public address.
+     * @param index - An NFT counter less than `balanceOf(selectedAddress)`.
+     * @returns Promise resolving to token identifier for the 'index'th asset assigned to 'selectedAddress'.
+     */
+    this.getNftTokenId = async (address, selectedAddress, index) => {
+      const contract = new (0, _contracts.Contract)(address, _metamaskethabis.abiERC721, this.provider);
+      return contract.tokenOfOwnerByIndex(selectedAddress, index);
+    };
+    /**
+     * Query for tokenURI for a given asset.
+     *
+     * @param address - ERC721 asset contract address.
+     * @param tokenId - ERC721 asset identifier.
+     * @returns Promise resolving to the 'tokenURI'.
+     */
+    this.getTokenURI = async (address, tokenId) => {
+      const contract = new (0, _contracts.Contract)(address, _metamaskethabis.abiERC721, this.provider);
+      const supportsMetadata = await this.contractSupportsMetadataInterface(
+        address
+      );
+      if (!supportsMetadata) {
+        throw new Error("Contract does not support ERC721 metadata interface.");
+      }
+      return contract.tokenURI(tokenId);
+    };
+    /**
+     * Query for name for a given asset.
+     *
+     * @param address - ERC721 asset contract address.
+     * @returns Promise resolving to the 'name'.
+     */
+    this.getAssetName = async (address) => {
+      const contract = new (0, _contracts.Contract)(address, _metamaskethabis.abiERC721, this.provider);
+      return contract.name();
+    };
+    /**
+     * Query for symbol for a given asset.
+     *
+     * @param address - ERC721 asset contract address.
+     * @returns Promise resolving to the 'symbol'.
+     */
+    this.getAssetSymbol = async (address) => {
+      const contract = new (0, _contracts.Contract)(address, _metamaskethabis.abiERC721, this.provider);
+      return contract.symbol();
+    };
+    /**
+     * Query if a contract implements an interface.
+     *
+     * @param address - Asset contract address.
+     * @param interfaceId - Interface identifier.
+     * @returns Promise resolving to whether the contract implements `interfaceID`.
+     */
+    this.contractSupportsInterface = async (address, interfaceId) => {
+      const contract = new (0, _contracts.Contract)(address, _metamaskethabis.abiERC721, this.provider);
+      try {
+        return await contract.supportsInterface(interfaceId);
+      } catch (err) {
+        if (err instanceof Error && err.message.includes("call revert exception")) {
+          return false;
+        }
+        throw err;
+      }
+    };
+    /**
+     * Query if a contract implements an interface.
+     *
+     * @param address - Asset contract address.
+     * @param ipfsGateway - The user's preferred IPFS gateway.
+     * @param tokenId - tokenId of a given token in the contract.
+     * @returns Promise resolving an object containing the standard, tokenURI, symbol and name of the given contract/tokenId pair.
+     */
+    this.getDetails = async (address, ipfsGateway, tokenId) => {
+      const isERC721 = await this.contractSupportsBase721Interface(address);
+      if (!isERC721) {
+        throw new Error("This isn't a valid ERC721 contract");
+      }
+      const [symbol, name, tokenURI] = await Promise.all([
+        _controllerutils.safelyExecute.call(void 0, () => this.getAssetSymbol(address)),
+        _controllerutils.safelyExecute.call(void 0, () => this.getAssetName(address)),
+        tokenId ? _controllerutils.safelyExecute.call(void 0, 
+          () => this.getTokenURI(address, tokenId).then(
+            (uri) => uri.startsWith("ipfs://") ? _chunkRELRWIJNjs.getFormattedIpfsUrl.call(void 0, ipfsGateway, uri, true) : uri
+          )
+        ) : void 0
+      ]);
+      let image;
+      if (tokenURI) {
+        try {
+          const response = await _controllerutils.timeoutFetch.call(void 0, tokenURI);
+          const object = await response.json();
+          image = object?.image;
+          if (image?.startsWith("ipfs://")) {
+            image = _chunkRELRWIJNjs.getFormattedIpfsUrl.call(void 0, ipfsGateway, image, true);
+          }
+        } catch {
+        }
+      }
+      return {
+        standard: _controllerutils.ERC721,
+        tokenURI,
+        symbol,
+        name,
+        image
+      };
+    };
+    this.provider = provider;
+  }
+  /**
+   * Query for owner for a given ERC721 asset.
+   *
+   * @param address - ERC721 asset contract address.
+   * @param tokenId - ERC721 asset identifier.
+   * @returns Promise resolving to the owner address.
+   */
+  async getOwnerOf(address, tokenId) {
+    const contract = new (0, _contracts.Contract)(address, _metamaskethabis.abiERC721, this.provider);
+    return contract.ownerOf(tokenId);
+  }
+};
+
+
+
+exports.ERC721Standard = ERC721Standard;
+//# sourceMappingURL=chunk-6NO7Z5DL.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-6NO7Z5DL.js.map b/node_modules/@metamask/assets-controllers/dist/chunk-6NO7Z5DL.js.map
new file mode 100644
index 0000000..2fc4014
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-6NO7Z5DL.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/Standards/NftStandards/ERC721/ERC721Standard.ts"],"names":[],"mappings":"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","sourcesContent":["import { Contract } from '@ethersproject/contracts';\nimport type { Web3Provider } from '@ethersproject/providers';\nimport {\n  timeoutFetch,\n  ERC721_INTERFACE_ID,\n  ERC721_METADATA_INTERFACE_ID,\n  ERC721_ENUMERABLE_INTERFACE_ID,\n  ERC721,\n  safelyExecute,\n} from '@metamask/controller-utils';\nimport { abiERC721 } from '@metamask/metamask-eth-abis';\n\nimport { getFormattedIpfsUrl } from '../../../assetsUtil';\n\nexport class ERC721Standard {\n  private readonly provider: Web3Provider;\n\n  constructor(provider: Web3Provider) {\n    this.provider = provider;\n  }\n\n  /**\n   * Query if contract implements ERC721Metadata interface.\n   *\n   * @param address - ERC721 asset contract address.\n   * @returns Promise resolving to whether the contract implements ERC721Metadata interface.\n   */\n  contractSupportsMetadataInterface = async (\n    address: string,\n  ): Promise<boolean> => {\n    return this.contractSupportsInterface(\n      address,\n      ERC721_METADATA_INTERFACE_ID,\n    );\n  };\n\n  /**\n   * Query if contract implements ERC721Enumerable interface.\n   *\n   * @param address - ERC721 asset contract address.\n   * @returns Promise resolving to whether the contract implements ERC721Enumerable interface.\n   */\n  contractSupportsEnumerableInterface = async (\n    address: string,\n  ): Promise<boolean> => {\n    return this.contractSupportsInterface(\n      address,\n      ERC721_ENUMERABLE_INTERFACE_ID,\n    );\n  };\n\n  /**\n   * Query if contract implements ERC721 interface.\n   *\n   * @param address - ERC721 asset contract address.\n   * @returns Promise resolving to whether the contract implements ERC721 interface.\n   */\n  contractSupportsBase721Interface = async (\n    address: string,\n  ): Promise<boolean> => {\n    return this.contractSupportsInterface(address, ERC721_INTERFACE_ID);\n  };\n\n  /**\n   * Enumerate assets assigned to an owner.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param selectedAddress - Current account public address.\n   * @param index - An NFT counter less than `balanceOf(selectedAddress)`.\n   * @returns Promise resolving to token identifier for the 'index'th asset assigned to 'selectedAddress'.\n   */\n  getNftTokenId = async (\n    address: string,\n    selectedAddress: string,\n    index: number,\n  ): Promise<string> => {\n    const contract = new Contract(address, abiERC721, this.provider);\n    return contract.tokenOfOwnerByIndex(selectedAddress, index);\n  };\n\n  /**\n   * Query for tokenURI for a given asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param tokenId - ERC721 asset identifier.\n   * @returns Promise resolving to the 'tokenURI'.\n   */\n  getTokenURI = async (address: string, tokenId: string): Promise<string> => {\n    const contract = new Contract(address, abiERC721, this.provider);\n    const supportsMetadata = await this.contractSupportsMetadataInterface(\n      address,\n    );\n    if (!supportsMetadata) {\n      throw new Error('Contract does not support ERC721 metadata interface.');\n    }\n    return contract.tokenURI(tokenId);\n  };\n\n  /**\n   * Query for name for a given asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @returns Promise resolving to the 'name'.\n   */\n  getAssetName = async (address: string): Promise<string> => {\n    const contract = new Contract(address, abiERC721, this.provider);\n    return contract.name();\n  };\n\n  /**\n   * Query for symbol for a given asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @returns Promise resolving to the 'symbol'.\n   */\n  getAssetSymbol = async (address: string): Promise<string> => {\n    const contract = new Contract(address, abiERC721, this.provider);\n    return contract.symbol();\n  };\n\n  /**\n   * Query for owner for a given ERC721 asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param tokenId - ERC721 asset identifier.\n   * @returns Promise resolving to the owner address.\n   */\n  async getOwnerOf(address: string, tokenId: string): Promise<string> {\n    const contract = new Contract(address, abiERC721, this.provider);\n    return contract.ownerOf(tokenId);\n  }\n\n  /**\n   * Query if a contract implements an interface.\n   *\n   * @param address - Asset contract address.\n   * @param interfaceId - Interface identifier.\n   * @returns Promise resolving to whether the contract implements `interfaceID`.\n   */\n  private readonly contractSupportsInterface = async (\n    address: string,\n    interfaceId: string,\n  ): Promise<boolean> => {\n    const contract = new Contract(address, abiERC721, this.provider);\n    try {\n      return await contract.supportsInterface(interfaceId);\n    } catch (err) {\n      // Mirror previous implementation\n      if (\n        err instanceof Error &&\n        err.message.includes('call revert exception')\n      ) {\n        return false;\n      }\n      throw err;\n    }\n  };\n\n  /**\n   * Query if a contract implements an interface.\n   *\n   * @param address - Asset contract address.\n   * @param ipfsGateway - The user's preferred IPFS gateway.\n   * @param tokenId - tokenId of a given token in the contract.\n   * @returns Promise resolving an object containing the standard, tokenURI, symbol and name of the given contract/tokenId pair.\n   */\n  getDetails = async (\n    address: string,\n    ipfsGateway: string,\n    tokenId?: string,\n  ): Promise<{\n    standard: string;\n    tokenURI: string | undefined;\n    symbol: string | undefined;\n    name: string | undefined;\n    image: string | undefined;\n  }> => {\n    const isERC721 = await this.contractSupportsBase721Interface(address);\n    if (!isERC721) {\n      throw new Error(\"This isn't a valid ERC721 contract\");\n    }\n\n    const [symbol, name, tokenURI] = await Promise.all([\n      safelyExecute(() => this.getAssetSymbol(address)),\n      safelyExecute(() => this.getAssetName(address)),\n      tokenId\n        ? safelyExecute(() =>\n            this.getTokenURI(address, tokenId).then((uri) =>\n              uri.startsWith('ipfs://')\n                ? getFormattedIpfsUrl(ipfsGateway, uri, true)\n                : uri,\n            ),\n          )\n        : undefined,\n    ]);\n\n    let image;\n    if (tokenURI) {\n      try {\n        const response = await timeoutFetch(tokenURI);\n        const object = await response.json();\n        image = object?.image;\n        if (image?.startsWith('ipfs://')) {\n          image = getFormattedIpfsUrl(ipfsGateway, image, true);\n        }\n      } catch {\n        // ignore\n      }\n    }\n\n    return {\n      standard: ERC721,\n      tokenURI,\n      symbol,\n      name,\n      image,\n    };\n  };\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-76KGJJJV.mjs b/node_modules/@metamask/assets-controllers/dist/chunk-76KGJJJV.mjs
new file mode 100644
index 0000000..846c9d7
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-76KGJJJV.mjs
@@ -0,0 +1,704 @@
+import {
+  ERC1155Standard
+} from "./chunk-CEENXWOB.mjs";
+import {
+  ERC20Standard
+} from "./chunk-MQ7TIWBK.mjs";
+import {
+  TOKEN_METADATA_NO_SUPPORT_ERROR,
+  fetchTokenMetadata
+} from "./chunk-KRTEFV4Q.mjs";
+import {
+  formatAggregatorNames,
+  formatIconUrlWithProxy
+} from "./chunk-E5PIGGYR.mjs";
+
+// src/TokensController.ts
+import { Contract } from "@ethersproject/contracts";
+import { Web3Provider } from "@ethersproject/providers";
+import { BaseControllerV1 } from "@metamask/base-controller";
+import contractsMap from "@metamask/contract-metadata";
+import {
+  toChecksumHexAddress,
+  ERC721_INTERFACE_ID,
+  ORIGIN_METAMASK,
+  ApprovalType,
+  ERC20,
+  ERC721,
+  ERC1155,
+  isValidHexAddress,
+  safelyExecute
+} from "@metamask/controller-utils";
+import { abiERC721 } from "@metamask/metamask-eth-abis";
+import { rpcErrors } from "@metamask/rpc-errors";
+import { Mutex } from "async-mutex";
+import { EventEmitter } from "events";
+import { v1 as random } from "uuid";
+var controllerName = "TokensController";
+var getDefaultTokensState = () => {
+  return {
+    tokens: [],
+    ignoredTokens: [],
+    detectedTokens: [],
+    allTokens: {},
+    allIgnoredTokens: {},
+    allDetectedTokens: {}
+  };
+};
+var TokensController = class extends BaseControllerV1 {
+  /**
+   * Creates a TokensController instance.
+   *
+   * @param options - The controller options.
+   * @param options.chainId - The chain ID of the current network.
+   * @param options.config - Initial options used to configure this controller.
+   * @param options.state - Initial state to set on this controller.
+   * @param options.messenger - The controller messenger.
+   */
+  constructor({
+    chainId: initialChainId,
+    config,
+    state,
+    messenger
+  }) {
+    super(config, state);
+    this.mutex = new Mutex();
+    /**
+     * EventEmitter instance used to listen to specific EIP747 events
+     */
+    this.hub = new EventEmitter();
+    /**
+     * Name of this controller used during composition
+     */
+    this.name = "TokensController";
+    this.defaultConfig = {
+      selectedAddress: "",
+      chainId: initialChainId,
+      provider: void 0,
+      ...config
+    };
+    this.defaultState = {
+      ...getDefaultTokensState(),
+      ...state
+    };
+    this.initialize();
+    this.abortController = new AbortController();
+    this.messagingSystem = messenger;
+    this.messagingSystem.registerActionHandler(
+      `${controllerName}:addDetectedTokens`,
+      this.addDetectedTokens.bind(this)
+    );
+    this.messagingSystem.subscribe(
+      "PreferencesController:stateChange",
+      ({ selectedAddress }) => {
+        const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
+        const { chainId } = this.config;
+        this.configure({ selectedAddress });
+        this.update({
+          tokens: allTokens[chainId]?.[selectedAddress] ?? [],
+          ignoredTokens: allIgnoredTokens[chainId]?.[selectedAddress] ?? [],
+          detectedTokens: allDetectedTokens[chainId]?.[selectedAddress] ?? []
+        });
+      }
+    );
+    this.messagingSystem.subscribe(
+      "NetworkController:networkDidChange",
+      ({ providerConfig }) => {
+        const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
+        const { selectedAddress } = this.config;
+        const { chainId } = providerConfig;
+        this.abortController.abort();
+        this.abortController = new AbortController();
+        this.configure({ chainId });
+        this.update({
+          tokens: allTokens[chainId]?.[selectedAddress] || [],
+          ignoredTokens: allIgnoredTokens[chainId]?.[selectedAddress] || [],
+          detectedTokens: allDetectedTokens[chainId]?.[selectedAddress] || []
+        });
+      }
+    );
+    this.messagingSystem.subscribe(
+      "TokenListController:stateChange",
+      ({ tokenList }) => {
+        const { tokens } = this.state;
+        if (tokens.length && !tokens[0].name) {
+          this.updateTokensAttribute(tokenList, "name");
+        }
+      }
+    );
+  }
+  /**
+   * Fetch metadata for a token.
+   *
+   * @param tokenAddress - The address of the token.
+   * @returns The token metadata.
+   */
+  async fetchTokenMetadata(tokenAddress) {
+    try {
+      const token = await fetchTokenMetadata(
+        this.config.chainId,
+        tokenAddress,
+        this.abortController.signal
+      );
+      return token;
+    } catch (error) {
+      if (error instanceof Error && error.message.includes(TOKEN_METADATA_NO_SUPPORT_ERROR)) {
+        return void 0;
+      }
+      throw error;
+    }
+  }
+  /**
+   * Adds a token to the stored token list.
+   *
+   * @param options - The method argument object.
+   * @param options.address - Hex address of the token contract.
+   * @param options.symbol - Symbol of the token.
+   * @param options.decimals - Number of decimals the token uses.
+   * @param options.name - Name of the token.
+   * @param options.image - Image of the token.
+   * @param options.interactingAddress - The address of the account to add a token to.
+   * @param options.networkClientId - Network Client ID.
+   * @returns Current token list.
+   */
+  async addToken({
+    address,
+    symbol,
+    decimals,
+    name,
+    image,
+    interactingAddress,
+    networkClientId
+  }) {
+    const { chainId, selectedAddress } = this.config;
+    const releaseLock = await this.mutex.acquire();
+    const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
+    let currentChainId = chainId;
+    if (networkClientId) {
+      currentChainId = this.messagingSystem.call(
+        "NetworkController:getNetworkClientById",
+        networkClientId
+      ).configuration.chainId;
+    }
+    const accountAddress = interactingAddress || selectedAddress;
+    const isInteractingWithWalletAccount = accountAddress === selectedAddress;
+    try {
+      address = toChecksumHexAddress(address);
+      const tokens = allTokens[currentChainId]?.[accountAddress] || [];
+      const ignoredTokens = allIgnoredTokens[currentChainId]?.[accountAddress] || [];
+      const detectedTokens = allDetectedTokens[currentChainId]?.[accountAddress] || [];
+      const newTokens = [...tokens];
+      const [isERC721, tokenMetadata] = await Promise.all([
+        this._detectIsERC721(address, networkClientId),
+        // TODO parameterize the token metadata fetch by networkClientId
+        this.fetchTokenMetadata(address)
+      ]);
+      if (!networkClientId && currentChainId !== this.config.chainId) {
+        throw new Error(
+          "TokensController Error: Switched networks while adding token"
+        );
+      }
+      const newEntry = {
+        address,
+        symbol,
+        decimals,
+        image: image || formatIconUrlWithProxy({
+          chainId: currentChainId,
+          tokenAddress: address
+        }),
+        isERC721,
+        aggregators: formatAggregatorNames(tokenMetadata?.aggregators || []),
+        name
+      };
+      const previousIndex = newTokens.findIndex(
+        (token) => token.address.toLowerCase() === address.toLowerCase()
+      );
+      if (previousIndex !== -1) {
+        newTokens[previousIndex] = newEntry;
+      } else {
+        newTokens.push(newEntry);
+      }
+      const newIgnoredTokens = ignoredTokens.filter(
+        (tokenAddress) => tokenAddress.toLowerCase() !== address.toLowerCase()
+      );
+      const newDetectedTokens = detectedTokens.filter(
+        (token) => token.address.toLowerCase() !== address.toLowerCase()
+      );
+      const { newAllTokens, newAllIgnoredTokens, newAllDetectedTokens } = this._getNewAllTokensState({
+        newTokens,
+        newIgnoredTokens,
+        newDetectedTokens,
+        interactingAddress: accountAddress,
+        interactingChainId: currentChainId
+      });
+      let newState = {
+        allTokens: newAllTokens,
+        allIgnoredTokens: newAllIgnoredTokens,
+        allDetectedTokens: newAllDetectedTokens
+      };
+      if (isInteractingWithWalletAccount) {
+        newState = {
+          ...newState,
+          tokens: newTokens,
+          ignoredTokens: newIgnoredTokens,
+          detectedTokens: newDetectedTokens
+        };
+      }
+      this.update(newState);
+      return newTokens;
+    } finally {
+      releaseLock();
+    }
+  }
+  /**
+   * Add a batch of tokens.
+   *
+   * @param tokensToImport - Array of tokens to import.
+   * @param networkClientId - Optional network client ID used to determine interacting chain ID.
+   */
+  async addTokens(tokensToImport, networkClientId) {
+    const releaseLock = await this.mutex.acquire();
+    const { tokens, detectedTokens, ignoredTokens } = this.state;
+    const importedTokensMap = {};
+    const newTokensMap = tokens.reduce((output, current) => {
+      output[current.address] = current;
+      return output;
+    }, {});
+    try {
+      tokensToImport.forEach((tokenToAdd) => {
+        const { address, symbol, decimals, image, aggregators, name } = tokenToAdd;
+        const checksumAddress = toChecksumHexAddress(address);
+        const formattedToken = {
+          address: checksumAddress,
+          symbol,
+          decimals,
+          image,
+          aggregators,
+          name
+        };
+        newTokensMap[address] = formattedToken;
+        importedTokensMap[address.toLowerCase()] = true;
+        return formattedToken;
+      });
+      const newTokens = Object.values(newTokensMap);
+      const newDetectedTokens = detectedTokens.filter(
+        (token) => !importedTokensMap[token.address.toLowerCase()]
+      );
+      const newIgnoredTokens = ignoredTokens.filter(
+        (tokenAddress) => !newTokensMap[tokenAddress.toLowerCase()]
+      );
+      let interactingChainId;
+      if (networkClientId) {
+        interactingChainId = this.messagingSystem.call(
+          "NetworkController:getNetworkClientById",
+          networkClientId
+        ).configuration.chainId;
+      }
+      const { newAllTokens, newAllDetectedTokens, newAllIgnoredTokens } = this._getNewAllTokensState({
+        newTokens,
+        newDetectedTokens,
+        newIgnoredTokens,
+        interactingChainId
+      });
+      this.update({
+        tokens: newTokens,
+        allTokens: newAllTokens,
+        detectedTokens: newDetectedTokens,
+        allDetectedTokens: newAllDetectedTokens,
+        ignoredTokens: newIgnoredTokens,
+        allIgnoredTokens: newAllIgnoredTokens
+      });
+    } finally {
+      releaseLock();
+    }
+  }
+  /**
+   * Ignore a batch of tokens.
+   *
+   * @param tokenAddressesToIgnore - Array of token addresses to ignore.
+   */
+  ignoreTokens(tokenAddressesToIgnore) {
+    const { ignoredTokens, detectedTokens, tokens } = this.state;
+    const ignoredTokensMap = {};
+    let newIgnoredTokens = [...ignoredTokens];
+    const checksummedTokenAddresses = tokenAddressesToIgnore.map((address) => {
+      const checksumAddress = toChecksumHexAddress(address);
+      ignoredTokensMap[address.toLowerCase()] = true;
+      return checksumAddress;
+    });
+    newIgnoredTokens = [...ignoredTokens, ...checksummedTokenAddresses];
+    const newDetectedTokens = detectedTokens.filter(
+      (token) => !ignoredTokensMap[token.address.toLowerCase()]
+    );
+    const newTokens = tokens.filter(
+      (token) => !ignoredTokensMap[token.address.toLowerCase()]
+    );
+    const { newAllIgnoredTokens, newAllDetectedTokens, newAllTokens } = this._getNewAllTokensState({
+      newIgnoredTokens,
+      newDetectedTokens,
+      newTokens
+    });
+    this.update({
+      ignoredTokens: newIgnoredTokens,
+      tokens: newTokens,
+      detectedTokens: newDetectedTokens,
+      allIgnoredTokens: newAllIgnoredTokens,
+      allDetectedTokens: newAllDetectedTokens,
+      allTokens: newAllTokens
+    });
+  }
+  /**
+   * Adds a batch of detected tokens to the stored token list.
+   *
+   * @param incomingDetectedTokens - Array of detected tokens to be added or updated.
+   * @param detectionDetails - An object containing the chain ID and address of the currently selected network on which the incomingDetectedTokens were detected.
+   * @param detectionDetails.selectedAddress - the account address on which the incomingDetectedTokens were detected.
+   * @param detectionDetails.chainId - the chainId on which the incomingDetectedTokens were detected.
+   */
+  async addDetectedTokens(incomingDetectedTokens, detectionDetails) {
+    const releaseLock = await this.mutex.acquire();
+    const chainId = detectionDetails?.chainId ?? this.config.chainId;
+    const accountAddress = detectionDetails?.selectedAddress ?? this.config.selectedAddress;
+    const { allTokens, allDetectedTokens, allIgnoredTokens } = this.state;
+    let newTokens = [...allTokens?.[chainId]?.[accountAddress] ?? []];
+    let newDetectedTokens = [
+      ...allDetectedTokens?.[chainId]?.[accountAddress] ?? []
+    ];
+    try {
+      incomingDetectedTokens.forEach((tokenToAdd) => {
+        const {
+          address,
+          symbol,
+          decimals,
+          image,
+          aggregators,
+          isERC721,
+          name
+        } = tokenToAdd;
+        const checksumAddress = toChecksumHexAddress(address);
+        const newEntry = {
+          address: checksumAddress,
+          symbol,
+          decimals,
+          image,
+          isERC721,
+          aggregators,
+          name
+        };
+        const previousImportedIndex = newTokens.findIndex(
+          (token) => token.address.toLowerCase() === checksumAddress.toLowerCase()
+        );
+        if (previousImportedIndex !== -1) {
+          newTokens[previousImportedIndex] = newEntry;
+        } else {
+          const ignoredTokenIndex = allIgnoredTokens?.[chainId]?.[accountAddress]?.indexOf(address) ?? -1;
+          if (ignoredTokenIndex === -1) {
+            const previousDetectedIndex = newDetectedTokens.findIndex(
+              (token) => token.address.toLowerCase() === checksumAddress.toLowerCase()
+            );
+            if (previousDetectedIndex !== -1) {
+              newDetectedTokens[previousDetectedIndex] = newEntry;
+            } else {
+              newDetectedTokens.push(newEntry);
+            }
+          }
+        }
+      });
+      const { newAllTokens, newAllDetectedTokens } = this._getNewAllTokensState(
+        {
+          newTokens,
+          newDetectedTokens,
+          interactingAddress: accountAddress,
+          interactingChainId: chainId
+        }
+      );
+      const { chainId: currentChain, selectedAddress: currentAddress } = this.config;
+      newTokens = newAllTokens?.[currentChain]?.[currentAddress] || [];
+      newDetectedTokens = newAllDetectedTokens?.[currentChain]?.[currentAddress] || [];
+      this.update({
+        tokens: newTokens,
+        allTokens: newAllTokens,
+        detectedTokens: newDetectedTokens,
+        allDetectedTokens: newAllDetectedTokens
+      });
+    } finally {
+      releaseLock();
+    }
+  }
+  /**
+   * Adds isERC721 field to token object. This is called when a user attempts to add tokens that
+   * were previously added which do not yet had isERC721 field.
+   *
+   * @param tokenAddress - The contract address of the token requiring the isERC721 field added.
+   * @returns The new token object with the added isERC721 field.
+   */
+  async updateTokenType(tokenAddress) {
+    const isERC721 = await this._detectIsERC721(tokenAddress);
+    const { tokens } = this.state;
+    const tokenIndex = tokens.findIndex((token) => {
+      return token.address.toLowerCase() === tokenAddress.toLowerCase();
+    });
+    tokens[tokenIndex].isERC721 = isERC721;
+    this.update({ tokens });
+    return tokens[tokenIndex];
+  }
+  /**
+   * This is a function that updates the tokens name for the tokens name if it is not defined.
+   *
+   * @param tokenList - Represents the fetched token list from service API
+   * @param tokenAttribute - Represents the token attribute that we want to update on the token list
+   */
+  updateTokensAttribute(tokenList, tokenAttribute) {
+    const { tokens } = this.state;
+    const newTokens = tokens.map((token) => {
+      const newToken = tokenList[token.address.toLowerCase()];
+      return !token[tokenAttribute] && newToken?.[tokenAttribute] ? { ...token, [tokenAttribute]: newToken[tokenAttribute] } : { ...token };
+    });
+    this.update({ tokens: newTokens });
+  }
+  /**
+   * Detects whether or not a token is ERC-721 compatible.
+   *
+   * @param tokenAddress - The token contract address.
+   * @param networkClientId - Optional network client ID to fetch contract info with.
+   * @returns A boolean indicating whether the token address passed in supports the EIP-721
+   * interface.
+   */
+  async _detectIsERC721(tokenAddress, networkClientId) {
+    const checksumAddress = toChecksumHexAddress(tokenAddress);
+    if (contractsMap[checksumAddress]?.erc721 === true) {
+      return Promise.resolve(true);
+    } else if (contractsMap[checksumAddress]?.erc20 === true) {
+      return Promise.resolve(false);
+    }
+    const tokenContract = this._createEthersContract(
+      tokenAddress,
+      abiERC721,
+      networkClientId
+    );
+    try {
+      return await tokenContract.supportsInterface(ERC721_INTERFACE_ID);
+    } catch (error) {
+      return false;
+    }
+  }
+  _getProvider(networkClientId) {
+    return new Web3Provider(
+      // @ts-expect-error TODO: remove this annotation once the `Eip1193Provider` class is released
+      networkClientId ? this.messagingSystem.call(
+        "NetworkController:getNetworkClientById",
+        networkClientId
+      ).provider : this.config.provider
+    );
+  }
+  _createEthersContract(tokenAddress, abi, networkClientId) {
+    const web3provider = this._getProvider(networkClientId);
+    const tokenContract = new Contract(tokenAddress, abi, web3provider);
+    return tokenContract;
+  }
+  _generateRandomId() {
+    return random();
+  }
+  /**
+   * Adds a new suggestedAsset to the list of watched assets.
+   * Parameters will be validated according to the asset type being watched.
+   *
+   * @param options - The method options.
+   * @param options.asset - The asset to be watched. For now only ERC20 tokens are accepted.
+   * @param options.type - The asset type.
+   * @param options.interactingAddress - The address of the account that is requesting to watch the asset.
+   * @param options.networkClientId - Network Client ID.
+   * @returns A promise that resolves if the asset was watched successfully, and rejects otherwise.
+   */
+  async watchAsset({
+    asset,
+    type,
+    interactingAddress,
+    networkClientId
+  }) {
+    if (type !== ERC20) {
+      throw new Error(`Asset of type ${type} not supported`);
+    }
+    if (!asset.address) {
+      throw rpcErrors.invalidParams("Address must be specified");
+    }
+    if (!isValidHexAddress(asset.address)) {
+      throw rpcErrors.invalidParams(`Invalid address "${asset.address}"`);
+    }
+    if (await this._detectIsERC721(asset.address, networkClientId)) {
+      throw rpcErrors.invalidParams(
+        `Contract ${asset.address} must match type ${type}, but was detected as ${ERC721}`
+      );
+    }
+    const provider = this._getProvider(networkClientId);
+    const isErc1155 = await safelyExecute(
+      () => new ERC1155Standard(provider).contractSupportsBase1155Interface(
+        asset.address
+      )
+    );
+    if (isErc1155) {
+      throw rpcErrors.invalidParams(
+        `Contract ${asset.address} must match type ${type}, but was detected as ${ERC1155}`
+      );
+    }
+    const erc20 = new ERC20Standard(provider);
+    const [contractName, contractSymbol, contractDecimals] = await Promise.all([
+      safelyExecute(() => erc20.getTokenName(asset.address)),
+      safelyExecute(() => erc20.getTokenSymbol(asset.address)),
+      safelyExecute(async () => erc20.getTokenDecimals(asset.address))
+    ]);
+    asset.name = contractName;
+    if (!asset.symbol && !contractSymbol) {
+      throw rpcErrors.invalidParams(
+        "A symbol is required, but was not found in either the request or contract"
+      );
+    }
+    if (contractSymbol !== void 0 && asset.symbol !== void 0 && asset.symbol.toUpperCase() !== contractSymbol.toUpperCase()) {
+      throw rpcErrors.invalidParams(
+        `The symbol in the request (${asset.symbol}) does not match the symbol in the contract (${contractSymbol})`
+      );
+    }
+    asset.symbol = contractSymbol ?? asset.symbol;
+    if (typeof asset.symbol !== "string") {
+      throw rpcErrors.invalidParams(`Invalid symbol: not a string`);
+    }
+    if (asset.symbol.length > 11) {
+      throw rpcErrors.invalidParams(
+        `Invalid symbol "${asset.symbol}": longer than 11 characters`
+      );
+    }
+    if (asset.decimals === void 0 && contractDecimals === void 0) {
+      throw rpcErrors.invalidParams(
+        "Decimals are required, but were not found in either the request or contract"
+      );
+    }
+    if (contractDecimals !== void 0 && asset.decimals !== void 0 && String(asset.decimals) !== contractDecimals) {
+      throw rpcErrors.invalidParams(
+        `The decimals in the request (${asset.decimals}) do not match the decimals in the contract (${contractDecimals})`
+      );
+    }
+    const decimalsStr = contractDecimals ?? asset.decimals;
+    const decimalsNum = parseInt(decimalsStr, 10);
+    if (!Number.isInteger(decimalsNum) || decimalsNum > 36 || decimalsNum < 0) {
+      throw rpcErrors.invalidParams(
+        `Invalid decimals "${decimalsStr}": must be an integer 0 <= 36`
+      );
+    }
+    asset.decimals = decimalsNum;
+    const suggestedAssetMeta = {
+      asset,
+      id: this._generateRandomId(),
+      time: Date.now(),
+      type,
+      interactingAddress: interactingAddress || this.config.selectedAddress
+    };
+    await this._requestApproval(suggestedAssetMeta);
+    const { address, symbol, decimals, name, image } = asset;
+    await this.addToken({
+      address,
+      symbol,
+      decimals,
+      name,
+      image,
+      interactingAddress: suggestedAssetMeta.interactingAddress,
+      networkClientId
+    });
+  }
+  /**
+   * Takes a new tokens and ignoredTokens array for the current network/account combination
+   * and returns new allTokens and allIgnoredTokens state to update to.
+   *
+   * @param params - Object that holds token params.
+   * @param params.newTokens - The new tokens to set for the current network and selected account.
+   * @param params.newIgnoredTokens - The new ignored tokens to set for the current network and selected account.
+   * @param params.newDetectedTokens - The new detected tokens to set for the current network and selected account.
+   * @param params.interactingAddress - The account address to use to store the tokens.
+   * @param params.interactingChainId - The chainId to use to store the tokens.
+   * @returns The updated `allTokens` and `allIgnoredTokens` state.
+   */
+  _getNewAllTokensState(params) {
+    const {
+      newTokens,
+      newIgnoredTokens,
+      newDetectedTokens,
+      interactingAddress,
+      interactingChainId
+    } = params;
+    const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
+    const { chainId, selectedAddress } = this.config;
+    const userAddressToAddTokens = interactingAddress ?? selectedAddress;
+    const chainIdToAddTokens = interactingChainId ?? chainId;
+    let newAllTokens = allTokens;
+    if (newTokens?.length || newTokens && allTokens && allTokens[chainIdToAddTokens] && allTokens[chainIdToAddTokens][userAddressToAddTokens]) {
+      const networkTokens = allTokens[chainIdToAddTokens];
+      const newNetworkTokens = {
+        ...networkTokens,
+        ...{ [userAddressToAddTokens]: newTokens }
+      };
+      newAllTokens = {
+        ...allTokens,
+        ...{ [chainIdToAddTokens]: newNetworkTokens }
+      };
+    }
+    let newAllIgnoredTokens = allIgnoredTokens;
+    if (newIgnoredTokens?.length || newIgnoredTokens && allIgnoredTokens && allIgnoredTokens[chainIdToAddTokens] && allIgnoredTokens[chainIdToAddTokens][userAddressToAddTokens]) {
+      const networkIgnoredTokens = allIgnoredTokens[chainIdToAddTokens];
+      const newIgnoredNetworkTokens = {
+        ...networkIgnoredTokens,
+        ...{ [userAddressToAddTokens]: newIgnoredTokens }
+      };
+      newAllIgnoredTokens = {
+        ...allIgnoredTokens,
+        ...{ [chainIdToAddTokens]: newIgnoredNetworkTokens }
+      };
+    }
+    let newAllDetectedTokens = allDetectedTokens;
+    if (newDetectedTokens?.length || newDetectedTokens && allDetectedTokens && allDetectedTokens[chainIdToAddTokens] && allDetectedTokens[chainIdToAddTokens][userAddressToAddTokens]) {
+      const networkDetectedTokens = allDetectedTokens[chainIdToAddTokens];
+      const newDetectedNetworkTokens = {
+        ...networkDetectedTokens,
+        ...{ [userAddressToAddTokens]: newDetectedTokens }
+      };
+      newAllDetectedTokens = {
+        ...allDetectedTokens,
+        ...{ [chainIdToAddTokens]: newDetectedNetworkTokens }
+      };
+    }
+    return { newAllTokens, newAllIgnoredTokens, newAllDetectedTokens };
+  }
+  /**
+   * Removes all tokens from the ignored list.
+   */
+  clearIgnoredTokens() {
+    this.update({ ignoredTokens: [], allIgnoredTokens: {} });
+  }
+  async _requestApproval(suggestedAssetMeta) {
+    return this.messagingSystem.call(
+      "ApprovalController:addRequest",
+      {
+        id: suggestedAssetMeta.id,
+        origin: ORIGIN_METAMASK,
+        type: ApprovalType.WatchAsset,
+        requestData: {
+          id: suggestedAssetMeta.id,
+          interactingAddress: suggestedAssetMeta.interactingAddress,
+          asset: {
+            address: suggestedAssetMeta.asset.address,
+            decimals: suggestedAssetMeta.asset.decimals,
+            symbol: suggestedAssetMeta.asset.symbol,
+            image: suggestedAssetMeta.asset.image || null
+          }
+        }
+      },
+      true
+    );
+  }
+};
+var TokensController_default = TokensController;
+
+export {
+  getDefaultTokensState,
+  TokensController,
+  TokensController_default
+};
+//# sourceMappingURL=chunk-76KGJJJV.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-76KGJJJV.mjs.map b/node_modules/@metamask/assets-controllers/dist/chunk-76KGJJJV.mjs.map
new file mode 100644
index 0000000..2efffe9
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-76KGJJJV.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/TokensController.ts"],"sourcesContent":["import { Contract } from '@ethersproject/contracts';\nimport { Web3Provider } from '@ethersproject/providers';\nimport type { AddApprovalRequest } from '@metamask/approval-controller';\nimport type {\n  BaseConfig,\n  BaseState,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport { BaseControllerV1 } from '@metamask/base-controller';\nimport contractsMap from '@metamask/contract-metadata';\nimport {\n  toChecksumHexAddress,\n  ERC721_INTERFACE_ID,\n  ORIGIN_METAMASK,\n  ApprovalType,\n  ERC20,\n  ERC721,\n  ERC1155,\n  isValidHexAddress,\n  safelyExecute,\n} from '@metamask/controller-utils';\nimport { abiERC721 } from '@metamask/metamask-eth-abis';\nimport type {\n  NetworkClientId,\n  NetworkControllerGetNetworkClientByIdAction,\n  NetworkControllerNetworkDidChangeEvent,\n  Provider,\n} from '@metamask/network-controller';\nimport type { PreferencesControllerStateChangeEvent } from '@metamask/preferences-controller';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type { Hex } from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\nimport { EventEmitter } from 'events';\nimport type { Patch } from 'immer/dist/immer';\nimport { v1 as random } from 'uuid';\n\nimport { formatAggregatorNames, formatIconUrlWithProxy } from './assetsUtil';\nimport { ERC20Standard } from './Standards/ERC20Standard';\nimport { ERC1155Standard } from './Standards/NftStandards/ERC1155/ERC1155Standard';\nimport {\n  fetchTokenMetadata,\n  TOKEN_METADATA_NO_SUPPORT_ERROR,\n} from './token-service';\nimport type {\n  TokenListMap,\n  TokenListStateChange,\n  TokenListToken,\n} from './TokenListController';\nimport type { Token } from './TokenRatesController';\n\n/**\n * @type TokensConfig\n *\n * Tokens controller configuration\n * @property selectedAddress - Vault selected address\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface TokensConfig extends BaseConfig {\n  selectedAddress: string;\n  chainId: Hex;\n  provider: Provider | undefined;\n}\n\n/**\n * @type SuggestedAssetMeta\n *\n * Suggested asset by EIP747 meta data\n * @property id - Generated UUID associated with this suggested asset\n * @property time - Timestamp associated with this this suggested asset\n * @property type - Type type this suggested asset\n * @property asset - Asset suggested object\n * @property interactingAddress - Account address that requested watch asset\n */\ntype SuggestedAssetMeta = {\n  id: string;\n  time: number;\n  type: string;\n  asset: Token;\n  interactingAddress: string;\n};\n\n/**\n * @type TokensState\n *\n * Assets controller state\n * @property tokens - List of tokens associated with the active network and address pair\n * @property ignoredTokens - List of ignoredTokens associated with the active network and address pair\n * @property detectedTokens - List of detected tokens associated with the active network and address pair\n * @property allTokens - Object containing tokens by network and account\n * @property allIgnoredTokens - Object containing hidden/ignored tokens by network and account\n * @property allDetectedTokens - Object containing tokens detected with non-zero balances\n */\nexport type TokensState = {\n  tokens: Token[];\n  ignoredTokens: string[];\n  detectedTokens: Token[];\n  allTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n  allIgnoredTokens: { [chainId: Hex]: { [key: string]: string[] } };\n  allDetectedTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n};\n\n/**\n * The name of the {@link TokensController}.\n */\nconst controllerName = 'TokensController';\n\nexport type TokensControllerActions =\n  | TokensControllerGetStateAction\n  | TokensControllerAddDetectedTokensAction;\n\n// TODO: Once `TokensController` is upgraded to V2, rewrite this type using the `ControllerGetStateAction` type, which constrains `TokensState` as `Record<string, Json>`.\nexport type TokensControllerGetStateAction = {\n  type: `${typeof controllerName}:getState`;\n  handler: () => TokensState;\n};\n\nexport type TokensControllerAddDetectedTokensAction = {\n  type: `${typeof controllerName}:addDetectedTokens`;\n  handler: TokensController['addDetectedTokens'];\n};\n\n/**\n * The external actions available to the {@link TokensController}.\n */\nexport type AllowedActions =\n  | AddApprovalRequest\n  | NetworkControllerGetNetworkClientByIdAction;\n\n// TODO: Once `TokensController` is upgraded to V2, rewrite this type using the `ControllerStateChangeEvent` type, which constrains `TokensState` as `Record<string, Json>`.\nexport type TokensControllerStateChangeEvent = {\n  type: `${typeof controllerName}:stateChange`;\n  payload: [TokensState, Patch[]];\n};\n\nexport type TokensControllerEvents = TokensControllerStateChangeEvent;\n\nexport type AllowedEvents =\n  | NetworkControllerNetworkDidChangeEvent\n  | PreferencesControllerStateChangeEvent\n  | TokenListStateChange;\n\n/**\n * The messenger of the {@link TokensController}.\n */\nexport type TokensControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  TokensControllerActions | AllowedActions,\n  TokensControllerEvents | AllowedEvents,\n  AllowedActions['type'],\n  AllowedEvents['type']\n>;\n\nexport const getDefaultTokensState = (): TokensState => {\n  return {\n    tokens: [],\n    ignoredTokens: [],\n    detectedTokens: [],\n    allTokens: {},\n    allIgnoredTokens: {},\n    allDetectedTokens: {},\n  };\n};\n\n/**\n * Controller that stores assets and exposes convenience methods\n */\nexport class TokensController extends BaseControllerV1<\n  TokensConfig,\n  TokensState & BaseState\n> {\n  private readonly mutex = new Mutex();\n\n  private abortController: AbortController;\n\n  private readonly messagingSystem: TokensControllerMessenger;\n\n  /**\n   * Fetch metadata for a token.\n   *\n   * @param tokenAddress - The address of the token.\n   * @returns The token metadata.\n   */\n  private async fetchTokenMetadata(\n    tokenAddress: string,\n  ): Promise<TokenListToken | undefined> {\n    try {\n      const token = await fetchTokenMetadata<TokenListToken>(\n        this.config.chainId,\n        tokenAddress,\n        this.abortController.signal,\n      );\n      return token;\n    } catch (error) {\n      if (\n        error instanceof Error &&\n        error.message.includes(TOKEN_METADATA_NO_SUPPORT_ERROR)\n      ) {\n        return undefined;\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * EventEmitter instance used to listen to specific EIP747 events\n   */\n  hub = new EventEmitter();\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'TokensController';\n\n  /**\n   * Creates a TokensController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.config - Initial options used to configure this controller.\n   * @param options.state - Initial state to set on this controller.\n   * @param options.messenger - The controller messenger.\n   */\n  constructor({\n    chainId: initialChainId,\n    config,\n    state,\n    messenger,\n  }: {\n    chainId: Hex;\n    config?: Partial<TokensConfig>;\n    state?: Partial<TokensState>;\n    messenger: TokensControllerMessenger;\n  }) {\n    super(config, state);\n\n    this.defaultConfig = {\n      selectedAddress: '',\n      chainId: initialChainId,\n      provider: undefined,\n      ...config,\n    };\n\n    this.defaultState = {\n      ...getDefaultTokensState(),\n      ...state,\n    };\n\n    this.initialize();\n    this.abortController = new AbortController();\n\n    this.messagingSystem = messenger;\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:addDetectedTokens` as const,\n      this.addDetectedTokens.bind(this),\n    );\n\n    this.messagingSystem.subscribe(\n      'PreferencesController:stateChange',\n      ({ selectedAddress }) => {\n        const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n        const { chainId } = this.config;\n        this.configure({ selectedAddress });\n        this.update({\n          tokens: allTokens[chainId]?.[selectedAddress] ?? [],\n          ignoredTokens: allIgnoredTokens[chainId]?.[selectedAddress] ?? [],\n          detectedTokens: allDetectedTokens[chainId]?.[selectedAddress] ?? [],\n        });\n      },\n    );\n\n    this.messagingSystem.subscribe(\n      'NetworkController:networkDidChange',\n      ({ providerConfig }) => {\n        const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n        const { selectedAddress } = this.config;\n        const { chainId } = providerConfig;\n        this.abortController.abort();\n        this.abortController = new AbortController();\n        this.configure({ chainId });\n        this.update({\n          tokens: allTokens[chainId]?.[selectedAddress] || [],\n          ignoredTokens: allIgnoredTokens[chainId]?.[selectedAddress] || [],\n          detectedTokens: allDetectedTokens[chainId]?.[selectedAddress] || [],\n        });\n      },\n    );\n\n    this.messagingSystem.subscribe(\n      'TokenListController:stateChange',\n      ({ tokenList }) => {\n        const { tokens } = this.state;\n        if (tokens.length && !tokens[0].name) {\n          this.updateTokensAttribute(tokenList, 'name');\n        }\n      },\n    );\n  }\n\n  /**\n   * Adds a token to the stored token list.\n   *\n   * @param options - The method argument object.\n   * @param options.address - Hex address of the token contract.\n   * @param options.symbol - Symbol of the token.\n   * @param options.decimals - Number of decimals the token uses.\n   * @param options.name - Name of the token.\n   * @param options.image - Image of the token.\n   * @param options.interactingAddress - The address of the account to add a token to.\n   * @param options.networkClientId - Network Client ID.\n   * @returns Current token list.\n   */\n  async addToken({\n    address,\n    symbol,\n    decimals,\n    name,\n    image,\n    interactingAddress,\n    networkClientId,\n  }: {\n    address: string;\n    symbol: string;\n    decimals: number;\n    name?: string;\n    image?: string;\n    interactingAddress?: string;\n    networkClientId?: NetworkClientId;\n  }): Promise<Token[]> {\n    const { chainId, selectedAddress } = this.config;\n    const releaseLock = await this.mutex.acquire();\n    const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n    let currentChainId = chainId;\n    if (networkClientId) {\n      currentChainId = this.messagingSystem.call(\n        'NetworkController:getNetworkClientById',\n        networkClientId,\n      ).configuration.chainId;\n    }\n\n    const accountAddress = interactingAddress || selectedAddress;\n    const isInteractingWithWalletAccount = accountAddress === selectedAddress;\n\n    try {\n      address = toChecksumHexAddress(address);\n      const tokens = allTokens[currentChainId]?.[accountAddress] || [];\n      const ignoredTokens =\n        allIgnoredTokens[currentChainId]?.[accountAddress] || [];\n      const detectedTokens =\n        allDetectedTokens[currentChainId]?.[accountAddress] || [];\n      const newTokens: Token[] = [...tokens];\n      const [isERC721, tokenMetadata] = await Promise.all([\n        this._detectIsERC721(address, networkClientId),\n        // TODO parameterize the token metadata fetch by networkClientId\n        this.fetchTokenMetadata(address),\n      ]);\n      // TODO remove this once this method is fully parameterized by networkClientId\n      if (!networkClientId && currentChainId !== this.config.chainId) {\n        throw new Error(\n          'TokensController Error: Switched networks while adding token',\n        );\n      }\n      const newEntry: Token = {\n        address,\n        symbol,\n        decimals,\n        image:\n          image ||\n          formatIconUrlWithProxy({\n            chainId: currentChainId,\n            tokenAddress: address,\n          }),\n        isERC721,\n        aggregators: formatAggregatorNames(tokenMetadata?.aggregators || []),\n        name,\n      };\n      const previousIndex = newTokens.findIndex(\n        (token) => token.address.toLowerCase() === address.toLowerCase(),\n      );\n      if (previousIndex !== -1) {\n        newTokens[previousIndex] = newEntry;\n      } else {\n        newTokens.push(newEntry);\n      }\n\n      const newIgnoredTokens = ignoredTokens.filter(\n        (tokenAddress) => tokenAddress.toLowerCase() !== address.toLowerCase(),\n      );\n      const newDetectedTokens = detectedTokens.filter(\n        (token) => token.address.toLowerCase() !== address.toLowerCase(),\n      );\n\n      const { newAllTokens, newAllIgnoredTokens, newAllDetectedTokens } =\n        this._getNewAllTokensState({\n          newTokens,\n          newIgnoredTokens,\n          newDetectedTokens,\n          interactingAddress: accountAddress,\n          interactingChainId: currentChainId,\n        });\n\n      let newState: Partial<TokensState> = {\n        allTokens: newAllTokens,\n        allIgnoredTokens: newAllIgnoredTokens,\n        allDetectedTokens: newAllDetectedTokens,\n      };\n\n      // Only update active tokens if user is interacting with their active wallet account.\n      if (isInteractingWithWalletAccount) {\n        newState = {\n          ...newState,\n          tokens: newTokens,\n          ignoredTokens: newIgnoredTokens,\n          detectedTokens: newDetectedTokens,\n        };\n      }\n\n      this.update(newState);\n      return newTokens;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Add a batch of tokens.\n   *\n   * @param tokensToImport - Array of tokens to import.\n   * @param networkClientId - Optional network client ID used to determine interacting chain ID.\n   */\n  async addTokens(tokensToImport: Token[], networkClientId?: NetworkClientId) {\n    const releaseLock = await this.mutex.acquire();\n    const { tokens, detectedTokens, ignoredTokens } = this.state;\n    const importedTokensMap: { [key: string]: true } = {};\n    // Used later to dedupe imported tokens\n    const newTokensMap = tokens.reduce((output, current) => {\n      output[current.address] = current;\n      return output;\n    }, {} as { [address: string]: Token });\n    try {\n      tokensToImport.forEach((tokenToAdd) => {\n        const { address, symbol, decimals, image, aggregators, name } =\n          tokenToAdd;\n        const checksumAddress = toChecksumHexAddress(address);\n        const formattedToken: Token = {\n          address: checksumAddress,\n          symbol,\n          decimals,\n          image,\n          aggregators,\n          name,\n        };\n        newTokensMap[address] = formattedToken;\n        importedTokensMap[address.toLowerCase()] = true;\n        return formattedToken;\n      });\n      const newTokens = Object.values(newTokensMap);\n\n      const newDetectedTokens = detectedTokens.filter(\n        (token) => !importedTokensMap[token.address.toLowerCase()],\n      );\n      const newIgnoredTokens = ignoredTokens.filter(\n        (tokenAddress) => !newTokensMap[tokenAddress.toLowerCase()],\n      );\n\n      let interactingChainId;\n      if (networkClientId) {\n        interactingChainId = this.messagingSystem.call(\n          'NetworkController:getNetworkClientById',\n          networkClientId,\n        ).configuration.chainId;\n      }\n\n      const { newAllTokens, newAllDetectedTokens, newAllIgnoredTokens } =\n        this._getNewAllTokensState({\n          newTokens,\n          newDetectedTokens,\n          newIgnoredTokens,\n          interactingChainId,\n        });\n\n      this.update({\n        tokens: newTokens,\n        allTokens: newAllTokens,\n        detectedTokens: newDetectedTokens,\n        allDetectedTokens: newAllDetectedTokens,\n        ignoredTokens: newIgnoredTokens,\n        allIgnoredTokens: newAllIgnoredTokens,\n      });\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Ignore a batch of tokens.\n   *\n   * @param tokenAddressesToIgnore - Array of token addresses to ignore.\n   */\n  ignoreTokens(tokenAddressesToIgnore: string[]) {\n    const { ignoredTokens, detectedTokens, tokens } = this.state;\n    const ignoredTokensMap: { [key: string]: true } = {};\n    let newIgnoredTokens: string[] = [...ignoredTokens];\n\n    const checksummedTokenAddresses = tokenAddressesToIgnore.map((address) => {\n      const checksumAddress = toChecksumHexAddress(address);\n      ignoredTokensMap[address.toLowerCase()] = true;\n      return checksumAddress;\n    });\n    newIgnoredTokens = [...ignoredTokens, ...checksummedTokenAddresses];\n    const newDetectedTokens = detectedTokens.filter(\n      (token) => !ignoredTokensMap[token.address.toLowerCase()],\n    );\n    const newTokens = tokens.filter(\n      (token) => !ignoredTokensMap[token.address.toLowerCase()],\n    );\n\n    const { newAllIgnoredTokens, newAllDetectedTokens, newAllTokens } =\n      this._getNewAllTokensState({\n        newIgnoredTokens,\n        newDetectedTokens,\n        newTokens,\n      });\n\n    this.update({\n      ignoredTokens: newIgnoredTokens,\n      tokens: newTokens,\n      detectedTokens: newDetectedTokens,\n      allIgnoredTokens: newAllIgnoredTokens,\n      allDetectedTokens: newAllDetectedTokens,\n      allTokens: newAllTokens,\n    });\n  }\n\n  /**\n   * Adds a batch of detected tokens to the stored token list.\n   *\n   * @param incomingDetectedTokens - Array of detected tokens to be added or updated.\n   * @param detectionDetails - An object containing the chain ID and address of the currently selected network on which the incomingDetectedTokens were detected.\n   * @param detectionDetails.selectedAddress - the account address on which the incomingDetectedTokens were detected.\n   * @param detectionDetails.chainId - the chainId on which the incomingDetectedTokens were detected.\n   */\n  async addDetectedTokens(\n    incomingDetectedTokens: Token[],\n    detectionDetails?: { selectedAddress: string; chainId: Hex },\n  ) {\n    const releaseLock = await this.mutex.acquire();\n\n    // Get existing tokens for the chain + account\n    const chainId = detectionDetails?.chainId ?? this.config.chainId;\n    const accountAddress =\n      detectionDetails?.selectedAddress ?? this.config.selectedAddress;\n\n    const { allTokens, allDetectedTokens, allIgnoredTokens } = this.state;\n    let newTokens = [...(allTokens?.[chainId]?.[accountAddress] ?? [])];\n    let newDetectedTokens = [\n      ...(allDetectedTokens?.[chainId]?.[accountAddress] ?? []),\n    ];\n\n    try {\n      incomingDetectedTokens.forEach((tokenToAdd) => {\n        const {\n          address,\n          symbol,\n          decimals,\n          image,\n          aggregators,\n          isERC721,\n          name,\n        } = tokenToAdd;\n        const checksumAddress = toChecksumHexAddress(address);\n        const newEntry: Token = {\n          address: checksumAddress,\n          symbol,\n          decimals,\n          image,\n          isERC721,\n          aggregators,\n          name,\n        };\n        const previousImportedIndex = newTokens.findIndex(\n          (token) =>\n            token.address.toLowerCase() === checksumAddress.toLowerCase(),\n        );\n        if (previousImportedIndex !== -1) {\n          // Update existing data of imported token\n          newTokens[previousImportedIndex] = newEntry;\n        } else {\n          const ignoredTokenIndex =\n            allIgnoredTokens?.[chainId]?.[accountAddress]?.indexOf(address) ??\n            -1;\n\n          if (ignoredTokenIndex === -1) {\n            // Add detected token\n            const previousDetectedIndex = newDetectedTokens.findIndex(\n              (token) =>\n                token.address.toLowerCase() === checksumAddress.toLowerCase(),\n            );\n            if (previousDetectedIndex !== -1) {\n              newDetectedTokens[previousDetectedIndex] = newEntry;\n            } else {\n              newDetectedTokens.push(newEntry);\n            }\n          }\n        }\n      });\n\n      const { newAllTokens, newAllDetectedTokens } = this._getNewAllTokensState(\n        {\n          newTokens,\n          newDetectedTokens,\n          interactingAddress: accountAddress,\n          interactingChainId: chainId,\n        },\n      );\n\n      // We may be detecting tokens on a different chain/account pair than are currently configured.\n      // Re-point `tokens` and `detectedTokens` to keep them referencing the current chain/account.\n      const { chainId: currentChain, selectedAddress: currentAddress } =\n        this.config;\n\n      newTokens = newAllTokens?.[currentChain]?.[currentAddress] || [];\n      newDetectedTokens =\n        newAllDetectedTokens?.[currentChain]?.[currentAddress] || [];\n\n      this.update({\n        tokens: newTokens,\n        allTokens: newAllTokens,\n        detectedTokens: newDetectedTokens,\n        allDetectedTokens: newAllDetectedTokens,\n      });\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Adds isERC721 field to token object. This is called when a user attempts to add tokens that\n   * were previously added which do not yet had isERC721 field.\n   *\n   * @param tokenAddress - The contract address of the token requiring the isERC721 field added.\n   * @returns The new token object with the added isERC721 field.\n   */\n  async updateTokenType(tokenAddress: string) {\n    const isERC721 = await this._detectIsERC721(tokenAddress);\n    const { tokens } = this.state;\n    const tokenIndex = tokens.findIndex((token) => {\n      return token.address.toLowerCase() === tokenAddress.toLowerCase();\n    });\n    tokens[tokenIndex].isERC721 = isERC721;\n    this.update({ tokens });\n    return tokens[tokenIndex];\n  }\n\n  /**\n   * This is a function that updates the tokens name for the tokens name if it is not defined.\n   *\n   * @param tokenList - Represents the fetched token list from service API\n   * @param tokenAttribute - Represents the token attribute that we want to update on the token list\n   */\n  private updateTokensAttribute(\n    tokenList: TokenListMap,\n    tokenAttribute: keyof Token & keyof TokenListToken,\n  ) {\n    const { tokens } = this.state;\n\n    const newTokens = tokens.map((token) => {\n      const newToken = tokenList[token.address.toLowerCase()];\n\n      return !token[tokenAttribute] && newToken?.[tokenAttribute]\n        ? { ...token, [tokenAttribute]: newToken[tokenAttribute] }\n        : { ...token };\n    });\n\n    this.update({ tokens: newTokens });\n  }\n\n  /**\n   * Detects whether or not a token is ERC-721 compatible.\n   *\n   * @param tokenAddress - The token contract address.\n   * @param networkClientId - Optional network client ID to fetch contract info with.\n   * @returns A boolean indicating whether the token address passed in supports the EIP-721\n   * interface.\n   */\n  async _detectIsERC721(\n    tokenAddress: string,\n    networkClientId?: NetworkClientId,\n  ) {\n    const checksumAddress = toChecksumHexAddress(tokenAddress);\n    // if this token is already in our contract metadata map we don't need\n    // to check against the contract\n    if (contractsMap[checksumAddress]?.erc721 === true) {\n      return Promise.resolve(true);\n    } else if (contractsMap[checksumAddress]?.erc20 === true) {\n      return Promise.resolve(false);\n    }\n\n    const tokenContract = this._createEthersContract(\n      tokenAddress,\n      abiERC721,\n      networkClientId,\n    );\n    try {\n      return await tokenContract.supportsInterface(ERC721_INTERFACE_ID);\n    } catch (error) {\n      // currently we see a variety of errors across different networks when\n      // token contracts are not ERC721 compatible. We need to figure out a better\n      // way of differentiating token interface types but for now if we get an error\n      // we have to assume the token is not ERC721 compatible.\n      return false;\n    }\n  }\n\n  _getProvider(networkClientId?: NetworkClientId): Web3Provider {\n    return new Web3Provider(\n      // @ts-expect-error TODO: remove this annotation once the `Eip1193Provider` class is released\n      networkClientId\n        ? this.messagingSystem.call(\n            'NetworkController:getNetworkClientById',\n            networkClientId,\n          ).provider\n        : this.config.provider,\n    );\n  }\n\n  _createEthersContract(\n    tokenAddress: string,\n    abi: string,\n    networkClientId?: NetworkClientId,\n  ): Contract {\n    const web3provider = this._getProvider(networkClientId);\n    const tokenContract = new Contract(tokenAddress, abi, web3provider);\n    return tokenContract;\n  }\n\n  _generateRandomId(): string {\n    return random();\n  }\n\n  /**\n   * Adds a new suggestedAsset to the list of watched assets.\n   * Parameters will be validated according to the asset type being watched.\n   *\n   * @param options - The method options.\n   * @param options.asset - The asset to be watched. For now only ERC20 tokens are accepted.\n   * @param options.type - The asset type.\n   * @param options.interactingAddress - The address of the account that is requesting to watch the asset.\n   * @param options.networkClientId - Network Client ID.\n   * @returns A promise that resolves if the asset was watched successfully, and rejects otherwise.\n   */\n  async watchAsset({\n    asset,\n    type,\n    interactingAddress,\n    networkClientId,\n  }: {\n    asset: Token;\n    type: string;\n    interactingAddress?: string;\n    networkClientId?: NetworkClientId;\n  }): Promise<void> {\n    if (type !== ERC20) {\n      throw new Error(`Asset of type ${type} not supported`);\n    }\n\n    if (!asset.address) {\n      throw rpcErrors.invalidParams('Address must be specified');\n    }\n\n    if (!isValidHexAddress(asset.address)) {\n      throw rpcErrors.invalidParams(`Invalid address \"${asset.address}\"`);\n    }\n\n    // Validate contract\n\n    if (await this._detectIsERC721(asset.address, networkClientId)) {\n      throw rpcErrors.invalidParams(\n        `Contract ${asset.address} must match type ${type}, but was detected as ${ERC721}`,\n      );\n    }\n\n    const provider = this._getProvider(networkClientId);\n    const isErc1155 = await safelyExecute(() =>\n      new ERC1155Standard(provider).contractSupportsBase1155Interface(\n        asset.address,\n      ),\n    );\n    if (isErc1155) {\n      throw rpcErrors.invalidParams(\n        `Contract ${asset.address} must match type ${type}, but was detected as ${ERC1155}`,\n      );\n    }\n\n    const erc20 = new ERC20Standard(provider);\n    const [contractName, contractSymbol, contractDecimals] = await Promise.all([\n      safelyExecute(() => erc20.getTokenName(asset.address)),\n      safelyExecute(() => erc20.getTokenSymbol(asset.address)),\n      safelyExecute(async () => erc20.getTokenDecimals(asset.address)),\n    ]);\n\n    asset.name = contractName;\n\n    // Validate symbol\n\n    if (!asset.symbol && !contractSymbol) {\n      throw rpcErrors.invalidParams(\n        'A symbol is required, but was not found in either the request or contract',\n      );\n    }\n\n    if (\n      contractSymbol !== undefined &&\n      asset.symbol !== undefined &&\n      asset.symbol.toUpperCase() !== contractSymbol.toUpperCase()\n    ) {\n      throw rpcErrors.invalidParams(\n        `The symbol in the request (${asset.symbol}) does not match the symbol in the contract (${contractSymbol})`,\n      );\n    }\n\n    asset.symbol = contractSymbol ?? asset.symbol;\n    if (typeof asset.symbol !== 'string') {\n      throw rpcErrors.invalidParams(`Invalid symbol: not a string`);\n    }\n\n    if (asset.symbol.length > 11) {\n      throw rpcErrors.invalidParams(\n        `Invalid symbol \"${asset.symbol}\": longer than 11 characters`,\n      );\n    }\n\n    // Validate decimals\n\n    if (asset.decimals === undefined && contractDecimals === undefined) {\n      throw rpcErrors.invalidParams(\n        'Decimals are required, but were not found in either the request or contract',\n      );\n    }\n\n    if (\n      contractDecimals !== undefined &&\n      asset.decimals !== undefined &&\n      String(asset.decimals) !== contractDecimals\n    ) {\n      throw rpcErrors.invalidParams(\n        `The decimals in the request (${asset.decimals}) do not match the decimals in the contract (${contractDecimals})`,\n      );\n    }\n\n    const decimalsStr = contractDecimals ?? asset.decimals;\n    const decimalsNum = parseInt(decimalsStr as unknown as string, 10);\n    if (!Number.isInteger(decimalsNum) || decimalsNum > 36 || decimalsNum < 0) {\n      throw rpcErrors.invalidParams(\n        `Invalid decimals \"${decimalsStr}\": must be an integer 0 <= 36`,\n      );\n    }\n    asset.decimals = decimalsNum;\n\n    const suggestedAssetMeta: SuggestedAssetMeta = {\n      asset,\n      id: this._generateRandomId(),\n      time: Date.now(),\n      type,\n      interactingAddress: interactingAddress || this.config.selectedAddress,\n    };\n\n    await this._requestApproval(suggestedAssetMeta);\n\n    const { address, symbol, decimals, name, image } = asset;\n    await this.addToken({\n      address,\n      symbol,\n      decimals,\n      name,\n      image,\n      interactingAddress: suggestedAssetMeta.interactingAddress,\n      networkClientId,\n    });\n  }\n\n  /**\n   * Takes a new tokens and ignoredTokens array for the current network/account combination\n   * and returns new allTokens and allIgnoredTokens state to update to.\n   *\n   * @param params - Object that holds token params.\n   * @param params.newTokens - The new tokens to set for the current network and selected account.\n   * @param params.newIgnoredTokens - The new ignored tokens to set for the current network and selected account.\n   * @param params.newDetectedTokens - The new detected tokens to set for the current network and selected account.\n   * @param params.interactingAddress - The account address to use to store the tokens.\n   * @param params.interactingChainId - The chainId to use to store the tokens.\n   * @returns The updated `allTokens` and `allIgnoredTokens` state.\n   */\n  _getNewAllTokensState(params: {\n    newTokens?: Token[];\n    newIgnoredTokens?: string[];\n    newDetectedTokens?: Token[];\n    interactingAddress?: string;\n    interactingChainId?: Hex;\n  }) {\n    const {\n      newTokens,\n      newIgnoredTokens,\n      newDetectedTokens,\n      interactingAddress,\n      interactingChainId,\n    } = params;\n    const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n    const { chainId, selectedAddress } = this.config;\n\n    const userAddressToAddTokens = interactingAddress ?? selectedAddress;\n    const chainIdToAddTokens = interactingChainId ?? chainId;\n\n    let newAllTokens = allTokens;\n    if (\n      newTokens?.length ||\n      (newTokens &&\n        allTokens &&\n        allTokens[chainIdToAddTokens] &&\n        allTokens[chainIdToAddTokens][userAddressToAddTokens])\n    ) {\n      const networkTokens = allTokens[chainIdToAddTokens];\n      const newNetworkTokens = {\n        ...networkTokens,\n        ...{ [userAddressToAddTokens]: newTokens },\n      };\n      newAllTokens = {\n        ...allTokens,\n        ...{ [chainIdToAddTokens]: newNetworkTokens },\n      };\n    }\n\n    let newAllIgnoredTokens = allIgnoredTokens;\n    if (\n      newIgnoredTokens?.length ||\n      (newIgnoredTokens &&\n        allIgnoredTokens &&\n        allIgnoredTokens[chainIdToAddTokens] &&\n        allIgnoredTokens[chainIdToAddTokens][userAddressToAddTokens])\n    ) {\n      const networkIgnoredTokens = allIgnoredTokens[chainIdToAddTokens];\n      const newIgnoredNetworkTokens = {\n        ...networkIgnoredTokens,\n        ...{ [userAddressToAddTokens]: newIgnoredTokens },\n      };\n      newAllIgnoredTokens = {\n        ...allIgnoredTokens,\n        ...{ [chainIdToAddTokens]: newIgnoredNetworkTokens },\n      };\n    }\n\n    let newAllDetectedTokens = allDetectedTokens;\n    if (\n      newDetectedTokens?.length ||\n      (newDetectedTokens &&\n        allDetectedTokens &&\n        allDetectedTokens[chainIdToAddTokens] &&\n        allDetectedTokens[chainIdToAddTokens][userAddressToAddTokens])\n    ) {\n      const networkDetectedTokens = allDetectedTokens[chainIdToAddTokens];\n      const newDetectedNetworkTokens = {\n        ...networkDetectedTokens,\n        ...{ [userAddressToAddTokens]: newDetectedTokens },\n      };\n      newAllDetectedTokens = {\n        ...allDetectedTokens,\n        ...{ [chainIdToAddTokens]: newDetectedNetworkTokens },\n      };\n    }\n    return { newAllTokens, newAllIgnoredTokens, newAllDetectedTokens };\n  }\n\n  /**\n   * Removes all tokens from the ignored list.\n   */\n  clearIgnoredTokens() {\n    this.update({ ignoredTokens: [], allIgnoredTokens: {} });\n  }\n\n  async _requestApproval(suggestedAssetMeta: SuggestedAssetMeta) {\n    return this.messagingSystem.call(\n      'ApprovalController:addRequest',\n      {\n        id: suggestedAssetMeta.id,\n        origin: ORIGIN_METAMASK,\n        type: ApprovalType.WatchAsset,\n        requestData: {\n          id: suggestedAssetMeta.id,\n          interactingAddress: suggestedAssetMeta.interactingAddress,\n          asset: {\n            address: suggestedAssetMeta.asset.address,\n            decimals: suggestedAssetMeta.asset.decimals,\n            symbol: suggestedAssetMeta.asset.symbol,\n            image: suggestedAssetMeta.asset.image || null,\n          },\n        },\n      },\n      true,\n    );\n  }\n}\n\nexport default TokensController;\n"],"mappings":"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","names":[]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-C4PQK53K.js b/node_modules/@metamask/assets-controllers/dist/chunk-C4PQK53K.js
new file mode 100644
index 0000000..5722f51
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-C4PQK53K.js
@@ -0,0 +1,32 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});// src/crypto-compare.ts
+var _controllerutils = require('@metamask/controller-utils');
+function getPricingURL(currentCurrency, nativeCurrency, includeUSDRate) {
+  return `https://min-api.cryptocompare.com/data/price?fsym=${nativeCurrency.toUpperCase()}&tsyms=${currentCurrency.toUpperCase()}${includeUSDRate && currentCurrency.toUpperCase() !== "USD" ? ",USD" : ""}`;
+}
+async function fetchExchangeRate(currency, nativeCurrency, includeUSDRate) {
+  const json = await _controllerutils.handleFetch.call(void 0, 
+    getPricingURL(currency, nativeCurrency, includeUSDRate)
+  );
+  if (json.Response === "Error") {
+    throw new Error(json.Message);
+  }
+  const conversionRate = Number(json[currency.toUpperCase()]);
+  const usdConversionRate = Number(json.USD);
+  if (!Number.isFinite(conversionRate)) {
+    throw new Error(
+      `Invalid response for ${currency.toUpperCase()}: ${json[currency.toUpperCase()]}`
+    );
+  }
+  if (includeUSDRate && !Number.isFinite(usdConversionRate)) {
+    throw new Error(`Invalid response for usdConversionRate: ${json.USD}`);
+  }
+  return {
+    conversionRate,
+    usdConversionRate
+  };
+}
+
+
+
+exports.fetchExchangeRate = fetchExchangeRate;
+//# sourceMappingURL=chunk-C4PQK53K.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-C4PQK53K.js.map b/node_modules/@metamask/assets-controllers/dist/chunk-C4PQK53K.js.map
new file mode 100644
index 0000000..0e106d0
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-C4PQK53K.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/crypto-compare.ts"],"names":[],"mappings":";AAAA,SAAS,mBAAmB;AAa5B,SAAS,cACP,iBACA,gBACA,gBACA;AACA,SACE,qDACG,eAAe,YAAY,CAAC,UAAU,gBAAgB,YAAY,CAAC,GACnE,kBAAkB,gBAAgB,YAAY,MAAM,QAAQ,SAAS,EAAE;AAE9E;AAUA,eAAsB,kBACpB,UACA,gBACA,gBAIC;AACD,QAAM,OAAO,MAAM;AAAA,IACjB,cAAc,UAAU,gBAAgB,cAAc;AAAA,EACxD;AAUA,MAAI,KAAK,aAAa,SAAS;AAC7B,UAAM,IAAI,MAAM,KAAK,OAAO;AAAA,EAC9B;AAEA,QAAM,iBAAiB,OAAO,KAAK,SAAS,YAAY,CAAC,CAAC;AAE1D,QAAM,oBAAoB,OAAO,KAAK,GAAG;AACzC,MAAI,CAAC,OAAO,SAAS,cAAc,GAAG;AACpC,UAAM,IAAI;AAAA,MACR,wBAAwB,SAAS,YAAY,CAAC,KAC5C,KAAK,SAAS,YAAY,CAAC,CAC7B;AAAA,IACF;AAAA,EACF;AAEA,MAAI,kBAAkB,CAAC,OAAO,SAAS,iBAAiB,GAAG;AACzD,UAAM,IAAI,MAAM,2CAA2C,KAAK,GAAG,EAAE;AAAA,EACvE;AAEA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,EACF;AACF","sourcesContent":["import { handleFetch } from '@metamask/controller-utils';\n\n/**\n * Get the CryptoCompare API URL for getting the conversion rate from the given native currency to\n * the given currency. Optionally, the conversion rate from the native currency to USD can also be\n * included in the response.\n *\n * @param currentCurrency - The currency to get a conversion rate for.\n * @param nativeCurrency - The native currency to convert from.\n * @param includeUSDRate - Whether or not the native currency to USD conversion rate should be\n * included in the response as well.\n * @returns The API URL for getting the conversion rate.\n */\nfunction getPricingURL(\n  currentCurrency: string,\n  nativeCurrency: string,\n  includeUSDRate?: boolean,\n) {\n  return (\n    `https://min-api.cryptocompare.com/data/price?fsym=` +\n    `${nativeCurrency.toUpperCase()}&tsyms=${currentCurrency.toUpperCase()}` +\n    `${includeUSDRate && currentCurrency.toUpperCase() !== 'USD' ? ',USD' : ''}`\n  );\n}\n\n/**\n * Fetches the exchange rate for a given currency.\n *\n * @param currency - ISO 4217 currency code.\n * @param nativeCurrency - Symbol for base asset.\n * @param includeUSDRate - Whether to add the USD rate to the fetch.\n * @returns Promise resolving to exchange rate for given currency.\n */\nexport async function fetchExchangeRate(\n  currency: string,\n  nativeCurrency: string,\n  includeUSDRate?: boolean,\n): Promise<{\n  conversionRate: number;\n  usdConversionRate: number;\n}> {\n  const json = await handleFetch(\n    getPricingURL(currency, nativeCurrency, includeUSDRate),\n  );\n\n  /*\n  Example expected error response (if pair is not found)\n  {\n    Response: \"Error\",\n    Message: \"cccagg_or_exchange market does not exist for this coin pair (ETH-<NON_EXISTENT_TOKEN>)\",\n    HasWarning: false,\n  }\n  */\n  if (json.Response === 'Error') {\n    throw new Error(json.Message);\n  }\n\n  const conversionRate = Number(json[currency.toUpperCase()]);\n\n  const usdConversionRate = Number(json.USD);\n  if (!Number.isFinite(conversionRate)) {\n    throw new Error(\n      `Invalid response for ${currency.toUpperCase()}: ${\n        json[currency.toUpperCase()]\n      }`,\n    );\n  }\n\n  if (includeUSDRate && !Number.isFinite(usdConversionRate)) {\n    throw new Error(`Invalid response for usdConversionRate: ${json.USD}`);\n  }\n\n  return {\n    conversionRate,\n    usdConversionRate,\n  };\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-CEENXWOB.mjs b/node_modules/@metamask/assets-controllers/dist/chunk-CEENXWOB.mjs
new file mode 100644
index 0000000..419f659
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-CEENXWOB.mjs
@@ -0,0 +1,215 @@
+import {
+  ethersBigNumberToBN,
+  getFormattedIpfsUrl
+} from "./chunk-E5PIGGYR.mjs";
+
+// src/Standards/NftStandards/ERC1155/ERC1155Standard.ts
+import { Contract } from "@ethersproject/contracts";
+import {
+  ERC1155,
+  ERC1155_INTERFACE_ID,
+  ERC1155_METADATA_URI_INTERFACE_ID,
+  ERC1155_TOKEN_RECEIVER_INTERFACE_ID,
+  safelyExecute,
+  timeoutFetch
+} from "@metamask/controller-utils";
+import { abiERC1155 } from "@metamask/metamask-eth-abis";
+var ERC1155Standard = class {
+  constructor(provider) {
+    this.provider = provider;
+  }
+  /**
+   * Query if contract implements ERC1155 URI Metadata interface.
+   *
+   * @param address - ERC1155 asset contract address.
+   * @returns Promise resolving to whether the contract implements ERC1155 URI Metadata interface.
+   */
+  async contractSupportsURIMetadataInterface(address) {
+    return this.contractSupportsInterface(
+      address,
+      ERC1155_METADATA_URI_INTERFACE_ID
+    );
+  }
+  /**
+   * Query if contract implements ERC1155 Token Receiver interface.
+   *
+   * @param address - ERC1155 asset contract address.
+   * @returns Promise resolving to whether the contract implements ERC1155 Token Receiver interface.
+   */
+  async contractSupportsTokenReceiverInterface(address) {
+    return this.contractSupportsInterface(
+      address,
+      ERC1155_TOKEN_RECEIVER_INTERFACE_ID
+    );
+  }
+  /**
+   * Query if contract implements ERC1155 interface.
+   *
+   * @param address - ERC1155 asset contract address.
+   * @returns Promise resolving to whether the contract implements the base ERC1155 interface.
+   */
+  async contractSupportsBase1155Interface(address) {
+    return this.contractSupportsInterface(address, ERC1155_INTERFACE_ID);
+  }
+  /**
+   * Query for tokenURI for a given asset.
+   *
+   * @param address - ERC1155 asset contract address.
+   * @param tokenId - ERC1155 asset identifier.
+   * @returns Promise resolving to the 'tokenURI'.
+   */
+  async getTokenURI(address, tokenId) {
+    const contract = new Contract(address, abiERC1155, this.provider);
+    return contract.uri(tokenId);
+  }
+  /**
+   * Query for balance of a given ERC1155 token.
+   *
+   * @param contractAddress - ERC1155 asset contract address.
+   * @param address - Wallet public address.
+   * @param tokenId - ERC1155 asset identifier.
+   * @returns Promise resolving to the 'balanceOf'.
+   */
+  async getBalanceOf(contractAddress, address, tokenId) {
+    const contract = new Contract(contractAddress, abiERC1155, this.provider);
+    const balance = await contract.balanceOf(address, tokenId);
+    return ethersBigNumberToBN(balance);
+  }
+  /**
+   * Transfer single ERC1155 token.
+   * When minting/creating tokens, the from arg MUST be set to 0x0 (i.e. zero address).
+   * When burning/destroying tokens, the to arg MUST be set to 0x0 (i.e. zero address).
+   *
+   * @param operator - ERC1155 token address.
+   * @param from - ERC1155 token holder.
+   * @param to - ERC1155 token recipient.
+   * @param id - ERC1155 token id.
+   * @param value - Number of tokens to be sent.
+   * @returns Promise resolving to the 'transferSingle'.
+   */
+  async transferSingle(operator, from, to, id, value) {
+    const contract = new Contract(operator, abiERC1155, this.provider);
+    return new Promise((resolve, reject) => {
+      contract.transferSingle(
+        operator,
+        from,
+        to,
+        id,
+        value,
+        (error, result) => {
+          if (error) {
+            reject(error);
+            return;
+          }
+          resolve(result);
+        }
+      );
+    });
+  }
+  /**
+   * Query for symbol for a given asset.
+   *
+   * @param address - ERC1155 asset contract address.
+   * @returns Promise resolving to the 'symbol'.
+   */
+  async getAssetSymbol(address) {
+    const contract = new Contract(
+      address,
+      // Contract ABI fragment containing only the symbol method to fetch the symbol of the contract.
+      [
+        {
+          inputs: [],
+          name: "symbol",
+          outputs: [{ name: "_symbol", type: "string" }],
+          stateMutability: "view",
+          type: "function",
+          payable: false
+        }
+      ],
+      this.provider
+    );
+    return contract.symbol();
+  }
+  /**
+   * Query for name for a given asset.
+   *
+   * @param address - ERC1155 asset contract address.
+   * @returns Promise resolving to the 'name'.
+   */
+  async getAssetName(address) {
+    const contract = new Contract(
+      address,
+      // Contract ABI fragment containing only the name method to fetch the name of the contract.
+      [
+        {
+          inputs: [],
+          name: "name",
+          outputs: [{ name: "_name", type: "string" }],
+          stateMutability: "view",
+          type: "function",
+          payable: false
+        }
+      ],
+      this.provider
+    );
+    return contract.name();
+  }
+  /**
+   * Query if a contract implements an interface.
+   *
+   * @param address - ERC1155 asset contract address.
+   * @param interfaceId - Interface identifier.
+   * @returns Promise resolving to whether the contract implements `interfaceID`.
+   */
+  async contractSupportsInterface(address, interfaceId) {
+    const contract = new Contract(address, abiERC1155, this.provider);
+    return contract.supportsInterface(interfaceId);
+  }
+  /**
+   * Query if a contract implements an interface.
+   *
+   * @param address - Asset contract address.
+   * @param ipfsGateway - The user's preferred IPFS gateway.
+   * @param tokenId - tokenId of a given token in the contract.
+   * @returns Promise resolving an object containing the standard, tokenURI, symbol and name of the given contract/tokenId pair.
+   */
+  async getDetails(address, ipfsGateway, tokenId) {
+    const isERC1155 = await this.contractSupportsBase1155Interface(address);
+    if (!isERC1155) {
+      throw new Error("This isn't a valid ERC1155 contract");
+    }
+    let image;
+    const [symbol, name, tokenURI] = await Promise.all([
+      safelyExecute(() => this.getAssetSymbol(address)),
+      safelyExecute(() => this.getAssetName(address)),
+      tokenId ? safelyExecute(
+        () => this.getTokenURI(address, tokenId).then(
+          (uri) => uri.startsWith("ipfs://") ? getFormattedIpfsUrl(ipfsGateway, uri, true) : uri
+        )
+      ) : void 0
+    ]);
+    if (tokenURI) {
+      try {
+        const response = await timeoutFetch(tokenURI);
+        const object = await response.json();
+        image = object?.image;
+        if (image?.startsWith("ipfs://")) {
+          image = getFormattedIpfsUrl(ipfsGateway, image, true);
+        }
+      } catch {
+      }
+    }
+    return {
+      standard: ERC1155,
+      tokenURI,
+      image,
+      symbol,
+      name
+    };
+  }
+};
+
+export {
+  ERC1155Standard
+};
+//# sourceMappingURL=chunk-CEENXWOB.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-CEENXWOB.mjs.map b/node_modules/@metamask/assets-controllers/dist/chunk-CEENXWOB.mjs.map
new file mode 100644
index 0000000..be9a86e
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-CEENXWOB.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/Standards/NftStandards/ERC1155/ERC1155Standard.ts"],"sourcesContent":["import { Contract } from '@ethersproject/contracts';\nimport type { Web3Provider } from '@ethersproject/providers';\nimport {\n  ERC1155,\n  ERC1155_INTERFACE_ID,\n  ERC1155_METADATA_URI_INTERFACE_ID,\n  ERC1155_TOKEN_RECEIVER_INTERFACE_ID,\n  safelyExecute,\n  timeoutFetch,\n} from '@metamask/controller-utils';\nimport { abiERC1155 } from '@metamask/metamask-eth-abis';\nimport type * as BN from 'bn.js';\n\nimport { getFormattedIpfsUrl, ethersBigNumberToBN } from '../../../assetsUtil';\n\nexport class ERC1155Standard {\n  private readonly provider: Web3Provider;\n\n  constructor(provider: Web3Provider) {\n    this.provider = provider;\n  }\n\n  /**\n   * Query if contract implements ERC1155 URI Metadata interface.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @returns Promise resolving to whether the contract implements ERC1155 URI Metadata interface.\n   */\n  async contractSupportsURIMetadataInterface(\n    address: string,\n  ): Promise<boolean> {\n    return this.contractSupportsInterface(\n      address,\n      ERC1155_METADATA_URI_INTERFACE_ID,\n    );\n  }\n\n  /**\n   * Query if contract implements ERC1155 Token Receiver interface.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @returns Promise resolving to whether the contract implements ERC1155 Token Receiver interface.\n   */\n  async contractSupportsTokenReceiverInterface(\n    address: string,\n  ): Promise<boolean> {\n    return this.contractSupportsInterface(\n      address,\n      ERC1155_TOKEN_RECEIVER_INTERFACE_ID,\n    );\n  }\n\n  /**\n   * Query if contract implements ERC1155 interface.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @returns Promise resolving to whether the contract implements the base ERC1155 interface.\n   */\n  async contractSupportsBase1155Interface(address: string): Promise<boolean> {\n    return this.contractSupportsInterface(address, ERC1155_INTERFACE_ID);\n  }\n\n  /**\n   * Query for tokenURI for a given asset.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @param tokenId - ERC1155 asset identifier.\n   * @returns Promise resolving to the 'tokenURI'.\n   */\n  async getTokenURI(address: string, tokenId: string): Promise<string> {\n    const contract = new Contract(address, abiERC1155, this.provider);\n    return contract.uri(tokenId);\n  }\n\n  /**\n   * Query for balance of a given ERC1155 token.\n   *\n   * @param contractAddress - ERC1155 asset contract address.\n   * @param address - Wallet public address.\n   * @param tokenId - ERC1155 asset identifier.\n   * @returns Promise resolving to the 'balanceOf'.\n   */\n  async getBalanceOf(\n    contractAddress: string,\n    address: string,\n    tokenId: string,\n  ): Promise<BN> {\n    const contract = new Contract(contractAddress, abiERC1155, this.provider);\n    const balance = await contract.balanceOf(address, tokenId);\n    return ethersBigNumberToBN(balance);\n  }\n\n  /**\n   * Transfer single ERC1155 token.\n   * When minting/creating tokens, the from arg MUST be set to 0x0 (i.e. zero address).\n   * When burning/destroying tokens, the to arg MUST be set to 0x0 (i.e. zero address).\n   *\n   * @param operator - ERC1155 token address.\n   * @param from - ERC1155 token holder.\n   * @param to - ERC1155 token recipient.\n   * @param id - ERC1155 token id.\n   * @param value - Number of tokens to be sent.\n   * @returns Promise resolving to the 'transferSingle'.\n   */\n  async transferSingle(\n    operator: string,\n    from: string,\n    to: string,\n    id: string,\n    value: string,\n  ): Promise<void> {\n    const contract = new Contract(operator, abiERC1155, this.provider);\n    return new Promise<void>((resolve, reject) => {\n      contract.transferSingle(\n        operator,\n        from,\n        to,\n        id,\n        value,\n        (error: Error, result: void) => {\n          /* istanbul ignore if */\n          if (error) {\n            reject(error);\n            return;\n          }\n          resolve(result);\n        },\n      );\n    });\n  }\n\n  /**\n   * Query for symbol for a given asset.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @returns Promise resolving to the 'symbol'.\n   */\n  async getAssetSymbol(address: string): Promise<string> {\n    const contract = new Contract(\n      address,\n      // Contract ABI fragment containing only the symbol method to fetch the symbol of the contract.\n      [\n        {\n          inputs: [],\n          name: 'symbol',\n          outputs: [{ name: '_symbol', type: 'string' }],\n          stateMutability: 'view',\n          type: 'function',\n          payable: false,\n        },\n      ],\n      this.provider,\n    );\n    return contract.symbol();\n  }\n\n  /**\n   * Query for name for a given asset.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @returns Promise resolving to the 'name'.\n   */\n  async getAssetName(address: string): Promise<string> {\n    const contract = new Contract(\n      address,\n      // Contract ABI fragment containing only the name method to fetch the name of the contract.\n      [\n        {\n          inputs: [],\n          name: 'name',\n          outputs: [{ name: '_name', type: 'string' }],\n          stateMutability: 'view',\n          type: 'function',\n          payable: false,\n        },\n      ],\n      this.provider,\n    );\n    return contract.name();\n  }\n\n  /**\n   * Query if a contract implements an interface.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @param interfaceId - Interface identifier.\n   * @returns Promise resolving to whether the contract implements `interfaceID`.\n   */\n  private async contractSupportsInterface(\n    address: string,\n    interfaceId: string,\n  ): Promise<boolean> {\n    const contract = new Contract(address, abiERC1155, this.provider);\n    return contract.supportsInterface(interfaceId);\n  }\n\n  /**\n   * Query if a contract implements an interface.\n   *\n   * @param address - Asset contract address.\n   * @param ipfsGateway - The user's preferred IPFS gateway.\n   * @param tokenId - tokenId of a given token in the contract.\n   * @returns Promise resolving an object containing the standard, tokenURI, symbol and name of the given contract/tokenId pair.\n   */\n  async getDetails(\n    address: string,\n    ipfsGateway: string,\n    tokenId?: string,\n  ): Promise<{\n    standard: string;\n    tokenURI: string | undefined;\n    image: string | undefined;\n    name: string | undefined;\n    symbol: string | undefined;\n  }> {\n    const isERC1155 = await this.contractSupportsBase1155Interface(address);\n\n    if (!isERC1155) {\n      throw new Error(\"This isn't a valid ERC1155 contract\");\n    }\n\n    let image;\n\n    const [symbol, name, tokenURI] = await Promise.all([\n      safelyExecute(() => this.getAssetSymbol(address)),\n      safelyExecute(() => this.getAssetName(address)),\n      tokenId\n        ? safelyExecute(() =>\n            this.getTokenURI(address, tokenId).then((uri) =>\n              uri.startsWith('ipfs://')\n                ? getFormattedIpfsUrl(ipfsGateway, uri, true)\n                : uri,\n            ),\n          )\n        : undefined,\n    ]);\n\n    if (tokenURI) {\n      try {\n        const response = await timeoutFetch(tokenURI);\n        const object = await response.json();\n        image = object?.image;\n        if (image?.startsWith('ipfs://')) {\n          image = getFormattedIpfsUrl(ipfsGateway, image, true);\n        }\n      } catch {\n        // Catch block should be kept empty to ignore exceptions, and\n        // pass as much information as possible to the return statement\n      }\n    }\n\n    // TODO consider querying to the metadata to get name.\n    return {\n      standard: ERC1155,\n      tokenURI,\n      image,\n      symbol,\n      name,\n    };\n  }\n}\n"],"mappings":"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","names":[]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-CNGRNK6N.js b/node_modules/@metamask/assets-controllers/dist/chunk-CNGRNK6N.js
new file mode 100644
index 0000000..df4b974
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-CNGRNK6N.js
@@ -0,0 +1,1228 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+
+
+
+
+var _chunkRELRWIJNjs = require('./chunk-RELRWIJN.js');
+
+// src/NftController.ts
+var _address = require('@ethersproject/address');
+var _basecontroller = require('@metamask/base-controller');
+
+
+
+
+
+
+
+
+
+
+
+var _controllerutils = require('@metamask/controller-utils');
+var _rpcerrors = require('@metamask/rpc-errors');
+var _utils = require('@metamask/utils');
+var _asyncmutex = require('async-mutex');
+var _bnjs = require('bn.js'); var _bnjs2 = _interopRequireDefault(_bnjs);
+var _events = require('events');
+var _uuid = require('uuid');
+var OpenSeaV2ChainIds = /* @__PURE__ */ ((OpenSeaV2ChainIds2) => {
+  OpenSeaV2ChainIds2["ethereum"] = "ethereum";
+  return OpenSeaV2ChainIds2;
+})(OpenSeaV2ChainIds || {});
+var ALL_NFTS_STATE_KEY = "allNfts";
+var ALL_NFTS_CONTRACTS_STATE_KEY = "allNftContracts";
+var getDefaultNftState = () => {
+  return {
+    allNftContracts: {},
+    allNfts: {},
+    ignoredNfts: []
+  };
+};
+var NftController = class extends _basecontroller.BaseControllerV1 {
+  /**
+   * Creates an NftController instance.
+   *
+   * @param options - The controller options.
+   * @param options.chainId - The chain ID of the current network.
+   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.
+   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.
+   * @param options.getERC721AssetName - Gets the name of the asset at the given address.
+   * @param options.getERC721AssetSymbol - Gets the symbol of the asset at the given address.
+   * @param options.getERC721TokenURI - Gets the URI of the ERC721 token at the given address, with the given ID.
+   * @param options.getERC721OwnerOf - Get the owner of a ERC-721 NFT.
+   * @param options.getERC1155BalanceOf - Gets balance of a ERC-1155 NFT.
+   * @param options.getERC1155TokenURI - Gets the URI of the ERC1155 token at the given address, with the given ID.
+   * @param options.getNetworkClientById - Gets the network client for the given networkClientId.
+   * @param options.onNftAdded - Callback that is called when an NFT is added. Currently used pass data
+   * for tracking the NFT added event.
+   * @param options.messenger - The controller messenger.
+   * @param config - Initial options used to configure this controller.
+   * @param state - Initial state to set on this controller.
+   */
+  constructor({
+    chainId: initialChainId,
+    onPreferencesStateChange,
+    onNetworkStateChange,
+    getERC721AssetName,
+    getERC721AssetSymbol,
+    getERC721TokenURI,
+    getERC721OwnerOf,
+    getERC1155BalanceOf,
+    getERC1155TokenURI,
+    getNetworkClientById,
+    onNftAdded,
+    messenger
+  }, config, state) {
+    super(config, state);
+    this.mutex = new (0, _asyncmutex.Mutex)();
+    /**
+     * EventEmitter instance used to listen to specific EIP747 events
+     */
+    this.hub = new (0, _events.EventEmitter)();
+    /**
+     * Name of this controller used during composition
+     */
+    this.name = "NftController";
+    this.defaultConfig = {
+      selectedAddress: "",
+      chainId: initialChainId,
+      ipfsGateway: _controllerutils.IPFS_DEFAULT_GATEWAY_URL,
+      openSeaEnabled: false,
+      useIPFSSubdomains: true,
+      isIpfsGatewayEnabled: true
+    };
+    this.defaultState = getDefaultNftState();
+    this.initialize();
+    this.getERC721AssetName = getERC721AssetName;
+    this.getERC721AssetSymbol = getERC721AssetSymbol;
+    this.getERC721TokenURI = getERC721TokenURI;
+    this.getERC721OwnerOf = getERC721OwnerOf;
+    this.getERC1155BalanceOf = getERC1155BalanceOf;
+    this.getERC1155TokenURI = getERC1155TokenURI;
+    this.getNetworkClientById = getNetworkClientById;
+    this.onNftAdded = onNftAdded;
+    this.messagingSystem = messenger;
+    onPreferencesStateChange(
+      ({
+        selectedAddress,
+        ipfsGateway,
+        openSeaEnabled,
+        isIpfsGatewayEnabled
+      }) => {
+        this.configure({
+          selectedAddress,
+          ipfsGateway,
+          openSeaEnabled,
+          isIpfsGatewayEnabled
+        });
+        const needsUpdateNftMetadata = isIpfsGatewayEnabled && ipfsGateway !== "" || openSeaEnabled;
+        if (needsUpdateNftMetadata) {
+          this.updateNftMetadata({ userAddress: selectedAddress });
+        }
+      }
+    );
+    onNetworkStateChange(({ providerConfig }) => {
+      const { chainId } = providerConfig;
+      this.configure({ chainId });
+    });
+  }
+  getNftApi({
+    contractAddress,
+    tokenId
+  }) {
+    return `${_controllerutils.OPENSEA_PROXY_URL}/chain/${"ethereum" /* ethereum */}/contract/${contractAddress}/nfts/${tokenId}`;
+  }
+  getNftContractInformationApi({
+    contractAddress
+  }) {
+    return `${_controllerutils.OPENSEA_PROXY_URL}/chain/${"ethereum" /* ethereum */}/contract/${contractAddress}`;
+  }
+  getNftCollectionInformationApi({
+    collectionSlug
+  }) {
+    return `${_controllerutils.OPENSEA_PROXY_URL}/collections/${collectionSlug}`;
+  }
+  /**
+   * Helper method to update nested state for allNfts and allNftContracts.
+   *
+   * @param newCollection - the modified piece of state to update in the controller's store
+   * @param baseStateKey - The root key in the store to update.
+   * @param passedConfig - An object containing the selectedAddress and chainId that are passed through the auto-detection flow.
+   * @param passedConfig.userAddress - the address passed through the NFT detection flow to ensure assets are stored to the correct account
+   * @param passedConfig.chainId - the chainId passed through the NFT detection flow to ensure assets are stored to the correct account
+   */
+  updateNestedNftState(newCollection, baseStateKey, { userAddress, chainId }) {
+    const { [baseStateKey]: oldState } = this.state;
+    const addressState = oldState[userAddress];
+    const newAddressState = {
+      ...addressState,
+      ...{ [chainId]: newCollection }
+    };
+    const newState = {
+      ...oldState,
+      ...{ [userAddress]: newAddressState }
+    };
+    this.update({
+      [baseStateKey]: newState
+    });
+  }
+  /**
+   * Request individual NFT information from OpenSea API.
+   *
+   * @param contractAddress - Hex address of the NFT contract.
+   * @param tokenId - The NFT identifier.
+   * @returns Promise resolving to the current NFT name and image.
+   */
+  async getNftInformationFromApi(contractAddress, tokenId) {
+    const nftInformation = await _controllerutils.fetchWithErrorHandling.call(void 0, {
+      url: this.getNftApi({
+        contractAddress,
+        tokenId
+      })
+    });
+    if (!nftInformation?.nft) {
+      return {
+        name: null,
+        description: null,
+        image: null,
+        standard: null
+      };
+    }
+    const {
+      num_sales,
+      background_color,
+      image_url,
+      image_preview_url,
+      image_thumbnail_url,
+      image_original_url,
+      animation_url,
+      animation_original_url,
+      name,
+      description,
+      external_link,
+      creator,
+      last_sale,
+      asset_contract: { schema_name }
+    } = _chunkRELRWIJNjs.mapOpenSeaDetailedNftV2ToV1.call(void 0, nftInformation.nft);
+    const nftMetadata = Object.assign(
+      {},
+      { name: name || null },
+      { description: description || null },
+      { image: image_url || null },
+      creator && { creator },
+      num_sales && { numberOfSales: num_sales },
+      background_color && { backgroundColor: background_color },
+      image_preview_url && { imagePreview: image_preview_url },
+      image_thumbnail_url && { imageThumbnail: image_thumbnail_url },
+      image_original_url && { imageOriginal: image_original_url },
+      animation_url && { animation: animation_url },
+      animation_original_url && {
+        animationOriginal: animation_original_url
+      },
+      external_link && { externalLink: external_link },
+      last_sale && { lastSale: last_sale },
+      schema_name && { standard: schema_name }
+    );
+    return nftMetadata;
+  }
+  /**
+   * Request individual NFT information from contracts that follows Metadata Interface.
+   *
+   * @param contractAddress - Hex address of the NFT contract.
+   * @param tokenId - The NFT identifier.
+   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @returns Promise resolving to the current NFT name and image.
+   */
+  async getNftInformationFromTokenURI(contractAddress, tokenId, networkClientId) {
+    const { ipfsGateway, useIPFSSubdomains, isIpfsGatewayEnabled } = this.config;
+    const result = await this.getNftURIAndStandard(
+      contractAddress,
+      tokenId,
+      networkClientId
+    );
+    let tokenURI = result[0];
+    const standard = result[1];
+    const hasIpfsTokenURI = tokenURI.startsWith("ipfs://");
+    if (hasIpfsTokenURI && !isIpfsGatewayEnabled) {
+      return {
+        image: null,
+        name: null,
+        description: null,
+        standard: standard || null,
+        favorite: false,
+        tokenURI: tokenURI ?? null
+      };
+    }
+    const isDisplayNFTMediaToggleEnabled = this.config.openSeaEnabled;
+    if (!hasIpfsTokenURI && !isDisplayNFTMediaToggleEnabled) {
+      return {
+        image: null,
+        name: null,
+        description: null,
+        standard: standard || null,
+        favorite: false,
+        tokenURI: tokenURI ?? null
+      };
+    }
+    if (hasIpfsTokenURI) {
+      tokenURI = _chunkRELRWIJNjs.getFormattedIpfsUrl.call(void 0, ipfsGateway, tokenURI, useIPFSSubdomains);
+    }
+    try {
+      const object = await _controllerutils.handleFetch.call(void 0, tokenURI);
+      const image = Object.prototype.hasOwnProperty.call(object, "image") ? "image" : (
+        /* istanbul ignore next */
+        "image_url"
+      );
+      return {
+        image: object[image],
+        name: object.name,
+        description: object.description,
+        standard,
+        favorite: false,
+        tokenURI: tokenURI ?? null
+      };
+    } catch {
+      return {
+        image: null,
+        name: null,
+        description: null,
+        standard: standard || null,
+        favorite: false,
+        tokenURI: tokenURI ?? null
+      };
+    }
+  }
+  /**
+   * Retrieve NFT uri with  metadata. TODO Update method to use IPFS.
+   *
+   * @param contractAddress - NFT contract address.
+   * @param tokenId - NFT token id.
+   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @returns Promise resolving NFT uri and token standard.
+   */
+  async getNftURIAndStandard(contractAddress, tokenId, networkClientId) {
+    try {
+      const uri = await this.getERC721TokenURI(
+        contractAddress,
+        tokenId,
+        networkClientId
+      );
+      return [uri, _controllerutils.ERC721];
+    } catch {
+    }
+    try {
+      const tokenURI = await this.getERC1155TokenURI(
+        contractAddress,
+        tokenId,
+        networkClientId
+      );
+      if (!tokenURI.includes("{id}")) {
+        return [tokenURI, _controllerutils.ERC1155];
+      }
+      const hexTokenId = _utils.remove0x.call(void 0, _controllerutils.BNToHex.call(void 0, new (0, _bnjs2.default)(tokenId))).padStart(64, "0").toLowerCase();
+      return [tokenURI.replace("{id}", hexTokenId), _controllerutils.ERC1155];
+    } catch {
+    }
+    return ["", ""];
+  }
+  /**
+   * Request individual NFT information (name, image url and description).
+   *
+   * @param contractAddress - Hex address of the NFT contract.
+   * @param tokenId - The NFT identifier.
+   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @returns Promise resolving to the current NFT name and image.
+   */
+  async getNftInformation(contractAddress, tokenId, networkClientId) {
+    const chainId = this.getCorrectChainId({
+      networkClientId
+    });
+    const [blockchainMetadata, openSeaMetadata] = await Promise.all([
+      _controllerutils.safelyExecute.call(void 0, 
+        () => this.getNftInformationFromTokenURI(
+          contractAddress,
+          tokenId,
+          networkClientId
+        )
+      ),
+      this.config.openSeaEnabled && chainId === "0x1" ? _controllerutils.safelyExecute.call(void 0, 
+        () => this.getNftInformationFromApi(contractAddress, tokenId)
+      ) : void 0
+    ]);
+    return {
+      ...openSeaMetadata,
+      name: blockchainMetadata?.name ?? openSeaMetadata?.name ?? null,
+      description: blockchainMetadata?.description ?? openSeaMetadata?.description ?? null,
+      image: blockchainMetadata?.image ?? openSeaMetadata?.image ?? null,
+      standard: blockchainMetadata?.standard ?? openSeaMetadata?.standard ?? null,
+      tokenURI: blockchainMetadata?.tokenURI ?? null
+    };
+  }
+  /**
+   * Request NFT contract information from OpenSea API.
+   *
+   * @param contractAddress - Hex address of the NFT contract.
+   * @returns Promise resolving to the current NFT name and image.
+   */
+  async getNftContractInformationFromApi(contractAddress) {
+    const apiNftContractObject = await _controllerutils.fetchWithErrorHandling.call(void 0, {
+      url: this.getNftContractInformationApi({
+        contractAddress
+      })
+    });
+    if (apiNftContractObject) {
+      const collection = await _controllerutils.fetchWithErrorHandling.call(void 0, {
+        url: this.getNftCollectionInformationApi({
+          collectionSlug: apiNftContractObject.collection
+        })
+      });
+      return _chunkRELRWIJNjs.mapOpenSeaContractV2ToV1.call(void 0, apiNftContractObject, collection);
+    }
+    return {
+      address: contractAddress,
+      asset_contract_type: null,
+      created_date: null,
+      schema_name: null,
+      symbol: null,
+      total_supply: null,
+      description: null,
+      external_link: null,
+      collection: {
+        name: null,
+        image_url: null
+      }
+    };
+  }
+  /**
+   * Request NFT contract information from the contract itself.
+   *
+   * @param contractAddress - Hex address of the NFT contract.
+   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @returns Promise resolving to the current NFT name and image.
+   */
+  async getNftContractInformationFromContract(contractAddress, networkClientId) {
+    const [name, symbol] = await Promise.all([
+      this.getERC721AssetName(contractAddress, networkClientId),
+      this.getERC721AssetSymbol(contractAddress, networkClientId)
+    ]);
+    return {
+      collection: { name },
+      symbol,
+      address: contractAddress
+    };
+  }
+  /**
+   * Request NFT contract information from OpenSea API.
+   *
+   * @param contractAddress - Hex address of the NFT contract.
+   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @returns Promise resolving to the NFT contract name, image and description.
+   */
+  async getNftContractInformation(contractAddress, networkClientId) {
+    const chainId = this.getCorrectChainId({
+      networkClientId
+    });
+    const [blockchainContractData, openSeaContractData] = await Promise.all([
+      _controllerutils.safelyExecute.call(void 0, 
+        () => this.getNftContractInformationFromContract(
+          contractAddress,
+          networkClientId
+        )
+      ),
+      this.config.openSeaEnabled && chainId === "0x1" ? _controllerutils.safelyExecute.call(void 0, 
+        () => this.getNftContractInformationFromApi(contractAddress)
+      ) : void 0
+    ]);
+    if (blockchainContractData || openSeaContractData) {
+      return {
+        address: contractAddress,
+        ...openSeaContractData,
+        ...blockchainContractData,
+        collection: {
+          name: null,
+          image_url: null,
+          ...openSeaContractData?.collection,
+          ...blockchainContractData?.collection
+        }
+      };
+    }
+    return {
+      address: contractAddress,
+      asset_contract_type: null,
+      created_date: null,
+      schema_name: null,
+      symbol: null,
+      total_supply: null,
+      description: null,
+      external_link: null,
+      collection: { name: null, image_url: null }
+    };
+  }
+  /**
+   * Adds an individual NFT to the stored NFT list.
+   *
+   * @param tokenAddress - Hex address of the NFT contract.
+   * @param tokenId - The NFT identifier.
+   * @param nftMetadata - NFT optional information (name, image and description).
+   * @param nftContract - An object containing contract data of the NFT being added.
+   * @param chainId - The chainId of the network where the NFT is being added.
+   * @param userAddress - The address of the account where the NFT is being added.
+   * @param source - Whether the NFT was detected, added manually or suggested by a dapp.
+   * @returns Promise resolving to the current NFT list.
+   */
+  async addIndividualNft(tokenAddress, tokenId, nftMetadata, nftContract, chainId, userAddress, source) {
+    const releaseLock = await this.mutex.acquire();
+    try {
+      tokenAddress = _controllerutils.toChecksumHexAddress.call(void 0, tokenAddress);
+      const { allNfts } = this.state;
+      const nfts = allNfts[userAddress]?.[chainId] || [];
+      const existingEntry = nfts.find(
+        (nft) => nft.address.toLowerCase() === tokenAddress.toLowerCase() && nft.tokenId === tokenId
+      );
+      if (existingEntry) {
+        const differentMetadata = _chunkRELRWIJNjs.compareNftMetadata.call(void 0, 
+          nftMetadata,
+          existingEntry
+        );
+        if (differentMetadata || !existingEntry.isCurrentlyOwned) {
+          const indexToRemove = nfts.findIndex(
+            (nft) => nft.address.toLowerCase() === tokenAddress.toLowerCase() && nft.tokenId === tokenId
+          );
+          if (indexToRemove !== -1) {
+            nfts.splice(indexToRemove, 1);
+          }
+        } else {
+          return nfts;
+        }
+      }
+      const newEntry = {
+        address: tokenAddress,
+        tokenId,
+        favorite: existingEntry?.favorite || false,
+        isCurrentlyOwned: true,
+        ...nftMetadata
+      };
+      const newNfts = [...nfts, newEntry];
+      this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {
+        chainId,
+        userAddress
+      });
+      if (this.onNftAdded) {
+        this.onNftAdded({
+          address: tokenAddress,
+          symbol: nftContract.symbol,
+          tokenId: tokenId.toString(),
+          standard: nftMetadata.standard,
+          source
+        });
+      }
+      return newNfts;
+    } finally {
+      releaseLock();
+    }
+  }
+  /**
+   * Adds an NFT contract to the stored NFT contracts list.
+   *
+   * @param options - options.
+   * @param options.tokenAddress - Hex address of the NFT contract.
+   * @param options.userAddress - The address of the account where the NFT is being added.
+   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.
+   * @returns Promise resolving to the current NFT contracts list.
+   */
+  async addNftContract({
+    tokenAddress,
+    userAddress,
+    networkClientId,
+    source
+  }) {
+    const releaseLock = await this.mutex.acquire();
+    try {
+      tokenAddress = _controllerutils.toChecksumHexAddress.call(void 0, tokenAddress);
+      const { allNftContracts } = this.state;
+      const chainId = this.getCorrectChainId({
+        networkClientId
+      });
+      const nftContracts = allNftContracts[userAddress]?.[chainId] || [];
+      const existingEntry = nftContracts.find(
+        (nftContract) => nftContract.address.toLowerCase() === tokenAddress.toLowerCase()
+      );
+      if (existingEntry) {
+        return nftContracts;
+      }
+      const contractInformation = await this.getNftContractInformation(
+        tokenAddress,
+        networkClientId
+      );
+      const {
+        asset_contract_type,
+        created_date,
+        schema_name,
+        symbol,
+        total_supply,
+        description,
+        external_link,
+        collection: { name, image_url }
+      } = contractInformation;
+      if (source === "detected" /* Detected */ && "address" in contractInformation && typeof contractInformation.address === "string" && "collection" in contractInformation && contractInformation.collection.name === null && "image_url" in contractInformation.collection && contractInformation.collection.image_url === null && Object.entries(contractInformation).every(([key, value]) => {
+        return key === "address" || key === "collection" || !value;
+      })) {
+        return nftContracts;
+      }
+      const newEntry = Object.assign(
+        {},
+        { address: tokenAddress },
+        description && { description },
+        name && { name },
+        image_url && { logo: image_url },
+        symbol && { symbol },
+        total_supply !== null && typeof total_supply !== "undefined" && { totalSupply: total_supply },
+        asset_contract_type && { assetContractType: asset_contract_type },
+        created_date && { createdDate: created_date },
+        schema_name && { schemaName: schema_name },
+        external_link && { externalLink: external_link }
+      );
+      const newNftContracts = [...nftContracts, newEntry];
+      this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY, {
+        chainId,
+        userAddress
+      });
+      return newNftContracts;
+    } finally {
+      releaseLock();
+    }
+  }
+  /**
+   * Removes an individual NFT from the stored token list and saves it in ignored NFTs list.
+   *
+   * @param address - Hex address of the NFT contract.
+   * @param tokenId - Token identifier of the NFT.
+   * @param options - options.
+   * @param options.chainId - The chainId of the network where the NFT is being removed.
+   * @param options.userAddress - The address of the account where the NFT is being removed.
+   */
+  removeAndIgnoreIndividualNft(address, tokenId, {
+    chainId,
+    userAddress
+  }) {
+    address = _controllerutils.toChecksumHexAddress.call(void 0, address);
+    const { allNfts, ignoredNfts } = this.state;
+    const newIgnoredNfts = [...ignoredNfts];
+    const nfts = allNfts[userAddress]?.[chainId] || [];
+    const newNfts = nfts.filter((nft) => {
+      if (nft.address.toLowerCase() === address.toLowerCase() && nft.tokenId === tokenId) {
+        const alreadyIgnored = newIgnoredNfts.find(
+          (c) => c.address === address && c.tokenId === tokenId
+        );
+        !alreadyIgnored && newIgnoredNfts.push(nft);
+        return false;
+      }
+      return true;
+    });
+    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {
+      userAddress,
+      chainId
+    });
+    this.update({
+      ignoredNfts: newIgnoredNfts
+    });
+  }
+  /**
+   * Removes an individual NFT from the stored token list.
+   *
+   * @param address - Hex address of the NFT contract.
+   * @param tokenId - Token identifier of the NFT.
+   * @param options - options.
+   * @param options.chainId - The chainId of the network where the NFT is being removed.
+   * @param options.userAddress - The address of the account where the NFT is being removed.
+   */
+  removeIndividualNft(address, tokenId, { chainId, userAddress }) {
+    address = _controllerutils.toChecksumHexAddress.call(void 0, address);
+    const { allNfts } = this.state;
+    const nfts = allNfts[userAddress]?.[chainId] || [];
+    const newNfts = nfts.filter(
+      (nft) => !(nft.address.toLowerCase() === address.toLowerCase() && nft.tokenId === tokenId)
+    );
+    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {
+      userAddress,
+      chainId
+    });
+  }
+  /**
+   * Removes an NFT contract to the stored NFT contracts list.
+   *
+   * @param address - Hex address of the NFT contract.
+   * @param options - options.
+   * @param options.chainId - The chainId of the network where the NFT is being removed.
+   * @param options.userAddress - The address of the account where the NFT is being removed.
+   * @returns Promise resolving to the current NFT contracts list.
+   */
+  removeNftContract(address, { chainId, userAddress }) {
+    address = _controllerutils.toChecksumHexAddress.call(void 0, address);
+    const { allNftContracts } = this.state;
+    const nftContracts = allNftContracts[userAddress]?.[chainId] || [];
+    const newNftContracts = nftContracts.filter(
+      (nftContract) => !(nftContract.address.toLowerCase() === address.toLowerCase())
+    );
+    this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY, {
+      chainId,
+      userAddress
+    });
+    return newNftContracts;
+  }
+  async validateWatchNft(asset, type, userAddress, { networkClientId } = {}) {
+    const { address: contractAddress, tokenId } = asset;
+    if (!type) {
+      throw _rpcerrors.rpcErrors.invalidParams("Asset type is required");
+    }
+    if (type !== _controllerutils.ERC721 && type !== _controllerutils.ERC1155) {
+      throw _rpcerrors.rpcErrors.invalidParams(
+        `Non NFT asset type ${type} not supported by watchNft`
+      );
+    }
+    if (!contractAddress || !tokenId) {
+      throw _rpcerrors.rpcErrors.invalidParams("Both address and tokenId are required");
+    }
+    if (!_address.isAddress.call(void 0, contractAddress)) {
+      throw _rpcerrors.rpcErrors.invalidParams("Invalid address");
+    }
+    if (!/^\d+$/u.test(tokenId)) {
+      throw _rpcerrors.rpcErrors.invalidParams("Invalid tokenId");
+    }
+    try {
+      const isOwner = await this.isNftOwner(
+        userAddress,
+        contractAddress,
+        tokenId,
+        { networkClientId }
+      );
+      if (!isOwner) {
+        throw _rpcerrors.rpcErrors.invalidInput(
+          "Suggested NFT is not owned by the selected account"
+        );
+      }
+    } catch (error) {
+      if (error instanceof Error) {
+        throw _rpcerrors.rpcErrors.resourceUnavailable(error.message);
+      }
+      throw error;
+    }
+  }
+  // temporary method to get the correct chainId until we remove chainId from the config & the chainId arg from the detection logic
+  // Just a helper method to prefer the networkClient chainId first then the chainId argument and then finally the config chainId
+  getCorrectChainId({
+    networkClientId
+  }) {
+    if (networkClientId) {
+      return this.getNetworkClientById(networkClientId).configuration.chainId;
+    }
+    return this.config.chainId;
+  }
+  /**
+   * Adds a new suggestedAsset to state. Parameters will be validated according to
+   * asset type being watched. A `<suggestedNftMeta.id>:pending` hub event will be emitted once added.
+   *
+   * @param asset - The asset to be watched. For now ERC721 and ERC1155 tokens are accepted.
+   * @param asset.address - The address of the asset contract.
+   * @param asset.tokenId - The ID of the asset.
+   * @param type - The asset type.
+   * @param origin - Domain origin to register the asset from.
+   * @param options - Options bag.
+   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @param options.userAddress - The address of the account where the NFT is being added.
+   * @returns Object containing a Promise resolving to the suggestedAsset address if accepted.
+   */
+  async watchNft(asset, type, origin, {
+    networkClientId,
+    userAddress = this.config.selectedAddress
+  } = {
+    userAddress: this.config.selectedAddress
+  }) {
+    await this.validateWatchNft(asset, type, userAddress);
+    const nftMetadata = await this.getNftInformation(
+      asset.address,
+      asset.tokenId,
+      networkClientId
+    );
+    if (nftMetadata.standard && nftMetadata.standard !== type) {
+      throw _rpcerrors.rpcErrors.invalidInput(
+        `Suggested NFT of type ${nftMetadata.standard} does not match received type ${type}`
+      );
+    }
+    const suggestedNftMeta = {
+      asset: { ...asset, ...nftMetadata },
+      type,
+      id: _uuid.v4.call(void 0, ),
+      time: Date.now(),
+      interactingAddress: userAddress,
+      origin
+    };
+    await this._requestApproval(suggestedNftMeta);
+    const { address, tokenId } = asset;
+    const { name, standard, description, image } = nftMetadata;
+    await this.addNft(address, tokenId, {
+      nftMetadata: {
+        name: name ?? null,
+        description: description ?? null,
+        image: image ?? null,
+        standard: standard ?? null
+      },
+      userAddress,
+      source: "dapp" /* Dapp */,
+      networkClientId
+    });
+  }
+  /**
+   * Sets an OpenSea API key to retrieve NFT information.
+   *
+   * @param openSeaApiKey - OpenSea API key.
+   */
+  setApiKey(openSeaApiKey) {
+    this.openSeaApiKey = openSeaApiKey;
+  }
+  /**
+   * Checks the ownership of a ERC-721 or ERC-1155 NFT for a given address.
+   *
+   * @param ownerAddress - User public address.
+   * @param nftAddress - NFT contract address.
+   * @param tokenId - NFT token ID.
+   * @param options - Options bag.
+   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @returns Promise resolving the NFT ownership.
+   */
+  async isNftOwner(ownerAddress, nftAddress, tokenId, {
+    networkClientId
+  } = {}) {
+    try {
+      const owner = await this.getERC721OwnerOf(
+        nftAddress,
+        tokenId,
+        networkClientId
+      );
+      return ownerAddress.toLowerCase() === owner.toLowerCase();
+    } catch {
+    }
+    try {
+      const balance = await this.getERC1155BalanceOf(
+        ownerAddress,
+        nftAddress,
+        tokenId,
+        networkClientId
+      );
+      return !balance.isZero();
+    } catch {
+    }
+    throw new Error(
+      `Unable to verify ownership. Possibly because the standard is not supported or the user's currently selected network does not match the chain of the asset in question.`
+    );
+  }
+  /**
+   * Verifies currently selected address owns entered NFT address/tokenId combo and
+   * adds the NFT and respective NFT contract to the stored NFT and NFT contracts lists.
+   *
+   * @param address - Hex address of the NFT contract.
+   * @param tokenId - The NFT identifier.
+   * @param options - an object of arguments
+   * @param options.userAddress - The address of the current user.
+   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.
+   */
+  async addNftVerifyOwnership(address, tokenId, {
+    userAddress = this.config.selectedAddress,
+    networkClientId,
+    source
+  } = {
+    userAddress: this.config.selectedAddress
+  }) {
+    if (!await this.isNftOwner(userAddress, address, tokenId, {
+      networkClientId
+    })) {
+      throw new Error("This NFT is not owned by the user");
+    }
+    await this.addNft(address, tokenId, {
+      networkClientId,
+      userAddress,
+      source
+    });
+  }
+  /**
+   * Adds an NFT and respective NFT contract to the stored NFT and NFT contracts lists.
+   *
+   * @param tokenAddress - Hex address of the NFT contract.
+   * @param tokenId - The NFT identifier.
+   * @param options - an object of arguments
+   * @param options.nftMetadata - NFT optional metadata.
+   * @param options.userAddress - The address of the current user.
+   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.
+   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @returns Promise resolving to the current NFT list.
+   */
+  async addNft(tokenAddress, tokenId, {
+    nftMetadata,
+    userAddress = this.config.selectedAddress,
+    source = "custom" /* Custom */,
+    networkClientId
+  } = { userAddress: this.config.selectedAddress }) {
+    tokenAddress = _controllerutils.toChecksumHexAddress.call(void 0, tokenAddress);
+    const chainId = this.getCorrectChainId({ networkClientId });
+    const newNftContracts = await this.addNftContract({
+      tokenAddress,
+      userAddress,
+      networkClientId,
+      source
+    });
+    nftMetadata = nftMetadata || await this.getNftInformation(tokenAddress, tokenId, networkClientId);
+    const nftContract = newNftContracts.find(
+      (contract) => contract.address.toLowerCase() === tokenAddress.toLowerCase()
+    );
+    if (nftContract) {
+      await this.addIndividualNft(
+        tokenAddress,
+        tokenId,
+        nftMetadata,
+        nftContract,
+        chainId,
+        userAddress,
+        source
+      );
+    }
+  }
+  /**
+   * Refetches NFT metadata and updates the state
+   *
+   * @param options - Options for refetching NFT metadata
+   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @param options.userAddress - The current user address
+   */
+  async updateNftMetadata({
+    userAddress = this.config.selectedAddress,
+    networkClientId
+  }) {
+    const chainId = this.getCorrectChainId({ networkClientId });
+    const { allNfts } = this.state;
+    const nfts = allNfts[userAddress]?.[chainId] || [];
+    const nftsToUpdate = nfts.filter(
+      (singleNft) => !singleNft.name && !singleNft.description && !singleNft.image
+    );
+    const nftsWithChecksumAdr = nftsToUpdate.map((nft) => {
+      return {
+        ...nft,
+        address: _controllerutils.toChecksumHexAddress.call(void 0, nft.address)
+      };
+    });
+    const nftMetadataResults = await Promise.allSettled(
+      nftsWithChecksumAdr.map(async (nft) => {
+        const resMetadata = await this.getNftInformation(
+          nft.address,
+          nft.tokenId,
+          networkClientId
+        );
+        return {
+          nft,
+          newMetadata: resMetadata
+        };
+      })
+    );
+    nftMetadataResults.filter(
+      (result) => result.status === "fulfilled"
+    ).forEach(
+      (elm) => this.updateNft(
+        elm.value.nft,
+        elm.value.newMetadata,
+        userAddress,
+        chainId
+      )
+    );
+  }
+  /**
+   * Removes an NFT from the stored token list.
+   *
+   * @param address - Hex address of the NFT contract.
+   * @param tokenId - Token identifier of the NFT.
+   * @param options - an object of arguments
+   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @param options.userAddress - The address of the account where the NFT is being removed.
+   */
+  removeNft(address, tokenId, {
+    networkClientId,
+    userAddress = this.config.selectedAddress
+  } = {
+    userAddress: this.config.selectedAddress
+  }) {
+    const chainId = this.getCorrectChainId({ networkClientId });
+    address = _controllerutils.toChecksumHexAddress.call(void 0, address);
+    this.removeIndividualNft(address, tokenId, { chainId, userAddress });
+    const { allNfts } = this.state;
+    const nfts = allNfts[userAddress]?.[chainId] || [];
+    const remainingNft = nfts.find(
+      (nft) => nft.address.toLowerCase() === address.toLowerCase()
+    );
+    if (!remainingNft) {
+      this.removeNftContract(address, { chainId, userAddress });
+    }
+  }
+  /**
+   * Removes an NFT from the stored token list and saves it in ignored NFTs list.
+   *
+   * @param address - Hex address of the NFT contract.
+   * @param tokenId - Token identifier of the NFT.
+   * @param options - an object of arguments
+   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @param options.userAddress - The address of the account where the NFT is being removed.
+   */
+  removeAndIgnoreNft(address, tokenId, {
+    networkClientId,
+    userAddress = this.config.selectedAddress
+  } = {
+    userAddress: this.config.selectedAddress
+  }) {
+    const chainId = this.getCorrectChainId({ networkClientId });
+    address = _controllerutils.toChecksumHexAddress.call(void 0, address);
+    this.removeAndIgnoreIndividualNft(address, tokenId, {
+      chainId,
+      userAddress
+    });
+    const { allNfts } = this.state;
+    const nfts = allNfts[userAddress]?.[chainId] || [];
+    const remainingNft = nfts.find(
+      (nft) => nft.address.toLowerCase() === address.toLowerCase()
+    );
+    if (!remainingNft) {
+      this.removeNftContract(address, { chainId, userAddress });
+    }
+  }
+  /**
+   * Removes all NFTs from the ignored list.
+   */
+  clearIgnoredNfts() {
+    this.update({ ignoredNfts: [] });
+  }
+  /**
+   * Checks whether input NFT is still owned by the user
+   * And updates the isCurrentlyOwned value on the NFT object accordingly.
+   *
+   * @param nft - The NFT object to check and update.
+   * @param batch - A boolean indicating whether this method is being called as part of a batch or single update.
+   * @param accountParams - The userAddress and chainId to check ownership against
+   * @param accountParams.userAddress - the address passed through the confirmed transaction flow to ensure assets are stored to the correct account
+   * @param accountParams.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @returns the NFT with the updated isCurrentlyOwned value
+   */
+  async checkAndUpdateSingleNftOwnershipStatus(nft, batch, {
+    userAddress = this.config.selectedAddress,
+    networkClientId
+  } = {
+    userAddress: this.config.selectedAddress
+  }) {
+    const chainId = this.getCorrectChainId({ networkClientId });
+    const { address, tokenId } = nft;
+    let isOwned = nft.isCurrentlyOwned;
+    try {
+      isOwned = await this.isNftOwner(userAddress, address, tokenId, {
+        networkClientId
+      });
+    } catch {
+    }
+    nft.isCurrentlyOwned = isOwned;
+    if (batch) {
+      return nft;
+    }
+    const { allNfts } = this.state;
+    const nfts = allNfts[userAddress]?.[chainId] || [];
+    const nftToUpdate = nfts.find(
+      (item) => item.tokenId === tokenId && item.address.toLowerCase() === address.toLowerCase()
+    );
+    if (nftToUpdate) {
+      nftToUpdate.isCurrentlyOwned = isOwned;
+      this.updateNestedNftState(nfts, ALL_NFTS_STATE_KEY, {
+        userAddress,
+        chainId
+      });
+    }
+    return nft;
+  }
+  /**
+   * Checks whether NFTs associated with current selectedAddress/chainId combination are still owned by the user
+   * And updates the isCurrentlyOwned value on each accordingly.
+   * @param options - an object of arguments
+   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @param options.userAddress - The address of the account where the NFT ownership status is checked/updated.
+   */
+  async checkAndUpdateAllNftsOwnershipStatus({
+    networkClientId,
+    userAddress = this.config.selectedAddress
+  } = {
+    userAddress: this.config.selectedAddress
+  }) {
+    const chainId = this.getCorrectChainId({ networkClientId });
+    const { allNfts } = this.state;
+    const nfts = allNfts[userAddress]?.[chainId] || [];
+    const updatedNfts = await Promise.all(
+      nfts.map(async (nft) => {
+        return await this.checkAndUpdateSingleNftOwnershipStatus(nft, true, {
+          networkClientId,
+          userAddress
+        }) ?? nft;
+      })
+    );
+    this.updateNestedNftState(updatedNfts, ALL_NFTS_STATE_KEY, {
+      userAddress,
+      chainId
+    });
+  }
+  /**
+   * Update NFT favorite status.
+   *
+   * @param address - Hex address of the NFT contract.
+   * @param tokenId - Hex address of the NFT contract.
+   * @param favorite - NFT new favorite status.
+   * @param options - an object of arguments
+   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @param options.userAddress - The address of the account where the NFT is being removed.
+   */
+  updateNftFavoriteStatus(address, tokenId, favorite, {
+    networkClientId,
+    userAddress = this.config.selectedAddress
+  } = {
+    userAddress: this.config.selectedAddress
+  }) {
+    const chainId = this.getCorrectChainId({ networkClientId });
+    const { allNfts } = this.state;
+    const nfts = allNfts[userAddress]?.[chainId] || [];
+    const index = nfts.findIndex(
+      (nft) => nft.address === address && nft.tokenId === tokenId
+    );
+    if (index === -1) {
+      return;
+    }
+    const updatedNft = {
+      ...nfts[index],
+      favorite
+    };
+    nfts[index] = updatedNft;
+    this.updateNestedNftState(nfts, ALL_NFTS_STATE_KEY, {
+      chainId,
+      userAddress
+    });
+  }
+  /**
+   * Returns an NFT by the address and token id.
+   *
+   * @param address - Hex address of the NFT contract.
+   * @param tokenId - Number that represents the id of the token.
+   * @param selectedAddress - Hex address of the user account.
+   * @param chainId - Id of the current network.
+   * @returns Object containing the NFT and its position in the array
+   */
+  findNftByAddressAndTokenId(address, tokenId, selectedAddress, chainId) {
+    const { allNfts } = this.state;
+    const nfts = allNfts[selectedAddress]?.[chainId] || [];
+    const index = nfts.findIndex(
+      (nft) => nft.address.toLowerCase() === address.toLowerCase() && nft.tokenId === tokenId
+    );
+    if (index === -1) {
+      return null;
+    }
+    return { nft: nfts[index], index };
+  }
+  /**
+   * Update NFT data.
+   *
+   * @param nft - NFT object to find the right NFT to updates.
+   * @param updates - NFT partial object to update properties of the NFT.
+   * @param selectedAddress - Hex address of the user account.
+   * @param chainId - Id of the current network.
+   */
+  updateNft(nft, updates, selectedAddress, chainId) {
+    const { allNfts } = this.state;
+    const nfts = allNfts[selectedAddress]?.[chainId] || [];
+    const nftInfo = this.findNftByAddressAndTokenId(
+      nft.address,
+      nft.tokenId,
+      selectedAddress,
+      chainId
+    );
+    if (!nftInfo) {
+      return;
+    }
+    const updatedNft = {
+      ...nft,
+      ...updates
+    };
+    const newNfts = [
+      ...nfts.slice(0, nftInfo.index),
+      updatedNft,
+      ...nfts.slice(nftInfo.index + 1)
+    ];
+    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {
+      chainId,
+      userAddress: selectedAddress
+    });
+  }
+  /**
+   * Resets the transaction status of an NFT.
+   *
+   * @param transactionId - NFT transaction id.
+   * @param selectedAddress - Hex address of the user account.
+   * @param chainId - Id of the current network.
+   * @returns a boolean indicating if the reset was well succeeded or not
+   */
+  resetNftTransactionStatusByTransactionId(transactionId, selectedAddress, chainId) {
+    const { allNfts } = this.state;
+    const nfts = allNfts[selectedAddress]?.[chainId] || [];
+    const index = nfts.findIndex(
+      (nft) => nft.transactionId === transactionId
+    );
+    if (index === -1) {
+      return false;
+    }
+    const updatedNft = {
+      ...nfts[index],
+      transactionId: void 0
+    };
+    const newNfts = [
+      ...nfts.slice(0, index),
+      updatedNft,
+      ...nfts.slice(index + 1)
+    ];
+    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {
+      chainId,
+      userAddress: selectedAddress
+    });
+    return true;
+  }
+  async _requestApproval(suggestedNftMeta) {
+    return this.messagingSystem.call(
+      "ApprovalController:addRequest",
+      {
+        id: suggestedNftMeta.id,
+        origin: suggestedNftMeta.origin,
+        type: _controllerutils.ApprovalType.WatchAsset,
+        requestData: {
+          id: suggestedNftMeta.id,
+          interactingAddress: suggestedNftMeta.interactingAddress,
+          asset: {
+            address: suggestedNftMeta.asset.address,
+            tokenId: suggestedNftMeta.asset.tokenId,
+            name: suggestedNftMeta.asset.name,
+            description: suggestedNftMeta.asset.description,
+            image: suggestedNftMeta.asset.image,
+            standard: suggestedNftMeta.asset.standard
+          }
+        }
+      },
+      true
+    );
+  }
+};
+var NftController_default = NftController;
+
+
+
+
+
+
+exports.OpenSeaV2ChainIds = OpenSeaV2ChainIds; exports.getDefaultNftState = getDefaultNftState; exports.NftController = NftController; exports.NftController_default = NftController_default;
+//# sourceMappingURL=chunk-CNGRNK6N.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-CNGRNK6N.js.map b/node_modules/@metamask/assets-controllers/dist/chunk-CNGRNK6N.js.map
new file mode 100644
index 0000000..bb17020
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-CNGRNK6N.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/NftController.ts"],"names":["OpenSeaV2ChainIds"],"mappings":"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","sourcesContent":["import { isAddress } from '@ethersproject/address';\nimport type { AddApprovalRequest } from '@metamask/approval-controller';\nimport type {\n  BaseConfig,\n  BaseState,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport { BaseControllerV1 } from '@metamask/base-controller';\nimport {\n  safelyExecute,\n  handleFetch,\n  toChecksumHexAddress,\n  BNToHex,\n  fetchWithErrorHandling,\n  IPFS_DEFAULT_GATEWAY_URL,\n  ERC721,\n  ERC1155,\n  OPENSEA_PROXY_URL,\n  ApprovalType,\n} from '@metamask/controller-utils';\nimport type {\n  NetworkClientId,\n  NetworkController,\n  NetworkState,\n} from '@metamask/network-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type { Hex } from '@metamask/utils';\nimport { remove0x } from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\nimport BN from 'bn.js';\nimport { EventEmitter } from 'events';\nimport { v4 as random } from 'uuid';\n\nimport type { AssetsContractController } from './AssetsContractController';\nimport {\n  compareNftMetadata,\n  getFormattedIpfsUrl,\n  mapOpenSeaContractV2ToV1,\n  mapOpenSeaDetailedNftV2ToV1,\n} from './assetsUtil';\nimport { Source } from './constants';\nimport type {\n  ApiNftCreator,\n  ApiNftContract,\n  ApiNftLastSale,\n} from './NftDetectionController';\n\ntype NFTStandardType = 'ERC721' | 'ERC1155';\n\ntype SuggestedNftMeta = {\n  asset: { address: string; tokenId: string } & NftMetadata;\n  id: string;\n  time: number;\n  type: NFTStandardType;\n  interactingAddress: string;\n  origin: string;\n};\n\nexport enum OpenSeaV2ChainIds {\n  ethereum = 'ethereum',\n}\n\nexport type OpenSeaV2GetNftResponse = { nft: OpenSeaV2DetailedNft };\n\nexport type OpenSeaV2Nft = {\n  identifier: string;\n  collection: string;\n  contract: string;\n  token_standard: string;\n  name: string;\n  description: string;\n  image_url?: string;\n  metadata_url?: string;\n  updated_at: string;\n  is_disabled: boolean;\n  is_nsfw: boolean;\n};\n\nexport type OpenSeaV2DetailedNft = OpenSeaV2Nft & {\n  animation_url?: string;\n  is_suspicious: boolean;\n  creator: string;\n  traits: {\n    trait_type: string;\n    display_type?: string;\n    max_value: string;\n    trait_count?: number;\n    value: number | string;\n  }[];\n  owners: {\n    address: string;\n    quantity: number;\n  }[];\n  rarity: { rank: number };\n};\n\nexport type OpenSeaV2ListNftsResponse = {\n  nfts: OpenSeaV2Nft[];\n  next?: string;\n};\n\nexport type OpenSeaV2Contract = {\n  address: string;\n  chain: string;\n  collection: string;\n  contract_standard: string;\n  name: string;\n  total_supply?: number;\n};\n\nexport type OpenSeaV2Collection = {\n  collection: string;\n  name: string;\n  description?: string;\n  image_url?: string;\n  owner: string;\n  category: string;\n  is_disabled: boolean;\n  is_nsfw: boolean;\n  trait_offers_enabled: boolean;\n  opensea_url: string;\n  project_url?: string;\n  wiki_url?: string;\n  discord_url?: string;\n  telegram_url?: string;\n  twitter_username?: string;\n  instagram_username?: string;\n  total_supply?: number;\n};\n\n/**\n * @type Nft\n *\n * NFT representation\n * @property address - Hex address of a ERC721 contract\n * @property description - The NFT description\n * @property image - URI of custom NFT image associated with this tokenId\n * @property name - Name associated with this tokenId and contract address\n * @property tokenId - The NFT identifier\n * @property numberOfSales - Number of sales\n * @property backgroundColor - The background color to be displayed with the item\n * @property imagePreview - URI of a smaller image associated with this NFT\n * @property imageThumbnail - URI of a thumbnail image associated with this NFT\n * @property imageOriginal - URI of the original image associated with this NFT\n * @property animation - URI of a animation associated with this NFT\n * @property animationOriginal - URI of the original animation associated with this NFT\n * @property externalLink - External link containing additional information\n * @property creator - The NFT owner information object\n * @property isCurrentlyOwned - Boolean indicating whether the address/chainId combination where it's currently stored currently owns this NFT\n * @property transactionId - Transaction Id associated with the NFT\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface Nft extends NftMetadata {\n  tokenId: string;\n  address: string;\n  isCurrentlyOwned?: boolean;\n}\n\ntype NftUpdate = {\n  nft: Nft;\n  newMetadata: NftMetadata;\n};\n\n/**\n * @type NftContract\n *\n * NFT contract information representation\n * @property name - Contract name\n * @property logo - Contract logo\n * @property address - Contract address\n * @property symbol - Contract symbol\n * @property description - Contract description\n * @property totalSupply - Total supply of NFTs\n * @property assetContractType - The NFT type, it could be `semi-fungible` or `non-fungible`\n * @property createdDate - Creation date\n * @property schemaName - The schema followed by the contract, it could be `ERC721` or `ERC1155`\n * @property externalLink - External link containing additional information\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface NftContract {\n  name?: string;\n  logo?: string;\n  address: string;\n  symbol?: string;\n  description?: string;\n  totalSupply?: string;\n  assetContractType?: string;\n  createdDate?: string;\n  schemaName?: string;\n  externalLink?: string;\n}\n\n/**\n * @type NftMetadata\n *\n * NFT custom information\n * @property name - NFT custom name\n * @property description - The NFT description\n * @property numberOfSales - Number of sales\n * @property backgroundColor - The background color to be displayed with the item\n * @property image - Image custom image URI\n * @property imagePreview - URI of a smaller image associated with this NFT\n * @property imageThumbnail - URI of a thumbnail image associated with this NFT\n * @property imageOriginal - URI of the original image associated with this NFT\n * @property animation - URI of a animation associated with this NFT\n * @property animationOriginal - URI of the original animation associated with this NFT\n * @property externalLink - External link containing additional information\n * @property creator - The NFT owner information object\n * @property standard - NFT standard name for the NFT, e.g., ERC-721 or ERC-1155\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface NftMetadata {\n  name: string | null;\n  description: string | null;\n  image: string | null;\n  standard: string | null;\n  favorite?: boolean;\n  numberOfSales?: number;\n  backgroundColor?: string;\n  imagePreview?: string;\n  imageThumbnail?: string;\n  imageOriginal?: string;\n  animation?: string;\n  animationOriginal?: string;\n  externalLink?: string;\n  creator?: ApiNftCreator;\n  lastSale?: ApiNftLastSale;\n  transactionId?: string;\n  tokenURI?: string | null;\n}\n\n/**\n * @type NftConfig\n *\n * NFT controller configuration\n * @property selectedAddress - Vault selected address\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface NftConfig extends BaseConfig {\n  selectedAddress: string;\n  chainId: Hex;\n  ipfsGateway: string;\n  openSeaEnabled: boolean;\n  useIPFSSubdomains: boolean;\n  isIpfsGatewayEnabled: boolean;\n}\n\n/**\n * @type NftState\n *\n * NFT controller state\n * @property allNftContracts - Object containing NFT contract information\n * @property allNfts - Object containing NFTs per account and network\n * @property ignoredNfts - List of NFTs that should be ignored\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface NftState extends BaseState {\n  allNftContracts: {\n    [key: string]: { [chainId: Hex]: NftContract[] };\n  };\n  allNfts: { [key: string]: { [chainId: Hex]: Nft[] } };\n  ignoredNfts: Nft[];\n}\n\nconst ALL_NFTS_STATE_KEY = 'allNfts';\nconst ALL_NFTS_CONTRACTS_STATE_KEY = 'allNftContracts';\n\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\ninterface NftAsset {\n  address: string;\n  tokenId: string;\n}\n\n/**\n * The name of the {@link NftController}.\n */\nconst controllerName = 'NftController';\n\n/**\n * The external actions available to the {@link NftController}.\n */\ntype AllowedActions = AddApprovalRequest;\n\n/**\n * The messenger of the {@link NftController}.\n */\nexport type NftControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  AllowedActions,\n  never,\n  AllowedActions['type'],\n  never\n>;\n\nexport const getDefaultNftState = (): NftState => {\n  return {\n    allNftContracts: {},\n    allNfts: {},\n    ignoredNfts: [],\n  };\n};\n\n/**\n * Controller that stores assets and exposes convenience methods\n */\nexport class NftController extends BaseControllerV1<NftConfig, NftState> {\n  private readonly mutex = new Mutex();\n\n  private readonly messagingSystem: NftControllerMessenger;\n\n  getNftApi({\n    contractAddress,\n    tokenId,\n  }: {\n    contractAddress: string;\n    tokenId: string;\n  }) {\n    return `${OPENSEA_PROXY_URL}/chain/${OpenSeaV2ChainIds.ethereum}/contract/${contractAddress}/nfts/${tokenId}`;\n  }\n\n  private getNftContractInformationApi({\n    contractAddress,\n  }: {\n    contractAddress: string;\n  }) {\n    return `${OPENSEA_PROXY_URL}/chain/${OpenSeaV2ChainIds.ethereum}/contract/${contractAddress}`;\n  }\n\n  private getNftCollectionInformationApi({\n    collectionSlug,\n  }: {\n    collectionSlug: string;\n  }) {\n    return `${OPENSEA_PROXY_URL}/collections/${collectionSlug}`;\n  }\n\n  /**\n   * Helper method to update nested state for allNfts and allNftContracts.\n   *\n   * @param newCollection - the modified piece of state to update in the controller's store\n   * @param baseStateKey - The root key in the store to update.\n   * @param passedConfig - An object containing the selectedAddress and chainId that are passed through the auto-detection flow.\n   * @param passedConfig.userAddress - the address passed through the NFT detection flow to ensure assets are stored to the correct account\n   * @param passedConfig.chainId - the chainId passed through the NFT detection flow to ensure assets are stored to the correct account\n   */\n  private updateNestedNftState(\n    newCollection: Nft[] | NftContract[],\n    baseStateKey: 'allNfts' | 'allNftContracts',\n    { userAddress, chainId }: { userAddress: string; chainId: Hex },\n  ) {\n    const { [baseStateKey]: oldState } = this.state;\n\n    const addressState = oldState[userAddress];\n    const newAddressState = {\n      ...addressState,\n      ...{ [chainId]: newCollection },\n    };\n    const newState = {\n      ...oldState,\n      ...{ [userAddress]: newAddressState },\n    };\n\n    this.update({\n      [baseStateKey]: newState,\n    });\n  }\n\n  /**\n   * Request individual NFT information from OpenSea API.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftInformationFromApi(\n    contractAddress: string,\n    tokenId: string,\n  ): Promise<NftMetadata> {\n    // TODO Parameterize this by chainId for non-mainnet token detection\n    // Attempt to fetch the data with the proxy\n    const nftInformation: OpenSeaV2GetNftResponse | undefined =\n      await fetchWithErrorHandling({\n        url: this.getNftApi({\n          contractAddress,\n          tokenId,\n        }),\n      });\n\n    // if we were still unable to fetch the data we return out the default/null of `NftMetadata`\n    if (!nftInformation?.nft) {\n      return {\n        name: null,\n        description: null,\n        image: null,\n        standard: null,\n      };\n    }\n\n    // if we've reached this point, we have successfully fetched some data for nftInformation\n    // now we reconfigure the data to conform to the `NftMetadata` type for storage.\n    const {\n      num_sales,\n      background_color,\n      image_url,\n      image_preview_url,\n      image_thumbnail_url,\n      image_original_url,\n      animation_url,\n      animation_original_url,\n      name,\n      description,\n      external_link,\n      creator,\n      last_sale,\n      asset_contract: { schema_name },\n    } = mapOpenSeaDetailedNftV2ToV1(nftInformation.nft);\n\n    /* istanbul ignore next */\n    const nftMetadata: NftMetadata = Object.assign(\n      {},\n      { name: name || null },\n      { description: description || null },\n      { image: image_url || null },\n      creator && { creator },\n      num_sales && { numberOfSales: num_sales },\n      background_color && { backgroundColor: background_color },\n      image_preview_url && { imagePreview: image_preview_url },\n      image_thumbnail_url && { imageThumbnail: image_thumbnail_url },\n      image_original_url && { imageOriginal: image_original_url },\n      animation_url && { animation: animation_url },\n      animation_original_url && {\n        animationOriginal: animation_original_url,\n      },\n      external_link && { externalLink: external_link },\n      last_sale && { lastSale: last_sale },\n      schema_name && { standard: schema_name },\n    );\n\n    return nftMetadata;\n  }\n\n  /**\n   * Request individual NFT information from contracts that follows Metadata Interface.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftInformationFromTokenURI(\n    contractAddress: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<NftMetadata> {\n    const { ipfsGateway, useIPFSSubdomains, isIpfsGatewayEnabled } =\n      this.config;\n    const result = await this.getNftURIAndStandard(\n      contractAddress,\n      tokenId,\n      networkClientId,\n    );\n    let tokenURI = result[0];\n    const standard = result[1];\n\n    const hasIpfsTokenURI = tokenURI.startsWith('ipfs://');\n\n    if (hasIpfsTokenURI && !isIpfsGatewayEnabled) {\n      return {\n        image: null,\n        name: null,\n        description: null,\n        standard: standard || null,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    }\n\n    const isDisplayNFTMediaToggleEnabled = this.config.openSeaEnabled;\n    if (!hasIpfsTokenURI && !isDisplayNFTMediaToggleEnabled) {\n      return {\n        image: null,\n        name: null,\n        description: null,\n        standard: standard || null,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    }\n\n    if (hasIpfsTokenURI) {\n      tokenURI = getFormattedIpfsUrl(ipfsGateway, tokenURI, useIPFSSubdomains);\n    }\n\n    try {\n      const object = await handleFetch(tokenURI);\n      // TODO: Check image_url existence. This is not part of EIP721 nor EIP1155\n      const image = Object.prototype.hasOwnProperty.call(object, 'image')\n        ? 'image'\n        : /* istanbul ignore next */ 'image_url';\n\n      return {\n        image: object[image],\n        name: object.name,\n        description: object.description,\n        standard,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    } catch {\n      return {\n        image: null,\n        name: null,\n        description: null,\n        standard: standard || null,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    }\n  }\n\n  /**\n   * Retrieve NFT uri with  metadata. TODO Update method to use IPFS.\n   *\n   * @param contractAddress - NFT contract address.\n   * @param tokenId - NFT token id.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving NFT uri and token standard.\n   */\n  private async getNftURIAndStandard(\n    contractAddress: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<[string, string]> {\n    // try ERC721 uri\n    try {\n      const uri = await this.getERC721TokenURI(\n        contractAddress,\n        tokenId,\n        networkClientId,\n      );\n      return [uri, ERC721];\n    } catch {\n      // Ignore error\n    }\n\n    // try ERC1155 uri\n    try {\n      const tokenURI = await this.getERC1155TokenURI(\n        contractAddress,\n        tokenId,\n        networkClientId,\n      );\n\n      /**\n       * According to EIP1155 the URI value allows for ID substitution\n       * in case the string `{id}` exists.\n       * https://eips.ethereum.org/EIPS/eip-1155#metadata\n       */\n\n      if (!tokenURI.includes('{id}')) {\n        return [tokenURI, ERC1155];\n      }\n\n      const hexTokenId = remove0x(BNToHex(new BN(tokenId)))\n        .padStart(64, '0')\n        .toLowerCase();\n      return [tokenURI.replace('{id}', hexTokenId), ERC1155];\n    } catch {\n      // Ignore error\n    }\n\n    return ['', ''];\n  }\n\n  /**\n   * Request individual NFT information (name, image url and description).\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftInformation(\n    contractAddress: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<NftMetadata> {\n    const chainId = this.getCorrectChainId({\n      networkClientId,\n    });\n\n    const [blockchainMetadata, openSeaMetadata] = await Promise.all([\n      safelyExecute(() =>\n        this.getNftInformationFromTokenURI(\n          contractAddress,\n          tokenId,\n          networkClientId,\n        ),\n      ),\n      this.config.openSeaEnabled && chainId === '0x1'\n        ? safelyExecute(() =>\n            this.getNftInformationFromApi(contractAddress, tokenId),\n          )\n        : undefined,\n    ]);\n\n    return {\n      ...openSeaMetadata,\n      name: blockchainMetadata?.name ?? openSeaMetadata?.name ?? null,\n      description:\n        blockchainMetadata?.description ?? openSeaMetadata?.description ?? null,\n      image: blockchainMetadata?.image ?? openSeaMetadata?.image ?? null,\n      standard:\n        blockchainMetadata?.standard ?? openSeaMetadata?.standard ?? null,\n      tokenURI: blockchainMetadata?.tokenURI ?? null,\n    };\n  }\n\n  /**\n   * Request NFT contract information from OpenSea API.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftContractInformationFromApi(\n    contractAddress: string,\n  ): Promise<ApiNftContract> {\n    /* istanbul ignore if */\n    const apiNftContractObject: OpenSeaV2Contract | undefined =\n      await fetchWithErrorHandling({\n        url: this.getNftContractInformationApi({\n          contractAddress,\n        }),\n      });\n\n    // If we successfully fetched the contract\n    if (apiNftContractObject) {\n      // Then fetch some additional details from the collection\n      const collection: OpenSeaV2Collection | undefined =\n        await fetchWithErrorHandling({\n          url: this.getNftCollectionInformationApi({\n            collectionSlug: apiNftContractObject.collection,\n          }),\n        });\n\n      return mapOpenSeaContractV2ToV1(apiNftContractObject, collection);\n    }\n\n    // If we've reached this point we were unable to fetch data from either the proxy or opensea so we return\n    // the default/null of ApiNftContract\n    return {\n      address: contractAddress,\n      asset_contract_type: null,\n      created_date: null,\n      schema_name: null,\n      symbol: null,\n      total_supply: null,\n      description: null,\n      external_link: null,\n      collection: {\n        name: null,\n        image_url: null,\n      },\n    };\n  }\n\n  /**\n   * Request NFT contract information from the contract itself.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftContractInformationFromContract(\n    contractAddress: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<\n    Partial<ApiNftContract> &\n      Pick<ApiNftContract, 'address'> &\n      Pick<ApiNftContract, 'collection'>\n  > {\n    const [name, symbol] = await Promise.all([\n      this.getERC721AssetName(contractAddress, networkClientId),\n      this.getERC721AssetSymbol(contractAddress, networkClientId),\n    ]);\n\n    return {\n      collection: { name },\n      symbol,\n      address: contractAddress,\n    };\n  }\n\n  /**\n   * Request NFT contract information from OpenSea API.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the NFT contract name, image and description.\n   */\n  private async getNftContractInformation(\n    contractAddress: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<\n    Partial<ApiNftContract> &\n      Pick<ApiNftContract, 'address'> &\n      Pick<ApiNftContract, 'collection'>\n  > {\n    const chainId = this.getCorrectChainId({\n      networkClientId,\n    });\n\n    const [blockchainContractData, openSeaContractData] = await Promise.all([\n      safelyExecute(() =>\n        this.getNftContractInformationFromContract(\n          contractAddress,\n          networkClientId,\n        ),\n      ),\n      this.config.openSeaEnabled && chainId === '0x1'\n        ? safelyExecute(() =>\n            this.getNftContractInformationFromApi(contractAddress),\n          )\n        : undefined,\n    ]);\n\n    if (blockchainContractData || openSeaContractData) {\n      return {\n        address: contractAddress,\n        ...openSeaContractData,\n        ...blockchainContractData,\n        collection: {\n          name: null,\n          image_url: null,\n          ...openSeaContractData?.collection,\n          ...blockchainContractData?.collection,\n        },\n      };\n    }\n\n    /* istanbul ignore next */\n    return {\n      address: contractAddress,\n      asset_contract_type: null,\n      created_date: null,\n      schema_name: null,\n      symbol: null,\n      total_supply: null,\n      description: null,\n      external_link: null,\n      collection: { name: null, image_url: null },\n    };\n  }\n\n  /**\n   * Adds an individual NFT to the stored NFT list.\n   *\n   * @param tokenAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param nftMetadata - NFT optional information (name, image and description).\n   * @param nftContract - An object containing contract data of the NFT being added.\n   * @param chainId - The chainId of the network where the NFT is being added.\n   * @param userAddress - The address of the account where the NFT is being added.\n   * @param source - Whether the NFT was detected, added manually or suggested by a dapp.\n   * @returns Promise resolving to the current NFT list.\n   */\n  private async addIndividualNft(\n    tokenAddress: string,\n    tokenId: string,\n    nftMetadata: NftMetadata,\n    nftContract: NftContract,\n    chainId: Hex,\n    userAddress: string,\n    source: Source,\n  ): Promise<Nft[]> {\n    // TODO: Remove unused return\n    const releaseLock = await this.mutex.acquire();\n    try {\n      tokenAddress = toChecksumHexAddress(tokenAddress);\n      const { allNfts } = this.state;\n\n      const nfts = allNfts[userAddress]?.[chainId] || [];\n\n      const existingEntry: Nft | undefined = nfts.find(\n        (nft) =>\n          nft.address.toLowerCase() === tokenAddress.toLowerCase() &&\n          nft.tokenId === tokenId,\n      );\n\n      if (existingEntry) {\n        const differentMetadata = compareNftMetadata(\n          nftMetadata,\n          existingEntry,\n        );\n        if (differentMetadata || !existingEntry.isCurrentlyOwned) {\n          // TODO: Switch to indexToUpdate\n          const indexToRemove = nfts.findIndex(\n            (nft) =>\n              nft.address.toLowerCase() === tokenAddress.toLowerCase() &&\n              nft.tokenId === tokenId,\n          );\n          /* istanbul ignore next */\n          if (indexToRemove !== -1) {\n            nfts.splice(indexToRemove, 1);\n          }\n        } else {\n          return nfts;\n        }\n      }\n\n      const newEntry: Nft = {\n        address: tokenAddress,\n        tokenId,\n        favorite: existingEntry?.favorite || false,\n        isCurrentlyOwned: true,\n        ...nftMetadata,\n      };\n\n      const newNfts = [...nfts, newEntry];\n      this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n        chainId,\n        userAddress,\n      });\n\n      if (this.onNftAdded) {\n        this.onNftAdded({\n          address: tokenAddress,\n          symbol: nftContract.symbol,\n          tokenId: tokenId.toString(),\n          standard: nftMetadata.standard,\n          source,\n        });\n      }\n      return newNfts;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Adds an NFT contract to the stored NFT contracts list.\n   *\n   * @param options - options.\n   * @param options.tokenAddress - Hex address of the NFT contract.\n   * @param options.userAddress - The address of the account where the NFT is being added.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.\n   * @returns Promise resolving to the current NFT contracts list.\n   */\n  private async addNftContract({\n    tokenAddress,\n    userAddress,\n    networkClientId,\n    source,\n  }: {\n    tokenAddress: string;\n    userAddress: string;\n    networkClientId?: NetworkClientId;\n    source?: Source;\n  }): Promise<NftContract[]> {\n    const releaseLock = await this.mutex.acquire();\n    try {\n      tokenAddress = toChecksumHexAddress(tokenAddress);\n      const { allNftContracts } = this.state;\n      const chainId = this.getCorrectChainId({\n        networkClientId,\n      });\n\n      const nftContracts = allNftContracts[userAddress]?.[chainId] || [];\n\n      const existingEntry = nftContracts.find(\n        (nftContract) =>\n          nftContract.address.toLowerCase() === tokenAddress.toLowerCase(),\n      );\n      if (existingEntry) {\n        return nftContracts;\n      }\n\n      // this doesn't work currently for detection if the user switches networks while the detection is processing\n      // will be fixed once detection uses networkClientIds\n      const contractInformation = await this.getNftContractInformation(\n        tokenAddress,\n        networkClientId,\n      );\n      const {\n        asset_contract_type,\n        created_date,\n        schema_name,\n        symbol,\n        total_supply,\n        description,\n        external_link,\n        collection: { name, image_url },\n      } = contractInformation;\n\n      // If the nft is auto-detected we want some valid metadata to be present\n      if (\n        source === Source.Detected &&\n        'address' in contractInformation &&\n        typeof contractInformation.address === 'string' &&\n        'collection' in contractInformation &&\n        contractInformation.collection.name === null &&\n        'image_url' in contractInformation.collection &&\n        contractInformation.collection.image_url === null &&\n        Object.entries(contractInformation).every(([key, value]) => {\n          return key === 'address' || key === 'collection' || !value;\n        })\n      ) {\n        return nftContracts;\n      }\n\n      /* istanbul ignore next */\n      const newEntry: NftContract = Object.assign(\n        {},\n        { address: tokenAddress },\n        description && { description },\n        name && { name },\n        image_url && { logo: image_url },\n        symbol && { symbol },\n        total_supply !== null &&\n          typeof total_supply !== 'undefined' && { totalSupply: total_supply },\n        asset_contract_type && { assetContractType: asset_contract_type },\n        created_date && { createdDate: created_date },\n        schema_name && { schemaName: schema_name },\n        external_link && { externalLink: external_link },\n      );\n      const newNftContracts = [...nftContracts, newEntry];\n      this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY, {\n        chainId,\n        userAddress,\n      });\n\n      return newNftContracts;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Removes an individual NFT from the stored token list and saves it in ignored NFTs list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   * @param options - options.\n   * @param options.chainId - The chainId of the network where the NFT is being removed.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   */\n  private removeAndIgnoreIndividualNft(\n    address: string,\n    tokenId: string,\n    {\n      chainId,\n      userAddress,\n    }: {\n      chainId: Hex;\n      userAddress: string;\n    },\n  ) {\n    address = toChecksumHexAddress(address);\n    const { allNfts, ignoredNfts } = this.state;\n    const newIgnoredNfts = [...ignoredNfts];\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const newNfts = nfts.filter((nft) => {\n      if (\n        nft.address.toLowerCase() === address.toLowerCase() &&\n        nft.tokenId === tokenId\n      ) {\n        const alreadyIgnored = newIgnoredNfts.find(\n          (c) => c.address === address && c.tokenId === tokenId,\n        );\n        !alreadyIgnored && newIgnoredNfts.push(nft);\n        return false;\n      }\n      return true;\n    });\n\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n      userAddress,\n      chainId,\n    });\n\n    this.update({\n      ignoredNfts: newIgnoredNfts,\n    });\n  }\n\n  /**\n   * Removes an individual NFT from the stored token list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   * @param options - options.\n   * @param options.chainId - The chainId of the network where the NFT is being removed.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   */\n  private removeIndividualNft(\n    address: string,\n    tokenId: string,\n    { chainId, userAddress }: { chainId: Hex; userAddress: string },\n  ) {\n    address = toChecksumHexAddress(address);\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const newNfts = nfts.filter(\n      (nft) =>\n        !(\n          nft.address.toLowerCase() === address.toLowerCase() &&\n          nft.tokenId === tokenId\n        ),\n    );\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n      userAddress,\n      chainId,\n    });\n  }\n\n  /**\n   * Removes an NFT contract to the stored NFT contracts list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param options - options.\n   * @param options.chainId - The chainId of the network where the NFT is being removed.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   * @returns Promise resolving to the current NFT contracts list.\n   */\n  private removeNftContract(\n    address: string,\n    { chainId, userAddress }: { chainId: Hex; userAddress: string },\n  ): NftContract[] {\n    address = toChecksumHexAddress(address);\n    const { allNftContracts } = this.state;\n    const nftContracts = allNftContracts[userAddress]?.[chainId] || [];\n\n    const newNftContracts = nftContracts.filter(\n      (nftContract) =>\n        !(nftContract.address.toLowerCase() === address.toLowerCase()),\n    );\n    this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY, {\n      chainId,\n      userAddress,\n    });\n\n    return newNftContracts;\n  }\n\n  /**\n   * EventEmitter instance used to listen to specific EIP747 events\n   */\n  hub = new EventEmitter();\n\n  /**\n   * Optional API key to use with opensea\n   */\n  openSeaApiKey?: string;\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'NftController';\n\n  private readonly getERC721AssetName: AssetsContractController['getERC721AssetName'];\n\n  private readonly getERC721AssetSymbol: AssetsContractController['getERC721AssetSymbol'];\n\n  private readonly getERC721TokenURI: AssetsContractController['getERC721TokenURI'];\n\n  private readonly getERC721OwnerOf: AssetsContractController['getERC721OwnerOf'];\n\n  private readonly getERC1155BalanceOf: AssetsContractController['getERC1155BalanceOf'];\n\n  private readonly getERC1155TokenURI: AssetsContractController['getERC1155TokenURI'];\n\n  private readonly getNetworkClientById: NetworkController['getNetworkClientById'];\n\n  private readonly onNftAdded?: (data: {\n    address: string;\n    symbol: string | undefined;\n    tokenId: string;\n    standard: string | null;\n    source: Source;\n  }) => void;\n\n  /**\n   * Creates an NftController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param options.getERC721AssetName - Gets the name of the asset at the given address.\n   * @param options.getERC721AssetSymbol - Gets the symbol of the asset at the given address.\n   * @param options.getERC721TokenURI - Gets the URI of the ERC721 token at the given address, with the given ID.\n   * @param options.getERC721OwnerOf - Get the owner of a ERC-721 NFT.\n   * @param options.getERC1155BalanceOf - Gets balance of a ERC-1155 NFT.\n   * @param options.getERC1155TokenURI - Gets the URI of the ERC1155 token at the given address, with the given ID.\n   * @param options.getNetworkClientById - Gets the network client for the given networkClientId.\n   * @param options.onNftAdded - Callback that is called when an NFT is added. Currently used pass data\n   * for tracking the NFT added event.\n   * @param options.messenger - The controller messenger.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      chainId: initialChainId,\n      onPreferencesStateChange,\n      onNetworkStateChange,\n      getERC721AssetName,\n      getERC721AssetSymbol,\n      getERC721TokenURI,\n      getERC721OwnerOf,\n      getERC1155BalanceOf,\n      getERC1155TokenURI,\n      getNetworkClientById,\n      onNftAdded,\n      messenger,\n    }: {\n      chainId: Hex;\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      getERC721AssetName: AssetsContractController['getERC721AssetName'];\n      getERC721AssetSymbol: AssetsContractController['getERC721AssetSymbol'];\n      getERC721TokenURI: AssetsContractController['getERC721TokenURI'];\n      getERC721OwnerOf: AssetsContractController['getERC721OwnerOf'];\n      getERC1155BalanceOf: AssetsContractController['getERC1155BalanceOf'];\n      getERC1155TokenURI: AssetsContractController['getERC1155TokenURI'];\n      getNetworkClientById: NetworkController['getNetworkClientById'];\n      onNftAdded?: (data: {\n        address: string;\n        symbol: string | undefined;\n        tokenId: string;\n        standard: string | null;\n        source: string;\n      }) => void;\n      messenger: NftControllerMessenger;\n    },\n    config?: Partial<BaseConfig>,\n    state?: Partial<NftState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      selectedAddress: '',\n      chainId: initialChainId,\n      ipfsGateway: IPFS_DEFAULT_GATEWAY_URL,\n      openSeaEnabled: false,\n      useIPFSSubdomains: true,\n      isIpfsGatewayEnabled: true,\n    };\n\n    this.defaultState = getDefaultNftState();\n    this.initialize();\n    this.getERC721AssetName = getERC721AssetName;\n    this.getERC721AssetSymbol = getERC721AssetSymbol;\n    this.getERC721TokenURI = getERC721TokenURI;\n    this.getERC721OwnerOf = getERC721OwnerOf;\n    this.getERC1155BalanceOf = getERC1155BalanceOf;\n    this.getERC1155TokenURI = getERC1155TokenURI;\n    this.getNetworkClientById = getNetworkClientById;\n    this.onNftAdded = onNftAdded;\n    this.messagingSystem = messenger;\n\n    onPreferencesStateChange(\n      ({\n        selectedAddress,\n        ipfsGateway,\n        openSeaEnabled,\n        isIpfsGatewayEnabled,\n      }) => {\n        this.configure({\n          selectedAddress,\n          ipfsGateway,\n          openSeaEnabled,\n          isIpfsGatewayEnabled,\n        });\n\n        const needsUpdateNftMetadata =\n          (isIpfsGatewayEnabled && ipfsGateway !== '') || openSeaEnabled;\n\n        if (needsUpdateNftMetadata) {\n          this.updateNftMetadata({ userAddress: selectedAddress });\n        }\n      },\n    );\n\n    onNetworkStateChange(({ providerConfig }) => {\n      const { chainId } = providerConfig;\n      this.configure({ chainId });\n    });\n  }\n\n  private async validateWatchNft(\n    asset: NftAsset,\n    type: NFTStandardType,\n    userAddress: string,\n    { networkClientId }: { networkClientId?: NetworkClientId } = {},\n  ) {\n    const { address: contractAddress, tokenId } = asset;\n\n    // Validate parameters\n    if (!type) {\n      throw rpcErrors.invalidParams('Asset type is required');\n    }\n\n    if (type !== ERC721 && type !== ERC1155) {\n      throw rpcErrors.invalidParams(\n        `Non NFT asset type ${type} not supported by watchNft`,\n      );\n    }\n\n    if (!contractAddress || !tokenId) {\n      throw rpcErrors.invalidParams('Both address and tokenId are required');\n    }\n\n    if (!isAddress(contractAddress)) {\n      throw rpcErrors.invalidParams('Invalid address');\n    }\n\n    if (!/^\\d+$/u.test(tokenId)) {\n      throw rpcErrors.invalidParams('Invalid tokenId');\n    }\n\n    // Check if the user owns the suggested NFT\n    try {\n      const isOwner = await this.isNftOwner(\n        userAddress,\n        contractAddress,\n        tokenId,\n        { networkClientId },\n      );\n      if (!isOwner) {\n        throw rpcErrors.invalidInput(\n          'Suggested NFT is not owned by the selected account',\n        );\n      }\n    } catch (error) {\n      // error thrown here: \"Unable to verify ownership. Possibly because the standard is not supported or the user's currently selected network does not match the chain of the asset in question.\"\n      if (error instanceof Error) {\n        throw rpcErrors.resourceUnavailable(error.message);\n      }\n      throw error;\n    }\n  }\n\n  // temporary method to get the correct chainId until we remove chainId from the config & the chainId arg from the detection logic\n  // Just a helper method to prefer the networkClient chainId first then the chainId argument and then finally the config chainId\n  private getCorrectChainId({\n    networkClientId,\n  }: {\n    networkClientId?: NetworkClientId;\n  }) {\n    if (networkClientId) {\n      return this.getNetworkClientById(networkClientId).configuration.chainId;\n    }\n    return this.config.chainId;\n  }\n\n  /**\n   * Adds a new suggestedAsset to state. Parameters will be validated according to\n   * asset type being watched. A `<suggestedNftMeta.id>:pending` hub event will be emitted once added.\n   *\n   * @param asset - The asset to be watched. For now ERC721 and ERC1155 tokens are accepted.\n   * @param asset.address - The address of the asset contract.\n   * @param asset.tokenId - The ID of the asset.\n   * @param type - The asset type.\n   * @param origin - Domain origin to register the asset from.\n   * @param options - Options bag.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The address of the account where the NFT is being added.\n   * @returns Object containing a Promise resolving to the suggestedAsset address if accepted.\n   */\n  async watchNft(\n    asset: NftAsset,\n    type: NFTStandardType,\n    origin: string,\n    {\n      networkClientId,\n      userAddress = this.config.selectedAddress,\n    }: {\n      networkClientId?: NetworkClientId;\n      userAddress?: string;\n    } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    await this.validateWatchNft(asset, type, userAddress);\n\n    const nftMetadata = await this.getNftInformation(\n      asset.address,\n      asset.tokenId,\n      networkClientId,\n    );\n\n    if (nftMetadata.standard && nftMetadata.standard !== type) {\n      throw rpcErrors.invalidInput(\n        `Suggested NFT of type ${nftMetadata.standard} does not match received type ${type}`,\n      );\n    }\n\n    const suggestedNftMeta: SuggestedNftMeta = {\n      asset: { ...asset, ...nftMetadata },\n      type,\n      id: random(),\n      time: Date.now(),\n      interactingAddress: userAddress,\n      origin,\n    };\n    await this._requestApproval(suggestedNftMeta);\n    const { address, tokenId } = asset;\n    const { name, standard, description, image } = nftMetadata;\n\n    await this.addNft(address, tokenId, {\n      nftMetadata: {\n        name: name ?? null,\n        description: description ?? null,\n        image: image ?? null,\n        standard: standard ?? null,\n      },\n      userAddress,\n      source: Source.Dapp,\n      networkClientId,\n    });\n  }\n\n  /**\n   * Sets an OpenSea API key to retrieve NFT information.\n   *\n   * @param openSeaApiKey - OpenSea API key.\n   */\n  setApiKey(openSeaApiKey: string) {\n    this.openSeaApiKey = openSeaApiKey;\n  }\n\n  /**\n   * Checks the ownership of a ERC-721 or ERC-1155 NFT for a given address.\n   *\n   * @param ownerAddress - User public address.\n   * @param nftAddress - NFT contract address.\n   * @param tokenId - NFT token ID.\n   * @param options - Options bag.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving the NFT ownership.\n   */\n  async isNftOwner(\n    ownerAddress: string,\n    nftAddress: string,\n    tokenId: string,\n    {\n      networkClientId,\n    }: {\n      networkClientId?: NetworkClientId;\n    } = {},\n  ): Promise<boolean> {\n    // Checks the ownership for ERC-721.\n    try {\n      const owner = await this.getERC721OwnerOf(\n        nftAddress,\n        tokenId,\n        networkClientId,\n      );\n      return ownerAddress.toLowerCase() === owner.toLowerCase();\n      // eslint-disable-next-line no-empty\n    } catch {\n      // Ignore ERC-721 contract error\n    }\n\n    // Checks the ownership for ERC-1155.\n    try {\n      const balance = await this.getERC1155BalanceOf(\n        ownerAddress,\n        nftAddress,\n        tokenId,\n        networkClientId,\n      );\n      return !balance.isZero();\n      // eslint-disable-next-line no-empty\n    } catch {\n      // Ignore ERC-1155 contract error\n    }\n\n    throw new Error(\n      `Unable to verify ownership. Possibly because the standard is not supported or the user's currently selected network does not match the chain of the asset in question.`,\n    );\n  }\n\n  /**\n   * Verifies currently selected address owns entered NFT address/tokenId combo and\n   * adds the NFT and respective NFT contract to the stored NFT and NFT contracts lists.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param options - an object of arguments\n   * @param options.userAddress - The address of the current user.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.\n   */\n  async addNftVerifyOwnership(\n    address: string,\n    tokenId: string,\n    {\n      userAddress = this.config.selectedAddress,\n      networkClientId,\n      source,\n    }: {\n      userAddress?: string;\n      networkClientId?: NetworkClientId;\n      source?: Source;\n    } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    if (\n      !(await this.isNftOwner(userAddress, address, tokenId, {\n        networkClientId,\n      }))\n    ) {\n      throw new Error('This NFT is not owned by the user');\n    }\n    await this.addNft(address, tokenId, {\n      networkClientId,\n      userAddress,\n      source,\n    });\n  }\n\n  /**\n   * Adds an NFT and respective NFT contract to the stored NFT and NFT contracts lists.\n   *\n   * @param tokenAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param options - an object of arguments\n   * @param options.nftMetadata - NFT optional metadata.\n   * @param options.userAddress - The address of the current user.\n   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the current NFT list.\n   */\n  async addNft(\n    tokenAddress: string,\n    tokenId: string,\n    {\n      nftMetadata,\n      userAddress = this.config.selectedAddress,\n      source = Source.Custom,\n      networkClientId,\n    }: {\n      nftMetadata?: NftMetadata;\n      userAddress?: string;\n      source?: Source;\n      networkClientId?: NetworkClientId;\n    } = { userAddress: this.config.selectedAddress },\n  ) {\n    tokenAddress = toChecksumHexAddress(tokenAddress);\n\n    const chainId = this.getCorrectChainId({ networkClientId });\n    const newNftContracts = await this.addNftContract({\n      tokenAddress,\n      userAddress,\n      networkClientId,\n      source,\n    });\n\n    nftMetadata =\n      nftMetadata ||\n      (await this.getNftInformation(tokenAddress, tokenId, networkClientId));\n\n    // If NFT contract was not added, do not add individual NFT\n    const nftContract = newNftContracts.find(\n      (contract) =>\n        contract.address.toLowerCase() === tokenAddress.toLowerCase(),\n    );\n\n    // If NFT contract information, add individual NFT\n    if (nftContract) {\n      await this.addIndividualNft(\n        tokenAddress,\n        tokenId,\n        nftMetadata,\n        nftContract,\n        chainId,\n        userAddress,\n        source,\n      );\n    }\n  }\n\n  /**\n   * Refetches NFT metadata and updates the state\n   *\n   * @param options - Options for refetching NFT metadata\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The current user address\n   */\n  async updateNftMetadata({\n    userAddress = this.config.selectedAddress,\n    networkClientId,\n  }: {\n    userAddress?: string;\n    networkClientId?: NetworkClientId;\n  }) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n    const { allNfts } = this.state;\n    const nfts: Nft[] = allNfts[userAddress]?.[chainId] || [];\n    // We want to update only nfts missing name/image or description\n    const nftsToUpdate = nfts.filter(\n      (singleNft) =>\n        !singleNft.name && !singleNft.description && !singleNft.image,\n    );\n\n    const nftsWithChecksumAdr = nftsToUpdate.map((nft) => {\n      return {\n        ...nft,\n        address: toChecksumHexAddress(nft.address),\n      };\n    });\n    const nftMetadataResults = await Promise.allSettled(\n      nftsWithChecksumAdr.map(async (nft) => {\n        const resMetadata = await this.getNftInformation(\n          nft.address,\n          nft.tokenId,\n          networkClientId,\n        );\n        return {\n          nft,\n          newMetadata: resMetadata,\n        };\n      }),\n    );\n\n    nftMetadataResults\n      .filter(\n        (result): result is PromiseFulfilledResult<NftUpdate> =>\n          result.status === 'fulfilled',\n      )\n      .forEach((elm) =>\n        this.updateNft(\n          elm.value.nft,\n          elm.value.newMetadata,\n          userAddress,\n          chainId,\n        ),\n      );\n  }\n\n  /**\n   * Removes an NFT from the stored token list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   * @param options - an object of arguments\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   */\n  removeNft(\n    address: string,\n    tokenId: string,\n    {\n      networkClientId,\n      userAddress = this.config.selectedAddress,\n    }: { networkClientId?: NetworkClientId; userAddress?: string } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n    address = toChecksumHexAddress(address);\n    this.removeIndividualNft(address, tokenId, { chainId, userAddress });\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const remainingNft = nfts.find(\n      (nft) => nft.address.toLowerCase() === address.toLowerCase(),\n    );\n\n    if (!remainingNft) {\n      this.removeNftContract(address, { chainId, userAddress });\n    }\n  }\n\n  /**\n   * Removes an NFT from the stored token list and saves it in ignored NFTs list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   * @param options - an object of arguments\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   */\n  removeAndIgnoreNft(\n    address: string,\n    tokenId: string,\n    {\n      networkClientId,\n      userAddress = this.config.selectedAddress,\n    }: { networkClientId?: NetworkClientId; userAddress?: string } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n    address = toChecksumHexAddress(address);\n    this.removeAndIgnoreIndividualNft(address, tokenId, {\n      chainId,\n      userAddress,\n    });\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const remainingNft = nfts.find(\n      (nft) => nft.address.toLowerCase() === address.toLowerCase(),\n    );\n    if (!remainingNft) {\n      this.removeNftContract(address, { chainId, userAddress });\n    }\n  }\n\n  /**\n   * Removes all NFTs from the ignored list.\n   */\n  clearIgnoredNfts() {\n    this.update({ ignoredNfts: [] });\n  }\n\n  /**\n   * Checks whether input NFT is still owned by the user\n   * And updates the isCurrentlyOwned value on the NFT object accordingly.\n   *\n   * @param nft - The NFT object to check and update.\n   * @param batch - A boolean indicating whether this method is being called as part of a batch or single update.\n   * @param accountParams - The userAddress and chainId to check ownership against\n   * @param accountParams.userAddress - the address passed through the confirmed transaction flow to ensure assets are stored to the correct account\n   * @param accountParams.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns the NFT with the updated isCurrentlyOwned value\n   */\n  async checkAndUpdateSingleNftOwnershipStatus(\n    nft: Nft,\n    batch: boolean,\n    {\n      userAddress = this.config.selectedAddress,\n      networkClientId,\n    }: { networkClientId?: NetworkClientId; userAddress?: string } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n    const { address, tokenId } = nft;\n    let isOwned = nft.isCurrentlyOwned;\n    try {\n      isOwned = await this.isNftOwner(userAddress, address, tokenId, {\n        networkClientId,\n      });\n    } catch {\n      // ignore error\n      // this will only throw an error 'Unable to verify ownership' in which case\n      // we want to keep the current value of isCurrentlyOwned for this flow.\n    }\n\n    nft.isCurrentlyOwned = isOwned;\n\n    if (batch) {\n      return nft;\n    }\n\n    // if this is not part of a batched update we update this one NFT in state\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const nftToUpdate = nfts.find(\n      (item) =>\n        item.tokenId === tokenId &&\n        item.address.toLowerCase() === address.toLowerCase(),\n    );\n    if (nftToUpdate) {\n      nftToUpdate.isCurrentlyOwned = isOwned;\n      this.updateNestedNftState(nfts, ALL_NFTS_STATE_KEY, {\n        userAddress,\n        chainId,\n      });\n    }\n    return nft;\n  }\n\n  /**\n   * Checks whether NFTs associated with current selectedAddress/chainId combination are still owned by the user\n   * And updates the isCurrentlyOwned value on each accordingly.\n   * @param options - an object of arguments\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The address of the account where the NFT ownership status is checked/updated.\n   */\n  async checkAndUpdateAllNftsOwnershipStatus(\n    {\n      networkClientId,\n      userAddress = this.config.selectedAddress,\n    }: { networkClientId?: NetworkClientId; userAddress?: string } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const updatedNfts = await Promise.all(\n      nfts.map(async (nft) => {\n        return (\n          (await this.checkAndUpdateSingleNftOwnershipStatus(nft, true, {\n            networkClientId,\n            userAddress,\n          })) ?? nft\n        );\n      }),\n    );\n\n    this.updateNestedNftState(updatedNfts, ALL_NFTS_STATE_KEY, {\n      userAddress,\n      chainId,\n    });\n  }\n\n  /**\n   * Update NFT favorite status.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Hex address of the NFT contract.\n   * @param favorite - NFT new favorite status.\n   * @param options - an object of arguments\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   */\n  updateNftFavoriteStatus(\n    address: string,\n    tokenId: string,\n    favorite: boolean,\n    {\n      networkClientId,\n      userAddress = this.config.selectedAddress,\n    }: {\n      networkClientId?: NetworkClientId;\n      userAddress?: string;\n    } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const index: number = nfts.findIndex(\n      (nft) => nft.address === address && nft.tokenId === tokenId,\n    );\n\n    if (index === -1) {\n      return;\n    }\n\n    const updatedNft: Nft = {\n      ...nfts[index],\n      favorite,\n    };\n\n    // Update Nfts array\n    nfts[index] = updatedNft;\n\n    this.updateNestedNftState(nfts, ALL_NFTS_STATE_KEY, {\n      chainId,\n      userAddress,\n    });\n  }\n\n  /**\n   * Returns an NFT by the address and token id.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Number that represents the id of the token.\n   * @param selectedAddress - Hex address of the user account.\n   * @param chainId - Id of the current network.\n   * @returns Object containing the NFT and its position in the array\n   */\n  findNftByAddressAndTokenId(\n    address: string,\n    tokenId: string,\n    selectedAddress: string,\n    chainId: Hex,\n  ): { nft: Nft; index: number } | null {\n    const { allNfts } = this.state;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const index: number = nfts.findIndex(\n      (nft) =>\n        nft.address.toLowerCase() === address.toLowerCase() &&\n        nft.tokenId === tokenId,\n    );\n\n    if (index === -1) {\n      return null;\n    }\n\n    return { nft: nfts[index], index };\n  }\n\n  /**\n   * Update NFT data.\n   *\n   * @param nft - NFT object to find the right NFT to updates.\n   * @param updates - NFT partial object to update properties of the NFT.\n   * @param selectedAddress - Hex address of the user account.\n   * @param chainId - Id of the current network.\n   */\n  updateNft(\n    nft: Nft,\n    updates: Partial<Nft>,\n    selectedAddress: string,\n    chainId: Hex,\n  ) {\n    const { allNfts } = this.state;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const nftInfo = this.findNftByAddressAndTokenId(\n      nft.address,\n      nft.tokenId,\n      selectedAddress,\n      chainId,\n    );\n\n    if (!nftInfo) {\n      return;\n    }\n\n    const updatedNft: Nft = {\n      ...nft,\n      ...updates,\n    };\n\n    const newNfts = [\n      ...nfts.slice(0, nftInfo.index),\n      updatedNft,\n      ...nfts.slice(nftInfo.index + 1),\n    ];\n\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n      chainId,\n      userAddress: selectedAddress,\n    });\n  }\n\n  /**\n   * Resets the transaction status of an NFT.\n   *\n   * @param transactionId - NFT transaction id.\n   * @param selectedAddress - Hex address of the user account.\n   * @param chainId - Id of the current network.\n   * @returns a boolean indicating if the reset was well succeeded or not\n   */\n  resetNftTransactionStatusByTransactionId(\n    transactionId: string,\n    selectedAddress: string,\n    chainId: Hex,\n  ): boolean {\n    const { allNfts } = this.state;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const index: number = nfts.findIndex(\n      (nft) => nft.transactionId === transactionId,\n    );\n\n    if (index === -1) {\n      return false;\n    }\n    const updatedNft: Nft = {\n      ...nfts[index],\n      transactionId: undefined,\n    };\n\n    const newNfts = [\n      ...nfts.slice(0, index),\n      updatedNft,\n      ...nfts.slice(index + 1),\n    ];\n\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n      chainId,\n      userAddress: selectedAddress,\n    });\n\n    return true;\n  }\n\n  async _requestApproval(suggestedNftMeta: SuggestedNftMeta) {\n    return this.messagingSystem.call(\n      'ApprovalController:addRequest',\n      {\n        id: suggestedNftMeta.id,\n        origin: suggestedNftMeta.origin,\n        type: ApprovalType.WatchAsset,\n        requestData: {\n          id: suggestedNftMeta.id,\n          interactingAddress: suggestedNftMeta.interactingAddress,\n          asset: {\n            address: suggestedNftMeta.asset.address,\n            tokenId: suggestedNftMeta.asset.tokenId,\n            name: suggestedNftMeta.asset.name,\n            description: suggestedNftMeta.asset.description,\n            image: suggestedNftMeta.asset.image,\n            standard: suggestedNftMeta.asset.standard,\n          },\n        },\n      },\n      true,\n    );\n  }\n}\n\nexport default NftController;\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-CP3HC7AQ.mjs b/node_modules/@metamask/assets-controllers/dist/chunk-CP3HC7AQ.mjs
new file mode 100644
index 0000000..3f81b8b
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-CP3HC7AQ.mjs
@@ -0,0 +1,12 @@
+// src/constants.ts
+var Source = /* @__PURE__ */ ((Source2) => {
+  Source2["Custom"] = "custom";
+  Source2["Dapp"] = "dapp";
+  Source2["Detected"] = "detected";
+  return Source2;
+})(Source || {});
+
+export {
+  Source
+};
+//# sourceMappingURL=chunk-CP3HC7AQ.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-CP3HC7AQ.mjs.map b/node_modules/@metamask/assets-controllers/dist/chunk-CP3HC7AQ.mjs.map
new file mode 100644
index 0000000..5cd428e
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-CP3HC7AQ.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/constants.ts"],"sourcesContent":["export enum Source {\n  Custom = 'custom',\n  Dapp = 'dapp',\n  Detected = 'detected',\n}\n"],"mappings":";AAAO,IAAK,SAAL,kBAAKA,YAAL;AACL,EAAAA,QAAA,YAAS;AACT,EAAAA,QAAA,UAAO;AACP,EAAAA,QAAA,cAAW;AAHD,SAAAA;AAAA,GAAA;","names":["Source"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-E5PIGGYR.mjs b/node_modules/@metamask/assets-controllers/dist/chunk-E5PIGGYR.mjs
new file mode 100644
index 0000000..cd98370
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-E5PIGGYR.mjs
@@ -0,0 +1,268 @@
+// src/assetsUtil.ts
+import {
+  convertHexToDecimal,
+  toChecksumHexAddress
+} from "@metamask/controller-utils";
+import { remove0x } from "@metamask/utils";
+import BN from "bn.js";
+import { CID } from "multiformats/cid";
+var TOKEN_PRICES_BATCH_SIZE = 30;
+function compareNftMetadata(newNftMetadata, nft) {
+  const keys = [
+    "image",
+    "backgroundColor",
+    "imagePreview",
+    "imageThumbnail",
+    "imageOriginal",
+    "animation",
+    "animationOriginal",
+    "externalLink",
+    "tokenURI"
+  ];
+  const differentValues = keys.reduce((value, key) => {
+    if (newNftMetadata[key] && newNftMetadata[key] !== nft[key]) {
+      return value + 1;
+    }
+    return value;
+  }, 0);
+  return differentValues > 0;
+}
+var aggregatorNameByKey = {
+  aave: "Aave",
+  bancor: "Bancor",
+  cmc: "CMC",
+  cryptocom: "Crypto.com",
+  coinGecko: "CoinGecko",
+  oneInch: "1inch",
+  paraswap: "Paraswap",
+  pmm: "PMM",
+  zapper: "Zapper",
+  zerion: "Zerion",
+  zeroEx: "0x",
+  synthetix: "Synthetix",
+  yearn: "Yearn",
+  apeswap: "ApeSwap",
+  binanceDex: "BinanceDex",
+  pancakeTop100: "PancakeTop100",
+  pancakeExtended: "PancakeExtended",
+  balancer: "Balancer",
+  quickswap: "QuickSwap",
+  matcha: "Matcha",
+  pangolinDex: "PangolinDex",
+  pangolinDexStableCoin: "PangolinDexStableCoin",
+  pangolinDexAvaxBridge: "PangolinDexAvaxBridge",
+  traderJoe: "TraderJoe",
+  airswapLight: "AirswapLight",
+  kleros: "Kleros"
+};
+var formatAggregatorNames = (aggregators) => {
+  return aggregators.map(
+    (key) => aggregatorNameByKey[key] || `${key[0].toUpperCase()}${key.substring(1, key.length)}`
+  );
+};
+var formatIconUrlWithProxy = ({
+  chainId,
+  tokenAddress
+}) => {
+  const chainIdDecimal = convertHexToDecimal(chainId).toString();
+  return `https://static.metafi.codefi.network/api/v1/tokenIcons/${chainIdDecimal}/${tokenAddress.toLowerCase()}.png`;
+};
+var SupportedTokenDetectionNetworks = /* @__PURE__ */ ((SupportedTokenDetectionNetworks2) => {
+  SupportedTokenDetectionNetworks2["mainnet"] = "0x1";
+  SupportedTokenDetectionNetworks2["bsc"] = "0x38";
+  SupportedTokenDetectionNetworks2["polygon"] = "0x89";
+  SupportedTokenDetectionNetworks2["avax"] = "0xa86a";
+  SupportedTokenDetectionNetworks2["aurora"] = "0x4e454152";
+  SupportedTokenDetectionNetworks2["linea_goerli"] = "0xe704";
+  SupportedTokenDetectionNetworks2["linea_mainnet"] = "0xe708";
+  SupportedTokenDetectionNetworks2["arbitrum"] = "0xa4b1";
+  SupportedTokenDetectionNetworks2["optimism"] = "0xa";
+  SupportedTokenDetectionNetworks2["base"] = "0x2105";
+  SupportedTokenDetectionNetworks2["zksync"] = "0x144";
+  return SupportedTokenDetectionNetworks2;
+})(SupportedTokenDetectionNetworks || {});
+function isTokenDetectionSupportedForNetwork(chainId) {
+  return Object.values(SupportedTokenDetectionNetworks).includes(chainId);
+}
+function isTokenListSupportedForNetwork(chainId) {
+  return isTokenDetectionSupportedForNetwork(chainId);
+}
+function removeIpfsProtocolPrefix(ipfsUrl) {
+  if (ipfsUrl.startsWith("ipfs://ipfs/")) {
+    return ipfsUrl.replace("ipfs://ipfs/", "");
+  } else if (ipfsUrl.startsWith("ipfs://")) {
+    return ipfsUrl.replace("ipfs://", "");
+  }
+  throw new Error("this method should not be used with non ipfs urls");
+}
+function getIpfsCIDv1AndPath(ipfsUrl) {
+  const url = removeIpfsProtocolPrefix(ipfsUrl);
+  const index = url.indexOf("/");
+  const cid = index !== -1 ? url.substring(0, index) : url;
+  const path = index !== -1 ? url.substring(index) : void 0;
+  return {
+    cid: CID.parse(cid).toV1().toString(),
+    path
+  };
+}
+function getFormattedIpfsUrl(ipfsGateway, ipfsUrl, subdomainSupported) {
+  const { host, protocol, origin } = new URL(addUrlProtocolPrefix(ipfsGateway));
+  if (subdomainSupported) {
+    const { cid, path } = getIpfsCIDv1AndPath(ipfsUrl);
+    return `${protocol}//${cid}.ipfs.${host}${path ?? ""}`;
+  }
+  const cidAndPath = removeIpfsProtocolPrefix(ipfsUrl);
+  return `${origin}/ipfs/${cidAndPath}`;
+}
+function addUrlProtocolPrefix(urlString) {
+  if (!urlString.match(/(^http:\/\/)|(^https:\/\/)/u)) {
+    return `https://${urlString}`;
+  }
+  return urlString;
+}
+function ethersBigNumberToBN(bigNumber) {
+  return new BN(remove0x(bigNumber.toHexString()), "hex");
+}
+function divideIntoBatches(values, { batchSize }) {
+  const batches = [];
+  for (let i = 0; i < values.length; i += batchSize) {
+    batches.push(values.slice(i, i + batchSize));
+  }
+  return batches;
+}
+async function reduceInBatchesSerially({
+  values,
+  batchSize,
+  eachBatch,
+  initialResult
+}) {
+  const batches = divideIntoBatches(values, { batchSize });
+  let workingResult = initialResult;
+  for (const [index, batch] of batches.entries()) {
+    workingResult = await eachBatch(workingResult, batch, index);
+  }
+  const finalResult = workingResult;
+  return finalResult;
+}
+function mapOpenSeaNftV2ToV1(nft) {
+  return {
+    token_id: nft.identifier,
+    num_sales: null,
+    background_color: null,
+    image_url: nft.image_url ?? null,
+    image_preview_url: null,
+    image_thumbnail_url: null,
+    image_original_url: null,
+    animation_url: null,
+    animation_original_url: null,
+    name: nft.name,
+    description: nft.description,
+    external_link: null,
+    asset_contract: {
+      address: nft.contract,
+      asset_contract_type: null,
+      created_date: null,
+      schema_name: nft.token_standard.toUpperCase(),
+      symbol: null,
+      total_supply: null,
+      description: nft.description,
+      external_link: null,
+      collection: {
+        name: nft.collection,
+        image_url: null
+      }
+    },
+    creator: {
+      user: { username: "" },
+      profile_img_url: "",
+      address: ""
+    },
+    last_sale: null
+  };
+}
+function mapOpenSeaDetailedNftV2ToV1(nft) {
+  const mapped = mapOpenSeaNftV2ToV1(nft);
+  return {
+    ...mapped,
+    animation_url: nft.animation_url ?? null,
+    creator: {
+      ...mapped.creator,
+      address: nft.creator
+    }
+  };
+}
+function mapOpenSeaContractV2ToV1(contract, collection) {
+  return {
+    address: contract.address,
+    asset_contract_type: null,
+    created_date: null,
+    schema_name: contract.contract_standard.toUpperCase(),
+    symbol: null,
+    total_supply: collection?.total_supply?.toString() ?? contract.total_supply?.toString() ?? null,
+    description: collection?.description ?? null,
+    external_link: collection?.project_url ?? null,
+    collection: {
+      name: collection?.name ?? contract.name,
+      image_url: collection?.image_url
+    }
+  };
+}
+async function fetchTokenContractExchangeRates({
+  tokenPricesService,
+  nativeCurrency,
+  tokenAddresses,
+  chainId
+}) {
+  const isChainIdSupported = tokenPricesService.validateChainIdSupported(chainId);
+  const isCurrencySupported = tokenPricesService.validateCurrencySupported(nativeCurrency);
+  if (!isChainIdSupported || !isCurrencySupported) {
+    return {};
+  }
+  const tokenPricesByTokenAddress = await reduceInBatchesSerially({
+    values: [...tokenAddresses].sort(),
+    batchSize: TOKEN_PRICES_BATCH_SIZE,
+    eachBatch: async (allTokenPricesByTokenAddress, batch) => {
+      const tokenPricesByTokenAddressForBatch = await tokenPricesService.fetchTokenPrices({
+        tokenAddresses: batch,
+        chainId,
+        currency: nativeCurrency
+      });
+      return {
+        ...allTokenPricesByTokenAddress,
+        ...tokenPricesByTokenAddressForBatch
+      };
+    },
+    initialResult: {}
+  });
+  return Object.entries(tokenPricesByTokenAddress).reduce(
+    (obj, [tokenAddress, tokenPrice]) => {
+      return {
+        ...obj,
+        [toChecksumHexAddress(tokenAddress)]: tokenPrice?.value
+      };
+    },
+    {}
+  );
+}
+
+export {
+  TOKEN_PRICES_BATCH_SIZE,
+  compareNftMetadata,
+  formatAggregatorNames,
+  formatIconUrlWithProxy,
+  SupportedTokenDetectionNetworks,
+  isTokenDetectionSupportedForNetwork,
+  isTokenListSupportedForNetwork,
+  removeIpfsProtocolPrefix,
+  getIpfsCIDv1AndPath,
+  getFormattedIpfsUrl,
+  addUrlProtocolPrefix,
+  ethersBigNumberToBN,
+  divideIntoBatches,
+  reduceInBatchesSerially,
+  mapOpenSeaNftV2ToV1,
+  mapOpenSeaDetailedNftV2ToV1,
+  mapOpenSeaContractV2ToV1,
+  fetchTokenContractExchangeRates
+};
+//# sourceMappingURL=chunk-E5PIGGYR.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-E5PIGGYR.mjs.map b/node_modules/@metamask/assets-controllers/dist/chunk-E5PIGGYR.mjs.map
new file mode 100644
index 0000000..3eee8cb
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-E5PIGGYR.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/assetsUtil.ts"],"sourcesContent":["import type { BigNumber } from '@ethersproject/bignumber';\nimport {\n  convertHexToDecimal,\n  toChecksumHexAddress,\n} from '@metamask/controller-utils';\nimport type { Hex } from '@metamask/utils';\nimport { remove0x } from '@metamask/utils';\nimport BN from 'bn.js';\nimport { CID } from 'multiformats/cid';\n\nimport type {\n  Nft,\n  NftMetadata,\n  OpenSeaV2Collection,\n  OpenSeaV2Contract,\n  OpenSeaV2DetailedNft,\n  OpenSeaV2Nft,\n} from './NftController';\nimport type { ApiNft, ApiNftContract } from './NftDetectionController';\nimport type { AbstractTokenPricesService } from './token-prices-service';\nimport { type ContractExchangeRates } from './TokenRatesController';\n\n/**\n * The maximum number of token addresses that should be sent to the Price API in\n * a single request.\n */\nexport const TOKEN_PRICES_BATCH_SIZE = 30;\n\n/**\n * Compares nft metadata entries to any nft entry.\n * We need this method when comparing a new fetched nft metadata, in case a entry changed to a defined value,\n * there's a need to update the nft in state.\n *\n * @param newNftMetadata - Nft metadata object.\n * @param nft - Nft object to compare with.\n * @returns Whether there are differences.\n */\nexport function compareNftMetadata(newNftMetadata: NftMetadata, nft: Nft) {\n  const keys: (keyof NftMetadata)[] = [\n    'image',\n    'backgroundColor',\n    'imagePreview',\n    'imageThumbnail',\n    'imageOriginal',\n    'animation',\n    'animationOriginal',\n    'externalLink',\n    'tokenURI',\n  ];\n  const differentValues = keys.reduce((value, key) => {\n    if (newNftMetadata[key] && newNftMetadata[key] !== nft[key]) {\n      return value + 1;\n    }\n    return value;\n  }, 0);\n  return differentValues > 0;\n}\n\nconst aggregatorNameByKey: Record<string, string> = {\n  aave: 'Aave',\n  bancor: 'Bancor',\n  cmc: 'CMC',\n  cryptocom: 'Crypto.com',\n  coinGecko: 'CoinGecko',\n  oneInch: '1inch',\n  paraswap: 'Paraswap',\n  pmm: 'PMM',\n  zapper: 'Zapper',\n  zerion: 'Zerion',\n  zeroEx: '0x',\n  synthetix: 'Synthetix',\n  yearn: 'Yearn',\n  apeswap: 'ApeSwap',\n  binanceDex: 'BinanceDex',\n  pancakeTop100: 'PancakeTop100',\n  pancakeExtended: 'PancakeExtended',\n  balancer: 'Balancer',\n  quickswap: 'QuickSwap',\n  matcha: 'Matcha',\n  pangolinDex: 'PangolinDex',\n  pangolinDexStableCoin: 'PangolinDexStableCoin',\n  pangolinDexAvaxBridge: 'PangolinDexAvaxBridge',\n  traderJoe: 'TraderJoe',\n  airswapLight: 'AirswapLight',\n  kleros: 'Kleros',\n};\n\n/**\n * Formats aggregator names to presentable format.\n *\n * @param aggregators - List of token list names in camelcase.\n * @returns Formatted aggregator names.\n */\nexport const formatAggregatorNames = (aggregators: string[]) => {\n  return aggregators.map(\n    (key) =>\n      aggregatorNameByKey[key] ||\n      `${key[0].toUpperCase()}${key.substring(1, key.length)}`,\n  );\n};\n\n/**\n * Format token list assets to use image proxy from Codefi.\n *\n * @param params - Object that contains chainID and tokenAddress.\n * @param params.chainId - ChainID of network in 0x-prefixed hexadecimal format.\n * @param params.tokenAddress - Address of token in mixed or lowercase.\n * @returns Formatted image url\n */\nexport const formatIconUrlWithProxy = ({\n  chainId,\n  tokenAddress,\n}: {\n  chainId: Hex;\n  tokenAddress: string;\n}) => {\n  const chainIdDecimal = convertHexToDecimal(chainId).toString();\n  return `https://static.metafi.codefi.network/api/v1/tokenIcons/${chainIdDecimal}/${tokenAddress.toLowerCase()}.png`;\n};\n\n/**\n * Networks where token detection is supported - Values are in decimal format\n */\nexport enum SupportedTokenDetectionNetworks {\n  mainnet = '0x1', // decimal: 1\n  bsc = '0x38', // decimal: 56\n  polygon = '0x89', // decimal: 137\n  avax = '0xa86a', // decimal: 43114\n  aurora = '0x4e454152', // decimal: 1313161554\n  linea_goerli = '0xe704', // decimal: 59140\n  linea_mainnet = '0xe708', // decimal: 59144\n  arbitrum = '0xa4b1', // decimal: 42161\n  optimism = '0xa', // decimal: 10\n  base = '0x2105', // decimal: 8453\n  zksync = '0x144', // decimal: 324\n}\n\n/**\n * Check if token detection is enabled for certain networks.\n *\n * @param chainId - ChainID of network\n * @returns Whether the current network supports token detection\n */\nexport function isTokenDetectionSupportedForNetwork(chainId: Hex): boolean {\n  return Object.values<Hex>(SupportedTokenDetectionNetworks).includes(chainId);\n}\n\n/**\n * Check if token list polling is enabled for a given network.\n * Currently this method is used to support e2e testing for consumers of this package.\n *\n * @param chainId - ChainID of network\n * @returns Whether the current network supports tokenlists\n */\nexport function isTokenListSupportedForNetwork(chainId: Hex): boolean {\n  return isTokenDetectionSupportedForNetwork(chainId);\n}\n\n/**\n * Removes IPFS protocol prefix from input string.\n *\n * @param ipfsUrl - An IPFS url (e.g. ipfs://{content id})\n * @returns IPFS content identifier and (possibly) path in a string\n * @throws Will throw if the url passed is not IPFS.\n */\nexport function removeIpfsProtocolPrefix(ipfsUrl: string) {\n  if (ipfsUrl.startsWith('ipfs://ipfs/')) {\n    return ipfsUrl.replace('ipfs://ipfs/', '');\n  } else if (ipfsUrl.startsWith('ipfs://')) {\n    return ipfsUrl.replace('ipfs://', '');\n  }\n  // this method should not be used with non-ipfs urls (i.e. startsWith('ipfs://') === true)\n  throw new Error('this method should not be used with non ipfs urls');\n}\n\n/**\n * Extracts content identifier and path from an input string.\n *\n * @param ipfsUrl - An IPFS URL minus the IPFS protocol prefix\n * @returns IFPS content identifier (cid) and sub path as string.\n * @throws Will throw if the url passed is not ipfs.\n */\nexport function getIpfsCIDv1AndPath(ipfsUrl: string): {\n  cid: string;\n  path?: string;\n} {\n  const url = removeIpfsProtocolPrefix(ipfsUrl);\n\n  // check if there is a path\n  // (CID is everything preceding first forward slash, path is everything after)\n  const index = url.indexOf('/');\n  const cid = index !== -1 ? url.substring(0, index) : url;\n  const path = index !== -1 ? url.substring(index) : undefined;\n\n  // We want to ensure that the CID is v1 (https://docs.ipfs.io/concepts/content-addressing/#identifier-formats)\n  // because most cid v0s appear to be incompatible with IPFS subdomains\n  return {\n    cid: CID.parse(cid).toV1().toString(),\n    path,\n  };\n}\n\n/**\n * Formats URL correctly for use retrieving assets hosted on IPFS.\n *\n * @param ipfsGateway - The users preferred IPFS gateway (full URL or just host).\n * @param ipfsUrl - The IFPS URL pointed at the asset.\n * @param subdomainSupported - Boolean indicating whether the URL should be formatted with subdomains or not.\n * @returns A formatted URL, with the user's preferred IPFS gateway and format (subdomain or not), pointing to an asset hosted on IPFS.\n */\nexport function getFormattedIpfsUrl(\n  ipfsGateway: string,\n  ipfsUrl: string,\n  subdomainSupported: boolean,\n): string {\n  const { host, protocol, origin } = new URL(addUrlProtocolPrefix(ipfsGateway));\n  if (subdomainSupported) {\n    const { cid, path } = getIpfsCIDv1AndPath(ipfsUrl);\n    return `${protocol}//${cid}.ipfs.${host}${path ?? ''}`;\n  }\n  const cidAndPath = removeIpfsProtocolPrefix(ipfsUrl);\n  return `${origin}/ipfs/${cidAndPath}`;\n}\n\n/**\n * Adds URL protocol prefix to input URL string if missing.\n *\n * @param urlString - An IPFS URL.\n * @returns A URL with a https:// prepended.\n */\nexport function addUrlProtocolPrefix(urlString: string): string {\n  if (!urlString.match(/(^http:\\/\\/)|(^https:\\/\\/)/u)) {\n    return `https://${urlString}`;\n  }\n  return urlString;\n}\n\n/**\n * Converts an Ethers BigNumber to a BN.\n *\n * @param bigNumber - An Ethers BigNumber instance.\n * @returns A BN object.\n */\nexport function ethersBigNumberToBN(bigNumber: BigNumber): BN {\n  return new BN(remove0x(bigNumber.toHexString()), 'hex');\n}\n\n/**\n * Partitions a list of values into groups that are at most `batchSize` in\n * length.\n *\n * @param values - The list of values.\n * @param args - The remaining arguments.\n * @param args.batchSize - The desired maximum number of values per batch.\n * @returns The list of batches.\n */\nexport function divideIntoBatches<Value>(\n  values: Value[],\n  { batchSize }: { batchSize: number },\n): Value[][] {\n  const batches = [];\n  for (let i = 0; i < values.length; i += batchSize) {\n    batches.push(values.slice(i, i + batchSize));\n  }\n  return batches;\n}\n\n/**\n * Constructs an object from processing batches of the given values\n * sequentially.\n *\n * @param args - The arguments to this function.\n * @param args.values - A list of values to iterate over.\n * @param args.batchSize - The maximum number of values in each batch.\n * @param args.eachBatch - A function to call for each batch. This function is\n * similar to the function that `Array.prototype.reduce` takes, in that it\n * receives the object that is being built, each batch in the list of batches\n * and the index, and should return an updated version of the object.\n * @param args.initialResult - The initial value of the final data structure,\n * i.e., the value that will be fed into the first call of `eachBatch`.\n * @returns The built object.\n */\nexport async function reduceInBatchesSerially<\n  Value,\n  Result extends Record<PropertyKey, unknown>,\n>({\n  values,\n  batchSize,\n  eachBatch,\n  initialResult,\n}: {\n  values: Value[];\n  batchSize: number;\n  eachBatch: (\n    workingResult: Partial<Result>,\n    batch: Value[],\n    index: number,\n  ) => Partial<Result> | Promise<Partial<Result>>;\n  initialResult: Partial<Result>;\n}): Promise<Result> {\n  const batches = divideIntoBatches(values, { batchSize });\n  let workingResult = initialResult;\n  for (const [index, batch] of batches.entries()) {\n    workingResult = await eachBatch(workingResult, batch, index);\n  }\n  // There's no way around this  we have to assume that in the end, the result\n  // matches the intended type.\n  const finalResult = workingResult as Result;\n  return finalResult;\n}\n\n/**\n * Maps an OpenSea V2 NFT to the V1 schema.\n * @param nft - The V2 NFT to map.\n * @returns The NFT in the V1 schema.\n */\nexport function mapOpenSeaNftV2ToV1(nft: OpenSeaV2Nft): ApiNft {\n  return {\n    token_id: nft.identifier,\n    num_sales: null,\n    background_color: null,\n    image_url: nft.image_url ?? null,\n    image_preview_url: null,\n    image_thumbnail_url: null,\n    image_original_url: null,\n    animation_url: null,\n    animation_original_url: null,\n    name: nft.name,\n    description: nft.description,\n    external_link: null,\n    asset_contract: {\n      address: nft.contract,\n      asset_contract_type: null,\n      created_date: null,\n      schema_name: nft.token_standard.toUpperCase(),\n      symbol: null,\n      total_supply: null,\n      description: nft.description,\n      external_link: null,\n      collection: {\n        name: nft.collection,\n        image_url: null,\n      },\n    },\n    creator: {\n      user: { username: '' },\n      profile_img_url: '',\n      address: '',\n    },\n    last_sale: null,\n  };\n}\n\n/**\n * Maps an OpenSea V2 detailed NFT to the V1 schema.\n * @param nft - The V2 detailed NFT to map.\n * @returns The NFT in the V1 schema.\n */\nexport function mapOpenSeaDetailedNftV2ToV1(nft: OpenSeaV2DetailedNft): ApiNft {\n  const mapped = mapOpenSeaNftV2ToV1(nft);\n  return {\n    ...mapped,\n    animation_url: nft.animation_url ?? null,\n    creator: {\n      ...mapped.creator,\n      address: nft.creator,\n    },\n  };\n}\n\n/**\n * Maps an OpenSea V2 contract to the V1 schema.\n * @param contract - The v2 contract data.\n * @param collection - The v2 collection data.\n * @returns The contract in the v1 schema.\n */\nexport function mapOpenSeaContractV2ToV1(\n  contract: OpenSeaV2Contract,\n  collection?: OpenSeaV2Collection,\n): ApiNftContract {\n  return {\n    address: contract.address,\n    asset_contract_type: null,\n    created_date: null,\n    schema_name: contract.contract_standard.toUpperCase(),\n    symbol: null,\n    total_supply:\n      collection?.total_supply?.toString() ??\n      contract.total_supply?.toString() ??\n      null,\n    description: collection?.description ?? null,\n    external_link: collection?.project_url ?? null,\n    collection: {\n      name: collection?.name ?? contract.name,\n      image_url: collection?.image_url,\n    },\n  };\n}\n\n/**\n * Retrieves token prices for a set of contract addresses in a specific currency and chainId.\n *\n * @param args - The arguments to function.\n * @param args.tokenPricesService - An object in charge of retrieving token prices.\n * @param args.nativeCurrency - The native currency to request price in.\n * @param args.tokenAddresses - The list of contract addresses.\n * @param args.chainId - The chainId of the tokens.\n * @returns The prices for the requested tokens.\n */\nexport async function fetchTokenContractExchangeRates({\n  tokenPricesService,\n  nativeCurrency,\n  tokenAddresses,\n  chainId,\n}: {\n  tokenPricesService: AbstractTokenPricesService;\n  nativeCurrency: string;\n  tokenAddresses: Hex[];\n  chainId: Hex;\n}): Promise<ContractExchangeRates> {\n  const isChainIdSupported =\n    tokenPricesService.validateChainIdSupported(chainId);\n  const isCurrencySupported =\n    tokenPricesService.validateCurrencySupported(nativeCurrency);\n\n  if (!isChainIdSupported || !isCurrencySupported) {\n    return {};\n  }\n\n  const tokenPricesByTokenAddress = await reduceInBatchesSerially<\n    Hex,\n    Awaited<ReturnType<AbstractTokenPricesService['fetchTokenPrices']>>\n  >({\n    values: [...tokenAddresses].sort(),\n    batchSize: TOKEN_PRICES_BATCH_SIZE,\n    eachBatch: async (allTokenPricesByTokenAddress, batch) => {\n      const tokenPricesByTokenAddressForBatch =\n        await tokenPricesService.fetchTokenPrices({\n          tokenAddresses: batch,\n          chainId,\n          currency: nativeCurrency,\n        });\n\n      return {\n        ...allTokenPricesByTokenAddress,\n        ...tokenPricesByTokenAddressForBatch,\n      };\n    },\n    initialResult: {},\n  });\n\n  return Object.entries(tokenPricesByTokenAddress).reduce(\n    (obj, [tokenAddress, tokenPrice]) => {\n      return {\n        ...obj,\n        [toChecksumHexAddress(tokenAddress)]: tokenPrice?.value,\n      };\n    },\n    {},\n  );\n}\n"],"mappings":"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","names":["SupportedTokenDetectionNetworks"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-GLZ66IRX.mjs b/node_modules/@metamask/assets-controllers/dist/chunk-GLZ66IRX.mjs
new file mode 100644
index 0000000..f65de67
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-GLZ66IRX.mjs
@@ -0,0 +1,245 @@
+import {
+  mapOpenSeaNftV2ToV1
+} from "./chunk-E5PIGGYR.mjs";
+
+// src/NftDetectionController.ts
+import {
+  OPENSEA_PROXY_URL,
+  fetchWithErrorHandling,
+  toChecksumHexAddress,
+  ChainId,
+  timeoutFetch,
+  safelyExecute
+} from "@metamask/controller-utils";
+import { StaticIntervalPollingControllerV1 } from "@metamask/polling-controller";
+var DEFAULT_INTERVAL = 18e4;
+var NftDetectionController = class extends StaticIntervalPollingControllerV1 {
+  /**
+   * Creates an NftDetectionController instance.
+   *
+   * @param options - The controller options.
+   * @param options.chainId - The chain ID of the current network.
+   * @param options.onNftsStateChange - Allows subscribing to assets controller state changes.
+   * @param options.onPreferencesStateChange - Allows subscribing to preferences controller state changes.
+   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.
+   * @param options.getOpenSeaApiKey - Gets the OpenSea API key, if one is set.
+   * @param options.addNft - Add an NFT.
+   * @param options.getNftApi - Gets the URL to fetch an NFT from OpenSea.
+   * @param options.getNftState - Gets the current state of the Assets controller.
+   * @param options.getNetworkClientById - Gets the network client by ID, from the NetworkController.
+   * @param config - Initial options used to configure this controller.
+   * @param state - Initial state to set on this controller.
+   */
+  constructor({
+    chainId: initialChainId,
+    getNetworkClientById,
+    onPreferencesStateChange,
+    onNetworkStateChange,
+    getOpenSeaApiKey,
+    addNft,
+    getNftApi,
+    getNftState
+  }, config, state) {
+    super(config, state);
+    /**
+     * Name of this controller used during composition
+     */
+    this.name = "NftDetectionController";
+    /**
+     * Checks whether network is mainnet or not.
+     *
+     * @returns Whether current network is mainnet.
+     */
+    this.isMainnet = () => this.config.chainId === ChainId.mainnet;
+    this.isMainnetByNetworkClientId = (networkClient) => {
+      return networkClient.configuration.chainId === ChainId.mainnet;
+    };
+    this.defaultConfig = {
+      interval: DEFAULT_INTERVAL,
+      chainId: initialChainId,
+      selectedAddress: "",
+      disabled: true
+    };
+    this.initialize();
+    this.getNftState = getNftState;
+    this.getNetworkClientById = getNetworkClientById;
+    onPreferencesStateChange(({ selectedAddress, useNftDetection }) => {
+      const { selectedAddress: previouslySelectedAddress, disabled } = this.config;
+      if (selectedAddress !== previouslySelectedAddress || !useNftDetection !== disabled) {
+        this.configure({ selectedAddress, disabled: !useNftDetection });
+        if (useNftDetection) {
+          this.start();
+        } else {
+          this.stop();
+        }
+      }
+    });
+    onNetworkStateChange(({ providerConfig }) => {
+      this.configure({
+        chainId: providerConfig.chainId
+      });
+    });
+    this.getOpenSeaApiKey = getOpenSeaApiKey;
+    this.addNft = addNft;
+    this.getNftApi = getNftApi;
+    this.setIntervalLength(this.config.interval);
+  }
+  getOwnerNftApi({
+    address,
+    next
+  }) {
+    return `${OPENSEA_PROXY_URL}/chain/${"ethereum" /* ethereum */}/account/${address}/nfts?limit=200&next=${next ?? ""}`;
+  }
+  async getOwnerNfts(address) {
+    let nftApiResponse;
+    let nfts = [];
+    let next;
+    do {
+      nftApiResponse = await fetchWithErrorHandling({
+        url: this.getOwnerNftApi({ address, next }),
+        timeout: 15e3
+      });
+      if (!nftApiResponse) {
+        return nfts;
+      }
+      const newNfts = await Promise.all(
+        nftApiResponse.nfts.map(async (nftV2) => {
+          const nftV1 = mapOpenSeaNftV2ToV1(nftV2);
+          if (!nftV1.image_url && nftV2.metadata_url) {
+            const nftDetails = await safelyExecute(
+              () => timeoutFetch(
+                this.getNftApi({
+                  contractAddress: nftV2.contract,
+                  tokenId: nftV2.identifier
+                }),
+                void 0,
+                1e3
+              ).then((r) => r.json())
+            );
+            nftV1.image_original_url = nftDetails?.nft?.image_url ?? null;
+          }
+          return nftV1;
+        })
+      );
+      nfts = [...nfts, ...newNfts];
+    } while (next = nftApiResponse.next);
+    return nfts;
+  }
+  async _executePoll(networkClientId, options) {
+    await this.detectNfts({ networkClientId, userAddress: options.address });
+  }
+  /**
+   * Start polling for the currency rate.
+   */
+  async start() {
+    if (!this.isMainnet() || this.disabled) {
+      return;
+    }
+    await this.startPolling();
+  }
+  /**
+   * Stop polling for the currency rate.
+   */
+  stop() {
+    this.stopPolling();
+  }
+  stopPolling() {
+    if (this.intervalId) {
+      clearInterval(this.intervalId);
+    }
+  }
+  /**
+   * Starts a new polling interval.
+   *
+   * @param interval - An interval on which to poll.
+   */
+  async startPolling(interval) {
+    interval && this.configure({ interval }, false, false);
+    this.stopPolling();
+    await this.detectNfts();
+    this.intervalId = setInterval(async () => {
+      await this.detectNfts();
+    }, this.config.interval);
+  }
+  /**
+   * Triggers asset ERC721 token auto detection on mainnet. Any newly detected NFTs are
+   * added.
+   *
+   * @param options - Options bag.
+   * @param options.networkClientId - The network client ID to detect NFTs on.
+   * @param options.userAddress - The address to detect NFTs for.
+   */
+  async detectNfts({
+    networkClientId,
+    userAddress
+  } = { userAddress: this.config.selectedAddress }) {
+    if (!this.isMainnet() || this.disabled) {
+      return;
+    }
+    if (!userAddress) {
+      return;
+    }
+    const apiNfts = await this.getOwnerNfts(userAddress);
+    const addNftPromises = apiNfts.map(async (nft) => {
+      const {
+        token_id,
+        num_sales,
+        background_color,
+        image_url,
+        image_preview_url,
+        image_thumbnail_url,
+        image_original_url,
+        animation_url,
+        animation_original_url,
+        name,
+        description,
+        external_link,
+        creator,
+        asset_contract: { address, schema_name },
+        last_sale
+      } = nft;
+      let ignored;
+      const { ignoredNfts } = this.getNftState();
+      if (ignoredNfts.length) {
+        ignored = ignoredNfts.find((c) => {
+          return c.address === toChecksumHexAddress(address) && c.tokenId === token_id;
+        });
+      }
+      if (!ignored) {
+        const nftMetadata = Object.assign(
+          {},
+          { name },
+          creator && { creator },
+          description && { description },
+          image_url && { image: image_url },
+          num_sales && { numberOfSales: num_sales },
+          background_color && { backgroundColor: background_color },
+          image_preview_url && { imagePreview: image_preview_url },
+          image_thumbnail_url && { imageThumbnail: image_thumbnail_url },
+          image_original_url && { imageOriginal: image_original_url },
+          animation_url && { animation: animation_url },
+          animation_original_url && {
+            animationOriginal: animation_original_url
+          },
+          schema_name && { standard: schema_name },
+          external_link && { externalLink: external_link },
+          last_sale && { lastSale: last_sale }
+        );
+        await this.addNft(address, token_id, {
+          nftMetadata,
+          userAddress,
+          source: "detected" /* Detected */,
+          networkClientId
+        });
+      }
+    });
+    await Promise.all(addNftPromises);
+  }
+};
+var NftDetectionController_default = NftDetectionController;
+
+export {
+  NftDetectionController,
+  NftDetectionController_default
+};
+//# sourceMappingURL=chunk-GLZ66IRX.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-GLZ66IRX.mjs.map b/node_modules/@metamask/assets-controllers/dist/chunk-GLZ66IRX.mjs.map
new file mode 100644
index 0000000..77219d3
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-GLZ66IRX.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/NftDetectionController.ts"],"sourcesContent":["import type { BaseConfig, BaseState } from '@metamask/base-controller';\nimport {\n  OPENSEA_PROXY_URL,\n  fetchWithErrorHandling,\n  toChecksumHexAddress,\n  ChainId,\n  timeoutFetch,\n  safelyExecute,\n} from '@metamask/controller-utils';\nimport type {\n  NetworkClientId,\n  NetworkController,\n  NetworkState,\n  NetworkClient,\n} from '@metamask/network-controller';\nimport { StaticIntervalPollingControllerV1 } from '@metamask/polling-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport type { Hex } from '@metamask/utils';\n\nimport { mapOpenSeaNftV2ToV1 } from './assetsUtil';\nimport { Source } from './constants';\nimport type { OpenSeaV2GetNftResponse } from './NftController';\nimport {\n  type NftController,\n  type NftState,\n  type NftMetadata,\n  type OpenSeaV2ListNftsResponse,\n  OpenSeaV2ChainIds,\n} from './NftController';\n\nconst DEFAULT_INTERVAL = 180000;\n\n/**\n * @type ApiNft\n *\n * NFT object coming from OpenSea api\n * @property token_id - The NFT identifier\n * @property num_sales - Number of sales\n * @property background_color - The background color to be displayed with the item\n * @property image_url - URI of an image associated with this NFT\n * @property image_preview_url - URI of a smaller image associated with this NFT\n * @property image_thumbnail_url - URI of a thumbnail image associated with this NFT\n * @property image_original_url - URI of the original image associated with this NFT\n * @property animation_url - URI of a animation associated with this NFT\n * @property animation_original_url - URI of the original animation associated with this NFT\n * @property name - The NFT name\n * @property description - The NFT description\n * @property external_link - External link containing additional information\n * @property assetContract - The NFT contract information object\n * @property creator - The NFT owner information object\n * @property lastSale - When this item was last sold\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface ApiNft {\n  token_id: string;\n  num_sales: number | null;\n  background_color: string | null;\n  image_url: string | null;\n  image_preview_url: string | null;\n  image_thumbnail_url: string | null;\n  image_original_url: string | null;\n  animation_url: string | null;\n  animation_original_url: string | null;\n  name: string | null;\n  description: string | null;\n  external_link: string | null;\n  asset_contract: ApiNftContract;\n  creator: ApiNftCreator;\n  last_sale: ApiNftLastSale | null;\n}\n\n/**\n * @type ApiNftContract\n *\n * NFT contract object coming from OpenSea api\n * @property address - Address of the NFT contract\n * @property asset_contract_type - The NFT type, it could be `semi-fungible` or `non-fungible`\n * @property created_date - Creation date\n * @property collection - Object containing the contract name and URI of an image associated\n * @property schema_name - The schema followed by the contract, it could be `ERC721` or `ERC1155`\n * @property symbol - The NFT contract symbol\n * @property total_supply - Total supply of NFTs\n * @property description - The NFT contract description\n * @property external_link - External link containing additional information\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface ApiNftContract {\n  address: string;\n  asset_contract_type: string | null;\n  created_date: string | null;\n  schema_name: string | null;\n  symbol: string | null;\n  total_supply: string | null;\n  description: string | null;\n  external_link: string | null;\n  collection: {\n    name: string | null;\n    image_url?: string | null;\n  };\n}\n\n/**\n * @type ApiNftLastSale\n *\n * NFT sale object coming from OpenSea api\n * @property event_timestamp - Object containing a `username`\n * @property total_price - URI of NFT image associated with this owner\n * @property transaction - Object containing transaction_hash and block_hash\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface ApiNftLastSale {\n  event_timestamp: string;\n  total_price: string;\n  transaction: { transaction_hash: string; block_hash: string };\n}\n\n/**\n * @type ApiNftCreator\n *\n * NFT creator object coming from OpenSea api\n * @property user - Object containing a `username`\n * @property profile_img_url - URI of NFT image associated with this owner\n * @property address - The owner address\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface ApiNftCreator {\n  user: { username: string };\n  profile_img_url: string;\n  address: string;\n}\n\n/**\n * @type NftDetectionConfig\n *\n * NftDetection configuration\n * @property interval - Polling interval used to fetch new token rates\n * @property chainId - Current chain ID\n * @property selectedAddress - Vault selected address\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface NftDetectionConfig extends BaseConfig {\n  interval: number;\n  chainId: Hex;\n  selectedAddress: string;\n}\n\n/**\n * Controller that passively polls on a set interval for NFT auto detection\n */\nexport class NftDetectionController extends StaticIntervalPollingControllerV1<\n  NftDetectionConfig,\n  BaseState\n> {\n  private intervalId?: ReturnType<typeof setTimeout>;\n\n  private getOwnerNftApi({\n    address,\n    next,\n  }: {\n    address: string;\n    next?: string;\n  }) {\n    return `${OPENSEA_PROXY_URL}/chain/${\n      OpenSeaV2ChainIds.ethereum\n    }/account/${address}/nfts?limit=200&next=${next ?? ''}`;\n  }\n\n  private async getOwnerNfts(address: string) {\n    let nftApiResponse: OpenSeaV2ListNftsResponse;\n    let nfts: ApiNft[] = [];\n    let next;\n\n    do {\n      nftApiResponse = await fetchWithErrorHandling({\n        url: this.getOwnerNftApi({ address, next }),\n        timeout: 15000,\n      });\n\n      if (!nftApiResponse) {\n        return nfts;\n      }\n\n      const newNfts = await Promise.all(\n        nftApiResponse.nfts.map(async (nftV2) => {\n          const nftV1 = mapOpenSeaNftV2ToV1(nftV2);\n\n          // If the image hasn't been processed into OpenSea's CDN, the image_url will be null.\n          // Try fetching the NFT individually, which returns the original image url from metadata if available.\n          if (!nftV1.image_url && nftV2.metadata_url) {\n            const nftDetails: OpenSeaV2GetNftResponse | undefined =\n              await safelyExecute(() =>\n                timeoutFetch(\n                  this.getNftApi({\n                    contractAddress: nftV2.contract,\n                    tokenId: nftV2.identifier,\n                  }),\n                  undefined,\n                  1000,\n                ).then((r) => r.json()),\n              );\n\n            nftV1.image_original_url = nftDetails?.nft?.image_url ?? null;\n          }\n          return nftV1;\n        }),\n      );\n\n      nfts = [...nfts, ...newNfts];\n    } while ((next = nftApiResponse.next));\n\n    return nfts;\n  }\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'NftDetectionController';\n\n  private readonly getOpenSeaApiKey: () => string | undefined;\n\n  private readonly addNft: NftController['addNft'];\n\n  private readonly getNftApi: NftController['getNftApi'];\n\n  private readonly getNftState: () => NftState;\n\n  private readonly getNetworkClientById: NetworkController['getNetworkClientById'];\n\n  /**\n   * Creates an NftDetectionController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.onNftsStateChange - Allows subscribing to assets controller state changes.\n   * @param options.onPreferencesStateChange - Allows subscribing to preferences controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param options.getOpenSeaApiKey - Gets the OpenSea API key, if one is set.\n   * @param options.addNft - Add an NFT.\n   * @param options.getNftApi - Gets the URL to fetch an NFT from OpenSea.\n   * @param options.getNftState - Gets the current state of the Assets controller.\n   * @param options.getNetworkClientById - Gets the network client by ID, from the NetworkController.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      chainId: initialChainId,\n      getNetworkClientById,\n      onPreferencesStateChange,\n      onNetworkStateChange,\n      getOpenSeaApiKey,\n      addNft,\n      getNftApi,\n      getNftState,\n    }: {\n      chainId: Hex;\n      getNetworkClientById: NetworkController['getNetworkClientById'];\n      onNftsStateChange: (listener: (nftsState: NftState) => void) => void;\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      getOpenSeaApiKey: () => string | undefined;\n      addNft: NftController['addNft'];\n      getNftApi: NftController['getNftApi'];\n      getNftState: () => NftState;\n    },\n    config?: Partial<NftDetectionConfig>,\n    state?: Partial<BaseState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      interval: DEFAULT_INTERVAL,\n      chainId: initialChainId,\n      selectedAddress: '',\n      disabled: true,\n    };\n    this.initialize();\n    this.getNftState = getNftState;\n    this.getNetworkClientById = getNetworkClientById;\n    onPreferencesStateChange(({ selectedAddress, useNftDetection }) => {\n      const { selectedAddress: previouslySelectedAddress, disabled } =\n        this.config;\n\n      if (\n        selectedAddress !== previouslySelectedAddress ||\n        !useNftDetection !== disabled\n      ) {\n        this.configure({ selectedAddress, disabled: !useNftDetection });\n        if (useNftDetection) {\n          this.start();\n        } else {\n          this.stop();\n        }\n      }\n    });\n\n    onNetworkStateChange(({ providerConfig }) => {\n      this.configure({\n        chainId: providerConfig.chainId,\n      });\n    });\n    this.getOpenSeaApiKey = getOpenSeaApiKey;\n    this.addNft = addNft;\n    this.getNftApi = getNftApi;\n    this.setIntervalLength(this.config.interval);\n  }\n\n  async _executePoll(\n    networkClientId: string,\n    options: { address: string },\n  ): Promise<void> {\n    await this.detectNfts({ networkClientId, userAddress: options.address });\n  }\n\n  /**\n   * Start polling for the currency rate.\n   */\n  async start() {\n    if (!this.isMainnet() || this.disabled) {\n      return;\n    }\n\n    await this.startPolling();\n  }\n\n  /**\n   * Stop polling for the currency rate.\n   */\n  stop() {\n    this.stopPolling();\n  }\n\n  private stopPolling() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n  }\n\n  /**\n   * Starts a new polling interval.\n   *\n   * @param interval - An interval on which to poll.\n   */\n  private async startPolling(interval?: number): Promise<void> {\n    interval && this.configure({ interval }, false, false);\n    this.stopPolling();\n    await this.detectNfts();\n    this.intervalId = setInterval(async () => {\n      await this.detectNfts();\n    }, this.config.interval);\n  }\n\n  /**\n   * Checks whether network is mainnet or not.\n   *\n   * @returns Whether current network is mainnet.\n   */\n  isMainnet = (): boolean => this.config.chainId === ChainId.mainnet;\n\n  isMainnetByNetworkClientId = (networkClient: NetworkClient): boolean => {\n    return networkClient.configuration.chainId === ChainId.mainnet;\n  };\n\n  /**\n   * Triggers asset ERC721 token auto detection on mainnet. Any newly detected NFTs are\n   * added.\n   *\n   * @param options - Options bag.\n   * @param options.networkClientId - The network client ID to detect NFTs on.\n   * @param options.userAddress - The address to detect NFTs for.\n   */\n  async detectNfts(\n    {\n      networkClientId,\n      userAddress,\n    }: {\n      networkClientId?: NetworkClientId;\n      userAddress: string;\n    } = { userAddress: this.config.selectedAddress },\n  ) {\n    /* istanbul ignore if */\n    if (!this.isMainnet() || this.disabled) {\n      return;\n    }\n    /* istanbul ignore else */\n    if (!userAddress) {\n      return;\n    }\n\n    const apiNfts = await this.getOwnerNfts(userAddress);\n    const addNftPromises = apiNfts.map(async (nft: ApiNft) => {\n      const {\n        token_id,\n        num_sales,\n        background_color,\n        image_url,\n        image_preview_url,\n        image_thumbnail_url,\n        image_original_url,\n        animation_url,\n        animation_original_url,\n        name,\n        description,\n        external_link,\n        creator,\n        asset_contract: { address, schema_name },\n        last_sale,\n      } = nft;\n\n      let ignored;\n      /* istanbul ignore else */\n      const { ignoredNfts } = this.getNftState();\n      if (ignoredNfts.length) {\n        ignored = ignoredNfts.find((c) => {\n          /* istanbul ignore next */\n          return (\n            c.address === toChecksumHexAddress(address) &&\n            c.tokenId === token_id\n          );\n        });\n      }\n\n      /* istanbul ignore else */\n      if (!ignored) {\n        /* istanbul ignore next */\n        const nftMetadata: NftMetadata = Object.assign(\n          {},\n          { name },\n          creator && { creator },\n          description && { description },\n          image_url && { image: image_url },\n          num_sales && { numberOfSales: num_sales },\n          background_color && { backgroundColor: background_color },\n          image_preview_url && { imagePreview: image_preview_url },\n          image_thumbnail_url && { imageThumbnail: image_thumbnail_url },\n          image_original_url && { imageOriginal: image_original_url },\n          animation_url && { animation: animation_url },\n          animation_original_url && {\n            animationOriginal: animation_original_url,\n          },\n          schema_name && { standard: schema_name },\n          external_link && { externalLink: external_link },\n          last_sale && { lastSale: last_sale },\n        );\n\n        await this.addNft(address, token_id, {\n          nftMetadata,\n          userAddress,\n          source: Source.Detected,\n          networkClientId,\n        });\n      }\n    });\n    await Promise.all(addNftPromises);\n  }\n}\n\nexport default NftDetectionController;\n"],"mappings":";;;;;AACA;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAOP,SAAS,yCAAyC;AAelD,IAAM,mBAAmB;AAiIlB,IAAM,yBAAN,cAAqC,kCAG1C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA4FA,YACE;AAAA,IACE,SAAS;AAAA,IACT;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAeA,QACA,OACA;AACA,UAAM,QAAQ,KAAK;AAxDrB;AAAA;AAAA;AAAA,SAAS,OAAO;AAgJhB;AAAA;AAAA;AAAA;AAAA;AAAA,qBAAY,MAAe,KAAK,OAAO,YAAY,QAAQ;AAE3D,sCAA6B,CAAC,kBAA0C;AACtE,aAAO,cAAc,cAAc,YAAY,QAAQ;AAAA,IACzD;AA3FE,SAAK,gBAAgB;AAAA,MACnB,UAAU;AAAA,MACV,SAAS;AAAA,MACT,iBAAiB;AAAA,MACjB,UAAU;AAAA,IACZ;AACA,SAAK,WAAW;AAChB,SAAK,cAAc;AACnB,SAAK,uBAAuB;AAC5B,6BAAyB,CAAC,EAAE,iBAAiB,gBAAgB,MAAM;AACjE,YAAM,EAAE,iBAAiB,2BAA2B,SAAS,IAC3D,KAAK;AAEP,UACE,oBAAoB,6BACpB,CAAC,oBAAoB,UACrB;AACA,aAAK,UAAU,EAAE,iBAAiB,UAAU,CAAC,gBAAgB,CAAC;AAC9D,YAAI,iBAAiB;AACnB,eAAK,MAAM;AAAA,QACb,OAAO;AACL,eAAK,KAAK;AAAA,QACZ;AAAA,MACF;AAAA,IACF,CAAC;AAED,yBAAqB,CAAC,EAAE,eAAe,MAAM;AAC3C,WAAK,UAAU;AAAA,QACb,SAAS,eAAe;AAAA,MAC1B,CAAC;AAAA,IACH,CAAC;AACD,SAAK,mBAAmB;AACxB,SAAK,SAAS;AACd,SAAK,YAAY;AACjB,SAAK,kBAAkB,KAAK,OAAO,QAAQ;AAAA,EAC7C;AAAA,EAzJQ,eAAe;AAAA,IACrB;AAAA,IACA;AAAA,EACF,GAGG;AACD,WAAO,GAAG,iBAAiB,mCAE3B,YAAY,OAAO,wBAAwB,QAAQ,EAAE;AAAA,EACvD;AAAA,EAEA,MAAc,aAAa,SAAiB;AAC1C,QAAI;AACJ,QAAI,OAAiB,CAAC;AACtB,QAAI;AAEJ,OAAG;AACD,uBAAiB,MAAM,uBAAuB;AAAA,QAC5C,KAAK,KAAK,eAAe,EAAE,SAAS,KAAK,CAAC;AAAA,QAC1C,SAAS;AAAA,MACX,CAAC;AAED,UAAI,CAAC,gBAAgB;AACnB,eAAO;AAAA,MACT;AAEA,YAAM,UAAU,MAAM,QAAQ;AAAA,QAC5B,eAAe,KAAK,IAAI,OAAO,UAAU;AACvC,gBAAM,QAAQ,oBAAoB,KAAK;AAIvC,cAAI,CAAC,MAAM,aAAa,MAAM,cAAc;AAC1C,kBAAM,aACJ,MAAM;AAAA,cAAc,MAClB;AAAA,gBACE,KAAK,UAAU;AAAA,kBACb,iBAAiB,MAAM;AAAA,kBACvB,SAAS,MAAM;AAAA,gBACjB,CAAC;AAAA,gBACD;AAAA,gBACA;AAAA,cACF,EAAE,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC;AAAA,YACxB;AAEF,kBAAM,qBAAqB,YAAY,KAAK,aAAa;AAAA,UAC3D;AACA,iBAAO;AAAA,QACT,CAAC;AAAA,MACH;AAEA,aAAO,CAAC,GAAG,MAAM,GAAG,OAAO;AAAA,IAC7B,SAAU,OAAO,eAAe;AAEhC,WAAO;AAAA,EACT;AAAA,EAmGA,MAAM,aACJ,iBACA,SACe;AACf,UAAM,KAAK,WAAW,EAAE,iBAAiB,aAAa,QAAQ,QAAQ,CAAC;AAAA,EACzE;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,QAAQ;AACZ,QAAI,CAAC,KAAK,UAAU,KAAK,KAAK,UAAU;AACtC;AAAA,IACF;AAEA,UAAM,KAAK,aAAa;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO;AACL,SAAK,YAAY;AAAA,EACnB;AAAA,EAEQ,cAAc;AACpB,QAAI,KAAK,YAAY;AACnB,oBAAc,KAAK,UAAU;AAAA,IAC/B;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAc,aAAa,UAAkC;AAC3D,gBAAY,KAAK,UAAU,EAAE,SAAS,GAAG,OAAO,KAAK;AACrD,SAAK,YAAY;AACjB,UAAM,KAAK,WAAW;AACtB,SAAK,aAAa,YAAY,YAAY;AACxC,YAAM,KAAK,WAAW;AAAA,IACxB,GAAG,KAAK,OAAO,QAAQ;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAqBA,MAAM,WACJ;AAAA,IACE;AAAA,IACA;AAAA,EACF,IAGI,EAAE,aAAa,KAAK,OAAO,gBAAgB,GAC/C;AAEA,QAAI,CAAC,KAAK,UAAU,KAAK,KAAK,UAAU;AACtC;AAAA,IACF;AAEA,QAAI,CAAC,aAAa;AAChB;AAAA,IACF;AAEA,UAAM,UAAU,MAAM,KAAK,aAAa,WAAW;AACnD,UAAM,iBAAiB,QAAQ,IAAI,OAAO,QAAgB;AACxD,YAAM;AAAA,QACJ;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,gBAAgB,EAAE,SAAS,YAAY;AAAA,QACvC;AAAA,MACF,IAAI;AAEJ,UAAI;AAEJ,YAAM,EAAE,YAAY,IAAI,KAAK,YAAY;AACzC,UAAI,YAAY,QAAQ;AACtB,kBAAU,YAAY,KAAK,CAAC,MAAM;AAEhC,iBACE,EAAE,YAAY,qBAAqB,OAAO,KAC1C,EAAE,YAAY;AAAA,QAElB,CAAC;AAAA,MACH;AAGA,UAAI,CAAC,SAAS;AAEZ,cAAM,cAA2B,OAAO;AAAA,UACtC,CAAC;AAAA,UACD,EAAE,KAAK;AAAA,UACP,WAAW,EAAE,QAAQ;AAAA,UACrB,eAAe,EAAE,YAAY;AAAA,UAC7B,aAAa,EAAE,OAAO,UAAU;AAAA,UAChC,aAAa,EAAE,eAAe,UAAU;AAAA,UACxC,oBAAoB,EAAE,iBAAiB,iBAAiB;AAAA,UACxD,qBAAqB,EAAE,cAAc,kBAAkB;AAAA,UACvD,uBAAuB,EAAE,gBAAgB,oBAAoB;AAAA,UAC7D,sBAAsB,EAAE,eAAe,mBAAmB;AAAA,UAC1D,iBAAiB,EAAE,WAAW,cAAc;AAAA,UAC5C,0BAA0B;AAAA,YACxB,mBAAmB;AAAA,UACrB;AAAA,UACA,eAAe,EAAE,UAAU,YAAY;AAAA,UACvC,iBAAiB,EAAE,cAAc,cAAc;AAAA,UAC/C,aAAa,EAAE,UAAU,UAAU;AAAA,QACrC;AAEA,cAAM,KAAK,OAAO,SAAS,UAAU;AAAA,UACnC;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF,CAAC;AACD,UAAM,QAAQ,IAAI,cAAc;AAAA,EAClC;AACF;AAEA,IAAO,iCAAQ;","names":[]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-H6TOSWUM.js b/node_modules/@metamask/assets-controllers/dist/chunk-H6TOSWUM.js
new file mode 100644
index 0000000..9321e74
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-H6TOSWUM.js
@@ -0,0 +1,157 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});
+
+var _chunkC4PQK53Kjs = require('./chunk-C4PQK53K.js');
+
+// src/CurrencyRateController.ts
+
+
+
+var _controllerutils = require('@metamask/controller-utils');
+var _pollingcontroller = require('@metamask/polling-controller');
+var _asyncmutex = require('async-mutex');
+var name = "CurrencyRateController";
+var metadata = {
+  currentCurrency: { persist: true, anonymous: true },
+  currencyRates: { persist: true, anonymous: true }
+};
+var defaultState = {
+  currentCurrency: "usd",
+  currencyRates: {
+    ETH: {
+      conversionDate: 0,
+      conversionRate: 0,
+      usdConversionRate: null
+    }
+  }
+};
+var CurrencyRateController = class extends _pollingcontroller.StaticIntervalPollingController {
+  /**
+   * Creates a CurrencyRateController instance.
+   *
+   * @param options - Constructor options.
+   * @param options.includeUsdRate - Keep track of the USD rate in addition to the current currency rate.
+   * @param options.interval - The polling interval, in milliseconds.
+   * @param options.messenger - A reference to the messaging system.
+   * @param options.state - Initial state to set on this controller.
+   * @param options.fetchExchangeRate - Fetches the exchange rate from an external API. This option is primarily meant for use in unit tests.
+   */
+  constructor({
+    includeUsdRate = false,
+    interval = 18e4,
+    messenger,
+    state,
+    fetchExchangeRate: fetchExchangeRate2 = _chunkC4PQK53Kjs.fetchExchangeRate
+  }) {
+    super({
+      name,
+      metadata,
+      messenger,
+      state: { ...defaultState, ...state }
+    });
+    this.mutex = new (0, _asyncmutex.Mutex)();
+    this.includeUsdRate = includeUsdRate;
+    this.setIntervalLength(interval);
+    this.fetchExchangeRate = fetchExchangeRate2;
+  }
+  /**
+   * Sets a currency to track.
+   *
+   * @param currentCurrency - ISO 4217 currency code.
+   */
+  async setCurrentCurrency(currentCurrency) {
+    const releaseLock = await this.mutex.acquire();
+    const nativeCurrencies = Object.keys(this.state.currencyRates);
+    try {
+      this.update(() => {
+        return {
+          ...defaultState,
+          currentCurrency
+        };
+      });
+    } finally {
+      releaseLock();
+    }
+    nativeCurrencies.forEach(this.updateExchangeRate.bind(this));
+  }
+  /**
+   * Updates the exchange rate for the current currency and native currency pair.
+   *
+   * @param nativeCurrency - The ticker symbol for the chain.
+   */
+  async updateExchangeRate(nativeCurrency) {
+    const releaseLock = await this.mutex.acquire();
+    const { currentCurrency, currencyRates } = this.state;
+    let conversionDate = null;
+    let conversionRate = null;
+    let usdConversionRate = null;
+    const nativeCurrencyForExchangeRate = Object.values(
+      _controllerutils.TESTNET_TICKER_SYMBOLS
+    ).includes(nativeCurrency) ? _controllerutils.FALL_BACK_VS_CURRENCY : nativeCurrency;
+    try {
+      if (currentCurrency && nativeCurrency && // if either currency is an empty string we can skip the comparison
+      // because it will result in an error from the api and ultimately
+      // a null conversionRate either way.
+      currentCurrency !== "" && nativeCurrency !== "") {
+        const fetchExchangeRateResponse = await this.fetchExchangeRate(
+          currentCurrency,
+          nativeCurrencyForExchangeRate,
+          this.includeUsdRate
+        );
+        conversionRate = fetchExchangeRateResponse.conversionRate;
+        usdConversionRate = fetchExchangeRateResponse.usdConversionRate;
+        conversionDate = Date.now() / 1e3;
+      }
+    } catch (error) {
+      if (!(error instanceof Error && error.message.includes("market does not exist for this coin pair"))) {
+        throw error;
+      }
+    } finally {
+      try {
+        this.update(() => {
+          return {
+            currencyRates: {
+              ...currencyRates,
+              [nativeCurrency]: {
+                conversionDate,
+                conversionRate,
+                usdConversionRate
+              }
+            },
+            currentCurrency
+          };
+        });
+      } finally {
+        releaseLock();
+      }
+    }
+  }
+  /**
+   * Prepare to discard this controller.
+   *
+   * This stops any active polling.
+   */
+  destroy() {
+    super.destroy();
+    this.stopAllPolling();
+  }
+  /**
+   * Updates exchange rate for the current currency.
+   *
+   * @param networkClientId - The network client ID used to get a ticker value.
+   * @returns The controller state.
+   */
+  async _executePoll(networkClientId) {
+    const networkClient = this.messagingSystem.call(
+      "NetworkController:getNetworkClientById",
+      networkClientId
+    );
+    await this.updateExchangeRate(networkClient.configuration.ticker);
+  }
+};
+var CurrencyRateController_default = CurrencyRateController;
+
+
+
+
+exports.CurrencyRateController = CurrencyRateController; exports.CurrencyRateController_default = CurrencyRateController_default;
+//# sourceMappingURL=chunk-H6TOSWUM.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-H6TOSWUM.js.map b/node_modules/@metamask/assets-controllers/dist/chunk-H6TOSWUM.js.map
new file mode 100644
index 0000000..c77d127
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-H6TOSWUM.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/CurrencyRateController.ts"],"names":["fetchExchangeRate"],"mappings":"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","sourcesContent":["import type {\n  RestrictedControllerMessenger,\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n} from '@metamask/base-controller';\nimport {\n  TESTNET_TICKER_SYMBOLS,\n  FALL_BACK_VS_CURRENCY,\n} from '@metamask/controller-utils';\nimport type {\n  NetworkClientId,\n  NetworkControllerGetNetworkClientByIdAction,\n} from '@metamask/network-controller';\nimport { StaticIntervalPollingController } from '@metamask/polling-controller';\nimport { Mutex } from 'async-mutex';\n\nimport { fetchExchangeRate as defaultFetchExchangeRate } from './crypto-compare';\n\n/**\n * @type CurrencyRateState\n * @property currencyRates - Object keyed by native currency\n * @property currencyRates.conversionDate - Timestamp of conversion rate expressed in ms since UNIX epoch\n * @property currencyRates.conversionRate - Conversion rate from current base asset to the current currency\n * @property currentCurrency - Currently-active ISO 4217 currency code\n * @property usdConversionRate - Conversion rate from usd to the current currency\n */\nexport type CurrencyRateState = {\n  currentCurrency: string;\n  currencyRates: Record<\n    string,\n    {\n      conversionDate: number | null;\n      conversionRate: number | null;\n      usdConversionRate: number | null;\n    }\n  >;\n};\n\nconst name = 'CurrencyRateController';\n\nexport type CurrencyRateStateChange = ControllerStateChangeEvent<\n  typeof name,\n  CurrencyRateState\n>;\n\nexport type CurrencyRateControllerEvents = CurrencyRateStateChange;\n\nexport type GetCurrencyRateState = ControllerGetStateAction<\n  typeof name,\n  CurrencyRateState\n>;\n\nexport type CurrencyRateControllerActions = GetCurrencyRateState;\n\ntype AllowedActions = NetworkControllerGetNetworkClientByIdAction;\n\ntype CurrencyRateMessenger = RestrictedControllerMessenger<\n  typeof name,\n  CurrencyRateControllerActions | AllowedActions,\n  CurrencyRateControllerEvents,\n  AllowedActions['type'],\n  never\n>;\n\nconst metadata = {\n  currentCurrency: { persist: true, anonymous: true },\n  currencyRates: { persist: true, anonymous: true },\n};\n\nconst defaultState = {\n  currentCurrency: 'usd',\n  currencyRates: {\n    ETH: {\n      conversionDate: 0,\n      conversionRate: 0,\n      usdConversionRate: null,\n    },\n  },\n};\n\n/**\n * Controller that passively polls on a set interval for an exchange rate from the current network\n * asset to the user's preferred currency.\n */\nexport class CurrencyRateController extends StaticIntervalPollingController<\n  typeof name,\n  CurrencyRateState,\n  CurrencyRateMessenger\n> {\n  private readonly mutex = new Mutex();\n\n  private readonly fetchExchangeRate;\n\n  private readonly includeUsdRate;\n\n  /**\n   * Creates a CurrencyRateController instance.\n   *\n   * @param options - Constructor options.\n   * @param options.includeUsdRate - Keep track of the USD rate in addition to the current currency rate.\n   * @param options.interval - The polling interval, in milliseconds.\n   * @param options.messenger - A reference to the messaging system.\n   * @param options.state - Initial state to set on this controller.\n   * @param options.fetchExchangeRate - Fetches the exchange rate from an external API. This option is primarily meant for use in unit tests.\n   */\n  constructor({\n    includeUsdRate = false,\n    interval = 180000,\n    messenger,\n    state,\n    fetchExchangeRate = defaultFetchExchangeRate,\n  }: {\n    includeUsdRate?: boolean;\n    interval?: number;\n    messenger: CurrencyRateMessenger;\n    state?: Partial<CurrencyRateState>;\n    fetchExchangeRate?: typeof defaultFetchExchangeRate;\n  }) {\n    super({\n      name,\n      metadata,\n      messenger,\n      state: { ...defaultState, ...state },\n    });\n    this.includeUsdRate = includeUsdRate;\n    this.setIntervalLength(interval);\n    this.fetchExchangeRate = fetchExchangeRate;\n  }\n\n  /**\n   * Sets a currency to track.\n   *\n   * @param currentCurrency - ISO 4217 currency code.\n   */\n  async setCurrentCurrency(currentCurrency: string) {\n    const releaseLock = await this.mutex.acquire();\n    const nativeCurrencies = Object.keys(this.state.currencyRates);\n    try {\n      this.update(() => {\n        return {\n          ...defaultState,\n          currentCurrency,\n        };\n      });\n    } finally {\n      releaseLock();\n    }\n    nativeCurrencies.forEach(this.updateExchangeRate.bind(this));\n  }\n\n  /**\n   * Updates the exchange rate for the current currency and native currency pair.\n   *\n   * @param nativeCurrency - The ticker symbol for the chain.\n   */\n  async updateExchangeRate(nativeCurrency: string): Promise<void> {\n    const releaseLock = await this.mutex.acquire();\n    const { currentCurrency, currencyRates } = this.state;\n\n    let conversionDate: number | null = null;\n    let conversionRate: number | null = null;\n    let usdConversionRate: number | null = null;\n\n    // For preloaded testnets (Goerli, Sepolia) we want to fetch exchange rate for real ETH.\n    const nativeCurrencyForExchangeRate = Object.values(\n      TESTNET_TICKER_SYMBOLS,\n    ).includes(nativeCurrency)\n      ? FALL_BACK_VS_CURRENCY // ETH\n      : nativeCurrency;\n\n    try {\n      if (\n        currentCurrency &&\n        nativeCurrency &&\n        // if either currency is an empty string we can skip the comparison\n        // because it will result in an error from the api and ultimately\n        // a null conversionRate either way.\n        currentCurrency !== '' &&\n        nativeCurrency !== ''\n      ) {\n        const fetchExchangeRateResponse = await this.fetchExchangeRate(\n          currentCurrency,\n          nativeCurrencyForExchangeRate,\n          this.includeUsdRate,\n        );\n        conversionRate = fetchExchangeRateResponse.conversionRate;\n        usdConversionRate = fetchExchangeRateResponse.usdConversionRate;\n        conversionDate = Date.now() / 1000;\n      }\n    } catch (error) {\n      if (\n        !(\n          error instanceof Error &&\n          error.message.includes('market does not exist for this coin pair')\n        )\n      ) {\n        throw error;\n      }\n    } finally {\n      try {\n        this.update(() => {\n          return {\n            currencyRates: {\n              ...currencyRates,\n              [nativeCurrency]: {\n                conversionDate,\n                conversionRate,\n                usdConversionRate,\n              },\n            },\n            currentCurrency,\n          };\n        });\n      } finally {\n        releaseLock();\n      }\n    }\n  }\n\n  /**\n   * Prepare to discard this controller.\n   *\n   * This stops any active polling.\n   */\n  override destroy() {\n    super.destroy();\n    this.stopAllPolling();\n  }\n\n  /**\n   * Updates exchange rate for the current currency.\n   *\n   * @param networkClientId - The network client ID used to get a ticker value.\n   * @returns The controller state.\n   */\n  async _executePoll(networkClientId: NetworkClientId): Promise<void> {\n    const networkClient = this.messagingSystem.call(\n      'NetworkController:getNetworkClientById',\n      networkClientId,\n    );\n    await this.updateExchangeRate(networkClient.configuration.ticker);\n  }\n}\n\nexport default CurrencyRateController;\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-KCUSDOIE.mjs b/node_modules/@metamask/assets-controllers/dist/chunk-KCUSDOIE.mjs
new file mode 100644
index 0000000..3e46d77
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-KCUSDOIE.mjs
@@ -0,0 +1,361 @@
+import {
+  ERC721Standard
+} from "./chunk-WIVSZVF4.mjs";
+import {
+  ERC1155Standard
+} from "./chunk-CEENXWOB.mjs";
+import {
+  ERC20Standard
+} from "./chunk-MQ7TIWBK.mjs";
+
+// src/AssetsContractController.ts
+import { Contract } from "@ethersproject/contracts";
+import { Web3Provider } from "@ethersproject/providers";
+import { BaseControllerV1 } from "@metamask/base-controller";
+import { IPFS_DEFAULT_GATEWAY_URL } from "@metamask/controller-utils";
+import abiSingleCallBalancesContract from "single-call-balance-checker-abi";
+var SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID = {
+  ["0x1" /* mainnet */]: "0xb1f8e55c7f64d203c1400b9d8555d050f94adf39",
+  ["0x38" /* bsc */]: "0x2352c63A83f9Fd126af8676146721Fa00924d7e4",
+  ["0x89" /* polygon */]: "0x2352c63A83f9Fd126af8676146721Fa00924d7e4",
+  ["0xa86a" /* avax */]: "0xD023D153a0DFa485130ECFdE2FAA7e612EF94818",
+  ["0x4e454152" /* aurora */]: "0x1286415D333855237f89Df27D388127181448538",
+  ["0xe704" /* linea_goerli */]: "0x10dAd7Ca3921471f616db788D9300DC97Db01783",
+  ["0xe708" /* linea_mainnet */]: "0xF62e6a41561b3650a69Bb03199C735e3E3328c0D",
+  ["0xa4b1" /* arbitrum */]: "0x151E24A486D7258dd7C33Fb67E4bB01919B7B32c",
+  ["0xa" /* optimism */]: "0xB1c568e9C3E6bdaf755A60c7418C269eb11524FC",
+  ["0x2105" /* base */]: "0x6AA75276052D96696134252587894ef5FFA520af",
+  ["0x144" /* zksync */]: "0x458fEd3144680a5b8bcfaa0F9594aa19B4Ea2D34"
+};
+var MISSING_PROVIDER_ERROR = "AssetsContractController failed to set the provider correctly. A provider must be set for this method to be available";
+var AssetsContractController = class extends BaseControllerV1 {
+  /**
+   * Creates a AssetsContractController instance.
+   *
+   * @param options - The controller options.
+   * @param options.chainId - The chain ID of the current network.
+   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.
+   * @param options.onNetworkDidChange - Allows subscribing to network controller networkDidChange events.
+   * @param options.getNetworkClientById - Gets the network client with the given id from the NetworkController.
+   * @param config - Initial options used to configure this controller.
+   * @param state - Initial state to set on this controller.
+   */
+  constructor({
+    chainId: initialChainId,
+    onPreferencesStateChange,
+    onNetworkDidChange,
+    getNetworkClientById
+  }, config, state) {
+    super(config, state);
+    /**
+     * Name of this controller used during composition
+     */
+    this.name = "AssetsContractController";
+    this.defaultConfig = {
+      provider: void 0,
+      ipfsGateway: IPFS_DEFAULT_GATEWAY_URL,
+      chainId: initialChainId
+    };
+    this.initialize();
+    this.getNetworkClientById = getNetworkClientById;
+    onPreferencesStateChange(({ ipfsGateway }) => {
+      this.configure({ ipfsGateway });
+    });
+    onNetworkDidChange((networkState) => {
+      if (this.config.chainId !== networkState.providerConfig.chainId) {
+        this.configure({
+          chainId: networkState.providerConfig.chainId
+        });
+      }
+    });
+  }
+  /**
+   * Sets a new provider.
+   *
+   * TODO: Replace this wth a method.
+   *
+   * @property provider - Provider used to create a new underlying Web3 instance
+   */
+  set provider(provider) {
+    this._provider = provider;
+  }
+  get provider() {
+    throw new Error("Property only used for setting");
+  }
+  /**
+   * Get the relevant provider instance.
+   *
+   * @param networkClientId - Network Client ID.
+   * @returns Web3Provider instance.
+   */
+  getProvider(networkClientId) {
+    const provider = networkClientId ? this.getNetworkClientById(networkClientId).provider : this._provider;
+    if (provider === void 0) {
+      throw new Error(MISSING_PROVIDER_ERROR);
+    }
+    return new Web3Provider(provider);
+  }
+  /**
+   * Get the relevant chain ID.
+   *
+   * @param networkClientId - Network Client ID used to get the provider.
+   * @returns Hex chain ID.
+   */
+  getChainId(networkClientId) {
+    return networkClientId ? this.getNetworkClientById(networkClientId).configuration.chainId : this.config.chainId;
+  }
+  /**
+   * Get a ERC20Standard instance using the relevant provider instance.
+   *
+   * @param networkClientId - Network Client ID used to get the provider.
+   * @returns ERC20Standard instance.
+   */
+  getERC20Standard(networkClientId) {
+    const provider = this.getProvider(networkClientId);
+    return new ERC20Standard(provider);
+  }
+  /**
+   * Get a ERC721Standard instance using the relevant provider instance.
+   *
+   * @param networkClientId - Network Client ID used to get the provider.
+   * @returns ERC721Standard instance.
+   */
+  getERC721Standard(networkClientId) {
+    const provider = this.getProvider(networkClientId);
+    return new ERC721Standard(provider);
+  }
+  /**
+   * Get a ERC1155Standard instance using the relevant provider instance.
+   *
+   * @param networkClientId - Network Client ID used to get the provider.
+   * @returns ERC1155Standard instance.
+   */
+  getERC1155Standard(networkClientId) {
+    const provider = this.getProvider(networkClientId);
+    return new ERC1155Standard(provider);
+  }
+  /**
+   * Get balance or count for current account on specific asset contract.
+   *
+   * @param address - Asset ERC20 contract address.
+   * @param selectedAddress - Current account public address.
+   * @param networkClientId - Network Client ID to fetch the provider with.
+   * @returns Promise resolving to BN object containing balance for current account on specific asset contract.
+   */
+  async getERC20BalanceOf(address, selectedAddress, networkClientId) {
+    const erc20Standard = this.getERC20Standard(networkClientId);
+    return erc20Standard.getBalanceOf(address, selectedAddress);
+  }
+  /**
+   * Query for the decimals for a given ERC20 asset.
+   *
+   * @param address - ERC20 asset contract address.
+   * @param networkClientId - Network Client ID to fetch the provider with.
+   * @returns Promise resolving to the 'decimals'.
+   */
+  async getERC20TokenDecimals(address, networkClientId) {
+    const erc20Standard = this.getERC20Standard(networkClientId);
+    return erc20Standard.getTokenDecimals(address);
+  }
+  /**
+   * Query for the name for a given ERC20 asset.
+   *
+   * @param address - ERC20 asset contract address.
+   * @param networkClientId - Network Client ID to fetch the provider with.
+   * @returns Promise resolving to the 'decimals'.
+   */
+  async getERC20TokenName(address, networkClientId) {
+    const erc20Standard = this.getERC20Standard(networkClientId);
+    return erc20Standard.getTokenName(address);
+  }
+  /**
+   * Enumerate assets assigned to an owner.
+   *
+   * @param address - ERC721 asset contract address.
+   * @param selectedAddress - Current account public address.
+   * @param index - An NFT counter less than `balanceOf(selectedAddress)`.
+   * @param networkClientId - Network Client ID to fetch the provider with.
+   * @returns Promise resolving to token identifier for the 'index'th asset assigned to 'selectedAddress'.
+   */
+  getERC721NftTokenId(address, selectedAddress, index, networkClientId) {
+    const erc721Standard = this.getERC721Standard(networkClientId);
+    return erc721Standard.getNftTokenId(address, selectedAddress, index);
+  }
+  /**
+   * Enumerate assets assigned to an owner.
+   *
+   * @param tokenAddress - ERC721 asset contract address.
+   * @param userAddress - Current account public address.
+   * @param tokenId - ERC721 asset identifier.
+   * @param networkClientId - Network Client ID to fetch the provider with.
+   * @returns Promise resolving to an object containing the token standard and a set of details which depend on which standard the token supports.
+   */
+  async getTokenStandardAndDetails(tokenAddress, userAddress, tokenId, networkClientId) {
+    this.getProvider(networkClientId);
+    const { ipfsGateway } = this.config;
+    try {
+      const erc721Standard = this.getERC721Standard(networkClientId);
+      return {
+        ...await erc721Standard.getDetails(
+          tokenAddress,
+          ipfsGateway,
+          tokenId
+        )
+      };
+    } catch {
+    }
+    try {
+      const erc1155Standard = this.getERC1155Standard(networkClientId);
+      return {
+        ...await erc1155Standard.getDetails(
+          tokenAddress,
+          ipfsGateway,
+          tokenId
+        )
+      };
+    } catch {
+    }
+    try {
+      const erc20Standard = this.getERC20Standard(networkClientId);
+      return {
+        ...await erc20Standard.getDetails(tokenAddress, userAddress)
+      };
+    } catch {
+    }
+    throw new Error("Unable to determine contract standard");
+  }
+  /**
+   * Query for tokenURI for a given ERC721 asset.
+   *
+   * @param address - ERC721 asset contract address.
+   * @param tokenId - ERC721 asset identifier.
+   * @param networkClientId - Network Client ID to fetch the provider with.
+   * @returns Promise resolving to the 'tokenURI'.
+   */
+  async getERC721TokenURI(address, tokenId, networkClientId) {
+    const erc721Standard = this.getERC721Standard(networkClientId);
+    return erc721Standard.getTokenURI(address, tokenId);
+  }
+  /**
+   * Query for name for a given asset.
+   *
+   * @param address - ERC721 or ERC20 asset contract address.
+   * @param networkClientId - Network Client ID to fetch the provider with.
+   * @returns Promise resolving to the 'name'.
+   */
+  async getERC721AssetName(address, networkClientId) {
+    const erc721Standard = this.getERC721Standard(networkClientId);
+    return erc721Standard.getAssetName(address);
+  }
+  /**
+   * Query for symbol for a given asset.
+   *
+   * @param address - ERC721 or ERC20 asset contract address.
+   * @param networkClientId - Network Client ID to fetch the provider with.
+   * @returns Promise resolving to the 'symbol'.
+   */
+  async getERC721AssetSymbol(address, networkClientId) {
+    const erc721Standard = this.getERC721Standard(networkClientId);
+    return erc721Standard.getAssetSymbol(address);
+  }
+  /**
+   * Query for owner for a given ERC721 asset.
+   *
+   * @param address - ERC721 asset contract address.
+   * @param tokenId - ERC721 asset identifier.
+   * @param networkClientId - Network Client ID to fetch the provider with.
+   * @returns Promise resolving to the owner address.
+   */
+  async getERC721OwnerOf(address, tokenId, networkClientId) {
+    const erc721Standard = this.getERC721Standard(networkClientId);
+    return erc721Standard.getOwnerOf(address, tokenId);
+  }
+  /**
+   * Query for tokenURI for a given asset.
+   *
+   * @param address - ERC1155 asset contract address.
+   * @param tokenId - ERC1155 asset identifier.
+   * @param networkClientId - Network Client ID to fetch the provider with.
+   * @returns Promise resolving to the 'tokenURI'.
+   */
+  async getERC1155TokenURI(address, tokenId, networkClientId) {
+    const erc1155Standard = this.getERC1155Standard(networkClientId);
+    return erc1155Standard.getTokenURI(address, tokenId);
+  }
+  /**
+   * Query for balance of a given ERC 1155 token.
+   *
+   * @param userAddress - Wallet public address.
+   * @param nftAddress - ERC1155 asset contract address.
+   * @param nftId - ERC1155 asset identifier.
+   * @param networkClientId - Network Client ID to fetch the provider with.
+   * @returns Promise resolving to the 'balanceOf'.
+   */
+  async getERC1155BalanceOf(userAddress, nftAddress, nftId, networkClientId) {
+    const erc1155Standard = this.getERC1155Standard(networkClientId);
+    return erc1155Standard.getBalanceOf(nftAddress, userAddress, nftId);
+  }
+  /**
+   * Transfer single ERC1155 token.
+   *
+   * @param nftAddress - ERC1155 token address.
+   * @param senderAddress - ERC1155 token sender.
+   * @param recipientAddress - ERC1155 token recipient.
+   * @param nftId - ERC1155 token id.
+   * @param qty - Quantity of tokens to be sent.
+   * @param networkClientId - Network Client ID to fetch the provider with.
+   * @returns Promise resolving to the 'transferSingle' ERC1155 token.
+   */
+  async transferSingleERC1155(nftAddress, senderAddress, recipientAddress, nftId, qty, networkClientId) {
+    const erc1155Standard = this.getERC1155Standard(networkClientId);
+    return erc1155Standard.transferSingle(
+      nftAddress,
+      senderAddress,
+      recipientAddress,
+      nftId,
+      qty
+    );
+  }
+  /**
+   * Get the token balance for a list of token addresses in a single call. Only non-zero balances
+   * are returned.
+   *
+   * @param selectedAddress - The address to check token balances for.
+   * @param tokensToDetect - The token addresses to detect balances for.
+   * @param networkClientId - Network Client ID to fetch the provider with.
+   * @returns The list of non-zero token balances.
+   */
+  async getBalancesInSingleCall(selectedAddress, tokensToDetect, networkClientId) {
+    const chainId = this.getChainId(networkClientId);
+    const provider = this.getProvider(networkClientId);
+    if (!(chainId in SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID)) {
+      return {};
+    }
+    const contractAddress = SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID[chainId];
+    const contract = new Contract(
+      contractAddress,
+      abiSingleCallBalancesContract,
+      provider
+    );
+    const result = await contract.balances([selectedAddress], tokensToDetect);
+    const nonZeroBalances = {};
+    if (result.length > 0) {
+      tokensToDetect.forEach((tokenAddress, index) => {
+        const balance = result[index];
+        if (String(balance) !== "0") {
+          nonZeroBalances[tokenAddress] = balance;
+        }
+      });
+    }
+    return nonZeroBalances;
+  }
+};
+var AssetsContractController_default = AssetsContractController;
+
+export {
+  SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID,
+  MISSING_PROVIDER_ERROR,
+  AssetsContractController,
+  AssetsContractController_default
+};
+//# sourceMappingURL=chunk-KCUSDOIE.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-KCUSDOIE.mjs.map b/node_modules/@metamask/assets-controllers/dist/chunk-KCUSDOIE.mjs.map
new file mode 100644
index 0000000..b846af1
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-KCUSDOIE.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/AssetsContractController.ts"],"sourcesContent":["import { Contract } from '@ethersproject/contracts';\nimport { Web3Provider } from '@ethersproject/providers';\nimport type { BaseConfig, BaseState } from '@metamask/base-controller';\nimport { BaseControllerV1 } from '@metamask/base-controller';\nimport { IPFS_DEFAULT_GATEWAY_URL } from '@metamask/controller-utils';\nimport type {\n  NetworkClientId,\n  NetworkState,\n  NetworkController,\n  Provider,\n} from '@metamask/network-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport type { Hex } from '@metamask/utils';\nimport type BN from 'bn.js';\nimport abiSingleCallBalancesContract from 'single-call-balance-checker-abi';\n\nimport { SupportedTokenDetectionNetworks } from './assetsUtil';\nimport { ERC20Standard } from './Standards/ERC20Standard';\nimport { ERC1155Standard } from './Standards/NftStandards/ERC1155/ERC1155Standard';\nimport { ERC721Standard } from './Standards/NftStandards/ERC721/ERC721Standard';\n\n/**\n * Check if token detection is enabled for certain networks\n *\n * @param chainId - ChainID of network\n * @returns Whether the current network supports token detection\n */\nexport const SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID: Record<Hex, string> = {\n  [SupportedTokenDetectionNetworks.mainnet]:\n    '0xb1f8e55c7f64d203c1400b9d8555d050f94adf39',\n  [SupportedTokenDetectionNetworks.bsc]:\n    '0x2352c63A83f9Fd126af8676146721Fa00924d7e4',\n  [SupportedTokenDetectionNetworks.polygon]:\n    '0x2352c63A83f9Fd126af8676146721Fa00924d7e4',\n  [SupportedTokenDetectionNetworks.avax]:\n    '0xD023D153a0DFa485130ECFdE2FAA7e612EF94818',\n  [SupportedTokenDetectionNetworks.aurora]:\n    '0x1286415D333855237f89Df27D388127181448538',\n  [SupportedTokenDetectionNetworks.linea_goerli]:\n    '0x10dAd7Ca3921471f616db788D9300DC97Db01783',\n  [SupportedTokenDetectionNetworks.linea_mainnet]:\n    '0xF62e6a41561b3650a69Bb03199C735e3E3328c0D',\n  [SupportedTokenDetectionNetworks.arbitrum]:\n    '0x151E24A486D7258dd7C33Fb67E4bB01919B7B32c',\n  [SupportedTokenDetectionNetworks.optimism]:\n    '0xB1c568e9C3E6bdaf755A60c7418C269eb11524FC',\n  [SupportedTokenDetectionNetworks.base]:\n    '0x6AA75276052D96696134252587894ef5FFA520af',\n  [SupportedTokenDetectionNetworks.zksync]:\n    '0x458fEd3144680a5b8bcfaa0F9594aa19B4Ea2D34',\n};\n\nexport const MISSING_PROVIDER_ERROR =\n  'AssetsContractController failed to set the provider correctly. A provider must be set for this method to be available';\n\n/**\n * @type AssetsContractConfig\n *\n * Assets Contract controller configuration\n * @property provider - Provider used to create a new web3 instance\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface AssetsContractConfig extends BaseConfig {\n  provider: Provider | undefined;\n  ipfsGateway: string;\n  chainId: Hex;\n}\n\n/**\n * @type BalanceMap\n *\n * Key value object containing the balance for each tokenAddress\n * @property [tokenAddress] - Address of the token\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface BalanceMap {\n  [tokenAddress: string]: BN;\n}\n\n/**\n * Controller that interacts with contracts on mainnet through web3\n */\nexport class AssetsContractController extends BaseControllerV1<\n  AssetsContractConfig,\n  BaseState\n> {\n  private _provider?: Provider;\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'AssetsContractController';\n\n  private readonly getNetworkClientById: NetworkController['getNetworkClientById'];\n\n  /**\n   * Creates a AssetsContractController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.onNetworkDidChange - Allows subscribing to network controller networkDidChange events.\n   * @param options.getNetworkClientById - Gets the network client with the given id from the NetworkController.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      chainId: initialChainId,\n      onPreferencesStateChange,\n      onNetworkDidChange,\n      getNetworkClientById,\n    }: {\n      chainId: Hex;\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onNetworkDidChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      getNetworkClientById: NetworkController['getNetworkClientById'];\n    },\n    config?: Partial<AssetsContractConfig>,\n    state?: Partial<BaseState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      provider: undefined,\n      ipfsGateway: IPFS_DEFAULT_GATEWAY_URL,\n      chainId: initialChainId,\n    };\n    this.initialize();\n    this.getNetworkClientById = getNetworkClientById;\n\n    onPreferencesStateChange(({ ipfsGateway }) => {\n      this.configure({ ipfsGateway });\n    });\n\n    onNetworkDidChange((networkState) => {\n      if (this.config.chainId !== networkState.providerConfig.chainId) {\n        this.configure({\n          chainId: networkState.providerConfig.chainId,\n        });\n      }\n    });\n  }\n\n  /**\n   * Sets a new provider.\n   *\n   * TODO: Replace this wth a method.\n   *\n   * @property provider - Provider used to create a new underlying Web3 instance\n   */\n  set provider(provider: Provider) {\n    this._provider = provider;\n  }\n\n  get provider() {\n    throw new Error('Property only used for setting');\n  }\n\n  /**\n   * Get the relevant provider instance.\n   *\n   * @param networkClientId - Network Client ID.\n   * @returns Web3Provider instance.\n   */\n  getProvider(networkClientId?: NetworkClientId): Web3Provider {\n    const provider = networkClientId\n      ? this.getNetworkClientById(networkClientId).provider\n      : this._provider;\n\n    if (provider === undefined) {\n      throw new Error(MISSING_PROVIDER_ERROR);\n    }\n\n    // @ts-expect-error TODO: remove this annotation once the `Eip1193Provider` class is released\n    return new Web3Provider(provider);\n  }\n\n  /**\n   * Get the relevant chain ID.\n   *\n   * @param networkClientId - Network Client ID used to get the provider.\n   * @returns Hex chain ID.\n   */\n  getChainId(networkClientId?: NetworkClientId): Hex {\n    return networkClientId\n      ? this.getNetworkClientById(networkClientId).configuration.chainId\n      : this.config.chainId;\n  }\n\n  /**\n   * Get a ERC20Standard instance using the relevant provider instance.\n   *\n   * @param networkClientId - Network Client ID used to get the provider.\n   * @returns ERC20Standard instance.\n   */\n  getERC20Standard(networkClientId?: NetworkClientId): ERC20Standard {\n    const provider = this.getProvider(networkClientId);\n    return new ERC20Standard(provider);\n  }\n\n  /**\n   * Get a ERC721Standard instance using the relevant provider instance.\n   *\n   * @param networkClientId - Network Client ID used to get the provider.\n   * @returns ERC721Standard instance.\n   */\n  getERC721Standard(networkClientId?: NetworkClientId): ERC721Standard {\n    const provider = this.getProvider(networkClientId);\n    return new ERC721Standard(provider);\n  }\n\n  /**\n   * Get a ERC1155Standard instance using the relevant provider instance.\n   *\n   * @param networkClientId - Network Client ID used to get the provider.\n   * @returns ERC1155Standard instance.\n   */\n  getERC1155Standard(networkClientId?: NetworkClientId): ERC1155Standard {\n    const provider = this.getProvider(networkClientId);\n    return new ERC1155Standard(provider);\n  }\n\n  /**\n   * Get balance or count for current account on specific asset contract.\n   *\n   * @param address - Asset ERC20 contract address.\n   * @param selectedAddress - Current account public address.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to BN object containing balance for current account on specific asset contract.\n   */\n  async getERC20BalanceOf(\n    address: string,\n    selectedAddress: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<BN> {\n    const erc20Standard = this.getERC20Standard(networkClientId);\n    return erc20Standard.getBalanceOf(address, selectedAddress);\n  }\n\n  /**\n   * Query for the decimals for a given ERC20 asset.\n   *\n   * @param address - ERC20 asset contract address.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'decimals'.\n   */\n  async getERC20TokenDecimals(\n    address: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc20Standard = this.getERC20Standard(networkClientId);\n    return erc20Standard.getTokenDecimals(address);\n  }\n\n  /**\n   * Query for the name for a given ERC20 asset.\n   *\n   * @param address - ERC20 asset contract address.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'decimals'.\n   */\n  async getERC20TokenName(\n    address: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc20Standard = this.getERC20Standard(networkClientId);\n    return erc20Standard.getTokenName(address);\n  }\n\n  /**\n   * Enumerate assets assigned to an owner.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param selectedAddress - Current account public address.\n   * @param index - An NFT counter less than `balanceOf(selectedAddress)`.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to token identifier for the 'index'th asset assigned to 'selectedAddress'.\n   */\n  getERC721NftTokenId(\n    address: string,\n    selectedAddress: string,\n    index: number,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc721Standard = this.getERC721Standard(networkClientId);\n    return erc721Standard.getNftTokenId(address, selectedAddress, index);\n  }\n\n  /**\n   * Enumerate assets assigned to an owner.\n   *\n   * @param tokenAddress - ERC721 asset contract address.\n   * @param userAddress - Current account public address.\n   * @param tokenId - ERC721 asset identifier.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to an object containing the token standard and a set of details which depend on which standard the token supports.\n   */\n  async getTokenStandardAndDetails(\n    tokenAddress: string,\n    userAddress?: string,\n    tokenId?: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<{\n    standard: string;\n    tokenURI?: string | undefined;\n    symbol?: string | undefined;\n    name?: string | undefined;\n    decimals?: string | undefined;\n    balance?: BN | undefined;\n  }> {\n    // Asserts provider is available\n    this.getProvider(networkClientId);\n\n    const { ipfsGateway } = this.config;\n\n    // ERC721\n    try {\n      const erc721Standard = this.getERC721Standard(networkClientId);\n      return {\n        ...(await erc721Standard.getDetails(\n          tokenAddress,\n          ipfsGateway,\n          tokenId,\n        )),\n      };\n    } catch {\n      // Ignore\n    }\n\n    // ERC1155\n    try {\n      const erc1155Standard = this.getERC1155Standard(networkClientId);\n      return {\n        ...(await erc1155Standard.getDetails(\n          tokenAddress,\n          ipfsGateway,\n          tokenId,\n        )),\n      };\n    } catch {\n      // Ignore\n    }\n\n    // ERC20\n    try {\n      const erc20Standard = this.getERC20Standard(networkClientId);\n      return {\n        ...(await erc20Standard.getDetails(tokenAddress, userAddress)),\n      };\n    } catch {\n      // Ignore\n    }\n\n    throw new Error('Unable to determine contract standard');\n  }\n\n  /**\n   * Query for tokenURI for a given ERC721 asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param tokenId - ERC721 asset identifier.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'tokenURI'.\n   */\n  async getERC721TokenURI(\n    address: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc721Standard = this.getERC721Standard(networkClientId);\n    return erc721Standard.getTokenURI(address, tokenId);\n  }\n\n  /**\n   * Query for name for a given asset.\n   *\n   * @param address - ERC721 or ERC20 asset contract address.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'name'.\n   */\n  async getERC721AssetName(\n    address: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc721Standard = this.getERC721Standard(networkClientId);\n    return erc721Standard.getAssetName(address);\n  }\n\n  /**\n   * Query for symbol for a given asset.\n   *\n   * @param address - ERC721 or ERC20 asset contract address.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'symbol'.\n   */\n  async getERC721AssetSymbol(\n    address: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc721Standard = this.getERC721Standard(networkClientId);\n    return erc721Standard.getAssetSymbol(address);\n  }\n\n  /**\n   * Query for owner for a given ERC721 asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param tokenId - ERC721 asset identifier.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the owner address.\n   */\n  async getERC721OwnerOf(\n    address: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc721Standard = this.getERC721Standard(networkClientId);\n    return erc721Standard.getOwnerOf(address, tokenId);\n  }\n\n  /**\n   * Query for tokenURI for a given asset.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @param tokenId - ERC1155 asset identifier.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'tokenURI'.\n   */\n  async getERC1155TokenURI(\n    address: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<string> {\n    const erc1155Standard = this.getERC1155Standard(networkClientId);\n    return erc1155Standard.getTokenURI(address, tokenId);\n  }\n\n  /**\n   * Query for balance of a given ERC 1155 token.\n   *\n   * @param userAddress - Wallet public address.\n   * @param nftAddress - ERC1155 asset contract address.\n   * @param nftId - ERC1155 asset identifier.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'balanceOf'.\n   */\n  async getERC1155BalanceOf(\n    userAddress: string,\n    nftAddress: string,\n    nftId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<BN> {\n    const erc1155Standard = this.getERC1155Standard(networkClientId);\n    return erc1155Standard.getBalanceOf(nftAddress, userAddress, nftId);\n  }\n\n  /**\n   * Transfer single ERC1155 token.\n   *\n   * @param nftAddress - ERC1155 token address.\n   * @param senderAddress - ERC1155 token sender.\n   * @param recipientAddress - ERC1155 token recipient.\n   * @param nftId - ERC1155 token id.\n   * @param qty - Quantity of tokens to be sent.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns Promise resolving to the 'transferSingle' ERC1155 token.\n   */\n  async transferSingleERC1155(\n    nftAddress: string,\n    senderAddress: string,\n    recipientAddress: string,\n    nftId: string,\n    qty: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<void> {\n    const erc1155Standard = this.getERC1155Standard(networkClientId);\n    return erc1155Standard.transferSingle(\n      nftAddress,\n      senderAddress,\n      recipientAddress,\n      nftId,\n      qty,\n    );\n  }\n\n  /**\n   * Get the token balance for a list of token addresses in a single call. Only non-zero balances\n   * are returned.\n   *\n   * @param selectedAddress - The address to check token balances for.\n   * @param tokensToDetect - The token addresses to detect balances for.\n   * @param networkClientId - Network Client ID to fetch the provider with.\n   * @returns The list of non-zero token balances.\n   */\n  async getBalancesInSingleCall(\n    selectedAddress: string,\n    tokensToDetect: string[],\n    networkClientId?: NetworkClientId,\n  ) {\n    const chainId = this.getChainId(networkClientId);\n    const provider = this.getProvider(networkClientId);\n    if (!(chainId in SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID)) {\n      // Only fetch balance if contract address exists\n      return {};\n    }\n    const contractAddress = SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID[chainId];\n\n    const contract = new Contract(\n      contractAddress,\n      abiSingleCallBalancesContract,\n      provider,\n    );\n    const result = await contract.balances([selectedAddress], tokensToDetect);\n    const nonZeroBalances: BalanceMap = {};\n    /* istanbul ignore else */\n    if (result.length > 0) {\n      tokensToDetect.forEach((tokenAddress, index) => {\n        const balance: BN = result[index];\n        /* istanbul ignore else */\n        if (String(balance) !== '0') {\n          nonZeroBalances[tokenAddress] = balance;\n        }\n      });\n    }\n    return nonZeroBalances;\n  }\n}\n\nexport default AssetsContractController;\n"],"mappings":";;;;;;;;;;;AAAA,SAAS,gBAAgB;AACzB,SAAS,oBAAoB;AAE7B,SAAS,wBAAwB;AACjC,SAAS,gCAAgC;AAUzC,OAAO,mCAAmC;AAanC,IAAM,0CAA+D;AAAA,EAC1E,oBAAwC,GACtC;AAAA,EACF,iBAAoC,GAClC;AAAA,EACF,qBAAwC,GACtC;AAAA,EACF,oBAAqC,GACnC;AAAA,EACF,0BAAuC,GACrC;AAAA,EACF,4BAA6C,GAC3C;AAAA,EACF,6BAA8C,GAC5C;AAAA,EACF,wBAAyC,GACvC;AAAA,EACF,qBAAyC,GACvC;AAAA,EACF,oBAAqC,GACnC;AAAA,EACF,qBAAuC,GACrC;AACJ;AAEO,IAAM,yBACX;AAiCK,IAAM,2BAAN,cAAuC,iBAG5C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAqBA,YACE;AAAA,IACE,SAAS;AAAA,IACT;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAUA,QACA,OACA;AACA,UAAM,QAAQ,KAAK;AAlCrB;AAAA;AAAA;AAAA,SAAS,OAAO;AAmCd,SAAK,gBAAgB;AAAA,MACnB,UAAU;AAAA,MACV,aAAa;AAAA,MACb,SAAS;AAAA,IACX;AACA,SAAK,WAAW;AAChB,SAAK,uBAAuB;AAE5B,6BAAyB,CAAC,EAAE,YAAY,MAAM;AAC5C,WAAK,UAAU,EAAE,YAAY,CAAC;AAAA,IAChC,CAAC;AAED,uBAAmB,CAAC,iBAAiB;AACnC,UAAI,KAAK,OAAO,YAAY,aAAa,eAAe,SAAS;AAC/D,aAAK,UAAU;AAAA,UACb,SAAS,aAAa,eAAe;AAAA,QACvC,CAAC;AAAA,MACH;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,IAAI,SAAS,UAAoB;AAC/B,SAAK,YAAY;AAAA,EACnB;AAAA,EAEA,IAAI,WAAW;AACb,UAAM,IAAI,MAAM,gCAAgC;AAAA,EAClD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,YAAY,iBAAiD;AAC3D,UAAM,WAAW,kBACb,KAAK,qBAAqB,eAAe,EAAE,WAC3C,KAAK;AAET,QAAI,aAAa,QAAW;AAC1B,YAAM,IAAI,MAAM,sBAAsB;AAAA,IACxC;AAGA,WAAO,IAAI,aAAa,QAAQ;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,WAAW,iBAAwC;AACjD,WAAO,kBACH,KAAK,qBAAqB,eAAe,EAAE,cAAc,UACzD,KAAK,OAAO;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,iBAAiB,iBAAkD;AACjE,UAAM,WAAW,KAAK,YAAY,eAAe;AACjD,WAAO,IAAI,cAAc,QAAQ;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,kBAAkB,iBAAmD;AACnE,UAAM,WAAW,KAAK,YAAY,eAAe;AACjD,WAAO,IAAI,eAAe,QAAQ;AAAA,EACpC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,mBAAmB,iBAAoD;AACrE,UAAM,WAAW,KAAK,YAAY,eAAe;AACjD,WAAO,IAAI,gBAAgB,QAAQ;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAM,kBACJ,SACA,iBACA,iBACa;AACb,UAAM,gBAAgB,KAAK,iBAAiB,eAAe;AAC3D,WAAO,cAAc,aAAa,SAAS,eAAe;AAAA,EAC5D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,sBACJ,SACA,iBACiB;AACjB,UAAM,gBAAgB,KAAK,iBAAiB,eAAe;AAC3D,WAAO,cAAc,iBAAiB,OAAO;AAAA,EAC/C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,kBACJ,SACA,iBACiB;AACjB,UAAM,gBAAgB,KAAK,iBAAiB,eAAe;AAC3D,WAAO,cAAc,aAAa,OAAO;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,oBACE,SACA,iBACA,OACA,iBACiB;AACjB,UAAM,iBAAiB,KAAK,kBAAkB,eAAe;AAC7D,WAAO,eAAe,cAAc,SAAS,iBAAiB,KAAK;AAAA,EACrE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,MAAM,2BACJ,cACA,aACA,SACA,iBAQC;AAED,SAAK,YAAY,eAAe;AAEhC,UAAM,EAAE,YAAY,IAAI,KAAK;AAG7B,QAAI;AACF,YAAM,iBAAiB,KAAK,kBAAkB,eAAe;AAC7D,aAAO;AAAA,QACL,GAAI,MAAM,eAAe;AAAA,UACvB;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAAA,IACF,QAAQ;AAAA,IAER;AAGA,QAAI;AACF,YAAM,kBAAkB,KAAK,mBAAmB,eAAe;AAC/D,aAAO;AAAA,QACL,GAAI,MAAM,gBAAgB;AAAA,UACxB;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAAA,IACF,QAAQ;AAAA,IAER;AAGA,QAAI;AACF,YAAM,gBAAgB,KAAK,iBAAiB,eAAe;AAC3D,aAAO;AAAA,QACL,GAAI,MAAM,cAAc,WAAW,cAAc,WAAW;AAAA,MAC9D;AAAA,IACF,QAAQ;AAAA,IAER;AAEA,UAAM,IAAI,MAAM,uCAAuC;AAAA,EACzD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAM,kBACJ,SACA,SACA,iBACiB;AACjB,UAAM,iBAAiB,KAAK,kBAAkB,eAAe;AAC7D,WAAO,eAAe,YAAY,SAAS,OAAO;AAAA,EACpD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,mBACJ,SACA,iBACiB;AACjB,UAAM,iBAAiB,KAAK,kBAAkB,eAAe;AAC7D,WAAO,eAAe,aAAa,OAAO;AAAA,EAC5C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,qBACJ,SACA,iBACiB;AACjB,UAAM,iBAAiB,KAAK,kBAAkB,eAAe;AAC7D,WAAO,eAAe,eAAe,OAAO;AAAA,EAC9C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAM,iBACJ,SACA,SACA,iBACiB;AACjB,UAAM,iBAAiB,KAAK,kBAAkB,eAAe;AAC7D,WAAO,eAAe,WAAW,SAAS,OAAO;AAAA,EACnD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAM,mBACJ,SACA,SACA,iBACiB;AACjB,UAAM,kBAAkB,KAAK,mBAAmB,eAAe;AAC/D,WAAO,gBAAgB,YAAY,SAAS,OAAO;AAAA,EACrD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,MAAM,oBACJ,aACA,YACA,OACA,iBACa;AACb,UAAM,kBAAkB,KAAK,mBAAmB,eAAe;AAC/D,WAAO,gBAAgB,aAAa,YAAY,aAAa,KAAK;AAAA,EACpE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,MAAM,sBACJ,YACA,eACA,kBACA,OACA,KACA,iBACe;AACf,UAAM,kBAAkB,KAAK,mBAAmB,eAAe;AAC/D,WAAO,gBAAgB;AAAA,MACrB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,MAAM,wBACJ,iBACA,gBACA,iBACA;AACA,UAAM,UAAU,KAAK,WAAW,eAAe;AAC/C,UAAM,WAAW,KAAK,YAAY,eAAe;AACjD,QAAI,EAAE,WAAW,0CAA0C;AAEzD,aAAO,CAAC;AAAA,IACV;AACA,UAAM,kBAAkB,wCAAwC,OAAO;AAEvE,UAAM,WAAW,IAAI;AAAA,MACnB;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,UAAM,SAAS,MAAM,SAAS,SAAS,CAAC,eAAe,GAAG,cAAc;AACxE,UAAM,kBAA8B,CAAC;AAErC,QAAI,OAAO,SAAS,GAAG;AACrB,qBAAe,QAAQ,CAAC,cAAc,UAAU;AAC9C,cAAM,UAAc,OAAO,KAAK;AAEhC,YAAI,OAAO,OAAO,MAAM,KAAK;AAC3B,0BAAgB,YAAY,IAAI;AAAA,QAClC;AAAA,MACF,CAAC;AAAA,IACH;AACA,WAAO;AAAA,EACT;AACF;AAEA,IAAO,mCAAQ;","names":[]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-KRTEFV4Q.mjs b/node_modules/@metamask/assets-controllers/dist/chunk-KRTEFV4Q.mjs
new file mode 100644
index 0000000..2c169a7
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-KRTEFV4Q.mjs
@@ -0,0 +1,74 @@
+import {
+  isTokenListSupportedForNetwork
+} from "./chunk-E5PIGGYR.mjs";
+
+// src/token-service.ts
+import { convertHexToDecimal, timeoutFetch } from "@metamask/controller-utils";
+var TOKEN_END_POINT_API = "https://token-api.metaswap.codefi.network";
+var TOKEN_METADATA_NO_SUPPORT_ERROR = "TokenService Error: Network does not support fetchTokenMetadata";
+function getTokensURL(chainId) {
+  return `${TOKEN_END_POINT_API}/tokens/${convertHexToDecimal(
+    chainId
+  )}?occurrenceFloor=3&includeNativeAssets=false&includeDuplicateSymbolAssets=false&includeTokenFees=false&includeAssetType=false`;
+}
+function getTokenMetadataURL(chainId, tokenAddress) {
+  return `${TOKEN_END_POINT_API}/token/${convertHexToDecimal(
+    chainId
+  )}?address=${tokenAddress}`;
+}
+var tenSecondsInMilliseconds = 1e4;
+var defaultTimeout = tenSecondsInMilliseconds;
+async function fetchTokenListByChainId(chainId, abortSignal, { timeout = defaultTimeout } = {}) {
+  const tokenURL = getTokensURL(chainId);
+  const response = await queryApi(tokenURL, abortSignal, timeout);
+  if (response) {
+    return parseJsonResponse(response);
+  }
+  return void 0;
+}
+async function fetchTokenMetadata(chainId, tokenAddress, abortSignal, { timeout = defaultTimeout } = {}) {
+  if (!isTokenListSupportedForNetwork(chainId)) {
+    throw new Error(TOKEN_METADATA_NO_SUPPORT_ERROR);
+  }
+  const tokenMetadataURL = getTokenMetadataURL(chainId, tokenAddress);
+  const response = await queryApi(tokenMetadataURL, abortSignal, timeout);
+  if (response) {
+    return parseJsonResponse(response);
+  }
+  return void 0;
+}
+async function queryApi(apiURL, abortSignal, timeout) {
+  const fetchOptions = {
+    referrer: apiURL,
+    referrerPolicy: "no-referrer-when-downgrade",
+    method: "GET",
+    mode: "cors",
+    signal: abortSignal,
+    cache: "default"
+  };
+  fetchOptions.headers = new window.Headers();
+  fetchOptions.headers.set("Content-Type", "application/json");
+  try {
+    return await timeoutFetch(apiURL, fetchOptions, timeout);
+  } catch (error) {
+    if (error instanceof Error && error.name === "AbortError") {
+      console.log("Request is aborted");
+    }
+  }
+  return void 0;
+}
+async function parseJsonResponse(apiResponse) {
+  const responseObj = await apiResponse.json();
+  if (responseObj?.error) {
+    throw new Error(`TokenService Error: ${responseObj.error}`);
+  }
+  return responseObj;
+}
+
+export {
+  TOKEN_END_POINT_API,
+  TOKEN_METADATA_NO_SUPPORT_ERROR,
+  fetchTokenListByChainId,
+  fetchTokenMetadata
+};
+//# sourceMappingURL=chunk-KRTEFV4Q.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-KRTEFV4Q.mjs.map b/node_modules/@metamask/assets-controllers/dist/chunk-KRTEFV4Q.mjs.map
new file mode 100644
index 0000000..8a4d055
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-KRTEFV4Q.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/token-service.ts"],"sourcesContent":["import { convertHexToDecimal, timeoutFetch } from '@metamask/controller-utils';\nimport type { Hex } from '@metamask/utils';\n\nimport { isTokenListSupportedForNetwork } from './assetsUtil';\n\nexport const TOKEN_END_POINT_API = 'https://token-api.metaswap.codefi.network';\nexport const TOKEN_METADATA_NO_SUPPORT_ERROR =\n  'TokenService Error: Network does not support fetchTokenMetadata';\n\n/**\n * Get the tokens URL for a specific network.\n *\n * @param chainId - The chain ID of the network the tokens requested are on.\n * @returns The tokens URL.\n */\nfunction getTokensURL(chainId: Hex) {\n  return `${TOKEN_END_POINT_API}/tokens/${convertHexToDecimal(\n    chainId,\n  )}?occurrenceFloor=3&includeNativeAssets=false&includeDuplicateSymbolAssets=false&includeTokenFees=false&includeAssetType=false`;\n}\n\n/**\n * Get the token metadata URL for the given network and token.\n *\n * @param chainId - The chain ID of the network the token is on.\n * @param tokenAddress - The token address.\n * @returns The token metadata URL.\n */\nfunction getTokenMetadataURL(chainId: Hex, tokenAddress: string) {\n  return `${TOKEN_END_POINT_API}/token/${convertHexToDecimal(\n    chainId,\n  )}?address=${tokenAddress}`;\n}\n\nconst tenSecondsInMilliseconds = 10_000;\n\n// Token list averages 1.6 MB in size\n// timeoutFetch by default has a 500ms timeout, which will almost always timeout given the response size.\nconst defaultTimeout = tenSecondsInMilliseconds;\n\n/**\n * Fetch the list of token metadata for a given network. This request is cancellable using the\n * abort signal passed in.\n *\n * @param chainId - The chain ID of the network the requested tokens are on.\n * @param abortSignal - The abort signal used to cancel the request if necessary.\n * @param options - Additional fetch options.\n * @param options.timeout - The fetch timeout.\n * @returns The token list, or `undefined` if the request was cancelled.\n */\nexport async function fetchTokenListByChainId(\n  chainId: Hex,\n  abortSignal: AbortSignal,\n  { timeout = defaultTimeout } = {},\n): Promise<unknown> {\n  const tokenURL = getTokensURL(chainId);\n  const response = await queryApi(tokenURL, abortSignal, timeout);\n  if (response) {\n    return parseJsonResponse(response);\n  }\n  return undefined;\n}\n\n/**\n * Fetch metadata for the token address provided for a given network. This request is cancellable\n * using the abort signal passed in.\n *\n * @param chainId - The chain ID of the network the token is on.\n * @param tokenAddress - The address of the token to fetch metadata for.\n * @param abortSignal - The abort signal used to cancel the request if necessary.\n * @param options - Additional fetch options.\n * @param options.timeout - The fetch timeout.\n * @returns The token metadata, or `undefined` if the request was either aborted or failed.\n */\nexport async function fetchTokenMetadata<T>(\n  chainId: Hex,\n  tokenAddress: string,\n  abortSignal: AbortSignal,\n  { timeout = defaultTimeout } = {},\n): Promise<T | undefined> {\n  if (!isTokenListSupportedForNetwork(chainId)) {\n    throw new Error(TOKEN_METADATA_NO_SUPPORT_ERROR);\n  }\n  const tokenMetadataURL = getTokenMetadataURL(chainId, tokenAddress);\n  const response = await queryApi(tokenMetadataURL, abortSignal, timeout);\n  if (response) {\n    return parseJsonResponse(response) as Promise<T>;\n  }\n  return undefined;\n}\n\n/**\n * Perform fetch request against the api.\n *\n * @param apiURL - The URL of the API to fetch.\n * @param abortSignal - The abort signal used to cancel the request if necessary.\n * @param timeout - The fetch timeout.\n * @returns Promise resolving request response.\n */\nasync function queryApi(\n  apiURL: string,\n  abortSignal: AbortSignal,\n  timeout: number,\n): Promise<Response | undefined> {\n  const fetchOptions: RequestInit = {\n    referrer: apiURL,\n    referrerPolicy: 'no-referrer-when-downgrade',\n    method: 'GET',\n    mode: 'cors',\n    signal: abortSignal,\n    cache: 'default',\n  };\n  fetchOptions.headers = new window.Headers();\n  fetchOptions.headers.set('Content-Type', 'application/json');\n  try {\n    return await timeoutFetch(apiURL, fetchOptions, timeout);\n  } catch (error) {\n    if (error instanceof Error && error.name === 'AbortError') {\n      console.log('Request is aborted');\n    }\n  }\n  return undefined;\n}\n\n/**\n * Parse an API response and return the response JSON data.\n *\n * @param apiResponse - The API response to parse.\n * @returns The response JSON data.\n * @throws Will throw if the response includes an error.\n */\nasync function parseJsonResponse(apiResponse: Response): Promise<unknown> {\n  const responseObj = await apiResponse.json();\n  // api may return errors as json without setting an error http status code\n  if (responseObj?.error) {\n    throw new Error(`TokenService Error: ${responseObj.error}`);\n  }\n  return responseObj;\n}\n"],"mappings":";;;;;AAAA,SAAS,qBAAqB,oBAAoB;AAK3C,IAAM,sBAAsB;AAC5B,IAAM,kCACX;AAQF,SAAS,aAAa,SAAc;AAClC,SAAO,GAAG,mBAAmB,WAAW;AAAA,IACtC;AAAA,EACF,CAAC;AACH;AASA,SAAS,oBAAoB,SAAc,cAAsB;AAC/D,SAAO,GAAG,mBAAmB,UAAU;AAAA,IACrC;AAAA,EACF,CAAC,YAAY,YAAY;AAC3B;AAEA,IAAM,2BAA2B;AAIjC,IAAM,iBAAiB;AAYvB,eAAsB,wBACpB,SACA,aACA,EAAE,UAAU,eAAe,IAAI,CAAC,GACd;AAClB,QAAM,WAAW,aAAa,OAAO;AACrC,QAAM,WAAW,MAAM,SAAS,UAAU,aAAa,OAAO;AAC9D,MAAI,UAAU;AACZ,WAAO,kBAAkB,QAAQ;AAAA,EACnC;AACA,SAAO;AACT;AAaA,eAAsB,mBACpB,SACA,cACA,aACA,EAAE,UAAU,eAAe,IAAI,CAAC,GACR;AACxB,MAAI,CAAC,+BAA+B,OAAO,GAAG;AAC5C,UAAM,IAAI,MAAM,+BAA+B;AAAA,EACjD;AACA,QAAM,mBAAmB,oBAAoB,SAAS,YAAY;AAClE,QAAM,WAAW,MAAM,SAAS,kBAAkB,aAAa,OAAO;AACtE,MAAI,UAAU;AACZ,WAAO,kBAAkB,QAAQ;AAAA,EACnC;AACA,SAAO;AACT;AAUA,eAAe,SACb,QACA,aACA,SAC+B;AAC/B,QAAM,eAA4B;AAAA,IAChC,UAAU;AAAA,IACV,gBAAgB;AAAA,IAChB,QAAQ;AAAA,IACR,MAAM;AAAA,IACN,QAAQ;AAAA,IACR,OAAO;AAAA,EACT;AACA,eAAa,UAAU,IAAI,OAAO,QAAQ;AAC1C,eAAa,QAAQ,IAAI,gBAAgB,kBAAkB;AAC3D,MAAI;AACF,WAAO,MAAM,aAAa,QAAQ,cAAc,OAAO;AAAA,EACzD,SAAS,OAAO;AACd,QAAI,iBAAiB,SAAS,MAAM,SAAS,cAAc;AACzD,cAAQ,IAAI,oBAAoB;AAAA,IAClC;AAAA,EACF;AACA,SAAO;AACT;AASA,eAAe,kBAAkB,aAAyC;AACxE,QAAM,cAAc,MAAM,YAAY,KAAK;AAE3C,MAAI,aAAa,OAAO;AACtB,UAAM,IAAI,MAAM,uBAAuB,YAAY,KAAK,EAAE;AAAA,EAC5D;AACA,SAAO;AACT;","names":[]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-KSGMD24G.js b/node_modules/@metamask/assets-controllers/dist/chunk-KSGMD24G.js
new file mode 100644
index 0000000..f42f7ac
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-KSGMD24G.js
@@ -0,0 +1,284 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});
+
+var _chunkVY7TUOK2js = require('./chunk-VY7TUOK2.js');
+
+
+
+
+var _chunkRELRWIJNjs = require('./chunk-RELRWIJN.js');
+
+
+
+var _chunkZ4BLTVTBjs = require('./chunk-Z4BLTVTB.js');
+
+// src/TokenListController.ts
+var _controllerutils = require('@metamask/controller-utils');
+var _pollingcontroller = require('@metamask/polling-controller');
+var _asyncmutex = require('async-mutex');
+var DEFAULT_INTERVAL = 24 * 60 * 60 * 1e3;
+var DEFAULT_THRESHOLD = 24 * 60 * 60 * 1e3;
+var name = "TokenListController";
+var metadata = {
+  tokenList: { persist: true, anonymous: true },
+  tokensChainsCache: { persist: true, anonymous: true },
+  preventPollingOnNetworkRestart: { persist: true, anonymous: true }
+};
+var getDefaultTokenListState = () => {
+  return {
+    tokenList: {},
+    tokensChainsCache: {},
+    preventPollingOnNetworkRestart: false
+  };
+};
+var _onNetworkControllerStateChange, onNetworkControllerStateChange_fn, _fetchFromCache, fetchFromCache_fn;
+var TokenListController = class extends _pollingcontroller.StaticIntervalPollingController {
+  /**
+   * Creates a TokenListController instance.
+   *
+   * @param options - The controller options.
+   * @param options.chainId - The chain ID of the current network.
+   * @param options.onNetworkStateChange - A function for registering an event handler for network state changes.
+   * @param options.interval - The polling interval, in milliseconds.
+   * @param options.cacheRefreshThreshold - The token cache expiry time, in milliseconds.
+   * @param options.messenger - A restricted controller messenger.
+   * @param options.state - Initial state to set on this controller.
+   * @param options.preventPollingOnNetworkRestart - Determines whether to prevent poilling on network restart in extension.
+   */
+  constructor({
+    chainId,
+    preventPollingOnNetworkRestart = false,
+    onNetworkStateChange,
+    interval = DEFAULT_INTERVAL,
+    cacheRefreshThreshold = DEFAULT_THRESHOLD,
+    messenger,
+    state
+  }) {
+    super({
+      name,
+      metadata,
+      messenger,
+      state: { ...getDefaultTokenListState(), ...state }
+    });
+    /**
+     * Updates state and restarts polling on changes to the network controller
+     * state.
+     *
+     * @param networkControllerState - The updated network controller state.
+     */
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _onNetworkControllerStateChange);
+    /**
+     * Checks if the Cache timestamp is valid,
+     * if yes data in cache will be returned
+     * otherwise null will be returned.
+     * @param chainId - The chain ID of the network for which to fetch the cache.
+     * @returns The cached data, or `null` if the cache was expired.
+     */
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _fetchFromCache);
+    this.mutex = new (0, _asyncmutex.Mutex)();
+    this.intervalDelay = interval;
+    this.cacheRefreshThreshold = cacheRefreshThreshold;
+    this.chainId = chainId;
+    this.updatePreventPollingOnNetworkRestart(preventPollingOnNetworkRestart);
+    this.abortController = new AbortController();
+    if (onNetworkStateChange) {
+      onNetworkStateChange(async (networkControllerState) => {
+        await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _onNetworkControllerStateChange, onNetworkControllerStateChange_fn).call(this, networkControllerState);
+      });
+    } else {
+      this.messagingSystem.subscribe(
+        "NetworkController:stateChange",
+        async (networkControllerState) => {
+          await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _onNetworkControllerStateChange, onNetworkControllerStateChange_fn).call(this, networkControllerState);
+        }
+      );
+    }
+  }
+  /**
+   * Start polling for the token list.
+   */
+  async start() {
+    if (!_chunkRELRWIJNjs.isTokenListSupportedForNetwork.call(void 0, this.chainId)) {
+      return;
+    }
+    await this.startPolling();
+  }
+  /**
+   * Restart polling for the token list.
+   */
+  async restart() {
+    this.stopPolling();
+    await this.startPolling();
+  }
+  /**
+   * Stop polling for the token list.
+   */
+  stop() {
+    this.stopPolling();
+  }
+  /**
+   * Prepare to discard this controller.
+   *
+   * This stops any active polling.
+   */
+  destroy() {
+    super.destroy();
+    this.stopPolling();
+  }
+  stopPolling() {
+    if (this.intervalId) {
+      clearInterval(this.intervalId);
+    }
+  }
+  /**
+   * Starts a new polling interval.
+   */
+  async startPolling() {
+    await _controllerutils.safelyExecute.call(void 0, () => this.fetchTokenList());
+    this.intervalId = setInterval(async () => {
+      await _controllerutils.safelyExecute.call(void 0, () => this.fetchTokenList());
+    }, this.intervalDelay);
+  }
+  /**
+   * Fetching token list from the Token Service API.
+   *
+   * @private
+   * @param networkClientId - The ID of the network client triggering the fetch.
+   * @returns A promise that resolves when this operation completes.
+   */
+  async _executePoll(networkClientId) {
+    return this.fetchTokenList(networkClientId);
+  }
+  /**
+   * Fetching token list from the Token Service API.
+   *
+   * @param networkClientId - The ID of the network client triggering the fetch.
+   */
+  async fetchTokenList(networkClientId) {
+    const releaseLock = await this.mutex.acquire();
+    let networkClient;
+    if (networkClientId) {
+      networkClient = this.messagingSystem.call(
+        "NetworkController:getNetworkClientById",
+        networkClientId
+      );
+    }
+    const chainId = networkClient?.configuration.chainId ?? this.chainId;
+    try {
+      const { tokensChainsCache } = this.state;
+      let tokenList = {};
+      const cachedTokens = await _controllerutils.safelyExecute.call(void 0, 
+        () => _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _fetchFromCache, fetchFromCache_fn).call(this, chainId)
+      );
+      if (cachedTokens) {
+        tokenList = { ...cachedTokens };
+      } else {
+        const tokensFromAPI = await _controllerutils.safelyExecute.call(void 0, 
+          () => _chunkVY7TUOK2js.fetchTokenListByChainId.call(void 0, 
+            chainId,
+            this.abortController.signal
+          )
+        );
+        if (!tokensFromAPI) {
+          tokenList = { ...tokensChainsCache[chainId]?.data || {} };
+          this.update(() => {
+            return {
+              ...this.state,
+              tokenList,
+              tokensChainsCache
+            };
+          });
+          return;
+        }
+        for (const token of tokensFromAPI) {
+          const formattedToken = {
+            ...token,
+            aggregators: _chunkRELRWIJNjs.formatAggregatorNames.call(void 0, token.aggregators),
+            iconUrl: _chunkRELRWIJNjs.formatIconUrlWithProxy.call(void 0, {
+              chainId,
+              tokenAddress: token.address
+            })
+          };
+          tokenList[token.address] = formattedToken;
+        }
+      }
+      const updatedTokensChainsCache = {
+        ...tokensChainsCache,
+        [chainId]: {
+          timestamp: Date.now(),
+          data: tokenList
+        }
+      };
+      this.update(() => {
+        return {
+          ...this.state,
+          tokenList,
+          tokensChainsCache: updatedTokensChainsCache
+        };
+      });
+    } finally {
+      releaseLock();
+    }
+  }
+  /**
+   * Clearing tokenList and tokensChainsCache explicitly.
+   */
+  clearingTokenListData() {
+    this.update(() => {
+      return {
+        ...this.state,
+        tokenList: {},
+        tokensChainsCache: {}
+      };
+    });
+  }
+  /**
+   * Updates preventPollingOnNetworkRestart from extension.
+   *
+   * @param shouldPreventPolling - Determine whether to prevent polling on network change
+   */
+  updatePreventPollingOnNetworkRestart(shouldPreventPolling) {
+    this.update(() => {
+      return {
+        ...this.state,
+        preventPollingOnNetworkRestart: shouldPreventPolling
+      };
+    });
+  }
+};
+_onNetworkControllerStateChange = new WeakSet();
+onNetworkControllerStateChange_fn = async function(networkControllerState) {
+  if (this.chainId !== networkControllerState.providerConfig.chainId) {
+    this.abortController.abort();
+    this.abortController = new AbortController();
+    this.chainId = networkControllerState.providerConfig.chainId;
+    if (this.state.preventPollingOnNetworkRestart) {
+      this.clearingTokenListData();
+    } else {
+      this.update(() => {
+        return {
+          ...this.state,
+          tokenList: this.state.tokensChainsCache[this.chainId]?.data || {}
+        };
+      });
+      await this.restart();
+    }
+  }
+};
+_fetchFromCache = new WeakSet();
+fetchFromCache_fn = async function(chainId) {
+  const { tokensChainsCache } = this.state;
+  const dataCache = tokensChainsCache[chainId];
+  const now = Date.now();
+  if (dataCache?.data && now - dataCache?.timestamp < this.cacheRefreshThreshold) {
+    return dataCache.data;
+  }
+  return null;
+};
+var TokenListController_default = TokenListController;
+
+
+
+
+
+exports.getDefaultTokenListState = getDefaultTokenListState; exports.TokenListController = TokenListController; exports.TokenListController_default = TokenListController_default;
+//# sourceMappingURL=chunk-KSGMD24G.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-KSGMD24G.js.map b/node_modules/@metamask/assets-controllers/dist/chunk-KSGMD24G.js.map
new file mode 100644
index 0000000..3fecf02
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-KSGMD24G.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/TokenListController.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport { safelyExecute } from '@metamask/controller-utils';\nimport type {\n  NetworkClientId,\n  NetworkControllerStateChangeEvent,\n  NetworkState,\n  NetworkControllerGetNetworkClientByIdAction,\n} from '@metamask/network-controller';\nimport { StaticIntervalPollingController } from '@metamask/polling-controller';\nimport type { Hex } from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\n\nimport {\n  isTokenListSupportedForNetwork,\n  formatAggregatorNames,\n  formatIconUrlWithProxy,\n} from './assetsUtil';\nimport { fetchTokenListByChainId } from './token-service';\n\nconst DEFAULT_INTERVAL = 24 * 60 * 60 * 1000;\nconst DEFAULT_THRESHOLD = 24 * 60 * 60 * 1000;\n\nconst name = 'TokenListController';\n\nexport type TokenListToken = {\n  name: string;\n  symbol: string;\n  decimals: number;\n  address: string;\n  occurrences: number;\n  aggregators: string[];\n  iconUrl: string;\n};\n\nexport type TokenListMap = Record<string, TokenListToken>;\n\ntype DataCache = {\n  timestamp: number;\n  data: TokenListMap;\n};\ntype TokensChainsCache = {\n  [chainId: Hex]: DataCache;\n};\n\nexport type TokenListState = {\n  tokenList: TokenListMap;\n  tokensChainsCache: TokensChainsCache;\n  preventPollingOnNetworkRestart: boolean;\n};\n\nexport type TokenListStateChange = ControllerStateChangeEvent<\n  typeof name,\n  TokenListState\n>;\n\nexport type TokenListControllerEvents = TokenListStateChange;\n\nexport type GetTokenListState = ControllerGetStateAction<\n  typeof name,\n  TokenListState\n>;\n\nexport type TokenListControllerActions = GetTokenListState;\n\ntype AllowedActions = NetworkControllerGetNetworkClientByIdAction;\n\ntype AllowedEvents = NetworkControllerStateChangeEvent;\n\nexport type TokenListControllerMessenger = RestrictedControllerMessenger<\n  typeof name,\n  TokenListControllerActions | AllowedActions,\n  TokenListControllerEvents | AllowedEvents,\n  AllowedActions['type'],\n  AllowedEvents['type']\n>;\n\nconst metadata = {\n  tokenList: { persist: true, anonymous: true },\n  tokensChainsCache: { persist: true, anonymous: true },\n  preventPollingOnNetworkRestart: { persist: true, anonymous: true },\n};\n\nexport const getDefaultTokenListState = (): TokenListState => {\n  return {\n    tokenList: {},\n    tokensChainsCache: {},\n    preventPollingOnNetworkRestart: false,\n  };\n};\n\n/**\n * Controller that passively polls on a set interval for the list of tokens from metaswaps api\n */\nexport class TokenListController extends StaticIntervalPollingController<\n  typeof name,\n  TokenListState,\n  TokenListControllerMessenger\n> {\n  private readonly mutex = new Mutex();\n\n  private intervalId?: ReturnType<typeof setTimeout>;\n\n  private readonly intervalDelay: number;\n\n  private readonly cacheRefreshThreshold: number;\n\n  private chainId: Hex;\n\n  private abortController: AbortController;\n\n  /**\n   * Creates a TokenListController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.onNetworkStateChange - A function for registering an event handler for network state changes.\n   * @param options.interval - The polling interval, in milliseconds.\n   * @param options.cacheRefreshThreshold - The token cache expiry time, in milliseconds.\n   * @param options.messenger - A restricted controller messenger.\n   * @param options.state - Initial state to set on this controller.\n   * @param options.preventPollingOnNetworkRestart - Determines whether to prevent poilling on network restart in extension.\n   */\n  constructor({\n    chainId,\n    preventPollingOnNetworkRestart = false,\n    onNetworkStateChange,\n    interval = DEFAULT_INTERVAL,\n    cacheRefreshThreshold = DEFAULT_THRESHOLD,\n    messenger,\n    state,\n  }: {\n    chainId: Hex;\n    preventPollingOnNetworkRestart?: boolean;\n    onNetworkStateChange?: (\n      listener: (networkState: NetworkState) => void,\n    ) => void;\n    interval?: number;\n    cacheRefreshThreshold?: number;\n    messenger: TokenListControllerMessenger;\n    state?: Partial<TokenListState>;\n  }) {\n    super({\n      name,\n      metadata,\n      messenger,\n      state: { ...getDefaultTokenListState(), ...state },\n    });\n    this.intervalDelay = interval;\n    this.cacheRefreshThreshold = cacheRefreshThreshold;\n    this.chainId = chainId;\n    this.updatePreventPollingOnNetworkRestart(preventPollingOnNetworkRestart);\n    this.abortController = new AbortController();\n    if (onNetworkStateChange) {\n      onNetworkStateChange(async (networkControllerState) => {\n        await this.#onNetworkControllerStateChange(networkControllerState);\n      });\n    } else {\n      this.messagingSystem.subscribe(\n        'NetworkController:stateChange',\n        async (networkControllerState) => {\n          await this.#onNetworkControllerStateChange(networkControllerState);\n        },\n      );\n    }\n  }\n\n  /**\n   * Updates state and restarts polling on changes to the network controller\n   * state.\n   *\n   * @param networkControllerState - The updated network controller state.\n   */\n  async #onNetworkControllerStateChange(networkControllerState: NetworkState) {\n    if (this.chainId !== networkControllerState.providerConfig.chainId) {\n      this.abortController.abort();\n      this.abortController = new AbortController();\n      this.chainId = networkControllerState.providerConfig.chainId;\n      if (this.state.preventPollingOnNetworkRestart) {\n        this.clearingTokenListData();\n      } else {\n        // Ensure tokenList is referencing data from correct network\n        this.update(() => {\n          return {\n            ...this.state,\n            tokenList: this.state.tokensChainsCache[this.chainId]?.data || {},\n          };\n        });\n        await this.restart();\n      }\n    }\n  }\n\n  /**\n   * Start polling for the token list.\n   */\n  async start() {\n    if (!isTokenListSupportedForNetwork(this.chainId)) {\n      return;\n    }\n    await this.startPolling();\n  }\n\n  /**\n   * Restart polling for the token list.\n   */\n  async restart() {\n    this.stopPolling();\n    await this.startPolling();\n  }\n\n  /**\n   * Stop polling for the token list.\n   */\n  stop() {\n    this.stopPolling();\n  }\n\n  /**\n   * Prepare to discard this controller.\n   *\n   * This stops any active polling.\n   */\n  override destroy() {\n    super.destroy();\n    this.stopPolling();\n  }\n\n  private stopPolling() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n  }\n\n  /**\n   * Starts a new polling interval.\n   */\n  private async startPolling(): Promise<void> {\n    await safelyExecute(() => this.fetchTokenList());\n    this.intervalId = setInterval(async () => {\n      await safelyExecute(() => this.fetchTokenList());\n    }, this.intervalDelay);\n  }\n\n  /**\n   * Fetching token list from the Token Service API.\n   *\n   * @private\n   * @param networkClientId - The ID of the network client triggering the fetch.\n   * @returns A promise that resolves when this operation completes.\n   */\n  async _executePoll(networkClientId: string): Promise<void> {\n    return this.fetchTokenList(networkClientId);\n  }\n\n  /**\n   * Fetching token list from the Token Service API.\n   *\n   * @param networkClientId - The ID of the network client triggering the fetch.\n   */\n  async fetchTokenList(networkClientId?: NetworkClientId): Promise<void> {\n    const releaseLock = await this.mutex.acquire();\n    let networkClient;\n    if (networkClientId) {\n      networkClient = this.messagingSystem.call(\n        'NetworkController:getNetworkClientById',\n        networkClientId,\n      );\n    }\n    const chainId = networkClient?.configuration.chainId ?? this.chainId;\n    try {\n      const { tokensChainsCache } = this.state;\n      let tokenList: TokenListMap = {};\n      const cachedTokens = await safelyExecute(() =>\n        this.#fetchFromCache(chainId),\n      );\n      if (cachedTokens) {\n        // Use non-expired cached tokens\n        tokenList = { ...cachedTokens };\n      } else {\n        // Fetch fresh token list\n        const tokensFromAPI = await safelyExecute(\n          () =>\n            fetchTokenListByChainId(\n              chainId,\n              this.abortController.signal,\n            ) as Promise<TokenListToken[]>,\n        );\n\n        if (!tokensFromAPI) {\n          // Fallback to expired cached tokens\n          tokenList = { ...(tokensChainsCache[chainId]?.data || {}) };\n          this.update(() => {\n            return {\n              ...this.state,\n              tokenList,\n              tokensChainsCache,\n            };\n          });\n          return;\n        }\n        for (const token of tokensFromAPI) {\n          const formattedToken: TokenListToken = {\n            ...token,\n            aggregators: formatAggregatorNames(token.aggregators),\n            iconUrl: formatIconUrlWithProxy({\n              chainId,\n              tokenAddress: token.address,\n            }),\n          };\n          tokenList[token.address] = formattedToken;\n        }\n      }\n      const updatedTokensChainsCache: TokensChainsCache = {\n        ...tokensChainsCache,\n        [chainId]: {\n          timestamp: Date.now(),\n          data: tokenList,\n        },\n      };\n      this.update(() => {\n        return {\n          ...this.state,\n          tokenList,\n          tokensChainsCache: updatedTokensChainsCache,\n        };\n      });\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Checks if the Cache timestamp is valid,\n   * if yes data in cache will be returned\n   * otherwise null will be returned.\n   * @param chainId - The chain ID of the network for which to fetch the cache.\n   * @returns The cached data, or `null` if the cache was expired.\n   */\n  async #fetchFromCache(chainId: Hex): Promise<TokenListMap | null> {\n    const { tokensChainsCache }: TokenListState = this.state;\n    const dataCache = tokensChainsCache[chainId];\n    const now = Date.now();\n    if (\n      dataCache?.data &&\n      now - dataCache?.timestamp < this.cacheRefreshThreshold\n    ) {\n      return dataCache.data;\n    }\n    return null;\n  }\n\n  /**\n   * Clearing tokenList and tokensChainsCache explicitly.\n   */\n  clearingTokenListData(): void {\n    this.update(() => {\n      return {\n        ...this.state,\n        tokenList: {},\n        tokensChainsCache: {},\n      };\n    });\n  }\n\n  /**\n   * Updates preventPollingOnNetworkRestart from extension.\n   *\n   * @param shouldPreventPolling - Determine whether to prevent polling on network change\n   */\n  updatePreventPollingOnNetworkRestart(shouldPreventPolling: boolean): void {\n    this.update(() => {\n      return {\n        ...this.state,\n        preventPollingOnNetworkRestart: shouldPreventPolling,\n      };\n    });\n  }\n}\n\nexport default TokenListController;\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-LD4GC7OR.js b/node_modules/@metamask/assets-controllers/dist/chunk-LD4GC7OR.js
new file mode 100644
index 0000000..cd8f792
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-LD4GC7OR.js
@@ -0,0 +1,139 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});
+
+
+
+var _chunkZ4BLTVTBjs = require('./chunk-Z4BLTVTB.js');
+
+// src/TokenBalancesController.ts
+
+
+var _basecontroller = require('@metamask/base-controller');
+var _controllerutils = require('@metamask/controller-utils');
+var DEFAULT_INTERVAL = 18e4;
+var controllerName = "TokenBalancesController";
+var metadata = {
+  contractBalances: { persist: true, anonymous: false }
+};
+function getDefaultTokenBalancesState() {
+  return {
+    contractBalances: {}
+  };
+}
+var _handle, _getERC20BalanceOf, _interval, _tokens, _disabled;
+var TokenBalancesController = class extends _basecontroller.BaseController {
+  /**
+   * Construct a Token Balances Controller.
+   *
+   * @param options - The controller options.
+   * @param options.interval - Polling interval used to fetch new token balances.
+   * @param options.tokens - List of tokens to track balances for.
+   * @param options.disabled - If set to true, all tracked tokens contract balances updates are blocked.
+   * @param options.getERC20BalanceOf - Gets the balance of the given account at the given contract address.
+   * @param options.state - Initial state to set on this controller.
+   * @param options.messenger - The controller restricted messenger.
+   */
+  constructor({
+    interval = DEFAULT_INTERVAL,
+    tokens = [],
+    disabled = false,
+    getERC20BalanceOf,
+    messenger,
+    state = {}
+  }) {
+    super({
+      name: controllerName,
+      metadata,
+      messenger,
+      state: {
+        ...getDefaultTokenBalancesState(),
+        ...state
+      }
+    });
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _handle, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getERC20BalanceOf, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _interval, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _tokens, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _disabled, void 0);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _disabled, disabled);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _interval, interval);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _tokens, tokens);
+    this.messagingSystem.subscribe(
+      "TokensController:stateChange",
+      ({ tokens: newTokens, detectedTokens }) => {
+        _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _tokens, [...newTokens, ...detectedTokens]);
+        this.updateBalances();
+      }
+    );
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _getERC20BalanceOf, getERC20BalanceOf);
+    this.poll();
+  }
+  /**
+   * Allows controller to update tracked tokens contract balances.
+   */
+  enable() {
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _disabled, false);
+  }
+  /**
+   * Blocks controller from updating tracked tokens contract balances.
+   */
+  disable() {
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _disabled, true);
+  }
+  /**
+   * Starts a new polling interval.
+   *
+   * @param interval - Polling interval used to fetch new token balances.
+   */
+  async poll(interval) {
+    if (interval) {
+      _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _interval, interval);
+    }
+    if (_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _handle)) {
+      clearTimeout(_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _handle));
+    }
+    await _controllerutils.safelyExecute.call(void 0, () => this.updateBalances());
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _handle, setTimeout(() => {
+      this.poll(_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _interval));
+    }, _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _interval)));
+  }
+  /**
+   * Updates balances for all tokens.
+   */
+  async updateBalances() {
+    if (_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _disabled)) {
+      return;
+    }
+    const newContractBalances = {};
+    for (const token of _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _tokens)) {
+      const { address } = token;
+      const { selectedAddress } = this.messagingSystem.call(
+        "PreferencesController:getState"
+      );
+      try {
+        newContractBalances[address] = _controllerutils.toHex.call(void 0, 
+          await _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _getERC20BalanceOf).call(this, address, selectedAddress)
+        );
+        token.balanceError = null;
+      } catch (error) {
+        newContractBalances[address] = _controllerutils.toHex.call(void 0, 0);
+        token.balanceError = error;
+      }
+    }
+    this.update((state) => {
+      state.contractBalances = newContractBalances;
+    });
+  }
+};
+_handle = new WeakMap();
+_getERC20BalanceOf = new WeakMap();
+_interval = new WeakMap();
+_tokens = new WeakMap();
+_disabled = new WeakMap();
+var TokenBalancesController_default = TokenBalancesController;
+
+
+
+
+
+exports.getDefaultTokenBalancesState = getDefaultTokenBalancesState; exports.TokenBalancesController = TokenBalancesController; exports.TokenBalancesController_default = TokenBalancesController_default;
+//# sourceMappingURL=chunk-LD4GC7OR.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-LD4GC7OR.js.map b/node_modules/@metamask/assets-controllers/dist/chunk-LD4GC7OR.js.map
new file mode 100644
index 0000000..d8e6599
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-LD4GC7OR.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/TokenBalancesController.ts"],"names":[],"mappings":";;;;;;;AAAA;AAAA,EAIE;AAAA,OACK;AACP,SAAS,eAAe,aAAa;AAOrC,IAAM,mBAAmB;AAEzB,IAAM,iBAAiB;AAEvB,IAAM,WAAW;AAAA,EACf,kBAAkB,EAAE,SAAS,MAAM,WAAW,MAAM;AACtD;AAiEO,SAAS,+BAA6D;AAC3E,SAAO;AAAA,IACL,kBAAkB,CAAC;AAAA,EACrB;AACF;AAxFA;AA8FO,IAAM,0BAAN,cAAsC,eAI3C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAsBA,YAAY;AAAA,IACV,WAAW;AAAA,IACX,SAAS,CAAC;AAAA,IACV,WAAW;AAAA,IACX;AAAA,IACA;AAAA,IACA,QAAQ,CAAC;AAAA,EACX,GAAmC;AACjC,UAAM;AAAA,MACJ,MAAM;AAAA,MACN;AAAA,MACA;AAAA,MACA,OAAO;AAAA,QACL,GAAG,6BAA6B;AAAA,QAChC,GAAG;AAAA,MACL;AAAA,IACF,CAAC;AArCH;AAEA;AAEA;AAEA;AAEA;AA+BE,uBAAK,WAAY;AACjB,uBAAK,WAAY;AACjB,uBAAK,SAAU;AAEf,SAAK,gBAAgB;AAAA,MACnB;AAAA,MACA,CAAC,EAAE,QAAQ,WAAW,eAAe,MAAM;AACzC,2BAAK,SAAU,CAAC,GAAG,WAAW,GAAG,cAAc;AAC/C,aAAK,eAAe;AAAA,MACtB;AAAA,IACF;AAEA,uBAAK,oBAAqB;AAE1B,SAAK,KAAK;AAAA,EACZ;AAAA;AAAA;AAAA;AAAA,EAKA,SAAS;AACP,uBAAK,WAAY;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA,EAKA,UAAU;AACR,uBAAK,WAAY;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,KAAK,UAAkC;AAC3C,QAAI,UAAU;AACZ,yBAAK,WAAY;AAAA,IACnB;AAEA,QAAI,mBAAK,UAAS;AAChB,mBAAa,mBAAK,QAAO;AAAA,IAC3B;AAEA,UAAM,cAAc,MAAM,KAAK,eAAe,CAAC;AAE/C,uBAAK,SAAU,WAAW,MAAM;AAC9B,WAAK,KAAK,mBAAK,UAAS;AAAA,IAC1B,GAAG,mBAAK,UAAS;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,iBAAiB;AACrB,QAAI,mBAAK,YAAW;AAClB;AAAA,IACF;AAEA,UAAM,sBAAwC,CAAC;AAC/C,eAAW,SAAS,mBAAK,UAAS;AAChC,YAAM,EAAE,QAAQ,IAAI;AACpB,YAAM,EAAE,gBAAgB,IAAI,KAAK,gBAAgB;AAAA,QAC/C;AAAA,MACF;AACA,UAAI;AACF,4BAAoB,OAAO,IAAI;AAAA,UAC7B,MAAM,mBAAK,oBAAL,WAAwB,SAAS;AAAA,QACzC;AACA,cAAM,eAAe;AAAA,MACvB,SAAS,OAAO;AACd,4BAAoB,OAAO,IAAI,MAAM,CAAC;AACtC,cAAM,eAAe;AAAA,MACvB;AAAA,IACF;AAEA,SAAK,OAAO,CAAC,UAAU;AACrB,YAAM,mBAAmB;AAAA,IAC3B,CAAC;AAAA,EACH;AACF;AAxHE;AAEA;AAEA;AAEA;AAEA;AAkHF,IAAO,kCAAQ","sourcesContent":["import {\n  type RestrictedControllerMessenger,\n  type ControllerGetStateAction,\n  type ControllerStateChangeEvent,\n  BaseController,\n} from '@metamask/base-controller';\nimport { safelyExecute, toHex } from '@metamask/controller-utils';\nimport type { PreferencesControllerGetStateAction } from '@metamask/preferences-controller';\n\nimport type { AssetsContractController } from './AssetsContractController';\nimport type { Token } from './TokenRatesController';\nimport type { TokensControllerStateChangeEvent } from './TokensController';\n\nconst DEFAULT_INTERVAL = 180000;\n\nconst controllerName = 'TokenBalancesController';\n\nconst metadata = {\n  contractBalances: { persist: true, anonymous: false },\n};\n\n/**\n * Token balances controller options\n * @property interval - Polling interval used to fetch new token balances.\n * @property tokens - List of tokens to track balances for.\n * @property disabled - If set to true, all tracked tokens contract balances updates are blocked.\n * @property getERC20BalanceOf - Gets the balance of the given account at the given contract address.\n */\ntype TokenBalancesControllerOptions = {\n  interval?: number;\n  tokens?: Token[];\n  disabled?: boolean;\n  getERC20BalanceOf: AssetsContractController['getERC20BalanceOf'];\n  messenger: TokenBalancesControllerMessenger;\n  state?: Partial<TokenBalancesControllerState>;\n};\n\n/**\n * Represents a mapping of hash token contract addresses to their balances.\n */\ntype ContractBalances = Record<string, string>;\n\n/**\n * Token balances controller state\n * @property contractBalances - Hash of token contract addresses to balances\n */\nexport type TokenBalancesControllerState = {\n  contractBalances: ContractBalances;\n};\n\nexport type TokenBalancesControllerGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  TokenBalancesControllerState\n>;\n\nexport type TokenBalancesControllerActions =\n  TokenBalancesControllerGetStateAction;\n\nexport type AllowedActions = PreferencesControllerGetStateAction;\n\nexport type TokenBalancesControllerStateChangeEvent =\n  ControllerStateChangeEvent<\n    typeof controllerName,\n    TokenBalancesControllerState\n  >;\n\nexport type TokenBalancesControllerEvents =\n  TokenBalancesControllerStateChangeEvent;\n\nexport type AllowedEvents = TokensControllerStateChangeEvent;\n\nexport type TokenBalancesControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  TokenBalancesControllerActions | AllowedActions,\n  TokenBalancesControllerEvents | AllowedEvents,\n  AllowedActions['type'],\n  AllowedEvents['type']\n>;\n\n/**\n * Get the default TokenBalancesController state.\n *\n * @returns The default TokenBalancesController state.\n */\nexport function getDefaultTokenBalancesState(): TokenBalancesControllerState {\n  return {\n    contractBalances: {},\n  };\n}\n\n/**\n * Controller that passively polls on a set interval token balances\n * for tokens stored in the TokensController\n */\nexport class TokenBalancesController extends BaseController<\n  typeof controllerName,\n  TokenBalancesControllerState,\n  TokenBalancesControllerMessenger\n> {\n  #handle?: ReturnType<typeof setTimeout>;\n\n  #getERC20BalanceOf: AssetsContractController['getERC20BalanceOf'];\n\n  #interval: number;\n\n  #tokens: Token[];\n\n  #disabled: boolean;\n\n  /**\n   * Construct a Token Balances Controller.\n   *\n   * @param options - The controller options.\n   * @param options.interval - Polling interval used to fetch new token balances.\n   * @param options.tokens - List of tokens to track balances for.\n   * @param options.disabled - If set to true, all tracked tokens contract balances updates are blocked.\n   * @param options.getERC20BalanceOf - Gets the balance of the given account at the given contract address.\n   * @param options.state - Initial state to set on this controller.\n   * @param options.messenger - The controller restricted messenger.\n   */\n  constructor({\n    interval = DEFAULT_INTERVAL,\n    tokens = [],\n    disabled = false,\n    getERC20BalanceOf,\n    messenger,\n    state = {},\n  }: TokenBalancesControllerOptions) {\n    super({\n      name: controllerName,\n      metadata,\n      messenger,\n      state: {\n        ...getDefaultTokenBalancesState(),\n        ...state,\n      },\n    });\n\n    this.#disabled = disabled;\n    this.#interval = interval;\n    this.#tokens = tokens;\n\n    this.messagingSystem.subscribe(\n      'TokensController:stateChange',\n      ({ tokens: newTokens, detectedTokens }) => {\n        this.#tokens = [...newTokens, ...detectedTokens];\n        this.updateBalances();\n      },\n    );\n\n    this.#getERC20BalanceOf = getERC20BalanceOf;\n\n    this.poll();\n  }\n\n  /**\n   * Allows controller to update tracked tokens contract balances.\n   */\n  enable() {\n    this.#disabled = false;\n  }\n\n  /**\n   * Blocks controller from updating tracked tokens contract balances.\n   */\n  disable() {\n    this.#disabled = true;\n  }\n\n  /**\n   * Starts a new polling interval.\n   *\n   * @param interval - Polling interval used to fetch new token balances.\n   */\n  async poll(interval?: number): Promise<void> {\n    if (interval) {\n      this.#interval = interval;\n    }\n\n    if (this.#handle) {\n      clearTimeout(this.#handle);\n    }\n\n    await safelyExecute(() => this.updateBalances());\n\n    this.#handle = setTimeout(() => {\n      this.poll(this.#interval);\n    }, this.#interval);\n  }\n\n  /**\n   * Updates balances for all tokens.\n   */\n  async updateBalances() {\n    if (this.#disabled) {\n      return;\n    }\n\n    const newContractBalances: ContractBalances = {};\n    for (const token of this.#tokens) {\n      const { address } = token;\n      const { selectedAddress } = this.messagingSystem.call(\n        'PreferencesController:getState',\n      );\n      try {\n        newContractBalances[address] = toHex(\n          await this.#getERC20BalanceOf(address, selectedAddress),\n        );\n        token.balanceError = null;\n      } catch (error) {\n        newContractBalances[address] = toHex(0);\n        token.balanceError = error;\n      }\n    }\n\n    this.update((state) => {\n      state.contractBalances = newContractBalances;\n    });\n  }\n}\n\nexport default TokenBalancesController;\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-MQ7TIWBK.mjs b/node_modules/@metamask/assets-controllers/dist/chunk-MQ7TIWBK.mjs
new file mode 100644
index 0000000..e31e1c2
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-MQ7TIWBK.mjs
@@ -0,0 +1,115 @@
+import {
+  ethersBigNumberToBN
+} from "./chunk-E5PIGGYR.mjs";
+
+// src/Standards/ERC20Standard.ts
+import { toUtf8 } from "@ethereumjs/util";
+import { Contract } from "@ethersproject/contracts";
+import { decodeSingle } from "@metamask/abi-utils";
+import { ERC20 } from "@metamask/controller-utils";
+import { abiERC20 } from "@metamask/metamask-eth-abis";
+import { assertIsStrictHexString } from "@metamask/utils";
+var ERC20Standard = class {
+  constructor(provider) {
+    this.provider = provider;
+  }
+  /**
+   * Get balance or count for current account on specific asset contract.
+   *
+   * @param address - Asset ERC20 contract address.
+   * @param selectedAddress - Current account public address.
+   * @returns Promise resolving to BN object containing balance for current account on specific asset contract.
+   */
+  async getBalanceOf(address, selectedAddress) {
+    const contract = new Contract(address, abiERC20, this.provider);
+    const balance = await contract.balanceOf(selectedAddress);
+    return ethersBigNumberToBN(balance);
+  }
+  /**
+   * Query for the decimals for a given ERC20 asset.
+   *
+   * @param address - ERC20 asset contract string.
+   * @returns Promise resolving to the 'decimals'.
+   */
+  async getTokenDecimals(address) {
+    const contract = new Contract(address, abiERC20, this.provider);
+    try {
+      const decimals = await contract.decimals();
+      return decimals.toString();
+    } catch (err) {
+      if (err instanceof Error && err.message.includes("call revert exception")) {
+        throw new Error("Failed to parse token decimals");
+      }
+      throw err;
+    }
+  }
+  /**
+   * Query for the name for a given ERC20 asset.
+   *
+   * @param address - ERC20 asset contract string.
+   * @returns Promise resolving to the 'name'.
+   */
+  async getTokenName(address) {
+    const contract = new Contract(address, abiERC20, this.provider);
+    try {
+      const name = await contract.name();
+      return name.toString();
+    } catch (err) {
+      if (err instanceof Error && err.message.includes("call revert exception")) {
+        throw new Error("Failed to parse token name");
+      }
+      throw err;
+    }
+  }
+  /**
+   * Query for symbol for a given ERC20 asset.
+   *
+   * @param address - ERC20 asset contract address.
+   * @returns Promise resolving to the 'symbol'.
+   */
+  async getTokenSymbol(address) {
+    const payload = { to: address, data: "0x95d89b41" };
+    const result = await this.provider.call(payload);
+    assertIsStrictHexString(result);
+    try {
+      const decoded = decodeSingle("string", result);
+      if (decoded?.length > 0) {
+        return decoded;
+      }
+    } catch {
+    }
+    try {
+      const utf8 = toUtf8(result);
+      if (utf8.length > 0) {
+        return utf8;
+      }
+    } catch {
+    }
+    throw new Error("Failed to parse token symbol");
+  }
+  /**
+   * Query if a contract implements an interface.
+   *
+   * @param address - Asset contract address.
+   * @param userAddress - The public address for the currently active user's account.
+   * @returns Promise resolving an object containing the standard, decimals, symbol and balance of the given contract/userAddress pair.
+   */
+  async getDetails(address, userAddress) {
+    const [decimals, symbol, balance] = await Promise.all([
+      this.getTokenDecimals(address),
+      this.getTokenSymbol(address),
+      userAddress ? this.getBalanceOf(address, userAddress) : void 0
+    ]);
+    return {
+      decimals,
+      symbol,
+      balance,
+      standard: ERC20
+    };
+  }
+};
+
+export {
+  ERC20Standard
+};
+//# sourceMappingURL=chunk-MQ7TIWBK.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-MQ7TIWBK.mjs.map b/node_modules/@metamask/assets-controllers/dist/chunk-MQ7TIWBK.mjs.map
new file mode 100644
index 0000000..935aa5b
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-MQ7TIWBK.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/Standards/ERC20Standard.ts"],"sourcesContent":["import { toUtf8 } from '@ethereumjs/util';\nimport { Contract } from '@ethersproject/contracts';\nimport type { Web3Provider } from '@ethersproject/providers';\nimport { decodeSingle } from '@metamask/abi-utils';\nimport { ERC20 } from '@metamask/controller-utils';\nimport { abiERC20 } from '@metamask/metamask-eth-abis';\nimport { assertIsStrictHexString } from '@metamask/utils';\nimport type BN from 'bn.js';\n\nimport { ethersBigNumberToBN } from '../assetsUtil';\n\nexport class ERC20Standard {\n  private readonly provider: Web3Provider;\n\n  constructor(provider: Web3Provider) {\n    this.provider = provider;\n  }\n\n  /**\n   * Get balance or count for current account on specific asset contract.\n   *\n   * @param address - Asset ERC20 contract address.\n   * @param selectedAddress - Current account public address.\n   * @returns Promise resolving to BN object containing balance for current account on specific asset contract.\n   */\n  async getBalanceOf(address: string, selectedAddress: string): Promise<BN> {\n    const contract = new Contract(address, abiERC20, this.provider);\n    const balance = await contract.balanceOf(selectedAddress);\n    return ethersBigNumberToBN(balance);\n  }\n\n  /**\n   * Query for the decimals for a given ERC20 asset.\n   *\n   * @param address - ERC20 asset contract string.\n   * @returns Promise resolving to the 'decimals'.\n   */\n  async getTokenDecimals(address: string): Promise<string> {\n    const contract = new Contract(address, abiERC20, this.provider);\n    try {\n      const decimals = await contract.decimals();\n      return decimals.toString();\n    } catch (err) {\n      // Mirror previous implementation\n      if (\n        err instanceof Error &&\n        err.message.includes('call revert exception')\n      ) {\n        throw new Error('Failed to parse token decimals');\n      }\n      throw err;\n    }\n  }\n\n  /**\n   * Query for the name for a given ERC20 asset.\n   *\n   * @param address - ERC20 asset contract string.\n   * @returns Promise resolving to the 'name'.\n   */\n  async getTokenName(address: string): Promise<string> {\n    const contract = new Contract(address, abiERC20, this.provider);\n    try {\n      const name = await contract.name();\n      return name.toString();\n    } catch (err) {\n      // Mirror previous implementation\n      if (\n        err instanceof Error &&\n        err.message.includes('call revert exception')\n      ) {\n        throw new Error('Failed to parse token name');\n      }\n      throw err;\n    }\n  }\n\n  /**\n   * Query for symbol for a given ERC20 asset.\n   *\n   * @param address - ERC20 asset contract address.\n   * @returns Promise resolving to the 'symbol'.\n   */\n  async getTokenSymbol(address: string): Promise<string> {\n    // Signature for calling `symbol()`\n    const payload = { to: address, data: '0x95d89b41' };\n    const result = await this.provider.call(payload);\n    assertIsStrictHexString(result);\n    // Parse as string - treat empty string as failure\n    try {\n      const decoded = decodeSingle('string', result);\n      if (decoded?.length > 0) {\n        return decoded;\n      }\n    } catch {\n      // Ignore error\n    }\n\n    // Parse as bytes - treat empty string as failure\n    try {\n      const utf8 = toUtf8(result);\n      if (utf8.length > 0) {\n        return utf8;\n      }\n    } catch {\n      // Ignore error\n    }\n\n    throw new Error('Failed to parse token symbol');\n  }\n\n  /**\n   * Query if a contract implements an interface.\n   *\n   * @param address - Asset contract address.\n   * @param userAddress - The public address for the currently active user's account.\n   * @returns Promise resolving an object containing the standard, decimals, symbol and balance of the given contract/userAddress pair.\n   */\n  async getDetails(\n    address: string,\n    userAddress?: string,\n  ): Promise<{\n    standard: string;\n    symbol: string | undefined;\n    decimals: string | undefined;\n    balance: BN | undefined;\n  }> {\n    const [decimals, symbol, balance] = await Promise.all([\n      this.getTokenDecimals(address),\n      this.getTokenSymbol(address),\n      userAddress ? this.getBalanceOf(address, userAddress) : undefined,\n    ]);\n    return {\n      decimals,\n      symbol,\n      balance,\n      standard: ERC20,\n    };\n  }\n}\n"],"mappings":";;;;;AAAA,SAAS,cAAc;AACvB,SAAS,gBAAgB;AAEzB,SAAS,oBAAoB;AAC7B,SAAS,aAAa;AACtB,SAAS,gBAAgB;AACzB,SAAS,+BAA+B;AAKjC,IAAM,gBAAN,MAAoB;AAAA,EAGzB,YAAY,UAAwB;AAClC,SAAK,WAAW;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,aAAa,SAAiB,iBAAsC;AACxE,UAAM,WAAW,IAAI,SAAS,SAAS,UAAU,KAAK,QAAQ;AAC9D,UAAM,UAAU,MAAM,SAAS,UAAU,eAAe;AACxD,WAAO,oBAAoB,OAAO;AAAA,EACpC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,iBAAiB,SAAkC;AACvD,UAAM,WAAW,IAAI,SAAS,SAAS,UAAU,KAAK,QAAQ;AAC9D,QAAI;AACF,YAAM,WAAW,MAAM,SAAS,SAAS;AACzC,aAAO,SAAS,SAAS;AAAA,IAC3B,SAAS,KAAK;AAEZ,UACE,eAAe,SACf,IAAI,QAAQ,SAAS,uBAAuB,GAC5C;AACA,cAAM,IAAI,MAAM,gCAAgC;AAAA,MAClD;AACA,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,aAAa,SAAkC;AACnD,UAAM,WAAW,IAAI,SAAS,SAAS,UAAU,KAAK,QAAQ;AAC9D,QAAI;AACF,YAAM,OAAO,MAAM,SAAS,KAAK;AACjC,aAAO,KAAK,SAAS;AAAA,IACvB,SAAS,KAAK;AAEZ,UACE,eAAe,SACf,IAAI,QAAQ,SAAS,uBAAuB,GAC5C;AACA,cAAM,IAAI,MAAM,4BAA4B;AAAA,MAC9C;AACA,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,eAAe,SAAkC;AAErD,UAAM,UAAU,EAAE,IAAI,SAAS,MAAM,aAAa;AAClD,UAAM,SAAS,MAAM,KAAK,SAAS,KAAK,OAAO;AAC/C,4BAAwB,MAAM;AAE9B,QAAI;AACF,YAAM,UAAU,aAAa,UAAU,MAAM;AAC7C,UAAI,SAAS,SAAS,GAAG;AACvB,eAAO;AAAA,MACT;AAAA,IACF,QAAQ;AAAA,IAER;AAGA,QAAI;AACF,YAAM,OAAO,OAAO,MAAM;AAC1B,UAAI,KAAK,SAAS,GAAG;AACnB,eAAO;AAAA,MACT;AAAA,IACF,QAAQ;AAAA,IAER;AAEA,UAAM,IAAI,MAAM,8BAA8B;AAAA,EAChD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,WACJ,SACA,aAMC;AACD,UAAM,CAAC,UAAU,QAAQ,OAAO,IAAI,MAAM,QAAQ,IAAI;AAAA,MACpD,KAAK,iBAAiB,OAAO;AAAA,MAC7B,KAAK,eAAe,OAAO;AAAA,MAC3B,cAAc,KAAK,aAAa,SAAS,WAAW,IAAI;AAAA,IAC1D,CAAC;AACD,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA,UAAU;AAAA,IACZ;AAAA,EACF;AACF;","names":[]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-NUBQRDKI.js b/node_modules/@metamask/assets-controllers/dist/chunk-NUBQRDKI.js
new file mode 100644
index 0000000..e215e98
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-NUBQRDKI.js
@@ -0,0 +1,704 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+
+var _chunkVHCPQS4Xjs = require('./chunk-VHCPQS4X.js');
+
+
+var _chunk355MWUUQjs = require('./chunk-355MWUUQ.js');
+
+
+
+var _chunkVY7TUOK2js = require('./chunk-VY7TUOK2.js');
+
+
+
+var _chunkRELRWIJNjs = require('./chunk-RELRWIJN.js');
+
+// src/TokensController.ts
+var _contracts = require('@ethersproject/contracts');
+var _providers = require('@ethersproject/providers');
+var _basecontroller = require('@metamask/base-controller');
+var _contractmetadata = require('@metamask/contract-metadata'); var _contractmetadata2 = _interopRequireDefault(_contractmetadata);
+
+
+
+
+
+
+
+
+
+
+var _controllerutils = require('@metamask/controller-utils');
+var _metamaskethabis = require('@metamask/metamask-eth-abis');
+var _rpcerrors = require('@metamask/rpc-errors');
+var _asyncmutex = require('async-mutex');
+var _events = require('events');
+var _uuid = require('uuid');
+var controllerName = "TokensController";
+var getDefaultTokensState = () => {
+  return {
+    tokens: [],
+    ignoredTokens: [],
+    detectedTokens: [],
+    allTokens: {},
+    allIgnoredTokens: {},
+    allDetectedTokens: {}
+  };
+};
+var TokensController = class extends _basecontroller.BaseControllerV1 {
+  /**
+   * Creates a TokensController instance.
+   *
+   * @param options - The controller options.
+   * @param options.chainId - The chain ID of the current network.
+   * @param options.config - Initial options used to configure this controller.
+   * @param options.state - Initial state to set on this controller.
+   * @param options.messenger - The controller messenger.
+   */
+  constructor({
+    chainId: initialChainId,
+    config,
+    state,
+    messenger
+  }) {
+    super(config, state);
+    this.mutex = new (0, _asyncmutex.Mutex)();
+    /**
+     * EventEmitter instance used to listen to specific EIP747 events
+     */
+    this.hub = new (0, _events.EventEmitter)();
+    /**
+     * Name of this controller used during composition
+     */
+    this.name = "TokensController";
+    this.defaultConfig = {
+      selectedAddress: "",
+      chainId: initialChainId,
+      provider: void 0,
+      ...config
+    };
+    this.defaultState = {
+      ...getDefaultTokensState(),
+      ...state
+    };
+    this.initialize();
+    this.abortController = new AbortController();
+    this.messagingSystem = messenger;
+    this.messagingSystem.registerActionHandler(
+      `${controllerName}:addDetectedTokens`,
+      this.addDetectedTokens.bind(this)
+    );
+    this.messagingSystem.subscribe(
+      "PreferencesController:stateChange",
+      ({ selectedAddress }) => {
+        const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
+        const { chainId } = this.config;
+        this.configure({ selectedAddress });
+        this.update({
+          tokens: allTokens[chainId]?.[selectedAddress] ?? [],
+          ignoredTokens: allIgnoredTokens[chainId]?.[selectedAddress] ?? [],
+          detectedTokens: allDetectedTokens[chainId]?.[selectedAddress] ?? []
+        });
+      }
+    );
+    this.messagingSystem.subscribe(
+      "NetworkController:networkDidChange",
+      ({ providerConfig }) => {
+        const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
+        const { selectedAddress } = this.config;
+        const { chainId } = providerConfig;
+        this.abortController.abort();
+        this.abortController = new AbortController();
+        this.configure({ chainId });
+        this.update({
+          tokens: allTokens[chainId]?.[selectedAddress] || [],
+          ignoredTokens: allIgnoredTokens[chainId]?.[selectedAddress] || [],
+          detectedTokens: allDetectedTokens[chainId]?.[selectedAddress] || []
+        });
+      }
+    );
+    this.messagingSystem.subscribe(
+      "TokenListController:stateChange",
+      ({ tokenList }) => {
+        const { tokens } = this.state;
+        if (tokens.length && !tokens[0].name) {
+          this.updateTokensAttribute(tokenList, "name");
+        }
+      }
+    );
+  }
+  /**
+   * Fetch metadata for a token.
+   *
+   * @param tokenAddress - The address of the token.
+   * @returns The token metadata.
+   */
+  async fetchTokenMetadata(tokenAddress) {
+    try {
+      const token = await _chunkVY7TUOK2js.fetchTokenMetadata.call(void 0, 
+        this.config.chainId,
+        tokenAddress,
+        this.abortController.signal
+      );
+      return token;
+    } catch (error) {
+      if (error instanceof Error && error.message.includes(_chunkVY7TUOK2js.TOKEN_METADATA_NO_SUPPORT_ERROR)) {
+        return void 0;
+      }
+      throw error;
+    }
+  }
+  /**
+   * Adds a token to the stored token list.
+   *
+   * @param options - The method argument object.
+   * @param options.address - Hex address of the token contract.
+   * @param options.symbol - Symbol of the token.
+   * @param options.decimals - Number of decimals the token uses.
+   * @param options.name - Name of the token.
+   * @param options.image - Image of the token.
+   * @param options.interactingAddress - The address of the account to add a token to.
+   * @param options.networkClientId - Network Client ID.
+   * @returns Current token list.
+   */
+  async addToken({
+    address,
+    symbol,
+    decimals,
+    name,
+    image,
+    interactingAddress,
+    networkClientId
+  }) {
+    const { chainId, selectedAddress } = this.config;
+    const releaseLock = await this.mutex.acquire();
+    const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
+    let currentChainId = chainId;
+    if (networkClientId) {
+      currentChainId = this.messagingSystem.call(
+        "NetworkController:getNetworkClientById",
+        networkClientId
+      ).configuration.chainId;
+    }
+    const accountAddress = interactingAddress || selectedAddress;
+    const isInteractingWithWalletAccount = accountAddress === selectedAddress;
+    try {
+      address = _controllerutils.toChecksumHexAddress.call(void 0, address);
+      const tokens = allTokens[currentChainId]?.[accountAddress] || [];
+      const ignoredTokens = allIgnoredTokens[currentChainId]?.[accountAddress] || [];
+      const detectedTokens = allDetectedTokens[currentChainId]?.[accountAddress] || [];
+      const newTokens = [...tokens];
+      const [isERC721, tokenMetadata] = await Promise.all([
+        this._detectIsERC721(address, networkClientId),
+        // TODO parameterize the token metadata fetch by networkClientId
+        this.fetchTokenMetadata(address)
+      ]);
+      if (!networkClientId && currentChainId !== this.config.chainId) {
+        throw new Error(
+          "TokensController Error: Switched networks while adding token"
+        );
+      }
+      const newEntry = {
+        address,
+        symbol,
+        decimals,
+        image: image || _chunkRELRWIJNjs.formatIconUrlWithProxy.call(void 0, {
+          chainId: currentChainId,
+          tokenAddress: address
+        }),
+        isERC721,
+        aggregators: _chunkRELRWIJNjs.formatAggregatorNames.call(void 0, tokenMetadata?.aggregators || []),
+        name
+      };
+      const previousIndex = newTokens.findIndex(
+        (token) => token.address.toLowerCase() === address.toLowerCase()
+      );
+      if (previousIndex !== -1) {
+        newTokens[previousIndex] = newEntry;
+      } else {
+        newTokens.push(newEntry);
+      }
+      const newIgnoredTokens = ignoredTokens.filter(
+        (tokenAddress) => tokenAddress.toLowerCase() !== address.toLowerCase()
+      );
+      const newDetectedTokens = detectedTokens.filter(
+        (token) => token.address.toLowerCase() !== address.toLowerCase()
+      );
+      const { newAllTokens, newAllIgnoredTokens, newAllDetectedTokens } = this._getNewAllTokensState({
+        newTokens,
+        newIgnoredTokens,
+        newDetectedTokens,
+        interactingAddress: accountAddress,
+        interactingChainId: currentChainId
+      });
+      let newState = {
+        allTokens: newAllTokens,
+        allIgnoredTokens: newAllIgnoredTokens,
+        allDetectedTokens: newAllDetectedTokens
+      };
+      if (isInteractingWithWalletAccount) {
+        newState = {
+          ...newState,
+          tokens: newTokens,
+          ignoredTokens: newIgnoredTokens,
+          detectedTokens: newDetectedTokens
+        };
+      }
+      this.update(newState);
+      return newTokens;
+    } finally {
+      releaseLock();
+    }
+  }
+  /**
+   * Add a batch of tokens.
+   *
+   * @param tokensToImport - Array of tokens to import.
+   * @param networkClientId - Optional network client ID used to determine interacting chain ID.
+   */
+  async addTokens(tokensToImport, networkClientId) {
+    const releaseLock = await this.mutex.acquire();
+    const { tokens, detectedTokens, ignoredTokens } = this.state;
+    const importedTokensMap = {};
+    const newTokensMap = tokens.reduce((output, current) => {
+      output[current.address] = current;
+      return output;
+    }, {});
+    try {
+      tokensToImport.forEach((tokenToAdd) => {
+        const { address, symbol, decimals, image, aggregators, name } = tokenToAdd;
+        const checksumAddress = _controllerutils.toChecksumHexAddress.call(void 0, address);
+        const formattedToken = {
+          address: checksumAddress,
+          symbol,
+          decimals,
+          image,
+          aggregators,
+          name
+        };
+        newTokensMap[address] = formattedToken;
+        importedTokensMap[address.toLowerCase()] = true;
+        return formattedToken;
+      });
+      const newTokens = Object.values(newTokensMap);
+      const newDetectedTokens = detectedTokens.filter(
+        (token) => !importedTokensMap[token.address.toLowerCase()]
+      );
+      const newIgnoredTokens = ignoredTokens.filter(
+        (tokenAddress) => !newTokensMap[tokenAddress.toLowerCase()]
+      );
+      let interactingChainId;
+      if (networkClientId) {
+        interactingChainId = this.messagingSystem.call(
+          "NetworkController:getNetworkClientById",
+          networkClientId
+        ).configuration.chainId;
+      }
+      const { newAllTokens, newAllDetectedTokens, newAllIgnoredTokens } = this._getNewAllTokensState({
+        newTokens,
+        newDetectedTokens,
+        newIgnoredTokens,
+        interactingChainId
+      });
+      this.update({
+        tokens: newTokens,
+        allTokens: newAllTokens,
+        detectedTokens: newDetectedTokens,
+        allDetectedTokens: newAllDetectedTokens,
+        ignoredTokens: newIgnoredTokens,
+        allIgnoredTokens: newAllIgnoredTokens
+      });
+    } finally {
+      releaseLock();
+    }
+  }
+  /**
+   * Ignore a batch of tokens.
+   *
+   * @param tokenAddressesToIgnore - Array of token addresses to ignore.
+   */
+  ignoreTokens(tokenAddressesToIgnore) {
+    const { ignoredTokens, detectedTokens, tokens } = this.state;
+    const ignoredTokensMap = {};
+    let newIgnoredTokens = [...ignoredTokens];
+    const checksummedTokenAddresses = tokenAddressesToIgnore.map((address) => {
+      const checksumAddress = _controllerutils.toChecksumHexAddress.call(void 0, address);
+      ignoredTokensMap[address.toLowerCase()] = true;
+      return checksumAddress;
+    });
+    newIgnoredTokens = [...ignoredTokens, ...checksummedTokenAddresses];
+    const newDetectedTokens = detectedTokens.filter(
+      (token) => !ignoredTokensMap[token.address.toLowerCase()]
+    );
+    const newTokens = tokens.filter(
+      (token) => !ignoredTokensMap[token.address.toLowerCase()]
+    );
+    const { newAllIgnoredTokens, newAllDetectedTokens, newAllTokens } = this._getNewAllTokensState({
+      newIgnoredTokens,
+      newDetectedTokens,
+      newTokens
+    });
+    this.update({
+      ignoredTokens: newIgnoredTokens,
+      tokens: newTokens,
+      detectedTokens: newDetectedTokens,
+      allIgnoredTokens: newAllIgnoredTokens,
+      allDetectedTokens: newAllDetectedTokens,
+      allTokens: newAllTokens
+    });
+  }
+  /**
+   * Adds a batch of detected tokens to the stored token list.
+   *
+   * @param incomingDetectedTokens - Array of detected tokens to be added or updated.
+   * @param detectionDetails - An object containing the chain ID and address of the currently selected network on which the incomingDetectedTokens were detected.
+   * @param detectionDetails.selectedAddress - the account address on which the incomingDetectedTokens were detected.
+   * @param detectionDetails.chainId - the chainId on which the incomingDetectedTokens were detected.
+   */
+  async addDetectedTokens(incomingDetectedTokens, detectionDetails) {
+    const releaseLock = await this.mutex.acquire();
+    const chainId = detectionDetails?.chainId ?? this.config.chainId;
+    const accountAddress = detectionDetails?.selectedAddress ?? this.config.selectedAddress;
+    const { allTokens, allDetectedTokens, allIgnoredTokens } = this.state;
+    let newTokens = [...allTokens?.[chainId]?.[accountAddress] ?? []];
+    let newDetectedTokens = [
+      ...allDetectedTokens?.[chainId]?.[accountAddress] ?? []
+    ];
+    try {
+      incomingDetectedTokens.forEach((tokenToAdd) => {
+        const {
+          address,
+          symbol,
+          decimals,
+          image,
+          aggregators,
+          isERC721,
+          name
+        } = tokenToAdd;
+        const checksumAddress = _controllerutils.toChecksumHexAddress.call(void 0, address);
+        const newEntry = {
+          address: checksumAddress,
+          symbol,
+          decimals,
+          image,
+          isERC721,
+          aggregators,
+          name
+        };
+        const previousImportedIndex = newTokens.findIndex(
+          (token) => token.address.toLowerCase() === checksumAddress.toLowerCase()
+        );
+        if (previousImportedIndex !== -1) {
+          newTokens[previousImportedIndex] = newEntry;
+        } else {
+          const ignoredTokenIndex = allIgnoredTokens?.[chainId]?.[accountAddress]?.indexOf(address) ?? -1;
+          if (ignoredTokenIndex === -1) {
+            const previousDetectedIndex = newDetectedTokens.findIndex(
+              (token) => token.address.toLowerCase() === checksumAddress.toLowerCase()
+            );
+            if (previousDetectedIndex !== -1) {
+              newDetectedTokens[previousDetectedIndex] = newEntry;
+            } else {
+              newDetectedTokens.push(newEntry);
+            }
+          }
+        }
+      });
+      const { newAllTokens, newAllDetectedTokens } = this._getNewAllTokensState(
+        {
+          newTokens,
+          newDetectedTokens,
+          interactingAddress: accountAddress,
+          interactingChainId: chainId
+        }
+      );
+      const { chainId: currentChain, selectedAddress: currentAddress } = this.config;
+      newTokens = newAllTokens?.[currentChain]?.[currentAddress] || [];
+      newDetectedTokens = newAllDetectedTokens?.[currentChain]?.[currentAddress] || [];
+      this.update({
+        tokens: newTokens,
+        allTokens: newAllTokens,
+        detectedTokens: newDetectedTokens,
+        allDetectedTokens: newAllDetectedTokens
+      });
+    } finally {
+      releaseLock();
+    }
+  }
+  /**
+   * Adds isERC721 field to token object. This is called when a user attempts to add tokens that
+   * were previously added which do not yet had isERC721 field.
+   *
+   * @param tokenAddress - The contract address of the token requiring the isERC721 field added.
+   * @returns The new token object with the added isERC721 field.
+   */
+  async updateTokenType(tokenAddress) {
+    const isERC721 = await this._detectIsERC721(tokenAddress);
+    const { tokens } = this.state;
+    const tokenIndex = tokens.findIndex((token) => {
+      return token.address.toLowerCase() === tokenAddress.toLowerCase();
+    });
+    tokens[tokenIndex].isERC721 = isERC721;
+    this.update({ tokens });
+    return tokens[tokenIndex];
+  }
+  /**
+   * This is a function that updates the tokens name for the tokens name if it is not defined.
+   *
+   * @param tokenList - Represents the fetched token list from service API
+   * @param tokenAttribute - Represents the token attribute that we want to update on the token list
+   */
+  updateTokensAttribute(tokenList, tokenAttribute) {
+    const { tokens } = this.state;
+    const newTokens = tokens.map((token) => {
+      const newToken = tokenList[token.address.toLowerCase()];
+      return !token[tokenAttribute] && newToken?.[tokenAttribute] ? { ...token, [tokenAttribute]: newToken[tokenAttribute] } : { ...token };
+    });
+    this.update({ tokens: newTokens });
+  }
+  /**
+   * Detects whether or not a token is ERC-721 compatible.
+   *
+   * @param tokenAddress - The token contract address.
+   * @param networkClientId - Optional network client ID to fetch contract info with.
+   * @returns A boolean indicating whether the token address passed in supports the EIP-721
+   * interface.
+   */
+  async _detectIsERC721(tokenAddress, networkClientId) {
+    const checksumAddress = _controllerutils.toChecksumHexAddress.call(void 0, tokenAddress);
+    if (_contractmetadata2.default[checksumAddress]?.erc721 === true) {
+      return Promise.resolve(true);
+    } else if (_contractmetadata2.default[checksumAddress]?.erc20 === true) {
+      return Promise.resolve(false);
+    }
+    const tokenContract = this._createEthersContract(
+      tokenAddress,
+      _metamaskethabis.abiERC721,
+      networkClientId
+    );
+    try {
+      return await tokenContract.supportsInterface(_controllerutils.ERC721_INTERFACE_ID);
+    } catch (error) {
+      return false;
+    }
+  }
+  _getProvider(networkClientId) {
+    return new (0, _providers.Web3Provider)(
+      // @ts-expect-error TODO: remove this annotation once the `Eip1193Provider` class is released
+      networkClientId ? this.messagingSystem.call(
+        "NetworkController:getNetworkClientById",
+        networkClientId
+      ).provider : this.config.provider
+    );
+  }
+  _createEthersContract(tokenAddress, abi, networkClientId) {
+    const web3provider = this._getProvider(networkClientId);
+    const tokenContract = new (0, _contracts.Contract)(tokenAddress, abi, web3provider);
+    return tokenContract;
+  }
+  _generateRandomId() {
+    return _uuid.v1.call(void 0, );
+  }
+  /**
+   * Adds a new suggestedAsset to the list of watched assets.
+   * Parameters will be validated according to the asset type being watched.
+   *
+   * @param options - The method options.
+   * @param options.asset - The asset to be watched. For now only ERC20 tokens are accepted.
+   * @param options.type - The asset type.
+   * @param options.interactingAddress - The address of the account that is requesting to watch the asset.
+   * @param options.networkClientId - Network Client ID.
+   * @returns A promise that resolves if the asset was watched successfully, and rejects otherwise.
+   */
+  async watchAsset({
+    asset,
+    type,
+    interactingAddress,
+    networkClientId
+  }) {
+    if (type !== _controllerutils.ERC20) {
+      throw new Error(`Asset of type ${type} not supported`);
+    }
+    if (!asset.address) {
+      throw _rpcerrors.rpcErrors.invalidParams("Address must be specified");
+    }
+    if (!_controllerutils.isValidHexAddress.call(void 0, asset.address)) {
+      throw _rpcerrors.rpcErrors.invalidParams(`Invalid address "${asset.address}"`);
+    }
+    if (await this._detectIsERC721(asset.address, networkClientId)) {
+      throw _rpcerrors.rpcErrors.invalidParams(
+        `Contract ${asset.address} must match type ${type}, but was detected as ${_controllerutils.ERC721}`
+      );
+    }
+    const provider = this._getProvider(networkClientId);
+    const isErc1155 = await _controllerutils.safelyExecute.call(void 0, 
+      () => new (0, _chunkVHCPQS4Xjs.ERC1155Standard)(provider).contractSupportsBase1155Interface(
+        asset.address
+      )
+    );
+    if (isErc1155) {
+      throw _rpcerrors.rpcErrors.invalidParams(
+        `Contract ${asset.address} must match type ${type}, but was detected as ${_controllerutils.ERC1155}`
+      );
+    }
+    const erc20 = new (0, _chunk355MWUUQjs.ERC20Standard)(provider);
+    const [contractName, contractSymbol, contractDecimals] = await Promise.all([
+      _controllerutils.safelyExecute.call(void 0, () => erc20.getTokenName(asset.address)),
+      _controllerutils.safelyExecute.call(void 0, () => erc20.getTokenSymbol(asset.address)),
+      _controllerutils.safelyExecute.call(void 0, async () => erc20.getTokenDecimals(asset.address))
+    ]);
+    asset.name = contractName;
+    if (!asset.symbol && !contractSymbol) {
+      throw _rpcerrors.rpcErrors.invalidParams(
+        "A symbol is required, but was not found in either the request or contract"
+      );
+    }
+    if (contractSymbol !== void 0 && asset.symbol !== void 0 && asset.symbol.toUpperCase() !== contractSymbol.toUpperCase()) {
+      throw _rpcerrors.rpcErrors.invalidParams(
+        `The symbol in the request (${asset.symbol}) does not match the symbol in the contract (${contractSymbol})`
+      );
+    }
+    asset.symbol = contractSymbol ?? asset.symbol;
+    if (typeof asset.symbol !== "string") {
+      throw _rpcerrors.rpcErrors.invalidParams(`Invalid symbol: not a string`);
+    }
+    if (asset.symbol.length > 11) {
+      throw _rpcerrors.rpcErrors.invalidParams(
+        `Invalid symbol "${asset.symbol}": longer than 11 characters`
+      );
+    }
+    if (asset.decimals === void 0 && contractDecimals === void 0) {
+      throw _rpcerrors.rpcErrors.invalidParams(
+        "Decimals are required, but were not found in either the request or contract"
+      );
+    }
+    if (contractDecimals !== void 0 && asset.decimals !== void 0 && String(asset.decimals) !== contractDecimals) {
+      throw _rpcerrors.rpcErrors.invalidParams(
+        `The decimals in the request (${asset.decimals}) do not match the decimals in the contract (${contractDecimals})`
+      );
+    }
+    const decimalsStr = contractDecimals ?? asset.decimals;
+    const decimalsNum = parseInt(decimalsStr, 10);
+    if (!Number.isInteger(decimalsNum) || decimalsNum > 36 || decimalsNum < 0) {
+      throw _rpcerrors.rpcErrors.invalidParams(
+        `Invalid decimals "${decimalsStr}": must be an integer 0 <= 36`
+      );
+    }
+    asset.decimals = decimalsNum;
+    const suggestedAssetMeta = {
+      asset,
+      id: this._generateRandomId(),
+      time: Date.now(),
+      type,
+      interactingAddress: interactingAddress || this.config.selectedAddress
+    };
+    await this._requestApproval(suggestedAssetMeta);
+    const { address, symbol, decimals, name, image } = asset;
+    await this.addToken({
+      address,
+      symbol,
+      decimals,
+      name,
+      image,
+      interactingAddress: suggestedAssetMeta.interactingAddress,
+      networkClientId
+    });
+  }
+  /**
+   * Takes a new tokens and ignoredTokens array for the current network/account combination
+   * and returns new allTokens and allIgnoredTokens state to update to.
+   *
+   * @param params - Object that holds token params.
+   * @param params.newTokens - The new tokens to set for the current network and selected account.
+   * @param params.newIgnoredTokens - The new ignored tokens to set for the current network and selected account.
+   * @param params.newDetectedTokens - The new detected tokens to set for the current network and selected account.
+   * @param params.interactingAddress - The account address to use to store the tokens.
+   * @param params.interactingChainId - The chainId to use to store the tokens.
+   * @returns The updated `allTokens` and `allIgnoredTokens` state.
+   */
+  _getNewAllTokensState(params) {
+    const {
+      newTokens,
+      newIgnoredTokens,
+      newDetectedTokens,
+      interactingAddress,
+      interactingChainId
+    } = params;
+    const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
+    const { chainId, selectedAddress } = this.config;
+    const userAddressToAddTokens = interactingAddress ?? selectedAddress;
+    const chainIdToAddTokens = interactingChainId ?? chainId;
+    let newAllTokens = allTokens;
+    if (newTokens?.length || newTokens && allTokens && allTokens[chainIdToAddTokens] && allTokens[chainIdToAddTokens][userAddressToAddTokens]) {
+      const networkTokens = allTokens[chainIdToAddTokens];
+      const newNetworkTokens = {
+        ...networkTokens,
+        ...{ [userAddressToAddTokens]: newTokens }
+      };
+      newAllTokens = {
+        ...allTokens,
+        ...{ [chainIdToAddTokens]: newNetworkTokens }
+      };
+    }
+    let newAllIgnoredTokens = allIgnoredTokens;
+    if (newIgnoredTokens?.length || newIgnoredTokens && allIgnoredTokens && allIgnoredTokens[chainIdToAddTokens] && allIgnoredTokens[chainIdToAddTokens][userAddressToAddTokens]) {
+      const networkIgnoredTokens = allIgnoredTokens[chainIdToAddTokens];
+      const newIgnoredNetworkTokens = {
+        ...networkIgnoredTokens,
+        ...{ [userAddressToAddTokens]: newIgnoredTokens }
+      };
+      newAllIgnoredTokens = {
+        ...allIgnoredTokens,
+        ...{ [chainIdToAddTokens]: newIgnoredNetworkTokens }
+      };
+    }
+    let newAllDetectedTokens = allDetectedTokens;
+    if (newDetectedTokens?.length || newDetectedTokens && allDetectedTokens && allDetectedTokens[chainIdToAddTokens] && allDetectedTokens[chainIdToAddTokens][userAddressToAddTokens]) {
+      const networkDetectedTokens = allDetectedTokens[chainIdToAddTokens];
+      const newDetectedNetworkTokens = {
+        ...networkDetectedTokens,
+        ...{ [userAddressToAddTokens]: newDetectedTokens }
+      };
+      newAllDetectedTokens = {
+        ...allDetectedTokens,
+        ...{ [chainIdToAddTokens]: newDetectedNetworkTokens }
+      };
+    }
+    return { newAllTokens, newAllIgnoredTokens, newAllDetectedTokens };
+  }
+  /**
+   * Removes all tokens from the ignored list.
+   */
+  clearIgnoredTokens() {
+    this.update({ ignoredTokens: [], allIgnoredTokens: {} });
+  }
+  async _requestApproval(suggestedAssetMeta) {
+    return this.messagingSystem.call(
+      "ApprovalController:addRequest",
+      {
+        id: suggestedAssetMeta.id,
+        origin: _controllerutils.ORIGIN_METAMASK,
+        type: _controllerutils.ApprovalType.WatchAsset,
+        requestData: {
+          id: suggestedAssetMeta.id,
+          interactingAddress: suggestedAssetMeta.interactingAddress,
+          asset: {
+            address: suggestedAssetMeta.asset.address,
+            decimals: suggestedAssetMeta.asset.decimals,
+            symbol: suggestedAssetMeta.asset.symbol,
+            image: suggestedAssetMeta.asset.image || null
+          }
+        }
+      },
+      true
+    );
+  }
+};
+var TokensController_default = TokensController;
+
+
+
+
+
+exports.getDefaultTokensState = getDefaultTokensState; exports.TokensController = TokensController; exports.TokensController_default = TokensController_default;
+//# sourceMappingURL=chunk-NUBQRDKI.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-NUBQRDKI.js.map b/node_modules/@metamask/assets-controllers/dist/chunk-NUBQRDKI.js.map
new file mode 100644
index 0000000..8316c26
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-NUBQRDKI.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/TokensController.ts"],"names":[],"mappings":"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","sourcesContent":["import { Contract } from '@ethersproject/contracts';\nimport { Web3Provider } from '@ethersproject/providers';\nimport type { AddApprovalRequest } from '@metamask/approval-controller';\nimport type {\n  BaseConfig,\n  BaseState,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport { BaseControllerV1 } from '@metamask/base-controller';\nimport contractsMap from '@metamask/contract-metadata';\nimport {\n  toChecksumHexAddress,\n  ERC721_INTERFACE_ID,\n  ORIGIN_METAMASK,\n  ApprovalType,\n  ERC20,\n  ERC721,\n  ERC1155,\n  isValidHexAddress,\n  safelyExecute,\n} from '@metamask/controller-utils';\nimport { abiERC721 } from '@metamask/metamask-eth-abis';\nimport type {\n  NetworkClientId,\n  NetworkControllerGetNetworkClientByIdAction,\n  NetworkControllerNetworkDidChangeEvent,\n  Provider,\n} from '@metamask/network-controller';\nimport type { PreferencesControllerStateChangeEvent } from '@metamask/preferences-controller';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type { Hex } from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\nimport { EventEmitter } from 'events';\nimport type { Patch } from 'immer/dist/immer';\nimport { v1 as random } from 'uuid';\n\nimport { formatAggregatorNames, formatIconUrlWithProxy } from './assetsUtil';\nimport { ERC20Standard } from './Standards/ERC20Standard';\nimport { ERC1155Standard } from './Standards/NftStandards/ERC1155/ERC1155Standard';\nimport {\n  fetchTokenMetadata,\n  TOKEN_METADATA_NO_SUPPORT_ERROR,\n} from './token-service';\nimport type {\n  TokenListMap,\n  TokenListStateChange,\n  TokenListToken,\n} from './TokenListController';\nimport type { Token } from './TokenRatesController';\n\n/**\n * @type TokensConfig\n *\n * Tokens controller configuration\n * @property selectedAddress - Vault selected address\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface TokensConfig extends BaseConfig {\n  selectedAddress: string;\n  chainId: Hex;\n  provider: Provider | undefined;\n}\n\n/**\n * @type SuggestedAssetMeta\n *\n * Suggested asset by EIP747 meta data\n * @property id - Generated UUID associated with this suggested asset\n * @property time - Timestamp associated with this this suggested asset\n * @property type - Type type this suggested asset\n * @property asset - Asset suggested object\n * @property interactingAddress - Account address that requested watch asset\n */\ntype SuggestedAssetMeta = {\n  id: string;\n  time: number;\n  type: string;\n  asset: Token;\n  interactingAddress: string;\n};\n\n/**\n * @type TokensState\n *\n * Assets controller state\n * @property tokens - List of tokens associated with the active network and address pair\n * @property ignoredTokens - List of ignoredTokens associated with the active network and address pair\n * @property detectedTokens - List of detected tokens associated with the active network and address pair\n * @property allTokens - Object containing tokens by network and account\n * @property allIgnoredTokens - Object containing hidden/ignored tokens by network and account\n * @property allDetectedTokens - Object containing tokens detected with non-zero balances\n */\nexport type TokensState = {\n  tokens: Token[];\n  ignoredTokens: string[];\n  detectedTokens: Token[];\n  allTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n  allIgnoredTokens: { [chainId: Hex]: { [key: string]: string[] } };\n  allDetectedTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n};\n\n/**\n * The name of the {@link TokensController}.\n */\nconst controllerName = 'TokensController';\n\nexport type TokensControllerActions =\n  | TokensControllerGetStateAction\n  | TokensControllerAddDetectedTokensAction;\n\n// TODO: Once `TokensController` is upgraded to V2, rewrite this type using the `ControllerGetStateAction` type, which constrains `TokensState` as `Record<string, Json>`.\nexport type TokensControllerGetStateAction = {\n  type: `${typeof controllerName}:getState`;\n  handler: () => TokensState;\n};\n\nexport type TokensControllerAddDetectedTokensAction = {\n  type: `${typeof controllerName}:addDetectedTokens`;\n  handler: TokensController['addDetectedTokens'];\n};\n\n/**\n * The external actions available to the {@link TokensController}.\n */\nexport type AllowedActions =\n  | AddApprovalRequest\n  | NetworkControllerGetNetworkClientByIdAction;\n\n// TODO: Once `TokensController` is upgraded to V2, rewrite this type using the `ControllerStateChangeEvent` type, which constrains `TokensState` as `Record<string, Json>`.\nexport type TokensControllerStateChangeEvent = {\n  type: `${typeof controllerName}:stateChange`;\n  payload: [TokensState, Patch[]];\n};\n\nexport type TokensControllerEvents = TokensControllerStateChangeEvent;\n\nexport type AllowedEvents =\n  | NetworkControllerNetworkDidChangeEvent\n  | PreferencesControllerStateChangeEvent\n  | TokenListStateChange;\n\n/**\n * The messenger of the {@link TokensController}.\n */\nexport type TokensControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  TokensControllerActions | AllowedActions,\n  TokensControllerEvents | AllowedEvents,\n  AllowedActions['type'],\n  AllowedEvents['type']\n>;\n\nexport const getDefaultTokensState = (): TokensState => {\n  return {\n    tokens: [],\n    ignoredTokens: [],\n    detectedTokens: [],\n    allTokens: {},\n    allIgnoredTokens: {},\n    allDetectedTokens: {},\n  };\n};\n\n/**\n * Controller that stores assets and exposes convenience methods\n */\nexport class TokensController extends BaseControllerV1<\n  TokensConfig,\n  TokensState & BaseState\n> {\n  private readonly mutex = new Mutex();\n\n  private abortController: AbortController;\n\n  private readonly messagingSystem: TokensControllerMessenger;\n\n  /**\n   * Fetch metadata for a token.\n   *\n   * @param tokenAddress - The address of the token.\n   * @returns The token metadata.\n   */\n  private async fetchTokenMetadata(\n    tokenAddress: string,\n  ): Promise<TokenListToken | undefined> {\n    try {\n      const token = await fetchTokenMetadata<TokenListToken>(\n        this.config.chainId,\n        tokenAddress,\n        this.abortController.signal,\n      );\n      return token;\n    } catch (error) {\n      if (\n        error instanceof Error &&\n        error.message.includes(TOKEN_METADATA_NO_SUPPORT_ERROR)\n      ) {\n        return undefined;\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * EventEmitter instance used to listen to specific EIP747 events\n   */\n  hub = new EventEmitter();\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'TokensController';\n\n  /**\n   * Creates a TokensController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.config - Initial options used to configure this controller.\n   * @param options.state - Initial state to set on this controller.\n   * @param options.messenger - The controller messenger.\n   */\n  constructor({\n    chainId: initialChainId,\n    config,\n    state,\n    messenger,\n  }: {\n    chainId: Hex;\n    config?: Partial<TokensConfig>;\n    state?: Partial<TokensState>;\n    messenger: TokensControllerMessenger;\n  }) {\n    super(config, state);\n\n    this.defaultConfig = {\n      selectedAddress: '',\n      chainId: initialChainId,\n      provider: undefined,\n      ...config,\n    };\n\n    this.defaultState = {\n      ...getDefaultTokensState(),\n      ...state,\n    };\n\n    this.initialize();\n    this.abortController = new AbortController();\n\n    this.messagingSystem = messenger;\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:addDetectedTokens` as const,\n      this.addDetectedTokens.bind(this),\n    );\n\n    this.messagingSystem.subscribe(\n      'PreferencesController:stateChange',\n      ({ selectedAddress }) => {\n        const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n        const { chainId } = this.config;\n        this.configure({ selectedAddress });\n        this.update({\n          tokens: allTokens[chainId]?.[selectedAddress] ?? [],\n          ignoredTokens: allIgnoredTokens[chainId]?.[selectedAddress] ?? [],\n          detectedTokens: allDetectedTokens[chainId]?.[selectedAddress] ?? [],\n        });\n      },\n    );\n\n    this.messagingSystem.subscribe(\n      'NetworkController:networkDidChange',\n      ({ providerConfig }) => {\n        const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n        const { selectedAddress } = this.config;\n        const { chainId } = providerConfig;\n        this.abortController.abort();\n        this.abortController = new AbortController();\n        this.configure({ chainId });\n        this.update({\n          tokens: allTokens[chainId]?.[selectedAddress] || [],\n          ignoredTokens: allIgnoredTokens[chainId]?.[selectedAddress] || [],\n          detectedTokens: allDetectedTokens[chainId]?.[selectedAddress] || [],\n        });\n      },\n    );\n\n    this.messagingSystem.subscribe(\n      'TokenListController:stateChange',\n      ({ tokenList }) => {\n        const { tokens } = this.state;\n        if (tokens.length && !tokens[0].name) {\n          this.updateTokensAttribute(tokenList, 'name');\n        }\n      },\n    );\n  }\n\n  /**\n   * Adds a token to the stored token list.\n   *\n   * @param options - The method argument object.\n   * @param options.address - Hex address of the token contract.\n   * @param options.symbol - Symbol of the token.\n   * @param options.decimals - Number of decimals the token uses.\n   * @param options.name - Name of the token.\n   * @param options.image - Image of the token.\n   * @param options.interactingAddress - The address of the account to add a token to.\n   * @param options.networkClientId - Network Client ID.\n   * @returns Current token list.\n   */\n  async addToken({\n    address,\n    symbol,\n    decimals,\n    name,\n    image,\n    interactingAddress,\n    networkClientId,\n  }: {\n    address: string;\n    symbol: string;\n    decimals: number;\n    name?: string;\n    image?: string;\n    interactingAddress?: string;\n    networkClientId?: NetworkClientId;\n  }): Promise<Token[]> {\n    const { chainId, selectedAddress } = this.config;\n    const releaseLock = await this.mutex.acquire();\n    const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n    let currentChainId = chainId;\n    if (networkClientId) {\n      currentChainId = this.messagingSystem.call(\n        'NetworkController:getNetworkClientById',\n        networkClientId,\n      ).configuration.chainId;\n    }\n\n    const accountAddress = interactingAddress || selectedAddress;\n    const isInteractingWithWalletAccount = accountAddress === selectedAddress;\n\n    try {\n      address = toChecksumHexAddress(address);\n      const tokens = allTokens[currentChainId]?.[accountAddress] || [];\n      const ignoredTokens =\n        allIgnoredTokens[currentChainId]?.[accountAddress] || [];\n      const detectedTokens =\n        allDetectedTokens[currentChainId]?.[accountAddress] || [];\n      const newTokens: Token[] = [...tokens];\n      const [isERC721, tokenMetadata] = await Promise.all([\n        this._detectIsERC721(address, networkClientId),\n        // TODO parameterize the token metadata fetch by networkClientId\n        this.fetchTokenMetadata(address),\n      ]);\n      // TODO remove this once this method is fully parameterized by networkClientId\n      if (!networkClientId && currentChainId !== this.config.chainId) {\n        throw new Error(\n          'TokensController Error: Switched networks while adding token',\n        );\n      }\n      const newEntry: Token = {\n        address,\n        symbol,\n        decimals,\n        image:\n          image ||\n          formatIconUrlWithProxy({\n            chainId: currentChainId,\n            tokenAddress: address,\n          }),\n        isERC721,\n        aggregators: formatAggregatorNames(tokenMetadata?.aggregators || []),\n        name,\n      };\n      const previousIndex = newTokens.findIndex(\n        (token) => token.address.toLowerCase() === address.toLowerCase(),\n      );\n      if (previousIndex !== -1) {\n        newTokens[previousIndex] = newEntry;\n      } else {\n        newTokens.push(newEntry);\n      }\n\n      const newIgnoredTokens = ignoredTokens.filter(\n        (tokenAddress) => tokenAddress.toLowerCase() !== address.toLowerCase(),\n      );\n      const newDetectedTokens = detectedTokens.filter(\n        (token) => token.address.toLowerCase() !== address.toLowerCase(),\n      );\n\n      const { newAllTokens, newAllIgnoredTokens, newAllDetectedTokens } =\n        this._getNewAllTokensState({\n          newTokens,\n          newIgnoredTokens,\n          newDetectedTokens,\n          interactingAddress: accountAddress,\n          interactingChainId: currentChainId,\n        });\n\n      let newState: Partial<TokensState> = {\n        allTokens: newAllTokens,\n        allIgnoredTokens: newAllIgnoredTokens,\n        allDetectedTokens: newAllDetectedTokens,\n      };\n\n      // Only update active tokens if user is interacting with their active wallet account.\n      if (isInteractingWithWalletAccount) {\n        newState = {\n          ...newState,\n          tokens: newTokens,\n          ignoredTokens: newIgnoredTokens,\n          detectedTokens: newDetectedTokens,\n        };\n      }\n\n      this.update(newState);\n      return newTokens;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Add a batch of tokens.\n   *\n   * @param tokensToImport - Array of tokens to import.\n   * @param networkClientId - Optional network client ID used to determine interacting chain ID.\n   */\n  async addTokens(tokensToImport: Token[], networkClientId?: NetworkClientId) {\n    const releaseLock = await this.mutex.acquire();\n    const { tokens, detectedTokens, ignoredTokens } = this.state;\n    const importedTokensMap: { [key: string]: true } = {};\n    // Used later to dedupe imported tokens\n    const newTokensMap = tokens.reduce((output, current) => {\n      output[current.address] = current;\n      return output;\n    }, {} as { [address: string]: Token });\n    try {\n      tokensToImport.forEach((tokenToAdd) => {\n        const { address, symbol, decimals, image, aggregators, name } =\n          tokenToAdd;\n        const checksumAddress = toChecksumHexAddress(address);\n        const formattedToken: Token = {\n          address: checksumAddress,\n          symbol,\n          decimals,\n          image,\n          aggregators,\n          name,\n        };\n        newTokensMap[address] = formattedToken;\n        importedTokensMap[address.toLowerCase()] = true;\n        return formattedToken;\n      });\n      const newTokens = Object.values(newTokensMap);\n\n      const newDetectedTokens = detectedTokens.filter(\n        (token) => !importedTokensMap[token.address.toLowerCase()],\n      );\n      const newIgnoredTokens = ignoredTokens.filter(\n        (tokenAddress) => !newTokensMap[tokenAddress.toLowerCase()],\n      );\n\n      let interactingChainId;\n      if (networkClientId) {\n        interactingChainId = this.messagingSystem.call(\n          'NetworkController:getNetworkClientById',\n          networkClientId,\n        ).configuration.chainId;\n      }\n\n      const { newAllTokens, newAllDetectedTokens, newAllIgnoredTokens } =\n        this._getNewAllTokensState({\n          newTokens,\n          newDetectedTokens,\n          newIgnoredTokens,\n          interactingChainId,\n        });\n\n      this.update({\n        tokens: newTokens,\n        allTokens: newAllTokens,\n        detectedTokens: newDetectedTokens,\n        allDetectedTokens: newAllDetectedTokens,\n        ignoredTokens: newIgnoredTokens,\n        allIgnoredTokens: newAllIgnoredTokens,\n      });\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Ignore a batch of tokens.\n   *\n   * @param tokenAddressesToIgnore - Array of token addresses to ignore.\n   */\n  ignoreTokens(tokenAddressesToIgnore: string[]) {\n    const { ignoredTokens, detectedTokens, tokens } = this.state;\n    const ignoredTokensMap: { [key: string]: true } = {};\n    let newIgnoredTokens: string[] = [...ignoredTokens];\n\n    const checksummedTokenAddresses = tokenAddressesToIgnore.map((address) => {\n      const checksumAddress = toChecksumHexAddress(address);\n      ignoredTokensMap[address.toLowerCase()] = true;\n      return checksumAddress;\n    });\n    newIgnoredTokens = [...ignoredTokens, ...checksummedTokenAddresses];\n    const newDetectedTokens = detectedTokens.filter(\n      (token) => !ignoredTokensMap[token.address.toLowerCase()],\n    );\n    const newTokens = tokens.filter(\n      (token) => !ignoredTokensMap[token.address.toLowerCase()],\n    );\n\n    const { newAllIgnoredTokens, newAllDetectedTokens, newAllTokens } =\n      this._getNewAllTokensState({\n        newIgnoredTokens,\n        newDetectedTokens,\n        newTokens,\n      });\n\n    this.update({\n      ignoredTokens: newIgnoredTokens,\n      tokens: newTokens,\n      detectedTokens: newDetectedTokens,\n      allIgnoredTokens: newAllIgnoredTokens,\n      allDetectedTokens: newAllDetectedTokens,\n      allTokens: newAllTokens,\n    });\n  }\n\n  /**\n   * Adds a batch of detected tokens to the stored token list.\n   *\n   * @param incomingDetectedTokens - Array of detected tokens to be added or updated.\n   * @param detectionDetails - An object containing the chain ID and address of the currently selected network on which the incomingDetectedTokens were detected.\n   * @param detectionDetails.selectedAddress - the account address on which the incomingDetectedTokens were detected.\n   * @param detectionDetails.chainId - the chainId on which the incomingDetectedTokens were detected.\n   */\n  async addDetectedTokens(\n    incomingDetectedTokens: Token[],\n    detectionDetails?: { selectedAddress: string; chainId: Hex },\n  ) {\n    const releaseLock = await this.mutex.acquire();\n\n    // Get existing tokens for the chain + account\n    const chainId = detectionDetails?.chainId ?? this.config.chainId;\n    const accountAddress =\n      detectionDetails?.selectedAddress ?? this.config.selectedAddress;\n\n    const { allTokens, allDetectedTokens, allIgnoredTokens } = this.state;\n    let newTokens = [...(allTokens?.[chainId]?.[accountAddress] ?? [])];\n    let newDetectedTokens = [\n      ...(allDetectedTokens?.[chainId]?.[accountAddress] ?? []),\n    ];\n\n    try {\n      incomingDetectedTokens.forEach((tokenToAdd) => {\n        const {\n          address,\n          symbol,\n          decimals,\n          image,\n          aggregators,\n          isERC721,\n          name,\n        } = tokenToAdd;\n        const checksumAddress = toChecksumHexAddress(address);\n        const newEntry: Token = {\n          address: checksumAddress,\n          symbol,\n          decimals,\n          image,\n          isERC721,\n          aggregators,\n          name,\n        };\n        const previousImportedIndex = newTokens.findIndex(\n          (token) =>\n            token.address.toLowerCase() === checksumAddress.toLowerCase(),\n        );\n        if (previousImportedIndex !== -1) {\n          // Update existing data of imported token\n          newTokens[previousImportedIndex] = newEntry;\n        } else {\n          const ignoredTokenIndex =\n            allIgnoredTokens?.[chainId]?.[accountAddress]?.indexOf(address) ??\n            -1;\n\n          if (ignoredTokenIndex === -1) {\n            // Add detected token\n            const previousDetectedIndex = newDetectedTokens.findIndex(\n              (token) =>\n                token.address.toLowerCase() === checksumAddress.toLowerCase(),\n            );\n            if (previousDetectedIndex !== -1) {\n              newDetectedTokens[previousDetectedIndex] = newEntry;\n            } else {\n              newDetectedTokens.push(newEntry);\n            }\n          }\n        }\n      });\n\n      const { newAllTokens, newAllDetectedTokens } = this._getNewAllTokensState(\n        {\n          newTokens,\n          newDetectedTokens,\n          interactingAddress: accountAddress,\n          interactingChainId: chainId,\n        },\n      );\n\n      // We may be detecting tokens on a different chain/account pair than are currently configured.\n      // Re-point `tokens` and `detectedTokens` to keep them referencing the current chain/account.\n      const { chainId: currentChain, selectedAddress: currentAddress } =\n        this.config;\n\n      newTokens = newAllTokens?.[currentChain]?.[currentAddress] || [];\n      newDetectedTokens =\n        newAllDetectedTokens?.[currentChain]?.[currentAddress] || [];\n\n      this.update({\n        tokens: newTokens,\n        allTokens: newAllTokens,\n        detectedTokens: newDetectedTokens,\n        allDetectedTokens: newAllDetectedTokens,\n      });\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Adds isERC721 field to token object. This is called when a user attempts to add tokens that\n   * were previously added which do not yet had isERC721 field.\n   *\n   * @param tokenAddress - The contract address of the token requiring the isERC721 field added.\n   * @returns The new token object with the added isERC721 field.\n   */\n  async updateTokenType(tokenAddress: string) {\n    const isERC721 = await this._detectIsERC721(tokenAddress);\n    const { tokens } = this.state;\n    const tokenIndex = tokens.findIndex((token) => {\n      return token.address.toLowerCase() === tokenAddress.toLowerCase();\n    });\n    tokens[tokenIndex].isERC721 = isERC721;\n    this.update({ tokens });\n    return tokens[tokenIndex];\n  }\n\n  /**\n   * This is a function that updates the tokens name for the tokens name if it is not defined.\n   *\n   * @param tokenList - Represents the fetched token list from service API\n   * @param tokenAttribute - Represents the token attribute that we want to update on the token list\n   */\n  private updateTokensAttribute(\n    tokenList: TokenListMap,\n    tokenAttribute: keyof Token & keyof TokenListToken,\n  ) {\n    const { tokens } = this.state;\n\n    const newTokens = tokens.map((token) => {\n      const newToken = tokenList[token.address.toLowerCase()];\n\n      return !token[tokenAttribute] && newToken?.[tokenAttribute]\n        ? { ...token, [tokenAttribute]: newToken[tokenAttribute] }\n        : { ...token };\n    });\n\n    this.update({ tokens: newTokens });\n  }\n\n  /**\n   * Detects whether or not a token is ERC-721 compatible.\n   *\n   * @param tokenAddress - The token contract address.\n   * @param networkClientId - Optional network client ID to fetch contract info with.\n   * @returns A boolean indicating whether the token address passed in supports the EIP-721\n   * interface.\n   */\n  async _detectIsERC721(\n    tokenAddress: string,\n    networkClientId?: NetworkClientId,\n  ) {\n    const checksumAddress = toChecksumHexAddress(tokenAddress);\n    // if this token is already in our contract metadata map we don't need\n    // to check against the contract\n    if (contractsMap[checksumAddress]?.erc721 === true) {\n      return Promise.resolve(true);\n    } else if (contractsMap[checksumAddress]?.erc20 === true) {\n      return Promise.resolve(false);\n    }\n\n    const tokenContract = this._createEthersContract(\n      tokenAddress,\n      abiERC721,\n      networkClientId,\n    );\n    try {\n      return await tokenContract.supportsInterface(ERC721_INTERFACE_ID);\n    } catch (error) {\n      // currently we see a variety of errors across different networks when\n      // token contracts are not ERC721 compatible. We need to figure out a better\n      // way of differentiating token interface types but for now if we get an error\n      // we have to assume the token is not ERC721 compatible.\n      return false;\n    }\n  }\n\n  _getProvider(networkClientId?: NetworkClientId): Web3Provider {\n    return new Web3Provider(\n      // @ts-expect-error TODO: remove this annotation once the `Eip1193Provider` class is released\n      networkClientId\n        ? this.messagingSystem.call(\n            'NetworkController:getNetworkClientById',\n            networkClientId,\n          ).provider\n        : this.config.provider,\n    );\n  }\n\n  _createEthersContract(\n    tokenAddress: string,\n    abi: string,\n    networkClientId?: NetworkClientId,\n  ): Contract {\n    const web3provider = this._getProvider(networkClientId);\n    const tokenContract = new Contract(tokenAddress, abi, web3provider);\n    return tokenContract;\n  }\n\n  _generateRandomId(): string {\n    return random();\n  }\n\n  /**\n   * Adds a new suggestedAsset to the list of watched assets.\n   * Parameters will be validated according to the asset type being watched.\n   *\n   * @param options - The method options.\n   * @param options.asset - The asset to be watched. For now only ERC20 tokens are accepted.\n   * @param options.type - The asset type.\n   * @param options.interactingAddress - The address of the account that is requesting to watch the asset.\n   * @param options.networkClientId - Network Client ID.\n   * @returns A promise that resolves if the asset was watched successfully, and rejects otherwise.\n   */\n  async watchAsset({\n    asset,\n    type,\n    interactingAddress,\n    networkClientId,\n  }: {\n    asset: Token;\n    type: string;\n    interactingAddress?: string;\n    networkClientId?: NetworkClientId;\n  }): Promise<void> {\n    if (type !== ERC20) {\n      throw new Error(`Asset of type ${type} not supported`);\n    }\n\n    if (!asset.address) {\n      throw rpcErrors.invalidParams('Address must be specified');\n    }\n\n    if (!isValidHexAddress(asset.address)) {\n      throw rpcErrors.invalidParams(`Invalid address \"${asset.address}\"`);\n    }\n\n    // Validate contract\n\n    if (await this._detectIsERC721(asset.address, networkClientId)) {\n      throw rpcErrors.invalidParams(\n        `Contract ${asset.address} must match type ${type}, but was detected as ${ERC721}`,\n      );\n    }\n\n    const provider = this._getProvider(networkClientId);\n    const isErc1155 = await safelyExecute(() =>\n      new ERC1155Standard(provider).contractSupportsBase1155Interface(\n        asset.address,\n      ),\n    );\n    if (isErc1155) {\n      throw rpcErrors.invalidParams(\n        `Contract ${asset.address} must match type ${type}, but was detected as ${ERC1155}`,\n      );\n    }\n\n    const erc20 = new ERC20Standard(provider);\n    const [contractName, contractSymbol, contractDecimals] = await Promise.all([\n      safelyExecute(() => erc20.getTokenName(asset.address)),\n      safelyExecute(() => erc20.getTokenSymbol(asset.address)),\n      safelyExecute(async () => erc20.getTokenDecimals(asset.address)),\n    ]);\n\n    asset.name = contractName;\n\n    // Validate symbol\n\n    if (!asset.symbol && !contractSymbol) {\n      throw rpcErrors.invalidParams(\n        'A symbol is required, but was not found in either the request or contract',\n      );\n    }\n\n    if (\n      contractSymbol !== undefined &&\n      asset.symbol !== undefined &&\n      asset.symbol.toUpperCase() !== contractSymbol.toUpperCase()\n    ) {\n      throw rpcErrors.invalidParams(\n        `The symbol in the request (${asset.symbol}) does not match the symbol in the contract (${contractSymbol})`,\n      );\n    }\n\n    asset.symbol = contractSymbol ?? asset.symbol;\n    if (typeof asset.symbol !== 'string') {\n      throw rpcErrors.invalidParams(`Invalid symbol: not a string`);\n    }\n\n    if (asset.symbol.length > 11) {\n      throw rpcErrors.invalidParams(\n        `Invalid symbol \"${asset.symbol}\": longer than 11 characters`,\n      );\n    }\n\n    // Validate decimals\n\n    if (asset.decimals === undefined && contractDecimals === undefined) {\n      throw rpcErrors.invalidParams(\n        'Decimals are required, but were not found in either the request or contract',\n      );\n    }\n\n    if (\n      contractDecimals !== undefined &&\n      asset.decimals !== undefined &&\n      String(asset.decimals) !== contractDecimals\n    ) {\n      throw rpcErrors.invalidParams(\n        `The decimals in the request (${asset.decimals}) do not match the decimals in the contract (${contractDecimals})`,\n      );\n    }\n\n    const decimalsStr = contractDecimals ?? asset.decimals;\n    const decimalsNum = parseInt(decimalsStr as unknown as string, 10);\n    if (!Number.isInteger(decimalsNum) || decimalsNum > 36 || decimalsNum < 0) {\n      throw rpcErrors.invalidParams(\n        `Invalid decimals \"${decimalsStr}\": must be an integer 0 <= 36`,\n      );\n    }\n    asset.decimals = decimalsNum;\n\n    const suggestedAssetMeta: SuggestedAssetMeta = {\n      asset,\n      id: this._generateRandomId(),\n      time: Date.now(),\n      type,\n      interactingAddress: interactingAddress || this.config.selectedAddress,\n    };\n\n    await this._requestApproval(suggestedAssetMeta);\n\n    const { address, symbol, decimals, name, image } = asset;\n    await this.addToken({\n      address,\n      symbol,\n      decimals,\n      name,\n      image,\n      interactingAddress: suggestedAssetMeta.interactingAddress,\n      networkClientId,\n    });\n  }\n\n  /**\n   * Takes a new tokens and ignoredTokens array for the current network/account combination\n   * and returns new allTokens and allIgnoredTokens state to update to.\n   *\n   * @param params - Object that holds token params.\n   * @param params.newTokens - The new tokens to set for the current network and selected account.\n   * @param params.newIgnoredTokens - The new ignored tokens to set for the current network and selected account.\n   * @param params.newDetectedTokens - The new detected tokens to set for the current network and selected account.\n   * @param params.interactingAddress - The account address to use to store the tokens.\n   * @param params.interactingChainId - The chainId to use to store the tokens.\n   * @returns The updated `allTokens` and `allIgnoredTokens` state.\n   */\n  _getNewAllTokensState(params: {\n    newTokens?: Token[];\n    newIgnoredTokens?: string[];\n    newDetectedTokens?: Token[];\n    interactingAddress?: string;\n    interactingChainId?: Hex;\n  }) {\n    const {\n      newTokens,\n      newIgnoredTokens,\n      newDetectedTokens,\n      interactingAddress,\n      interactingChainId,\n    } = params;\n    const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n    const { chainId, selectedAddress } = this.config;\n\n    const userAddressToAddTokens = interactingAddress ?? selectedAddress;\n    const chainIdToAddTokens = interactingChainId ?? chainId;\n\n    let newAllTokens = allTokens;\n    if (\n      newTokens?.length ||\n      (newTokens &&\n        allTokens &&\n        allTokens[chainIdToAddTokens] &&\n        allTokens[chainIdToAddTokens][userAddressToAddTokens])\n    ) {\n      const networkTokens = allTokens[chainIdToAddTokens];\n      const newNetworkTokens = {\n        ...networkTokens,\n        ...{ [userAddressToAddTokens]: newTokens },\n      };\n      newAllTokens = {\n        ...allTokens,\n        ...{ [chainIdToAddTokens]: newNetworkTokens },\n      };\n    }\n\n    let newAllIgnoredTokens = allIgnoredTokens;\n    if (\n      newIgnoredTokens?.length ||\n      (newIgnoredTokens &&\n        allIgnoredTokens &&\n        allIgnoredTokens[chainIdToAddTokens] &&\n        allIgnoredTokens[chainIdToAddTokens][userAddressToAddTokens])\n    ) {\n      const networkIgnoredTokens = allIgnoredTokens[chainIdToAddTokens];\n      const newIgnoredNetworkTokens = {\n        ...networkIgnoredTokens,\n        ...{ [userAddressToAddTokens]: newIgnoredTokens },\n      };\n      newAllIgnoredTokens = {\n        ...allIgnoredTokens,\n        ...{ [chainIdToAddTokens]: newIgnoredNetworkTokens },\n      };\n    }\n\n    let newAllDetectedTokens = allDetectedTokens;\n    if (\n      newDetectedTokens?.length ||\n      (newDetectedTokens &&\n        allDetectedTokens &&\n        allDetectedTokens[chainIdToAddTokens] &&\n        allDetectedTokens[chainIdToAddTokens][userAddressToAddTokens])\n    ) {\n      const networkDetectedTokens = allDetectedTokens[chainIdToAddTokens];\n      const newDetectedNetworkTokens = {\n        ...networkDetectedTokens,\n        ...{ [userAddressToAddTokens]: newDetectedTokens },\n      };\n      newAllDetectedTokens = {\n        ...allDetectedTokens,\n        ...{ [chainIdToAddTokens]: newDetectedNetworkTokens },\n      };\n    }\n    return { newAllTokens, newAllIgnoredTokens, newAllDetectedTokens };\n  }\n\n  /**\n   * Removes all tokens from the ignored list.\n   */\n  clearIgnoredTokens() {\n    this.update({ ignoredTokens: [], allIgnoredTokens: {} });\n  }\n\n  async _requestApproval(suggestedAssetMeta: SuggestedAssetMeta) {\n    return this.messagingSystem.call(\n      'ApprovalController:addRequest',\n      {\n        id: suggestedAssetMeta.id,\n        origin: ORIGIN_METAMASK,\n        type: ApprovalType.WatchAsset,\n        requestData: {\n          id: suggestedAssetMeta.id,\n          interactingAddress: suggestedAssetMeta.interactingAddress,\n          asset: {\n            address: suggestedAssetMeta.asset.address,\n            decimals: suggestedAssetMeta.asset.decimals,\n            symbol: suggestedAssetMeta.asset.symbol,\n            image: suggestedAssetMeta.asset.image || null,\n          },\n        },\n      },\n      true,\n    );\n  }\n}\n\nexport default TokensController;\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-OBUR4TXH.js b/node_modules/@metamask/assets-controllers/dist/chunk-OBUR4TXH.js
new file mode 100644
index 0000000..83035d6
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-OBUR4TXH.js
@@ -0,0 +1 @@
+"use strict";//# sourceMappingURL=chunk-OBUR4TXH.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-OBUR4TXH.js.map b/node_modules/@metamask/assets-controllers/dist/chunk-OBUR4TXH.js.map
new file mode 100644
index 0000000..a464c67
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-OBUR4TXH.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":[],"names":[],"mappings":""}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-OSEZFHQ3.mjs b/node_modules/@metamask/assets-controllers/dist/chunk-OSEZFHQ3.mjs
new file mode 100644
index 0000000..55c1558
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-OSEZFHQ3.mjs
@@ -0,0 +1,343 @@
+import {
+  __privateAdd,
+  __privateGet,
+  __privateSet
+} from "./chunk-XUI43LEZ.mjs";
+
+// src/token-prices-service/codefi-v2.ts
+import { handleFetch } from "@metamask/controller-utils";
+import { hexToNumber } from "@metamask/utils";
+import {
+  circuitBreaker,
+  ConsecutiveBreaker,
+  ExponentialBackoff,
+  handleAll,
+  retry,
+  wrap,
+  CircuitState
+} from "cockatiel";
+var SUPPORTED_CURRENCIES = [
+  // Bitcoin
+  "btc",
+  // Ether
+  "eth",
+  // Litecoin
+  "ltc",
+  // Bitcoin Cash
+  "bch",
+  // Binance Coin
+  "bnb",
+  // EOS
+  "eos",
+  // XRP
+  "xrp",
+  // Lumens
+  "xlm",
+  // Chainlink
+  "link",
+  // Polkadot
+  "dot",
+  // Yearn.finance
+  "yfi",
+  // US Dollar
+  "usd",
+  // United Arab Emirates Dirham
+  "aed",
+  // Argentine Peso
+  "ars",
+  // Australian Dollar
+  "aud",
+  // Bangladeshi Taka
+  "bdt",
+  // Bahraini Dinar
+  "bhd",
+  // Bermudian Dollar
+  "bmd",
+  // Brazil Real
+  "brl",
+  // Canadian Dollar
+  "cad",
+  // Swiss Franc
+  "chf",
+  // Chilean Peso
+  "clp",
+  // Chinese Yuan
+  "cny",
+  // Czech Koruna
+  "czk",
+  // Danish Krone
+  "dkk",
+  // Euro
+  "eur",
+  // British Pound Sterling
+  "gbp",
+  // Hong Kong Dollar
+  "hkd",
+  // Hungarian Forint
+  "huf",
+  // Indonesian Rupiah
+  "idr",
+  // Israeli New Shekel
+  "ils",
+  // Indian Rupee
+  "inr",
+  // Japanese Yen
+  "jpy",
+  // South Korean Won
+  "krw",
+  // Kuwaiti Dinar
+  "kwd",
+  // Sri Lankan Rupee
+  "lkr",
+  // Burmese Kyat
+  "mmk",
+  // Mexican Peso
+  "mxn",
+  // Malaysian Ringgit
+  "myr",
+  // Nigerian Naira
+  "ngn",
+  // Norwegian Krone
+  "nok",
+  // New Zealand Dollar
+  "nzd",
+  // Philippine Peso
+  "php",
+  // Pakistani Rupee
+  "pkr",
+  // Polish Zloty
+  "pln",
+  // Russian Ruble
+  "rub",
+  // Saudi Riyal
+  "sar",
+  // Swedish Krona
+  "sek",
+  // Singapore Dollar
+  "sgd",
+  // Thai Baht
+  "thb",
+  // Turkish Lira
+  "try",
+  // New Taiwan Dollar
+  "twd",
+  // Ukrainian hryvnia
+  "uah",
+  // Venezuelan bolvar fuerte
+  "vef",
+  // Vietnamese ng
+  "vnd",
+  // South African Rand
+  "zar",
+  // IMF Special Drawing Rights
+  "xdr",
+  // Silver - Troy Ounce
+  "xag",
+  // Gold - Troy Ounce
+  "xau",
+  // Bits
+  "bits",
+  // Satoshi
+  "sats"
+];
+var SUPPORTED_CHAIN_IDS = [
+  // Ethereum Mainnet
+  "0x1",
+  // OP Mainnet
+  "0xa",
+  // Cronos Mainnet
+  "0x19",
+  // BNB Smart Chain Mainnet
+  "0x38",
+  // Syscoin Mainnet
+  "0x39",
+  // OKXChain Mainnet
+  "0x42",
+  // Hoo Smart Chain
+  "0x46",
+  // Meter Mainnet
+  "0x52",
+  // TomoChain
+  "0x58",
+  // Gnosis
+  "0x64",
+  // Velas EVM Mainnet
+  "0x6a",
+  // Fuse Mainnet
+  "0x7a",
+  // Huobi ECO Chain Mainnet
+  "0x80",
+  // Polygon Mainnet
+  "0x89",
+  // Fantom Opera
+  "0xfa",
+  // Boba Network
+  "0x120",
+  // KCC Mainnet
+  "0x141",
+  // zkSync Era Mainnet
+  "0x144",
+  // Theta Mainnet
+  "0x169",
+  // Metis Andromeda Mainnet
+  "0x440",
+  // Moonbeam
+  "0x504",
+  // Moonriver
+  "0x505",
+  // Base
+  "0x2105",
+  // Shiden
+  "0x150",
+  // Smart Bitcoin Cash
+  "0x2710",
+  // Arbitrum One
+  "0xa4b1",
+  // Celo Mainnet
+  "0xa4ec",
+  // Oasis Emerald
+  "0xa516",
+  // Avalanche C-Chain
+  "0xa86a",
+  // Polis Mainnet
+  "0x518af",
+  // Aurora Mainnet
+  "0x4e454152",
+  // Harmony Mainnet Shard 0
+  "0x63564c40",
+  // Linea Mainnet
+  "0xe708"
+];
+var BASE_URL = "https://price-api.metafi.codefi.network/v2";
+var DEFAULT_TOKEN_PRICE_RETRIES = 3;
+var DEFAULT_TOKEN_PRICE_MAX_CONSECUTIVE_FAILURES = (1 + DEFAULT_TOKEN_PRICE_RETRIES) * 3;
+var DEFAULT_DEGRADED_THRESHOLD = 5e3;
+var _tokenPricePolicy;
+var CodefiTokenPricesServiceV2 = class {
+  /**
+   * Construct a Codefi Token Price Service.
+   *
+   * @param options - Constructor options
+   * @param options.degradedThreshold - The threshold between "normal" and "degrated" service,
+   * in milliseconds.
+   * @param options.retries - Number of retry attempts for each token price update.
+   * @param options.maximumConsecutiveFailures - The maximum number of consecutive failures
+   * allowed before breaking the circuit and pausing further updates.
+   * @param options.onBreak - An event handler for when the circuit breaks, useful for capturing
+   * metrics about network failures.
+   * @param options.onDegraded - An event handler for when the circuit remains closed, but requests
+   * are failing or resolving too slowly (i.e. resolving more slowly than the `degradedThreshold).
+   * @param options.circuitBreakDuration - The amount of time to wait when the circuit breaks
+   * from too many consecutive failures.
+   */
+  constructor({
+    degradedThreshold = DEFAULT_DEGRADED_THRESHOLD,
+    retries = DEFAULT_TOKEN_PRICE_RETRIES,
+    maximumConsecutiveFailures = DEFAULT_TOKEN_PRICE_MAX_CONSECUTIVE_FAILURES,
+    onBreak,
+    onDegraded,
+    circuitBreakDuration = 30 * 60 * 1e3
+  } = {}) {
+    __privateAdd(this, _tokenPricePolicy, void 0);
+    const retryPolicy = retry(handleAll, {
+      maxAttempts: retries,
+      backoff: new ExponentialBackoff()
+    });
+    const circuitBreakerPolicy = circuitBreaker(handleAll, {
+      halfOpenAfter: circuitBreakDuration,
+      breaker: new ConsecutiveBreaker(maximumConsecutiveFailures)
+    });
+    if (onBreak) {
+      circuitBreakerPolicy.onBreak(onBreak);
+    }
+    if (onDegraded) {
+      retryPolicy.onGiveUp(() => {
+        if (circuitBreakerPolicy.state === CircuitState.Closed) {
+          onDegraded();
+        }
+      });
+      retryPolicy.onSuccess(({ duration }) => {
+        if (circuitBreakerPolicy.state === CircuitState.Closed && duration > degradedThreshold) {
+          onDegraded();
+        }
+      });
+    }
+    __privateSet(this, _tokenPricePolicy, wrap(retryPolicy, circuitBreakerPolicy));
+  }
+  /**
+   * Retrieves prices in the given currency for the tokens identified by the
+   * given addresses which are expected to live on the given chain.
+   *
+   * @param args - The arguments to function.
+   * @param args.chainId - An EIP-155 chain ID.
+   * @param args.tokenAddresses - Addresses for tokens that live on the chain.
+   * @param args.currency - The desired currency of the token prices.
+   * @returns The prices for the requested tokens.
+   */
+  async fetchTokenPrices({
+    chainId,
+    tokenAddresses,
+    currency
+  }) {
+    const chainIdAsNumber = hexToNumber(chainId);
+    const url = new URL(`${BASE_URL}/chains/${chainIdAsNumber}/spot-prices`);
+    url.searchParams.append("tokenAddresses", tokenAddresses.join(","));
+    url.searchParams.append("vsCurrency", currency);
+    const pricesByCurrencyByTokenAddress = await __privateGet(this, _tokenPricePolicy).execute(
+      () => handleFetch(url, { headers: { "Cache-Control": "no-cache" } })
+    );
+    return tokenAddresses.reduce(
+      (obj, tokenAddress) => {
+        const lowercasedTokenAddress = tokenAddress.toLowerCase();
+        const lowercasedCurrency = currency.toLowerCase();
+        const price = pricesByCurrencyByTokenAddress[lowercasedTokenAddress]?.[lowercasedCurrency];
+        if (!price) {
+          console.error(
+            `Could not find price for "${tokenAddress}" in "${currency}"`
+          );
+        }
+        const tokenPrice = {
+          tokenAddress,
+          value: price,
+          currency
+        };
+        return {
+          ...obj,
+          ...tokenPrice.value !== void 0 ? { [tokenAddress]: tokenPrice } : {}
+        };
+      },
+      {}
+    );
+  }
+  /**
+   * Type guard for whether the API can return token prices for the given chain
+   * ID.
+   *
+   * @param chainId - The chain ID to check.
+   * @returns True if the API supports the chain ID, false otherwise.
+   */
+  validateChainIdSupported(chainId) {
+    const supportedChainIds = SUPPORTED_CHAIN_IDS;
+    return typeof chainId === "string" && supportedChainIds.includes(chainId);
+  }
+  /**
+   * Type guard for whether the API can return token prices in the given
+   * currency.
+   *
+   * @param currency - The currency to check. If a string, can be either
+   * lowercase or uppercase.
+   * @returns True if the API supports the currency, false otherwise.
+   */
+  validateCurrencySupported(currency) {
+    const supportedCurrencies = SUPPORTED_CURRENCIES;
+    return typeof currency === "string" && supportedCurrencies.includes(currency.toLowerCase());
+  }
+};
+_tokenPricePolicy = new WeakMap();
+
+export {
+  SUPPORTED_CURRENCIES,
+  SUPPORTED_CHAIN_IDS,
+  CodefiTokenPricesServiceV2
+};
+//# sourceMappingURL=chunk-OSEZFHQ3.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-OSEZFHQ3.mjs.map b/node_modules/@metamask/assets-controllers/dist/chunk-OSEZFHQ3.mjs.map
new file mode 100644
index 0000000..047eead
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-OSEZFHQ3.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/token-prices-service/codefi-v2.ts"],"sourcesContent":["import { handleFetch } from '@metamask/controller-utils';\nimport type { Hex } from '@metamask/utils';\nimport { hexToNumber } from '@metamask/utils';\nimport {\n  circuitBreaker,\n  ConsecutiveBreaker,\n  ExponentialBackoff,\n  handleAll,\n  type IPolicy,\n  retry,\n  wrap,\n  CircuitState,\n} from 'cockatiel';\n\nimport type {\n  AbstractTokenPricesService,\n  TokenPrice,\n  TokenPricesByTokenAddress,\n} from './abstract-token-prices-service';\n\n/**\n * The shape of the data that the /spot-prices endpoint returns.\n */\ntype SpotPricesEndpointData<\n  TokenAddress extends Hex,\n  Currency extends string,\n> = Record<TokenAddress, Record<Currency, number>>;\n\n/**\n * The list of currencies that can be supplied as the `vsCurrency` parameter to\n * the `/spot-prices` endpoint, in lowercase form.\n */\nexport const SUPPORTED_CURRENCIES = [\n  // Bitcoin\n  'btc',\n  // Ether\n  'eth',\n  // Litecoin\n  'ltc',\n  // Bitcoin Cash\n  'bch',\n  // Binance Coin\n  'bnb',\n  // EOS\n  'eos',\n  // XRP\n  'xrp',\n  // Lumens\n  'xlm',\n  // Chainlink\n  'link',\n  // Polkadot\n  'dot',\n  // Yearn.finance\n  'yfi',\n  // US Dollar\n  'usd',\n  // United Arab Emirates Dirham\n  'aed',\n  // Argentine Peso\n  'ars',\n  // Australian Dollar\n  'aud',\n  // Bangladeshi Taka\n  'bdt',\n  // Bahraini Dinar\n  'bhd',\n  // Bermudian Dollar\n  'bmd',\n  // Brazil Real\n  'brl',\n  // Canadian Dollar\n  'cad',\n  // Swiss Franc\n  'chf',\n  // Chilean Peso\n  'clp',\n  // Chinese Yuan\n  'cny',\n  // Czech Koruna\n  'czk',\n  // Danish Krone\n  'dkk',\n  // Euro\n  'eur',\n  // British Pound Sterling\n  'gbp',\n  // Hong Kong Dollar\n  'hkd',\n  // Hungarian Forint\n  'huf',\n  // Indonesian Rupiah\n  'idr',\n  // Israeli New Shekel\n  'ils',\n  // Indian Rupee\n  'inr',\n  // Japanese Yen\n  'jpy',\n  // South Korean Won\n  'krw',\n  // Kuwaiti Dinar\n  'kwd',\n  // Sri Lankan Rupee\n  'lkr',\n  // Burmese Kyat\n  'mmk',\n  // Mexican Peso\n  'mxn',\n  // Malaysian Ringgit\n  'myr',\n  // Nigerian Naira\n  'ngn',\n  // Norwegian Krone\n  'nok',\n  // New Zealand Dollar\n  'nzd',\n  // Philippine Peso\n  'php',\n  // Pakistani Rupee\n  'pkr',\n  // Polish Zloty\n  'pln',\n  // Russian Ruble\n  'rub',\n  // Saudi Riyal\n  'sar',\n  // Swedish Krona\n  'sek',\n  // Singapore Dollar\n  'sgd',\n  // Thai Baht\n  'thb',\n  // Turkish Lira\n  'try',\n  // New Taiwan Dollar\n  'twd',\n  // Ukrainian hryvnia\n  'uah',\n  // Venezuelan bolvar fuerte\n  'vef',\n  // Vietnamese ng\n  'vnd',\n  // South African Rand\n  'zar',\n  // IMF Special Drawing Rights\n  'xdr',\n  // Silver - Troy Ounce\n  'xag',\n  // Gold - Troy Ounce\n  'xau',\n  // Bits\n  'bits',\n  // Satoshi\n  'sats',\n] as const;\n\n/**\n * A currency that can be supplied as the `vsCurrency` parameter to\n * the `/spot-prices` endpoint. Covers both uppercase and lowercase versions.\n */\ntype SupportedCurrency =\n  | (typeof SUPPORTED_CURRENCIES)[number]\n  | Uppercase<(typeof SUPPORTED_CURRENCIES)[number]>;\n\n/**\n * The list of chain IDs that can be supplied in the URL for the `/spot-prices`\n * endpoint, but in hexadecimal form (for consistency with how we represent\n * chain IDs in other places).\n * @see Used by {@link CodefiTokenPricesServiceV2} to validate that a given chain ID is supported by V2 of the Codefi Price API.\n */\nexport const SUPPORTED_CHAIN_IDS = [\n  // Ethereum Mainnet\n  '0x1',\n  // OP Mainnet\n  '0xa',\n  // Cronos Mainnet\n  '0x19',\n  // BNB Smart Chain Mainnet\n  '0x38',\n  // Syscoin Mainnet\n  '0x39',\n  // OKXChain Mainnet\n  '0x42',\n  // Hoo Smart Chain\n  '0x46',\n  // Meter Mainnet\n  '0x52',\n  // TomoChain\n  '0x58',\n  // Gnosis\n  '0x64',\n  // Velas EVM Mainnet\n  '0x6a',\n  // Fuse Mainnet\n  '0x7a',\n  // Huobi ECO Chain Mainnet\n  '0x80',\n  // Polygon Mainnet\n  '0x89',\n  // Fantom Opera\n  '0xfa',\n  // Boba Network\n  '0x120',\n  // KCC Mainnet\n  '0x141',\n  // zkSync Era Mainnet\n  '0x144',\n  // Theta Mainnet\n  '0x169',\n  // Metis Andromeda Mainnet\n  '0x440',\n  // Moonbeam\n  '0x504',\n  // Moonriver\n  '0x505',\n  // Base\n  '0x2105',\n  // Shiden\n  '0x150',\n  // Smart Bitcoin Cash\n  '0x2710',\n  // Arbitrum One\n  '0xa4b1',\n  // Celo Mainnet\n  '0xa4ec',\n  // Oasis Emerald\n  '0xa516',\n  // Avalanche C-Chain\n  '0xa86a',\n  // Polis Mainnet\n  '0x518af',\n  // Aurora Mainnet\n  '0x4e454152',\n  // Harmony Mainnet Shard 0\n  '0x63564c40',\n  // Linea Mainnet\n  '0xe708',\n] as const;\n\n/**\n * A chain ID that can be supplied in the URL for the `/spot-prices` endpoint,\n * but in hexadecimal form (for consistency with how we represent chain IDs in\n * other places).\n */\ntype SupportedChainId = (typeof SUPPORTED_CHAIN_IDS)[number];\n\n/**\n * All requests to V2 of the Price API start with this.\n */\nconst BASE_URL = 'https://price-api.metafi.codefi.network/v2';\n\nconst DEFAULT_TOKEN_PRICE_RETRIES = 3;\n// Each update attempt will result (1 + retries) calls if the server is down\nconst DEFAULT_TOKEN_PRICE_MAX_CONSECUTIVE_FAILURES =\n  (1 + DEFAULT_TOKEN_PRICE_RETRIES) * 3;\n\nconst DEFAULT_DEGRADED_THRESHOLD = 5_000;\n\n/**\n * This version of the token prices service uses V2 of the Codefi Price API to\n * fetch token prices.\n */\nexport class CodefiTokenPricesServiceV2\n  implements\n    AbstractTokenPricesService<SupportedChainId, Hex, SupportedCurrency>\n{\n  #tokenPricePolicy: IPolicy;\n\n  /**\n   * Construct a Codefi Token Price Service.\n   *\n   * @param options - Constructor options\n   * @param options.degradedThreshold - The threshold between \"normal\" and \"degrated\" service,\n   * in milliseconds.\n   * @param options.retries - Number of retry attempts for each token price update.\n   * @param options.maximumConsecutiveFailures - The maximum number of consecutive failures\n   * allowed before breaking the circuit and pausing further updates.\n   * @param options.onBreak - An event handler for when the circuit breaks, useful for capturing\n   * metrics about network failures.\n   * @param options.onDegraded - An event handler for when the circuit remains closed, but requests\n   * are failing or resolving too slowly (i.e. resolving more slowly than the `degradedThreshold).\n   * @param options.circuitBreakDuration - The amount of time to wait when the circuit breaks\n   * from too many consecutive failures.\n   */\n  constructor({\n    degradedThreshold = DEFAULT_DEGRADED_THRESHOLD,\n    retries = DEFAULT_TOKEN_PRICE_RETRIES,\n    maximumConsecutiveFailures = DEFAULT_TOKEN_PRICE_MAX_CONSECUTIVE_FAILURES,\n    onBreak,\n    onDegraded,\n    circuitBreakDuration = 30 * 60 * 1000,\n  }: {\n    degradedThreshold?: number;\n    retries?: number;\n    maximumConsecutiveFailures?: number;\n    onBreak?: () => void;\n    onDegraded?: () => void;\n    circuitBreakDuration?: number;\n  } = {}) {\n    // Construct a policy that will retry each update, and halt further updates\n    // for a certain period after too many consecutive failures.\n    const retryPolicy = retry(handleAll, {\n      maxAttempts: retries,\n      backoff: new ExponentialBackoff(),\n    });\n    const circuitBreakerPolicy = circuitBreaker(handleAll, {\n      halfOpenAfter: circuitBreakDuration,\n      breaker: new ConsecutiveBreaker(maximumConsecutiveFailures),\n    });\n    if (onBreak) {\n      circuitBreakerPolicy.onBreak(onBreak);\n    }\n    if (onDegraded) {\n      retryPolicy.onGiveUp(() => {\n        if (circuitBreakerPolicy.state === CircuitState.Closed) {\n          onDegraded();\n        }\n      });\n      retryPolicy.onSuccess(({ duration }) => {\n        if (\n          circuitBreakerPolicy.state === CircuitState.Closed &&\n          duration > degradedThreshold\n        ) {\n          onDegraded();\n        }\n      });\n    }\n    this.#tokenPricePolicy = wrap(retryPolicy, circuitBreakerPolicy);\n  }\n\n  /**\n   * Retrieves prices in the given currency for the tokens identified by the\n   * given addresses which are expected to live on the given chain.\n   *\n   * @param args - The arguments to function.\n   * @param args.chainId - An EIP-155 chain ID.\n   * @param args.tokenAddresses - Addresses for tokens that live on the chain.\n   * @param args.currency - The desired currency of the token prices.\n   * @returns The prices for the requested tokens.\n   */\n  async fetchTokenPrices({\n    chainId,\n    tokenAddresses,\n    currency,\n  }: {\n    chainId: SupportedChainId;\n    tokenAddresses: Hex[];\n    currency: SupportedCurrency;\n  }): Promise<Partial<TokenPricesByTokenAddress<Hex, SupportedCurrency>>> {\n    const chainIdAsNumber = hexToNumber(chainId);\n\n    const url = new URL(`${BASE_URL}/chains/${chainIdAsNumber}/spot-prices`);\n    url.searchParams.append('tokenAddresses', tokenAddresses.join(','));\n    url.searchParams.append('vsCurrency', currency);\n\n    const pricesByCurrencyByTokenAddress: SpotPricesEndpointData<\n      Lowercase<Hex>,\n      Lowercase<SupportedCurrency>\n    > = await this.#tokenPricePolicy.execute(() =>\n      handleFetch(url, { headers: { 'Cache-Control': 'no-cache' } }),\n    );\n\n    return tokenAddresses.reduce(\n      (\n        obj: Partial<TokenPricesByTokenAddress<Hex, SupportedCurrency>>,\n        tokenAddress,\n      ) => {\n        // The Price API lowercases both currency and token addresses, so we have\n        // to keep track of them and make sure we return the original versions.\n        const lowercasedTokenAddress =\n          tokenAddress.toLowerCase() as Lowercase<Hex>;\n        const lowercasedCurrency =\n          currency.toLowerCase() as Lowercase<SupportedCurrency>;\n\n        const price =\n          pricesByCurrencyByTokenAddress[lowercasedTokenAddress]?.[\n            lowercasedCurrency\n          ];\n\n        if (!price) {\n          // console error instead of throwing to not interrupt the fetching of other tokens in case just one fails\n          console.error(\n            `Could not find price for \"${tokenAddress}\" in \"${currency}\"`,\n          );\n        }\n\n        const tokenPrice: TokenPrice<Hex, SupportedCurrency> = {\n          tokenAddress,\n          value: price,\n          currency,\n        };\n\n        return {\n          ...obj,\n          ...(tokenPrice.value !== undefined\n            ? { [tokenAddress]: tokenPrice }\n            : {}),\n        };\n      },\n      {},\n    ) as Partial<TokenPricesByTokenAddress<Hex, SupportedCurrency>>;\n  }\n\n  /**\n   * Type guard for whether the API can return token prices for the given chain\n   * ID.\n   *\n   * @param chainId - The chain ID to check.\n   * @returns True if the API supports the chain ID, false otherwise.\n   */\n  validateChainIdSupported(chainId: unknown): chainId is SupportedChainId {\n    const supportedChainIds: readonly string[] = SUPPORTED_CHAIN_IDS;\n    return typeof chainId === 'string' && supportedChainIds.includes(chainId);\n  }\n\n  /**\n   * Type guard for whether the API can return token prices in the given\n   * currency.\n   *\n   * @param currency - The currency to check. If a string, can be either\n   * lowercase or uppercase.\n   * @returns True if the API supports the currency, false otherwise.\n   */\n  validateCurrencySupported(currency: unknown): currency is SupportedCurrency {\n    const supportedCurrencies: readonly string[] = SUPPORTED_CURRENCIES;\n    return (\n      typeof currency === 'string' &&\n      supportedCurrencies.includes(currency.toLowerCase())\n    );\n  }\n}\n"],"mappings":"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","names":[]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-PAJTKWEC.mjs b/node_modules/@metamask/assets-controllers/dist/chunk-PAJTKWEC.mjs
new file mode 100644
index 0000000..58047d9
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-PAJTKWEC.mjs
@@ -0,0 +1,246 @@
+import {
+  __privateAdd,
+  __privateMethod
+} from "./chunk-XUI43LEZ.mjs";
+
+// src/AccountTrackerController.ts
+import { query, safelyExecuteWithTimeout } from "@metamask/controller-utils";
+import EthQuery from "@metamask/eth-query";
+import { StaticIntervalPollingControllerV1 } from "@metamask/polling-controller";
+import { assert } from "@metamask/utils";
+import { Mutex } from "async-mutex";
+import { cloneDeep } from "lodash";
+var _getCorrectNetworkClient, getCorrectNetworkClient_fn;
+var AccountTrackerController = class extends StaticIntervalPollingControllerV1 {
+  /**
+   * Creates an AccountTracker instance.
+   *
+   * @param options - The controller options.
+   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.
+   * @param options.getIdentities - Gets the identities from the Preferences store.
+   * @param options.getSelectedAddress - Gets the selected address from the Preferences store.
+   * @param options.getMultiAccountBalancesEnabled - Gets the multi account balances enabled flag from the Preferences store.
+   * @param options.getCurrentChainId - Gets the chain ID for the current network from the Network store.
+   * @param options.getNetworkClientById - Gets the network client with the given id from the NetworkController.
+   * @param config - Initial options used to configure this controller.
+   * @param state - Initial state to set on this controller.
+   */
+  constructor({
+    onPreferencesStateChange,
+    getIdentities,
+    getSelectedAddress,
+    getMultiAccountBalancesEnabled,
+    getCurrentChainId,
+    getNetworkClientById
+  }, config, state) {
+    super(config, state);
+    /**
+     * Resolves a networkClientId to a network client config
+     * or globally selected network config if not provided
+     *
+     * @param networkClientId - Optional networkClientId to fetch a network client with
+     * @returns network client config
+     */
+    __privateAdd(this, _getCorrectNetworkClient);
+    this.refreshMutex = new Mutex();
+    /**
+     * Name of this controller used during composition
+     */
+    this.name = "AccountTrackerController";
+    /**
+     * Refreshes the balances of the accounts depending on the multi-account setting.
+     * If multi-account is disabled, only updates the selected account balance.
+     * If multi-account is enabled, updates balances for all accounts.
+     *
+     * @param networkClientId - Optional networkClientId to fetch a network client with
+     */
+    this.refresh = async (networkClientId) => {
+      const releaseLock = await this.refreshMutex.acquire();
+      try {
+        const { chainId, ethQuery } = __privateMethod(this, _getCorrectNetworkClient, getCorrectNetworkClient_fn).call(this, networkClientId);
+        this.syncAccounts(chainId);
+        const { accounts, accountsByChainId } = this.state;
+        const isMultiAccountBalancesEnabled = this.getMultiAccountBalancesEnabled();
+        const accountsToUpdate = isMultiAccountBalancesEnabled ? Object.keys(accounts) : [this.getSelectedAddress()];
+        const accountsForChain = { ...accountsByChainId[chainId] };
+        for (const address of accountsToUpdate) {
+          const balance = await this.getBalanceFromChain(address, ethQuery);
+          if (balance) {
+            accountsForChain[address] = {
+              balance
+            };
+          }
+        }
+        this.update({
+          ...chainId === this.getCurrentChainId() && {
+            accounts: accountsForChain
+          },
+          accountsByChainId: {
+            ...this.state.accountsByChainId,
+            [chainId]: accountsForChain
+          }
+        });
+      } catch (err) {
+        releaseLock();
+        throw err;
+      }
+    };
+    this.defaultConfig = {
+      interval: 1e4
+    };
+    this.defaultState = {
+      accounts: {},
+      accountsByChainId: {
+        [getCurrentChainId()]: {}
+      }
+    };
+    this.initialize();
+    this.setIntervalLength(this.config.interval);
+    this.getIdentities = getIdentities;
+    this.getSelectedAddress = getSelectedAddress;
+    this.getMultiAccountBalancesEnabled = getMultiAccountBalancesEnabled;
+    this.getCurrentChainId = getCurrentChainId;
+    this.getNetworkClientById = getNetworkClientById;
+    onPreferencesStateChange(() => {
+      this.refresh();
+    });
+    this.poll();
+  }
+  syncAccounts(newChainId) {
+    const accounts = { ...this.state.accounts };
+    const accountsByChainId = cloneDeep(this.state.accountsByChainId);
+    const existing = Object.keys(accounts);
+    if (!accountsByChainId[newChainId]) {
+      accountsByChainId[newChainId] = {};
+      existing.forEach((address) => {
+        accountsByChainId[newChainId][address] = { balance: "0x0" };
+      });
+    }
+    const addresses = Object.keys(this.getIdentities());
+    const newAddresses = addresses.filter(
+      (address) => !existing.includes(address)
+    );
+    const oldAddresses = existing.filter(
+      (address) => !addresses.includes(address)
+    );
+    newAddresses.forEach((address) => {
+      accounts[address] = { balance: "0x0" };
+    });
+    Object.keys(accountsByChainId).forEach((chainId) => {
+      newAddresses.forEach((address) => {
+        accountsByChainId[chainId][address] = {
+          balance: "0x0"
+        };
+      });
+    });
+    oldAddresses.forEach((address) => {
+      delete accounts[address];
+    });
+    Object.keys(accountsByChainId).forEach((chainId) => {
+      oldAddresses.forEach((address) => {
+        delete accountsByChainId[chainId][address];
+      });
+    });
+    this.update({ accounts, accountsByChainId });
+  }
+  /**
+   * Sets a new provider.
+   *
+   * TODO: Replace this wth a method.
+   *
+   * @param provider - Provider used to create a new underlying EthQuery instance.
+   */
+  set provider(provider) {
+    this._provider = provider;
+  }
+  get provider() {
+    throw new Error("Property only used for setting");
+  }
+  /**
+   * Starts a new polling interval.
+   *
+   * @param interval - Polling interval trigger a 'refresh'.
+   */
+  async poll(interval) {
+    interval && this.configure({ interval }, false, false);
+    this.handle && clearTimeout(this.handle);
+    await this.refresh();
+    this.handle = setTimeout(() => {
+      this.poll(this.config.interval);
+    }, this.config.interval);
+  }
+  /**
+   * Refreshes the balances of the accounts using the networkClientId
+   *
+   * @param networkClientId - The network client ID used to get balances.
+   */
+  async _executePoll(networkClientId) {
+    this.refresh(networkClientId);
+  }
+  /**
+   * Fetches the balance of a given address from the blockchain.
+   *
+   * @param address - The account address to fetch the balance for.
+   * @param ethQuery - The EthQuery instance to query getBalnce with.
+   * @returns A promise that resolves to the balance in a hex string format.
+   */
+  async getBalanceFromChain(address, ethQuery) {
+    return await safelyExecuteWithTimeout(async () => {
+      assert(ethQuery, "Provider not set.");
+      return await query(ethQuery, "getBalance", [address]);
+    });
+  }
+  /**
+   * Sync accounts balances with some additional addresses.
+   *
+   * @param addresses - the additional addresses, may be hardware wallet addresses.
+   * @param networkClientId - Optional networkClientId to fetch a network client with.
+   * @returns accounts - addresses with synced balance
+   */
+  async syncBalanceWithAddresses(addresses, networkClientId) {
+    const { ethQuery } = __privateMethod(this, _getCorrectNetworkClient, getCorrectNetworkClient_fn).call(this, networkClientId);
+    return await Promise.all(
+      addresses.map((address) => {
+        return safelyExecuteWithTimeout(async () => {
+          assert(ethQuery, "Provider not set.");
+          const balance = await query(ethQuery, "getBalance", [address]);
+          return [address, balance];
+        });
+      })
+    ).then((value) => {
+      return value.reduce((obj, item) => {
+        if (!item) {
+          return obj;
+        }
+        const [address, balance] = item;
+        return {
+          ...obj,
+          [address]: {
+            balance
+          }
+        };
+      }, {});
+    });
+  }
+};
+_getCorrectNetworkClient = new WeakSet();
+getCorrectNetworkClient_fn = function(networkClientId) {
+  if (networkClientId) {
+    const networkClient = this.getNetworkClientById(networkClientId);
+    return {
+      chainId: networkClient.configuration.chainId,
+      ethQuery: new EthQuery(networkClient.provider)
+    };
+  }
+  return {
+    chainId: this.getCurrentChainId(),
+    ethQuery: this._provider ? new EthQuery(this._provider) : void 0
+  };
+};
+var AccountTrackerController_default = AccountTrackerController;
+
+export {
+  AccountTrackerController,
+  AccountTrackerController_default
+};
+//# sourceMappingURL=chunk-PAJTKWEC.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-PAJTKWEC.mjs.map b/node_modules/@metamask/assets-controllers/dist/chunk-PAJTKWEC.mjs.map
new file mode 100644
index 0000000..3365aa4
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-PAJTKWEC.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/AccountTrackerController.ts"],"sourcesContent":["import type { BaseConfig, BaseState } from '@metamask/base-controller';\nimport { query, safelyExecuteWithTimeout } from '@metamask/controller-utils';\nimport EthQuery from '@metamask/eth-query';\nimport type { Provider } from '@metamask/eth-query';\nimport type {\n  NetworkClientId,\n  NetworkController,\n  NetworkState,\n} from '@metamask/network-controller';\nimport { StaticIntervalPollingControllerV1 } from '@metamask/polling-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport { assert } from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\nimport { cloneDeep } from 'lodash';\n\n/**\n * @type AccountInformation\n *\n * Account information object\n * @property balance - Hex string of an account balancec in wei\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface AccountInformation {\n  balance: string;\n}\n\n/**\n * @type AccountTrackerConfig\n *\n * Account tracker controller configuration\n * @property provider - Provider used to create a new underlying EthQuery instance\n */\n// This interface was created before this ESLint rule was added.\n// Remove in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface AccountTrackerConfig extends BaseConfig {\n  interval: number;\n  provider?: Provider;\n}\n\n/**\n * @type AccountTrackerState\n *\n * Account tracker controller state\n * @property accounts - Map of addresses to account information\n */\n// This interface was created before this ESLint rule was added.\n// Remove in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface AccountTrackerState extends BaseState {\n  accounts: { [address: string]: AccountInformation };\n  accountsByChainId: Record<string, { [address: string]: AccountInformation }>;\n}\n\n/**\n * Controller that tracks the network balances for all user accounts.\n */\nexport class AccountTrackerController extends StaticIntervalPollingControllerV1<\n  AccountTrackerConfig,\n  AccountTrackerState\n> {\n  private _provider?: Provider;\n\n  private readonly refreshMutex = new Mutex();\n\n  private handle?: ReturnType<typeof setTimeout>;\n\n  private syncAccounts(newChainId: string) {\n    const accounts = { ...this.state.accounts };\n    const accountsByChainId = cloneDeep(this.state.accountsByChainId);\n\n    const existing = Object.keys(accounts);\n    if (!accountsByChainId[newChainId]) {\n      accountsByChainId[newChainId] = {};\n      existing.forEach((address) => {\n        accountsByChainId[newChainId][address] = { balance: '0x0' };\n      });\n    }\n\n    const addresses = Object.keys(this.getIdentities());\n    const newAddresses = addresses.filter(\n      (address) => !existing.includes(address),\n    );\n    const oldAddresses = existing.filter(\n      (address) => !addresses.includes(address),\n    );\n    newAddresses.forEach((address) => {\n      accounts[address] = { balance: '0x0' };\n    });\n    Object.keys(accountsByChainId).forEach((chainId) => {\n      newAddresses.forEach((address) => {\n        accountsByChainId[chainId][address] = {\n          balance: '0x0',\n        };\n      });\n    });\n\n    oldAddresses.forEach((address) => {\n      delete accounts[address];\n    });\n    Object.keys(accountsByChainId).forEach((chainId) => {\n      oldAddresses.forEach((address) => {\n        delete accountsByChainId[chainId][address];\n      });\n    });\n\n    this.update({ accounts, accountsByChainId });\n  }\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'AccountTrackerController';\n\n  private readonly getIdentities: () => PreferencesState['identities'];\n\n  private readonly getSelectedAddress: () => PreferencesState['selectedAddress'];\n\n  private readonly getMultiAccountBalancesEnabled: () => PreferencesState['isMultiAccountBalancesEnabled'];\n\n  private readonly getCurrentChainId: () => NetworkState['providerConfig']['chainId'];\n\n  private readonly getNetworkClientById: NetworkController['getNetworkClientById'];\n\n  /**\n   * Creates an AccountTracker instance.\n   *\n   * @param options - The controller options.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.getIdentities - Gets the identities from the Preferences store.\n   * @param options.getSelectedAddress - Gets the selected address from the Preferences store.\n   * @param options.getMultiAccountBalancesEnabled - Gets the multi account balances enabled flag from the Preferences store.\n   * @param options.getCurrentChainId - Gets the chain ID for the current network from the Network store.\n   * @param options.getNetworkClientById - Gets the network client with the given id from the NetworkController.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      onPreferencesStateChange,\n      getIdentities,\n      getSelectedAddress,\n      getMultiAccountBalancesEnabled,\n      getCurrentChainId,\n      getNetworkClientById,\n    }: {\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      getIdentities: () => PreferencesState['identities'];\n      getSelectedAddress: () => PreferencesState['selectedAddress'];\n      getMultiAccountBalancesEnabled: () => PreferencesState['isMultiAccountBalancesEnabled'];\n      getCurrentChainId: () => NetworkState['providerConfig']['chainId'];\n      getNetworkClientById: NetworkController['getNetworkClientById'];\n    },\n    config?: Partial<AccountTrackerConfig>,\n    state?: Partial<AccountTrackerState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      interval: 10000,\n    };\n    this.defaultState = {\n      accounts: {},\n      accountsByChainId: {\n        [getCurrentChainId()]: {},\n      },\n    };\n    this.initialize();\n    this.setIntervalLength(this.config.interval);\n    this.getIdentities = getIdentities;\n    this.getSelectedAddress = getSelectedAddress;\n    this.getMultiAccountBalancesEnabled = getMultiAccountBalancesEnabled;\n    this.getCurrentChainId = getCurrentChainId;\n    this.getNetworkClientById = getNetworkClientById;\n    onPreferencesStateChange(() => {\n      this.refresh();\n    });\n    this.poll();\n  }\n\n  /**\n   * Sets a new provider.\n   *\n   * TODO: Replace this wth a method.\n   *\n   * @param provider - Provider used to create a new underlying EthQuery instance.\n   */\n  set provider(provider: Provider) {\n    this._provider = provider;\n  }\n\n  get provider() {\n    throw new Error('Property only used for setting');\n  }\n\n  /**\n   * Resolves a networkClientId to a network client config\n   * or globally selected network config if not provided\n   *\n   * @param networkClientId - Optional networkClientId to fetch a network client with\n   * @returns network client config\n   */\n  #getCorrectNetworkClient(networkClientId?: NetworkClientId): {\n    chainId: string;\n    ethQuery?: EthQuery;\n  } {\n    if (networkClientId) {\n      const networkClient = this.getNetworkClientById(networkClientId);\n\n      return {\n        chainId: networkClient.configuration.chainId,\n        ethQuery: new EthQuery(networkClient.provider),\n      };\n    }\n\n    return {\n      chainId: this.getCurrentChainId(),\n      ethQuery: this._provider ? new EthQuery(this._provider) : undefined,\n    };\n  }\n\n  /**\n   * Starts a new polling interval.\n   *\n   * @param interval - Polling interval trigger a 'refresh'.\n   */\n  async poll(interval?: number): Promise<void> {\n    interval && this.configure({ interval }, false, false);\n    this.handle && clearTimeout(this.handle);\n    await this.refresh();\n    this.handle = setTimeout(() => {\n      this.poll(this.config.interval);\n    }, this.config.interval);\n  }\n\n  /**\n   * Refreshes the balances of the accounts using the networkClientId\n   *\n   * @param networkClientId - The network client ID used to get balances.\n   */\n  async _executePoll(networkClientId: string): Promise<void> {\n    this.refresh(networkClientId);\n  }\n\n  /**\n   * Refreshes the balances of the accounts depending on the multi-account setting.\n   * If multi-account is disabled, only updates the selected account balance.\n   * If multi-account is enabled, updates balances for all accounts.\n   *\n   * @param networkClientId - Optional networkClientId to fetch a network client with\n   */\n  refresh = async (networkClientId?: NetworkClientId) => {\n    const releaseLock = await this.refreshMutex.acquire();\n    try {\n      const { chainId, ethQuery } =\n        this.#getCorrectNetworkClient(networkClientId);\n      this.syncAccounts(chainId);\n      const { accounts, accountsByChainId } = this.state;\n      const isMultiAccountBalancesEnabled =\n        this.getMultiAccountBalancesEnabled();\n\n      const accountsToUpdate = isMultiAccountBalancesEnabled\n        ? Object.keys(accounts)\n        : [this.getSelectedAddress()];\n\n      const accountsForChain = { ...accountsByChainId[chainId] };\n      for (const address of accountsToUpdate) {\n        const balance = await this.getBalanceFromChain(address, ethQuery);\n        if (balance) {\n          accountsForChain[address] = {\n            balance,\n          };\n        }\n      }\n\n      this.update({\n        ...(chainId === this.getCurrentChainId() && {\n          accounts: accountsForChain,\n        }),\n        accountsByChainId: {\n          ...this.state.accountsByChainId,\n          [chainId]: accountsForChain,\n        },\n      });\n    } catch (err) {\n      releaseLock();\n      throw err;\n    }\n  };\n\n  /**\n   * Fetches the balance of a given address from the blockchain.\n   *\n   * @param address - The account address to fetch the balance for.\n   * @param ethQuery - The EthQuery instance to query getBalnce with.\n   * @returns A promise that resolves to the balance in a hex string format.\n   */\n  private async getBalanceFromChain(\n    address: string,\n    ethQuery?: EthQuery,\n  ): Promise<string | undefined> {\n    return await safelyExecuteWithTimeout(async () => {\n      assert(ethQuery, 'Provider not set.');\n      return await query(ethQuery, 'getBalance', [address]);\n    });\n  }\n\n  /**\n   * Sync accounts balances with some additional addresses.\n   *\n   * @param addresses - the additional addresses, may be hardware wallet addresses.\n   * @param networkClientId - Optional networkClientId to fetch a network client with.\n   * @returns accounts - addresses with synced balance\n   */\n  async syncBalanceWithAddresses(\n    addresses: string[],\n    networkClientId?: NetworkClientId,\n  ): Promise<Record<string, { balance: string }>> {\n    const { ethQuery } = this.#getCorrectNetworkClient(networkClientId);\n\n    return await Promise.all(\n      addresses.map((address): Promise<[string, string] | undefined> => {\n        return safelyExecuteWithTimeout(async () => {\n          assert(ethQuery, 'Provider not set.');\n          const balance = await query(ethQuery, 'getBalance', [address]);\n          return [address, balance];\n        });\n      }),\n    ).then((value) => {\n      return value.reduce((obj, item) => {\n        if (!item) {\n          return obj;\n        }\n\n        const [address, balance] = item;\n        return {\n          ...obj,\n          [address]: {\n            balance,\n          },\n        };\n      }, {});\n    });\n  }\n}\n\nexport default AccountTrackerController;\n"],"mappings":"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","names":[]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-PD624ZNK.js b/node_modules/@metamask/assets-controllers/dist/chunk-PD624ZNK.js
new file mode 100644
index 0000000..64e7866
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-PD624ZNK.js
@@ -0,0 +1,418 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});
+
+var _chunkC4PQK53Kjs = require('./chunk-C4PQK53K.js');
+
+
+
+var _chunkRELRWIJNjs = require('./chunk-RELRWIJN.js');
+
+
+
+
+
+var _chunkZ4BLTVTBjs = require('./chunk-Z4BLTVTB.js');
+
+// src/TokenRatesController.ts
+
+
+
+
+
+var _controllerutils = require('@metamask/controller-utils');
+var _pollingcontroller = require('@metamask/polling-controller');
+var _utils = require('@metamask/utils');
+var _lodash = require('lodash');
+async function getCurrencyConversionRate({
+  from,
+  to
+}) {
+  const includeUSDRate = false;
+  try {
+    const result = await _chunkC4PQK53Kjs.fetchExchangeRate.call(void 0, 
+      to,
+      from,
+      includeUSDRate
+    );
+    return result.conversionRate;
+  } catch (error) {
+    if (error instanceof Error && error.message.includes("market does not exist for this coin pair")) {
+      return null;
+    }
+    throw error;
+  }
+}
+var _pollState, _tokenPricesService, _inProcessExchangeRateUpdates, _getTokenAddresses, getTokenAddresses_fn, _stopPoll, stopPoll_fn, _poll, poll_fn, _fetchAndMapExchangeRates, fetchAndMapExchangeRates_fn, _fetchAndMapExchangeRatesForSupportedNativeCurrency, fetchAndMapExchangeRatesForSupportedNativeCurrency_fn, _fetchAndMapExchangeRatesForUnsupportedNativeCurrency, fetchAndMapExchangeRatesForUnsupportedNativeCurrency_fn;
+var TokenRatesController = class extends _pollingcontroller.StaticIntervalPollingControllerV1 {
+  /**
+   * Creates a TokenRatesController instance.
+   *
+   * @param options - The controller options.
+   * @param options.interval - The polling interval in ms
+   * @param options.threshold - The duration in ms before metadata fetched from CoinGecko is considered stale
+   * @param options.getNetworkClientById - Gets the network client with the given id from the NetworkController.
+   * @param options.chainId - The chain ID of the current network.
+   * @param options.ticker - The ticker for the current network.
+   * @param options.selectedAddress - The current selected address.
+   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.
+   * @param options.onTokensStateChange - Allows subscribing to token controller state changes.
+   * @param options.onNetworkStateChange - Allows subscribing to network state changes.
+   * @param options.tokenPricesService - An object in charge of retrieving token prices.
+   * @param config - Initial options used to configure this controller.
+   * @param state - Initial state to set on this controller.
+   */
+  constructor({
+    interval = 3 * 60 * 1e3,
+    threshold = 6 * 60 * 60 * 1e3,
+    getNetworkClientById,
+    chainId: initialChainId,
+    ticker: initialTicker,
+    selectedAddress: initialSelectedAddress,
+    onPreferencesStateChange,
+    onTokensStateChange,
+    onNetworkStateChange,
+    tokenPricesService
+  }, config, state) {
+    super(config, state);
+    /**
+     * Get the user's tokens for the given chain.
+     *
+     * @param chainId - The chain ID.
+     * @returns The list of tokens addresses for the current chain
+     */
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getTokenAddresses);
+    /**
+     * Clear the active polling timer, if present.
+     */
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _stopPoll);
+    /**
+     * Poll for exchange rate updates.
+     */
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _poll);
+    /**
+     * Uses the token prices service to retrieve exchange rates for tokens in a
+     * particular currency.
+     *
+     * If the price API does not support the given chain ID, returns an empty
+     * object.
+     *
+     * If the price API does not support the given currency, retrieves exchange
+     * rates in a known currency instead, then converts those rates using the
+     * exchange rate between the known currency and desired currency.
+     *
+     * @param args - The arguments to this function.
+     * @param args.tokenAddresses - Addresses for tokens.
+     * @param args.chainId - The EIP-155 ID of the chain where the tokens live.
+     * @param args.nativeCurrency - The native currency in which to request
+     * exchange rates.
+     * @returns A map from token address to its exchange rate in the native
+     * currency, or an empty map if no exchange rates can be obtained for the
+     * chain ID.
+     */
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _fetchAndMapExchangeRates);
+    /**
+     * Retrieves prices in the given currency for the given tokens on the given
+     * chain. Ensures that token addresses are checksum addresses.
+     *
+     * @param args - The arguments to this function.
+     * @param args.tokenAddresses - Addresses for tokens.
+     * @param args.chainId - The EIP-155 ID of the chain where the tokens live.
+     * @param args.nativeCurrency - The native currency in which to request
+     * prices.
+     * @returns A map of the token addresses (as checksums) to their prices in the
+     * native currency.
+     */
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _fetchAndMapExchangeRatesForSupportedNativeCurrency);
+    /**
+     * If the price API does not support a given native currency, then we need to
+     * convert it to a fallback currency and feed that currency into the price
+     * API, then convert the prices to our desired native currency.
+     *
+     * @param args - The arguments to this function.
+     * @param args.tokenAddresses - Addresses for tokens.
+     * @param args.nativeCurrency - The native currency in which to request
+     * prices.
+     * @returns A map of the token addresses (as checksums) to their prices in the
+     * native currency.
+     */
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _fetchAndMapExchangeRatesForUnsupportedNativeCurrency);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _pollState, "Inactive" /* Inactive */);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _tokenPricesService, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _inProcessExchangeRateUpdates, {});
+    /**
+     * Name of this controller used during composition
+     */
+    this.name = "TokenRatesController";
+    this.defaultConfig = {
+      interval,
+      threshold,
+      disabled: false,
+      nativeCurrency: initialTicker,
+      chainId: initialChainId,
+      selectedAddress: initialSelectedAddress,
+      allTokens: {},
+      // TODO: initialize these correctly, maybe as part of BaseControllerV2 migration
+      allDetectedTokens: {}
+    };
+    this.defaultState = {
+      contractExchangeRates: {},
+      contractExchangeRatesByChainId: {}
+    };
+    this.initialize();
+    this.setIntervalLength(interval);
+    this.getNetworkClientById = getNetworkClientById;
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _tokenPricesService, tokenPricesService);
+    if (config?.disabled) {
+      this.configure({ disabled: true }, false, false);
+    }
+    onPreferencesStateChange(async ({ selectedAddress }) => {
+      if (this.config.selectedAddress !== selectedAddress) {
+        this.configure({ selectedAddress });
+        if (_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _pollState) === "Active" /* Active */) {
+          await this.updateExchangeRates();
+        }
+      }
+    });
+    onTokensStateChange(async ({ allTokens, allDetectedTokens }) => {
+      const previousTokenAddresses = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getTokenAddresses, getTokenAddresses_fn).call(this, this.config.chainId);
+      this.configure({ allTokens, allDetectedTokens });
+      const newTokenAddresses = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getTokenAddresses, getTokenAddresses_fn).call(this, this.config.chainId);
+      if (!_lodash.isEqual.call(void 0, previousTokenAddresses, newTokenAddresses) && _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _pollState) === "Active" /* Active */) {
+        await this.updateExchangeRates();
+      }
+    });
+    onNetworkStateChange(async ({ providerConfig }) => {
+      const { chainId, ticker } = providerConfig;
+      if (this.config.chainId !== chainId || this.config.nativeCurrency !== ticker) {
+        this.update({ contractExchangeRates: {} });
+        this.configure({ chainId, nativeCurrency: ticker });
+        if (_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _pollState) === "Active" /* Active */) {
+          await this.updateExchangeRates();
+        }
+      }
+    });
+  }
+  /**
+   * Start (or restart) polling.
+   */
+  async start() {
+    _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _stopPoll, stopPoll_fn).call(this);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _pollState, "Active" /* Active */);
+    await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _poll, poll_fn).call(this);
+  }
+  /**
+   * Stop polling.
+   */
+  stop() {
+    _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _stopPoll, stopPoll_fn).call(this);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _pollState, "Inactive" /* Inactive */);
+  }
+  /**
+   * Updates exchange rates for all tokens.
+   */
+  async updateExchangeRates() {
+    const { chainId, nativeCurrency } = this.config;
+    await this.updateExchangeRatesByChainId({
+      chainId,
+      nativeCurrency
+    });
+  }
+  /**
+   * Updates exchange rates for all tokens.
+   *
+   * @param options - The options to fetch exchange rates.
+   * @param options.chainId - The chain ID.
+   * @param options.nativeCurrency - The ticker for the chain.
+   */
+  async updateExchangeRatesByChainId({
+    chainId,
+    nativeCurrency
+  }) {
+    if (this.disabled) {
+      return;
+    }
+    const tokenAddresses = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getTokenAddresses, getTokenAddresses_fn).call(this, chainId);
+    if (tokenAddresses.length === 0) {
+      return;
+    }
+    const updateKey = `${chainId}:${nativeCurrency}`;
+    if (updateKey in _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _inProcessExchangeRateUpdates)) {
+      await _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _inProcessExchangeRateUpdates)[updateKey];
+      return;
+    }
+    const {
+      promise: inProgressUpdate,
+      resolve: updateSucceeded,
+      reject: updateFailed
+    } = _utils.createDeferredPromise.call(void 0, { suppressUnhandledRejection: true });
+    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _inProcessExchangeRateUpdates)[updateKey] = inProgressUpdate;
+    try {
+      const newContractExchangeRates = await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _fetchAndMapExchangeRates, fetchAndMapExchangeRates_fn).call(this, {
+        tokenAddresses,
+        chainId,
+        nativeCurrency
+      });
+      const existingContractExchangeRates = this.state.contractExchangeRates;
+      const updatedContractExchangeRates = chainId === this.config.chainId && nativeCurrency === this.config.nativeCurrency ? newContractExchangeRates : existingContractExchangeRates;
+      const existingContractExchangeRatesForChainId = this.state.contractExchangeRatesByChainId[chainId] ?? {};
+      const updatedContractExchangeRatesForChainId = {
+        ...this.state.contractExchangeRatesByChainId,
+        [chainId]: {
+          ...existingContractExchangeRatesForChainId,
+          [nativeCurrency]: {
+            ...existingContractExchangeRatesForChainId[nativeCurrency],
+            ...newContractExchangeRates
+          }
+        }
+      };
+      this.update({
+        contractExchangeRates: updatedContractExchangeRates,
+        contractExchangeRatesByChainId: updatedContractExchangeRatesForChainId
+      });
+      updateSucceeded();
+    } catch (error) {
+      updateFailed(error);
+      throw error;
+    } finally {
+      delete _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _inProcessExchangeRateUpdates)[updateKey];
+    }
+  }
+  /**
+   * Updates token rates for the given networkClientId
+   *
+   * @param networkClientId - The network client ID used to get a ticker value.
+   * @returns The controller state.
+   */
+  async _executePoll(networkClientId) {
+    const networkClient = this.getNetworkClientById(networkClientId);
+    await this.updateExchangeRatesByChainId({
+      chainId: networkClient.configuration.chainId,
+      nativeCurrency: networkClient.configuration.ticker
+    });
+  }
+};
+_pollState = new WeakMap();
+_tokenPricesService = new WeakMap();
+_inProcessExchangeRateUpdates = new WeakMap();
+_getTokenAddresses = new WeakSet();
+getTokenAddresses_fn = function(chainId) {
+  const { allTokens, allDetectedTokens } = this.config;
+  const tokens = allTokens[chainId]?.[this.config.selectedAddress] || [];
+  const detectedTokens = allDetectedTokens[chainId]?.[this.config.selectedAddress] || [];
+  return [
+    ...new Set(
+      [...tokens, ...detectedTokens].map(
+        (token) => _controllerutils.toHex.call(void 0, _controllerutils.toChecksumHexAddress.call(void 0, token.address))
+      )
+    )
+  ].sort();
+};
+_stopPoll = new WeakSet();
+stopPoll_fn = function() {
+  if (this.handle) {
+    clearTimeout(this.handle);
+  }
+};
+_poll = new WeakSet();
+poll_fn = async function() {
+  await _controllerutils.safelyExecute.call(void 0, () => this.updateExchangeRates());
+  this.handle = setTimeout(() => {
+    _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _poll, poll_fn).call(this);
+  }, this.config.interval);
+};
+_fetchAndMapExchangeRates = new WeakSet();
+fetchAndMapExchangeRates_fn = async function({
+  tokenAddresses,
+  chainId,
+  nativeCurrency
+}) {
+  if (!_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _tokenPricesService).validateChainIdSupported(chainId)) {
+    return tokenAddresses.reduce((obj, tokenAddress) => {
+      return {
+        ...obj,
+        [tokenAddress]: void 0
+      };
+    }, {});
+  }
+  if (_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _tokenPricesService).validateCurrencySupported(nativeCurrency)) {
+    return await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _fetchAndMapExchangeRatesForSupportedNativeCurrency, fetchAndMapExchangeRatesForSupportedNativeCurrency_fn).call(this, {
+      tokenAddresses,
+      chainId,
+      nativeCurrency
+    });
+  }
+  return await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _fetchAndMapExchangeRatesForUnsupportedNativeCurrency, fetchAndMapExchangeRatesForUnsupportedNativeCurrency_fn).call(this, {
+    tokenAddresses,
+    nativeCurrency
+  });
+};
+_fetchAndMapExchangeRatesForSupportedNativeCurrency = new WeakSet();
+fetchAndMapExchangeRatesForSupportedNativeCurrency_fn = async function({
+  tokenAddresses,
+  chainId,
+  nativeCurrency
+}) {
+  const tokenPricesByTokenAddress = await _chunkRELRWIJNjs.reduceInBatchesSerially.call(void 0, {
+    values: [...tokenAddresses].sort(),
+    batchSize: _chunkRELRWIJNjs.TOKEN_PRICES_BATCH_SIZE,
+    eachBatch: async (allTokenPricesByTokenAddress, batch) => {
+      const tokenPricesByTokenAddressForBatch = await _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _tokenPricesService).fetchTokenPrices({
+        tokenAddresses: batch,
+        chainId,
+        currency: nativeCurrency
+      });
+      return {
+        ...allTokenPricesByTokenAddress,
+        ...tokenPricesByTokenAddressForBatch
+      };
+    },
+    initialResult: {}
+  });
+  return Object.entries(tokenPricesByTokenAddress).reduce(
+    (obj, [tokenAddress, tokenPrice]) => {
+      return {
+        ...obj,
+        [tokenAddress]: tokenPrice?.value
+      };
+    },
+    {}
+  );
+};
+_fetchAndMapExchangeRatesForUnsupportedNativeCurrency = new WeakSet();
+fetchAndMapExchangeRatesForUnsupportedNativeCurrency_fn = async function({
+  tokenAddresses,
+  nativeCurrency
+}) {
+  const [
+    contractExchangeRates,
+    fallbackCurrencyToNativeCurrencyConversionRate
+  ] = await Promise.all([
+    _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _fetchAndMapExchangeRatesForSupportedNativeCurrency, fetchAndMapExchangeRatesForSupportedNativeCurrency_fn).call(this, {
+      tokenAddresses,
+      chainId: this.config.chainId,
+      nativeCurrency: _controllerutils.FALL_BACK_VS_CURRENCY
+    }),
+    getCurrencyConversionRate({
+      from: _controllerutils.FALL_BACK_VS_CURRENCY,
+      to: nativeCurrency
+    })
+  ]);
+  if (fallbackCurrencyToNativeCurrencyConversionRate === null) {
+    return {};
+  }
+  return Object.entries(contractExchangeRates).reduce(
+    (obj, [tokenAddress, tokenValue]) => {
+      return {
+        ...obj,
+        [tokenAddress]: tokenValue ? tokenValue * fallbackCurrencyToNativeCurrencyConversionRate : void 0
+      };
+    },
+    {}
+  );
+};
+var TokenRatesController_default = TokenRatesController;
+
+
+
+
+exports.TokenRatesController = TokenRatesController; exports.TokenRatesController_default = TokenRatesController_default;
+//# sourceMappingURL=chunk-PD624ZNK.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-PD624ZNK.js.map b/node_modules/@metamask/assets-controllers/dist/chunk-PD624ZNK.js.map
new file mode 100644
index 0000000..230b7f4
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-PD624ZNK.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/TokenRatesController.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;AACA;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAMP,SAAS,yCAAyC;AAElD,SAAS,6BAAuC;AAChD,SAAS,eAAe;AA8FxB,eAAe,0BAA0B;AAAA,EACvC;AAAA,EACA;AACF,GAGG;AACD,QAAM,iBAAiB;AACvB,MAAI;AACF,UAAM,SAAS,MAAM;AAAA,MACnB;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,WAAO,OAAO;AAAA,EAChB,SAAS,OAAO;AACd,QACE,iBAAiB,SACjB,MAAM,QAAQ,SAAS,0CAA0C,GACjE;AACA,aAAO;AAAA,IACT;AACA,UAAM;AAAA,EACR;AACF;AArIA;AA2IO,IAAM,uBAAN,cAAmC,kCAGxC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAiCA,YACE;AAAA,IACE,WAAW,IAAI,KAAK;AAAA,IACpB,YAAY,IAAI,KAAK,KAAK;AAAA,IAC1B;AAAA,IACA,SAAS;AAAA,IACT,QAAQ;AAAA,IACR,iBAAiB;AAAA,IACjB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAkBA,QACA,OACA;AACA,UAAM,QAAQ,KAAK;AAqErB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmCA;AAAA;AAAA;AAAA;AASA;AAAA;AAAA;AAAA,uBAAM;AAwHN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAAM;AA0DN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAAM;AAsDN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAAM;AAxZN,mCAAa;AAEb;AAEA,sDAA2E,CAAC;AAK5E;AAAA;AAAA;AAAA,SAAS,OAAO;AAuDd,SAAK,gBAAgB;AAAA,MACnB;AAAA,MACA;AAAA,MACA,UAAU;AAAA,MACV,gBAAgB;AAAA,MAChB,SAAS;AAAA,MACT,iBAAiB;AAAA,MACjB,WAAW,CAAC;AAAA;AAAA,MACZ,mBAAmB,CAAC;AAAA,IACtB;AAEA,SAAK,eAAe;AAAA,MAClB,uBAAuB,CAAC;AAAA,MACxB,gCAAgC,CAAC;AAAA,IACnC;AACA,SAAK,WAAW;AAChB,SAAK,kBAAkB,QAAQ;AAC/B,SAAK,uBAAuB;AAC5B,uBAAK,qBAAsB;AAE3B,QAAI,QAAQ,UAAU;AACpB,WAAK,UAAU,EAAE,UAAU,KAAK,GAAG,OAAO,KAAK;AAAA,IACjD;AAEA,6BAAyB,OAAO,EAAE,gBAAgB,MAAM;AACtD,UAAI,KAAK,OAAO,oBAAoB,iBAAiB;AACnD,aAAK,UAAU,EAAE,gBAAgB,CAAC;AAClC,YAAI,mBAAK,gBAAe,uBAAkB;AACxC,gBAAM,KAAK,oBAAoB;AAAA,QACjC;AAAA,MACF;AAAA,IACF,CAAC;AAED,wBAAoB,OAAO,EAAE,WAAW,kBAAkB,MAAM;AAC9D,YAAM,yBAAyB,sBAAK,0CAAL,WAC7B,KAAK,OAAO;AAEd,WAAK,UAAU,EAAE,WAAW,kBAAkB,CAAC;AAC/C,YAAM,oBAAoB,sBAAK,0CAAL,WAAwB,KAAK,OAAO;AAC9D,UACE,CAAC,QAAQ,wBAAwB,iBAAiB,KAClD,mBAAK,gBAAe,uBACpB;AACA,cAAM,KAAK,oBAAoB;AAAA,MACjC;AAAA,IACF,CAAC;AAED,yBAAqB,OAAO,EAAE,eAAe,MAAM;AACjD,YAAM,EAAE,SAAS,OAAO,IAAI;AAC5B,UACE,KAAK,OAAO,YAAY,WACxB,KAAK,OAAO,mBAAmB,QAC/B;AACA,aAAK,OAAO,EAAE,uBAAuB,CAAC,EAAE,CAAC;AACzC,aAAK,UAAU,EAAE,SAAS,gBAAgB,OAAO,CAAC;AAClD,YAAI,mBAAK,gBAAe,uBAAkB;AACxC,gBAAM,KAAK,oBAAoB;AAAA,QACjC;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EA0BA,MAAM,QAAQ;AACZ,0BAAK,wBAAL;AACA,uBAAK,YAAa;AAClB,UAAM,sBAAK,gBAAL;AAAA,EACR;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO;AACL,0BAAK,wBAAL;AACA,uBAAK,YAAa;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA,EA2BA,MAAM,sBAAsB;AAC1B,UAAM,EAAE,SAAS,eAAe,IAAI,KAAK;AACzC,UAAM,KAAK,6BAA6B;AAAA,MACtC;AAAA,MACA;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,6BAA6B;AAAA,IACjC;AAAA,IACA;AAAA,EACF,GAGG;AACD,QAAI,KAAK,UAAU;AACjB;AAAA,IACF;AAEA,UAAM,iBAAiB,sBAAK,0CAAL,WAAwB;AAC/C,QAAI,eAAe,WAAW,GAAG;AAC/B;AAAA,IACF;AAEA,UAAM,YAAgC,GAAG,OAAO,IAAI,cAAc;AAClE,QAAI,aAAa,mBAAK,gCAA+B;AAInD,YAAM,mBAAK,+BAA8B,SAAS;AAClD;AAAA,IACF;AAEA,UAAM;AAAA,MACJ,SAAS;AAAA,MACT,SAAS;AAAA,MACT,QAAQ;AAAA,IACV,IAAI,sBAAsB,EAAE,4BAA4B,KAAK,CAAC;AAC9D,uBAAK,+BAA8B,SAAS,IAAI;AAEhD,QAAI;AACF,YAAM,2BAA2B,MAAM,sBAAK,wDAAL,WAA+B;AAAA,QACpE;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAEA,YAAM,gCAAgC,KAAK,MAAM;AACjD,YAAM,+BACJ,YAAY,KAAK,OAAO,WACxB,mBAAmB,KAAK,OAAO,iBAC3B,2BACA;AAEN,YAAM,0CACJ,KAAK,MAAM,+BAA+B,OAAO,KAAK,CAAC;AACzD,YAAM,yCAAyC;AAAA,QAC7C,GAAG,KAAK,MAAM;AAAA,QACd,CAAC,OAAO,GAAG;AAAA,UACT,GAAG;AAAA,UACH,CAAC,cAAc,GAAG;AAAA,YAChB,GAAG,wCAAwC,cAAc;AAAA,YACzD,GAAG;AAAA,UACL;AAAA,QACF;AAAA,MACF;AAEA,WAAK,OAAO;AAAA,QACV,uBAAuB;AAAA,QACvB,gCAAgC;AAAA,MAClC,CAAC;AACD,sBAAgB;AAAA,IAClB,SAAS,OAAgB;AACvB,mBAAa,KAAK;AAClB,YAAM;AAAA,IACR,UAAE;AACA,aAAO,mBAAK,+BAA8B,SAAS;AAAA,IACrD;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA4DA,MAAM,aAAa,iBAAiD;AAClE,UAAM,gBAAgB,KAAK,qBAAqB,eAAe;AAC/D,UAAM,KAAK,6BAA6B;AAAA,MACtC,SAAS,cAAc,cAAc;AAAA,MACrC,gBAAgB,cAAc,cAAc;AAAA,IAC9C,CAAC;AAAA,EACH;AA0GF;AA9bE;AAEA;AAEA;AAgIA;AAAA,uBAAkB,SAAC,SAAqB;AACtC,QAAM,EAAE,WAAW,kBAAkB,IAAI,KAAK;AAC9C,QAAM,SAAS,UAAU,OAAO,IAAI,KAAK,OAAO,eAAe,KAAK,CAAC;AACrE,QAAM,iBACJ,kBAAkB,OAAO,IAAI,KAAK,OAAO,eAAe,KAAK,CAAC;AAEhE,SAAO;AAAA,IACL,GAAG,IAAI;AAAA,MACL,CAAC,GAAG,QAAQ,GAAG,cAAc,EAAE;AAAA,QAAI,CAAC,UAClC,MAAM,qBAAqB,MAAM,OAAO,CAAC;AAAA,MAC3C;AAAA,IACF;AAAA,EACF,EAAE,KAAK;AACT;AAsBA;AAAA,cAAS,WAAG;AACV,MAAI,KAAK,QAAQ;AACf,iBAAa,KAAK,MAAM;AAAA,EAC1B;AACF;AAKM;AAAA,UAAK,iBAAG;AACZ,QAAM,cAAc,MAAM,KAAK,oBAAoB,CAAC;AAIpD,OAAK,SAAS,WAAW,MAAM;AAC7B,0BAAK,gBAAL;AAAA,EACF,GAAG,KAAK,OAAO,QAAQ;AACzB;AAgHM;AAAA,8BAAyB,eAAC;AAAA,EAC9B;AAAA,EACA;AAAA,EACA;AACF,GAImC;AACjC,MAAI,CAAC,mBAAK,qBAAoB,yBAAyB,OAAO,GAAG;AAC/D,WAAO,eAAe,OAAO,CAAC,KAAK,iBAAiB;AAClD,aAAO;AAAA,QACL,GAAG;AAAA,QACH,CAAC,YAAY,GAAG;AAAA,MAClB;AAAA,IACF,GAAG,CAAC,CAAC;AAAA,EACP;AAEA,MAAI,mBAAK,qBAAoB,0BAA0B,cAAc,GAAG;AACtE,WAAO,MAAM,sBAAK,4GAAL,WAAyD;AAAA,MACpE;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAEA,SAAO,MAAM,sBAAK,gHAAL,WAA2D;AAAA,IACtE;AAAA,IACA;AAAA,EACF;AACF;AA4BM;AAAA,wDAAmD,eAAC;AAAA,EACxD;AAAA,EACA;AAAA,EACA;AACF,GAImC;AACjC,QAAM,4BAA4B,MAAM,wBAGtC;AAAA,IACA,QAAQ,CAAC,GAAG,cAAc,EAAE,KAAK;AAAA,IACjC,WAAW;AAAA,IACX,WAAW,OAAO,8BAA8B,UAAU;AACxD,YAAM,oCACJ,MAAM,mBAAK,qBAAoB,iBAAiB;AAAA,QAC9C,gBAAgB;AAAA,QAChB;AAAA,QACA,UAAU;AAAA,MACZ,CAAC;AAEH,aAAO;AAAA,QACL,GAAG;AAAA,QACH,GAAG;AAAA,MACL;AAAA,IACF;AAAA,IACA,eAAe,CAAC;AAAA,EAClB,CAAC;AAED,SAAO,OAAO,QAAQ,yBAAyB,EAAE;AAAA,IAC/C,CAAC,KAAK,CAAC,cAAc,UAAU,MAAM;AACnC,aAAO;AAAA,QACL,GAAG;AAAA,QACH,CAAC,YAAY,GAAG,YAAY;AAAA,MAC9B;AAAA,IACF;AAAA,IACA,CAAC;AAAA,EACH;AACF;AAcM;AAAA,0DAAqD,eAAC;AAAA,EAC1D;AAAA,EACA;AACF,GAGmC;AACjC,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,EACF,IAAI,MAAM,QAAQ,IAAI;AAAA,IACpB,sBAAK,4GAAL,WAAyD;AAAA,MACvD;AAAA,MACA,SAAS,KAAK,OAAO;AAAA,MACrB,gBAAgB;AAAA,IAClB;AAAA,IACA,0BAA0B;AAAA,MACxB,MAAM;AAAA,MACN,IAAI;AAAA,IACN,CAAC;AAAA,EACH,CAAC;AAED,MAAI,mDAAmD,MAAM;AAC3D,WAAO,CAAC;AAAA,EACV;AAEA,SAAO,OAAO,QAAQ,qBAAqB,EAAE;AAAA,IAC3C,CAAC,KAAK,CAAC,cAAc,UAAU,MAAM;AACnC,aAAO;AAAA,QACL,GAAG;AAAA,QACH,CAAC,YAAY,GAAG,aACZ,aAAa,iDACb;AAAA,MACN;AAAA,IACF;AAAA,IACA,CAAC;AAAA,EACH;AACF;AAGF,IAAO,+BAAQ","sourcesContent":["import type { BaseConfig, BaseState } from '@metamask/base-controller';\nimport {\n  safelyExecute,\n  toChecksumHexAddress,\n  FALL_BACK_VS_CURRENCY,\n  toHex,\n} from '@metamask/controller-utils';\nimport type {\n  NetworkClientId,\n  NetworkController,\n  NetworkState,\n} from '@metamask/network-controller';\nimport { StaticIntervalPollingControllerV1 } from '@metamask/polling-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport { createDeferredPromise, type Hex } from '@metamask/utils';\nimport { isEqual } from 'lodash';\n\nimport { reduceInBatchesSerially, TOKEN_PRICES_BATCH_SIZE } from './assetsUtil';\nimport { fetchExchangeRate as fetchNativeCurrencyExchangeRate } from './crypto-compare';\nimport type { AbstractTokenPricesService } from './token-prices-service/abstract-token-prices-service';\nimport type { TokensState } from './TokensController';\n\n/**\n * @type Token\n *\n * Token representation\n * @property address - Hex address of the token contract\n * @property decimals - Number of decimals the token uses\n * @property symbol - Symbol of the token\n * @property image - Image of the token, url or bit32 image\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface Token {\n  address: string;\n  decimals: number;\n  symbol: string;\n  aggregators?: string[];\n  image?: string;\n  balanceError?: unknown;\n  isERC721?: boolean;\n  name?: string;\n}\n\n/**\n * @type TokenRatesConfig\n *\n * Token rates controller configuration\n * @property interval - Polling interval used to fetch new token rates\n * @property nativeCurrency - Current native currency selected to use base of rates\n * @property chainId - Current network chainId\n * @property tokens - List of tokens to track exchange rates for\n * @property threshold - Threshold to invalidate the supportedChains\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface TokenRatesConfig extends BaseConfig {\n  interval: number;\n  nativeCurrency: string;\n  chainId: Hex;\n  selectedAddress: string;\n  allTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n  allDetectedTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n  threshold: number;\n}\n\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface ContractExchangeRates {\n  [address: string]: number | undefined;\n}\n\nenum PollState {\n  Active = 'Active',\n  Inactive = 'Inactive',\n}\n\n/**\n * @type TokenRatesState\n *\n * Token rates controller state\n * @property contractExchangeRates - Hash of token contract addresses to exchange rates (single globally selected chain, will be deprecated soon)\n * @property contractExchangeRatesByChainId - Hash of token contract addresses to exchange rates keyed by chain ID and native currency (ticker)\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface TokenRatesState extends BaseState {\n  contractExchangeRates: ContractExchangeRates;\n  contractExchangeRatesByChainId: Record<\n    Hex,\n    Record<string, ContractExchangeRates>\n  >;\n}\n\n/**\n * Uses the CryptoCompare API to fetch the exchange rate between one currency\n * and another, i.e., the multiplier to apply the amount of one currency in\n * order to convert it to another.\n *\n * @param args - The arguments to this function.\n * @param args.from - The currency to convert from.\n * @param args.to - The currency to convert to.\n * @returns The exchange rate between `fromCurrency` to `toCurrency` if one\n * exists, or null if one does not.\n */\nasync function getCurrencyConversionRate({\n  from,\n  to,\n}: {\n  from: string;\n  to: string;\n}) {\n  const includeUSDRate = false;\n  try {\n    const result = await fetchNativeCurrencyExchangeRate(\n      to,\n      from,\n      includeUSDRate,\n    );\n    return result.conversionRate;\n  } catch (error) {\n    if (\n      error instanceof Error &&\n      error.message.includes('market does not exist for this coin pair')\n    ) {\n      return null;\n    }\n    throw error;\n  }\n}\n\n/**\n * Controller that passively polls on a set interval for token-to-fiat exchange rates\n * for tokens stored in the TokensController\n */\nexport class TokenRatesController extends StaticIntervalPollingControllerV1<\n  TokenRatesConfig,\n  TokenRatesState\n> {\n  private handle?: ReturnType<typeof setTimeout>;\n\n  #pollState = PollState.Inactive;\n\n  #tokenPricesService: AbstractTokenPricesService;\n\n  #inProcessExchangeRateUpdates: Record<`${Hex}:${string}`, Promise<void>> = {};\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'TokenRatesController';\n\n  private readonly getNetworkClientById: NetworkController['getNetworkClientById'];\n\n  /**\n   * Creates a TokenRatesController instance.\n   *\n   * @param options - The controller options.\n   * @param options.interval - The polling interval in ms\n   * @param options.threshold - The duration in ms before metadata fetched from CoinGecko is considered stale\n   * @param options.getNetworkClientById - Gets the network client with the given id from the NetworkController.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.ticker - The ticker for the current network.\n   * @param options.selectedAddress - The current selected address.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.onTokensStateChange - Allows subscribing to token controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network state changes.\n   * @param options.tokenPricesService - An object in charge of retrieving token prices.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      interval = 3 * 60 * 1000,\n      threshold = 6 * 60 * 60 * 1000,\n      getNetworkClientById,\n      chainId: initialChainId,\n      ticker: initialTicker,\n      selectedAddress: initialSelectedAddress,\n      onPreferencesStateChange,\n      onTokensStateChange,\n      onNetworkStateChange,\n      tokenPricesService,\n    }: {\n      interval?: number;\n      threshold?: number;\n      getNetworkClientById: NetworkController['getNetworkClientById'];\n      chainId: Hex;\n      ticker: string;\n      selectedAddress: string;\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onTokensStateChange: (\n        listener: (tokensState: TokensState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      tokenPricesService: AbstractTokenPricesService;\n    },\n    config?: Partial<TokenRatesConfig>,\n    state?: Partial<TokenRatesState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      interval,\n      threshold,\n      disabled: false,\n      nativeCurrency: initialTicker,\n      chainId: initialChainId,\n      selectedAddress: initialSelectedAddress,\n      allTokens: {}, // TODO: initialize these correctly, maybe as part of BaseControllerV2 migration\n      allDetectedTokens: {},\n    };\n\n    this.defaultState = {\n      contractExchangeRates: {},\n      contractExchangeRatesByChainId: {},\n    };\n    this.initialize();\n    this.setIntervalLength(interval);\n    this.getNetworkClientById = getNetworkClientById;\n    this.#tokenPricesService = tokenPricesService;\n\n    if (config?.disabled) {\n      this.configure({ disabled: true }, false, false);\n    }\n\n    onPreferencesStateChange(async ({ selectedAddress }) => {\n      if (this.config.selectedAddress !== selectedAddress) {\n        this.configure({ selectedAddress });\n        if (this.#pollState === PollState.Active) {\n          await this.updateExchangeRates();\n        }\n      }\n    });\n\n    onTokensStateChange(async ({ allTokens, allDetectedTokens }) => {\n      const previousTokenAddresses = this.#getTokenAddresses(\n        this.config.chainId,\n      );\n      this.configure({ allTokens, allDetectedTokens });\n      const newTokenAddresses = this.#getTokenAddresses(this.config.chainId);\n      if (\n        !isEqual(previousTokenAddresses, newTokenAddresses) &&\n        this.#pollState === PollState.Active\n      ) {\n        await this.updateExchangeRates();\n      }\n    });\n\n    onNetworkStateChange(async ({ providerConfig }) => {\n      const { chainId, ticker } = providerConfig;\n      if (\n        this.config.chainId !== chainId ||\n        this.config.nativeCurrency !== ticker\n      ) {\n        this.update({ contractExchangeRates: {} });\n        this.configure({ chainId, nativeCurrency: ticker });\n        if (this.#pollState === PollState.Active) {\n          await this.updateExchangeRates();\n        }\n      }\n    });\n  }\n\n  /**\n   * Get the user's tokens for the given chain.\n   *\n   * @param chainId - The chain ID.\n   * @returns The list of tokens addresses for the current chain\n   */\n  #getTokenAddresses(chainId: Hex): Hex[] {\n    const { allTokens, allDetectedTokens } = this.config;\n    const tokens = allTokens[chainId]?.[this.config.selectedAddress] || [];\n    const detectedTokens =\n      allDetectedTokens[chainId]?.[this.config.selectedAddress] || [];\n\n    return [\n      ...new Set(\n        [...tokens, ...detectedTokens].map((token) =>\n          toHex(toChecksumHexAddress(token.address)),\n        ),\n      ),\n    ].sort();\n  }\n\n  /**\n   * Start (or restart) polling.\n   */\n  async start() {\n    this.#stopPoll();\n    this.#pollState = PollState.Active;\n    await this.#poll();\n  }\n\n  /**\n   * Stop polling.\n   */\n  stop() {\n    this.#stopPoll();\n    this.#pollState = PollState.Inactive;\n  }\n\n  /**\n   * Clear the active polling timer, if present.\n   */\n  #stopPoll() {\n    if (this.handle) {\n      clearTimeout(this.handle);\n    }\n  }\n\n  /**\n   * Poll for exchange rate updates.\n   */\n  async #poll() {\n    await safelyExecute(() => this.updateExchangeRates());\n\n    // Poll using recursive `setTimeout` instead of `setInterval` so that\n    // requests don't stack if they take longer than the polling interval\n    this.handle = setTimeout(() => {\n      this.#poll();\n    }, this.config.interval);\n  }\n\n  /**\n   * Updates exchange rates for all tokens.\n   */\n  async updateExchangeRates() {\n    const { chainId, nativeCurrency } = this.config;\n    await this.updateExchangeRatesByChainId({\n      chainId,\n      nativeCurrency,\n    });\n  }\n\n  /**\n   * Updates exchange rates for all tokens.\n   *\n   * @param options - The options to fetch exchange rates.\n   * @param options.chainId - The chain ID.\n   * @param options.nativeCurrency - The ticker for the chain.\n   */\n  async updateExchangeRatesByChainId({\n    chainId,\n    nativeCurrency,\n  }: {\n    chainId: Hex;\n    nativeCurrency: string;\n  }) {\n    if (this.disabled) {\n      return;\n    }\n\n    const tokenAddresses = this.#getTokenAddresses(chainId);\n    if (tokenAddresses.length === 0) {\n      return;\n    }\n\n    const updateKey: `${Hex}:${string}` = `${chainId}:${nativeCurrency}`;\n    if (updateKey in this.#inProcessExchangeRateUpdates) {\n      // This prevents redundant updates\n      // This promise is resolved after the in-progress update has finished,\n      // and state has been updated.\n      await this.#inProcessExchangeRateUpdates[updateKey];\n      return;\n    }\n\n    const {\n      promise: inProgressUpdate,\n      resolve: updateSucceeded,\n      reject: updateFailed,\n    } = createDeferredPromise({ suppressUnhandledRejection: true });\n    this.#inProcessExchangeRateUpdates[updateKey] = inProgressUpdate;\n\n    try {\n      const newContractExchangeRates = await this.#fetchAndMapExchangeRates({\n        tokenAddresses,\n        chainId,\n        nativeCurrency,\n      });\n\n      const existingContractExchangeRates = this.state.contractExchangeRates;\n      const updatedContractExchangeRates =\n        chainId === this.config.chainId &&\n        nativeCurrency === this.config.nativeCurrency\n          ? newContractExchangeRates\n          : existingContractExchangeRates;\n\n      const existingContractExchangeRatesForChainId =\n        this.state.contractExchangeRatesByChainId[chainId] ?? {};\n      const updatedContractExchangeRatesForChainId = {\n        ...this.state.contractExchangeRatesByChainId,\n        [chainId]: {\n          ...existingContractExchangeRatesForChainId,\n          [nativeCurrency]: {\n            ...existingContractExchangeRatesForChainId[nativeCurrency],\n            ...newContractExchangeRates,\n          },\n        },\n      };\n\n      this.update({\n        contractExchangeRates: updatedContractExchangeRates,\n        contractExchangeRatesByChainId: updatedContractExchangeRatesForChainId,\n      });\n      updateSucceeded();\n    } catch (error: unknown) {\n      updateFailed(error);\n      throw error;\n    } finally {\n      delete this.#inProcessExchangeRateUpdates[updateKey];\n    }\n  }\n\n  /**\n   * Uses the token prices service to retrieve exchange rates for tokens in a\n   * particular currency.\n   *\n   * If the price API does not support the given chain ID, returns an empty\n   * object.\n   *\n   * If the price API does not support the given currency, retrieves exchange\n   * rates in a known currency instead, then converts those rates using the\n   * exchange rate between the known currency and desired currency.\n   *\n   * @param args - The arguments to this function.\n   * @param args.tokenAddresses - Addresses for tokens.\n   * @param args.chainId - The EIP-155 ID of the chain where the tokens live.\n   * @param args.nativeCurrency - The native currency in which to request\n   * exchange rates.\n   * @returns A map from token address to its exchange rate in the native\n   * currency, or an empty map if no exchange rates can be obtained for the\n   * chain ID.\n   */\n  async #fetchAndMapExchangeRates({\n    tokenAddresses,\n    chainId,\n    nativeCurrency,\n  }: {\n    tokenAddresses: Hex[];\n    chainId: Hex;\n    nativeCurrency: string;\n  }): Promise<ContractExchangeRates> {\n    if (!this.#tokenPricesService.validateChainIdSupported(chainId)) {\n      return tokenAddresses.reduce((obj, tokenAddress) => {\n        return {\n          ...obj,\n          [tokenAddress]: undefined,\n        };\n      }, {});\n    }\n\n    if (this.#tokenPricesService.validateCurrencySupported(nativeCurrency)) {\n      return await this.#fetchAndMapExchangeRatesForSupportedNativeCurrency({\n        tokenAddresses,\n        chainId,\n        nativeCurrency,\n      });\n    }\n\n    return await this.#fetchAndMapExchangeRatesForUnsupportedNativeCurrency({\n      tokenAddresses,\n      nativeCurrency,\n    });\n  }\n\n  /**\n   * Updates token rates for the given networkClientId\n   *\n   * @param networkClientId - The network client ID used to get a ticker value.\n   * @returns The controller state.\n   */\n  async _executePoll(networkClientId: NetworkClientId): Promise<void> {\n    const networkClient = this.getNetworkClientById(networkClientId);\n    await this.updateExchangeRatesByChainId({\n      chainId: networkClient.configuration.chainId,\n      nativeCurrency: networkClient.configuration.ticker,\n    });\n  }\n\n  /**\n   * Retrieves prices in the given currency for the given tokens on the given\n   * chain. Ensures that token addresses are checksum addresses.\n   *\n   * @param args - The arguments to this function.\n   * @param args.tokenAddresses - Addresses for tokens.\n   * @param args.chainId - The EIP-155 ID of the chain where the tokens live.\n   * @param args.nativeCurrency - The native currency in which to request\n   * prices.\n   * @returns A map of the token addresses (as checksums) to their prices in the\n   * native currency.\n   */\n  async #fetchAndMapExchangeRatesForSupportedNativeCurrency({\n    tokenAddresses,\n    chainId,\n    nativeCurrency,\n  }: {\n    tokenAddresses: Hex[];\n    chainId: Hex;\n    nativeCurrency: string;\n  }): Promise<ContractExchangeRates> {\n    const tokenPricesByTokenAddress = await reduceInBatchesSerially<\n      Hex,\n      Awaited<ReturnType<AbstractTokenPricesService['fetchTokenPrices']>>\n    >({\n      values: [...tokenAddresses].sort(),\n      batchSize: TOKEN_PRICES_BATCH_SIZE,\n      eachBatch: async (allTokenPricesByTokenAddress, batch) => {\n        const tokenPricesByTokenAddressForBatch =\n          await this.#tokenPricesService.fetchTokenPrices({\n            tokenAddresses: batch,\n            chainId,\n            currency: nativeCurrency,\n          });\n\n        return {\n          ...allTokenPricesByTokenAddress,\n          ...tokenPricesByTokenAddressForBatch,\n        };\n      },\n      initialResult: {},\n    });\n\n    return Object.entries(tokenPricesByTokenAddress).reduce(\n      (obj, [tokenAddress, tokenPrice]) => {\n        return {\n          ...obj,\n          [tokenAddress]: tokenPrice?.value,\n        };\n      },\n      {},\n    );\n  }\n\n  /**\n   * If the price API does not support a given native currency, then we need to\n   * convert it to a fallback currency and feed that currency into the price\n   * API, then convert the prices to our desired native currency.\n   *\n   * @param args - The arguments to this function.\n   * @param args.tokenAddresses - Addresses for tokens.\n   * @param args.nativeCurrency - The native currency in which to request\n   * prices.\n   * @returns A map of the token addresses (as checksums) to their prices in the\n   * native currency.\n   */\n  async #fetchAndMapExchangeRatesForUnsupportedNativeCurrency({\n    tokenAddresses,\n    nativeCurrency,\n  }: {\n    tokenAddresses: Hex[];\n    nativeCurrency: string;\n  }): Promise<ContractExchangeRates> {\n    const [\n      contractExchangeRates,\n      fallbackCurrencyToNativeCurrencyConversionRate,\n    ] = await Promise.all([\n      this.#fetchAndMapExchangeRatesForSupportedNativeCurrency({\n        tokenAddresses,\n        chainId: this.config.chainId,\n        nativeCurrency: FALL_BACK_VS_CURRENCY,\n      }),\n      getCurrencyConversionRate({\n        from: FALL_BACK_VS_CURRENCY,\n        to: nativeCurrency,\n      }),\n    ]);\n\n    if (fallbackCurrencyToNativeCurrencyConversionRate === null) {\n      return {};\n    }\n\n    return Object.entries(contractExchangeRates).reduce(\n      (obj, [tokenAddress, tokenValue]) => {\n        return {\n          ...obj,\n          [tokenAddress]: tokenValue\n            ? tokenValue * fallbackCurrencyToNativeCurrencyConversionRate\n            : undefined,\n        };\n      },\n      {},\n    );\n  }\n}\n\nexport default TokenRatesController;\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-RELRWIJN.js b/node_modules/@metamask/assets-controllers/dist/chunk-RELRWIJN.js
new file mode 100644
index 0000000..f53a80e
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-RELRWIJN.js
@@ -0,0 +1,268 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }// src/assetsUtil.ts
+
+
+
+var _controllerutils = require('@metamask/controller-utils');
+var _utils = require('@metamask/utils');
+var _bnjs = require('bn.js'); var _bnjs2 = _interopRequireDefault(_bnjs);
+var _cid = require('multiformats/cid');
+var TOKEN_PRICES_BATCH_SIZE = 30;
+function compareNftMetadata(newNftMetadata, nft) {
+  const keys = [
+    "image",
+    "backgroundColor",
+    "imagePreview",
+    "imageThumbnail",
+    "imageOriginal",
+    "animation",
+    "animationOriginal",
+    "externalLink",
+    "tokenURI"
+  ];
+  const differentValues = keys.reduce((value, key) => {
+    if (newNftMetadata[key] && newNftMetadata[key] !== nft[key]) {
+      return value + 1;
+    }
+    return value;
+  }, 0);
+  return differentValues > 0;
+}
+var aggregatorNameByKey = {
+  aave: "Aave",
+  bancor: "Bancor",
+  cmc: "CMC",
+  cryptocom: "Crypto.com",
+  coinGecko: "CoinGecko",
+  oneInch: "1inch",
+  paraswap: "Paraswap",
+  pmm: "PMM",
+  zapper: "Zapper",
+  zerion: "Zerion",
+  zeroEx: "0x",
+  synthetix: "Synthetix",
+  yearn: "Yearn",
+  apeswap: "ApeSwap",
+  binanceDex: "BinanceDex",
+  pancakeTop100: "PancakeTop100",
+  pancakeExtended: "PancakeExtended",
+  balancer: "Balancer",
+  quickswap: "QuickSwap",
+  matcha: "Matcha",
+  pangolinDex: "PangolinDex",
+  pangolinDexStableCoin: "PangolinDexStableCoin",
+  pangolinDexAvaxBridge: "PangolinDexAvaxBridge",
+  traderJoe: "TraderJoe",
+  airswapLight: "AirswapLight",
+  kleros: "Kleros"
+};
+var formatAggregatorNames = (aggregators) => {
+  return aggregators.map(
+    (key) => aggregatorNameByKey[key] || `${key[0].toUpperCase()}${key.substring(1, key.length)}`
+  );
+};
+var formatIconUrlWithProxy = ({
+  chainId,
+  tokenAddress
+}) => {
+  const chainIdDecimal = _controllerutils.convertHexToDecimal.call(void 0, chainId).toString();
+  return `https://static.metafi.codefi.network/api/v1/tokenIcons/${chainIdDecimal}/${tokenAddress.toLowerCase()}.png`;
+};
+var SupportedTokenDetectionNetworks = /* @__PURE__ */ ((SupportedTokenDetectionNetworks2) => {
+  SupportedTokenDetectionNetworks2["mainnet"] = "0x1";
+  SupportedTokenDetectionNetworks2["bsc"] = "0x38";
+  SupportedTokenDetectionNetworks2["polygon"] = "0x89";
+  SupportedTokenDetectionNetworks2["avax"] = "0xa86a";
+  SupportedTokenDetectionNetworks2["aurora"] = "0x4e454152";
+  SupportedTokenDetectionNetworks2["linea_goerli"] = "0xe704";
+  SupportedTokenDetectionNetworks2["linea_mainnet"] = "0xe708";
+  SupportedTokenDetectionNetworks2["arbitrum"] = "0xa4b1";
+  SupportedTokenDetectionNetworks2["optimism"] = "0xa";
+  SupportedTokenDetectionNetworks2["base"] = "0x2105";
+  SupportedTokenDetectionNetworks2["zksync"] = "0x144";
+  return SupportedTokenDetectionNetworks2;
+})(SupportedTokenDetectionNetworks || {});
+function isTokenDetectionSupportedForNetwork(chainId) {
+  return Object.values(SupportedTokenDetectionNetworks).includes(chainId);
+}
+function isTokenListSupportedForNetwork(chainId) {
+  return isTokenDetectionSupportedForNetwork(chainId);
+}
+function removeIpfsProtocolPrefix(ipfsUrl) {
+  if (ipfsUrl.startsWith("ipfs://ipfs/")) {
+    return ipfsUrl.replace("ipfs://ipfs/", "");
+  } else if (ipfsUrl.startsWith("ipfs://")) {
+    return ipfsUrl.replace("ipfs://", "");
+  }
+  throw new Error("this method should not be used with non ipfs urls");
+}
+function getIpfsCIDv1AndPath(ipfsUrl) {
+  const url = removeIpfsProtocolPrefix(ipfsUrl);
+  const index = url.indexOf("/");
+  const cid = index !== -1 ? url.substring(0, index) : url;
+  const path = index !== -1 ? url.substring(index) : void 0;
+  return {
+    cid: _cid.CID.parse(cid).toV1().toString(),
+    path
+  };
+}
+function getFormattedIpfsUrl(ipfsGateway, ipfsUrl, subdomainSupported) {
+  const { host, protocol, origin } = new URL(addUrlProtocolPrefix(ipfsGateway));
+  if (subdomainSupported) {
+    const { cid, path } = getIpfsCIDv1AndPath(ipfsUrl);
+    return `${protocol}//${cid}.ipfs.${host}${path ?? ""}`;
+  }
+  const cidAndPath = removeIpfsProtocolPrefix(ipfsUrl);
+  return `${origin}/ipfs/${cidAndPath}`;
+}
+function addUrlProtocolPrefix(urlString) {
+  if (!urlString.match(/(^http:\/\/)|(^https:\/\/)/u)) {
+    return `https://${urlString}`;
+  }
+  return urlString;
+}
+function ethersBigNumberToBN(bigNumber) {
+  return new (0, _bnjs2.default)(_utils.remove0x.call(void 0, bigNumber.toHexString()), "hex");
+}
+function divideIntoBatches(values, { batchSize }) {
+  const batches = [];
+  for (let i = 0; i < values.length; i += batchSize) {
+    batches.push(values.slice(i, i + batchSize));
+  }
+  return batches;
+}
+async function reduceInBatchesSerially({
+  values,
+  batchSize,
+  eachBatch,
+  initialResult
+}) {
+  const batches = divideIntoBatches(values, { batchSize });
+  let workingResult = initialResult;
+  for (const [index, batch] of batches.entries()) {
+    workingResult = await eachBatch(workingResult, batch, index);
+  }
+  const finalResult = workingResult;
+  return finalResult;
+}
+function mapOpenSeaNftV2ToV1(nft) {
+  return {
+    token_id: nft.identifier,
+    num_sales: null,
+    background_color: null,
+    image_url: nft.image_url ?? null,
+    image_preview_url: null,
+    image_thumbnail_url: null,
+    image_original_url: null,
+    animation_url: null,
+    animation_original_url: null,
+    name: nft.name,
+    description: nft.description,
+    external_link: null,
+    asset_contract: {
+      address: nft.contract,
+      asset_contract_type: null,
+      created_date: null,
+      schema_name: nft.token_standard.toUpperCase(),
+      symbol: null,
+      total_supply: null,
+      description: nft.description,
+      external_link: null,
+      collection: {
+        name: nft.collection,
+        image_url: null
+      }
+    },
+    creator: {
+      user: { username: "" },
+      profile_img_url: "",
+      address: ""
+    },
+    last_sale: null
+  };
+}
+function mapOpenSeaDetailedNftV2ToV1(nft) {
+  const mapped = mapOpenSeaNftV2ToV1(nft);
+  return {
+    ...mapped,
+    animation_url: nft.animation_url ?? null,
+    creator: {
+      ...mapped.creator,
+      address: nft.creator
+    }
+  };
+}
+function mapOpenSeaContractV2ToV1(contract, collection) {
+  return {
+    address: contract.address,
+    asset_contract_type: null,
+    created_date: null,
+    schema_name: contract.contract_standard.toUpperCase(),
+    symbol: null,
+    total_supply: collection?.total_supply?.toString() ?? contract.total_supply?.toString() ?? null,
+    description: collection?.description ?? null,
+    external_link: collection?.project_url ?? null,
+    collection: {
+      name: collection?.name ?? contract.name,
+      image_url: collection?.image_url
+    }
+  };
+}
+async function fetchTokenContractExchangeRates({
+  tokenPricesService,
+  nativeCurrency,
+  tokenAddresses,
+  chainId
+}) {
+  const isChainIdSupported = tokenPricesService.validateChainIdSupported(chainId);
+  const isCurrencySupported = tokenPricesService.validateCurrencySupported(nativeCurrency);
+  if (!isChainIdSupported || !isCurrencySupported) {
+    return {};
+  }
+  const tokenPricesByTokenAddress = await reduceInBatchesSerially({
+    values: [...tokenAddresses].sort(),
+    batchSize: TOKEN_PRICES_BATCH_SIZE,
+    eachBatch: async (allTokenPricesByTokenAddress, batch) => {
+      const tokenPricesByTokenAddressForBatch = await tokenPricesService.fetchTokenPrices({
+        tokenAddresses: batch,
+        chainId,
+        currency: nativeCurrency
+      });
+      return {
+        ...allTokenPricesByTokenAddress,
+        ...tokenPricesByTokenAddressForBatch
+      };
+    },
+    initialResult: {}
+  });
+  return Object.entries(tokenPricesByTokenAddress).reduce(
+    (obj, [tokenAddress, tokenPrice]) => {
+      return {
+        ...obj,
+        [_controllerutils.toChecksumHexAddress.call(void 0, tokenAddress)]: tokenPrice?.value
+      };
+    },
+    {}
+  );
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+exports.TOKEN_PRICES_BATCH_SIZE = TOKEN_PRICES_BATCH_SIZE; exports.compareNftMetadata = compareNftMetadata; exports.formatAggregatorNames = formatAggregatorNames; exports.formatIconUrlWithProxy = formatIconUrlWithProxy; exports.SupportedTokenDetectionNetworks = SupportedTokenDetectionNetworks; exports.isTokenDetectionSupportedForNetwork = isTokenDetectionSupportedForNetwork; exports.isTokenListSupportedForNetwork = isTokenListSupportedForNetwork; exports.removeIpfsProtocolPrefix = removeIpfsProtocolPrefix; exports.getIpfsCIDv1AndPath = getIpfsCIDv1AndPath; exports.getFormattedIpfsUrl = getFormattedIpfsUrl; exports.addUrlProtocolPrefix = addUrlProtocolPrefix; exports.ethersBigNumberToBN = ethersBigNumberToBN; exports.divideIntoBatches = divideIntoBatches; exports.reduceInBatchesSerially = reduceInBatchesSerially; exports.mapOpenSeaNftV2ToV1 = mapOpenSeaNftV2ToV1; exports.mapOpenSeaDetailedNftV2ToV1 = mapOpenSeaDetailedNftV2ToV1; exports.mapOpenSeaContractV2ToV1 = mapOpenSeaContractV2ToV1; exports.fetchTokenContractExchangeRates = fetchTokenContractExchangeRates;
+//# sourceMappingURL=chunk-RELRWIJN.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-RELRWIJN.js.map b/node_modules/@metamask/assets-controllers/dist/chunk-RELRWIJN.js.map
new file mode 100644
index 0000000..821935a
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-RELRWIJN.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/assetsUtil.ts"],"names":["SupportedTokenDetectionNetworks"],"mappings":"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","sourcesContent":["import type { BigNumber } from '@ethersproject/bignumber';\nimport {\n  convertHexToDecimal,\n  toChecksumHexAddress,\n} from '@metamask/controller-utils';\nimport type { Hex } from '@metamask/utils';\nimport { remove0x } from '@metamask/utils';\nimport BN from 'bn.js';\nimport { CID } from 'multiformats/cid';\n\nimport type {\n  Nft,\n  NftMetadata,\n  OpenSeaV2Collection,\n  OpenSeaV2Contract,\n  OpenSeaV2DetailedNft,\n  OpenSeaV2Nft,\n} from './NftController';\nimport type { ApiNft, ApiNftContract } from './NftDetectionController';\nimport type { AbstractTokenPricesService } from './token-prices-service';\nimport { type ContractExchangeRates } from './TokenRatesController';\n\n/**\n * The maximum number of token addresses that should be sent to the Price API in\n * a single request.\n */\nexport const TOKEN_PRICES_BATCH_SIZE = 30;\n\n/**\n * Compares nft metadata entries to any nft entry.\n * We need this method when comparing a new fetched nft metadata, in case a entry changed to a defined value,\n * there's a need to update the nft in state.\n *\n * @param newNftMetadata - Nft metadata object.\n * @param nft - Nft object to compare with.\n * @returns Whether there are differences.\n */\nexport function compareNftMetadata(newNftMetadata: NftMetadata, nft: Nft) {\n  const keys: (keyof NftMetadata)[] = [\n    'image',\n    'backgroundColor',\n    'imagePreview',\n    'imageThumbnail',\n    'imageOriginal',\n    'animation',\n    'animationOriginal',\n    'externalLink',\n    'tokenURI',\n  ];\n  const differentValues = keys.reduce((value, key) => {\n    if (newNftMetadata[key] && newNftMetadata[key] !== nft[key]) {\n      return value + 1;\n    }\n    return value;\n  }, 0);\n  return differentValues > 0;\n}\n\nconst aggregatorNameByKey: Record<string, string> = {\n  aave: 'Aave',\n  bancor: 'Bancor',\n  cmc: 'CMC',\n  cryptocom: 'Crypto.com',\n  coinGecko: 'CoinGecko',\n  oneInch: '1inch',\n  paraswap: 'Paraswap',\n  pmm: 'PMM',\n  zapper: 'Zapper',\n  zerion: 'Zerion',\n  zeroEx: '0x',\n  synthetix: 'Synthetix',\n  yearn: 'Yearn',\n  apeswap: 'ApeSwap',\n  binanceDex: 'BinanceDex',\n  pancakeTop100: 'PancakeTop100',\n  pancakeExtended: 'PancakeExtended',\n  balancer: 'Balancer',\n  quickswap: 'QuickSwap',\n  matcha: 'Matcha',\n  pangolinDex: 'PangolinDex',\n  pangolinDexStableCoin: 'PangolinDexStableCoin',\n  pangolinDexAvaxBridge: 'PangolinDexAvaxBridge',\n  traderJoe: 'TraderJoe',\n  airswapLight: 'AirswapLight',\n  kleros: 'Kleros',\n};\n\n/**\n * Formats aggregator names to presentable format.\n *\n * @param aggregators - List of token list names in camelcase.\n * @returns Formatted aggregator names.\n */\nexport const formatAggregatorNames = (aggregators: string[]) => {\n  return aggregators.map(\n    (key) =>\n      aggregatorNameByKey[key] ||\n      `${key[0].toUpperCase()}${key.substring(1, key.length)}`,\n  );\n};\n\n/**\n * Format token list assets to use image proxy from Codefi.\n *\n * @param params - Object that contains chainID and tokenAddress.\n * @param params.chainId - ChainID of network in 0x-prefixed hexadecimal format.\n * @param params.tokenAddress - Address of token in mixed or lowercase.\n * @returns Formatted image url\n */\nexport const formatIconUrlWithProxy = ({\n  chainId,\n  tokenAddress,\n}: {\n  chainId: Hex;\n  tokenAddress: string;\n}) => {\n  const chainIdDecimal = convertHexToDecimal(chainId).toString();\n  return `https://static.metafi.codefi.network/api/v1/tokenIcons/${chainIdDecimal}/${tokenAddress.toLowerCase()}.png`;\n};\n\n/**\n * Networks where token detection is supported - Values are in decimal format\n */\nexport enum SupportedTokenDetectionNetworks {\n  mainnet = '0x1', // decimal: 1\n  bsc = '0x38', // decimal: 56\n  polygon = '0x89', // decimal: 137\n  avax = '0xa86a', // decimal: 43114\n  aurora = '0x4e454152', // decimal: 1313161554\n  linea_goerli = '0xe704', // decimal: 59140\n  linea_mainnet = '0xe708', // decimal: 59144\n  arbitrum = '0xa4b1', // decimal: 42161\n  optimism = '0xa', // decimal: 10\n  base = '0x2105', // decimal: 8453\n  zksync = '0x144', // decimal: 324\n}\n\n/**\n * Check if token detection is enabled for certain networks.\n *\n * @param chainId - ChainID of network\n * @returns Whether the current network supports token detection\n */\nexport function isTokenDetectionSupportedForNetwork(chainId: Hex): boolean {\n  return Object.values<Hex>(SupportedTokenDetectionNetworks).includes(chainId);\n}\n\n/**\n * Check if token list polling is enabled for a given network.\n * Currently this method is used to support e2e testing for consumers of this package.\n *\n * @param chainId - ChainID of network\n * @returns Whether the current network supports tokenlists\n */\nexport function isTokenListSupportedForNetwork(chainId: Hex): boolean {\n  return isTokenDetectionSupportedForNetwork(chainId);\n}\n\n/**\n * Removes IPFS protocol prefix from input string.\n *\n * @param ipfsUrl - An IPFS url (e.g. ipfs://{content id})\n * @returns IPFS content identifier and (possibly) path in a string\n * @throws Will throw if the url passed is not IPFS.\n */\nexport function removeIpfsProtocolPrefix(ipfsUrl: string) {\n  if (ipfsUrl.startsWith('ipfs://ipfs/')) {\n    return ipfsUrl.replace('ipfs://ipfs/', '');\n  } else if (ipfsUrl.startsWith('ipfs://')) {\n    return ipfsUrl.replace('ipfs://', '');\n  }\n  // this method should not be used with non-ipfs urls (i.e. startsWith('ipfs://') === true)\n  throw new Error('this method should not be used with non ipfs urls');\n}\n\n/**\n * Extracts content identifier and path from an input string.\n *\n * @param ipfsUrl - An IPFS URL minus the IPFS protocol prefix\n * @returns IFPS content identifier (cid) and sub path as string.\n * @throws Will throw if the url passed is not ipfs.\n */\nexport function getIpfsCIDv1AndPath(ipfsUrl: string): {\n  cid: string;\n  path?: string;\n} {\n  const url = removeIpfsProtocolPrefix(ipfsUrl);\n\n  // check if there is a path\n  // (CID is everything preceding first forward slash, path is everything after)\n  const index = url.indexOf('/');\n  const cid = index !== -1 ? url.substring(0, index) : url;\n  const path = index !== -1 ? url.substring(index) : undefined;\n\n  // We want to ensure that the CID is v1 (https://docs.ipfs.io/concepts/content-addressing/#identifier-formats)\n  // because most cid v0s appear to be incompatible with IPFS subdomains\n  return {\n    cid: CID.parse(cid).toV1().toString(),\n    path,\n  };\n}\n\n/**\n * Formats URL correctly for use retrieving assets hosted on IPFS.\n *\n * @param ipfsGateway - The users preferred IPFS gateway (full URL or just host).\n * @param ipfsUrl - The IFPS URL pointed at the asset.\n * @param subdomainSupported - Boolean indicating whether the URL should be formatted with subdomains or not.\n * @returns A formatted URL, with the user's preferred IPFS gateway and format (subdomain or not), pointing to an asset hosted on IPFS.\n */\nexport function getFormattedIpfsUrl(\n  ipfsGateway: string,\n  ipfsUrl: string,\n  subdomainSupported: boolean,\n): string {\n  const { host, protocol, origin } = new URL(addUrlProtocolPrefix(ipfsGateway));\n  if (subdomainSupported) {\n    const { cid, path } = getIpfsCIDv1AndPath(ipfsUrl);\n    return `${protocol}//${cid}.ipfs.${host}${path ?? ''}`;\n  }\n  const cidAndPath = removeIpfsProtocolPrefix(ipfsUrl);\n  return `${origin}/ipfs/${cidAndPath}`;\n}\n\n/**\n * Adds URL protocol prefix to input URL string if missing.\n *\n * @param urlString - An IPFS URL.\n * @returns A URL with a https:// prepended.\n */\nexport function addUrlProtocolPrefix(urlString: string): string {\n  if (!urlString.match(/(^http:\\/\\/)|(^https:\\/\\/)/u)) {\n    return `https://${urlString}`;\n  }\n  return urlString;\n}\n\n/**\n * Converts an Ethers BigNumber to a BN.\n *\n * @param bigNumber - An Ethers BigNumber instance.\n * @returns A BN object.\n */\nexport function ethersBigNumberToBN(bigNumber: BigNumber): BN {\n  return new BN(remove0x(bigNumber.toHexString()), 'hex');\n}\n\n/**\n * Partitions a list of values into groups that are at most `batchSize` in\n * length.\n *\n * @param values - The list of values.\n * @param args - The remaining arguments.\n * @param args.batchSize - The desired maximum number of values per batch.\n * @returns The list of batches.\n */\nexport function divideIntoBatches<Value>(\n  values: Value[],\n  { batchSize }: { batchSize: number },\n): Value[][] {\n  const batches = [];\n  for (let i = 0; i < values.length; i += batchSize) {\n    batches.push(values.slice(i, i + batchSize));\n  }\n  return batches;\n}\n\n/**\n * Constructs an object from processing batches of the given values\n * sequentially.\n *\n * @param args - The arguments to this function.\n * @param args.values - A list of values to iterate over.\n * @param args.batchSize - The maximum number of values in each batch.\n * @param args.eachBatch - A function to call for each batch. This function is\n * similar to the function that `Array.prototype.reduce` takes, in that it\n * receives the object that is being built, each batch in the list of batches\n * and the index, and should return an updated version of the object.\n * @param args.initialResult - The initial value of the final data structure,\n * i.e., the value that will be fed into the first call of `eachBatch`.\n * @returns The built object.\n */\nexport async function reduceInBatchesSerially<\n  Value,\n  Result extends Record<PropertyKey, unknown>,\n>({\n  values,\n  batchSize,\n  eachBatch,\n  initialResult,\n}: {\n  values: Value[];\n  batchSize: number;\n  eachBatch: (\n    workingResult: Partial<Result>,\n    batch: Value[],\n    index: number,\n  ) => Partial<Result> | Promise<Partial<Result>>;\n  initialResult: Partial<Result>;\n}): Promise<Result> {\n  const batches = divideIntoBatches(values, { batchSize });\n  let workingResult = initialResult;\n  for (const [index, batch] of batches.entries()) {\n    workingResult = await eachBatch(workingResult, batch, index);\n  }\n  // There's no way around this  we have to assume that in the end, the result\n  // matches the intended type.\n  const finalResult = workingResult as Result;\n  return finalResult;\n}\n\n/**\n * Maps an OpenSea V2 NFT to the V1 schema.\n * @param nft - The V2 NFT to map.\n * @returns The NFT in the V1 schema.\n */\nexport function mapOpenSeaNftV2ToV1(nft: OpenSeaV2Nft): ApiNft {\n  return {\n    token_id: nft.identifier,\n    num_sales: null,\n    background_color: null,\n    image_url: nft.image_url ?? null,\n    image_preview_url: null,\n    image_thumbnail_url: null,\n    image_original_url: null,\n    animation_url: null,\n    animation_original_url: null,\n    name: nft.name,\n    description: nft.description,\n    external_link: null,\n    asset_contract: {\n      address: nft.contract,\n      asset_contract_type: null,\n      created_date: null,\n      schema_name: nft.token_standard.toUpperCase(),\n      symbol: null,\n      total_supply: null,\n      description: nft.description,\n      external_link: null,\n      collection: {\n        name: nft.collection,\n        image_url: null,\n      },\n    },\n    creator: {\n      user: { username: '' },\n      profile_img_url: '',\n      address: '',\n    },\n    last_sale: null,\n  };\n}\n\n/**\n * Maps an OpenSea V2 detailed NFT to the V1 schema.\n * @param nft - The V2 detailed NFT to map.\n * @returns The NFT in the V1 schema.\n */\nexport function mapOpenSeaDetailedNftV2ToV1(nft: OpenSeaV2DetailedNft): ApiNft {\n  const mapped = mapOpenSeaNftV2ToV1(nft);\n  return {\n    ...mapped,\n    animation_url: nft.animation_url ?? null,\n    creator: {\n      ...mapped.creator,\n      address: nft.creator,\n    },\n  };\n}\n\n/**\n * Maps an OpenSea V2 contract to the V1 schema.\n * @param contract - The v2 contract data.\n * @param collection - The v2 collection data.\n * @returns The contract in the v1 schema.\n */\nexport function mapOpenSeaContractV2ToV1(\n  contract: OpenSeaV2Contract,\n  collection?: OpenSeaV2Collection,\n): ApiNftContract {\n  return {\n    address: contract.address,\n    asset_contract_type: null,\n    created_date: null,\n    schema_name: contract.contract_standard.toUpperCase(),\n    symbol: null,\n    total_supply:\n      collection?.total_supply?.toString() ??\n      contract.total_supply?.toString() ??\n      null,\n    description: collection?.description ?? null,\n    external_link: collection?.project_url ?? null,\n    collection: {\n      name: collection?.name ?? contract.name,\n      image_url: collection?.image_url,\n    },\n  };\n}\n\n/**\n * Retrieves token prices for a set of contract addresses in a specific currency and chainId.\n *\n * @param args - The arguments to function.\n * @param args.tokenPricesService - An object in charge of retrieving token prices.\n * @param args.nativeCurrency - The native currency to request price in.\n * @param args.tokenAddresses - The list of contract addresses.\n * @param args.chainId - The chainId of the tokens.\n * @returns The prices for the requested tokens.\n */\nexport async function fetchTokenContractExchangeRates({\n  tokenPricesService,\n  nativeCurrency,\n  tokenAddresses,\n  chainId,\n}: {\n  tokenPricesService: AbstractTokenPricesService;\n  nativeCurrency: string;\n  tokenAddresses: Hex[];\n  chainId: Hex;\n}): Promise<ContractExchangeRates> {\n  const isChainIdSupported =\n    tokenPricesService.validateChainIdSupported(chainId);\n  const isCurrencySupported =\n    tokenPricesService.validateCurrencySupported(nativeCurrency);\n\n  if (!isChainIdSupported || !isCurrencySupported) {\n    return {};\n  }\n\n  const tokenPricesByTokenAddress = await reduceInBatchesSerially<\n    Hex,\n    Awaited<ReturnType<AbstractTokenPricesService['fetchTokenPrices']>>\n  >({\n    values: [...tokenAddresses].sort(),\n    batchSize: TOKEN_PRICES_BATCH_SIZE,\n    eachBatch: async (allTokenPricesByTokenAddress, batch) => {\n      const tokenPricesByTokenAddressForBatch =\n        await tokenPricesService.fetchTokenPrices({\n          tokenAddresses: batch,\n          chainId,\n          currency: nativeCurrency,\n        });\n\n      return {\n        ...allTokenPricesByTokenAddress,\n        ...tokenPricesByTokenAddressForBatch,\n      };\n    },\n    initialResult: {},\n  });\n\n  return Object.entries(tokenPricesByTokenAddress).reduce(\n    (obj, [tokenAddress, tokenPrice]) => {\n      return {\n        ...obj,\n        [toChecksumHexAddress(tokenAddress)]: tokenPrice?.value,\n      };\n    },\n    {},\n  );\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-RGHTNZQ6.js b/node_modules/@metamask/assets-controllers/dist/chunk-RGHTNZQ6.js
new file mode 100644
index 0000000..e10351d
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-RGHTNZQ6.js
@@ -0,0 +1,12 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});// src/constants.ts
+var Source = /* @__PURE__ */ ((Source2) => {
+  Source2["Custom"] = "custom";
+  Source2["Dapp"] = "dapp";
+  Source2["Detected"] = "detected";
+  return Source2;
+})(Source || {});
+
+
+
+exports.Source = Source;
+//# sourceMappingURL=chunk-RGHTNZQ6.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-RGHTNZQ6.js.map b/node_modules/@metamask/assets-controllers/dist/chunk-RGHTNZQ6.js.map
new file mode 100644
index 0000000..bf37073
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-RGHTNZQ6.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/constants.ts"],"names":["Source"],"mappings":";AAAO,IAAK,SAAL,kBAAKA,YAAL;AACL,EAAAA,QAAA,YAAS;AACT,EAAAA,QAAA,UAAO;AACP,EAAAA,QAAA,cAAW;AAHD,SAAAA;AAAA,GAAA","sourcesContent":["export enum Source {\n  Custom = 'custom',\n  Dapp = 'dapp',\n  Detected = 'detected',\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-TCO22VIO.mjs b/node_modules/@metamask/assets-controllers/dist/chunk-TCO22VIO.mjs
new file mode 100644
index 0000000..52178c3
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-TCO22VIO.mjs
@@ -0,0 +1,32 @@
+// src/crypto-compare.ts
+import { handleFetch } from "@metamask/controller-utils";
+function getPricingURL(currentCurrency, nativeCurrency, includeUSDRate) {
+  return `https://min-api.cryptocompare.com/data/price?fsym=${nativeCurrency.toUpperCase()}&tsyms=${currentCurrency.toUpperCase()}${includeUSDRate && currentCurrency.toUpperCase() !== "USD" ? ",USD" : ""}`;
+}
+async function fetchExchangeRate(currency, nativeCurrency, includeUSDRate) {
+  const json = await handleFetch(
+    getPricingURL(currency, nativeCurrency, includeUSDRate)
+  );
+  if (json.Response === "Error") {
+    throw new Error(json.Message);
+  }
+  const conversionRate = Number(json[currency.toUpperCase()]);
+  const usdConversionRate = Number(json.USD);
+  if (!Number.isFinite(conversionRate)) {
+    throw new Error(
+      `Invalid response for ${currency.toUpperCase()}: ${json[currency.toUpperCase()]}`
+    );
+  }
+  if (includeUSDRate && !Number.isFinite(usdConversionRate)) {
+    throw new Error(`Invalid response for usdConversionRate: ${json.USD}`);
+  }
+  return {
+    conversionRate,
+    usdConversionRate
+  };
+}
+
+export {
+  fetchExchangeRate
+};
+//# sourceMappingURL=chunk-TCO22VIO.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-TCO22VIO.mjs.map b/node_modules/@metamask/assets-controllers/dist/chunk-TCO22VIO.mjs.map
new file mode 100644
index 0000000..84c8325
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-TCO22VIO.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/crypto-compare.ts"],"sourcesContent":["import { handleFetch } from '@metamask/controller-utils';\n\n/**\n * Get the CryptoCompare API URL for getting the conversion rate from the given native currency to\n * the given currency. Optionally, the conversion rate from the native currency to USD can also be\n * included in the response.\n *\n * @param currentCurrency - The currency to get a conversion rate for.\n * @param nativeCurrency - The native currency to convert from.\n * @param includeUSDRate - Whether or not the native currency to USD conversion rate should be\n * included in the response as well.\n * @returns The API URL for getting the conversion rate.\n */\nfunction getPricingURL(\n  currentCurrency: string,\n  nativeCurrency: string,\n  includeUSDRate?: boolean,\n) {\n  return (\n    `https://min-api.cryptocompare.com/data/price?fsym=` +\n    `${nativeCurrency.toUpperCase()}&tsyms=${currentCurrency.toUpperCase()}` +\n    `${includeUSDRate && currentCurrency.toUpperCase() !== 'USD' ? ',USD' : ''}`\n  );\n}\n\n/**\n * Fetches the exchange rate for a given currency.\n *\n * @param currency - ISO 4217 currency code.\n * @param nativeCurrency - Symbol for base asset.\n * @param includeUSDRate - Whether to add the USD rate to the fetch.\n * @returns Promise resolving to exchange rate for given currency.\n */\nexport async function fetchExchangeRate(\n  currency: string,\n  nativeCurrency: string,\n  includeUSDRate?: boolean,\n): Promise<{\n  conversionRate: number;\n  usdConversionRate: number;\n}> {\n  const json = await handleFetch(\n    getPricingURL(currency, nativeCurrency, includeUSDRate),\n  );\n\n  /*\n  Example expected error response (if pair is not found)\n  {\n    Response: \"Error\",\n    Message: \"cccagg_or_exchange market does not exist for this coin pair (ETH-<NON_EXISTENT_TOKEN>)\",\n    HasWarning: false,\n  }\n  */\n  if (json.Response === 'Error') {\n    throw new Error(json.Message);\n  }\n\n  const conversionRate = Number(json[currency.toUpperCase()]);\n\n  const usdConversionRate = Number(json.USD);\n  if (!Number.isFinite(conversionRate)) {\n    throw new Error(\n      `Invalid response for ${currency.toUpperCase()}: ${\n        json[currency.toUpperCase()]\n      }`,\n    );\n  }\n\n  if (includeUSDRate && !Number.isFinite(usdConversionRate)) {\n    throw new Error(`Invalid response for usdConversionRate: ${json.USD}`);\n  }\n\n  return {\n    conversionRate,\n    usdConversionRate,\n  };\n}\n"],"mappings":";AAAA,SAAS,mBAAmB;AAa5B,SAAS,cACP,iBACA,gBACA,gBACA;AACA,SACE,qDACG,eAAe,YAAY,CAAC,UAAU,gBAAgB,YAAY,CAAC,GACnE,kBAAkB,gBAAgB,YAAY,MAAM,QAAQ,SAAS,EAAE;AAE9E;AAUA,eAAsB,kBACpB,UACA,gBACA,gBAIC;AACD,QAAM,OAAO,MAAM;AAAA,IACjB,cAAc,UAAU,gBAAgB,cAAc;AAAA,EACxD;AAUA,MAAI,KAAK,aAAa,SAAS;AAC7B,UAAM,IAAI,MAAM,KAAK,OAAO;AAAA,EAC9B;AAEA,QAAM,iBAAiB,OAAO,KAAK,SAAS,YAAY,CAAC,CAAC;AAE1D,QAAM,oBAAoB,OAAO,KAAK,GAAG;AACzC,MAAI,CAAC,OAAO,SAAS,cAAc,GAAG;AACpC,UAAM,IAAI;AAAA,MACR,wBAAwB,SAAS,YAAY,CAAC,KAC5C,KAAK,SAAS,YAAY,CAAC,CAC7B;AAAA,IACF;AAAA,EACF;AAEA,MAAI,kBAAkB,CAAC,OAAO,SAAS,iBAAiB,GAAG;AACzD,UAAM,IAAI,MAAM,2CAA2C,KAAK,GAAG,EAAE;AAAA,EACvE;AAEA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,EACF;AACF;","names":[]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-V4ZO3F2S.js b/node_modules/@metamask/assets-controllers/dist/chunk-V4ZO3F2S.js
new file mode 100644
index 0000000..0430e5c
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-V4ZO3F2S.js
@@ -0,0 +1,246 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+
+
+var _chunkZ4BLTVTBjs = require('./chunk-Z4BLTVTB.js');
+
+// src/AccountTrackerController.ts
+var _controllerutils = require('@metamask/controller-utils');
+var _ethquery = require('@metamask/eth-query'); var _ethquery2 = _interopRequireDefault(_ethquery);
+var _pollingcontroller = require('@metamask/polling-controller');
+var _utils = require('@metamask/utils');
+var _asyncmutex = require('async-mutex');
+var _lodash = require('lodash');
+var _getCorrectNetworkClient, getCorrectNetworkClient_fn;
+var AccountTrackerController = class extends _pollingcontroller.StaticIntervalPollingControllerV1 {
+  /**
+   * Creates an AccountTracker instance.
+   *
+   * @param options - The controller options.
+   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.
+   * @param options.getIdentities - Gets the identities from the Preferences store.
+   * @param options.getSelectedAddress - Gets the selected address from the Preferences store.
+   * @param options.getMultiAccountBalancesEnabled - Gets the multi account balances enabled flag from the Preferences store.
+   * @param options.getCurrentChainId - Gets the chain ID for the current network from the Network store.
+   * @param options.getNetworkClientById - Gets the network client with the given id from the NetworkController.
+   * @param config - Initial options used to configure this controller.
+   * @param state - Initial state to set on this controller.
+   */
+  constructor({
+    onPreferencesStateChange,
+    getIdentities,
+    getSelectedAddress,
+    getMultiAccountBalancesEnabled,
+    getCurrentChainId,
+    getNetworkClientById
+  }, config, state) {
+    super(config, state);
+    /**
+     * Resolves a networkClientId to a network client config
+     * or globally selected network config if not provided
+     *
+     * @param networkClientId - Optional networkClientId to fetch a network client with
+     * @returns network client config
+     */
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getCorrectNetworkClient);
+    this.refreshMutex = new (0, _asyncmutex.Mutex)();
+    /**
+     * Name of this controller used during composition
+     */
+    this.name = "AccountTrackerController";
+    /**
+     * Refreshes the balances of the accounts depending on the multi-account setting.
+     * If multi-account is disabled, only updates the selected account balance.
+     * If multi-account is enabled, updates balances for all accounts.
+     *
+     * @param networkClientId - Optional networkClientId to fetch a network client with
+     */
+    this.refresh = async (networkClientId) => {
+      const releaseLock = await this.refreshMutex.acquire();
+      try {
+        const { chainId, ethQuery } = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getCorrectNetworkClient, getCorrectNetworkClient_fn).call(this, networkClientId);
+        this.syncAccounts(chainId);
+        const { accounts, accountsByChainId } = this.state;
+        const isMultiAccountBalancesEnabled = this.getMultiAccountBalancesEnabled();
+        const accountsToUpdate = isMultiAccountBalancesEnabled ? Object.keys(accounts) : [this.getSelectedAddress()];
+        const accountsForChain = { ...accountsByChainId[chainId] };
+        for (const address of accountsToUpdate) {
+          const balance = await this.getBalanceFromChain(address, ethQuery);
+          if (balance) {
+            accountsForChain[address] = {
+              balance
+            };
+          }
+        }
+        this.update({
+          ...chainId === this.getCurrentChainId() && {
+            accounts: accountsForChain
+          },
+          accountsByChainId: {
+            ...this.state.accountsByChainId,
+            [chainId]: accountsForChain
+          }
+        });
+      } catch (err) {
+        releaseLock();
+        throw err;
+      }
+    };
+    this.defaultConfig = {
+      interval: 1e4
+    };
+    this.defaultState = {
+      accounts: {},
+      accountsByChainId: {
+        [getCurrentChainId()]: {}
+      }
+    };
+    this.initialize();
+    this.setIntervalLength(this.config.interval);
+    this.getIdentities = getIdentities;
+    this.getSelectedAddress = getSelectedAddress;
+    this.getMultiAccountBalancesEnabled = getMultiAccountBalancesEnabled;
+    this.getCurrentChainId = getCurrentChainId;
+    this.getNetworkClientById = getNetworkClientById;
+    onPreferencesStateChange(() => {
+      this.refresh();
+    });
+    this.poll();
+  }
+  syncAccounts(newChainId) {
+    const accounts = { ...this.state.accounts };
+    const accountsByChainId = _lodash.cloneDeep.call(void 0, this.state.accountsByChainId);
+    const existing = Object.keys(accounts);
+    if (!accountsByChainId[newChainId]) {
+      accountsByChainId[newChainId] = {};
+      existing.forEach((address) => {
+        accountsByChainId[newChainId][address] = { balance: "0x0" };
+      });
+    }
+    const addresses = Object.keys(this.getIdentities());
+    const newAddresses = addresses.filter(
+      (address) => !existing.includes(address)
+    );
+    const oldAddresses = existing.filter(
+      (address) => !addresses.includes(address)
+    );
+    newAddresses.forEach((address) => {
+      accounts[address] = { balance: "0x0" };
+    });
+    Object.keys(accountsByChainId).forEach((chainId) => {
+      newAddresses.forEach((address) => {
+        accountsByChainId[chainId][address] = {
+          balance: "0x0"
+        };
+      });
+    });
+    oldAddresses.forEach((address) => {
+      delete accounts[address];
+    });
+    Object.keys(accountsByChainId).forEach((chainId) => {
+      oldAddresses.forEach((address) => {
+        delete accountsByChainId[chainId][address];
+      });
+    });
+    this.update({ accounts, accountsByChainId });
+  }
+  /**
+   * Sets a new provider.
+   *
+   * TODO: Replace this wth a method.
+   *
+   * @param provider - Provider used to create a new underlying EthQuery instance.
+   */
+  set provider(provider) {
+    this._provider = provider;
+  }
+  get provider() {
+    throw new Error("Property only used for setting");
+  }
+  /**
+   * Starts a new polling interval.
+   *
+   * @param interval - Polling interval trigger a 'refresh'.
+   */
+  async poll(interval) {
+    interval && this.configure({ interval }, false, false);
+    this.handle && clearTimeout(this.handle);
+    await this.refresh();
+    this.handle = setTimeout(() => {
+      this.poll(this.config.interval);
+    }, this.config.interval);
+  }
+  /**
+   * Refreshes the balances of the accounts using the networkClientId
+   *
+   * @param networkClientId - The network client ID used to get balances.
+   */
+  async _executePoll(networkClientId) {
+    this.refresh(networkClientId);
+  }
+  /**
+   * Fetches the balance of a given address from the blockchain.
+   *
+   * @param address - The account address to fetch the balance for.
+   * @param ethQuery - The EthQuery instance to query getBalnce with.
+   * @returns A promise that resolves to the balance in a hex string format.
+   */
+  async getBalanceFromChain(address, ethQuery) {
+    return await _controllerutils.safelyExecuteWithTimeout.call(void 0, async () => {
+      _utils.assert.call(void 0, ethQuery, "Provider not set.");
+      return await _controllerutils.query.call(void 0, ethQuery, "getBalance", [address]);
+    });
+  }
+  /**
+   * Sync accounts balances with some additional addresses.
+   *
+   * @param addresses - the additional addresses, may be hardware wallet addresses.
+   * @param networkClientId - Optional networkClientId to fetch a network client with.
+   * @returns accounts - addresses with synced balance
+   */
+  async syncBalanceWithAddresses(addresses, networkClientId) {
+    const { ethQuery } = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getCorrectNetworkClient, getCorrectNetworkClient_fn).call(this, networkClientId);
+    return await Promise.all(
+      addresses.map((address) => {
+        return _controllerutils.safelyExecuteWithTimeout.call(void 0, async () => {
+          _utils.assert.call(void 0, ethQuery, "Provider not set.");
+          const balance = await _controllerutils.query.call(void 0, ethQuery, "getBalance", [address]);
+          return [address, balance];
+        });
+      })
+    ).then((value) => {
+      return value.reduce((obj, item) => {
+        if (!item) {
+          return obj;
+        }
+        const [address, balance] = item;
+        return {
+          ...obj,
+          [address]: {
+            balance
+          }
+        };
+      }, {});
+    });
+  }
+};
+_getCorrectNetworkClient = new WeakSet();
+getCorrectNetworkClient_fn = function(networkClientId) {
+  if (networkClientId) {
+    const networkClient = this.getNetworkClientById(networkClientId);
+    return {
+      chainId: networkClient.configuration.chainId,
+      ethQuery: new (0, _ethquery2.default)(networkClient.provider)
+    };
+  }
+  return {
+    chainId: this.getCurrentChainId(),
+    ethQuery: this._provider ? new (0, _ethquery2.default)(this._provider) : void 0
+  };
+};
+var AccountTrackerController_default = AccountTrackerController;
+
+
+
+
+exports.AccountTrackerController = AccountTrackerController; exports.AccountTrackerController_default = AccountTrackerController_default;
+//# sourceMappingURL=chunk-V4ZO3F2S.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-V4ZO3F2S.js.map b/node_modules/@metamask/assets-controllers/dist/chunk-V4ZO3F2S.js.map
new file mode 100644
index 0000000..deb94d9
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-V4ZO3F2S.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/AccountTrackerController.ts"],"names":[],"mappings":"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","sourcesContent":["import type { BaseConfig, BaseState } from '@metamask/base-controller';\nimport { query, safelyExecuteWithTimeout } from '@metamask/controller-utils';\nimport EthQuery from '@metamask/eth-query';\nimport type { Provider } from '@metamask/eth-query';\nimport type {\n  NetworkClientId,\n  NetworkController,\n  NetworkState,\n} from '@metamask/network-controller';\nimport { StaticIntervalPollingControllerV1 } from '@metamask/polling-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport { assert } from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\nimport { cloneDeep } from 'lodash';\n\n/**\n * @type AccountInformation\n *\n * Account information object\n * @property balance - Hex string of an account balancec in wei\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface AccountInformation {\n  balance: string;\n}\n\n/**\n * @type AccountTrackerConfig\n *\n * Account tracker controller configuration\n * @property provider - Provider used to create a new underlying EthQuery instance\n */\n// This interface was created before this ESLint rule was added.\n// Remove in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface AccountTrackerConfig extends BaseConfig {\n  interval: number;\n  provider?: Provider;\n}\n\n/**\n * @type AccountTrackerState\n *\n * Account tracker controller state\n * @property accounts - Map of addresses to account information\n */\n// This interface was created before this ESLint rule was added.\n// Remove in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface AccountTrackerState extends BaseState {\n  accounts: { [address: string]: AccountInformation };\n  accountsByChainId: Record<string, { [address: string]: AccountInformation }>;\n}\n\n/**\n * Controller that tracks the network balances for all user accounts.\n */\nexport class AccountTrackerController extends StaticIntervalPollingControllerV1<\n  AccountTrackerConfig,\n  AccountTrackerState\n> {\n  private _provider?: Provider;\n\n  private readonly refreshMutex = new Mutex();\n\n  private handle?: ReturnType<typeof setTimeout>;\n\n  private syncAccounts(newChainId: string) {\n    const accounts = { ...this.state.accounts };\n    const accountsByChainId = cloneDeep(this.state.accountsByChainId);\n\n    const existing = Object.keys(accounts);\n    if (!accountsByChainId[newChainId]) {\n      accountsByChainId[newChainId] = {};\n      existing.forEach((address) => {\n        accountsByChainId[newChainId][address] = { balance: '0x0' };\n      });\n    }\n\n    const addresses = Object.keys(this.getIdentities());\n    const newAddresses = addresses.filter(\n      (address) => !existing.includes(address),\n    );\n    const oldAddresses = existing.filter(\n      (address) => !addresses.includes(address),\n    );\n    newAddresses.forEach((address) => {\n      accounts[address] = { balance: '0x0' };\n    });\n    Object.keys(accountsByChainId).forEach((chainId) => {\n      newAddresses.forEach((address) => {\n        accountsByChainId[chainId][address] = {\n          balance: '0x0',\n        };\n      });\n    });\n\n    oldAddresses.forEach((address) => {\n      delete accounts[address];\n    });\n    Object.keys(accountsByChainId).forEach((chainId) => {\n      oldAddresses.forEach((address) => {\n        delete accountsByChainId[chainId][address];\n      });\n    });\n\n    this.update({ accounts, accountsByChainId });\n  }\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'AccountTrackerController';\n\n  private readonly getIdentities: () => PreferencesState['identities'];\n\n  private readonly getSelectedAddress: () => PreferencesState['selectedAddress'];\n\n  private readonly getMultiAccountBalancesEnabled: () => PreferencesState['isMultiAccountBalancesEnabled'];\n\n  private readonly getCurrentChainId: () => NetworkState['providerConfig']['chainId'];\n\n  private readonly getNetworkClientById: NetworkController['getNetworkClientById'];\n\n  /**\n   * Creates an AccountTracker instance.\n   *\n   * @param options - The controller options.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.getIdentities - Gets the identities from the Preferences store.\n   * @param options.getSelectedAddress - Gets the selected address from the Preferences store.\n   * @param options.getMultiAccountBalancesEnabled - Gets the multi account balances enabled flag from the Preferences store.\n   * @param options.getCurrentChainId - Gets the chain ID for the current network from the Network store.\n   * @param options.getNetworkClientById - Gets the network client with the given id from the NetworkController.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      onPreferencesStateChange,\n      getIdentities,\n      getSelectedAddress,\n      getMultiAccountBalancesEnabled,\n      getCurrentChainId,\n      getNetworkClientById,\n    }: {\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      getIdentities: () => PreferencesState['identities'];\n      getSelectedAddress: () => PreferencesState['selectedAddress'];\n      getMultiAccountBalancesEnabled: () => PreferencesState['isMultiAccountBalancesEnabled'];\n      getCurrentChainId: () => NetworkState['providerConfig']['chainId'];\n      getNetworkClientById: NetworkController['getNetworkClientById'];\n    },\n    config?: Partial<AccountTrackerConfig>,\n    state?: Partial<AccountTrackerState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      interval: 10000,\n    };\n    this.defaultState = {\n      accounts: {},\n      accountsByChainId: {\n        [getCurrentChainId()]: {},\n      },\n    };\n    this.initialize();\n    this.setIntervalLength(this.config.interval);\n    this.getIdentities = getIdentities;\n    this.getSelectedAddress = getSelectedAddress;\n    this.getMultiAccountBalancesEnabled = getMultiAccountBalancesEnabled;\n    this.getCurrentChainId = getCurrentChainId;\n    this.getNetworkClientById = getNetworkClientById;\n    onPreferencesStateChange(() => {\n      this.refresh();\n    });\n    this.poll();\n  }\n\n  /**\n   * Sets a new provider.\n   *\n   * TODO: Replace this wth a method.\n   *\n   * @param provider - Provider used to create a new underlying EthQuery instance.\n   */\n  set provider(provider: Provider) {\n    this._provider = provider;\n  }\n\n  get provider() {\n    throw new Error('Property only used for setting');\n  }\n\n  /**\n   * Resolves a networkClientId to a network client config\n   * or globally selected network config if not provided\n   *\n   * @param networkClientId - Optional networkClientId to fetch a network client with\n   * @returns network client config\n   */\n  #getCorrectNetworkClient(networkClientId?: NetworkClientId): {\n    chainId: string;\n    ethQuery?: EthQuery;\n  } {\n    if (networkClientId) {\n      const networkClient = this.getNetworkClientById(networkClientId);\n\n      return {\n        chainId: networkClient.configuration.chainId,\n        ethQuery: new EthQuery(networkClient.provider),\n      };\n    }\n\n    return {\n      chainId: this.getCurrentChainId(),\n      ethQuery: this._provider ? new EthQuery(this._provider) : undefined,\n    };\n  }\n\n  /**\n   * Starts a new polling interval.\n   *\n   * @param interval - Polling interval trigger a 'refresh'.\n   */\n  async poll(interval?: number): Promise<void> {\n    interval && this.configure({ interval }, false, false);\n    this.handle && clearTimeout(this.handle);\n    await this.refresh();\n    this.handle = setTimeout(() => {\n      this.poll(this.config.interval);\n    }, this.config.interval);\n  }\n\n  /**\n   * Refreshes the balances of the accounts using the networkClientId\n   *\n   * @param networkClientId - The network client ID used to get balances.\n   */\n  async _executePoll(networkClientId: string): Promise<void> {\n    this.refresh(networkClientId);\n  }\n\n  /**\n   * Refreshes the balances of the accounts depending on the multi-account setting.\n   * If multi-account is disabled, only updates the selected account balance.\n   * If multi-account is enabled, updates balances for all accounts.\n   *\n   * @param networkClientId - Optional networkClientId to fetch a network client with\n   */\n  refresh = async (networkClientId?: NetworkClientId) => {\n    const releaseLock = await this.refreshMutex.acquire();\n    try {\n      const { chainId, ethQuery } =\n        this.#getCorrectNetworkClient(networkClientId);\n      this.syncAccounts(chainId);\n      const { accounts, accountsByChainId } = this.state;\n      const isMultiAccountBalancesEnabled =\n        this.getMultiAccountBalancesEnabled();\n\n      const accountsToUpdate = isMultiAccountBalancesEnabled\n        ? Object.keys(accounts)\n        : [this.getSelectedAddress()];\n\n      const accountsForChain = { ...accountsByChainId[chainId] };\n      for (const address of accountsToUpdate) {\n        const balance = await this.getBalanceFromChain(address, ethQuery);\n        if (balance) {\n          accountsForChain[address] = {\n            balance,\n          };\n        }\n      }\n\n      this.update({\n        ...(chainId === this.getCurrentChainId() && {\n          accounts: accountsForChain,\n        }),\n        accountsByChainId: {\n          ...this.state.accountsByChainId,\n          [chainId]: accountsForChain,\n        },\n      });\n    } catch (err) {\n      releaseLock();\n      throw err;\n    }\n  };\n\n  /**\n   * Fetches the balance of a given address from the blockchain.\n   *\n   * @param address - The account address to fetch the balance for.\n   * @param ethQuery - The EthQuery instance to query getBalnce with.\n   * @returns A promise that resolves to the balance in a hex string format.\n   */\n  private async getBalanceFromChain(\n    address: string,\n    ethQuery?: EthQuery,\n  ): Promise<string | undefined> {\n    return await safelyExecuteWithTimeout(async () => {\n      assert(ethQuery, 'Provider not set.');\n      return await query(ethQuery, 'getBalance', [address]);\n    });\n  }\n\n  /**\n   * Sync accounts balances with some additional addresses.\n   *\n   * @param addresses - the additional addresses, may be hardware wallet addresses.\n   * @param networkClientId - Optional networkClientId to fetch a network client with.\n   * @returns accounts - addresses with synced balance\n   */\n  async syncBalanceWithAddresses(\n    addresses: string[],\n    networkClientId?: NetworkClientId,\n  ): Promise<Record<string, { balance: string }>> {\n    const { ethQuery } = this.#getCorrectNetworkClient(networkClientId);\n\n    return await Promise.all(\n      addresses.map((address): Promise<[string, string] | undefined> => {\n        return safelyExecuteWithTimeout(async () => {\n          assert(ethQuery, 'Provider not set.');\n          const balance = await query(ethQuery, 'getBalance', [address]);\n          return [address, balance];\n        });\n      }),\n    ).then((value) => {\n      return value.reduce((obj, item) => {\n        if (!item) {\n          return obj;\n        }\n\n        const [address, balance] = item;\n        return {\n          ...obj,\n          [address]: {\n            balance,\n          },\n        };\n      }, {});\n    });\n  }\n}\n\nexport default AccountTrackerController;\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-VHCPQS4X.js b/node_modules/@metamask/assets-controllers/dist/chunk-VHCPQS4X.js
new file mode 100644
index 0000000..53da011
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-VHCPQS4X.js
@@ -0,0 +1,215 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});
+
+
+var _chunkRELRWIJNjs = require('./chunk-RELRWIJN.js');
+
+// src/Standards/NftStandards/ERC1155/ERC1155Standard.ts
+var _contracts = require('@ethersproject/contracts');
+
+
+
+
+
+
+
+var _controllerutils = require('@metamask/controller-utils');
+var _metamaskethabis = require('@metamask/metamask-eth-abis');
+var ERC1155Standard = class {
+  constructor(provider) {
+    this.provider = provider;
+  }
+  /**
+   * Query if contract implements ERC1155 URI Metadata interface.
+   *
+   * @param address - ERC1155 asset contract address.
+   * @returns Promise resolving to whether the contract implements ERC1155 URI Metadata interface.
+   */
+  async contractSupportsURIMetadataInterface(address) {
+    return this.contractSupportsInterface(
+      address,
+      _controllerutils.ERC1155_METADATA_URI_INTERFACE_ID
+    );
+  }
+  /**
+   * Query if contract implements ERC1155 Token Receiver interface.
+   *
+   * @param address - ERC1155 asset contract address.
+   * @returns Promise resolving to whether the contract implements ERC1155 Token Receiver interface.
+   */
+  async contractSupportsTokenReceiverInterface(address) {
+    return this.contractSupportsInterface(
+      address,
+      _controllerutils.ERC1155_TOKEN_RECEIVER_INTERFACE_ID
+    );
+  }
+  /**
+   * Query if contract implements ERC1155 interface.
+   *
+   * @param address - ERC1155 asset contract address.
+   * @returns Promise resolving to whether the contract implements the base ERC1155 interface.
+   */
+  async contractSupportsBase1155Interface(address) {
+    return this.contractSupportsInterface(address, _controllerutils.ERC1155_INTERFACE_ID);
+  }
+  /**
+   * Query for tokenURI for a given asset.
+   *
+   * @param address - ERC1155 asset contract address.
+   * @param tokenId - ERC1155 asset identifier.
+   * @returns Promise resolving to the 'tokenURI'.
+   */
+  async getTokenURI(address, tokenId) {
+    const contract = new (0, _contracts.Contract)(address, _metamaskethabis.abiERC1155, this.provider);
+    return contract.uri(tokenId);
+  }
+  /**
+   * Query for balance of a given ERC1155 token.
+   *
+   * @param contractAddress - ERC1155 asset contract address.
+   * @param address - Wallet public address.
+   * @param tokenId - ERC1155 asset identifier.
+   * @returns Promise resolving to the 'balanceOf'.
+   */
+  async getBalanceOf(contractAddress, address, tokenId) {
+    const contract = new (0, _contracts.Contract)(contractAddress, _metamaskethabis.abiERC1155, this.provider);
+    const balance = await contract.balanceOf(address, tokenId);
+    return _chunkRELRWIJNjs.ethersBigNumberToBN.call(void 0, balance);
+  }
+  /**
+   * Transfer single ERC1155 token.
+   * When minting/creating tokens, the from arg MUST be set to 0x0 (i.e. zero address).
+   * When burning/destroying tokens, the to arg MUST be set to 0x0 (i.e. zero address).
+   *
+   * @param operator - ERC1155 token address.
+   * @param from - ERC1155 token holder.
+   * @param to - ERC1155 token recipient.
+   * @param id - ERC1155 token id.
+   * @param value - Number of tokens to be sent.
+   * @returns Promise resolving to the 'transferSingle'.
+   */
+  async transferSingle(operator, from, to, id, value) {
+    const contract = new (0, _contracts.Contract)(operator, _metamaskethabis.abiERC1155, this.provider);
+    return new Promise((resolve, reject) => {
+      contract.transferSingle(
+        operator,
+        from,
+        to,
+        id,
+        value,
+        (error, result) => {
+          if (error) {
+            reject(error);
+            return;
+          }
+          resolve(result);
+        }
+      );
+    });
+  }
+  /**
+   * Query for symbol for a given asset.
+   *
+   * @param address - ERC1155 asset contract address.
+   * @returns Promise resolving to the 'symbol'.
+   */
+  async getAssetSymbol(address) {
+    const contract = new (0, _contracts.Contract)(
+      address,
+      // Contract ABI fragment containing only the symbol method to fetch the symbol of the contract.
+      [
+        {
+          inputs: [],
+          name: "symbol",
+          outputs: [{ name: "_symbol", type: "string" }],
+          stateMutability: "view",
+          type: "function",
+          payable: false
+        }
+      ],
+      this.provider
+    );
+    return contract.symbol();
+  }
+  /**
+   * Query for name for a given asset.
+   *
+   * @param address - ERC1155 asset contract address.
+   * @returns Promise resolving to the 'name'.
+   */
+  async getAssetName(address) {
+    const contract = new (0, _contracts.Contract)(
+      address,
+      // Contract ABI fragment containing only the name method to fetch the name of the contract.
+      [
+        {
+          inputs: [],
+          name: "name",
+          outputs: [{ name: "_name", type: "string" }],
+          stateMutability: "view",
+          type: "function",
+          payable: false
+        }
+      ],
+      this.provider
+    );
+    return contract.name();
+  }
+  /**
+   * Query if a contract implements an interface.
+   *
+   * @param address - ERC1155 asset contract address.
+   * @param interfaceId - Interface identifier.
+   * @returns Promise resolving to whether the contract implements `interfaceID`.
+   */
+  async contractSupportsInterface(address, interfaceId) {
+    const contract = new (0, _contracts.Contract)(address, _metamaskethabis.abiERC1155, this.provider);
+    return contract.supportsInterface(interfaceId);
+  }
+  /**
+   * Query if a contract implements an interface.
+   *
+   * @param address - Asset contract address.
+   * @param ipfsGateway - The user's preferred IPFS gateway.
+   * @param tokenId - tokenId of a given token in the contract.
+   * @returns Promise resolving an object containing the standard, tokenURI, symbol and name of the given contract/tokenId pair.
+   */
+  async getDetails(address, ipfsGateway, tokenId) {
+    const isERC1155 = await this.contractSupportsBase1155Interface(address);
+    if (!isERC1155) {
+      throw new Error("This isn't a valid ERC1155 contract");
+    }
+    let image;
+    const [symbol, name, tokenURI] = await Promise.all([
+      _controllerutils.safelyExecute.call(void 0, () => this.getAssetSymbol(address)),
+      _controllerutils.safelyExecute.call(void 0, () => this.getAssetName(address)),
+      tokenId ? _controllerutils.safelyExecute.call(void 0, 
+        () => this.getTokenURI(address, tokenId).then(
+          (uri) => uri.startsWith("ipfs://") ? _chunkRELRWIJNjs.getFormattedIpfsUrl.call(void 0, ipfsGateway, uri, true) : uri
+        )
+      ) : void 0
+    ]);
+    if (tokenURI) {
+      try {
+        const response = await _controllerutils.timeoutFetch.call(void 0, tokenURI);
+        const object = await response.json();
+        image = object?.image;
+        if (image?.startsWith("ipfs://")) {
+          image = _chunkRELRWIJNjs.getFormattedIpfsUrl.call(void 0, ipfsGateway, image, true);
+        }
+      } catch {
+      }
+    }
+    return {
+      standard: _controllerutils.ERC1155,
+      tokenURI,
+      image,
+      symbol,
+      name
+    };
+  }
+};
+
+
+
+exports.ERC1155Standard = ERC1155Standard;
+//# sourceMappingURL=chunk-VHCPQS4X.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-VHCPQS4X.js.map b/node_modules/@metamask/assets-controllers/dist/chunk-VHCPQS4X.js.map
new file mode 100644
index 0000000..503eeaa
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-VHCPQS4X.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/Standards/NftStandards/ERC1155/ERC1155Standard.ts"],"names":[],"mappings":"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","sourcesContent":["import { Contract } from '@ethersproject/contracts';\nimport type { Web3Provider } from '@ethersproject/providers';\nimport {\n  ERC1155,\n  ERC1155_INTERFACE_ID,\n  ERC1155_METADATA_URI_INTERFACE_ID,\n  ERC1155_TOKEN_RECEIVER_INTERFACE_ID,\n  safelyExecute,\n  timeoutFetch,\n} from '@metamask/controller-utils';\nimport { abiERC1155 } from '@metamask/metamask-eth-abis';\nimport type * as BN from 'bn.js';\n\nimport { getFormattedIpfsUrl, ethersBigNumberToBN } from '../../../assetsUtil';\n\nexport class ERC1155Standard {\n  private readonly provider: Web3Provider;\n\n  constructor(provider: Web3Provider) {\n    this.provider = provider;\n  }\n\n  /**\n   * Query if contract implements ERC1155 URI Metadata interface.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @returns Promise resolving to whether the contract implements ERC1155 URI Metadata interface.\n   */\n  async contractSupportsURIMetadataInterface(\n    address: string,\n  ): Promise<boolean> {\n    return this.contractSupportsInterface(\n      address,\n      ERC1155_METADATA_URI_INTERFACE_ID,\n    );\n  }\n\n  /**\n   * Query if contract implements ERC1155 Token Receiver interface.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @returns Promise resolving to whether the contract implements ERC1155 Token Receiver interface.\n   */\n  async contractSupportsTokenReceiverInterface(\n    address: string,\n  ): Promise<boolean> {\n    return this.contractSupportsInterface(\n      address,\n      ERC1155_TOKEN_RECEIVER_INTERFACE_ID,\n    );\n  }\n\n  /**\n   * Query if contract implements ERC1155 interface.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @returns Promise resolving to whether the contract implements the base ERC1155 interface.\n   */\n  async contractSupportsBase1155Interface(address: string): Promise<boolean> {\n    return this.contractSupportsInterface(address, ERC1155_INTERFACE_ID);\n  }\n\n  /**\n   * Query for tokenURI for a given asset.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @param tokenId - ERC1155 asset identifier.\n   * @returns Promise resolving to the 'tokenURI'.\n   */\n  async getTokenURI(address: string, tokenId: string): Promise<string> {\n    const contract = new Contract(address, abiERC1155, this.provider);\n    return contract.uri(tokenId);\n  }\n\n  /**\n   * Query for balance of a given ERC1155 token.\n   *\n   * @param contractAddress - ERC1155 asset contract address.\n   * @param address - Wallet public address.\n   * @param tokenId - ERC1155 asset identifier.\n   * @returns Promise resolving to the 'balanceOf'.\n   */\n  async getBalanceOf(\n    contractAddress: string,\n    address: string,\n    tokenId: string,\n  ): Promise<BN> {\n    const contract = new Contract(contractAddress, abiERC1155, this.provider);\n    const balance = await contract.balanceOf(address, tokenId);\n    return ethersBigNumberToBN(balance);\n  }\n\n  /**\n   * Transfer single ERC1155 token.\n   * When minting/creating tokens, the from arg MUST be set to 0x0 (i.e. zero address).\n   * When burning/destroying tokens, the to arg MUST be set to 0x0 (i.e. zero address).\n   *\n   * @param operator - ERC1155 token address.\n   * @param from - ERC1155 token holder.\n   * @param to - ERC1155 token recipient.\n   * @param id - ERC1155 token id.\n   * @param value - Number of tokens to be sent.\n   * @returns Promise resolving to the 'transferSingle'.\n   */\n  async transferSingle(\n    operator: string,\n    from: string,\n    to: string,\n    id: string,\n    value: string,\n  ): Promise<void> {\n    const contract = new Contract(operator, abiERC1155, this.provider);\n    return new Promise<void>((resolve, reject) => {\n      contract.transferSingle(\n        operator,\n        from,\n        to,\n        id,\n        value,\n        (error: Error, result: void) => {\n          /* istanbul ignore if */\n          if (error) {\n            reject(error);\n            return;\n          }\n          resolve(result);\n        },\n      );\n    });\n  }\n\n  /**\n   * Query for symbol for a given asset.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @returns Promise resolving to the 'symbol'.\n   */\n  async getAssetSymbol(address: string): Promise<string> {\n    const contract = new Contract(\n      address,\n      // Contract ABI fragment containing only the symbol method to fetch the symbol of the contract.\n      [\n        {\n          inputs: [],\n          name: 'symbol',\n          outputs: [{ name: '_symbol', type: 'string' }],\n          stateMutability: 'view',\n          type: 'function',\n          payable: false,\n        },\n      ],\n      this.provider,\n    );\n    return contract.symbol();\n  }\n\n  /**\n   * Query for name for a given asset.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @returns Promise resolving to the 'name'.\n   */\n  async getAssetName(address: string): Promise<string> {\n    const contract = new Contract(\n      address,\n      // Contract ABI fragment containing only the name method to fetch the name of the contract.\n      [\n        {\n          inputs: [],\n          name: 'name',\n          outputs: [{ name: '_name', type: 'string' }],\n          stateMutability: 'view',\n          type: 'function',\n          payable: false,\n        },\n      ],\n      this.provider,\n    );\n    return contract.name();\n  }\n\n  /**\n   * Query if a contract implements an interface.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @param interfaceId - Interface identifier.\n   * @returns Promise resolving to whether the contract implements `interfaceID`.\n   */\n  private async contractSupportsInterface(\n    address: string,\n    interfaceId: string,\n  ): Promise<boolean> {\n    const contract = new Contract(address, abiERC1155, this.provider);\n    return contract.supportsInterface(interfaceId);\n  }\n\n  /**\n   * Query if a contract implements an interface.\n   *\n   * @param address - Asset contract address.\n   * @param ipfsGateway - The user's preferred IPFS gateway.\n   * @param tokenId - tokenId of a given token in the contract.\n   * @returns Promise resolving an object containing the standard, tokenURI, symbol and name of the given contract/tokenId pair.\n   */\n  async getDetails(\n    address: string,\n    ipfsGateway: string,\n    tokenId?: string,\n  ): Promise<{\n    standard: string;\n    tokenURI: string | undefined;\n    image: string | undefined;\n    name: string | undefined;\n    symbol: string | undefined;\n  }> {\n    const isERC1155 = await this.contractSupportsBase1155Interface(address);\n\n    if (!isERC1155) {\n      throw new Error(\"This isn't a valid ERC1155 contract\");\n    }\n\n    let image;\n\n    const [symbol, name, tokenURI] = await Promise.all([\n      safelyExecute(() => this.getAssetSymbol(address)),\n      safelyExecute(() => this.getAssetName(address)),\n      tokenId\n        ? safelyExecute(() =>\n            this.getTokenURI(address, tokenId).then((uri) =>\n              uri.startsWith('ipfs://')\n                ? getFormattedIpfsUrl(ipfsGateway, uri, true)\n                : uri,\n            ),\n          )\n        : undefined,\n    ]);\n\n    if (tokenURI) {\n      try {\n        const response = await timeoutFetch(tokenURI);\n        const object = await response.json();\n        image = object?.image;\n        if (image?.startsWith('ipfs://')) {\n          image = getFormattedIpfsUrl(ipfsGateway, image, true);\n        }\n      } catch {\n        // Catch block should be kept empty to ignore exceptions, and\n        // pass as much information as possible to the return statement\n      }\n    }\n\n    // TODO consider querying to the metadata to get name.\n    return {\n      standard: ERC1155,\n      tokenURI,\n      image,\n      symbol,\n      name,\n    };\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-VY7TUOK2.js b/node_modules/@metamask/assets-controllers/dist/chunk-VY7TUOK2.js
new file mode 100644
index 0000000..7a65e4a
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-VY7TUOK2.js
@@ -0,0 +1,74 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});
+
+var _chunkRELRWIJNjs = require('./chunk-RELRWIJN.js');
+
+// src/token-service.ts
+var _controllerutils = require('@metamask/controller-utils');
+var TOKEN_END_POINT_API = "https://token-api.metaswap.codefi.network";
+var TOKEN_METADATA_NO_SUPPORT_ERROR = "TokenService Error: Network does not support fetchTokenMetadata";
+function getTokensURL(chainId) {
+  return `${TOKEN_END_POINT_API}/tokens/${_controllerutils.convertHexToDecimal.call(void 0, 
+    chainId
+  )}?occurrenceFloor=3&includeNativeAssets=false&includeDuplicateSymbolAssets=false&includeTokenFees=false&includeAssetType=false`;
+}
+function getTokenMetadataURL(chainId, tokenAddress) {
+  return `${TOKEN_END_POINT_API}/token/${_controllerutils.convertHexToDecimal.call(void 0, 
+    chainId
+  )}?address=${tokenAddress}`;
+}
+var tenSecondsInMilliseconds = 1e4;
+var defaultTimeout = tenSecondsInMilliseconds;
+async function fetchTokenListByChainId(chainId, abortSignal, { timeout = defaultTimeout } = {}) {
+  const tokenURL = getTokensURL(chainId);
+  const response = await queryApi(tokenURL, abortSignal, timeout);
+  if (response) {
+    return parseJsonResponse(response);
+  }
+  return void 0;
+}
+async function fetchTokenMetadata(chainId, tokenAddress, abortSignal, { timeout = defaultTimeout } = {}) {
+  if (!_chunkRELRWIJNjs.isTokenListSupportedForNetwork.call(void 0, chainId)) {
+    throw new Error(TOKEN_METADATA_NO_SUPPORT_ERROR);
+  }
+  const tokenMetadataURL = getTokenMetadataURL(chainId, tokenAddress);
+  const response = await queryApi(tokenMetadataURL, abortSignal, timeout);
+  if (response) {
+    return parseJsonResponse(response);
+  }
+  return void 0;
+}
+async function queryApi(apiURL, abortSignal, timeout) {
+  const fetchOptions = {
+    referrer: apiURL,
+    referrerPolicy: "no-referrer-when-downgrade",
+    method: "GET",
+    mode: "cors",
+    signal: abortSignal,
+    cache: "default"
+  };
+  fetchOptions.headers = new window.Headers();
+  fetchOptions.headers.set("Content-Type", "application/json");
+  try {
+    return await _controllerutils.timeoutFetch.call(void 0, apiURL, fetchOptions, timeout);
+  } catch (error) {
+    if (error instanceof Error && error.name === "AbortError") {
+      console.log("Request is aborted");
+    }
+  }
+  return void 0;
+}
+async function parseJsonResponse(apiResponse) {
+  const responseObj = await apiResponse.json();
+  if (responseObj?.error) {
+    throw new Error(`TokenService Error: ${responseObj.error}`);
+  }
+  return responseObj;
+}
+
+
+
+
+
+
+exports.TOKEN_END_POINT_API = TOKEN_END_POINT_API; exports.TOKEN_METADATA_NO_SUPPORT_ERROR = TOKEN_METADATA_NO_SUPPORT_ERROR; exports.fetchTokenListByChainId = fetchTokenListByChainId; exports.fetchTokenMetadata = fetchTokenMetadata;
+//# sourceMappingURL=chunk-VY7TUOK2.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-VY7TUOK2.js.map b/node_modules/@metamask/assets-controllers/dist/chunk-VY7TUOK2.js.map
new file mode 100644
index 0000000..35e9d07
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-VY7TUOK2.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/token-service.ts"],"names":[],"mappings":";;;;;AAAA,SAAS,qBAAqB,oBAAoB;AAK3C,IAAM,sBAAsB;AAC5B,IAAM,kCACX;AAQF,SAAS,aAAa,SAAc;AAClC,SAAO,GAAG,mBAAmB,WAAW;AAAA,IACtC;AAAA,EACF,CAAC;AACH;AASA,SAAS,oBAAoB,SAAc,cAAsB;AAC/D,SAAO,GAAG,mBAAmB,UAAU;AAAA,IACrC;AAAA,EACF,CAAC,YAAY,YAAY;AAC3B;AAEA,IAAM,2BAA2B;AAIjC,IAAM,iBAAiB;AAYvB,eAAsB,wBACpB,SACA,aACA,EAAE,UAAU,eAAe,IAAI,CAAC,GACd;AAClB,QAAM,WAAW,aAAa,OAAO;AACrC,QAAM,WAAW,MAAM,SAAS,UAAU,aAAa,OAAO;AAC9D,MAAI,UAAU;AACZ,WAAO,kBAAkB,QAAQ;AAAA,EACnC;AACA,SAAO;AACT;AAaA,eAAsB,mBACpB,SACA,cACA,aACA,EAAE,UAAU,eAAe,IAAI,CAAC,GACR;AACxB,MAAI,CAAC,+BAA+B,OAAO,GAAG;AAC5C,UAAM,IAAI,MAAM,+BAA+B;AAAA,EACjD;AACA,QAAM,mBAAmB,oBAAoB,SAAS,YAAY;AAClE,QAAM,WAAW,MAAM,SAAS,kBAAkB,aAAa,OAAO;AACtE,MAAI,UAAU;AACZ,WAAO,kBAAkB,QAAQ;AAAA,EACnC;AACA,SAAO;AACT;AAUA,eAAe,SACb,QACA,aACA,SAC+B;AAC/B,QAAM,eAA4B;AAAA,IAChC,UAAU;AAAA,IACV,gBAAgB;AAAA,IAChB,QAAQ;AAAA,IACR,MAAM;AAAA,IACN,QAAQ;AAAA,IACR,OAAO;AAAA,EACT;AACA,eAAa,UAAU,IAAI,OAAO,QAAQ;AAC1C,eAAa,QAAQ,IAAI,gBAAgB,kBAAkB;AAC3D,MAAI;AACF,WAAO,MAAM,aAAa,QAAQ,cAAc,OAAO;AAAA,EACzD,SAAS,OAAO;AACd,QAAI,iBAAiB,SAAS,MAAM,SAAS,cAAc;AACzD,cAAQ,IAAI,oBAAoB;AAAA,IAClC;AAAA,EACF;AACA,SAAO;AACT;AASA,eAAe,kBAAkB,aAAyC;AACxE,QAAM,cAAc,MAAM,YAAY,KAAK;AAE3C,MAAI,aAAa,OAAO;AACtB,UAAM,IAAI,MAAM,uBAAuB,YAAY,KAAK,EAAE;AAAA,EAC5D;AACA,SAAO;AACT","sourcesContent":["import { convertHexToDecimal, timeoutFetch } from '@metamask/controller-utils';\nimport type { Hex } from '@metamask/utils';\n\nimport { isTokenListSupportedForNetwork } from './assetsUtil';\n\nexport const TOKEN_END_POINT_API = 'https://token-api.metaswap.codefi.network';\nexport const TOKEN_METADATA_NO_SUPPORT_ERROR =\n  'TokenService Error: Network does not support fetchTokenMetadata';\n\n/**\n * Get the tokens URL for a specific network.\n *\n * @param chainId - The chain ID of the network the tokens requested are on.\n * @returns The tokens URL.\n */\nfunction getTokensURL(chainId: Hex) {\n  return `${TOKEN_END_POINT_API}/tokens/${convertHexToDecimal(\n    chainId,\n  )}?occurrenceFloor=3&includeNativeAssets=false&includeDuplicateSymbolAssets=false&includeTokenFees=false&includeAssetType=false`;\n}\n\n/**\n * Get the token metadata URL for the given network and token.\n *\n * @param chainId - The chain ID of the network the token is on.\n * @param tokenAddress - The token address.\n * @returns The token metadata URL.\n */\nfunction getTokenMetadataURL(chainId: Hex, tokenAddress: string) {\n  return `${TOKEN_END_POINT_API}/token/${convertHexToDecimal(\n    chainId,\n  )}?address=${tokenAddress}`;\n}\n\nconst tenSecondsInMilliseconds = 10_000;\n\n// Token list averages 1.6 MB in size\n// timeoutFetch by default has a 500ms timeout, which will almost always timeout given the response size.\nconst defaultTimeout = tenSecondsInMilliseconds;\n\n/**\n * Fetch the list of token metadata for a given network. This request is cancellable using the\n * abort signal passed in.\n *\n * @param chainId - The chain ID of the network the requested tokens are on.\n * @param abortSignal - The abort signal used to cancel the request if necessary.\n * @param options - Additional fetch options.\n * @param options.timeout - The fetch timeout.\n * @returns The token list, or `undefined` if the request was cancelled.\n */\nexport async function fetchTokenListByChainId(\n  chainId: Hex,\n  abortSignal: AbortSignal,\n  { timeout = defaultTimeout } = {},\n): Promise<unknown> {\n  const tokenURL = getTokensURL(chainId);\n  const response = await queryApi(tokenURL, abortSignal, timeout);\n  if (response) {\n    return parseJsonResponse(response);\n  }\n  return undefined;\n}\n\n/**\n * Fetch metadata for the token address provided for a given network. This request is cancellable\n * using the abort signal passed in.\n *\n * @param chainId - The chain ID of the network the token is on.\n * @param tokenAddress - The address of the token to fetch metadata for.\n * @param abortSignal - The abort signal used to cancel the request if necessary.\n * @param options - Additional fetch options.\n * @param options.timeout - The fetch timeout.\n * @returns The token metadata, or `undefined` if the request was either aborted or failed.\n */\nexport async function fetchTokenMetadata<T>(\n  chainId: Hex,\n  tokenAddress: string,\n  abortSignal: AbortSignal,\n  { timeout = defaultTimeout } = {},\n): Promise<T | undefined> {\n  if (!isTokenListSupportedForNetwork(chainId)) {\n    throw new Error(TOKEN_METADATA_NO_SUPPORT_ERROR);\n  }\n  const tokenMetadataURL = getTokenMetadataURL(chainId, tokenAddress);\n  const response = await queryApi(tokenMetadataURL, abortSignal, timeout);\n  if (response) {\n    return parseJsonResponse(response) as Promise<T>;\n  }\n  return undefined;\n}\n\n/**\n * Perform fetch request against the api.\n *\n * @param apiURL - The URL of the API to fetch.\n * @param abortSignal - The abort signal used to cancel the request if necessary.\n * @param timeout - The fetch timeout.\n * @returns Promise resolving request response.\n */\nasync function queryApi(\n  apiURL: string,\n  abortSignal: AbortSignal,\n  timeout: number,\n): Promise<Response | undefined> {\n  const fetchOptions: RequestInit = {\n    referrer: apiURL,\n    referrerPolicy: 'no-referrer-when-downgrade',\n    method: 'GET',\n    mode: 'cors',\n    signal: abortSignal,\n    cache: 'default',\n  };\n  fetchOptions.headers = new window.Headers();\n  fetchOptions.headers.set('Content-Type', 'application/json');\n  try {\n    return await timeoutFetch(apiURL, fetchOptions, timeout);\n  } catch (error) {\n    if (error instanceof Error && error.name === 'AbortError') {\n      console.log('Request is aborted');\n    }\n  }\n  return undefined;\n}\n\n/**\n * Parse an API response and return the response JSON data.\n *\n * @param apiResponse - The API response to parse.\n * @returns The response JSON data.\n * @throws Will throw if the response includes an error.\n */\nasync function parseJsonResponse(apiResponse: Response): Promise<unknown> {\n  const responseObj = await apiResponse.json();\n  // api may return errors as json without setting an error http status code\n  if (responseObj?.error) {\n    throw new Error(`TokenService Error: ${responseObj.error}`);\n  }\n  return responseObj;\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-WIVSZVF4.mjs b/node_modules/@metamask/assets-controllers/dist/chunk-WIVSZVF4.mjs
new file mode 100644
index 0000000..0096dae
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-WIVSZVF4.mjs
@@ -0,0 +1,178 @@
+import {
+  getFormattedIpfsUrl
+} from "./chunk-E5PIGGYR.mjs";
+
+// src/Standards/NftStandards/ERC721/ERC721Standard.ts
+import { Contract } from "@ethersproject/contracts";
+import {
+  timeoutFetch,
+  ERC721_INTERFACE_ID,
+  ERC721_METADATA_INTERFACE_ID,
+  ERC721_ENUMERABLE_INTERFACE_ID,
+  ERC721,
+  safelyExecute
+} from "@metamask/controller-utils";
+import { abiERC721 } from "@metamask/metamask-eth-abis";
+var ERC721Standard = class {
+  constructor(provider) {
+    /**
+     * Query if contract implements ERC721Metadata interface.
+     *
+     * @param address - ERC721 asset contract address.
+     * @returns Promise resolving to whether the contract implements ERC721Metadata interface.
+     */
+    this.contractSupportsMetadataInterface = async (address) => {
+      return this.contractSupportsInterface(
+        address,
+        ERC721_METADATA_INTERFACE_ID
+      );
+    };
+    /**
+     * Query if contract implements ERC721Enumerable interface.
+     *
+     * @param address - ERC721 asset contract address.
+     * @returns Promise resolving to whether the contract implements ERC721Enumerable interface.
+     */
+    this.contractSupportsEnumerableInterface = async (address) => {
+      return this.contractSupportsInterface(
+        address,
+        ERC721_ENUMERABLE_INTERFACE_ID
+      );
+    };
+    /**
+     * Query if contract implements ERC721 interface.
+     *
+     * @param address - ERC721 asset contract address.
+     * @returns Promise resolving to whether the contract implements ERC721 interface.
+     */
+    this.contractSupportsBase721Interface = async (address) => {
+      return this.contractSupportsInterface(address, ERC721_INTERFACE_ID);
+    };
+    /**
+     * Enumerate assets assigned to an owner.
+     *
+     * @param address - ERC721 asset contract address.
+     * @param selectedAddress - Current account public address.
+     * @param index - An NFT counter less than `balanceOf(selectedAddress)`.
+     * @returns Promise resolving to token identifier for the 'index'th asset assigned to 'selectedAddress'.
+     */
+    this.getNftTokenId = async (address, selectedAddress, index) => {
+      const contract = new Contract(address, abiERC721, this.provider);
+      return contract.tokenOfOwnerByIndex(selectedAddress, index);
+    };
+    /**
+     * Query for tokenURI for a given asset.
+     *
+     * @param address - ERC721 asset contract address.
+     * @param tokenId - ERC721 asset identifier.
+     * @returns Promise resolving to the 'tokenURI'.
+     */
+    this.getTokenURI = async (address, tokenId) => {
+      const contract = new Contract(address, abiERC721, this.provider);
+      const supportsMetadata = await this.contractSupportsMetadataInterface(
+        address
+      );
+      if (!supportsMetadata) {
+        throw new Error("Contract does not support ERC721 metadata interface.");
+      }
+      return contract.tokenURI(tokenId);
+    };
+    /**
+     * Query for name for a given asset.
+     *
+     * @param address - ERC721 asset contract address.
+     * @returns Promise resolving to the 'name'.
+     */
+    this.getAssetName = async (address) => {
+      const contract = new Contract(address, abiERC721, this.provider);
+      return contract.name();
+    };
+    /**
+     * Query for symbol for a given asset.
+     *
+     * @param address - ERC721 asset contract address.
+     * @returns Promise resolving to the 'symbol'.
+     */
+    this.getAssetSymbol = async (address) => {
+      const contract = new Contract(address, abiERC721, this.provider);
+      return contract.symbol();
+    };
+    /**
+     * Query if a contract implements an interface.
+     *
+     * @param address - Asset contract address.
+     * @param interfaceId - Interface identifier.
+     * @returns Promise resolving to whether the contract implements `interfaceID`.
+     */
+    this.contractSupportsInterface = async (address, interfaceId) => {
+      const contract = new Contract(address, abiERC721, this.provider);
+      try {
+        return await contract.supportsInterface(interfaceId);
+      } catch (err) {
+        if (err instanceof Error && err.message.includes("call revert exception")) {
+          return false;
+        }
+        throw err;
+      }
+    };
+    /**
+     * Query if a contract implements an interface.
+     *
+     * @param address - Asset contract address.
+     * @param ipfsGateway - The user's preferred IPFS gateway.
+     * @param tokenId - tokenId of a given token in the contract.
+     * @returns Promise resolving an object containing the standard, tokenURI, symbol and name of the given contract/tokenId pair.
+     */
+    this.getDetails = async (address, ipfsGateway, tokenId) => {
+      const isERC721 = await this.contractSupportsBase721Interface(address);
+      if (!isERC721) {
+        throw new Error("This isn't a valid ERC721 contract");
+      }
+      const [symbol, name, tokenURI] = await Promise.all([
+        safelyExecute(() => this.getAssetSymbol(address)),
+        safelyExecute(() => this.getAssetName(address)),
+        tokenId ? safelyExecute(
+          () => this.getTokenURI(address, tokenId).then(
+            (uri) => uri.startsWith("ipfs://") ? getFormattedIpfsUrl(ipfsGateway, uri, true) : uri
+          )
+        ) : void 0
+      ]);
+      let image;
+      if (tokenURI) {
+        try {
+          const response = await timeoutFetch(tokenURI);
+          const object = await response.json();
+          image = object?.image;
+          if (image?.startsWith("ipfs://")) {
+            image = getFormattedIpfsUrl(ipfsGateway, image, true);
+          }
+        } catch {
+        }
+      }
+      return {
+        standard: ERC721,
+        tokenURI,
+        symbol,
+        name,
+        image
+      };
+    };
+    this.provider = provider;
+  }
+  /**
+   * Query for owner for a given ERC721 asset.
+   *
+   * @param address - ERC721 asset contract address.
+   * @param tokenId - ERC721 asset identifier.
+   * @returns Promise resolving to the owner address.
+   */
+  async getOwnerOf(address, tokenId) {
+    const contract = new Contract(address, abiERC721, this.provider);
+    return contract.ownerOf(tokenId);
+  }
+};
+
+export {
+  ERC721Standard
+};
+//# sourceMappingURL=chunk-WIVSZVF4.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-WIVSZVF4.mjs.map b/node_modules/@metamask/assets-controllers/dist/chunk-WIVSZVF4.mjs.map
new file mode 100644
index 0000000..71ec539
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-WIVSZVF4.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/Standards/NftStandards/ERC721/ERC721Standard.ts"],"sourcesContent":["import { Contract } from '@ethersproject/contracts';\nimport type { Web3Provider } from '@ethersproject/providers';\nimport {\n  timeoutFetch,\n  ERC721_INTERFACE_ID,\n  ERC721_METADATA_INTERFACE_ID,\n  ERC721_ENUMERABLE_INTERFACE_ID,\n  ERC721,\n  safelyExecute,\n} from '@metamask/controller-utils';\nimport { abiERC721 } from '@metamask/metamask-eth-abis';\n\nimport { getFormattedIpfsUrl } from '../../../assetsUtil';\n\nexport class ERC721Standard {\n  private readonly provider: Web3Provider;\n\n  constructor(provider: Web3Provider) {\n    this.provider = provider;\n  }\n\n  /**\n   * Query if contract implements ERC721Metadata interface.\n   *\n   * @param address - ERC721 asset contract address.\n   * @returns Promise resolving to whether the contract implements ERC721Metadata interface.\n   */\n  contractSupportsMetadataInterface = async (\n    address: string,\n  ): Promise<boolean> => {\n    return this.contractSupportsInterface(\n      address,\n      ERC721_METADATA_INTERFACE_ID,\n    );\n  };\n\n  /**\n   * Query if contract implements ERC721Enumerable interface.\n   *\n   * @param address - ERC721 asset contract address.\n   * @returns Promise resolving to whether the contract implements ERC721Enumerable interface.\n   */\n  contractSupportsEnumerableInterface = async (\n    address: string,\n  ): Promise<boolean> => {\n    return this.contractSupportsInterface(\n      address,\n      ERC721_ENUMERABLE_INTERFACE_ID,\n    );\n  };\n\n  /**\n   * Query if contract implements ERC721 interface.\n   *\n   * @param address - ERC721 asset contract address.\n   * @returns Promise resolving to whether the contract implements ERC721 interface.\n   */\n  contractSupportsBase721Interface = async (\n    address: string,\n  ): Promise<boolean> => {\n    return this.contractSupportsInterface(address, ERC721_INTERFACE_ID);\n  };\n\n  /**\n   * Enumerate assets assigned to an owner.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param selectedAddress - Current account public address.\n   * @param index - An NFT counter less than `balanceOf(selectedAddress)`.\n   * @returns Promise resolving to token identifier for the 'index'th asset assigned to 'selectedAddress'.\n   */\n  getNftTokenId = async (\n    address: string,\n    selectedAddress: string,\n    index: number,\n  ): Promise<string> => {\n    const contract = new Contract(address, abiERC721, this.provider);\n    return contract.tokenOfOwnerByIndex(selectedAddress, index);\n  };\n\n  /**\n   * Query for tokenURI for a given asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param tokenId - ERC721 asset identifier.\n   * @returns Promise resolving to the 'tokenURI'.\n   */\n  getTokenURI = async (address: string, tokenId: string): Promise<string> => {\n    const contract = new Contract(address, abiERC721, this.provider);\n    const supportsMetadata = await this.contractSupportsMetadataInterface(\n      address,\n    );\n    if (!supportsMetadata) {\n      throw new Error('Contract does not support ERC721 metadata interface.');\n    }\n    return contract.tokenURI(tokenId);\n  };\n\n  /**\n   * Query for name for a given asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @returns Promise resolving to the 'name'.\n   */\n  getAssetName = async (address: string): Promise<string> => {\n    const contract = new Contract(address, abiERC721, this.provider);\n    return contract.name();\n  };\n\n  /**\n   * Query for symbol for a given asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @returns Promise resolving to the 'symbol'.\n   */\n  getAssetSymbol = async (address: string): Promise<string> => {\n    const contract = new Contract(address, abiERC721, this.provider);\n    return contract.symbol();\n  };\n\n  /**\n   * Query for owner for a given ERC721 asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param tokenId - ERC721 asset identifier.\n   * @returns Promise resolving to the owner address.\n   */\n  async getOwnerOf(address: string, tokenId: string): Promise<string> {\n    const contract = new Contract(address, abiERC721, this.provider);\n    return contract.ownerOf(tokenId);\n  }\n\n  /**\n   * Query if a contract implements an interface.\n   *\n   * @param address - Asset contract address.\n   * @param interfaceId - Interface identifier.\n   * @returns Promise resolving to whether the contract implements `interfaceID`.\n   */\n  private readonly contractSupportsInterface = async (\n    address: string,\n    interfaceId: string,\n  ): Promise<boolean> => {\n    const contract = new Contract(address, abiERC721, this.provider);\n    try {\n      return await contract.supportsInterface(interfaceId);\n    } catch (err) {\n      // Mirror previous implementation\n      if (\n        err instanceof Error &&\n        err.message.includes('call revert exception')\n      ) {\n        return false;\n      }\n      throw err;\n    }\n  };\n\n  /**\n   * Query if a contract implements an interface.\n   *\n   * @param address - Asset contract address.\n   * @param ipfsGateway - The user's preferred IPFS gateway.\n   * @param tokenId - tokenId of a given token in the contract.\n   * @returns Promise resolving an object containing the standard, tokenURI, symbol and name of the given contract/tokenId pair.\n   */\n  getDetails = async (\n    address: string,\n    ipfsGateway: string,\n    tokenId?: string,\n  ): Promise<{\n    standard: string;\n    tokenURI: string | undefined;\n    symbol: string | undefined;\n    name: string | undefined;\n    image: string | undefined;\n  }> => {\n    const isERC721 = await this.contractSupportsBase721Interface(address);\n    if (!isERC721) {\n      throw new Error(\"This isn't a valid ERC721 contract\");\n    }\n\n    const [symbol, name, tokenURI] = await Promise.all([\n      safelyExecute(() => this.getAssetSymbol(address)),\n      safelyExecute(() => this.getAssetName(address)),\n      tokenId\n        ? safelyExecute(() =>\n            this.getTokenURI(address, tokenId).then((uri) =>\n              uri.startsWith('ipfs://')\n                ? getFormattedIpfsUrl(ipfsGateway, uri, true)\n                : uri,\n            ),\n          )\n        : undefined,\n    ]);\n\n    let image;\n    if (tokenURI) {\n      try {\n        const response = await timeoutFetch(tokenURI);\n        const object = await response.json();\n        image = object?.image;\n        if (image?.startsWith('ipfs://')) {\n          image = getFormattedIpfsUrl(ipfsGateway, image, true);\n        }\n      } catch {\n        // ignore\n      }\n    }\n\n    return {\n      standard: ERC721,\n      tokenURI,\n      symbol,\n      name,\n      image,\n    };\n  };\n}\n"],"mappings":"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","names":[]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-WSOHBBCO.js b/node_modules/@metamask/assets-controllers/dist/chunk-WSOHBBCO.js
new file mode 100644
index 0000000..f928988
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-WSOHBBCO.js
@@ -0,0 +1,245 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});
+
+var _chunkRELRWIJNjs = require('./chunk-RELRWIJN.js');
+
+// src/NftDetectionController.ts
+
+
+
+
+
+
+
+var _controllerutils = require('@metamask/controller-utils');
+var _pollingcontroller = require('@metamask/polling-controller');
+var DEFAULT_INTERVAL = 18e4;
+var NftDetectionController = class extends _pollingcontroller.StaticIntervalPollingControllerV1 {
+  /**
+   * Creates an NftDetectionController instance.
+   *
+   * @param options - The controller options.
+   * @param options.chainId - The chain ID of the current network.
+   * @param options.onNftsStateChange - Allows subscribing to assets controller state changes.
+   * @param options.onPreferencesStateChange - Allows subscribing to preferences controller state changes.
+   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.
+   * @param options.getOpenSeaApiKey - Gets the OpenSea API key, if one is set.
+   * @param options.addNft - Add an NFT.
+   * @param options.getNftApi - Gets the URL to fetch an NFT from OpenSea.
+   * @param options.getNftState - Gets the current state of the Assets controller.
+   * @param options.getNetworkClientById - Gets the network client by ID, from the NetworkController.
+   * @param config - Initial options used to configure this controller.
+   * @param state - Initial state to set on this controller.
+   */
+  constructor({
+    chainId: initialChainId,
+    getNetworkClientById,
+    onPreferencesStateChange,
+    onNetworkStateChange,
+    getOpenSeaApiKey,
+    addNft,
+    getNftApi,
+    getNftState
+  }, config, state) {
+    super(config, state);
+    /**
+     * Name of this controller used during composition
+     */
+    this.name = "NftDetectionController";
+    /**
+     * Checks whether network is mainnet or not.
+     *
+     * @returns Whether current network is mainnet.
+     */
+    this.isMainnet = () => this.config.chainId === _controllerutils.ChainId.mainnet;
+    this.isMainnetByNetworkClientId = (networkClient) => {
+      return networkClient.configuration.chainId === _controllerutils.ChainId.mainnet;
+    };
+    this.defaultConfig = {
+      interval: DEFAULT_INTERVAL,
+      chainId: initialChainId,
+      selectedAddress: "",
+      disabled: true
+    };
+    this.initialize();
+    this.getNftState = getNftState;
+    this.getNetworkClientById = getNetworkClientById;
+    onPreferencesStateChange(({ selectedAddress, useNftDetection }) => {
+      const { selectedAddress: previouslySelectedAddress, disabled } = this.config;
+      if (selectedAddress !== previouslySelectedAddress || !useNftDetection !== disabled) {
+        this.configure({ selectedAddress, disabled: !useNftDetection });
+        if (useNftDetection) {
+          this.start();
+        } else {
+          this.stop();
+        }
+      }
+    });
+    onNetworkStateChange(({ providerConfig }) => {
+      this.configure({
+        chainId: providerConfig.chainId
+      });
+    });
+    this.getOpenSeaApiKey = getOpenSeaApiKey;
+    this.addNft = addNft;
+    this.getNftApi = getNftApi;
+    this.setIntervalLength(this.config.interval);
+  }
+  getOwnerNftApi({
+    address,
+    next
+  }) {
+    return `${_controllerutils.OPENSEA_PROXY_URL}/chain/${"ethereum" /* ethereum */}/account/${address}/nfts?limit=200&next=${next ?? ""}`;
+  }
+  async getOwnerNfts(address) {
+    let nftApiResponse;
+    let nfts = [];
+    let next;
+    do {
+      nftApiResponse = await _controllerutils.fetchWithErrorHandling.call(void 0, {
+        url: this.getOwnerNftApi({ address, next }),
+        timeout: 15e3
+      });
+      if (!nftApiResponse) {
+        return nfts;
+      }
+      const newNfts = await Promise.all(
+        nftApiResponse.nfts.map(async (nftV2) => {
+          const nftV1 = _chunkRELRWIJNjs.mapOpenSeaNftV2ToV1.call(void 0, nftV2);
+          if (!nftV1.image_url && nftV2.metadata_url) {
+            const nftDetails = await _controllerutils.safelyExecute.call(void 0, 
+              () => _controllerutils.timeoutFetch.call(void 0, 
+                this.getNftApi({
+                  contractAddress: nftV2.contract,
+                  tokenId: nftV2.identifier
+                }),
+                void 0,
+                1e3
+              ).then((r) => r.json())
+            );
+            nftV1.image_original_url = nftDetails?.nft?.image_url ?? null;
+          }
+          return nftV1;
+        })
+      );
+      nfts = [...nfts, ...newNfts];
+    } while (next = nftApiResponse.next);
+    return nfts;
+  }
+  async _executePoll(networkClientId, options) {
+    await this.detectNfts({ networkClientId, userAddress: options.address });
+  }
+  /**
+   * Start polling for the currency rate.
+   */
+  async start() {
+    if (!this.isMainnet() || this.disabled) {
+      return;
+    }
+    await this.startPolling();
+  }
+  /**
+   * Stop polling for the currency rate.
+   */
+  stop() {
+    this.stopPolling();
+  }
+  stopPolling() {
+    if (this.intervalId) {
+      clearInterval(this.intervalId);
+    }
+  }
+  /**
+   * Starts a new polling interval.
+   *
+   * @param interval - An interval on which to poll.
+   */
+  async startPolling(interval) {
+    interval && this.configure({ interval }, false, false);
+    this.stopPolling();
+    await this.detectNfts();
+    this.intervalId = setInterval(async () => {
+      await this.detectNfts();
+    }, this.config.interval);
+  }
+  /**
+   * Triggers asset ERC721 token auto detection on mainnet. Any newly detected NFTs are
+   * added.
+   *
+   * @param options - Options bag.
+   * @param options.networkClientId - The network client ID to detect NFTs on.
+   * @param options.userAddress - The address to detect NFTs for.
+   */
+  async detectNfts({
+    networkClientId,
+    userAddress
+  } = { userAddress: this.config.selectedAddress }) {
+    if (!this.isMainnet() || this.disabled) {
+      return;
+    }
+    if (!userAddress) {
+      return;
+    }
+    const apiNfts = await this.getOwnerNfts(userAddress);
+    const addNftPromises = apiNfts.map(async (nft) => {
+      const {
+        token_id,
+        num_sales,
+        background_color,
+        image_url,
+        image_preview_url,
+        image_thumbnail_url,
+        image_original_url,
+        animation_url,
+        animation_original_url,
+        name,
+        description,
+        external_link,
+        creator,
+        asset_contract: { address, schema_name },
+        last_sale
+      } = nft;
+      let ignored;
+      const { ignoredNfts } = this.getNftState();
+      if (ignoredNfts.length) {
+        ignored = ignoredNfts.find((c) => {
+          return c.address === _controllerutils.toChecksumHexAddress.call(void 0, address) && c.tokenId === token_id;
+        });
+      }
+      if (!ignored) {
+        const nftMetadata = Object.assign(
+          {},
+          { name },
+          creator && { creator },
+          description && { description },
+          image_url && { image: image_url },
+          num_sales && { numberOfSales: num_sales },
+          background_color && { backgroundColor: background_color },
+          image_preview_url && { imagePreview: image_preview_url },
+          image_thumbnail_url && { imageThumbnail: image_thumbnail_url },
+          image_original_url && { imageOriginal: image_original_url },
+          animation_url && { animation: animation_url },
+          animation_original_url && {
+            animationOriginal: animation_original_url
+          },
+          schema_name && { standard: schema_name },
+          external_link && { externalLink: external_link },
+          last_sale && { lastSale: last_sale }
+        );
+        await this.addNft(address, token_id, {
+          nftMetadata,
+          userAddress,
+          source: "detected" /* Detected */,
+          networkClientId
+        });
+      }
+    });
+    await Promise.all(addNftPromises);
+  }
+};
+var NftDetectionController_default = NftDetectionController;
+
+
+
+
+exports.NftDetectionController = NftDetectionController; exports.NftDetectionController_default = NftDetectionController_default;
+//# sourceMappingURL=chunk-WSOHBBCO.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-WSOHBBCO.js.map b/node_modules/@metamask/assets-controllers/dist/chunk-WSOHBBCO.js.map
new file mode 100644
index 0000000..7ebdb95
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-WSOHBBCO.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/NftDetectionController.ts"],"names":[],"mappings":"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","sourcesContent":["import type { BaseConfig, BaseState } from '@metamask/base-controller';\nimport {\n  OPENSEA_PROXY_URL,\n  fetchWithErrorHandling,\n  toChecksumHexAddress,\n  ChainId,\n  timeoutFetch,\n  safelyExecute,\n} from '@metamask/controller-utils';\nimport type {\n  NetworkClientId,\n  NetworkController,\n  NetworkState,\n  NetworkClient,\n} from '@metamask/network-controller';\nimport { StaticIntervalPollingControllerV1 } from '@metamask/polling-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport type { Hex } from '@metamask/utils';\n\nimport { mapOpenSeaNftV2ToV1 } from './assetsUtil';\nimport { Source } from './constants';\nimport type { OpenSeaV2GetNftResponse } from './NftController';\nimport {\n  type NftController,\n  type NftState,\n  type NftMetadata,\n  type OpenSeaV2ListNftsResponse,\n  OpenSeaV2ChainIds,\n} from './NftController';\n\nconst DEFAULT_INTERVAL = 180000;\n\n/**\n * @type ApiNft\n *\n * NFT object coming from OpenSea api\n * @property token_id - The NFT identifier\n * @property num_sales - Number of sales\n * @property background_color - The background color to be displayed with the item\n * @property image_url - URI of an image associated with this NFT\n * @property image_preview_url - URI of a smaller image associated with this NFT\n * @property image_thumbnail_url - URI of a thumbnail image associated with this NFT\n * @property image_original_url - URI of the original image associated with this NFT\n * @property animation_url - URI of a animation associated with this NFT\n * @property animation_original_url - URI of the original animation associated with this NFT\n * @property name - The NFT name\n * @property description - The NFT description\n * @property external_link - External link containing additional information\n * @property assetContract - The NFT contract information object\n * @property creator - The NFT owner information object\n * @property lastSale - When this item was last sold\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface ApiNft {\n  token_id: string;\n  num_sales: number | null;\n  background_color: string | null;\n  image_url: string | null;\n  image_preview_url: string | null;\n  image_thumbnail_url: string | null;\n  image_original_url: string | null;\n  animation_url: string | null;\n  animation_original_url: string | null;\n  name: string | null;\n  description: string | null;\n  external_link: string | null;\n  asset_contract: ApiNftContract;\n  creator: ApiNftCreator;\n  last_sale: ApiNftLastSale | null;\n}\n\n/**\n * @type ApiNftContract\n *\n * NFT contract object coming from OpenSea api\n * @property address - Address of the NFT contract\n * @property asset_contract_type - The NFT type, it could be `semi-fungible` or `non-fungible`\n * @property created_date - Creation date\n * @property collection - Object containing the contract name and URI of an image associated\n * @property schema_name - The schema followed by the contract, it could be `ERC721` or `ERC1155`\n * @property symbol - The NFT contract symbol\n * @property total_supply - Total supply of NFTs\n * @property description - The NFT contract description\n * @property external_link - External link containing additional information\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface ApiNftContract {\n  address: string;\n  asset_contract_type: string | null;\n  created_date: string | null;\n  schema_name: string | null;\n  symbol: string | null;\n  total_supply: string | null;\n  description: string | null;\n  external_link: string | null;\n  collection: {\n    name: string | null;\n    image_url?: string | null;\n  };\n}\n\n/**\n * @type ApiNftLastSale\n *\n * NFT sale object coming from OpenSea api\n * @property event_timestamp - Object containing a `username`\n * @property total_price - URI of NFT image associated with this owner\n * @property transaction - Object containing transaction_hash and block_hash\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface ApiNftLastSale {\n  event_timestamp: string;\n  total_price: string;\n  transaction: { transaction_hash: string; block_hash: string };\n}\n\n/**\n * @type ApiNftCreator\n *\n * NFT creator object coming from OpenSea api\n * @property user - Object containing a `username`\n * @property profile_img_url - URI of NFT image associated with this owner\n * @property address - The owner address\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface ApiNftCreator {\n  user: { username: string };\n  profile_img_url: string;\n  address: string;\n}\n\n/**\n * @type NftDetectionConfig\n *\n * NftDetection configuration\n * @property interval - Polling interval used to fetch new token rates\n * @property chainId - Current chain ID\n * @property selectedAddress - Vault selected address\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface NftDetectionConfig extends BaseConfig {\n  interval: number;\n  chainId: Hex;\n  selectedAddress: string;\n}\n\n/**\n * Controller that passively polls on a set interval for NFT auto detection\n */\nexport class NftDetectionController extends StaticIntervalPollingControllerV1<\n  NftDetectionConfig,\n  BaseState\n> {\n  private intervalId?: ReturnType<typeof setTimeout>;\n\n  private getOwnerNftApi({\n    address,\n    next,\n  }: {\n    address: string;\n    next?: string;\n  }) {\n    return `${OPENSEA_PROXY_URL}/chain/${\n      OpenSeaV2ChainIds.ethereum\n    }/account/${address}/nfts?limit=200&next=${next ?? ''}`;\n  }\n\n  private async getOwnerNfts(address: string) {\n    let nftApiResponse: OpenSeaV2ListNftsResponse;\n    let nfts: ApiNft[] = [];\n    let next;\n\n    do {\n      nftApiResponse = await fetchWithErrorHandling({\n        url: this.getOwnerNftApi({ address, next }),\n        timeout: 15000,\n      });\n\n      if (!nftApiResponse) {\n        return nfts;\n      }\n\n      const newNfts = await Promise.all(\n        nftApiResponse.nfts.map(async (nftV2) => {\n          const nftV1 = mapOpenSeaNftV2ToV1(nftV2);\n\n          // If the image hasn't been processed into OpenSea's CDN, the image_url will be null.\n          // Try fetching the NFT individually, which returns the original image url from metadata if available.\n          if (!nftV1.image_url && nftV2.metadata_url) {\n            const nftDetails: OpenSeaV2GetNftResponse | undefined =\n              await safelyExecute(() =>\n                timeoutFetch(\n                  this.getNftApi({\n                    contractAddress: nftV2.contract,\n                    tokenId: nftV2.identifier,\n                  }),\n                  undefined,\n                  1000,\n                ).then((r) => r.json()),\n              );\n\n            nftV1.image_original_url = nftDetails?.nft?.image_url ?? null;\n          }\n          return nftV1;\n        }),\n      );\n\n      nfts = [...nfts, ...newNfts];\n    } while ((next = nftApiResponse.next));\n\n    return nfts;\n  }\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'NftDetectionController';\n\n  private readonly getOpenSeaApiKey: () => string | undefined;\n\n  private readonly addNft: NftController['addNft'];\n\n  private readonly getNftApi: NftController['getNftApi'];\n\n  private readonly getNftState: () => NftState;\n\n  private readonly getNetworkClientById: NetworkController['getNetworkClientById'];\n\n  /**\n   * Creates an NftDetectionController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.onNftsStateChange - Allows subscribing to assets controller state changes.\n   * @param options.onPreferencesStateChange - Allows subscribing to preferences controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param options.getOpenSeaApiKey - Gets the OpenSea API key, if one is set.\n   * @param options.addNft - Add an NFT.\n   * @param options.getNftApi - Gets the URL to fetch an NFT from OpenSea.\n   * @param options.getNftState - Gets the current state of the Assets controller.\n   * @param options.getNetworkClientById - Gets the network client by ID, from the NetworkController.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      chainId: initialChainId,\n      getNetworkClientById,\n      onPreferencesStateChange,\n      onNetworkStateChange,\n      getOpenSeaApiKey,\n      addNft,\n      getNftApi,\n      getNftState,\n    }: {\n      chainId: Hex;\n      getNetworkClientById: NetworkController['getNetworkClientById'];\n      onNftsStateChange: (listener: (nftsState: NftState) => void) => void;\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      getOpenSeaApiKey: () => string | undefined;\n      addNft: NftController['addNft'];\n      getNftApi: NftController['getNftApi'];\n      getNftState: () => NftState;\n    },\n    config?: Partial<NftDetectionConfig>,\n    state?: Partial<BaseState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      interval: DEFAULT_INTERVAL,\n      chainId: initialChainId,\n      selectedAddress: '',\n      disabled: true,\n    };\n    this.initialize();\n    this.getNftState = getNftState;\n    this.getNetworkClientById = getNetworkClientById;\n    onPreferencesStateChange(({ selectedAddress, useNftDetection }) => {\n      const { selectedAddress: previouslySelectedAddress, disabled } =\n        this.config;\n\n      if (\n        selectedAddress !== previouslySelectedAddress ||\n        !useNftDetection !== disabled\n      ) {\n        this.configure({ selectedAddress, disabled: !useNftDetection });\n        if (useNftDetection) {\n          this.start();\n        } else {\n          this.stop();\n        }\n      }\n    });\n\n    onNetworkStateChange(({ providerConfig }) => {\n      this.configure({\n        chainId: providerConfig.chainId,\n      });\n    });\n    this.getOpenSeaApiKey = getOpenSeaApiKey;\n    this.addNft = addNft;\n    this.getNftApi = getNftApi;\n    this.setIntervalLength(this.config.interval);\n  }\n\n  async _executePoll(\n    networkClientId: string,\n    options: { address: string },\n  ): Promise<void> {\n    await this.detectNfts({ networkClientId, userAddress: options.address });\n  }\n\n  /**\n   * Start polling for the currency rate.\n   */\n  async start() {\n    if (!this.isMainnet() || this.disabled) {\n      return;\n    }\n\n    await this.startPolling();\n  }\n\n  /**\n   * Stop polling for the currency rate.\n   */\n  stop() {\n    this.stopPolling();\n  }\n\n  private stopPolling() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n  }\n\n  /**\n   * Starts a new polling interval.\n   *\n   * @param interval - An interval on which to poll.\n   */\n  private async startPolling(interval?: number): Promise<void> {\n    interval && this.configure({ interval }, false, false);\n    this.stopPolling();\n    await this.detectNfts();\n    this.intervalId = setInterval(async () => {\n      await this.detectNfts();\n    }, this.config.interval);\n  }\n\n  /**\n   * Checks whether network is mainnet or not.\n   *\n   * @returns Whether current network is mainnet.\n   */\n  isMainnet = (): boolean => this.config.chainId === ChainId.mainnet;\n\n  isMainnetByNetworkClientId = (networkClient: NetworkClient): boolean => {\n    return networkClient.configuration.chainId === ChainId.mainnet;\n  };\n\n  /**\n   * Triggers asset ERC721 token auto detection on mainnet. Any newly detected NFTs are\n   * added.\n   *\n   * @param options - Options bag.\n   * @param options.networkClientId - The network client ID to detect NFTs on.\n   * @param options.userAddress - The address to detect NFTs for.\n   */\n  async detectNfts(\n    {\n      networkClientId,\n      userAddress,\n    }: {\n      networkClientId?: NetworkClientId;\n      userAddress: string;\n    } = { userAddress: this.config.selectedAddress },\n  ) {\n    /* istanbul ignore if */\n    if (!this.isMainnet() || this.disabled) {\n      return;\n    }\n    /* istanbul ignore else */\n    if (!userAddress) {\n      return;\n    }\n\n    const apiNfts = await this.getOwnerNfts(userAddress);\n    const addNftPromises = apiNfts.map(async (nft: ApiNft) => {\n      const {\n        token_id,\n        num_sales,\n        background_color,\n        image_url,\n        image_preview_url,\n        image_thumbnail_url,\n        image_original_url,\n        animation_url,\n        animation_original_url,\n        name,\n        description,\n        external_link,\n        creator,\n        asset_contract: { address, schema_name },\n        last_sale,\n      } = nft;\n\n      let ignored;\n      /* istanbul ignore else */\n      const { ignoredNfts } = this.getNftState();\n      if (ignoredNfts.length) {\n        ignored = ignoredNfts.find((c) => {\n          /* istanbul ignore next */\n          return (\n            c.address === toChecksumHexAddress(address) &&\n            c.tokenId === token_id\n          );\n        });\n      }\n\n      /* istanbul ignore else */\n      if (!ignored) {\n        /* istanbul ignore next */\n        const nftMetadata: NftMetadata = Object.assign(\n          {},\n          { name },\n          creator && { creator },\n          description && { description },\n          image_url && { image: image_url },\n          num_sales && { numberOfSales: num_sales },\n          background_color && { backgroundColor: background_color },\n          image_preview_url && { imagePreview: image_preview_url },\n          image_thumbnail_url && { imageThumbnail: image_thumbnail_url },\n          image_original_url && { imageOriginal: image_original_url },\n          animation_url && { animation: animation_url },\n          animation_original_url && {\n            animationOriginal: animation_original_url,\n          },\n          schema_name && { standard: schema_name },\n          external_link && { externalLink: external_link },\n          last_sale && { lastSale: last_sale },\n        );\n\n        await this.addNft(address, token_id, {\n          nftMetadata,\n          userAddress,\n          source: Source.Detected,\n          networkClientId,\n        });\n      }\n    });\n    await Promise.all(addNftPromises);\n  }\n}\n\nexport default NftDetectionController;\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-WTG2VMDL.mjs b/node_modules/@metamask/assets-controllers/dist/chunk-WTG2VMDL.mjs
new file mode 100644
index 0000000..29d695d
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-WTG2VMDL.mjs
@@ -0,0 +1,1228 @@
+import {
+  compareNftMetadata,
+  getFormattedIpfsUrl,
+  mapOpenSeaContractV2ToV1,
+  mapOpenSeaDetailedNftV2ToV1
+} from "./chunk-E5PIGGYR.mjs";
+
+// src/NftController.ts
+import { isAddress } from "@ethersproject/address";
+import { BaseControllerV1 } from "@metamask/base-controller";
+import {
+  safelyExecute,
+  handleFetch,
+  toChecksumHexAddress,
+  BNToHex,
+  fetchWithErrorHandling,
+  IPFS_DEFAULT_GATEWAY_URL,
+  ERC721,
+  ERC1155,
+  OPENSEA_PROXY_URL,
+  ApprovalType
+} from "@metamask/controller-utils";
+import { rpcErrors } from "@metamask/rpc-errors";
+import { remove0x } from "@metamask/utils";
+import { Mutex } from "async-mutex";
+import BN from "bn.js";
+import { EventEmitter } from "events";
+import { v4 as random } from "uuid";
+var OpenSeaV2ChainIds = /* @__PURE__ */ ((OpenSeaV2ChainIds2) => {
+  OpenSeaV2ChainIds2["ethereum"] = "ethereum";
+  return OpenSeaV2ChainIds2;
+})(OpenSeaV2ChainIds || {});
+var ALL_NFTS_STATE_KEY = "allNfts";
+var ALL_NFTS_CONTRACTS_STATE_KEY = "allNftContracts";
+var getDefaultNftState = () => {
+  return {
+    allNftContracts: {},
+    allNfts: {},
+    ignoredNfts: []
+  };
+};
+var NftController = class extends BaseControllerV1 {
+  /**
+   * Creates an NftController instance.
+   *
+   * @param options - The controller options.
+   * @param options.chainId - The chain ID of the current network.
+   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.
+   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.
+   * @param options.getERC721AssetName - Gets the name of the asset at the given address.
+   * @param options.getERC721AssetSymbol - Gets the symbol of the asset at the given address.
+   * @param options.getERC721TokenURI - Gets the URI of the ERC721 token at the given address, with the given ID.
+   * @param options.getERC721OwnerOf - Get the owner of a ERC-721 NFT.
+   * @param options.getERC1155BalanceOf - Gets balance of a ERC-1155 NFT.
+   * @param options.getERC1155TokenURI - Gets the URI of the ERC1155 token at the given address, with the given ID.
+   * @param options.getNetworkClientById - Gets the network client for the given networkClientId.
+   * @param options.onNftAdded - Callback that is called when an NFT is added. Currently used pass data
+   * for tracking the NFT added event.
+   * @param options.messenger - The controller messenger.
+   * @param config - Initial options used to configure this controller.
+   * @param state - Initial state to set on this controller.
+   */
+  constructor({
+    chainId: initialChainId,
+    onPreferencesStateChange,
+    onNetworkStateChange,
+    getERC721AssetName,
+    getERC721AssetSymbol,
+    getERC721TokenURI,
+    getERC721OwnerOf,
+    getERC1155BalanceOf,
+    getERC1155TokenURI,
+    getNetworkClientById,
+    onNftAdded,
+    messenger
+  }, config, state) {
+    super(config, state);
+    this.mutex = new Mutex();
+    /**
+     * EventEmitter instance used to listen to specific EIP747 events
+     */
+    this.hub = new EventEmitter();
+    /**
+     * Name of this controller used during composition
+     */
+    this.name = "NftController";
+    this.defaultConfig = {
+      selectedAddress: "",
+      chainId: initialChainId,
+      ipfsGateway: IPFS_DEFAULT_GATEWAY_URL,
+      openSeaEnabled: false,
+      useIPFSSubdomains: true,
+      isIpfsGatewayEnabled: true
+    };
+    this.defaultState = getDefaultNftState();
+    this.initialize();
+    this.getERC721AssetName = getERC721AssetName;
+    this.getERC721AssetSymbol = getERC721AssetSymbol;
+    this.getERC721TokenURI = getERC721TokenURI;
+    this.getERC721OwnerOf = getERC721OwnerOf;
+    this.getERC1155BalanceOf = getERC1155BalanceOf;
+    this.getERC1155TokenURI = getERC1155TokenURI;
+    this.getNetworkClientById = getNetworkClientById;
+    this.onNftAdded = onNftAdded;
+    this.messagingSystem = messenger;
+    onPreferencesStateChange(
+      ({
+        selectedAddress,
+        ipfsGateway,
+        openSeaEnabled,
+        isIpfsGatewayEnabled
+      }) => {
+        this.configure({
+          selectedAddress,
+          ipfsGateway,
+          openSeaEnabled,
+          isIpfsGatewayEnabled
+        });
+        const needsUpdateNftMetadata = isIpfsGatewayEnabled && ipfsGateway !== "" || openSeaEnabled;
+        if (needsUpdateNftMetadata) {
+          this.updateNftMetadata({ userAddress: selectedAddress });
+        }
+      }
+    );
+    onNetworkStateChange(({ providerConfig }) => {
+      const { chainId } = providerConfig;
+      this.configure({ chainId });
+    });
+  }
+  getNftApi({
+    contractAddress,
+    tokenId
+  }) {
+    return `${OPENSEA_PROXY_URL}/chain/${"ethereum" /* ethereum */}/contract/${contractAddress}/nfts/${tokenId}`;
+  }
+  getNftContractInformationApi({
+    contractAddress
+  }) {
+    return `${OPENSEA_PROXY_URL}/chain/${"ethereum" /* ethereum */}/contract/${contractAddress}`;
+  }
+  getNftCollectionInformationApi({
+    collectionSlug
+  }) {
+    return `${OPENSEA_PROXY_URL}/collections/${collectionSlug}`;
+  }
+  /**
+   * Helper method to update nested state for allNfts and allNftContracts.
+   *
+   * @param newCollection - the modified piece of state to update in the controller's store
+   * @param baseStateKey - The root key in the store to update.
+   * @param passedConfig - An object containing the selectedAddress and chainId that are passed through the auto-detection flow.
+   * @param passedConfig.userAddress - the address passed through the NFT detection flow to ensure assets are stored to the correct account
+   * @param passedConfig.chainId - the chainId passed through the NFT detection flow to ensure assets are stored to the correct account
+   */
+  updateNestedNftState(newCollection, baseStateKey, { userAddress, chainId }) {
+    const { [baseStateKey]: oldState } = this.state;
+    const addressState = oldState[userAddress];
+    const newAddressState = {
+      ...addressState,
+      ...{ [chainId]: newCollection }
+    };
+    const newState = {
+      ...oldState,
+      ...{ [userAddress]: newAddressState }
+    };
+    this.update({
+      [baseStateKey]: newState
+    });
+  }
+  /**
+   * Request individual NFT information from OpenSea API.
+   *
+   * @param contractAddress - Hex address of the NFT contract.
+   * @param tokenId - The NFT identifier.
+   * @returns Promise resolving to the current NFT name and image.
+   */
+  async getNftInformationFromApi(contractAddress, tokenId) {
+    const nftInformation = await fetchWithErrorHandling({
+      url: this.getNftApi({
+        contractAddress,
+        tokenId
+      })
+    });
+    if (!nftInformation?.nft) {
+      return {
+        name: null,
+        description: null,
+        image: null,
+        standard: null
+      };
+    }
+    const {
+      num_sales,
+      background_color,
+      image_url,
+      image_preview_url,
+      image_thumbnail_url,
+      image_original_url,
+      animation_url,
+      animation_original_url,
+      name,
+      description,
+      external_link,
+      creator,
+      last_sale,
+      asset_contract: { schema_name }
+    } = mapOpenSeaDetailedNftV2ToV1(nftInformation.nft);
+    const nftMetadata = Object.assign(
+      {},
+      { name: name || null },
+      { description: description || null },
+      { image: image_url || null },
+      creator && { creator },
+      num_sales && { numberOfSales: num_sales },
+      background_color && { backgroundColor: background_color },
+      image_preview_url && { imagePreview: image_preview_url },
+      image_thumbnail_url && { imageThumbnail: image_thumbnail_url },
+      image_original_url && { imageOriginal: image_original_url },
+      animation_url && { animation: animation_url },
+      animation_original_url && {
+        animationOriginal: animation_original_url
+      },
+      external_link && { externalLink: external_link },
+      last_sale && { lastSale: last_sale },
+      schema_name && { standard: schema_name }
+    );
+    return nftMetadata;
+  }
+  /**
+   * Request individual NFT information from contracts that follows Metadata Interface.
+   *
+   * @param contractAddress - Hex address of the NFT contract.
+   * @param tokenId - The NFT identifier.
+   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @returns Promise resolving to the current NFT name and image.
+   */
+  async getNftInformationFromTokenURI(contractAddress, tokenId, networkClientId) {
+    const { ipfsGateway, useIPFSSubdomains, isIpfsGatewayEnabled } = this.config;
+    const result = await this.getNftURIAndStandard(
+      contractAddress,
+      tokenId,
+      networkClientId
+    );
+    let tokenURI = result[0];
+    const standard = result[1];
+    const hasIpfsTokenURI = tokenURI.startsWith("ipfs://");
+    if (hasIpfsTokenURI && !isIpfsGatewayEnabled) {
+      return {
+        image: null,
+        name: null,
+        description: null,
+        standard: standard || null,
+        favorite: false,
+        tokenURI: tokenURI ?? null
+      };
+    }
+    const isDisplayNFTMediaToggleEnabled = this.config.openSeaEnabled;
+    if (!hasIpfsTokenURI && !isDisplayNFTMediaToggleEnabled) {
+      return {
+        image: null,
+        name: null,
+        description: null,
+        standard: standard || null,
+        favorite: false,
+        tokenURI: tokenURI ?? null
+      };
+    }
+    if (hasIpfsTokenURI) {
+      tokenURI = getFormattedIpfsUrl(ipfsGateway, tokenURI, useIPFSSubdomains);
+    }
+    try {
+      const object = await handleFetch(tokenURI);
+      const image = Object.prototype.hasOwnProperty.call(object, "image") ? "image" : (
+        /* istanbul ignore next */
+        "image_url"
+      );
+      return {
+        image: object[image],
+        name: object.name,
+        description: object.description,
+        standard,
+        favorite: false,
+        tokenURI: tokenURI ?? null
+      };
+    } catch {
+      return {
+        image: null,
+        name: null,
+        description: null,
+        standard: standard || null,
+        favorite: false,
+        tokenURI: tokenURI ?? null
+      };
+    }
+  }
+  /**
+   * Retrieve NFT uri with  metadata. TODO Update method to use IPFS.
+   *
+   * @param contractAddress - NFT contract address.
+   * @param tokenId - NFT token id.
+   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @returns Promise resolving NFT uri and token standard.
+   */
+  async getNftURIAndStandard(contractAddress, tokenId, networkClientId) {
+    try {
+      const uri = await this.getERC721TokenURI(
+        contractAddress,
+        tokenId,
+        networkClientId
+      );
+      return [uri, ERC721];
+    } catch {
+    }
+    try {
+      const tokenURI = await this.getERC1155TokenURI(
+        contractAddress,
+        tokenId,
+        networkClientId
+      );
+      if (!tokenURI.includes("{id}")) {
+        return [tokenURI, ERC1155];
+      }
+      const hexTokenId = remove0x(BNToHex(new BN(tokenId))).padStart(64, "0").toLowerCase();
+      return [tokenURI.replace("{id}", hexTokenId), ERC1155];
+    } catch {
+    }
+    return ["", ""];
+  }
+  /**
+   * Request individual NFT information (name, image url and description).
+   *
+   * @param contractAddress - Hex address of the NFT contract.
+   * @param tokenId - The NFT identifier.
+   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @returns Promise resolving to the current NFT name and image.
+   */
+  async getNftInformation(contractAddress, tokenId, networkClientId) {
+    const chainId = this.getCorrectChainId({
+      networkClientId
+    });
+    const [blockchainMetadata, openSeaMetadata] = await Promise.all([
+      safelyExecute(
+        () => this.getNftInformationFromTokenURI(
+          contractAddress,
+          tokenId,
+          networkClientId
+        )
+      ),
+      this.config.openSeaEnabled && chainId === "0x1" ? safelyExecute(
+        () => this.getNftInformationFromApi(contractAddress, tokenId)
+      ) : void 0
+    ]);
+    return {
+      ...openSeaMetadata,
+      name: blockchainMetadata?.name ?? openSeaMetadata?.name ?? null,
+      description: blockchainMetadata?.description ?? openSeaMetadata?.description ?? null,
+      image: blockchainMetadata?.image ?? openSeaMetadata?.image ?? null,
+      standard: blockchainMetadata?.standard ?? openSeaMetadata?.standard ?? null,
+      tokenURI: blockchainMetadata?.tokenURI ?? null
+    };
+  }
+  /**
+   * Request NFT contract information from OpenSea API.
+   *
+   * @param contractAddress - Hex address of the NFT contract.
+   * @returns Promise resolving to the current NFT name and image.
+   */
+  async getNftContractInformationFromApi(contractAddress) {
+    const apiNftContractObject = await fetchWithErrorHandling({
+      url: this.getNftContractInformationApi({
+        contractAddress
+      })
+    });
+    if (apiNftContractObject) {
+      const collection = await fetchWithErrorHandling({
+        url: this.getNftCollectionInformationApi({
+          collectionSlug: apiNftContractObject.collection
+        })
+      });
+      return mapOpenSeaContractV2ToV1(apiNftContractObject, collection);
+    }
+    return {
+      address: contractAddress,
+      asset_contract_type: null,
+      created_date: null,
+      schema_name: null,
+      symbol: null,
+      total_supply: null,
+      description: null,
+      external_link: null,
+      collection: {
+        name: null,
+        image_url: null
+      }
+    };
+  }
+  /**
+   * Request NFT contract information from the contract itself.
+   *
+   * @param contractAddress - Hex address of the NFT contract.
+   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @returns Promise resolving to the current NFT name and image.
+   */
+  async getNftContractInformationFromContract(contractAddress, networkClientId) {
+    const [name, symbol] = await Promise.all([
+      this.getERC721AssetName(contractAddress, networkClientId),
+      this.getERC721AssetSymbol(contractAddress, networkClientId)
+    ]);
+    return {
+      collection: { name },
+      symbol,
+      address: contractAddress
+    };
+  }
+  /**
+   * Request NFT contract information from OpenSea API.
+   *
+   * @param contractAddress - Hex address of the NFT contract.
+   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @returns Promise resolving to the NFT contract name, image and description.
+   */
+  async getNftContractInformation(contractAddress, networkClientId) {
+    const chainId = this.getCorrectChainId({
+      networkClientId
+    });
+    const [blockchainContractData, openSeaContractData] = await Promise.all([
+      safelyExecute(
+        () => this.getNftContractInformationFromContract(
+          contractAddress,
+          networkClientId
+        )
+      ),
+      this.config.openSeaEnabled && chainId === "0x1" ? safelyExecute(
+        () => this.getNftContractInformationFromApi(contractAddress)
+      ) : void 0
+    ]);
+    if (blockchainContractData || openSeaContractData) {
+      return {
+        address: contractAddress,
+        ...openSeaContractData,
+        ...blockchainContractData,
+        collection: {
+          name: null,
+          image_url: null,
+          ...openSeaContractData?.collection,
+          ...blockchainContractData?.collection
+        }
+      };
+    }
+    return {
+      address: contractAddress,
+      asset_contract_type: null,
+      created_date: null,
+      schema_name: null,
+      symbol: null,
+      total_supply: null,
+      description: null,
+      external_link: null,
+      collection: { name: null, image_url: null }
+    };
+  }
+  /**
+   * Adds an individual NFT to the stored NFT list.
+   *
+   * @param tokenAddress - Hex address of the NFT contract.
+   * @param tokenId - The NFT identifier.
+   * @param nftMetadata - NFT optional information (name, image and description).
+   * @param nftContract - An object containing contract data of the NFT being added.
+   * @param chainId - The chainId of the network where the NFT is being added.
+   * @param userAddress - The address of the account where the NFT is being added.
+   * @param source - Whether the NFT was detected, added manually or suggested by a dapp.
+   * @returns Promise resolving to the current NFT list.
+   */
+  async addIndividualNft(tokenAddress, tokenId, nftMetadata, nftContract, chainId, userAddress, source) {
+    const releaseLock = await this.mutex.acquire();
+    try {
+      tokenAddress = toChecksumHexAddress(tokenAddress);
+      const { allNfts } = this.state;
+      const nfts = allNfts[userAddress]?.[chainId] || [];
+      const existingEntry = nfts.find(
+        (nft) => nft.address.toLowerCase() === tokenAddress.toLowerCase() && nft.tokenId === tokenId
+      );
+      if (existingEntry) {
+        const differentMetadata = compareNftMetadata(
+          nftMetadata,
+          existingEntry
+        );
+        if (differentMetadata || !existingEntry.isCurrentlyOwned) {
+          const indexToRemove = nfts.findIndex(
+            (nft) => nft.address.toLowerCase() === tokenAddress.toLowerCase() && nft.tokenId === tokenId
+          );
+          if (indexToRemove !== -1) {
+            nfts.splice(indexToRemove, 1);
+          }
+        } else {
+          return nfts;
+        }
+      }
+      const newEntry = {
+        address: tokenAddress,
+        tokenId,
+        favorite: existingEntry?.favorite || false,
+        isCurrentlyOwned: true,
+        ...nftMetadata
+      };
+      const newNfts = [...nfts, newEntry];
+      this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {
+        chainId,
+        userAddress
+      });
+      if (this.onNftAdded) {
+        this.onNftAdded({
+          address: tokenAddress,
+          symbol: nftContract.symbol,
+          tokenId: tokenId.toString(),
+          standard: nftMetadata.standard,
+          source
+        });
+      }
+      return newNfts;
+    } finally {
+      releaseLock();
+    }
+  }
+  /**
+   * Adds an NFT contract to the stored NFT contracts list.
+   *
+   * @param options - options.
+   * @param options.tokenAddress - Hex address of the NFT contract.
+   * @param options.userAddress - The address of the account where the NFT is being added.
+   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.
+   * @returns Promise resolving to the current NFT contracts list.
+   */
+  async addNftContract({
+    tokenAddress,
+    userAddress,
+    networkClientId,
+    source
+  }) {
+    const releaseLock = await this.mutex.acquire();
+    try {
+      tokenAddress = toChecksumHexAddress(tokenAddress);
+      const { allNftContracts } = this.state;
+      const chainId = this.getCorrectChainId({
+        networkClientId
+      });
+      const nftContracts = allNftContracts[userAddress]?.[chainId] || [];
+      const existingEntry = nftContracts.find(
+        (nftContract) => nftContract.address.toLowerCase() === tokenAddress.toLowerCase()
+      );
+      if (existingEntry) {
+        return nftContracts;
+      }
+      const contractInformation = await this.getNftContractInformation(
+        tokenAddress,
+        networkClientId
+      );
+      const {
+        asset_contract_type,
+        created_date,
+        schema_name,
+        symbol,
+        total_supply,
+        description,
+        external_link,
+        collection: { name, image_url }
+      } = contractInformation;
+      if (source === "detected" /* Detected */ && "address" in contractInformation && typeof contractInformation.address === "string" && "collection" in contractInformation && contractInformation.collection.name === null && "image_url" in contractInformation.collection && contractInformation.collection.image_url === null && Object.entries(contractInformation).every(([key, value]) => {
+        return key === "address" || key === "collection" || !value;
+      })) {
+        return nftContracts;
+      }
+      const newEntry = Object.assign(
+        {},
+        { address: tokenAddress },
+        description && { description },
+        name && { name },
+        image_url && { logo: image_url },
+        symbol && { symbol },
+        total_supply !== null && typeof total_supply !== "undefined" && { totalSupply: total_supply },
+        asset_contract_type && { assetContractType: asset_contract_type },
+        created_date && { createdDate: created_date },
+        schema_name && { schemaName: schema_name },
+        external_link && { externalLink: external_link }
+      );
+      const newNftContracts = [...nftContracts, newEntry];
+      this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY, {
+        chainId,
+        userAddress
+      });
+      return newNftContracts;
+    } finally {
+      releaseLock();
+    }
+  }
+  /**
+   * Removes an individual NFT from the stored token list and saves it in ignored NFTs list.
+   *
+   * @param address - Hex address of the NFT contract.
+   * @param tokenId - Token identifier of the NFT.
+   * @param options - options.
+   * @param options.chainId - The chainId of the network where the NFT is being removed.
+   * @param options.userAddress - The address of the account where the NFT is being removed.
+   */
+  removeAndIgnoreIndividualNft(address, tokenId, {
+    chainId,
+    userAddress
+  }) {
+    address = toChecksumHexAddress(address);
+    const { allNfts, ignoredNfts } = this.state;
+    const newIgnoredNfts = [...ignoredNfts];
+    const nfts = allNfts[userAddress]?.[chainId] || [];
+    const newNfts = nfts.filter((nft) => {
+      if (nft.address.toLowerCase() === address.toLowerCase() && nft.tokenId === tokenId) {
+        const alreadyIgnored = newIgnoredNfts.find(
+          (c) => c.address === address && c.tokenId === tokenId
+        );
+        !alreadyIgnored && newIgnoredNfts.push(nft);
+        return false;
+      }
+      return true;
+    });
+    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {
+      userAddress,
+      chainId
+    });
+    this.update({
+      ignoredNfts: newIgnoredNfts
+    });
+  }
+  /**
+   * Removes an individual NFT from the stored token list.
+   *
+   * @param address - Hex address of the NFT contract.
+   * @param tokenId - Token identifier of the NFT.
+   * @param options - options.
+   * @param options.chainId - The chainId of the network where the NFT is being removed.
+   * @param options.userAddress - The address of the account where the NFT is being removed.
+   */
+  removeIndividualNft(address, tokenId, { chainId, userAddress }) {
+    address = toChecksumHexAddress(address);
+    const { allNfts } = this.state;
+    const nfts = allNfts[userAddress]?.[chainId] || [];
+    const newNfts = nfts.filter(
+      (nft) => !(nft.address.toLowerCase() === address.toLowerCase() && nft.tokenId === tokenId)
+    );
+    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {
+      userAddress,
+      chainId
+    });
+  }
+  /**
+   * Removes an NFT contract to the stored NFT contracts list.
+   *
+   * @param address - Hex address of the NFT contract.
+   * @param options - options.
+   * @param options.chainId - The chainId of the network where the NFT is being removed.
+   * @param options.userAddress - The address of the account where the NFT is being removed.
+   * @returns Promise resolving to the current NFT contracts list.
+   */
+  removeNftContract(address, { chainId, userAddress }) {
+    address = toChecksumHexAddress(address);
+    const { allNftContracts } = this.state;
+    const nftContracts = allNftContracts[userAddress]?.[chainId] || [];
+    const newNftContracts = nftContracts.filter(
+      (nftContract) => !(nftContract.address.toLowerCase() === address.toLowerCase())
+    );
+    this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY, {
+      chainId,
+      userAddress
+    });
+    return newNftContracts;
+  }
+  async validateWatchNft(asset, type, userAddress, { networkClientId } = {}) {
+    const { address: contractAddress, tokenId } = asset;
+    if (!type) {
+      throw rpcErrors.invalidParams("Asset type is required");
+    }
+    if (type !== ERC721 && type !== ERC1155) {
+      throw rpcErrors.invalidParams(
+        `Non NFT asset type ${type} not supported by watchNft`
+      );
+    }
+    if (!contractAddress || !tokenId) {
+      throw rpcErrors.invalidParams("Both address and tokenId are required");
+    }
+    if (!isAddress(contractAddress)) {
+      throw rpcErrors.invalidParams("Invalid address");
+    }
+    if (!/^\d+$/u.test(tokenId)) {
+      throw rpcErrors.invalidParams("Invalid tokenId");
+    }
+    try {
+      const isOwner = await this.isNftOwner(
+        userAddress,
+        contractAddress,
+        tokenId,
+        { networkClientId }
+      );
+      if (!isOwner) {
+        throw rpcErrors.invalidInput(
+          "Suggested NFT is not owned by the selected account"
+        );
+      }
+    } catch (error) {
+      if (error instanceof Error) {
+        throw rpcErrors.resourceUnavailable(error.message);
+      }
+      throw error;
+    }
+  }
+  // temporary method to get the correct chainId until we remove chainId from the config & the chainId arg from the detection logic
+  // Just a helper method to prefer the networkClient chainId first then the chainId argument and then finally the config chainId
+  getCorrectChainId({
+    networkClientId
+  }) {
+    if (networkClientId) {
+      return this.getNetworkClientById(networkClientId).configuration.chainId;
+    }
+    return this.config.chainId;
+  }
+  /**
+   * Adds a new suggestedAsset to state. Parameters will be validated according to
+   * asset type being watched. A `<suggestedNftMeta.id>:pending` hub event will be emitted once added.
+   *
+   * @param asset - The asset to be watched. For now ERC721 and ERC1155 tokens are accepted.
+   * @param asset.address - The address of the asset contract.
+   * @param asset.tokenId - The ID of the asset.
+   * @param type - The asset type.
+   * @param origin - Domain origin to register the asset from.
+   * @param options - Options bag.
+   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @param options.userAddress - The address of the account where the NFT is being added.
+   * @returns Object containing a Promise resolving to the suggestedAsset address if accepted.
+   */
+  async watchNft(asset, type, origin, {
+    networkClientId,
+    userAddress = this.config.selectedAddress
+  } = {
+    userAddress: this.config.selectedAddress
+  }) {
+    await this.validateWatchNft(asset, type, userAddress);
+    const nftMetadata = await this.getNftInformation(
+      asset.address,
+      asset.tokenId,
+      networkClientId
+    );
+    if (nftMetadata.standard && nftMetadata.standard !== type) {
+      throw rpcErrors.invalidInput(
+        `Suggested NFT of type ${nftMetadata.standard} does not match received type ${type}`
+      );
+    }
+    const suggestedNftMeta = {
+      asset: { ...asset, ...nftMetadata },
+      type,
+      id: random(),
+      time: Date.now(),
+      interactingAddress: userAddress,
+      origin
+    };
+    await this._requestApproval(suggestedNftMeta);
+    const { address, tokenId } = asset;
+    const { name, standard, description, image } = nftMetadata;
+    await this.addNft(address, tokenId, {
+      nftMetadata: {
+        name: name ?? null,
+        description: description ?? null,
+        image: image ?? null,
+        standard: standard ?? null
+      },
+      userAddress,
+      source: "dapp" /* Dapp */,
+      networkClientId
+    });
+  }
+  /**
+   * Sets an OpenSea API key to retrieve NFT information.
+   *
+   * @param openSeaApiKey - OpenSea API key.
+   */
+  setApiKey(openSeaApiKey) {
+    this.openSeaApiKey = openSeaApiKey;
+  }
+  /**
+   * Checks the ownership of a ERC-721 or ERC-1155 NFT for a given address.
+   *
+   * @param ownerAddress - User public address.
+   * @param nftAddress - NFT contract address.
+   * @param tokenId - NFT token ID.
+   * @param options - Options bag.
+   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @returns Promise resolving the NFT ownership.
+   */
+  async isNftOwner(ownerAddress, nftAddress, tokenId, {
+    networkClientId
+  } = {}) {
+    try {
+      const owner = await this.getERC721OwnerOf(
+        nftAddress,
+        tokenId,
+        networkClientId
+      );
+      return ownerAddress.toLowerCase() === owner.toLowerCase();
+    } catch {
+    }
+    try {
+      const balance = await this.getERC1155BalanceOf(
+        ownerAddress,
+        nftAddress,
+        tokenId,
+        networkClientId
+      );
+      return !balance.isZero();
+    } catch {
+    }
+    throw new Error(
+      `Unable to verify ownership. Possibly because the standard is not supported or the user's currently selected network does not match the chain of the asset in question.`
+    );
+  }
+  /**
+   * Verifies currently selected address owns entered NFT address/tokenId combo and
+   * adds the NFT and respective NFT contract to the stored NFT and NFT contracts lists.
+   *
+   * @param address - Hex address of the NFT contract.
+   * @param tokenId - The NFT identifier.
+   * @param options - an object of arguments
+   * @param options.userAddress - The address of the current user.
+   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.
+   */
+  async addNftVerifyOwnership(address, tokenId, {
+    userAddress = this.config.selectedAddress,
+    networkClientId,
+    source
+  } = {
+    userAddress: this.config.selectedAddress
+  }) {
+    if (!await this.isNftOwner(userAddress, address, tokenId, {
+      networkClientId
+    })) {
+      throw new Error("This NFT is not owned by the user");
+    }
+    await this.addNft(address, tokenId, {
+      networkClientId,
+      userAddress,
+      source
+    });
+  }
+  /**
+   * Adds an NFT and respective NFT contract to the stored NFT and NFT contracts lists.
+   *
+   * @param tokenAddress - Hex address of the NFT contract.
+   * @param tokenId - The NFT identifier.
+   * @param options - an object of arguments
+   * @param options.nftMetadata - NFT optional metadata.
+   * @param options.userAddress - The address of the current user.
+   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.
+   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @returns Promise resolving to the current NFT list.
+   */
+  async addNft(tokenAddress, tokenId, {
+    nftMetadata,
+    userAddress = this.config.selectedAddress,
+    source = "custom" /* Custom */,
+    networkClientId
+  } = { userAddress: this.config.selectedAddress }) {
+    tokenAddress = toChecksumHexAddress(tokenAddress);
+    const chainId = this.getCorrectChainId({ networkClientId });
+    const newNftContracts = await this.addNftContract({
+      tokenAddress,
+      userAddress,
+      networkClientId,
+      source
+    });
+    nftMetadata = nftMetadata || await this.getNftInformation(tokenAddress, tokenId, networkClientId);
+    const nftContract = newNftContracts.find(
+      (contract) => contract.address.toLowerCase() === tokenAddress.toLowerCase()
+    );
+    if (nftContract) {
+      await this.addIndividualNft(
+        tokenAddress,
+        tokenId,
+        nftMetadata,
+        nftContract,
+        chainId,
+        userAddress,
+        source
+      );
+    }
+  }
+  /**
+   * Refetches NFT metadata and updates the state
+   *
+   * @param options - Options for refetching NFT metadata
+   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @param options.userAddress - The current user address
+   */
+  async updateNftMetadata({
+    userAddress = this.config.selectedAddress,
+    networkClientId
+  }) {
+    const chainId = this.getCorrectChainId({ networkClientId });
+    const { allNfts } = this.state;
+    const nfts = allNfts[userAddress]?.[chainId] || [];
+    const nftsToUpdate = nfts.filter(
+      (singleNft) => !singleNft.name && !singleNft.description && !singleNft.image
+    );
+    const nftsWithChecksumAdr = nftsToUpdate.map((nft) => {
+      return {
+        ...nft,
+        address: toChecksumHexAddress(nft.address)
+      };
+    });
+    const nftMetadataResults = await Promise.allSettled(
+      nftsWithChecksumAdr.map(async (nft) => {
+        const resMetadata = await this.getNftInformation(
+          nft.address,
+          nft.tokenId,
+          networkClientId
+        );
+        return {
+          nft,
+          newMetadata: resMetadata
+        };
+      })
+    );
+    nftMetadataResults.filter(
+      (result) => result.status === "fulfilled"
+    ).forEach(
+      (elm) => this.updateNft(
+        elm.value.nft,
+        elm.value.newMetadata,
+        userAddress,
+        chainId
+      )
+    );
+  }
+  /**
+   * Removes an NFT from the stored token list.
+   *
+   * @param address - Hex address of the NFT contract.
+   * @param tokenId - Token identifier of the NFT.
+   * @param options - an object of arguments
+   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @param options.userAddress - The address of the account where the NFT is being removed.
+   */
+  removeNft(address, tokenId, {
+    networkClientId,
+    userAddress = this.config.selectedAddress
+  } = {
+    userAddress: this.config.selectedAddress
+  }) {
+    const chainId = this.getCorrectChainId({ networkClientId });
+    address = toChecksumHexAddress(address);
+    this.removeIndividualNft(address, tokenId, { chainId, userAddress });
+    const { allNfts } = this.state;
+    const nfts = allNfts[userAddress]?.[chainId] || [];
+    const remainingNft = nfts.find(
+      (nft) => nft.address.toLowerCase() === address.toLowerCase()
+    );
+    if (!remainingNft) {
+      this.removeNftContract(address, { chainId, userAddress });
+    }
+  }
+  /**
+   * Removes an NFT from the stored token list and saves it in ignored NFTs list.
+   *
+   * @param address - Hex address of the NFT contract.
+   * @param tokenId - Token identifier of the NFT.
+   * @param options - an object of arguments
+   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @param options.userAddress - The address of the account where the NFT is being removed.
+   */
+  removeAndIgnoreNft(address, tokenId, {
+    networkClientId,
+    userAddress = this.config.selectedAddress
+  } = {
+    userAddress: this.config.selectedAddress
+  }) {
+    const chainId = this.getCorrectChainId({ networkClientId });
+    address = toChecksumHexAddress(address);
+    this.removeAndIgnoreIndividualNft(address, tokenId, {
+      chainId,
+      userAddress
+    });
+    const { allNfts } = this.state;
+    const nfts = allNfts[userAddress]?.[chainId] || [];
+    const remainingNft = nfts.find(
+      (nft) => nft.address.toLowerCase() === address.toLowerCase()
+    );
+    if (!remainingNft) {
+      this.removeNftContract(address, { chainId, userAddress });
+    }
+  }
+  /**
+   * Removes all NFTs from the ignored list.
+   */
+  clearIgnoredNfts() {
+    this.update({ ignoredNfts: [] });
+  }
+  /**
+   * Checks whether input NFT is still owned by the user
+   * And updates the isCurrentlyOwned value on the NFT object accordingly.
+   *
+   * @param nft - The NFT object to check and update.
+   * @param batch - A boolean indicating whether this method is being called as part of a batch or single update.
+   * @param accountParams - The userAddress and chainId to check ownership against
+   * @param accountParams.userAddress - the address passed through the confirmed transaction flow to ensure assets are stored to the correct account
+   * @param accountParams.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @returns the NFT with the updated isCurrentlyOwned value
+   */
+  async checkAndUpdateSingleNftOwnershipStatus(nft, batch, {
+    userAddress = this.config.selectedAddress,
+    networkClientId
+  } = {
+    userAddress: this.config.selectedAddress
+  }) {
+    const chainId = this.getCorrectChainId({ networkClientId });
+    const { address, tokenId } = nft;
+    let isOwned = nft.isCurrentlyOwned;
+    try {
+      isOwned = await this.isNftOwner(userAddress, address, tokenId, {
+        networkClientId
+      });
+    } catch {
+    }
+    nft.isCurrentlyOwned = isOwned;
+    if (batch) {
+      return nft;
+    }
+    const { allNfts } = this.state;
+    const nfts = allNfts[userAddress]?.[chainId] || [];
+    const nftToUpdate = nfts.find(
+      (item) => item.tokenId === tokenId && item.address.toLowerCase() === address.toLowerCase()
+    );
+    if (nftToUpdate) {
+      nftToUpdate.isCurrentlyOwned = isOwned;
+      this.updateNestedNftState(nfts, ALL_NFTS_STATE_KEY, {
+        userAddress,
+        chainId
+      });
+    }
+    return nft;
+  }
+  /**
+   * Checks whether NFTs associated with current selectedAddress/chainId combination are still owned by the user
+   * And updates the isCurrentlyOwned value on each accordingly.
+   * @param options - an object of arguments
+   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @param options.userAddress - The address of the account where the NFT ownership status is checked/updated.
+   */
+  async checkAndUpdateAllNftsOwnershipStatus({
+    networkClientId,
+    userAddress = this.config.selectedAddress
+  } = {
+    userAddress: this.config.selectedAddress
+  }) {
+    const chainId = this.getCorrectChainId({ networkClientId });
+    const { allNfts } = this.state;
+    const nfts = allNfts[userAddress]?.[chainId] || [];
+    const updatedNfts = await Promise.all(
+      nfts.map(async (nft) => {
+        return await this.checkAndUpdateSingleNftOwnershipStatus(nft, true, {
+          networkClientId,
+          userAddress
+        }) ?? nft;
+      })
+    );
+    this.updateNestedNftState(updatedNfts, ALL_NFTS_STATE_KEY, {
+      userAddress,
+      chainId
+    });
+  }
+  /**
+   * Update NFT favorite status.
+   *
+   * @param address - Hex address of the NFT contract.
+   * @param tokenId - Hex address of the NFT contract.
+   * @param favorite - NFT new favorite status.
+   * @param options - an object of arguments
+   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @param options.userAddress - The address of the account where the NFT is being removed.
+   */
+  updateNftFavoriteStatus(address, tokenId, favorite, {
+    networkClientId,
+    userAddress = this.config.selectedAddress
+  } = {
+    userAddress: this.config.selectedAddress
+  }) {
+    const chainId = this.getCorrectChainId({ networkClientId });
+    const { allNfts } = this.state;
+    const nfts = allNfts[userAddress]?.[chainId] || [];
+    const index = nfts.findIndex(
+      (nft) => nft.address === address && nft.tokenId === tokenId
+    );
+    if (index === -1) {
+      return;
+    }
+    const updatedNft = {
+      ...nfts[index],
+      favorite
+    };
+    nfts[index] = updatedNft;
+    this.updateNestedNftState(nfts, ALL_NFTS_STATE_KEY, {
+      chainId,
+      userAddress
+    });
+  }
+  /**
+   * Returns an NFT by the address and token id.
+   *
+   * @param address - Hex address of the NFT contract.
+   * @param tokenId - Number that represents the id of the token.
+   * @param selectedAddress - Hex address of the user account.
+   * @param chainId - Id of the current network.
+   * @returns Object containing the NFT and its position in the array
+   */
+  findNftByAddressAndTokenId(address, tokenId, selectedAddress, chainId) {
+    const { allNfts } = this.state;
+    const nfts = allNfts[selectedAddress]?.[chainId] || [];
+    const index = nfts.findIndex(
+      (nft) => nft.address.toLowerCase() === address.toLowerCase() && nft.tokenId === tokenId
+    );
+    if (index === -1) {
+      return null;
+    }
+    return { nft: nfts[index], index };
+  }
+  /**
+   * Update NFT data.
+   *
+   * @param nft - NFT object to find the right NFT to updates.
+   * @param updates - NFT partial object to update properties of the NFT.
+   * @param selectedAddress - Hex address of the user account.
+   * @param chainId - Id of the current network.
+   */
+  updateNft(nft, updates, selectedAddress, chainId) {
+    const { allNfts } = this.state;
+    const nfts = allNfts[selectedAddress]?.[chainId] || [];
+    const nftInfo = this.findNftByAddressAndTokenId(
+      nft.address,
+      nft.tokenId,
+      selectedAddress,
+      chainId
+    );
+    if (!nftInfo) {
+      return;
+    }
+    const updatedNft = {
+      ...nft,
+      ...updates
+    };
+    const newNfts = [
+      ...nfts.slice(0, nftInfo.index),
+      updatedNft,
+      ...nfts.slice(nftInfo.index + 1)
+    ];
+    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {
+      chainId,
+      userAddress: selectedAddress
+    });
+  }
+  /**
+   * Resets the transaction status of an NFT.
+   *
+   * @param transactionId - NFT transaction id.
+   * @param selectedAddress - Hex address of the user account.
+   * @param chainId - Id of the current network.
+   * @returns a boolean indicating if the reset was well succeeded or not
+   */
+  resetNftTransactionStatusByTransactionId(transactionId, selectedAddress, chainId) {
+    const { allNfts } = this.state;
+    const nfts = allNfts[selectedAddress]?.[chainId] || [];
+    const index = nfts.findIndex(
+      (nft) => nft.transactionId === transactionId
+    );
+    if (index === -1) {
+      return false;
+    }
+    const updatedNft = {
+      ...nfts[index],
+      transactionId: void 0
+    };
+    const newNfts = [
+      ...nfts.slice(0, index),
+      updatedNft,
+      ...nfts.slice(index + 1)
+    ];
+    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {
+      chainId,
+      userAddress: selectedAddress
+    });
+    return true;
+  }
+  async _requestApproval(suggestedNftMeta) {
+    return this.messagingSystem.call(
+      "ApprovalController:addRequest",
+      {
+        id: suggestedNftMeta.id,
+        origin: suggestedNftMeta.origin,
+        type: ApprovalType.WatchAsset,
+        requestData: {
+          id: suggestedNftMeta.id,
+          interactingAddress: suggestedNftMeta.interactingAddress,
+          asset: {
+            address: suggestedNftMeta.asset.address,
+            tokenId: suggestedNftMeta.asset.tokenId,
+            name: suggestedNftMeta.asset.name,
+            description: suggestedNftMeta.asset.description,
+            image: suggestedNftMeta.asset.image,
+            standard: suggestedNftMeta.asset.standard
+          }
+        }
+      },
+      true
+    );
+  }
+};
+var NftController_default = NftController;
+
+export {
+  OpenSeaV2ChainIds,
+  getDefaultNftState,
+  NftController,
+  NftController_default
+};
+//# sourceMappingURL=chunk-WTG2VMDL.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-WTG2VMDL.mjs.map b/node_modules/@metamask/assets-controllers/dist/chunk-WTG2VMDL.mjs.map
new file mode 100644
index 0000000..588e225
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-WTG2VMDL.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/NftController.ts"],"sourcesContent":["import { isAddress } from '@ethersproject/address';\nimport type { AddApprovalRequest } from '@metamask/approval-controller';\nimport type {\n  BaseConfig,\n  BaseState,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport { BaseControllerV1 } from '@metamask/base-controller';\nimport {\n  safelyExecute,\n  handleFetch,\n  toChecksumHexAddress,\n  BNToHex,\n  fetchWithErrorHandling,\n  IPFS_DEFAULT_GATEWAY_URL,\n  ERC721,\n  ERC1155,\n  OPENSEA_PROXY_URL,\n  ApprovalType,\n} from '@metamask/controller-utils';\nimport type {\n  NetworkClientId,\n  NetworkController,\n  NetworkState,\n} from '@metamask/network-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type { Hex } from '@metamask/utils';\nimport { remove0x } from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\nimport BN from 'bn.js';\nimport { EventEmitter } from 'events';\nimport { v4 as random } from 'uuid';\n\nimport type { AssetsContractController } from './AssetsContractController';\nimport {\n  compareNftMetadata,\n  getFormattedIpfsUrl,\n  mapOpenSeaContractV2ToV1,\n  mapOpenSeaDetailedNftV2ToV1,\n} from './assetsUtil';\nimport { Source } from './constants';\nimport type {\n  ApiNftCreator,\n  ApiNftContract,\n  ApiNftLastSale,\n} from './NftDetectionController';\n\ntype NFTStandardType = 'ERC721' | 'ERC1155';\n\ntype SuggestedNftMeta = {\n  asset: { address: string; tokenId: string } & NftMetadata;\n  id: string;\n  time: number;\n  type: NFTStandardType;\n  interactingAddress: string;\n  origin: string;\n};\n\nexport enum OpenSeaV2ChainIds {\n  ethereum = 'ethereum',\n}\n\nexport type OpenSeaV2GetNftResponse = { nft: OpenSeaV2DetailedNft };\n\nexport type OpenSeaV2Nft = {\n  identifier: string;\n  collection: string;\n  contract: string;\n  token_standard: string;\n  name: string;\n  description: string;\n  image_url?: string;\n  metadata_url?: string;\n  updated_at: string;\n  is_disabled: boolean;\n  is_nsfw: boolean;\n};\n\nexport type OpenSeaV2DetailedNft = OpenSeaV2Nft & {\n  animation_url?: string;\n  is_suspicious: boolean;\n  creator: string;\n  traits: {\n    trait_type: string;\n    display_type?: string;\n    max_value: string;\n    trait_count?: number;\n    value: number | string;\n  }[];\n  owners: {\n    address: string;\n    quantity: number;\n  }[];\n  rarity: { rank: number };\n};\n\nexport type OpenSeaV2ListNftsResponse = {\n  nfts: OpenSeaV2Nft[];\n  next?: string;\n};\n\nexport type OpenSeaV2Contract = {\n  address: string;\n  chain: string;\n  collection: string;\n  contract_standard: string;\n  name: string;\n  total_supply?: number;\n};\n\nexport type OpenSeaV2Collection = {\n  collection: string;\n  name: string;\n  description?: string;\n  image_url?: string;\n  owner: string;\n  category: string;\n  is_disabled: boolean;\n  is_nsfw: boolean;\n  trait_offers_enabled: boolean;\n  opensea_url: string;\n  project_url?: string;\n  wiki_url?: string;\n  discord_url?: string;\n  telegram_url?: string;\n  twitter_username?: string;\n  instagram_username?: string;\n  total_supply?: number;\n};\n\n/**\n * @type Nft\n *\n * NFT representation\n * @property address - Hex address of a ERC721 contract\n * @property description - The NFT description\n * @property image - URI of custom NFT image associated with this tokenId\n * @property name - Name associated with this tokenId and contract address\n * @property tokenId - The NFT identifier\n * @property numberOfSales - Number of sales\n * @property backgroundColor - The background color to be displayed with the item\n * @property imagePreview - URI of a smaller image associated with this NFT\n * @property imageThumbnail - URI of a thumbnail image associated with this NFT\n * @property imageOriginal - URI of the original image associated with this NFT\n * @property animation - URI of a animation associated with this NFT\n * @property animationOriginal - URI of the original animation associated with this NFT\n * @property externalLink - External link containing additional information\n * @property creator - The NFT owner information object\n * @property isCurrentlyOwned - Boolean indicating whether the address/chainId combination where it's currently stored currently owns this NFT\n * @property transactionId - Transaction Id associated with the NFT\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface Nft extends NftMetadata {\n  tokenId: string;\n  address: string;\n  isCurrentlyOwned?: boolean;\n}\n\ntype NftUpdate = {\n  nft: Nft;\n  newMetadata: NftMetadata;\n};\n\n/**\n * @type NftContract\n *\n * NFT contract information representation\n * @property name - Contract name\n * @property logo - Contract logo\n * @property address - Contract address\n * @property symbol - Contract symbol\n * @property description - Contract description\n * @property totalSupply - Total supply of NFTs\n * @property assetContractType - The NFT type, it could be `semi-fungible` or `non-fungible`\n * @property createdDate - Creation date\n * @property schemaName - The schema followed by the contract, it could be `ERC721` or `ERC1155`\n * @property externalLink - External link containing additional information\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface NftContract {\n  name?: string;\n  logo?: string;\n  address: string;\n  symbol?: string;\n  description?: string;\n  totalSupply?: string;\n  assetContractType?: string;\n  createdDate?: string;\n  schemaName?: string;\n  externalLink?: string;\n}\n\n/**\n * @type NftMetadata\n *\n * NFT custom information\n * @property name - NFT custom name\n * @property description - The NFT description\n * @property numberOfSales - Number of sales\n * @property backgroundColor - The background color to be displayed with the item\n * @property image - Image custom image URI\n * @property imagePreview - URI of a smaller image associated with this NFT\n * @property imageThumbnail - URI of a thumbnail image associated with this NFT\n * @property imageOriginal - URI of the original image associated with this NFT\n * @property animation - URI of a animation associated with this NFT\n * @property animationOriginal - URI of the original animation associated with this NFT\n * @property externalLink - External link containing additional information\n * @property creator - The NFT owner information object\n * @property standard - NFT standard name for the NFT, e.g., ERC-721 or ERC-1155\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface NftMetadata {\n  name: string | null;\n  description: string | null;\n  image: string | null;\n  standard: string | null;\n  favorite?: boolean;\n  numberOfSales?: number;\n  backgroundColor?: string;\n  imagePreview?: string;\n  imageThumbnail?: string;\n  imageOriginal?: string;\n  animation?: string;\n  animationOriginal?: string;\n  externalLink?: string;\n  creator?: ApiNftCreator;\n  lastSale?: ApiNftLastSale;\n  transactionId?: string;\n  tokenURI?: string | null;\n}\n\n/**\n * @type NftConfig\n *\n * NFT controller configuration\n * @property selectedAddress - Vault selected address\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface NftConfig extends BaseConfig {\n  selectedAddress: string;\n  chainId: Hex;\n  ipfsGateway: string;\n  openSeaEnabled: boolean;\n  useIPFSSubdomains: boolean;\n  isIpfsGatewayEnabled: boolean;\n}\n\n/**\n * @type NftState\n *\n * NFT controller state\n * @property allNftContracts - Object containing NFT contract information\n * @property allNfts - Object containing NFTs per account and network\n * @property ignoredNfts - List of NFTs that should be ignored\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface NftState extends BaseState {\n  allNftContracts: {\n    [key: string]: { [chainId: Hex]: NftContract[] };\n  };\n  allNfts: { [key: string]: { [chainId: Hex]: Nft[] } };\n  ignoredNfts: Nft[];\n}\n\nconst ALL_NFTS_STATE_KEY = 'allNfts';\nconst ALL_NFTS_CONTRACTS_STATE_KEY = 'allNftContracts';\n\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\ninterface NftAsset {\n  address: string;\n  tokenId: string;\n}\n\n/**\n * The name of the {@link NftController}.\n */\nconst controllerName = 'NftController';\n\n/**\n * The external actions available to the {@link NftController}.\n */\ntype AllowedActions = AddApprovalRequest;\n\n/**\n * The messenger of the {@link NftController}.\n */\nexport type NftControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  AllowedActions,\n  never,\n  AllowedActions['type'],\n  never\n>;\n\nexport const getDefaultNftState = (): NftState => {\n  return {\n    allNftContracts: {},\n    allNfts: {},\n    ignoredNfts: [],\n  };\n};\n\n/**\n * Controller that stores assets and exposes convenience methods\n */\nexport class NftController extends BaseControllerV1<NftConfig, NftState> {\n  private readonly mutex = new Mutex();\n\n  private readonly messagingSystem: NftControllerMessenger;\n\n  getNftApi({\n    contractAddress,\n    tokenId,\n  }: {\n    contractAddress: string;\n    tokenId: string;\n  }) {\n    return `${OPENSEA_PROXY_URL}/chain/${OpenSeaV2ChainIds.ethereum}/contract/${contractAddress}/nfts/${tokenId}`;\n  }\n\n  private getNftContractInformationApi({\n    contractAddress,\n  }: {\n    contractAddress: string;\n  }) {\n    return `${OPENSEA_PROXY_URL}/chain/${OpenSeaV2ChainIds.ethereum}/contract/${contractAddress}`;\n  }\n\n  private getNftCollectionInformationApi({\n    collectionSlug,\n  }: {\n    collectionSlug: string;\n  }) {\n    return `${OPENSEA_PROXY_URL}/collections/${collectionSlug}`;\n  }\n\n  /**\n   * Helper method to update nested state for allNfts and allNftContracts.\n   *\n   * @param newCollection - the modified piece of state to update in the controller's store\n   * @param baseStateKey - The root key in the store to update.\n   * @param passedConfig - An object containing the selectedAddress and chainId that are passed through the auto-detection flow.\n   * @param passedConfig.userAddress - the address passed through the NFT detection flow to ensure assets are stored to the correct account\n   * @param passedConfig.chainId - the chainId passed through the NFT detection flow to ensure assets are stored to the correct account\n   */\n  private updateNestedNftState(\n    newCollection: Nft[] | NftContract[],\n    baseStateKey: 'allNfts' | 'allNftContracts',\n    { userAddress, chainId }: { userAddress: string; chainId: Hex },\n  ) {\n    const { [baseStateKey]: oldState } = this.state;\n\n    const addressState = oldState[userAddress];\n    const newAddressState = {\n      ...addressState,\n      ...{ [chainId]: newCollection },\n    };\n    const newState = {\n      ...oldState,\n      ...{ [userAddress]: newAddressState },\n    };\n\n    this.update({\n      [baseStateKey]: newState,\n    });\n  }\n\n  /**\n   * Request individual NFT information from OpenSea API.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftInformationFromApi(\n    contractAddress: string,\n    tokenId: string,\n  ): Promise<NftMetadata> {\n    // TODO Parameterize this by chainId for non-mainnet token detection\n    // Attempt to fetch the data with the proxy\n    const nftInformation: OpenSeaV2GetNftResponse | undefined =\n      await fetchWithErrorHandling({\n        url: this.getNftApi({\n          contractAddress,\n          tokenId,\n        }),\n      });\n\n    // if we were still unable to fetch the data we return out the default/null of `NftMetadata`\n    if (!nftInformation?.nft) {\n      return {\n        name: null,\n        description: null,\n        image: null,\n        standard: null,\n      };\n    }\n\n    // if we've reached this point, we have successfully fetched some data for nftInformation\n    // now we reconfigure the data to conform to the `NftMetadata` type for storage.\n    const {\n      num_sales,\n      background_color,\n      image_url,\n      image_preview_url,\n      image_thumbnail_url,\n      image_original_url,\n      animation_url,\n      animation_original_url,\n      name,\n      description,\n      external_link,\n      creator,\n      last_sale,\n      asset_contract: { schema_name },\n    } = mapOpenSeaDetailedNftV2ToV1(nftInformation.nft);\n\n    /* istanbul ignore next */\n    const nftMetadata: NftMetadata = Object.assign(\n      {},\n      { name: name || null },\n      { description: description || null },\n      { image: image_url || null },\n      creator && { creator },\n      num_sales && { numberOfSales: num_sales },\n      background_color && { backgroundColor: background_color },\n      image_preview_url && { imagePreview: image_preview_url },\n      image_thumbnail_url && { imageThumbnail: image_thumbnail_url },\n      image_original_url && { imageOriginal: image_original_url },\n      animation_url && { animation: animation_url },\n      animation_original_url && {\n        animationOriginal: animation_original_url,\n      },\n      external_link && { externalLink: external_link },\n      last_sale && { lastSale: last_sale },\n      schema_name && { standard: schema_name },\n    );\n\n    return nftMetadata;\n  }\n\n  /**\n   * Request individual NFT information from contracts that follows Metadata Interface.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftInformationFromTokenURI(\n    contractAddress: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<NftMetadata> {\n    const { ipfsGateway, useIPFSSubdomains, isIpfsGatewayEnabled } =\n      this.config;\n    const result = await this.getNftURIAndStandard(\n      contractAddress,\n      tokenId,\n      networkClientId,\n    );\n    let tokenURI = result[0];\n    const standard = result[1];\n\n    const hasIpfsTokenURI = tokenURI.startsWith('ipfs://');\n\n    if (hasIpfsTokenURI && !isIpfsGatewayEnabled) {\n      return {\n        image: null,\n        name: null,\n        description: null,\n        standard: standard || null,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    }\n\n    const isDisplayNFTMediaToggleEnabled = this.config.openSeaEnabled;\n    if (!hasIpfsTokenURI && !isDisplayNFTMediaToggleEnabled) {\n      return {\n        image: null,\n        name: null,\n        description: null,\n        standard: standard || null,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    }\n\n    if (hasIpfsTokenURI) {\n      tokenURI = getFormattedIpfsUrl(ipfsGateway, tokenURI, useIPFSSubdomains);\n    }\n\n    try {\n      const object = await handleFetch(tokenURI);\n      // TODO: Check image_url existence. This is not part of EIP721 nor EIP1155\n      const image = Object.prototype.hasOwnProperty.call(object, 'image')\n        ? 'image'\n        : /* istanbul ignore next */ 'image_url';\n\n      return {\n        image: object[image],\n        name: object.name,\n        description: object.description,\n        standard,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    } catch {\n      return {\n        image: null,\n        name: null,\n        description: null,\n        standard: standard || null,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    }\n  }\n\n  /**\n   * Retrieve NFT uri with  metadata. TODO Update method to use IPFS.\n   *\n   * @param contractAddress - NFT contract address.\n   * @param tokenId - NFT token id.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving NFT uri and token standard.\n   */\n  private async getNftURIAndStandard(\n    contractAddress: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<[string, string]> {\n    // try ERC721 uri\n    try {\n      const uri = await this.getERC721TokenURI(\n        contractAddress,\n        tokenId,\n        networkClientId,\n      );\n      return [uri, ERC721];\n    } catch {\n      // Ignore error\n    }\n\n    // try ERC1155 uri\n    try {\n      const tokenURI = await this.getERC1155TokenURI(\n        contractAddress,\n        tokenId,\n        networkClientId,\n      );\n\n      /**\n       * According to EIP1155 the URI value allows for ID substitution\n       * in case the string `{id}` exists.\n       * https://eips.ethereum.org/EIPS/eip-1155#metadata\n       */\n\n      if (!tokenURI.includes('{id}')) {\n        return [tokenURI, ERC1155];\n      }\n\n      const hexTokenId = remove0x(BNToHex(new BN(tokenId)))\n        .padStart(64, '0')\n        .toLowerCase();\n      return [tokenURI.replace('{id}', hexTokenId), ERC1155];\n    } catch {\n      // Ignore error\n    }\n\n    return ['', ''];\n  }\n\n  /**\n   * Request individual NFT information (name, image url and description).\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftInformation(\n    contractAddress: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<NftMetadata> {\n    const chainId = this.getCorrectChainId({\n      networkClientId,\n    });\n\n    const [blockchainMetadata, openSeaMetadata] = await Promise.all([\n      safelyExecute(() =>\n        this.getNftInformationFromTokenURI(\n          contractAddress,\n          tokenId,\n          networkClientId,\n        ),\n      ),\n      this.config.openSeaEnabled && chainId === '0x1'\n        ? safelyExecute(() =>\n            this.getNftInformationFromApi(contractAddress, tokenId),\n          )\n        : undefined,\n    ]);\n\n    return {\n      ...openSeaMetadata,\n      name: blockchainMetadata?.name ?? openSeaMetadata?.name ?? null,\n      description:\n        blockchainMetadata?.description ?? openSeaMetadata?.description ?? null,\n      image: blockchainMetadata?.image ?? openSeaMetadata?.image ?? null,\n      standard:\n        blockchainMetadata?.standard ?? openSeaMetadata?.standard ?? null,\n      tokenURI: blockchainMetadata?.tokenURI ?? null,\n    };\n  }\n\n  /**\n   * Request NFT contract information from OpenSea API.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftContractInformationFromApi(\n    contractAddress: string,\n  ): Promise<ApiNftContract> {\n    /* istanbul ignore if */\n    const apiNftContractObject: OpenSeaV2Contract | undefined =\n      await fetchWithErrorHandling({\n        url: this.getNftContractInformationApi({\n          contractAddress,\n        }),\n      });\n\n    // If we successfully fetched the contract\n    if (apiNftContractObject) {\n      // Then fetch some additional details from the collection\n      const collection: OpenSeaV2Collection | undefined =\n        await fetchWithErrorHandling({\n          url: this.getNftCollectionInformationApi({\n            collectionSlug: apiNftContractObject.collection,\n          }),\n        });\n\n      return mapOpenSeaContractV2ToV1(apiNftContractObject, collection);\n    }\n\n    // If we've reached this point we were unable to fetch data from either the proxy or opensea so we return\n    // the default/null of ApiNftContract\n    return {\n      address: contractAddress,\n      asset_contract_type: null,\n      created_date: null,\n      schema_name: null,\n      symbol: null,\n      total_supply: null,\n      description: null,\n      external_link: null,\n      collection: {\n        name: null,\n        image_url: null,\n      },\n    };\n  }\n\n  /**\n   * Request NFT contract information from the contract itself.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftContractInformationFromContract(\n    contractAddress: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<\n    Partial<ApiNftContract> &\n      Pick<ApiNftContract, 'address'> &\n      Pick<ApiNftContract, 'collection'>\n  > {\n    const [name, symbol] = await Promise.all([\n      this.getERC721AssetName(contractAddress, networkClientId),\n      this.getERC721AssetSymbol(contractAddress, networkClientId),\n    ]);\n\n    return {\n      collection: { name },\n      symbol,\n      address: contractAddress,\n    };\n  }\n\n  /**\n   * Request NFT contract information from OpenSea API.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the NFT contract name, image and description.\n   */\n  private async getNftContractInformation(\n    contractAddress: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<\n    Partial<ApiNftContract> &\n      Pick<ApiNftContract, 'address'> &\n      Pick<ApiNftContract, 'collection'>\n  > {\n    const chainId = this.getCorrectChainId({\n      networkClientId,\n    });\n\n    const [blockchainContractData, openSeaContractData] = await Promise.all([\n      safelyExecute(() =>\n        this.getNftContractInformationFromContract(\n          contractAddress,\n          networkClientId,\n        ),\n      ),\n      this.config.openSeaEnabled && chainId === '0x1'\n        ? safelyExecute(() =>\n            this.getNftContractInformationFromApi(contractAddress),\n          )\n        : undefined,\n    ]);\n\n    if (blockchainContractData || openSeaContractData) {\n      return {\n        address: contractAddress,\n        ...openSeaContractData,\n        ...blockchainContractData,\n        collection: {\n          name: null,\n          image_url: null,\n          ...openSeaContractData?.collection,\n          ...blockchainContractData?.collection,\n        },\n      };\n    }\n\n    /* istanbul ignore next */\n    return {\n      address: contractAddress,\n      asset_contract_type: null,\n      created_date: null,\n      schema_name: null,\n      symbol: null,\n      total_supply: null,\n      description: null,\n      external_link: null,\n      collection: { name: null, image_url: null },\n    };\n  }\n\n  /**\n   * Adds an individual NFT to the stored NFT list.\n   *\n   * @param tokenAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param nftMetadata - NFT optional information (name, image and description).\n   * @param nftContract - An object containing contract data of the NFT being added.\n   * @param chainId - The chainId of the network where the NFT is being added.\n   * @param userAddress - The address of the account where the NFT is being added.\n   * @param source - Whether the NFT was detected, added manually or suggested by a dapp.\n   * @returns Promise resolving to the current NFT list.\n   */\n  private async addIndividualNft(\n    tokenAddress: string,\n    tokenId: string,\n    nftMetadata: NftMetadata,\n    nftContract: NftContract,\n    chainId: Hex,\n    userAddress: string,\n    source: Source,\n  ): Promise<Nft[]> {\n    // TODO: Remove unused return\n    const releaseLock = await this.mutex.acquire();\n    try {\n      tokenAddress = toChecksumHexAddress(tokenAddress);\n      const { allNfts } = this.state;\n\n      const nfts = allNfts[userAddress]?.[chainId] || [];\n\n      const existingEntry: Nft | undefined = nfts.find(\n        (nft) =>\n          nft.address.toLowerCase() === tokenAddress.toLowerCase() &&\n          nft.tokenId === tokenId,\n      );\n\n      if (existingEntry) {\n        const differentMetadata = compareNftMetadata(\n          nftMetadata,\n          existingEntry,\n        );\n        if (differentMetadata || !existingEntry.isCurrentlyOwned) {\n          // TODO: Switch to indexToUpdate\n          const indexToRemove = nfts.findIndex(\n            (nft) =>\n              nft.address.toLowerCase() === tokenAddress.toLowerCase() &&\n              nft.tokenId === tokenId,\n          );\n          /* istanbul ignore next */\n          if (indexToRemove !== -1) {\n            nfts.splice(indexToRemove, 1);\n          }\n        } else {\n          return nfts;\n        }\n      }\n\n      const newEntry: Nft = {\n        address: tokenAddress,\n        tokenId,\n        favorite: existingEntry?.favorite || false,\n        isCurrentlyOwned: true,\n        ...nftMetadata,\n      };\n\n      const newNfts = [...nfts, newEntry];\n      this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n        chainId,\n        userAddress,\n      });\n\n      if (this.onNftAdded) {\n        this.onNftAdded({\n          address: tokenAddress,\n          symbol: nftContract.symbol,\n          tokenId: tokenId.toString(),\n          standard: nftMetadata.standard,\n          source,\n        });\n      }\n      return newNfts;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Adds an NFT contract to the stored NFT contracts list.\n   *\n   * @param options - options.\n   * @param options.tokenAddress - Hex address of the NFT contract.\n   * @param options.userAddress - The address of the account where the NFT is being added.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.\n   * @returns Promise resolving to the current NFT contracts list.\n   */\n  private async addNftContract({\n    tokenAddress,\n    userAddress,\n    networkClientId,\n    source,\n  }: {\n    tokenAddress: string;\n    userAddress: string;\n    networkClientId?: NetworkClientId;\n    source?: Source;\n  }): Promise<NftContract[]> {\n    const releaseLock = await this.mutex.acquire();\n    try {\n      tokenAddress = toChecksumHexAddress(tokenAddress);\n      const { allNftContracts } = this.state;\n      const chainId = this.getCorrectChainId({\n        networkClientId,\n      });\n\n      const nftContracts = allNftContracts[userAddress]?.[chainId] || [];\n\n      const existingEntry = nftContracts.find(\n        (nftContract) =>\n          nftContract.address.toLowerCase() === tokenAddress.toLowerCase(),\n      );\n      if (existingEntry) {\n        return nftContracts;\n      }\n\n      // this doesn't work currently for detection if the user switches networks while the detection is processing\n      // will be fixed once detection uses networkClientIds\n      const contractInformation = await this.getNftContractInformation(\n        tokenAddress,\n        networkClientId,\n      );\n      const {\n        asset_contract_type,\n        created_date,\n        schema_name,\n        symbol,\n        total_supply,\n        description,\n        external_link,\n        collection: { name, image_url },\n      } = contractInformation;\n\n      // If the nft is auto-detected we want some valid metadata to be present\n      if (\n        source === Source.Detected &&\n        'address' in contractInformation &&\n        typeof contractInformation.address === 'string' &&\n        'collection' in contractInformation &&\n        contractInformation.collection.name === null &&\n        'image_url' in contractInformation.collection &&\n        contractInformation.collection.image_url === null &&\n        Object.entries(contractInformation).every(([key, value]) => {\n          return key === 'address' || key === 'collection' || !value;\n        })\n      ) {\n        return nftContracts;\n      }\n\n      /* istanbul ignore next */\n      const newEntry: NftContract = Object.assign(\n        {},\n        { address: tokenAddress },\n        description && { description },\n        name && { name },\n        image_url && { logo: image_url },\n        symbol && { symbol },\n        total_supply !== null &&\n          typeof total_supply !== 'undefined' && { totalSupply: total_supply },\n        asset_contract_type && { assetContractType: asset_contract_type },\n        created_date && { createdDate: created_date },\n        schema_name && { schemaName: schema_name },\n        external_link && { externalLink: external_link },\n      );\n      const newNftContracts = [...nftContracts, newEntry];\n      this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY, {\n        chainId,\n        userAddress,\n      });\n\n      return newNftContracts;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Removes an individual NFT from the stored token list and saves it in ignored NFTs list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   * @param options - options.\n   * @param options.chainId - The chainId of the network where the NFT is being removed.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   */\n  private removeAndIgnoreIndividualNft(\n    address: string,\n    tokenId: string,\n    {\n      chainId,\n      userAddress,\n    }: {\n      chainId: Hex;\n      userAddress: string;\n    },\n  ) {\n    address = toChecksumHexAddress(address);\n    const { allNfts, ignoredNfts } = this.state;\n    const newIgnoredNfts = [...ignoredNfts];\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const newNfts = nfts.filter((nft) => {\n      if (\n        nft.address.toLowerCase() === address.toLowerCase() &&\n        nft.tokenId === tokenId\n      ) {\n        const alreadyIgnored = newIgnoredNfts.find(\n          (c) => c.address === address && c.tokenId === tokenId,\n        );\n        !alreadyIgnored && newIgnoredNfts.push(nft);\n        return false;\n      }\n      return true;\n    });\n\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n      userAddress,\n      chainId,\n    });\n\n    this.update({\n      ignoredNfts: newIgnoredNfts,\n    });\n  }\n\n  /**\n   * Removes an individual NFT from the stored token list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   * @param options - options.\n   * @param options.chainId - The chainId of the network where the NFT is being removed.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   */\n  private removeIndividualNft(\n    address: string,\n    tokenId: string,\n    { chainId, userAddress }: { chainId: Hex; userAddress: string },\n  ) {\n    address = toChecksumHexAddress(address);\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const newNfts = nfts.filter(\n      (nft) =>\n        !(\n          nft.address.toLowerCase() === address.toLowerCase() &&\n          nft.tokenId === tokenId\n        ),\n    );\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n      userAddress,\n      chainId,\n    });\n  }\n\n  /**\n   * Removes an NFT contract to the stored NFT contracts list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param options - options.\n   * @param options.chainId - The chainId of the network where the NFT is being removed.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   * @returns Promise resolving to the current NFT contracts list.\n   */\n  private removeNftContract(\n    address: string,\n    { chainId, userAddress }: { chainId: Hex; userAddress: string },\n  ): NftContract[] {\n    address = toChecksumHexAddress(address);\n    const { allNftContracts } = this.state;\n    const nftContracts = allNftContracts[userAddress]?.[chainId] || [];\n\n    const newNftContracts = nftContracts.filter(\n      (nftContract) =>\n        !(nftContract.address.toLowerCase() === address.toLowerCase()),\n    );\n    this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY, {\n      chainId,\n      userAddress,\n    });\n\n    return newNftContracts;\n  }\n\n  /**\n   * EventEmitter instance used to listen to specific EIP747 events\n   */\n  hub = new EventEmitter();\n\n  /**\n   * Optional API key to use with opensea\n   */\n  openSeaApiKey?: string;\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'NftController';\n\n  private readonly getERC721AssetName: AssetsContractController['getERC721AssetName'];\n\n  private readonly getERC721AssetSymbol: AssetsContractController['getERC721AssetSymbol'];\n\n  private readonly getERC721TokenURI: AssetsContractController['getERC721TokenURI'];\n\n  private readonly getERC721OwnerOf: AssetsContractController['getERC721OwnerOf'];\n\n  private readonly getERC1155BalanceOf: AssetsContractController['getERC1155BalanceOf'];\n\n  private readonly getERC1155TokenURI: AssetsContractController['getERC1155TokenURI'];\n\n  private readonly getNetworkClientById: NetworkController['getNetworkClientById'];\n\n  private readonly onNftAdded?: (data: {\n    address: string;\n    symbol: string | undefined;\n    tokenId: string;\n    standard: string | null;\n    source: Source;\n  }) => void;\n\n  /**\n   * Creates an NftController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param options.getERC721AssetName - Gets the name of the asset at the given address.\n   * @param options.getERC721AssetSymbol - Gets the symbol of the asset at the given address.\n   * @param options.getERC721TokenURI - Gets the URI of the ERC721 token at the given address, with the given ID.\n   * @param options.getERC721OwnerOf - Get the owner of a ERC-721 NFT.\n   * @param options.getERC1155BalanceOf - Gets balance of a ERC-1155 NFT.\n   * @param options.getERC1155TokenURI - Gets the URI of the ERC1155 token at the given address, with the given ID.\n   * @param options.getNetworkClientById - Gets the network client for the given networkClientId.\n   * @param options.onNftAdded - Callback that is called when an NFT is added. Currently used pass data\n   * for tracking the NFT added event.\n   * @param options.messenger - The controller messenger.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      chainId: initialChainId,\n      onPreferencesStateChange,\n      onNetworkStateChange,\n      getERC721AssetName,\n      getERC721AssetSymbol,\n      getERC721TokenURI,\n      getERC721OwnerOf,\n      getERC1155BalanceOf,\n      getERC1155TokenURI,\n      getNetworkClientById,\n      onNftAdded,\n      messenger,\n    }: {\n      chainId: Hex;\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      getERC721AssetName: AssetsContractController['getERC721AssetName'];\n      getERC721AssetSymbol: AssetsContractController['getERC721AssetSymbol'];\n      getERC721TokenURI: AssetsContractController['getERC721TokenURI'];\n      getERC721OwnerOf: AssetsContractController['getERC721OwnerOf'];\n      getERC1155BalanceOf: AssetsContractController['getERC1155BalanceOf'];\n      getERC1155TokenURI: AssetsContractController['getERC1155TokenURI'];\n      getNetworkClientById: NetworkController['getNetworkClientById'];\n      onNftAdded?: (data: {\n        address: string;\n        symbol: string | undefined;\n        tokenId: string;\n        standard: string | null;\n        source: string;\n      }) => void;\n      messenger: NftControllerMessenger;\n    },\n    config?: Partial<BaseConfig>,\n    state?: Partial<NftState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      selectedAddress: '',\n      chainId: initialChainId,\n      ipfsGateway: IPFS_DEFAULT_GATEWAY_URL,\n      openSeaEnabled: false,\n      useIPFSSubdomains: true,\n      isIpfsGatewayEnabled: true,\n    };\n\n    this.defaultState = getDefaultNftState();\n    this.initialize();\n    this.getERC721AssetName = getERC721AssetName;\n    this.getERC721AssetSymbol = getERC721AssetSymbol;\n    this.getERC721TokenURI = getERC721TokenURI;\n    this.getERC721OwnerOf = getERC721OwnerOf;\n    this.getERC1155BalanceOf = getERC1155BalanceOf;\n    this.getERC1155TokenURI = getERC1155TokenURI;\n    this.getNetworkClientById = getNetworkClientById;\n    this.onNftAdded = onNftAdded;\n    this.messagingSystem = messenger;\n\n    onPreferencesStateChange(\n      ({\n        selectedAddress,\n        ipfsGateway,\n        openSeaEnabled,\n        isIpfsGatewayEnabled,\n      }) => {\n        this.configure({\n          selectedAddress,\n          ipfsGateway,\n          openSeaEnabled,\n          isIpfsGatewayEnabled,\n        });\n\n        const needsUpdateNftMetadata =\n          (isIpfsGatewayEnabled && ipfsGateway !== '') || openSeaEnabled;\n\n        if (needsUpdateNftMetadata) {\n          this.updateNftMetadata({ userAddress: selectedAddress });\n        }\n      },\n    );\n\n    onNetworkStateChange(({ providerConfig }) => {\n      const { chainId } = providerConfig;\n      this.configure({ chainId });\n    });\n  }\n\n  private async validateWatchNft(\n    asset: NftAsset,\n    type: NFTStandardType,\n    userAddress: string,\n    { networkClientId }: { networkClientId?: NetworkClientId } = {},\n  ) {\n    const { address: contractAddress, tokenId } = asset;\n\n    // Validate parameters\n    if (!type) {\n      throw rpcErrors.invalidParams('Asset type is required');\n    }\n\n    if (type !== ERC721 && type !== ERC1155) {\n      throw rpcErrors.invalidParams(\n        `Non NFT asset type ${type} not supported by watchNft`,\n      );\n    }\n\n    if (!contractAddress || !tokenId) {\n      throw rpcErrors.invalidParams('Both address and tokenId are required');\n    }\n\n    if (!isAddress(contractAddress)) {\n      throw rpcErrors.invalidParams('Invalid address');\n    }\n\n    if (!/^\\d+$/u.test(tokenId)) {\n      throw rpcErrors.invalidParams('Invalid tokenId');\n    }\n\n    // Check if the user owns the suggested NFT\n    try {\n      const isOwner = await this.isNftOwner(\n        userAddress,\n        contractAddress,\n        tokenId,\n        { networkClientId },\n      );\n      if (!isOwner) {\n        throw rpcErrors.invalidInput(\n          'Suggested NFT is not owned by the selected account',\n        );\n      }\n    } catch (error) {\n      // error thrown here: \"Unable to verify ownership. Possibly because the standard is not supported or the user's currently selected network does not match the chain of the asset in question.\"\n      if (error instanceof Error) {\n        throw rpcErrors.resourceUnavailable(error.message);\n      }\n      throw error;\n    }\n  }\n\n  // temporary method to get the correct chainId until we remove chainId from the config & the chainId arg from the detection logic\n  // Just a helper method to prefer the networkClient chainId first then the chainId argument and then finally the config chainId\n  private getCorrectChainId({\n    networkClientId,\n  }: {\n    networkClientId?: NetworkClientId;\n  }) {\n    if (networkClientId) {\n      return this.getNetworkClientById(networkClientId).configuration.chainId;\n    }\n    return this.config.chainId;\n  }\n\n  /**\n   * Adds a new suggestedAsset to state. Parameters will be validated according to\n   * asset type being watched. A `<suggestedNftMeta.id>:pending` hub event will be emitted once added.\n   *\n   * @param asset - The asset to be watched. For now ERC721 and ERC1155 tokens are accepted.\n   * @param asset.address - The address of the asset contract.\n   * @param asset.tokenId - The ID of the asset.\n   * @param type - The asset type.\n   * @param origin - Domain origin to register the asset from.\n   * @param options - Options bag.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The address of the account where the NFT is being added.\n   * @returns Object containing a Promise resolving to the suggestedAsset address if accepted.\n   */\n  async watchNft(\n    asset: NftAsset,\n    type: NFTStandardType,\n    origin: string,\n    {\n      networkClientId,\n      userAddress = this.config.selectedAddress,\n    }: {\n      networkClientId?: NetworkClientId;\n      userAddress?: string;\n    } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    await this.validateWatchNft(asset, type, userAddress);\n\n    const nftMetadata = await this.getNftInformation(\n      asset.address,\n      asset.tokenId,\n      networkClientId,\n    );\n\n    if (nftMetadata.standard && nftMetadata.standard !== type) {\n      throw rpcErrors.invalidInput(\n        `Suggested NFT of type ${nftMetadata.standard} does not match received type ${type}`,\n      );\n    }\n\n    const suggestedNftMeta: SuggestedNftMeta = {\n      asset: { ...asset, ...nftMetadata },\n      type,\n      id: random(),\n      time: Date.now(),\n      interactingAddress: userAddress,\n      origin,\n    };\n    await this._requestApproval(suggestedNftMeta);\n    const { address, tokenId } = asset;\n    const { name, standard, description, image } = nftMetadata;\n\n    await this.addNft(address, tokenId, {\n      nftMetadata: {\n        name: name ?? null,\n        description: description ?? null,\n        image: image ?? null,\n        standard: standard ?? null,\n      },\n      userAddress,\n      source: Source.Dapp,\n      networkClientId,\n    });\n  }\n\n  /**\n   * Sets an OpenSea API key to retrieve NFT information.\n   *\n   * @param openSeaApiKey - OpenSea API key.\n   */\n  setApiKey(openSeaApiKey: string) {\n    this.openSeaApiKey = openSeaApiKey;\n  }\n\n  /**\n   * Checks the ownership of a ERC-721 or ERC-1155 NFT for a given address.\n   *\n   * @param ownerAddress - User public address.\n   * @param nftAddress - NFT contract address.\n   * @param tokenId - NFT token ID.\n   * @param options - Options bag.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving the NFT ownership.\n   */\n  async isNftOwner(\n    ownerAddress: string,\n    nftAddress: string,\n    tokenId: string,\n    {\n      networkClientId,\n    }: {\n      networkClientId?: NetworkClientId;\n    } = {},\n  ): Promise<boolean> {\n    // Checks the ownership for ERC-721.\n    try {\n      const owner = await this.getERC721OwnerOf(\n        nftAddress,\n        tokenId,\n        networkClientId,\n      );\n      return ownerAddress.toLowerCase() === owner.toLowerCase();\n      // eslint-disable-next-line no-empty\n    } catch {\n      // Ignore ERC-721 contract error\n    }\n\n    // Checks the ownership for ERC-1155.\n    try {\n      const balance = await this.getERC1155BalanceOf(\n        ownerAddress,\n        nftAddress,\n        tokenId,\n        networkClientId,\n      );\n      return !balance.isZero();\n      // eslint-disable-next-line no-empty\n    } catch {\n      // Ignore ERC-1155 contract error\n    }\n\n    throw new Error(\n      `Unable to verify ownership. Possibly because the standard is not supported or the user's currently selected network does not match the chain of the asset in question.`,\n    );\n  }\n\n  /**\n   * Verifies currently selected address owns entered NFT address/tokenId combo and\n   * adds the NFT and respective NFT contract to the stored NFT and NFT contracts lists.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param options - an object of arguments\n   * @param options.userAddress - The address of the current user.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.\n   */\n  async addNftVerifyOwnership(\n    address: string,\n    tokenId: string,\n    {\n      userAddress = this.config.selectedAddress,\n      networkClientId,\n      source,\n    }: {\n      userAddress?: string;\n      networkClientId?: NetworkClientId;\n      source?: Source;\n    } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    if (\n      !(await this.isNftOwner(userAddress, address, tokenId, {\n        networkClientId,\n      }))\n    ) {\n      throw new Error('This NFT is not owned by the user');\n    }\n    await this.addNft(address, tokenId, {\n      networkClientId,\n      userAddress,\n      source,\n    });\n  }\n\n  /**\n   * Adds an NFT and respective NFT contract to the stored NFT and NFT contracts lists.\n   *\n   * @param tokenAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param options - an object of arguments\n   * @param options.nftMetadata - NFT optional metadata.\n   * @param options.userAddress - The address of the current user.\n   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the current NFT list.\n   */\n  async addNft(\n    tokenAddress: string,\n    tokenId: string,\n    {\n      nftMetadata,\n      userAddress = this.config.selectedAddress,\n      source = Source.Custom,\n      networkClientId,\n    }: {\n      nftMetadata?: NftMetadata;\n      userAddress?: string;\n      source?: Source;\n      networkClientId?: NetworkClientId;\n    } = { userAddress: this.config.selectedAddress },\n  ) {\n    tokenAddress = toChecksumHexAddress(tokenAddress);\n\n    const chainId = this.getCorrectChainId({ networkClientId });\n    const newNftContracts = await this.addNftContract({\n      tokenAddress,\n      userAddress,\n      networkClientId,\n      source,\n    });\n\n    nftMetadata =\n      nftMetadata ||\n      (await this.getNftInformation(tokenAddress, tokenId, networkClientId));\n\n    // If NFT contract was not added, do not add individual NFT\n    const nftContract = newNftContracts.find(\n      (contract) =>\n        contract.address.toLowerCase() === tokenAddress.toLowerCase(),\n    );\n\n    // If NFT contract information, add individual NFT\n    if (nftContract) {\n      await this.addIndividualNft(\n        tokenAddress,\n        tokenId,\n        nftMetadata,\n        nftContract,\n        chainId,\n        userAddress,\n        source,\n      );\n    }\n  }\n\n  /**\n   * Refetches NFT metadata and updates the state\n   *\n   * @param options - Options for refetching NFT metadata\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The current user address\n   */\n  async updateNftMetadata({\n    userAddress = this.config.selectedAddress,\n    networkClientId,\n  }: {\n    userAddress?: string;\n    networkClientId?: NetworkClientId;\n  }) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n    const { allNfts } = this.state;\n    const nfts: Nft[] = allNfts[userAddress]?.[chainId] || [];\n    // We want to update only nfts missing name/image or description\n    const nftsToUpdate = nfts.filter(\n      (singleNft) =>\n        !singleNft.name && !singleNft.description && !singleNft.image,\n    );\n\n    const nftsWithChecksumAdr = nftsToUpdate.map((nft) => {\n      return {\n        ...nft,\n        address: toChecksumHexAddress(nft.address),\n      };\n    });\n    const nftMetadataResults = await Promise.allSettled(\n      nftsWithChecksumAdr.map(async (nft) => {\n        const resMetadata = await this.getNftInformation(\n          nft.address,\n          nft.tokenId,\n          networkClientId,\n        );\n        return {\n          nft,\n          newMetadata: resMetadata,\n        };\n      }),\n    );\n\n    nftMetadataResults\n      .filter(\n        (result): result is PromiseFulfilledResult<NftUpdate> =>\n          result.status === 'fulfilled',\n      )\n      .forEach((elm) =>\n        this.updateNft(\n          elm.value.nft,\n          elm.value.newMetadata,\n          userAddress,\n          chainId,\n        ),\n      );\n  }\n\n  /**\n   * Removes an NFT from the stored token list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   * @param options - an object of arguments\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   */\n  removeNft(\n    address: string,\n    tokenId: string,\n    {\n      networkClientId,\n      userAddress = this.config.selectedAddress,\n    }: { networkClientId?: NetworkClientId; userAddress?: string } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n    address = toChecksumHexAddress(address);\n    this.removeIndividualNft(address, tokenId, { chainId, userAddress });\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const remainingNft = nfts.find(\n      (nft) => nft.address.toLowerCase() === address.toLowerCase(),\n    );\n\n    if (!remainingNft) {\n      this.removeNftContract(address, { chainId, userAddress });\n    }\n  }\n\n  /**\n   * Removes an NFT from the stored token list and saves it in ignored NFTs list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   * @param options - an object of arguments\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   */\n  removeAndIgnoreNft(\n    address: string,\n    tokenId: string,\n    {\n      networkClientId,\n      userAddress = this.config.selectedAddress,\n    }: { networkClientId?: NetworkClientId; userAddress?: string } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n    address = toChecksumHexAddress(address);\n    this.removeAndIgnoreIndividualNft(address, tokenId, {\n      chainId,\n      userAddress,\n    });\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const remainingNft = nfts.find(\n      (nft) => nft.address.toLowerCase() === address.toLowerCase(),\n    );\n    if (!remainingNft) {\n      this.removeNftContract(address, { chainId, userAddress });\n    }\n  }\n\n  /**\n   * Removes all NFTs from the ignored list.\n   */\n  clearIgnoredNfts() {\n    this.update({ ignoredNfts: [] });\n  }\n\n  /**\n   * Checks whether input NFT is still owned by the user\n   * And updates the isCurrentlyOwned value on the NFT object accordingly.\n   *\n   * @param nft - The NFT object to check and update.\n   * @param batch - A boolean indicating whether this method is being called as part of a batch or single update.\n   * @param accountParams - The userAddress and chainId to check ownership against\n   * @param accountParams.userAddress - the address passed through the confirmed transaction flow to ensure assets are stored to the correct account\n   * @param accountParams.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns the NFT with the updated isCurrentlyOwned value\n   */\n  async checkAndUpdateSingleNftOwnershipStatus(\n    nft: Nft,\n    batch: boolean,\n    {\n      userAddress = this.config.selectedAddress,\n      networkClientId,\n    }: { networkClientId?: NetworkClientId; userAddress?: string } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n    const { address, tokenId } = nft;\n    let isOwned = nft.isCurrentlyOwned;\n    try {\n      isOwned = await this.isNftOwner(userAddress, address, tokenId, {\n        networkClientId,\n      });\n    } catch {\n      // ignore error\n      // this will only throw an error 'Unable to verify ownership' in which case\n      // we want to keep the current value of isCurrentlyOwned for this flow.\n    }\n\n    nft.isCurrentlyOwned = isOwned;\n\n    if (batch) {\n      return nft;\n    }\n\n    // if this is not part of a batched update we update this one NFT in state\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const nftToUpdate = nfts.find(\n      (item) =>\n        item.tokenId === tokenId &&\n        item.address.toLowerCase() === address.toLowerCase(),\n    );\n    if (nftToUpdate) {\n      nftToUpdate.isCurrentlyOwned = isOwned;\n      this.updateNestedNftState(nfts, ALL_NFTS_STATE_KEY, {\n        userAddress,\n        chainId,\n      });\n    }\n    return nft;\n  }\n\n  /**\n   * Checks whether NFTs associated with current selectedAddress/chainId combination are still owned by the user\n   * And updates the isCurrentlyOwned value on each accordingly.\n   * @param options - an object of arguments\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The address of the account where the NFT ownership status is checked/updated.\n   */\n  async checkAndUpdateAllNftsOwnershipStatus(\n    {\n      networkClientId,\n      userAddress = this.config.selectedAddress,\n    }: { networkClientId?: NetworkClientId; userAddress?: string } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const updatedNfts = await Promise.all(\n      nfts.map(async (nft) => {\n        return (\n          (await this.checkAndUpdateSingleNftOwnershipStatus(nft, true, {\n            networkClientId,\n            userAddress,\n          })) ?? nft\n        );\n      }),\n    );\n\n    this.updateNestedNftState(updatedNfts, ALL_NFTS_STATE_KEY, {\n      userAddress,\n      chainId,\n    });\n  }\n\n  /**\n   * Update NFT favorite status.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Hex address of the NFT contract.\n   * @param favorite - NFT new favorite status.\n   * @param options - an object of arguments\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   */\n  updateNftFavoriteStatus(\n    address: string,\n    tokenId: string,\n    favorite: boolean,\n    {\n      networkClientId,\n      userAddress = this.config.selectedAddress,\n    }: {\n      networkClientId?: NetworkClientId;\n      userAddress?: string;\n    } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const index: number = nfts.findIndex(\n      (nft) => nft.address === address && nft.tokenId === tokenId,\n    );\n\n    if (index === -1) {\n      return;\n    }\n\n    const updatedNft: Nft = {\n      ...nfts[index],\n      favorite,\n    };\n\n    // Update Nfts array\n    nfts[index] = updatedNft;\n\n    this.updateNestedNftState(nfts, ALL_NFTS_STATE_KEY, {\n      chainId,\n      userAddress,\n    });\n  }\n\n  /**\n   * Returns an NFT by the address and token id.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Number that represents the id of the token.\n   * @param selectedAddress - Hex address of the user account.\n   * @param chainId - Id of the current network.\n   * @returns Object containing the NFT and its position in the array\n   */\n  findNftByAddressAndTokenId(\n    address: string,\n    tokenId: string,\n    selectedAddress: string,\n    chainId: Hex,\n  ): { nft: Nft; index: number } | null {\n    const { allNfts } = this.state;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const index: number = nfts.findIndex(\n      (nft) =>\n        nft.address.toLowerCase() === address.toLowerCase() &&\n        nft.tokenId === tokenId,\n    );\n\n    if (index === -1) {\n      return null;\n    }\n\n    return { nft: nfts[index], index };\n  }\n\n  /**\n   * Update NFT data.\n   *\n   * @param nft - NFT object to find the right NFT to updates.\n   * @param updates - NFT partial object to update properties of the NFT.\n   * @param selectedAddress - Hex address of the user account.\n   * @param chainId - Id of the current network.\n   */\n  updateNft(\n    nft: Nft,\n    updates: Partial<Nft>,\n    selectedAddress: string,\n    chainId: Hex,\n  ) {\n    const { allNfts } = this.state;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const nftInfo = this.findNftByAddressAndTokenId(\n      nft.address,\n      nft.tokenId,\n      selectedAddress,\n      chainId,\n    );\n\n    if (!nftInfo) {\n      return;\n    }\n\n    const updatedNft: Nft = {\n      ...nft,\n      ...updates,\n    };\n\n    const newNfts = [\n      ...nfts.slice(0, nftInfo.index),\n      updatedNft,\n      ...nfts.slice(nftInfo.index + 1),\n    ];\n\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n      chainId,\n      userAddress: selectedAddress,\n    });\n  }\n\n  /**\n   * Resets the transaction status of an NFT.\n   *\n   * @param transactionId - NFT transaction id.\n   * @param selectedAddress - Hex address of the user account.\n   * @param chainId - Id of the current network.\n   * @returns a boolean indicating if the reset was well succeeded or not\n   */\n  resetNftTransactionStatusByTransactionId(\n    transactionId: string,\n    selectedAddress: string,\n    chainId: Hex,\n  ): boolean {\n    const { allNfts } = this.state;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const index: number = nfts.findIndex(\n      (nft) => nft.transactionId === transactionId,\n    );\n\n    if (index === -1) {\n      return false;\n    }\n    const updatedNft: Nft = {\n      ...nfts[index],\n      transactionId: undefined,\n    };\n\n    const newNfts = [\n      ...nfts.slice(0, index),\n      updatedNft,\n      ...nfts.slice(index + 1),\n    ];\n\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n      chainId,\n      userAddress: selectedAddress,\n    });\n\n    return true;\n  }\n\n  async _requestApproval(suggestedNftMeta: SuggestedNftMeta) {\n    return this.messagingSystem.call(\n      'ApprovalController:addRequest',\n      {\n        id: suggestedNftMeta.id,\n        origin: suggestedNftMeta.origin,\n        type: ApprovalType.WatchAsset,\n        requestData: {\n          id: suggestedNftMeta.id,\n          interactingAddress: suggestedNftMeta.interactingAddress,\n          asset: {\n            address: suggestedNftMeta.asset.address,\n            tokenId: suggestedNftMeta.asset.tokenId,\n            name: suggestedNftMeta.asset.name,\n            description: suggestedNftMeta.asset.description,\n            image: suggestedNftMeta.asset.image,\n            standard: suggestedNftMeta.asset.standard,\n          },\n        },\n      },\n      true,\n    );\n  }\n}\n\nexport default NftController;\n"],"mappings":"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","names":["OpenSeaV2ChainIds"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-XEZJ5XMV.js b/node_modules/@metamask/assets-controllers/dist/chunk-XEZJ5XMV.js
new file mode 100644
index 0000000..b9f398d
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-XEZJ5XMV.js
@@ -0,0 +1,411 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+
+var _chunkRELRWIJNjs = require('./chunk-RELRWIJN.js');
+
+
+
+
+
+var _chunkZ4BLTVTBjs = require('./chunk-Z4BLTVTB.js');
+
+// src/TokenDetectionController.ts
+var _contractmetadata = require('@metamask/contract-metadata'); var _contractmetadata2 = _interopRequireDefault(_contractmetadata);
+var _controllerutils = require('@metamask/controller-utils');
+var _pollingcontroller = require('@metamask/polling-controller');
+var DEFAULT_INTERVAL = 18e4;
+function isEqualCaseInsensitive(value1, value2) {
+  if (typeof value1 !== "string" || typeof value2 !== "string") {
+    return false;
+  }
+  return value1.toLowerCase() === value2.toLowerCase();
+}
+var STATIC_MAINNET_TOKEN_LIST = Object.entries(
+  _contractmetadata2.default
+).reduce((acc, [base, contract]) => {
+  const { logo, erc20, erc721, ...tokenMetadata } = contract;
+  return {
+    ...acc,
+    [base.toLowerCase()]: {
+      ...tokenMetadata,
+      address: base.toLowerCase(),
+      iconUrl: `images/contract/${logo}`,
+      aggregators: []
+    }
+  };
+}, {});
+var controllerName = "TokenDetectionController";
+var _intervalId, _selectedAddress, _networkClientId, _tokenList, _disabled, _isUnlocked, _isDetectionEnabledFromPreferences, _isDetectionEnabledForNetwork, _getBalancesInSingleCall, _trackMetaMetricsEvent, _registerEventListeners, registerEventListeners_fn, _stopPolling, stopPolling_fn, _startPolling, startPolling_fn, _getCorrectChainIdAndNetworkClientId, getCorrectChainIdAndNetworkClientId_fn, _restartTokenDetection, restartTokenDetection_fn, _getSlicesOfTokensToDetect, getSlicesOfTokensToDetect_fn, _addDetectedTokens, addDetectedTokens_fn;
+var TokenDetectionController = class extends _pollingcontroller.StaticIntervalPollingController {
+  /**
+   * Creates a TokenDetectionController instance.
+   *
+   * @param options - The controller options.
+   * @param options.messenger - The controller messaging system.
+   * @param options.disabled - If set to true, all network requests are blocked.
+   * @param options.interval - Polling interval used to fetch new token rates
+   * @param options.selectedAddress - Vault selected address
+   * @param options.getBalancesInSingleCall - Gets the balances of a list of tokens for the given address.
+   * @param options.trackMetaMetricsEvent - Sets options for MetaMetrics event tracking.
+   */
+  constructor({
+    selectedAddress,
+    interval = DEFAULT_INTERVAL,
+    disabled = true,
+    getBalancesInSingleCall,
+    trackMetaMetricsEvent,
+    messenger
+  }) {
+    super({
+      name: controllerName,
+      messenger,
+      state: {},
+      metadata: {}
+    });
+    /**
+     * Constructor helper for registering this controller's messaging system subscriptions to controller events.
+     */
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _registerEventListeners);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _stopPolling);
+    /**
+     * Starts a new polling interval.
+     */
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _startPolling);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getCorrectChainIdAndNetworkClientId);
+    /**
+     * Restart token detection polling period and call detectNewTokens
+     * in case of address change or user session initialization.
+     *
+     * @param options - Options for restart token detection.
+     * @param options.selectedAddress - the selectedAddress against which to detect for token balances
+     * @param options.networkClientId - The ID of the network client to use.
+     */
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _restartTokenDetection);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getSlicesOfTokensToDetect);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _addDetectedTokens);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _intervalId, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _selectedAddress, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _networkClientId, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _tokenList, {});
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _disabled, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _isUnlocked, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _isDetectionEnabledFromPreferences, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _isDetectionEnabledForNetwork, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getBalancesInSingleCall, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _trackMetaMetricsEvent, void 0);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _disabled, disabled);
+    this.setIntervalLength(interval);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _selectedAddress, selectedAddress ?? this.messagingSystem.call("AccountsController:getSelectedAccount").address);
+    const { chainId, networkClientId } = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getCorrectChainIdAndNetworkClientId, getCorrectChainIdAndNetworkClientId_fn).call(this);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _networkClientId, networkClientId);
+    const { useTokenDetection: defaultUseTokenDetection } = this.messagingSystem.call("PreferencesController:getState");
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _isDetectionEnabledFromPreferences, defaultUseTokenDetection);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _isDetectionEnabledForNetwork, _chunkRELRWIJNjs.isTokenDetectionSupportedForNetwork.call(void 0, chainId));
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _getBalancesInSingleCall, getBalancesInSingleCall);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _trackMetaMetricsEvent, trackMetaMetricsEvent);
+    const { isUnlocked } = this.messagingSystem.call(
+      "KeyringController:getState"
+    );
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _isUnlocked, isUnlocked);
+    _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _registerEventListeners, registerEventListeners_fn).call(this);
+  }
+  /**
+   * Allows controller to make active and passive polling requests
+   */
+  enable() {
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _disabled, false);
+  }
+  /**
+   * Blocks controller from making network calls
+   */
+  disable() {
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _disabled, true);
+  }
+  /**
+   * Internal isActive state
+   * @type {boolean}
+   */
+  get isActive() {
+    return !_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _disabled) && _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _isUnlocked);
+  }
+  /**
+   * Start polling for detected tokens.
+   */
+  async start() {
+    this.enable();
+    await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _startPolling, startPolling_fn).call(this);
+  }
+  /**
+   * Stop polling for detected tokens.
+   */
+  stop() {
+    this.disable();
+    _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _stopPolling, stopPolling_fn).call(this);
+  }
+  async _executePoll(networkClientId, options) {
+    if (!this.isActive) {
+      return;
+    }
+    await this.detectTokens({
+      networkClientId,
+      selectedAddress: options.address
+    });
+  }
+  /**
+   * For each token in the token list provided by the TokenListController, checks the token's balance for the selected account address on the active network.
+   * On mainnet, if token detection is disabled in preferences, ERC20 token auto detection will be triggered for each contract address in the legacy token list from the @metamask/contract-metadata repo.
+   *
+   * @param options - Options for token detection.
+   * @param options.networkClientId - The ID of the network client to use.
+   * @param options.selectedAddress - the selectedAddress against which to detect for token balances.
+   */
+  async detectTokens({
+    networkClientId,
+    selectedAddress
+  } = {}) {
+    if (!this.isActive) {
+      return;
+    }
+    const addressAgainstWhichToDetect = selectedAddress ?? _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _selectedAddress);
+    const { chainId, networkClientId: selectedNetworkClientId } = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getCorrectChainIdAndNetworkClientId, getCorrectChainIdAndNetworkClientId_fn).call(this, networkClientId);
+    const chainIdAgainstWhichToDetect = chainId;
+    const networkClientIdAgainstWhichToDetect = selectedNetworkClientId;
+    if (!_chunkRELRWIJNjs.isTokenDetectionSupportedForNetwork.call(void 0, chainIdAgainstWhichToDetect)) {
+      return;
+    }
+    if (!_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _isDetectionEnabledFromPreferences) && chainIdAgainstWhichToDetect !== _controllerutils.ChainId.mainnet) {
+      return;
+    }
+    const isTokenDetectionInactiveInMainnet = !_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _isDetectionEnabledFromPreferences) && chainIdAgainstWhichToDetect === _controllerutils.ChainId.mainnet;
+    const { tokensChainsCache } = this.messagingSystem.call(
+      "TokenListController:getState"
+    );
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _tokenList, isTokenDetectionInactiveInMainnet ? STATIC_MAINNET_TOKEN_LIST : tokensChainsCache[chainIdAgainstWhichToDetect]?.data ?? {});
+    for (const tokensSlice of _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getSlicesOfTokensToDetect, getSlicesOfTokensToDetect_fn).call(this, {
+      chainId: chainIdAgainstWhichToDetect,
+      selectedAddress: addressAgainstWhichToDetect
+    })) {
+      await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _addDetectedTokens, addDetectedTokens_fn).call(this, {
+        tokensSlice,
+        selectedAddress: addressAgainstWhichToDetect,
+        networkClientId: networkClientIdAgainstWhichToDetect,
+        chainId: chainIdAgainstWhichToDetect
+      });
+    }
+  }
+};
+_intervalId = new WeakMap();
+_selectedAddress = new WeakMap();
+_networkClientId = new WeakMap();
+_tokenList = new WeakMap();
+_disabled = new WeakMap();
+_isUnlocked = new WeakMap();
+_isDetectionEnabledFromPreferences = new WeakMap();
+_isDetectionEnabledForNetwork = new WeakMap();
+_getBalancesInSingleCall = new WeakMap();
+_trackMetaMetricsEvent = new WeakMap();
+_registerEventListeners = new WeakSet();
+registerEventListeners_fn = function() {
+  this.messagingSystem.subscribe("KeyringController:unlock", async () => {
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _isUnlocked, true);
+    await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _restartTokenDetection, restartTokenDetection_fn).call(this);
+  });
+  this.messagingSystem.subscribe("KeyringController:lock", () => {
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _isUnlocked, false);
+    _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _stopPolling, stopPolling_fn).call(this);
+  });
+  this.messagingSystem.subscribe(
+    "TokenListController:stateChange",
+    async ({ tokenList }) => {
+      const hasTokens = Object.keys(tokenList).length;
+      if (hasTokens) {
+        await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _restartTokenDetection, restartTokenDetection_fn).call(this);
+      }
+    }
+  );
+  this.messagingSystem.subscribe(
+    "PreferencesController:stateChange",
+    async ({ selectedAddress: newSelectedAddress, useTokenDetection }) => {
+      const isSelectedAddressChanged = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _selectedAddress) !== newSelectedAddress;
+      const isDetectionChangedFromPreferences = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _isDetectionEnabledFromPreferences) !== useTokenDetection;
+      _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _selectedAddress, newSelectedAddress);
+      _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _isDetectionEnabledFromPreferences, useTokenDetection);
+      if (useTokenDetection && (isSelectedAddressChanged || isDetectionChangedFromPreferences)) {
+        await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _restartTokenDetection, restartTokenDetection_fn).call(this, {
+          selectedAddress: _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _selectedAddress)
+        });
+      }
+    }
+  );
+  this.messagingSystem.subscribe(
+    "AccountsController:selectedAccountChange",
+    async ({ address: newSelectedAddress }) => {
+      const isSelectedAddressChanged = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _selectedAddress) !== newSelectedAddress;
+      if (isSelectedAddressChanged && _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _isDetectionEnabledFromPreferences)) {
+        _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _selectedAddress, newSelectedAddress);
+        await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _restartTokenDetection, restartTokenDetection_fn).call(this, {
+          selectedAddress: _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _selectedAddress)
+        });
+      }
+    }
+  );
+  this.messagingSystem.subscribe(
+    "NetworkController:networkDidChange",
+    async ({ selectedNetworkClientId }) => {
+      const isNetworkClientIdChanged = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _networkClientId) !== selectedNetworkClientId;
+      const { chainId: newChainId } = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getCorrectChainIdAndNetworkClientId, getCorrectChainIdAndNetworkClientId_fn).call(this, selectedNetworkClientId);
+      _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _isDetectionEnabledForNetwork, _chunkRELRWIJNjs.isTokenDetectionSupportedForNetwork.call(void 0, newChainId));
+      if (isNetworkClientIdChanged && _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _isDetectionEnabledForNetwork)) {
+        _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _networkClientId, selectedNetworkClientId);
+        await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _restartTokenDetection, restartTokenDetection_fn).call(this, {
+          networkClientId: _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _networkClientId)
+        });
+      }
+    }
+  );
+};
+_stopPolling = new WeakSet();
+stopPolling_fn = function() {
+  if (_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _intervalId)) {
+    clearInterval(_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _intervalId));
+  }
+};
+_startPolling = new WeakSet();
+startPolling_fn = async function() {
+  if (!this.isActive) {
+    return;
+  }
+  _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _stopPolling, stopPolling_fn).call(this);
+  await this.detectTokens();
+  _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _intervalId, setInterval(async () => {
+    await this.detectTokens();
+  }, this.getIntervalLength()));
+};
+_getCorrectChainIdAndNetworkClientId = new WeakSet();
+getCorrectChainIdAndNetworkClientId_fn = function(networkClientId) {
+  if (networkClientId) {
+    const networkConfiguration = this.messagingSystem.call(
+      "NetworkController:getNetworkConfigurationByNetworkClientId",
+      networkClientId
+    );
+    if (networkConfiguration) {
+      return {
+        chainId: networkConfiguration.chainId,
+        networkClientId
+      };
+    }
+  }
+  const { selectedNetworkClientId } = this.messagingSystem.call(
+    "NetworkController:getState"
+  );
+  const {
+    configuration: { chainId }
+  } = this.messagingSystem.call(
+    "NetworkController:getNetworkClientById",
+    selectedNetworkClientId
+  );
+  return {
+    chainId,
+    networkClientId: selectedNetworkClientId
+  };
+};
+_restartTokenDetection = new WeakSet();
+restartTokenDetection_fn = async function({
+  selectedAddress,
+  networkClientId
+} = {}) {
+  await this.detectTokens({
+    networkClientId,
+    selectedAddress
+  });
+  this.setIntervalLength(DEFAULT_INTERVAL);
+};
+_getSlicesOfTokensToDetect = new WeakSet();
+getSlicesOfTokensToDetect_fn = function({
+  chainId,
+  selectedAddress
+}) {
+  const { allTokens, allDetectedTokens, allIgnoredTokens } = this.messagingSystem.call("TokensController:getState");
+  const [tokensAddresses, detectedTokensAddresses, ignoredTokensAddresses] = [
+    allTokens,
+    allDetectedTokens,
+    allIgnoredTokens
+  ].map(
+    (tokens) => (tokens[chainId]?.[selectedAddress] ?? []).map(
+      (value) => typeof value === "string" ? value : value.address
+    )
+  );
+  const tokensToDetect = [];
+  for (const tokenAddress of Object.keys(_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _tokenList))) {
+    if ([
+      tokensAddresses,
+      detectedTokensAddresses,
+      ignoredTokensAddresses
+    ].every(
+      (addresses) => !addresses.find(
+        (address) => isEqualCaseInsensitive(address, tokenAddress)
+      )
+    )) {
+      tokensToDetect.push(tokenAddress);
+    }
+  }
+  const slicesOfTokensToDetect = [];
+  for (let i = 0, size = 1e3; i < tokensToDetect.length; i += size) {
+    slicesOfTokensToDetect.push(tokensToDetect.slice(i, i + size));
+  }
+  return slicesOfTokensToDetect;
+};
+_addDetectedTokens = new WeakSet();
+addDetectedTokens_fn = async function({
+  tokensSlice,
+  selectedAddress,
+  networkClientId,
+  chainId
+}) {
+  await _controllerutils.safelyExecute.call(void 0, async () => {
+    const balances = await _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _getBalancesInSingleCall).call(this, selectedAddress, tokensSlice, networkClientId);
+    const tokensWithBalance = [];
+    const eventTokensDetails = [];
+    for (const nonZeroTokenAddress of Object.keys(balances)) {
+      const { decimals, symbol, aggregators, iconUrl, name } = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _tokenList)[nonZeroTokenAddress];
+      eventTokensDetails.push(`${symbol} - ${nonZeroTokenAddress}`);
+      tokensWithBalance.push({
+        address: nonZeroTokenAddress,
+        decimals,
+        symbol,
+        aggregators,
+        image: iconUrl,
+        isERC721: false,
+        name
+      });
+    }
+    if (tokensWithBalance.length) {
+      _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _trackMetaMetricsEvent).call(this, {
+        event: "Token Detected",
+        category: "Wallet",
+        properties: {
+          tokens: eventTokensDetails,
+          token_standard: "ERC20",
+          asset_type: "TOKEN"
+        }
+      });
+      await this.messagingSystem.call(
+        "TokensController:addDetectedTokens",
+        tokensWithBalance,
+        {
+          selectedAddress,
+          chainId
+        }
+      );
+    }
+  });
+};
+var TokenDetectionController_default = TokenDetectionController;
+
+
+
+
+
+
+
+exports.isEqualCaseInsensitive = isEqualCaseInsensitive; exports.STATIC_MAINNET_TOKEN_LIST = STATIC_MAINNET_TOKEN_LIST; exports.controllerName = controllerName; exports.TokenDetectionController = TokenDetectionController; exports.TokenDetectionController_default = TokenDetectionController_default;
+//# sourceMappingURL=chunk-XEZJ5XMV.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-XEZJ5XMV.js.map b/node_modules/@metamask/assets-controllers/dist/chunk-XEZJ5XMV.js.map
new file mode 100644
index 0000000..dbc07f5
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-XEZJ5XMV.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/TokenDetectionController.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  AccountsControllerGetSelectedAccountAction,\n  AccountsControllerSelectedAccountChangeEvent,\n} from '@metamask/accounts-controller';\nimport type {\n  RestrictedControllerMessenger,\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n} from '@metamask/base-controller';\nimport contractMap from '@metamask/contract-metadata';\nimport { ChainId, safelyExecute } from '@metamask/controller-utils';\nimport type {\n  KeyringControllerGetStateAction,\n  KeyringControllerLockEvent,\n  KeyringControllerUnlockEvent,\n} from '@metamask/keyring-controller';\nimport type {\n  NetworkClientId,\n  NetworkControllerGetNetworkClientByIdAction,\n  NetworkControllerGetNetworkConfigurationByNetworkClientId,\n  NetworkControllerGetStateAction,\n  NetworkControllerNetworkDidChangeEvent,\n} from '@metamask/network-controller';\nimport { StaticIntervalPollingController } from '@metamask/polling-controller';\nimport type {\n  PreferencesControllerGetStateAction,\n  PreferencesControllerStateChangeEvent,\n} from '@metamask/preferences-controller';\nimport type { Hex } from '@metamask/utils';\n\nimport type { AssetsContractController } from './AssetsContractController';\nimport { isTokenDetectionSupportedForNetwork } from './assetsUtil';\nimport type {\n  GetTokenListState,\n  TokenListMap,\n  TokenListStateChange,\n} from './TokenListController';\nimport type { Token } from './TokenRatesController';\nimport type {\n  TokensControllerAddDetectedTokensAction,\n  TokensControllerGetStateAction,\n} from './TokensController';\n\nconst DEFAULT_INTERVAL = 180000;\n\n/**\n * Compare 2 given strings and return boolean\n * eg: \"foo\" and \"FOO\" => true\n * eg: \"foo\" and \"bar\" => false\n * eg: \"foo\" and 123 => false\n *\n * @param value1 - first string to compare\n * @param value2 - first string to compare\n * @returns true if 2 strings are identical when they are lowercase\n */\nexport function isEqualCaseInsensitive(\n  value1: string,\n  value2: string,\n): boolean {\n  if (typeof value1 !== 'string' || typeof value2 !== 'string') {\n    return false;\n  }\n  return value1.toLowerCase() === value2.toLowerCase();\n}\n\ntype LegacyToken = {\n  name: string;\n  logo: `${string}.svg`;\n  symbol: string;\n  decimals: number;\n  erc20?: boolean;\n  erc721?: boolean;\n};\n\ntype TokenDetectionMap = {\n  [P in keyof TokenListMap]: Omit<TokenListMap[P], 'occurrences'>;\n};\n\nexport const STATIC_MAINNET_TOKEN_LIST = Object.entries<LegacyToken>(\n  contractMap,\n).reduce<TokenDetectionMap>((acc, [base, contract]) => {\n  const { logo, erc20, erc721, ...tokenMetadata } = contract;\n  return {\n    ...acc,\n    [base.toLowerCase()]: {\n      ...tokenMetadata,\n      address: base.toLowerCase(),\n      iconUrl: `images/contract/${logo}`,\n      aggregators: [],\n    },\n  };\n}, {});\n\nexport const controllerName = 'TokenDetectionController';\n\nexport type TokenDetectionState = Record<never, never>;\n\nexport type TokenDetectionControllerGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  TokenDetectionState\n>;\n\nexport type TokenDetectionControllerActions =\n  TokenDetectionControllerGetStateAction;\n\nexport type AllowedActions =\n  | AccountsControllerGetSelectedAccountAction\n  | NetworkControllerGetNetworkClientByIdAction\n  | NetworkControllerGetNetworkConfigurationByNetworkClientId\n  | NetworkControllerGetStateAction\n  | GetTokenListState\n  | KeyringControllerGetStateAction\n  | PreferencesControllerGetStateAction\n  | TokensControllerGetStateAction\n  | TokensControllerAddDetectedTokensAction;\n\nexport type TokenDetectionControllerStateChangeEvent =\n  ControllerStateChangeEvent<typeof controllerName, TokenDetectionState>;\n\nexport type TokenDetectionControllerEvents =\n  TokenDetectionControllerStateChangeEvent;\n\nexport type AllowedEvents =\n  | AccountsControllerSelectedAccountChangeEvent\n  | NetworkControllerNetworkDidChangeEvent\n  | TokenListStateChange\n  | KeyringControllerLockEvent\n  | KeyringControllerUnlockEvent\n  | PreferencesControllerStateChangeEvent;\n\nexport type TokenDetectionControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  TokenDetectionControllerActions | AllowedActions,\n  TokenDetectionControllerEvents | AllowedEvents,\n  AllowedActions['type'],\n  AllowedEvents['type']\n>;\n\n/**\n * Controller that passively polls on a set interval for Tokens auto detection\n * @property intervalId - Polling interval used to fetch new token rates\n * @property selectedAddress - Vault selected address\n * @property networkClientId - The network client ID of the current selected network\n * @property disabled - Boolean to track if network requests are blocked\n * @property isUnlocked - Boolean to track if the keyring state is unlocked\n * @property isDetectionEnabledFromPreferences - Boolean to track if detection is enabled from PreferencesController\n * @property isDetectionEnabledForNetwork - Boolean to track if detected is enabled for current network\n */\nexport class TokenDetectionController extends StaticIntervalPollingController<\n  typeof controllerName,\n  TokenDetectionState,\n  TokenDetectionControllerMessenger\n> {\n  #intervalId?: ReturnType<typeof setTimeout>;\n\n  #selectedAddress: string;\n\n  #networkClientId: NetworkClientId;\n\n  #tokenList: TokenDetectionMap = {};\n\n  #disabled: boolean;\n\n  #isUnlocked: boolean;\n\n  #isDetectionEnabledFromPreferences: boolean;\n\n  #isDetectionEnabledForNetwork: boolean;\n\n  readonly #getBalancesInSingleCall: AssetsContractController['getBalancesInSingleCall'];\n\n  readonly #trackMetaMetricsEvent: (options: {\n    event: string;\n    category: string;\n    properties: {\n      tokens: string[];\n      token_standard: string;\n      asset_type: string;\n    };\n  }) => void;\n\n  /**\n   * Creates a TokenDetectionController instance.\n   *\n   * @param options - The controller options.\n   * @param options.messenger - The controller messaging system.\n   * @param options.disabled - If set to true, all network requests are blocked.\n   * @param options.interval - Polling interval used to fetch new token rates\n   * @param options.selectedAddress - Vault selected address\n   * @param options.getBalancesInSingleCall - Gets the balances of a list of tokens for the given address.\n   * @param options.trackMetaMetricsEvent - Sets options for MetaMetrics event tracking.\n   */\n  constructor({\n    selectedAddress,\n    interval = DEFAULT_INTERVAL,\n    disabled = true,\n    getBalancesInSingleCall,\n    trackMetaMetricsEvent,\n    messenger,\n  }: {\n    selectedAddress?: string;\n    interval?: number;\n    disabled?: boolean;\n    getBalancesInSingleCall: AssetsContractController['getBalancesInSingleCall'];\n    trackMetaMetricsEvent: (options: {\n      event: string;\n      category: string;\n      properties: {\n        tokens: string[];\n        token_standard: string;\n        asset_type: string;\n      };\n    }) => void;\n    messenger: TokenDetectionControllerMessenger;\n  }) {\n    super({\n      name: controllerName,\n      messenger,\n      state: {},\n      metadata: {},\n    });\n\n    this.#disabled = disabled;\n    this.setIntervalLength(interval);\n\n    this.#selectedAddress =\n      selectedAddress ??\n      this.messagingSystem.call('AccountsController:getSelectedAccount')\n        .address;\n\n    const { chainId, networkClientId } =\n      this.#getCorrectChainIdAndNetworkClientId();\n    this.#networkClientId = networkClientId;\n\n    const { useTokenDetection: defaultUseTokenDetection } =\n      this.messagingSystem.call('PreferencesController:getState');\n    this.#isDetectionEnabledFromPreferences = defaultUseTokenDetection;\n    this.#isDetectionEnabledForNetwork =\n      isTokenDetectionSupportedForNetwork(chainId);\n\n    this.#getBalancesInSingleCall = getBalancesInSingleCall;\n\n    this.#trackMetaMetricsEvent = trackMetaMetricsEvent;\n\n    const { isUnlocked } = this.messagingSystem.call(\n      'KeyringController:getState',\n    );\n    this.#isUnlocked = isUnlocked;\n\n    this.#registerEventListeners();\n  }\n\n  /**\n   * Constructor helper for registering this controller's messaging system subscriptions to controller events.\n   */\n  #registerEventListeners() {\n    this.messagingSystem.subscribe('KeyringController:unlock', async () => {\n      this.#isUnlocked = true;\n      await this.#restartTokenDetection();\n    });\n\n    this.messagingSystem.subscribe('KeyringController:lock', () => {\n      this.#isUnlocked = false;\n      this.#stopPolling();\n    });\n\n    this.messagingSystem.subscribe(\n      'TokenListController:stateChange',\n      async ({ tokenList }) => {\n        const hasTokens = Object.keys(tokenList).length;\n\n        if (hasTokens) {\n          await this.#restartTokenDetection();\n        }\n      },\n    );\n\n    this.messagingSystem.subscribe(\n      'PreferencesController:stateChange',\n      async ({ selectedAddress: newSelectedAddress, useTokenDetection }) => {\n        const isSelectedAddressChanged =\n          this.#selectedAddress !== newSelectedAddress;\n        const isDetectionChangedFromPreferences =\n          this.#isDetectionEnabledFromPreferences !== useTokenDetection;\n\n        this.#selectedAddress = newSelectedAddress;\n        this.#isDetectionEnabledFromPreferences = useTokenDetection;\n\n        if (\n          useTokenDetection &&\n          (isSelectedAddressChanged || isDetectionChangedFromPreferences)\n        ) {\n          await this.#restartTokenDetection({\n            selectedAddress: this.#selectedAddress,\n          });\n        }\n      },\n    );\n\n    this.messagingSystem.subscribe(\n      'AccountsController:selectedAccountChange',\n      async ({ address: newSelectedAddress }) => {\n        const isSelectedAddressChanged =\n          this.#selectedAddress !== newSelectedAddress;\n        if (\n          isSelectedAddressChanged &&\n          this.#isDetectionEnabledFromPreferences\n        ) {\n          this.#selectedAddress = newSelectedAddress;\n          await this.#restartTokenDetection({\n            selectedAddress: this.#selectedAddress,\n          });\n        }\n      },\n    );\n\n    this.messagingSystem.subscribe(\n      'NetworkController:networkDidChange',\n      async ({ selectedNetworkClientId }) => {\n        const isNetworkClientIdChanged =\n          this.#networkClientId !== selectedNetworkClientId;\n\n        const { chainId: newChainId } =\n          this.#getCorrectChainIdAndNetworkClientId(selectedNetworkClientId);\n        this.#isDetectionEnabledForNetwork =\n          isTokenDetectionSupportedForNetwork(newChainId);\n\n        if (isNetworkClientIdChanged && this.#isDetectionEnabledForNetwork) {\n          this.#networkClientId = selectedNetworkClientId;\n          await this.#restartTokenDetection({\n            networkClientId: this.#networkClientId,\n          });\n        }\n      },\n    );\n  }\n\n  /**\n   * Allows controller to make active and passive polling requests\n   */\n  enable(): void {\n    this.#disabled = false;\n  }\n\n  /**\n   * Blocks controller from making network calls\n   */\n  disable(): void {\n    this.#disabled = true;\n  }\n\n  /**\n   * Internal isActive state\n   * @type {boolean}\n   */\n  get isActive(): boolean {\n    return !this.#disabled && this.#isUnlocked;\n  }\n\n  /**\n   * Start polling for detected tokens.\n   */\n  async start(): Promise<void> {\n    this.enable();\n    await this.#startPolling();\n  }\n\n  /**\n   * Stop polling for detected tokens.\n   */\n  stop(): void {\n    this.disable();\n    this.#stopPolling();\n  }\n\n  #stopPolling(): void {\n    if (this.#intervalId) {\n      clearInterval(this.#intervalId);\n    }\n  }\n\n  /**\n   * Starts a new polling interval.\n   */\n  async #startPolling(): Promise<void> {\n    if (!this.isActive) {\n      return;\n    }\n    this.#stopPolling();\n    await this.detectTokens();\n    this.#intervalId = setInterval(async () => {\n      await this.detectTokens();\n    }, this.getIntervalLength());\n  }\n\n  #getCorrectChainIdAndNetworkClientId(networkClientId?: NetworkClientId): {\n    chainId: Hex;\n    networkClientId: NetworkClientId;\n  } {\n    if (networkClientId) {\n      const networkConfiguration = this.messagingSystem.call(\n        'NetworkController:getNetworkConfigurationByNetworkClientId',\n        networkClientId,\n      );\n      if (networkConfiguration) {\n        return {\n          chainId: networkConfiguration.chainId,\n          networkClientId,\n        };\n      }\n    }\n    const { selectedNetworkClientId } = this.messagingSystem.call(\n      'NetworkController:getState',\n    );\n    const {\n      configuration: { chainId },\n    } = this.messagingSystem.call(\n      'NetworkController:getNetworkClientById',\n      selectedNetworkClientId,\n    );\n    return {\n      chainId,\n      networkClientId: selectedNetworkClientId,\n    };\n  }\n\n  async _executePoll(\n    networkClientId: NetworkClientId,\n    options: { address: string },\n  ): Promise<void> {\n    if (!this.isActive) {\n      return;\n    }\n    await this.detectTokens({\n      networkClientId,\n      selectedAddress: options.address,\n    });\n  }\n\n  /**\n   * Restart token detection polling period and call detectNewTokens\n   * in case of address change or user session initialization.\n   *\n   * @param options - Options for restart token detection.\n   * @param options.selectedAddress - the selectedAddress against which to detect for token balances\n   * @param options.networkClientId - The ID of the network client to use.\n   */\n  async #restartTokenDetection({\n    selectedAddress,\n    networkClientId,\n  }: {\n    selectedAddress?: string;\n    networkClientId?: NetworkClientId;\n  } = {}): Promise<void> {\n    await this.detectTokens({\n      networkClientId,\n      selectedAddress,\n    });\n    this.setIntervalLength(DEFAULT_INTERVAL);\n  }\n\n  /**\n   * For each token in the token list provided by the TokenListController, checks the token's balance for the selected account address on the active network.\n   * On mainnet, if token detection is disabled in preferences, ERC20 token auto detection will be triggered for each contract address in the legacy token list from the @metamask/contract-metadata repo.\n   *\n   * @param options - Options for token detection.\n   * @param options.networkClientId - The ID of the network client to use.\n   * @param options.selectedAddress - the selectedAddress against which to detect for token balances.\n   */\n  async detectTokens({\n    networkClientId,\n    selectedAddress,\n  }: {\n    networkClientId?: NetworkClientId;\n    selectedAddress?: string;\n  } = {}): Promise<void> {\n    if (!this.isActive) {\n      return;\n    }\n\n    const addressAgainstWhichToDetect =\n      selectedAddress ?? this.#selectedAddress;\n    const { chainId, networkClientId: selectedNetworkClientId } =\n      this.#getCorrectChainIdAndNetworkClientId(networkClientId);\n    const chainIdAgainstWhichToDetect = chainId;\n    const networkClientIdAgainstWhichToDetect = selectedNetworkClientId;\n\n    if (!isTokenDetectionSupportedForNetwork(chainIdAgainstWhichToDetect)) {\n      return;\n    }\n    if (\n      !this.#isDetectionEnabledFromPreferences &&\n      chainIdAgainstWhichToDetect !== ChainId.mainnet\n    ) {\n      return;\n    }\n    const isTokenDetectionInactiveInMainnet =\n      !this.#isDetectionEnabledFromPreferences &&\n      chainIdAgainstWhichToDetect === ChainId.mainnet;\n    const { tokensChainsCache } = this.messagingSystem.call(\n      'TokenListController:getState',\n    );\n    this.#tokenList = isTokenDetectionInactiveInMainnet\n      ? STATIC_MAINNET_TOKEN_LIST\n      : tokensChainsCache[chainIdAgainstWhichToDetect]?.data ?? {};\n\n    for (const tokensSlice of this.#getSlicesOfTokensToDetect({\n      chainId: chainIdAgainstWhichToDetect,\n      selectedAddress: addressAgainstWhichToDetect,\n    })) {\n      await this.#addDetectedTokens({\n        tokensSlice,\n        selectedAddress: addressAgainstWhichToDetect,\n        networkClientId: networkClientIdAgainstWhichToDetect,\n        chainId: chainIdAgainstWhichToDetect,\n      });\n    }\n  }\n\n  #getSlicesOfTokensToDetect({\n    chainId,\n    selectedAddress,\n  }: {\n    chainId: Hex;\n    selectedAddress: string;\n  }): string[][] {\n    const { allTokens, allDetectedTokens, allIgnoredTokens } =\n      this.messagingSystem.call('TokensController:getState');\n    const [tokensAddresses, detectedTokensAddresses, ignoredTokensAddresses] = [\n      allTokens,\n      allDetectedTokens,\n      allIgnoredTokens,\n    ].map((tokens) =>\n      (tokens[chainId]?.[selectedAddress] ?? []).map((value) =>\n        typeof value === 'string' ? value : value.address,\n      ),\n    );\n\n    const tokensToDetect: string[] = [];\n    for (const tokenAddress of Object.keys(this.#tokenList)) {\n      if (\n        [\n          tokensAddresses,\n          detectedTokensAddresses,\n          ignoredTokensAddresses,\n        ].every(\n          (addresses) =>\n            !addresses.find((address) =>\n              isEqualCaseInsensitive(address, tokenAddress),\n            ),\n        )\n      ) {\n        tokensToDetect.push(tokenAddress);\n      }\n    }\n\n    const slicesOfTokensToDetect = [];\n    for (let i = 0, size = 1000; i < tokensToDetect.length; i += size) {\n      slicesOfTokensToDetect.push(tokensToDetect.slice(i, i + size));\n    }\n\n    return slicesOfTokensToDetect;\n  }\n\n  async #addDetectedTokens({\n    tokensSlice,\n    selectedAddress,\n    networkClientId,\n    chainId,\n  }: {\n    tokensSlice: string[];\n    selectedAddress: string;\n    networkClientId: NetworkClientId;\n    chainId: Hex;\n  }): Promise<void> {\n    await safelyExecute(async () => {\n      const balances = await this.#getBalancesInSingleCall(\n        selectedAddress,\n        tokensSlice,\n        networkClientId,\n      );\n\n      const tokensWithBalance: Token[] = [];\n      const eventTokensDetails: string[] = [];\n      for (const nonZeroTokenAddress of Object.keys(balances)) {\n        const { decimals, symbol, aggregators, iconUrl, name } =\n          this.#tokenList[nonZeroTokenAddress];\n        eventTokensDetails.push(`${symbol} - ${nonZeroTokenAddress}`);\n        tokensWithBalance.push({\n          address: nonZeroTokenAddress,\n          decimals,\n          symbol,\n          aggregators,\n          image: iconUrl,\n          isERC721: false,\n          name,\n        });\n      }\n\n      if (tokensWithBalance.length) {\n        this.#trackMetaMetricsEvent({\n          event: 'Token Detected',\n          category: 'Wallet',\n          properties: {\n            tokens: eventTokensDetails,\n            token_standard: 'ERC20',\n            asset_type: 'TOKEN',\n          },\n        });\n\n        await this.messagingSystem.call(\n          'TokensController:addDetectedTokens',\n          tokensWithBalance,\n          {\n            selectedAddress,\n            chainId,\n          },\n        );\n      }\n    });\n  }\n}\n\nexport default TokenDetectionController;\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-XUI43LEZ.mjs b/node_modules/@metamask/assets-controllers/dist/chunk-XUI43LEZ.mjs
new file mode 100644
index 0000000..b796d95
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-XUI43LEZ.mjs
@@ -0,0 +1,30 @@
+var __accessCheck = (obj, member, msg) => {
+  if (!member.has(obj))
+    throw TypeError("Cannot " + msg);
+};
+var __privateGet = (obj, member, getter) => {
+  __accessCheck(obj, member, "read from private field");
+  return getter ? getter.call(obj) : member.get(obj);
+};
+var __privateAdd = (obj, member, value) => {
+  if (member.has(obj))
+    throw TypeError("Cannot add the same private member more than once");
+  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
+};
+var __privateSet = (obj, member, value, setter) => {
+  __accessCheck(obj, member, "write to private field");
+  setter ? setter.call(obj, value) : member.set(obj, value);
+  return value;
+};
+var __privateMethod = (obj, member, method) => {
+  __accessCheck(obj, member, "access private method");
+  return method;
+};
+
+export {
+  __privateGet,
+  __privateAdd,
+  __privateSet,
+  __privateMethod
+};
+//# sourceMappingURL=chunk-XUI43LEZ.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-XUI43LEZ.mjs.map b/node_modules/@metamask/assets-controllers/dist/chunk-XUI43LEZ.mjs.map
new file mode 100644
index 0000000..84c51b2
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-XUI43LEZ.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":[],"sourcesContent":[],"mappings":"","names":[]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-Z4BLTVTB.js b/node_modules/@metamask/assets-controllers/dist/chunk-Z4BLTVTB.js
new file mode 100644
index 0000000..0ecaf70
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-Z4BLTVTB.js
@@ -0,0 +1,30 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});var __accessCheck = (obj, member, msg) => {
+  if (!member.has(obj))
+    throw TypeError("Cannot " + msg);
+};
+var __privateGet = (obj, member, getter) => {
+  __accessCheck(obj, member, "read from private field");
+  return getter ? getter.call(obj) : member.get(obj);
+};
+var __privateAdd = (obj, member, value) => {
+  if (member.has(obj))
+    throw TypeError("Cannot add the same private member more than once");
+  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
+};
+var __privateSet = (obj, member, value, setter) => {
+  __accessCheck(obj, member, "write to private field");
+  setter ? setter.call(obj, value) : member.set(obj, value);
+  return value;
+};
+var __privateMethod = (obj, member, method) => {
+  __accessCheck(obj, member, "access private method");
+  return method;
+};
+
+
+
+
+
+
+exports.__privateGet = __privateGet; exports.__privateAdd = __privateAdd; exports.__privateSet = __privateSet; exports.__privateMethod = __privateMethod;
+//# sourceMappingURL=chunk-Z4BLTVTB.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-Z4BLTVTB.js.map b/node_modules/@metamask/assets-controllers/dist/chunk-Z4BLTVTB.js.map
new file mode 100644
index 0000000..a464c67
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-Z4BLTVTB.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":[],"names":[],"mappings":""}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-ZKJSG4TA.mjs b/node_modules/@metamask/assets-controllers/dist/chunk-ZKJSG4TA.mjs
new file mode 100644
index 0000000..f34e963
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-ZKJSG4TA.mjs
@@ -0,0 +1,411 @@
+import {
+  isTokenDetectionSupportedForNetwork
+} from "./chunk-E5PIGGYR.mjs";
+import {
+  __privateAdd,
+  __privateGet,
+  __privateMethod,
+  __privateSet
+} from "./chunk-XUI43LEZ.mjs";
+
+// src/TokenDetectionController.ts
+import contractMap from "@metamask/contract-metadata";
+import { ChainId, safelyExecute } from "@metamask/controller-utils";
+import { StaticIntervalPollingController } from "@metamask/polling-controller";
+var DEFAULT_INTERVAL = 18e4;
+function isEqualCaseInsensitive(value1, value2) {
+  if (typeof value1 !== "string" || typeof value2 !== "string") {
+    return false;
+  }
+  return value1.toLowerCase() === value2.toLowerCase();
+}
+var STATIC_MAINNET_TOKEN_LIST = Object.entries(
+  contractMap
+).reduce((acc, [base, contract]) => {
+  const { logo, erc20, erc721, ...tokenMetadata } = contract;
+  return {
+    ...acc,
+    [base.toLowerCase()]: {
+      ...tokenMetadata,
+      address: base.toLowerCase(),
+      iconUrl: `images/contract/${logo}`,
+      aggregators: []
+    }
+  };
+}, {});
+var controllerName = "TokenDetectionController";
+var _intervalId, _selectedAddress, _networkClientId, _tokenList, _disabled, _isUnlocked, _isDetectionEnabledFromPreferences, _isDetectionEnabledForNetwork, _getBalancesInSingleCall, _trackMetaMetricsEvent, _registerEventListeners, registerEventListeners_fn, _stopPolling, stopPolling_fn, _startPolling, startPolling_fn, _getCorrectChainIdAndNetworkClientId, getCorrectChainIdAndNetworkClientId_fn, _restartTokenDetection, restartTokenDetection_fn, _getSlicesOfTokensToDetect, getSlicesOfTokensToDetect_fn, _addDetectedTokens, addDetectedTokens_fn;
+var TokenDetectionController = class extends StaticIntervalPollingController {
+  /**
+   * Creates a TokenDetectionController instance.
+   *
+   * @param options - The controller options.
+   * @param options.messenger - The controller messaging system.
+   * @param options.disabled - If set to true, all network requests are blocked.
+   * @param options.interval - Polling interval used to fetch new token rates
+   * @param options.selectedAddress - Vault selected address
+   * @param options.getBalancesInSingleCall - Gets the balances of a list of tokens for the given address.
+   * @param options.trackMetaMetricsEvent - Sets options for MetaMetrics event tracking.
+   */
+  constructor({
+    selectedAddress,
+    interval = DEFAULT_INTERVAL,
+    disabled = true,
+    getBalancesInSingleCall,
+    trackMetaMetricsEvent,
+    messenger
+  }) {
+    super({
+      name: controllerName,
+      messenger,
+      state: {},
+      metadata: {}
+    });
+    /**
+     * Constructor helper for registering this controller's messaging system subscriptions to controller events.
+     */
+    __privateAdd(this, _registerEventListeners);
+    __privateAdd(this, _stopPolling);
+    /**
+     * Starts a new polling interval.
+     */
+    __privateAdd(this, _startPolling);
+    __privateAdd(this, _getCorrectChainIdAndNetworkClientId);
+    /**
+     * Restart token detection polling period and call detectNewTokens
+     * in case of address change or user session initialization.
+     *
+     * @param options - Options for restart token detection.
+     * @param options.selectedAddress - the selectedAddress against which to detect for token balances
+     * @param options.networkClientId - The ID of the network client to use.
+     */
+    __privateAdd(this, _restartTokenDetection);
+    __privateAdd(this, _getSlicesOfTokensToDetect);
+    __privateAdd(this, _addDetectedTokens);
+    __privateAdd(this, _intervalId, void 0);
+    __privateAdd(this, _selectedAddress, void 0);
+    __privateAdd(this, _networkClientId, void 0);
+    __privateAdd(this, _tokenList, {});
+    __privateAdd(this, _disabled, void 0);
+    __privateAdd(this, _isUnlocked, void 0);
+    __privateAdd(this, _isDetectionEnabledFromPreferences, void 0);
+    __privateAdd(this, _isDetectionEnabledForNetwork, void 0);
+    __privateAdd(this, _getBalancesInSingleCall, void 0);
+    __privateAdd(this, _trackMetaMetricsEvent, void 0);
+    __privateSet(this, _disabled, disabled);
+    this.setIntervalLength(interval);
+    __privateSet(this, _selectedAddress, selectedAddress ?? this.messagingSystem.call("AccountsController:getSelectedAccount").address);
+    const { chainId, networkClientId } = __privateMethod(this, _getCorrectChainIdAndNetworkClientId, getCorrectChainIdAndNetworkClientId_fn).call(this);
+    __privateSet(this, _networkClientId, networkClientId);
+    const { useTokenDetection: defaultUseTokenDetection } = this.messagingSystem.call("PreferencesController:getState");
+    __privateSet(this, _isDetectionEnabledFromPreferences, defaultUseTokenDetection);
+    __privateSet(this, _isDetectionEnabledForNetwork, isTokenDetectionSupportedForNetwork(chainId));
+    __privateSet(this, _getBalancesInSingleCall, getBalancesInSingleCall);
+    __privateSet(this, _trackMetaMetricsEvent, trackMetaMetricsEvent);
+    const { isUnlocked } = this.messagingSystem.call(
+      "KeyringController:getState"
+    );
+    __privateSet(this, _isUnlocked, isUnlocked);
+    __privateMethod(this, _registerEventListeners, registerEventListeners_fn).call(this);
+  }
+  /**
+   * Allows controller to make active and passive polling requests
+   */
+  enable() {
+    __privateSet(this, _disabled, false);
+  }
+  /**
+   * Blocks controller from making network calls
+   */
+  disable() {
+    __privateSet(this, _disabled, true);
+  }
+  /**
+   * Internal isActive state
+   * @type {boolean}
+   */
+  get isActive() {
+    return !__privateGet(this, _disabled) && __privateGet(this, _isUnlocked);
+  }
+  /**
+   * Start polling for detected tokens.
+   */
+  async start() {
+    this.enable();
+    await __privateMethod(this, _startPolling, startPolling_fn).call(this);
+  }
+  /**
+   * Stop polling for detected tokens.
+   */
+  stop() {
+    this.disable();
+    __privateMethod(this, _stopPolling, stopPolling_fn).call(this);
+  }
+  async _executePoll(networkClientId, options) {
+    if (!this.isActive) {
+      return;
+    }
+    await this.detectTokens({
+      networkClientId,
+      selectedAddress: options.address
+    });
+  }
+  /**
+   * For each token in the token list provided by the TokenListController, checks the token's balance for the selected account address on the active network.
+   * On mainnet, if token detection is disabled in preferences, ERC20 token auto detection will be triggered for each contract address in the legacy token list from the @metamask/contract-metadata repo.
+   *
+   * @param options - Options for token detection.
+   * @param options.networkClientId - The ID of the network client to use.
+   * @param options.selectedAddress - the selectedAddress against which to detect for token balances.
+   */
+  async detectTokens({
+    networkClientId,
+    selectedAddress
+  } = {}) {
+    if (!this.isActive) {
+      return;
+    }
+    const addressAgainstWhichToDetect = selectedAddress ?? __privateGet(this, _selectedAddress);
+    const { chainId, networkClientId: selectedNetworkClientId } = __privateMethod(this, _getCorrectChainIdAndNetworkClientId, getCorrectChainIdAndNetworkClientId_fn).call(this, networkClientId);
+    const chainIdAgainstWhichToDetect = chainId;
+    const networkClientIdAgainstWhichToDetect = selectedNetworkClientId;
+    if (!isTokenDetectionSupportedForNetwork(chainIdAgainstWhichToDetect)) {
+      return;
+    }
+    if (!__privateGet(this, _isDetectionEnabledFromPreferences) && chainIdAgainstWhichToDetect !== ChainId.mainnet) {
+      return;
+    }
+    const isTokenDetectionInactiveInMainnet = !__privateGet(this, _isDetectionEnabledFromPreferences) && chainIdAgainstWhichToDetect === ChainId.mainnet;
+    const { tokensChainsCache } = this.messagingSystem.call(
+      "TokenListController:getState"
+    );
+    __privateSet(this, _tokenList, isTokenDetectionInactiveInMainnet ? STATIC_MAINNET_TOKEN_LIST : tokensChainsCache[chainIdAgainstWhichToDetect]?.data ?? {});
+    for (const tokensSlice of __privateMethod(this, _getSlicesOfTokensToDetect, getSlicesOfTokensToDetect_fn).call(this, {
+      chainId: chainIdAgainstWhichToDetect,
+      selectedAddress: addressAgainstWhichToDetect
+    })) {
+      await __privateMethod(this, _addDetectedTokens, addDetectedTokens_fn).call(this, {
+        tokensSlice,
+        selectedAddress: addressAgainstWhichToDetect,
+        networkClientId: networkClientIdAgainstWhichToDetect,
+        chainId: chainIdAgainstWhichToDetect
+      });
+    }
+  }
+};
+_intervalId = new WeakMap();
+_selectedAddress = new WeakMap();
+_networkClientId = new WeakMap();
+_tokenList = new WeakMap();
+_disabled = new WeakMap();
+_isUnlocked = new WeakMap();
+_isDetectionEnabledFromPreferences = new WeakMap();
+_isDetectionEnabledForNetwork = new WeakMap();
+_getBalancesInSingleCall = new WeakMap();
+_trackMetaMetricsEvent = new WeakMap();
+_registerEventListeners = new WeakSet();
+registerEventListeners_fn = function() {
+  this.messagingSystem.subscribe("KeyringController:unlock", async () => {
+    __privateSet(this, _isUnlocked, true);
+    await __privateMethod(this, _restartTokenDetection, restartTokenDetection_fn).call(this);
+  });
+  this.messagingSystem.subscribe("KeyringController:lock", () => {
+    __privateSet(this, _isUnlocked, false);
+    __privateMethod(this, _stopPolling, stopPolling_fn).call(this);
+  });
+  this.messagingSystem.subscribe(
+    "TokenListController:stateChange",
+    async ({ tokenList }) => {
+      const hasTokens = Object.keys(tokenList).length;
+      if (hasTokens) {
+        await __privateMethod(this, _restartTokenDetection, restartTokenDetection_fn).call(this);
+      }
+    }
+  );
+  this.messagingSystem.subscribe(
+    "PreferencesController:stateChange",
+    async ({ selectedAddress: newSelectedAddress, useTokenDetection }) => {
+      const isSelectedAddressChanged = __privateGet(this, _selectedAddress) !== newSelectedAddress;
+      const isDetectionChangedFromPreferences = __privateGet(this, _isDetectionEnabledFromPreferences) !== useTokenDetection;
+      __privateSet(this, _selectedAddress, newSelectedAddress);
+      __privateSet(this, _isDetectionEnabledFromPreferences, useTokenDetection);
+      if (useTokenDetection && (isSelectedAddressChanged || isDetectionChangedFromPreferences)) {
+        await __privateMethod(this, _restartTokenDetection, restartTokenDetection_fn).call(this, {
+          selectedAddress: __privateGet(this, _selectedAddress)
+        });
+      }
+    }
+  );
+  this.messagingSystem.subscribe(
+    "AccountsController:selectedAccountChange",
+    async ({ address: newSelectedAddress }) => {
+      const isSelectedAddressChanged = __privateGet(this, _selectedAddress) !== newSelectedAddress;
+      if (isSelectedAddressChanged && __privateGet(this, _isDetectionEnabledFromPreferences)) {
+        __privateSet(this, _selectedAddress, newSelectedAddress);
+        await __privateMethod(this, _restartTokenDetection, restartTokenDetection_fn).call(this, {
+          selectedAddress: __privateGet(this, _selectedAddress)
+        });
+      }
+    }
+  );
+  this.messagingSystem.subscribe(
+    "NetworkController:networkDidChange",
+    async ({ selectedNetworkClientId }) => {
+      const isNetworkClientIdChanged = __privateGet(this, _networkClientId) !== selectedNetworkClientId;
+      const { chainId: newChainId } = __privateMethod(this, _getCorrectChainIdAndNetworkClientId, getCorrectChainIdAndNetworkClientId_fn).call(this, selectedNetworkClientId);
+      __privateSet(this, _isDetectionEnabledForNetwork, isTokenDetectionSupportedForNetwork(newChainId));
+      if (isNetworkClientIdChanged && __privateGet(this, _isDetectionEnabledForNetwork)) {
+        __privateSet(this, _networkClientId, selectedNetworkClientId);
+        await __privateMethod(this, _restartTokenDetection, restartTokenDetection_fn).call(this, {
+          networkClientId: __privateGet(this, _networkClientId)
+        });
+      }
+    }
+  );
+};
+_stopPolling = new WeakSet();
+stopPolling_fn = function() {
+  if (__privateGet(this, _intervalId)) {
+    clearInterval(__privateGet(this, _intervalId));
+  }
+};
+_startPolling = new WeakSet();
+startPolling_fn = async function() {
+  if (!this.isActive) {
+    return;
+  }
+  __privateMethod(this, _stopPolling, stopPolling_fn).call(this);
+  await this.detectTokens();
+  __privateSet(this, _intervalId, setInterval(async () => {
+    await this.detectTokens();
+  }, this.getIntervalLength()));
+};
+_getCorrectChainIdAndNetworkClientId = new WeakSet();
+getCorrectChainIdAndNetworkClientId_fn = function(networkClientId) {
+  if (networkClientId) {
+    const networkConfiguration = this.messagingSystem.call(
+      "NetworkController:getNetworkConfigurationByNetworkClientId",
+      networkClientId
+    );
+    if (networkConfiguration) {
+      return {
+        chainId: networkConfiguration.chainId,
+        networkClientId
+      };
+    }
+  }
+  const { selectedNetworkClientId } = this.messagingSystem.call(
+    "NetworkController:getState"
+  );
+  const {
+    configuration: { chainId }
+  } = this.messagingSystem.call(
+    "NetworkController:getNetworkClientById",
+    selectedNetworkClientId
+  );
+  return {
+    chainId,
+    networkClientId: selectedNetworkClientId
+  };
+};
+_restartTokenDetection = new WeakSet();
+restartTokenDetection_fn = async function({
+  selectedAddress,
+  networkClientId
+} = {}) {
+  await this.detectTokens({
+    networkClientId,
+    selectedAddress
+  });
+  this.setIntervalLength(DEFAULT_INTERVAL);
+};
+_getSlicesOfTokensToDetect = new WeakSet();
+getSlicesOfTokensToDetect_fn = function({
+  chainId,
+  selectedAddress
+}) {
+  const { allTokens, allDetectedTokens, allIgnoredTokens } = this.messagingSystem.call("TokensController:getState");
+  const [tokensAddresses, detectedTokensAddresses, ignoredTokensAddresses] = [
+    allTokens,
+    allDetectedTokens,
+    allIgnoredTokens
+  ].map(
+    (tokens) => (tokens[chainId]?.[selectedAddress] ?? []).map(
+      (value) => typeof value === "string" ? value : value.address
+    )
+  );
+  const tokensToDetect = [];
+  for (const tokenAddress of Object.keys(__privateGet(this, _tokenList))) {
+    if ([
+      tokensAddresses,
+      detectedTokensAddresses,
+      ignoredTokensAddresses
+    ].every(
+      (addresses) => !addresses.find(
+        (address) => isEqualCaseInsensitive(address, tokenAddress)
+      )
+    )) {
+      tokensToDetect.push(tokenAddress);
+    }
+  }
+  const slicesOfTokensToDetect = [];
+  for (let i = 0, size = 1e3; i < tokensToDetect.length; i += size) {
+    slicesOfTokensToDetect.push(tokensToDetect.slice(i, i + size));
+  }
+  return slicesOfTokensToDetect;
+};
+_addDetectedTokens = new WeakSet();
+addDetectedTokens_fn = async function({
+  tokensSlice,
+  selectedAddress,
+  networkClientId,
+  chainId
+}) {
+  await safelyExecute(async () => {
+    const balances = await __privateGet(this, _getBalancesInSingleCall).call(this, selectedAddress, tokensSlice, networkClientId);
+    const tokensWithBalance = [];
+    const eventTokensDetails = [];
+    for (const nonZeroTokenAddress of Object.keys(balances)) {
+      const { decimals, symbol, aggregators, iconUrl, name } = __privateGet(this, _tokenList)[nonZeroTokenAddress];
+      eventTokensDetails.push(`${symbol} - ${nonZeroTokenAddress}`);
+      tokensWithBalance.push({
+        address: nonZeroTokenAddress,
+        decimals,
+        symbol,
+        aggregators,
+        image: iconUrl,
+        isERC721: false,
+        name
+      });
+    }
+    if (tokensWithBalance.length) {
+      __privateGet(this, _trackMetaMetricsEvent).call(this, {
+        event: "Token Detected",
+        category: "Wallet",
+        properties: {
+          tokens: eventTokensDetails,
+          token_standard: "ERC20",
+          asset_type: "TOKEN"
+        }
+      });
+      await this.messagingSystem.call(
+        "TokensController:addDetectedTokens",
+        tokensWithBalance,
+        {
+          selectedAddress,
+          chainId
+        }
+      );
+    }
+  });
+};
+var TokenDetectionController_default = TokenDetectionController;
+
+export {
+  isEqualCaseInsensitive,
+  STATIC_MAINNET_TOKEN_LIST,
+  controllerName,
+  TokenDetectionController,
+  TokenDetectionController_default
+};
+//# sourceMappingURL=chunk-ZKJSG4TA.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/chunk-ZKJSG4TA.mjs.map b/node_modules/@metamask/assets-controllers/dist/chunk-ZKJSG4TA.mjs.map
new file mode 100644
index 0000000..4809195
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/chunk-ZKJSG4TA.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/TokenDetectionController.ts"],"sourcesContent":["import type {\n  AccountsControllerGetSelectedAccountAction,\n  AccountsControllerSelectedAccountChangeEvent,\n} from '@metamask/accounts-controller';\nimport type {\n  RestrictedControllerMessenger,\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n} from '@metamask/base-controller';\nimport contractMap from '@metamask/contract-metadata';\nimport { ChainId, safelyExecute } from '@metamask/controller-utils';\nimport type {\n  KeyringControllerGetStateAction,\n  KeyringControllerLockEvent,\n  KeyringControllerUnlockEvent,\n} from '@metamask/keyring-controller';\nimport type {\n  NetworkClientId,\n  NetworkControllerGetNetworkClientByIdAction,\n  NetworkControllerGetNetworkConfigurationByNetworkClientId,\n  NetworkControllerGetStateAction,\n  NetworkControllerNetworkDidChangeEvent,\n} from '@metamask/network-controller';\nimport { StaticIntervalPollingController } from '@metamask/polling-controller';\nimport type {\n  PreferencesControllerGetStateAction,\n  PreferencesControllerStateChangeEvent,\n} from '@metamask/preferences-controller';\nimport type { Hex } from '@metamask/utils';\n\nimport type { AssetsContractController } from './AssetsContractController';\nimport { isTokenDetectionSupportedForNetwork } from './assetsUtil';\nimport type {\n  GetTokenListState,\n  TokenListMap,\n  TokenListStateChange,\n} from './TokenListController';\nimport type { Token } from './TokenRatesController';\nimport type {\n  TokensControllerAddDetectedTokensAction,\n  TokensControllerGetStateAction,\n} from './TokensController';\n\nconst DEFAULT_INTERVAL = 180000;\n\n/**\n * Compare 2 given strings and return boolean\n * eg: \"foo\" and \"FOO\" => true\n * eg: \"foo\" and \"bar\" => false\n * eg: \"foo\" and 123 => false\n *\n * @param value1 - first string to compare\n * @param value2 - first string to compare\n * @returns true if 2 strings are identical when they are lowercase\n */\nexport function isEqualCaseInsensitive(\n  value1: string,\n  value2: string,\n): boolean {\n  if (typeof value1 !== 'string' || typeof value2 !== 'string') {\n    return false;\n  }\n  return value1.toLowerCase() === value2.toLowerCase();\n}\n\ntype LegacyToken = {\n  name: string;\n  logo: `${string}.svg`;\n  symbol: string;\n  decimals: number;\n  erc20?: boolean;\n  erc721?: boolean;\n};\n\ntype TokenDetectionMap = {\n  [P in keyof TokenListMap]: Omit<TokenListMap[P], 'occurrences'>;\n};\n\nexport const STATIC_MAINNET_TOKEN_LIST = Object.entries<LegacyToken>(\n  contractMap,\n).reduce<TokenDetectionMap>((acc, [base, contract]) => {\n  const { logo, erc20, erc721, ...tokenMetadata } = contract;\n  return {\n    ...acc,\n    [base.toLowerCase()]: {\n      ...tokenMetadata,\n      address: base.toLowerCase(),\n      iconUrl: `images/contract/${logo}`,\n      aggregators: [],\n    },\n  };\n}, {});\n\nexport const controllerName = 'TokenDetectionController';\n\nexport type TokenDetectionState = Record<never, never>;\n\nexport type TokenDetectionControllerGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  TokenDetectionState\n>;\n\nexport type TokenDetectionControllerActions =\n  TokenDetectionControllerGetStateAction;\n\nexport type AllowedActions =\n  | AccountsControllerGetSelectedAccountAction\n  | NetworkControllerGetNetworkClientByIdAction\n  | NetworkControllerGetNetworkConfigurationByNetworkClientId\n  | NetworkControllerGetStateAction\n  | GetTokenListState\n  | KeyringControllerGetStateAction\n  | PreferencesControllerGetStateAction\n  | TokensControllerGetStateAction\n  | TokensControllerAddDetectedTokensAction;\n\nexport type TokenDetectionControllerStateChangeEvent =\n  ControllerStateChangeEvent<typeof controllerName, TokenDetectionState>;\n\nexport type TokenDetectionControllerEvents =\n  TokenDetectionControllerStateChangeEvent;\n\nexport type AllowedEvents =\n  | AccountsControllerSelectedAccountChangeEvent\n  | NetworkControllerNetworkDidChangeEvent\n  | TokenListStateChange\n  | KeyringControllerLockEvent\n  | KeyringControllerUnlockEvent\n  | PreferencesControllerStateChangeEvent;\n\nexport type TokenDetectionControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  TokenDetectionControllerActions | AllowedActions,\n  TokenDetectionControllerEvents | AllowedEvents,\n  AllowedActions['type'],\n  AllowedEvents['type']\n>;\n\n/**\n * Controller that passively polls on a set interval for Tokens auto detection\n * @property intervalId - Polling interval used to fetch new token rates\n * @property selectedAddress - Vault selected address\n * @property networkClientId - The network client ID of the current selected network\n * @property disabled - Boolean to track if network requests are blocked\n * @property isUnlocked - Boolean to track if the keyring state is unlocked\n * @property isDetectionEnabledFromPreferences - Boolean to track if detection is enabled from PreferencesController\n * @property isDetectionEnabledForNetwork - Boolean to track if detected is enabled for current network\n */\nexport class TokenDetectionController extends StaticIntervalPollingController<\n  typeof controllerName,\n  TokenDetectionState,\n  TokenDetectionControllerMessenger\n> {\n  #intervalId?: ReturnType<typeof setTimeout>;\n\n  #selectedAddress: string;\n\n  #networkClientId: NetworkClientId;\n\n  #tokenList: TokenDetectionMap = {};\n\n  #disabled: boolean;\n\n  #isUnlocked: boolean;\n\n  #isDetectionEnabledFromPreferences: boolean;\n\n  #isDetectionEnabledForNetwork: boolean;\n\n  readonly #getBalancesInSingleCall: AssetsContractController['getBalancesInSingleCall'];\n\n  readonly #trackMetaMetricsEvent: (options: {\n    event: string;\n    category: string;\n    properties: {\n      tokens: string[];\n      token_standard: string;\n      asset_type: string;\n    };\n  }) => void;\n\n  /**\n   * Creates a TokenDetectionController instance.\n   *\n   * @param options - The controller options.\n   * @param options.messenger - The controller messaging system.\n   * @param options.disabled - If set to true, all network requests are blocked.\n   * @param options.interval - Polling interval used to fetch new token rates\n   * @param options.selectedAddress - Vault selected address\n   * @param options.getBalancesInSingleCall - Gets the balances of a list of tokens for the given address.\n   * @param options.trackMetaMetricsEvent - Sets options for MetaMetrics event tracking.\n   */\n  constructor({\n    selectedAddress,\n    interval = DEFAULT_INTERVAL,\n    disabled = true,\n    getBalancesInSingleCall,\n    trackMetaMetricsEvent,\n    messenger,\n  }: {\n    selectedAddress?: string;\n    interval?: number;\n    disabled?: boolean;\n    getBalancesInSingleCall: AssetsContractController['getBalancesInSingleCall'];\n    trackMetaMetricsEvent: (options: {\n      event: string;\n      category: string;\n      properties: {\n        tokens: string[];\n        token_standard: string;\n        asset_type: string;\n      };\n    }) => void;\n    messenger: TokenDetectionControllerMessenger;\n  }) {\n    super({\n      name: controllerName,\n      messenger,\n      state: {},\n      metadata: {},\n    });\n\n    this.#disabled = disabled;\n    this.setIntervalLength(interval);\n\n    this.#selectedAddress =\n      selectedAddress ??\n      this.messagingSystem.call('AccountsController:getSelectedAccount')\n        .address;\n\n    const { chainId, networkClientId } =\n      this.#getCorrectChainIdAndNetworkClientId();\n    this.#networkClientId = networkClientId;\n\n    const { useTokenDetection: defaultUseTokenDetection } =\n      this.messagingSystem.call('PreferencesController:getState');\n    this.#isDetectionEnabledFromPreferences = defaultUseTokenDetection;\n    this.#isDetectionEnabledForNetwork =\n      isTokenDetectionSupportedForNetwork(chainId);\n\n    this.#getBalancesInSingleCall = getBalancesInSingleCall;\n\n    this.#trackMetaMetricsEvent = trackMetaMetricsEvent;\n\n    const { isUnlocked } = this.messagingSystem.call(\n      'KeyringController:getState',\n    );\n    this.#isUnlocked = isUnlocked;\n\n    this.#registerEventListeners();\n  }\n\n  /**\n   * Constructor helper for registering this controller's messaging system subscriptions to controller events.\n   */\n  #registerEventListeners() {\n    this.messagingSystem.subscribe('KeyringController:unlock', async () => {\n      this.#isUnlocked = true;\n      await this.#restartTokenDetection();\n    });\n\n    this.messagingSystem.subscribe('KeyringController:lock', () => {\n      this.#isUnlocked = false;\n      this.#stopPolling();\n    });\n\n    this.messagingSystem.subscribe(\n      'TokenListController:stateChange',\n      async ({ tokenList }) => {\n        const hasTokens = Object.keys(tokenList).length;\n\n        if (hasTokens) {\n          await this.#restartTokenDetection();\n        }\n      },\n    );\n\n    this.messagingSystem.subscribe(\n      'PreferencesController:stateChange',\n      async ({ selectedAddress: newSelectedAddress, useTokenDetection }) => {\n        const isSelectedAddressChanged =\n          this.#selectedAddress !== newSelectedAddress;\n        const isDetectionChangedFromPreferences =\n          this.#isDetectionEnabledFromPreferences !== useTokenDetection;\n\n        this.#selectedAddress = newSelectedAddress;\n        this.#isDetectionEnabledFromPreferences = useTokenDetection;\n\n        if (\n          useTokenDetection &&\n          (isSelectedAddressChanged || isDetectionChangedFromPreferences)\n        ) {\n          await this.#restartTokenDetection({\n            selectedAddress: this.#selectedAddress,\n          });\n        }\n      },\n    );\n\n    this.messagingSystem.subscribe(\n      'AccountsController:selectedAccountChange',\n      async ({ address: newSelectedAddress }) => {\n        const isSelectedAddressChanged =\n          this.#selectedAddress !== newSelectedAddress;\n        if (\n          isSelectedAddressChanged &&\n          this.#isDetectionEnabledFromPreferences\n        ) {\n          this.#selectedAddress = newSelectedAddress;\n          await this.#restartTokenDetection({\n            selectedAddress: this.#selectedAddress,\n          });\n        }\n      },\n    );\n\n    this.messagingSystem.subscribe(\n      'NetworkController:networkDidChange',\n      async ({ selectedNetworkClientId }) => {\n        const isNetworkClientIdChanged =\n          this.#networkClientId !== selectedNetworkClientId;\n\n        const { chainId: newChainId } =\n          this.#getCorrectChainIdAndNetworkClientId(selectedNetworkClientId);\n        this.#isDetectionEnabledForNetwork =\n          isTokenDetectionSupportedForNetwork(newChainId);\n\n        if (isNetworkClientIdChanged && this.#isDetectionEnabledForNetwork) {\n          this.#networkClientId = selectedNetworkClientId;\n          await this.#restartTokenDetection({\n            networkClientId: this.#networkClientId,\n          });\n        }\n      },\n    );\n  }\n\n  /**\n   * Allows controller to make active and passive polling requests\n   */\n  enable(): void {\n    this.#disabled = false;\n  }\n\n  /**\n   * Blocks controller from making network calls\n   */\n  disable(): void {\n    this.#disabled = true;\n  }\n\n  /**\n   * Internal isActive state\n   * @type {boolean}\n   */\n  get isActive(): boolean {\n    return !this.#disabled && this.#isUnlocked;\n  }\n\n  /**\n   * Start polling for detected tokens.\n   */\n  async start(): Promise<void> {\n    this.enable();\n    await this.#startPolling();\n  }\n\n  /**\n   * Stop polling for detected tokens.\n   */\n  stop(): void {\n    this.disable();\n    this.#stopPolling();\n  }\n\n  #stopPolling(): void {\n    if (this.#intervalId) {\n      clearInterval(this.#intervalId);\n    }\n  }\n\n  /**\n   * Starts a new polling interval.\n   */\n  async #startPolling(): Promise<void> {\n    if (!this.isActive) {\n      return;\n    }\n    this.#stopPolling();\n    await this.detectTokens();\n    this.#intervalId = setInterval(async () => {\n      await this.detectTokens();\n    }, this.getIntervalLength());\n  }\n\n  #getCorrectChainIdAndNetworkClientId(networkClientId?: NetworkClientId): {\n    chainId: Hex;\n    networkClientId: NetworkClientId;\n  } {\n    if (networkClientId) {\n      const networkConfiguration = this.messagingSystem.call(\n        'NetworkController:getNetworkConfigurationByNetworkClientId',\n        networkClientId,\n      );\n      if (networkConfiguration) {\n        return {\n          chainId: networkConfiguration.chainId,\n          networkClientId,\n        };\n      }\n    }\n    const { selectedNetworkClientId } = this.messagingSystem.call(\n      'NetworkController:getState',\n    );\n    const {\n      configuration: { chainId },\n    } = this.messagingSystem.call(\n      'NetworkController:getNetworkClientById',\n      selectedNetworkClientId,\n    );\n    return {\n      chainId,\n      networkClientId: selectedNetworkClientId,\n    };\n  }\n\n  async _executePoll(\n    networkClientId: NetworkClientId,\n    options: { address: string },\n  ): Promise<void> {\n    if (!this.isActive) {\n      return;\n    }\n    await this.detectTokens({\n      networkClientId,\n      selectedAddress: options.address,\n    });\n  }\n\n  /**\n   * Restart token detection polling period and call detectNewTokens\n   * in case of address change or user session initialization.\n   *\n   * @param options - Options for restart token detection.\n   * @param options.selectedAddress - the selectedAddress against which to detect for token balances\n   * @param options.networkClientId - The ID of the network client to use.\n   */\n  async #restartTokenDetection({\n    selectedAddress,\n    networkClientId,\n  }: {\n    selectedAddress?: string;\n    networkClientId?: NetworkClientId;\n  } = {}): Promise<void> {\n    await this.detectTokens({\n      networkClientId,\n      selectedAddress,\n    });\n    this.setIntervalLength(DEFAULT_INTERVAL);\n  }\n\n  /**\n   * For each token in the token list provided by the TokenListController, checks the token's balance for the selected account address on the active network.\n   * On mainnet, if token detection is disabled in preferences, ERC20 token auto detection will be triggered for each contract address in the legacy token list from the @metamask/contract-metadata repo.\n   *\n   * @param options - Options for token detection.\n   * @param options.networkClientId - The ID of the network client to use.\n   * @param options.selectedAddress - the selectedAddress against which to detect for token balances.\n   */\n  async detectTokens({\n    networkClientId,\n    selectedAddress,\n  }: {\n    networkClientId?: NetworkClientId;\n    selectedAddress?: string;\n  } = {}): Promise<void> {\n    if (!this.isActive) {\n      return;\n    }\n\n    const addressAgainstWhichToDetect =\n      selectedAddress ?? this.#selectedAddress;\n    const { chainId, networkClientId: selectedNetworkClientId } =\n      this.#getCorrectChainIdAndNetworkClientId(networkClientId);\n    const chainIdAgainstWhichToDetect = chainId;\n    const networkClientIdAgainstWhichToDetect = selectedNetworkClientId;\n\n    if (!isTokenDetectionSupportedForNetwork(chainIdAgainstWhichToDetect)) {\n      return;\n    }\n    if (\n      !this.#isDetectionEnabledFromPreferences &&\n      chainIdAgainstWhichToDetect !== ChainId.mainnet\n    ) {\n      return;\n    }\n    const isTokenDetectionInactiveInMainnet =\n      !this.#isDetectionEnabledFromPreferences &&\n      chainIdAgainstWhichToDetect === ChainId.mainnet;\n    const { tokensChainsCache } = this.messagingSystem.call(\n      'TokenListController:getState',\n    );\n    this.#tokenList = isTokenDetectionInactiveInMainnet\n      ? STATIC_MAINNET_TOKEN_LIST\n      : tokensChainsCache[chainIdAgainstWhichToDetect]?.data ?? {};\n\n    for (const tokensSlice of this.#getSlicesOfTokensToDetect({\n      chainId: chainIdAgainstWhichToDetect,\n      selectedAddress: addressAgainstWhichToDetect,\n    })) {\n      await this.#addDetectedTokens({\n        tokensSlice,\n        selectedAddress: addressAgainstWhichToDetect,\n        networkClientId: networkClientIdAgainstWhichToDetect,\n        chainId: chainIdAgainstWhichToDetect,\n      });\n    }\n  }\n\n  #getSlicesOfTokensToDetect({\n    chainId,\n    selectedAddress,\n  }: {\n    chainId: Hex;\n    selectedAddress: string;\n  }): string[][] {\n    const { allTokens, allDetectedTokens, allIgnoredTokens } =\n      this.messagingSystem.call('TokensController:getState');\n    const [tokensAddresses, detectedTokensAddresses, ignoredTokensAddresses] = [\n      allTokens,\n      allDetectedTokens,\n      allIgnoredTokens,\n    ].map((tokens) =>\n      (tokens[chainId]?.[selectedAddress] ?? []).map((value) =>\n        typeof value === 'string' ? value : value.address,\n      ),\n    );\n\n    const tokensToDetect: string[] = [];\n    for (const tokenAddress of Object.keys(this.#tokenList)) {\n      if (\n        [\n          tokensAddresses,\n          detectedTokensAddresses,\n          ignoredTokensAddresses,\n        ].every(\n          (addresses) =>\n            !addresses.find((address) =>\n              isEqualCaseInsensitive(address, tokenAddress),\n            ),\n        )\n      ) {\n        tokensToDetect.push(tokenAddress);\n      }\n    }\n\n    const slicesOfTokensToDetect = [];\n    for (let i = 0, size = 1000; i < tokensToDetect.length; i += size) {\n      slicesOfTokensToDetect.push(tokensToDetect.slice(i, i + size));\n    }\n\n    return slicesOfTokensToDetect;\n  }\n\n  async #addDetectedTokens({\n    tokensSlice,\n    selectedAddress,\n    networkClientId,\n    chainId,\n  }: {\n    tokensSlice: string[];\n    selectedAddress: string;\n    networkClientId: NetworkClientId;\n    chainId: Hex;\n  }): Promise<void> {\n    await safelyExecute(async () => {\n      const balances = await this.#getBalancesInSingleCall(\n        selectedAddress,\n        tokensSlice,\n        networkClientId,\n      );\n\n      const tokensWithBalance: Token[] = [];\n      const eventTokensDetails: string[] = [];\n      for (const nonZeroTokenAddress of Object.keys(balances)) {\n        const { decimals, symbol, aggregators, iconUrl, name } =\n          this.#tokenList[nonZeroTokenAddress];\n        eventTokensDetails.push(`${symbol} - ${nonZeroTokenAddress}`);\n        tokensWithBalance.push({\n          address: nonZeroTokenAddress,\n          decimals,\n          symbol,\n          aggregators,\n          image: iconUrl,\n          isERC721: false,\n          name,\n        });\n      }\n\n      if (tokensWithBalance.length) {\n        this.#trackMetaMetricsEvent({\n          event: 'Token Detected',\n          category: 'Wallet',\n          properties: {\n            tokens: eventTokensDetails,\n            token_standard: 'ERC20',\n            asset_type: 'TOKEN',\n          },\n        });\n\n        await this.messagingSystem.call(\n          'TokensController:addDetectedTokens',\n          tokensWithBalance,\n          {\n            selectedAddress,\n            chainId,\n          },\n        );\n      }\n    });\n  }\n}\n\nexport default TokenDetectionController;\n"],"mappings":"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","names":[]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/constants.mjs b/node_modules/@metamask/assets-controllers/dist/constants.mjs
new file mode 100644
index 0000000..03da170
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/constants.mjs
@@ -0,0 +1,8 @@
+import {
+  Source
+} from "./chunk-CP3HC7AQ.mjs";
+import "./chunk-XUI43LEZ.mjs";
+export {
+  Source
+};
+//# sourceMappingURL=constants.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/constants.mjs.map b/node_modules/@metamask/assets-controllers/dist/constants.mjs.map
new file mode 100644
index 0000000..84c51b2
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/constants.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":[],"sourcesContent":[],"mappings":"","names":[]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/crypto-compare.mjs b/node_modules/@metamask/assets-controllers/dist/crypto-compare.mjs
new file mode 100644
index 0000000..acae36d
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/crypto-compare.mjs
@@ -0,0 +1,8 @@
+import {
+  fetchExchangeRate
+} from "./chunk-TCO22VIO.mjs";
+import "./chunk-XUI43LEZ.mjs";
+export {
+  fetchExchangeRate
+};
+//# sourceMappingURL=crypto-compare.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/crypto-compare.mjs.map b/node_modules/@metamask/assets-controllers/dist/crypto-compare.mjs.map
new file mode 100644
index 0000000..84c51b2
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/crypto-compare.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":[],"sourcesContent":[],"mappings":"","names":[]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/index.d.ts b/node_modules/@metamask/assets-controllers/dist/index.d.ts
index 9526321..5f08fce 100644
--- a/node_modules/@metamask/assets-controllers/dist/index.d.ts
+++ b/node_modules/@metamask/assets-controllers/dist/index.d.ts
@@ -9,4 +9,5 @@ export * from './TokenListController';
 export * from './TokenRatesController';
 export * from './TokensController';
 export { isTokenDetectionSupportedForNetwork, formatIconUrlWithProxy, getFormattedIpfsUrl, } from './assetsUtil';
+export { CodefiTokenPricesServiceV2 } from './token-prices-service';
 //# sourceMappingURL=index.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/index.d.ts.map b/node_modules/@metamask/assets-controllers/dist/index.d.ts.map
index dc17d8c..54c83af 100644
--- a/node_modules/@metamask/assets-controllers/dist/index.d.ts.map
+++ b/node_modules/@metamask/assets-controllers/dist/index.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"AAAA,cAAc,4BAA4B,CAAC;AAC3C,cAAc,4BAA4B,CAAC;AAC3C,cAAc,0BAA0B,CAAC;AACzC,cAAc,iBAAiB,CAAC;AAChC,cAAc,0BAA0B,CAAC;AACzC,cAAc,2BAA2B,CAAC;AAC1C,cAAc,4BAA4B,CAAC;AAC3C,cAAc,uBAAuB,CAAC;AACtC,cAAc,wBAAwB,CAAC;AACvC,cAAc,oBAAoB,CAAC;AACnC,OAAO,EACL,mCAAmC,EACnC,sBAAsB,EACtB,mBAAmB,GACpB,MAAM,cAAc,CAAC"}
\ No newline at end of file
+{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"AAAA,cAAc,4BAA4B,CAAC;AAC3C,cAAc,4BAA4B,CAAC;AAC3C,cAAc,0BAA0B,CAAC;AACzC,cAAc,iBAAiB,CAAC;AAChC,cAAc,0BAA0B,CAAC;AACzC,cAAc,2BAA2B,CAAC;AAC1C,cAAc,4BAA4B,CAAC;AAC3C,cAAc,uBAAuB,CAAC;AACtC,cAAc,wBAAwB,CAAC;AACvC,cAAc,oBAAoB,CAAC;AACnC,OAAO,EACL,mCAAmC,EACnC,sBAAsB,EACtB,mBAAmB,GACpB,MAAM,cAAc,CAAC;AACtB,OAAO,EAAE,0BAA0B,EAAE,MAAM,wBAAwB,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/index.js b/node_modules/@metamask/assets-controllers/dist/index.js
index d4d8682..1b151e6 100644
--- a/node_modules/@metamask/assets-controllers/dist/index.js
+++ b/node_modules/@metamask/assets-controllers/dist/index.js
@@ -14,7 +14,7 @@ var __exportStar = (this && this.__exportStar) || function(m, exports) {
     for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
 };
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.getFormattedIpfsUrl = exports.formatIconUrlWithProxy = exports.isTokenDetectionSupportedForNetwork = void 0;
+exports.CodefiTokenPricesServiceV2 = exports.getFormattedIpfsUrl = exports.formatIconUrlWithProxy = exports.isTokenDetectionSupportedForNetwork = void 0;
 __exportStar(require("./AccountTrackerController"), exports);
 __exportStar(require("./AssetsContractController"), exports);
 __exportStar(require("./CurrencyRateController"), exports);
@@ -29,4 +29,6 @@ var assetsUtil_1 = require("./assetsUtil");
 Object.defineProperty(exports, "isTokenDetectionSupportedForNetwork", { enumerable: true, get: function () { return assetsUtil_1.isTokenDetectionSupportedForNetwork; } });
 Object.defineProperty(exports, "formatIconUrlWithProxy", { enumerable: true, get: function () { return assetsUtil_1.formatIconUrlWithProxy; } });
 Object.defineProperty(exports, "getFormattedIpfsUrl", { enumerable: true, get: function () { return assetsUtil_1.getFormattedIpfsUrl; } });
+var token_prices_service_1 = require("./token-prices-service");
+Object.defineProperty(exports, "CodefiTokenPricesServiceV2", { enumerable: true, get: function () { return token_prices_service_1.CodefiTokenPricesServiceV2; } });
 //# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/index.js.map b/node_modules/@metamask/assets-controllers/dist/index.js.map
index ea0eaab..ab8b9b9 100644
--- a/node_modules/@metamask/assets-controllers/dist/index.js.map
+++ b/node_modules/@metamask/assets-controllers/dist/index.js.map
@@ -1 +1 @@
-{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAAA,6DAA2C;AAC3C,6DAA2C;AAC3C,2DAAyC;AACzC,kDAAgC;AAChC,2DAAyC;AACzC,4DAA0C;AAC1C,6DAA2C;AAC3C,wDAAsC;AACtC,yDAAuC;AACvC,qDAAmC;AACnC,2CAIsB;AAHpB,iIAAA,mCAAmC,OAAA;AACnC,oHAAA,sBAAsB,OAAA;AACtB,iHAAA,mBAAmB,OAAA","sourcesContent":["export * from './AccountTrackerController';\nexport * from './AssetsContractController';\nexport * from './CurrencyRateController';\nexport * from './NftController';\nexport * from './NftDetectionController';\nexport * from './TokenBalancesController';\nexport * from './TokenDetectionController';\nexport * from './TokenListController';\nexport * from './TokenRatesController';\nexport * from './TokensController';\nexport {\n  isTokenDetectionSupportedForNetwork,\n  formatIconUrlWithProxy,\n  getFormattedIpfsUrl,\n} from './assetsUtil';\n"]}
\ No newline at end of file
+{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAAA,6DAA2C;AAC3C,6DAA2C;AAC3C,2DAAyC;AACzC,kDAAgC;AAChC,2DAAyC;AACzC,4DAA0C;AAC1C,6DAA2C;AAC3C,wDAAsC;AACtC,yDAAuC;AACvC,qDAAmC;AACnC,2CAIsB;AAHpB,iIAAA,mCAAmC,OAAA;AACnC,oHAAA,sBAAsB,OAAA;AACtB,iHAAA,mBAAmB,OAAA;AAErB,+DAAoE;AAA3D,kIAAA,0BAA0B,OAAA","sourcesContent":["export * from './AccountTrackerController';\nexport * from './AssetsContractController';\nexport * from './CurrencyRateController';\nexport * from './NftController';\nexport * from './NftDetectionController';\nexport * from './TokenBalancesController';\nexport * from './TokenDetectionController';\nexport * from './TokenListController';\nexport * from './TokenRatesController';\nexport * from './TokensController';\nexport {\n  isTokenDetectionSupportedForNetwork,\n  formatIconUrlWithProxy,\n  getFormattedIpfsUrl,\n} from './assetsUtil';\nexport { CodefiTokenPricesServiceV2 } from './token-prices-service';\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/index.mjs b/node_modules/@metamask/assets-controllers/dist/index.mjs
new file mode 100644
index 0000000..5978cec
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/index.mjs
@@ -0,0 +1,75 @@
+import "./chunk-27KOXCQK.mjs";
+import {
+  CodefiTokenPricesServiceV2,
+  SUPPORTED_CHAIN_IDS
+} from "./chunk-OSEZFHQ3.mjs";
+import {
+  TokenRatesController
+} from "./chunk-2IZUMKMY.mjs";
+import {
+  TokensController
+} from "./chunk-76KGJJJV.mjs";
+import {
+  AccountTrackerController
+} from "./chunk-PAJTKWEC.mjs";
+import {
+  AssetsContractController,
+  MISSING_PROVIDER_ERROR,
+  SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID
+} from "./chunk-KCUSDOIE.mjs";
+import "./chunk-WIVSZVF4.mjs";
+import "./chunk-CEENXWOB.mjs";
+import "./chunk-MQ7TIWBK.mjs";
+import {
+  CurrencyRateController
+} from "./chunk-23F5W3A2.mjs";
+import "./chunk-TCO22VIO.mjs";
+import {
+  NftDetectionController
+} from "./chunk-GLZ66IRX.mjs";
+import {
+  NftController,
+  OpenSeaV2ChainIds,
+  getDefaultNftState
+} from "./chunk-WTG2VMDL.mjs";
+import "./chunk-CP3HC7AQ.mjs";
+import {
+  TokenBalancesController
+} from "./chunk-4LY47RPI.mjs";
+import {
+  TokenDetectionController
+} from "./chunk-ZKJSG4TA.mjs";
+import {
+  TokenListController
+} from "./chunk-523YP4Z3.mjs";
+import "./chunk-KRTEFV4Q.mjs";
+import {
+  fetchTokenContractExchangeRates,
+  formatIconUrlWithProxy,
+  getFormattedIpfsUrl,
+  isTokenDetectionSupportedForNetwork
+} from "./chunk-E5PIGGYR.mjs";
+import "./chunk-XUI43LEZ.mjs";
+export {
+  AccountTrackerController,
+  AssetsContractController,
+  CodefiTokenPricesServiceV2,
+  CurrencyRateController,
+  MISSING_PROVIDER_ERROR,
+  NftController,
+  NftDetectionController,
+  OpenSeaV2ChainIds,
+  SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID,
+  SUPPORTED_CHAIN_IDS,
+  TokenBalancesController,
+  TokenDetectionController,
+  TokenListController,
+  TokenRatesController,
+  TokensController,
+  fetchTokenContractExchangeRates,
+  formatIconUrlWithProxy,
+  getDefaultNftState,
+  getFormattedIpfsUrl,
+  isTokenDetectionSupportedForNetwork
+};
+//# sourceMappingURL=index.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/index.mjs.map b/node_modules/@metamask/assets-controllers/dist/index.mjs.map
new file mode 100644
index 0000000..84c51b2
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/index.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":[],"sourcesContent":[],"mappings":"","names":[]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-prices-service/abstract-token-prices-service.d.ts b/node_modules/@metamask/assets-controllers/dist/token-prices-service/abstract-token-prices-service.d.ts
new file mode 100644
index 0000000..2350815
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/token-prices-service/abstract-token-prices-service.d.ts
@@ -0,0 +1,62 @@
+import type { Hex } from '@metamask/utils';
+/**
+ * Represents the price of a token in a currency.
+ */
+export declare type TokenPrice<TokenAddress extends Hex, Currency extends string> = {
+    tokenAddress: TokenAddress;
+    value: number;
+    currency: Currency;
+};
+/**
+ * A map of token address to its price.
+ */
+export declare type TokenPricesByTokenAddress<TokenAddress extends Hex, Currency extends string> = {
+    [A in TokenAddress]: TokenPrice<A, Currency>;
+};
+/**
+ * An ideal token prices service. All implementations must confirm to this
+ * interface.
+ *
+ * @template ChainId - A type union of valid arguments for the `chainId`
+ * argument to `fetchTokenPrices`.
+ * @template TokenAddress - A type union of all token addresses. The reason this
+ * type parameter exists is so that we can guarantee that same addresses that
+ * `fetchTokenPrices` receives are the same addresses that shown up in the
+ * return value.
+ * @template Currency - A type union of valid arguments for the `currency`
+ * argument to `fetchTokenPrices`.
+ */
+export declare type AbstractTokenPricesService<ChainId extends string = string, TokenAddress extends Hex = Hex, Currency extends string = string> = {
+    /**
+     * Retrieves prices in the given currency for the tokens identified by the
+     * given addresses which are expected to live on the given chain.
+     *
+     * @param args - The arguments to this function.
+     * @param args.chainId - An EIP-155 chain ID.
+     * @param args.tokenAddresses - Addresses for tokens that live on the chain.
+     * @param args.currency - The desired currency of the token prices.
+     * @returns The prices for the requested tokens.
+     */
+    fetchTokenPrices({ chainId, tokenAddresses, currency, }: {
+        chainId: ChainId;
+        tokenAddresses: TokenAddress[];
+        currency: Currency;
+    }): Promise<Partial<TokenPricesByTokenAddress<TokenAddress, Currency>>>;
+    /**
+     * Type guard for whether the API can return token prices for the given chain
+     * ID.
+     *
+     * @param chainId - The chain ID to check.
+     * @returns True if the API supports the chain ID, false otherwise.
+     */
+    validateChainIdSupported(chainId: unknown): chainId is ChainId;
+    /**
+     * Type guard for whether the API can return token prices in the given
+     * currency.
+     *
+     * @param currency - The currency to check.
+     * @returns True if the API supports the currency, false otherwise.
+     */
+    validateCurrencySupported(currency: unknown): currency is Currency;
+};
+//# sourceMappingURL=abstract-token-prices-service.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-prices-service/abstract-token-prices-service.d.ts.map b/node_modules/@metamask/assets-controllers/dist/token-prices-service/abstract-token-prices-service.d.ts.map
new file mode 100644
index 0000000..31d878a
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/token-prices-service/abstract-token-prices-service.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"abstract-token-prices-service.d.ts","sourceRoot":"","sources":["../../src/token-prices-service/abstract-token-prices-service.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,GAAG,EAAE,MAAM,iBAAiB,CAAC;AAE3C;;GAEG;AACH,oBAAY,UAAU,CAAC,YAAY,SAAS,GAAG,EAAE,QAAQ,SAAS,MAAM,IAAI;IAC1E,YAAY,EAAE,YAAY,CAAC;IAC3B,KAAK,EAAE,MAAM,CAAC;IACd,QAAQ,EAAE,QAAQ,CAAC;CACpB,CAAC;AAEF;;GAEG;AACH,oBAAY,yBAAyB,CACnC,YAAY,SAAS,GAAG,EACxB,QAAQ,SAAS,MAAM,IACrB;KACD,CAAC,IAAI,YAAY,GAAG,UAAU,CAAC,CAAC,EAAE,QAAQ,CAAC;CAC7C,CAAC;AAEF;;;;;;;;;;;;GAYG;AACH,oBAAY,0BAA0B,CACpC,OAAO,SAAS,MAAM,GAAG,MAAM,EAC/B,YAAY,SAAS,GAAG,GAAG,GAAG,EAC9B,QAAQ,SAAS,MAAM,GAAG,MAAM,IAC9B;IACF;;;;;;;;;OASG;IACH,gBAAgB,CAAC,EACf,OAAO,EACP,cAAc,EACd,QAAQ,GACT,EAAE;QACD,OAAO,EAAE,OAAO,CAAC;QACjB,cAAc,EAAE,YAAY,EAAE,CAAC;QAC/B,QAAQ,EAAE,QAAQ,CAAC;KACpB,GAAG,OAAO,CAAC,OAAO,CAAC,yBAAyB,CAAC,YAAY,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC;IAExE;;;;;;OAMG;IACH,wBAAwB,CAAC,OAAO,EAAE,OAAO,GAAG,OAAO,IAAI,OAAO,CAAC;IAE/D;;;;;;OAMG;IACH,yBAAyB,CAAC,QAAQ,EAAE,OAAO,GAAG,QAAQ,IAAI,QAAQ,CAAC;CACpE,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-prices-service/abstract-token-prices-service.js b/node_modules/@metamask/assets-controllers/dist/token-prices-service/abstract-token-prices-service.js
new file mode 100644
index 0000000..6b79d8f
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/token-prices-service/abstract-token-prices-service.js
@@ -0,0 +1,3 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+//# sourceMappingURL=abstract-token-prices-service.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-prices-service/abstract-token-prices-service.js.map b/node_modules/@metamask/assets-controllers/dist/token-prices-service/abstract-token-prices-service.js.map
new file mode 100644
index 0000000..b91e096
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/token-prices-service/abstract-token-prices-service.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"abstract-token-prices-service.js","sourceRoot":"","sources":["../../src/token-prices-service/abstract-token-prices-service.ts"],"names":[],"mappings":"","sourcesContent":["import type { Hex } from '@metamask/utils';\n\n/**\n * Represents the price of a token in a currency.\n */\nexport type TokenPrice<TokenAddress extends Hex, Currency extends string> = {\n  tokenAddress: TokenAddress;\n  value: number;\n  currency: Currency;\n};\n\n/**\n * A map of token address to its price.\n */\nexport type TokenPricesByTokenAddress<\n  TokenAddress extends Hex,\n  Currency extends string,\n> = {\n  [A in TokenAddress]: TokenPrice<A, Currency>;\n};\n\n/**\n * An ideal token prices service. All implementations must confirm to this\n * interface.\n *\n * @template ChainId - A type union of valid arguments for the `chainId`\n * argument to `fetchTokenPrices`.\n * @template TokenAddress - A type union of all token addresses. The reason this\n * type parameter exists is so that we can guarantee that same addresses that\n * `fetchTokenPrices` receives are the same addresses that shown up in the\n * return value.\n * @template Currency - A type union of valid arguments for the `currency`\n * argument to `fetchTokenPrices`.\n */\nexport type AbstractTokenPricesService<\n  ChainId extends string = string,\n  TokenAddress extends Hex = Hex,\n  Currency extends string = string,\n> = {\n  /**\n   * Retrieves prices in the given currency for the tokens identified by the\n   * given addresses which are expected to live on the given chain.\n   *\n   * @param args - The arguments to this function.\n   * @param args.chainId - An EIP-155 chain ID.\n   * @param args.tokenAddresses - Addresses for tokens that live on the chain.\n   * @param args.currency - The desired currency of the token prices.\n   * @returns The prices for the requested tokens.\n   */\n  fetchTokenPrices({\n    chainId,\n    tokenAddresses,\n    currency,\n  }: {\n    chainId: ChainId;\n    tokenAddresses: TokenAddress[];\n    currency: Currency;\n  }): Promise<Partial<TokenPricesByTokenAddress<TokenAddress, Currency>>>;\n\n  /**\n   * Type guard for whether the API can return token prices for the given chain\n   * ID.\n   *\n   * @param chainId - The chain ID to check.\n   * @returns True if the API supports the chain ID, false otherwise.\n   */\n  validateChainIdSupported(chainId: unknown): chainId is ChainId;\n\n  /**\n   * Type guard for whether the API can return token prices in the given\n   * currency.\n   *\n   * @param currency - The currency to check.\n   * @returns True if the API supports the currency, false otherwise.\n   */\n  validateCurrencySupported(currency: unknown): currency is Currency;\n};\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-prices-service/abstract-token-prices-service.mjs b/node_modules/@metamask/assets-controllers/dist/token-prices-service/abstract-token-prices-service.mjs
new file mode 100644
index 0000000..de4443f
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/token-prices-service/abstract-token-prices-service.mjs
@@ -0,0 +1 @@
+//# sourceMappingURL=abstract-token-prices-service.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-prices-service/abstract-token-prices-service.mjs.map b/node_modules/@metamask/assets-controllers/dist/token-prices-service/abstract-token-prices-service.mjs.map
new file mode 100644
index 0000000..84c51b2
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/token-prices-service/abstract-token-prices-service.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":[],"sourcesContent":[],"mappings":"","names":[]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-prices-service/codefi-v2.d.ts b/node_modules/@metamask/assets-controllers/dist/token-prices-service/codefi-v2.d.ts
new file mode 100644
index 0000000..0fa4154
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/token-prices-service/codefi-v2.d.ts
@@ -0,0 +1,80 @@
+import type { Hex } from '@metamask/utils';
+import type { AbstractTokenPricesService, TokenPricesByTokenAddress } from './abstract-token-prices-service';
+/**
+ * The list of currencies that can be supplied as the `vsCurrency` parameter to
+ * the `/spot-prices` endpoint, in lowercase form.
+ */
+export declare const SUPPORTED_CURRENCIES: readonly ["btc", "eth", "ltc", "bch", "bnb", "eos", "xrp", "xlm", "link", "dot", "yfi", "usd", "aed", "ars", "aud", "bdt", "bhd", "bmd", "brl", "cad", "chf", "clp", "cny", "czk", "dkk", "eur", "gbp", "hkd", "huf", "idr", "ils", "inr", "jpy", "krw", "kwd", "lkr", "mmk", "mxn", "myr", "ngn", "nok", "nzd", "php", "pkr", "pln", "rub", "sar", "sek", "sgd", "thb", "try", "twd", "uah", "vef", "vnd", "zar", "xdr", "xag", "xau", "bits", "sats"];
+/**
+ * A currency that can be supplied as the `vsCurrency` parameter to
+ * the `/spot-prices` endpoint. Covers both uppercase and lowercase versions.
+ */
+declare type SupportedCurrency = typeof SUPPORTED_CURRENCIES[number] | Uppercase<typeof SUPPORTED_CURRENCIES[number]>;
+/**
+ * The list of chain IDs that can be supplied in the URL for the `/spot-prices`
+ * endpoint, but in hexadecimal form (for consistency with how we represent
+ * chain IDs in other places).
+ */
+export declare const SUPPORTED_CHAIN_IDS: readonly ["0x1", "0xa", "0x19", "0x38", "0x39", "0x42", "0x46", "0x52", "0x58", "0x64", "0x6a", "0x7a", "0x80", "0x89", "0xfa", "0x120", "0x141", "0x144", "0x169", "0x440", "0x504", "0x505", "0x2105", "0x150", "0x2710", "0xa4b1", "0xa4ec", "0xa516", "0xa86a", "0x518af", "0x4e454152", "0x63564c40"];
+/**
+ * A chain ID that can be supplied in the URL for the `/spot-prices` endpoint,
+ * but in hexadecimal form (for consistency with how we represent chain IDs in
+ * other places).
+ */
+declare type SupportedChainId = typeof SUPPORTED_CHAIN_IDS[number];
+/**
+ * This version of the token prices service uses V2 of the Codefi Price API to
+ * fetch token prices.
+ */
+export declare class CodefiTokenPricesServiceV2 implements AbstractTokenPricesService<SupportedChainId, Hex, SupportedCurrency> {
+    #private;
+    /**
+     * Construct a Codefi Token Price Service.
+     *
+     * @param options - Constructor options
+     * @param options.retries - Number of retry attempts for each token price update.
+     * @param options.maximumConsecutiveFailures - The maximum number of consecutive failures
+     * allowed before breaking the circuit and pausing further updates.
+     * @param options.circuitBreakDuration - The amount of time to wait when the circuit breaks
+     * from too many consecutive failures.
+     */
+    constructor({ retries, maximumConsecutiveFailures, circuitBreakDuration, }?: {
+        retries?: number;
+        maximumConsecutiveFailures?: number;
+        circuitBreakDuration?: number;
+    });
+    /**
+     * Retrieves prices in the given currency for the tokens identified by the
+     * given addresses which are expected to live on the given chain.
+     *
+     * @param args - The arguments to function.
+     * @param args.chainId - An EIP-155 chain ID.
+     * @param args.tokenAddresses - Addresses for tokens that live on the chain.
+     * @param args.currency - The desired currency of the token prices.
+     * @returns The prices for the requested tokens.
+     */
+    fetchTokenPrices({ chainId, tokenAddresses, currency, }: {
+        chainId: SupportedChainId;
+        tokenAddresses: Hex[];
+        currency: SupportedCurrency;
+    }): Promise<Partial<TokenPricesByTokenAddress<Hex, SupportedCurrency>>>;
+    /**
+     * Type guard for whether the API can return token prices for the given chain
+     * ID.
+     *
+     * @param chainId - The chain ID to check.
+     * @returns True if the API supports the chain ID, false otherwise.
+     */
+    validateChainIdSupported(chainId: unknown): chainId is SupportedChainId;
+    /**
+     * Type guard for whether the API can return token prices in the given
+     * currency.
+     *
+     * @param currency - The currency to check. If a string, can be either
+     * lowercase or uppercase.
+     * @returns True if the API supports the currency, false otherwise.
+     */
+    validateCurrencySupported(currency: unknown): currency is SupportedCurrency;
+}
+export {};
+//# sourceMappingURL=codefi-v2.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-prices-service/codefi-v2.d.ts.map b/node_modules/@metamask/assets-controllers/dist/token-prices-service/codefi-v2.d.ts.map
new file mode 100644
index 0000000..b07b8c0
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/token-prices-service/codefi-v2.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"codefi-v2.d.ts","sourceRoot":"","sources":["../../src/token-prices-service/codefi-v2.ts"],"names":[],"mappings":"AACA,OAAO,KAAK,EAAE,GAAG,EAAE,MAAM,iBAAiB,CAAC;AAY3C,OAAO,KAAK,EACV,0BAA0B,EAE1B,yBAAyB,EAC1B,MAAM,iCAAiC,CAAC;AAUzC;;;GAGG;AACH,eAAO,MAAM,oBAAoB,ybA2HvB,CAAC;AAEX;;;GAGG;AACH,aAAK,iBAAiB,GAClB,OAAO,oBAAoB,CAAC,MAAM,CAAC,GACnC,SAAS,CAAC,OAAO,oBAAoB,CAAC,MAAM,CAAC,CAAC,CAAC;AAEnD;;;;GAIG;AACH,eAAO,MAAM,mBAAmB,4SAiEtB,CAAC;AACX;;;;GAIG;AACH,aAAK,gBAAgB,GAAG,OAAO,mBAAmB,CAAC,MAAM,CAAC,CAAC;AAY3D;;;GAGG;AACH,qBAAa,0BACX,YACE,0BAA0B,CAAC,gBAAgB,EAAE,GAAG,EAAE,iBAAiB,CAAC;;IAItE;;;;;;;;;OASG;gBACS,EACV,OAAqC,EACrC,0BAAyE,EACzE,oBAAqC,GACtC,GAAE;QACD,OAAO,CAAC,EAAE,MAAM,CAAC;QACjB,0BAA0B,CAAC,EAAE,MAAM,CAAC;QACpC,oBAAoB,CAAC,EAAE,MAAM,CAAC;KAC1B;IAcN;;;;;;;;;OASG;IACG,gBAAgB,CAAC,EACrB,OAAO,EACP,cAAc,EACd,QAAQ,GACT,EAAE;QACD,OAAO,EAAE,gBAAgB,CAAC;QAC1B,cAAc,EAAE,GAAG,EAAE,CAAC;QACtB,QAAQ,EAAE,iBAAiB,CAAC;KAC7B,GAAG,OAAO,CAAC,OAAO,CAAC,yBAAyB,CAAC,GAAG,EAAE,iBAAiB,CAAC,CAAC,CAAC;IAoDvE;;;;;;OAMG;IACH,wBAAwB,CAAC,OAAO,EAAE,OAAO,GAAG,OAAO,IAAI,gBAAgB;IAKvE;;;;;;;OAOG;IACH,yBAAyB,CAAC,QAAQ,EAAE,OAAO,GAAG,QAAQ,IAAI,iBAAiB;CAO5E"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-prices-service/codefi-v2.js b/node_modules/@metamask/assets-controllers/dist/token-prices-service/codefi-v2.js
new file mode 100644
index 0000000..fedd210
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/token-prices-service/codefi-v2.js
@@ -0,0 +1,329 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
+    if (kind === "m") throw new TypeError("Private method is not writable");
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
+    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
+};
+var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
+    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
+};
+var _CodefiTokenPricesServiceV2_tokenPricePolicy;
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.CodefiTokenPricesServiceV2 = exports.SUPPORTED_CHAIN_IDS = exports.SUPPORTED_CURRENCIES = void 0;
+const controller_utils_1 = require("@metamask/controller-utils");
+const utils_1 = require("@metamask/utils");
+const cockatiel_1 = require("cockatiel");
+/**
+ * The list of currencies that can be supplied as the `vsCurrency` parameter to
+ * the `/spot-prices` endpoint, in lowercase form.
+ */
+exports.SUPPORTED_CURRENCIES = [
+    // Bitcoin
+    'btc',
+    // Ether
+    'eth',
+    // Litecoin
+    'ltc',
+    // Bitcoin Cash
+    'bch',
+    // Binance Coin
+    'bnb',
+    // EOS
+    'eos',
+    // XRP
+    'xrp',
+    // Lumens
+    'xlm',
+    // Chainlink
+    'link',
+    // Polkadot
+    'dot',
+    // Yearn.finance
+    'yfi',
+    // US Dollar
+    'usd',
+    // United Arab Emirates Dirham
+    'aed',
+    // Argentine Peso
+    'ars',
+    // Australian Dollar
+    'aud',
+    // Bangladeshi Taka
+    'bdt',
+    // Bahraini Dinar
+    'bhd',
+    // Bermudian Dollar
+    'bmd',
+    // Brazil Real
+    'brl',
+    // Canadian Dollar
+    'cad',
+    // Swiss Franc
+    'chf',
+    // Chilean Peso
+    'clp',
+    // Chinese Yuan
+    'cny',
+    // Czech Koruna
+    'czk',
+    // Danish Krone
+    'dkk',
+    // Euro
+    'eur',
+    // British Pound Sterling
+    'gbp',
+    // Hong Kong Dollar
+    'hkd',
+    // Hungarian Forint
+    'huf',
+    // Indonesian Rupiah
+    'idr',
+    // Israeli New Shekel
+    'ils',
+    // Indian Rupee
+    'inr',
+    // Japanese Yen
+    'jpy',
+    // South Korean Won
+    'krw',
+    // Kuwaiti Dinar
+    'kwd',
+    // Sri Lankan Rupee
+    'lkr',
+    // Burmese Kyat
+    'mmk',
+    // Mexican Peso
+    'mxn',
+    // Malaysian Ringgit
+    'myr',
+    // Nigerian Naira
+    'ngn',
+    // Norwegian Krone
+    'nok',
+    // New Zealand Dollar
+    'nzd',
+    // Philippine Peso
+    'php',
+    // Pakistani Rupee
+    'pkr',
+    // Polish Zloty
+    'pln',
+    // Russian Ruble
+    'rub',
+    // Saudi Riyal
+    'sar',
+    // Swedish Krona
+    'sek',
+    // Singapore Dollar
+    'sgd',
+    // Thai Baht
+    'thb',
+    // Turkish Lira
+    'try',
+    // New Taiwan Dollar
+    'twd',
+    // Ukrainian hryvnia
+    'uah',
+    // Venezuelan bolvar fuerte
+    'vef',
+    // Vietnamese ng
+    'vnd',
+    // South African Rand
+    'zar',
+    // IMF Special Drawing Rights
+    'xdr',
+    // Silver - Troy Ounce
+    'xag',
+    // Gold - Troy Ounce
+    'xau',
+    // Bits
+    'bits',
+    // Satoshi
+    'sats',
+];
+/**
+ * The list of chain IDs that can be supplied in the URL for the `/spot-prices`
+ * endpoint, but in hexadecimal form (for consistency with how we represent
+ * chain IDs in other places).
+ */
+exports.SUPPORTED_CHAIN_IDS = [
+    // Ethereum Mainnet
+    '0x1',
+    // OP Mainnet
+    '0xa',
+    // Cronos Mainnet
+    '0x19',
+    // BNB Smart Chain Mainnet
+    '0x38',
+    // Syscoin Mainnet
+    '0x39',
+    // OKXChain Mainnet
+    '0x42',
+    // Hoo Smart Chain
+    '0x46',
+    // Meter Mainnet
+    '0x52',
+    // TomoChain
+    '0x58',
+    // Gnosis
+    '0x64',
+    // Velas EVM Mainnet
+    '0x6a',
+    // Fuse Mainnet
+    '0x7a',
+    // Huobi ECO Chain Mainnet
+    '0x80',
+    // Polygon Mainnet
+    '0x89',
+    // Fantom Opera
+    '0xfa',
+    // Boba Network
+    '0x120',
+    // KCC Mainnet
+    '0x141',
+    // zkSync Era Mainnet
+    '0x144',
+    // Theta Mainnet
+    '0x169',
+    // Metis Andromeda Mainnet
+    '0x440',
+    // Moonbeam
+    '0x504',
+    // Moonriver
+    '0x505',
+    // Base
+    '0x2105',
+    // Shiden
+    '0x150',
+    // Smart Bitcoin Cash
+    '0x2710',
+    // Arbitrum One
+    '0xa4b1',
+    // Celo Mainnet
+    '0xa4ec',
+    // Oasis Emerald
+    '0xa516',
+    // Avalanche C-Chain
+    '0xa86a',
+    // Polis Mainnet
+    '0x518af',
+    // Aurora Mainnet
+    '0x4e454152',
+    // Harmony Mainnet Shard 0
+    '0x63564c40',
+];
+/**
+ * All requests to V2 of the Price API start with this.
+ */
+const BASE_URL = 'https://price-api.metafi.codefi.network/v2';
+const DEFAULT_TOKEN_PRICE_RETRIES = 3;
+// Each update attempt will result (1 + retries) calls if the server is down
+const DEFAULT_TOKEN_PRICE_MAX_CONSECUTIVE_FAILURES = (1 + DEFAULT_TOKEN_PRICE_RETRIES) * 3;
+/**
+ * This version of the token prices service uses V2 of the Codefi Price API to
+ * fetch token prices.
+ */
+class CodefiTokenPricesServiceV2 {
+    /**
+     * Construct a Codefi Token Price Service.
+     *
+     * @param options - Constructor options
+     * @param options.retries - Number of retry attempts for each token price update.
+     * @param options.maximumConsecutiveFailures - The maximum number of consecutive failures
+     * allowed before breaking the circuit and pausing further updates.
+     * @param options.circuitBreakDuration - The amount of time to wait when the circuit breaks
+     * from too many consecutive failures.
+     */
+    constructor({ retries = DEFAULT_TOKEN_PRICE_RETRIES, maximumConsecutiveFailures = DEFAULT_TOKEN_PRICE_MAX_CONSECUTIVE_FAILURES, circuitBreakDuration = 30 * 60 * 1000, } = {}) {
+        _CodefiTokenPricesServiceV2_tokenPricePolicy.set(this, void 0);
+        // Construct a policy that will retry each update, and halt further updates
+        // for a certain period after too many consecutive failures.
+        const retryPolicy = (0, cockatiel_1.retry)(cockatiel_1.handleAll, {
+            maxAttempts: retries,
+            backoff: new cockatiel_1.ExponentialBackoff(),
+        });
+        const circuitBreakerPolicy = (0, cockatiel_1.circuitBreaker)(cockatiel_1.handleAll, {
+            halfOpenAfter: circuitBreakDuration,
+            breaker: new cockatiel_1.ConsecutiveBreaker(maximumConsecutiveFailures),
+        });
+        __classPrivateFieldSet(this, _CodefiTokenPricesServiceV2_tokenPricePolicy, (0, cockatiel_1.wrap)(retryPolicy, circuitBreakerPolicy), "f");
+    }
+    /**
+     * Retrieves prices in the given currency for the tokens identified by the
+     * given addresses which are expected to live on the given chain.
+     *
+     * @param args - The arguments to function.
+     * @param args.chainId - An EIP-155 chain ID.
+     * @param args.tokenAddresses - Addresses for tokens that live on the chain.
+     * @param args.currency - The desired currency of the token prices.
+     * @returns The prices for the requested tokens.
+     */
+    fetchTokenPrices({ chainId, tokenAddresses, currency, }) {
+        return __awaiter(this, void 0, void 0, function* () {
+            const chainIdAsNumber = (0, utils_1.hexToNumber)(chainId);
+            const url = new URL(`${BASE_URL}/chains/${chainIdAsNumber}/spot-prices`);
+            url.searchParams.append('tokenAddresses', tokenAddresses.join(','));
+            url.searchParams.append('vsCurrency', currency);
+            const pricesByCurrencyByTokenAddress = yield __classPrivateFieldGet(this, _CodefiTokenPricesServiceV2_tokenPricePolicy, "f").execute(() => (0, controller_utils_1.handleFetch)(url));
+            return tokenAddresses.reduce((obj, tokenAddress) => {
+                var _a;
+                // The Price API lowercases both currency and token addresses, so we have
+                // to keep track of them and make sure we return the original versions.
+                const lowercasedTokenAddress = tokenAddress.toLowerCase();
+                const lowercasedCurrency = currency.toLowerCase();
+                const price = (_a = pricesByCurrencyByTokenAddress[lowercasedTokenAddress]) === null || _a === void 0 ? void 0 : _a[lowercasedCurrency];
+                if (!price) {
+                    // console error instead of throwing to not interrupt the fetching of other tokens in case just one fails
+                    console.error(`Could not find price for "${tokenAddress}" in "${currency}"`);
+                }
+                const tokenPrice = {
+                    tokenAddress,
+                    value: price,
+                    currency,
+                };
+                return Object.assign(Object.assign({}, obj), (tokenPrice.value !== undefined
+                    ? { [tokenAddress]: tokenPrice }
+                    : {}));
+            }, {});
+        });
+    }
+    /**
+     * Type guard for whether the API can return token prices for the given chain
+     * ID.
+     *
+     * @param chainId - The chain ID to check.
+     * @returns True if the API supports the chain ID, false otherwise.
+     */
+    validateChainIdSupported(chainId) {
+        const supportedChainIds = exports.SUPPORTED_CHAIN_IDS;
+        return typeof chainId === 'string' && supportedChainIds.includes(chainId);
+    }
+    /**
+     * Type guard for whether the API can return token prices in the given
+     * currency.
+     *
+     * @param currency - The currency to check. If a string, can be either
+     * lowercase or uppercase.
+     * @returns True if the API supports the currency, false otherwise.
+     */
+    validateCurrencySupported(currency) {
+        const supportedCurrencies = exports.SUPPORTED_CURRENCIES;
+        return (typeof currency === 'string' &&
+            supportedCurrencies.includes(currency.toLowerCase()));
+    }
+}
+exports.CodefiTokenPricesServiceV2 = CodefiTokenPricesServiceV2;
+_CodefiTokenPricesServiceV2_tokenPricePolicy = new WeakMap();
+//# sourceMappingURL=codefi-v2.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-prices-service/codefi-v2.js.map b/node_modules/@metamask/assets-controllers/dist/token-prices-service/codefi-v2.js.map
new file mode 100644
index 0000000..6622712
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/token-prices-service/codefi-v2.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"codefi-v2.js","sourceRoot":"","sources":["../../src/token-prices-service/codefi-v2.ts"],"names":[],"mappings":"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","sourcesContent":["import { handleFetch } from '@metamask/controller-utils';\nimport type { Hex } from '@metamask/utils';\nimport { hexToNumber } from '@metamask/utils';\nimport {\n  circuitBreaker,\n  ConsecutiveBreaker,\n  ExponentialBackoff,\n  handleAll,\n  type IPolicy,\n  retry,\n  wrap,\n} from 'cockatiel';\n\nimport type {\n  AbstractTokenPricesService,\n  TokenPrice,\n  TokenPricesByTokenAddress,\n} from './abstract-token-prices-service';\n\n/**\n * The shape of the data that the /spot-prices endpoint returns.\n */\ntype SpotPricesEndpointData<\n  TokenAddress extends Hex,\n  Currency extends string,\n> = Record<TokenAddress, Record<Currency, number>>;\n\n/**\n * The list of currencies that can be supplied as the `vsCurrency` parameter to\n * the `/spot-prices` endpoint, in lowercase form.\n */\nexport const SUPPORTED_CURRENCIES = [\n  // Bitcoin\n  'btc',\n  // Ether\n  'eth',\n  // Litecoin\n  'ltc',\n  // Bitcoin Cash\n  'bch',\n  // Binance Coin\n  'bnb',\n  // EOS\n  'eos',\n  // XRP\n  'xrp',\n  // Lumens\n  'xlm',\n  // Chainlink\n  'link',\n  // Polkadot\n  'dot',\n  // Yearn.finance\n  'yfi',\n  // US Dollar\n  'usd',\n  // United Arab Emirates Dirham\n  'aed',\n  // Argentine Peso\n  'ars',\n  // Australian Dollar\n  'aud',\n  // Bangladeshi Taka\n  'bdt',\n  // Bahraini Dinar\n  'bhd',\n  // Bermudian Dollar\n  'bmd',\n  // Brazil Real\n  'brl',\n  // Canadian Dollar\n  'cad',\n  // Swiss Franc\n  'chf',\n  // Chilean Peso\n  'clp',\n  // Chinese Yuan\n  'cny',\n  // Czech Koruna\n  'czk',\n  // Danish Krone\n  'dkk',\n  // Euro\n  'eur',\n  // British Pound Sterling\n  'gbp',\n  // Hong Kong Dollar\n  'hkd',\n  // Hungarian Forint\n  'huf',\n  // Indonesian Rupiah\n  'idr',\n  // Israeli New Shekel\n  'ils',\n  // Indian Rupee\n  'inr',\n  // Japanese Yen\n  'jpy',\n  // South Korean Won\n  'krw',\n  // Kuwaiti Dinar\n  'kwd',\n  // Sri Lankan Rupee\n  'lkr',\n  // Burmese Kyat\n  'mmk',\n  // Mexican Peso\n  'mxn',\n  // Malaysian Ringgit\n  'myr',\n  // Nigerian Naira\n  'ngn',\n  // Norwegian Krone\n  'nok',\n  // New Zealand Dollar\n  'nzd',\n  // Philippine Peso\n  'php',\n  // Pakistani Rupee\n  'pkr',\n  // Polish Zloty\n  'pln',\n  // Russian Ruble\n  'rub',\n  // Saudi Riyal\n  'sar',\n  // Swedish Krona\n  'sek',\n  // Singapore Dollar\n  'sgd',\n  // Thai Baht\n  'thb',\n  // Turkish Lira\n  'try',\n  // New Taiwan Dollar\n  'twd',\n  // Ukrainian hryvnia\n  'uah',\n  // Venezuelan bolvar fuerte\n  'vef',\n  // Vietnamese ng\n  'vnd',\n  // South African Rand\n  'zar',\n  // IMF Special Drawing Rights\n  'xdr',\n  // Silver - Troy Ounce\n  'xag',\n  // Gold - Troy Ounce\n  'xau',\n  // Bits\n  'bits',\n  // Satoshi\n  'sats',\n] as const;\n\n/**\n * A currency that can be supplied as the `vsCurrency` parameter to\n * the `/spot-prices` endpoint. Covers both uppercase and lowercase versions.\n */\ntype SupportedCurrency =\n  | typeof SUPPORTED_CURRENCIES[number]\n  | Uppercase<typeof SUPPORTED_CURRENCIES[number]>;\n\n/**\n * The list of chain IDs that can be supplied in the URL for the `/spot-prices`\n * endpoint, but in hexadecimal form (for consistency with how we represent\n * chain IDs in other places).\n */\nexport const SUPPORTED_CHAIN_IDS = [\n  // Ethereum Mainnet\n  '0x1',\n  // OP Mainnet\n  '0xa',\n  // Cronos Mainnet\n  '0x19',\n  // BNB Smart Chain Mainnet\n  '0x38',\n  // Syscoin Mainnet\n  '0x39',\n  // OKXChain Mainnet\n  '0x42',\n  // Hoo Smart Chain\n  '0x46',\n  // Meter Mainnet\n  '0x52',\n  // TomoChain\n  '0x58',\n  // Gnosis\n  '0x64',\n  // Velas EVM Mainnet\n  '0x6a',\n  // Fuse Mainnet\n  '0x7a',\n  // Huobi ECO Chain Mainnet\n  '0x80',\n  // Polygon Mainnet\n  '0x89',\n  // Fantom Opera\n  '0xfa',\n  // Boba Network\n  '0x120',\n  // KCC Mainnet\n  '0x141',\n  // zkSync Era Mainnet\n  '0x144',\n  // Theta Mainnet\n  '0x169',\n  // Metis Andromeda Mainnet\n  '0x440',\n  // Moonbeam\n  '0x504',\n  // Moonriver\n  '0x505',\n  // Base\n  '0x2105',\n  // Shiden\n  '0x150',\n  // Smart Bitcoin Cash\n  '0x2710',\n  // Arbitrum One\n  '0xa4b1',\n  // Celo Mainnet\n  '0xa4ec',\n  // Oasis Emerald\n  '0xa516',\n  // Avalanche C-Chain\n  '0xa86a',\n  // Polis Mainnet\n  '0x518af',\n  // Aurora Mainnet\n  '0x4e454152',\n  // Harmony Mainnet Shard 0\n  '0x63564c40',\n] as const;\n/**\n * A chain ID that can be supplied in the URL for the `/spot-prices` endpoint,\n * but in hexadecimal form (for consistency with how we represent chain IDs in\n * other places).\n */\ntype SupportedChainId = typeof SUPPORTED_CHAIN_IDS[number];\n\n/**\n * All requests to V2 of the Price API start with this.\n */\nconst BASE_URL = 'https://price-api.metafi.codefi.network/v2';\n\nconst DEFAULT_TOKEN_PRICE_RETRIES = 3;\n// Each update attempt will result (1 + retries) calls if the server is down\nconst DEFAULT_TOKEN_PRICE_MAX_CONSECUTIVE_FAILURES =\n  (1 + DEFAULT_TOKEN_PRICE_RETRIES) * 3;\n\n/**\n * This version of the token prices service uses V2 of the Codefi Price API to\n * fetch token prices.\n */\nexport class CodefiTokenPricesServiceV2\n  implements\n    AbstractTokenPricesService<SupportedChainId, Hex, SupportedCurrency>\n{\n  #tokenPricePolicy: IPolicy;\n\n  /**\n   * Construct a Codefi Token Price Service.\n   *\n   * @param options - Constructor options\n   * @param options.retries - Number of retry attempts for each token price update.\n   * @param options.maximumConsecutiveFailures - The maximum number of consecutive failures\n   * allowed before breaking the circuit and pausing further updates.\n   * @param options.circuitBreakDuration - The amount of time to wait when the circuit breaks\n   * from too many consecutive failures.\n   */\n  constructor({\n    retries = DEFAULT_TOKEN_PRICE_RETRIES,\n    maximumConsecutiveFailures = DEFAULT_TOKEN_PRICE_MAX_CONSECUTIVE_FAILURES,\n    circuitBreakDuration = 30 * 60 * 1000,\n  }: {\n    retries?: number;\n    maximumConsecutiveFailures?: number;\n    circuitBreakDuration?: number;\n  } = {}) {\n    // Construct a policy that will retry each update, and halt further updates\n    // for a certain period after too many consecutive failures.\n    const retryPolicy = retry(handleAll, {\n      maxAttempts: retries,\n      backoff: new ExponentialBackoff(),\n    });\n    const circuitBreakerPolicy = circuitBreaker(handleAll, {\n      halfOpenAfter: circuitBreakDuration,\n      breaker: new ConsecutiveBreaker(maximumConsecutiveFailures),\n    });\n    this.#tokenPricePolicy = wrap(retryPolicy, circuitBreakerPolicy);\n  }\n\n  /**\n   * Retrieves prices in the given currency for the tokens identified by the\n   * given addresses which are expected to live on the given chain.\n   *\n   * @param args - The arguments to function.\n   * @param args.chainId - An EIP-155 chain ID.\n   * @param args.tokenAddresses - Addresses for tokens that live on the chain.\n   * @param args.currency - The desired currency of the token prices.\n   * @returns The prices for the requested tokens.\n   */\n  async fetchTokenPrices({\n    chainId,\n    tokenAddresses,\n    currency,\n  }: {\n    chainId: SupportedChainId;\n    tokenAddresses: Hex[];\n    currency: SupportedCurrency;\n  }): Promise<Partial<TokenPricesByTokenAddress<Hex, SupportedCurrency>>> {\n    const chainIdAsNumber = hexToNumber(chainId);\n\n    const url = new URL(`${BASE_URL}/chains/${chainIdAsNumber}/spot-prices`);\n    url.searchParams.append('tokenAddresses', tokenAddresses.join(','));\n    url.searchParams.append('vsCurrency', currency);\n\n    const pricesByCurrencyByTokenAddress: SpotPricesEndpointData<\n      Lowercase<Hex>,\n      Lowercase<SupportedCurrency>\n    > = await this.#tokenPricePolicy.execute(() => handleFetch(url));\n\n    return tokenAddresses.reduce(\n      (\n        obj: Partial<TokenPricesByTokenAddress<Hex, SupportedCurrency>>,\n        tokenAddress,\n      ) => {\n        // The Price API lowercases both currency and token addresses, so we have\n        // to keep track of them and make sure we return the original versions.\n        const lowercasedTokenAddress =\n          tokenAddress.toLowerCase() as Lowercase<Hex>;\n        const lowercasedCurrency =\n          currency.toLowerCase() as Lowercase<SupportedCurrency>;\n\n        const price =\n          pricesByCurrencyByTokenAddress[lowercasedTokenAddress]?.[\n            lowercasedCurrency\n          ];\n\n        if (!price) {\n          // console error instead of throwing to not interrupt the fetching of other tokens in case just one fails\n          console.error(\n            `Could not find price for \"${tokenAddress}\" in \"${currency}\"`,\n          );\n        }\n\n        const tokenPrice: TokenPrice<Hex, SupportedCurrency> = {\n          tokenAddress,\n          value: price,\n          currency,\n        };\n        return {\n          ...obj,\n          ...(tokenPrice.value !== undefined\n            ? { [tokenAddress]: tokenPrice }\n            : {}),\n        };\n      },\n      {},\n    ) as Partial<TokenPricesByTokenAddress<Hex, SupportedCurrency>>;\n  }\n\n  /**\n   * Type guard for whether the API can return token prices for the given chain\n   * ID.\n   *\n   * @param chainId - The chain ID to check.\n   * @returns True if the API supports the chain ID, false otherwise.\n   */\n  validateChainIdSupported(chainId: unknown): chainId is SupportedChainId {\n    const supportedChainIds: readonly string[] = SUPPORTED_CHAIN_IDS;\n    return typeof chainId === 'string' && supportedChainIds.includes(chainId);\n  }\n\n  /**\n   * Type guard for whether the API can return token prices in the given\n   * currency.\n   *\n   * @param currency - The currency to check. If a string, can be either\n   * lowercase or uppercase.\n   * @returns True if the API supports the currency, false otherwise.\n   */\n  validateCurrencySupported(currency: unknown): currency is SupportedCurrency {\n    const supportedCurrencies: readonly string[] = SUPPORTED_CURRENCIES;\n    return (\n      typeof currency === 'string' &&\n      supportedCurrencies.includes(currency.toLowerCase())\n    );\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-prices-service/codefi-v2.mjs b/node_modules/@metamask/assets-controllers/dist/token-prices-service/codefi-v2.mjs
new file mode 100644
index 0000000..84a8c58
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/token-prices-service/codefi-v2.mjs
@@ -0,0 +1,12 @@
+import {
+  CodefiTokenPricesServiceV2,
+  SUPPORTED_CHAIN_IDS,
+  SUPPORTED_CURRENCIES
+} from "../chunk-OSEZFHQ3.mjs";
+import "../chunk-XUI43LEZ.mjs";
+export {
+  CodefiTokenPricesServiceV2,
+  SUPPORTED_CHAIN_IDS,
+  SUPPORTED_CURRENCIES
+};
+//# sourceMappingURL=codefi-v2.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-prices-service/codefi-v2.mjs.map b/node_modules/@metamask/assets-controllers/dist/token-prices-service/codefi-v2.mjs.map
new file mode 100644
index 0000000..84c51b2
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/token-prices-service/codefi-v2.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":[],"sourcesContent":[],"mappings":"","names":[]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-prices-service/index.d.ts b/node_modules/@metamask/assets-controllers/dist/token-prices-service/index.d.ts
new file mode 100644
index 0000000..785225a
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/token-prices-service/index.d.ts
@@ -0,0 +1,3 @@
+export type { AbstractTokenPricesService } from './abstract-token-prices-service';
+export { CodefiTokenPricesServiceV2 } from './codefi-v2';
+//# sourceMappingURL=index.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-prices-service/index.d.ts.map b/node_modules/@metamask/assets-controllers/dist/token-prices-service/index.d.ts.map
new file mode 100644
index 0000000..48c1a1c
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/token-prices-service/index.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../src/token-prices-service/index.ts"],"names":[],"mappings":"AAAA,YAAY,EAAE,0BAA0B,EAAE,MAAM,iCAAiC,CAAC;AAClF,OAAO,EAAE,0BAA0B,EAAE,MAAM,aAAa,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-prices-service/index.js b/node_modules/@metamask/assets-controllers/dist/token-prices-service/index.js
new file mode 100644
index 0000000..5d52474
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/token-prices-service/index.js
@@ -0,0 +1,6 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.CodefiTokenPricesServiceV2 = void 0;
+var codefi_v2_1 = require("./codefi-v2");
+Object.defineProperty(exports, "CodefiTokenPricesServiceV2", { enumerable: true, get: function () { return codefi_v2_1.CodefiTokenPricesServiceV2; } });
+//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-prices-service/index.js.map b/node_modules/@metamask/assets-controllers/dist/token-prices-service/index.js.map
new file mode 100644
index 0000000..2692b27
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/token-prices-service/index.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/token-prices-service/index.ts"],"names":[],"mappings":";;;AACA,yCAAyD;AAAhD,uHAAA,0BAA0B,OAAA","sourcesContent":["export type { AbstractTokenPricesService } from './abstract-token-prices-service';\nexport { CodefiTokenPricesServiceV2 } from './codefi-v2';\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-prices-service/index.mjs b/node_modules/@metamask/assets-controllers/dist/token-prices-service/index.mjs
new file mode 100644
index 0000000..f0a8217
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/token-prices-service/index.mjs
@@ -0,0 +1,11 @@
+import "../chunk-27KOXCQK.mjs";
+import {
+  CodefiTokenPricesServiceV2,
+  SUPPORTED_CHAIN_IDS
+} from "../chunk-OSEZFHQ3.mjs";
+import "../chunk-XUI43LEZ.mjs";
+export {
+  CodefiTokenPricesServiceV2,
+  SUPPORTED_CHAIN_IDS
+};
+//# sourceMappingURL=index.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-prices-service/index.mjs.map b/node_modules/@metamask/assets-controllers/dist/token-prices-service/index.mjs.map
new file mode 100644
index 0000000..84c51b2
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/token-prices-service/index.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":[],"sourcesContent":[],"mappings":"","names":[]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-service.d.ts.map b/node_modules/@metamask/assets-controllers/dist/token-service.d.ts.map
index 950c3ad..1d549e5 100644
--- a/node_modules/@metamask/assets-controllers/dist/token-service.d.ts.map
+++ b/node_modules/@metamask/assets-controllers/dist/token-service.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"token-service.d.ts","sourceRoot":"","sources":["../src/token-service.ts"],"names":[],"mappings":"AACA,OAAO,KAAK,EAAE,GAAG,EAAE,MAAM,iBAAiB,CAAC;AAI3C,eAAO,MAAM,mBAAmB,8CAA8C,CAAC;AAC/E,eAAO,MAAM,+BAA+B,oEACuB,CAAC;AA+BpE;;;;;;;;;GASG;AACH,wBAAsB,cAAc,CAClC,OAAO,EAAE,GAAG,EACZ,WAAW,EAAE,WAAW,EACxB,EAAE,OAAwB,EAAE;;CAAK,GAChC,OAAO,CAAC,OAAO,CAAC,CAOlB;AAED;;;;;;;;;;GAUG;AACH,wBAAsB,kBAAkB,CAAC,CAAC,EACxC,OAAO,EAAE,GAAG,EACZ,YAAY,EAAE,MAAM,EACpB,WAAW,EAAE,WAAW,EACxB,EAAE,OAAwB,EAAE;;CAAK,GAChC,OAAO,CAAC,CAAC,GAAG,SAAS,CAAC,CAUxB"}
\ No newline at end of file
+{"version":3,"file":"token-service.d.ts","sourceRoot":"","sources":["../src/token-service.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,GAAG,EAAE,MAAM,iBAAiB,CAAC;AAI3C,eAAO,MAAM,mBAAmB,8CAA8C,CAAC;AAC/E,eAAO,MAAM,+BAA+B,oEACuB,CAAC;AA+BpE;;;;;;;;;GASG;AACH,wBAAsB,cAAc,CAClC,OAAO,EAAE,GAAG,EACZ,WAAW,EAAE,WAAW,EACxB,EAAE,OAAwB,EAAE;;CAAK,GAChC,OAAO,CAAC,OAAO,CAAC,CAOlB;AAED;;;;;;;;;;GAUG;AACH,wBAAsB,kBAAkB,CAAC,CAAC,EACxC,OAAO,EAAE,GAAG,EACZ,YAAY,EAAE,MAAM,EACpB,WAAW,EAAE,WAAW,EACxB,EAAE,OAAwB,EAAE;;CAAK,GAChC,OAAO,CAAC,CAAC,GAAG,SAAS,CAAC,CAUxB"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-service.js.map b/node_modules/@metamask/assets-controllers/dist/token-service.js.map
index 83b7875..e64fcc6 100644
--- a/node_modules/@metamask/assets-controllers/dist/token-service.js.map
+++ b/node_modules/@metamask/assets-controllers/dist/token-service.js.map
@@ -1 +1 @@
-{"version":3,"file":"token-service.js","sourceRoot":"","sources":["../src/token-service.ts"],"names":[],"mappings":"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","sourcesContent":["import { convertHexToDecimal, timeoutFetch } from '@metamask/controller-utils';\nimport type { Hex } from '@metamask/utils';\n\nimport { isTokenListSupportedForNetwork } from './assetsUtil';\n\nexport const TOKEN_END_POINT_API = 'https://token-api.metaswap.codefi.network';\nexport const TOKEN_METADATA_NO_SUPPORT_ERROR =\n  'TokenService Error: Network does not support fetchTokenMetadata';\n\n/**\n * Get the tokens URL for a specific network.\n *\n * @param chainId - The chain ID of the network the tokens requested are on.\n * @returns The tokens URL.\n */\nfunction getTokensURL(chainId: Hex) {\n  return `${TOKEN_END_POINT_API}/tokens/${convertHexToDecimal(chainId)}`;\n}\n\n/**\n * Get the token metadata URL for the given network and token.\n *\n * @param chainId - The chain ID of the network the token is on.\n * @param tokenAddress - The token address.\n * @returns The token metadata URL.\n */\nfunction getTokenMetadataURL(chainId: Hex, tokenAddress: string) {\n  return `${TOKEN_END_POINT_API}/token/${convertHexToDecimal(\n    chainId,\n  )}?address=${tokenAddress}`;\n}\n\nconst tenSecondsInMilliseconds = 10_000;\n\n// Token list averages 1.6 MB in size\n// timeoutFetch by default has a 500ms timeout, which will almost always timeout given the response size.\nconst defaultTimeout = tenSecondsInMilliseconds;\n\n/**\n * Fetch the list of token metadata for a given network. This request is cancellable using the\n * abort signal passed in.\n *\n * @param chainId - The chain ID of the network the requested tokens are on.\n * @param abortSignal - The abort signal used to cancel the request if necessary.\n * @param options - Additional fetch options.\n * @param options.timeout - The fetch timeout.\n * @returns The token list, or `undefined` if the request was cancelled.\n */\nexport async function fetchTokenList(\n  chainId: Hex,\n  abortSignal: AbortSignal,\n  { timeout = defaultTimeout } = {},\n): Promise<unknown> {\n  const tokenURL = getTokensURL(chainId);\n  const response = await queryApi(tokenURL, abortSignal, timeout);\n  if (response) {\n    return parseJsonResponse(response);\n  }\n  return undefined;\n}\n\n/**\n * Fetch metadata for the token address provided for a given network. This request is cancellable\n * using the abort signal passed in.\n *\n * @param chainId - The chain ID of the network the token is on.\n * @param tokenAddress - The address of the token to fetch metadata for.\n * @param abortSignal - The abort signal used to cancel the request if necessary.\n * @param options - Additional fetch options.\n * @param options.timeout - The fetch timeout.\n * @returns The token metadata, or `undefined` if the request was either aborted or failed.\n */\nexport async function fetchTokenMetadata<T>(\n  chainId: Hex,\n  tokenAddress: string,\n  abortSignal: AbortSignal,\n  { timeout = defaultTimeout } = {},\n): Promise<T | undefined> {\n  if (!isTokenListSupportedForNetwork(chainId)) {\n    throw new Error(TOKEN_METADATA_NO_SUPPORT_ERROR);\n  }\n  const tokenMetadataURL = getTokenMetadataURL(chainId, tokenAddress);\n  const response = await queryApi(tokenMetadataURL, abortSignal, timeout);\n  if (response) {\n    return parseJsonResponse(response) as Promise<T>;\n  }\n  return undefined;\n}\n\n/**\n * Perform fetch request against the api.\n *\n * @param apiURL - The URL of the API to fetch.\n * @param abortSignal - The abort signal used to cancel the request if necessary.\n * @param timeout - The fetch timeout.\n * @returns Promise resolving request response.\n */\nasync function queryApi(\n  apiURL: string,\n  abortSignal: AbortSignal,\n  timeout: number,\n): Promise<Response | undefined> {\n  const fetchOptions: RequestInit = {\n    referrer: apiURL,\n    referrerPolicy: 'no-referrer-when-downgrade',\n    method: 'GET',\n    mode: 'cors',\n    signal: abortSignal,\n    cache: 'default',\n  };\n  fetchOptions.headers = new window.Headers();\n  fetchOptions.headers.set('Content-Type', 'application/json');\n  try {\n    return await timeoutFetch(apiURL, fetchOptions, timeout);\n  } catch (error) {\n    if (error instanceof Error && error.name === 'AbortError') {\n      console.log('Request is aborted');\n    }\n  }\n  return undefined;\n}\n\n/**\n * Parse an API response and return the response JSON data.\n *\n * @param apiResponse - The API response to parse.\n * @returns The response JSON data.\n * @throws Will throw if the response includes an error.\n */\nasync function parseJsonResponse(apiResponse: Response): Promise<unknown> {\n  const responseObj = await apiResponse.json();\n  // api may return errors as json without setting an error http status code\n  if (responseObj?.error) {\n    throw new Error(`TokenService Error: ${responseObj.error}`);\n  }\n  return responseObj;\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"token-service.js","sourceRoot":"","sources":["../src/token-service.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Hex } from '@metamask/utils';\nimport { convertHexToDecimal, timeoutFetch } from '@metamask/controller-utils';\nimport { isTokenListSupportedForNetwork } from './assetsUtil';\n\nexport const TOKEN_END_POINT_API = 'https://token-api.metaswap.codefi.network';\nexport const TOKEN_METADATA_NO_SUPPORT_ERROR =\n  'TokenService Error: Network does not support fetchTokenMetadata';\n\n/**\n * Get the tokens URL for a specific network.\n *\n * @param chainId - The chain ID of the network the tokens requested are on.\n * @returns The tokens URL.\n */\nfunction getTokensURL(chainId: Hex) {\n  return `${TOKEN_END_POINT_API}/tokens/${convertHexToDecimal(chainId)}`;\n}\n\n/**\n * Get the token metadata URL for the given network and token.\n *\n * @param chainId - The chain ID of the network the token is on.\n * @param tokenAddress - The token address.\n * @returns The token metadata URL.\n */\nfunction getTokenMetadataURL(chainId: Hex, tokenAddress: string) {\n  return `${TOKEN_END_POINT_API}/token/${convertHexToDecimal(\n    chainId,\n  )}?address=${tokenAddress}`;\n}\n\nconst tenSecondsInMilliseconds = 10_000;\n\n// Token list averages 1.6 MB in size\n// timeoutFetch by default has a 500ms timeout, which will almost always timeout given the response size.\nconst defaultTimeout = tenSecondsInMilliseconds;\n\n/**\n * Fetch the list of token metadata for a given network. This request is cancellable using the\n * abort signal passed in.\n *\n * @param chainId - The chain ID of the network the requested tokens are on.\n * @param abortSignal - The abort signal used to cancel the request if necessary.\n * @param options - Additional fetch options.\n * @param options.timeout - The fetch timeout.\n * @returns The token list, or `undefined` if the request was cancelled.\n */\nexport async function fetchTokenList(\n  chainId: Hex,\n  abortSignal: AbortSignal,\n  { timeout = defaultTimeout } = {},\n): Promise<unknown> {\n  const tokenURL = getTokensURL(chainId);\n  const response = await queryApi(tokenURL, abortSignal, timeout);\n  if (response) {\n    return parseJsonResponse(response);\n  }\n  return undefined;\n}\n\n/**\n * Fetch metadata for the token address provided for a given network. This request is cancellable\n * using the abort signal passed in.\n *\n * @param chainId - The chain ID of the network the token is on.\n * @param tokenAddress - The address of the token to fetch metadata for.\n * @param abortSignal - The abort signal used to cancel the request if necessary.\n * @param options - Additional fetch options.\n * @param options.timeout - The fetch timeout.\n * @returns The token metadata, or `undefined` if the request was either aborted or failed.\n */\nexport async function fetchTokenMetadata<T>(\n  chainId: Hex,\n  tokenAddress: string,\n  abortSignal: AbortSignal,\n  { timeout = defaultTimeout } = {},\n): Promise<T | undefined> {\n  if (!isTokenListSupportedForNetwork(chainId)) {\n    throw new Error(TOKEN_METADATA_NO_SUPPORT_ERROR);\n  }\n  const tokenMetadataURL = getTokenMetadataURL(chainId, tokenAddress);\n  const response = await queryApi(tokenMetadataURL, abortSignal, timeout);\n  if (response) {\n    return parseJsonResponse(response) as Promise<T>;\n  }\n  return undefined;\n}\n\n/**\n * Perform fetch request against the api.\n *\n * @param apiURL - The URL of the API to fetch.\n * @param abortSignal - The abort signal used to cancel the request if necessary.\n * @param timeout - The fetch timeout.\n * @returns Promise resolving request response.\n */\nasync function queryApi(\n  apiURL: string,\n  abortSignal: AbortSignal,\n  timeout: number,\n): Promise<Response | undefined> {\n  const fetchOptions: RequestInit = {\n    referrer: apiURL,\n    referrerPolicy: 'no-referrer-when-downgrade',\n    method: 'GET',\n    mode: 'cors',\n    signal: abortSignal,\n    cache: 'default',\n  };\n  fetchOptions.headers = new window.Headers();\n  fetchOptions.headers.set('Content-Type', 'application/json');\n  try {\n    return await timeoutFetch(apiURL, fetchOptions, timeout);\n  } catch (error) {\n    if (error instanceof Error && error.name === 'AbortError') {\n      console.log('Request is aborted');\n    }\n  }\n  return undefined;\n}\n\n/**\n * Parse an API response and return the response JSON data.\n *\n * @param apiResponse - The API response to parse.\n * @returns The response JSON data.\n * @throws Will throw if the response includes an error.\n */\nasync function parseJsonResponse(apiResponse: Response): Promise<unknown> {\n  const responseObj = await apiResponse.json();\n  // api may return errors as json without setting an error http status code\n  if (responseObj?.error) {\n    throw new Error(`TokenService Error: ${responseObj.error}`);\n  }\n  return responseObj;\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-service.mjs b/node_modules/@metamask/assets-controllers/dist/token-service.mjs
new file mode 100644
index 0000000..f3e26de
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/token-service.mjs
@@ -0,0 +1,15 @@
+import {
+  TOKEN_END_POINT_API,
+  TOKEN_METADATA_NO_SUPPORT_ERROR,
+  fetchTokenListByChainId,
+  fetchTokenMetadata
+} from "./chunk-KRTEFV4Q.mjs";
+import "./chunk-E5PIGGYR.mjs";
+import "./chunk-XUI43LEZ.mjs";
+export {
+  TOKEN_END_POINT_API,
+  TOKEN_METADATA_NO_SUPPORT_ERROR,
+  fetchTokenListByChainId,
+  fetchTokenMetadata
+};
+//# sourceMappingURL=token-service.mjs.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/token-service.mjs.map b/node_modules/@metamask/assets-controllers/dist/token-service.mjs.map
new file mode 100644
index 0000000..84c51b2
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/token-service.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":[],"sourcesContent":[],"mappings":"","names":[]}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/tsconfig.build.tsbuildinfo b/node_modules/@metamask/assets-controllers/dist/tsconfig.build.tsbuildinfo
new file mode 100644
index 0000000..6eb8c57
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/tsconfig.build.tsbuildinfo
@@ -0,0 +1 @@
+{"program":{"fileNames":["../../../node_modules/typescript/lib/lib.es5.d.ts","../../../node_modules/typescript/lib/lib.es2015.d.ts","../../../node_modules/typescript/lib/lib.es2016.d.ts","../../../node_modules/typescript/lib/lib.es2017.d.ts","../../../node_modules/typescript/lib/lib.es2018.d.ts","../../../node_modules/typescript/lib/lib.es2019.d.ts","../../../node_modules/typescript/lib/lib.es2020.d.ts","../../../node_modules/typescript/lib/lib.dom.d.ts","../../../node_modules/typescript/lib/lib.es2015.core.d.ts","../../../node_modules/typescript/lib/lib.es2015.collection.d.ts","../../../node_modules/typescript/lib/lib.es2015.generator.d.ts","../../../node_modules/typescript/lib/lib.es2015.iterable.d.ts","../../../node_modules/typescript/lib/lib.es2015.promise.d.ts","../../../node_modules/typescript/lib/lib.es2015.proxy.d.ts","../../../node_modules/typescript/lib/lib.es2015.reflect.d.ts","../../../node_modules/typescript/lib/lib.es2015.symbol.d.ts","../../../node_modules/typescript/lib/lib.es2015.symbol.wellknown.d.ts","../../../node_modules/typescript/lib/lib.es2016.array.include.d.ts","../../../node_modules/typescript/lib/lib.es2017.object.d.ts","../../../node_modules/typescript/lib/lib.es2017.sharedmemory.d.ts","../../../node_modules/typescript/lib/lib.es2017.string.d.ts","../../../node_modules/typescript/lib/lib.es2017.intl.d.ts","../../../node_modules/typescript/lib/lib.es2017.typedarrays.d.ts","../../../node_modules/typescript/lib/lib.es2018.asyncgenerator.d.ts","../../../node_modules/typescript/lib/lib.es2018.asynciterable.d.ts","../../../node_modules/typescript/lib/lib.es2018.intl.d.ts","../../../node_modules/typescript/lib/lib.es2018.promise.d.ts","../../../node_modules/typescript/lib/lib.es2018.regexp.d.ts","../../../node_modules/typescript/lib/lib.es2019.array.d.ts","../../../node_modules/typescript/lib/lib.es2019.object.d.ts","../../../node_modules/typescript/lib/lib.es2019.string.d.ts","../../../node_modules/typescript/lib/lib.es2019.symbol.d.ts","../../../node_modules/typescript/lib/lib.es2019.intl.d.ts","../../../node_modules/typescript/lib/lib.es2020.bigint.d.ts","../../../node_modules/typescript/lib/lib.es2020.date.d.ts","../../../node_modules/typescript/lib/lib.es2020.promise.d.ts","../../../node_modules/typescript/lib/lib.es2020.sharedmemory.d.ts","../../../node_modules/typescript/lib/lib.es2020.string.d.ts","../../../node_modules/typescript/lib/lib.es2020.symbol.wellknown.d.ts","../../../node_modules/typescript/lib/lib.es2020.intl.d.ts","../../../node_modules/typescript/lib/lib.es2020.number.d.ts","../../../node_modules/typescript/lib/lib.esnext.intl.d.ts","../../../types/eth-ens-namehash.d.ts","../../../types/ethereum-ens-network-map.d.ts","../../../types/global.d.ts","../../../types/single-call-balance-checker-abi.d.ts","../../../types/@metamask/contract-metadata.d.ts","../../../types/@metamask/eth-hd-keyring.d.ts","../../../types/@metamask/eth-simple-keyring.d.ts","../../../types/@metamask/ethjs-provider-http.d.ts","../../../types/@metamask/ethjs-unit.d.ts","../../../types/@metamask/metamask-eth-abis.d.ts","../../../types/eth-json-rpc-infura/src/createprovider.d.ts","../../../types/eth-phishing-detect/src/config.json.d.ts","../../../types/eth-phishing-detect/src/detector.d.ts","../../base-controller/dist/types/basecontrollerv1.d.ts","../../../node_modules/superstruct/dist/error.d.ts","../../../node_modules/superstruct/dist/utils.d.ts","../../../node_modules/superstruct/dist/struct.d.ts","../../../node_modules/superstruct/dist/structs/coercions.d.ts","../../../node_modules/superstruct/dist/structs/refinements.d.ts","../../../node_modules/superstruct/dist/structs/types.d.ts","../../../node_modules/superstruct/dist/structs/utilities.d.ts","../../../node_modules/superstruct/dist/index.d.ts","../../../node_modules/@metamask/utils/dist/types/assert.d.ts","../../../node_modules/@metamask/utils/dist/types/base64.d.ts","../../../node_modules/@metamask/utils/dist/types/hex.d.ts","../../../node_modules/@metamask/utils/dist/types/bytes.d.ts","../../../node_modules/@metamask/utils/dist/types/caip-types.d.ts","../../../node_modules/@metamask/utils/dist/types/checksum.d.ts","../../../node_modules/@metamask/utils/dist/types/coercers.d.ts","../../../node_modules/@metamask/utils/dist/types/collections.d.ts","../../../node_modules/@metamask/utils/dist/types/encryption-types.d.ts","../../../node_modules/@metamask/utils/dist/types/errors.d.ts","../../../node_modules/@metamask/utils/dist/types/json.d.ts","../../../node_modules/@types/node/assert.d.ts","../../../node_modules/@types/node/assert/strict.d.ts","../../../node_modules/@types/node/globals.d.ts","../../../node_modules/@types/node/async_hooks.d.ts","../../../node_modules/@types/node/buffer.d.ts","../../../node_modules/@types/node/child_process.d.ts","../../../node_modules/@types/node/cluster.d.ts","../../../node_modules/@types/node/console.d.ts","../../../node_modules/@types/node/constants.d.ts","../../../node_modules/@types/node/crypto.d.ts","../../../node_modules/@types/node/dgram.d.ts","../../../node_modules/@types/node/diagnostics_channel.d.ts","../../../node_modules/@types/node/dns.d.ts","../../../node_modules/@types/node/dns/promises.d.ts","../../../node_modules/@types/node/domain.d.ts","../../../node_modules/@types/node/events.d.ts","../../../node_modules/@types/node/fs.d.ts","../../../node_modules/@types/node/fs/promises.d.ts","../../../node_modules/@types/node/http.d.ts","../../../node_modules/@types/node/http2.d.ts","../../../node_modules/@types/node/https.d.ts","../../../node_modules/@types/node/inspector.d.ts","../../../node_modules/@types/node/module.d.ts","../../../node_modules/@types/node/net.d.ts","../../../node_modules/@types/node/os.d.ts","../../../node_modules/@types/node/path.d.ts","../../../node_modules/@types/node/perf_hooks.d.ts","../../../node_modules/@types/node/process.d.ts","../../../node_modules/@types/node/punycode.d.ts","../../../node_modules/@types/node/querystring.d.ts","../../../node_modules/@types/node/readline.d.ts","../../../node_modules/@types/node/repl.d.ts","../../../node_modules/@types/node/stream.d.ts","../../../node_modules/@types/node/stream/promises.d.ts","../../../node_modules/@types/node/stream/consumers.d.ts","../../../node_modules/@types/node/stream/web.d.ts","../../../node_modules/@types/node/string_decoder.d.ts","../../../node_modules/@types/node/test.d.ts","../../../node_modules/@types/node/timers.d.ts","../../../node_modules/@types/node/timers/promises.d.ts","../../../node_modules/@types/node/tls.d.ts","../../../node_modules/@types/node/trace_events.d.ts","../../../node_modules/@types/node/tty.d.ts","../../../node_modules/@types/node/url.d.ts","../../../node_modules/@types/node/util.d.ts","../../../node_modules/@types/node/v8.d.ts","../../../node_modules/@types/node/vm.d.ts","../../../node_modules/@types/node/wasi.d.ts","../../../node_modules/@types/node/worker_threads.d.ts","../../../node_modules/@types/node/zlib.d.ts","../../../node_modules/@types/node/globals.global.d.ts","../../../node_modules/@types/node/index.d.ts","../../../node_modules/@ethereumjs/common/dist/enums.d.ts","../../../node_modules/@ethereumjs/common/dist/types.d.ts","../../../node_modules/buffer/index.d.ts","../../../node_modules/@ethereumjs/util/dist/constants.d.ts","../../../node_modules/@ethereumjs/util/dist/units.d.ts","../../../node_modules/@ethereumjs/util/dist/address.d.ts","../../../node_modules/@ethereumjs/util/dist/bytes.d.ts","../../../node_modules/@ethereumjs/util/dist/types.d.ts","../../../node_modules/@ethereumjs/util/dist/account.d.ts","../../../node_modules/@ethereumjs/util/dist/withdrawal.d.ts","../../../node_modules/@ethereumjs/util/dist/signature.d.ts","../../../node_modules/@ethereumjs/util/dist/encoding.d.ts","../../../node_modules/@ethereumjs/util/dist/asynceventemitter.d.ts","../../../node_modules/@ethereumjs/util/dist/internal.d.ts","../../../node_modules/@ethereumjs/util/dist/lock.d.ts","../../../node_modules/@ethereumjs/util/dist/provider.d.ts","../../../node_modules/@ethereumjs/util/dist/index.d.ts","../../../node_modules/@ethereumjs/common/dist/common.d.ts","../../../node_modules/@ethereumjs/common/dist/utils.d.ts","../../../node_modules/@ethereumjs/common/dist/index.d.ts","../../../node_modules/@ethereumjs/tx/dist/eip2930transaction.d.ts","../../../node_modules/@ethereumjs/tx/dist/legacytransaction.d.ts","../../../node_modules/@ethereumjs/tx/dist/types.d.ts","../../../node_modules/@ethereumjs/tx/dist/basetransaction.d.ts","../../../node_modules/@ethereumjs/tx/dist/eip1559transaction.d.ts","../../../node_modules/@ethereumjs/tx/dist/transactionfactory.d.ts","../../../node_modules/@ethereumjs/tx/dist/index.d.ts","../../../node_modules/@metamask/utils/dist/types/keyring.d.ts","../../../node_modules/@types/ms/index.d.ts","../../../node_modules/@types/debug/index.d.ts","../../../node_modules/@metamask/utils/dist/types/logging.d.ts","../../../node_modules/@metamask/utils/dist/types/misc.d.ts","../../../node_modules/@metamask/utils/dist/types/number.d.ts","../../../node_modules/@metamask/utils/dist/types/opaque.d.ts","../../../node_modules/@metamask/utils/dist/types/promise.d.ts","../../../node_modules/@metamask/utils/dist/types/time.d.ts","../../../node_modules/@metamask/utils/dist/types/transaction-types.d.ts","../../../node_modules/@metamask/utils/dist/types/versions.d.ts","../../../node_modules/@metamask/utils/dist/types/index.d.ts","../../../node_modules/immer/dist/utils/env.d.ts","../../../node_modules/immer/dist/utils/errors.d.ts","../../../node_modules/immer/dist/types/types-external.d.ts","../../../node_modules/immer/dist/types/types-internal.d.ts","../../../node_modules/immer/dist/utils/common.d.ts","../../../node_modules/immer/dist/utils/plugins.d.ts","../../../node_modules/immer/dist/core/scope.d.ts","../../../node_modules/immer/dist/core/finalize.d.ts","../../../node_modules/immer/dist/core/proxy.d.ts","../../../node_modules/immer/dist/core/immerclass.d.ts","../../../node_modules/immer/dist/core/current.d.ts","../../../node_modules/immer/dist/internal.d.ts","../../../node_modules/immer/dist/plugins/es5.d.ts","../../../node_modules/immer/dist/plugins/patches.d.ts","../../../node_modules/immer/dist/plugins/mapset.d.ts","../../../node_modules/immer/dist/plugins/all.d.ts","../../../node_modules/immer/dist/immer.d.ts","../../base-controller/dist/types/restrictedcontrollermessenger.d.ts","../../base-controller/dist/types/controllermessenger.d.ts","../../base-controller/dist/types/basecontrollerv2.d.ts","../../base-controller/dist/types/index.d.ts","../../controller-utils/dist/types/types.d.ts","../../controller-utils/dist/types/constants.d.ts","../../../node_modules/@metamask/eth-query/index.d.ts","../../../node_modules/@types/bn.js/index.d.ts","../../controller-utils/dist/types/util.d.ts","../../../node_modules/@spruceid/siwe-parser/dist/abnf.d.ts","../../../node_modules/@spruceid/siwe-parser/dist/regex.d.ts","../../../node_modules/@spruceid/siwe-parser/dist/parsers.d.ts","../../controller-utils/dist/types/siwe.d.ts","../../controller-utils/dist/types/index.d.ts","../../../node_modules/@metamask/swappable-obj-proxy/dist/types.d.ts","../../../node_modules/@metamask/swappable-obj-proxy/dist/createeventemitterproxy.d.ts","../../../node_modules/@metamask/swappable-obj-proxy/dist/createswappableproxy.d.ts","../../../node_modules/@metamask/swappable-obj-proxy/dist/index.d.ts","../../network-controller/dist/types/constants.d.ts","../../../node_modules/@metamask/safe-event-emitter/index.d.ts","../../json-rpc-engine/dist/types/jsonrpcengine.d.ts","../../json-rpc-engine/dist/types/createasyncmiddleware.d.ts","../../json-rpc-engine/dist/types/createscaffoldmiddleware.d.ts","../../json-rpc-engine/dist/types/getuniqueid.d.ts","../../json-rpc-engine/dist/types/idremapmiddleware.d.ts","../../json-rpc-engine/dist/types/mergemiddleware.d.ts","../../json-rpc-engine/dist/types/index.d.ts","../../eth-json-rpc-provider/dist/types/safe-event-emitter-provider.d.ts","../../eth-json-rpc-provider/dist/types/provider-from-engine.d.ts","../../eth-json-rpc-provider/dist/types/provider-from-middleware.d.ts","../../eth-json-rpc-provider/dist/types/index.d.ts","../../../node_modules/eth-block-tracker/dist/blocktracker.d.ts","../../../node_modules/eth-block-tracker/dist/pollingblocktracker.d.ts","../../../node_modules/eth-block-tracker/dist/subscribeblocktracker.d.ts","../../../node_modules/eth-block-tracker/dist/index.d.ts","../../network-controller/dist/types/types.d.ts","../../network-controller/dist/types/create-auto-managed-network-client.d.ts","../../network-controller/dist/types/networkcontroller.d.ts","../../network-controller/dist/types/create-network-client.d.ts","../../network-controller/dist/types/index.d.ts","../../polling-controller/dist/types/types.d.ts","../../polling-controller/dist/types/blocktrackerpollingcontroller.d.ts","../../polling-controller/dist/types/staticintervalpollingcontroller.d.ts","../../polling-controller/dist/types/index.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/patchcbor.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/lib/dataitem.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/lib/cbor-sync.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/lib/index.d.ts","../../../node_modules/@ngraveio/bc-ur/dist/ur.d.ts","../../../node_modules/@ngraveio/bc-ur/dist/urencoder.d.ts","../../../node_modules/@ngraveio/bc-ur/dist/fountainencoder.d.ts","../../../node_modules/@ngraveio/bc-ur/dist/fountaindecoder.d.ts","../../../node_modules/@ngraveio/bc-ur/dist/urdecoder.d.ts","../../../node_modules/@ngraveio/bc-ur/dist/index.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/registrytype.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/registryitem.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/cryptocoininfo.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/pathcomponent.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/cryptokeypath.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/types.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/cryptohdkey.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/cryptoeckey.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/bytes.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/multikey.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/scriptexpression.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/cryptooutput.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/cryptopsbt.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/cryptoaccount.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/decoder/index.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/extended/cryptomultiaccounts.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/errors/index.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/extended/derivationschema.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/extended/keyderivation.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/extended/qrhardwarecall.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/utils.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/index.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry-eth/dist/ethsignrequest.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry-eth/dist/ethsignature.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry-eth/dist/ethnftitem.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry-eth/dist/utlis.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry-eth/dist/index.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/dist/interactionprovider.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/dist/basekeyring.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/dist/index.d.ts","../../../node_modules/@metamask/obs-store/node_modules/@metamask/safe-event-emitter/index.d.ts","../../../node_modules/@metamask/obs-store/dist/observablestore.d.ts","../../../node_modules/@metamask/obs-store/dist/asstream.d.ts","../../../node_modules/@metamask/obs-store/dist/composedstore.d.ts","../../../node_modules/@metamask/obs-store/dist/mergedstore.d.ts","../../../node_modules/@metamask/obs-store/dist/transform.d.ts","../../../node_modules/@metamask/obs-store/dist/index.d.ts","../../../node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/@keystonehq/bc-ur-registry-eth/dist/index.d.ts","../../../node_modules/@keystonehq/metamask-airgapped-keyring/dist/metamaskinteractionprovider.d.ts","../../../node_modules/@keystonehq/metamask-airgapped-keyring/dist/metamaskkeyring.d.ts","../../../node_modules/@keystonehq/metamask-airgapped-keyring/dist/index.d.ts","../../../node_modules/@metamask/browser-passworder/dist/index.d.ts","../../../node_modules/@metamask/keyring-api/dist/superstruct.d.ts","../../../node_modules/@metamask/keyring-api/dist/api.d.ts","../../../node_modules/@metamask/keyring-api/dist/eth/erc4337/types.d.ts","../../../node_modules/@metamask/keyring-api/dist/eth/erc4337/index.d.ts","../../../node_modules/@metamask/keyring-api/dist/eth/types.d.ts","../../../node_modules/@metamask/keyring-api/dist/eth/index.d.ts","../../../node_modules/@metamask/keyring-api/dist/events.d.ts","../../../node_modules/@metamask/keyring-api/dist/internal/api.d.ts","../../../node_modules/@metamask/keyring-api/dist/internal/eth/ethkeyring.d.ts","../../../node_modules/@metamask/keyring-api/dist/internal/eth/index.d.ts","../../../node_modules/@metamask/keyring-api/dist/internal/events.d.ts","../../../node_modules/@metamask/keyring-api/dist/internal/rpc.d.ts","../../../node_modules/@metamask/keyring-api/dist/internal/types.d.ts","../../../node_modules/@metamask/keyring-api/dist/internal/index.d.ts","../../../node_modules/@metamask/keyring-api/dist/jsonrpcrequest.d.ts","../../../node_modules/@metamask/keyring-api/dist/keyringclient.d.ts","../../../node_modules/@metamask/providers/dist/utils.d.ts","../../../node_modules/@metamask/providers/dist/baseprovider.d.ts","../../../node_modules/@metamask/providers/dist/eip6963.d.ts","../../../node_modules/@types/readable-stream/node_modules/safe-buffer/index.d.ts","../../../node_modules/@types/readable-stream/index.d.ts","../../../node_modules/@metamask/providers/dist/streamprovider.d.ts","../../../node_modules/@metamask/providers/dist/extension-provider/createexternalextensionprovider.d.ts","../../../node_modules/@metamask/providers/dist/metamaskinpageprovider.d.ts","../../../node_modules/@metamask/providers/dist/initializeinpageprovider.d.ts","../../../node_modules/@metamask/providers/dist/shimweb3.d.ts","../../../node_modules/@metamask/providers/dist/index.d.ts","../../../node_modules/@metamask/keyring-api/dist/keyringsnaprpcclient.d.ts","../../../node_modules/@metamask/keyring-api/dist/rpc-handler.d.ts","../../../node_modules/@metamask/rpc-errors/dist/types/utils.d.ts","../../../node_modules/@metamask/rpc-errors/dist/types/classes.d.ts","../../../node_modules/@metamask/rpc-errors/dist/types/errors.d.ts","../../../node_modules/@metamask/rpc-errors/dist/types/error-constants.d.ts","../../../node_modules/@metamask/rpc-errors/dist/types/index.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/errors.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/internals/error-wrappers.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/internals/errors.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/internals/helpers.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/internals/structs.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/internals/index.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/error-wrappers.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/nodes.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/address.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/copyable.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/divider.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/heading.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/image.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/panel.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/spinner.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/text.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/row.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/index.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/component.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/index.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/images.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/dialog.d.ts","../../../node_modules/@metamask/key-tree/dist/types/constants.d.ts","../../../node_modules/@noble/ed25519/lib/index.d.ts","../../../node_modules/@metamask/key-tree/dist/types/curves/ed25519.d.ts","../../../node_modules/@noble/secp256k1/lib/index.d.ts","../../../node_modules/@metamask/key-tree/dist/types/curves/secp256k1.d.ts","../../../node_modules/@metamask/key-tree/dist/types/curves/curve.d.ts","../../../node_modules/@metamask/key-tree/dist/types/curves/index.d.ts","../../../node_modules/@metamask/key-tree/dist/types/utils.d.ts","../../../node_modules/@metamask/key-tree/dist/types/bip44cointypenode.d.ts","../../../node_modules/@metamask/key-tree/dist/types/slip10node.d.ts","../../../node_modules/@metamask/key-tree/dist/types/bip44node.d.ts","../../../node_modules/@metamask/key-tree/dist/types/derivers/bip32.d.ts","../../../node_modules/@metamask/key-tree/dist/types/derivers/bip39.d.ts","../../../node_modules/@metamask/key-tree/dist/types/derivers/slip10.d.ts","../../../node_modules/@metamask/key-tree/dist/types/derivers/index.d.ts","../../../node_modules/@metamask/key-tree/dist/types/index.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/caip.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/permissions.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/get-bip32-entropy.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/get-bip32-public-key.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/get-bip44-entropy.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/get-client-status.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/get-entropy.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/get-file.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/get-locale.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/snap.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/get-snaps.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/invoke-snap.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/invoke-keyring.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/manage-accounts.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/manage-state.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/notify.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/request-snaps.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/methods.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/index.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/provider.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/global.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/cronjob.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/home-page.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/keyring.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/lifecycle.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/name-lookup.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/rpc-request.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/transaction.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/signature.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/index.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/index.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/index.d.ts","../../../node_modules/@metamask/keyring-api/dist/snap-utils.d.ts","../../../node_modules/@metamask/keyring-api/dist/index.d.ts","../../message-manager/dist/types/abstractmessagemanager.d.ts","../../message-manager/dist/types/messagemanager.d.ts","../../message-manager/dist/types/personalmessagemanager.d.ts","../../message-manager/dist/types/typedmessagemanager.d.ts","../../message-manager/dist/types/encryptionpublickeymanager.d.ts","../../message-manager/dist/types/decryptmessagemanager.d.ts","../../message-manager/dist/types/index.d.ts","../../keyring-controller/dist/types/keyringcontroller.d.ts","../../keyring-controller/dist/types/index.d.ts","../../preferences-controller/dist/types/constants.d.ts","../../preferences-controller/dist/types/preferencescontroller.d.ts","../../preferences-controller/dist/types/index.d.ts","../../../node_modules/async-mutex/lib/mutexinterface.d.ts","../../../node_modules/async-mutex/lib/mutex.d.ts","../../../node_modules/async-mutex/lib/semaphoreinterface.d.ts","../../../node_modules/async-mutex/lib/semaphore.d.ts","../../../node_modules/async-mutex/lib/withtimeout.d.ts","../../../node_modules/async-mutex/lib/index.d.ts","../../../node_modules/@types/lodash/common/common.d.ts","../../../node_modules/@types/lodash/common/array.d.ts","../../../node_modules/@types/lodash/common/collection.d.ts","../../../node_modules/@types/lodash/common/date.d.ts","../../../node_modules/@types/lodash/common/function.d.ts","../../../node_modules/@types/lodash/common/lang.d.ts","../../../node_modules/@types/lodash/common/math.d.ts","../../../node_modules/@types/lodash/common/number.d.ts","../../../node_modules/@types/lodash/common/object.d.ts","../../../node_modules/@types/lodash/common/seq.d.ts","../../../node_modules/@types/lodash/common/string.d.ts","../../../node_modules/@types/lodash/common/util.d.ts","../../../node_modules/@types/lodash/index.d.ts","../src/accounttrackercontroller.ts","../../../node_modules/@ethersproject/bytes/lib/index.d.ts","../../../node_modules/@ethersproject/bignumber/lib/bignumber.d.ts","../../../node_modules/@ethersproject/bignumber/lib/fixednumber.d.ts","../../../node_modules/@ethersproject/bignumber/lib/index.d.ts","../../../node_modules/@ethersproject/abi/lib/fragments.d.ts","../../../node_modules/@ethersproject/abi/lib/coders/abstract-coder.d.ts","../../../node_modules/@ethersproject/abi/lib/abi-coder.d.ts","../../../node_modules/@ethersproject/properties/lib/index.d.ts","../../../node_modules/@ethersproject/abi/lib/interface.d.ts","../../../node_modules/@ethersproject/abi/lib/index.d.ts","../../../node_modules/@ethersproject/networks/lib/types.d.ts","../../../node_modules/@ethersproject/networks/lib/index.d.ts","../../../node_modules/@ethersproject/transactions/lib/index.d.ts","../../../node_modules/@ethersproject/web/lib/index.d.ts","../../../node_modules/@ethersproject/abstract-provider/lib/index.d.ts","../../../node_modules/@ethersproject/abstract-signer/lib/index.d.ts","../../../node_modules/@ethersproject/contracts/lib/index.d.ts","../../../node_modules/@ethersproject/providers/lib/formatter.d.ts","../../../node_modules/@ethersproject/providers/lib/base-provider.d.ts","../../../node_modules/@ethersproject/providers/lib/json-rpc-provider.d.ts","../../../node_modules/@ethersproject/providers/lib/websocket-provider.d.ts","../../../node_modules/@ethersproject/providers/lib/url-json-rpc-provider.d.ts","../../../node_modules/@ethersproject/providers/lib/alchemy-provider.d.ts","../../../node_modules/@ethersproject/providers/lib/ankr-provider.d.ts","../../../node_modules/@ethersproject/providers/lib/cloudflare-provider.d.ts","../../../node_modules/@ethersproject/providers/lib/etherscan-provider.d.ts","../../../node_modules/@ethersproject/providers/lib/fallback-provider.d.ts","../../../node_modules/@ethersproject/providers/lib/ipc-provider.d.ts","../../../node_modules/@ethersproject/providers/lib/infura-provider.d.ts","../../../node_modules/@ethersproject/providers/lib/json-rpc-batch-provider.d.ts","../../../node_modules/@ethersproject/providers/lib/nodesmith-provider.d.ts","../../../node_modules/@ethersproject/providers/lib/pocket-provider.d.ts","../../../node_modules/@ethersproject/providers/lib/web3-provider.d.ts","../../../node_modules/@ethersproject/providers/lib/index.d.ts","../../../node_modules/multiformats/types/src/bases/interface.d.ts","../../../node_modules/multiformats/types/src/hashes/interface.d.ts","../../../node_modules/multiformats/types/src/cid.d.ts","../../../node_modules/@ethersproject/address/lib/index.d.ts","../../approval-controller/dist/types/approvalcontroller.d.ts","../../approval-controller/dist/types/errors.d.ts","../../approval-controller/dist/types/index.d.ts","../../../node_modules/@types/uuid/index.d.ts","../src/constants.ts","../src/nftdetectioncontroller.ts","../src/nftcontroller.ts","../src/token-prices-service/abstract-token-prices-service.ts","../../../node_modules/cockatiel/dist/backoff/constantbackoff.d.ts","../../../node_modules/cockatiel/dist/backoff/delegatebackoff.d.ts","../../../node_modules/cockatiel/dist/backoff/exponentialbackoffgenerators.d.ts","../../../node_modules/cockatiel/dist/backoff/exponentialbackoff.d.ts","../../../node_modules/cockatiel/dist/backoff/iterablebackoff.d.ts","../../../node_modules/cockatiel/dist/backoff/backoff.d.ts","../../../node_modules/cockatiel/dist/common/event.d.ts","../../../node_modules/cockatiel/dist/bulkheadpolicy.d.ts","../../../node_modules/cockatiel/dist/fallbackpolicy.d.ts","../../../node_modules/cockatiel/dist/nooppolicy.d.ts","../../../node_modules/cockatiel/dist/retrypolicy.d.ts","../../../node_modules/cockatiel/dist/timeoutpolicy.d.ts","../../../node_modules/cockatiel/dist/policy.d.ts","../../../node_modules/cockatiel/dist/common/executor.d.ts","../../../node_modules/cockatiel/dist/circuitbreakerpolicy.d.ts","../../../node_modules/cockatiel/dist/breaker/samplingbreaker.d.ts","../../../node_modules/cockatiel/dist/breaker/consecutivebreaker.d.ts","../../../node_modules/cockatiel/dist/breaker/breaker.d.ts","../../../node_modules/cockatiel/dist/errors/brokencircuiterror.d.ts","../../../node_modules/cockatiel/dist/errors/bulkheadrejectederror.d.ts","../../../node_modules/cockatiel/dist/errors/isolatedcircuiterror.d.ts","../../../node_modules/cockatiel/dist/errors/taskcancellederror.d.ts","../../../node_modules/cockatiel/dist/errors/errors.d.ts","../../../node_modules/cockatiel/dist/index.d.ts","../src/token-prices-service/codefi-v2.ts","../src/token-prices-service/index.ts","../src/crypto-compare.ts","../../../node_modules/@metamask/metamask-eth-abis/dist/abis/abierc20.d.ts","../../../node_modules/@metamask/metamask-eth-abis/dist/abis/abierc721.d.ts","../../../node_modules/@metamask/metamask-eth-abis/dist/abis/abierc1155.d.ts","../../../node_modules/@metamask/metamask-eth-abis/dist/index.d.ts","../../../node_modules/@metamask/abi-utils/dist/parsers/parser.d.ts","../../../node_modules/@metamask/abi-utils/dist/parsers/address.d.ts","../../../node_modules/@metamask/abi-utils/dist/parsers/array.d.ts","../../../node_modules/@metamask/abi-utils/dist/parsers/bool.d.ts","../../../node_modules/@metamask/abi-utils/dist/parsers/bytes.d.ts","../../../node_modules/@metamask/abi-utils/dist/parsers/fixed-bytes.d.ts","../../../node_modules/@metamask/abi-utils/dist/parsers/function.d.ts","../../../node_modules/@metamask/abi-utils/dist/parsers/number.d.ts","../../../node_modules/@metamask/abi-utils/dist/parsers/string.d.ts","../../../node_modules/@metamask/abi-utils/dist/parsers/tuple.d.ts","../../../node_modules/@metamask/abi-utils/dist/parsers/index.d.ts","../../../node_modules/@metamask/abi-utils/dist/types/abi.d.ts","../../../node_modules/@metamask/abi-utils/dist/types/index.d.ts","../../../node_modules/@metamask/abi-utils/dist/abi.d.ts","../../../node_modules/@metamask/abi-utils/dist/errors.d.ts","../../../node_modules/@metamask/abi-utils/dist/index.d.ts","../src/standards/erc20standard.ts","../src/standards/nftstandards/erc1155/erc1155standard.ts","../src/token-service.ts","../src/tokenlistcontroller.ts","../src/tokenscontroller.ts","../src/tokenratescontroller.ts","../src/assetsutil.ts","../src/standards/nftstandards/erc721/erc721standard.ts","../src/assetscontractcontroller.ts","../src/currencyratecontroller.ts","../src/tokenbalancescontroller.ts","../../../node_modules/@metamask/object-multiplex/dist/substream.d.ts","../../../node_modules/@metamask/object-multiplex/dist/objectmultiplex.d.ts","../../../node_modules/@metamask/object-multiplex/dist/index.d.ts","../../../node_modules/@metamask/post-message-stream/dist/utils.d.ts","../../../node_modules/@metamask/post-message-stream/dist/basepostmessagestream.d.ts","../../../node_modules/@metamask/post-message-stream/dist/window/windowpostmessagestream.d.ts","../../../node_modules/@metamask/post-message-stream/dist/webworker/webworkerpostmessagestream.d.ts","../../../node_modules/@metamask/post-message-stream/dist/webworker/webworkerparentpostmessagestream.d.ts","../../../node_modules/@metamask/post-message-stream/dist/node-process/processparentmessagestream.d.ts","../../../node_modules/@metamask/post-message-stream/dist/node-process/processmessagestream.d.ts","../../../node_modules/@metamask/post-message-stream/dist/node-thread/threadparentmessagestream.d.ts","../../../node_modules/@metamask/post-message-stream/dist/node-thread/threadmessagestream.d.ts","../../../node_modules/@metamask/post-message-stream/dist/runtime/browserruntimepostmessagestream.d.ts","../../../node_modules/@metamask/post-message-stream/dist/index.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/array.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/auxiliary-files.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/virtual-file/virtualfile.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/virtual-file/tovirtualfile.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/virtual-file/index.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/base64.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/bytes.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/caveats.d.ts","../../../node_modules/cron-parser/types/common.d.ts","../../../node_modules/cron-parser/types/index.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/cronjob.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/checksum.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/deep-clone.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/default-endowments.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/derivation-paths.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/entropy.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/eval.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/errors.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/fs.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/handler-types.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/handlers.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/iframe.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/json.d.ts","../../../node_modules/nanoid/index.d.ts","../../../node_modules/@types/deep-freeze-strict/index.d.ts","../../permission-controller/src/permission-middleware.ts","../../permission-controller/src/subjectmetadatacontroller.ts","../../permission-controller/src/utils.ts","../../permission-controller/src/permissioncontroller.ts","../../permission-controller/src/permission.ts","../../permission-controller/src/errors.ts","../../permission-controller/src/caveat.ts","../../permission-controller/src/rpc-methods/getpermissions.ts","../../permission-controller/src/rpc-methods/requestpermissions.ts","../../permission-controller/src/rpc-methods/revokepermissions.ts","../../permission-controller/src/rpc-methods/index.ts","../../permission-controller/src/index.ts","../../../node_modules/@metamask/snaps-utils/dist/types/json-rpc.d.ts","../../../node_modules/@metamask/snaps-registry/dist/verify.d.ts","../../../node_modules/@metamask/snaps-registry/dist/index.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/structs.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/manifest/validation.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/types.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/snaps.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/manifest/manifest.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/manifest/index.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/localization.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/logging.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/mock.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/namespace.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/npm.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/path.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/post-process.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/strings.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/ui.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/validation.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/versions.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/index.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/services/executionservice.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/services/abstractexecutionservice.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/services/proxypostmessagestream.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/services/iframe/iframeexecutionservice.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/services/iframe/index.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/services/node/nodeprocessexecutionservice.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/services/node/nodethreadexecutionservice.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/services/node/index.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/services/proxy/proxyexecutionservice.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/services/offscreen/offscreenexecutionservice.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/services/offscreen/index.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/services/webworker/webworkerexecutionservice.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/services/webworker/index.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/services/index.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/snaps/location/npm.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/snaps/location/location.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/snaps/location/http.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/snaps/location/local.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/snaps/location/index.d.ts","../../../node_modules/@types/punycode/index.d.ts","../../phishing-controller/src/utils.ts","../../phishing-controller/src/phishingcontroller.ts","../../phishing-controller/src/index.ts","../../../node_modules/@xstate/fsm/lib/types.d.ts","../../../node_modules/@xstate/fsm/lib/index.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/snaps/registry/registry.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/snaps/registry/json.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/snaps/registry/index.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/snaps/timer.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/snaps/snapcontroller.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/snaps/endowments/enum.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/snaps/endowments/rpc.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/snaps/endowments/signature-insight.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/snaps/endowments/transaction-insight.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/snaps/endowments/name-lookup.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/snaps/endowments/keyring.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/snaps/endowments/index.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/snaps/selectors.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/snaps/permissions.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/snaps/index.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/utils.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/cronjob/cronjobcontroller.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/cronjob/index.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/index.d.ts","../../accounts-controller/dist/types/accountscontroller.d.ts","../../accounts-controller/dist/types/utils.d.ts","../../accounts-controller/dist/types/index.d.ts","../src/tokendetectioncontroller.ts","../src/index.ts","../../../node_modules/@babel/types/lib/index.d.ts","../../../node_modules/@types/babel__generator/index.d.ts","../../../node_modules/@babel/parser/typings/babel-parser.d.ts","../../../node_modules/@types/babel__template/index.d.ts","../../../node_modules/@types/babel__traverse/index.d.ts","../../../node_modules/@types/babel__core/index.d.ts","../../../node_modules/@types/eslint/helpers.d.ts","../../../node_modules/@types/estree/index.d.ts","../../../node_modules/@types/json-schema/index.d.ts","../../../node_modules/@types/eslint/index.d.ts","../../../node_modules/@types/graceful-fs/index.d.ts","../../../node_modules/@types/istanbul-lib-coverage/index.d.ts","../../../node_modules/@types/istanbul-lib-report/index.d.ts","../../../node_modules/@types/istanbul-reports/index.d.ts","../../../node_modules/chalk/index.d.ts","../../../node_modules/jest-diff/build/cleanupsemantic.d.ts","../../../node_modules/pretty-format/build/types.d.ts","../../../node_modules/pretty-format/build/index.d.ts","../../../node_modules/jest-diff/build/types.d.ts","../../../node_modules/jest-diff/build/difflines.d.ts","../../../node_modules/jest-diff/build/printdiffs.d.ts","../../../node_modules/jest-diff/build/index.d.ts","../../../node_modules/jest-matcher-utils/build/index.d.ts","../../../node_modules/@types/jest/index.d.ts","../../../node_modules/@types/jest-when/index.d.ts","../../../node_modules/@types/json5/index.d.ts","../../../node_modules/@types/minimatch/index.d.ts","../../../node_modules/@types/parse-json/index.d.ts","../../../node_modules/@types/pbkdf2/index.d.ts","../../../node_modules/@types/prettier/index.d.ts","../../../node_modules/@types/secp256k1/index.d.ts","../../../node_modules/@types/semver/classes/semver.d.ts","../../../node_modules/@types/semver/functions/parse.d.ts","../../../node_modules/@types/semver/functions/valid.d.ts","../../../node_modules/@types/semver/functions/clean.d.ts","../../../node_modules/@types/semver/functions/inc.d.ts","../../../node_modules/@types/semver/functions/diff.d.ts","../../../node_modules/@types/semver/functions/major.d.ts","../../../node_modules/@types/semver/functions/minor.d.ts","../../../node_modules/@types/semver/functions/patch.d.ts","../../../node_modules/@types/semver/functions/prerelease.d.ts","../../../node_modules/@types/semver/functions/compare.d.ts","../../../node_modules/@types/semver/functions/rcompare.d.ts","../../../node_modules/@types/semver/functions/compare-loose.d.ts","../../../node_modules/@types/semver/functions/compare-build.d.ts","../../../node_modules/@types/semver/functions/sort.d.ts","../../../node_modules/@types/semver/functions/rsort.d.ts","../../../node_modules/@types/semver/functions/gt.d.ts","../../../node_modules/@types/semver/functions/lt.d.ts","../../../node_modules/@types/semver/functions/eq.d.ts","../../../node_modules/@types/semver/functions/neq.d.ts","../../../node_modules/@types/semver/functions/gte.d.ts","../../../node_modules/@types/semver/functions/lte.d.ts","../../../node_modules/@types/semver/functions/cmp.d.ts","../../../node_modules/@types/semver/functions/coerce.d.ts","../../../node_modules/@types/semver/classes/comparator.d.ts","../../../node_modules/@types/semver/classes/range.d.ts","../../../node_modules/@types/semver/functions/satisfies.d.ts","../../../node_modules/@types/semver/ranges/max-satisfying.d.ts","../../../node_modules/@types/semver/ranges/min-satisfying.d.ts","../../../node_modules/@types/semver/ranges/to-comparators.d.ts","../../../node_modules/@types/semver/ranges/min-version.d.ts","../../../node_modules/@types/semver/ranges/valid.d.ts","../../../node_modules/@types/semver/ranges/outside.d.ts","../../../node_modules/@types/semver/ranges/gtr.d.ts","../../../node_modules/@types/semver/ranges/ltr.d.ts","../../../node_modules/@types/semver/ranges/intersects.d.ts","../../../node_modules/@types/semver/ranges/simplify.d.ts","../../../node_modules/@types/semver/ranges/subset.d.ts","../../../node_modules/@types/semver/internals/identifiers.d.ts","../../../node_modules/@types/semver/index.d.ts","../../../node_modules/@types/sinonjs__fake-timers/index.d.ts","../../../node_modules/@types/sinon/index.d.ts","../../../node_modules/@types/stack-utils/index.d.ts","../../../node_modules/@types/yargs-parser/index.d.ts","../../../node_modules/@types/yargs/index.d.ts"],"fileInfos":[{"version":"8730f4bf322026ff5229336391a18bcaa1f94d4f82416c8b2f3954e2ccaae2ba","affectsGlobalScope":true},"dc47c4fa66b9b9890cf076304de2a9c5201e94b740cffdf09f87296d877d71f6","7a387c58583dfca701b6c85e0adaf43fb17d590fb16d5b2dc0a2fbd89f35c467","8a12173c586e95f4433e0c6dc446bc88346be73ffe9ca6eec7aa63c8f3dca7f9","5f4e733ced4e129482ae2186aae29fde948ab7182844c3a5a51dd346182c7b06","4b421cbfb3a38a27c279dec1e9112c3d1da296f77a1a85ddadf7e7a425d45d18","1fc5ab7a764205c68fa10d381b08417795fc73111d6dd16b5b1ed36badb743d9",{"version":"3aafcb693fe5b5c3bd277bd4c3a617b53db474fe498fc5df067c5603b1eebde7","affectsGlobalScope":true},{"version":"adb996790133eb33b33aadb9c09f15c2c575e71fb57a62de8bf74dbf59ec7dfb","affectsGlobalScope":true},{"version":"8cc8c5a3bac513368b0157f3d8b31cfdcfe78b56d3724f30f80ed9715e404af8","affectsGlobalScope":true},{"version":"cdccba9a388c2ee3fd6ad4018c640a471a6c060e96f1232062223063b0a5ac6a","affectsGlobalScope":true},{"version":"c5c05907c02476e4bde6b7e76a79ffcd948aedd14b6a8f56e4674221b0417398","affectsGlobalScope":true},{"version":"5f406584aef28a331c36523df688ca3650288d14f39c5d2e555c95f0d2ff8f6f","affectsGlobalScope":true},{"version":"22f230e544b35349cfb3bd9110b6ef37b41c6d6c43c3314a31bd0d9652fcec72","affectsGlobalScope":true},{"version":"7ea0b55f6b315cf9ac2ad622b0a7813315bb6e97bf4bb3fbf8f8affbca7dc695","affectsGlobalScope":true},{"version":"3013574108c36fd3aaca79764002b3717da09725a36a6fc02eac386593110f93","affectsGlobalScope":true},{"version":"eb26de841c52236d8222f87e9e6a235332e0788af8c87a71e9e210314300410a","affectsGlobalScope":true},{"version":"3be5a1453daa63e031d266bf342f3943603873d890ab8b9ada95e22389389006","affectsGlobalScope":true},{"version":"17bb1fc99591b00515502d264fa55dc8370c45c5298f4a5c2083557dccba5a2a","affectsGlobalScope":true},{"version":"7ce9f0bde3307ca1f944119f6365f2d776d281a393b576a18a2f2893a2d75c98","affectsGlobalScope":true},{"version":"6a6b173e739a6a99629a8594bfb294cc7329bfb7b227f12e1f7c11bc163b8577","affectsGlobalScope":true},{"version":"81cac4cbc92c0c839c70f8ffb94eb61e2d32dc1c3cf6d95844ca099463cf37ea","affectsGlobalScope":true},{"version":"b0124885ef82641903d232172577f2ceb5d3e60aed4da1153bab4221e1f6dd4e","affectsGlobalScope":true},{"version":"0eb85d6c590b0d577919a79e0084fa1744c1beba6fd0d4e951432fa1ede5510a","affectsGlobalScope":true},{"version":"da233fc1c8a377ba9e0bed690a73c290d843c2c3d23a7bd7ec5cd3d7d73ba1e0","affectsGlobalScope":true},{"version":"d154ea5bb7f7f9001ed9153e876b2d5b8f5c2bb9ec02b3ae0d239ec769f1f2ae","affectsGlobalScope":true},{"version":"bb2d3fb05a1d2ffbca947cc7cbc95d23e1d053d6595391bd325deb265a18d36c","affectsGlobalScope":true},{"version":"c80df75850fea5caa2afe43b9949338ce4e2de086f91713e9af1a06f973872b8","affectsGlobalScope":true},{"version":"9d57b2b5d15838ed094aa9ff1299eecef40b190722eb619bac4616657a05f951","affectsGlobalScope":true},{"version":"6c51b5dd26a2c31dbf37f00cfc32b2aa6a92e19c995aefb5b97a3a64f1ac99de","affectsGlobalScope":true},{"version":"6e7997ef61de3132e4d4b2250e75343f487903ddf5370e7ce33cf1b9db9a63ed","affectsGlobalScope":true},{"version":"2ad234885a4240522efccd77de6c7d99eecf9b4de0914adb9a35c0c22433f993","affectsGlobalScope":true},{"version":"5e5e095c4470c8bab227dbbc61374878ecead104c74ab9960d3adcccfee23205","affectsGlobalScope":true},{"version":"09aa50414b80c023553090e2f53827f007a301bc34b0495bfb2c3c08ab9ad1eb","affectsGlobalScope":true},{"version":"d7f680a43f8cd12a6b6122c07c54ba40952b0c8aa140dcfcf32eb9e6cb028596","affectsGlobalScope":true},{"version":"3787b83e297de7c315d55d4a7c546ae28e5f6c0a361b7a1dcec1f1f50a54ef11","affectsGlobalScope":true},{"version":"e7e8e1d368290e9295ef18ca23f405cf40d5456fa9f20db6373a61ca45f75f40","affectsGlobalScope":true},{"version":"faf0221ae0465363c842ce6aa8a0cbda5d9296940a8e26c86e04cc4081eea21e","affectsGlobalScope":true},{"version":"06393d13ea207a1bfe08ec8d7be562549c5e2da8983f2ee074e00002629d1871","affectsGlobalScope":true},{"version":"2768ef564cfc0689a1b76106c421a2909bdff0acbe87da010785adab80efdd5c","affectsGlobalScope":true},{"version":"b248e32ca52e8f5571390a4142558ae4f203ae2f94d5bac38a3084d529ef4e58","affectsGlobalScope":true},{"version":"52d1bb7ab7a3306fd0375c8bff560feed26ed676a5b0457fa8027b563aecb9a4","affectsGlobalScope":true},"70bbfaec021ac4a0c805374225b55d70887f987df8b8dd7711d79464bb7b4385","869089d60b67219f63e6aca810284c89bae1b384b5cbc7ce64e53d82ad223ed5",{"version":"18338b6a4b920ec7d49b4ffafcbf0fa8a86b4bfd432966efd722dab611157cf4","affectsGlobalScope":true},"62a0875a0397b35a2364f1d401c0ce17975dfa4d47bf6844de858ae04da349f9","ee7491d0318d1fafcba97d5b72b450eb52671570f7a4ecd9e8898d40eaae9472","e3e7d217d89b380c1f34395eadc9289542851b0f0a64007dfe1fb7cf7423d24e","fd79909e93b4d50fd0ed9f3d39ddf8ba0653290bac25c295aac49f6befbd081b","345a9cc2945406f53051cd0e9b51f82e1e53929848eab046fdda91ee8aa7da31","9debe2de883da37a914e5e784a7be54c201b8f1d783822ad6f443ff409a5ea21","dee5d5c5440cda1f3668f11809a5503c30db0476ad117dd450f7ba5a45300e8f","f5e396c1424c391078c866d6f84afe0b4d2f7f85a160b9c756cd63b5b1775d93","5caa6f4fff16066d377d4e254f6c34c16540da3809cd66cd626a303bc33c419f","730d055528bdf12c8524870bb33d237991be9084c57634e56e5d8075f6605e02","75b22c74010ba649de1a1676a4c4b8b5bb4294fecd05089e2094429b16d7840c","e475453e7140e95542332943d3052fe4c7430ad1efce42b3e9157f1fee8cbc5f","ebfdf904255ce746c9d30117c2edef355fb19bf7650478d2405f39f0e4f302e6","f3f63b48addb8e2ea9d20bb671c3c306413b3daa39996d0ae52f63d8e32158e1","a50599c08934a62f11657bdbe0dc929ab66da1b1f09974408fd9a33ec1bb8060","5a20e7d6c630b91be15e9b837853173829d00273197481dc8d3e94df61105a71","8d478048d71cc16f806d4b71b252ecb67c7444ccf4f4b09b29a312712184f859","b4000a0a525fa921e896cbdb32ae802c9684f0fd371b5fc69e7310f7918cc2c3","9df4662ca3dbc2522bc115833ee04faa1afbb4e249a85ef4a0a09c621346bd08","b25d9065cf1c1f537a140bbc508e953ed2262f77134574c432d206ff36f4bdbf","1b103313097041aa9cd705a682c652f08613cb5cf8663321061c0902f845e81c","68ccec8662818911d8a12b8ed028bc5729fb4f1d34793c4701265ba60bc73cf4","5f85b8b79dc4d36af672c035b2beb71545de63a5d60bccbeee64c260941672ab","affb9dc7079c3a3522e046c5dc1325950a843b1ebd7dc0f0386aeb2397b9f0db","40fe4b689225816b31fe5794c0fbf3534568819709e40295ead998a2bc1ab237","f65b5e33b9ad545a1eebbd6afe857314725ad42aaf069913e33f928ab3e4990a","fb6f2a87beb7fb1f4c2b762d0c76a9459fc91f557231569b0ee21399e22aa13d","31c858dc85996fac4b7fa944e1016d5c72f514930a72357ab5001097bf6511c7","3de30a871b3340be8b679c52aa12f90dd1c8c60874517be58968fdbcc4d79445","6fd985bd31eaf77542625306fb0404d32bff978990f0a06428e5f0b9a3b58109","34693fb4a5e771e11668219221344dd1bd7d8b77ed005a1c1d965fb559be8406","7394959e5a741b185456e1ef5d64599c36c60a323207450991e7a42e08911419",{"version":"e44ea2d6b7b853f6c81482416db43dafc11944561b810e469ae423085511ce7e","affectsGlobalScope":true},"f51b4042a3ac86f1f707500a9768f88d0b0c1fc3f3e45a73333283dea720cdc6",{"version":"a7289d79eb84a59d2475b4d0136b4404be3cfdd17c3ea46b9194add1d645df01","affectsGlobalScope":true},"0bb26fa2a90ee890eed57ee812c71fa84d3d07850163ec4a204de86412cc57c1","132ca47da601c60141dd6f10bd08c70d0620177e5638439df2464ec3945b6d98",{"version":"55d2bbae076fed7269c3e16faeb32f988f558427b7a1c3bf04aa7551ab86ae90","affectsGlobalScope":true},"a40826e8476694e90da94aa008283a7de50d1dafd37beada623863f1901cb7fb","cf83847c9264dcd592b6c89c1542925b899b277228687f3638614e3fa784cf76","3a41ebe7f089d50f447466b35b6cabb8b584c0994fc9809d0cd0a4ebc41e1239","7693b90b3075deaccafd5efb467bf9f2b747a3075be888652ef73e64396d8628","0c42d6cba77d9ad1cf45256ccb8489aa502fe2dbee1ec9048a29d49f5d532e73","2cf89c17245db65d175d4ef699cd68187516f9b3ae5c572fc0b9ad60f35dc223","5f20d20b7607174caf1a6da9141aeb9f2142159ae2410ca30c7a0fccd1d19c99",{"version":"a34d65f61ec5aac5b53502c8b0bd4e00d217bccb95bf94d449e2571baa11fb8c","affectsGlobalScope":true},"8d42e5af5fb0a96a77e135ce84cc60636c9bad39d9dba043a4efe9d1bdeb3cc3","56fcc451e9065eb121c9cc4c1b9994a816306f3b0b3b1fce7ad59f0ac97a9999","8a6f12b74d3e6c4f5e1b918cb8e64ae16bc6756cf0d48bcc28a28e1bf26ca0cd","c3759b5bc5cc40f5988d86a497741a80fa91258629ae50a2b3735e774cd377cc","bf268a0aea37ad4ae3b7a9b58559190b6fc01ea16a31e35cd05817a0a60f895a","45dd82fb5aea9b12b2a90b427b28f3a014e8b2ee9b74087a5ab882841cb5fbc5",{"version":"d7dad6db394a3d9f7b49755e4b610fbf8ed6eb0c9810ae5f1a119f6b5d76de45","affectsGlobalScope":true},"48b2f9302651eb31acd5be69bb4e6b35797a7fcd6b77391d10a4ccadf7dc3609","0c8c917ef15498c827bd494a0ef365e9f76deb211f8acbb86932e20489310788","dd67d2b5e4e8a182a38de8e69fb736945eaa4588e0909c14e01a14bd3cc1fd1e",{"version":"9cdc2c6144b03822c9842505d09945bcf813b86827fdb260dd7586b63abc19bf","affectsGlobalScope":true},{"version":"2923dee3c897f03e91b54a210cdbefea7290562f0ac4b948667d4c9ee844b79e","affectsGlobalScope":true},"79169698d09a2be54b14f3bcad2575b414bf3525063fde0a1e4fcd5d6efd380e","051d939bcf77caa3cef3282708ab3a6fdfb741a7366e1d74a9e7603b67417ec3","0be79b3ff0f16b6c2f9bc8c4cc7097ea417d8d67f8267f7e1eec8e32b548c2ff","1c61ffa3a71b77363b30d19832c269ef62fba787f5610cac7254728d3b69ab2e","a234d62ae81d012ebf23898a45672edf3e5c93ecf5a438a42b96c08dd68cde43","269929a24b2816343a178008ac9ae9248304d92a8ba8e233055e0ed6dbe6ef71","09ed02a725db002693236b6dfc49b2c6eb5557be1421d7fbe4f07cfe38211d92","09d801ff4a303d4976d4b9cb94af3a9097c4a70345e662d176975872d2998e51","c8558b01389b5f7610ac293aa612ccea2ae64d83af43b49f8142f190be1f414c","c40fdf7b2e18df49ce0568e37f0292c12807a0748be79e272745e7216bed2606",{"version":"b10b426c56e220b5093bf8a2446ee47af47263b7b1a03f4b18e42326b231b111","affectsGlobalScope":true},"4e228e78c1e9b0a75c70588d59288f63a6258e8b1fe4a67b0c53fe03461421d9","b4635ef36bee17e1304337d591c3b6b461ecdbc1876d0effbe6a581e62201fe5","205d50c24359ead003dc537b9b65d2a64208dfdffe368f403cf9e0357831db9e","1265fddcd0c68be9d2a3b29805d0280484c961264dd95e0b675f7bd91f777e78",{"version":"e4507242542bd499238f693d88b2d32e22177cc508854625f87bcc9bc3fa1256","affectsGlobalScope":true},{"version":"d942354e4966a98d3a92d1b1af0b4ac06f33af3f88116743e2c304c027ca26ef","affectsGlobalScope":true},"39f0808e5be3cb38674726c21fe2eb453c55e48a901679b4ce30fef85549b892","6afd66a7432ef100027ea110449e874196381e019e30eda7e7d8ca390366b7a8","befb8a9a78ac99d8fbc3ed392810489a7b90760c7a58934e8f1c8538f581cff3","e670bdf01540d35c170fae68edfd2f288eff909936780c379d6a9103b787b22c","867f95abf1df444aab146b19847391fc2f922a55f6a970a27ed8226766cee29f",{"version":"ab9b9a36e5284fd8d3bf2f7d5fcbc60052f25f27e4d20954782099282c60d23e","affectsGlobalScope":true},"88003d9ab15507806f41b120be6d407c1afe566c2f6689ebe3a034dd5ec0c8dc","175323e2a79a6076e0bada8a390d535a3ea817158bf1b1f46e31efca9028a0a2","7a10053aadc19335532a4d02756db4865974fd69bea5439ddcc5bfdf062d9476","4967529644e391115ca5592184d4b63980569adf60ee685f968fd59ab1557188","aed9e712a9b168345362e8f3a949f16c99ca1e05d21328f05735dfdbb24414ef","b04fe6922ed3db93afdbd49cdda8576aa75f744592fceea96fb0d5f32158c4f5","ed8d6c8de90fc2a4faaebc28e91f2469928738efd5208fb75ade0fa607e892b7","d7c52b198d680fe65b1a8d1b001f0173ffa2536ca2e7082431d726ce1f6714cd","c07f251e1c4e415a838e5498380b55cfea94f3513229de292d2aa85ae52fc3e9","0ed401424892d6bf294a5374efe512d6951b54a71e5dd0290c55b6d0d915f6f7","b945be6da6a3616ef3a250bfe223362b1c7c6872e775b0c4d82a1bf7a28ff902","beea49237dd7c7110fabf3c7509919c9cb9da841d847c53cac162dc3479e2f87","0f45f8a529c450d8f394106cc622bff79e44a1716e1ac9c3cc68b43f7ecf65ee","c624ce90b04c27ce4f318ba6330d39bde3d4e306f0f497ce78d4bda5ab8e22ca","9b8253aa5cb2c82d505f72afdbf96e83b15cc6b9a6f4fadbbbab46210d5f1977","86a8f52e4b1ac49155e889376bcfa8528a634c90c27fec65aa0e949f77b740c5","aab5dd41c1e2316cc0b42a7dd15684f8582d5a1d16c0516276a2a8a7d0fecd9c","59948226626ee210045296ba1fc6cb0fe748d1ff613204e08e7157ab6862dee7","ec3e54d8b713c170fdc8110a7e4a6a97513a7ab6b05ac9e1100cb064d2bb7349","43beb30ecb39a603fde4376554887310b0699f25f7f39c5c91e3147b51bb3a26","666b77d7f06f49da114b090a399abbfa66d5b6c01a3fd9dc4f063a52ace28507","31997714a93fbc570f52d47d6a8ebfb021a34a68ea9ba58bbb69cdec9565657e","6032e4262822160128e644de3fc4410bcd7517c2f137525fd2623d2bb23cb0d3","8bd5c9b1016629c144fd228983395b9dbf0676a576716bc3d316cab612c33cd5","2ed90bd3925b23aed8f859ffd0e885250be0424ca2b57e9866dabef152e1d6b7","93f6bd17d92dab9db7897e1430a5aeaa03bcf51623156213d8397710367a76ce","3f62b770a42e8c47c7008726f95aa383e69d97e85e680d237b99fcb0ee601dd8","5b84cfe78028c35c3bb89c042f18bf08d09da11e82d275c378ae4d07d8477e6c","980d21b0081cbf81774083b1e3a46f4bbdcd2b68858df0f66d7fad9c82bc34bc","6a9c5127096b35264eb7cd21b2417bfc1d42cceca9ba4ce2bb0c3410b7816042","93b7325b49dfbf613d940ed0e471216657b2d77459dac34f1b5b1678f08f884c","b17f3bb7d8333479c7e45e5f3d876761b9bca58f97594eca3f6a944fd825e632","3c1f1236cce6d6e0c4e2c1b4371e6f72d7c14842ecd76a98ed0748ee5730c8f3","6d7f58d5ea72d7834946fd7104a734dc7d40661be8b2e1eaced1ddce3268ebaf","4c26222991e6c97d5a8f541d4f2c67585eda9e8b33cf9f52931b098045236e88","3140d587067e55ce4028275cf71b40a3fd431863ad148efc3106af84a0794cf9","47383b45796d525a4039cd22d2840ac55a1ff03a43d027f7f867ba7314a9cf53","6548773b3abbc18de29176c2141f766d4e437e40596ee480447abf83575445ad","6ddd27af0436ce59dd4c1896e2bfdb2bdb2529847d078b83ce67a144dff05491","816264799aef3fd5a09a3b6c25217d5ec26a9dfc7465eac7d6073bcdc7d88f3f","4df0891b133884cd9ed752d31c7d0ec0a09234e9ed5394abffd3c660761598db","b603b62d3dcd31ef757dc7339b4fa8acdbca318b0fb9ac485f9a1351955615f9","e642bd47b75ad6b53cbf0dfd7ddfa0f120bd10193f0c58ec37d87b59bf604aca","be90b24d2ee6f875ce3aaa482e7c41a54278856b03d04212681c4032df62baf9","78f5ff400b3cb37e7b90eef1ff311253ed31c8cb66505e9828fad099bffde021","372c47090e1131305d163469a895ff2938f33fa73aad988df31cd31743f9efb6","71c67dc6987bdbd5599353f90009ff825dd7db0450ef9a0aee5bb0c574d18512","6f12403b5eca6ae7ca8e3efe3eeb9c683b06ce3e3844ccfd04098d83cd7e4957","282c535df88175d64d9df4550d2fd1176fd940c1c6822f1e7584003237f179d3","c3a4752cf103e4c6034d5bd449c8f9d5e7b352d22a5f8f9a41a8efb11646f9c2","11a9e38611ac3c77c74240c58b6bd64a0032128b29354e999650f1de1e034b1c","4ed103ca6fff9cb244f7c4b86d1eb28ce8069c32db720784329946731badb5bb","d738f282842970e058672663311c6875482ee36607c88b98ffb6604fba99cb2a","ec859cd8226aa623e41bbb47c249a55ee16dc1b8647359585244d57d3a5ed0c7","8891c6e959d253a66434ff5dc9ae46058fb3493e84b4ca39f710ef2d350656b1","c4463cf02535444dcbc3e67ecd29f1972490f74e49957d6fd4282a1013796ba6","0cb0a957ff02de0b25fd0f3f37130ca7f22d1e0dea256569c714c1f73c6791f8","2f5075dc512d51786b1ba3b1696565641dfaae3ac854f5f13d61fa12ef81a47e","ca3353cc82b1981f0d25d71d7432d583a6ef882ccdea82d65fbe49af37be51cb","50679a8e27aacf72f8c40bcab15d7ef5e83494089b4726b83eec4554344d5cdc","45351e0d51780b6f4088277a4457b9879506ee2720a887de232df0f1efcb33d8","5d697a4b315cc5bb3042ae869abffd10c3b0d7b182cda0e4c45d8819937e5796","7c1b05262a4623e5d2a5832433582e0d6b453a3db8aa799b98f38d105812296f","6ee58aa536dabb19b09bc036f1abe83feb51e13d63b23d30b2d0631a2de99b8f","8aceb205dcc6f814ad99635baf1e40b6e01d06d3fe27b72fd766c6d0b8c0c600","c6dc7623255210d258b93c412fef322322ee4d7e3323ea87930decd98585fa5c","c1e87ae9c6982a1628be91d9f3a52ec5a73ed1a6d42e4e8119bf96c453b14cc0","161a4d1342b99b095a9531e65ba773ab33df0d906d7ae9f4f39180320fe23237","722cf9592e0d42cb903e40aa725f3e8e7cde91271f6be8c318bfbd7e337ff886","c972ef44deca1fa8fab465915ffa00f82e126aacf3dfc8979c03b1b066ce5bb6","ac9b69620b356f5bcfbc17d6a2a0591354eade1c5febb05cb1079b30ea0094c6","8e7adb22c0adecf7464861fc58ae3fc617b41ffbd70c97aa8493dc0966a82273","755f3cd1d9c1b564cff090e3b0e29200ae55690a91b87cb9e7a64c2dbeb314d3","d6bb7e0a6877b7856c183bff13d09dd9ae599ea43c6f6b33d3d5f72a830ed460","f1b51ae93c762d7c43f559933cd4842dd870367e8d92e90704ffa685dd5b29a3","3f450762fd7c34ed545e738abccb0af6a703572a10521643cf8fc88e3724c99c","fcc8beef29f39f09b1d9c9f99c42f9fed605ab1c28d2a630185f732b9ba53763","c4ee21daf8875c018b9335d42711cca5607ad6d44f5970b575c7daca2ac0ff02","6213b8f686f56beab22b59a0f468590fd3a4c5fa931236a017efeca91d7c9584","c451cec9a588b1f105a5ea2c6063d4fca112b9d70105cacdadda0e1ef67e9379","cb047832dc68f5a2c41c62c5e95ddcacbae3a8b034d40cd15319a8cb7f25104a","980336ccdfc3c08f3c3b201aa6662e6016e20f15847f8465b68f3e8e67b4665c","5a3493939995f46ff3d9073cd534fb8961c3bf4e08c71db27066ff03d906dea8","bb5a2ac327605ebebf831c469b05bd34a33a6a46ee8c1edd9f3310aad32cf6a1","bf5d041f2440b4a9391e2b5eb3b8d94cbf1e3b8ff4703b6539d4e65e758c8f37","8516469eb90e723b0eb03df1be098f7e6a4709f6f48fd4532868d20a0a934f6e","d60e9ab369a72d234aac49adbe2900d8ef1408a6ea4db552cf2a48c9d8d6a1bc","0ebb4698803f01e2e7df6acce572fff068f4a20c47221721dafd70a27e372831","a12eaa942232703a8a8477a2f240ad5a2c26c595012ea8f128224e77984099c4","4070c2f1c3434fcf84886e04d30d82cd650ee443e53b82b404b144175cf8741e","2cea9689efa8591732096235abe7f084fc29c92badd5b0897a5e876b77e71887","4ed4e504126014fee13aaef5e3fc140f2ff7031ff3a8b5386717905820ea2d09","8129a34006218a6f3cdc81bbd438d5429eb18b08b4338a26977ac3b4df129d75","30d2170e1a718b5035611af55e3618b4ba8f42f0749bb52ee593da6082c4e2ce","d48e1bcdf505009c479e9b94fef46c7ab2f1dc0d8c64ddec667d6fe558ca5317","a3b8b6be7620897d1e481e8650c980a210a138fceb6e710eaf95fd9dd0dfe94a","12c89d0e32758c120a569045f21cf5b77244f86792611ced8de7f86b37e77781","14bd47270e654c8eb3b1489fa8c095912ee62a0a29bb92743393203722347c53","c32bd7ed9bd99aaa7e8d692933f6b9c731bfd4ec75abb3cb40fd614682269163","d15460aec5149378f542463bb6073f5f6e058353e4b82bda2d7b9201ecdce26a","92cb686a9ca5eb5dd7d5d8d43a3707194c1e91ea07a027b3bcb60b6011b24632","8e609bb71c20b858c77f0e9f90bb1319db8477b13f9f965f1a1e18524bf50881","25139d6a726e0e19d9fc4fa3197367b4a82ec34a08a5ecf23963e142c202c0f3","e3328bffc8eab74665a4fe9c59d6f12f4c8570c3d858497e241eb37efe17dfcf","29389551e426a46421134b55182d6fcf5b143670998bf81db2619c1228235392","c18f7e16982695bdd04e3e183a327d116185f77f1a37b9b2e849d7d93269cd74","2cfb37011989c21dc70b91d521a2d5a4e0f18507f5f536b5dfe504edb15916e8","bb5e02df7aaec7a4ea642639a9963b24b8d9fd6798351f07d8c58616942fbcbf","299a899cb4d061f5d83843ec453e936e9659b2c435746823f90c40eddaef4745","d5610c0fd12870f644b0f42c1bcc4fa2295ac3e3ca01916bdb42c3bdc4c80c36","2c56a8e249b1f45dbdf973100cd37fe2ea68709573cf1fdf2e3052c593be68d8","3553da417ee7b07e388b13bd12a70a1c03e65a6132ba5427fe68f5b362373e6f","612358502042d351c227ba779fdcf6d875d827e424930e60297c533524e50668","d2b5be376ef162aa0c24a826e7dd2d77671a045c085e16d1c1276db4bdccbac7","c4138d8dcccedaff6621e009cf0a54a7bed2a5ad4c509a3513bccc4f417ef939","ad8747fe978dff3e80f4b12b48d37cc8dff11b61d04c035aefbc982ce21201ce","b154f789fd65298e1ba6cbba6944ea892d564c95f3d3700ed85baf8f80748473","c660265aedd7c5b236e2017e53095cb98da66200eb0e8d023b5bf713c36494e8","0efc36bf5c0daca6217fec7063359ccdab8c3a23bb405d25340fae22cf72d74f","5abff0c87d4f9c89715107042d4c73b68ef7a128759f451c8a0fc450cbaaf660","5a03308fbd1af441065149a84c692931bebc7e7735afc23be8684f4e10d3aa06","c787bf4f8f0abbf815cfbd348be41046f2b8f270be24fe7aa8a8fcdd2b7df8c2","e7a5191c663a3228f30104961d548b372e51c5936c01ffc8eddd262bb98d7d7c","43fdc9abe6f8640fda4cdc55a1ee5f666d3fce554277043df925c383137ddf69","f0b09665c9d52de465687fbd3cfb65111d3ffc59ae00c6f42654150f3db05518","72f8c078d06cff690e24ff2b0e118a9de2833dcebf7c53e762dcb505ddf36a68","b7d190f58039b13408eba5edd7fc3305fa1b8f10f3cd90087bf21fcba33a8565","f9b9d0950fdfb90f57e3f045fe73dce7fa6e7921b37622fc12e64fcd90afbd0f","e61b36e7fde608f8bb4b9c973d81556553a715eaef42a181a16ddd7a28da4ac7","03b8389b222af729eae0fb3c33366dcbb1f5a0102ce319bf1d7d5ee987e59fd0","2bf6be7c04db280fdd9b786764f8650c23f9f4d533791cb25a11b25314b76a55","dbb5fc7edd36bfba95cc4dd564e4458276ced30eed18bc05fbda948b3fda8686","c2b556c7cff0dabce2e31cb373ac61c14d8ebc35f1086dff30b39e9ec5357d0d","f958af01131076e8af55d28c4835a51063226ab488ca8738fdee38aeef7d0d33","9f3797b01e3d83d4e4b875699ae984f380ca86aa0a0c9df43ac5bba1cb1f8b7b","752b15ad1b34887adeaa838fc55f5d4ca399026afd266d4ed4db0e3db02eae4e","778331eaea1093451e50be9844bd2b6937c3bb81b0b1ee700624c9774ecfcf2b","0ca0dfc9f657d0822eca9530c7870b22a1d2a5fc48182bdd4d0e6e88e4ad9c35","5c746f034288e6842dd1589b169dcfcc16c5ce5abbd928889ab67aea4fe0b501","92ce6dbbcc135cffd09a58e19fef34bf351391bec92c40d849e4e9997d475769","99e77d092fed72b6b8578d00c7af004f76e98b30ba99f1947535eb4c04a51676","fcc8beef29f39f09b1d9c9f99c42f9fed605ab1c28d2a630185f732b9ba53763","b5ef52a9f9083724decc5d060f0b34e3a480deed71c32d55ca16c214eb4cc928","5c9cadb9446d1868615558eda1fbf64df5b4fae5ef051d0d7ead6fd28544e3bd","ed7f49215f59f3f514efd4e6ffbdd66cc87d7ce03177e98d17416f34f32cc52c","f100912a3785eed4a3d29c12f5910b101af9353454de5ddba9b4d43456c56dd1","f0ae57a70e4297198722b8e777c7f738a797c4ee1485ab0afa6601f4a7160933","98034cd285344125f7165a3bb68246d38ab35fabe7f6d6a7c8f80407d31f548d","0ca0dfc9f657d0822eca9530c7870b22a1d2a5fc48182bdd4d0e6e88e4ad9c35","06b4a23064991251512df4edc12341d5bc69a17b942da18372312d383c90eee7","0f898802705f9a534b537f1be6c57265080e0abd6993d935554c255e6d56cc1a","745efa7b6e27b7216cccede166a822b56acc41b10a8090966c8cf2c96239cb83","6ab2a6257ae7bb05559841100c786c845fe465a90be7b904db9096c2fb14696b","2a5660d9beb6154f5840c444aa6f178c0c96e684275a869ec9a662b5ad9bd662","c9f26fa63b17f3581e7cbcd68e6cf66e6f3e59feb91f6b54757d41355ddacbe5","bc8328d870b710ab827730fe134f39d7d0589a72e7a0c5dea585296d0183f369","d5c19655468e29f60c871b21e73af8ebc653f736e7123ade916f22c4a5f80ce5","55bdc187765b1f5006234e7bf15f911689a5119dcd02be11a798ecaf59d2b3d7","24b3bc595939a193945e81f7e34f4bcfc7efbd133e249878f82aae47a7c89694","85052c71d72b9b017c88179f57a464d66e22619c7acd7d83b117a79cf1608979","eaca2afa1bea4de1d06e0a388415bfdc142f784d709011964ac31aa65948d578","210370b6d8a73c7ebf9c15e12c1a690dd0e0befd5e355c9aaccbb61045ee21f2","f5d7a36ff056cc314b0f61c89a03c4c36a24183b246e61d958e75e86521304cd","a3a497437625850c31a84c043b128740dd6d9991fa591e1809aa7b65f9056b9f","6c951235cbf3c324a20c0e2dfdd013d7b226b0c2a72dbd84925682a8d7199237","9defb9601d423af5b1ba2c0a5bf0a0290b7bc8eb1b782442ccab3a501c38c34a","3a971ea3e36685b96f24fbd53a94ad8dc061711b84e51fde4cf201f7041e618d","9b6c162d20e2ad4abdcff61a24082564ac59e63092220618162aef6e440c9228","b0874729266d9f7fafb9ff1127fcbad2cf7972b5dcc1fdc104be79266a708bc2","53f91718970aebc7f62bf345d5cc142d05fea4a898dc2077d3fa2d9a307c7c23","a666f7afc7c92e446555b395a4a51b56bfb4eea6d94c4d74df4acda372c3eafb",{"version":"8839183ef160bc38dd808df85cf560ed61a5b0145b6bdecbfa8b95b7b647e06e","affectsGlobalScope":true},"5e379df3d61561c2ed7789b5995b9ba2143bbba21a905e2381e16efe7d1fa424","f07a137bbe2de7a122c37bfea00e761975fb264c49f18003d398d71b3fb35a5f","1358eeee3ec0967677540238b34a4b74750430b829314926cfe447478bd55fcf","4f69796a7c13a8ce4cab08a0630661c96c1ebc4af169b2e85fae95679a0df30b","2b029331136db8dfa9704ea4418944303aa9adcff5d265f0fe96b2b13cda08e9","362968c41d11b6ceb3b98bff924730e5e12e16eb589c273e05bb5ca7394151d6","496aaa1fda9fc368d8acac5434f53e10a662798157c56fc000360264fa305d63","918c642c9f073c0c873d3812c68868505f567b6b1128a1170c4ba74b5fd18dd4","63c271a745f628ffd4bd7ad0a63b021c362c9bd6bf8b18441a7162892395a214","a867ba47f71fe3993cef54246893ff8f01411e12e411d8cf1bd038a448b36404","9f9e5bae412fa5909fae636d6733aee27a108cc2ed5b13980611016336774d3c","662fe197bba64bd3f17ee118058cd2d0d2dbe33d7c0c865fd6365d90bfc44e1e","030519c351f800551cac2658038804969ca4584d2c0175a710602ac234ca1340","0278a6939ca83cd040b08ff8c5fc7838b6693ddc52f22526bf158e6b10e0246c","c2d6206e5ba4fd3063b01218c2b3b997afc1cfbeb49fcee991fa8595842ce53d","db2caa413bed06ad8f48a88a59a3eb2a195d6f150ba5579d3308ec9aac326ad6","2f594c996095bc714b08169b7a7e461ca3e2e6c290517d54e565de244d2443da","9df6ec68878d65bc690ea3a33ce3ef5aa8254c36bc5f8346c0c2fd1f3b88a35c","a4fad04c4acc8a4b195cbbccef4c55019104753d547d5c94441643ccc89108a0","0244c23ea642361f7c192c1f0cfff9c12cfa5f51f9b155edd5c0a89fef308d34","852b3fafcc4daad2a9150dd97e959c5b818c2b34d7a594d001f5c088aa3a8a6b","e5655d0da32cb100d93cb8f9754aa7cded45ba9f981d0b3467783ff3dc35a54e","d2b89a19ab8ed5780ec668e4439ac11f12241a9b9a32470b3c7e84ea64cfb842","8d419a77d65f91a5788ff760c1773d68fbdd194f5e63ff877a5e9c879d8a6a9c","334e40b3530b0d92518444b2a0b2608b7988c7132febc93e04ca9c15d0e8a058","9b6aaeafd7d5c93f3eacc9ef727fd64dfd75a63274e5137f6ce182eee60cca71","6bb747ac019210ef62125c2f0f0f4129010c765e556f4ce072aa0fadc86542d2","99e1bb2aca37fd9d6b86d517896e05eba415987dd84610a2789514c0d93502f4","322d531a629f96c4d2b4d7864bb77fe2e938fc881c5eb582bdb3b192c823ec6e","65c506882b16993f4870c2d73fb48b6d34b7d91d73acc6cacc3307e99bec42bf","9aff8604f50c9ea7d547330c1d168a6eb3d53d65a1600701c4741241571b9e13","61103d02997ef119fa02e32e092658523c4fe1232643e38c1f505015c4cbd3a3","49607b9a683dfd00cb0783ecabef2e8d284491c431176791e0503193a14ad283","874087eec1d457f6e3baf5ac46c42ea200e55040b394fac667aa3a64c49f5f6c","6e8a5b04a18abb192abc89d7219b9c6f633cb3136777ec808673a65f111ca749","6610b9f45f1f71d2b1fb67df49cbcabe3f9e668a1ccb7d8328a51407b259ffb3","f13697041a3403b9f3ea6442d9de0c2154d610fbee9e2d44148cc84470389a9c","8952dd3e4ad7e445743358eb0630e70dc6bdc3c06598a0fd4bf360e959a77c55","a22a9669b2d3c24bb7ccf110e1bc5c980dfcfea9f8ac4719382223843e8a032b","e6f6440893f51adcf17b8498224004a65448828e1d95f2a06244a34a7525ccae","193f3eeb12d0c70404fddd0d6c6d395a6721320284d0d4d39e0538e47ac6931e","ab408226026bb8f267f4b7578d9c853db182cd1a4e4a05cdbc4cc36103075142","a7d992c4e10ca67ded5ea1bd4b974a87bc5395b2f51ac038e89c09aa2c9b1ddc","a85b317beb9f4b26f5c25fdaf03d925f9545fadb3679d1366324e9212b416b96","e5423640cf93ef900af69ac6b4efdbe339b0b332d15ed5f0ac15209c5fd86b50","eaec27135176a532508108c395b02e36658b861398d67b071790a0cddd5f595f","a4a3de26bc39d380e4021163f89f4b2fbf82f2a712b010efac1698bfd8c288ce","21b3d5e502c3c1eed625d13559db2a8df2ccd4f9e15185b158d5de392153db2d","2ba6ea7729eb2976f3397e6c9f381796fbc458fc01b076c357210ec2cbbc5b99","417692489d8e511510cf1268f89374466d7ef8d9edb085adbacc7756ffceed73","963a49f6949886df3d3d3dffef6ac3dab5f33704b918edb519ea3c063ba8eb35","7bd08ed4a983c57145375265be7d27b8ee27adf462c10c3d328a993ca89d9e19","970b722b55e730c9a4f78633f83c7c7769920293e2dfd45a58452bfe3486c63e","6e795e6270d39e918c7a0e62ac73793cda06fcf4b3692ee46583e15f5bf57ab8","3735b57d483d444664bea49fdb3884a1768112f72755233ae6cdbdc2e27de1d4","5c09195ef359ffa9c6bbdb4fefb101d87ede4b9e9c28213faf5b45d102e4c609","80b4d93a4dcc90a12f6f4bb7c6851a8182ae29e556716d0d80b5c012a5ef554a","2556ef9d1820e0b6bbca6dd65a50ea64f525c4d8247ab50dff44c3f0d14a5643","cbd1c836db190d6e3add07165afc228f04e1f6170e1fe3aa5e6fc24a7e9573a3","9b13881feb958237232586d888a10a39d47cdffe3ee34688ed41888fa7baad94","122fe82cf5af80f0b26832b258b537b7dfe3ec28449c301b259ab10204b50d45","747e6326a724bc54f799a466a5b5c4978a601a04a063a5bdabe150af2f25b9e2","b57e22e53b56cca7a57bfcfb234aa6a66f9b9e4c07159d7388f94f17a3eaee2c","e47709ec4d1618ef429648cd8ef967aef2005526b34fcbfac33037add347dc71","b81abb3e47fbbb3af41fa75bada89bbcfa4b0feed9a0d6d4b19ed1ce1033b53c","15b330546e9784461058e5fd6e2346bf272140fa6f0cda34e193ae501d8b17b1","4d8ce72fd080bf9a46bdcc274bcbacccedd66d84e203966b197ac25a96932183","73327e6ae34e3f6591877fb75b451cf620cbbd76ee2b678213a9f793633cd0d3","3f1ba2f69944fa346789db7f60d53c9bec00032de0d797967978dea42e77b941","3f5df31539fee4816b97d4e45b4344fbdaf3ca59f6df941f8d780ee441e92cc1","3d6ba50fab14d650fc77799e91bf386a8da1684936fd5bf2ec9b1b2c100144ec","6a954c62ded10a4ddb99aba785de8a2edfe97db9415d50f72b09a7e0ec9eb343","c7a2d32f7fd176fd5bd8f14c758bf2d8e67d845274b43b352b65645fae2ebc27",{"version":"cd756ccdabf433dd02b84d755383e489f14b3c1aede0477783aa04830fd5d695","affectsGlobalScope":true},"9cbdff04326da794ba008c0fc977ab062d1fe3fa2e9759654c72ffbe54b64a7c","e9eff6fb1d9998d06dbd20d8a7d8e5b083887a7bf03f8a7c00cdc494a8748b47","150855f967a6490161d5aeed4cc4adf31fcb8f5dbe54b75799c12b8687fc9cc2","cf08b7139adc21b94204e3d4b3daf9946e3462a9e3fdc3e94c87e767e7936e20","235a8917cd7e9eecc6745761d8f82aa15a503ee5054335f2f30b2762bbf8c2e3","6b6392704ddb3f50e647dbbb716782bdd0cf8ea9cc134aae256a26223e632b47","8ca39cd27de19c42904b3aaa26bef6886389d59eadbb86960cc8c0a2e460043a","a8dce27dd03f36ced2d4bbe3f0a51b52d745f66a91b2e7008b284b3a111e64fd","a7362b94bce70cc24219e9365a9b1e8b15678ca86dd2ba98bf3c43daf8689b8c","bb487d201c9bc48a09387f34638b6d9b0961fba7c9de97fe49c70dffbd712699","66b52d3ff4793904e048e4dddd784b450f17ba8da42e0ab3951465b738292cd6","e29d76ef1183ac0edf94b4712b6e51730c447c7e773e75ceb44a720b0c9a9fd9","f778d58c18f0e0342297c146f494e0c453a2e40f7255cad461c952adedd7eb3b","c28258d89be3eca9d052a3689714f261722a47e2b22e891549ea7cd4e19f3b37","96f0d856b66d8af1242dea20c5eb182aaaa74be74b7fc6be91bcb5f6c16e405f","4749d39670f618849b640148c8164b52283b4a3be227f192a431fbf132d9d7c1","b682db93a241da3a145e40b75bff4e5f454c74bbb44af7cff2884847294f2ddb","53c7854f35e1d3fab9f0e95d7f7c70777a9f95e121d980269f17ae7d26b5fcce","960fccfbc730994718317411e9f75dac992f48d1645fbedb177f77bd4ee5eea4","2e28c01ab28f1c6d97e47def32e3df6a36c3848dd21520fff899b5c79b286659","ab42ad18cbdd1ffce21d707268fdbfc5f4255c3d6e76612aedf66e17d138ce79","d42c6e985bdb10a2aaa3dae14d9b0d8589e74a7c2f9475bf543b855bb3c010ba","be11d1fd9568724e5fc8f6801bc7f92408cb6dc726c58782b4ebcda150bbca64","5cd6db16600b1b35aeabc394266dd1205d1fa8e0e826efd36fbe3b085758bc14","78bc872ec551739e21c64416ff51a49bad02f4aac7e1355f69d2e21d23850ffc","72e7be5040a865e113cf78e17eba90499c44607a6a59d0d9b6f843369167523c","0d2acd3a3840418f280e10b2adc0154848f4a162ab6a6466cbf5d0210200a6f8","08417035838838db86f31bd576b1fe246be76c1507b8fc1f2eec744c0d0d125e","b78647f4fd09671f9e7502612cf5f0c072ab2ec917312810d36927fcdeeb5a7c","d6b58d955981bc1742501b792f1ab9f4cba0c4611f28dcf1c99376c1c33c9f9c","0cb9cfa126435d30332ff00441e0db904e55dccb5b1fa7220eaf024e7f425eeb","675e702f2032766a91eeadee64f51014c64688525da99dccd8178f0c599f13a8","458111fc89d11d2151277c822dfdc1a28fa5b6b2493cf942e37d4cd0a6ee5f22","19c816167e076e7c24f074389c6cf3ed87bdbb917d1ea439ca281f9d26db2439","187119ff4f9553676a884e296089e131e8cc01691c546273b1d0089c3533ce42","febf0b2de54781102b00f61653b21377390a048fbf5262718c91860d11ff34a6","98f9d826db9cd99d27a01a59ee5f22863df00ccf1aaf43e1d7db80ebf716f7c3","0aaef8cded245bf5036a7a40b65622dd6c4da71f7a35343112edbe112b348a1e","00baffbe8a2f2e4875367479489b5d43b5fc1429ecb4a4cc98cfc3009095f52a","dcd91d3b697cb650b95db5471189b99815af5db2a1cd28760f91e0b12ede8ed5","3c92b6dfd43cc1c2485d9eba5ff0b74a19bb8725b692773ef1d66dac48cda4bd","3cf0d343c2276842a5b617f22ba82af6322c7cfe8bb52238ffc0c491a3c21019","df996e25faa505f85aeb294d15ebe61b399cf1d1e49959cdfaf2cc0815c203f9",{"version":"f2eff8704452659641164876c1ef0df4174659ce7311b0665798ea3f556fa9ad","affectsGlobalScope":true},{"version":"27c33fb4f509b29317686c6ff123aba92074ff6c7bc4c36aaa5ce02e39aa5880","signature":"b3df1401040a165c0422c12ebb1f1b6804b6e474926e5cdc7a5883a56015ed5f"},"1fcb8b15db812281d69a3090d488903f9e93033004aef9d8889ca3ad0753a96f","bdf5a95eb0a2dd1d39805bdf51b46ba012bb9b92b2ddaae16219595bba7678a5","9f794a0e8550a03baff865a3961cc22afbd85bc4ba9672bdda036971928f85f4","66a697d1e4cdbf25cdce4644a8085a8563041fa8c7731d4d9f5e8f22e66ba72c","a0c8e17f4d1ea2704c62d7349bc3b8d9a12e3761b5960cb44144d3f0333b3fcb","3471c0df3d0391e1dffe6e8bf150294531b2b71a2afa5f2b86e52bf84a5db60a","5d4df4de055eddf3187094f938a640f8d96e4c551a47d6686596fdb6ba4c3014","8bc2cad630da1033c1fd8d7df2bffb18af0da6113bd086a8bbec04a2471a1e00","a1059d1bbc8ad46bfe668b8450e7e8002887c4ab987bdb96d6108d8023f8bb8f","5134885e9648e2c6745f8aa1c3e7f5ab3b3617258b3d81ca02de6655ede3d74e","4f1ae3f24125216cf07c5211a3f00d2bb4782d7cc76c0681603f8249f9232ff0","d3fb92a5640f83f7844d60b35317a0f95c27e3658a749d76d218c461ad091668","d1f8bfcd91b284657ef8187c55ace7db91a3c43e642c3f14e54364154932f7e4","f54c92bfcae54f360fe79514746efce4870e4ddabc064e95d406bba291e9f672","175fd7186fa6a70f9db9b270a04a503cae23cf01cb77e3905bac115c38424cf7","c993f7ed1b8e1023c1f2ee5b262dbc3b70b27475674e40a53a58591f9972dacc","c914014ab7c7001178663f29d31a495398234a41219af61f26d7e8e91b46af96","277afd6ab6ec72889e2988e0ddd7d138c1f512e68a1fa4e90eedfd71e2097a51","c0908f85f2b645d375127a3b53a17a65f782e17962d5c1eb68f08b1188acbf15","3fadac5d409cc2f27b1d2f4e7568600f02840205f301c9ae7a3068b46476438b","da6aae64ad559286830fd44c81e3d33303348f184af7db4fde8dd99ae9749407","3633f87c97d359cb55fa7bf0668fb2be8a23342951af6ec2d06e6d0cf7409371","cc3a5427d44fc77ff25e80b3edee4650a51f83de761faf5e633994ecf1ab1b44","b350eda75c6e47299b36002b31d5b220c405c21c365e708989829db013fadbb4","f421882756b6714834ae4687ab1aeadf344a1cc45437d2edffbac020ff3801c1","1d61d6ad832dabafbf63b86c5a79d704f2c8763ada9318e135b17a3cb2d09b32","e5cef5de3e5ad3436d414d20743231e284733b9cf4375dc79eff4fcca4282f99","e624419ba84e33e661e89a28083119ca41f6953dba09a4f82b660684087afe6d","942be430bd0feaced2e3e598273b17e50ea565ec9dac840b580b0b99e1a3cd5c","73350006cec5a0c6b71d53b0b0ddbfb82be96752a9c4e3c904c59e633bc9485e","a7df5c2e9594966c7e0d4a763b13ed5727506d892669df5f7bc9826f539c1d35","258cc5cd6891f6bcbaccefd953997038844e7f65d582cac987ffabf7181bcd4c","00a6db28fc4df6ddf10adbe630d9df620ec13af19039c1869653e60dafa739d2","649324d5abb5464aabe35d86cd0eef16562df811f0971481cee664afa5acbc88","930446bf32192f698b78f8ea4b309d8c2cfe02ab5ad78e4db907417405ebf5e7","5d3e07dbeabff37885262d9b4bd21c3185d95a09a268ab795f81135046a32bf4","7d309fbde13b5e30eff77c07a28b66451b0b50b83564d0cfa6a2a52c8b69aae6","f02da9dd36d7a9aa33c9b2e37ef1f54b0d9ad6a713bae372ae4b72890e40c168","f49652fe12e37331aa6c8a9d0825c55241bc8d3ad61897c3bdb722e0519ea290","1ed0bf138e87912d741e28333b58cbf814ae863783b3b404d2454cbabb9c5fc0","3452ee7d8ef0b1bbd47b2a56924a1dc3c79dc84a19d212e9dc496f92e4943aa0","fab58e600970e66547644a44bc9918e3223aa2cbd9e8763cec004b2cfb48827e",{"version":"5943b853fbb3d54c14caf7190a70811ece9a04fd48a0a9f9694078ad9be5cd03","signature":"71e2431e82504b51217a255925d20a8758ad61230024650112b6d925e613b131"},{"version":"6b93596d2864a9fa0fc64cccc47b1a90cf6921f021db19f4e045a397adcfde29","signature":"130b20a0080f4b10fd886d81bd73806ff8595ffbc2dcbac344f99002bca28340"},{"version":"e8eb22fdee8a04f350fe7073f75e25641104ed7508b4a9ec929bf53c34dd0bef","signature":"819cf3c1b7801c009781af338ef5986f2d6cc7afad4d038e9777b9f9fe8437df"},{"version":"a3dcfe57f16e3d01b7ca96290d7ca9ca2870b177a2d76a3673ce7017e181d031","signature":"88299bffcc7f4eee130d15c2af8935f051cf9c3a5c4e0b6f7f698a63077a4383"},"da04ea3f901991d8097ac63ef6fb5967726e3dc1924e2c8efef374b1db9487c6","96c42cfe5614d9f894078048dda1b53409774bd502d584ffa9bee3c1b39537fc","a49dd2c42f34a0f8fd8577340378112785f3a8fa44c5fe6522466421c68f66f2","7a3e0d544a45a2801f7b657fb931e5ceb749cac766560a4cde600c171b41079f","78edf86617005dfa5709c44024989d60398a21bbf865574680e0cdb29e93b88b","0dd44432ff360867ec9422c184e78973fec749dc96920c23aa02088a908cb0cd","06b1afe677e95808681e5260e9f567815e67c59d00eb5de7d21e4754581deb8c","58b3270f2e1111859e0f15c74d2a47b45471a6cda53bb61fadf2d17987ff4c0e","ff6139ad0ecc332393c72a42af66734c3104f775ceeb7af4533fd82df42dfa51","12597a7bb3fa105568418303af2376061d15f57f2d5f24059082043b358dee74","4c2291243804f0e8610c1f05f0d2a3c5a1497e34bf6314378a0857cd42472680","d2e012a1efa7115c2857284eb541e8b906c0d24c5918568e6dd77e2d6a9592f7","99d74aabcb821273945c9f8446f52b9fb27f666d7ee5b00b4814fc29ce72f307","3f1af437818017218c9a8afd6404d25ddb811482952a18c703acbf0889e5d5a4","f7478db71332be7f074506a83b8bd76d52569e022256c2088b27204f1b3b2f22","d4e4c606f38b8a083af300a9011d3bdf77dd63a5a98f05f1566dd84539df6562","e33dedae6123556e3052e6102b2bd64a3c99850b1eb21e27eaed328ccda6f611","391e793b760e7a3e504784021eab7b430a24a87821ad86ea1ae2da88fd2a413a","1356a2fbd07d5f9a5530f9658342bce4f0358f1620f0bba7a923f842ad8d0600","d2c0337f150e9d23259a20d6a6b1db9173f0171162adbd7c42b9a10d53b086b1","54586daaf9e77f8a26b27a4e3cb191f668c54abe9a402c2ce4be19c0b9d95207","95a276eeed4301374463a1725f4bd6a339a6e9dde5ba51910a17f65f8d0c2414","2094effba5caec56950d079ee0c08e175f38dd205d06a877e86cd4bf864fefa1","8c054d37f059c24bb3cc0f1a828009185ff690af19b5c68946074144f8c11904",{"version":"01edba9a90b7a79f2aa7099f7b66405a94d93fe9179e2de15728c1a775415769","signature":"1991a87fd9ce6a724003881138ca1320d26a5faffd436a5cf097d0c5ac8a47a9"},"53f6d74dbd78f08ed7b56f6b0a558b7f8d201852ebcde17e7a0be8816abafff2",{"version":"bcd1960109c8436b14c5fde77f5f06f3a1ee9989de9d202b69e29c0a6624ecfc","signature":"f1d217f36dbd97aaa1014006113535b447cce411dae240062350ffb9f8435b9e"},"14c94f7888c75007a94132f03caef0f6b58bcb136c2994213fd2d3b99f3d7f85","4695042a55a75a6c62dc57f2efe60ef3c7bbe19adedb5081f6e51dd664bbc3f7","b006ad8d854471e7a270bd8918508090961bdc1cfe77ed51f13f471fe682acac","6aa8a22514d2e55b728af76a05dfc44a31010e6149ba6b4c4aa9d8b6bfcb03cf","37a4a7a5aef4e6a9c652e636aefeef0df9a1cddc24d94dc00a32401a9c9cf8a6","deb2b8baebf3bb0d77453a950dc16dd3f51cbdc12efb69bf8bc4805fbf20fe7e","032108185be5a41a316b4a7872c74331bd574b13499f4b32ce7105ba1c12c339","bd05b91626fdf3e479751850b11e93c3d05ec9dc2afe6e0c1614dd34162aa970","b2ff62f5ded5dc3f30e89fd7d3bd1e5904085326e16ae71cec450b14bb0884e7","afbf3186ef8d68015006b1ed3bbaf54eece8908c27b146b0f7d522842f3210ac","09aea5c0044ff8161e00a9e874bfa5806652270d490dba2a914606f89351ef06","d42ca1c2dc79317b5fb8e14a7d85fc0addc9fe2b142355e34753d60ccc78007a","598b50b11b8daa1bee5f6c59c35ef8df93e05737ec541846634d79bdc60b8503","b40d2724b7cfa63ce888b2e6ebc269c9472109f65072ec9eddb97a83f4801897","2897ce01245d031ff94ec172a8537473ab88c56b139dfcf6d2f620b7b6d4a450","9bbe7d497d72552f0c13b88affff3b9c43dc16037e55ee342e9e7c11d15fc1c8","269867d10a8163319dd29262fcde46cdc275f60fc8750119fe71480474c2b66b","cf0c859d39a640beb86ecc33ec846c32d705f9982aa69e11009e23649934b95f","0e5e5794df0a788165de5a59e25ce055250360a36764e91b060cc1d05e9a9b59","04f00895ed87b76dcfeae85fd8389b10b363d86f08da4d5283f0be5dc42cbee4",{"version":"a254f5dc005eaffffb0afc0c42d168534fc959b2bde70b494afedfe20bfd7dc5","signature":"6a6747a61a1d968c53970b79f35641fba4a17005efc6d021240f3897ce2878fe"},{"version":"4e0094fc185fa5d4aeaacd5f525579bdfd8c2e10fc9ba2b349b312f329aa8b3c","signature":"3f1a08c5204101a5aee11207600d595a3e8cc24ee2b320e6c29edf198573e744"},{"version":"3af6e0f12e5a77347aafa0b38953f5909ac6c1ec9597ad26fd4e3def9dc43275","signature":"567f0f4dfb84be50ed306a03fee43efb0780d122d2b52170bbdb4e44874131f1"},{"version":"e9526437280f5cf11d114fc5df84f529ca142df90a320a56176e363ebed5c0b5","signature":"8ddb476321ecb63bfd236d0f4fd7f9b8965f1866dae46bd3168f559c302f4e2d"},{"version":"e8a9d476c45af9c0330983441deeb93c39e325ebb73b3385b7644630bbeacf6e","signature":"be5e1f61859b81be95fd171a61539d13e1e8b3bdfdea1a169b734d5c0862c408"},{"version":"2a0f41c5e876d5ffe17d4376660cbe9a4d3d9b1c4b70d5b00c2d5dfd33c9742b","signature":"89380172dd35719b05ff17ae673e21f267a1c0e6dcf82e3feb9a7ec215d6654a"},{"version":"6cf63398889ee97578e2f27f5fefb2a0440a8c210e7adb7092a9a1846449cbcb","signature":"09befe554c073007596d22fb721e754a2cf3e0d729fd75ba96c08f0dbae66b40"},{"version":"f70e47178691a1c646101499b32ae4d2d909c846217c426b2f69a0aeb6b73696","signature":"b9c4088f76376b9aa0005a67a2998bbe87c1222af2a62db949b6e5f006e3fb35"},{"version":"9b559c957bbd5253f77671ffb2ae01433faad8478819256a5c5b780b8e91879f","signature":"324a12bd7356b69c8f6cf1b75e02bc38cc167e2d4a2073ebffbd93388e224e09"},{"version":"3981b4f66c48b4c12898a051407a32d9d8ce84c6d7c476e83804a68270045e27","signature":"2d8e4effa6aa3bfff7d2cee7730b8f60e642ef0dd1a11b80e385738172eaa358"},{"version":"a04dd52280a45c96b6d9ac0af59246320e46f1925d3f0d7d481bdcd9f63927f5","signature":"c6c1d82d09e9b43209287e728d4a58d4d37f29cc774baa2a6538025eabd45c38"},"56c48fb5bb6316dfc27fbad065966b4ddbc38e9a0a1a5060d19b5da405ae7d6e","7091568b9a1b74b699ad09df6c130db712ed089d173a235e301a7a7ee0a4ca44","de33aa2a38affd9e71297ef7ec001a4525502878b09744308fb6518159f77d2d","57476e482c9b4e152bd23d0dc3c29375e48afee0de775674a3c1ea63cb4cf843","39554d914495ecc36b94d8bbc5076a6a891f12b7136cddb369a9a7083dd8522e","8fbe66a2959a393eb61b836224e0cd3983c89e5c2562d4875f36e3b61ee4cb77","c6695d874d1fd79c0f2266fc4943100b7b8d41d5e582408378763162679e8a92","ef69ca2ef1bd34fe5a447ccd3b055fbf12386487daff75bf109fb59e5eec06fc","ac9e28385721178e3e3f790128faf65baaf14191c070b2c9c5a50f337af5fb32","c244e83ebb4fe4d539d7f6d9405003d615e4bb7ba37629f0d5a0293c5f8bec7c","5716af400de6dc6ec6c90fa3d5b3dcb0ec1acd5156be0db4898f48796ad14f95","b22e4c25f0d8c8d0772da29fb1a697e4a7d118165f9217e9d2f7507a40633391","236dd26131e1ff9d6eb981e6865d6ef5e96f80f1353b6027800db9d3126282a1","37b51656ff8302a4556e29c775f311eb9ad813948d2c527405cea041dba3baf3","00abf32ca3af92f8be9ecbc9b63090b4909a756317d791927a83cffd24e9c8ac","cd28efe88fac7a92f3f5cfc7dd3c764f0b31bdaaa061ff044de1639810d6a7da","8b2100d3ba68063b7baf5038f26eefe46543dcebf1e7dbaf46277f24307cefcb","6eef4d0ee338cea465480c9cbd575df6f78d47fe0c2df1cd09fadcb7849e10cb","7e166acb2fd7d1218defe1e6a6aea8e922f60ed5f084ff792d684da6d34ea52a","d1c84af1e6d5fa4a5f4badd45b03b67c9255a675df235a3ec25307a0f5524278","1d006630f622824118aa3e02752ad84abe4034ff263981d0e04eec15149bc284","1e424e6e23a4afd1a70072713dac73d41ce296d7ead7c2919402af98bb322974","827eb54656695635a6e25543f711f0fe86d1083e5e1c0e84f394ffc122bd3ad7","2309cee540edc190aa607149b673b437cb8807f4e8d921bf7f5a50e6aa8d609c","703509e96cc30dce834ef8188c958c69306473b8a7e5cb3a6f324cee05a1f7bb","c6484bbc2305abf731a57e3605a6a7d05d7dbe21b0b64f2626dacfeb447ebbda","900daf04dc607dc3858c0f976d6f9e17b829a07de58d62dc6f730eaf06986075","08e0ac95e650bd4c87145b6ab2257b70c06254bf76a0b9f8a7d60c51fb8ed6b8","4b57ec505a035491c692b89af2c6902c312ec22f8fa9b6dae3e93686659fb7e0","7d796672940d3b2d37f2edea4d7bcf4c7993966286006228cbc8fa35ac92871d","6829629d578b001051fb6dc2fb4976fbce015c04666b5a73d97335e003a75f7e","132fd53917ed7f55275faa52c35e4d4d41e9576fea231d12740b723df2bade93","e53d21a2061c7b91944dfebec59bed2ce24ab165f984e3bae0f3a7a9f6c0458e","5bb98ed780a13a967031ec63f79754ad9c65c5eac5b7a6fa24cf40e926bc1cf2","b30b0ecb0308138e957fbbce863f7b3c3ba0ca2d2696a095a3af6e90bc0653a9","27ca878cf70b3030e8403f51ce65949d364fa776d6dae3527f91635a40836672","4c494db381ad1f479c137fdbb89dd32af10082cba7c11c2950a4e207bf4a3966","a45ee7555d019a67fbe092898d1aef0b1d02a9f6679ab84461ff515b4460d706","9990f9e566bc3c2c6e38df81294fb756e7f5b7b0e5bb17ab75384e190548b4b6","6fe7571c8a80808224648046008d1366ba4e29206ac79ce4c56d6fab3350492b","b4c7f80da76735fc6e12c1fc28792c901273aadda9cce74223e586182b856757","1a7cee6cce12f69f55f8fc7a55093a26a6618596399e25ccb7b29d86bc5df45f","d49e656fbe9e3fb40f1b381699bd97d87165b287f25178e28e991016a22c9df2","61355e28a4c25220df8819b47d091a996782f335aba4d5496ad7348749e0433f","11a8a3bf561b28e887819dec170064b63eaa3e08ab8c9385858a152f0764368b","9ef37c71b0f65869e429820c761c07550bdc5e354182fc73d486345ddfefd8b4","a39c32b055d2e6103e5c49b9aed2d7bb5b06571c98fc31105264d280431bdbd7","618ebb93311695a13844118cdc9a7314dd3a2c6f35092d87f76828cac555ddc9","cc0917950dfdfb1e67d99fb605517b9d1d03e2fdf7e62cd463d99295851d3b1f","9bed8447acaa89be63540ec500b165442fcb0de020015175b5a5c66d42a61c4a","0df1434fa41979b81c7872ffdf6bb4890de5d3f1deddec785330ccfbd20928e5","28e21b3654f4e56d8780646a07fff83a12faf0cd6225d9ca641e579225630787","8cc038e44d9d447fbf0744d90d8ea17155359c977a1c3c0d84416738bb320d65","39b2a085a63b2029e5c647facd010db2de444efab1d42ab76996b67c30b09b8d","cc127014a6e002e5e012a449d65875bc45b9bd1a27b24b72b2d08741a75e628e","b6fed9393f0b62eef2b3102d8e942f484a27b628d70b3bb19656e348950cfa50","d53f9f96afd41359edeb2d5ad98559f3bfad261391d5aef95320fefb0c6a8742","c75c7ceb1ae9aaa610a7a0445b6d4cff08a419dacb734f09ae26d6ea403c05a0","e03ddabe57729effa1b596881f9b51041e6ac2c39efec013a5c97ddd3fc538eb","db65a5ba647d053677bedcfb5b205e2af2d91e227d458854065fa8989054c631","cb6499c8963a29914c75965dbfbf11fc61602f3a73a1356a56fd571add30263b","d5bbd453310990e851908183fbbef9e6e2db8e0c86d97b42b723fd5238f71c81","6e503f5e906174df62cf3c7612497591a1dbb63110cdc524f0735a2016a6ad2e","95e76bed30f6e993e1fcc1b90a4675682e4800ae43403547a775d6e3c7ab2b0f","ed2b7ce9544f75d9aece6f8ed250b7c7048c3067de906c2c9f2e68d632b8fdcc","8b206b995edc6dd849b85c1c56531b9780e3ba75302fd02a2d173f008028707e","368312d58826b4913ff752c687d05e2d73f7efbf82409057827ebffab649329a","639f9321a98b734242a3573764d7f1de5369b0b0b10c768ae37639e8bda5dd03","61cabba9616d7245a0169ccb3289b46082d587c354228a6e8fe5324237154a91","dc5fe5f6b39c3fdfaeba333bcd5f0cc98bb3068797a4d7010f585366f549ddf7","4a3ab8cb278bfd1f18f24cc45a02188b63afa6aef50035df6d79c4638f24059a","85e1786d423c8ff9db411f577016fc4850d64a8baefdf829c001dbedf2bd7406","42cab173ca1afa1abcb1e10b7022fe302a496962746be5c2c8b700f738b463a7","352eaba0f41d2f64629e433a351d4c0cec1816a69bf09d7f64a5ea4531e44963","773bf9af93b5027de9b5b4c779d5cda35f0eb92c7f43a97f2ef3ca081495a191","edb6d09bae4fe20b6c33b196e9d5fb5baa72c2277a55ab87b650e79c711eca15","59625b1fcc91f2686751fd5b623126f434d7b405bd8d866a555963ce2ac69846","4085594e6044f12c00ecfa553df96850b6c67ea450745010b9dc5b69a2ec0e59","6a0fc2556eb4eebd8b19c929dcfd24ca333e5e17b67d71a1309283774d29ddb7","6add9ba44e4369d21c68364b43a2c859a55f59d26bc0bb53c41dc9a981d34319","2f505cf4e223d7f98e91fba72420ae2ac24adc330c1bf1e645c84a3c6d957d96","fc69ffd599d3e525aba38f80c7cc2ecd187dbf148287364c75f199c8294a00e6","2ad138be6972de52ed966e6402aa6403af79e9f183486e0a725ffa075a0555fb","fdac2512ddaa17ff3746ad7d7ac3a346c02e0fe50647a8472195aa43ef5823e3","967fb6e86b55db228ab50c81f85f39d6a23a0c15bcfa6e19d255e0952d33a65a","aaa18625bdc130d923949621e3ab3371d076742efcdf5edf286830d2da95b5d1","e3932de252bbe43132ad3226865b2a376ad945dbc1d767540c01b7bddc6477c2","b2f52f3cbd863dc4e690614b5cddbf412dea435d0de099db6d8adfd3cbefcd65","557c93b35f3b58e6844a9b8817559da1e0641f7f08f918e3cd1a8efee126746f","80ad2ae93d57dadac5e377ec6743df5e0211ea30bafd4b648c52366af057bb2b","07f90213b5800a0b43a6d6f309517dcca5afc6ffeb4bed396878a29fc5d6ceb0","cd1d2f103b79002cd94b85a640a103f094227a2c4c53bc8af1fdbf4e13d9729e","dfef9c847826fac5c480b6d972d3a597b932a2308f330a4416eeeb81c63ba1b2","7ebdf1a6a2a03c7ebe195935b28e3e6ebe7a5f2ba2bede0c5bc776923f2008f3","21f706150e32f03ecd1714d7a7ac55ce3caadc7c7a2a960ba57cc5d39ad84c9d","bb0e637020f81cb40d16f202c3a783f0e269e29547fb84ca9f187a5ea8556965","462da802b50ac0d94a3c8f7f58a6a0aa08108bfc1394449ea56f1e0f63f5132e","379871c4aacc245d4e07e3ce07a185e721029e811682616ac775f42ceef65d2a","b6534b358b17f51fff83b331bd84affbd4bae16884a25b8998979a3e02408281","a0ba1e2711c2520189ed980225e7a429b0706a1eabf9113e53f0e72550a1b23d","61ab2f2d7b5cd232e133561a389c2cf8886a1e676d22296d0f9a80e9a43d931d","120fc359e29ed9b55b518de8c34f4e2560e1b0c7e3f3f7c033dfcf22fb9ffd35","15ecb7dc0e6f2c1825c41f2d5f45957dd5887cf6567ecbeba8d8cf61c6885bb1","76c48b551946fa2311b501887c8388daf81a71c0d4dddaf4ae12716aee80b77e","907df70e69348493ab26792f98336775fa0d2d13ad2a3f2ea74ee3b62ac558e6","ccf87b238899b23687260fb4ea32ebac24ff6044530f8b54837f25b8462cac21","46a5b446ae02d0764625b053a3356d480dd19c362d59a40f60c8336cdea3c298","9cd282d8b364afbeacd0b43c6283a108e3bd822201730cbf7415bb100b3e19f9","eae2239ecd775a2dddd386896edf0eb70bf3bfd7dae2482dbc49a2054e6f2cca","badb4cfbfc6eca3a038be22c76297bec0b5c1478d8b73d60e8b50725b7dcc15c","09b8e68297e56f6cd8214976b5083938e63016efba8b8f5c83b14bc4ed558c39","139d53f8d0e50a655f7516e1e8a66cbad5e43e04c2720686ff8ba009feb9e48c","c4a172a07892088b23c828b2868b5101cddda593f8e20cfe3e514828deb299a9","516efe800aaa0b7504b71f2d7e7e9bed5f28eb6c9c739bfdf237f09c7addea46","10ae729013e6620dc937df5dd7077c34e29ad313a28aa75cec39957640cdc8b0","5d1c231948a91ffeb8d0e5ae6cf55c77015f0364569a97f9036bea1f45ac861f","25107bef30f920db282053349c8110a40c94d4d8352aeb9732f59647f2d39b9f","c89a0460d566857a90384c8f9002d33db5a9a7fe6d0b2b0d58f169ab35b66529","955a15609b0b382eaefedbe00bd7b669244b05692989a0bfb44e206f2479a7da",{"version":"1d906797866bce4e64329b49cd5b866f1b13159d7bbabaf92571d6e2aae333d6","signature":"a5ac165a57188ab19afc0375d08a98fb8886cfdb95bfeccb7cdae09c0854cc2f"},{"version":"2e2b305ab2b21ebc58807acffa34c734b9550c62801adc37e872c98c8d0f6bdb","signature":"7818f30a8d867d32f67c0a0ce64b002fdf855f4150b1fb5735249ff126727c0a"},"a5aaeca001d2f69093d04aac4db321e4c338fd9b20cbc4f0b0af3dc6ae0f235b","cc957354aa3c94c9961ebf46282cfde1e81d107fc5785a61f62c67f1dd3ac2eb","8041cfce439ff29d339742389de04c136e3029d6b1817f07b2d7fcbfb7534990","93de1c6dab503f053efe8d304cb522bb3a89feab8c98f307a674a4fae04773e9","29a46d003ca3c721e6405f00dee7e3de91b14e09701eba5d887bf76fb2d47d38","069bebfee29864e3955378107e243508b163e77ab10de6a5ee03ae06939f0bb9",{"version":"64d4b35c5456adf258d2cf56c341e203a073253f229ef3208fc0d5020253b241","affectsGlobalScope":true},"ee7d8894904b465b072be0d2e4b45cf6b887cdba16a467645c4e200982ece7ea","f3d8c757e148ad968f0d98697987db363070abada5f503da3c06aefd9d4248c1","df95e00612c1faa5e0e7ef0dba589b18665bbeb3221db2b6cee1fe4d0e61921f","afe73051ff6a03a9565cbd8ebb0e956ee3df5e913ad5c1ded64218aabfa3dcb5","8b06ac3faeacb8484d84ddb44571d8f410697f98d7bfa86c0fda60373a9f5215","7eb06594824ada538b1d8b48c3925a83e7db792f47a081a62cf3e5c4e23cf0ee","f5638f7c2f12a9a1a57b5c41b3c1ea7db3876c003bab68e6a57afd6bcc169af0","0d14fa22c41fdc7277e6f71473b20ebc07f40f00e38875142335d5b63cdfc9d2","d8aab31ba8e618cc3eea10b0945de81cb93b7e8150a013a482332263b9305322","462bccdf75fcafc1ae8c30400c9425e1a4681db5d605d1a0edb4f990a54d8094","5923d8facbac6ecf7c84739a5c701a57af94a6f6648d6229a6c768cf28f0f8cb","7adecb2c3238794c378d336a8182d4c3dd2c4fa6fa1785e2797a3db550edea62","dc12dc0e5aa06f4e1a7692149b78f89116af823b9e1f1e4eae140cd3e0e674e6","1bfc6565b90c8771615cd8cfcf9b36efc0275e5e83ac7d9181307e96eb495161","8a8a96898906f065f296665e411f51010b51372fa260d5373bf9f64356703190","7f82ef88bdb67d9a850dd1c7cd2d690f33e0f0acd208e3c9eba086f3670d4f73",{"version":"ccfd8774cd9b929f63ff7dcf657977eb0652e3547f1fcac1b3a1dc5db22d4d58","affectsGlobalScope":true},"d92dc90fecd2552db74d8dc3c6fb4db9145b2aa0efe2c127236ba035969068d4","96d14f21b7652903852eef49379d04dbda28c16ed36468f8c9fa08f7c14c9538","8841e2aa774b89bd23302dede20663306dc1b9902431ac64b24be8b8d0e3f649","2b8264b2fefd7367e0f20e2c04eed5d3038831fe00f5efbc110ff0131aab899b","a73a445c1e0a6d0f8b48e8eb22dc9d647896783a7f8991cbbc31c0d94bf1f5a2","d88a5e779faf033be3d52142a04fbe1cb96009868e3bbdd296b2bc6c59e06c0e","3dce33e7eb25594863b8e615f14a45ab98190d85953436750644212d8a18c066","2b93035328f7778d200252681c1d86285d501ed424825a18f81e4c3028aa51d9","2ac9c8332c5f8510b8bdd571f8271e0f39b0577714d5e95c1e79a12b2616f069","42c21aa963e7b86fa00801d96e88b36803188018d5ad91db2a9101bccd40b3ff","d31eb848cdebb4c55b4893b335a7c0cca95ad66dee13cbb7d0893810c0a9c301","b9f96255e1048ed2ea33ec553122716f0e57fc1c3ad778e9aa15f5b46547bd23","7a9e0a564fee396cacf706523b5aeed96e04c6b871a8bebefad78499fbffc5bc","906c751ef5822ec0dadcea2f0e9db64a33fb4ee926cc9f7efa38afe5d5371b2a","5387c049e9702f2d2d7ece1a74836a14b47fbebe9bbeb19f94c580a37c855351","c68391fb9efad5d99ff332c65b1606248c4e4a9f1dd9a087204242b56c7126d6","e9cf02252d3a0ced987d24845dcb1f11c1be5541f17e5daa44c6de2d18138d0c","e8b02b879754d85f48489294f99147aeccc352c760d95a6fe2b6e49cd400b2fe","9f6908ab3d8a86c68b86e38578afc7095114e66b2fc36a2a96e9252aac3998e0","0eedb2344442b143ddcd788f87096961cd8572b64f10b4afc3356aa0460171c6","71405cc70f183d029cc5018375f6c35117ffdaf11846c35ebf85ee3956b1b2a6","c68baff4d8ba346130e9753cefe2e487a16731bf17e05fdacc81e8c9a26aae9d","2cd15528d8bb5d0453aa339b4b52e0696e8b07e790c153831c642c3dea5ac8af","479d622e66283ffa9883fbc33e441f7fc928b2277ff30aacbec7b7761b4e9579","ade307876dc5ca267ca308d09e737b611505e015c535863f22420a11fffc1c54","f8cdefa3e0dee639eccbe9794b46f90291e5fd3989fcba60d2f08fde56179fb9","86c5a62f99aac7053976e317dbe9acb2eaf903aaf3d2e5bb1cafe5c2df7b37a8","2b300954ce01a8343866f737656e13243e86e5baef51bd0631b21dcef1f6e954","a2d409a9ffd872d6b9d78ead00baa116bbc73cfa959fce9a2f29d3227876b2a1","b288936f560cd71f4a6002953290de9ff8dfbfbf37f5a9391be5c83322324898","61178a781ef82e0ff54f9430397e71e8f365fc1e3725e0e5346f2de7b0d50dfa","6a6ccb37feb3aad32d9be026a3337db195979cd5727a616fc0f557e974101a54","c649ea79205c029a02272ef55b7ab14ada0903db26144d2205021f24727ac7a3","38e2b02897c6357bbcff729ef84c736727b45cc152abe95a7567caccdfad2a1d","d6610ea7e0b1a7686dba062a1e5544dd7d34140f4545305b7c6afaebfb348341","3dee35db743bdba2c8d19aece7ac049bde6fa587e195d86547c882784e6ba34c","b15e55c5fa977c2f25ca0b1db52cfa2d1fd4bf0baf90a8b90d4a7678ca462ff1","f41d30972724714763a2698ae949fbc463afb203b5fa7c4ad7e4de0871129a17","843dd7b6a7c6269fd43827303f5cbe65c1fecabc30b4670a50d5a15d57daeeb9","f06d8b8567ee9fd799bf7f806efe93b67683ef24f4dea5b23ef12edff4434d9d","6017384f697ff38bc3ef6a546df5b230c3c31329db84cbfe686c83bec011e2b2","e1a5b30d9248549ca0c0bb1d653bafae20c64c4aa5928cc4cd3017b55c2177b0","a593632d5878f17295bd53e1c77f27bf4c15212822f764a2bfc1702f4b413fa0","a868a534ba1c2ca9060b8a13b0ffbbbf78b4be7b0ff80d8c75b02773f7192c29","da7545aba8f54a50fde23e2ede00158dc8112560d934cee58098dfb03aae9b9d","34baf65cfee92f110d6653322e2120c2d368ee64b3c7981dff08ed105c4f19b0","a1a261624efb3a00ff346b13580f70f3463b8cdcc58b60f5793ff11785d52cab","f83b320cceccfc48457a818d18fc9a006ab18d0bdd727aa2c2e73dc1b4a45e98","9d92b037978bb9525bc4b673ebddd443277542e010c0aef019c03a170ccdaa73","b0d10e46cfe3f6c476b69af02eaa38e4ccc7430221ce3109ae84bb9fb8282298","70e9a18da08294f75bf23e46c7d69e67634c0765d355887b9b41f0d959e1426e","ed44ba6b95f08b758748be7902e0cc54178b1337c56d0e2469c77b03f63ac73b"],"options":{"composite":true,"declaration":true,"declarationMap":true,"emitDeclarationOnly":true,"esModuleInterop":true,"inlineSources":true,"module":1,"outDir":"./types","rootDir":"../src","sourceMap":true,"strict":true,"target":7},"fileIdsList":[[120,643],[120],[91,120,127,128,129,144],[120,128,129,145,146],[120,127,128],[120,127,144,147,150],[120,127,147,150,151],[120,148,149,150,152,153],[120,127,150],[120,127,144,147,148,149,152],[120,127,135],[120,127],[91,120,127],[80,120,127],[120,131,132,133,134,135,136,137,138,139,140,141,142,143],[120,127,133,134],[120,127,133,135],[120,418,422,423],[120,418,421],[120,421],[120,422,424,426],[120,418,421,422,423,424,425],[120,418,421,425,429,430,431],[120,418,421,425,432],[120,418],[120,418,419],[120,419,420],[120,418,421,427,430,432,433],[120,428],[120,429,431,435,438,439],[120,429,431,439],[120,127,421,425,429,430,432,435],[120,429,439],[120,429,432,436],[120,421,430,432],[120,429,432,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450],[120,429,437],[120,127,437],[120,418,425,429,430,431,432,433,436],[120,429,431,435,437],[120,429,436,437],[120,127,154,264,265],[120,265,266],[120,264],[120,127,259],[120,259,260,261,262,263],[120,127,231,238,239],[120,127,231,238,239,259],[120,127,231,238,239,243],[120,127,231,238,239,240,242,243],[120,127,231,238,239,241],[120,127,231,238,239,244,245,247,248],[120,237,259],[120,127,231,238,239,244],[120,127,231,238,239,242],[120,127,231,238,239,255],[120,127,231,238,239,256],[120,130,228,231,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258],[120,229],[120,229,230],[120,229,238,239,244,245],[120,231,237,238],[120,276,277],[91,120,127,264,267,274],[120,267,276],[120,166,507],[120,166,505,507,508,509],[120,166,495],[120,495],[120,495,496,497,498,499,500,501,502,503,504],[120,505],[120,506],[120,336,342,343,346],[120,336,342,345],[120,338,340],[120,337],[120,338,340,341],[120,339],[120,345,350],[120,336,342,345,350],[120,342,345,347,348,349],[120,336,342,343,344,345,346,350],[120,336,342,344,346],[120,336,342],[64,120,166,280],[120,282],[64,120,280],[120,283,284],[64,120],[120,280,281,285,286,293,295,307,308,384],[64,120,166,385],[120,166,285],[120,288],[64,120,166],[120,287,289,290,291,292],[120,166,281,294],[120,166,294,295,306],[120,166,286,383],[58,64,120],[120,491,492,493],[120,523],[120,127,300,522],[120,127,300,523],[108,120,127,269],[120,269],[120,269,270,271,272,273],[120,268],[108,120,127],[120,300,525],[120,525,526,527,528,529,530,531,532,533,534],[120,525,526],[81,120,127,525,526],[120,124,127,525,526],[120,526],[120,166,203,210,296],[120,297],[120,301],[120,297,298,301,302,303,304,305],[120,127,298,300,303],[120,127,166,297,300,301],[120,296,303],[120,127,166,203,210,297,300],[120,166,210],[120,166,309],[120,309,310],[120,309,310,311,312],[120,166],[120,187,383,572,593,609,622,637],[120,635],[120,166,607,633,634,636],[120,127,210,300,524,535,593,594,609],[120,166,187,593,609],[120,535,595],[120,597],[120,594,595,596,598,601,604,606],[120,599,600],[81,120,127,535,607],[120,124,127,535,607],[120,603],[120,595,602,607],[120,535,595,596],[120,166,535],[120,605],[120,595,596],[120,166,572,593,609,624,625,626,627,628,629],[120,166,572,593,609,624],[120,612,621,623,630,631,632],[120,593,609],[120,608,609,610,611],[120,593,609,610],[120,166,593,608,609],[120,166,593,609],[120,572,593,609],[120,619,620],[120,166,187,575,619],[120,166,383,575],[120,166,183,187,383,458,572,575,593,607,609,612,616,618,621,622],[120,166,383,593,609,622,633],[64,120,166,574],[120,127,166,314],[120,166,319],[120,333],[120,166,314,319,320,333,334,382],[120,127,166,313,314],[120,315,316,317,318],[58,64,120,317],[120,371],[120,373,374,375,376,377,378,379,380],[120,352],[120,319,333,379],[120,319,333,352],[120,352,353,361,370,371,372,381],[120,319,333],[120,351,353],[120,353],[120,319],[120,166,361],[120,335,354,355,356,357,358,359,360,362,363,364,365,366,367,368,369],[120,166,363],[120,319,335,354,355,356,357,358,359,360,362,363,364,365,366,367,368],[120,166,352],[120,306,370],[120,166,353],[120,331],[64,120,321],[120,322,323,324,325,326,327,328,329,330],[120,321,331,332],[120,383],[120,540],[120,538],[64,120,166,545],[120,351],[120,166,313,383],[120,166,540],[64,120,383,555],[120,536,537,540,541,542,543,546,547,548,549,550,551,552,553,554,555,556,557,558,573,576,578,579,581,582,583,584,585,586,587,588,589,590,591,592],[64,120,166,572],[64,120,166,383,540,581],[120,157],[120,577,580],[120,127,166,540,577,578,579],[64,120,166,383,576],[64,120,383,576],[120,578],[64,120,383,572,575,577,578,582],[64,120,166,540,543,556,581,582],[120,538,539],[92,120,127,538],[120,198],[120,198,199,200],[67,120],[64,67,120],[65,66,67,68,69,70,71,72,73,74,75,120,155,158,159,160,161,162,163,164,165],[58,64,65,120],[67,73,75,120,154],[67,68,120],[64,120,161],[120,127,234],[120,232,233,236],[120,232,235],[120,127,232],[120,193,194],[120,643,644,645,646,647],[120,643,645],[120,156],[120,649,650,651],[92,120,127],[120,654],[120,655],[120,666],[120,660,665],[120,404,406,407,408,409,410,411,412,413,414,415,416],[120,404,405,407,408,409,410,411,412,413,414,415,416],[120,405,406,407,408,409,410,411,412,413,414,415,416],[120,404,405,406,408,409,410,411,412,413,414,415,416],[120,404,405,406,407,409,410,411,412,413,414,415,416],[120,404,405,406,407,408,410,411,412,413,414,415,416],[120,404,405,406,407,408,409,411,412,413,414,415,416],[120,404,405,406,407,408,409,410,412,413,414,415,416],[120,404,405,406,407,408,409,410,411,413,414,415,416],[120,404,405,406,407,408,409,410,411,412,414,415,416],[120,404,405,406,407,408,409,410,411,412,413,415,416],[120,404,405,406,407,408,409,410,411,412,413,414,416],[120,404,405,406,407,408,409,410,411,412,413,414,415],[76,120],[79,120],[80,85,111,120],[81,91,92,99,108,119,120],[81,82,91,99,120],[83,120],[84,85,92,100,120],[85,108,116,120],[86,88,91,99,120],[87,120],[88,89,120],[90,91,120],[91,120],[91,92,93,108,119,120],[91,92,93,108,120],[91,94,99,108,119,120],[91,92,94,95,99,108,116,119,120],[94,96,108,116,119,120],[76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126],[91,97,120],[98,119,120,124],[88,91,99,108,120],[100,120],[101,120],[79,102,120],[103,118,120,124],[104,120],[105,120],[91,106,120],[106,107,120,122],[80,91,108,109,110,120],[80,108,110,120],[108,109,120],[111,120],[112,120],[91,114,115,120],[114,115,120],[85,99,116,120],[117,120],[99,118,120],[80,94,105,119,120],[85,120],[108,120,121],[120,122],[120,123],[80,85,91,93,102,108,119,120,122,124],[108,120,125],[120,127,299],[120,674,713],[120,674,698,713],[120,713],[120,674],[120,674,699,713],[120,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712],[120,699,713],[120,714],[120,717],[120,617],[120,398,399,400,401,402],[120,398],[120,400],[120,398,400],[120,464,465,466,467,468],[120,469],[120,466,469],[120,467],[120,478,479,480],[120,481],[120,478,481],[120,127,470,476],[120,127,470,476,477,481],[120,470,476],[120,482,483,484,485],[120,482],[120,127,476,477,487],[120,469,470,471,472,473,474,475,476,478,481,486],[120,127,476,487],[120,127,469,470,471,472,473,474,475,478,481],[120,127,469,470,476,477],[120,127,470,476,477],[120,544],[120,203],[120,215,216,217],[120,203,214,215],[120,178],[120,178,179,180,181,182],[120,167,168,169,170,171,172,173,174,175,176,177],[120,658,661],[120,658,661,662,663],[120,660],[120,657,664],[120,452,453],[120,659],[57,59,60,61,62,63,120],[57,58,120],[59,120],[58,59,120],[57,59,120],[120,187,385,394,637],[120,638,639],[120,166,187,313],[120,456,457],[120,166,187,190,197,223,227,397,403,416],[46,120,166,187,191,197,223,397,434,451,511,512,517,518],[120,166,191,197,421,454,461,462,489,516],[120,197],[120,187,197,223,227,403,490],[120,417,461,462,489,514,515,516,517,519,520,521,641],[91,120,166,187,191,197,223,313,397,403,455,458,459,460,461,517,519],[120,166,187,197,223,227,397,460,462,517],[52,120,144,166,191,197,434,451,510,517],[52,120,191,197,434,451,517],[52,120,197,434,451,517],[120,166,197,463,487],[120,463,488],[120,166,197,517],[120,187,197,397,515,516,519],[47,120,166,187,197,223,227,394,397,514,515,516,517,519,640],[120,166,187,197,223,227,403,513,517],[120,166,187,197,223,227,397,416,463,490,515,517],[47,52,91,120,166,183,187,197,223,313,397,403,434,451,458,459,511,512,513,514,516,517],[120,166,183,184,185],[120,184],[56,120,184,185,186],[120,185],[120,188],[120,188,189,192,196],[120,195],[120,166,190,191],[120,211,212,213],[120,210,211],[120,166,210,211],[120,166,203,210],[120,166,204],[120,204,205,206,207,208,209],[120,166,203],[120,393],[120,154,166,183,187,278,279,385,392],[91,120,127,166,187],[120,386],[120,386,387,388,389,390,391],[120,197,386],[120,219],[120,202,219,221,222],[120,166,187,190,197,201,202,219,220],[120,166,197,214,218],[120,166,564,565,566],[120,313,565],[120,562,563,564,565,566,567,571],[120,166,210,564,566,572],[120,166,187,197,559,562,564,567],[120,166,183,187,197,313,458,559,560,561,562,563,565,566,567],[120,166,210,563,564,565],[120,568,569,570],[120,166,197,210,563,565,566],[120,166,210,563,565,566],[120,166,187,564],[120,166,210,565,567],[120,615],[55,120,187,197,613,614],[120,166,187,223,224],[120,224,225,226],[120,127,166,187,223,224],[120,166,223],[120,396],[120,187,394,395],[187,190,223,227,397],[166,187,191,223,397,451,511,512,518],[166,191,421,461,462,489,516],[187,223,227,490],[417,461,462,489,514,515,516,517,519,520,521,641],[91,166,187,223,397,458,460,461,519],[166,187,223,227,397,462],[191,451],[451],[166],[166,463],[187,397,515,516,519],[187,223,227,394,397,514,515,519,640],[166,187,223,227],[166,187,223,227,397,463,515],[91,166,183,187,223,397,434,451,458,514,516]],"referencedMap":[[645,1],[643,2],[145,3],[128,2],[147,4],[129,5],[146,2],[151,6],[152,7],[148,7],[154,8],[149,7],[153,9],[150,10],[136,11],[133,12],[140,13],[134,11],[131,14],[139,2],[144,15],[141,2],[142,2],[143,2],[138,12],[135,16],[132,2],[137,17],[424,18],[423,19],[422,20],[427,21],[426,22],[432,23],[433,24],[455,19],[419,25],[420,26],[421,27],[418,2],[434,28],[429,29],[428,2],[425,2],[440,30],[441,31],[436,32],[442,33],[443,34],[444,34],[435,35],[451,36],[446,30],[445,37],[447,38],[437,39],[448,33],[449,31],[439,40],[450,37],[438,41],[430,19],[431,2],[266,42],[267,43],[265,44],[262,45],[261,45],[260,45],[264,46],[263,2],[246,47],[251,48],[240,47],[245,49],[244,50],[242,51],[249,52],[250,47],[252,53],[254,2],[253,54],[255,55],[256,56],[257,57],[259,58],[230,59],[229,2],[231,60],[247,61],[228,2],[241,2],[239,62],[238,2],[248,2],[243,2],[258,2],[278,63],[276,64],[277,65],[275,46],[508,66],[509,2],[510,67],[496,68],[497,69],[498,69],[499,68],[500,68],[501,69],[505,70],[502,68],[495,2],[503,69],[504,69],[506,71],[507,72],[279,2],[190,2],[344,73],[346,74],[336,2],[341,75],[338,76],[342,77],[340,78],[347,79],[348,80],[350,81],[349,79],[351,82],[345,83],[343,84],[281,85],[283,86],[282,87],[285,88],[284,89],[286,2],[385,90],[287,91],[288,92],[289,93],[290,94],[293,95],[291,2],[292,85],[294,85],[295,96],[307,97],[308,96],[384,98],[280,99],[493,2],[491,2],[492,2],[494,100],[524,101],[523,102],[522,103],[270,104],[271,105],[274,106],[272,105],[269,107],[273,108],[268,13],[526,109],[535,110],[531,111],[530,112],[533,111],[532,113],[534,114],[525,2],[529,114],[528,111],[527,114],[297,115],[298,116],[302,117],[306,118],[304,119],[303,120],[305,121],[301,122],[296,123],[310,124],[312,2],[311,125],[313,126],[309,127],[203,13],[635,128],[636,129],[637,130],[595,131],[594,132],[597,133],[598,134],[607,135],[601,136],[599,137],[600,138],[604,139],[603,140],[602,141],[596,142],[606,143],[605,144],[624,2],[630,145],[629,146],[628,146],[625,146],[626,146],[627,146],[633,147],[610,148],[612,149],[611,150],[609,151],[608,152],[632,153],[621,154],[620,155],[619,156],[631,148],[623,157],[622,2],[634,158],[575,159],[574,94],[320,160],[314,161],[334,162],[383,163],[315,164],[316,127],[317,127],[319,165],[318,166],[352,2],[372,167],[373,127],[374,162],[381,168],[375,127],[376,127],[377,169],[378,127],[380,170],[379,171],[382,172],[335,173],[354,174],[355,175],[356,174],[357,2],[358,127],[359,176],[360,2],[362,177],[370,178],[364,179],[363,127],[365,127],[366,161],[369,180],[367,176],[368,177],[353,181],[371,182],[361,183],[332,184],[322,185],[323,185],[324,185],[325,185],[326,185],[331,186],[327,185],[330,185],[328,185],[329,185],[333,187],[321,89],[536,2],[537,188],[541,189],[542,189],[543,2],[547,190],[546,191],[548,2],[549,2],[550,192],[551,2],[553,193],[552,2],[554,194],[555,2],[556,195],[557,2],[593,196],[573,197],[558,127],[582,198],[583,199],[581,200],[580,201],[577,202],[584,2],[585,203],[586,204],[587,2],[588,2],[579,205],[589,2],[576,99],[578,206],[590,188],[591,204],[592,127],[540,207],[539,208],[538,2],[199,209],[200,209],[201,210],[198,2],[65,89],[66,89],[68,211],[69,89],[70,89],[71,212],[72,2],[73,2],[74,2],[67,89],[166,213],[75,214],[155,215],[158,199],[159,2],[160,2],[161,2],[162,2],[163,2],[164,216],[165,217],[235,218],[234,12],[237,219],[232,12],[236,220],[233,221],[337,2],[339,2],[193,2],[195,222],[194,2],[648,223],[644,1],[646,224],[647,1],[191,12],[157,225],[560,2],[649,2],[652,226],[650,2],[653,227],[654,2],[655,228],[656,229],[667,230],[666,231],[651,2],[668,2],[405,232],[406,233],[404,234],[407,235],[408,236],[409,237],[410,238],[411,239],[412,240],[413,241],[414,242],[415,243],[416,244],[669,2],[156,2],[76,245],[77,245],[79,246],[80,247],[81,248],[82,249],[83,250],[84,251],[85,252],[86,253],[87,254],[88,255],[89,255],[90,256],[91,257],[92,258],[93,259],[78,2],[126,2],[94,260],[95,261],[96,262],[127,263],[97,264],[98,265],[99,266],[100,267],[101,268],[102,269],[103,270],[104,271],[105,272],[106,273],[107,274],[108,275],[110,276],[109,277],[111,278],[112,279],[113,2],[114,280],[115,281],[116,282],[117,283],[118,284],[119,285],[120,286],[121,287],[122,288],[123,289],[124,290],[125,291],[670,2],[671,12],[672,2],[613,2],[300,292],[299,2],[673,12],[698,293],[699,294],[674,295],[677,295],[696,293],[697,293],[687,293],[686,296],[684,293],[679,293],[692,293],[690,293],[694,293],[678,293],[691,293],[695,293],[680,293],[681,293],[693,293],[675,293],[682,293],[683,293],[685,293],[689,293],[700,297],[688,293],[676,293],[713,298],[712,2],[707,297],[709,299],[708,297],[701,297],[702,297],[704,297],[706,297],[710,299],[711,299],[703,299],[705,299],[715,300],[714,2],[716,2],[459,2],[717,2],[718,301],[618,302],[617,2],[403,303],[399,304],[398,2],[401,305],[400,2],[402,306],[130,2],[657,2],[469,307],[464,308],[465,308],[467,309],[466,310],[468,308],[481,311],[480,312],[479,313],[471,314],[478,315],[470,12],[477,316],[482,2],[483,2],[486,317],[484,318],[485,2],[472,319],[487,320],[473,321],[476,322],[474,323],[475,324],[544,2],[545,325],[215,326],[218,327],[216,328],[217,328],[177,2],[174,329],[176,329],[175,329],[173,329],[183,330],[178,331],[182,2],[179,2],[181,2],[180,2],[169,329],[170,329],[171,329],[167,2],[168,2],[172,329],[658,2],[662,332],[664,333],[663,332],[661,334],[665,335],[452,2],[454,336],[453,2],[559,2],[660,337],[659,2],[57,2],[64,338],[59,339],[60,340],[61,340],[62,341],[63,341],[58,342],[8,2],[10,2],[9,2],[2,2],[11,2],[12,2],[13,2],[14,2],[15,2],[16,2],[17,2],[18,2],[3,2],[4,2],[22,2],[19,2],[20,2],[21,2],[23,2],[24,2],[25,2],[5,2],[26,2],[27,2],[28,2],[29,2],[6,2],[33,2],[30,2],[31,2],[32,2],[34,2],[7,2],[35,2],[40,2],[41,2],[36,2],[37,2],[38,2],[39,2],[1,2],[42,2],[638,343],[640,344],[639,2],[456,345],[457,2],[458,346],[417,347],[519,348],[517,349],[460,2],[490,350],[520,351],[642,352],[462,353],[461,354],[511,355],[512,356],[518,357],[463,127],[488,358],[489,359],[513,360],[521,361],[641,362],[514,363],[516,364],[515,365],[56,2],[186,366],[185,367],[187,368],[184,369],[189,370],[197,371],[196,372],[188,2],[192,373],[214,374],[212,375],[213,376],[211,377],[205,378],[206,378],[207,2],[208,378],[210,379],[204,380],[209,378],[394,381],[393,382],[386,383],[391,384],[390,384],[392,385],[387,384],[388,386],[389,384],[202,2],[220,387],[222,387],[223,388],[221,389],[219,390],[567,391],[566,392],[572,393],[561,394],[565,395],[564,396],[568,397],[571,398],[569,399],[570,400],[562,401],[563,402],[616,403],[615,404],[614,403],[225,405],[227,406],[226,407],[224,408],[395,2],[397,409],[396,410],[47,2],[48,2],[49,2],[50,2],[51,2],[52,2],[43,2],[53,2],[54,2],[55,2],[44,2],[45,2],[46,2]],"exportedModulesMap":[[645,1],[643,2],[145,3],[128,2],[147,4],[129,5],[146,2],[151,6],[152,7],[148,7],[154,8],[149,7],[153,9],[150,10],[136,11],[133,12],[140,13],[134,11],[131,14],[139,2],[144,15],[141,2],[142,2],[143,2],[138,12],[135,16],[132,2],[137,17],[424,18],[423,19],[422,20],[427,21],[426,22],[432,23],[433,24],[455,19],[419,25],[420,26],[421,27],[418,2],[434,28],[429,29],[428,2],[425,2],[440,30],[441,31],[436,32],[442,33],[443,34],[444,34],[435,35],[451,36],[446,30],[445,37],[447,38],[437,39],[448,33],[449,31],[439,40],[450,37],[438,41],[430,19],[431,2],[266,42],[267,43],[265,44],[262,45],[261,45],[260,45],[264,46],[263,2],[246,47],[251,48],[240,47],[245,49],[244,50],[242,51],[249,52],[250,47],[252,53],[254,2],[253,54],[255,55],[256,56],[257,57],[259,58],[230,59],[229,2],[231,60],[247,61],[228,2],[241,2],[239,62],[238,2],[248,2],[243,2],[258,2],[278,63],[276,64],[277,65],[275,46],[508,66],[509,2],[510,67],[496,68],[497,69],[498,69],[499,68],[500,68],[501,69],[505,70],[502,68],[495,2],[503,69],[504,69],[506,71],[507,72],[279,2],[190,2],[344,73],[346,74],[336,2],[341,75],[338,76],[342,77],[340,78],[347,79],[348,80],[350,81],[349,79],[351,82],[345,83],[343,84],[281,85],[283,86],[282,87],[285,88],[284,89],[286,2],[385,90],[287,91],[288,92],[289,93],[290,94],[293,95],[291,2],[292,85],[294,85],[295,96],[307,97],[308,96],[384,98],[280,99],[493,2],[491,2],[492,2],[494,100],[524,101],[523,102],[522,103],[270,104],[271,105],[274,106],[272,105],[269,107],[273,108],[268,13],[526,109],[535,110],[531,111],[530,112],[533,111],[532,113],[534,114],[525,2],[529,114],[528,111],[527,114],[297,115],[298,116],[302,117],[306,118],[304,119],[303,120],[305,121],[301,122],[296,123],[310,124],[312,2],[311,125],[313,126],[309,127],[203,13],[635,128],[636,129],[637,130],[595,131],[594,132],[597,133],[598,134],[607,135],[601,136],[599,137],[600,138],[604,139],[603,140],[602,141],[596,142],[606,143],[605,144],[624,2],[630,145],[629,146],[628,146],[625,146],[626,146],[627,146],[633,147],[610,148],[612,149],[611,150],[609,151],[608,152],[632,153],[621,154],[620,155],[619,156],[631,148],[623,157],[622,2],[634,158],[575,159],[574,94],[320,160],[314,161],[334,162],[383,163],[315,164],[316,127],[317,127],[319,165],[318,166],[352,2],[372,167],[373,127],[374,162],[381,168],[375,127],[376,127],[377,169],[378,127],[380,170],[379,171],[382,172],[335,173],[354,174],[355,175],[356,174],[357,2],[358,127],[359,176],[360,2],[362,177],[370,178],[364,179],[363,127],[365,127],[366,161],[369,180],[367,176],[368,177],[353,181],[371,182],[361,183],[332,184],[322,185],[323,185],[324,185],[325,185],[326,185],[331,186],[327,185],[330,185],[328,185],[329,185],[333,187],[321,89],[536,2],[537,188],[541,189],[542,189],[543,2],[547,190],[546,191],[548,2],[549,2],[550,192],[551,2],[553,193],[552,2],[554,194],[555,2],[556,195],[557,2],[593,196],[573,197],[558,127],[582,198],[583,199],[581,200],[580,201],[577,202],[584,2],[585,203],[586,204],[587,2],[588,2],[579,205],[589,2],[576,99],[578,206],[590,188],[591,204],[592,127],[540,207],[539,208],[538,2],[199,209],[200,209],[201,210],[198,2],[65,89],[66,89],[68,211],[69,89],[70,89],[71,212],[72,2],[73,2],[74,2],[67,89],[166,213],[75,214],[155,215],[158,199],[159,2],[160,2],[161,2],[162,2],[163,2],[164,216],[165,217],[235,218],[234,12],[237,219],[232,12],[236,220],[233,221],[337,2],[339,2],[193,2],[195,222],[194,2],[648,223],[644,1],[646,224],[647,1],[191,12],[157,225],[560,2],[649,2],[652,226],[650,2],[653,227],[654,2],[655,228],[656,229],[667,230],[666,231],[651,2],[668,2],[405,232],[406,233],[404,234],[407,235],[408,236],[409,237],[410,238],[411,239],[412,240],[413,241],[414,242],[415,243],[416,244],[669,2],[156,2],[76,245],[77,245],[79,246],[80,247],[81,248],[82,249],[83,250],[84,251],[85,252],[86,253],[87,254],[88,255],[89,255],[90,256],[91,257],[92,258],[93,259],[78,2],[126,2],[94,260],[95,261],[96,262],[127,263],[97,264],[98,265],[99,266],[100,267],[101,268],[102,269],[103,270],[104,271],[105,272],[106,273],[107,274],[108,275],[110,276],[109,277],[111,278],[112,279],[113,2],[114,280],[115,281],[116,282],[117,283],[118,284],[119,285],[120,286],[121,287],[122,288],[123,289],[124,290],[125,291],[670,2],[671,12],[672,2],[613,2],[300,292],[299,2],[673,12],[698,293],[699,294],[674,295],[677,295],[696,293],[697,293],[687,293],[686,296],[684,293],[679,293],[692,293],[690,293],[694,293],[678,293],[691,293],[695,293],[680,293],[681,293],[693,293],[675,293],[682,293],[683,293],[685,293],[689,293],[700,297],[688,293],[676,293],[713,298],[712,2],[707,297],[709,299],[708,297],[701,297],[702,297],[704,297],[706,297],[710,299],[711,299],[703,299],[705,299],[715,300],[714,2],[716,2],[459,2],[717,2],[718,301],[618,302],[617,2],[403,303],[399,304],[398,2],[401,305],[400,2],[402,306],[130,2],[657,2],[469,307],[464,308],[465,308],[467,309],[466,310],[468,308],[481,311],[480,312],[479,313],[471,314],[478,315],[470,12],[477,316],[482,2],[483,2],[486,317],[484,318],[485,2],[472,319],[487,320],[473,321],[476,322],[474,323],[475,324],[544,2],[545,325],[215,326],[218,327],[216,328],[217,328],[177,2],[174,329],[176,329],[175,329],[173,329],[183,330],[178,331],[182,2],[179,2],[181,2],[180,2],[169,329],[170,329],[171,329],[167,2],[168,2],[172,329],[658,2],[662,332],[664,333],[663,332],[661,334],[665,335],[452,2],[454,336],[453,2],[559,2],[660,337],[659,2],[57,2],[64,338],[59,339],[60,340],[61,340],[62,341],[63,341],[58,342],[8,2],[10,2],[9,2],[2,2],[11,2],[12,2],[13,2],[14,2],[15,2],[16,2],[17,2],[18,2],[3,2],[4,2],[22,2],[19,2],[20,2],[21,2],[23,2],[24,2],[25,2],[5,2],[26,2],[27,2],[28,2],[29,2],[6,2],[33,2],[30,2],[31,2],[32,2],[34,2],[7,2],[35,2],[40,2],[41,2],[36,2],[37,2],[38,2],[39,2],[1,2],[42,2],[638,343],[640,344],[639,2],[456,345],[457,2],[458,346],[417,411],[519,412],[517,413],[520,414],[642,415],[462,416],[461,417],[511,418],[512,418],[518,419],[463,420],[488,421],[489,359],[513,420],[521,422],[641,423],[514,424],[516,425],[515,426],[56,2],[186,366],[185,367],[187,368],[184,369],[189,370],[197,371],[196,372],[188,2],[192,373],[214,374],[212,375],[213,376],[211,377],[205,378],[206,378],[207,2],[208,378],[210,379],[204,380],[209,378],[394,381],[393,382],[386,383],[391,384],[390,384],[392,385],[387,384],[388,386],[389,384],[202,2],[220,387],[222,387],[223,388],[221,389],[219,390],[567,391],[566,392],[572,393],[561,394],[565,395],[564,396],[568,397],[571,398],[569,399],[570,400],[562,401],[563,402],[616,403],[615,404],[614,403],[225,405],[227,406],[226,407],[224,408],[395,2],[397,409],[396,410],[47,2],[48,2],[49,2],[50,2],[51,2],[52,2],[43,2],[53,2],[54,2],[55,2],[44,2],[45,2],[46,2]],"semanticDiagnosticsPerFile":[645,643,145,128,147,129,146,151,152,148,154,149,153,150,136,133,140,134,131,139,144,141,142,143,138,135,132,137,424,423,422,427,426,432,433,455,419,420,421,418,434,429,428,425,440,441,436,442,443,444,435,451,446,445,447,437,448,449,439,450,438,430,431,266,267,265,262,261,260,264,263,246,251,240,245,244,242,249,250,252,254,253,255,256,257,259,230,229,231,247,228,241,239,238,248,243,258,278,276,277,275,508,509,510,496,497,498,499,500,501,505,502,495,503,504,506,507,279,190,344,346,336,341,338,342,340,347,348,350,349,351,345,343,281,283,282,285,284,286,385,287,288,289,290,293,291,292,294,295,307,308,384,280,493,491,492,494,524,523,522,270,271,274,272,269,273,268,526,535,531,530,533,532,534,525,529,528,527,297,298,302,306,304,303,305,301,296,310,312,311,313,309,203,635,636,637,595,594,597,598,607,601,599,600,604,603,602,596,606,605,624,630,629,628,625,626,627,633,610,612,611,609,608,632,621,620,619,631,623,622,634,575,574,320,314,334,383,315,316,317,319,318,352,372,373,374,381,375,376,377,378,380,379,382,335,354,355,356,357,358,359,360,362,370,364,363,365,366,369,367,368,353,371,361,332,322,323,324,325,326,331,327,330,328,329,333,321,536,537,541,542,543,547,546,548,549,550,551,553,552,554,555,556,557,593,573,558,582,583,581,580,577,584,585,586,587,588,579,589,576,578,590,591,592,540,539,538,199,200,201,198,65,66,68,69,70,71,72,73,74,67,166,75,155,158,159,160,161,162,163,164,165,235,234,237,232,236,233,337,339,193,195,194,648,644,646,647,191,157,560,649,652,650,653,654,655,656,667,666,651,668,405,406,404,407,408,409,410,411,412,413,414,415,416,669,156,76,77,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,78,126,94,95,96,127,97,98,99,100,101,102,103,104,105,106,107,108,110,109,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,670,671,672,613,300,299,673,698,699,674,677,696,697,687,686,684,679,692,690,694,678,691,695,680,681,693,675,682,683,685,689,700,688,676,713,712,707,709,708,701,702,704,706,710,711,703,705,715,714,716,459,717,718,618,617,403,399,398,401,400,402,130,657,469,464,465,467,466,468,481,480,479,471,478,470,477,482,483,486,484,485,472,487,473,476,474,475,544,545,215,218,216,217,177,174,176,175,173,183,178,182,179,181,180,169,170,171,167,168,172,658,662,664,663,661,665,452,454,453,559,660,659,57,64,59,60,61,62,63,58,8,10,9,2,11,12,13,14,15,16,17,18,3,4,22,19,20,21,23,24,25,5,26,27,28,29,6,33,30,31,32,34,7,35,40,41,36,37,38,39,1,42,638,640,639,456,457,458,417,519,517,460,490,520,642,462,461,511,512,518,463,488,489,513,521,641,514,516,515,56,186,185,187,184,189,197,196,188,192,214,212,213,211,205,206,207,208,210,204,209,394,393,386,391,390,392,387,388,389,202,220,222,223,221,219,567,566,572,561,565,564,568,571,569,570,562,563,616,615,614,225,227,226,224,395,397,396,47,48,49,50,51,52,43,53,54,55,44,45,46],"latestChangedDtsFile":"./types/index.d.ts"},"version":"4.9.5"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/AccountTrackerController.d.ts b/node_modules/@metamask/assets-controllers/dist/types/AccountTrackerController.d.ts
new file mode 100644
index 0000000..b3272df
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/types/AccountTrackerController.d.ts
@@ -0,0 +1,127 @@
+import type { BaseConfig, BaseState } from '@metamask/base-controller';
+import type { Provider } from '@metamask/eth-query';
+import type { NetworkClientId, NetworkController, NetworkState } from '@metamask/network-controller';
+import { StaticIntervalPollingControllerV1 } from '@metamask/polling-controller';
+import type { PreferencesState } from '@metamask/preferences-controller';
+/**
+ * @type AccountInformation
+ *
+ * Account information object
+ * @property balance - Hex string of an account balancec in wei
+ */
+export interface AccountInformation {
+    balance: string;
+}
+/**
+ * @type AccountTrackerConfig
+ *
+ * Account tracker controller configuration
+ * @property provider - Provider used to create a new underlying EthQuery instance
+ */
+export interface AccountTrackerConfig extends BaseConfig {
+    interval: number;
+    provider?: Provider;
+}
+/**
+ * @type AccountTrackerState
+ *
+ * Account tracker controller state
+ * @property accounts - Map of addresses to account information
+ */
+export interface AccountTrackerState extends BaseState {
+    accounts: {
+        [address: string]: AccountInformation;
+    };
+    accountsByChainId: Record<string, {
+        [address: string]: AccountInformation;
+    }>;
+}
+/**
+ * Controller that tracks the network balances for all user accounts.
+ */
+export declare class AccountTrackerController extends StaticIntervalPollingControllerV1<AccountTrackerConfig, AccountTrackerState> {
+    #private;
+    private _provider?;
+    private readonly refreshMutex;
+    private handle?;
+    private syncAccounts;
+    /**
+     * Name of this controller used during composition
+     */
+    name: string;
+    private readonly getIdentities;
+    private readonly getSelectedAddress;
+    private readonly getMultiAccountBalancesEnabled;
+    private readonly getCurrentChainId;
+    private readonly getNetworkClientById;
+    /**
+     * Creates an AccountTracker instance.
+     *
+     * @param options - The controller options.
+     * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.
+     * @param options.getIdentities - Gets the identities from the Preferences store.
+     * @param options.getSelectedAddress - Gets the selected address from the Preferences store.
+     * @param options.getMultiAccountBalancesEnabled - Gets the multi account balances enabled flag from the Preferences store.
+     * @param options.getCurrentChainId - Gets the chain ID for the current network from the Network store.
+     * @param options.getNetworkClientById - Gets the network client with the given id from the NetworkController.
+     * @param config - Initial options used to configure this controller.
+     * @param state - Initial state to set on this controller.
+     */
+    constructor({ onPreferencesStateChange, getIdentities, getSelectedAddress, getMultiAccountBalancesEnabled, getCurrentChainId, getNetworkClientById, }: {
+        onPreferencesStateChange: (listener: (preferencesState: PreferencesState) => void) => void;
+        getIdentities: () => PreferencesState['identities'];
+        getSelectedAddress: () => PreferencesState['selectedAddress'];
+        getMultiAccountBalancesEnabled: () => PreferencesState['isMultiAccountBalancesEnabled'];
+        getCurrentChainId: () => NetworkState['providerConfig']['chainId'];
+        getNetworkClientById: NetworkController['getNetworkClientById'];
+    }, config?: Partial<AccountTrackerConfig>, state?: Partial<AccountTrackerState>);
+    /**
+     * Sets a new provider.
+     *
+     * TODO: Replace this wth a method.
+     *
+     * @param provider - Provider used to create a new underlying EthQuery instance.
+     */
+    set provider(provider: Provider);
+    get provider(): Provider;
+    /**
+     * Starts a new polling interval.
+     *
+     * @param interval - Polling interval trigger a 'refresh'.
+     */
+    poll(interval?: number): Promise<void>;
+    /**
+     * Refreshes the balances of the accounts using the networkClientId
+     *
+     * @param networkClientId - The network client ID used to get balances.
+     */
+    _executePoll(networkClientId: string): Promise<void>;
+    /**
+     * Refreshes the balances of the accounts depending on the multi-account setting.
+     * If multi-account is disabled, only updates the selected account balance.
+     * If multi-account is enabled, updates balances for all accounts.
+     *
+     * @param networkClientId - Optional networkClientId to fetch a network client with
+     */
+    refresh: (networkClientId?: NetworkClientId) => Promise<void>;
+    /**
+     * Fetches the balance of a given address from the blockchain.
+     *
+     * @param address - The account address to fetch the balance for.
+     * @param ethQuery - The EthQuery instance to query getBalnce with.
+     * @returns A promise that resolves to the balance in a hex string format.
+     */
+    private getBalanceFromChain;
+    /**
+     * Sync accounts balances with some additional addresses.
+     *
+     * @param addresses - the additional addresses, may be hardware wallet addresses.
+     * @param networkClientId - Optional networkClientId to fetch a network client with.
+     * @returns accounts - addresses with synced balance
+     */
+    syncBalanceWithAddresses(addresses: string[], networkClientId?: NetworkClientId): Promise<Record<string, {
+        balance: string;
+    }>>;
+}
+export default AccountTrackerController;
+//# sourceMappingURL=AccountTrackerController.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/AccountTrackerController.d.ts.map b/node_modules/@metamask/assets-controllers/dist/types/AccountTrackerController.d.ts.map
new file mode 100644
index 0000000..02640ae
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/types/AccountTrackerController.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"AccountTrackerController.d.ts","sourceRoot":"","sources":["../../src/AccountTrackerController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/AssetsContractController.d.ts b/node_modules/@metamask/assets-controllers/dist/types/AssetsContractController.d.ts
new file mode 100644
index 0000000..978f283
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/types/AssetsContractController.d.ts
@@ -0,0 +1,239 @@
+import { Web3Provider } from '@ethersproject/providers';
+import type { BaseConfig, BaseState } from '@metamask/base-controller';
+import { BaseControllerV1 } from '@metamask/base-controller';
+import type { NetworkClientId, NetworkState, NetworkController, Provider } from '@metamask/network-controller';
+import type { PreferencesState } from '@metamask/preferences-controller';
+import type { Hex } from '@metamask/utils';
+import type BN from 'bn.js';
+import { ERC20Standard } from './Standards/ERC20Standard';
+import { ERC1155Standard } from './Standards/NftStandards/ERC1155/ERC1155Standard';
+import { ERC721Standard } from './Standards/NftStandards/ERC721/ERC721Standard';
+/**
+ * Check if token detection is enabled for certain networks
+ *
+ * @param chainId - ChainID of network
+ * @returns Whether the current network supports token detection
+ */
+export declare const SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID: Record<Hex, string>;
+export declare const MISSING_PROVIDER_ERROR = "AssetsContractController failed to set the provider correctly. A provider must be set for this method to be available";
+/**
+ * @type AssetsContractConfig
+ *
+ * Assets Contract controller configuration
+ * @property provider - Provider used to create a new web3 instance
+ */
+export interface AssetsContractConfig extends BaseConfig {
+    provider: Provider | undefined;
+    ipfsGateway: string;
+    chainId: Hex;
+}
+/**
+ * @type BalanceMap
+ *
+ * Key value object containing the balance for each tokenAddress
+ * @property [tokenAddress] - Address of the token
+ */
+export interface BalanceMap {
+    [tokenAddress: string]: BN;
+}
+/**
+ * Controller that interacts with contracts on mainnet through web3
+ */
+export declare class AssetsContractController extends BaseControllerV1<AssetsContractConfig, BaseState> {
+    private _provider?;
+    /**
+     * Name of this controller used during composition
+     */
+    name: string;
+    private readonly getNetworkClientById;
+    /**
+     * Creates a AssetsContractController instance.
+     *
+     * @param options - The controller options.
+     * @param options.chainId - The chain ID of the current network.
+     * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.
+     * @param options.onNetworkDidChange - Allows subscribing to network controller networkDidChange events.
+     * @param options.getNetworkClientById - Gets the network client with the given id from the NetworkController.
+     * @param config - Initial options used to configure this controller.
+     * @param state - Initial state to set on this controller.
+     */
+    constructor({ chainId: initialChainId, onPreferencesStateChange, onNetworkDidChange, getNetworkClientById, }: {
+        chainId: Hex;
+        onPreferencesStateChange: (listener: (preferencesState: PreferencesState) => void) => void;
+        onNetworkDidChange: (listener: (networkState: NetworkState) => void) => void;
+        getNetworkClientById: NetworkController['getNetworkClientById'];
+    }, config?: Partial<AssetsContractConfig>, state?: Partial<BaseState>);
+    /**
+     * Sets a new provider.
+     *
+     * TODO: Replace this wth a method.
+     *
+     * @property provider - Provider used to create a new underlying Web3 instance
+     */
+    set provider(provider: Provider);
+    get provider(): Provider;
+    /**
+     * Get the relevant provider instance.
+     *
+     * @param networkClientId - Network Client ID.
+     * @returns Web3Provider instance.
+     */
+    getProvider(networkClientId?: NetworkClientId): Web3Provider;
+    /**
+     * Get the relevant chain ID.
+     *
+     * @param networkClientId - Network Client ID used to get the provider.
+     * @returns Hex chain ID.
+     */
+    getChainId(networkClientId?: NetworkClientId): Hex;
+    /**
+     * Get a ERC20Standard instance using the relevant provider instance.
+     *
+     * @param networkClientId - Network Client ID used to get the provider.
+     * @returns ERC20Standard instance.
+     */
+    getERC20Standard(networkClientId?: NetworkClientId): ERC20Standard;
+    /**
+     * Get a ERC721Standard instance using the relevant provider instance.
+     *
+     * @param networkClientId - Network Client ID used to get the provider.
+     * @returns ERC721Standard instance.
+     */
+    getERC721Standard(networkClientId?: NetworkClientId): ERC721Standard;
+    /**
+     * Get a ERC1155Standard instance using the relevant provider instance.
+     *
+     * @param networkClientId - Network Client ID used to get the provider.
+     * @returns ERC1155Standard instance.
+     */
+    getERC1155Standard(networkClientId?: NetworkClientId): ERC1155Standard;
+    /**
+     * Get balance or count for current account on specific asset contract.
+     *
+     * @param address - Asset ERC20 contract address.
+     * @param selectedAddress - Current account public address.
+     * @param networkClientId - Network Client ID to fetch the provider with.
+     * @returns Promise resolving to BN object containing balance for current account on specific asset contract.
+     */
+    getERC20BalanceOf(address: string, selectedAddress: string, networkClientId?: NetworkClientId): Promise<BN>;
+    /**
+     * Query for the decimals for a given ERC20 asset.
+     *
+     * @param address - ERC20 asset contract address.
+     * @param networkClientId - Network Client ID to fetch the provider with.
+     * @returns Promise resolving to the 'decimals'.
+     */
+    getERC20TokenDecimals(address: string, networkClientId?: NetworkClientId): Promise<string>;
+    /**
+     * Query for the name for a given ERC20 asset.
+     *
+     * @param address - ERC20 asset contract address.
+     * @param networkClientId - Network Client ID to fetch the provider with.
+     * @returns Promise resolving to the 'decimals'.
+     */
+    getERC20TokenName(address: string, networkClientId?: NetworkClientId): Promise<string>;
+    /**
+     * Enumerate assets assigned to an owner.
+     *
+     * @param address - ERC721 asset contract address.
+     * @param selectedAddress - Current account public address.
+     * @param index - An NFT counter less than `balanceOf(selectedAddress)`.
+     * @param networkClientId - Network Client ID to fetch the provider with.
+     * @returns Promise resolving to token identifier for the 'index'th asset assigned to 'selectedAddress'.
+     */
+    getERC721NftTokenId(address: string, selectedAddress: string, index: number, networkClientId?: NetworkClientId): Promise<string>;
+    /**
+     * Enumerate assets assigned to an owner.
+     *
+     * @param tokenAddress - ERC721 asset contract address.
+     * @param userAddress - Current account public address.
+     * @param tokenId - ERC721 asset identifier.
+     * @param networkClientId - Network Client ID to fetch the provider with.
+     * @returns Promise resolving to an object containing the token standard and a set of details which depend on which standard the token supports.
+     */
+    getTokenStandardAndDetails(tokenAddress: string, userAddress?: string, tokenId?: string, networkClientId?: NetworkClientId): Promise<{
+        standard: string;
+        tokenURI?: string | undefined;
+        symbol?: string | undefined;
+        name?: string | undefined;
+        decimals?: string | undefined;
+        balance?: BN | undefined;
+    }>;
+    /**
+     * Query for tokenURI for a given ERC721 asset.
+     *
+     * @param address - ERC721 asset contract address.
+     * @param tokenId - ERC721 asset identifier.
+     * @param networkClientId - Network Client ID to fetch the provider with.
+     * @returns Promise resolving to the 'tokenURI'.
+     */
+    getERC721TokenURI(address: string, tokenId: string, networkClientId?: NetworkClientId): Promise<string>;
+    /**
+     * Query for name for a given asset.
+     *
+     * @param address - ERC721 or ERC20 asset contract address.
+     * @param networkClientId - Network Client ID to fetch the provider with.
+     * @returns Promise resolving to the 'name'.
+     */
+    getERC721AssetName(address: string, networkClientId?: NetworkClientId): Promise<string>;
+    /**
+     * Query for symbol for a given asset.
+     *
+     * @param address - ERC721 or ERC20 asset contract address.
+     * @param networkClientId - Network Client ID to fetch the provider with.
+     * @returns Promise resolving to the 'symbol'.
+     */
+    getERC721AssetSymbol(address: string, networkClientId?: NetworkClientId): Promise<string>;
+    /**
+     * Query for owner for a given ERC721 asset.
+     *
+     * @param address - ERC721 asset contract address.
+     * @param tokenId - ERC721 asset identifier.
+     * @param networkClientId - Network Client ID to fetch the provider with.
+     * @returns Promise resolving to the owner address.
+     */
+    getERC721OwnerOf(address: string, tokenId: string, networkClientId?: NetworkClientId): Promise<string>;
+    /**
+     * Query for tokenURI for a given asset.
+     *
+     * @param address - ERC1155 asset contract address.
+     * @param tokenId - ERC1155 asset identifier.
+     * @param networkClientId - Network Client ID to fetch the provider with.
+     * @returns Promise resolving to the 'tokenURI'.
+     */
+    getERC1155TokenURI(address: string, tokenId: string, networkClientId?: NetworkClientId): Promise<string>;
+    /**
+     * Query for balance of a given ERC 1155 token.
+     *
+     * @param userAddress - Wallet public address.
+     * @param nftAddress - ERC1155 asset contract address.
+     * @param nftId - ERC1155 asset identifier.
+     * @param networkClientId - Network Client ID to fetch the provider with.
+     * @returns Promise resolving to the 'balanceOf'.
+     */
+    getERC1155BalanceOf(userAddress: string, nftAddress: string, nftId: string, networkClientId?: NetworkClientId): Promise<BN>;
+    /**
+     * Transfer single ERC1155 token.
+     *
+     * @param nftAddress - ERC1155 token address.
+     * @param senderAddress - ERC1155 token sender.
+     * @param recipientAddress - ERC1155 token recipient.
+     * @param nftId - ERC1155 token id.
+     * @param qty - Quantity of tokens to be sent.
+     * @param networkClientId - Network Client ID to fetch the provider with.
+     * @returns Promise resolving to the 'transferSingle' ERC1155 token.
+     */
+    transferSingleERC1155(nftAddress: string, senderAddress: string, recipientAddress: string, nftId: string, qty: string, networkClientId?: NetworkClientId): Promise<void>;
+    /**
+     * Get the token balance for a list of token addresses in a single call. Only non-zero balances
+     * are returned.
+     *
+     * @param selectedAddress - The address to check token balances for.
+     * @param tokensToDetect - The token addresses to detect balances for.
+     * @param networkClientId - Network Client ID to fetch the provider with.
+     * @returns The list of non-zero token balances.
+     */
+    getBalancesInSingleCall(selectedAddress: string, tokensToDetect: string[], networkClientId?: NetworkClientId): Promise<BalanceMap>;
+}
+export default AssetsContractController;
+//# sourceMappingURL=AssetsContractController.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/AssetsContractController.d.ts.map b/node_modules/@metamask/assets-controllers/dist/types/AssetsContractController.d.ts.map
new file mode 100644
index 0000000..14cd545
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/types/AssetsContractController.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"AssetsContractController.d.ts","sourceRoot":"","sources":["../../src/AssetsContractController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/CurrencyRateController.d.ts b/node_modules/@metamask/assets-controllers/dist/types/CurrencyRateController.d.ts
new file mode 100644
index 0000000..6211f06
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/types/CurrencyRateController.d.ts
@@ -0,0 +1,80 @@
+import type { RestrictedControllerMessenger, ControllerGetStateAction, ControllerStateChangeEvent } from '@metamask/base-controller';
+import type { NetworkClientId, NetworkControllerGetNetworkClientByIdAction } from '@metamask/network-controller';
+import { StaticIntervalPollingController } from '@metamask/polling-controller';
+import { fetchExchangeRate as defaultFetchExchangeRate } from './crypto-compare';
+/**
+ * @type CurrencyRateState
+ * @property currencyRates - Object keyed by native currency
+ * @property currencyRates.conversionDate - Timestamp of conversion rate expressed in ms since UNIX epoch
+ * @property currencyRates.conversionRate - Conversion rate from current base asset to the current currency
+ * @property currentCurrency - Currently-active ISO 4217 currency code
+ * @property usdConversionRate - Conversion rate from usd to the current currency
+ */
+export type CurrencyRateState = {
+    currentCurrency: string;
+    currencyRates: Record<string, {
+        conversionDate: number | null;
+        conversionRate: number | null;
+        usdConversionRate: number | null;
+    }>;
+};
+declare const name = "CurrencyRateController";
+export type CurrencyRateStateChange = ControllerStateChangeEvent<typeof name, CurrencyRateState>;
+export type CurrencyRateControllerEvents = CurrencyRateStateChange;
+export type GetCurrencyRateState = ControllerGetStateAction<typeof name, CurrencyRateState>;
+export type CurrencyRateControllerActions = GetCurrencyRateState;
+type AllowedActions = NetworkControllerGetNetworkClientByIdAction;
+type CurrencyRateMessenger = RestrictedControllerMessenger<typeof name, CurrencyRateControllerActions | AllowedActions, CurrencyRateControllerEvents, AllowedActions['type'], never>;
+/**
+ * Controller that passively polls on a set interval for an exchange rate from the current network
+ * asset to the user's preferred currency.
+ */
+export declare class CurrencyRateController extends StaticIntervalPollingController<typeof name, CurrencyRateState, CurrencyRateMessenger> {
+    private readonly mutex;
+    private readonly fetchExchangeRate;
+    private readonly includeUsdRate;
+    /**
+     * Creates a CurrencyRateController instance.
+     *
+     * @param options - Constructor options.
+     * @param options.includeUsdRate - Keep track of the USD rate in addition to the current currency rate.
+     * @param options.interval - The polling interval, in milliseconds.
+     * @param options.messenger - A reference to the messaging system.
+     * @param options.state - Initial state to set on this controller.
+     * @param options.fetchExchangeRate - Fetches the exchange rate from an external API. This option is primarily meant for use in unit tests.
+     */
+    constructor({ includeUsdRate, interval, messenger, state, fetchExchangeRate, }: {
+        includeUsdRate?: boolean;
+        interval?: number;
+        messenger: CurrencyRateMessenger;
+        state?: Partial<CurrencyRateState>;
+        fetchExchangeRate?: typeof defaultFetchExchangeRate;
+    });
+    /**
+     * Sets a currency to track.
+     *
+     * @param currentCurrency - ISO 4217 currency code.
+     */
+    setCurrentCurrency(currentCurrency: string): Promise<void>;
+    /**
+     * Updates the exchange rate for the current currency and native currency pair.
+     *
+     * @param nativeCurrency - The ticker symbol for the chain.
+     */
+    updateExchangeRate(nativeCurrency: string): Promise<void>;
+    /**
+     * Prepare to discard this controller.
+     *
+     * This stops any active polling.
+     */
+    destroy(): void;
+    /**
+     * Updates exchange rate for the current currency.
+     *
+     * @param networkClientId - The network client ID used to get a ticker value.
+     * @returns The controller state.
+     */
+    _executePoll(networkClientId: NetworkClientId): Promise<void>;
+}
+export default CurrencyRateController;
+//# sourceMappingURL=CurrencyRateController.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/CurrencyRateController.d.ts.map b/node_modules/@metamask/assets-controllers/dist/types/CurrencyRateController.d.ts.map
new file mode 100644
index 0000000..8f00566
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/types/CurrencyRateController.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"CurrencyRateController.d.ts","sourceRoot":"","sources":["../../src/CurrencyRateController.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EACV,6BAA6B,EAC7B,wBAAwB,EACxB,0BAA0B,EAC3B,MAAM,2BAA2B,CAAC;AAKnC,OAAO,KAAK,EACV,eAAe,EACf,2CAA2C,EAC5C,MAAM,8BAA8B,CAAC;AACtC,OAAO,EAAE,+BAA+B,EAAE,MAAM,8BAA8B,CAAC;AAG/E,OAAO,EAAE,iBAAiB,IAAI,wBAAwB,EAAE,MAAM,kBAAkB,CAAC;AAEjF;;;;;;;GAOG;AACH,MAAM,MAAM,iBAAiB,GAAG;IAC9B,eAAe,EAAE,MAAM,CAAC;IACxB,aAAa,EAAE,MAAM,CACnB,MAAM,EACN;QACE,cAAc,EAAE,MAAM,GAAG,IAAI,CAAC;QAC9B,cAAc,EAAE,MAAM,GAAG,IAAI,CAAC;QAC9B,iBAAiB,EAAE,MAAM,GAAG,IAAI,CAAC;KAClC,CACF,CAAC;CACH,CAAC;AAEF,QAAA,MAAM,IAAI,2BAA2B,CAAC;AAEtC,MAAM,MAAM,uBAAuB,GAAG,0BAA0B,CAC9D,OAAO,IAAI,EACX,iBAAiB,CAClB,CAAC;AAEF,MAAM,MAAM,4BAA4B,GAAG,uBAAuB,CAAC;AAEnE,MAAM,MAAM,oBAAoB,GAAG,wBAAwB,CACzD,OAAO,IAAI,EACX,iBAAiB,CAClB,CAAC;AAEF,MAAM,MAAM,6BAA6B,GAAG,oBAAoB,CAAC;AAEjE,KAAK,cAAc,GAAG,2CAA2C,CAAC;AAElE,KAAK,qBAAqB,GAAG,6BAA6B,CACxD,OAAO,IAAI,EACX,6BAA6B,GAAG,cAAc,EAC9C,4BAA4B,EAC5B,cAAc,CAAC,MAAM,CAAC,EACtB,KAAK,CACN,CAAC;AAkBF;;;GAGG;AACH,qBAAa,sBAAuB,SAAQ,+BAA+B,CACzE,OAAO,IAAI,EACX,iBAAiB,EACjB,qBAAqB,CACtB;IACC,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAe;IAErC,OAAO,CAAC,QAAQ,CAAC,iBAAiB,CAAC;IAEnC,OAAO,CAAC,QAAQ,CAAC,cAAc,CAAC;IAEhC;;;;;;;;;OASG;gBACS,EACV,cAAsB,EACtB,QAAiB,EACjB,SAAS,EACT,KAAK,EACL,iBAA4C,GAC7C,EAAE;QACD,cAAc,CAAC,EAAE,OAAO,CAAC;QACzB,QAAQ,CAAC,EAAE,MAAM,CAAC;QAClB,SAAS,EAAE,qBAAqB,CAAC;QACjC,KAAK,CAAC,EAAE,OAAO,CAAC,iBAAiB,CAAC,CAAC;QACnC,iBAAiB,CAAC,EAAE,OAAO,wBAAwB,CAAC;KACrD;IAYD;;;;OAIG;IACG,kBAAkB,CAAC,eAAe,EAAE,MAAM;IAgBhD;;;;OAIG;IACG,kBAAkB,CAAC,cAAc,EAAE,MAAM,GAAG,OAAO,CAAC,IAAI,CAAC;IAgE/D;;;;OAIG;IACM,OAAO;IAKhB;;;;;OAKG;IACG,YAAY,CAAC,eAAe,EAAE,eAAe,GAAG,OAAO,CAAC,IAAI,CAAC;CAOpE;AAED,eAAe,sBAAsB,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/NftController.d.ts b/node_modules/@metamask/assets-controllers/dist/types/NftController.d.ts
new file mode 100644
index 0000000..1c74123
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/types/NftController.d.ts
@@ -0,0 +1,617 @@
+/// <reference types="node" />
+import type { AddApprovalRequest } from '@metamask/approval-controller';
+import type { BaseConfig, BaseState, RestrictedControllerMessenger } from '@metamask/base-controller';
+import { BaseControllerV1 } from '@metamask/base-controller';
+import type { NetworkClientId, NetworkController, NetworkState } from '@metamask/network-controller';
+import type { PreferencesState } from '@metamask/preferences-controller';
+import type { Hex } from '@metamask/utils';
+import { EventEmitter } from 'events';
+import type { AssetsContractController } from './AssetsContractController';
+import { Source } from './constants';
+import type { ApiNftCreator, ApiNftLastSale } from './NftDetectionController';
+type NFTStandardType = 'ERC721' | 'ERC1155';
+type SuggestedNftMeta = {
+    asset: {
+        address: string;
+        tokenId: string;
+    } & NftMetadata;
+    id: string;
+    time: number;
+    type: NFTStandardType;
+    interactingAddress: string;
+    origin: string;
+};
+export declare enum OpenSeaV2ChainIds {
+    ethereum = "ethereum"
+}
+export type OpenSeaV2GetNftResponse = {
+    nft: OpenSeaV2DetailedNft;
+};
+export type OpenSeaV2Nft = {
+    identifier: string;
+    collection: string;
+    contract: string;
+    token_standard: string;
+    name: string;
+    description: string;
+    image_url?: string;
+    metadata_url?: string;
+    updated_at: string;
+    is_disabled: boolean;
+    is_nsfw: boolean;
+};
+export type OpenSeaV2DetailedNft = OpenSeaV2Nft & {
+    animation_url?: string;
+    is_suspicious: boolean;
+    creator: string;
+    traits: {
+        trait_type: string;
+        display_type?: string;
+        max_value: string;
+        trait_count?: number;
+        value: number | string;
+    }[];
+    owners: {
+        address: string;
+        quantity: number;
+    }[];
+    rarity: {
+        rank: number;
+    };
+};
+export type OpenSeaV2ListNftsResponse = {
+    nfts: OpenSeaV2Nft[];
+    next?: string;
+};
+export type OpenSeaV2Contract = {
+    address: string;
+    chain: string;
+    collection: string;
+    contract_standard: string;
+    name: string;
+    total_supply?: number;
+};
+export type OpenSeaV2Collection = {
+    collection: string;
+    name: string;
+    description?: string;
+    image_url?: string;
+    owner: string;
+    category: string;
+    is_disabled: boolean;
+    is_nsfw: boolean;
+    trait_offers_enabled: boolean;
+    opensea_url: string;
+    project_url?: string;
+    wiki_url?: string;
+    discord_url?: string;
+    telegram_url?: string;
+    twitter_username?: string;
+    instagram_username?: string;
+    total_supply?: number;
+};
+/**
+ * @type Nft
+ *
+ * NFT representation
+ * @property address - Hex address of a ERC721 contract
+ * @property description - The NFT description
+ * @property image - URI of custom NFT image associated with this tokenId
+ * @property name - Name associated with this tokenId and contract address
+ * @property tokenId - The NFT identifier
+ * @property numberOfSales - Number of sales
+ * @property backgroundColor - The background color to be displayed with the item
+ * @property imagePreview - URI of a smaller image associated with this NFT
+ * @property imageThumbnail - URI of a thumbnail image associated with this NFT
+ * @property imageOriginal - URI of the original image associated with this NFT
+ * @property animation - URI of a animation associated with this NFT
+ * @property animationOriginal - URI of the original animation associated with this NFT
+ * @property externalLink - External link containing additional information
+ * @property creator - The NFT owner information object
+ * @property isCurrentlyOwned - Boolean indicating whether the address/chainId combination where it's currently stored currently owns this NFT
+ * @property transactionId - Transaction Id associated with the NFT
+ */
+export interface Nft extends NftMetadata {
+    tokenId: string;
+    address: string;
+    isCurrentlyOwned?: boolean;
+}
+/**
+ * @type NftContract
+ *
+ * NFT contract information representation
+ * @property name - Contract name
+ * @property logo - Contract logo
+ * @property address - Contract address
+ * @property symbol - Contract symbol
+ * @property description - Contract description
+ * @property totalSupply - Total supply of NFTs
+ * @property assetContractType - The NFT type, it could be `semi-fungible` or `non-fungible`
+ * @property createdDate - Creation date
+ * @property schemaName - The schema followed by the contract, it could be `ERC721` or `ERC1155`
+ * @property externalLink - External link containing additional information
+ */
+export interface NftContract {
+    name?: string;
+    logo?: string;
+    address: string;
+    symbol?: string;
+    description?: string;
+    totalSupply?: string;
+    assetContractType?: string;
+    createdDate?: string;
+    schemaName?: string;
+    externalLink?: string;
+}
+/**
+ * @type NftMetadata
+ *
+ * NFT custom information
+ * @property name - NFT custom name
+ * @property description - The NFT description
+ * @property numberOfSales - Number of sales
+ * @property backgroundColor - The background color to be displayed with the item
+ * @property image - Image custom image URI
+ * @property imagePreview - URI of a smaller image associated with this NFT
+ * @property imageThumbnail - URI of a thumbnail image associated with this NFT
+ * @property imageOriginal - URI of the original image associated with this NFT
+ * @property animation - URI of a animation associated with this NFT
+ * @property animationOriginal - URI of the original animation associated with this NFT
+ * @property externalLink - External link containing additional information
+ * @property creator - The NFT owner information object
+ * @property standard - NFT standard name for the NFT, e.g., ERC-721 or ERC-1155
+ */
+export interface NftMetadata {
+    name: string | null;
+    description: string | null;
+    image: string | null;
+    standard: string | null;
+    favorite?: boolean;
+    numberOfSales?: number;
+    backgroundColor?: string;
+    imagePreview?: string;
+    imageThumbnail?: string;
+    imageOriginal?: string;
+    animation?: string;
+    animationOriginal?: string;
+    externalLink?: string;
+    creator?: ApiNftCreator;
+    lastSale?: ApiNftLastSale;
+    transactionId?: string;
+    tokenURI?: string | null;
+}
+/**
+ * @type NftConfig
+ *
+ * NFT controller configuration
+ * @property selectedAddress - Vault selected address
+ */
+export interface NftConfig extends BaseConfig {
+    selectedAddress: string;
+    chainId: Hex;
+    ipfsGateway: string;
+    openSeaEnabled: boolean;
+    useIPFSSubdomains: boolean;
+    isIpfsGatewayEnabled: boolean;
+}
+/**
+ * @type NftState
+ *
+ * NFT controller state
+ * @property allNftContracts - Object containing NFT contract information
+ * @property allNfts - Object containing NFTs per account and network
+ * @property ignoredNfts - List of NFTs that should be ignored
+ */
+export interface NftState extends BaseState {
+    allNftContracts: {
+        [key: string]: {
+            [chainId: Hex]: NftContract[];
+        };
+    };
+    allNfts: {
+        [key: string]: {
+            [chainId: Hex]: Nft[];
+        };
+    };
+    ignoredNfts: Nft[];
+}
+interface NftAsset {
+    address: string;
+    tokenId: string;
+}
+/**
+ * The name of the {@link NftController}.
+ */
+declare const controllerName = "NftController";
+/**
+ * The external actions available to the {@link NftController}.
+ */
+type AllowedActions = AddApprovalRequest;
+/**
+ * The messenger of the {@link NftController}.
+ */
+export type NftControllerMessenger = RestrictedControllerMessenger<typeof controllerName, AllowedActions, never, AllowedActions['type'], never>;
+export declare const getDefaultNftState: () => NftState;
+/**
+ * Controller that stores assets and exposes convenience methods
+ */
+export declare class NftController extends BaseControllerV1<NftConfig, NftState> {
+    private readonly mutex;
+    private readonly messagingSystem;
+    getNftApi({ contractAddress, tokenId, }: {
+        contractAddress: string;
+        tokenId: string;
+    }): string;
+    private getNftContractInformationApi;
+    private getNftCollectionInformationApi;
+    /**
+     * Helper method to update nested state for allNfts and allNftContracts.
+     *
+     * @param newCollection - the modified piece of state to update in the controller's store
+     * @param baseStateKey - The root key in the store to update.
+     * @param passedConfig - An object containing the selectedAddress and chainId that are passed through the auto-detection flow.
+     * @param passedConfig.userAddress - the address passed through the NFT detection flow to ensure assets are stored to the correct account
+     * @param passedConfig.chainId - the chainId passed through the NFT detection flow to ensure assets are stored to the correct account
+     */
+    private updateNestedNftState;
+    /**
+     * Request individual NFT information from OpenSea API.
+     *
+     * @param contractAddress - Hex address of the NFT contract.
+     * @param tokenId - The NFT identifier.
+     * @returns Promise resolving to the current NFT name and image.
+     */
+    private getNftInformationFromApi;
+    /**
+     * Request individual NFT information from contracts that follows Metadata Interface.
+     *
+     * @param contractAddress - Hex address of the NFT contract.
+     * @param tokenId - The NFT identifier.
+     * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @returns Promise resolving to the current NFT name and image.
+     */
+    private getNftInformationFromTokenURI;
+    /**
+     * Retrieve NFT uri with  metadata. TODO Update method to use IPFS.
+     *
+     * @param contractAddress - NFT contract address.
+     * @param tokenId - NFT token id.
+     * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @returns Promise resolving NFT uri and token standard.
+     */
+    private getNftURIAndStandard;
+    /**
+     * Request individual NFT information (name, image url and description).
+     *
+     * @param contractAddress - Hex address of the NFT contract.
+     * @param tokenId - The NFT identifier.
+     * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @returns Promise resolving to the current NFT name and image.
+     */
+    private getNftInformation;
+    /**
+     * Request NFT contract information from OpenSea API.
+     *
+     * @param contractAddress - Hex address of the NFT contract.
+     * @returns Promise resolving to the current NFT name and image.
+     */
+    private getNftContractInformationFromApi;
+    /**
+     * Request NFT contract information from the contract itself.
+     *
+     * @param contractAddress - Hex address of the NFT contract.
+     * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @returns Promise resolving to the current NFT name and image.
+     */
+    private getNftContractInformationFromContract;
+    /**
+     * Request NFT contract information from OpenSea API.
+     *
+     * @param contractAddress - Hex address of the NFT contract.
+     * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @returns Promise resolving to the NFT contract name, image and description.
+     */
+    private getNftContractInformation;
+    /**
+     * Adds an individual NFT to the stored NFT list.
+     *
+     * @param tokenAddress - Hex address of the NFT contract.
+     * @param tokenId - The NFT identifier.
+     * @param nftMetadata - NFT optional information (name, image and description).
+     * @param nftContract - An object containing contract data of the NFT being added.
+     * @param chainId - The chainId of the network where the NFT is being added.
+     * @param userAddress - The address of the account where the NFT is being added.
+     * @param source - Whether the NFT was detected, added manually or suggested by a dapp.
+     * @returns Promise resolving to the current NFT list.
+     */
+    private addIndividualNft;
+    /**
+     * Adds an NFT contract to the stored NFT contracts list.
+     *
+     * @param options - options.
+     * @param options.tokenAddress - Hex address of the NFT contract.
+     * @param options.userAddress - The address of the account where the NFT is being added.
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.
+     * @returns Promise resolving to the current NFT contracts list.
+     */
+    private addNftContract;
+    /**
+     * Removes an individual NFT from the stored token list and saves it in ignored NFTs list.
+     *
+     * @param address - Hex address of the NFT contract.
+     * @param tokenId - Token identifier of the NFT.
+     * @param options - options.
+     * @param options.chainId - The chainId of the network where the NFT is being removed.
+     * @param options.userAddress - The address of the account where the NFT is being removed.
+     */
+    private removeAndIgnoreIndividualNft;
+    /**
+     * Removes an individual NFT from the stored token list.
+     *
+     * @param address - Hex address of the NFT contract.
+     * @param tokenId - Token identifier of the NFT.
+     * @param options - options.
+     * @param options.chainId - The chainId of the network where the NFT is being removed.
+     * @param options.userAddress - The address of the account where the NFT is being removed.
+     */
+    private removeIndividualNft;
+    /**
+     * Removes an NFT contract to the stored NFT contracts list.
+     *
+     * @param address - Hex address of the NFT contract.
+     * @param options - options.
+     * @param options.chainId - The chainId of the network where the NFT is being removed.
+     * @param options.userAddress - The address of the account where the NFT is being removed.
+     * @returns Promise resolving to the current NFT contracts list.
+     */
+    private removeNftContract;
+    /**
+     * EventEmitter instance used to listen to specific EIP747 events
+     */
+    hub: EventEmitter;
+    /**
+     * Optional API key to use with opensea
+     */
+    openSeaApiKey?: string;
+    /**
+     * Name of this controller used during composition
+     */
+    name: string;
+    private readonly getERC721AssetName;
+    private readonly getERC721AssetSymbol;
+    private readonly getERC721TokenURI;
+    private readonly getERC721OwnerOf;
+    private readonly getERC1155BalanceOf;
+    private readonly getERC1155TokenURI;
+    private readonly getNetworkClientById;
+    private readonly onNftAdded?;
+    /**
+     * Creates an NftController instance.
+     *
+     * @param options - The controller options.
+     * @param options.chainId - The chain ID of the current network.
+     * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.
+     * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.
+     * @param options.getERC721AssetName - Gets the name of the asset at the given address.
+     * @param options.getERC721AssetSymbol - Gets the symbol of the asset at the given address.
+     * @param options.getERC721TokenURI - Gets the URI of the ERC721 token at the given address, with the given ID.
+     * @param options.getERC721OwnerOf - Get the owner of a ERC-721 NFT.
+     * @param options.getERC1155BalanceOf - Gets balance of a ERC-1155 NFT.
+     * @param options.getERC1155TokenURI - Gets the URI of the ERC1155 token at the given address, with the given ID.
+     * @param options.getNetworkClientById - Gets the network client for the given networkClientId.
+     * @param options.onNftAdded - Callback that is called when an NFT is added. Currently used pass data
+     * for tracking the NFT added event.
+     * @param options.messenger - The controller messenger.
+     * @param config - Initial options used to configure this controller.
+     * @param state - Initial state to set on this controller.
+     */
+    constructor({ chainId: initialChainId, onPreferencesStateChange, onNetworkStateChange, getERC721AssetName, getERC721AssetSymbol, getERC721TokenURI, getERC721OwnerOf, getERC1155BalanceOf, getERC1155TokenURI, getNetworkClientById, onNftAdded, messenger, }: {
+        chainId: Hex;
+        onPreferencesStateChange: (listener: (preferencesState: PreferencesState) => void) => void;
+        onNetworkStateChange: (listener: (networkState: NetworkState) => void) => void;
+        getERC721AssetName: AssetsContractController['getERC721AssetName'];
+        getERC721AssetSymbol: AssetsContractController['getERC721AssetSymbol'];
+        getERC721TokenURI: AssetsContractController['getERC721TokenURI'];
+        getERC721OwnerOf: AssetsContractController['getERC721OwnerOf'];
+        getERC1155BalanceOf: AssetsContractController['getERC1155BalanceOf'];
+        getERC1155TokenURI: AssetsContractController['getERC1155TokenURI'];
+        getNetworkClientById: NetworkController['getNetworkClientById'];
+        onNftAdded?: (data: {
+            address: string;
+            symbol: string | undefined;
+            tokenId: string;
+            standard: string | null;
+            source: string;
+        }) => void;
+        messenger: NftControllerMessenger;
+    }, config?: Partial<BaseConfig>, state?: Partial<NftState>);
+    private validateWatchNft;
+    private getCorrectChainId;
+    /**
+     * Adds a new suggestedAsset to state. Parameters will be validated according to
+     * asset type being watched. A `<suggestedNftMeta.id>:pending` hub event will be emitted once added.
+     *
+     * @param asset - The asset to be watched. For now ERC721 and ERC1155 tokens are accepted.
+     * @param asset.address - The address of the asset contract.
+     * @param asset.tokenId - The ID of the asset.
+     * @param type - The asset type.
+     * @param origin - Domain origin to register the asset from.
+     * @param options - Options bag.
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @param options.userAddress - The address of the account where the NFT is being added.
+     * @returns Object containing a Promise resolving to the suggestedAsset address if accepted.
+     */
+    watchNft(asset: NftAsset, type: NFTStandardType, origin: string, { networkClientId, userAddress, }?: {
+        networkClientId?: NetworkClientId;
+        userAddress?: string;
+    }): Promise<void>;
+    /**
+     * Sets an OpenSea API key to retrieve NFT information.
+     *
+     * @param openSeaApiKey - OpenSea API key.
+     */
+    setApiKey(openSeaApiKey: string): void;
+    /**
+     * Checks the ownership of a ERC-721 or ERC-1155 NFT for a given address.
+     *
+     * @param ownerAddress - User public address.
+     * @param nftAddress - NFT contract address.
+     * @param tokenId - NFT token ID.
+     * @param options - Options bag.
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @returns Promise resolving the NFT ownership.
+     */
+    isNftOwner(ownerAddress: string, nftAddress: string, tokenId: string, { networkClientId, }?: {
+        networkClientId?: NetworkClientId;
+    }): Promise<boolean>;
+    /**
+     * Verifies currently selected address owns entered NFT address/tokenId combo and
+     * adds the NFT and respective NFT contract to the stored NFT and NFT contracts lists.
+     *
+     * @param address - Hex address of the NFT contract.
+     * @param tokenId - The NFT identifier.
+     * @param options - an object of arguments
+     * @param options.userAddress - The address of the current user.
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.
+     */
+    addNftVerifyOwnership(address: string, tokenId: string, { userAddress, networkClientId, source, }?: {
+        userAddress?: string;
+        networkClientId?: NetworkClientId;
+        source?: Source;
+    }): Promise<void>;
+    /**
+     * Adds an NFT and respective NFT contract to the stored NFT and NFT contracts lists.
+     *
+     * @param tokenAddress - Hex address of the NFT contract.
+     * @param tokenId - The NFT identifier.
+     * @param options - an object of arguments
+     * @param options.nftMetadata - NFT optional metadata.
+     * @param options.userAddress - The address of the current user.
+     * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @returns Promise resolving to the current NFT list.
+     */
+    addNft(tokenAddress: string, tokenId: string, { nftMetadata, userAddress, source, networkClientId, }?: {
+        nftMetadata?: NftMetadata;
+        userAddress?: string;
+        source?: Source;
+        networkClientId?: NetworkClientId;
+    }): Promise<void>;
+    /**
+     * Refetches NFT metadata and updates the state
+     *
+     * @param options - Options for refetching NFT metadata
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @param options.userAddress - The current user address
+     */
+    updateNftMetadata({ userAddress, networkClientId, }: {
+        userAddress?: string;
+        networkClientId?: NetworkClientId;
+    }): Promise<void>;
+    /**
+     * Removes an NFT from the stored token list.
+     *
+     * @param address - Hex address of the NFT contract.
+     * @param tokenId - Token identifier of the NFT.
+     * @param options - an object of arguments
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @param options.userAddress - The address of the account where the NFT is being removed.
+     */
+    removeNft(address: string, tokenId: string, { networkClientId, userAddress, }?: {
+        networkClientId?: NetworkClientId;
+        userAddress?: string;
+    }): void;
+    /**
+     * Removes an NFT from the stored token list and saves it in ignored NFTs list.
+     *
+     * @param address - Hex address of the NFT contract.
+     * @param tokenId - Token identifier of the NFT.
+     * @param options - an object of arguments
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @param options.userAddress - The address of the account where the NFT is being removed.
+     */
+    removeAndIgnoreNft(address: string, tokenId: string, { networkClientId, userAddress, }?: {
+        networkClientId?: NetworkClientId;
+        userAddress?: string;
+    }): void;
+    /**
+     * Removes all NFTs from the ignored list.
+     */
+    clearIgnoredNfts(): void;
+    /**
+     * Checks whether input NFT is still owned by the user
+     * And updates the isCurrentlyOwned value on the NFT object accordingly.
+     *
+     * @param nft - The NFT object to check and update.
+     * @param batch - A boolean indicating whether this method is being called as part of a batch or single update.
+     * @param accountParams - The userAddress and chainId to check ownership against
+     * @param accountParams.userAddress - the address passed through the confirmed transaction flow to ensure assets are stored to the correct account
+     * @param accountParams.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @returns the NFT with the updated isCurrentlyOwned value
+     */
+    checkAndUpdateSingleNftOwnershipStatus(nft: Nft, batch: boolean, { userAddress, networkClientId, }?: {
+        networkClientId?: NetworkClientId;
+        userAddress?: string;
+    }): Promise<Nft>;
+    /**
+     * Checks whether NFTs associated with current selectedAddress/chainId combination are still owned by the user
+     * And updates the isCurrentlyOwned value on each accordingly.
+     * @param options - an object of arguments
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @param options.userAddress - The address of the account where the NFT ownership status is checked/updated.
+     */
+    checkAndUpdateAllNftsOwnershipStatus({ networkClientId, userAddress, }?: {
+        networkClientId?: NetworkClientId;
+        userAddress?: string;
+    }): Promise<void>;
+    /**
+     * Update NFT favorite status.
+     *
+     * @param address - Hex address of the NFT contract.
+     * @param tokenId - Hex address of the NFT contract.
+     * @param favorite - NFT new favorite status.
+     * @param options - an object of arguments
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @param options.userAddress - The address of the account where the NFT is being removed.
+     */
+    updateNftFavoriteStatus(address: string, tokenId: string, favorite: boolean, { networkClientId, userAddress, }?: {
+        networkClientId?: NetworkClientId;
+        userAddress?: string;
+    }): void;
+    /**
+     * Returns an NFT by the address and token id.
+     *
+     * @param address - Hex address of the NFT contract.
+     * @param tokenId - Number that represents the id of the token.
+     * @param selectedAddress - Hex address of the user account.
+     * @param chainId - Id of the current network.
+     * @returns Object containing the NFT and its position in the array
+     */
+    findNftByAddressAndTokenId(address: string, tokenId: string, selectedAddress: string, chainId: Hex): {
+        nft: Nft;
+        index: number;
+    } | null;
+    /**
+     * Update NFT data.
+     *
+     * @param nft - NFT object to find the right NFT to updates.
+     * @param updates - NFT partial object to update properties of the NFT.
+     * @param selectedAddress - Hex address of the user account.
+     * @param chainId - Id of the current network.
+     */
+    updateNft(nft: Nft, updates: Partial<Nft>, selectedAddress: string, chainId: Hex): void;
+    /**
+     * Resets the transaction status of an NFT.
+     *
+     * @param transactionId - NFT transaction id.
+     * @param selectedAddress - Hex address of the user account.
+     * @param chainId - Id of the current network.
+     * @returns a boolean indicating if the reset was well succeeded or not
+     */
+    resetNftTransactionStatusByTransactionId(transactionId: string, selectedAddress: string, chainId: Hex): boolean;
+    _requestApproval(suggestedNftMeta: SuggestedNftMeta): Promise<unknown>;
+}
+export default NftController;
+//# sourceMappingURL=NftController.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/NftController.d.ts.map b/node_modules/@metamask/assets-controllers/dist/types/NftController.d.ts.map
new file mode 100644
index 0000000..a2c55a0
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/types/NftController.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"NftController.d.ts","sourceRoot":"","sources":["../../src/NftController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/NftDetectionController.d.ts b/node_modules/@metamask/assets-controllers/dist/types/NftDetectionController.d.ts
new file mode 100644
index 0000000..d5c60db
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/types/NftDetectionController.d.ts
@@ -0,0 +1,198 @@
+import type { BaseConfig, BaseState } from '@metamask/base-controller';
+import type { NetworkClientId, NetworkController, NetworkState, NetworkClient } from '@metamask/network-controller';
+import { StaticIntervalPollingControllerV1 } from '@metamask/polling-controller';
+import type { PreferencesState } from '@metamask/preferences-controller';
+import type { Hex } from '@metamask/utils';
+import { type NftController, type NftState } from './NftController';
+/**
+ * @type ApiNft
+ *
+ * NFT object coming from OpenSea api
+ * @property token_id - The NFT identifier
+ * @property num_sales - Number of sales
+ * @property background_color - The background color to be displayed with the item
+ * @property image_url - URI of an image associated with this NFT
+ * @property image_preview_url - URI of a smaller image associated with this NFT
+ * @property image_thumbnail_url - URI of a thumbnail image associated with this NFT
+ * @property image_original_url - URI of the original image associated with this NFT
+ * @property animation_url - URI of a animation associated with this NFT
+ * @property animation_original_url - URI of the original animation associated with this NFT
+ * @property name - The NFT name
+ * @property description - The NFT description
+ * @property external_link - External link containing additional information
+ * @property assetContract - The NFT contract information object
+ * @property creator - The NFT owner information object
+ * @property lastSale - When this item was last sold
+ */
+export interface ApiNft {
+    token_id: string;
+    num_sales: number | null;
+    background_color: string | null;
+    image_url: string | null;
+    image_preview_url: string | null;
+    image_thumbnail_url: string | null;
+    image_original_url: string | null;
+    animation_url: string | null;
+    animation_original_url: string | null;
+    name: string | null;
+    description: string | null;
+    external_link: string | null;
+    asset_contract: ApiNftContract;
+    creator: ApiNftCreator;
+    last_sale: ApiNftLastSale | null;
+}
+/**
+ * @type ApiNftContract
+ *
+ * NFT contract object coming from OpenSea api
+ * @property address - Address of the NFT contract
+ * @property asset_contract_type - The NFT type, it could be `semi-fungible` or `non-fungible`
+ * @property created_date - Creation date
+ * @property collection - Object containing the contract name and URI of an image associated
+ * @property schema_name - The schema followed by the contract, it could be `ERC721` or `ERC1155`
+ * @property symbol - The NFT contract symbol
+ * @property total_supply - Total supply of NFTs
+ * @property description - The NFT contract description
+ * @property external_link - External link containing additional information
+ */
+export interface ApiNftContract {
+    address: string;
+    asset_contract_type: string | null;
+    created_date: string | null;
+    schema_name: string | null;
+    symbol: string | null;
+    total_supply: string | null;
+    description: string | null;
+    external_link: string | null;
+    collection: {
+        name: string | null;
+        image_url?: string | null;
+    };
+}
+/**
+ * @type ApiNftLastSale
+ *
+ * NFT sale object coming from OpenSea api
+ * @property event_timestamp - Object containing a `username`
+ * @property total_price - URI of NFT image associated with this owner
+ * @property transaction - Object containing transaction_hash and block_hash
+ */
+export interface ApiNftLastSale {
+    event_timestamp: string;
+    total_price: string;
+    transaction: {
+        transaction_hash: string;
+        block_hash: string;
+    };
+}
+/**
+ * @type ApiNftCreator
+ *
+ * NFT creator object coming from OpenSea api
+ * @property user - Object containing a `username`
+ * @property profile_img_url - URI of NFT image associated with this owner
+ * @property address - The owner address
+ */
+export interface ApiNftCreator {
+    user: {
+        username: string;
+    };
+    profile_img_url: string;
+    address: string;
+}
+/**
+ * @type NftDetectionConfig
+ *
+ * NftDetection configuration
+ * @property interval - Polling interval used to fetch new token rates
+ * @property chainId - Current chain ID
+ * @property selectedAddress - Vault selected address
+ */
+export interface NftDetectionConfig extends BaseConfig {
+    interval: number;
+    chainId: Hex;
+    selectedAddress: string;
+}
+/**
+ * Controller that passively polls on a set interval for NFT auto detection
+ */
+export declare class NftDetectionController extends StaticIntervalPollingControllerV1<NftDetectionConfig, BaseState> {
+    private intervalId?;
+    private getOwnerNftApi;
+    private getOwnerNfts;
+    /**
+     * Name of this controller used during composition
+     */
+    name: string;
+    private readonly getOpenSeaApiKey;
+    private readonly addNft;
+    private readonly getNftApi;
+    private readonly getNftState;
+    private readonly getNetworkClientById;
+    /**
+     * Creates an NftDetectionController instance.
+     *
+     * @param options - The controller options.
+     * @param options.chainId - The chain ID of the current network.
+     * @param options.onNftsStateChange - Allows subscribing to assets controller state changes.
+     * @param options.onPreferencesStateChange - Allows subscribing to preferences controller state changes.
+     * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.
+     * @param options.getOpenSeaApiKey - Gets the OpenSea API key, if one is set.
+     * @param options.addNft - Add an NFT.
+     * @param options.getNftApi - Gets the URL to fetch an NFT from OpenSea.
+     * @param options.getNftState - Gets the current state of the Assets controller.
+     * @param options.getNetworkClientById - Gets the network client by ID, from the NetworkController.
+     * @param config - Initial options used to configure this controller.
+     * @param state - Initial state to set on this controller.
+     */
+    constructor({ chainId: initialChainId, getNetworkClientById, onPreferencesStateChange, onNetworkStateChange, getOpenSeaApiKey, addNft, getNftApi, getNftState, }: {
+        chainId: Hex;
+        getNetworkClientById: NetworkController['getNetworkClientById'];
+        onNftsStateChange: (listener: (nftsState: NftState) => void) => void;
+        onPreferencesStateChange: (listener: (preferencesState: PreferencesState) => void) => void;
+        onNetworkStateChange: (listener: (networkState: NetworkState) => void) => void;
+        getOpenSeaApiKey: () => string | undefined;
+        addNft: NftController['addNft'];
+        getNftApi: NftController['getNftApi'];
+        getNftState: () => NftState;
+    }, config?: Partial<NftDetectionConfig>, state?: Partial<BaseState>);
+    _executePoll(networkClientId: string, options: {
+        address: string;
+    }): Promise<void>;
+    /**
+     * Start polling for the currency rate.
+     */
+    start(): Promise<void>;
+    /**
+     * Stop polling for the currency rate.
+     */
+    stop(): void;
+    private stopPolling;
+    /**
+     * Starts a new polling interval.
+     *
+     * @param interval - An interval on which to poll.
+     */
+    private startPolling;
+    /**
+     * Checks whether network is mainnet or not.
+     *
+     * @returns Whether current network is mainnet.
+     */
+    isMainnet: () => boolean;
+    isMainnetByNetworkClientId: (networkClient: NetworkClient) => boolean;
+    /**
+     * Triggers asset ERC721 token auto detection on mainnet. Any newly detected NFTs are
+     * added.
+     *
+     * @param options - Options bag.
+     * @param options.networkClientId - The network client ID to detect NFTs on.
+     * @param options.userAddress - The address to detect NFTs for.
+     */
+    detectNfts({ networkClientId, userAddress, }?: {
+        networkClientId?: NetworkClientId;
+        userAddress: string;
+    }): Promise<void>;
+}
+export default NftDetectionController;
+//# sourceMappingURL=NftDetectionController.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/NftDetectionController.d.ts.map b/node_modules/@metamask/assets-controllers/dist/types/NftDetectionController.d.ts.map
new file mode 100644
index 0000000..7e7645a
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/types/NftDetectionController.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"NftDetectionController.d.ts","sourceRoot":"","sources":["../../src/NftDetectionController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/Standards/ERC20Standard.d.ts b/node_modules/@metamask/assets-controllers/dist/types/Standards/ERC20Standard.d.ts
new file mode 100644
index 0000000..781856a
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/types/Standards/ERC20Standard.d.ts
@@ -0,0 +1,49 @@
+import type { Web3Provider } from '@ethersproject/providers';
+import type BN from 'bn.js';
+export declare class ERC20Standard {
+    private readonly provider;
+    constructor(provider: Web3Provider);
+    /**
+     * Get balance or count for current account on specific asset contract.
+     *
+     * @param address - Asset ERC20 contract address.
+     * @param selectedAddress - Current account public address.
+     * @returns Promise resolving to BN object containing balance for current account on specific asset contract.
+     */
+    getBalanceOf(address: string, selectedAddress: string): Promise<BN>;
+    /**
+     * Query for the decimals for a given ERC20 asset.
+     *
+     * @param address - ERC20 asset contract string.
+     * @returns Promise resolving to the 'decimals'.
+     */
+    getTokenDecimals(address: string): Promise<string>;
+    /**
+     * Query for the name for a given ERC20 asset.
+     *
+     * @param address - ERC20 asset contract string.
+     * @returns Promise resolving to the 'name'.
+     */
+    getTokenName(address: string): Promise<string>;
+    /**
+     * Query for symbol for a given ERC20 asset.
+     *
+     * @param address - ERC20 asset contract address.
+     * @returns Promise resolving to the 'symbol'.
+     */
+    getTokenSymbol(address: string): Promise<string>;
+    /**
+     * Query if a contract implements an interface.
+     *
+     * @param address - Asset contract address.
+     * @param userAddress - The public address for the currently active user's account.
+     * @returns Promise resolving an object containing the standard, decimals, symbol and balance of the given contract/userAddress pair.
+     */
+    getDetails(address: string, userAddress?: string): Promise<{
+        standard: string;
+        symbol: string | undefined;
+        decimals: string | undefined;
+        balance: BN | undefined;
+    }>;
+}
+//# sourceMappingURL=ERC20Standard.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/Standards/ERC20Standard.d.ts.map b/node_modules/@metamask/assets-controllers/dist/types/Standards/ERC20Standard.d.ts.map
new file mode 100644
index 0000000..ef18e7d
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/types/Standards/ERC20Standard.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"ERC20Standard.d.ts","sourceRoot":"","sources":["../../../src/Standards/ERC20Standard.ts"],"names":[],"mappings":"AAEA,OAAO,KAAK,EAAE,YAAY,EAAE,MAAM,0BAA0B,CAAC;AAK7D,OAAO,KAAK,EAAE,MAAM,OAAO,CAAC;AAI5B,qBAAa,aAAa;IACxB,OAAO,CAAC,QAAQ,CAAC,QAAQ,CAAe;gBAE5B,QAAQ,EAAE,YAAY;IAIlC;;;;;;OAMG;IACG,YAAY,CAAC,OAAO,EAAE,MAAM,EAAE,eAAe,EAAE,MAAM,GAAG,OAAO,CAAC,EAAE,CAAC;IAMzE;;;;;OAKG;IACG,gBAAgB,CAAC,OAAO,EAAE,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;IAiBxD;;;;;OAKG;IACG,YAAY,CAAC,OAAO,EAAE,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;IAiBpD;;;;;OAKG;IACG,cAAc,CAAC,OAAO,EAAE,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;IA4BtD;;;;;;OAMG;IACG,UAAU,CACd,OAAO,EAAE,MAAM,EACf,WAAW,CAAC,EAAE,MAAM,GACnB,OAAO,CAAC;QACT,QAAQ,EAAE,MAAM,CAAC;QACjB,MAAM,EAAE,MAAM,GAAG,SAAS,CAAC;QAC3B,QAAQ,EAAE,MAAM,GAAG,SAAS,CAAC;QAC7B,OAAO,EAAE,EAAE,GAAG,SAAS,CAAC;KACzB,CAAC;CAaH"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/Standards/NftStandards/ERC1155/ERC1155Standard.d.ts b/node_modules/@metamask/assets-controllers/dist/types/Standards/NftStandards/ERC1155/ERC1155Standard.d.ts
new file mode 100644
index 0000000..3606153
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/types/Standards/NftStandards/ERC1155/ERC1155Standard.d.ts
@@ -0,0 +1,95 @@
+import type { Web3Provider } from '@ethersproject/providers';
+import type * as BN from 'bn.js';
+export declare class ERC1155Standard {
+    private readonly provider;
+    constructor(provider: Web3Provider);
+    /**
+     * Query if contract implements ERC1155 URI Metadata interface.
+     *
+     * @param address - ERC1155 asset contract address.
+     * @returns Promise resolving to whether the contract implements ERC1155 URI Metadata interface.
+     */
+    contractSupportsURIMetadataInterface(address: string): Promise<boolean>;
+    /**
+     * Query if contract implements ERC1155 Token Receiver interface.
+     *
+     * @param address - ERC1155 asset contract address.
+     * @returns Promise resolving to whether the contract implements ERC1155 Token Receiver interface.
+     */
+    contractSupportsTokenReceiverInterface(address: string): Promise<boolean>;
+    /**
+     * Query if contract implements ERC1155 interface.
+     *
+     * @param address - ERC1155 asset contract address.
+     * @returns Promise resolving to whether the contract implements the base ERC1155 interface.
+     */
+    contractSupportsBase1155Interface(address: string): Promise<boolean>;
+    /**
+     * Query for tokenURI for a given asset.
+     *
+     * @param address - ERC1155 asset contract address.
+     * @param tokenId - ERC1155 asset identifier.
+     * @returns Promise resolving to the 'tokenURI'.
+     */
+    getTokenURI(address: string, tokenId: string): Promise<string>;
+    /**
+     * Query for balance of a given ERC1155 token.
+     *
+     * @param contractAddress - ERC1155 asset contract address.
+     * @param address - Wallet public address.
+     * @param tokenId - ERC1155 asset identifier.
+     * @returns Promise resolving to the 'balanceOf'.
+     */
+    getBalanceOf(contractAddress: string, address: string, tokenId: string): Promise<BN>;
+    /**
+     * Transfer single ERC1155 token.
+     * When minting/creating tokens, the from arg MUST be set to 0x0 (i.e. zero address).
+     * When burning/destroying tokens, the to arg MUST be set to 0x0 (i.e. zero address).
+     *
+     * @param operator - ERC1155 token address.
+     * @param from - ERC1155 token holder.
+     * @param to - ERC1155 token recipient.
+     * @param id - ERC1155 token id.
+     * @param value - Number of tokens to be sent.
+     * @returns Promise resolving to the 'transferSingle'.
+     */
+    transferSingle(operator: string, from: string, to: string, id: string, value: string): Promise<void>;
+    /**
+     * Query for symbol for a given asset.
+     *
+     * @param address - ERC1155 asset contract address.
+     * @returns Promise resolving to the 'symbol'.
+     */
+    getAssetSymbol(address: string): Promise<string>;
+    /**
+     * Query for name for a given asset.
+     *
+     * @param address - ERC1155 asset contract address.
+     * @returns Promise resolving to the 'name'.
+     */
+    getAssetName(address: string): Promise<string>;
+    /**
+     * Query if a contract implements an interface.
+     *
+     * @param address - ERC1155 asset contract address.
+     * @param interfaceId - Interface identifier.
+     * @returns Promise resolving to whether the contract implements `interfaceID`.
+     */
+    private contractSupportsInterface;
+    /**
+     * Query if a contract implements an interface.
+     *
+     * @param address - Asset contract address.
+     * @param ipfsGateway - The user's preferred IPFS gateway.
+     * @param tokenId - tokenId of a given token in the contract.
+     * @returns Promise resolving an object containing the standard, tokenURI, symbol and name of the given contract/tokenId pair.
+     */
+    getDetails(address: string, ipfsGateway: string, tokenId?: string): Promise<{
+        standard: string;
+        tokenURI: string | undefined;
+        image: string | undefined;
+        name: string | undefined;
+        symbol: string | undefined;
+    }>;
+}
+//# sourceMappingURL=ERC1155Standard.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/Standards/NftStandards/ERC1155/ERC1155Standard.d.ts.map b/node_modules/@metamask/assets-controllers/dist/types/Standards/NftStandards/ERC1155/ERC1155Standard.d.ts.map
new file mode 100644
index 0000000..dd03fad
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/types/Standards/NftStandards/ERC1155/ERC1155Standard.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"ERC1155Standard.d.ts","sourceRoot":"","sources":["../../../../../src/Standards/NftStandards/ERC1155/ERC1155Standard.ts"],"names":[],"mappings":"AACA,OAAO,KAAK,EAAE,YAAY,EAAE,MAAM,0BAA0B,CAAC;AAU7D,OAAO,KAAK,KAAK,EAAE,MAAM,OAAO,CAAC;AAIjC,qBAAa,eAAe;IAC1B,OAAO,CAAC,QAAQ,CAAC,QAAQ,CAAe;gBAE5B,QAAQ,EAAE,YAAY;IAIlC;;;;;OAKG;IACG,oCAAoC,CACxC,OAAO,EAAE,MAAM,GACd,OAAO,CAAC,OAAO,CAAC;IAOnB;;;;;OAKG;IACG,sCAAsC,CAC1C,OAAO,EAAE,MAAM,GACd,OAAO,CAAC,OAAO,CAAC;IAOnB;;;;;OAKG;IACG,iCAAiC,CAAC,OAAO,EAAE,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC;IAI1E;;;;;;OAMG;IACG,WAAW,CAAC,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;IAKpE;;;;;;;OAOG;IACG,YAAY,CAChB,eAAe,EAAE,MAAM,EACvB,OAAO,EAAE,MAAM,EACf,OAAO,EAAE,MAAM,GACd,OAAO,CAAC,EAAE,CAAC;IAMd;;;;;;;;;;;OAWG;IACG,cAAc,CAClB,QAAQ,EAAE,MAAM,EAChB,IAAI,EAAE,MAAM,EACZ,EAAE,EAAE,MAAM,EACV,EAAE,EAAE,MAAM,EACV,KAAK,EAAE,MAAM,GACZ,OAAO,CAAC,IAAI,CAAC;IAqBhB;;;;;OAKG;IACG,cAAc,CAAC,OAAO,EAAE,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;IAmBtD;;;;;OAKG;IACG,YAAY,CAAC,OAAO,EAAE,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;IAmBpD;;;;;;OAMG;YACW,yBAAyB;IAQvC;;;;;;;OAOG;IACG,UAAU,CACd,OAAO,EAAE,MAAM,EACf,WAAW,EAAE,MAAM,EACnB,OAAO,CAAC,EAAE,MAAM,GACf,OAAO,CAAC;QACT,QAAQ,EAAE,MAAM,CAAC;QACjB,QAAQ,EAAE,MAAM,GAAG,SAAS,CAAC;QAC7B,KAAK,EAAE,MAAM,GAAG,SAAS,CAAC;QAC1B,IAAI,EAAE,MAAM,GAAG,SAAS,CAAC;QACzB,MAAM,EAAE,MAAM,GAAG,SAAS,CAAC;KAC5B,CAAC;CA8CH"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/Standards/NftStandards/ERC721/ERC721Standard.d.ts b/node_modules/@metamask/assets-controllers/dist/types/Standards/NftStandards/ERC721/ERC721Standard.d.ts
new file mode 100644
index 0000000..22ef482
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/types/Standards/NftStandards/ERC721/ERC721Standard.d.ts
@@ -0,0 +1,89 @@
+import type { Web3Provider } from '@ethersproject/providers';
+export declare class ERC721Standard {
+    private readonly provider;
+    constructor(provider: Web3Provider);
+    /**
+     * Query if contract implements ERC721Metadata interface.
+     *
+     * @param address - ERC721 asset contract address.
+     * @returns Promise resolving to whether the contract implements ERC721Metadata interface.
+     */
+    contractSupportsMetadataInterface: (address: string) => Promise<boolean>;
+    /**
+     * Query if contract implements ERC721Enumerable interface.
+     *
+     * @param address - ERC721 asset contract address.
+     * @returns Promise resolving to whether the contract implements ERC721Enumerable interface.
+     */
+    contractSupportsEnumerableInterface: (address: string) => Promise<boolean>;
+    /**
+     * Query if contract implements ERC721 interface.
+     *
+     * @param address - ERC721 asset contract address.
+     * @returns Promise resolving to whether the contract implements ERC721 interface.
+     */
+    contractSupportsBase721Interface: (address: string) => Promise<boolean>;
+    /**
+     * Enumerate assets assigned to an owner.
+     *
+     * @param address - ERC721 asset contract address.
+     * @param selectedAddress - Current account public address.
+     * @param index - An NFT counter less than `balanceOf(selectedAddress)`.
+     * @returns Promise resolving to token identifier for the 'index'th asset assigned to 'selectedAddress'.
+     */
+    getNftTokenId: (address: string, selectedAddress: string, index: number) => Promise<string>;
+    /**
+     * Query for tokenURI for a given asset.
+     *
+     * @param address - ERC721 asset contract address.
+     * @param tokenId - ERC721 asset identifier.
+     * @returns Promise resolving to the 'tokenURI'.
+     */
+    getTokenURI: (address: string, tokenId: string) => Promise<string>;
+    /**
+     * Query for name for a given asset.
+     *
+     * @param address - ERC721 asset contract address.
+     * @returns Promise resolving to the 'name'.
+     */
+    getAssetName: (address: string) => Promise<string>;
+    /**
+     * Query for symbol for a given asset.
+     *
+     * @param address - ERC721 asset contract address.
+     * @returns Promise resolving to the 'symbol'.
+     */
+    getAssetSymbol: (address: string) => Promise<string>;
+    /**
+     * Query for owner for a given ERC721 asset.
+     *
+     * @param address - ERC721 asset contract address.
+     * @param tokenId - ERC721 asset identifier.
+     * @returns Promise resolving to the owner address.
+     */
+    getOwnerOf(address: string, tokenId: string): Promise<string>;
+    /**
+     * Query if a contract implements an interface.
+     *
+     * @param address - Asset contract address.
+     * @param interfaceId - Interface identifier.
+     * @returns Promise resolving to whether the contract implements `interfaceID`.
+     */
+    private readonly contractSupportsInterface;
+    /**
+     * Query if a contract implements an interface.
+     *
+     * @param address - Asset contract address.
+     * @param ipfsGateway - The user's preferred IPFS gateway.
+     * @param tokenId - tokenId of a given token in the contract.
+     * @returns Promise resolving an object containing the standard, tokenURI, symbol and name of the given contract/tokenId pair.
+     */
+    getDetails: (address: string, ipfsGateway: string, tokenId?: string) => Promise<{
+        standard: string;
+        tokenURI: string | undefined;
+        symbol: string | undefined;
+        name: string | undefined;
+        image: string | undefined;
+    }>;
+}
+//# sourceMappingURL=ERC721Standard.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/Standards/NftStandards/ERC721/ERC721Standard.d.ts.map b/node_modules/@metamask/assets-controllers/dist/types/Standards/NftStandards/ERC721/ERC721Standard.d.ts.map
new file mode 100644
index 0000000..80fe3c0
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/types/Standards/NftStandards/ERC721/ERC721Standard.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"ERC721Standard.d.ts","sourceRoot":"","sources":["../../../../../src/Standards/NftStandards/ERC721/ERC721Standard.ts"],"names":[],"mappings":"AACA,OAAO,KAAK,EAAE,YAAY,EAAE,MAAM,0BAA0B,CAAC;AAa7D,qBAAa,cAAc;IACzB,OAAO,CAAC,QAAQ,CAAC,QAAQ,CAAe;gBAE5B,QAAQ,EAAE,YAAY;IAIlC;;;;;OAKG;IACH,iCAAiC,YACtB,MAAM,KACd,QAAQ,OAAO,CAAC,CAKjB;IAEF;;;;;OAKG;IACH,mCAAmC,YACxB,MAAM,KACd,QAAQ,OAAO,CAAC,CAKjB;IAEF;;;;;OAKG;IACH,gCAAgC,YACrB,MAAM,KACd,QAAQ,OAAO,CAAC,CAEjB;IAEF;;;;;;;OAOG;IACH,aAAa,YACF,MAAM,mBACE,MAAM,SAChB,MAAM,KACZ,QAAQ,MAAM,CAAC,CAGhB;IAEF;;;;;;OAMG;IACH,WAAW,YAAmB,MAAM,WAAW,MAAM,KAAG,QAAQ,MAAM,CAAC,CASrE;IAEF;;;;;OAKG;IACH,YAAY,YAAmB,MAAM,KAAG,QAAQ,MAAM,CAAC,CAGrD;IAEF;;;;;OAKG;IACH,cAAc,YAAmB,MAAM,KAAG,QAAQ,MAAM,CAAC,CAGvD;IAEF;;;;;;OAMG;IACG,UAAU,CAAC,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;IAKnE;;;;;;OAMG;IACH,OAAO,CAAC,QAAQ,CAAC,yBAAyB,CAiBxC;IAEF;;;;;;;OAOG;IACH,UAAU,YACC,MAAM,eACF,MAAM,YACT,MAAM;kBAEN,MAAM;kBACN,MAAM,GAAG,SAAS;gBACpB,MAAM,GAAG,SAAS;cACpB,MAAM,GAAG,SAAS;eACjB,MAAM,GAAG,SAAS;OA0CzB;CACH"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/TokenBalancesController.d.ts b/node_modules/@metamask/assets-controllers/dist/types/TokenBalancesController.d.ts
new file mode 100644
index 0000000..52bb3ac
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/types/TokenBalancesController.d.ts
@@ -0,0 +1,84 @@
+import { type RestrictedControllerMessenger, type ControllerGetStateAction, type ControllerStateChangeEvent, BaseController } from '@metamask/base-controller';
+import type { PreferencesControllerGetStateAction } from '@metamask/preferences-controller';
+import type { AssetsContractController } from './AssetsContractController';
+import type { Token } from './TokenRatesController';
+import type { TokensControllerStateChangeEvent } from './TokensController';
+declare const controllerName = "TokenBalancesController";
+/**
+ * Token balances controller options
+ * @property interval - Polling interval used to fetch new token balances.
+ * @property tokens - List of tokens to track balances for.
+ * @property disabled - If set to true, all tracked tokens contract balances updates are blocked.
+ * @property getERC20BalanceOf - Gets the balance of the given account at the given contract address.
+ */
+type TokenBalancesControllerOptions = {
+    interval?: number;
+    tokens?: Token[];
+    disabled?: boolean;
+    getERC20BalanceOf: AssetsContractController['getERC20BalanceOf'];
+    messenger: TokenBalancesControllerMessenger;
+    state?: Partial<TokenBalancesControllerState>;
+};
+/**
+ * Represents a mapping of hash token contract addresses to their balances.
+ */
+type ContractBalances = Record<string, string>;
+/**
+ * Token balances controller state
+ * @property contractBalances - Hash of token contract addresses to balances
+ */
+export type TokenBalancesControllerState = {
+    contractBalances: ContractBalances;
+};
+export type TokenBalancesControllerGetStateAction = ControllerGetStateAction<typeof controllerName, TokenBalancesControllerState>;
+export type TokenBalancesControllerActions = TokenBalancesControllerGetStateAction;
+export type AllowedActions = PreferencesControllerGetStateAction;
+export type TokenBalancesControllerStateChangeEvent = ControllerStateChangeEvent<typeof controllerName, TokenBalancesControllerState>;
+export type TokenBalancesControllerEvents = TokenBalancesControllerStateChangeEvent;
+export type AllowedEvents = TokensControllerStateChangeEvent;
+export type TokenBalancesControllerMessenger = RestrictedControllerMessenger<typeof controllerName, TokenBalancesControllerActions | AllowedActions, TokenBalancesControllerEvents | AllowedEvents, AllowedActions['type'], AllowedEvents['type']>;
+/**
+ * Get the default TokenBalancesController state.
+ *
+ * @returns The default TokenBalancesController state.
+ */
+export declare function getDefaultTokenBalancesState(): TokenBalancesControllerState;
+/**
+ * Controller that passively polls on a set interval token balances
+ * for tokens stored in the TokensController
+ */
+export declare class TokenBalancesController extends BaseController<typeof controllerName, TokenBalancesControllerState, TokenBalancesControllerMessenger> {
+    #private;
+    /**
+     * Construct a Token Balances Controller.
+     *
+     * @param options - The controller options.
+     * @param options.interval - Polling interval used to fetch new token balances.
+     * @param options.tokens - List of tokens to track balances for.
+     * @param options.disabled - If set to true, all tracked tokens contract balances updates are blocked.
+     * @param options.getERC20BalanceOf - Gets the balance of the given account at the given contract address.
+     * @param options.state - Initial state to set on this controller.
+     * @param options.messenger - The controller restricted messenger.
+     */
+    constructor({ interval, tokens, disabled, getERC20BalanceOf, messenger, state, }: TokenBalancesControllerOptions);
+    /**
+     * Allows controller to update tracked tokens contract balances.
+     */
+    enable(): void;
+    /**
+     * Blocks controller from updating tracked tokens contract balances.
+     */
+    disable(): void;
+    /**
+     * Starts a new polling interval.
+     *
+     * @param interval - Polling interval used to fetch new token balances.
+     */
+    poll(interval?: number): Promise<void>;
+    /**
+     * Updates balances for all tokens.
+     */
+    updateBalances(): Promise<void>;
+}
+export default TokenBalancesController;
+//# sourceMappingURL=TokenBalancesController.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/TokenBalancesController.d.ts.map b/node_modules/@metamask/assets-controllers/dist/types/TokenBalancesController.d.ts.map
new file mode 100644
index 0000000..0fbf42b
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/types/TokenBalancesController.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"TokenBalancesController.d.ts","sourceRoot":"","sources":["../../src/TokenBalancesController.ts"],"names":[],"mappings":"AAAA,OAAO,EACL,KAAK,6BAA6B,EAClC,KAAK,wBAAwB,EAC7B,KAAK,0BAA0B,EAC/B,cAAc,EACf,MAAM,2BAA2B,CAAC;AAEnC,OAAO,KAAK,EAAE,mCAAmC,EAAE,MAAM,kCAAkC,CAAC;AAE5F,OAAO,KAAK,EAAE,wBAAwB,EAAE,MAAM,4BAA4B,CAAC;AAC3E,OAAO,KAAK,EAAE,KAAK,EAAE,MAAM,wBAAwB,CAAC;AACpD,OAAO,KAAK,EAAE,gCAAgC,EAAE,MAAM,oBAAoB,CAAC;AAI3E,QAAA,MAAM,cAAc,4BAA4B,CAAC;AAMjD;;;;;;GAMG;AACH,KAAK,8BAA8B,GAAG;IACpC,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,MAAM,CAAC,EAAE,KAAK,EAAE,CAAC;IACjB,QAAQ,CAAC,EAAE,OAAO,CAAC;IACnB,iBAAiB,EAAE,wBAAwB,CAAC,mBAAmB,CAAC,CAAC;IACjE,SAAS,EAAE,gCAAgC,CAAC;IAC5C,KAAK,CAAC,EAAE,OAAO,CAAC,4BAA4B,CAAC,CAAC;CAC/C,CAAC;AAEF;;GAEG;AACH,KAAK,gBAAgB,GAAG,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;AAE/C;;;GAGG;AACH,MAAM,MAAM,4BAA4B,GAAG;IACzC,gBAAgB,EAAE,gBAAgB,CAAC;CACpC,CAAC;AAEF,MAAM,MAAM,qCAAqC,GAAG,wBAAwB,CAC1E,OAAO,cAAc,EACrB,4BAA4B,CAC7B,CAAC;AAEF,MAAM,MAAM,8BAA8B,GACxC,qCAAqC,CAAC;AAExC,MAAM,MAAM,cAAc,GAAG,mCAAmC,CAAC;AAEjE,MAAM,MAAM,uCAAuC,GACjD,0BAA0B,CACxB,OAAO,cAAc,EACrB,4BAA4B,CAC7B,CAAC;AAEJ,MAAM,MAAM,6BAA6B,GACvC,uCAAuC,CAAC;AAE1C,MAAM,MAAM,aAAa,GAAG,gCAAgC,CAAC;AAE7D,MAAM,MAAM,gCAAgC,GAAG,6BAA6B,CAC1E,OAAO,cAAc,EACrB,8BAA8B,GAAG,cAAc,EAC/C,6BAA6B,GAAG,aAAa,EAC7C,cAAc,CAAC,MAAM,CAAC,EACtB,aAAa,CAAC,MAAM,CAAC,CACtB,CAAC;AAEF;;;;GAIG;AACH,wBAAgB,4BAA4B,IAAI,4BAA4B,CAI3E;AAED;;;GAGG;AACH,qBAAa,uBAAwB,SAAQ,cAAc,CACzD,OAAO,cAAc,EACrB,4BAA4B,EAC5B,gCAAgC,CACjC;;IAWC;;;;;;;;;;OAUG;gBACS,EACV,QAA2B,EAC3B,MAAW,EACX,QAAgB,EAChB,iBAAiB,EACjB,SAAS,EACT,KAAU,GACX,EAAE,8BAA8B;IA4BjC;;OAEG;IACH,MAAM;IAIN;;OAEG;IACH,OAAO;IAIP;;;;OAIG;IACG,IAAI,CAAC,QAAQ,CAAC,EAAE,MAAM,GAAG,OAAO,CAAC,IAAI,CAAC;IAgB5C;;OAEG;IACG,cAAc;CA0BrB;AAED,eAAe,uBAAuB,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/TokenDetectionController.d.ts b/node_modules/@metamask/assets-controllers/dist/types/TokenDetectionController.d.ts
new file mode 100644
index 0000000..220d78d
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/types/TokenDetectionController.d.ts
@@ -0,0 +1,111 @@
+import type { AccountsControllerGetSelectedAccountAction, AccountsControllerSelectedAccountChangeEvent } from '@metamask/accounts-controller';
+import type { RestrictedControllerMessenger, ControllerGetStateAction, ControllerStateChangeEvent } from '@metamask/base-controller';
+import type { KeyringControllerGetStateAction, KeyringControllerLockEvent, KeyringControllerUnlockEvent } from '@metamask/keyring-controller';
+import type { NetworkClientId, NetworkControllerGetNetworkClientByIdAction, NetworkControllerGetNetworkConfigurationByNetworkClientId, NetworkControllerGetStateAction, NetworkControllerNetworkDidChangeEvent } from '@metamask/network-controller';
+import { StaticIntervalPollingController } from '@metamask/polling-controller';
+import type { PreferencesControllerGetStateAction, PreferencesControllerStateChangeEvent } from '@metamask/preferences-controller';
+import type { AssetsContractController } from './AssetsContractController';
+import type { GetTokenListState, TokenListMap, TokenListStateChange } from './TokenListController';
+import type { TokensControllerAddDetectedTokensAction, TokensControllerGetStateAction } from './TokensController';
+/**
+ * Compare 2 given strings and return boolean
+ * eg: "foo" and "FOO" => true
+ * eg: "foo" and "bar" => false
+ * eg: "foo" and 123 => false
+ *
+ * @param value1 - first string to compare
+ * @param value2 - first string to compare
+ * @returns true if 2 strings are identical when they are lowercase
+ */
+export declare function isEqualCaseInsensitive(value1: string, value2: string): boolean;
+type TokenDetectionMap = {
+    [P in keyof TokenListMap]: Omit<TokenListMap[P], 'occurrences'>;
+};
+export declare const STATIC_MAINNET_TOKEN_LIST: TokenDetectionMap;
+export declare const controllerName = "TokenDetectionController";
+export type TokenDetectionState = Record<never, never>;
+export type TokenDetectionControllerGetStateAction = ControllerGetStateAction<typeof controllerName, TokenDetectionState>;
+export type TokenDetectionControllerActions = TokenDetectionControllerGetStateAction;
+export type AllowedActions = AccountsControllerGetSelectedAccountAction | NetworkControllerGetNetworkClientByIdAction | NetworkControllerGetNetworkConfigurationByNetworkClientId | NetworkControllerGetStateAction | GetTokenListState | KeyringControllerGetStateAction | PreferencesControllerGetStateAction | TokensControllerGetStateAction | TokensControllerAddDetectedTokensAction;
+export type TokenDetectionControllerStateChangeEvent = ControllerStateChangeEvent<typeof controllerName, TokenDetectionState>;
+export type TokenDetectionControllerEvents = TokenDetectionControllerStateChangeEvent;
+export type AllowedEvents = AccountsControllerSelectedAccountChangeEvent | NetworkControllerNetworkDidChangeEvent | TokenListStateChange | KeyringControllerLockEvent | KeyringControllerUnlockEvent | PreferencesControllerStateChangeEvent;
+export type TokenDetectionControllerMessenger = RestrictedControllerMessenger<typeof controllerName, TokenDetectionControllerActions | AllowedActions, TokenDetectionControllerEvents | AllowedEvents, AllowedActions['type'], AllowedEvents['type']>;
+/**
+ * Controller that passively polls on a set interval for Tokens auto detection
+ * @property intervalId - Polling interval used to fetch new token rates
+ * @property selectedAddress - Vault selected address
+ * @property networkClientId - The network client ID of the current selected network
+ * @property disabled - Boolean to track if network requests are blocked
+ * @property isUnlocked - Boolean to track if the keyring state is unlocked
+ * @property isDetectionEnabledFromPreferences - Boolean to track if detection is enabled from PreferencesController
+ * @property isDetectionEnabledForNetwork - Boolean to track if detected is enabled for current network
+ */
+export declare class TokenDetectionController extends StaticIntervalPollingController<typeof controllerName, TokenDetectionState, TokenDetectionControllerMessenger> {
+    #private;
+    /**
+     * Creates a TokenDetectionController instance.
+     *
+     * @param options - The controller options.
+     * @param options.messenger - The controller messaging system.
+     * @param options.disabled - If set to true, all network requests are blocked.
+     * @param options.interval - Polling interval used to fetch new token rates
+     * @param options.selectedAddress - Vault selected address
+     * @param options.getBalancesInSingleCall - Gets the balances of a list of tokens for the given address.
+     * @param options.trackMetaMetricsEvent - Sets options for MetaMetrics event tracking.
+     */
+    constructor({ selectedAddress, interval, disabled, getBalancesInSingleCall, trackMetaMetricsEvent, messenger, }: {
+        selectedAddress?: string;
+        interval?: number;
+        disabled?: boolean;
+        getBalancesInSingleCall: AssetsContractController['getBalancesInSingleCall'];
+        trackMetaMetricsEvent: (options: {
+            event: string;
+            category: string;
+            properties: {
+                tokens: string[];
+                token_standard: string;
+                asset_type: string;
+            };
+        }) => void;
+        messenger: TokenDetectionControllerMessenger;
+    });
+    /**
+     * Allows controller to make active and passive polling requests
+     */
+    enable(): void;
+    /**
+     * Blocks controller from making network calls
+     */
+    disable(): void;
+    /**
+     * Internal isActive state
+     * @type {boolean}
+     */
+    get isActive(): boolean;
+    /**
+     * Start polling for detected tokens.
+     */
+    start(): Promise<void>;
+    /**
+     * Stop polling for detected tokens.
+     */
+    stop(): void;
+    _executePoll(networkClientId: NetworkClientId, options: {
+        address: string;
+    }): Promise<void>;
+    /**
+     * For each token in the token list provided by the TokenListController, checks the token's balance for the selected account address on the active network.
+     * On mainnet, if token detection is disabled in preferences, ERC20 token auto detection will be triggered for each contract address in the legacy token list from the @metamask/contract-metadata repo.
+     *
+     * @param options - Options for token detection.
+     * @param options.networkClientId - The ID of the network client to use.
+     * @param options.selectedAddress - the selectedAddress against which to detect for token balances.
+     */
+    detectTokens({ networkClientId, selectedAddress, }?: {
+        networkClientId?: NetworkClientId;
+        selectedAddress?: string;
+    }): Promise<void>;
+}
+export default TokenDetectionController;
+//# sourceMappingURL=TokenDetectionController.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/TokenDetectionController.d.ts.map b/node_modules/@metamask/assets-controllers/dist/types/TokenDetectionController.d.ts.map
new file mode 100644
index 0000000..db12470
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/types/TokenDetectionController.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"TokenDetectionController.d.ts","sourceRoot":"","sources":["../../src/TokenDetectionController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/TokenListController.d.ts b/node_modules/@metamask/assets-controllers/dist/types/TokenListController.d.ts
new file mode 100644
index 0000000..4809923
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/types/TokenListController.d.ts
@@ -0,0 +1,117 @@
+import type { ControllerGetStateAction, ControllerStateChangeEvent, RestrictedControllerMessenger } from '@metamask/base-controller';
+import type { NetworkClientId, NetworkControllerStateChangeEvent, NetworkState, NetworkControllerGetNetworkClientByIdAction } from '@metamask/network-controller';
+import { StaticIntervalPollingController } from '@metamask/polling-controller';
+import type { Hex } from '@metamask/utils';
+declare const name = "TokenListController";
+export type TokenListToken = {
+    name: string;
+    symbol: string;
+    decimals: number;
+    address: string;
+    occurrences: number;
+    aggregators: string[];
+    iconUrl: string;
+};
+export type TokenListMap = Record<string, TokenListToken>;
+type DataCache = {
+    timestamp: number;
+    data: TokenListMap;
+};
+type TokensChainsCache = {
+    [chainId: Hex]: DataCache;
+};
+export type TokenListState = {
+    tokenList: TokenListMap;
+    tokensChainsCache: TokensChainsCache;
+    preventPollingOnNetworkRestart: boolean;
+};
+export type TokenListStateChange = ControllerStateChangeEvent<typeof name, TokenListState>;
+export type TokenListControllerEvents = TokenListStateChange;
+export type GetTokenListState = ControllerGetStateAction<typeof name, TokenListState>;
+export type TokenListControllerActions = GetTokenListState;
+type AllowedActions = NetworkControllerGetNetworkClientByIdAction;
+type AllowedEvents = NetworkControllerStateChangeEvent;
+export type TokenListControllerMessenger = RestrictedControllerMessenger<typeof name, TokenListControllerActions | AllowedActions, TokenListControllerEvents | AllowedEvents, AllowedActions['type'], AllowedEvents['type']>;
+export declare const getDefaultTokenListState: () => TokenListState;
+/**
+ * Controller that passively polls on a set interval for the list of tokens from metaswaps api
+ */
+export declare class TokenListController extends StaticIntervalPollingController<typeof name, TokenListState, TokenListControllerMessenger> {
+    #private;
+    private readonly mutex;
+    private intervalId?;
+    private readonly intervalDelay;
+    private readonly cacheRefreshThreshold;
+    private chainId;
+    private abortController;
+    /**
+     * Creates a TokenListController instance.
+     *
+     * @param options - The controller options.
+     * @param options.chainId - The chain ID of the current network.
+     * @param options.onNetworkStateChange - A function for registering an event handler for network state changes.
+     * @param options.interval - The polling interval, in milliseconds.
+     * @param options.cacheRefreshThreshold - The token cache expiry time, in milliseconds.
+     * @param options.messenger - A restricted controller messenger.
+     * @param options.state - Initial state to set on this controller.
+     * @param options.preventPollingOnNetworkRestart - Determines whether to prevent poilling on network restart in extension.
+     */
+    constructor({ chainId, preventPollingOnNetworkRestart, onNetworkStateChange, interval, cacheRefreshThreshold, messenger, state, }: {
+        chainId: Hex;
+        preventPollingOnNetworkRestart?: boolean;
+        onNetworkStateChange?: (listener: (networkState: NetworkState) => void) => void;
+        interval?: number;
+        cacheRefreshThreshold?: number;
+        messenger: TokenListControllerMessenger;
+        state?: Partial<TokenListState>;
+    });
+    /**
+     * Start polling for the token list.
+     */
+    start(): Promise<void>;
+    /**
+     * Restart polling for the token list.
+     */
+    restart(): Promise<void>;
+    /**
+     * Stop polling for the token list.
+     */
+    stop(): void;
+    /**
+     * Prepare to discard this controller.
+     *
+     * This stops any active polling.
+     */
+    destroy(): void;
+    private stopPolling;
+    /**
+     * Starts a new polling interval.
+     */
+    private startPolling;
+    /**
+     * Fetching token list from the Token Service API.
+     *
+     * @private
+     * @param networkClientId - The ID of the network client triggering the fetch.
+     * @returns A promise that resolves when this operation completes.
+     */
+    _executePoll(networkClientId: string): Promise<void>;
+    /**
+     * Fetching token list from the Token Service API.
+     *
+     * @param networkClientId - The ID of the network client triggering the fetch.
+     */
+    fetchTokenList(networkClientId?: NetworkClientId): Promise<void>;
+    /**
+     * Clearing tokenList and tokensChainsCache explicitly.
+     */
+    clearingTokenListData(): void;
+    /**
+     * Updates preventPollingOnNetworkRestart from extension.
+     *
+     * @param shouldPreventPolling - Determine whether to prevent polling on network change
+     */
+    updatePreventPollingOnNetworkRestart(shouldPreventPolling: boolean): void;
+}
+export default TokenListController;
+//# sourceMappingURL=TokenListController.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/TokenListController.d.ts.map b/node_modules/@metamask/assets-controllers/dist/types/TokenListController.d.ts.map
new file mode 100644
index 0000000..94f80e4
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/types/TokenListController.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"TokenListController.d.ts","sourceRoot":"","sources":["../../src/TokenListController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/TokenRatesController.d.ts b/node_modules/@metamask/assets-controllers/dist/types/TokenRatesController.d.ts
new file mode 100644
index 0000000..8f35b5b
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/types/TokenRatesController.d.ts
@@ -0,0 +1,141 @@
+import type { BaseConfig, BaseState } from '@metamask/base-controller';
+import type { NetworkClientId, NetworkController, NetworkState } from '@metamask/network-controller';
+import { StaticIntervalPollingControllerV1 } from '@metamask/polling-controller';
+import type { PreferencesState } from '@metamask/preferences-controller';
+import { type Hex } from '@metamask/utils';
+import type { AbstractTokenPricesService } from './token-prices-service/abstract-token-prices-service';
+import type { TokensState } from './TokensController';
+/**
+ * @type Token
+ *
+ * Token representation
+ * @property address - Hex address of the token contract
+ * @property decimals - Number of decimals the token uses
+ * @property symbol - Symbol of the token
+ * @property image - Image of the token, url or bit32 image
+ */
+export interface Token {
+    address: string;
+    decimals: number;
+    symbol: string;
+    aggregators?: string[];
+    image?: string;
+    balanceError?: unknown;
+    isERC721?: boolean;
+    name?: string;
+}
+/**
+ * @type TokenRatesConfig
+ *
+ * Token rates controller configuration
+ * @property interval - Polling interval used to fetch new token rates
+ * @property nativeCurrency - Current native currency selected to use base of rates
+ * @property chainId - Current network chainId
+ * @property tokens - List of tokens to track exchange rates for
+ * @property threshold - Threshold to invalidate the supportedChains
+ */
+export interface TokenRatesConfig extends BaseConfig {
+    interval: number;
+    nativeCurrency: string;
+    chainId: Hex;
+    selectedAddress: string;
+    allTokens: {
+        [chainId: Hex]: {
+            [key: string]: Token[];
+        };
+    };
+    allDetectedTokens: {
+        [chainId: Hex]: {
+            [key: string]: Token[];
+        };
+    };
+    threshold: number;
+}
+export interface ContractExchangeRates {
+    [address: string]: number | undefined;
+}
+/**
+ * @type TokenRatesState
+ *
+ * Token rates controller state
+ * @property contractExchangeRates - Hash of token contract addresses to exchange rates (single globally selected chain, will be deprecated soon)
+ * @property contractExchangeRatesByChainId - Hash of token contract addresses to exchange rates keyed by chain ID and native currency (ticker)
+ */
+export interface TokenRatesState extends BaseState {
+    contractExchangeRates: ContractExchangeRates;
+    contractExchangeRatesByChainId: Record<Hex, Record<string, ContractExchangeRates>>;
+}
+/**
+ * Controller that passively polls on a set interval for token-to-fiat exchange rates
+ * for tokens stored in the TokensController
+ */
+export declare class TokenRatesController extends StaticIntervalPollingControllerV1<TokenRatesConfig, TokenRatesState> {
+    #private;
+    private handle?;
+    /**
+     * Name of this controller used during composition
+     */
+    name: string;
+    private readonly getNetworkClientById;
+    /**
+     * Creates a TokenRatesController instance.
+     *
+     * @param options - The controller options.
+     * @param options.interval - The polling interval in ms
+     * @param options.threshold - The duration in ms before metadata fetched from CoinGecko is considered stale
+     * @param options.getNetworkClientById - Gets the network client with the given id from the NetworkController.
+     * @param options.chainId - The chain ID of the current network.
+     * @param options.ticker - The ticker for the current network.
+     * @param options.selectedAddress - The current selected address.
+     * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.
+     * @param options.onTokensStateChange - Allows subscribing to token controller state changes.
+     * @param options.onNetworkStateChange - Allows subscribing to network state changes.
+     * @param options.tokenPricesService - An object in charge of retrieving token prices.
+     * @param config - Initial options used to configure this controller.
+     * @param state - Initial state to set on this controller.
+     */
+    constructor({ interval, threshold, getNetworkClientById, chainId: initialChainId, ticker: initialTicker, selectedAddress: initialSelectedAddress, onPreferencesStateChange, onTokensStateChange, onNetworkStateChange, tokenPricesService, }: {
+        interval?: number;
+        threshold?: number;
+        getNetworkClientById: NetworkController['getNetworkClientById'];
+        chainId: Hex;
+        ticker: string;
+        selectedAddress: string;
+        onPreferencesStateChange: (listener: (preferencesState: PreferencesState) => void) => void;
+        onTokensStateChange: (listener: (tokensState: TokensState) => void) => void;
+        onNetworkStateChange: (listener: (networkState: NetworkState) => void) => void;
+        tokenPricesService: AbstractTokenPricesService;
+    }, config?: Partial<TokenRatesConfig>, state?: Partial<TokenRatesState>);
+    /**
+     * Start (or restart) polling.
+     */
+    start(): Promise<void>;
+    /**
+     * Stop polling.
+     */
+    stop(): void;
+    /**
+     * Updates exchange rates for all tokens.
+     */
+    updateExchangeRates(): Promise<void>;
+    /**
+     * Updates exchange rates for all tokens.
+     *
+     * @param options - The options to fetch exchange rates.
+     * @param options.chainId - The chain ID.
+     * @param options.nativeCurrency - The ticker for the chain.
+     */
+    updateExchangeRatesByChainId({ chainId, nativeCurrency, }: {
+        chainId: Hex;
+        nativeCurrency: string;
+    }): Promise<void>;
+    /**
+     * Updates token rates for the given networkClientId
+     *
+     * @param networkClientId - The network client ID used to get a ticker value.
+     * @returns The controller state.
+     */
+    _executePoll(networkClientId: NetworkClientId): Promise<void>;
+}
+export default TokenRatesController;
+//# sourceMappingURL=TokenRatesController.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/TokenRatesController.d.ts.map b/node_modules/@metamask/assets-controllers/dist/types/TokenRatesController.d.ts.map
new file mode 100644
index 0000000..d0eae3c
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/types/TokenRatesController.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"TokenRatesController.d.ts","sourceRoot":"","sources":["../../src/TokenRatesController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/TokensController.d.ts b/node_modules/@metamask/assets-controllers/dist/types/TokensController.d.ts
new file mode 100644
index 0000000..76e3aaf
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/types/TokensController.d.ts
@@ -0,0 +1,271 @@
+/// <reference types="node" />
+import { Contract } from '@ethersproject/contracts';
+import { Web3Provider } from '@ethersproject/providers';
+import type { AddApprovalRequest } from '@metamask/approval-controller';
+import type { BaseConfig, BaseState, RestrictedControllerMessenger } from '@metamask/base-controller';
+import { BaseControllerV1 } from '@metamask/base-controller';
+import type { NetworkClientId, NetworkControllerGetNetworkClientByIdAction, NetworkControllerNetworkDidChangeEvent, Provider } from '@metamask/network-controller';
+import type { PreferencesControllerStateChangeEvent } from '@metamask/preferences-controller';
+import type { Hex } from '@metamask/utils';
+import { EventEmitter } from 'events';
+import type { Patch } from 'immer/dist/immer';
+import type { TokenListStateChange } from './TokenListController';
+import type { Token } from './TokenRatesController';
+/**
+ * @type TokensConfig
+ *
+ * Tokens controller configuration
+ * @property selectedAddress - Vault selected address
+ */
+export interface TokensConfig extends BaseConfig {
+    selectedAddress: string;
+    chainId: Hex;
+    provider: Provider | undefined;
+}
+/**
+ * @type SuggestedAssetMeta
+ *
+ * Suggested asset by EIP747 meta data
+ * @property id - Generated UUID associated with this suggested asset
+ * @property time - Timestamp associated with this this suggested asset
+ * @property type - Type type this suggested asset
+ * @property asset - Asset suggested object
+ * @property interactingAddress - Account address that requested watch asset
+ */
+type SuggestedAssetMeta = {
+    id: string;
+    time: number;
+    type: string;
+    asset: Token;
+    interactingAddress: string;
+};
+/**
+ * @type TokensState
+ *
+ * Assets controller state
+ * @property tokens - List of tokens associated with the active network and address pair
+ * @property ignoredTokens - List of ignoredTokens associated with the active network and address pair
+ * @property detectedTokens - List of detected tokens associated with the active network and address pair
+ * @property allTokens - Object containing tokens by network and account
+ * @property allIgnoredTokens - Object containing hidden/ignored tokens by network and account
+ * @property allDetectedTokens - Object containing tokens detected with non-zero balances
+ */
+export type TokensState = {
+    tokens: Token[];
+    ignoredTokens: string[];
+    detectedTokens: Token[];
+    allTokens: {
+        [chainId: Hex]: {
+            [key: string]: Token[];
+        };
+    };
+    allIgnoredTokens: {
+        [chainId: Hex]: {
+            [key: string]: string[];
+        };
+    };
+    allDetectedTokens: {
+        [chainId: Hex]: {
+            [key: string]: Token[];
+        };
+    };
+};
+/**
+ * The name of the {@link TokensController}.
+ */
+declare const controllerName = "TokensController";
+export type TokensControllerActions = TokensControllerGetStateAction | TokensControllerAddDetectedTokensAction;
+export type TokensControllerGetStateAction = {
+    type: `${typeof controllerName}:getState`;
+    handler: () => TokensState;
+};
+export type TokensControllerAddDetectedTokensAction = {
+    type: `${typeof controllerName}:addDetectedTokens`;
+    handler: TokensController['addDetectedTokens'];
+};
+/**
+ * The external actions available to the {@link TokensController}.
+ */
+export type AllowedActions = AddApprovalRequest | NetworkControllerGetNetworkClientByIdAction;
+export type TokensControllerStateChangeEvent = {
+    type: `${typeof controllerName}:stateChange`;
+    payload: [TokensState, Patch[]];
+};
+export type TokensControllerEvents = TokensControllerStateChangeEvent;
+export type AllowedEvents = NetworkControllerNetworkDidChangeEvent | PreferencesControllerStateChangeEvent | TokenListStateChange;
+/**
+ * The messenger of the {@link TokensController}.
+ */
+export type TokensControllerMessenger = RestrictedControllerMessenger<typeof controllerName, TokensControllerActions | AllowedActions, TokensControllerEvents | AllowedEvents, AllowedActions['type'], AllowedEvents['type']>;
+export declare const getDefaultTokensState: () => TokensState;
+/**
+ * Controller that stores assets and exposes convenience methods
+ */
+export declare class TokensController extends BaseControllerV1<TokensConfig, TokensState & BaseState> {
+    private readonly mutex;
+    private abortController;
+    private readonly messagingSystem;
+    /**
+     * Fetch metadata for a token.
+     *
+     * @param tokenAddress - The address of the token.
+     * @returns The token metadata.
+     */
+    private fetchTokenMetadata;
+    /**
+     * EventEmitter instance used to listen to specific EIP747 events
+     */
+    hub: EventEmitter;
+    /**
+     * Name of this controller used during composition
+     */
+    name: string;
+    /**
+     * Creates a TokensController instance.
+     *
+     * @param options - The controller options.
+     * @param options.chainId - The chain ID of the current network.
+     * @param options.config - Initial options used to configure this controller.
+     * @param options.state - Initial state to set on this controller.
+     * @param options.messenger - The controller messenger.
+     */
+    constructor({ chainId: initialChainId, config, state, messenger, }: {
+        chainId: Hex;
+        config?: Partial<TokensConfig>;
+        state?: Partial<TokensState>;
+        messenger: TokensControllerMessenger;
+    });
+    /**
+     * Adds a token to the stored token list.
+     *
+     * @param options - The method argument object.
+     * @param options.address - Hex address of the token contract.
+     * @param options.symbol - Symbol of the token.
+     * @param options.decimals - Number of decimals the token uses.
+     * @param options.name - Name of the token.
+     * @param options.image - Image of the token.
+     * @param options.interactingAddress - The address of the account to add a token to.
+     * @param options.networkClientId - Network Client ID.
+     * @returns Current token list.
+     */
+    addToken({ address, symbol, decimals, name, image, interactingAddress, networkClientId, }: {
+        address: string;
+        symbol: string;
+        decimals: number;
+        name?: string;
+        image?: string;
+        interactingAddress?: string;
+        networkClientId?: NetworkClientId;
+    }): Promise<Token[]>;
+    /**
+     * Add a batch of tokens.
+     *
+     * @param tokensToImport - Array of tokens to import.
+     * @param networkClientId - Optional network client ID used to determine interacting chain ID.
+     */
+    addTokens(tokensToImport: Token[], networkClientId?: NetworkClientId): Promise<void>;
+    /**
+     * Ignore a batch of tokens.
+     *
+     * @param tokenAddressesToIgnore - Array of token addresses to ignore.
+     */
+    ignoreTokens(tokenAddressesToIgnore: string[]): void;
+    /**
+     * Adds a batch of detected tokens to the stored token list.
+     *
+     * @param incomingDetectedTokens - Array of detected tokens to be added or updated.
+     * @param detectionDetails - An object containing the chain ID and address of the currently selected network on which the incomingDetectedTokens were detected.
+     * @param detectionDetails.selectedAddress - the account address on which the incomingDetectedTokens were detected.
+     * @param detectionDetails.chainId - the chainId on which the incomingDetectedTokens were detected.
+     */
+    addDetectedTokens(incomingDetectedTokens: Token[], detectionDetails?: {
+        selectedAddress: string;
+        chainId: Hex;
+    }): Promise<void>;
+    /**
+     * Adds isERC721 field to token object. This is called when a user attempts to add tokens that
+     * were previously added which do not yet had isERC721 field.
+     *
+     * @param tokenAddress - The contract address of the token requiring the isERC721 field added.
+     * @returns The new token object with the added isERC721 field.
+     */
+    updateTokenType(tokenAddress: string): Promise<Token>;
+    /**
+     * This is a function that updates the tokens name for the tokens name if it is not defined.
+     *
+     * @param tokenList - Represents the fetched token list from service API
+     * @param tokenAttribute - Represents the token attribute that we want to update on the token list
+     */
+    private updateTokensAttribute;
+    /**
+     * Detects whether or not a token is ERC-721 compatible.
+     *
+     * @param tokenAddress - The token contract address.
+     * @param networkClientId - Optional network client ID to fetch contract info with.
+     * @returns A boolean indicating whether the token address passed in supports the EIP-721
+     * interface.
+     */
+    _detectIsERC721(tokenAddress: string, networkClientId?: NetworkClientId): Promise<any>;
+    _getProvider(networkClientId?: NetworkClientId): Web3Provider;
+    _createEthersContract(tokenAddress: string, abi: string, networkClientId?: NetworkClientId): Contract;
+    _generateRandomId(): string;
+    /**
+     * Adds a new suggestedAsset to the list of watched assets.
+     * Parameters will be validated according to the asset type being watched.
+     *
+     * @param options - The method options.
+     * @param options.asset - The asset to be watched. For now only ERC20 tokens are accepted.
+     * @param options.type - The asset type.
+     * @param options.interactingAddress - The address of the account that is requesting to watch the asset.
+     * @param options.networkClientId - Network Client ID.
+     * @returns A promise that resolves if the asset was watched successfully, and rejects otherwise.
+     */
+    watchAsset({ asset, type, interactingAddress, networkClientId, }: {
+        asset: Token;
+        type: string;
+        interactingAddress?: string;
+        networkClientId?: NetworkClientId;
+    }): Promise<void>;
+    /**
+     * Takes a new tokens and ignoredTokens array for the current network/account combination
+     * and returns new allTokens and allIgnoredTokens state to update to.
+     *
+     * @param params - Object that holds token params.
+     * @param params.newTokens - The new tokens to set for the current network and selected account.
+     * @param params.newIgnoredTokens - The new ignored tokens to set for the current network and selected account.
+     * @param params.newDetectedTokens - The new detected tokens to set for the current network and selected account.
+     * @param params.interactingAddress - The account address to use to store the tokens.
+     * @param params.interactingChainId - The chainId to use to store the tokens.
+     * @returns The updated `allTokens` and `allIgnoredTokens` state.
+     */
+    _getNewAllTokensState(params: {
+        newTokens?: Token[];
+        newIgnoredTokens?: string[];
+        newDetectedTokens?: Token[];
+        interactingAddress?: string;
+        interactingChainId?: Hex;
+    }): {
+        newAllTokens: {
+            [chainId: `0x${string}`]: {
+                [key: string]: Token[];
+            };
+        };
+        newAllIgnoredTokens: {
+            [chainId: `0x${string}`]: {
+                [key: string]: string[];
+            };
+        };
+        newAllDetectedTokens: {
+            [chainId: `0x${string}`]: {
+                [key: string]: Token[];
+            };
+        };
+    };
+    /**
+     * Removes all tokens from the ignored list.
+     */
+    clearIgnoredTokens(): void;
+    _requestApproval(suggestedAssetMeta: SuggestedAssetMeta): Promise<unknown>;
+}
+export default TokensController;
+//# sourceMappingURL=TokensController.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/TokensController.d.ts.map b/node_modules/@metamask/assets-controllers/dist/types/TokensController.d.ts.map
new file mode 100644
index 0000000..5b08f62
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/types/TokensController.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"TokensController.d.ts","sourceRoot":"","sources":["../../src/TokensController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/assetsUtil.d.ts b/node_modules/@metamask/assets-controllers/dist/types/assetsUtil.d.ts
new file mode 100644
index 0000000..85c8569
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/types/assetsUtil.d.ts
@@ -0,0 +1,183 @@
+import type { BigNumber } from '@ethersproject/bignumber';
+import type { Hex } from '@metamask/utils';
+import BN from 'bn.js';
+import type { Nft, NftMetadata, OpenSeaV2Collection, OpenSeaV2Contract, OpenSeaV2DetailedNft, OpenSeaV2Nft } from './NftController';
+import type { ApiNft, ApiNftContract } from './NftDetectionController';
+import type { AbstractTokenPricesService } from './token-prices-service';
+import { type ContractExchangeRates } from './TokenRatesController';
+/**
+ * The maximum number of token addresses that should be sent to the Price API in
+ * a single request.
+ */
+export declare const TOKEN_PRICES_BATCH_SIZE = 30;
+/**
+ * Compares nft metadata entries to any nft entry.
+ * We need this method when comparing a new fetched nft metadata, in case a entry changed to a defined value,
+ * there's a need to update the nft in state.
+ *
+ * @param newNftMetadata - Nft metadata object.
+ * @param nft - Nft object to compare with.
+ * @returns Whether there are differences.
+ */
+export declare function compareNftMetadata(newNftMetadata: NftMetadata, nft: Nft): boolean;
+/**
+ * Formats aggregator names to presentable format.
+ *
+ * @param aggregators - List of token list names in camelcase.
+ * @returns Formatted aggregator names.
+ */
+export declare const formatAggregatorNames: (aggregators: string[]) => string[];
+/**
+ * Format token list assets to use image proxy from Codefi.
+ *
+ * @param params - Object that contains chainID and tokenAddress.
+ * @param params.chainId - ChainID of network in 0x-prefixed hexadecimal format.
+ * @param params.tokenAddress - Address of token in mixed or lowercase.
+ * @returns Formatted image url
+ */
+export declare const formatIconUrlWithProxy: ({ chainId, tokenAddress, }: {
+    chainId: Hex;
+    tokenAddress: string;
+}) => string;
+/**
+ * Networks where token detection is supported - Values are in decimal format
+ */
+export declare enum SupportedTokenDetectionNetworks {
+    mainnet = "0x1",
+    bsc = "0x38",
+    polygon = "0x89",
+    avax = "0xa86a",
+    aurora = "0x4e454152",
+    linea_goerli = "0xe704",
+    linea_mainnet = "0xe708",
+    arbitrum = "0xa4b1",
+    optimism = "0xa",
+    base = "0x2105",
+    zksync = "0x144"
+}
+/**
+ * Check if token detection is enabled for certain networks.
+ *
+ * @param chainId - ChainID of network
+ * @returns Whether the current network supports token detection
+ */
+export declare function isTokenDetectionSupportedForNetwork(chainId: Hex): boolean;
+/**
+ * Check if token list polling is enabled for a given network.
+ * Currently this method is used to support e2e testing for consumers of this package.
+ *
+ * @param chainId - ChainID of network
+ * @returns Whether the current network supports tokenlists
+ */
+export declare function isTokenListSupportedForNetwork(chainId: Hex): boolean;
+/**
+ * Removes IPFS protocol prefix from input string.
+ *
+ * @param ipfsUrl - An IPFS url (e.g. ipfs://{content id})
+ * @returns IPFS content identifier and (possibly) path in a string
+ * @throws Will throw if the url passed is not IPFS.
+ */
+export declare function removeIpfsProtocolPrefix(ipfsUrl: string): string;
+/**
+ * Extracts content identifier and path from an input string.
+ *
+ * @param ipfsUrl - An IPFS URL minus the IPFS protocol prefix
+ * @returns IFPS content identifier (cid) and sub path as string.
+ * @throws Will throw if the url passed is not ipfs.
+ */
+export declare function getIpfsCIDv1AndPath(ipfsUrl: string): {
+    cid: string;
+    path?: string;
+};
+/**
+ * Formats URL correctly for use retrieving assets hosted on IPFS.
+ *
+ * @param ipfsGateway - The users preferred IPFS gateway (full URL or just host).
+ * @param ipfsUrl - The IFPS URL pointed at the asset.
+ * @param subdomainSupported - Boolean indicating whether the URL should be formatted with subdomains or not.
+ * @returns A formatted URL, with the user's preferred IPFS gateway and format (subdomain or not), pointing to an asset hosted on IPFS.
+ */
+export declare function getFormattedIpfsUrl(ipfsGateway: string, ipfsUrl: string, subdomainSupported: boolean): string;
+/**
+ * Adds URL protocol prefix to input URL string if missing.
+ *
+ * @param urlString - An IPFS URL.
+ * @returns A URL with a https:// prepended.
+ */
+export declare function addUrlProtocolPrefix(urlString: string): string;
+/**
+ * Converts an Ethers BigNumber to a BN.
+ *
+ * @param bigNumber - An Ethers BigNumber instance.
+ * @returns A BN object.
+ */
+export declare function ethersBigNumberToBN(bigNumber: BigNumber): BN;
+/**
+ * Partitions a list of values into groups that are at most `batchSize` in
+ * length.
+ *
+ * @param values - The list of values.
+ * @param args - The remaining arguments.
+ * @param args.batchSize - The desired maximum number of values per batch.
+ * @returns The list of batches.
+ */
+export declare function divideIntoBatches<Value>(values: Value[], { batchSize }: {
+    batchSize: number;
+}): Value[][];
+/**
+ * Constructs an object from processing batches of the given values
+ * sequentially.
+ *
+ * @param args - The arguments to this function.
+ * @param args.values - A list of values to iterate over.
+ * @param args.batchSize - The maximum number of values in each batch.
+ * @param args.eachBatch - A function to call for each batch. This function is
+ * similar to the function that `Array.prototype.reduce` takes, in that it
+ * receives the object that is being built, each batch in the list of batches
+ * and the index, and should return an updated version of the object.
+ * @param args.initialResult - The initial value of the final data structure,
+ * i.e., the value that will be fed into the first call of `eachBatch`.
+ * @returns The built object.
+ */
+export declare function reduceInBatchesSerially<Value, Result extends Record<PropertyKey, unknown>>({ values, batchSize, eachBatch, initialResult, }: {
+    values: Value[];
+    batchSize: number;
+    eachBatch: (workingResult: Partial<Result>, batch: Value[], index: number) => Partial<Result> | Promise<Partial<Result>>;
+    initialResult: Partial<Result>;
+}): Promise<Result>;
+/**
+ * Maps an OpenSea V2 NFT to the V1 schema.
+ * @param nft - The V2 NFT to map.
+ * @returns The NFT in the V1 schema.
+ */
+export declare function mapOpenSeaNftV2ToV1(nft: OpenSeaV2Nft): ApiNft;
+/**
+ * Maps an OpenSea V2 detailed NFT to the V1 schema.
+ * @param nft - The V2 detailed NFT to map.
+ * @returns The NFT in the V1 schema.
+ */
+export declare function mapOpenSeaDetailedNftV2ToV1(nft: OpenSeaV2DetailedNft): ApiNft;
+/**
+ * Maps an OpenSea V2 contract to the V1 schema.
+ * @param contract - The v2 contract data.
+ * @param collection - The v2 collection data.
+ * @returns The contract in the v1 schema.
+ */
+export declare function mapOpenSeaContractV2ToV1(contract: OpenSeaV2Contract, collection?: OpenSeaV2Collection): ApiNftContract;
+/**
+ * Retrieves token prices for a set of contract addresses in a specific currency and chainId.
+ *
+ * @param args - The arguments to function.
+ * @param args.tokenPricesService - An object in charge of retrieving token prices.
+ * @param args.nativeCurrency - The native currency to request price in.
+ * @param args.tokenAddresses - The list of contract addresses.
+ * @param args.chainId - The chainId of the tokens.
+ * @returns The prices for the requested tokens.
+ */
+export declare function fetchTokenContractExchangeRates({ tokenPricesService, nativeCurrency, tokenAddresses, chainId, }: {
+    tokenPricesService: AbstractTokenPricesService;
+    nativeCurrency: string;
+    tokenAddresses: Hex[];
+    chainId: Hex;
+}): Promise<ContractExchangeRates>;
+//# sourceMappingURL=assetsUtil.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/assetsUtil.d.ts.map b/node_modules/@metamask/assets-controllers/dist/types/assetsUtil.d.ts.map
new file mode 100644
index 0000000..51ea9ad
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/types/assetsUtil.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"assetsUtil.d.ts","sourceRoot":"","sources":["../../src/assetsUtil.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/constants.d.ts b/node_modules/@metamask/assets-controllers/dist/types/constants.d.ts
new file mode 100644
index 0000000..e388239
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/types/constants.d.ts
@@ -0,0 +1,6 @@
+export declare enum Source {
+    Custom = "custom",
+    Dapp = "dapp",
+    Detected = "detected"
+}
+//# sourceMappingURL=constants.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/constants.d.ts.map b/node_modules/@metamask/assets-controllers/dist/types/constants.d.ts.map
new file mode 100644
index 0000000..7e1d5a4
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/types/constants.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"constants.d.ts","sourceRoot":"","sources":["../../src/constants.ts"],"names":[],"mappings":"AAAA,oBAAY,MAAM;IAChB,MAAM,WAAW;IACjB,IAAI,SAAS;IACb,QAAQ,aAAa;CACtB"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/crypto-compare.d.ts b/node_modules/@metamask/assets-controllers/dist/types/crypto-compare.d.ts
new file mode 100644
index 0000000..da659b7
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/types/crypto-compare.d.ts
@@ -0,0 +1,13 @@
+/**
+ * Fetches the exchange rate for a given currency.
+ *
+ * @param currency - ISO 4217 currency code.
+ * @param nativeCurrency - Symbol for base asset.
+ * @param includeUSDRate - Whether to add the USD rate to the fetch.
+ * @returns Promise resolving to exchange rate for given currency.
+ */
+export declare function fetchExchangeRate(currency: string, nativeCurrency: string, includeUSDRate?: boolean): Promise<{
+    conversionRate: number;
+    usdConversionRate: number;
+}>;
+//# sourceMappingURL=crypto-compare.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/crypto-compare.d.ts.map b/node_modules/@metamask/assets-controllers/dist/types/crypto-compare.d.ts.map
new file mode 100644
index 0000000..353a237
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/types/crypto-compare.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"crypto-compare.d.ts","sourceRoot":"","sources":["../../src/crypto-compare.ts"],"names":[],"mappings":"AAyBA;;;;;;;GAOG;AACH,wBAAsB,iBAAiB,CACrC,QAAQ,EAAE,MAAM,EAChB,cAAc,EAAE,MAAM,EACtB,cAAc,CAAC,EAAE,OAAO,GACvB,OAAO,CAAC;IACT,cAAc,EAAE,MAAM,CAAC;IACvB,iBAAiB,EAAE,MAAM,CAAC;CAC3B,CAAC,CAoCD"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/index.d.ts b/node_modules/@metamask/assets-controllers/dist/types/index.d.ts
new file mode 100644
index 0000000..eebcaf0
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/types/index.d.ts
@@ -0,0 +1,18 @@
+export * from './AccountTrackerController';
+export * from './AssetsContractController';
+export * from './CurrencyRateController';
+export * from './NftController';
+export * from './NftDetectionController';
+export type { TokenBalancesControllerMessenger, TokenBalancesControllerActions, TokenBalancesControllerGetStateAction, TokenBalancesControllerEvents, TokenBalancesControllerStateChangeEvent, } from './TokenBalancesController';
+export { TokenBalancesController } from './TokenBalancesController';
+export type { TokenDetectionControllerMessenger, TokenDetectionControllerActions, TokenDetectionControllerGetStateAction, TokenDetectionControllerEvents, TokenDetectionControllerStateChangeEvent, } from './TokenDetectionController';
+export { TokenDetectionController } from './TokenDetectionController';
+export type { TokenListState, TokenListToken, TokenListMap, TokenListStateChange, TokenListControllerEvents, GetTokenListState, TokenListControllerActions, TokenListControllerMessenger, } from './TokenListController';
+export { TokenListController } from './TokenListController';
+export type { Token, TokenRatesConfig, ContractExchangeRates, TokenRatesState, } from './TokenRatesController';
+export { TokenRatesController } from './TokenRatesController';
+export type { TokensConfig, TokensState, TokensControllerActions, TokensControllerGetStateAction, TokensControllerAddDetectedTokensAction, TokensControllerEvents, TokensControllerStateChangeEvent, TokensControllerMessenger, } from './TokensController';
+export { TokensController } from './TokensController';
+export { isTokenDetectionSupportedForNetwork, formatIconUrlWithProxy, getFormattedIpfsUrl, fetchTokenContractExchangeRates, } from './assetsUtil';
+export { CodefiTokenPricesServiceV2, SUPPORTED_CHAIN_IDS, } from './token-prices-service';
+//# sourceMappingURL=index.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/index.d.ts.map b/node_modules/@metamask/assets-controllers/dist/types/index.d.ts.map
new file mode 100644
index 0000000..dc57dc9
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/types/index.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"AAAA,cAAc,4BAA4B,CAAC;AAC3C,cAAc,4BAA4B,CAAC;AAC3C,cAAc,0BAA0B,CAAC;AACzC,cAAc,iBAAiB,CAAC;AAChC,cAAc,0BAA0B,CAAC;AACzC,YAAY,EACV,gCAAgC,EAChC,8BAA8B,EAC9B,qCAAqC,EACrC,6BAA6B,EAC7B,uCAAuC,GACxC,MAAM,2BAA2B,CAAC;AACnC,OAAO,EAAE,uBAAuB,EAAE,MAAM,2BAA2B,CAAC;AACpE,YAAY,EACV,iCAAiC,EACjC,+BAA+B,EAC/B,sCAAsC,EACtC,8BAA8B,EAC9B,wCAAwC,GACzC,MAAM,4BAA4B,CAAC;AACpC,OAAO,EAAE,wBAAwB,EAAE,MAAM,4BAA4B,CAAC;AACtE,YAAY,EACV,cAAc,EACd,cAAc,EACd,YAAY,EACZ,oBAAoB,EACpB,yBAAyB,EACzB,iBAAiB,EACjB,0BAA0B,EAC1B,4BAA4B,GAC7B,MAAM,uBAAuB,CAAC;AAC/B,OAAO,EAAE,mBAAmB,EAAE,MAAM,uBAAuB,CAAC;AAC5D,YAAY,EACV,KAAK,EACL,gBAAgB,EAChB,qBAAqB,EACrB,eAAe,GAChB,MAAM,wBAAwB,CAAC;AAChC,OAAO,EAAE,oBAAoB,EAAE,MAAM,wBAAwB,CAAC;AAC9D,YAAY,EACV,YAAY,EACZ,WAAW,EACX,uBAAuB,EACvB,8BAA8B,EAC9B,uCAAuC,EACvC,sBAAsB,EACtB,gCAAgC,EAChC,yBAAyB,GAC1B,MAAM,oBAAoB,CAAC;AAC5B,OAAO,EAAE,gBAAgB,EAAE,MAAM,oBAAoB,CAAC;AACtD,OAAO,EACL,mCAAmC,EACnC,sBAAsB,EACtB,mBAAmB,EACnB,+BAA+B,GAChC,MAAM,cAAc,CAAC;AACtB,OAAO,EACL,0BAA0B,EAC1B,mBAAmB,GACpB,MAAM,wBAAwB,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/token-prices-service/abstract-token-prices-service.d.ts b/node_modules/@metamask/assets-controllers/dist/types/token-prices-service/abstract-token-prices-service.d.ts
new file mode 100644
index 0000000..d95cc33
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/types/token-prices-service/abstract-token-prices-service.d.ts
@@ -0,0 +1,62 @@
+import type { Hex } from '@metamask/utils';
+/**
+ * Represents the price of a token in a currency.
+ */
+export type TokenPrice<TokenAddress extends Hex, Currency extends string> = {
+    tokenAddress: TokenAddress;
+    value: number;
+    currency: Currency;
+};
+/**
+ * A map of token address to its price.
+ */
+export type TokenPricesByTokenAddress<TokenAddress extends Hex, Currency extends string> = {
+    [A in TokenAddress]: TokenPrice<A, Currency>;
+};
+/**
+ * An ideal token prices service. All implementations must confirm to this
+ * interface.
+ *
+ * @template ChainId - A type union of valid arguments for the `chainId`
+ * argument to `fetchTokenPrices`.
+ * @template TokenAddress - A type union of all token addresses. The reason this
+ * type parameter exists is so that we can guarantee that same addresses that
+ * `fetchTokenPrices` receives are the same addresses that shown up in the
+ * return value.
+ * @template Currency - A type union of valid arguments for the `currency`
+ * argument to `fetchTokenPrices`.
+ */
+export type AbstractTokenPricesService<ChainId extends Hex = Hex, TokenAddress extends Hex = Hex, Currency extends string = string> = {
+    /**
+     * Retrieves prices in the given currency for the tokens identified by the
+     * given addresses which are expected to live on the given chain.
+     *
+     * @param args - The arguments to this function.
+     * @param args.chainId - An EIP-155 chain ID.
+     * @param args.tokenAddresses - Addresses for tokens that live on the chain.
+     * @param args.currency - The desired currency of the token prices.
+     * @returns The prices for the requested tokens.
+     */
+    fetchTokenPrices({ chainId, tokenAddresses, currency, }: {
+        chainId: ChainId;
+        tokenAddresses: TokenAddress[];
+        currency: Currency;
+    }): Promise<Partial<TokenPricesByTokenAddress<TokenAddress, Currency>>>;
+    /**
+     * Type guard for whether the API can return token prices for the given chain
+     * ID.
+     *
+     * @param chainId - The chain ID to check.
+     * @returns True if the API supports the chain ID, false otherwise.
+     */
+    validateChainIdSupported(chainId: unknown): chainId is ChainId;
+    /**
+     * Type guard for whether the API can return token prices in the given
+     * currency.
+     *
+     * @param currency - The currency to check.
+     * @returns True if the API supports the currency, false otherwise.
+     */
+    validateCurrencySupported(currency: unknown): currency is Currency;
+};
+//# sourceMappingURL=abstract-token-prices-service.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/token-prices-service/abstract-token-prices-service.d.ts.map b/node_modules/@metamask/assets-controllers/dist/types/token-prices-service/abstract-token-prices-service.d.ts.map
new file mode 100644
index 0000000..bc62078
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/types/token-prices-service/abstract-token-prices-service.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"abstract-token-prices-service.d.ts","sourceRoot":"","sources":["../../../src/token-prices-service/abstract-token-prices-service.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,GAAG,EAAE,MAAM,iBAAiB,CAAC;AAE3C;;GAEG;AACH,MAAM,MAAM,UAAU,CAAC,YAAY,SAAS,GAAG,EAAE,QAAQ,SAAS,MAAM,IAAI;IAC1E,YAAY,EAAE,YAAY,CAAC;IAC3B,KAAK,EAAE,MAAM,CAAC;IACd,QAAQ,EAAE,QAAQ,CAAC;CACpB,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,yBAAyB,CACnC,YAAY,SAAS,GAAG,EACxB,QAAQ,SAAS,MAAM,IACrB;KACD,CAAC,IAAI,YAAY,GAAG,UAAU,CAAC,CAAC,EAAE,QAAQ,CAAC;CAC7C,CAAC;AAEF;;;;;;;;;;;;GAYG;AACH,MAAM,MAAM,0BAA0B,CACpC,OAAO,SAAS,GAAG,GAAG,GAAG,EACzB,YAAY,SAAS,GAAG,GAAG,GAAG,EAC9B,QAAQ,SAAS,MAAM,GAAG,MAAM,IAC9B;IACF;;;;;;;;;OASG;IACH,gBAAgB,CAAC,EACf,OAAO,EACP,cAAc,EACd,QAAQ,GACT,EAAE;QACD,OAAO,EAAE,OAAO,CAAC;QACjB,cAAc,EAAE,YAAY,EAAE,CAAC;QAC/B,QAAQ,EAAE,QAAQ,CAAC;KACpB,GAAG,OAAO,CAAC,OAAO,CAAC,yBAAyB,CAAC,YAAY,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC;IAExE;;;;;;OAMG;IACH,wBAAwB,CAAC,OAAO,EAAE,OAAO,GAAG,OAAO,IAAI,OAAO,CAAC;IAE/D;;;;;;OAMG;IACH,yBAAyB,CAAC,QAAQ,EAAE,OAAO,GAAG,QAAQ,IAAI,QAAQ,CAAC;CACpE,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/token-prices-service/codefi-v2.d.ts b/node_modules/@metamask/assets-controllers/dist/types/token-prices-service/codefi-v2.d.ts
new file mode 100644
index 0000000..6c35c69
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/types/token-prices-service/codefi-v2.d.ts
@@ -0,0 +1,90 @@
+import type { Hex } from '@metamask/utils';
+import type { AbstractTokenPricesService, TokenPricesByTokenAddress } from './abstract-token-prices-service';
+/**
+ * The list of currencies that can be supplied as the `vsCurrency` parameter to
+ * the `/spot-prices` endpoint, in lowercase form.
+ */
+export declare const SUPPORTED_CURRENCIES: readonly ["btc", "eth", "ltc", "bch", "bnb", "eos", "xrp", "xlm", "link", "dot", "yfi", "usd", "aed", "ars", "aud", "bdt", "bhd", "bmd", "brl", "cad", "chf", "clp", "cny", "czk", "dkk", "eur", "gbp", "hkd", "huf", "idr", "ils", "inr", "jpy", "krw", "kwd", "lkr", "mmk", "mxn", "myr", "ngn", "nok", "nzd", "php", "pkr", "pln", "rub", "sar", "sek", "sgd", "thb", "try", "twd", "uah", "vef", "vnd", "zar", "xdr", "xag", "xau", "bits", "sats"];
+/**
+ * A currency that can be supplied as the `vsCurrency` parameter to
+ * the `/spot-prices` endpoint. Covers both uppercase and lowercase versions.
+ */
+type SupportedCurrency = (typeof SUPPORTED_CURRENCIES)[number] | Uppercase<(typeof SUPPORTED_CURRENCIES)[number]>;
+/**
+ * The list of chain IDs that can be supplied in the URL for the `/spot-prices`
+ * endpoint, but in hexadecimal form (for consistency with how we represent
+ * chain IDs in other places).
+ * @see Used by {@link CodefiTokenPricesServiceV2} to validate that a given chain ID is supported by V2 of the Codefi Price API.
+ */
+export declare const SUPPORTED_CHAIN_IDS: readonly ["0x1", "0xa", "0x19", "0x38", "0x39", "0x42", "0x46", "0x52", "0x58", "0x64", "0x6a", "0x7a", "0x80", "0x89", "0xfa", "0x120", "0x141", "0x144", "0x169", "0x440", "0x504", "0x505", "0x2105", "0x150", "0x2710", "0xa4b1", "0xa4ec", "0xa516", "0xa86a", "0x518af", "0x4e454152", "0x63564c40", "0xe708"];
+/**
+ * A chain ID that can be supplied in the URL for the `/spot-prices` endpoint,
+ * but in hexadecimal form (for consistency with how we represent chain IDs in
+ * other places).
+ */
+type SupportedChainId = (typeof SUPPORTED_CHAIN_IDS)[number];
+/**
+ * This version of the token prices service uses V2 of the Codefi Price API to
+ * fetch token prices.
+ */
+export declare class CodefiTokenPricesServiceV2 implements AbstractTokenPricesService<SupportedChainId, Hex, SupportedCurrency> {
+    #private;
+    /**
+     * Construct a Codefi Token Price Service.
+     *
+     * @param options - Constructor options
+     * @param options.degradedThreshold - The threshold between "normal" and "degrated" service,
+     * in milliseconds.
+     * @param options.retries - Number of retry attempts for each token price update.
+     * @param options.maximumConsecutiveFailures - The maximum number of consecutive failures
+     * allowed before breaking the circuit and pausing further updates.
+     * @param options.onBreak - An event handler for when the circuit breaks, useful for capturing
+     * metrics about network failures.
+     * @param options.onDegraded - An event handler for when the circuit remains closed, but requests
+     * are failing or resolving too slowly (i.e. resolving more slowly than the `degradedThreshold).
+     * @param options.circuitBreakDuration - The amount of time to wait when the circuit breaks
+     * from too many consecutive failures.
+     */
+    constructor({ degradedThreshold, retries, maximumConsecutiveFailures, onBreak, onDegraded, circuitBreakDuration, }?: {
+        degradedThreshold?: number;
+        retries?: number;
+        maximumConsecutiveFailures?: number;
+        onBreak?: () => void;
+        onDegraded?: () => void;
+        circuitBreakDuration?: number;
+    });
+    /**
+     * Retrieves prices in the given currency for the tokens identified by the
+     * given addresses which are expected to live on the given chain.
+     *
+     * @param args - The arguments to function.
+     * @param args.chainId - An EIP-155 chain ID.
+     * @param args.tokenAddresses - Addresses for tokens that live on the chain.
+     * @param args.currency - The desired currency of the token prices.
+     * @returns The prices for the requested tokens.
+     */
+    fetchTokenPrices({ chainId, tokenAddresses, currency, }: {
+        chainId: SupportedChainId;
+        tokenAddresses: Hex[];
+        currency: SupportedCurrency;
+    }): Promise<Partial<TokenPricesByTokenAddress<Hex, SupportedCurrency>>>;
+    /**
+     * Type guard for whether the API can return token prices for the given chain
+     * ID.
+     *
+     * @param chainId - The chain ID to check.
+     * @returns True if the API supports the chain ID, false otherwise.
+     */
+    validateChainIdSupported(chainId: unknown): chainId is SupportedChainId;
+    /**
+     * Type guard for whether the API can return token prices in the given
+     * currency.
+     *
+     * @param currency - The currency to check. If a string, can be either
+     * lowercase or uppercase.
+     * @returns True if the API supports the currency, false otherwise.
+     */
+    validateCurrencySupported(currency: unknown): currency is SupportedCurrency;
+}
+export {};
+//# sourceMappingURL=codefi-v2.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/token-prices-service/codefi-v2.d.ts.map b/node_modules/@metamask/assets-controllers/dist/types/token-prices-service/codefi-v2.d.ts.map
new file mode 100644
index 0000000..b644474
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/types/token-prices-service/codefi-v2.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"codefi-v2.d.ts","sourceRoot":"","sources":["../../../src/token-prices-service/codefi-v2.ts"],"names":[],"mappings":"AACA,OAAO,KAAK,EAAE,GAAG,EAAE,MAAM,iBAAiB,CAAC;AAa3C,OAAO,KAAK,EACV,0BAA0B,EAE1B,yBAAyB,EAC1B,MAAM,iCAAiC,CAAC;AAUzC;;;GAGG;AACH,eAAO,MAAM,oBAAoB,ybA2HvB,CAAC;AAEX;;;GAGG;AACH,KAAK,iBAAiB,GAClB,CAAC,OAAO,oBAAoB,CAAC,CAAC,MAAM,CAAC,GACrC,SAAS,CAAC,CAAC,OAAO,oBAAoB,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;AAErD;;;;;GAKG;AACH,eAAO,MAAM,mBAAmB,sTAmEtB,CAAC;AAEX;;;;GAIG;AACH,KAAK,gBAAgB,GAAG,CAAC,OAAO,mBAAmB,CAAC,CAAC,MAAM,CAAC,CAAC;AAc7D;;;GAGG;AACH,qBAAa,0BACX,YACE,0BAA0B,CAAC,gBAAgB,EAAE,GAAG,EAAE,iBAAiB,CAAC;;IAItE;;;;;;;;;;;;;;;OAeG;gBACS,EACV,iBAA8C,EAC9C,OAAqC,EACrC,0BAAyE,EACzE,OAAO,EACP,UAAU,EACV,oBAAqC,GACtC,GAAE;QACD,iBAAiB,CAAC,EAAE,MAAM,CAAC;QAC3B,OAAO,CAAC,EAAE,MAAM,CAAC;QACjB,0BAA0B,CAAC,EAAE,MAAM,CAAC;QACpC,OAAO,CAAC,EAAE,MAAM,IAAI,CAAC;QACrB,UAAU,CAAC,EAAE,MAAM,IAAI,CAAC;QACxB,oBAAoB,CAAC,EAAE,MAAM,CAAC;KAC1B;IAgCN;;;;;;;;;OASG;IACG,gBAAgB,CAAC,EACrB,OAAO,EACP,cAAc,EACd,QAAQ,GACT,EAAE;QACD,OAAO,EAAE,gBAAgB,CAAC;QAC1B,cAAc,EAAE,GAAG,EAAE,CAAC;QACtB,QAAQ,EAAE,iBAAiB,CAAC;KAC7B,GAAG,OAAO,CAAC,OAAO,CAAC,yBAAyB,CAAC,GAAG,EAAE,iBAAiB,CAAC,CAAC,CAAC;IAuDvE;;;;;;OAMG;IACH,wBAAwB,CAAC,OAAO,EAAE,OAAO,GAAG,OAAO,IAAI,gBAAgB;IAKvE;;;;;;;OAOG;IACH,yBAAyB,CAAC,QAAQ,EAAE,OAAO,GAAG,QAAQ,IAAI,iBAAiB;CAO5E"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/token-prices-service/index.d.ts b/node_modules/@metamask/assets-controllers/dist/types/token-prices-service/index.d.ts
new file mode 100644
index 0000000..6276a90
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/types/token-prices-service/index.d.ts
@@ -0,0 +1,3 @@
+export type { AbstractTokenPricesService } from './abstract-token-prices-service';
+export { CodefiTokenPricesServiceV2, SUPPORTED_CHAIN_IDS } from './codefi-v2';
+//# sourceMappingURL=index.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/token-prices-service/index.d.ts.map b/node_modules/@metamask/assets-controllers/dist/types/token-prices-service/index.d.ts.map
new file mode 100644
index 0000000..15cd9dc
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/types/token-prices-service/index.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../../src/token-prices-service/index.ts"],"names":[],"mappings":"AAAA,YAAY,EAAE,0BAA0B,EAAE,MAAM,iCAAiC,CAAC;AAClF,OAAO,EAAE,0BAA0B,EAAE,mBAAmB,EAAE,MAAM,aAAa,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/token-service.d.ts b/node_modules/@metamask/assets-controllers/dist/types/token-service.d.ts
new file mode 100644
index 0000000..9caf787
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/types/token-service.d.ts
@@ -0,0 +1,31 @@
+import type { Hex } from '@metamask/utils';
+export declare const TOKEN_END_POINT_API = "https://token-api.metaswap.codefi.network";
+export declare const TOKEN_METADATA_NO_SUPPORT_ERROR = "TokenService Error: Network does not support fetchTokenMetadata";
+/**
+ * Fetch the list of token metadata for a given network. This request is cancellable using the
+ * abort signal passed in.
+ *
+ * @param chainId - The chain ID of the network the requested tokens are on.
+ * @param abortSignal - The abort signal used to cancel the request if necessary.
+ * @param options - Additional fetch options.
+ * @param options.timeout - The fetch timeout.
+ * @returns The token list, or `undefined` if the request was cancelled.
+ */
+export declare function fetchTokenListByChainId(chainId: Hex, abortSignal: AbortSignal, { timeout }?: {
+    timeout?: number | undefined;
+}): Promise<unknown>;
+/**
+ * Fetch metadata for the token address provided for a given network. This request is cancellable
+ * using the abort signal passed in.
+ *
+ * @param chainId - The chain ID of the network the token is on.
+ * @param tokenAddress - The address of the token to fetch metadata for.
+ * @param abortSignal - The abort signal used to cancel the request if necessary.
+ * @param options - Additional fetch options.
+ * @param options.timeout - The fetch timeout.
+ * @returns The token metadata, or `undefined` if the request was either aborted or failed.
+ */
+export declare function fetchTokenMetadata<T>(chainId: Hex, tokenAddress: string, abortSignal: AbortSignal, { timeout }?: {
+    timeout?: number | undefined;
+}): Promise<T | undefined>;
+//# sourceMappingURL=token-service.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@metamask/assets-controllers/dist/types/token-service.d.ts.map b/node_modules/@metamask/assets-controllers/dist/types/token-service.d.ts.map
new file mode 100644
index 0000000..97c2709
--- /dev/null
+++ b/node_modules/@metamask/assets-controllers/dist/types/token-service.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"token-service.d.ts","sourceRoot":"","sources":["../../src/token-service.ts"],"names":[],"mappings":"AACA,OAAO,KAAK,EAAE,GAAG,EAAE,MAAM,iBAAiB,CAAC;AAI3C,eAAO,MAAM,mBAAmB,8CAA8C,CAAC;AAC/E,eAAO,MAAM,+BAA+B,oEACuB,CAAC;AAiCpE;;;;;;;;;GASG;AACH,wBAAsB,uBAAuB,CAC3C,OAAO,EAAE,GAAG,EACZ,WAAW,EAAE,WAAW,EACxB,EAAE,OAAwB,EAAE;;CAAK,GAChC,OAAO,CAAC,OAAO,CAAC,CAOlB;AAED;;;;;;;;;;GAUG;AACH,wBAAsB,kBAAkB,CAAC,CAAC,EACxC,OAAO,EAAE,GAAG,EACZ,YAAY,EAAE,MAAM,EACpB,WAAW,EAAE,WAAW,EACxB,EAAE,OAAwB,EAAE;;CAAK,GAChC,OAAO,CAAC,CAAC,GAAG,SAAS,CAAC,CAUxB"}
\ No newline at end of file
