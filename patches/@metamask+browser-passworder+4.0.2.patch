diff --git a/node_modules/@metamask/browser-passworder/dist/index.js b/node_modules/@metamask/browser-passworder/dist/index.js
index 6c719e7..0196363 100644
--- a/node_modules/@metamask/browser-passworder/dist/index.js
+++ b/node_modules/@metamask/browser-passworder/dist/index.js
@@ -4,6 +4,11 @@ exports.generateSalt = exports.serializeBufferForStorage = exports.serializeBuff
 const EXPORT_FORMAT = 'jwk';
 const DERIVED_KEY_FORMAT = 'AES-GCM';
 const STRING_ENCODING = 'utf-8';
+
+import { NativeModules } from 'react-native';
+const Aes = NativeModules.Aes;
+const AesForked = NativeModules.AesForked;
+
 /**
  * Encrypts a data object that can be any serializable value using
  * a provided password.
@@ -14,11 +19,28 @@ const STRING_ENCODING = 'utf-8';
  * @param salt - The salt to use to encrypt.
  * @returns The encrypted vault.
  */
-async function encrypt(password, dataObj, key, salt = generateSalt()) {
-    const cryptoKey = key || (await keyFromPassword(password, salt));
-    const payload = await encryptWithKey(cryptoKey, dataObj);
-    payload.salt = salt;
-    return JSON.stringify(payload);
+
+
+generateSalt = (byteCount = 32) => {
+    const view = new Uint8Array(byteCount);
+    global.crypto.getRandomValues(view);
+    // eslint-disable-next-line no-undef
+    const b64encoded = btoa(String.fromCharCode.apply(null, view));
+    return b64encoded;
+  }
+
+encryptWithKey = async (text, keyBase64) => {
+    const iv = await Aes.randomKey(16);
+    return Aes.encrypt(text, keyBase64, iv).then((cipher) => ({ cipher, iv }));
+};
+
+async function encrypt(password, object) {
+    const salt = generateSalt(16);
+    const key = await Aes.pbkdf2(password, salt, 5000, 256);
+    const result = await encryptWithKey(JSON.stringify(object), key);
+    result.salt = salt;
+    result.lib = 'original';
+    return JSON.stringify(result);
 }
 exports.encrypt = encrypt;
 /**
@@ -75,12 +97,17 @@ exports.encryptWithKey = encryptWithKey;
  * @param key - The key to decrypt with.
  * @returns The decrypted data.
  */
-async function decrypt(password, text, key) {
-    const payload = JSON.parse(text);
-    const { salt } = payload;
-    const cryptoKey = key || (await keyFromPassword(password, salt));
-    const result = await decryptWithKey(cryptoKey, payload);
-    return result;
+
+decryptWithKey = (encryptedData, key, lib) =>
+lib === 'original'
+  ? Aes.decrypt(encryptedData.cipher, key, encryptedData.iv)
+  : AesForked.decrypt(encryptedData.cipher, key, encryptedData.iv);
+
+async function decrypt(password, encryptedString) {
+    const encryptedData = JSON.parse(encryptedString);
+    const key = await Aes.pbkdf2(password, encryptedData.salt, 5000, 256)
+    const data = await Aes.decrypt(encryptedData.cipher, key, encryptedData.iv)
+    return JSON.parse(data);
 }
 exports.decrypt = decrypt;
 /**
@@ -151,27 +178,7 @@ async function exportKey(key) {
     return JSON.stringify(exportedKey);
 }
 exports.exportKey = exportKey;
-/**
- * Generate a CryptoKey from a password and random salt.
- *
- * @param password - The password to use to generate key.
- * @param salt - The salt string to use in key derivation.
- * @param exportable - Should the derived key be exportable.
- * @returns A CryptoKey for encryption and decryption.
- */
-async function keyFromPassword(password, salt, exportable = false) {
-    const passBuffer = Buffer.from(password, STRING_ENCODING);
-    const saltBuffer = Buffer.from(salt, 'base64');
-    const key = await global.crypto.subtle.importKey('raw', passBuffer, { name: 'PBKDF2' }, false, ['deriveBits', 'deriveKey']);
-    const derivedKey = await global.crypto.subtle.deriveKey({
-        name: 'PBKDF2',
-        salt: saltBuffer,
-        iterations: 10000,
-        hash: 'SHA-256',
-    }, key, { name: DERIVED_KEY_FORMAT, length: 256 }, exportable, ['encrypt', 'decrypt']);
-    return derivedKey;
-}
-exports.keyFromPassword = keyFromPassword;
+
 /**
  * Converts a hex string into a buffer.
  *
