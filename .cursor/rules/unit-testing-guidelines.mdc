---
description: Project Guidelines for Unit Testing
globs: *.test.*
alwaysApply: false
---

Reference: [MetaMask Unit Testing Guidelines](https://github.com/MetaMask/contributor-docs/blob/main/docs/testing/unit-testing.md)

# Unit Testing Guidelines

## Test Naming Rules

- **NEVER use "should" in test names** - this is a hard rule with zero exceptions
- **Use action-oriented descriptions** that describe what the code does
- **Be specific about the behavior being tested**
- **AVOID** weasel words like "handle", "manage", or other non-specific action verbs
- **AVOID** subjective outcome words like "successfully", "correctly", "invalid" - instead indicate what the actual result should be
- **BE SPECIFIC** about conditions: use "email without domain" instead of "invalid email"

```ts
// âŒ WRONG
it('should return fixed timestamp', () => { ... });
it('should ignore events', () => { ... });
it('should display error when input is invalid', () => { ... });
it('handles invalid input correctly', () => { ... });

// âœ… CORRECT
it('returns fixed timestamp for privacy events', () => { ... });
it('ignores events without privacy timestamp property', () => { ... });
it('displays error when email is missing @ symbol', () => { ... });
it('returns false for email without domain', () => { ... });
```

## Test Structure and Organization - MANDATORY

- **EVERY test MUST follow the AAA pattern** (Arrange, Act, Assert) with blank line separation
- **Each test must cover ONE behavior** and be isolated from others
- **Use helper functions** for test data creation
- **Group related tests** in `describe` blocks

```ts
it('returns false for email without domain', () => {
  const input = 'user@';

  const result = validateEmail(input);

  expect(result).toBe(false);
});
```

**Helper Functions**:
```ts
const createTestEvent = (overrides = {}) => ({
  type: EventType.TrackEvent,
  event: 'Test Event',
  timestamp: '2024-01-01T12:00:00.000Z',
  ...overrides,
});
```

## Element Selection - PREFER DATA TEST IDs

- **ALWAYS prefer `testID` props** for selecting elements in tests
- **Use `getByTestId`** as the primary query method for reliable element selection
- **Add `testID` props** to components when writing new code or updating existing code
- **Avoid selecting by text** when the text might change (i18n, copy updates)
- **Use semantic queries** (`getByRole`, `getByLabelText`) for accessibility-critical elements

```tsx
// âœ… CORRECT - Use testID for reliable selection
<Button testID="submit-button" onPress={handleSubmit}>
  {t('common.submit')}
</Button>

// In test:
const submitButton = screen.getByTestId('submit-button');
expect(submitButton).toBeOnTheScreen();

// âœ… ALSO GOOD - Semantic queries for accessibility
const input = screen.getByRole('textbox', { name: 'Email' });
const checkbox = screen.getByLabelText('Accept terms');

// âŒ AVOID - Fragile text-based selection
const button = screen.getByText('Submit'); // Breaks when text changes
const input = screen.getByPlaceholderText('Enter email'); // Fragile
```

### CHILD PROP OBJECTS - ALL COMPONENTS SUPPORT THIS

**ALL `@metamask/design-system-react-native` and `app/component-library` components support child prop objects for passing testIDs to internal elements.** This is a universal design pattern - there is NO reason to mock these components.

Common child prop object patterns:
- `closeButtonProps` - for close/dismiss buttons
- `backButtonProps` - for back navigation buttons
- `startAccessoryProps` / `endAccessoryProps` - for accessory elements
- `iconProps` - for icon elements
- `labelProps` - for label text elements
- `inputProps` - for input elements within compound components
- `*Props` - any prop ending in `Props` is likely a child prop object

```tsx
// âŒ WRONG - Mocking to add testID (141 lines of unnecessary code!)
// The testID capability ALREADY EXISTS via child prop objects!
jest.mock('BottomSheetHeader', () => {
  return ({ onClose }) => (
    <TouchableOpacity testID="close-button" onPress={onClose}>Close</TouchableOpacity>
  );
});

// âœ… CORRECT - Use the component's child prop object API
<HeaderCenter
  title="Select a region"
  onClose={handleClose}
  closeButtonProps={{ testID: 'region-selector-close-button' }}
/>

// âœ… CORRECT - BottomSheetHeader supports child prop objects
<BottomSheetHeader
  onClose={handleClose}
  closeButtonProps={{ testID: 'modal-close-button' }}
  onBack={handleBack}
  backButtonProps={{ testID: 'modal-back-button' }}
>
  {title}
</BottomSheetHeader>

// In test - no mocking needed!
const closeButton = screen.getByTestId('region-selector-close-button');
fireEvent.press(closeButton);
```

### This Is Universal - No Exceptions

| Library | testID Support |
|---------|----------------|
| `@metamask/design-system-react-native` | âœ… All components support `testID` prop AND child prop objects |
| `app/component-library/*` | âœ… All components support `testID` prop AND child prop objects |

**If you think you need to mock one of these components to add a testID, you are wrong.** The capability already exists - find the child prop object.

### How to Find Child Prop Objects

1. **Use IDE autocomplete** - Type the component and explore available props ending in `Props`
2. **Check TypeScript types** - Look at the component's props interface
3. **Check component source** - Search for `Props` suffix patterns
4. **Check Storybook** - Component stories demonstrate these props

```tsx
// Example: Finding props for BottomSheet components
// In your IDE, type <BottomSheetHeader and use autocomplete to see:
// - closeButtonProps?: ButtonIconProps
// - backButtonProps?: ButtonIconProps
// - startAccessory?: React.ReactNode
// - etc.

// Example: Design system Button with icon
<Button
  testID="submit-button"
  iconProps={{ testID: 'submit-icon' }}
  labelProps={{ testID: 'submit-label' }}
>
  Submit
</Button>
```

### TestID Naming Conventions

```tsx
// Use kebab-case for testIDs
testID="settings-screen"
testID="submit-button"
testID="error-message"
testID="token-list-item"

// Include context for list items
testID={`token-item-${token.symbol}`}
testID={`network-option-${network.chainId}`}
```

## Assertions - PREFER toBeOnTheScreen

- **ALWAYS use `toBeOnTheScreen()`** to assert element presence - NOT `toBeTruthy()` or `toBeDefined()`
- **Use specific matchers** that communicate intent clearly
- **Avoid weak matchers** that don't actually verify the expected behavior

```tsx
// âœ… CORRECT - Clear, specific assertions
expect(screen.getByTestId('submit-button')).toBeOnTheScreen();
expect(screen.queryByTestId('error-message')).not.toBeOnTheScreen();
expect(screen.getByTestId('balance-text')).toHaveTextContent('100 ETH');

// âŒ WRONG - Weak matchers that don't verify presence properly
expect(screen.getByTestId('submit-button')).toBeTruthy();  // Misleading
expect(screen.getByTestId('submit-button')).toBeDefined(); // Doesn't verify render
expect(element).not.toBeNull(); // Use toBeOnTheScreen() instead
```

### Recommended Matchers

| Instead of | Use |
|------------|-----|
| `toBeTruthy()` for elements | `toBeOnTheScreen()` |
| `toBeDefined()` for elements | `toBeOnTheScreen()` |
| `not.toBeNull()` | `not.toBeOnTheScreen()` or `queryByTestId` returning null |
| `toHaveLength(1)` for single element | `toBeOnTheScreen()` |

## Mocking Rules

### General Mocking Guidelines

- **Mock external boundaries** - APIs, native modules, third-party services
- **NO** use of `require` - use ES6 imports only
- **NO** use of `any` type - use proper TypeScript types
- **Use realistic mock data** that reflects real usage
- **Never mock the component under test** - only mock its external dependencies

### What to Mock

```ts
// âœ… MOCK: External APIs and services
jest.mock('../services/api');

// âœ… MOCK: Native modules and platform-specific code
jest.mock('react-native-keychain');
jest.mock('@react-native-async-storage/async-storage');

// âœ… MOCK: Non-deterministic functions
jest.useFakeTimers();
jest.spyOn(Math, 'random').mockReturnValue(0.5);

// âœ… MOCK: Navigation and routing
const mockNavigate = jest.fn();
jest.mock('@react-navigation/native', () => ({
  useNavigation: () => ({ navigate: mockNavigate }),
}));
```

## UI Component Testing - TestID Guidelines - CRITICAL

**NEVER mock `@metamask/design-system-react-native` or `app/component-library` components to inject testIDs.** These components already support testIDs through props and child prop objects.

### Why This Matters

ALL `@metamask/design-system-react-native` and `app/component-library` components provide:
- **Built-in testID support** via the `testID` prop
- **Child prop objects** (`closeButtonProps`, `iconProps`, etc.) for passing testIDs to internal elements
- This eliminates the need to mock components just to inject testIDs

### The Problem: Mocking to Inject TestIDs

```tsx
// âŒ BAD: 84+ test files in the codebase do this unnecessarily
jest.mock('@metamask/design-system-react-native', () => ({
  Box: 'View',
  Text: 'Text',
  TextVariant: { BodyMd: 'BodyMd' },
  // ... 20+ lines of mock boilerplate
}));

// âŒ ALSO BAD: Mocking the Tailwind preset
jest.mock('@metamask/design-system-twrnc-preset', () => ({
  useTailwind: () => ({
    style: jest.fn(() => ({})),
    color: jest.fn(() => '#000000'),
  }),
}));

// âŒ BAD: Mocking component-library components to add testIDs
jest.mock('BottomSheetHeader', () => /* 30+ lines recreating the component */);

// âœ… GOOD: Use child prop objects to pass testIDs to internal elements
<BottomSheetHeader
  onClose={handleClose}
  closeButtonProps={{ testID: 'modal-close-button' }}
/>

// âœ… GOOD: Just render and use testID
render(<MyComponent />);
expect(screen.getByTestId('modal-close-button')).toBeOnTheScreen();
```

### Libraries That Should NOT Be Mocked for TestID Injection

| Library | TestID Support |
|---------|----------------|
| `@metamask/design-system-react-native` | All components support `testID` prop and child prop objects |
| `app/component-library/*` | All components support `testID` prop and child prop objects (e.g., `closeButtonProps`, `iconProps`) |

### Why These Mocks Are Coupled (Important Context)

Mocking `@metamask/design-system-react-native` creates a chain reaction that forces you to mock `@metamask/design-system-twrnc-preset` too:

1. You mock `Box` â†’ `'View'` (basic React Native View)
2. The mocked View doesn't understand `twClassName` prop
3. Tailwind styles from `tw.style()` have nowhere to go / cause warnings
4. So you mock `useTailwind` â†’ returns empty `{}` to silence errors
5. Tests pass... but you're now testing mocks, not real components

**60+ test files** in the codebase mock both libraries together for this reason. The solution is to mock **neither** - they're designed to work together in tests.

### Before You Mock for TestIDs, Ask These Questions

1. **Am I mocking just to add a testID?** â†’ STOP - the component likely already supports testID
2. **Does the component have a `testID` prop?** â†’ Use it directly
3. **Does the component have child prop objects?** â†’ Pass testID through them (e.g., `closeButtonProps={{ testID: '...' }}`)
4. **Is this from `@metamask/design-system-react-native` or `app/component-library`?** â†’ It supports testID - DON'T MOCK

### Correct Mocking Pattern

```ts
// âœ… CORRECT
import { apiService } from '../services/api';
jest.mock('../services/api');
const mockApiService = apiService as jest.Mocked<typeof apiService>;

interface MockEvent {
  type: EventType;
  event: string;
  timestamp: string;
}

// âŒ WRONG
const mockApi = require('../services/api'); // âŒ no require
const mockApi: any = jest.fn();             // âŒ no any type
```

## Test Isolation and Focus - MANDATORY

- **Each test MUST be independent** - no shared state between tests
- **Use `beforeEach` for setup, `afterEach` for cleanup**
- **Reset all mocks between tests**
- **Tests MUST run in any order**
- **Avoid duplicated or polluted tests**
- **Use mocks for all external dependencies**

```ts
// âœ… CORRECT Test Isolation
describe('MetaMetricsCustomTimestampPlugin', () => {
  let plugin: MetaMetricsCustomTimestampPlugin;

  beforeEach(() => {
    plugin = new MetaMetricsCustomTimestampPlugin({
      timestampStrategy: 'fixed',
      customTimestamp: '1970-01-01T00:00:00.000Z',
    });
    jest.clearAllMocks();
  });

  afterEach(() => {
    jest.resetAllMocks();
  });

  it('returns fixed timestamp for privacy events', () => {
    const event = createTestEvent({ privacyTimestamp: true });

    const result = plugin.execute(event);

    expect(result.timestamp).toBe('1970-01-01T00:00:00.000Z');
  });
});
```

## Test Coverage (MANDATORY)

**EVERY component MUST test:**
- âœ… **Happy path** - normal expected behavior
- âœ… **Edge cases** - null, undefined, empty values, boundary conditions
- âœ… **Error conditions** - invalid inputs, failure scenarios
- âœ… **Different code paths** - all if/else branches, switch cases
- âœ… **Method chaining** - for builder patterns
- âœ… **Side effects** - property changes, state updates, cleanup

```ts
// âœ… CORRECT Coverage Example
describe('MetaMetricsCustomTimestampPlugin', () => {
  describe('execute', () => {
    it('returns fixed timestamp for privacy events', () => {
      // Happy path
    });

    it('ignores events without privacy timestamp property', () => {
      // Edge case
    });

    it('throws error when strategy is null', () => {
      // Error condition
    });

    it('uses event-specific timestamp strategy when provided', () => {
      // Different code path
    });

    it('removes privacy properties from event', () => {
      // Side effect
    });
  });
});
```

## Parameterized Tests

- Parameterize tests to cover all values (e.g., enums) with type-safe iteration.

```ts
it.each(['small', 'medium', 'large'] as const)('renders %s size', (size) => {
  expect(renderComponent(size)).toBeOnTheScreen();
});
```

## Test Determinism

- **EVERYTHING** not under test must be mocked - no exceptions.
- Avoid brittle tests: do not test internal state or UI snapshots for logic.
- Only test public behavior, not implementation details.
- Mock time, randomness, and external systems to ensure consistent results.

```ts
// Mock all external dependencies
jest.mock('../services/api');
jest.mock('../utils/date');
jest.mock('../hooks/useAuth');

jest.useFakeTimers();
jest.setSystemTime(new Date('2024-01-01'));
```

- Avoid relying on global state or hardcoded values (e.g., dates) or mock it.

## Async Testing and act() - CRITICAL

**ALWAYS use `act()` when testing async operations that trigger React state updates.**

### When to Use act()

Use `act()` when you:
- Call async functions via component props (e.g., `onRefresh`, `onPress` with async handlers)
- Invoke functions that perform state updates asynchronously
- Test pull-to-refresh or other async interactions

### Symptoms of Missing act()

Tests fail intermittently with:
- `TypeError: terminated`
- `SocketError: other side closed`
- Warnings about state updates not being wrapped in act()

### Examples

```ts
// âŒ WRONG - Causes flaky tests
it('calls Logger.error when handleOnRefresh fails', async () => {
  const mockLoggerError = jest.spyOn(Logger, 'error');
  render(BankDetails);

  // Async function called without act() - causes race condition
  screen
    .getByTestId('refresh-control-scrollview')
    .props.refreshControl.props.onRefresh();

  await waitFor(() => {
    expect(mockLoggerError).toHaveBeenCalled();
  });
});

// âœ… CORRECT - Properly handles async state updates
it('calls Logger.error when handleOnRefresh fails', async () => {
  const mockLoggerError = jest.spyOn(Logger, 'error');
  render(BankDetails);

  // Wrap async operation in act()
  await act(async () => {
    await screen
      .getByTestId('refresh-control-scrollview')
      .props.refreshControl.props.onRefresh();
  });

  await waitFor(() => {
    expect(mockLoggerError).toHaveBeenCalled();
  });
});
```

### Common Patterns Requiring act()

```ts
// RefreshControl callbacks
await act(async () => {
  await refreshControl.props.onRefresh();
});

// Async button press handlers
await act(async () => {
  await button.props.onPress();
});

// Any async callback that updates state
await act(async () => {
  await component.props.onSomeAsyncAction();
});
```

### Why This Matters

Without `act()`:
1. Async function starts executing
2. Test continues and waits only for specific assertion
3. Jest cleanup/termination happens while promises are still pending
4. Results in "terminated" or "other side closed" errors

With `act()`:
1. React Testing Library waits for all state updates
2. All promises resolve before test proceeds
3. Clean, deterministic test execution

# Reviewer Responsibilities

- Validate that tests fail when the code is broken (test the test).
```ts
// Break the SuT and make sure this test fails
expect(result).toBe(false);
```
- Ensure tests use proper matchers (`toBeOnTheScreen` vs `toBeDefined`).
- Do not approve PRs without reviewing snapshot diffs, it can reveal errors.
- Reject tests with complex names combining multiple logical conditions (AND/OR).

# Refactoring Support

- Ensure tests provide safety nets during refactors and logic changes. Run the tests before pushing commits!
- Encourage small, testable components.
- Unit tests must act as documentation for feature expectations.

# Quality Checklist - MANDATORY

Before submitting any test file, verify:
- [ ] **No mocking components to inject testIDs** - Use `testID` props and child prop objects instead
- [ ] **No mocking of `@metamask/design-system-react-native` for testIDs** - All components support testID
- [ ] **No mocking of `app/component-library` for testIDs** - All components support testID and child prop objects
- [ ] **testIDs passed via child prop objects** - Use `closeButtonProps={{ testID }}` not mocks
- [ ] **No "should" in any test name**
- [ ] **All tests follow AAA pattern**
- [ ] **Each test has one clear purpose**
- [ ] **All code paths are tested**
- [ ] **Edge cases are covered**
- [ ] **Test data is realistic**
- [ ] **Tests are independent**
- [ ] **Assertions use `toBeOnTheScreen()`** - NOT `toBeTruthy()` or `toBeDefined()` for elements
- [ ] **Elements selected by `testID`** - NOT fragile text queries
- [ ] **Test names are descriptive**
- [ ] **No test duplication**
- [ ] **Async operations wrapped in act()** when they trigger state updates

# Common Mistakes to AVOID - CRITICAL

- âŒ **Mocking to inject testIDs** - Check for child prop objects first (`closeButtonProps`, `iconProps`, etc.)
- âŒ **Mocking @metamask/design-system-react-native for testIDs** - Components already support testID props
- âŒ **Mocking component-library components for testIDs** - They support testID via child prop objects
- âŒ **Using "should" in test names** - Use action-oriented descriptions
- âŒ **Testing multiple behaviors in one test** - One test, one behavior
- âŒ **Sharing state between tests** - Each test must be independent
- âŒ **Not testing error conditions** - Test both success and failure paths
- âŒ **Using unrealistic test data** - Use data that reflects real usage
- âŒ **Not following AAA pattern** - Always Arrange, Act, Assert
- âŒ **Not testing edge cases** - Test null, undefined, empty values
- âŒ **Using weak matchers** - Use `toBeOnTheScreen()` instead of `toBeTruthy()`/`toBeDefined()`
- âŒ **Selecting elements by text** - Use `testID` props for reliable selection
- âŒ **Not wrapping async state updates in act()** - Causes flaky "terminated" errors

# Anti-patterns to Avoid

- âŒ **NEVER mock `@metamask/design-system-react-native` to inject testIDs** - ALL components support testID props and child prop objects.
- âŒ **NEVER mock `app/component-library` components to inject testIDs** - ALL components support testID props and child prop objects.
- âŒ **NEVER mock components just to inject testIDs** - The capability already exists via child prop objects (`closeButtonProps`, etc.).
- âŒ Do not consider snapshot coverage as functional coverage.
- âŒ Do not rely on code coverage percentage without real assertions.
- âŒ Do not use weak matchers like `toBeDefined` or `toBeTruthy` to assert element presence. Use `toBeOnTheScreen()`.
- âŒ Do not select elements by text that might change (i18n keys, copy updates). Use `testID` props instead.
- âŒ Do not mock the component or function under test - only mock its external dependencies.

### Design System & Component Library Mocking - STRICTLY PROHIBITED

```tsx
// âŒ WRONG - This pattern appears in 84+ test files and must be refactored
jest.mock('@metamask/design-system-react-native', () => ({
  Box: 'View',
  Text: 'Text',
  TextVariant: { BodyMd: 'BodyMd' },
}));

// âŒ WRONG - Mocking component-library to inject testIDs
jest.mock('BottomSheetHeader', () => {
  return ({ onClose }) => (
    <TouchableOpacity testID="close-button" onPress={onClose}>Close</TouchableOpacity>
  );
});
// This is 30+ lines of code to add a testID that already exists via closeButtonProps!

// âœ… CORRECT - Use child prop objects to pass testIDs
<BottomSheetHeader
  onClose={handleClose}
  closeButtonProps={{ testID: 'modal-close-button' }}
/>

// âœ… CORRECT - No mock needed, use real components with testID
import { render, screen, fireEvent } from '@testing-library/react-native';

it('closes modal when close button pressed', () => {
  render(<MyModal />);
  
  fireEvent.press(screen.getByTestId('modal-close-button'));
  
  expect(mockOnClose).toHaveBeenCalled();
});
```

# Unit tests developement workflow

- Always run unit tests after making code changes.
- **NEVER** use npm, npx, or other package managers - ONLY use yarn

## Testing Commands

### Single File Testing
```shell
# Use this command for testing a specific file
yarn jest <filename>
# Use this command for testing specific test cases
yarn jest <filename> -t "<test-name-pattern>"
# Use this command for running all unit tests
yarn test:unit
# Run a specific test file
yarn jest MyComponent.test.tsx
yarn jest utils/helpers.test.ts
```

### Coverage Reports
```shell
# Use this command for coverage reports
yarn test:unit:coverage
```


## Workflow Requirements
- Confirm all tests are passing before commit.
- When a snapshot update is detected, confirm the changes are expected.
- Do not blindly update snapshots without understanding the differences.

# Reference Code Examples

**Proper AAA**:
```ts
it('indicates expired milk when past due date', () => {
  const today = new Date('2025-06-01');
  const milk = { expiration: new Date('2025-05-30') };

  const result = isMilkGood(today, milk);

  expect(result).toBe(false);
});
```

## âŒ Brittle Snapshot
```ts
it('renders the button', () => {
  const { container } = render(<MyButton />);
  expect(container).toMatchSnapshot(); // ðŸš« fails on minor style changes
});
```

## âœ… Robust UI Assertion
```ts
it('displays error message when API fails', async () => {
  mockApi.failOnce();
  const { findByText } = render(<MyComponent />);

  expect(await findByText('Something went wrong')).toBeOnTheScreen();
});
```

**Test the Test**:
```ts
it('hides selector when disabled', () => {
  const { queryByTestId } = render(<Selector enabled={false} />);

  expect(queryByTestId('IPFS_GATEWAY_SELECTED')).toBeNull();
  
  // Break test: change enabled={false} to enabled={true} and verify test fails
});
```

## Reviewer Responsibilities

Validate tests fail when code breaks â€¢ Ensure proper matchers â€¢ Review snapshot diffs â€¢ Reject complex names with AND/OR

```ts
// OK
it('renders button when enabled')

// NOT OK
it('renders and disables button when input is empty or missing required field')
```

## Workflow

Always run tests after changes â€¢ Confirm all pass before commit â€¢ Review snapshot changes â€¢ Don't blindly update snapshots

**Resources**: [Contributor docs](https://github.com/MetaMask/contributor-docs/blob/main/docs/testing/unit-testing.md) â€¢ [Jest Matchers](https://jestjs.io/docs/using-matchers) â€¢ [React Native Testing Library](https://testing-library.com/docs/react-native-testing-library/intro/)
