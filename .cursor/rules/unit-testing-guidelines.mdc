---
description: Project Guidelines for Unit Testing
globs: *.test.*
alwaysApply: false
---

Reference: [MetaMask Unit Testing Guidelines](https://github.com/MetaMask/contributor-docs/blob/main/docs/testing/unit-testing.md)

# Unit Testing Guidelines

## Test Naming Rules

- **NEVER use "should" in test names** - this is a hard rule with zero exceptions
- **Use action-oriented descriptions** that describe what the code does
- **Be specific about the behavior being tested**
- **AVOID** weasel words like "handle", "manage", or other non-specific action verbs
- **AVOID** subjective outcome words like "successfully", "correctly", "invalid" - instead indicate what the actual result should be
- **BE SPECIFIC** about conditions: use "email without domain" instead of "invalid email"

```ts
// ‚ùå WRONG
it('should return fixed timestamp', () => { ... });
it('should ignore events', () => { ... });
it('should display error when input is invalid', () => { ... });
it('handles invalid input correctly', () => { ... });

// ‚úÖ CORRECT
it('returns fixed timestamp for privacy events', () => { ... });
it('ignores events without privacy timestamp property', () => { ... });
it('displays error when email is missing @ symbol', () => { ... });
it('returns false for email without domain', () => { ... });
```

## Test Structure and Organization - MANDATORY

- **EVERY test MUST follow the AAA pattern** (Arrange, Act, Assert) with blank line separation
- **Each test must cover ONE behavior** and be isolated from others
- **Use helper functions** for test data creation
- **Group related tests** in `describe` blocks

```ts
it('returns false for email without domain', () => {
  const input = 'user@';

  const result = validateEmail(input);

  expect(result).toBe(false);
});
```

**Helper Functions**:
```ts
const createTestEvent = (overrides = {}) => ({
  type: EventType.TrackEvent,
  event: 'Test Event',
  timestamp: '2024-01-01T12:00:00.000Z',
  ...overrides,
});
```

## Mocking Rules - CRITICAL

- **EVERYTHING not under test MUST be mocked** - no exceptions
- **NO** use of `require` - use ES6 imports only
- **NO** use of `any` type - use proper TypeScript types
- **Mock all external dependencies** including APIs, services, hooks
- **Use realistic mock data** that reflects real usage
- **Avoid excessive mocking** - prefer testing UI elements directly with `toBeOnTheScreen()` instead of mocking component internals

```ts
// ‚úÖ CORRECT
import { apiService } from '../services/api';
jest.mock('../services/api');
const mockApiService = apiService as jest.Mocked<typeof apiService>;

interface MockEvent {
  type: EventType;
  event: string;
  timestamp: string;
}

// ‚ùå WRONG
const mockApi = require('../services/api'); // ‚ùå no require
const mockApi: any = jest.fn();             // ‚ùå no any type
```

## Element Selection and Assertions - MANDATORY

### Prefer Data Test IDs

- **ALWAYS prefer `testID` (data-testid) for element selection** - provides stable, semantic selectors
- **Use descriptive test IDs** that reflect the element's purpose, not implementation details
- **Avoid selecting by text content** when possible - text can change, test IDs are stable

```ts
// ‚úÖ CORRECT - Using testID
it('displays loading indicator during fetch', () => {
  render(<MyComponent />);
  
  expect(screen.getByTestId('loading-indicator')).toBeOnTheScreen();
});

// ‚ùå WRONG - Selecting by text (brittle)
it('displays loading indicator during fetch', () => {
  render(<MyComponent />);
  
  expect(screen.getByText('Loading...')).toBeOnTheScreen(); // ‚ùå text can change
});
```

### Prefer `toBeOnTheScreen()` Over Weak Matchers

- **ALWAYS use `toBeOnTheScreen()`** to verify elements are rendered and visible
- **NEVER use `toBeTruthy()`, `toBeDefined()`, or `toBeNull()`** for element presence assertions
- **Use `toBeOnTheScreen()`** instead of excessive mocking to verify UI state

```ts
// ‚úÖ CORRECT - Direct UI verification
it('displays error message when API fails', async () => {
  mockApi.failOnce();
  render(<MyComponent />);

  expect(await screen.findByTestId('error-message')).toBeOnTheScreen();
});

// ‚ùå WRONG - Weak matcher
it('displays error message when API fails', async () => {
  mockApi.failOnce();
  const { queryByTestId } = render(<MyComponent />);

  expect(queryByTestId('error-message')).toBeTruthy(); // ‚ùå weak assertion
});

// ‚ùå WRONG - Excessive mocking instead of UI verification
it('displays error message when API fails', async () => {
  const mockSetError = jest.fn();
  jest.spyOn(MyComponent, 'setError').mockImplementation(mockSetError);
  mockApi.failOnce();
  render(<MyComponent />);

  expect(mockSetError).toHaveBeenCalled(); // ‚ùå testing implementation, not UI
});
```

### When to Use Different Query Methods

- **`getByTestId`** - Element must exist (throws if not found)
- **`queryByTestId`** - Element may not exist (returns null if not found)
- **`findByTestId`** - Element appears asynchronously (returns promise)

```ts
// Element must be present
expect(screen.getByTestId('submit-button')).toBeOnTheScreen();

// Element may not be present
expect(screen.queryByTestId('error-message')).toBeNull();

// Element appears asynchronously
expect(await screen.findByTestId('success-message')).toBeOnTheScreen();
```

## Test Isolation and Focus - MANDATORY

- **Each test MUST be independent** - no shared state between tests
- **Use `beforeEach` for setup, `afterEach` for cleanup**
- **Reset all mocks between tests**
- **Tests MUST run in any order**
- **Avoid duplicated or polluted tests**
- **Use mocks for all external dependencies**

```ts
// ‚úÖ CORRECT Test Isolation
describe('MetaMetricsCustomTimestampPlugin', () => {
  let plugin: MetaMetricsCustomTimestampPlugin;

  beforeEach(() => {
    plugin = new MetaMetricsCustomTimestampPlugin({
      timestampStrategy: 'fixed',
      customTimestamp: '1970-01-01T00:00:00.000Z',
    });
    jest.clearAllMocks();
  });

  afterEach(() => {
    jest.resetAllMocks();
  });

  it('returns fixed timestamp for privacy events', () => {
    const event = createTestEvent({ privacyTimestamp: true });

    const result = plugin.execute(event);

    expect(result.timestamp).toBe('1970-01-01T00:00:00.000Z');
  });
});
```

## Test Coverage (MANDATORY)

**EVERY component MUST test:**
- ‚úÖ **Happy path** - normal expected behavior
- ‚úÖ **Edge cases** - null, undefined, empty values, boundary conditions
- ‚úÖ **Error conditions** - invalid inputs, failure scenarios
- ‚úÖ **Different code paths** - all if/else branches, switch cases
- ‚úÖ **Method chaining** - for builder patterns
- ‚úÖ **Side effects** - property changes, state updates, cleanup

```ts
// ‚úÖ CORRECT Coverage Example
describe('MetaMetricsCustomTimestampPlugin', () => {
  describe('execute', () => {
    it('returns fixed timestamp for privacy events', () => {
      // Happy path
    });

    it('ignores events without privacy timestamp property', () => {
      // Edge case
    });

    it('throws error when strategy is null', () => {
      // Error condition
    });

    it('uses event-specific timestamp strategy when provided', () => {
      // Different code path
    });

    it('removes privacy properties from event', () => {
      // Side effect
    });
  });
});
```

## Parameterized Tests

- Parameterize tests to cover all values (e.g., enums) with type-safe iteration.

```ts
it.each(['small', 'medium', 'large'] as const)('renders %s size', (size) => {
  expect(renderComponent(size)).toBeOnTheScreen();
});
```

## Test Determinism

- **EVERYTHING** not under test must be mocked - no exceptions.
- Avoid brittle tests: do not test internal state or UI snapshots for logic.
- Only test public behavior, not implementation details.
- Mock time, randomness, and external systems to ensure consistent results.

```ts
// Mock all external dependencies
jest.mock('../services/api');
jest.mock('../utils/date');
jest.mock('../hooks/useAuth');

jest.useFakeTimers();
jest.setSystemTime(new Date('2024-01-01'));
```

- Avoid relying on global state or hardcoded values (e.g., dates) or mock it.

## Async Testing and act() - CRITICAL

**ALWAYS use `act()` when testing async operations that trigger React state updates.**

### When to Use act()

Use `act()` when you:
- Call async functions via component props (e.g., `onRefresh`, `onPress` with async handlers)
- Invoke functions that perform state updates asynchronously
- Test pull-to-refresh or other async interactions

### Symptoms of Missing act()

Tests fail intermittently with:
- `TypeError: terminated`
- `SocketError: other side closed`
- Warnings about state updates not being wrapped in act()

### Examples

```ts
// ‚ùå WRONG - Causes flaky tests
it('calls Logger.error when handleOnRefresh fails', async () => {
  const mockLoggerError = jest.spyOn(Logger, 'error');
  render(BankDetails);

  // Async function called without act() - causes race condition
  screen
    .getByTestId('refresh-control-scrollview')
    .props.refreshControl.props.onRefresh();

  await waitFor(() => {
    expect(mockLoggerError).toHaveBeenCalled();
  });
});

// ‚úÖ CORRECT - Properly handles async state updates
it('calls Logger.error when handleOnRefresh fails', async () => {
  const mockLoggerError = jest.spyOn(Logger, 'error');
  render(BankDetails);

  // Wrap async operation in act()
  await act(async () => {
    await screen
      .getByTestId('refresh-control-scrollview')
      .props.refreshControl.props.onRefresh();
  });

  await waitFor(() => {
    expect(mockLoggerError).toHaveBeenCalled();
  });
});
```

### Common Patterns Requiring act()

```ts
// RefreshControl callbacks
await act(async () => {
  await refreshControl.props.onRefresh();
});

// Async button press handlers
await act(async () => {
  await button.props.onPress();
});

// Any async callback that updates state
await act(async () => {
  await component.props.onSomeAsyncAction();
});
```

### Why This Matters

Without `act()`:
1. Async function starts executing
2. Test continues and waits only for specific assertion
3. Jest cleanup/termination happens while promises are still pending
4. Results in "terminated" or "other side closed" errors

With `act()`:
1. React Testing Library waits for all state updates
2. All promises resolve before test proceeds
3. Clean, deterministic test execution

# Reviewer Responsibilities

- Validate that tests fail when the code is broken (test the test).
```ts
// Break the SuT and make sure this test fails
expect(result).toBe(false);
```
- **Ensure tests use proper matchers** - Always `toBeOnTheScreen()` for element presence, never `toBeTruthy()` or `toBeDefined()`.
- **Verify data test IDs are used** - Prefer `getByTestId()` over `getByText()` for element selection.
- **Check for excessive mocking** - Prefer direct UI verification with `toBeOnTheScreen()` over mocking component internals.
- Do not approve PRs without reviewing snapshot diffs, it can reveal errors.
- Reject tests with complex names combining multiple logical conditions (AND/OR).

# Refactoring Support

- Ensure tests provide safety nets during refactors and logic changes. Run the tests before pushing commits!
- Encourage small, testable components.
- Unit tests must act as documentation for feature expectations.

# Quality Checklist - MANDATORY

Before submitting any test file, verify:
- [ ] **No "should" in any test name**
- [ ] **All tests follow AAA pattern**
- [ ] **Each test has one clear purpose**
- [ ] **All code paths are tested**
- [ ] **Edge cases are covered**
- [ ] **Test data is realistic**
- [ ] **Tests are independent**
- [ ] **Assertions are specific** - Use `toBeOnTheScreen()` for element presence, never `toBeTruthy()` or `toBeDefined()`
- [ ] **Data test IDs are used** - Prefer `getByTestId()` over `getByText()` for element selection
- [ ] **No excessive mocking** - Prefer direct UI verification with `toBeOnTheScreen()` over mocking internals
- [ ] **Test names are descriptive**
- [ ] **No test duplication**
- [ ] **Async operations wrapped in act()** when they trigger state updates

# Common Mistakes to AVOID - CRITICAL

- ‚ùå **Using "should" in test names** - This is the #1 mistake
- ‚ùå **Testing multiple behaviors in one test** - One test, one behavior
- ‚ùå **Sharing state between tests** - Each test must be independent
- ‚ùå **Not testing error conditions** - Test both success and failure paths
- ‚ùå **Using unrealistic test data** - Use data that reflects real usage
- ‚ùå **Not following AAA pattern** - Always Arrange, Act, Assert
- ‚ùå **Not testing edge cases** - Test null, undefined, empty values
- ‚ùå **Using weak matchers** - Use specific assertions like `toBe()`, `toEqual()`, `toBeOnTheScreen()`
- ‚ùå **Using `toBeTruthy()` or `toBeDefined()` for element presence** - Always use `toBeOnTheScreen()`
- ‚ùå **Selecting elements by text instead of testID** - Prefer `getByTestId()` over `getByText()`
- ‚ùå **Excessive mocking instead of UI verification** - Test what users see with `toBeOnTheScreen()`
- ‚ùå **Not wrapping async state updates in act()** - Causes flaky "terminated" errors

# Anti-patterns to Avoid

- ‚ùå Do not consider snapshot coverage as functional coverage.
- ‚ùå Do not rely on code coverage percentage without real assertions.
- ‚ùå **NEVER use weak matchers** like `toBeDefined()`, `toBeTruthy()`, or `toBeNull()` to assert element presence. **ALWAYS use `toBeOnTheScreen()`**.
- ‚ùå **NEVER select elements by text content** when a stable `testID` is available - prefer `getByTestId()` over `getByText()`.
- ‚ùå **NEVER mock component internals** to verify UI state - prefer direct UI verification with `toBeOnTheScreen()`.
- ‚ùå **NEVER use excessive mocking** when you can verify UI elements directly - test what users see, not implementation details.

# Unit tests developement workflow

- Always run unit tests after making code changes.
- **NEVER** use npm, npx, or other package managers - ONLY use yarn

## Testing Commands

### Single File Testing
```shell
# Use this command for testing a specific file
yarn jest <filename>
# Use this command for testing specific test cases
yarn jest <filename> -t "<test-name-pattern>"
# Use this command for running all unit tests
yarn test:unit
# Run a specific test file
yarn jest MyComponent.test.tsx
yarn jest utils/helpers.test.ts
```

### Coverage Reports
```shell
# Use this command for coverage reports
yarn test:unit:coverage
```


## Workflow Requirements
- Confirm all tests are passing before commit.
- When a snapshot update is detected, confirm the changes are expected.
- Do not blindly update snapshots without understanding the differences.

# Reference Code Examples

**Proper AAA**:
```ts
it('indicates expired milk when past due date', () => {
  const today = new Date('2025-06-01');
  const milk = { expiration: new Date('2025-05-30') };

  const result = isMilkGood(today, milk);

  expect(result).toBe(false);
});
```

## ‚ùå Brittle Snapshot
```ts
it('renders the button', () => {
  const { container } = render(<MyButton />);
  expect(container).toMatchSnapshot(); // üö´ fails on minor style changes
});
```

## ‚úÖ Robust UI Assertion
```ts
it('displays error message when API fails', async () => {
  mockApi.failOnce();
  render(<MyComponent />);

  expect(await screen.findByTestId('error-message')).toBeOnTheScreen();
});
```

**Test the Test**:
```ts
it('hides selector when disabled', () => {
  render(<Selector enabled={false} />);

  expect(screen.queryByTestId('IPFS_GATEWAY_SELECTED')).toBeNull();
  
  // Break test: change enabled={false} to enabled={true} and verify test fails
});

it('displays selector when enabled', () => {
  render(<Selector enabled={true} />);

  expect(screen.getByTestId('IPFS_GATEWAY_SELECTED')).toBeOnTheScreen();
  
  // Break test: change enabled={true} to enabled={false} and verify test fails
});
```

## Reviewer Responsibilities

Validate tests fail when code breaks ‚Ä¢ Ensure proper matchers ‚Ä¢ Review snapshot diffs ‚Ä¢ Reject complex names with AND/OR

```ts
// OK
it('renders button when enabled')

// NOT OK
it('renders and disables button when input is empty or missing required field')
```

## Workflow

Always run tests after changes ‚Ä¢ Confirm all pass before commit ‚Ä¢ Review snapshot changes ‚Ä¢ Don't blindly update snapshots

**Resources**: [Contributor docs](https://github.com/MetaMask/contributor-docs/blob/main/docs/testing/unit-testing.md) ‚Ä¢ [Jest Matchers](https://jestjs.io/docs/using-matchers) ‚Ä¢ [React Native Testing Library](https://testing-library.com/docs/react-native-testing-library/intro/)
