---
description: UI Development Guidelines
globs:
  - 'app/**/*.{tsx,jsx}'
alwaysApply: true
---

# MetaMask Mobile React Native UI Development Guidelines

## Core Principle

Always prioritize @metamask/design-system-react-native components and Tailwind CSS patterns over custom implementations.

## Component Hierarchy (STRICT ORDER)

### The Rule: Check Design System First
**Before writing any new component or choosing what to use, ask: "Does @metamask/design-system-react-native have this?"**

1. **FIRST**: Use `@metamask/design-system-react-native` components
   - **Always use for**: Box (layout), Text (typography), Button/ButtonBase/ButtonIcon, Icon, Checkbox
   - **Always use for**: Avatar variants (Account, Base, Favicon, Group, Icon, Network, Token)
   - **Always use for**: Badge variants (Count, Icon, Network, Status, Wrapper)
   - **Rule**: If it exists in the design system, you MUST use it

2. **SECOND**: Use `app/component-library` ONLY if design system lacks it
   - **Use for**: BottomSheet, Tabs, Headers, ListItems, Skeleton, Tags, Modal, Overlay, Toast, RadioButton, etc.
   - **Rule**: These are MetaMask-specific implementations not (yet) in the design system
   - **Important**: component-library components should themselves use design system primitives internally

3. **THIRD**: Feature-specific components
   - **Use for**: Complex, domain-specific UI that combines multiple design system/component-library components
   - **Examples**: `BridgeInputSelector`, `StakeInputView`, `NFTDetailsModal`, `PerpsTradingCard`, `PredictionMarketOrderPanel`
   - **Location**: Can live in feature directories (`app/components/Views/*/components/`, `app/features/*/`)
   - **Rule**: Must be built using Box, Text, and other design system primitives - NO raw View/Text or StyleSheet
   - **Reuse**: Check if a feature-specific component already exists in the feature's directory before building a new one. These components should be reused within their feature domain.

4. **LAST RESORT**: Custom components with StyleSheet
   - **Only when**: Highly specialized one-off needs with no design system equivalent AND no component-library equivalent
   - **Requires**: Strong justification why design system primitives can't be composed

### Decision Tree
```
Need a component?
  ‚îú‚îÄ Is it Box, Text, Button, Icon, Avatar, Badge, or Checkbox?
  ‚îÇ  ‚îî‚îÄ YES ‚Üí Use @metamask/design-system-react-native [STOP]
  ‚îÇ
  ‚îú‚îÄ Is it BottomSheet, Tabs, Header, ListItem, Skeleton, Tag, Modal, etc?
  ‚îÇ  ‚îî‚îÄ YES ‚Üí Use app/component-library [STOP]
  ‚îÇ
  ‚îú‚îÄ Is it feature-specific UI (e.g., PerpsTradingCard, PredictionMarketOrderPanel)?
  ‚îÇ  ‚îú‚îÄ Does it already exist in the feature's directory?
  ‚îÇ  ‚îÇ  ‚îú‚îÄ YES ‚Üí Reuse existing component [STOP]
  ‚îÇ  ‚îÇ  ‚îî‚îÄ NO ‚Üí Build new feature component using design system primitives [STOP]
  ‚îÇ  ‚îî‚îÄ
  ‚îÇ
  ‚îî‚îÄ Can I compose it from Box + Text + other primitives?
     ‚îú‚îÄ YES ‚Üí Compose from design system [STOP]
     ‚îî‚îÄ NO ‚Üí Consider if custom implementation is truly necessary
```

### Why This Hierarchy Matters
- **Consistency**: Design system ensures consistent look, feel, and behavior
- **Maintenance**: Centralized updates benefit all consumers
- **Accessibility**: Design system components include a11y best practices
- **Performance**: Optimized implementations tested at scale
- **Type Safety**: Full TypeScript support with JSDoc documentation

## Feature-Specific Component Organization

### Working with Feature Components

When implementing UI that is specific to a feature (e.g., Perps, Predictions, Bridge, Stake):

1. **Check for existing components FIRST**
   - Look in the feature's component directory: `app/features/[feature-name]/components/` or `app/components/Views/[FeatureName]/components/`
   - Search for similar component names or functionality
   - Use Glob/Grep to find existing implementations

2. **Reuse existing feature components**
   - If a `PerpsTradingCard` already exists, use it
   - If a `PredictionMarketOrderPanel` already exists, use it
   - These components are already built with design system primitives and are optimized for their feature

3. **Build new feature components only when needed**
   - If the component doesn't exist, build it using design system primitives
   - Place it in the appropriate feature directory
   - Name it clearly to indicate its purpose and feature domain

4. **Feature component guidelines**
   - **DO**: Build feature components from Box, Text, Button, Icon, etc.
   - **DO**: Reuse these components within the feature
   - **DO**: Keep them in feature-specific directories
   - **DON'T**: Use StyleSheet or raw View/Text components
   - **DON'T**: Duplicate functionality - check for existing components first
   - **DON'T**: Make feature components overly generic - they serve specific feature needs

### Example Directory Structure
```
app/
‚îú‚îÄ‚îÄ features/
‚îÇ   ‚îú‚îÄ‚îÄ perps/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ components/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ PerpsTradingCard/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ PerpsPositionPanel/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ PerpsOrderForm/
‚îÇ   ‚îú‚îÄ‚îÄ predictions/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ components/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ PredictionMarketCard/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ PredictionOutcomeSelector/
‚îÇ   ‚îî‚îÄ‚îÄ bridge/
‚îÇ       ‚îî‚îÄ‚îÄ components/
‚îÇ           ‚îî‚îÄ‚îÄ BridgeInputSelector/
‚îî‚îÄ‚îÄ components/
    ‚îî‚îÄ‚îÄ Views/
        ‚îî‚îÄ‚îÄ Stake/
            ‚îî‚îÄ‚îÄ components/
                ‚îî‚îÄ‚îÄ StakeInputView/
```

### Workflow: Implementing a Feature Component

1. **Identify the feature** - Determine which feature this component belongs to (Perps, Predictions, Bridge, etc.)
2. **Search the codebase** - Use Glob/Grep to find if a similar component already exists in the feature's directory
3. **Reuse or build** - If found, reuse it. If not, build it with design system primitives
4. **Place correctly** - Put it in the appropriate feature directory
5. **Document** - Add clear props and purpose if it's a new component

## Required Imports for React Native

```tsx
// ALWAYS prefer these imports
import { useTailwind } from '@metamask/design-system-twrnc-preset';
import {
  Box,
  Text,
  Button,
  ButtonBase,
  Icon,
  TextVariant,
  BoxFlexDirection,
  BoxAlignItems,
  BoxJustifyContent,
  // ... other design system components
} from '@metamask/design-system-react-native';
```

## Component Documentation Access

### Type Definitions & JSDoc Comments
All @metamask/design-system-react-native components have comprehensive TypeScript definitions with JSDoc comments:

- **Box**: `/node_modules/@metamask/design-system-react-native/dist/components/Box/Box.types.d.cts`
- **Text**: `/node_modules/@metamask/design-system-react-native/dist/components/Text/Text.types.d.cts`
- **Button**: `/node_modules/@metamask/design-system-react-native/dist/components/Button/Button.types.d.cts`

When unsure about component APIs:
1. Read the `.types.d.cts` files for complete prop documentation
2. Reference `app/component-library/components/design-system.stories.tsx` for usage examples
3. Check GitHub source: https://github.com/MetaMask/metamask-design-system/tree/main/packages/design-system-react-native/src/components

### Box Component Quick Reference
- **Spacing**: Use `gap`, `padding*`, `margin*` props with values 0-12 (maps to 0px-48px)
- **Flexbox**: Use `flexDirection`, `alignItems`, `justifyContent` enum props
- **Colors**: Use `backgroundColor` and `borderColor` with semantic tokens
- **Tailwind**: Use `twClassName` for utilities not covered by props

## Styling Rules (ENFORCE STRICTLY)

### ‚úÖ ALWAYS DO:

- Use `const tw = useTailwind();` hook instead of importing twrnc directly
- Use `Box` component instead of `View`
- Use `Text` component with variants instead of raw Text with styles
- Use `twClassName` prop for static styles
- Use `tw.style()` function for interactive/dynamic styles
- Use design system color tokens: `bg-default`, `text-primary`, `border-muted`
- Use component props first: `variant`, `color`, `size`, etc.

### ‚ùå NEVER SUGGEST:

- `import tw from 'twrnc'` (use useTailwind hook instead)
- `StyleSheet.create()` (use Tailwind classes)
- Raw `View` or `Text` components (use Box/Text from design system)
- Arbitrary color values like `bg-[#3B82F6]` or `text-[#000000]`
- Inline style objects unless for dynamic values
- Mixing multiple styling approaches unnecessarily

## Code Pattern Templates

### Basic Container:

```tsx
const MyComponent = () => {
  const tw = useTailwind();

  return (
    <Box twClassName="w-full bg-default p-4">
      <Text variant={TextVariant.HeadingMd}>Title</Text>
    </Box>
  );
};
```

### Flex Layout:

```tsx
<Box
  flexDirection={BoxFlexDirection.Row}
  alignItems={BoxAlignItems.Center}
  justifyContent={BoxJustifyContent.Between}
  twClassName="gap-3"
>
```

### Interactive Element:

```tsx
<ButtonBase
  twClassName="h-20 flex-1 rounded-lg bg-muted px-0 py-4"
  style={({ pressed }) =>
    tw.style(
      'w-full flex-row items-center justify-center',
      pressed && 'bg-pressed',
    )
  }
>
  <Text fontWeight={FontWeight.Medium}>Button Text</Text>
</ButtonBase>
```

### Pressable with Tailwind:

```tsx
<Pressable
  style={({ pressed }) =>
    tw.style(
      'w-full flex-row items-center justify-between px-4 py-2',
      pressed && 'bg-pressed',
    )
  }
>
```

## Box Component Best Practices

### Prefer Props Over twClassName for Layout
‚úÖ **DO** - Use typed props for type safety and consistency:
```tsx
<Box
  flexDirection={BoxFlexDirection.Row}
  alignItems={BoxAlignItems.Center}
  justifyContent={BoxJustifyContent.Between}
  gap={3}
  padding={4}
  margin={2}
>
```

‚ùå **DON'T** - Use twClassName for properties that have dedicated props:
```tsx
<Box twClassName="flex-row items-center justify-between gap-3 p-4 m-2">
```

### When to Use twClassName
Use `twClassName` for:
- Width and height: `w-full`, `h-20`, `w-[337px]`
- Complex positioning: `absolute`, `relative`, `top-0`, `left-0`
- Borders (partial): `rounded-lg`, `border-t`
- Shadows and opacity: `shadow-lg`, `opacity-50`
- Utilities not covered by props: `overflow-hidden`, `z-10`

### Spacing System
- Use numeric props (0-12) for spacing: `padding={4}` = 16px
- Each unit = 4px (so 12 = 48px max)
- For custom spacing beyond 48px, use twClassName: `twClassName="p-20"`

### Color Tokens
Always use semantic color tokens:
```tsx
// ‚úÖ Semantic tokens
<Box backgroundColor={BoxBackgroundColor.BackgroundDefault}>
<Box backgroundColor={BoxBackgroundColor.PrimaryDefault}>
<Box backgroundColor={BoxBackgroundColor.ErrorMuted}>

// ‚ùå Arbitrary colors
<Box twClassName="bg-[#3B82F6]">
<Box style={{ backgroundColor: '#FF0000' }}>
```

## Component Conversion Guide

| DON'T Use                            | USE Instead                            |
| ------------------------------------ | -------------------------------------- |
| `<View>`                             | `<Box>`                                |
| `<Text style={...}>`                 | `<Text variant={TextVariant.BodyMd}>`  |
| `StyleSheet.create()`                | `twClassName="..."`                    |
| `style={{ backgroundColor: 'red' }}` | `twClassName="bg-error-default"`       |
| `flexDirection: 'row'`               | `flexDirection={BoxFlexDirection.Row}` |
| Manual padding/margin                | `twClassName="p-4 m-2"`                |

## Legacy Code Migration Guidelines

### Identifying Legacy Patterns
üö´ **Anti-patterns to refactor when encountered:**
- Files using `StyleSheet.create()`
- Separate `.styles.ts` or `.styles.tsx` files
- Raw `View` components instead of `Box`
- Raw `Text` components with custom styles instead of design system `Text` with variants
- Inline style objects for static styles

### Migration Priority
1. **High Priority**: Components being actively modified
2. **Medium Priority**: Frequently used shared components in `app/component-library`
3. **Low Priority**: Stable legacy components with no active development

### Migration Steps
1. Replace `View` ‚Üí `Box` from design system
2. Replace `Text` ‚Üí `Text` with appropriate `TextVariant`
3. Convert `StyleSheet.create()` styles ‚Üí `twClassName` props or `tw.style()`
4. Convert arbitrary colors ‚Üí design system color tokens
5. Delete `.styles.ts` files after migration
6. Test thoroughly - layout can shift during migration

### Example Migration

**Before:**
```tsx
import { View, Text, StyleSheet } from 'react-native';

const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
    backgroundColor: '#ffffff',
  },
  title: {
    fontSize: 16,
    fontWeight: '500',
    color: '#000000',
  },
});

<View style={styles.container}>
  <Text style={styles.title}>Title</Text>
</View>
```

**After:**
```tsx
import { useTailwind } from '@metamask/design-system-twrnc-preset';
import { Box, Text, TextVariant, BoxFlexDirection, BoxAlignItems, FontWeight } from '@metamask/design-system-react-native';

const tw = useTailwind();

<Box
  flexDirection={BoxFlexDirection.Row}
  alignItems={BoxAlignItems.Center}
  twClassName="p-4 bg-default"
>
  <Text variant={TextVariant.BodyMd} fontWeight={FontWeight.Medium}>
    Title
  </Text>
</Box>
```

## Error Prevention & Code Review Checklist

### Before Committing Code, Verify:
- [ ] No `import tw from 'twrnc'` (must use `useTailwind()` hook)
- [ ] No raw `View` components (use `Box`)
- [ ] No raw `Text` without variants (use `Text` with `TextVariant`)
- [ ] No `StyleSheet.create()` (use `twClassName` or `tw.style()`)
- [ ] No arbitrary color values (use design system tokens)
- [ ] No separate `.styles.ts` files for new components
- [ ] Component props used before `twClassName` for layout
- [ ] Interactive styles use `tw.style()` with state functions

### When You See These Patterns, IMMEDIATELY Suggest Alternatives:
- Any `import tw from 'twrnc'` ‚Üí `import { useTailwind } from '@metamask/design-system-twrnc-preset'`
- Any `View` component ‚Üí `Box` from design system
- Any `StyleSheet` usage ‚Üí Tailwind classes
- Any arbitrary color values ‚Üí Design system tokens
- Any manual flex properties ‚Üí Box component props + twClassName

### AI Agent Guidelines
When suggesting code changes:
1. ALWAYS read component type definitions first for accurate API usage
2. ALWAYS check `design-system.stories.tsx` for real-world patterns
3. ALWAYS search for existing feature-specific components before building new ones (use Glob/Grep to find similar components in feature directories)
4. REJECT any suggestions that violate the hierarchy
5. SUGGEST migrations when encountering legacy patterns
6. EXPLAIN why design system approach is preferred

## Design System Priority

Before suggesting any UI solution:

1. Check if `@metamask/design-system-react-native` has the component
2. Use component's built-in props (variant, color, size)
3. Add layout/spacing with `twClassName`
4. Add interactions with `tw.style()`
5. Only suggest component-library or custom components if design system lacks it

## Reference Examples

Always reference the patterns from `app/component-library/components/design-system.stories.tsx` for proper usage examples.

## Enforcement

- REJECT any code suggestions that use StyleSheet.create()
- REJECT raw View/Text usage when Box/Text components exist
- REQUIRE useTailwind hook for all Tailwind usage
- REQUIRE design system components as first choice
- ENFORCE design token usage over arbitrary values

@app/component-library/components/design-system.stories.tsx
