name: Build Mobile App

on:
  workflow_call:
    inputs:
      build_name:
        required: true
        type: string
      platform:
        required: true
        type: string # android, ios, or both
  workflow_dispatch:
    inputs:
      build_name:
        required: true
        type: choice
        options:
          - main-prod
          - main-rc
          - main-test
          - main-e2e
          - main-exp
          - main-dev
          - flask-prod
          - flask-test
          - flask-e2e
          - flask-dev
          - qa-prod
          - qa-dev
      platform:
        required: true
        type: choice
        options: [android, ios, both]

permissions:
  contents: read
  id-token: write

jobs:
  # Load config
  prepare:
    runs-on: ubuntu-latest
    outputs:
      github_environment: ${{ steps.config.outputs.github_environment }}
      secrets_json: ${{ steps.config.outputs.secrets_json }}
      signing_aws_role: ${{ steps.config.outputs.signing_aws_role }}
      signing_aws_secret: ${{ steps.config.outputs.signing_aws_secret }}
      signing_android_keystore_path: ${{ steps.config.outputs.signing_android_keystore_path }}
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - run: yarn install --immutable
      - run: node scripts/validate-build-config.js

      - name: Load config
        id: config
        run: |
          node -e "
          const yaml = require('js-yaml');
          const fs = require('fs');
          const config = yaml.load(fs.readFileSync('.github/builds.yml', 'utf8'));
          const build = config.builds['${{ inputs.build_name }}'];
          fs.appendFileSync(process.env.GITHUB_OUTPUT, 'github_environment=' + build.github_environment + '\n');
          fs.appendFileSync(process.env.GITHUB_OUTPUT, 'secrets_json=' + JSON.stringify(build.secrets || {}) + '\n');
          const signing = build.signing;
          fs.appendFileSync(process.env.GITHUB_OUTPUT, 'signing_aws_role=' + (signing ? signing.aws_role || '' : '') + '\n');
          fs.appendFileSync(process.env.GITHUB_OUTPUT, 'signing_aws_secret=' + (signing ? signing.aws_secret || '' : '') + '\n');
          fs.appendFileSync(process.env.GITHUB_OUTPUT, 'signing_android_keystore_path=' + (signing && signing.android_keystore_path ? signing.android_keystore_path : '') + '\n');
          "

  # Build
  build:
    needs: [prepare]
    timeout-minutes: 120
    strategy:
      matrix:
        platform: ${{ inputs.platform == 'both' && fromJSON('["android", "ios"]') || fromJSON(format('["{0}"]', inputs.platform)) }}
    # Android: Cirrus lg (large) runner for 8GB Gradle heap; iOS: GitHub-hosted macOS
    runs-on: ${{ matrix.platform == 'ios' && 'ghcr.io/cirruslabs/macos-runner:sequoia-xl' || 'ghcr.io/cirruslabs/ubuntu-runner-amd64:24.04-lg' }}
    environment: ${{ needs.prepare.outputs.github_environment }}
    env:
      # So bundle exec (in yarn pod:install) finds ios/Gemfile when running from repo root
      BUNDLE_GEMFILE: ios/Gemfile
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'yarn'
      - run: yarn install --immutable

      - name: Apply build config
        run: |
          # Load env vars from builds.yml (this step only)
          eval "$(node scripts/apply-build-config.js ${{ inputs.build_name }} --export)"
          # Persist to GITHUB_ENV so later steps (e.g. Build) see CONFIGURATION, IS_SIM_BUILD, etc.
          node scripts/apply-build-config.js ${{ inputs.build_name }} --export-github-env >> "$GITHUB_ENV"

      - name: Set secrets
        env:
          CONFIG_SECRETS: ${{ needs.prepare.outputs.secrets_json }}
          # Injected from builds.yml (run scripts/generate-build-workflow-secrets-env.js after changing secrets)
          ANDROID_APPLE_CLIENT_ID: ${{ secrets.ANDROID_APPLE_CLIENT_ID }}
          ANDROID_GOOGLE_CLIENT_ID: ${{ secrets.ANDROID_GOOGLE_CLIENT_ID }}
          ANDROID_GOOGLE_SERVER_CLIENT_ID: ${{ secrets.ANDROID_GOOGLE_SERVER_CLIENT_ID }}
          FCM_CONFIG_API_KEY: ${{ secrets.FCM_CONFIG_API_KEY }}
          FCM_CONFIG_APP_ID: ${{ secrets.FCM_CONFIG_APP_ID }}
          FCM_CONFIG_AUTH_DOMAIN: ${{ secrets.FCM_CONFIG_AUTH_DOMAIN }}
          FCM_CONFIG_MEASUREMENT_ID: ${{ secrets.FCM_CONFIG_MEASUREMENT_ID }}
          FCM_CONFIG_MESSAGING_SENDER_ID: ${{ secrets.FCM_CONFIG_MESSAGING_SENDER_ID }}
          FCM_CONFIG_PROJECT_ID: ${{ secrets.FCM_CONFIG_PROJECT_ID }}
          FCM_CONFIG_STORAGE_BUCKET: ${{ secrets.FCM_CONFIG_STORAGE_BUCKET }}
          FEATURES_ANNOUNCEMENTS_ACCESS_TOKEN: ${{ secrets.FEATURES_ANNOUNCEMENTS_ACCESS_TOKEN }}
          FEATURES_ANNOUNCEMENTS_SPACE_ID: ${{ secrets.FEATURES_ANNOUNCEMENTS_SPACE_ID }}
          GOOGLE_SERVICES_B64_ANDROID: ${{ secrets.GOOGLE_SERVICES_B64_ANDROID }}
          GOOGLE_SERVICES_B64_IOS: ${{ secrets.GOOGLE_SERVICES_B64_IOS }}
          IOS_GOOGLE_CLIENT_ID: ${{ secrets.IOS_GOOGLE_CLIENT_ID }}
          IOS_GOOGLE_REDIRECT_URI: ${{ secrets.IOS_GOOGLE_REDIRECT_URI }}
          MAIN_ANDROID_APPLE_CLIENT_ID_UAT: ${{ secrets.MAIN_ANDROID_APPLE_CLIENT_ID_UAT }}
          MAIN_ANDROID_GOOGLE_CLIENT_ID_UAT: ${{ secrets.MAIN_ANDROID_GOOGLE_CLIENT_ID_UAT }}
          MAIN_ANDROID_GOOGLE_SERVER_CLIENT_ID_UAT: ${{ secrets.MAIN_ANDROID_GOOGLE_SERVER_CLIENT_ID_UAT }}
          MAIN_IOS_GOOGLE_CLIENT_ID_UAT: ${{ secrets.MAIN_IOS_GOOGLE_CLIENT_ID_UAT }}
          MAIN_IOS_GOOGLE_REDIRECT_URI_UAT: ${{ secrets.MAIN_IOS_GOOGLE_REDIRECT_URI_UAT }}
          MM_BRANCH_KEY_LIVE: ${{ secrets.MM_BRANCH_KEY_LIVE }}
          MM_CARD_BAANX_API_CLIENT_KEY: ${{ secrets.MM_CARD_BAANX_API_CLIENT_KEY }}
          MM_CARD_BAANX_API_CLIENT_KEY_UAT: ${{ secrets.MM_CARD_BAANX_API_CLIENT_KEY_UAT }}
          MM_FOX_CODE: ${{ secrets.MM_FOX_CODE }}
          MM_INFURA_PROJECT_ID: ${{ secrets.MM_INFURA_PROJECT_ID }}
          MM_SENTRY_AUTH_TOKEN: ${{ secrets.MM_SENTRY_AUTH_TOKEN }}
          MM_SENTRY_DSN: ${{ secrets.MM_SENTRY_DSN }}
          QUICKNODE_ARBITRUM_URL: ${{ secrets.QUICKNODE_ARBITRUM_URL }}
          QUICKNODE_AVALANCHE_URL: ${{ secrets.QUICKNODE_AVALANCHE_URL }}
          QUICKNODE_BASE_URL: ${{ secrets.QUICKNODE_BASE_URL }}
          QUICKNODE_LINEA_MAINNET_URL: ${{ secrets.QUICKNODE_LINEA_MAINNET_URL }}
          QUICKNODE_MAINNET_URL: ${{ secrets.QUICKNODE_MAINNET_URL }}
          QUICKNODE_MONAD_URL: ${{ secrets.QUICKNODE_MONAD_URL }}
          QUICKNODE_OPTIMISM_URL: ${{ secrets.QUICKNODE_OPTIMISM_URL }}
          QUICKNODE_POLYGON_URL: ${{ secrets.QUICKNODE_POLYGON_URL }}
          SEGMENT_DELETE_API_SOURCE_ID: ${{ secrets.SEGMENT_DELETE_API_SOURCE_ID }}
          SEGMENT_DELETE_API_SOURCE_ID_QA: ${{ secrets.SEGMENT_DELETE_API_SOURCE_ID_QA }}
          SEGMENT_PROXY_URL: ${{ secrets.SEGMENT_PROXY_URL }}
          SEGMENT_PROXY_URL_QA: ${{ secrets.SEGMENT_PROXY_URL_QA }}
          SEGMENT_REGULATIONS_ENDPOINT: ${{ secrets.SEGMENT_REGULATIONS_ENDPOINT }}
          SEGMENT_REGULATIONS_ENDPOINT_QA: ${{ secrets.SEGMENT_REGULATIONS_ENDPOINT_QA }}
          SEGMENT_WRITE_KEY: ${{ secrets.SEGMENT_WRITE_KEY }}
          SEGMENT_WRITE_KEY_QA: ${{ secrets.SEGMENT_WRITE_KEY_QA }}
          WALLET_CONNECT_PROJECT_ID: ${{ secrets.WALLET_CONNECT_PROJECT_ID }}
        run: node scripts/set-secrets-from-config.js

      # Android only: minimal env (SDK is pre-installed on Cirrus runner)
      - name: Set Android environment variables
        if: matrix.platform == 'android'
        run: |
          echo "ANDROID_HOME=/opt/android-sdk" >> "$GITHUB_ENV"
          echo "ANDROID_SDK_ROOT=/opt/android-sdk" >> "$GITHUB_ENV"

      - name: Setup Java
        if: matrix.platform == 'android'
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      # iOS: Install Ruby using rbenv (already present on Cirrus macOS runner)
      - name: Install Ruby
        if: matrix.platform == 'ios'
        env:
          # Override job-level BUNDLE_GEMFILE (ios/Gemfile) since we cd into ios/
          BUNDLE_GEMFILE: Gemfile
        run: |
          RUBY_VERSION=$(cat .ruby-version)
          echo "üì¶ Installing Ruby ${RUBY_VERSION}..."
          
          # Install Ruby version if not already installed
          if ! rbenv versions | grep -q "${RUBY_VERSION}"; then
            rbenv install "${RUBY_VERSION}"
          fi
          
          # Set Ruby version globally for this runner
          rbenv global "${RUBY_VERSION}"
          
          # Initialize rbenv (required: GitHub Actions runs bash with --noprofile --norc)
          eval "$(rbenv init -)"
          
          # Add rbenv shims to PATH for subsequent steps
          echo "$HOME/.rbenv/shims" >> $GITHUB_PATH
          
          # Verify installation and version
          ACTUAL_VERSION=$(ruby --version)
          echo "‚úÖ Ruby version: ${ACTUAL_VERSION}"
          if ! echo "${ACTUAL_VERSION}" | grep -q "${RUBY_VERSION}"; then
            echo "‚ùå ERROR: Expected Ruby ${RUBY_VERSION}, but got: ${ACTUAL_VERSION}"
            exit 1
          fi
          
          # Install bundler
          gem install bundler -v 2.5.8
          
          # Install gems from ios/Gemfile
          cd ios && bundle install

      # iOS: Cache CocoaPods
      - name: Cache CocoaPods
        if: matrix.platform == 'ios'
        uses: cirruslabs/cache@bba69c6578b863ad0398ad40567bd2ef70290fe0 # v4
        with:
          path: |
            ios/Pods
            ~/Library/Caches/CocoaPods
            ~/.cocoapods
          key: ${{ runner.os }}-pods-${{ inputs.build_name }}-${{ hashFiles('ios/Podfile.lock') }}
          restore-keys: |
            ${{ runner.os }}-pods-${{ inputs.build_name }}-

      # iOS: Cache DerivedData (includes ModuleCache.noindex) to speed up Xcode builds
      - name: Cache iOS DerivedData
        if: matrix.platform == 'ios'
        uses: cirruslabs/cache@bba69c6578b863ad0398ad40567bd2ef70290fe0 # v4
        with:
          path: |
            ~/Library/Developer/Xcode/DerivedData
            ios/build
          key: ${{ runner.os }}-ios-derived-${{ inputs.build_name }}-${{ hashFiles('ios/Podfile.lock') }}-${{ hashFiles('ios/**/*.{h,m,mm,swift}') }}
          restore-keys: |
            ${{ runner.os }}-ios-derived-${{ inputs.build_name }}-${{ hashFiles('ios/Podfile.lock') }}-
            ${{ runner.os }}-ios-derived-${{ inputs.build_name }}-

      # Signing: uses role + secret from builds.yml (skip for dev builds - main-dev, flask-dev, qa-dev use debug/simulator)
      - name: Configure signing certificates
        if: needs.prepare.outputs.signing_aws_role != ''
        uses: ./.github/actions/configure-signing
        with:
          aws-role-to-assume: ${{ needs.prepare.outputs.signing_aws_role }}
          aws-region: 'us-east-2'
          platform: ${{ matrix.platform }}
          aws-secret-name: ${{ needs.prepare.outputs.signing_aws_secret }}
          android-keystore-path: ${{ needs.prepare.outputs.signing_android_keystore_path }}

      - name: Setup project dependencies with retry
        uses: nick-fields/retry@ce71cc2ab81d554ebbe88c79ab5975992d79ba08 #v3.0.2
        with:
          timeout_minutes: 10
          max_attempts: 3
          retry_wait_seconds: 30
          command: |
            echo "üöÄ Setting up project..."
            if [ "${{ matrix.platform }}" = "ios" ]; then
              yarn setup:github-ci --build-ios --no-build-android
            else
              yarn setup:github-ci --no-build-ios
            fi

      # Android: use CI Gradle settings (8GB heap, OOM handling) to avoid daemon OOM
      - name: Use CI Gradle properties (Android)
        if: matrix.platform == 'android'
        run: cp android/gradle.properties.github android/gradle.properties

      # Build with retry logic. Timeouts: 55min per attempt, 115min total for step, 120min job
      # First iOS build (cold cache): ~45-60min. Subsequent builds (warm cache): ~10-20min
      - name: Build ${{ matrix.platform }}
        timeout-minutes: 115
        uses: nick-fields/retry@ce71cc2ab81d554ebbe88c79ab5975992d79ba08 #v3.0.2
        with:
          timeout_minutes: 55
          max_attempts: 2
          retry_wait_seconds: 60
          command: |
            export NODE_OPTIONS='--max-old-space-size=4096'
            export METRO_MAX_WORKERS='4'
            BUILD_NAME="${{ inputs.build_name }}"
            SCRIPT_NAME="build:${{ matrix.platform }}:${BUILD_NAME//-/:}"
            yarn run "$SCRIPT_NAME"

      # Rename Android artifacts
      - name: Rename Android artifacts
        if: matrix.platform == 'android' && success()
        run: |
          set -e
          
          # Get version from package.json
          APP_VERSION=$(node -p "require('./package.json').version")
          
          # Determine flavor based on build type
          case "$METAMASK_BUILD_TYPE" in
            main) APP_FLAVOR="prod" ;;
            flask) APP_FLAVOR="flask" ;;
            qa) APP_FLAVOR="qa" ;;
            *) echo "Unknown build type: $METAMASK_BUILD_TYPE"; exit 1 ;;
          esac
          
          # Determine if Debug or Release
          if [ "$CONFIGURATION" = "Debug" ]; then
            BUILD_CONFIG="debug"
          else
            BUILD_CONFIG="release"
          fi
          
          # Set paths
          APK_DIR="android/app/build/outputs/apk/$APP_FLAVOR/$BUILD_CONFIG"
          BUNDLE_DIR="android/app/build/outputs/bundle/${APP_FLAVOR}Release"
          
          # Create new base name: metamask-{environment}-{buildType}-{version}-{buildNumber}
          NEW_BASE_NAME="metamask-$METAMASK_ENVIRONMENT-$METAMASK_BUILD_TYPE-$APP_VERSION-$GITHUB_RUN_NUMBER"
          
          echo "üìù Renaming artifacts to: $NEW_BASE_NAME"
          
          # Rename APK
          OLD_APK="$APK_DIR/app-$APP_FLAVOR-$BUILD_CONFIG.apk"
          if [ -f "$OLD_APK" ]; then
            NEW_APK="$APK_DIR/$NEW_BASE_NAME.apk"
            cp "$OLD_APK" "$NEW_APK"
            echo "‚úÖ Renamed APK: $NEW_APK"
          else
            echo "‚ö†Ô∏è  APK not found: $OLD_APK"
          fi
          
          # Rename AAB (only for Release builds)
          if [ "$BUILD_CONFIG" = "release" ]; then
            OLD_AAB="$BUNDLE_DIR/app-$APP_FLAVOR-release.aab"
            if [ -f "$OLD_AAB" ]; then
              NEW_AAB="$BUNDLE_DIR/$NEW_BASE_NAME.aab"
              cp "$OLD_AAB" "$NEW_AAB"
              echo "‚úÖ Renamed AAB: $NEW_AAB"
            else
              echo "‚ö†Ô∏è  AAB not found: $OLD_AAB"
            fi
          fi
          
          echo "üì¶ Final artifacts:"
          find android/app/build/outputs -type f \( -name "*.apk" -o -name "*.aab" \) -exec ls -lh {} \;

      # Rename iOS artifacts
      - name: Rename iOS artifacts
        if: matrix.platform == 'ios' && success()
        run: |
          set -e
          
          # Get version from package.json
          APP_VERSION=$(node -p "require('./package.json').version")
          
          # Determine app name based on build type
          case "$METAMASK_BUILD_TYPE" in
            main) APP_NAME="MetaMask" ;;
            flask) APP_NAME="MetaMask-Flask" ;;
            qa) APP_NAME="MetaMask-QA" ;;
            *) echo "Unknown build type: $METAMASK_BUILD_TYPE"; exit 1 ;;
          esac
          
          # Determine build paths based on simulator vs device
          if [ "$IS_SIM_BUILD" = "true" ]; then
            BUILD_DIR="ios/build/Build/Products/${CONFIGURATION:-Release}-iphonesimulator"
            DEVICE_TYPE="simulator"
            BINARY_EXTENSION=".app"
          else
            BUILD_DIR="ios/build/output"
            DEVICE_TYPE="device"
            BINARY_EXTENSION=".ipa"
          fi
          
          # Create new base name: metamask-{deviceType}-{environment}-{buildType}-{version}-{buildNumber}
          NEW_BASE_NAME="metamask-${DEVICE_TYPE}-$METAMASK_ENVIRONMENT-$METAMASK_BUILD_TYPE-$APP_VERSION-$GITHUB_RUN_NUMBER"
          
          echo "üìù Renaming artifacts to: $NEW_BASE_NAME"
          
          # Rename binary (.app or .ipa)
          OLD_BINARY="$BUILD_DIR/$APP_NAME$BINARY_EXTENSION"
          if [ -e "$OLD_BINARY" ]; then
            NEW_BINARY="$BUILD_DIR/$NEW_BASE_NAME$BINARY_EXTENSION"
            cp -r "$OLD_BINARY" "$NEW_BINARY"
            echo "‚úÖ Renamed binary: $NEW_BINARY"
          else
            echo "‚ö†Ô∏è  Binary not found: $OLD_BINARY"
          fi
          
          # Rename xcarchive (only for device builds)
          if [ "$IS_SIM_BUILD" != "true" ]; then
            OLD_ARCHIVE="ios/build/$APP_NAME.xcarchive"
            if [ -e "$OLD_ARCHIVE" ]; then
              NEW_ARCHIVE="ios/build/$NEW_BASE_NAME.xcarchive"
              cp -r "$OLD_ARCHIVE" "$NEW_ARCHIVE"
              echo "‚úÖ Renamed archive: $NEW_ARCHIVE"
            else
              echo "‚ö†Ô∏è  Archive not found: $OLD_ARCHIVE"
            fi
          fi
          
          echo "üì¶ Final artifacts:"
          if [ "$IS_SIM_BUILD" = "true" ]; then
            find ios/build/Build/Products -name "*.app" -type d -exec ls -ldh {} \;
          else
            find ios/build/output -name "*.ipa" -type f -exec ls -lh {} \;
            find ios/build -name "*.xcarchive" -maxdepth 1 -type d -exec ls -ldh {} \;
          fi

      # Upload build artifacts (only if build succeeded)
      - name: Upload iOS artifacts
        if: matrix.platform == 'ios' && success()
        uses: actions/upload-artifact@v4
        with:
          name: ios-${{ inputs.build_name }}
          path: ios/build/
          if-no-files-found: error

      - name: Upload Android artifacts
        if: matrix.platform == 'android' && success()
        uses: actions/upload-artifact@v4
        with:
          name: android-${{ inputs.build_name }}
          path: android/app/build/outputs/
          if-no-files-found: error
