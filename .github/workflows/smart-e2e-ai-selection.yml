# Dynamic AI Smart E2E Test Selection
# Analyzes code changes and dynamically generates test jobs for selected tags

name: Smart E2E AI Selection

on:
  pull_request:
    types: [labeled, synchronize, reopened]
    branches: [main]
  workflow_dispatch:
    inputs:
      enable_ios:
        description: 'Enable iOS builds and tests'
        required: false
        default: false
        type: boolean
      enable_android:
        description: 'Enable Android builds and tests'
        required: false
        default: true
        type: boolean
      include_main_changes:
        description: 'Include recent changes from main branch'
        required: false
        default: false
        type: boolean
      base_branch:
        description: 'Base branch to compare against'
        required: false
        default: 'origin/main'
        type: string

permissions:
  contents: read
  id-token: write
  pull-requests: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # Step 1: AI Analysis & Test Planning
  analyze-and-plan:
    name: 'AI Analysis & Test Planning'
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' || contains(github.event.pull_request.labels.*.name, 'smart-e2e') || contains(github.event.pull_request.labels.*.name, 'smart-e2e-android') || contains(github.event.pull_request.labels.*.name, 'smart-e2e-ios')
    outputs:
      selected-tags: ${{ steps.ai-analysis.outputs.tags }}
      selected-tags-display: ${{ steps.ai-analysis.outputs.tags_display }}
      test-strategy: ${{ steps.ai-analysis.outputs.strategy }}
      total-splits: ${{ steps.ai-analysis.outputs.total_splits }}
      matrix-splits: ${{ steps.ai-analysis.outputs.matrix_splits }}
      should-run-tests: ${{ steps.ai-analysis.outputs.run_tests }}
      risk-level: ${{ steps.ai-analysis.outputs.risk_level }}
      reasoning: ${{ steps.ai-analysis.outputs.reasoning }}
      confidence: ${{ steps.ai-analysis.outputs.confidence }}
      breakdown: ${{ steps.ai-analysis.outputs.breakdown }}
    steps:
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install minimal dependencies for AI analysis
        run: |
          echo "ðŸ“¦ Installing only required packages for AI analysis..."
          # Install to a separate location that won't be overwritten
          mkdir -p /tmp/ai-deps
          cd /tmp/ai-deps
          npm init -y
          npm install @anthropic-ai/sdk@latest esbuild-register@latest --no-audit --no-fund
          echo "âœ… AI analysis dependencies installed in /tmp/ai-deps"

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          # Ensure we get the full branch history for proper diff analysis
          ref: ${{ github.head_ref || github.ref }}

      - name: Setup git for comprehensive analysis
        run: |
          echo "ðŸ”§ Ensuring complete git history..."
          git fetch --unshallow --all || echo "Already unshallow"
          git fetch origin main:main 2>/dev/null || echo "Main already available"
          echo "âœ… Git setup complete"

      - name: Copy AI dependencies to workspace
        run: |
          echo "ðŸ“‹ Copying AI dependencies to workspace..."
          # Create node_modules if it doesn't exist
          mkdir -p node_modules
          # Copy our pre-installed dependencies
          cp -r /tmp/ai-deps/node_modules/* node_modules/
          echo "âœ… AI dependencies available in workspace"

      - name: Test Selection AI Analysis
        id: ai-analysis
        env:
          E2E_CLAUDE_API_KEY: ${{ secrets.E2E_CLAUDE_API_KEY }}
        run: |
          echo "ðŸ¤– Running AI analysis..."

          # Build command with dynamic arguments based on trigger type
          BASE_CMD="node -r esbuild-register scripts/e2e/ai-e2e-tags-selector.ts --output json"

          # Add base branch if specified (manual trigger)
          if [ "${{ github.event.inputs.base_branch }}" != "" ] && [ "${{ github.event.inputs.base_branch }}" != "origin/main" ]; then
            BASE_CMD="$BASE_CMD --base-branch ${{ github.event.inputs.base_branch }}"
          fi

          # Add include-main-changes flag
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            if [ "${{ github.event.inputs.include_main_changes }}" == "true" ]; then
              BASE_CMD="$BASE_CMD --include-main-changes"
            fi
          else
            # For PR triggers, always include main changes for comprehensive analysis
            BASE_CMD="$BASE_CMD --include-main-changes"
          fi

          echo "ðŸ¤– Running AI analysis with command: $BASE_CMD"
          echo "ðŸ“‹ Event name: ${{ github.event_name }}"
          echo "ðŸ“‹ Include main changes input: ${{ github.event.inputs.include_main_changes }}"

          # Debug git state
          echo "ðŸ” Git debug info:"
          FILES_WITH_MAIN=$(git diff --name-only origin/main..HEAD 2>/dev/null | wc -l || echo 'ERROR')
          FILES_WITHOUT_MAIN=$(git diff --name-only origin/main...HEAD 2>/dev/null | wc -l || echo 'ERROR')
          echo "- Files with include-main: $FILES_WITH_MAIN"
          echo "- Files without include-main: $FILES_WITHOUT_MAIN"

          RESULT=$(eval $BASE_CMD)

          # Validate JSON output
          if ! echo "$RESULT" | jq . > /dev/null 2>&1; then
            echo "âŒ Invalid JSON output from AI analysis"
            echo "Raw output: $RESULT"
            exit 1
          fi

          echo "ðŸ“Š AI analysis completed successfully (builds running in parallel)"

          # Parse results
          TAGS=$(echo "$RESULT" | jq -r '.selectedTags | join("|")')  # Use pipe separator for grep regex
          TAG_COUNT=$(echo "$RESULT" | jq -r '.selectedTags | length')
          RISK_LEVEL=$(echo "$RESULT" | jq -r '.riskLevel')
          TAG_DISPLAY=$(echo "$RESULT" | jq -r '.selectedTags | join(", ")')  # Human-readable format
          TOTAL_SPLITS=$(echo "$RESULT" | jq -r '.totalSplits // 3')  # Use AI-calculated splits or fallback to 3
          REASONING=$(echo "$RESULT" | jq -r '.reasoning // "AI analysis completed"')
          CONFIDENCE=$(echo "$RESULT" | jq -r '.confidence // 75')

          echo "âœ… Selected tags: $TAG_DISPLAY"
          echo "ðŸ“ˆ Risk level: $RISK_LEVEL"
          echo "ðŸ”¢ Tag count: $TAG_COUNT"
          echo "ðŸ§® Total splits: $TOTAL_SPLITS (calculated based on test file counts)"

          # Generate matrix array for GitHub Actions
          MATRIX_ARRAY="["
          for i in $(seq 1 $TOTAL_SPLITS); do
            if [ $i -eq 1 ]; then
              MATRIX_ARRAY="${MATRIX_ARRAY}$i"
            else
              MATRIX_ARRAY="${MATRIX_ARRAY},$i"
            fi
          done
          MATRIX_ARRAY="${MATRIX_ARRAY}]"

          echo "ðŸ”¢ Generated matrix array: $MATRIX_ARRAY"

          # Set outputs
          echo "tags=$TAGS" >> "$GITHUB_OUTPUT"
          echo "tags_display=$TAG_DISPLAY" >> "$GITHUB_OUTPUT"
          echo "strategy=dynamic-$TAG_COUNT-tags" >> "$GITHUB_OUTPUT"
          echo "total_splits=$TOTAL_SPLITS" >> "$GITHUB_OUTPUT"
          echo "matrix_splits=$MATRIX_ARRAY" >> "$GITHUB_OUTPUT"
          echo "risk_level=$RISK_LEVEL" >> "$GITHUB_OUTPUT"

          # Handle multi-line reasoning content carefully
          {
            echo "reasoning<<EOF"
            echo "$REASONING"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

          echo "confidence=$CONFIDENCE" >> "$GITHUB_OUTPUT"

          # Handle multi-line breakdown content carefully
          {
            echo "breakdown<<EOF"
            echo "$BREAKDOWN"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

          # Only run tests if we have tags selected and splits > 0
          if [ "$TAG_COUNT" -eq 0 ]; then
            echo "run_tests=false" >> "$GITHUB_OUTPUT"
            echo "â„¹ï¸ No E2E tests needed - AI determined changes are very low risk"
          elif [ "$TOTAL_SPLITS" -gt 0 ]; then
            echo "run_tests=true" >> "$GITHUB_OUTPUT"
            echo "âœ… Will run $((TOTAL_SPLITS * 2)) CI jobs ($TOTAL_SPLITS per platform Ã— 2 platforms)"
          else
            echo "run_tests=false" >> "$GITHUB_OUTPUT"
            echo "â„¹ï¸ No E2E tests needed - selected tags have no test files"
          fi

          # Create readable test plan with file breakdown
          echo "## ðŸŽ¯ Smart E2E Test Plan" >> $GITHUB_STEP_SUMMARY

          if [ "$TAG_COUNT" -eq 0 ]; then
            echo "- **Selected Tags**: None (no tests needed)" >> $GITHUB_STEP_SUMMARY
            echo "- **Risk Level**: $RISK_LEVEL" >> $GITHUB_STEP_SUMMARY
            echo "- **AI Confidence**: ${CONFIDENCE}%" >> $GITHUB_STEP_SUMMARY
            echo "- **Total CI Jobs**: 0 (AI determined changes are very low risk)" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **Selected Tags**: $TAG_DISPLAY" >> $GITHUB_STEP_SUMMARY
            echo "- **Risk Level**: $RISK_LEVEL" >> $GITHUB_STEP_SUMMARY
            echo "- **AI Confidence**: ${CONFIDENCE}%" >> $GITHUB_STEP_SUMMARY
            echo "- **Total Splits**: $TOTAL_SPLITS (optimized for actual test files)" >> $GITHUB_STEP_SUMMARY

            if [ "$TOTAL_SPLITS" -gt 0 ]; then
              echo "- **Total CI Jobs**: $((TOTAL_SPLITS * 2)) ($TOTAL_SPLITS per platform Ã— 2 platforms)" >> $GITHUB_STEP_SUMMARY
            else
              echo "- **Total CI Jobs**: 0 (selected tags have no test files)" >> $GITHUB_STEP_SUMMARY
            fi
          fi

          # Add AI reasoning
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ¤– AI Analysis Reasoning" >> $GITHUB_STEP_SUMMARY
          echo "$REASONING" >> $GITHUB_STEP_SUMMARY

          # Add test file breakdown if available
          BREAKDOWN=$(echo "$RESULT" | jq -r '.testFileBreakdown[]? | "  - " + .tag + ": " + (.fileCount | tostring) + " files â†’ " + (.recommendedSplits | tostring) + " splits"' | tr '\n' '\n')
          if [ -n "$BREAKDOWN" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### ðŸ“Š Test File Breakdown" >> $GITHUB_STEP_SUMMARY
            echo "$BREAKDOWN" >> $GITHUB_STEP_SUMMARY
          fi

  # Step 2: Post AI analysis to PR
  post-pr-comment:
    name: 'Post AI Analysis to PR'
    needs: [analyze-and-plan]
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Post AI analysis to PR
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Create AI analysis comment
          cat > pr_comment.md << EOF
          ## ðŸ¤– Smart E2E Test Analysis

          **Risk Level:** ${{ needs.analyze-and-plan.outputs.risk-level }} | **Selected Tags:** ${{ needs.analyze-and-plan.outputs.selected-tags-display }}

          **AI Analysis:**
          > ${{ needs.analyze-and-plan.outputs.reasoning }}

          **Test Plan:**
          - **Total Splits:** ${{ needs.analyze-and-plan.outputs.total-splits }} per platform (optimized for actual test files)
          - **Confidence:** ${{ needs.analyze-and-plan.outputs.confidence }}%

          **Test File Breakdown:**
          ${{ needs.analyze-and-plan.outputs.breakdown || '(No breakdown available)' }}

          _â³ Tests are starting... [View workflow run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})_
          EOF

          # Delete any existing Smart E2E comments and create a new one
          echo "ðŸ” Checking for existing Smart E2E comments..."

          # Get all existing comment IDs that contain our marker
          EXISTING_COMMENTS=$(gh pr view ${{ github.event.pull_request.number }} --json comments --jq '.comments[] | select(.body | contains("ðŸ¤– Smart E2E Test Analysis")) | .id' || echo "")

          # Delete existing comments if any exist
          if [ -n "$EXISTING_COMMENTS" ]; then
            echo "ðŸ—‘ï¸ Deleting existing Smart E2E comments..."
            echo "$EXISTING_COMMENTS" | while read -r comment_id; do
              if [ -n "$comment_id" ]; then
                echo "Deleting comment: $comment_id"
                gh api -X DELETE "repos/${{ github.repository }}/issues/comments/$comment_id" || echo "Failed to delete comment $comment_id"
              fi
            done
          fi

          # Always create a fresh comment
          echo "ðŸ“ Creating new PR comment..."
          gh pr comment ${{ github.event.pull_request.number }} --body-file pr_comment.md

  # Step 3: Determine platform conditions
  platform-conditions:
    name: 'Platform Conditions'
    needs: [analyze-and-plan]
    runs-on: ubuntu-latest
    outputs:
      should-build-ios: ${{ steps.conditions.outputs.should-build-ios }}
      should-build-android: ${{ steps.conditions.outputs.should-build-android }}
      should-test-ios: ${{ steps.conditions.outputs.should-test-ios }}
      should-test-android: ${{ steps.conditions.outputs.should-test-android }}
      actual-ios-jobs: ${{ steps.conditions.outputs.actual-ios-jobs }}
      actual-android-jobs: ${{ steps.conditions.outputs.actual-android-jobs }}
      actual-total-jobs: ${{ steps.conditions.outputs.actual-total-jobs }}
    steps:
      - name: Calculate platform conditions
        id: conditions
        run: |
          # Base conditions
          TESTS_NEEDED="${{ needs.analyze-and-plan.outputs.should-run-tests }}"
          HAS_SPLITS="${{ needs.analyze-and-plan.outputs.total-splits != '0' }}"

          # Platform enablement logic
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            IOS_ENABLED="${{ github.event.inputs.enable_ios }}"
            ANDROID_ENABLED="${{ github.event.inputs.enable_android }}"
          else
            IOS_ENABLED="${{ contains(github.event.pull_request.labels.*.name, 'smart-e2e-ios') || contains(github.event.pull_request.labels.*.name, 'smart-e2e') }}"
            ANDROID_ENABLED="${{ contains(github.event.pull_request.labels.*.name, 'smart-e2e-android') || contains(github.event.pull_request.labels.*.name, 'smart-e2e') }}"
          fi

          # Calculate final conditions
          if [[ "$TESTS_NEEDED" == "true" && "$HAS_SPLITS" == "true" ]]; then
            SHOULD_BUILD_IOS=$([[ "$IOS_ENABLED" == "true" ]] && echo "true" || echo "false")
            SHOULD_BUILD_ANDROID=$([[ "$ANDROID_ENABLED" == "true" ]] && echo "true" || echo "false")
          else
            SHOULD_BUILD_IOS="false"
            SHOULD_BUILD_ANDROID="false"
          fi

          echo "should-build-ios=$SHOULD_BUILD_IOS" >> "$GITHUB_OUTPUT"
          echo "should-build-android=$SHOULD_BUILD_ANDROID" >> "$GITHUB_OUTPUT"
          echo "should-test-ios=$SHOULD_BUILD_IOS" >> "$GITHUB_OUTPUT"
          echo "should-test-android=$SHOULD_BUILD_ANDROID" >> "$GITHUB_OUTPUT"

          # Calculate actual job counts
          TOTAL_SPLITS="${{ needs.analyze-and-plan.outputs.total-splits }}"
          IOS_JOBS=0
          ANDROID_JOBS=0

          if [ "$SHOULD_BUILD_IOS" = "true" ] && [ "$TOTAL_SPLITS" -gt 0 ]; then
            IOS_JOBS="$TOTAL_SPLITS"
          fi

          if [ "$SHOULD_BUILD_ANDROID" = "true" ] && [ "$TOTAL_SPLITS" -gt 0 ]; then
            ANDROID_JOBS="$TOTAL_SPLITS"
          fi

          TOTAL_JOBS=$((IOS_JOBS + ANDROID_JOBS))

          echo "actual-ios-jobs=$IOS_JOBS" >> "$GITHUB_OUTPUT"
          echo "actual-android-jobs=$ANDROID_JOBS" >> "$GITHUB_OUTPUT"
          echo "actual-total-jobs=$TOTAL_JOBS" >> "$GITHUB_OUTPUT"

          echo "ðŸŽ¯ Platform Conditions:"
          echo "- iOS Build/Test: $SHOULD_BUILD_IOS ($IOS_JOBS jobs)"
          echo "- Android Build/Test: $SHOULD_BUILD_ANDROID ($ANDROID_JOBS jobs)"
          echo "- Total CI Jobs: $TOTAL_JOBS"

  # Step 3: Build iOS app for testing
  build-ios:
    name: 'Build iOS App'
    needs: [platform-conditions]
    if: needs.platform-conditions.outputs.should-build-ios == 'true'
    uses: ./.github/workflows/build-ios-e2e.yml
    secrets: inherit

  # Step 4: Build Android app for testing
  build-android:
    name: 'Build Android App'
    needs: [platform-conditions]
    if: needs.platform-conditions.outputs.should-build-android == 'true'
    uses: ./.github/workflows/build-android-e2e.yml
    secrets: inherit

  # Step 5: Dynamic iOS E2E Tests using reusable workflow
  ios-smart-tests:
    needs: [analyze-and-plan, platform-conditions, build-ios]
    if: needs.platform-conditions.outputs.should-test-ios == 'true' && needs.build-ios.result == 'success'
    strategy:
      fail-fast: false
      matrix:
        split: ${{ fromJson(needs.analyze-and-plan.outputs.matrix-splits) }}
    uses: ./.github/workflows/run-e2e-workflow.yml
    with:
      test-suite-name: 'Smart-iOS-E2E-Split-${{ matrix.split }}-of-${{ needs.analyze-and-plan.outputs.total-splits }}'
      platform: 'ios'
      test_suite_tag: '${{ needs.analyze-and-plan.outputs.selected-tags }}'
      split_number: ${{ matrix.split }}
      total_splits: ${{ fromJson(needs.analyze-and-plan.outputs.total-splits) }}
      test-timeout-minutes: 120
    secrets: inherit

  # Step 6: Dynamic Android E2E Tests using reusable workflow
  android-smart-tests:
    needs: [analyze-and-plan, platform-conditions, build-android]
    if: needs.platform-conditions.outputs.should-test-android == 'true' && needs.build-android.result == 'success'
    strategy:
      fail-fast: false
      matrix:
        split: ${{ fromJson(needs.analyze-and-plan.outputs.matrix-splits) }}
    uses: ./.github/workflows/run-e2e-workflow.yml
    with:
      test-suite-name: 'Smart-Android-E2E-Split-${{ matrix.split }}-of-${{ needs.analyze-and-plan.outputs.total-splits }}'
      platform: 'android'
      test_suite_tag: '${{ needs.analyze-and-plan.outputs.selected-tags }}'
      split_number: ${{ matrix.split }}
      total_splits: ${{ fromJson(needs.analyze-and-plan.outputs.total-splits) }}
      test-timeout-minutes: 120
    secrets: inherit

  # Step 7: Report iOS Test Results
  report-ios-smart-tests:
    name: 'ðŸ“Š iOS Smart E2E Test Report'
    needs: [platform-conditions, ios-smart-tests]
    if: needs.platform-conditions.outputs.should-test-ios == 'true' && (success() || failure())
    uses: ./.github/workflows/report-e2e-tests.yml
    with:
      platform: 'ios'
      test-type: 'smart-e2e'
      artifact-pattern: 'Smart-iOS-E2E-*-test-results'
      report-name: 'iOS Smart E2E Test Results'

  # Step 8: Report Android Test Results
  report-android-smart-tests:
    name: 'ðŸ“Š Android Smart E2E Test Report'
    needs: [platform-conditions, android-smart-tests]
    if: needs.platform-conditions.outputs.should-test-android == 'true' && (success() || failure())
    uses: ./.github/workflows/report-e2e-tests.yml
    with:
      platform: 'android'
      test-type: 'smart-e2e'
      artifact-pattern: 'Smart-Android-E2E-*-test-results'
      report-name: 'Android Smart E2E Test Results'

  # Step 9: Final Summary Report
  report-results:
    name: 'ðŸ“Š Smart E2E Test Results Summary'
    runs-on: ubuntu-latest
    needs:
      [
        analyze-and-plan,
        platform-conditions,
        ios-smart-tests,
        android-smart-tests,
        report-ios-smart-tests,
        report-android-smart-tests,
      ]
    if: always() && needs.analyze-and-plan.result == 'success'
    steps:
      - name: Generate test report
        run: |
          {
            echo "## ðŸŽ¯ Smart E2E Test Execution Report"
            echo "- **Trigger**: ${{ github.event_name }}"
            echo "- **Strategy**: ${{ needs.analyze-and-plan.outputs.test-strategy }}"
            echo "- **Selected Tags**: ${{ needs.analyze-and-plan.outputs.selected-tags-display }}"
            echo "- **Total Splits**: ${{ needs.analyze-and-plan.outputs.total-splits }}"
            echo ""
            echo "- **iOS Jobs**: ${{ needs.platform-conditions.outputs.actual-ios-jobs }} (enabled: ${{ needs.platform-conditions.outputs.should-build-ios }})"
            echo "- **Android Jobs**: ${{ needs.platform-conditions.outputs.actual-android-jobs }} (enabled: ${{ needs.platform-conditions.outputs.should-build-android }})"
            echo "- **Total CI Jobs**: ${{ needs.platform-conditions.outputs.actual-total-jobs }}"
            echo ""
            echo "- **iOS Result**: ${{ needs.ios-smart-tests.result || 'skipped' }}"
            echo "- **Android Result**: ${{ needs.android-smart-tests.result || 'skipped' }}"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Update PR comment with final results
        if: github.event_name == 'pull_request'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Update the existing comment with final results
          cat > pr_comment_final.md << EOF
          ## ðŸ¤– Smart E2E Test Analysis âœ…

          **Risk Level:** ${{ needs.analyze-and-plan.outputs.strategy }} | **Selected Tags:** ${{ needs.analyze-and-plan.outputs.selected-tags-display }}

          **Final Results:**
          - **iOS Jobs:** ${{ needs.platform-conditions.outputs.actual-ios-jobs }} (Result: ${{ needs.ios-smart-tests.result || 'skipped' }})
          - **Android Jobs:** ${{ needs.platform-conditions.outputs.actual-android-jobs }} (Result: ${{ needs.android-smart-tests.result || 'skipped' }})
          - **Total CI Jobs:** ${{ needs.platform-conditions.outputs.actual-total-jobs }}

          **Platform Configuration:**
          - iOS enabled: ${{ needs.platform-conditions.outputs.should-build-ios }}
          - Android enabled: ${{ needs.platform-conditions.outputs.should-build-android }}

          _âœ… [View complete workflow run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}) â€¢ Smart E2E AI Selection_
          EOF

          # Delete existing Smart E2E comment and create final results comment
          echo "ðŸ” Looking for existing Smart E2E comment to update..."

          # Get existing comment ID
          EXISTING_COMMENTS=$(gh pr view ${{ github.event.pull_request.number }} --json comments --jq '.comments[] | select(.body | contains("ðŸ¤– Smart E2E Test Analysis")) | .id' || echo "")

          # Delete existing comment if it exists
          if [ -n "$EXISTING_COMMENTS" ]; then
            echo "ðŸ—‘ï¸ Replacing existing Smart E2E comment with final results..."
            echo "$EXISTING_COMMENTS" | while read -r comment_id; do
              if [ -n "$comment_id" ]; then
                echo "Deleting comment: $comment_id"
                gh api -X DELETE "repos/${{ github.repository }}/issues/comments/$comment_id" || echo "Failed to delete comment $comment_id"
              fi
            done
          fi

          # Create final results comment
          echo "ðŸ“ Creating final results comment..."
          gh pr comment ${{ github.event.pull_request.number }} --body-file pr_comment_final.md

      - name: Check test results
        run: |
          IOS_RESULT="${{ needs.ios-smart-tests.result }}"
          ANDROID_RESULT="${{ needs.android-smart-tests.result }}"
          SHOULD_RUN_TESTS="${{ needs.analyze-and-plan.outputs.should-run-tests }}"
          TOTAL_SPLITS="${{ needs.analyze-and-plan.outputs.total-splits }}"

          if [[ "$SHOULD_RUN_TESTS" == "false" ]] || [[ "$TOTAL_SPLITS" == "0" ]]; then
            echo "â„¹ï¸ No E2E tests were needed based on AI analysis"
            echo "âœ… Smart E2E analysis completed - no testing required"
          elif [[ "$IOS_RESULT" == "failure" ]] || [[ "$ANDROID_RESULT" == "failure" ]]; then
            echo "âŒ Some E2E tests failed"
            exit 1
          else
            echo "âœ… All E2E tests completed successfully"
          fi
