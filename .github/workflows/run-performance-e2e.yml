name: Build Apps and Run Performance E2E Tests
on:
  schedule:
    - cron: '0 3 * * 1-6'
  workflow_dispatch:
    inputs:
      description:
        description: 'Optional description for this test run'
        required: false
        type: string
permissions:
  contents: read
  id-token: write
env:
  BROWSERSTACK_USERNAME: ${{ secrets.BROWSERSTACK_USERNAME }}
  BROWSERSTACK_ACCESS_KEY: ${{ secrets.BROWSERSTACK_ACCESS_KEY }}
  MM_TEST_ACCOUNT_SRP: ${{ secrets.MM_TEST_ACCOUNT_SRP }}
  TEST_SRP_1: ${{ secrets.TEST_SRP_1 }}
  TEST_SRP_2: ${{ secrets.TEST_SRP_2 }}
  TEST_SRP_3: ${{ secrets.TEST_SRP_3 }}
  DISABLE_VIDEO_DOWNLOAD: true

jobs:
  read-device-matrix:
    name: Read Device Matrix
    runs-on: ubuntu-latest
    outputs:
      android_matrix: ${{ steps.matrix.outputs.android }}
      ios_matrix: ${{ steps.matrix.outputs.ios }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Read device matrix
        id: matrix
        run: |
          # This step reads the device matrix from appwright/device-matrix.json
          echo "Reading device matrix from appwright/device-matrix.json"
          
          # Extract Android devices
          ANDROID_MATRIX=$(jq -r ".android_devices | map({name: .name, os_version: .os_version, category: .category}) | tojson" appwright/device-matrix.json)
          # Extract iOS devices
          IOS_MATRIX=$(jq -r ".ios_devices | map({name: .name, os_version: .os_version, category: .category}) | tojson" appwright/device-matrix.json)
          
          {
            echo "android=$ANDROID_MATRIX"
            echo "ios=$IOS_MATRIX"
          } >> "$GITHUB_OUTPUT"
          
          echo "Android matrix: $ANDROID_MATRIX"
          echo "iOS matrix: $IOS_MATRIX"
          
          # Validate that we have devices
          ANDROID_COUNT=$(echo "$ANDROID_MATRIX" | jq 'length')
          IOS_COUNT=$(echo "$IOS_MATRIX" | jq 'length')
          
          echo "Found $ANDROID_COUNT Android devices and $IOS_COUNT iOS devices"
          
          if [ "$ANDROID_COUNT" -eq 0 ] && [ "$IOS_COUNT" -eq 0 ]; then
            echo "Error: No devices found in device-matrix.json"
            exit 1
          fi

  # Job to trigger QA builds and extract BrowserStack URLs
  trigger-qa-builds-and-upload:
    name: Trigger QA Builds and Extract BrowserStack URLs
    runs-on: ubuntu-latest
    needs: read-device-matrix
    env:
      BITRISE_APP_ID: ${{ secrets.BITRISE_APP_ID }}
      BITRISE_BUILD_TRIGGER_TOKEN: ${{ secrets.BITRISE_BUILD_TRIGGER_TOKEN }}
      BITRISE_API_TOKEN: ${{ secrets.BITRISE_API_TOKEN }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version-file: '.nvmrc'
          cache: 'yarn'
      
      - name: Install dependencies
        run: yarn setup
      
      - name: Cache node_modules
        uses: actions/cache@v4
        with:
          path: |
            node_modules
            .yarn/cache
            .yarn/install-state.gz
          key: ${{ runner.os }}-yarn-${{ hashFiles('**/yarn.lock') }}
          restore-keys: |
            ${{ runner.os }}-yarn-
      
      - name: Trigger Bitrise QA Builds
        env:
          BITRISE_APP_ID: ${{ env.BITRISE_APP_ID }}
          BITRISE_BUILD_TRIGGER_TOKEN: ${{ env.BITRISE_BUILD_TRIGGER_TOKEN }}
          BITRISE_API_TOKEN: ${{ env.BITRISE_API_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Triggering Bitrise QA builds..."
          echo "BITRISE_APP_ID: $BITRISE_APP_ID"
          echo "Current branch: ${{ github.ref_name }}"
          
          # Trigger QA builds pipeline with pre-imported wallet (for regular tests)
          QA_BUILD_RESPONSE=$(curl -s -X POST \
            "https://app.bitrise.io/app/$BITRISE_APP_ID/build/start.json" \
            -H "Content-Type: application/json" \
            -d '{
              "build_params": {
                "branch": "${{ github.ref_name }}",
                "pipeline_id": "create_qa_builds_pipeline",
                "commit_message": "Triggered by Performance E2E workflow - QA Build with pre-imported wallet",
                "environments": [
                  {
                    "mapped_to": "ADDITIONAL_SRP_1",
                    "value": "${{ secrets.TEST_SRP_1 }}",
                    "is_expand": true
                  },
                  {
                    "mapped_to": "PREDEFINED_PASSWORD", 
                    "value": "${{ secrets.E2E_PASSWORD }}",
                    "is_expand": true
                  }
                ]
              },
              "hook_info": {
                "type": "bitrise",
                "build_trigger_token": "'"$BITRISE_BUILD_TRIGGER_TOKEN"'"
              },
              "triggered_by": "GitHub Actions Performance E2E - QA Build"
            }')
          
          # Trigger Clean builds pipeline without pre-imported wallet (for onboarding tests)
          CLEAN_BUILD_RESPONSE=$(curl -s -X POST \
            "https://app.bitrise.io/app/$BITRISE_APP_ID/build/start.json" \
            -H "Content-Type: application/json" \
            -d '{
              "build_params": {
                "branch": "${{ github.ref_name }}",
                "pipeline_id": "create_qa_builds_pipeline",
                "commit_message": "Triggered by Performance E2E workflow - Clean Build for onboarding tests"
              },
              "hook_info": {
                "type": "bitrise",
                "build_trigger_token": "'"$BITRISE_BUILD_TRIGGER_TOKEN"'"
              },
              "triggered_by": "GitHub Actions Performance E2E - Clean Build"
            }')
          
          echo "QA Build response: $QA_BUILD_RESPONSE"
          QA_BUILD_SLUG=$(echo "$QA_BUILD_RESPONSE" | jq -r '.build_slug')
          echo "QA Build slug: $QA_BUILD_SLUG"
          
          if [[ -z "$QA_BUILD_SLUG" || "$QA_BUILD_SLUG" == "null" ]]; then
            echo "Error: Failed to get QA build slug"
            echo "Full response: $QA_BUILD_RESPONSE"
            echo "Trying alternative response structure..."
            QA_BUILD_SLUG=$(echo "$QA_BUILD_RESPONSE" | jq -r '.data.build_slug // .build_slug // .slug')
            echo "Alternative QA build slug: $QA_BUILD_SLUG"
            if [[ -z "$QA_BUILD_SLUG" || "$QA_BUILD_SLUG" == "null" ]]; then
              echo "Still no QA build slug found. Response keys:"
              echo "$QA_BUILD_RESPONSE" | jq -r 'keys[]'
              exit 1
            fi
          fi
          
          echo "Clean Build response: $CLEAN_BUILD_RESPONSE"
          CLEAN_BUILD_SLUG=$(echo "$CLEAN_BUILD_RESPONSE" | jq -r '.build_slug')
          echo "Clean Build slug: $CLEAN_BUILD_SLUG"
          
          if [[ -z "$CLEAN_BUILD_SLUG" || "$CLEAN_BUILD_SLUG" == "null" ]]; then
            echo "Error: Failed to get clean build slug"
            echo "Full response: $CLEAN_BUILD_RESPONSE"
            echo "Trying alternative response structure..."
            CLEAN_BUILD_SLUG=$(echo "$CLEAN_BUILD_RESPONSE" | jq -r '.data.build_slug // .build_slug // .slug')
            echo "Alternative clean build slug: $CLEAN_BUILD_SLUG"
            if [[ -z "$CLEAN_BUILD_SLUG" || "$CLEAN_BUILD_SLUG" == "null" ]]; then
              echo "Still no clean build slug found. Response keys:"
              echo "$CLEAN_BUILD_RESPONSE" | jq -r 'keys[]'
              exit 1
            fi
          fi
          
          # Store build slugs for artifact download
          echo "QA_BUILD_SLUG=$QA_BUILD_SLUG" >> "$GITHUB_ENV"
          echo "CLEAN_BUILD_SLUG=$CLEAN_BUILD_SLUG" >> "$GITHUB_ENV"
          
          echo "Waiting for both builds to complete..."
          TIMEOUT=1800  # 30 minutes
          ELAPSED=0
          QA_BUILD_COMPLETED=false
          CLEAN_BUILD_COMPLETED=false
          
          while [ "$ELAPSED" -lt "$TIMEOUT" ]; do
            # Check QA pipeline status
            if [ "$QA_BUILD_COMPLETED" = false ]; then
              echo "Checking QA pipeline status for slug: $QA_BUILD_SLUG"
              QA_PIPELINE_RESPONSE=$(curl -s -H "Authorization: $BITRISE_API_TOKEN" \
                "https://api.bitrise.io/v0.1/apps/$BITRISE_APP_ID/pipelines/$QA_BUILD_SLUG")
              QA_PIPELINE_STATUS=$(echo "$QA_PIPELINE_RESPONSE" | jq -r '.status')
              echo "QA Pipeline status: $QA_PIPELINE_STATUS"
              
              if [ "$QA_PIPELINE_STATUS" = "succeeded" ]; then
                echo "QA Pipeline completed successfully!"
                QA_BUILD_COMPLETED=true
              elif [ "$QA_PIPELINE_STATUS" = "failed" ]; then
                echo "QA Pipeline failed!"
                exit 1
              fi
            fi
            
            # Check Clean pipeline status
            if [ "$CLEAN_BUILD_COMPLETED" = false ]; then
              echo "Checking Clean pipeline status for slug: $CLEAN_BUILD_SLUG"
              CLEAN_PIPELINE_RESPONSE=$(curl -s -H "Authorization: $BITRISE_API_TOKEN" \
                "https://api.bitrise.io/v0.1/apps/$BITRISE_APP_ID/pipelines/$CLEAN_BUILD_SLUG")
              CLEAN_PIPELINE_STATUS=$(echo "$CLEAN_PIPELINE_RESPONSE" | jq -r '.status')
              echo "Clean Pipeline status: $CLEAN_PIPELINE_STATUS"
              
              if [ "$CLEAN_PIPELINE_STATUS" = "succeeded" ]; then
                echo "Clean Pipeline completed successfully!"
                CLEAN_BUILD_COMPLETED=true
              elif [ "$CLEAN_PIPELINE_STATUS" = "failed" ]; then
                echo "Clean Pipeline failed!"
                exit 1
              fi
            fi
            
            # Check if both builds are completed
            if [ "$QA_BUILD_COMPLETED" = true ] && [ "$CLEAN_BUILD_COMPLETED" = true ]; then
              echo "Both builds completed successfully!"
              break
            fi
            
            sleep 30
            ELAPSED=$((ELAPSED + 30))
          done
          
          if [ "$ELAPSED" -ge "$TIMEOUT" ]; then
            echo "Timeout waiting for pipelines to complete"
            echo "QA Pipeline status: $QA_PIPELINE_STATUS"
            echo "Clean Pipeline status: $CLEAN_PIPELINE_STATUS"
            exit 1
          fi
          
          # Extract build IDs from both completed pipelines
          echo "Extracting build IDs from completed pipelines..."
          
          # QA Build IDs (with pre-imported wallet)
          QA_ANDROID_BUILD_ID=$(echo "$QA_PIPELINE_RESPONSE" | jq -r '.stages[0].workflows[] | select(.name == "build_android_qa") | .external_id')
          QA_IOS_BUILD_ID=$(echo "$QA_PIPELINE_RESPONSE" | jq -r '.stages[0].workflows[] | select(.name == "build_ios_qa") | .external_id')
          
          # Clean Build IDs (without pre-imported wallet)
          CLEAN_ANDROID_BUILD_ID=$(echo "$CLEAN_PIPELINE_RESPONSE" | jq -r '.stages[0].workflows[] | select(.name == "build_android_qa") | .external_id')
          CLEAN_IOS_BUILD_ID=$(echo "$CLEAN_PIPELINE_RESPONSE" | jq -r '.stages[0].workflows[] | select(.name == "build_ios_qa") | .external_id')
          
          if [[ -z "$QA_ANDROID_BUILD_ID" || "$QA_ANDROID_BUILD_ID" == "null" ]]; then
            echo "Error: Failed to get QA Android build ID"
            exit 1
          fi
          
          if [[ -z "$QA_IOS_BUILD_ID" || "$QA_IOS_BUILD_ID" == "null" ]]; then
            echo "Error: Failed to get QA iOS build ID"
            exit 1
          fi
          
          if [[ -z "$CLEAN_ANDROID_BUILD_ID" || "$CLEAN_ANDROID_BUILD_ID" == "null" ]]; then
            echo "Error: Failed to get Clean Android build ID"
            exit 1
          fi
          
          if [[ -z "$CLEAN_IOS_BUILD_ID" || "$CLEAN_IOS_BUILD_ID" == "null" ]]; then
            echo "Error: Failed to get Clean iOS build ID"
            exit 1
          fi
          
          # Store build IDs for artifact download
          {
            echo "QA_ANDROID_BUILD_ID=$QA_ANDROID_BUILD_ID"
            echo "QA_IOS_BUILD_ID=$QA_IOS_BUILD_ID"
            echo "CLEAN_ANDROID_BUILD_ID=$CLEAN_ANDROID_BUILD_ID"
            echo "CLEAN_IOS_BUILD_ID=$CLEAN_IOS_BUILD_ID"
          } >> "$GITHUB_ENV"
      
      - name: Download Build Artifacts
        id: download-artifacts
        env:
          BITRISE_APP_ID: ${{ env.BITRISE_APP_ID }}
          BITRISE_API_TOKEN: ${{ env.BITRISE_API_TOKEN }}
        run: |
          echo "Downloading browserstack_uploaded_apps.json files..."
          echo "QA Android Build ID: $QA_ANDROID_BUILD_ID"
          echo "QA iOS Build ID: $QA_IOS_BUILD_ID"
          echo "Clean Android Build ID: $CLEAN_ANDROID_BUILD_ID"
          echo "Clean iOS Build ID: $CLEAN_IOS_BUILD_ID"
          
          # Download QA Android browserstack_uploaded_apps.json
          echo "Fetching QA Android artifacts..."
          QA_ANDROID_ARTIFACTS=$(curl -s -H "Authorization: $BITRISE_API_TOKEN" \
            "https://api.bitrise.io/v0.1/apps/$BITRISE_APP_ID/builds/$QA_ANDROID_BUILD_ID/artifacts")
          
          if ! curl -s -H "Authorization: $BITRISE_API_TOKEN" \
            "https://api.bitrise.io/v0.1/apps/$BITRISE_APP_ID/builds/$QA_ANDROID_BUILD_ID/artifacts" > /dev/null; then
            echo "Error: Failed to fetch QA Android artifacts"
            exit 1
          fi
                    
          # Find the QA Android browserstack_uploaded_apps.json file
          QA_ANDROID_BS_JSON_ARTIFACT=$(echo "$QA_ANDROID_ARTIFACTS" | jq -r '.data[] | 
            select(.title == "browserstack_uploaded_apps.json")')
          
          echo "QA Android browserstack JSON artifact: $QA_ANDROID_BS_JSON_ARTIFACT"
          
          if [[ -n "$QA_ANDROID_BS_JSON_ARTIFACT" ]]; then
            QA_ANDROID_BS_ARTIFACT_SLUG=$(echo "$QA_ANDROID_BS_JSON_ARTIFACT" | jq -r '.slug')

            # Download the JSON file
            QA_ANDROID_BS_DOWNLOAD_URL=$(curl -s -H "Authorization: $BITRISE_API_TOKEN" \
              "https://api.bitrise.io/v0.1/apps/$BITRISE_APP_ID/builds/$QA_ANDROID_BUILD_ID/artifacts/$QA_ANDROID_BS_ARTIFACT_SLUG" | \
              jq -r '.data.expiring_download_url')
            
            if [[ -n "$QA_ANDROID_BS_DOWNLOAD_URL" && "$QA_ANDROID_BS_DOWNLOAD_URL" != "null" ]]; then
              echo "Downloading QA Android browserstack JSON..."
              wget -O "qa_android_browserstack_apps.json" "$QA_ANDROID_BS_DOWNLOAD_URL"
              
              if ! wget -O "qa_android_browserstack_apps.json" "$QA_ANDROID_BS_DOWNLOAD_URL"; then
                echo "Error: Failed to download QA Android browserstack JSON"
                exit 1
              fi
              
              # Extract the first Android APK app_url
              QA_ANDROID_BS_URL=$(jq -r '.[] | select(.app_name | endswith(".apk")) | .app_url' "qa_android_browserstack_apps.json" | head -1)
              QA_ANDROID_VERSION=$(jq -r '.[] | select(.app_name | endswith(".apk")) | .app_version' "qa_android_browserstack_apps.json" | head -1)
              
              echo "QA Android BrowserStack URL: $QA_ANDROID_BS_URL"
              echo "QA Android version: $QA_ANDROID_VERSION"
              {
                echo "qa-android-version=$QA_ANDROID_VERSION"
                echo "browserstack-qa-android-url=$QA_ANDROID_BS_URL"
              } >> "$GITHUB_OUTPUT"
            else
              echo "Error: No QA Android browserstack JSON download URL found"
              exit 1
            fi
          else
            echo "Error: No QA Android browserstack_uploaded_apps.json artifact found"
            exit 1
          fi
          
          # Download Clean Android browserstack_uploaded_apps.json
          echo "Fetching Clean Android artifacts..."
          CLEAN_ANDROID_ARTIFACTS=$(curl -s -H "Authorization: $BITRISE_API_TOKEN" \
            "https://api.bitrise.io/v0.1/apps/$BITRISE_APP_ID/builds/$CLEAN_ANDROID_BUILD_ID/artifacts")
          
          if ! curl -s -H "Authorization: $BITRISE_API_TOKEN" \
            "https://api.bitrise.io/v0.1/apps/$BITRISE_APP_ID/builds/$CLEAN_ANDROID_BUILD_ID/artifacts" > /dev/null; then
            echo "Error: Failed to fetch Clean Android artifacts"
            exit 1
          fi
                    
          # Find the Clean Android browserstack_uploaded_apps.json file
          CLEAN_ANDROID_BS_JSON_ARTIFACT=$(echo "$CLEAN_ANDROID_ARTIFACTS" | jq -r '.data[] | 
            select(.title == "browserstack_uploaded_apps.json")')
          
          echo "Clean Android browserstack JSON artifact: $CLEAN_ANDROID_BS_JSON_ARTIFACT"
          
          if [[ -n "$CLEAN_ANDROID_BS_JSON_ARTIFACT" ]]; then
            CLEAN_ANDROID_BS_ARTIFACT_SLUG=$(echo "$CLEAN_ANDROID_BS_JSON_ARTIFACT" | jq -r '.slug')

            # Download the JSON file
            CLEAN_ANDROID_BS_DOWNLOAD_URL=$(curl -s -H "Authorization: $BITRISE_API_TOKEN" \
              "https://api.bitrise.io/v0.1/apps/$BITRISE_APP_ID/builds/$CLEAN_ANDROID_BUILD_ID/artifacts/$CLEAN_ANDROID_BS_ARTIFACT_SLUG" | \
              jq -r '.data.expiring_download_url')
            
            if [[ -n "$CLEAN_ANDROID_BS_DOWNLOAD_URL" && "$CLEAN_ANDROID_BS_DOWNLOAD_URL" != "null" ]]; then
              echo "Downloading Clean Android browserstack JSON..."
              wget -O "clean_android_browserstack_apps.json" "$CLEAN_ANDROID_BS_DOWNLOAD_URL"
              
              if ! wget -O "clean_android_browserstack_apps.json" "$CLEAN_ANDROID_BS_DOWNLOAD_URL"; then
                echo "Error: Failed to download Clean Android browserstack JSON"
                exit 1
              fi
              
              # Extract the first Android APK app_url
              CLEAN_ANDROID_BS_URL=$(jq -r '.[] | select(.app_name | endswith(".apk")) | .app_url' "clean_android_browserstack_apps.json" | head -1)
              CLEAN_ANDROID_VERSION=$(jq -r '.[] | select(.app_name | endswith(".apk")) | .app_version' "clean_android_browserstack_apps.json" | head -1)
              
              echo "Clean Android BrowserStack URL: $CLEAN_ANDROID_BS_URL"
              echo "Clean Android version: $CLEAN_ANDROID_VERSION"
              {
                echo "clean-android-version=$CLEAN_ANDROID_VERSION"
                echo "browserstack-clean-android-url=$CLEAN_ANDROID_BS_URL"
              } >> "$GITHUB_OUTPUT"
            else
              echo "Error: No Clean Android browserstack JSON download URL found"
              exit 1
            fi
          else
            echo "Error: No Clean Android browserstack_uploaded_apps.json artifact found"
            exit 1
          fi
          
          # Download QA iOS browserstack_uploaded_apps.json
          echo "Fetching QA iOS artifacts..."
          QA_IOS_ARTIFACTS=$(curl -s -H "Authorization: $BITRISE_API_TOKEN" \
            "https://api.bitrise.io/v0.1/apps/$BITRISE_APP_ID/builds/$QA_IOS_BUILD_ID/artifacts")
          
          if ! curl -s -H "Authorization: $BITRISE_API_TOKEN" \
            "https://api.bitrise.io/v0.1/apps/$BITRISE_APP_ID/builds/$QA_IOS_BUILD_ID/artifacts" > /dev/null; then
            echo "Error: Failed to fetch QA iOS artifacts"
            exit 1
          fi
                    
          # Find the QA iOS browserstack_uploaded_apps.json file
          QA_IOS_BS_JSON_ARTIFACT=$(echo "$QA_IOS_ARTIFACTS" | jq -r '.data[] | 
            select(.title == "browserstack_uploaded_apps.json")')
          
          echo "QA iOS browserstack JSON artifact: $QA_IOS_BS_JSON_ARTIFACT"
          
          if [[ -n "$QA_IOS_BS_JSON_ARTIFACT" ]]; then
            QA_IOS_BS_ARTIFACT_SLUG=$(echo "$QA_IOS_BS_JSON_ARTIFACT" | jq -r '.slug')
            echo "QA iOS browserstack artifact slug: $QA_IOS_BS_ARTIFACT_SLUG"
            
            # Download the JSON file
            QA_IOS_BS_DOWNLOAD_URL=$(curl -s -H "Authorization: $BITRISE_API_TOKEN" \
              "https://api.bitrise.io/v0.1/apps/$BITRISE_APP_ID/builds/$QA_IOS_BUILD_ID/artifacts/$QA_IOS_BS_ARTIFACT_SLUG" | \
              jq -r '.data.expiring_download_url')
            
            if [[ -n "$QA_IOS_BS_DOWNLOAD_URL" && "$QA_IOS_BS_DOWNLOAD_URL" != "null" ]]; then
              echo "Downloading QA iOS browserstack JSON..."
              wget -O "qa_ios_browserstack_apps.json" "$QA_IOS_BS_DOWNLOAD_URL"
              
              if ! wget -O "qa_ios_browserstack_apps.json" "$QA_IOS_BS_DOWNLOAD_URL"; then
                echo "Error: Failed to download QA iOS browserstack JSON"
                exit 1
              fi
              
              # Extract the first iOS IPA app_url
              QA_IOS_BS_URL=$(jq -r '.[] | select(.app_name | endswith(".ipa")) | .app_url' "qa_ios_browserstack_apps.json" | head -1)
              QA_IOS_VERSION=$(jq -r '.[] | select(.app_name | endswith(".ipa")) | .app_version' "qa_ios_browserstack_apps.json" | head -1)
              
              echo "QA iOS BrowserStack URL: $QA_IOS_BS_URL"
              echo "QA iOS version: $QA_IOS_VERSION"
              {
                echo "qa-ios-version=$QA_IOS_VERSION"
                echo "browserstack-qa-ios-url=$QA_IOS_BS_URL"
              } >> "$GITHUB_OUTPUT"
            else
              echo "Error: No QA iOS browserstack JSON download URL found"
              exit 1
            fi
          else
            echo "Error: No QA iOS browserstack_uploaded_apps.json artifact found"
            exit 1
          fi
          
          # Download Clean iOS browserstack_uploaded_apps.json
          echo "Fetching Clean iOS artifacts..."
          CLEAN_IOS_ARTIFACTS=$(curl -s -H "Authorization: $BITRISE_API_TOKEN" \
            "https://api.bitrise.io/v0.1/apps/$BITRISE_APP_ID/builds/$CLEAN_IOS_BUILD_ID/artifacts")
          
          if ! curl -s -H "Authorization: $BITRISE_API_TOKEN" \
            "https://api.bitrise.io/v0.1/apps/$BITRISE_APP_ID/builds/$CLEAN_IOS_BUILD_ID/artifacts" > /dev/null; then
            echo "Error: Failed to fetch Clean iOS artifacts"
            exit 1
          fi
                    
          # Find the Clean iOS browserstack_uploaded_apps.json file
          CLEAN_IOS_BS_JSON_ARTIFACT=$(echo "$CLEAN_IOS_ARTIFACTS" | jq -r '.data[] | 
            select(.title == "browserstack_uploaded_apps.json")')
          
          echo "Clean iOS browserstack JSON artifact: $CLEAN_IOS_BS_JSON_ARTIFACT"
          
          if [[ -n "$CLEAN_IOS_BS_JSON_ARTIFACT" ]]; then
            CLEAN_IOS_BS_ARTIFACT_SLUG=$(echo "$CLEAN_IOS_BS_JSON_ARTIFACT" | jq -r '.slug')
            echo "Clean iOS browserstack artifact slug: $CLEAN_IOS_BS_ARTIFACT_SLUG"
            
            # Download the JSON file
            CLEAN_IOS_BS_DOWNLOAD_URL=$(curl -s -H "Authorization: $BITRISE_API_TOKEN" \
              "https://api.bitrise.io/v0.1/apps/$BITRISE_APP_ID/builds/$CLEAN_IOS_BUILD_ID/artifacts/$CLEAN_IOS_BS_ARTIFACT_SLUG" | \
              jq -r '.data.expiring_download_url')
            
            if [[ -n "$CLEAN_IOS_BS_DOWNLOAD_URL" && "$CLEAN_IOS_BS_DOWNLOAD_URL" != "null" ]]; then
              echo "Downloading Clean iOS browserstack JSON..."
              wget -O "clean_ios_browserstack_apps.json" "$CLEAN_IOS_BS_DOWNLOAD_URL"
              
              if ! wget -O "clean_ios_browserstack_apps.json" "$CLEAN_IOS_BS_DOWNLOAD_URL"; then
                echo "Error: Failed to download Clean iOS browserstack JSON"
                exit 1
              fi
              
              # Extract the first iOS IPA app_url
              CLEAN_IOS_BS_URL=$(jq -r '.[] | select(.app_name | endswith(".ipa")) | .app_url' "clean_ios_browserstack_apps.json" | head -1)
              CLEAN_IOS_VERSION=$(jq -r '.[] | select(.app_name | endswith(".ipa")) | .app_version' "clean_ios_browserstack_apps.json" | head -1)
              
              echo "Clean iOS BrowserStack URL: $CLEAN_IOS_BS_URL"
              echo "Clean iOS version: $CLEAN_IOS_VERSION"
              {
                echo "clean-ios-version=$CLEAN_IOS_VERSION"
                echo "browserstack-clean-ios-url=$CLEAN_IOS_BS_URL"
              } >> "$GITHUB_OUTPUT"
            else
              echo "Error: No Clean iOS browserstack JSON download URL found"
              exit 1
            fi
          else
            echo "Error: No Clean iOS browserstack_uploaded_apps.json artifact found"
            exit 1
          fi
          
          echo "BrowserStack URLs extracted successfully!"
          echo "QA Android: $QA_ANDROID_BS_URL"
          echo "QA iOS: $QA_IOS_BS_URL"
          echo "Clean Android: $CLEAN_ANDROID_BS_URL"
          echo "Clean iOS: $CLEAN_IOS_BS_URL"
    
    outputs:
      qa-android-version: ${{ steps.download-artifacts.outputs.qa-android-version }}
      qa-ios-version: ${{ steps.download-artifacts.outputs.qa-ios-version }}
      browserstack-qa-android-url: ${{ steps.download-artifacts.outputs.browserstack-qa-android-url }}
      browserstack-qa-ios-url: ${{ steps.download-artifacts.outputs.browserstack-qa-ios-url }}
      clean-android-version: ${{ steps.download-artifacts.outputs.clean-android-version }}
      clean-ios-version: ${{ steps.download-artifacts.outputs.clean-ios-version }}
      browserstack-clean-android-url: ${{ steps.download-artifacts.outputs.browserstack-clean-android-url }}
      browserstack-clean-ios-url: ${{ steps.download-artifacts.outputs.browserstack-clean-ios-url }}

  # Unified Tests Job - Runs Both Regular and Onboarding Tests
  performance-tests:
    name: Performance Tests (All Types)
    runs-on: ubuntu-latest
    timeout-minutes: 60
    needs: [trigger-qa-builds-and-upload, read-device-matrix]
    strategy:
      fail-fast: false
      matrix:
        device: ${{ fromJson(needs.read-device-matrix.outputs.android_matrix) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Restore node_modules cache
        id: cache
        uses: actions/cache@v4
        with:
          path: |
            node_modules
            .yarn/cache
            .yarn/install-state.gz
          key: ${{ runner.os }}-yarn-${{ hashFiles('**/yarn.lock') }}
          restore-keys: |
            ${{ runner.os }}-yarn-
      
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version-file: '.nvmrc'
          cache: 'yarn'
      
      - name: Install dependencies (if cache miss)
        if: steps.cache.outputs.cache-hit != 'true'
        run: yarn setup
      
      - name: BrowserStack Env Setup
        uses: browserstack/github-actions/setup-env@4478e16186f38e5be07721931642e65a028713c3
        with:
          username: ${{ env.BROWSERSTACK_USERNAME }}
          access-key: ${{ env.BROWSERSTACK_ACCESS_KEY }}
          build-name: ${{ github.repository }}-${{ github.ref_name }}-android-${{ matrix.device.name }}-${{ matrix.device.os_version }}-${{ github.run_number }}
          project-name: ${{ github.repository }}
      
      - name: Setup BrowserStack Local
        uses: browserstack/github-actions/setup-local@4478e16186f38e5be07721931642e65a028713c3
        with:
          local-testing: start
          local-identifier: ${{ github.run_id }}
          local-args: --force-local --verbose
      
      - name: Wait for BrowserStack Local
        run: |
          echo "Waiting for BrowserStack Local to be ready..."
          sleep 30
          echo "BrowserStack Local should be ready now"
      
      - name: Set Android Test Environment
        run: |
          echo "Setting test environment for device: ${{ matrix.device.name }}"
          {
            echo "BROWSERSTACK_DEVICE=${{ matrix.device.name }}"
            echo "BROWSERSTACK_OS_VERSION=${{ matrix.device.os_version }}"
            echo "BROWSERSTACK_ANDROID_APP_URL=${{ needs.trigger-qa-builds-and-upload.outputs.browserstack-qa-android-url }}"
            echo "BROWSERSTACK_ANDROID_CLEAN_APP_URL=${{ needs.trigger-qa-builds-and-upload.outputs.browserstack-clean-android-url }}"
            echo "TEST_PLATFORM=android"
            echo "QA_APP_VERSION=${{ needs.trigger-qa-builds-and-upload.outputs.qa-android-version }}"
            echo "CLEAN_APP_VERSION=${{ needs.trigger-qa-builds-and-upload.outputs.clean-android-version }}"
          } >> "$GITHUB_ENV"
      
      - name: Run All Android Tests on ${{ matrix.device.name }}
        env:
          BROWSERSTACK_LOCAL: true
          BROWSERSTACK_LOCAL_IDENTIFIER: ${{ github.run_id }}
        run: |
          echo "=== Running All Tests on ${{ matrix.device.name }} (${{ matrix.device.category }} Class) ==="
          echo "OS Version: ${{ matrix.device.os_version }}"
          echo "Category: ${{ matrix.device.category }}"
          echo "Branch: ${{ github.ref_name }}"
          echo "QA App Version: ${{ needs.trigger-qa-builds-and-upload.outputs.qa-android-version }}"
          echo "Clean App Version: ${{ needs.trigger-qa-builds-and-upload.outputs.clean-android-version }}"
          echo "BrowserStack QA Android App URL: ${{ needs.trigger-qa-builds-and-upload.outputs.browserstack-qa-android-url }}"
          echo "BrowserStack Clean Android App URL: ${{ needs.trigger-qa-builds-and-upload.outputs.browserstack-clean-android-url }}"
          
          # Run all tests (both regular and onboarding) in one command
          yarn run-appwright:all-android-bs
      
      - name: Upload Android Test Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: android-test-results-${{ matrix.device.name }}-${{ matrix.device.os_version }}
          path: |
            appwright/test-reports/appwright-report/
            appwright/reporters/reports
          if-no-files-found: ignore
          retention-days: 7

  ios-tests:
    name: iOS Performance Tests (All Types)
    runs-on: ubuntu-latest
    timeout-minutes: 60
    needs: [trigger-qa-builds-and-upload, read-device-matrix]
    strategy:
      fail-fast: false
      matrix:
        device: ${{ fromJson(needs.read-device-matrix.outputs.ios_matrix) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Restore node_modules cache
        id: cache
        uses: actions/cache@v4
        with:
          path: |
            node_modules
            .yarn/cache
            .yarn/install-state.gz
          key: ${{ runner.os }}-yarn-${{ hashFiles('**/yarn.lock') }}
          restore-keys: |
            ${{ runner.os }}-yarn-
      
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version-file: '.nvmrc'
          cache: 'yarn'
      
      - name: Install dependencies (if cache miss)
        if: steps.cache.outputs.cache-hit != 'true'
        run: yarn setup
      
      - name: BrowserStack Env Setup
        uses: browserstack/github-actions/setup-env@4478e16186f38e5be07721931642e65a028713c3
        with:
          username: ${{ env.BROWSERSTACK_USERNAME }}
          access-key: ${{ env.BROWSERSTACK_ACCESS_KEY }}
          build-name: ${{ github.repository }}-${{ github.ref_name }}-ios-${{ matrix.device.name }}-${{ matrix.device.os_version }}-${{ github.run_number }}
          project-name: ${{ github.repository }}
      
      - name: Setup BrowserStack Local
        uses: browserstack/github-actions/setup-local@4478e16186f38e5be07721931642e65a028713c3
        with:
          local-testing: start
          local-identifier: ${{ github.run_id }}
          local-args: --force-local --verbose
      
      - name: Wait for BrowserStack Local
        run: |
          echo "Waiting for BrowserStack Local to be ready..."
          sleep 30
          echo "BrowserStack Local should be ready now"
      
      - name: Set iOS Test Environment
        run: |
          echo "Setting test environment for device: ${{ matrix.device.name }}"
          {
            echo "BROWSERSTACK_DEVICE=${{ matrix.device.name }}"
            echo "BROWSERSTACK_OS_VERSION=${{ matrix.device.os_version }}"
            echo "BROWSERSTACK_IOS_APP_URL=${{ needs.trigger-qa-builds-and-upload.outputs.browserstack-qa-ios-url }}"
            echo "BROWSERSTACK_IOS_CLEAN_APP_URL=${{ needs.trigger-qa-builds-and-upload.outputs.browserstack-clean-ios-url }}"
            echo "QA_APP_VERSION=${{ needs.trigger-qa-builds-and-upload.outputs.qa-ios-version }}"
            echo "CLEAN_APP_VERSION=${{ needs.trigger-qa-builds-and-upload.outputs.clean-ios-version }}"
          } >> "$GITHUB_ENV"
      
      - name: Run All iOS Tests on ${{ matrix.device.name }}
        env:
          BROWSERSTACK_LOCAL: true
          BROWSERSTACK_LOCAL_IDENTIFIER: ${{ github.run_id }}
        run: |
          echo "=== Running All Tests on ${{ matrix.device.name }} (${{ matrix.device.category }} Class) ==="
          echo "OS Version: ${{ matrix.device.os_version }}"
          echo "Category: ${{ matrix.device.category }}"
          echo "Branch: ${{ github.ref_name }}"
          echo "QA App Version: ${{ needs.trigger-qa-builds-and-upload.outputs.qa-ios-version }}"
          echo "Clean App Version: ${{ needs.trigger-qa-builds-and-upload.outputs.clean-ios-version }}"
          echo "BrowserStack QA iOS App URL: ${{ needs.trigger-qa-builds-and-upload.outputs.browserstack-qa-ios-url }}"
          echo "BrowserStack Clean iOS App URL: ${{ needs.trigger-qa-builds-and-upload.outputs.browserstack-clean-ios-url }}"
          if [ "${{ matrix.device.os_version }}" == "13" ] || [ "${{ matrix.device.os_version }}" == "11" ]; then
            echo "Warning: iOS ${{ matrix.device.os_version }} may not be supported by MetaMask app"
          fi
          
          # Run all tests (both regular and onboarding) in one command
          yarn run-appwright:all-ios-bs
      
      - name: Upload iOS Test Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: ios-test-results-${{ matrix.device.name }}-${{ matrix.device.os_version }}
          path: |
            appwright/test-reports/appwright-report/
            appwright/reporters/reports
          if-no-files-found: ignore
          retention-days: 7

  # Results Gathering Job
  gather-results:
    name: Gather Test Results
    runs-on: ubuntu-latest
    needs: [trigger-qa-builds-and-upload, performance-tests, ios-tests]
    if: always()
    
    steps:
      - name: Download All Test Results
        uses: actions/download-artifact@v4
        with:
          path: appwright/test-reports/
      
      - name: Upload Combined Reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: combined-reports
          path: |
            appwright/test-reports/appwright-report/
            appwright/reporters/reports
          if-no-files-found: ignore
          retention-days: 14
    
      - name: Check Test Results
        id: test-results
        run: |
          if [ "${{ needs.performance-tests.result }}" == "failure" ] || [ "${{ needs.ios-tests.result }}" == "failure" ]; then
            echo "Some tests failed. Check the individual job results above."
            echo "Note: iOS 13 and iOS 11 failures are expected due to MetaMask app compatibility."
            echo "overall_status=failure" >> "$GITHUB_OUTPUT"
            exit 1
          else
            echo "All test jobs completed successfully!"
            echo "overall_status=success" >> "$GITHUB_OUTPUT"
          fi
      
      - name: Display Build Info
        run: |
          echo "=== QA Build Information (with pre-imported wallet) ==="
          echo "Android Version: ${{ needs.trigger-qa-builds-and-upload.outputs.qa-android-version }}"
          echo "iOS Version: ${{ needs.trigger-qa-builds-and-upload.outputs.qa-ios-version }}"
          echo ""
          echo "=== Clean Build Information (for onboarding tests) ==="
          echo "Android Version: ${{ needs.trigger-qa-builds-and-upload.outputs.clean-android-version }}"
          echo "iOS Version: ${{ needs.trigger-qa-builds-and-upload.outputs.clean-ios-version }}"
          echo ""
          echo "=== BrowserStack App URLs ==="
          echo "QA Android App URL: ${{ needs.trigger-qa-builds-and-upload.outputs.browserstack-qa-android-url }}"
          echo "QA iOS App URL: ${{ needs.trigger-qa-builds-and-upload.outputs.browserstack-qa-ios-url }}"
          echo "Clean Android App URL: ${{ needs.trigger-qa-builds-and-upload.outputs.browserstack-clean-android-url }}"
          echo "Clean iOS App URL: ${{ needs.trigger-qa-builds-and-upload.outputs.browserstack-clean-ios-url }}"
    
    outputs:
      overall_status: ${{ steps.test-results.outputs.overall_status }}

  # All Status Check Job
  all-status:
    name: Check All Job Statuses
    runs-on: ubuntu-latest
    needs: [read-device-matrix, trigger-qa-builds-and-upload, performance-tests, ios-tests, gather-results]
    if: always()
    outputs:
      overall_status: ${{ steps.status-check.outputs.overall_status }}
      android_status: ${{ steps.status-check.outputs.android_status }}
      ios_status: ${{ steps.status-check.outputs.ios_status }}
      trigger_status: ${{ steps.status-check.outputs.trigger_status }}
    
    steps:
      - name: Check All Job Statuses
        id: status-check
        run: |
          echo "Checking status of all jobs..."
          
          TRIGGER_RESULT="${{ needs.trigger-qa-builds-and-upload.result }}"
          ANDROID_RESULT="${{ needs.performance-tests.result }}"
          IOS_RESULT="${{ needs.ios-tests.result }}"
          
          echo "Job Results:"
          echo "- trigger-qa-builds-and-upload: $TRIGGER_RESULT"
          echo "- performance-tests (Android + Onboarding): $ANDROID_RESULT"
          echo "- ios-tests (iOS + Onboarding): $IOS_RESULT"
          
          # Determine overall status
          if [ "$TRIGGER_RESULT" = "failure" ]; then
            OVERALL_STATUS="❌ FAILED"
            echo "Overall Status: FAILED (QA builds failed)"
          elif [ "$ANDROID_RESULT" = "failure" ] || [ "$IOS_RESULT" = "failure" ]; then
            OVERALL_STATUS="❌ FAILED"
            echo "Overall Status: FAILED (tests failed)"
          else
            OVERALL_STATUS="✅ PASSED"
            echo "Overall Status: PASSED (all tests passed)"
          fi
          
          # Set outputs
          {
            echo "overall_status=$OVERALL_STATUS"
            echo "android_status=$ANDROID_RESULT"
            echo "ios_status=$IOS_RESULT"
            echo "trigger_status=$TRIGGER_RESULT"
          } >> "$GITHUB_OUTPUT"

  # Slack Notification Job
  slack-notification:
    name: Send Slack Notification
    runs-on: ubuntu-latest
    needs: [all-status]
    if: always()
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Generate Test Summary
        id: test-summary
        run: |
          echo "Generating test summary..."
          
          # Get device matrix for device names
          DEVICE_MATRIX=$(cat appwright/device-matrix.json)
          
          # Extract device information
          ANDROID_DEVICES=$(echo "$DEVICE_MATRIX" | jq -r '.android_devices[] | "\(.name) (\(.os_version))"')
          IOS_DEVICES=$(echo "$DEVICE_MATRIX" | jq -r '.ios_devices[] | "\(.name) (\(.os_version))"')
          
          # Get status from all-status job
          ANDROID_STATUS="${{ needs.all-status.outputs.android_status }}"
          IOS_STATUS="${{ needs.all-status.outputs.ios_status }}"
          
          # Format status for display
          if [ "$ANDROID_STATUS" = "success" ]; then
            ANDROID_DISPLAY="✅ PASSED"
          else
            ANDROID_DISPLAY="❌ FAILED"
          fi
          
          if [ "$IOS_STATUS" = "success" ]; then
            IOS_DISPLAY="✅ PASSED"
          else
            IOS_DISPLAY="❌ FAILED"
          fi
          
          # Create summary
          SUMMARY="*Performance E2E Tests*\n\n"
          
          SUMMARY+="---------------\n\n"
          SUMMARY+="*Devices Tested:*\n"
          SUMMARY+="• Android:\n"
          while IFS= read -r device; do
            if [ -n "$device" ]; then
              SUMMARY+="  • $device\n"
            fi
          done <<< "$ANDROID_DEVICES"
          SUMMARY+="• iOS:\n"
          while IFS= read -r device; do
            if [ -n "$device" ]; then
              SUMMARY+="  • $device\n"
            fi
          done <<< "$IOS_DEVICES"
          SUMMARY+="\n"
          SUMMARY+="---------------\n\n"
          SUMMARY+="*Test Results:*\n"
          SUMMARY+="• Android Tests (Regular + Onboarding): $ANDROID_DISPLAY\n"
          SUMMARY+="• iOS Tests (Regular + Onboarding): $IOS_DISPLAY\n\n"
          SUMMARY+="---------------\n\n"
          SUMMARY+="*Build Info:*\n"
          SUMMARY+="• Commit Hash: \`${{ github.sha }}\`\n"
          SUMMARY+="---------------\n\n"
          SUMMARY+="<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Full Results>"
          
          {
            echo "summary<<EOF"
            echo "$SUMMARY"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"
          
          echo "Test summary generated"
      
      # - name: Send Slack Notification
      #   uses: slackapi/slack-github-action@91efab103c0de0a537f72a35f6b8cda0ee76bf0a
      #   with:
      #     webhook: ${{ secrets.PERFORMANCE_E2E_SLACK_WEBHOOK_URL }}
      #     webhook-type: incoming-webhook
      #     payload: |
      #       {
      #         "text": "${{ steps.test-summary.outputs.summary }}"
      #       }