diff --git a/dist/RampsController.cjs b/dist/RampsController.cjs
index c55475c28a2bf06c7b079953e91337b95505d466..d8cb924b255152c52d40b804021c3987033991c7 100644
--- a/dist/RampsController.cjs
+++ b/dist/RampsController.cjs
@@ -10,7 +10,7 @@ var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (
     if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
     return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
 };
-var _RampsController_instances, _RampsController_requestCacheTTL, _RampsController_requestCacheMaxSize, _RampsController_pendingRequests, _RampsController_removeRequestState, _RampsController_updateRequestState;
+var _RampsController_instances, _RampsController_requestCacheTTL, _RampsController_requestCacheMaxSize, _RampsController_pendingRequests, _RampsController_removeRequestState, _RampsController_updateRequestState, _RampsController_getCountriesData;
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.RampsController = exports.getDefaultRampsControllerState = exports.controllerName = void 0;
 const base_controller_1 = require("@metamask/base-controller");
@@ -32,6 +32,12 @@ const rampsControllerMetadata = {
         includeInStateLogs: true,
         usedInUi: true,
     },
+    preferredProvider: {
+        persist: true,
+        includeInDebugSnapshot: true,
+        includeInStateLogs: true,
+        usedInUi: true,
+    },
     eligibility: {
         persist: true,
         includeInDebugSnapshot: true,
@@ -62,12 +68,66 @@ const rampsControllerMetadata = {
 function getDefaultRampsControllerState() {
     return {
         userRegion: null,
+        preferredProvider: null,
         eligibility: null,
         tokens: null,
         requests: {},
     };
 }
 exports.getDefaultRampsControllerState = getDefaultRampsControllerState;
+// === HELPER FUNCTIONS ===
+/**
+ * Finds a country and state from a region code string.
+ *
+ * @param regionCode - The region code (e.g., "us-ca" or "fr").
+ * @param countries - Array of countries to search.
+ * @returns UserRegion object with country and state, or null if not found.
+ */
+function findRegionFromCode(regionCode, countries) {
+    const normalizedCode = regionCode.toLowerCase().trim();
+    const parts = normalizedCode.split('-');
+    const countryCode = parts[0];
+    const stateCode = parts[1];
+    const country = countries.find((c) => {
+        if (c.isoCode?.toLowerCase() === countryCode) {
+            return true;
+        }
+        if (c.id) {
+            const id = c.id.toLowerCase();
+            if (id.startsWith('/regions/')) {
+                const extractedCode = id.replace('/regions/', '').split('/')[0];
+                return extractedCode === countryCode;
+            }
+            return id === countryCode || id.endsWith(`/${countryCode}`);
+        }
+        return false;
+    });
+    if (!country) {
+        return null;
+    }
+    let state = null;
+    if (stateCode && country.states) {
+        state =
+            country.states.find((s) => {
+                if (s.stateId?.toLowerCase() === stateCode) {
+                    return true;
+                }
+                if (s.id) {
+                    const stateId = s.id.toLowerCase();
+                    if (stateId.includes(`-${stateCode}`) ||
+                        stateId.endsWith(`/${stateCode}`)) {
+                        return true;
+                    }
+                }
+                return false;
+            }) || null;
+    }
+    return {
+        country,
+        state,
+        regionCode: normalizedCode,
+    };
+}
 // === CONTROLLER DEFINITION ===
 /**
  * Manages cryptocurrency on/off ramps functionality.
@@ -206,36 +266,78 @@ class RampsController extends base_controller_1.BaseController {
      * then automatically fetches eligibility for that region.
      *
      * @param options - Options for cache behavior.
-     * @returns The user region string.
+     * @returns The user region object.
      */
     async updateUserRegion(options) {
         const cacheKey = (0, RequestCache_1.createCacheKey)('updateUserRegion', []);
-        const userRegion = await this.executeRequest(cacheKey, async () => {
+        const regionCode = await this.executeRequest(cacheKey, async () => {
             const result = await this.messenger.call('RampsService:getGeolocation');
             return result;
         }, options);
-        const normalizedRegion = userRegion
-            ? userRegion.toLowerCase().trim()
-            : userRegion;
-        this.update((state) => {
-            state.userRegion = normalizedRegion;
-            state.tokens = null;
-        });
-        if (normalizedRegion) {
-            try {
-                await this.updateEligibility(normalizedRegion, options);
-            }
-            catch {
+        if (!regionCode) {
+            this.update((state) => {
+                state.userRegion = null;
+                state.tokens = null;
+            });
+            return null;
+        }
+        const normalizedRegion = regionCode.toLowerCase().trim();
+        try {
+            const countries = await __classPrivateFieldGet(this, _RampsController_instances, "m", _RampsController_getCountriesData).call(this, 'buy', options);
+            const userRegion = findRegionFromCode(normalizedRegion, countries);
+            if (userRegion) {
                 this.update((state) => {
-                    const currentUserRegion = state.userRegion?.toLowerCase().trim();
-                    if (currentUserRegion === normalizedRegion) {
-                        state.eligibility = null;
-                        state.tokens = null;
-                    }
+                    state.userRegion = userRegion;
+                    state.tokens = null;
                 });
+                try {
+                    await this.updateEligibility(userRegion.regionCode, options);
+                }
+                catch {
+                    this.update((state) => {
+                        if (state.userRegion?.regionCode === userRegion.regionCode) {
+                            state.eligibility = null;
+                            state.tokens = null;
+                        }
+                    });
+                }
+                return userRegion;
             }
         }
-        return normalizedRegion;
+        catch {
+            // If countries fetch fails, fall back to storing just the region code
+            // This maintains backward compatibility
+        }
+        // Fallback: store as region code only if countries not available
+        // This shouldn't happen in normal flow, but handles edge cases
+        const fallbackRegion = {
+            country: {
+                isoCode: normalizedRegion.split('-')[0].toUpperCase(),
+                flag: 'ðŸ³ï¸',
+                name: normalizedRegion,
+                phone: { prefix: '', placeholder: '', template: '' },
+                currency: '',
+                supported: false,
+            },
+            state: null,
+            regionCode: normalizedRegion,
+        };
+        this.update((state) => {
+            state.userRegion = fallbackRegion;
+            state.tokens = null;
+        });
+        try {
+            await this.updateEligibility(normalizedRegion, options);
+        }
+        catch {
+            this.update((state) => {
+                if (state.userRegion?.regionCode === normalizedRegion) {
+                    state.eligibility = null;
+                    state.tokens = null;
+                }
+            });
+        }
+        return fallbackRegion;
     }
     /**
      * Sets the user's region manually (without fetching geolocation).
@@ -247,22 +349,54 @@ class RampsController extends base_controller_1.BaseController {
      */
     async setUserRegion(region, options) {
         const normalizedRegion = region.toLowerCase().trim();
+        try {
+            const countries = await __classPrivateFieldGet(this, _RampsController_instances, "m", _RampsController_getCountriesData).call(this, 'buy', options);
+            const userRegion = findRegionFromCode(normalizedRegion, countries);
+            if (userRegion) {
+                this.update((state) => {
+                    state.userRegion = userRegion;
+                    state.tokens = null;
+                });
+                try {
+                    return await this.updateEligibility(userRegion.regionCode, options);
+                }
+                catch (error) {
+                    this.update((state) => {
+                        if (state.userRegion?.regionCode === userRegion.regionCode) {
+                            state.eligibility = null;
+                            state.tokens = null;
+                        }
+                    });
+                    throw error;
+                }
+            }
+        }
+        catch {
+            // If countries fetch fails, fall back to storing just the region code
+        }
+        // Fallback: store as region code only if countries not available
+        const fallbackRegion = {
+            country: {
+                isoCode: normalizedRegion.split('-')[0].toUpperCase(),
+                flag: 'ðŸ³ï¸',
+                name: normalizedRegion,
+                phone: { prefix: '', placeholder: '', template: '' },
+                currency: '',
+                supported: false,
+            },
+            state: null,
+            regionCode: normalizedRegion,
+        };
         this.update((state) => {
-            state.userRegion = normalizedRegion;
+            state.userRegion = fallbackRegion;
             state.tokens = null;
         });
         try {
             return await this.updateEligibility(normalizedRegion, options);
         }
         catch (error) {
-            // Eligibility fetch failed, but user region was successfully set.
-            // Don't let eligibility errors prevent user region state from being updated.
-            // Clear eligibility state to avoid showing stale data from a previous location.
-            // Only clear if the region still matches to avoid race conditions where a newer
-            // region change has already succeeded.
             this.update((state) => {
-                const currentUserRegion = state.userRegion?.toLowerCase().trim();
-                if (currentUserRegion === normalizedRegion) {
+                if (state.userRegion?.regionCode === normalizedRegion) {
                     state.eligibility = null;
                     state.tokens = null;
                 }
@@ -270,6 +404,17 @@ class RampsController extends base_controller_1.BaseController {
             throw error;
         }
     }
+    /**
+     * Sets the user's preferred provider.
+     * This allows users to set their preferred ramp provider.
+     *
+     * @param provider - The provider object to set.
+     */
+    setPreferredProvider(provider) {
+        this.update((state) => {
+            state.preferredProvider = provider;
+        });
+    }
     /**
      * Initializes the controller by fetching the user's region from geolocation.
      * This should be called once at app startup to set up the initial region.
@@ -286,7 +431,7 @@ class RampsController extends base_controller_1.BaseController {
         });
         if (userRegion) {
             try {
-                await this.getTokens(userRegion, 'buy', options);
+                await this.getTokens(userRegion.regionCode, 'buy', options);
             }
             catch {
                 // Token fetch failed - error state will be available via selectors
@@ -307,8 +452,8 @@ class RampsController extends base_controller_1.BaseController {
             return this.messenger.call('RampsService:getEligibility', normalizedIsoCode);
         }, options);
         this.update((state) => {
-            const userRegion = state.userRegion?.toLowerCase().trim();
-            if (userRegion === undefined || userRegion === normalizedIsoCode) {
+            const userRegionCode = state.userRegion?.regionCode;
+            if (userRegionCode === undefined || userRegionCode === normalizedIsoCode) {
                 state.eligibility = eligibility;
             }
         });
@@ -337,7 +482,7 @@ class RampsController extends base_controller_1.BaseController {
      * @returns The tokens response containing topTokens and allTokens.
      */
     async getTokens(region, action = 'buy', options) {
-        const regionToUse = region ?? this.state.userRegion;
+        const regionToUse = region ?? this.state.userRegion?.regionCode;
         if (!regionToUse) {
             throw new Error('Region is required. Either provide a region parameter or ensure userRegion is set in controller state.');
         }
@@ -347,8 +492,8 @@ class RampsController extends base_controller_1.BaseController {
             return this.messenger.call('RampsService:getTokens', normalizedRegion, action);
         }, options);
         this.update((state) => {
-            const userRegion = state.userRegion?.toLowerCase().trim();
-            if (userRegion === undefined || userRegion === normalizedRegion) {
+            const userRegionCode = state.userRegion?.regionCode;
+            if (userRegionCode === undefined || userRegionCode === normalizedRegion) {
                 state.tokens = tokens;
             }
         });
@@ -385,5 +530,15 @@ _RampsController_requestCacheTTL = new WeakMap(), _RampsController_requestCacheM
             }
         }
     });
+}, _RampsController_getCountriesData = 
+/**
+ * Gets countries data from cache or fetches it if not available.
+ *
+ * @param action - The ramp action type ('buy' or 'sell').
+ * @param options - Options for cache behavior.
+ * @returns Array of countries.
+ */
+async function _RampsController_getCountriesData(action = 'buy', options) {
+    return this.getCountries(action, options);
 };
 //# sourceMappingURL=RampsController.cjs.map
\ No newline at end of file
diff --git a/dist/RampsController.cjs.map b/dist/RampsController.cjs.map
index 4c0f95a0e22906c63c3954889dc5ab565c56046f..f4a8069805b8a21a47d8cf2d53bfa12d74015d36 100644
--- a/dist/RampsController.cjs.map
+++ b/dist/RampsController.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"RampsController.cjs","sourceRoot":"","sources":["../src/RampsController.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n  StateMetadata,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport type { Messenger } from '@metamask/messenger';\nimport type { Json } from '@metamask/utils';\n\nimport type { Country, Eligibility, TokensResponse } from './RampsService';\nimport type {\n  RampsServiceGetGeolocationAction,\n  RampsServiceGetCountriesAction,\n  RampsServiceGetEligibilityAction,\n  RampsServiceGetTokensAction,\n} from './RampsService-method-action-types';\nimport type {\n  RequestCache as RequestCacheType,\n  RequestState,\n  ExecuteRequestOptions,\n  PendingRequest,\n} from './RequestCache';\nimport {\n  DEFAULT_REQUEST_CACHE_TTL,\n  DEFAULT_REQUEST_CACHE_MAX_SIZE,\n  createCacheKey,\n  isCacheExpired,\n  createLoadingState,\n  createSuccessState,\n  createErrorState,\n} from './RequestCache';\n\n// === GENERAL ===\n\n/**\n * The name of the {@link RampsController}, used to namespace the\n * controller's actions and events and to namespace the controller's state data\n * when composed with other controllers.\n */\nexport const controllerName = 'RampsController';\n\n// === STATE ===\n\n/**\n * Describes the shape of the state object for {@link RampsController}.\n */\nexport type RampsControllerState = {\n  /**\n   * The user's selected region code (e.g., \"US-CA\").\n   * Initially set via geolocation fetch, but can be manually changed by the user.\n   */\n  userRegion: string | null;\n  /**\n   * Eligibility information for the user's current region.\n   */\n  eligibility: Eligibility | null;\n  /**\n   * Tokens fetched for the current region and action.\n   * Contains topTokens and allTokens arrays.\n   */\n  tokens: TokensResponse | null;\n  /**\n   * Cache of request states, keyed by cache key.\n   * This stores loading, success, and error states for API requests.\n   */\n  requests: RequestCacheType;\n};\n\n/**\n * The metadata for each property in {@link RampsControllerState}.\n */\nconst rampsControllerMetadata = {\n  userRegion: {\n    persist: true,\n    includeInDebugSnapshot: true,\n    includeInStateLogs: true,\n    usedInUi: true,\n  },\n  eligibility: {\n    persist: true,\n    includeInDebugSnapshot: true,\n    includeInStateLogs: true,\n    usedInUi: true,\n  },\n  tokens: {\n    persist: true,\n    includeInDebugSnapshot: true,\n    includeInStateLogs: true,\n    usedInUi: true,\n  },\n  requests: {\n    persist: false,\n    includeInDebugSnapshot: true,\n    includeInStateLogs: false,\n    usedInUi: true,\n  },\n} satisfies StateMetadata<RampsControllerState>;\n\n/**\n * Constructs the default {@link RampsController} state. This allows\n * consumers to provide a partial state object when initializing the controller\n * and also helps in constructing complete state objects for this controller in\n * tests.\n *\n * @returns The default {@link RampsController} state.\n */\nexport function getDefaultRampsControllerState(): RampsControllerState {\n  return {\n    userRegion: null,\n    eligibility: null,\n    tokens: null,\n    requests: {},\n  };\n}\n\n// === MESSENGER ===\n\n/**\n * Retrieves the state of the {@link RampsController}.\n */\nexport type RampsControllerGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  RampsControllerState\n>;\n\n/**\n * Actions that {@link RampsControllerMessenger} exposes to other consumers.\n */\nexport type RampsControllerActions = RampsControllerGetStateAction;\n\n/**\n * Actions from other messengers that {@link RampsController} calls.\n */\ntype AllowedActions =\n  | RampsServiceGetGeolocationAction\n  | RampsServiceGetCountriesAction\n  | RampsServiceGetEligibilityAction\n  | RampsServiceGetTokensAction;\n\n/**\n * Published when the state of {@link RampsController} changes.\n */\nexport type RampsControllerStateChangeEvent = ControllerStateChangeEvent<\n  typeof controllerName,\n  RampsControllerState\n>;\n\n/**\n * Events that {@link RampsControllerMessenger} exposes to other consumers.\n */\nexport type RampsControllerEvents = RampsControllerStateChangeEvent;\n\n/**\n * Events from other messengers that {@link RampsController} subscribes to.\n */\ntype AllowedEvents = never;\n\n/**\n * The messenger restricted to actions and events accessed by\n * {@link RampsController}.\n */\nexport type RampsControllerMessenger = Messenger<\n  typeof controllerName,\n  RampsControllerActions | AllowedActions,\n  RampsControllerEvents | AllowedEvents\n>;\n\n/**\n * Configuration options for the RampsController.\n */\nexport type RampsControllerOptions = {\n  /** The messenger suited for this controller. */\n  messenger: RampsControllerMessenger;\n  /** The desired state with which to initialize this controller. */\n  state?: Partial<RampsControllerState>;\n  /** Time to live for cached requests in milliseconds. Defaults to 15 minutes. */\n  requestCacheTTL?: number;\n  /** Maximum number of entries in the request cache. Defaults to 250. */\n  requestCacheMaxSize?: number;\n};\n\n// === CONTROLLER DEFINITION ===\n\n/**\n * Manages cryptocurrency on/off ramps functionality.\n */\nexport class RampsController extends BaseController<\n  typeof controllerName,\n  RampsControllerState,\n  RampsControllerMessenger\n> {\n  /**\n   * Default TTL for cached requests.\n   */\n  readonly #requestCacheTTL: number;\n\n  /**\n   * Maximum number of entries in the request cache.\n   */\n  readonly #requestCacheMaxSize: number;\n\n  /**\n   * Map of pending requests for deduplication.\n   * Key is the cache key, value is the pending request with abort controller.\n   */\n  readonly #pendingRequests: Map<string, PendingRequest> = new Map();\n\n  /**\n   * Constructs a new {@link RampsController}.\n   *\n   * @param args - The constructor arguments.\n   * @param args.messenger - The messenger suited for this controller.\n   * @param args.state - The desired state with which to initialize this\n   * controller. Missing properties will be filled in with defaults.\n   * @param args.requestCacheTTL - Time to live for cached requests in milliseconds.\n   * @param args.requestCacheMaxSize - Maximum number of entries in the request cache.\n   */\n  constructor({\n    messenger,\n    state = {},\n    requestCacheTTL = DEFAULT_REQUEST_CACHE_TTL,\n    requestCacheMaxSize = DEFAULT_REQUEST_CACHE_MAX_SIZE,\n  }: RampsControllerOptions) {\n    super({\n      messenger,\n      metadata: rampsControllerMetadata,\n      name: controllerName,\n      state: {\n        ...getDefaultRampsControllerState(),\n        ...state,\n        // Always reset requests cache on initialization (non-persisted)\n        requests: {},\n      },\n    });\n\n    this.#requestCacheTTL = requestCacheTTL;\n    this.#requestCacheMaxSize = requestCacheMaxSize;\n  }\n\n  /**\n   * Executes a request with caching and deduplication.\n   *\n   * If a request with the same cache key is already in flight, returns the\n   * existing promise. If valid cached data exists, returns it without making\n   * a new request.\n   *\n   * @param cacheKey - Unique identifier for this request.\n   * @param fetcher - Function that performs the actual fetch. Receives an AbortSignal.\n   * @param options - Options for cache behavior.\n   * @returns The result of the request.\n   */\n  async executeRequest<TResult>(\n    cacheKey: string,\n    fetcher: (signal: AbortSignal) => Promise<TResult>,\n    options?: ExecuteRequestOptions,\n  ): Promise<TResult> {\n    const ttl = options?.ttl ?? this.#requestCacheTTL;\n\n    // Check for existing pending request - join it instead of making a duplicate\n    const pending = this.#pendingRequests.get(cacheKey);\n    if (pending) {\n      return pending.promise as Promise<TResult>;\n    }\n\n    // Check cache validity (unless force refresh)\n    if (!options?.forceRefresh) {\n      const cached = this.state.requests[cacheKey];\n      if (cached && !isCacheExpired(cached, ttl)) {\n        return cached.data as TResult;\n      }\n    }\n\n    // Create abort controller for this request\n    const abortController = new AbortController();\n    const lastFetchedAt = Date.now();\n\n    // Update state to loading\n    this.#updateRequestState(cacheKey, createLoadingState());\n\n    // Create the fetch promise\n    const promise = (async (): Promise<TResult> => {\n      try {\n        const data = await fetcher(abortController.signal);\n\n        // Don't update state if aborted\n        if (abortController.signal.aborted) {\n          throw new Error('Request was aborted');\n        }\n\n        this.#updateRequestState(\n          cacheKey,\n          createSuccessState(data as Json, lastFetchedAt),\n        );\n        return data;\n      } catch (error) {\n        // Don't update state if aborted\n        if (abortController.signal.aborted) {\n          throw error;\n        }\n\n        const errorMessage = (error as Error)?.message;\n\n        this.#updateRequestState(\n          cacheKey,\n          createErrorState(errorMessage ?? 'Unknown error', lastFetchedAt),\n        );\n        throw error;\n      } finally {\n        // Only delete if this is still our entry (not replaced by a new request)\n        const currentPending = this.#pendingRequests.get(cacheKey);\n        if (currentPending?.abortController === abortController) {\n          this.#pendingRequests.delete(cacheKey);\n        }\n      }\n    })();\n\n    // Store pending request for deduplication\n    this.#pendingRequests.set(cacheKey, { promise, abortController });\n\n    return promise;\n  }\n\n  /**\n   * Aborts a pending request if one exists.\n   *\n   * @param cacheKey - The cache key of the request to abort.\n   * @returns True if a request was aborted.\n   */\n  abortRequest(cacheKey: string): boolean {\n    const pending = this.#pendingRequests.get(cacheKey);\n    if (pending) {\n      pending.abortController.abort();\n      this.#pendingRequests.delete(cacheKey);\n      this.#removeRequestState(cacheKey);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Removes a request state from the cache.\n   *\n   * @param cacheKey - The cache key to remove.\n   */\n  #removeRequestState(cacheKey: string): void {\n    this.update((state) => {\n      const requests = state.requests as unknown as Record<\n        string,\n        RequestState | undefined\n      >;\n      delete requests[cacheKey];\n    });\n  }\n\n  /**\n   * Gets the state of a specific cached request.\n   *\n   * @param cacheKey - The cache key to look up.\n   * @returns The request state, or undefined if not cached.\n   */\n  getRequestState(cacheKey: string): RequestState | undefined {\n    return this.state.requests[cacheKey];\n  }\n\n  /**\n   * Updates the state for a specific request.\n   *\n   * @param cacheKey - The cache key.\n   * @param requestState - The new state for the request.\n   */\n  #updateRequestState(cacheKey: string, requestState: RequestState): void {\n    const maxSize = this.#requestCacheMaxSize;\n\n    this.update((state) => {\n      const requests = state.requests as unknown as Record<\n        string,\n        RequestState | undefined\n      >;\n      requests[cacheKey] = requestState;\n\n      // Evict oldest entries if cache exceeds max size\n      const keys = Object.keys(requests);\n\n      if (keys.length > maxSize) {\n        // Sort by timestamp (oldest first)\n        const sortedKeys = keys.sort((a, b) => {\n          const aTime = requests[a]?.timestamp ?? 0;\n          const bTime = requests[b]?.timestamp ?? 0;\n          return aTime - bTime;\n        });\n\n        // Remove oldest entries until we're under the limit\n        const entriesToRemove = keys.length - maxSize;\n        for (let i = 0; i < entriesToRemove; i++) {\n          const keyToRemove = sortedKeys[i];\n          if (keyToRemove) {\n            delete requests[keyToRemove];\n          }\n        }\n      }\n    });\n  }\n\n  /**\n   * Updates the user's region by fetching geolocation and eligibility.\n   * This method calls the RampsService to get the geolocation,\n   * then automatically fetches eligibility for that region.\n   *\n   * @param options - Options for cache behavior.\n   * @returns The user region string.\n   */\n  async updateUserRegion(options?: ExecuteRequestOptions): Promise<string> {\n    const cacheKey = createCacheKey('updateUserRegion', []);\n\n    const userRegion = await this.executeRequest(\n      cacheKey,\n      async () => {\n        const result = await this.messenger.call('RampsService:getGeolocation');\n        return result;\n      },\n      options,\n    );\n\n    const normalizedRegion = userRegion\n      ? userRegion.toLowerCase().trim()\n      : userRegion;\n\n    this.update((state) => {\n      state.userRegion = normalizedRegion;\n      state.tokens = null;\n    });\n\n    if (normalizedRegion) {\n      try {\n        await this.updateEligibility(normalizedRegion, options);\n      } catch {\n        this.update((state) => {\n          const currentUserRegion = state.userRegion?.toLowerCase().trim();\n          if (currentUserRegion === normalizedRegion) {\n            state.eligibility = null;\n            state.tokens = null;\n          }\n        });\n      }\n    }\n\n    return normalizedRegion;\n  }\n\n  /**\n   * Sets the user's region manually (without fetching geolocation).\n   * This allows users to override the detected region.\n   *\n   * @param region - The region code to set (e.g., \"US-CA\").\n   * @param options - Options for cache behavior when fetching eligibility.\n   * @returns The eligibility information for the region.\n   */\n  async setUserRegion(\n    region: string,\n    options?: ExecuteRequestOptions,\n  ): Promise<Eligibility> {\n    const normalizedRegion = region.toLowerCase().trim();\n\n    this.update((state) => {\n      state.userRegion = normalizedRegion;\n      state.tokens = null;\n    });\n\n    try {\n      return await this.updateEligibility(normalizedRegion, options);\n    } catch (error) {\n      // Eligibility fetch failed, but user region was successfully set.\n      // Don't let eligibility errors prevent user region state from being updated.\n      // Clear eligibility state to avoid showing stale data from a previous location.\n      // Only clear if the region still matches to avoid race conditions where a newer\n      // region change has already succeeded.\n      this.update((state) => {\n        const currentUserRegion = state.userRegion?.toLowerCase().trim();\n        if (currentUserRegion === normalizedRegion) {\n          state.eligibility = null;\n          state.tokens = null;\n        }\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Initializes the controller by fetching the user's region from geolocation.\n   * This should be called once at app startup to set up the initial region.\n   * After the region is set and eligibility is determined, tokens are fetched\n   * and saved to state.\n   *\n   * @param options - Options for cache behavior.\n   * @returns Promise that resolves when initialization is complete.\n   */\n  async init(options?: ExecuteRequestOptions): Promise<void> {\n    const userRegion = await this.updateUserRegion(options).catch(() => {\n      // User region fetch failed - error state will be available via selectors\n      return null;\n    });\n\n    if (userRegion) {\n      try {\n        await this.getTokens(userRegion, 'buy', options);\n      } catch {\n        // Token fetch failed - error state will be available via selectors\n      }\n    }\n  }\n\n  /**\n   * Updates the eligibility information for a given region.\n   *\n   * @param isoCode - The ISO code for the region (e.g., \"us\", \"fr\", \"us-ny\").\n   * @param options - Options for cache behavior.\n   * @returns The eligibility information.\n   */\n  async updateEligibility(\n    isoCode: string,\n    options?: ExecuteRequestOptions,\n  ): Promise<Eligibility> {\n    const normalizedIsoCode = isoCode.toLowerCase().trim();\n    const cacheKey = createCacheKey('updateEligibility', [normalizedIsoCode]);\n\n    const eligibility = await this.executeRequest(\n      cacheKey,\n      async () => {\n        return this.messenger.call(\n          'RampsService:getEligibility',\n          normalizedIsoCode,\n        );\n      },\n      options,\n    );\n\n    this.update((state) => {\n      const userRegion = state.userRegion?.toLowerCase().trim();\n\n      if (userRegion === undefined || userRegion === normalizedIsoCode) {\n        state.eligibility = eligibility;\n      }\n    });\n\n    return eligibility;\n  }\n\n  /**\n   * Fetches the list of supported countries for a given ramp action.\n   *\n   * @param action - The ramp action type ('buy' or 'sell').\n   * @param options - Options for cache behavior.\n   * @returns An array of countries with their eligibility information.\n   */\n  async getCountries(\n    action: 'buy' | 'sell' = 'buy',\n    options?: ExecuteRequestOptions,\n  ): Promise<Country[]> {\n    const cacheKey = createCacheKey('getCountries', [action]);\n\n    return this.executeRequest(\n      cacheKey,\n      async () => {\n        return this.messenger.call('RampsService:getCountries', action);\n      },\n      options,\n    );\n  }\n\n  /**\n   * Fetches the list of available tokens for a given region and action.\n   * The tokens are saved in the controller state once fetched.\n   *\n   * @param region - The region code (e.g., \"us\", \"fr\", \"us-ny\"). If not provided, uses the user's region from controller state.\n   * @param action - The ramp action type ('buy' or 'sell').\n   * @param options - Options for cache behavior.\n   * @returns The tokens response containing topTokens and allTokens.\n   */\n  async getTokens(\n    region?: string,\n    action: 'buy' | 'sell' = 'buy',\n    options?: ExecuteRequestOptions,\n  ): Promise<TokensResponse> {\n    const regionToUse = region ?? this.state.userRegion;\n\n    if (!regionToUse) {\n      throw new Error(\n        'Region is required. Either provide a region parameter or ensure userRegion is set in controller state.',\n      );\n    }\n\n    const normalizedRegion = regionToUse.toLowerCase().trim();\n    const cacheKey = createCacheKey('getTokens', [normalizedRegion, action]);\n\n    const tokens = await this.executeRequest(\n      cacheKey,\n      async () => {\n        return this.messenger.call(\n          'RampsService:getTokens',\n          normalizedRegion,\n          action,\n        );\n      },\n      options,\n    );\n\n    this.update((state) => {\n      const userRegion = state.userRegion?.toLowerCase().trim();\n\n      if (userRegion === undefined || userRegion === normalizedRegion) {\n        state.tokens = tokens;\n      }\n    });\n\n    return tokens;\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"RampsController.cjs","sourceRoot":"","sources":["../src/RampsController.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n  StateMetadata,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport type { Messenger } from '@metamask/messenger';\nimport type { Json } from '@metamask/utils';\n\nimport type {\n  Country,\n  Eligibility,\n  TokensResponse,\n  Provider,\n  State,\n} from './RampsService';\nimport type {\n  RampsServiceGetGeolocationAction,\n  RampsServiceGetCountriesAction,\n  RampsServiceGetEligibilityAction,\n  RampsServiceGetTokensAction,\n} from './RampsService-method-action-types';\nimport type {\n  RequestCache as RequestCacheType,\n  RequestState,\n  ExecuteRequestOptions,\n  PendingRequest,\n} from './RequestCache';\nimport {\n  DEFAULT_REQUEST_CACHE_TTL,\n  DEFAULT_REQUEST_CACHE_MAX_SIZE,\n  createCacheKey,\n  isCacheExpired,\n  createLoadingState,\n  createSuccessState,\n  createErrorState,\n} from './RequestCache';\n\n// === GENERAL ===\n\n/**\n * The name of the {@link RampsController}, used to namespace the\n * controller's actions and events and to namespace the controller's state data\n * when composed with other controllers.\n */\nexport const controllerName = 'RampsController';\n\n// === STATE ===\n\n/**\n * Represents the user's selected region with full country and state objects.\n */\nexport type UserRegion = {\n  /**\n   * The country object for the selected region.\n   */\n  country: Country;\n  /**\n   * The state object if a state was selected, null if only country was selected.\n   */\n  state: State | null;\n  /**\n   * The region code string (e.g., \"us-ut\" or \"fr\") used for API calls.\n   */\n  regionCode: string;\n};\n\n/**\n * Describes the shape of the state object for {@link RampsController}.\n */\nexport type RampsControllerState = {\n  /**\n   * The user's selected region with full country and state objects.\n   * Initially set via geolocation fetch, but can be manually changed by the user.\n   */\n  userRegion: UserRegion | null;\n  /**\n   * The user's preferred provider.\n   * Can be manually set by the user.\n   */\n  preferredProvider: Provider | null;\n  /**\n   * Eligibility information for the user's current region.\n   */\n  eligibility: Eligibility | null;\n  /**\n   * Tokens fetched for the current region and action.\n   * Contains topTokens and allTokens arrays.\n   */\n  tokens: TokensResponse | null;\n  /**\n   * Cache of request states, keyed by cache key.\n   * This stores loading, success, and error states for API requests.\n   */\n  requests: RequestCacheType;\n};\n\n/**\n * The metadata for each property in {@link RampsControllerState}.\n */\nconst rampsControllerMetadata = {\n  userRegion: {\n    persist: true,\n    includeInDebugSnapshot: true,\n    includeInStateLogs: true,\n    usedInUi: true,\n  },\n  preferredProvider: {\n    persist: true,\n    includeInDebugSnapshot: true,\n    includeInStateLogs: true,\n    usedInUi: true,\n  },\n  eligibility: {\n    persist: true,\n    includeInDebugSnapshot: true,\n    includeInStateLogs: true,\n    usedInUi: true,\n  },\n  tokens: {\n    persist: true,\n    includeInDebugSnapshot: true,\n    includeInStateLogs: true,\n    usedInUi: true,\n  },\n  requests: {\n    persist: false,\n    includeInDebugSnapshot: true,\n    includeInStateLogs: false,\n    usedInUi: true,\n  },\n} satisfies StateMetadata<RampsControllerState>;\n\n/**\n * Constructs the default {@link RampsController} state. This allows\n * consumers to provide a partial state object when initializing the controller\n * and also helps in constructing complete state objects for this controller in\n * tests.\n *\n * @returns The default {@link RampsController} state.\n */\nexport function getDefaultRampsControllerState(): RampsControllerState {\n  return {\n    userRegion: null,\n    preferredProvider: null,\n    eligibility: null,\n    tokens: null,\n    requests: {},\n  };\n}\n\n// === MESSENGER ===\n\n/**\n * Retrieves the state of the {@link RampsController}.\n */\nexport type RampsControllerGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  RampsControllerState\n>;\n\n/**\n * Actions that {@link RampsControllerMessenger} exposes to other consumers.\n */\nexport type RampsControllerActions = RampsControllerGetStateAction;\n\n/**\n * Actions from other messengers that {@link RampsController} calls.\n */\ntype AllowedActions =\n  | RampsServiceGetGeolocationAction\n  | RampsServiceGetCountriesAction\n  | RampsServiceGetEligibilityAction\n  | RampsServiceGetTokensAction;\n\n/**\n * Published when the state of {@link RampsController} changes.\n */\nexport type RampsControllerStateChangeEvent = ControllerStateChangeEvent<\n  typeof controllerName,\n  RampsControllerState\n>;\n\n/**\n * Events that {@link RampsControllerMessenger} exposes to other consumers.\n */\nexport type RampsControllerEvents = RampsControllerStateChangeEvent;\n\n/**\n * Events from other messengers that {@link RampsController} subscribes to.\n */\ntype AllowedEvents = never;\n\n/**\n * The messenger restricted to actions and events accessed by\n * {@link RampsController}.\n */\nexport type RampsControllerMessenger = Messenger<\n  typeof controllerName,\n  RampsControllerActions | AllowedActions,\n  RampsControllerEvents | AllowedEvents\n>;\n\n/**\n * Configuration options for the RampsController.\n */\nexport type RampsControllerOptions = {\n  /** The messenger suited for this controller. */\n  messenger: RampsControllerMessenger;\n  /** The desired state with which to initialize this controller. */\n  state?: Partial<RampsControllerState>;\n  /** Time to live for cached requests in milliseconds. Defaults to 15 minutes. */\n  requestCacheTTL?: number;\n  /** Maximum number of entries in the request cache. Defaults to 250. */\n  requestCacheMaxSize?: number;\n};\n\n// === HELPER FUNCTIONS ===\n\n/**\n * Finds a country and state from a region code string.\n *\n * @param regionCode - The region code (e.g., \"us-ca\" or \"fr\").\n * @param countries - Array of countries to search.\n * @returns UserRegion object with country and state, or null if not found.\n */\nfunction findRegionFromCode(\n  regionCode: string,\n  countries: Country[],\n): UserRegion | null {\n  const normalizedCode = regionCode.toLowerCase().trim();\n  const parts = normalizedCode.split('-');\n  const countryCode = parts[0];\n  const stateCode = parts[1];\n\n  const country = countries.find((c) => {\n    if (c.isoCode?.toLowerCase() === countryCode) {\n      return true;\n    }\n    if (c.id) {\n      const id = c.id.toLowerCase();\n      if (id.startsWith('/regions/')) {\n        const extractedCode = id.replace('/regions/', '').split('/')[0];\n        return extractedCode === countryCode;\n      }\n      return id === countryCode || id.endsWith(`/${countryCode}`);\n    }\n    return false;\n  });\n\n  if (!country) {\n    return null;\n  }\n\n  let state: State | null = null;\n  if (stateCode && country.states) {\n    state =\n      country.states.find((s) => {\n        if (s.stateId?.toLowerCase() === stateCode) {\n          return true;\n        }\n        if (s.id) {\n          const stateId = s.id.toLowerCase();\n          if (\n            stateId.includes(`-${stateCode}`) ||\n            stateId.endsWith(`/${stateCode}`)\n          ) {\n            return true;\n          }\n        }\n        return false;\n      }) || null;\n  }\n\n  return {\n    country,\n    state,\n    regionCode: normalizedCode,\n  };\n}\n\n// === CONTROLLER DEFINITION ===\n\n/**\n * Manages cryptocurrency on/off ramps functionality.\n */\nexport class RampsController extends BaseController<\n  typeof controllerName,\n  RampsControllerState,\n  RampsControllerMessenger\n> {\n  /**\n   * Default TTL for cached requests.\n   */\n  readonly #requestCacheTTL: number;\n\n  /**\n   * Maximum number of entries in the request cache.\n   */\n  readonly #requestCacheMaxSize: number;\n\n  /**\n   * Map of pending requests for deduplication.\n   * Key is the cache key, value is the pending request with abort controller.\n   */\n  readonly #pendingRequests: Map<string, PendingRequest> = new Map();\n\n  /**\n   * Constructs a new {@link RampsController}.\n   *\n   * @param args - The constructor arguments.\n   * @param args.messenger - The messenger suited for this controller.\n   * @param args.state - The desired state with which to initialize this\n   * controller. Missing properties will be filled in with defaults.\n   * @param args.requestCacheTTL - Time to live for cached requests in milliseconds.\n   * @param args.requestCacheMaxSize - Maximum number of entries in the request cache.\n   */\n  constructor({\n    messenger,\n    state = {},\n    requestCacheTTL = DEFAULT_REQUEST_CACHE_TTL,\n    requestCacheMaxSize = DEFAULT_REQUEST_CACHE_MAX_SIZE,\n  }: RampsControllerOptions) {\n    super({\n      messenger,\n      metadata: rampsControllerMetadata,\n      name: controllerName,\n      state: {\n        ...getDefaultRampsControllerState(),\n        ...state,\n        // Always reset requests cache on initialization (non-persisted)\n        requests: {},\n      },\n    });\n\n    this.#requestCacheTTL = requestCacheTTL;\n    this.#requestCacheMaxSize = requestCacheMaxSize;\n  }\n\n  /**\n   * Executes a request with caching and deduplication.\n   *\n   * If a request with the same cache key is already in flight, returns the\n   * existing promise. If valid cached data exists, returns it without making\n   * a new request.\n   *\n   * @param cacheKey - Unique identifier for this request.\n   * @param fetcher - Function that performs the actual fetch. Receives an AbortSignal.\n   * @param options - Options for cache behavior.\n   * @returns The result of the request.\n   */\n  async executeRequest<TResult>(\n    cacheKey: string,\n    fetcher: (signal: AbortSignal) => Promise<TResult>,\n    options?: ExecuteRequestOptions,\n  ): Promise<TResult> {\n    const ttl = options?.ttl ?? this.#requestCacheTTL;\n\n    // Check for existing pending request - join it instead of making a duplicate\n    const pending = this.#pendingRequests.get(cacheKey);\n    if (pending) {\n      return pending.promise as Promise<TResult>;\n    }\n\n    // Check cache validity (unless force refresh)\n    if (!options?.forceRefresh) {\n      const cached = this.state.requests[cacheKey];\n      if (cached && !isCacheExpired(cached, ttl)) {\n        return cached.data as TResult;\n      }\n    }\n\n    // Create abort controller for this request\n    const abortController = new AbortController();\n    const lastFetchedAt = Date.now();\n\n    // Update state to loading\n    this.#updateRequestState(cacheKey, createLoadingState());\n\n    // Create the fetch promise\n    const promise = (async (): Promise<TResult> => {\n      try {\n        const data = await fetcher(abortController.signal);\n\n        // Don't update state if aborted\n        if (abortController.signal.aborted) {\n          throw new Error('Request was aborted');\n        }\n\n        this.#updateRequestState(\n          cacheKey,\n          createSuccessState(data as Json, lastFetchedAt),\n        );\n        return data;\n      } catch (error) {\n        // Don't update state if aborted\n        if (abortController.signal.aborted) {\n          throw error;\n        }\n\n        const errorMessage = (error as Error)?.message;\n\n        this.#updateRequestState(\n          cacheKey,\n          createErrorState(errorMessage ?? 'Unknown error', lastFetchedAt),\n        );\n        throw error;\n      } finally {\n        // Only delete if this is still our entry (not replaced by a new request)\n        const currentPending = this.#pendingRequests.get(cacheKey);\n        if (currentPending?.abortController === abortController) {\n          this.#pendingRequests.delete(cacheKey);\n        }\n      }\n    })();\n\n    // Store pending request for deduplication\n    this.#pendingRequests.set(cacheKey, { promise, abortController });\n\n    return promise;\n  }\n\n  /**\n   * Aborts a pending request if one exists.\n   *\n   * @param cacheKey - The cache key of the request to abort.\n   * @returns True if a request was aborted.\n   */\n  abortRequest(cacheKey: string): boolean {\n    const pending = this.#pendingRequests.get(cacheKey);\n    if (pending) {\n      pending.abortController.abort();\n      this.#pendingRequests.delete(cacheKey);\n      this.#removeRequestState(cacheKey);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Removes a request state from the cache.\n   *\n   * @param cacheKey - The cache key to remove.\n   */\n  #removeRequestState(cacheKey: string): void {\n    this.update((state) => {\n      const requests = state.requests as unknown as Record<\n        string,\n        RequestState | undefined\n      >;\n      delete requests[cacheKey];\n    });\n  }\n\n  /**\n   * Gets the state of a specific cached request.\n   *\n   * @param cacheKey - The cache key to look up.\n   * @returns The request state, or undefined if not cached.\n   */\n  getRequestState(cacheKey: string): RequestState | undefined {\n    return this.state.requests[cacheKey];\n  }\n\n  /**\n   * Updates the state for a specific request.\n   *\n   * @param cacheKey - The cache key.\n   * @param requestState - The new state for the request.\n   */\n  #updateRequestState(cacheKey: string, requestState: RequestState): void {\n    const maxSize = this.#requestCacheMaxSize;\n\n    this.update((state) => {\n      const requests = state.requests as unknown as Record<\n        string,\n        RequestState | undefined\n      >;\n      requests[cacheKey] = requestState;\n\n      // Evict oldest entries if cache exceeds max size\n      const keys = Object.keys(requests);\n\n      if (keys.length > maxSize) {\n        // Sort by timestamp (oldest first)\n        const sortedKeys = keys.sort((a, b) => {\n          const aTime = requests[a]?.timestamp ?? 0;\n          const bTime = requests[b]?.timestamp ?? 0;\n          return aTime - bTime;\n        });\n\n        // Remove oldest entries until we're under the limit\n        const entriesToRemove = keys.length - maxSize;\n        for (let i = 0; i < entriesToRemove; i++) {\n          const keyToRemove = sortedKeys[i];\n          if (keyToRemove) {\n            delete requests[keyToRemove];\n          }\n        }\n      }\n    });\n  }\n\n  /**\n   * Gets countries data from cache or fetches it if not available.\n   *\n   * @param action - The ramp action type ('buy' or 'sell').\n   * @param options - Options for cache behavior.\n   * @returns Array of countries.\n   */\n  async #getCountriesData(\n    action: 'buy' | 'sell' = 'buy',\n    options?: ExecuteRequestOptions,\n  ): Promise<Country[]> {\n    return this.getCountries(action, options);\n  }\n\n  /**\n   * Updates the user's region by fetching geolocation and eligibility.\n   * This method calls the RampsService to get the geolocation,\n   * then automatically fetches eligibility for that region.\n   *\n   * @param options - Options for cache behavior.\n   * @returns The user region object.\n   */\n  async updateUserRegion(\n    options?: ExecuteRequestOptions,\n  ): Promise<UserRegion | null> {\n    const cacheKey = createCacheKey('updateUserRegion', []);\n\n    const regionCode = await this.executeRequest(\n      cacheKey,\n      async () => {\n        const result = await this.messenger.call('RampsService:getGeolocation');\n        return result;\n      },\n      options,\n    );\n\n    if (!regionCode) {\n      this.update((state) => {\n        state.userRegion = null;\n        state.tokens = null;\n      });\n      return null;\n    }\n\n    const normalizedRegion = regionCode.toLowerCase().trim();\n\n    try {\n      const countries = await this.#getCountriesData('buy', options);\n      const userRegion = findRegionFromCode(normalizedRegion, countries);\n\n      if (userRegion) {\n        this.update((state) => {\n          state.userRegion = userRegion;\n          state.tokens = null;\n        });\n\n        try {\n          await this.updateEligibility(userRegion.regionCode, options);\n        } catch {\n          this.update((state) => {\n            if (state.userRegion?.regionCode === userRegion.regionCode) {\n              state.eligibility = null;\n              state.tokens = null;\n            }\n          });\n        }\n\n        return userRegion;\n      }\n    } catch {\n      // If countries fetch fails, fall back to storing just the region code\n      // This maintains backward compatibility\n    }\n\n    // Fallback: store as region code only if countries not available\n    // This shouldn't happen in normal flow, but handles edge cases\n    const fallbackRegion: UserRegion = {\n      country: {\n        isoCode: normalizedRegion.split('-')[0].toUpperCase(),\n        flag: 'ðŸ³ï¸',\n        name: normalizedRegion,\n        phone: { prefix: '', placeholder: '', template: '' },\n        currency: '',\n        supported: false,\n      },\n      state: null,\n      regionCode: normalizedRegion,\n    };\n\n    this.update((state) => {\n      state.userRegion = fallbackRegion;\n      state.tokens = null;\n    });\n\n    try {\n      await this.updateEligibility(normalizedRegion, options);\n    } catch {\n      this.update((state) => {\n        if (state.userRegion?.regionCode === normalizedRegion) {\n          state.eligibility = null;\n          state.tokens = null;\n        }\n      });\n    }\n\n    return fallbackRegion;\n  }\n\n  /**\n   * Sets the user's region manually (without fetching geolocation).\n   * This allows users to override the detected region.\n   *\n   * @param region - The region code to set (e.g., \"US-CA\").\n   * @param options - Options for cache behavior when fetching eligibility.\n   * @returns The eligibility information for the region.\n   */\n  async setUserRegion(\n    region: string,\n    options?: ExecuteRequestOptions,\n  ): Promise<Eligibility> {\n    const normalizedRegion = region.toLowerCase().trim();\n\n    try {\n      const countries = await this.#getCountriesData('buy', options);\n      const userRegion = findRegionFromCode(normalizedRegion, countries);\n\n      if (userRegion) {\n        this.update((state) => {\n          state.userRegion = userRegion;\n          state.tokens = null;\n        });\n\n        try {\n          return await this.updateEligibility(userRegion.regionCode, options);\n        } catch (error) {\n          this.update((state) => {\n            if (state.userRegion?.regionCode === userRegion.regionCode) {\n              state.eligibility = null;\n              state.tokens = null;\n            }\n          });\n          throw error;\n        }\n      }\n    } catch {\n      // If countries fetch fails, fall back to storing just the region code\n    }\n\n    // Fallback: store as region code only if countries not available\n    const fallbackRegion: UserRegion = {\n      country: {\n        isoCode: normalizedRegion.split('-')[0].toUpperCase(),\n        flag: 'ðŸ³ï¸',\n        name: normalizedRegion,\n        phone: { prefix: '', placeholder: '', template: '' },\n        currency: '',\n        supported: false,\n      },\n      state: null,\n      regionCode: normalizedRegion,\n    };\n\n    this.update((state) => {\n      state.userRegion = fallbackRegion;\n      state.tokens = null;\n    });\n\n    try {\n      return await this.updateEligibility(normalizedRegion, options);\n    } catch (error) {\n      this.update((state) => {\n        if (state.userRegion?.regionCode === normalizedRegion) {\n          state.eligibility = null;\n          state.tokens = null;\n        }\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Sets the user's preferred provider.\n   * This allows users to set their preferred ramp provider.\n   *\n   * @param provider - The provider object to set.\n   */\n  setPreferredProvider(provider: Provider | null): void {\n    this.update((state) => {\n      state.preferredProvider = provider;\n    });\n  }\n\n  /**\n   * Initializes the controller by fetching the user's region from geolocation.\n   * This should be called once at app startup to set up the initial region.\n   * After the region is set and eligibility is determined, tokens are fetched\n   * and saved to state.\n   *\n   * @param options - Options for cache behavior.\n   * @returns Promise that resolves when initialization is complete.\n   */\n  async init(options?: ExecuteRequestOptions): Promise<void> {\n    const userRegion = await this.updateUserRegion(options).catch(() => {\n      // User region fetch failed - error state will be available via selectors\n      return null;\n    });\n\n    if (userRegion) {\n      try {\n        await this.getTokens(userRegion.regionCode, 'buy', options);\n      } catch {\n        // Token fetch failed - error state will be available via selectors\n      }\n    }\n  }\n\n  /**\n   * Updates the eligibility information for a given region.\n   *\n   * @param isoCode - The ISO code for the region (e.g., \"us\", \"fr\", \"us-ny\").\n   * @param options - Options for cache behavior.\n   * @returns The eligibility information.\n   */\n  async updateEligibility(\n    isoCode: string,\n    options?: ExecuteRequestOptions,\n  ): Promise<Eligibility> {\n    const normalizedIsoCode = isoCode.toLowerCase().trim();\n    const cacheKey = createCacheKey('updateEligibility', [normalizedIsoCode]);\n\n    const eligibility = await this.executeRequest(\n      cacheKey,\n      async () => {\n        return this.messenger.call(\n          'RampsService:getEligibility',\n          normalizedIsoCode,\n        );\n      },\n      options,\n    );\n\n    this.update((state) => {\n      const userRegionCode = state.userRegion?.regionCode;\n\n      if (userRegionCode === undefined || userRegionCode === normalizedIsoCode) {\n        state.eligibility = eligibility;\n      }\n    });\n\n    return eligibility;\n  }\n\n  /**\n   * Fetches the list of supported countries for a given ramp action.\n   *\n   * @param action - The ramp action type ('buy' or 'sell').\n   * @param options - Options for cache behavior.\n   * @returns An array of countries with their eligibility information.\n   */\n  async getCountries(\n    action: 'buy' | 'sell' = 'buy',\n    options?: ExecuteRequestOptions,\n  ): Promise<Country[]> {\n    const cacheKey = createCacheKey('getCountries', [action]);\n\n    return this.executeRequest(\n      cacheKey,\n      async () => {\n        return this.messenger.call('RampsService:getCountries', action);\n      },\n      options,\n    );\n  }\n\n  /**\n   * Fetches the list of available tokens for a given region and action.\n   * The tokens are saved in the controller state once fetched.\n   *\n   * @param region - The region code (e.g., \"us\", \"fr\", \"us-ny\"). If not provided, uses the user's region from controller state.\n   * @param action - The ramp action type ('buy' or 'sell').\n   * @param options - Options for cache behavior.\n   * @returns The tokens response containing topTokens and allTokens.\n   */\n  async getTokens(\n    region?: string,\n    action: 'buy' | 'sell' = 'buy',\n    options?: ExecuteRequestOptions,\n  ): Promise<TokensResponse> {\n    const regionToUse = region ?? this.state.userRegion?.regionCode;\n\n    if (!regionToUse) {\n      throw new Error(\n        'Region is required. Either provide a region parameter or ensure userRegion is set in controller state.',\n      );\n    }\n\n    const normalizedRegion = regionToUse.toLowerCase().trim();\n    const cacheKey = createCacheKey('getTokens', [normalizedRegion, action]);\n\n    const tokens = await this.executeRequest(\n      cacheKey,\n      async () => {\n        return this.messenger.call(\n          'RampsService:getTokens',\n          normalizedRegion,\n          action,\n        );\n      },\n      options,\n    );\n\n    this.update((state) => {\n      const userRegionCode = state.userRegion?.regionCode;\n\n      if (userRegionCode === undefined || userRegionCode === normalizedRegion) {\n        state.tokens = tokens;\n      }\n    });\n\n    return tokens;\n  }\n}\n"]}
\ No newline at end of file
diff --git a/dist/RampsController.d.cts b/dist/RampsController.d.cts
index 9a916cc66838fa4c93fa01ed53a862063fceda5d..8bb11285a987cc1a3f11cd96b644de54aac63bb6 100644
--- a/dist/RampsController.d.cts
+++ b/dist/RampsController.d.cts
@@ -1,7 +1,7 @@
 import type { ControllerGetStateAction, ControllerStateChangeEvent } from "@metamask/base-controller";
 import { BaseController } from "@metamask/base-controller";
 import type { Messenger } from "@metamask/messenger";
-import type { Country, Eligibility, TokensResponse } from "./RampsService.cjs";
+import type { Country, Eligibility, TokensResponse, Provider, State } from "./RampsService.cjs";
 import type { RampsServiceGetGeolocationAction, RampsServiceGetCountriesAction, RampsServiceGetEligibilityAction, RampsServiceGetTokensAction } from "./RampsService-method-action-types.cjs";
 import type { RequestCache as RequestCacheType, RequestState, ExecuteRequestOptions } from "./RequestCache.cjs";
 /**
@@ -10,15 +10,37 @@ import type { RequestCache as RequestCacheType, RequestState, ExecuteRequestOpti
  * when composed with other controllers.
  */
 export declare const controllerName = "RampsController";
+/**
+ * Represents the user's selected region with full country and state objects.
+ */
+export type UserRegion = {
+    /**
+     * The country object for the selected region.
+     */
+    country: Country;
+    /**
+     * The state object if a state was selected, null if only country was selected.
+     */
+    state: State | null;
+    /**
+     * The region code string (e.g., "us-ut" or "fr") used for API calls.
+     */
+    regionCode: string;
+};
 /**
  * Describes the shape of the state object for {@link RampsController}.
  */
 export type RampsControllerState = {
     /**
-     * The user's selected region code (e.g., "US-CA").
+     * The user's selected region with full country and state objects.
      * Initially set via geolocation fetch, but can be manually changed by the user.
      */
-    userRegion: string | null;
+    userRegion: UserRegion | null;
+    /**
+     * The user's preferred provider.
+     * Can be manually set by the user.
+     */
+    preferredProvider: Provider | null;
     /**
      * Eligibility information for the user's current region.
      */
@@ -134,9 +156,9 @@ export declare class RampsController extends BaseController<typeof controllerNam
      * then automatically fetches eligibility for that region.
      *
      * @param options - Options for cache behavior.
-     * @returns The user region string.
+     * @returns The user region object.
      */
-    updateUserRegion(options?: ExecuteRequestOptions): Promise<string>;
+    updateUserRegion(options?: ExecuteRequestOptions): Promise<UserRegion | null>;
     /**
      * Sets the user's region manually (without fetching geolocation).
      * This allows users to override the detected region.
@@ -146,6 +168,13 @@ export declare class RampsController extends BaseController<typeof controllerNam
      * @returns The eligibility information for the region.
      */
     setUserRegion(region: string, options?: ExecuteRequestOptions): Promise<Eligibility>;
+    /**
+     * Sets the user's preferred provider.
+     * This allows users to set their preferred ramp provider.
+     *
+     * @param provider - The provider object to set.
+     */
+    setPreferredProvider(provider: Provider | null): void;
     /**
      * Initializes the controller by fetching the user's region from geolocation.
      * This should be called once at app startup to set up the initial region.
diff --git a/dist/RampsController.d.cts.map b/dist/RampsController.d.cts.map
index 29dd2bee19770a82f4c13c515e40f315fa160478..c1c7f8c1024eda360b0004e7f491d67284d55f3b 100644
--- a/dist/RampsController.d.cts.map
+++ b/dist/RampsController.d.cts.map
@@ -1 +1 @@
-{"version":3,"file":"RampsController.d.cts","sourceRoot":"","sources":["../src/RampsController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"RampsController.d.cts","sourceRoot":"","sources":["../src/RampsController.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EACV,wBAAwB,EACxB,0BAA0B,EAE3B,kCAAkC;AACnC,OAAO,EAAE,cAAc,EAAE,kCAAkC;AAC3D,OAAO,KAAK,EAAE,SAAS,EAAE,4BAA4B;AAGrD,OAAO,KAAK,EACV,OAAO,EACP,WAAW,EACX,cAAc,EACd,QAAQ,EACR,KAAK,EACN,2BAAuB;AACxB,OAAO,KAAK,EACV,gCAAgC,EAChC,8BAA8B,EAC9B,gCAAgC,EAChC,2BAA2B,EAC5B,+CAA2C;AAC5C,OAAO,KAAK,EACV,YAAY,IAAI,gBAAgB,EAChC,YAAY,EACZ,qBAAqB,EAEtB,2BAAuB;AAaxB;;;;GAIG;AACH,eAAO,MAAM,cAAc,oBAAoB,CAAC;AAIhD;;GAEG;AACH,MAAM,MAAM,UAAU,GAAG;IACvB;;OAEG;IACH,OAAO,EAAE,OAAO,CAAC;IACjB;;OAEG;IACH,KAAK,EAAE,KAAK,GAAG,IAAI,CAAC;IACpB;;OAEG;IACH,UAAU,EAAE,MAAM,CAAC;CACpB,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,oBAAoB,GAAG;IACjC;;;OAGG;IACH,UAAU,EAAE,UAAU,GAAG,IAAI,CAAC;IAC9B;;;OAGG;IACH,iBAAiB,EAAE,QAAQ,GAAG,IAAI,CAAC;IACnC;;OAEG;IACH,WAAW,EAAE,WAAW,GAAG,IAAI,CAAC;IAChC;;;OAGG;IACH,MAAM,EAAE,cAAc,GAAG,IAAI,CAAC;IAC9B;;;OAGG;IACH,QAAQ,EAAE,gBAAgB,CAAC;CAC5B,CAAC;AAsCF;;;;;;;GAOG;AACH,wBAAgB,8BAA8B,IAAI,oBAAoB,CAQrE;AAID;;GAEG;AACH,MAAM,MAAM,6BAA6B,GAAG,wBAAwB,CAClE,OAAO,cAAc,EACrB,oBAAoB,CACrB,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,sBAAsB,GAAG,6BAA6B,CAAC;AAEnE;;GAEG;AACH,KAAK,cAAc,GACf,gCAAgC,GAChC,8BAA8B,GAC9B,gCAAgC,GAChC,2BAA2B,CAAC;AAEhC;;GAEG;AACH,MAAM,MAAM,+BAA+B,GAAG,0BAA0B,CACtE,OAAO,cAAc,EACrB,oBAAoB,CACrB,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,qBAAqB,GAAG,+BAA+B,CAAC;AAEpE;;GAEG;AACH,KAAK,aAAa,GAAG,KAAK,CAAC;AAE3B;;;GAGG;AACH,MAAM,MAAM,wBAAwB,GAAG,SAAS,CAC9C,OAAO,cAAc,EACrB,sBAAsB,GAAG,cAAc,EACvC,qBAAqB,GAAG,aAAa,CACtC,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,sBAAsB,GAAG;IACnC,gDAAgD;IAChD,SAAS,EAAE,wBAAwB,CAAC;IACpC,kEAAkE;IAClE,KAAK,CAAC,EAAE,OAAO,CAAC,oBAAoB,CAAC,CAAC;IACtC,gFAAgF;IAChF,eAAe,CAAC,EAAE,MAAM,CAAC;IACzB,uEAAuE;IACvE,mBAAmB,CAAC,EAAE,MAAM,CAAC;CAC9B,CAAC;AAoEF;;GAEG;AACH,qBAAa,eAAgB,SAAQ,cAAc,CACjD,OAAO,cAAc,EACrB,oBAAoB,EACpB,wBAAwB,CACzB;;IAiBC;;;;;;;;;OASG;gBACS,EACV,SAAS,EACT,KAAU,EACV,eAA2C,EAC3C,mBAAoD,GACrD,EAAE,sBAAsB;IAiBzB;;;;;;;;;;;OAWG;IACG,cAAc,CAAC,OAAO,EAC1B,QAAQ,EAAE,MAAM,EAChB,OAAO,EAAE,CAAC,MAAM,EAAE,WAAW,KAAK,OAAO,CAAC,OAAO,CAAC,EAClD,OAAO,CAAC,EAAE,qBAAqB,GAC9B,OAAO,CAAC,OAAO,CAAC;IAmEnB;;;;;OAKG;IACH,YAAY,CAAC,QAAQ,EAAE,MAAM,GAAG,OAAO;IA0BvC;;;;;OAKG;IACH,eAAe,CAAC,QAAQ,EAAE,MAAM,GAAG,YAAY,GAAG,SAAS;IAyD3D;;;;;;;OAOG;IACG,gBAAgB,CACpB,OAAO,CAAC,EAAE,qBAAqB,GAC9B,OAAO,CAAC,UAAU,GAAG,IAAI,CAAC;IAoF7B;;;;;;;OAOG;IACG,aAAa,CACjB,MAAM,EAAE,MAAM,EACd,OAAO,CAAC,EAAE,qBAAqB,GAC9B,OAAO,CAAC,WAAW,CAAC;IA6DvB;;;;;OAKG;IACH,oBAAoB,CAAC,QAAQ,EAAE,QAAQ,GAAG,IAAI,GAAG,IAAI;IAMrD;;;;;;;;OAQG;IACG,IAAI,CAAC,OAAO,CAAC,EAAE,qBAAqB,GAAG,OAAO,CAAC,IAAI,CAAC;IAe1D;;;;;;OAMG;IACG,iBAAiB,CACrB,OAAO,EAAE,MAAM,EACf,OAAO,CAAC,EAAE,qBAAqB,GAC9B,OAAO,CAAC,WAAW,CAAC;IA0BvB;;;;;;OAMG;IACG,YAAY,CAChB,MAAM,GAAE,KAAK,GAAG,MAAc,EAC9B,OAAO,CAAC,EAAE,qBAAqB,GAC9B,OAAO,CAAC,OAAO,EAAE,CAAC;IAYrB;;;;;;;;OAQG;IACG,SAAS,CACb,MAAM,CAAC,EAAE,MAAM,EACf,MAAM,GAAE,KAAK,GAAG,MAAc,EAC9B,OAAO,CAAC,EAAE,qBAAqB,GAC9B,OAAO,CAAC,cAAc,CAAC;CAkC3B"}
\ No newline at end of file
diff --git a/dist/RampsController.d.mts b/dist/RampsController.d.mts
index af2f357018d4b9a71701af65da4b7ee9f96a5f11..57701d1f4cefd45feb3a3da6359c72d68a83757c 100644
--- a/dist/RampsController.d.mts
+++ b/dist/RampsController.d.mts
@@ -1,7 +1,7 @@
 import type { ControllerGetStateAction, ControllerStateChangeEvent } from "@metamask/base-controller";
 import { BaseController } from "@metamask/base-controller";
 import type { Messenger } from "@metamask/messenger";
-import type { Country, Eligibility, TokensResponse } from "./RampsService.mjs";
+import type { Country, Eligibility, TokensResponse, Provider, State } from "./RampsService.mjs";
 import type { RampsServiceGetGeolocationAction, RampsServiceGetCountriesAction, RampsServiceGetEligibilityAction, RampsServiceGetTokensAction } from "./RampsService-method-action-types.mjs";
 import type { RequestCache as RequestCacheType, RequestState, ExecuteRequestOptions } from "./RequestCache.mjs";
 /**
@@ -10,15 +10,37 @@ import type { RequestCache as RequestCacheType, RequestState, ExecuteRequestOpti
  * when composed with other controllers.
  */
 export declare const controllerName = "RampsController";
+/**
+ * Represents the user's selected region with full country and state objects.
+ */
+export type UserRegion = {
+    /**
+     * The country object for the selected region.
+     */
+    country: Country;
+    /**
+     * The state object if a state was selected, null if only country was selected.
+     */
+    state: State | null;
+    /**
+     * The region code string (e.g., "us-ut" or "fr") used for API calls.
+     */
+    regionCode: string;
+};
 /**
  * Describes the shape of the state object for {@link RampsController}.
  */
 export type RampsControllerState = {
     /**
-     * The user's selected region code (e.g., "US-CA").
+     * The user's selected region with full country and state objects.
      * Initially set via geolocation fetch, but can be manually changed by the user.
      */
-    userRegion: string | null;
+    userRegion: UserRegion | null;
+    /**
+     * The user's preferred provider.
+     * Can be manually set by the user.
+     */
+    preferredProvider: Provider | null;
     /**
      * Eligibility information for the user's current region.
      */
@@ -134,9 +156,9 @@ export declare class RampsController extends BaseController<typeof controllerNam
      * then automatically fetches eligibility for that region.
      *
      * @param options - Options for cache behavior.
-     * @returns The user region string.
+     * @returns The user region object.
      */
-    updateUserRegion(options?: ExecuteRequestOptions): Promise<string>;
+    updateUserRegion(options?: ExecuteRequestOptions): Promise<UserRegion | null>;
     /**
      * Sets the user's region manually (without fetching geolocation).
      * This allows users to override the detected region.
@@ -146,6 +168,13 @@ export declare class RampsController extends BaseController<typeof controllerNam
      * @returns The eligibility information for the region.
      */
     setUserRegion(region: string, options?: ExecuteRequestOptions): Promise<Eligibility>;
+    /**
+     * Sets the user's preferred provider.
+     * This allows users to set their preferred ramp provider.
+     *
+     * @param provider - The provider object to set.
+     */
+    setPreferredProvider(provider: Provider | null): void;
     /**
      * Initializes the controller by fetching the user's region from geolocation.
      * This should be called once at app startup to set up the initial region.
diff --git a/dist/RampsController.d.mts.map b/dist/RampsController.d.mts.map
index f2b54ea3fda51fd46ccbe380e1528fc53d4bf24d..c865ae77d9a63a12c0e748c103efa03a1b9c8e2d 100644
--- a/dist/RampsController.d.mts.map
+++ b/dist/RampsController.d.mts.map
@@ -1 +1 @@
-{"version":3,"file":"RampsController.d.mts","sourceRoot":"","sources":["../src/RampsController.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EACV,wBAAwB,EACxB,0BAA0B,EAE3B,kCAAkC;AACnC,OAAO,EAAE,cAAc,EAAE,kCAAkC;AAC3D,OAAO,KAAK,EAAE,SAAS,EAAE,4BAA4B;AAGrD,OAAO,KAAK,EAAE,OAAO,EAAE,WAAW,EAAE,cAAc,EAAE,2BAAuB;AAC3E,OAAO,KAAK,EACV,gCAAgC,EAChC,8BAA8B,EAC9B,gCAAgC,EAChC,2BAA2B,EAC5B,+CAA2C;AAC5C,OAAO,KAAK,EACV,YAAY,IAAI,gBAAgB,EAChC,YAAY,EACZ,qBAAqB,EAEtB,2BAAuB;AAaxB;;;;GAIG;AACH,eAAO,MAAM,cAAc,oBAAoB,CAAC;AAIhD;;GAEG;AACH,MAAM,MAAM,oBAAoB,GAAG;IACjC;;;OAGG;IACH,UAAU,EAAE,MAAM,GAAG,IAAI,CAAC;IAC1B;;OAEG;IACH,WAAW,EAAE,WAAW,GAAG,IAAI,CAAC;IAChC;;;OAGG;IACH,MAAM,EAAE,cAAc,GAAG,IAAI,CAAC;IAC9B;;;OAGG;IACH,QAAQ,EAAE,gBAAgB,CAAC;CAC5B,CAAC;AAgCF;;;;;;;GAOG;AACH,wBAAgB,8BAA8B,IAAI,oBAAoB,CAOrE;AAID;;GAEG;AACH,MAAM,MAAM,6BAA6B,GAAG,wBAAwB,CAClE,OAAO,cAAc,EACrB,oBAAoB,CACrB,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,sBAAsB,GAAG,6BAA6B,CAAC;AAEnE;;GAEG;AACH,KAAK,cAAc,GACf,gCAAgC,GAChC,8BAA8B,GAC9B,gCAAgC,GAChC,2BAA2B,CAAC;AAEhC;;GAEG;AACH,MAAM,MAAM,+BAA+B,GAAG,0BAA0B,CACtE,OAAO,cAAc,EACrB,oBAAoB,CACrB,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,qBAAqB,GAAG,+BAA+B,CAAC;AAEpE;;GAEG;AACH,KAAK,aAAa,GAAG,KAAK,CAAC;AAE3B;;;GAGG;AACH,MAAM,MAAM,wBAAwB,GAAG,SAAS,CAC9C,OAAO,cAAc,EACrB,sBAAsB,GAAG,cAAc,EACvC,qBAAqB,GAAG,aAAa,CACtC,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,sBAAsB,GAAG;IACnC,gDAAgD;IAChD,SAAS,EAAE,wBAAwB,CAAC;IACpC,kEAAkE;IAClE,KAAK,CAAC,EAAE,OAAO,CAAC,oBAAoB,CAAC,CAAC;IACtC,gFAAgF;IAChF,eAAe,CAAC,EAAE,MAAM,CAAC;IACzB,uEAAuE;IACvE,mBAAmB,CAAC,EAAE,MAAM,CAAC;CAC9B,CAAC;AAIF;;GAEG;AACH,qBAAa,eAAgB,SAAQ,cAAc,CACjD,OAAO,cAAc,EACrB,oBAAoB,EACpB,wBAAwB,CACzB;;IAiBC;;;;;;;;;OASG;gBACS,EACV,SAAS,EACT,KAAU,EACV,eAA2C,EAC3C,mBAAoD,GACrD,EAAE,sBAAsB;IAiBzB;;;;;;;;;;;OAWG;IACG,cAAc,CAAC,OAAO,EAC1B,QAAQ,EAAE,MAAM,EAChB,OAAO,EAAE,CAAC,MAAM,EAAE,WAAW,KAAK,OAAO,CAAC,OAAO,CAAC,EAClD,OAAO,CAAC,EAAE,qBAAqB,GAC9B,OAAO,CAAC,OAAO,CAAC;IAmEnB;;;;;OAKG;IACH,YAAY,CAAC,QAAQ,EAAE,MAAM,GAAG,OAAO;IA0BvC;;;;;OAKG;IACH,eAAe,CAAC,QAAQ,EAAE,MAAM,GAAG,YAAY,GAAG,SAAS;IA2C3D;;;;;;;OAOG;IACG,gBAAgB,CAAC,OAAO,CAAC,EAAE,qBAAqB,GAAG,OAAO,CAAC,MAAM,CAAC;IAsCxE;;;;;;;OAOG;IACG,aAAa,CACjB,MAAM,EAAE,MAAM,EACd,OAAO,CAAC,EAAE,qBAAqB,GAC9B,OAAO,CAAC,WAAW,CAAC;IA2BvB;;;;;;;;OAQG;IACG,IAAI,CAAC,OAAO,CAAC,EAAE,qBAAqB,GAAG,OAAO,CAAC,IAAI,CAAC;IAe1D;;;;;;OAMG;IACG,iBAAiB,CACrB,OAAO,EAAE,MAAM,EACf,OAAO,CAAC,EAAE,qBAAqB,GAC9B,OAAO,CAAC,WAAW,CAAC;IA0BvB;;;;;;OAMG;IACG,YAAY,CAChB,MAAM,GAAE,KAAK,GAAG,MAAc,EAC9B,OAAO,CAAC,EAAE,qBAAqB,GAC9B,OAAO,CAAC,OAAO,EAAE,CAAC;IAYrB;;;;;;;;OAQG;IACG,SAAS,CACb,MAAM,CAAC,EAAE,MAAM,EACf,MAAM,GAAE,KAAK,GAAG,MAAc,EAC9B,OAAO,CAAC,EAAE,qBAAqB,GAC9B,OAAO,CAAC,cAAc,CAAC;CAkC3B"}
\ No newline at end of file
+{"version":3,"file":"RampsController.d.mts","sourceRoot":"","sources":["../src/RampsController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/RampsController.mjs b/dist/RampsController.mjs
index 7efddf7a9cc73bab38dda4d742a7b6b4875da58f..3f4d5fc0379edb8a42fcbddd48a5336453832d19 100644
--- a/dist/RampsController.mjs
+++ b/dist/RampsController.mjs
@@ -9,7 +9,7 @@ var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (
     if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
     return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
 };
-var _RampsController_instances, _RampsController_requestCacheTTL, _RampsController_requestCacheMaxSize, _RampsController_pendingRequests, _RampsController_removeRequestState, _RampsController_updateRequestState;
+var _RampsController_instances, _RampsController_requestCacheTTL, _RampsController_requestCacheMaxSize, _RampsController_pendingRequests, _RampsController_removeRequestState, _RampsController_updateRequestState, _RampsController_getCountriesData;
 import { BaseController } from "@metamask/base-controller";
 import { DEFAULT_REQUEST_CACHE_TTL, DEFAULT_REQUEST_CACHE_MAX_SIZE, createCacheKey, isCacheExpired, createLoadingState, createSuccessState, createErrorState } from "./RequestCache.mjs";
 // === GENERAL ===
@@ -29,6 +29,12 @@ const rampsControllerMetadata = {
         includeInStateLogs: true,
         usedInUi: true,
     },
+    preferredProvider: {
+        persist: true,
+        includeInDebugSnapshot: true,
+        includeInStateLogs: true,
+        usedInUi: true,
+    },
     eligibility: {
         persist: true,
         includeInDebugSnapshot: true,
@@ -59,11 +65,65 @@ const rampsControllerMetadata = {
 export function getDefaultRampsControllerState() {
     return {
         userRegion: null,
+        preferredProvider: null,
         eligibility: null,
         tokens: null,
         requests: {},
     };
 }
+// === HELPER FUNCTIONS ===
+/**
+ * Finds a country and state from a region code string.
+ *
+ * @param regionCode - The region code (e.g., "us-ca" or "fr").
+ * @param countries - Array of countries to search.
+ * @returns UserRegion object with country and state, or null if not found.
+ */
+function findRegionFromCode(regionCode, countries) {
+    const normalizedCode = regionCode.toLowerCase().trim();
+    const parts = normalizedCode.split('-');
+    const countryCode = parts[0];
+    const stateCode = parts[1];
+    const country = countries.find((c) => {
+        if (c.isoCode?.toLowerCase() === countryCode) {
+            return true;
+        }
+        if (c.id) {
+            const id = c.id.toLowerCase();
+            if (id.startsWith('/regions/')) {
+                const extractedCode = id.replace('/regions/', '').split('/')[0];
+                return extractedCode === countryCode;
+            }
+            return id === countryCode || id.endsWith(`/${countryCode}`);
+        }
+        return false;
+    });
+    if (!country) {
+        return null;
+    }
+    let state = null;
+    if (stateCode && country.states) {
+        state =
+            country.states.find((s) => {
+                if (s.stateId?.toLowerCase() === stateCode) {
+                    return true;
+                }
+                if (s.id) {
+                    const stateId = s.id.toLowerCase();
+                    if (stateId.includes(`-${stateCode}`) ||
+                        stateId.endsWith(`/${stateCode}`)) {
+                        return true;
+                    }
+                }
+                return false;
+            }) || null;
+    }
+    return {
+        country,
+        state,
+        regionCode: normalizedCode,
+    };
+}
 // === CONTROLLER DEFINITION ===
 /**
  * Manages cryptocurrency on/off ramps functionality.
@@ -202,36 +262,78 @@ export class RampsController extends BaseController {
      * then automatically fetches eligibility for that region.
      *
      * @param options - Options for cache behavior.
-     * @returns The user region string.
+     * @returns The user region object.
      */
     async updateUserRegion(options) {
         const cacheKey = createCacheKey('updateUserRegion', []);
-        const userRegion = await this.executeRequest(cacheKey, async () => {
+        const regionCode = await this.executeRequest(cacheKey, async () => {
             const result = await this.messenger.call('RampsService:getGeolocation');
             return result;
         }, options);
-        const normalizedRegion = userRegion
-            ? userRegion.toLowerCase().trim()
-            : userRegion;
-        this.update((state) => {
-            state.userRegion = normalizedRegion;
-            state.tokens = null;
-        });
-        if (normalizedRegion) {
-            try {
-                await this.updateEligibility(normalizedRegion, options);
-            }
-            catch {
+        if (!regionCode) {
+            this.update((state) => {
+                state.userRegion = null;
+                state.tokens = null;
+            });
+            return null;
+        }
+        const normalizedRegion = regionCode.toLowerCase().trim();
+        try {
+            const countries = await __classPrivateFieldGet(this, _RampsController_instances, "m", _RampsController_getCountriesData).call(this, 'buy', options);
+            const userRegion = findRegionFromCode(normalizedRegion, countries);
+            if (userRegion) {
                 this.update((state) => {
-                    const currentUserRegion = state.userRegion?.toLowerCase().trim();
-                    if (currentUserRegion === normalizedRegion) {
-                        state.eligibility = null;
-                        state.tokens = null;
-                    }
+                    state.userRegion = userRegion;
+                    state.tokens = null;
                 });
+                try {
+                    await this.updateEligibility(userRegion.regionCode, options);
+                }
+                catch {
+                    this.update((state) => {
+                        if (state.userRegion?.regionCode === userRegion.regionCode) {
+                            state.eligibility = null;
+                            state.tokens = null;
+                        }
+                    });
+                }
+                return userRegion;
             }
         }
-        return normalizedRegion;
+        catch {
+            // If countries fetch fails, fall back to storing just the region code
+            // This maintains backward compatibility
+        }
+        // Fallback: store as region code only if countries not available
+        // This shouldn't happen in normal flow, but handles edge cases
+        const fallbackRegion = {
+            country: {
+                isoCode: normalizedRegion.split('-')[0].toUpperCase(),
+                flag: 'ðŸ³ï¸',
+                name: normalizedRegion,
+                phone: { prefix: '', placeholder: '', template: '' },
+                currency: '',
+                supported: false,
+            },
+            state: null,
+            regionCode: normalizedRegion,
+        };
+        this.update((state) => {
+            state.userRegion = fallbackRegion;
+            state.tokens = null;
+        });
+        try {
+            await this.updateEligibility(normalizedRegion, options);
+        }
+        catch {
+            this.update((state) => {
+                if (state.userRegion?.regionCode === normalizedRegion) {
+                    state.eligibility = null;
+                    state.tokens = null;
+                }
+            });
+        }
+        return fallbackRegion;
     }
     /**
      * Sets the user's region manually (without fetching geolocation).
@@ -243,22 +345,54 @@ export class RampsController extends BaseController {
      */
     async setUserRegion(region, options) {
         const normalizedRegion = region.toLowerCase().trim();
+        try {
+            const countries = await __classPrivateFieldGet(this, _RampsController_instances, "m", _RampsController_getCountriesData).call(this, 'buy', options);
+            const userRegion = findRegionFromCode(normalizedRegion, countries);
+            if (userRegion) {
+                this.update((state) => {
+                    state.userRegion = userRegion;
+                    state.tokens = null;
+                });
+                try {
+                    return await this.updateEligibility(userRegion.regionCode, options);
+                }
+                catch (error) {
+                    this.update((state) => {
+                        if (state.userRegion?.regionCode === userRegion.regionCode) {
+                            state.eligibility = null;
+                            state.tokens = null;
+                        }
+                    });
+                    throw error;
+                }
+            }
+        }
+        catch {
+            // If countries fetch fails, fall back to storing just the region code
+        }
+        // Fallback: store as region code only if countries not available
+        const fallbackRegion = {
+            country: {
+                isoCode: normalizedRegion.split('-')[0].toUpperCase(),
+                flag: 'ðŸ³ï¸',
+                name: normalizedRegion,
+                phone: { prefix: '', placeholder: '', template: '' },
+                currency: '',
+                supported: false,
+            },
+            state: null,
+            regionCode: normalizedRegion,
+        };
         this.update((state) => {
-            state.userRegion = normalizedRegion;
+            state.userRegion = fallbackRegion;
             state.tokens = null;
         });
         try {
             return await this.updateEligibility(normalizedRegion, options);
         }
         catch (error) {
-            // Eligibility fetch failed, but user region was successfully set.
-            // Don't let eligibility errors prevent user region state from being updated.
-            // Clear eligibility state to avoid showing stale data from a previous location.
-            // Only clear if the region still matches to avoid race conditions where a newer
-            // region change has already succeeded.
             this.update((state) => {
-                const currentUserRegion = state.userRegion?.toLowerCase().trim();
-                if (currentUserRegion === normalizedRegion) {
+                if (state.userRegion?.regionCode === normalizedRegion) {
                     state.eligibility = null;
                     state.tokens = null;
                 }
@@ -266,6 +400,17 @@ export class RampsController extends BaseController {
             throw error;
         }
     }
+    /**
+     * Sets the user's preferred provider.
+     * This allows users to set their preferred ramp provider.
+     *
+     * @param provider - The provider object to set.
+     */
+    setPreferredProvider(provider) {
+        this.update((state) => {
+            state.preferredProvider = provider;
+        });
+    }
     /**
      * Initializes the controller by fetching the user's region from geolocation.
      * This should be called once at app startup to set up the initial region.
@@ -282,7 +427,7 @@ export class RampsController extends BaseController {
         });
         if (userRegion) {
             try {
-                await this.getTokens(userRegion, 'buy', options);
+                await this.getTokens(userRegion.regionCode, 'buy', options);
             }
             catch {
                 // Token fetch failed - error state will be available via selectors
@@ -303,8 +448,8 @@ export class RampsController extends BaseController {
             return this.messenger.call('RampsService:getEligibility', normalizedIsoCode);
         }, options);
         this.update((state) => {
-            const userRegion = state.userRegion?.toLowerCase().trim();
-            if (userRegion === undefined || userRegion === normalizedIsoCode) {
+            const userRegionCode = state.userRegion?.regionCode;
+            if (userRegionCode === undefined || userRegionCode === normalizedIsoCode) {
                 state.eligibility = eligibility;
             }
         });
@@ -333,7 +478,7 @@ export class RampsController extends BaseController {
      * @returns The tokens response containing topTokens and allTokens.
      */
     async getTokens(region, action = 'buy', options) {
-        const regionToUse = region ?? this.state.userRegion;
+        const regionToUse = region ?? this.state.userRegion?.regionCode;
         if (!regionToUse) {
             throw new Error('Region is required. Either provide a region parameter or ensure userRegion is set in controller state.');
         }
@@ -343,8 +488,8 @@ export class RampsController extends BaseController {
             return this.messenger.call('RampsService:getTokens', normalizedRegion, action);
         }, options);
         this.update((state) => {
-            const userRegion = state.userRegion?.toLowerCase().trim();
-            if (userRegion === undefined || userRegion === normalizedRegion) {
+            const userRegionCode = state.userRegion?.regionCode;
+            if (userRegionCode === undefined || userRegionCode === normalizedRegion) {
                 state.tokens = tokens;
             }
         });
@@ -380,5 +525,15 @@ _RampsController_requestCacheTTL = new WeakMap(), _RampsController_requestCacheM
             }
         }
     });
+}, _RampsController_getCountriesData = 
+/**
+ * Gets countries data from cache or fetches it if not available.
+ *
+ * @param action - The ramp action type ('buy' or 'sell').
+ * @param options - Options for cache behavior.
+ * @returns Array of countries.
+ */
+async function _RampsController_getCountriesData(action = 'buy', options) {
+    return this.getCountries(action, options);
 };
 //# sourceMappingURL=RampsController.mjs.map
\ No newline at end of file
diff --git a/dist/RampsController.mjs.map b/dist/RampsController.mjs.map
index 0e37da618392a166c5f53a3887714c8a97baf027..d0b6e697853a69c8ae04a0dbf005d1c319c819d6 100644
--- a/dist/RampsController.mjs.map
+++ b/dist/RampsController.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"RampsController.mjs","sourceRoot":"","sources":["../src/RampsController.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n  StateMetadata,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport type { Messenger } from '@metamask/messenger';\nimport type { Json } from '@metamask/utils';\n\nimport type { Country, Eligibility, TokensResponse } from './RampsService';\nimport type {\n  RampsServiceGetGeolocationAction,\n  RampsServiceGetCountriesAction,\n  RampsServiceGetEligibilityAction,\n  RampsServiceGetTokensAction,\n} from './RampsService-method-action-types';\nimport type {\n  RequestCache as RequestCacheType,\n  RequestState,\n  ExecuteRequestOptions,\n  PendingRequest,\n} from './RequestCache';\nimport {\n  DEFAULT_REQUEST_CACHE_TTL,\n  DEFAULT_REQUEST_CACHE_MAX_SIZE,\n  createCacheKey,\n  isCacheExpired,\n  createLoadingState,\n  createSuccessState,\n  createErrorState,\n} from './RequestCache';\n\n// === GENERAL ===\n\n/**\n * The name of the {@link RampsController}, used to namespace the\n * controller's actions and events and to namespace the controller's state data\n * when composed with other controllers.\n */\nexport const controllerName = 'RampsController';\n\n// === STATE ===\n\n/**\n * Describes the shape of the state object for {@link RampsController}.\n */\nexport type RampsControllerState = {\n  /**\n   * The user's selected region code (e.g., \"US-CA\").\n   * Initially set via geolocation fetch, but can be manually changed by the user.\n   */\n  userRegion: string | null;\n  /**\n   * Eligibility information for the user's current region.\n   */\n  eligibility: Eligibility | null;\n  /**\n   * Tokens fetched for the current region and action.\n   * Contains topTokens and allTokens arrays.\n   */\n  tokens: TokensResponse | null;\n  /**\n   * Cache of request states, keyed by cache key.\n   * This stores loading, success, and error states for API requests.\n   */\n  requests: RequestCacheType;\n};\n\n/**\n * The metadata for each property in {@link RampsControllerState}.\n */\nconst rampsControllerMetadata = {\n  userRegion: {\n    persist: true,\n    includeInDebugSnapshot: true,\n    includeInStateLogs: true,\n    usedInUi: true,\n  },\n  eligibility: {\n    persist: true,\n    includeInDebugSnapshot: true,\n    includeInStateLogs: true,\n    usedInUi: true,\n  },\n  tokens: {\n    persist: true,\n    includeInDebugSnapshot: true,\n    includeInStateLogs: true,\n    usedInUi: true,\n  },\n  requests: {\n    persist: false,\n    includeInDebugSnapshot: true,\n    includeInStateLogs: false,\n    usedInUi: true,\n  },\n} satisfies StateMetadata<RampsControllerState>;\n\n/**\n * Constructs the default {@link RampsController} state. This allows\n * consumers to provide a partial state object when initializing the controller\n * and also helps in constructing complete state objects for this controller in\n * tests.\n *\n * @returns The default {@link RampsController} state.\n */\nexport function getDefaultRampsControllerState(): RampsControllerState {\n  return {\n    userRegion: null,\n    eligibility: null,\n    tokens: null,\n    requests: {},\n  };\n}\n\n// === MESSENGER ===\n\n/**\n * Retrieves the state of the {@link RampsController}.\n */\nexport type RampsControllerGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  RampsControllerState\n>;\n\n/**\n * Actions that {@link RampsControllerMessenger} exposes to other consumers.\n */\nexport type RampsControllerActions = RampsControllerGetStateAction;\n\n/**\n * Actions from other messengers that {@link RampsController} calls.\n */\ntype AllowedActions =\n  | RampsServiceGetGeolocationAction\n  | RampsServiceGetCountriesAction\n  | RampsServiceGetEligibilityAction\n  | RampsServiceGetTokensAction;\n\n/**\n * Published when the state of {@link RampsController} changes.\n */\nexport type RampsControllerStateChangeEvent = ControllerStateChangeEvent<\n  typeof controllerName,\n  RampsControllerState\n>;\n\n/**\n * Events that {@link RampsControllerMessenger} exposes to other consumers.\n */\nexport type RampsControllerEvents = RampsControllerStateChangeEvent;\n\n/**\n * Events from other messengers that {@link RampsController} subscribes to.\n */\ntype AllowedEvents = never;\n\n/**\n * The messenger restricted to actions and events accessed by\n * {@link RampsController}.\n */\nexport type RampsControllerMessenger = Messenger<\n  typeof controllerName,\n  RampsControllerActions | AllowedActions,\n  RampsControllerEvents | AllowedEvents\n>;\n\n/**\n * Configuration options for the RampsController.\n */\nexport type RampsControllerOptions = {\n  /** The messenger suited for this controller. */\n  messenger: RampsControllerMessenger;\n  /** The desired state with which to initialize this controller. */\n  state?: Partial<RampsControllerState>;\n  /** Time to live for cached requests in milliseconds. Defaults to 15 minutes. */\n  requestCacheTTL?: number;\n  /** Maximum number of entries in the request cache. Defaults to 250. */\n  requestCacheMaxSize?: number;\n};\n\n// === CONTROLLER DEFINITION ===\n\n/**\n * Manages cryptocurrency on/off ramps functionality.\n */\nexport class RampsController extends BaseController<\n  typeof controllerName,\n  RampsControllerState,\n  RampsControllerMessenger\n> {\n  /**\n   * Default TTL for cached requests.\n   */\n  readonly #requestCacheTTL: number;\n\n  /**\n   * Maximum number of entries in the request cache.\n   */\n  readonly #requestCacheMaxSize: number;\n\n  /**\n   * Map of pending requests for deduplication.\n   * Key is the cache key, value is the pending request with abort controller.\n   */\n  readonly #pendingRequests: Map<string, PendingRequest> = new Map();\n\n  /**\n   * Constructs a new {@link RampsController}.\n   *\n   * @param args - The constructor arguments.\n   * @param args.messenger - The messenger suited for this controller.\n   * @param args.state - The desired state with which to initialize this\n   * controller. Missing properties will be filled in with defaults.\n   * @param args.requestCacheTTL - Time to live for cached requests in milliseconds.\n   * @param args.requestCacheMaxSize - Maximum number of entries in the request cache.\n   */\n  constructor({\n    messenger,\n    state = {},\n    requestCacheTTL = DEFAULT_REQUEST_CACHE_TTL,\n    requestCacheMaxSize = DEFAULT_REQUEST_CACHE_MAX_SIZE,\n  }: RampsControllerOptions) {\n    super({\n      messenger,\n      metadata: rampsControllerMetadata,\n      name: controllerName,\n      state: {\n        ...getDefaultRampsControllerState(),\n        ...state,\n        // Always reset requests cache on initialization (non-persisted)\n        requests: {},\n      },\n    });\n\n    this.#requestCacheTTL = requestCacheTTL;\n    this.#requestCacheMaxSize = requestCacheMaxSize;\n  }\n\n  /**\n   * Executes a request with caching and deduplication.\n   *\n   * If a request with the same cache key is already in flight, returns the\n   * existing promise. If valid cached data exists, returns it without making\n   * a new request.\n   *\n   * @param cacheKey - Unique identifier for this request.\n   * @param fetcher - Function that performs the actual fetch. Receives an AbortSignal.\n   * @param options - Options for cache behavior.\n   * @returns The result of the request.\n   */\n  async executeRequest<TResult>(\n    cacheKey: string,\n    fetcher: (signal: AbortSignal) => Promise<TResult>,\n    options?: ExecuteRequestOptions,\n  ): Promise<TResult> {\n    const ttl = options?.ttl ?? this.#requestCacheTTL;\n\n    // Check for existing pending request - join it instead of making a duplicate\n    const pending = this.#pendingRequests.get(cacheKey);\n    if (pending) {\n      return pending.promise as Promise<TResult>;\n    }\n\n    // Check cache validity (unless force refresh)\n    if (!options?.forceRefresh) {\n      const cached = this.state.requests[cacheKey];\n      if (cached && !isCacheExpired(cached, ttl)) {\n        return cached.data as TResult;\n      }\n    }\n\n    // Create abort controller for this request\n    const abortController = new AbortController();\n    const lastFetchedAt = Date.now();\n\n    // Update state to loading\n    this.#updateRequestState(cacheKey, createLoadingState());\n\n    // Create the fetch promise\n    const promise = (async (): Promise<TResult> => {\n      try {\n        const data = await fetcher(abortController.signal);\n\n        // Don't update state if aborted\n        if (abortController.signal.aborted) {\n          throw new Error('Request was aborted');\n        }\n\n        this.#updateRequestState(\n          cacheKey,\n          createSuccessState(data as Json, lastFetchedAt),\n        );\n        return data;\n      } catch (error) {\n        // Don't update state if aborted\n        if (abortController.signal.aborted) {\n          throw error;\n        }\n\n        const errorMessage = (error as Error)?.message;\n\n        this.#updateRequestState(\n          cacheKey,\n          createErrorState(errorMessage ?? 'Unknown error', lastFetchedAt),\n        );\n        throw error;\n      } finally {\n        // Only delete if this is still our entry (not replaced by a new request)\n        const currentPending = this.#pendingRequests.get(cacheKey);\n        if (currentPending?.abortController === abortController) {\n          this.#pendingRequests.delete(cacheKey);\n        }\n      }\n    })();\n\n    // Store pending request for deduplication\n    this.#pendingRequests.set(cacheKey, { promise, abortController });\n\n    return promise;\n  }\n\n  /**\n   * Aborts a pending request if one exists.\n   *\n   * @param cacheKey - The cache key of the request to abort.\n   * @returns True if a request was aborted.\n   */\n  abortRequest(cacheKey: string): boolean {\n    const pending = this.#pendingRequests.get(cacheKey);\n    if (pending) {\n      pending.abortController.abort();\n      this.#pendingRequests.delete(cacheKey);\n      this.#removeRequestState(cacheKey);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Removes a request state from the cache.\n   *\n   * @param cacheKey - The cache key to remove.\n   */\n  #removeRequestState(cacheKey: string): void {\n    this.update((state) => {\n      const requests = state.requests as unknown as Record<\n        string,\n        RequestState | undefined\n      >;\n      delete requests[cacheKey];\n    });\n  }\n\n  /**\n   * Gets the state of a specific cached request.\n   *\n   * @param cacheKey - The cache key to look up.\n   * @returns The request state, or undefined if not cached.\n   */\n  getRequestState(cacheKey: string): RequestState | undefined {\n    return this.state.requests[cacheKey];\n  }\n\n  /**\n   * Updates the state for a specific request.\n   *\n   * @param cacheKey - The cache key.\n   * @param requestState - The new state for the request.\n   */\n  #updateRequestState(cacheKey: string, requestState: RequestState): void {\n    const maxSize = this.#requestCacheMaxSize;\n\n    this.update((state) => {\n      const requests = state.requests as unknown as Record<\n        string,\n        RequestState | undefined\n      >;\n      requests[cacheKey] = requestState;\n\n      // Evict oldest entries if cache exceeds max size\n      const keys = Object.keys(requests);\n\n      if (keys.length > maxSize) {\n        // Sort by timestamp (oldest first)\n        const sortedKeys = keys.sort((a, b) => {\n          const aTime = requests[a]?.timestamp ?? 0;\n          const bTime = requests[b]?.timestamp ?? 0;\n          return aTime - bTime;\n        });\n\n        // Remove oldest entries until we're under the limit\n        const entriesToRemove = keys.length - maxSize;\n        for (let i = 0; i < entriesToRemove; i++) {\n          const keyToRemove = sortedKeys[i];\n          if (keyToRemove) {\n            delete requests[keyToRemove];\n          }\n        }\n      }\n    });\n  }\n\n  /**\n   * Updates the user's region by fetching geolocation and eligibility.\n   * This method calls the RampsService to get the geolocation,\n   * then automatically fetches eligibility for that region.\n   *\n   * @param options - Options for cache behavior.\n   * @returns The user region string.\n   */\n  async updateUserRegion(options?: ExecuteRequestOptions): Promise<string> {\n    const cacheKey = createCacheKey('updateUserRegion', []);\n\n    const userRegion = await this.executeRequest(\n      cacheKey,\n      async () => {\n        const result = await this.messenger.call('RampsService:getGeolocation');\n        return result;\n      },\n      options,\n    );\n\n    const normalizedRegion = userRegion\n      ? userRegion.toLowerCase().trim()\n      : userRegion;\n\n    this.update((state) => {\n      state.userRegion = normalizedRegion;\n      state.tokens = null;\n    });\n\n    if (normalizedRegion) {\n      try {\n        await this.updateEligibility(normalizedRegion, options);\n      } catch {\n        this.update((state) => {\n          const currentUserRegion = state.userRegion?.toLowerCase().trim();\n          if (currentUserRegion === normalizedRegion) {\n            state.eligibility = null;\n            state.tokens = null;\n          }\n        });\n      }\n    }\n\n    return normalizedRegion;\n  }\n\n  /**\n   * Sets the user's region manually (without fetching geolocation).\n   * This allows users to override the detected region.\n   *\n   * @param region - The region code to set (e.g., \"US-CA\").\n   * @param options - Options for cache behavior when fetching eligibility.\n   * @returns The eligibility information for the region.\n   */\n  async setUserRegion(\n    region: string,\n    options?: ExecuteRequestOptions,\n  ): Promise<Eligibility> {\n    const normalizedRegion = region.toLowerCase().trim();\n\n    this.update((state) => {\n      state.userRegion = normalizedRegion;\n      state.tokens = null;\n    });\n\n    try {\n      return await this.updateEligibility(normalizedRegion, options);\n    } catch (error) {\n      // Eligibility fetch failed, but user region was successfully set.\n      // Don't let eligibility errors prevent user region state from being updated.\n      // Clear eligibility state to avoid showing stale data from a previous location.\n      // Only clear if the region still matches to avoid race conditions where a newer\n      // region change has already succeeded.\n      this.update((state) => {\n        const currentUserRegion = state.userRegion?.toLowerCase().trim();\n        if (currentUserRegion === normalizedRegion) {\n          state.eligibility = null;\n          state.tokens = null;\n        }\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Initializes the controller by fetching the user's region from geolocation.\n   * This should be called once at app startup to set up the initial region.\n   * After the region is set and eligibility is determined, tokens are fetched\n   * and saved to state.\n   *\n   * @param options - Options for cache behavior.\n   * @returns Promise that resolves when initialization is complete.\n   */\n  async init(options?: ExecuteRequestOptions): Promise<void> {\n    const userRegion = await this.updateUserRegion(options).catch(() => {\n      // User region fetch failed - error state will be available via selectors\n      return null;\n    });\n\n    if (userRegion) {\n      try {\n        await this.getTokens(userRegion, 'buy', options);\n      } catch {\n        // Token fetch failed - error state will be available via selectors\n      }\n    }\n  }\n\n  /**\n   * Updates the eligibility information for a given region.\n   *\n   * @param isoCode - The ISO code for the region (e.g., \"us\", \"fr\", \"us-ny\").\n   * @param options - Options for cache behavior.\n   * @returns The eligibility information.\n   */\n  async updateEligibility(\n    isoCode: string,\n    options?: ExecuteRequestOptions,\n  ): Promise<Eligibility> {\n    const normalizedIsoCode = isoCode.toLowerCase().trim();\n    const cacheKey = createCacheKey('updateEligibility', [normalizedIsoCode]);\n\n    const eligibility = await this.executeRequest(\n      cacheKey,\n      async () => {\n        return this.messenger.call(\n          'RampsService:getEligibility',\n          normalizedIsoCode,\n        );\n      },\n      options,\n    );\n\n    this.update((state) => {\n      const userRegion = state.userRegion?.toLowerCase().trim();\n\n      if (userRegion === undefined || userRegion === normalizedIsoCode) {\n        state.eligibility = eligibility;\n      }\n    });\n\n    return eligibility;\n  }\n\n  /**\n   * Fetches the list of supported countries for a given ramp action.\n   *\n   * @param action - The ramp action type ('buy' or 'sell').\n   * @param options - Options for cache behavior.\n   * @returns An array of countries with their eligibility information.\n   */\n  async getCountries(\n    action: 'buy' | 'sell' = 'buy',\n    options?: ExecuteRequestOptions,\n  ): Promise<Country[]> {\n    const cacheKey = createCacheKey('getCountries', [action]);\n\n    return this.executeRequest(\n      cacheKey,\n      async () => {\n        return this.messenger.call('RampsService:getCountries', action);\n      },\n      options,\n    );\n  }\n\n  /**\n   * Fetches the list of available tokens for a given region and action.\n   * The tokens are saved in the controller state once fetched.\n   *\n   * @param region - The region code (e.g., \"us\", \"fr\", \"us-ny\"). If not provided, uses the user's region from controller state.\n   * @param action - The ramp action type ('buy' or 'sell').\n   * @param options - Options for cache behavior.\n   * @returns The tokens response containing topTokens and allTokens.\n   */\n  async getTokens(\n    region?: string,\n    action: 'buy' | 'sell' = 'buy',\n    options?: ExecuteRequestOptions,\n  ): Promise<TokensResponse> {\n    const regionToUse = region ?? this.state.userRegion;\n\n    if (!regionToUse) {\n      throw new Error(\n        'Region is required. Either provide a region parameter or ensure userRegion is set in controller state.',\n      );\n    }\n\n    const normalizedRegion = regionToUse.toLowerCase().trim();\n    const cacheKey = createCacheKey('getTokens', [normalizedRegion, action]);\n\n    const tokens = await this.executeRequest(\n      cacheKey,\n      async () => {\n        return this.messenger.call(\n          'RampsService:getTokens',\n          normalizedRegion,\n          action,\n        );\n      },\n      options,\n    );\n\n    this.update((state) => {\n      const userRegion = state.userRegion?.toLowerCase().trim();\n\n      if (userRegion === undefined || userRegion === normalizedRegion) {\n        state.tokens = tokens;\n      }\n    });\n\n    return tokens;\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"RampsController.mjs","sourceRoot":"","sources":["../src/RampsController.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n  StateMetadata,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport type { Messenger } from '@metamask/messenger';\nimport type { Json } from '@metamask/utils';\n\nimport type {\n  Country,\n  Eligibility,\n  TokensResponse,\n  Provider,\n  State,\n} from './RampsService';\nimport type {\n  RampsServiceGetGeolocationAction,\n  RampsServiceGetCountriesAction,\n  RampsServiceGetEligibilityAction,\n  RampsServiceGetTokensAction,\n} from './RampsService-method-action-types';\nimport type {\n  RequestCache as RequestCacheType,\n  RequestState,\n  ExecuteRequestOptions,\n  PendingRequest,\n} from './RequestCache';\nimport {\n  DEFAULT_REQUEST_CACHE_TTL,\n  DEFAULT_REQUEST_CACHE_MAX_SIZE,\n  createCacheKey,\n  isCacheExpired,\n  createLoadingState,\n  createSuccessState,\n  createErrorState,\n} from './RequestCache';\n\n// === GENERAL ===\n\n/**\n * The name of the {@link RampsController}, used to namespace the\n * controller's actions and events and to namespace the controller's state data\n * when composed with other controllers.\n */\nexport const controllerName = 'RampsController';\n\n// === STATE ===\n\n/**\n * Represents the user's selected region with full country and state objects.\n */\nexport type UserRegion = {\n  /**\n   * The country object for the selected region.\n   */\n  country: Country;\n  /**\n   * The state object if a state was selected, null if only country was selected.\n   */\n  state: State | null;\n  /**\n   * The region code string (e.g., \"us-ut\" or \"fr\") used for API calls.\n   */\n  regionCode: string;\n};\n\n/**\n * Describes the shape of the state object for {@link RampsController}.\n */\nexport type RampsControllerState = {\n  /**\n   * The user's selected region with full country and state objects.\n   * Initially set via geolocation fetch, but can be manually changed by the user.\n   */\n  userRegion: UserRegion | null;\n  /**\n   * The user's preferred provider.\n   * Can be manually set by the user.\n   */\n  preferredProvider: Provider | null;\n  /**\n   * Eligibility information for the user's current region.\n   */\n  eligibility: Eligibility | null;\n  /**\n   * Tokens fetched for the current region and action.\n   * Contains topTokens and allTokens arrays.\n   */\n  tokens: TokensResponse | null;\n  /**\n   * Cache of request states, keyed by cache key.\n   * This stores loading, success, and error states for API requests.\n   */\n  requests: RequestCacheType;\n};\n\n/**\n * The metadata for each property in {@link RampsControllerState}.\n */\nconst rampsControllerMetadata = {\n  userRegion: {\n    persist: true,\n    includeInDebugSnapshot: true,\n    includeInStateLogs: true,\n    usedInUi: true,\n  },\n  preferredProvider: {\n    persist: true,\n    includeInDebugSnapshot: true,\n    includeInStateLogs: true,\n    usedInUi: true,\n  },\n  eligibility: {\n    persist: true,\n    includeInDebugSnapshot: true,\n    includeInStateLogs: true,\n    usedInUi: true,\n  },\n  tokens: {\n    persist: true,\n    includeInDebugSnapshot: true,\n    includeInStateLogs: true,\n    usedInUi: true,\n  },\n  requests: {\n    persist: false,\n    includeInDebugSnapshot: true,\n    includeInStateLogs: false,\n    usedInUi: true,\n  },\n} satisfies StateMetadata<RampsControllerState>;\n\n/**\n * Constructs the default {@link RampsController} state. This allows\n * consumers to provide a partial state object when initializing the controller\n * and also helps in constructing complete state objects for this controller in\n * tests.\n *\n * @returns The default {@link RampsController} state.\n */\nexport function getDefaultRampsControllerState(): RampsControllerState {\n  return {\n    userRegion: null,\n    preferredProvider: null,\n    eligibility: null,\n    tokens: null,\n    requests: {},\n  };\n}\n\n// === MESSENGER ===\n\n/**\n * Retrieves the state of the {@link RampsController}.\n */\nexport type RampsControllerGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  RampsControllerState\n>;\n\n/**\n * Actions that {@link RampsControllerMessenger} exposes to other consumers.\n */\nexport type RampsControllerActions = RampsControllerGetStateAction;\n\n/**\n * Actions from other messengers that {@link RampsController} calls.\n */\ntype AllowedActions =\n  | RampsServiceGetGeolocationAction\n  | RampsServiceGetCountriesAction\n  | RampsServiceGetEligibilityAction\n  | RampsServiceGetTokensAction;\n\n/**\n * Published when the state of {@link RampsController} changes.\n */\nexport type RampsControllerStateChangeEvent = ControllerStateChangeEvent<\n  typeof controllerName,\n  RampsControllerState\n>;\n\n/**\n * Events that {@link RampsControllerMessenger} exposes to other consumers.\n */\nexport type RampsControllerEvents = RampsControllerStateChangeEvent;\n\n/**\n * Events from other messengers that {@link RampsController} subscribes to.\n */\ntype AllowedEvents = never;\n\n/**\n * The messenger restricted to actions and events accessed by\n * {@link RampsController}.\n */\nexport type RampsControllerMessenger = Messenger<\n  typeof controllerName,\n  RampsControllerActions | AllowedActions,\n  RampsControllerEvents | AllowedEvents\n>;\n\n/**\n * Configuration options for the RampsController.\n */\nexport type RampsControllerOptions = {\n  /** The messenger suited for this controller. */\n  messenger: RampsControllerMessenger;\n  /** The desired state with which to initialize this controller. */\n  state?: Partial<RampsControllerState>;\n  /** Time to live for cached requests in milliseconds. Defaults to 15 minutes. */\n  requestCacheTTL?: number;\n  /** Maximum number of entries in the request cache. Defaults to 250. */\n  requestCacheMaxSize?: number;\n};\n\n// === HELPER FUNCTIONS ===\n\n/**\n * Finds a country and state from a region code string.\n *\n * @param regionCode - The region code (e.g., \"us-ca\" or \"fr\").\n * @param countries - Array of countries to search.\n * @returns UserRegion object with country and state, or null if not found.\n */\nfunction findRegionFromCode(\n  regionCode: string,\n  countries: Country[],\n): UserRegion | null {\n  const normalizedCode = regionCode.toLowerCase().trim();\n  const parts = normalizedCode.split('-');\n  const countryCode = parts[0];\n  const stateCode = parts[1];\n\n  const country = countries.find((c) => {\n    if (c.isoCode?.toLowerCase() === countryCode) {\n      return true;\n    }\n    if (c.id) {\n      const id = c.id.toLowerCase();\n      if (id.startsWith('/regions/')) {\n        const extractedCode = id.replace('/regions/', '').split('/')[0];\n        return extractedCode === countryCode;\n      }\n      return id === countryCode || id.endsWith(`/${countryCode}`);\n    }\n    return false;\n  });\n\n  if (!country) {\n    return null;\n  }\n\n  let state: State | null = null;\n  if (stateCode && country.states) {\n    state =\n      country.states.find((s) => {\n        if (s.stateId?.toLowerCase() === stateCode) {\n          return true;\n        }\n        if (s.id) {\n          const stateId = s.id.toLowerCase();\n          if (\n            stateId.includes(`-${stateCode}`) ||\n            stateId.endsWith(`/${stateCode}`)\n          ) {\n            return true;\n          }\n        }\n        return false;\n      }) || null;\n  }\n\n  return {\n    country,\n    state,\n    regionCode: normalizedCode,\n  };\n}\n\n// === CONTROLLER DEFINITION ===\n\n/**\n * Manages cryptocurrency on/off ramps functionality.\n */\nexport class RampsController extends BaseController<\n  typeof controllerName,\n  RampsControllerState,\n  RampsControllerMessenger\n> {\n  /**\n   * Default TTL for cached requests.\n   */\n  readonly #requestCacheTTL: number;\n\n  /**\n   * Maximum number of entries in the request cache.\n   */\n  readonly #requestCacheMaxSize: number;\n\n  /**\n   * Map of pending requests for deduplication.\n   * Key is the cache key, value is the pending request with abort controller.\n   */\n  readonly #pendingRequests: Map<string, PendingRequest> = new Map();\n\n  /**\n   * Constructs a new {@link RampsController}.\n   *\n   * @param args - The constructor arguments.\n   * @param args.messenger - The messenger suited for this controller.\n   * @param args.state - The desired state with which to initialize this\n   * controller. Missing properties will be filled in with defaults.\n   * @param args.requestCacheTTL - Time to live for cached requests in milliseconds.\n   * @param args.requestCacheMaxSize - Maximum number of entries in the request cache.\n   */\n  constructor({\n    messenger,\n    state = {},\n    requestCacheTTL = DEFAULT_REQUEST_CACHE_TTL,\n    requestCacheMaxSize = DEFAULT_REQUEST_CACHE_MAX_SIZE,\n  }: RampsControllerOptions) {\n    super({\n      messenger,\n      metadata: rampsControllerMetadata,\n      name: controllerName,\n      state: {\n        ...getDefaultRampsControllerState(),\n        ...state,\n        // Always reset requests cache on initialization (non-persisted)\n        requests: {},\n      },\n    });\n\n    this.#requestCacheTTL = requestCacheTTL;\n    this.#requestCacheMaxSize = requestCacheMaxSize;\n  }\n\n  /**\n   * Executes a request with caching and deduplication.\n   *\n   * If a request with the same cache key is already in flight, returns the\n   * existing promise. If valid cached data exists, returns it without making\n   * a new request.\n   *\n   * @param cacheKey - Unique identifier for this request.\n   * @param fetcher - Function that performs the actual fetch. Receives an AbortSignal.\n   * @param options - Options for cache behavior.\n   * @returns The result of the request.\n   */\n  async executeRequest<TResult>(\n    cacheKey: string,\n    fetcher: (signal: AbortSignal) => Promise<TResult>,\n    options?: ExecuteRequestOptions,\n  ): Promise<TResult> {\n    const ttl = options?.ttl ?? this.#requestCacheTTL;\n\n    // Check for existing pending request - join it instead of making a duplicate\n    const pending = this.#pendingRequests.get(cacheKey);\n    if (pending) {\n      return pending.promise as Promise<TResult>;\n    }\n\n    // Check cache validity (unless force refresh)\n    if (!options?.forceRefresh) {\n      const cached = this.state.requests[cacheKey];\n      if (cached && !isCacheExpired(cached, ttl)) {\n        return cached.data as TResult;\n      }\n    }\n\n    // Create abort controller for this request\n    const abortController = new AbortController();\n    const lastFetchedAt = Date.now();\n\n    // Update state to loading\n    this.#updateRequestState(cacheKey, createLoadingState());\n\n    // Create the fetch promise\n    const promise = (async (): Promise<TResult> => {\n      try {\n        const data = await fetcher(abortController.signal);\n\n        // Don't update state if aborted\n        if (abortController.signal.aborted) {\n          throw new Error('Request was aborted');\n        }\n\n        this.#updateRequestState(\n          cacheKey,\n          createSuccessState(data as Json, lastFetchedAt),\n        );\n        return data;\n      } catch (error) {\n        // Don't update state if aborted\n        if (abortController.signal.aborted) {\n          throw error;\n        }\n\n        const errorMessage = (error as Error)?.message;\n\n        this.#updateRequestState(\n          cacheKey,\n          createErrorState(errorMessage ?? 'Unknown error', lastFetchedAt),\n        );\n        throw error;\n      } finally {\n        // Only delete if this is still our entry (not replaced by a new request)\n        const currentPending = this.#pendingRequests.get(cacheKey);\n        if (currentPending?.abortController === abortController) {\n          this.#pendingRequests.delete(cacheKey);\n        }\n      }\n    })();\n\n    // Store pending request for deduplication\n    this.#pendingRequests.set(cacheKey, { promise, abortController });\n\n    return promise;\n  }\n\n  /**\n   * Aborts a pending request if one exists.\n   *\n   * @param cacheKey - The cache key of the request to abort.\n   * @returns True if a request was aborted.\n   */\n  abortRequest(cacheKey: string): boolean {\n    const pending = this.#pendingRequests.get(cacheKey);\n    if (pending) {\n      pending.abortController.abort();\n      this.#pendingRequests.delete(cacheKey);\n      this.#removeRequestState(cacheKey);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Removes a request state from the cache.\n   *\n   * @param cacheKey - The cache key to remove.\n   */\n  #removeRequestState(cacheKey: string): void {\n    this.update((state) => {\n      const requests = state.requests as unknown as Record<\n        string,\n        RequestState | undefined\n      >;\n      delete requests[cacheKey];\n    });\n  }\n\n  /**\n   * Gets the state of a specific cached request.\n   *\n   * @param cacheKey - The cache key to look up.\n   * @returns The request state, or undefined if not cached.\n   */\n  getRequestState(cacheKey: string): RequestState | undefined {\n    return this.state.requests[cacheKey];\n  }\n\n  /**\n   * Updates the state for a specific request.\n   *\n   * @param cacheKey - The cache key.\n   * @param requestState - The new state for the request.\n   */\n  #updateRequestState(cacheKey: string, requestState: RequestState): void {\n    const maxSize = this.#requestCacheMaxSize;\n\n    this.update((state) => {\n      const requests = state.requests as unknown as Record<\n        string,\n        RequestState | undefined\n      >;\n      requests[cacheKey] = requestState;\n\n      // Evict oldest entries if cache exceeds max size\n      const keys = Object.keys(requests);\n\n      if (keys.length > maxSize) {\n        // Sort by timestamp (oldest first)\n        const sortedKeys = keys.sort((a, b) => {\n          const aTime = requests[a]?.timestamp ?? 0;\n          const bTime = requests[b]?.timestamp ?? 0;\n          return aTime - bTime;\n        });\n\n        // Remove oldest entries until we're under the limit\n        const entriesToRemove = keys.length - maxSize;\n        for (let i = 0; i < entriesToRemove; i++) {\n          const keyToRemove = sortedKeys[i];\n          if (keyToRemove) {\n            delete requests[keyToRemove];\n          }\n        }\n      }\n    });\n  }\n\n  /**\n   * Gets countries data from cache or fetches it if not available.\n   *\n   * @param action - The ramp action type ('buy' or 'sell').\n   * @param options - Options for cache behavior.\n   * @returns Array of countries.\n   */\n  async #getCountriesData(\n    action: 'buy' | 'sell' = 'buy',\n    options?: ExecuteRequestOptions,\n  ): Promise<Country[]> {\n    return this.getCountries(action, options);\n  }\n\n  /**\n   * Updates the user's region by fetching geolocation and eligibility.\n   * This method calls the RampsService to get the geolocation,\n   * then automatically fetches eligibility for that region.\n   *\n   * @param options - Options for cache behavior.\n   * @returns The user region object.\n   */\n  async updateUserRegion(\n    options?: ExecuteRequestOptions,\n  ): Promise<UserRegion | null> {\n    const cacheKey = createCacheKey('updateUserRegion', []);\n\n    const regionCode = await this.executeRequest(\n      cacheKey,\n      async () => {\n        const result = await this.messenger.call('RampsService:getGeolocation');\n        return result;\n      },\n      options,\n    );\n\n    if (!regionCode) {\n      this.update((state) => {\n        state.userRegion = null;\n        state.tokens = null;\n      });\n      return null;\n    }\n\n    const normalizedRegion = regionCode.toLowerCase().trim();\n\n    try {\n      const countries = await this.#getCountriesData('buy', options);\n      const userRegion = findRegionFromCode(normalizedRegion, countries);\n\n      if (userRegion) {\n        this.update((state) => {\n          state.userRegion = userRegion;\n          state.tokens = null;\n        });\n\n        try {\n          await this.updateEligibility(userRegion.regionCode, options);\n        } catch {\n          this.update((state) => {\n            if (state.userRegion?.regionCode === userRegion.regionCode) {\n              state.eligibility = null;\n              state.tokens = null;\n            }\n          });\n        }\n\n        return userRegion;\n      }\n    } catch {\n      // If countries fetch fails, fall back to storing just the region code\n      // This maintains backward compatibility\n    }\n\n    // Fallback: store as region code only if countries not available\n    // This shouldn't happen in normal flow, but handles edge cases\n    const fallbackRegion: UserRegion = {\n      country: {\n        isoCode: normalizedRegion.split('-')[0].toUpperCase(),\n        flag: 'ðŸ³ï¸',\n        name: normalizedRegion,\n        phone: { prefix: '', placeholder: '', template: '' },\n        currency: '',\n        supported: false,\n      },\n      state: null,\n      regionCode: normalizedRegion,\n    };\n\n    this.update((state) => {\n      state.userRegion = fallbackRegion;\n      state.tokens = null;\n    });\n\n    try {\n      await this.updateEligibility(normalizedRegion, options);\n    } catch {\n      this.update((state) => {\n        if (state.userRegion?.regionCode === normalizedRegion) {\n          state.eligibility = null;\n          state.tokens = null;\n        }\n      });\n    }\n\n    return fallbackRegion;\n  }\n\n  /**\n   * Sets the user's region manually (without fetching geolocation).\n   * This allows users to override the detected region.\n   *\n   * @param region - The region code to set (e.g., \"US-CA\").\n   * @param options - Options for cache behavior when fetching eligibility.\n   * @returns The eligibility information for the region.\n   */\n  async setUserRegion(\n    region: string,\n    options?: ExecuteRequestOptions,\n  ): Promise<Eligibility> {\n    const normalizedRegion = region.toLowerCase().trim();\n\n    try {\n      const countries = await this.#getCountriesData('buy', options);\n      const userRegion = findRegionFromCode(normalizedRegion, countries);\n\n      if (userRegion) {\n        this.update((state) => {\n          state.userRegion = userRegion;\n          state.tokens = null;\n        });\n\n        try {\n          return await this.updateEligibility(userRegion.regionCode, options);\n        } catch (error) {\n          this.update((state) => {\n            if (state.userRegion?.regionCode === userRegion.regionCode) {\n              state.eligibility = null;\n              state.tokens = null;\n            }\n          });\n          throw error;\n        }\n      }\n    } catch {\n      // If countries fetch fails, fall back to storing just the region code\n    }\n\n    // Fallback: store as region code only if countries not available\n    const fallbackRegion: UserRegion = {\n      country: {\n        isoCode: normalizedRegion.split('-')[0].toUpperCase(),\n        flag: 'ðŸ³ï¸',\n        name: normalizedRegion,\n        phone: { prefix: '', placeholder: '', template: '' },\n        currency: '',\n        supported: false,\n      },\n      state: null,\n      regionCode: normalizedRegion,\n    };\n\n    this.update((state) => {\n      state.userRegion = fallbackRegion;\n      state.tokens = null;\n    });\n\n    try {\n      return await this.updateEligibility(normalizedRegion, options);\n    } catch (error) {\n      this.update((state) => {\n        if (state.userRegion?.regionCode === normalizedRegion) {\n          state.eligibility = null;\n          state.tokens = null;\n        }\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Sets the user's preferred provider.\n   * This allows users to set their preferred ramp provider.\n   *\n   * @param provider - The provider object to set.\n   */\n  setPreferredProvider(provider: Provider | null): void {\n    this.update((state) => {\n      state.preferredProvider = provider;\n    });\n  }\n\n  /**\n   * Initializes the controller by fetching the user's region from geolocation.\n   * This should be called once at app startup to set up the initial region.\n   * After the region is set and eligibility is determined, tokens are fetched\n   * and saved to state.\n   *\n   * @param options - Options for cache behavior.\n   * @returns Promise that resolves when initialization is complete.\n   */\n  async init(options?: ExecuteRequestOptions): Promise<void> {\n    const userRegion = await this.updateUserRegion(options).catch(() => {\n      // User region fetch failed - error state will be available via selectors\n      return null;\n    });\n\n    if (userRegion) {\n      try {\n        await this.getTokens(userRegion.regionCode, 'buy', options);\n      } catch {\n        // Token fetch failed - error state will be available via selectors\n      }\n    }\n  }\n\n  /**\n   * Updates the eligibility information for a given region.\n   *\n   * @param isoCode - The ISO code for the region (e.g., \"us\", \"fr\", \"us-ny\").\n   * @param options - Options for cache behavior.\n   * @returns The eligibility information.\n   */\n  async updateEligibility(\n    isoCode: string,\n    options?: ExecuteRequestOptions,\n  ): Promise<Eligibility> {\n    const normalizedIsoCode = isoCode.toLowerCase().trim();\n    const cacheKey = createCacheKey('updateEligibility', [normalizedIsoCode]);\n\n    const eligibility = await this.executeRequest(\n      cacheKey,\n      async () => {\n        return this.messenger.call(\n          'RampsService:getEligibility',\n          normalizedIsoCode,\n        );\n      },\n      options,\n    );\n\n    this.update((state) => {\n      const userRegionCode = state.userRegion?.regionCode;\n\n      if (userRegionCode === undefined || userRegionCode === normalizedIsoCode) {\n        state.eligibility = eligibility;\n      }\n    });\n\n    return eligibility;\n  }\n\n  /**\n   * Fetches the list of supported countries for a given ramp action.\n   *\n   * @param action - The ramp action type ('buy' or 'sell').\n   * @param options - Options for cache behavior.\n   * @returns An array of countries with their eligibility information.\n   */\n  async getCountries(\n    action: 'buy' | 'sell' = 'buy',\n    options?: ExecuteRequestOptions,\n  ): Promise<Country[]> {\n    const cacheKey = createCacheKey('getCountries', [action]);\n\n    return this.executeRequest(\n      cacheKey,\n      async () => {\n        return this.messenger.call('RampsService:getCountries', action);\n      },\n      options,\n    );\n  }\n\n  /**\n   * Fetches the list of available tokens for a given region and action.\n   * The tokens are saved in the controller state once fetched.\n   *\n   * @param region - The region code (e.g., \"us\", \"fr\", \"us-ny\"). If not provided, uses the user's region from controller state.\n   * @param action - The ramp action type ('buy' or 'sell').\n   * @param options - Options for cache behavior.\n   * @returns The tokens response containing topTokens and allTokens.\n   */\n  async getTokens(\n    region?: string,\n    action: 'buy' | 'sell' = 'buy',\n    options?: ExecuteRequestOptions,\n  ): Promise<TokensResponse> {\n    const regionToUse = region ?? this.state.userRegion?.regionCode;\n\n    if (!regionToUse) {\n      throw new Error(\n        'Region is required. Either provide a region parameter or ensure userRegion is set in controller state.',\n      );\n    }\n\n    const normalizedRegion = regionToUse.toLowerCase().trim();\n    const cacheKey = createCacheKey('getTokens', [normalizedRegion, action]);\n\n    const tokens = await this.executeRequest(\n      cacheKey,\n      async () => {\n        return this.messenger.call(\n          'RampsService:getTokens',\n          normalizedRegion,\n          action,\n        );\n      },\n      options,\n    );\n\n    this.update((state) => {\n      const userRegionCode = state.userRegion?.regionCode;\n\n      if (userRegionCode === undefined || userRegionCode === normalizedRegion) {\n        state.tokens = tokens;\n      }\n    });\n\n    return tokens;\n  }\n}\n"]}
\ No newline at end of file
diff --git a/dist/RampsService.cjs b/dist/RampsService.cjs
index 342d5d59adc737aba807f56e8347add7459d20ff..d10427fc60c16b91e80ece4d6baa354bdc04fe19 100644
--- a/dist/RampsService.cjs
+++ b/dist/RampsService.cjs
@@ -230,7 +230,7 @@ class RampsService {
      * @returns An array of countries filtered by aggregator support.
      */
     async getCountries(action = 'buy') {
-        const countries = await __classPrivateFieldGet(this, _RampsService_instances, "m", _RampsService_request).call(this, RampsApiService.Regions, 'regions/countries', { action, responseType: 'json' });
+        const countries = await __classPrivateFieldGet(this, _RampsService_instances, "m", _RampsService_request).call(this, RampsApiService.Regions, '/v2/regions/countries', { action, responseType: 'json' });
         if (!Array.isArray(countries)) {
             throw new Error('Malformed response received from countries API');
         }
diff --git a/dist/RampsService.cjs.map b/dist/RampsService.cjs.map
index be0633b42e097b8c41c34e1a05aadbc06fc38df1..203a22b3dd1b9af0eceea4e8227491c660e4e458 100644
--- a/dist/RampsService.cjs.map
+++ b/dist/RampsService.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"RampsService.cjs","sourceRoot":"","sources":["../src/RampsService.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  CreateServicePolicyOptions,\n  ServicePolicy,\n} from '@metamask/controller-utils';\nimport { createServicePolicy, HttpError } from '@metamask/controller-utils';\nimport type { Messenger } from '@metamask/messenger';\n\nimport type { RampsServiceMethodActions } from './RampsService-method-action-types';\nimport packageJson from '../package.json';\n\n/**\n * Represents phone number information for a country.\n */\nexport type CountryPhone = {\n  prefix: string;\n  placeholder: string;\n  template: string;\n};\n\n/**\n * Represents a state/province within a country.\n */\nexport type State = {\n  /**\n   * State identifier. Can be in path format (e.g., \"/regions/us-ut\") or ISO code format (e.g., \"us-ut\").\n   */\n  id?: string;\n  /**\n   * State name.\n   */\n  name?: string;\n  /**\n   * ISO state code (e.g., \"UT\", \"NY\").\n   */\n  stateId?: string;\n  /**\n   * Whether this state is supported for ramps.\n   */\n  supported?: boolean;\n  /**\n   * Whether this state is recommended.\n   */\n  recommended?: boolean;\n};\n\n/**\n * Represents eligibility information for a region.\n * Returned from the /regions/countries/{isoCode} endpoint.\n */\nexport type Eligibility = {\n  /**\n   * Whether aggregator providers are available.\n   */\n  aggregator?: boolean;\n  /**\n   * Whether deposit (buy) is available.\n   */\n  deposit?: boolean;\n  /**\n   * Whether global providers are available.\n   */\n  global?: boolean;\n};\n\n/**\n * Represents a country returned from the regions/countries API.\n */\nexport type Country = {\n  /**\n   * ISO-2 country code (e.g., \"US\", \"GB\").\n   */\n  isoCode: string;\n  /**\n   * Country identifier. Can be in path format (e.g., \"/regions/us\") or ISO code format.\n   * If not provided, defaults to isoCode.\n   */\n  id?: string;\n  /**\n   * Country flag emoji or code.\n   */\n  flag: string;\n  /**\n   * Country name.\n   */\n  name: string;\n  /**\n   * Phone number information.\n   */\n  phone: CountryPhone;\n  /**\n   * Default currency code.\n   */\n  currency: string;\n  /**\n   * Whether this country is supported for ramps.\n   */\n  supported: boolean;\n  /**\n   * Whether this country is recommended.\n   */\n  recommended?: boolean;\n  /**\n   * Array of state objects.\n   */\n  states?: State[];\n};\n\n/**\n * Represents a token returned from the regions/{region}/tokens API.\n */\nexport type RampsToken = {\n  /**\n   * The asset identifier in CAIP-19 format (e.g., \"eip155:1/erc20:0x...\").\n   */\n  assetId: string;\n  /**\n   * The chain identifier in CAIP-2 format (e.g., \"eip155:1\").\n   */\n  chainId: string;\n  /**\n   * Token name (e.g., \"USD Coin\").\n   */\n  name: string;\n  /**\n   * Token symbol (e.g., \"USDC\").\n   */\n  symbol: string;\n  /**\n   * Number of decimals for the token.\n   */\n  decimals: number;\n  /**\n   * URL to the token icon.\n   */\n  iconUrl: string;\n  /**\n   * Whether this token is supported.\n   */\n  tokenSupported: boolean;\n};\n\n/**\n * Response from the regions/{region}/tokens API.\n */\nexport type TokensResponse = {\n  /**\n   * Top/popular tokens for the region.\n   */\n  topTokens: RampsToken[];\n  /**\n   * All available tokens for the region.\n   */\n  allTokens: RampsToken[];\n};\n\n/**\n * The SDK version to send with API requests. (backwards-compatibility)\n */\nexport const RAMPS_SDK_VERSION = '2.1.6';\n\n// === GENERAL ===\n\n/**\n * The name of the {@link RampsService}, used to namespace the\n * service's actions and events.\n */\nexport const serviceName = 'RampsService';\n\n/**\n * The environment to use for API requests.\n */\nexport enum RampsEnvironment {\n  Production = 'production',\n  Staging = 'staging',\n  Development = 'development',\n}\n\n/**\n * The type of ramps API service.\n * Determines which base URL to use (cache vs standard).\n */\nexport enum RampsApiService {\n  Regions = 'regions',\n  Orders = 'orders',\n}\n\n// === MESSENGER ===\n\nconst MESSENGER_EXPOSED_METHODS = [\n  'getGeolocation',\n  'getCountries',\n  'getEligibility',\n  'getTokens',\n] as const;\n\n/**\n * Actions that {@link RampsService} exposes to other consumers.\n */\nexport type RampsServiceActions = RampsServiceMethodActions;\n\n/**\n * Actions from other messengers that {@link RampsService} calls.\n */\ntype AllowedActions = never;\n\n/**\n * Events that {@link RampsService} exposes to other consumers.\n */\nexport type RampsServiceEvents = never;\n\n/**\n * Events from other messengers that {@link RampsService} subscribes to.\n */\ntype AllowedEvents = never;\n\n/**\n * The messenger which is restricted to actions and events accessed by\n * {@link RampsService}.\n */\nexport type RampsServiceMessenger = Messenger<\n  typeof serviceName,\n  RampsServiceActions | AllowedActions,\n  RampsServiceEvents | AllowedEvents\n>;\n\n// === SERVICE DEFINITION ===\n\n/**\n * Gets the base URL for API requests based on the environment and service type.\n * The Regions service uses a cache URL, while other services use the standard URL.\n *\n * @param environment - The environment to use.\n * @param service - The API service type (determines if cache URL is used).\n * @returns The base URL for API requests.\n */\nfunction getBaseUrl(\n  environment: RampsEnvironment,\n  service: RampsApiService,\n): string {\n  const cache = service === RampsApiService.Regions ? '-cache' : '';\n\n  switch (environment) {\n    case RampsEnvironment.Production:\n      return `https://on-ramp${cache}.api.cx.metamask.io`;\n    case RampsEnvironment.Staging:\n    case RampsEnvironment.Development:\n      return `https://on-ramp${cache}.uat-api.cx.metamask.io`;\n    default:\n      throw new Error(`Invalid environment: ${String(environment)}`);\n  }\n}\n\n/**\n * This service object is responsible for interacting with the Ramps API.\n *\n * @example\n *\n * ``` ts\n * import { Messenger } from '@metamask/messenger';\n * import type {\n *   RampsServiceActions,\n *   RampsServiceEvents,\n * } from '@metamask/ramps-controller';\n *\n * const rootMessenger = new Messenger<\n *   'Root',\n *   RampsServiceActions\n *   RampsServiceEvents\n * >({ namespace: 'Root' });\n * const rampsServiceMessenger = new Messenger<\n *   'RampsService',\n *   RampsServiceActions,\n *   RampsServiceEvents,\n *   typeof rootMessenger,\n * >({\n *   namespace: 'RampsService',\n *   parent: rootMessenger,\n * });\n * // Instantiate the service to register its actions on the messenger\n * new RampsService({\n *   messenger: rampsServiceMessenger,\n *   environment: RampsEnvironment.Production,\n *   context: 'mobile-ios',\n *   fetch,\n * });\n *\n * // Later...\n * // Get the user's geolocation\n * const geolocation = await rootMessenger.call(\n *   'RampsService:getGeolocation',\n * );\n * // ... Do something with the geolocation ...\n * ```\n */\nexport class RampsService {\n  /**\n   * The name of the service.\n   */\n  readonly name: typeof serviceName;\n\n  /**\n   * The messenger suited for this service.\n   */\n  readonly #messenger: ConstructorParameters<\n    typeof RampsService\n  >[0]['messenger'];\n\n  /**\n   * A function that can be used to make an HTTP request.\n   */\n  readonly #fetch: ConstructorParameters<typeof RampsService>[0]['fetch'];\n\n  /**\n   * The policy that wraps the request.\n   *\n   * @see {@link createServicePolicy}\n   */\n  readonly #policy: ServicePolicy;\n\n  /**\n   * The environment used for API requests.\n   */\n  readonly #environment: RampsEnvironment;\n\n  /**\n   * The context for API requests (e.g., 'mobile-ios', 'mobile-android').\n   */\n  readonly #context: string;\n\n  /**\n   * Constructs a new RampsService object.\n   *\n   * @param args - The constructor arguments.\n   * @param args.messenger - The messenger suited for this service.\n   * @param args.environment - The environment to use for API requests.\n   * @param args.context - The context for API requests (e.g., 'mobile-ios', 'mobile-android').\n   * @param args.fetch - A function that can be used to make an HTTP request. If\n   * your JavaScript environment supports `fetch` natively, you'll probably want\n   * to pass that; otherwise you can pass an equivalent (such as `fetch` via\n   * `node-fetch`).\n   * @param args.policyOptions - Options to pass to `createServicePolicy`, which\n   * is used to wrap each request. See {@link CreateServicePolicyOptions}.\n   */\n  constructor({\n    messenger,\n    environment = RampsEnvironment.Staging,\n    context,\n    fetch: fetchFunction,\n    policyOptions = {},\n  }: {\n    messenger: RampsServiceMessenger;\n    environment?: RampsEnvironment;\n    context: string;\n    fetch: typeof fetch;\n    policyOptions?: CreateServicePolicyOptions;\n  }) {\n    this.name = serviceName;\n    this.#messenger = messenger;\n    this.#fetch = fetchFunction;\n    this.#policy = createServicePolicy(policyOptions);\n    this.#environment = environment;\n    this.#context = context;\n\n    this.#messenger.registerMethodActionHandlers(\n      this,\n      MESSENGER_EXPOSED_METHODS,\n    );\n  }\n\n  /**\n   * Registers a handler that will be called after a request returns a non-500\n   * response, causing a retry. Primarily useful in tests where timers are being\n   * mocked.\n   *\n   * @param listener - The handler to be called.\n   * @returns An object that can be used to unregister the handler. See\n   * {@link CockatielEvent}.\n   * @see {@link createServicePolicy}\n   */\n  onRetry(\n    listener: Parameters<ServicePolicy['onRetry']>[0],\n  ): ReturnType<ServicePolicy['onRetry']> {\n    return this.#policy.onRetry(listener);\n  }\n\n  /**\n   * Registers a handler that will be called after a set number of retry rounds\n   * prove that requests to the API endpoint consistently return a 5xx response.\n   *\n   * @param listener - The handler to be called.\n   * @returns An object that can be used to unregister the handler. See\n   * {@link CockatielEvent}.\n   * @see {@link createServicePolicy}\n   */\n  onBreak(\n    listener: Parameters<ServicePolicy['onBreak']>[0],\n  ): ReturnType<ServicePolicy['onBreak']> {\n    return this.#policy.onBreak(listener);\n  }\n\n  /**\n   * Registers a handler that will be called under one of two circumstances:\n   *\n   * 1. After a set number of retries prove that requests to the API\n   * consistently result in one of the following failures:\n   *    1. A connection initiation error\n   *    2. A connection reset error\n   *    3. A timeout error\n   *    4. A non-JSON response\n   *    5. A 502, 503, or 504 response\n   * 2. After a successful request is made to the API, but the response takes\n   * longer than a set duration to return.\n   *\n   * @param listener - The handler to be called.\n   * @returns An object that can be used to unregister the handler. See\n   * {@link CockatielEvent}.\n   */\n  onDegraded(\n    listener: Parameters<ServicePolicy['onDegraded']>[0],\n  ): ReturnType<ServicePolicy['onDegraded']> {\n    return this.#policy.onDegraded(listener);\n  }\n\n  /**\n   * Adds common request parameters to a URL.\n   *\n   * @param url - The URL to add parameters to.\n   * @param action - The ramp action type (optional, not all endpoints require it).\n   */\n  #addCommonParams(url: URL, action?: 'buy' | 'sell'): void {\n    if (action) {\n      url.searchParams.set('action', action);\n    }\n    url.searchParams.set('sdk', RAMPS_SDK_VERSION);\n    url.searchParams.set('controller', packageJson.version);\n    url.searchParams.set('context', this.#context);\n  }\n\n  /**\n   * Makes an API request with retry policy and error handling.\n   *\n   * @param service - The API service type (determines base URL).\n   * @param path - The endpoint path.\n   * @param options - Request options.\n   * @param options.action - The ramp action type (optional).\n   * @param options.responseType - How to parse the response ('json' or 'text').\n   * @returns The parsed response data.\n   */\n  async #request<TResponse>(\n    service: RampsApiService,\n    path: string,\n    options: {\n      action?: 'buy' | 'sell';\n      responseType: 'json' | 'text';\n    },\n  ): Promise<TResponse> {\n    return this.#policy.execute(async () => {\n      const baseUrl = getBaseUrl(this.#environment, service);\n      const url = new URL(path, baseUrl);\n      this.#addCommonParams(url, options.action);\n\n      const response = await this.#fetch(url);\n      if (!response.ok) {\n        throw new HttpError(\n          response.status,\n          `Fetching '${url.toString()}' failed with status '${response.status}'`,\n        );\n      }\n\n      return options.responseType === 'json'\n        ? (response.json() as Promise<TResponse>)\n        : (response.text() as Promise<TResponse>);\n    });\n  }\n\n  /**\n   * Makes a request to the API in order to retrieve the user's geolocation\n   * based on their IP address.\n   *\n   * @returns The user's country/region code (e.g., \"US-UT\" for Utah, USA).\n   */\n  async getGeolocation(): Promise<string> {\n    const textResponse = await this.#request<string>(\n      RampsApiService.Orders,\n      'geolocation',\n      { responseType: 'text' },\n    );\n\n    const trimmedResponse = textResponse.trim();\n    if (trimmedResponse.length > 0) {\n      return trimmedResponse;\n    }\n\n    throw new Error('Malformed response received from geolocation API');\n  }\n\n  /**\n   * Makes a request to the cached API to retrieve the list of supported countries.\n   * Filters countries based on aggregator support (preserves OnRampSDK logic).\n   *\n   * @param action - The ramp action type ('buy' or 'sell').\n   * @returns An array of countries filtered by aggregator support.\n   */\n  async getCountries(action: 'buy' | 'sell' = 'buy'): Promise<Country[]> {\n    const countries = await this.#request<Country[]>(\n      RampsApiService.Regions,\n      'regions/countries',\n      { action, responseType: 'json' },\n    );\n\n    if (!Array.isArray(countries)) {\n      throw new Error('Malformed response received from countries API');\n    }\n\n    return countries.filter((country) => {\n      if (country.states && country.states.length > 0) {\n        const hasSupportedState = country.states.some(\n          (state) => state.supported !== false,\n        );\n        return country.supported || hasSupportedState;\n      }\n\n      return country.supported;\n    });\n  }\n\n  /**\n   * Fetches eligibility information for a specific region.\n   *\n   * @param isoCode - The ISO code for the region (e.g., \"us\", \"fr\", \"us-ny\").\n   * @returns Eligibility information for the region.\n   */\n  async getEligibility(isoCode: string): Promise<Eligibility> {\n    const normalizedIsoCode = isoCode.toLowerCase().trim();\n    return this.#request<Eligibility>(\n      RampsApiService.Regions,\n      `regions/countries/${normalizedIsoCode}`,\n      { responseType: 'json' },\n    );\n  }\n\n  /**\n   * Fetches the list of available tokens for a given region and action.\n   *\n   * @param region - The region code (e.g., \"us\", \"fr\", \"us-ny\").\n   * @param action - The ramp action type ('buy' or 'sell').\n   * @returns The tokens response containing topTokens and allTokens.\n   */\n  async getTokens(\n    region: string,\n    action: 'buy' | 'sell' = 'buy',\n  ): Promise<TokensResponse> {\n    const normalizedRegion = region.toLowerCase().trim();\n    const response = await this.#request<TokensResponse>(\n      RampsApiService.Regions,\n      `regions/${normalizedRegion}/tokens`,\n      { action, responseType: 'json' },\n    );\n\n    if (!response || typeof response !== 'object') {\n      throw new Error('Malformed response received from tokens API');\n    }\n\n    if (\n      !Array.isArray(response.topTokens) ||\n      !Array.isArray(response.allTokens)\n    ) {\n      throw new Error('Malformed response received from tokens API');\n    }\n\n    return response;\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"RampsService.cjs","sourceRoot":"","sources":["../src/RampsService.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  CreateServicePolicyOptions,\n  ServicePolicy,\n} from '@metamask/controller-utils';\nimport { createServicePolicy, HttpError } from '@metamask/controller-utils';\nimport type { Messenger } from '@metamask/messenger';\n\nimport type { RampsServiceMethodActions } from './RampsService-method-action-types';\nimport packageJson from '../package.json';\n\n/**\n * Represents phone number information for a country.\n */\nexport type CountryPhone = {\n  prefix: string;\n  placeholder: string;\n  template: string;\n};\n\n/**\n * Represents a state/province within a country.\n */\nexport type State = {\n  /**\n   * State identifier. Can be in path format (e.g., \"/regions/us-ut\") or ISO code format (e.g., \"us-ut\").\n   */\n  id?: string;\n  /**\n   * State name.\n   */\n  name?: string;\n  /**\n   * ISO state code (e.g., \"UT\", \"NY\").\n   */\n  stateId?: string;\n  /**\n   * Whether this state is supported for ramps.\n   */\n  supported?: boolean;\n  /**\n   * Whether this state is recommended.\n   */\n  recommended?: boolean;\n};\n\n/**\n * Represents eligibility information for a region.\n * Returned from the /regions/countries/{isoCode} endpoint.\n */\nexport type Eligibility = {\n  /**\n   * Whether aggregator providers are available.\n   */\n  aggregator?: boolean;\n  /**\n   * Whether deposit (buy) is available.\n   */\n  deposit?: boolean;\n  /**\n   * Whether global providers are available.\n   */\n  global?: boolean;\n};\n\n/**\n * Represents a provider link.\n */\nexport type ProviderLink = {\n  name: string;\n  url: string;\n};\n\n/**\n * Represents provider logos.\n */\nexport type ProviderLogos = {\n  light: string;\n  dark: string;\n  height: number;\n  width: number;\n};\n\n/**\n * Represents a ramp provider.\n */\nexport type Provider = {\n  id: string;\n  name: string;\n  environmentType: string;\n  description: string;\n  hqAddress: string;\n  links: ProviderLink[];\n  logos: ProviderLogos;\n};\n\n/**\n * Represents a country returned from the regions/countries API.\n */\nexport type Country = {\n  /**\n   * ISO-2 country code (e.g., \"US\", \"GB\").\n   */\n  isoCode: string;\n  /**\n   * Country identifier. Can be in path format (e.g., \"/regions/us\") or ISO code format.\n   * If not provided, defaults to isoCode.\n   */\n  id?: string;\n  /**\n   * Country flag emoji or code.\n   */\n  flag: string;\n  /**\n   * Country name.\n   */\n  name: string;\n  /**\n   * Phone number information.\n   */\n  phone: CountryPhone;\n  /**\n   * Default currency code.\n   */\n  currency: string;\n  /**\n   * Whether this country is supported for ramps.\n   */\n  supported: boolean;\n  /**\n   * Whether this country is recommended.\n   */\n  recommended?: boolean;\n  /**\n   * Array of state objects.\n   */\n  states?: State[];\n};\n\n/**\n * Represents a token returned from the regions/{region}/tokens API.\n */\nexport type RampsToken = {\n  /**\n   * The asset identifier in CAIP-19 format (e.g., \"eip155:1/erc20:0x...\").\n   */\n  assetId: string;\n  /**\n   * The chain identifier in CAIP-2 format (e.g., \"eip155:1\").\n   */\n  chainId: string;\n  /**\n   * Token name (e.g., \"USD Coin\").\n   */\n  name: string;\n  /**\n   * Token symbol (e.g., \"USDC\").\n   */\n  symbol: string;\n  /**\n   * Number of decimals for the token.\n   */\n  decimals: number;\n  /**\n   * URL to the token icon.\n   */\n  iconUrl: string;\n  /**\n   * Whether this token is supported.\n   */\n  tokenSupported: boolean;\n};\n\n/**\n * Response from the regions/{region}/tokens API.\n */\nexport type TokensResponse = {\n  /**\n   * Top/popular tokens for the region.\n   */\n  topTokens: RampsToken[];\n  /**\n   * All available tokens for the region.\n   */\n  allTokens: RampsToken[];\n};\n\n/**\n * The SDK version to send with API requests. (backwards-compatibility)\n */\nexport const RAMPS_SDK_VERSION = '2.1.6';\n\n// === GENERAL ===\n\n/**\n * The name of the {@link RampsService}, used to namespace the\n * service's actions and events.\n */\nexport const serviceName = 'RampsService';\n\n/**\n * The environment to use for API requests.\n */\nexport enum RampsEnvironment {\n  Production = 'production',\n  Staging = 'staging',\n  Development = 'development',\n}\n\n/**\n * The type of ramps API service.\n * Determines which base URL to use (cache vs standard).\n */\nexport enum RampsApiService {\n  Regions = 'regions',\n  Orders = 'orders',\n}\n\n// === MESSENGER ===\n\nconst MESSENGER_EXPOSED_METHODS = [\n  'getGeolocation',\n  'getCountries',\n  'getEligibility',\n  'getTokens',\n] as const;\n\n/**\n * Actions that {@link RampsService} exposes to other consumers.\n */\nexport type RampsServiceActions = RampsServiceMethodActions;\n\n/**\n * Actions from other messengers that {@link RampsService} calls.\n */\ntype AllowedActions = never;\n\n/**\n * Events that {@link RampsService} exposes to other consumers.\n */\nexport type RampsServiceEvents = never;\n\n/**\n * Events from other messengers that {@link RampsService} subscribes to.\n */\ntype AllowedEvents = never;\n\n/**\n * The messenger which is restricted to actions and events accessed by\n * {@link RampsService}.\n */\nexport type RampsServiceMessenger = Messenger<\n  typeof serviceName,\n  RampsServiceActions | AllowedActions,\n  RampsServiceEvents | AllowedEvents\n>;\n\n// === SERVICE DEFINITION ===\n\n/**\n * Gets the base URL for API requests based on the environment and service type.\n * The Regions service uses a cache URL, while other services use the standard URL.\n *\n * @param environment - The environment to use.\n * @param service - The API service type (determines if cache URL is used).\n * @returns The base URL for API requests.\n */\nfunction getBaseUrl(\n  environment: RampsEnvironment,\n  service: RampsApiService,\n): string {\n  const cache = service === RampsApiService.Regions ? '-cache' : '';\n\n  switch (environment) {\n    case RampsEnvironment.Production:\n      return `https://on-ramp${cache}.api.cx.metamask.io`;\n    case RampsEnvironment.Staging:\n    case RampsEnvironment.Development:\n      return `https://on-ramp${cache}.uat-api.cx.metamask.io`;\n    default:\n      throw new Error(`Invalid environment: ${String(environment)}`);\n  }\n}\n\n/**\n * This service object is responsible for interacting with the Ramps API.\n *\n * @example\n *\n * ``` ts\n * import { Messenger } from '@metamask/messenger';\n * import type {\n *   RampsServiceActions,\n *   RampsServiceEvents,\n * } from '@metamask/ramps-controller';\n *\n * const rootMessenger = new Messenger<\n *   'Root',\n *   RampsServiceActions\n *   RampsServiceEvents\n * >({ namespace: 'Root' });\n * const rampsServiceMessenger = new Messenger<\n *   'RampsService',\n *   RampsServiceActions,\n *   RampsServiceEvents,\n *   typeof rootMessenger,\n * >({\n *   namespace: 'RampsService',\n *   parent: rootMessenger,\n * });\n * // Instantiate the service to register its actions on the messenger\n * new RampsService({\n *   messenger: rampsServiceMessenger,\n *   environment: RampsEnvironment.Production,\n *   context: 'mobile-ios',\n *   fetch,\n * });\n *\n * // Later...\n * // Get the user's geolocation\n * const geolocation = await rootMessenger.call(\n *   'RampsService:getGeolocation',\n * );\n * // ... Do something with the geolocation ...\n * ```\n */\nexport class RampsService {\n  /**\n   * The name of the service.\n   */\n  readonly name: typeof serviceName;\n\n  /**\n   * The messenger suited for this service.\n   */\n  readonly #messenger: ConstructorParameters<\n    typeof RampsService\n  >[0]['messenger'];\n\n  /**\n   * A function that can be used to make an HTTP request.\n   */\n  readonly #fetch: ConstructorParameters<typeof RampsService>[0]['fetch'];\n\n  /**\n   * The policy that wraps the request.\n   *\n   * @see {@link createServicePolicy}\n   */\n  readonly #policy: ServicePolicy;\n\n  /**\n   * The environment used for API requests.\n   */\n  readonly #environment: RampsEnvironment;\n\n  /**\n   * The context for API requests (e.g., 'mobile-ios', 'mobile-android').\n   */\n  readonly #context: string;\n\n  /**\n   * Constructs a new RampsService object.\n   *\n   * @param args - The constructor arguments.\n   * @param args.messenger - The messenger suited for this service.\n   * @param args.environment - The environment to use for API requests.\n   * @param args.context - The context for API requests (e.g., 'mobile-ios', 'mobile-android').\n   * @param args.fetch - A function that can be used to make an HTTP request. If\n   * your JavaScript environment supports `fetch` natively, you'll probably want\n   * to pass that; otherwise you can pass an equivalent (such as `fetch` via\n   * `node-fetch`).\n   * @param args.policyOptions - Options to pass to `createServicePolicy`, which\n   * is used to wrap each request. See {@link CreateServicePolicyOptions}.\n   */\n  constructor({\n    messenger,\n    environment = RampsEnvironment.Staging,\n    context,\n    fetch: fetchFunction,\n    policyOptions = {},\n  }: {\n    messenger: RampsServiceMessenger;\n    environment?: RampsEnvironment;\n    context: string;\n    fetch: typeof fetch;\n    policyOptions?: CreateServicePolicyOptions;\n  }) {\n    this.name = serviceName;\n    this.#messenger = messenger;\n    this.#fetch = fetchFunction;\n    this.#policy = createServicePolicy(policyOptions);\n    this.#environment = environment;\n    this.#context = context;\n\n    this.#messenger.registerMethodActionHandlers(\n      this,\n      MESSENGER_EXPOSED_METHODS,\n    );\n  }\n\n  /**\n   * Registers a handler that will be called after a request returns a non-500\n   * response, causing a retry. Primarily useful in tests where timers are being\n   * mocked.\n   *\n   * @param listener - The handler to be called.\n   * @returns An object that can be used to unregister the handler. See\n   * {@link CockatielEvent}.\n   * @see {@link createServicePolicy}\n   */\n  onRetry(\n    listener: Parameters<ServicePolicy['onRetry']>[0],\n  ): ReturnType<ServicePolicy['onRetry']> {\n    return this.#policy.onRetry(listener);\n  }\n\n  /**\n   * Registers a handler that will be called after a set number of retry rounds\n   * prove that requests to the API endpoint consistently return a 5xx response.\n   *\n   * @param listener - The handler to be called.\n   * @returns An object that can be used to unregister the handler. See\n   * {@link CockatielEvent}.\n   * @see {@link createServicePolicy}\n   */\n  onBreak(\n    listener: Parameters<ServicePolicy['onBreak']>[0],\n  ): ReturnType<ServicePolicy['onBreak']> {\n    return this.#policy.onBreak(listener);\n  }\n\n  /**\n   * Registers a handler that will be called under one of two circumstances:\n   *\n   * 1. After a set number of retries prove that requests to the API\n   * consistently result in one of the following failures:\n   *    1. A connection initiation error\n   *    2. A connection reset error\n   *    3. A timeout error\n   *    4. A non-JSON response\n   *    5. A 502, 503, or 504 response\n   * 2. After a successful request is made to the API, but the response takes\n   * longer than a set duration to return.\n   *\n   * @param listener - The handler to be called.\n   * @returns An object that can be used to unregister the handler. See\n   * {@link CockatielEvent}.\n   */\n  onDegraded(\n    listener: Parameters<ServicePolicy['onDegraded']>[0],\n  ): ReturnType<ServicePolicy['onDegraded']> {\n    return this.#policy.onDegraded(listener);\n  }\n\n  /**\n   * Adds common request parameters to a URL.\n   *\n   * @param url - The URL to add parameters to.\n   * @param action - The ramp action type (optional, not all endpoints require it).\n   */\n  #addCommonParams(url: URL, action?: 'buy' | 'sell'): void {\n    if (action) {\n      url.searchParams.set('action', action);\n    }\n    url.searchParams.set('sdk', RAMPS_SDK_VERSION);\n    url.searchParams.set('controller', packageJson.version);\n    url.searchParams.set('context', this.#context);\n  }\n\n  /**\n   * Makes an API request with retry policy and error handling.\n   *\n   * @param service - The API service type (determines base URL).\n   * @param path - The endpoint path.\n   * @param options - Request options.\n   * @param options.action - The ramp action type (optional).\n   * @param options.responseType - How to parse the response ('json' or 'text').\n   * @returns The parsed response data.\n   */\n  async #request<TResponse>(\n    service: RampsApiService,\n    path: string,\n    options: {\n      action?: 'buy' | 'sell';\n      responseType: 'json' | 'text';\n    },\n  ): Promise<TResponse> {\n    return this.#policy.execute(async () => {\n      const baseUrl = getBaseUrl(this.#environment, service);\n      const url = new URL(path, baseUrl);\n      this.#addCommonParams(url, options.action);\n\n      const response = await this.#fetch(url);\n      if (!response.ok) {\n        throw new HttpError(\n          response.status,\n          `Fetching '${url.toString()}' failed with status '${response.status}'`,\n        );\n      }\n\n      return options.responseType === 'json'\n        ? (response.json() as Promise<TResponse>)\n        : (response.text() as Promise<TResponse>);\n    });\n  }\n\n  /**\n   * Makes a request to the API in order to retrieve the user's geolocation\n   * based on their IP address.\n   *\n   * @returns The user's country/region code (e.g., \"US-UT\" for Utah, USA).\n   */\n  async getGeolocation(): Promise<string> {\n    const textResponse = await this.#request<string>(\n      RampsApiService.Orders,\n      'geolocation',\n      { responseType: 'text' },\n    );\n\n    const trimmedResponse = textResponse.trim();\n    if (trimmedResponse.length > 0) {\n      return trimmedResponse;\n    }\n\n    throw new Error('Malformed response received from geolocation API');\n  }\n\n  /**\n   * Makes a request to the cached API to retrieve the list of supported countries.\n   * Filters countries based on aggregator support (preserves OnRampSDK logic).\n   *\n   * @param action - The ramp action type ('buy' or 'sell').\n   * @returns An array of countries filtered by aggregator support.\n   */\n  async getCountries(action: 'buy' | 'sell' = 'buy'): Promise<Country[]> {\n    const countries = await this.#request<Country[]>(\n      RampsApiService.Regions,\n      '/v2/regions/countries',\n      { action, responseType: 'json' },\n    );\n\n    if (!Array.isArray(countries)) {\n      throw new Error('Malformed response received from countries API');\n    }\n\n    return countries.filter((country) => {\n      if (country.states && country.states.length > 0) {\n        const hasSupportedState = country.states.some(\n          (state) => state.supported !== false,\n        );\n        return country.supported || hasSupportedState;\n      }\n\n      return country.supported;\n    });\n  }\n\n  /**\n   * Fetches eligibility information for a specific region.\n   *\n   * @param isoCode - The ISO code for the region (e.g., \"us\", \"fr\", \"us-ny\").\n   * @returns Eligibility information for the region.\n   */\n  async getEligibility(isoCode: string): Promise<Eligibility> {\n    const normalizedIsoCode = isoCode.toLowerCase().trim();\n    return this.#request<Eligibility>(\n      RampsApiService.Regions,\n      `regions/countries/${normalizedIsoCode}`,\n      { responseType: 'json' },\n    );\n  }\n\n  /**\n   * Fetches the list of available tokens for a given region and action.\n   *\n   * @param region - The region code (e.g., \"us\", \"fr\", \"us-ny\").\n   * @param action - The ramp action type ('buy' or 'sell').\n   * @returns The tokens response containing topTokens and allTokens.\n   */\n  async getTokens(\n    region: string,\n    action: 'buy' | 'sell' = 'buy',\n  ): Promise<TokensResponse> {\n    const normalizedRegion = region.toLowerCase().trim();\n    const response = await this.#request<TokensResponse>(\n      RampsApiService.Regions,\n      `regions/${normalizedRegion}/tokens`,\n      { action, responseType: 'json' },\n    );\n\n    if (!response || typeof response !== 'object') {\n      throw new Error('Malformed response received from tokens API');\n    }\n\n    if (\n      !Array.isArray(response.topTokens) ||\n      !Array.isArray(response.allTokens)\n    ) {\n      throw new Error('Malformed response received from tokens API');\n    }\n\n    return response;\n  }\n}\n"]}
\ No newline at end of file
diff --git a/dist/RampsService.d.cts b/dist/RampsService.d.cts
index 819f59253db09073ed4aab0d1485e07b1a577cca..7efd04436390d3f742a03314d9e087dba045818e 100644
--- a/dist/RampsService.d.cts
+++ b/dist/RampsService.d.cts
@@ -52,6 +52,34 @@ export type Eligibility = {
      */
     global?: boolean;
 };
+/**
+ * Represents a provider link.
+ */
+export type ProviderLink = {
+    name: string;
+    url: string;
+};
+/**
+ * Represents provider logos.
+ */
+export type ProviderLogos = {
+    light: string;
+    dark: string;
+    height: number;
+    width: number;
+};
+/**
+ * Represents a ramp provider.
+ */
+export type Provider = {
+    id: string;
+    name: string;
+    environmentType: string;
+    description: string;
+    hqAddress: string;
+    links: ProviderLink[];
+    logos: ProviderLogos;
+};
 /**
  * Represents a country returned from the regions/countries API.
  */
diff --git a/dist/RampsService.d.cts.map b/dist/RampsService.d.cts.map
index e738ff34e36b3f2be35fa5989d845abb6a46d4e5..9c4266c43ff3be1b3cb16f0ff6195e2a61e4ce99 100644
--- a/dist/RampsService.d.cts.map
+++ b/dist/RampsService.d.cts.map
@@ -1 +1 @@
-{"version":3,"file":"RampsService.d.cts","sourceRoot":"","sources":["../src/RampsService.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"RampsService.d.cts","sourceRoot":"","sources":["../src/RampsService.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/RampsService.d.mts b/dist/RampsService.d.mts
index 046413ecab0d8b455e2117a3edc13e96dec3d68e..2addd786b5b2939f03cd5d0096c7e92af5d63f69 100644
--- a/dist/RampsService.d.mts
+++ b/dist/RampsService.d.mts
@@ -52,6 +52,34 @@ export type Eligibility = {
      */
     global?: boolean;
 };
+/**
+ * Represents a provider link.
+ */
+export type ProviderLink = {
+    name: string;
+    url: string;
+};
+/**
+ * Represents provider logos.
+ */
+export type ProviderLogos = {
+    light: string;
+    dark: string;
+    height: number;
+    width: number;
+};
+/**
+ * Represents a ramp provider.
+ */
+export type Provider = {
+    id: string;
+    name: string;
+    environmentType: string;
+    description: string;
+    hqAddress: string;
+    links: ProviderLink[];
+    logos: ProviderLogos;
+};
 /**
  * Represents a country returned from the regions/countries API.
  */
diff --git a/dist/RampsService.d.mts.map b/dist/RampsService.d.mts.map
index b4a67f6d6a75a507e2bfb554ec99a6ab4271dc37..6943a6b65e14b871a9af1205b237428f72b5cb7d 100644
--- a/dist/RampsService.d.mts.map
+++ b/dist/RampsService.d.mts.map
@@ -1 +1 @@
-{"version":3,"file":"RampsService.d.mts","sourceRoot":"","sources":["../src/RampsService.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"RampsService.d.mts","sourceRoot":"","sources":["../src/RampsService.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/RampsService.mjs b/dist/RampsService.mjs
index 02c15ca5b310b11475b68ca984cbc70b39159251..cccd695934006db2be17d8aebc5d7e7f58b364da 100644
--- a/dist/RampsService.mjs
+++ b/dist/RampsService.mjs
@@ -224,7 +224,7 @@ export class RampsService {
      * @returns An array of countries filtered by aggregator support.
      */
     async getCountries(action = 'buy') {
-        const countries = await __classPrivateFieldGet(this, _RampsService_instances, "m", _RampsService_request).call(this, RampsApiService.Regions, 'regions/countries', { action, responseType: 'json' });
+        const countries = await __classPrivateFieldGet(this, _RampsService_instances, "m", _RampsService_request).call(this, RampsApiService.Regions, '/v2/regions/countries', { action, responseType: 'json' });
         if (!Array.isArray(countries)) {
             throw new Error('Malformed response received from countries API');
         }
diff --git a/dist/RampsService.mjs.map b/dist/RampsService.mjs.map
index 35a00f8ac7f3a10607d50fbced7cdf46c7672f47..1f4e3d8210f2662be16bd3dc5da03c0155a7e3e7 100644
--- a/dist/RampsService.mjs.map
+++ b/dist/RampsService.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"RampsService.mjs","sourceRoot":"","sources":["../src/RampsService.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  CreateServicePolicyOptions,\n  ServicePolicy,\n} from '@metamask/controller-utils';\nimport { createServicePolicy, HttpError } from '@metamask/controller-utils';\nimport type { Messenger } from '@metamask/messenger';\n\nimport type { RampsServiceMethodActions } from './RampsService-method-action-types';\nimport packageJson from '../package.json';\n\n/**\n * Represents phone number information for a country.\n */\nexport type CountryPhone = {\n  prefix: string;\n  placeholder: string;\n  template: string;\n};\n\n/**\n * Represents a state/province within a country.\n */\nexport type State = {\n  /**\n   * State identifier. Can be in path format (e.g., \"/regions/us-ut\") or ISO code format (e.g., \"us-ut\").\n   */\n  id?: string;\n  /**\n   * State name.\n   */\n  name?: string;\n  /**\n   * ISO state code (e.g., \"UT\", \"NY\").\n   */\n  stateId?: string;\n  /**\n   * Whether this state is supported for ramps.\n   */\n  supported?: boolean;\n  /**\n   * Whether this state is recommended.\n   */\n  recommended?: boolean;\n};\n\n/**\n * Represents eligibility information for a region.\n * Returned from the /regions/countries/{isoCode} endpoint.\n */\nexport type Eligibility = {\n  /**\n   * Whether aggregator providers are available.\n   */\n  aggregator?: boolean;\n  /**\n   * Whether deposit (buy) is available.\n   */\n  deposit?: boolean;\n  /**\n   * Whether global providers are available.\n   */\n  global?: boolean;\n};\n\n/**\n * Represents a country returned from the regions/countries API.\n */\nexport type Country = {\n  /**\n   * ISO-2 country code (e.g., \"US\", \"GB\").\n   */\n  isoCode: string;\n  /**\n   * Country identifier. Can be in path format (e.g., \"/regions/us\") or ISO code format.\n   * If not provided, defaults to isoCode.\n   */\n  id?: string;\n  /**\n   * Country flag emoji or code.\n   */\n  flag: string;\n  /**\n   * Country name.\n   */\n  name: string;\n  /**\n   * Phone number information.\n   */\n  phone: CountryPhone;\n  /**\n   * Default currency code.\n   */\n  currency: string;\n  /**\n   * Whether this country is supported for ramps.\n   */\n  supported: boolean;\n  /**\n   * Whether this country is recommended.\n   */\n  recommended?: boolean;\n  /**\n   * Array of state objects.\n   */\n  states?: State[];\n};\n\n/**\n * Represents a token returned from the regions/{region}/tokens API.\n */\nexport type RampsToken = {\n  /**\n   * The asset identifier in CAIP-19 format (e.g., \"eip155:1/erc20:0x...\").\n   */\n  assetId: string;\n  /**\n   * The chain identifier in CAIP-2 format (e.g., \"eip155:1\").\n   */\n  chainId: string;\n  /**\n   * Token name (e.g., \"USD Coin\").\n   */\n  name: string;\n  /**\n   * Token symbol (e.g., \"USDC\").\n   */\n  symbol: string;\n  /**\n   * Number of decimals for the token.\n   */\n  decimals: number;\n  /**\n   * URL to the token icon.\n   */\n  iconUrl: string;\n  /**\n   * Whether this token is supported.\n   */\n  tokenSupported: boolean;\n};\n\n/**\n * Response from the regions/{region}/tokens API.\n */\nexport type TokensResponse = {\n  /**\n   * Top/popular tokens for the region.\n   */\n  topTokens: RampsToken[];\n  /**\n   * All available tokens for the region.\n   */\n  allTokens: RampsToken[];\n};\n\n/**\n * The SDK version to send with API requests. (backwards-compatibility)\n */\nexport const RAMPS_SDK_VERSION = '2.1.6';\n\n// === GENERAL ===\n\n/**\n * The name of the {@link RampsService}, used to namespace the\n * service's actions and events.\n */\nexport const serviceName = 'RampsService';\n\n/**\n * The environment to use for API requests.\n */\nexport enum RampsEnvironment {\n  Production = 'production',\n  Staging = 'staging',\n  Development = 'development',\n}\n\n/**\n * The type of ramps API service.\n * Determines which base URL to use (cache vs standard).\n */\nexport enum RampsApiService {\n  Regions = 'regions',\n  Orders = 'orders',\n}\n\n// === MESSENGER ===\n\nconst MESSENGER_EXPOSED_METHODS = [\n  'getGeolocation',\n  'getCountries',\n  'getEligibility',\n  'getTokens',\n] as const;\n\n/**\n * Actions that {@link RampsService} exposes to other consumers.\n */\nexport type RampsServiceActions = RampsServiceMethodActions;\n\n/**\n * Actions from other messengers that {@link RampsService} calls.\n */\ntype AllowedActions = never;\n\n/**\n * Events that {@link RampsService} exposes to other consumers.\n */\nexport type RampsServiceEvents = never;\n\n/**\n * Events from other messengers that {@link RampsService} subscribes to.\n */\ntype AllowedEvents = never;\n\n/**\n * The messenger which is restricted to actions and events accessed by\n * {@link RampsService}.\n */\nexport type RampsServiceMessenger = Messenger<\n  typeof serviceName,\n  RampsServiceActions | AllowedActions,\n  RampsServiceEvents | AllowedEvents\n>;\n\n// === SERVICE DEFINITION ===\n\n/**\n * Gets the base URL for API requests based on the environment and service type.\n * The Regions service uses a cache URL, while other services use the standard URL.\n *\n * @param environment - The environment to use.\n * @param service - The API service type (determines if cache URL is used).\n * @returns The base URL for API requests.\n */\nfunction getBaseUrl(\n  environment: RampsEnvironment,\n  service: RampsApiService,\n): string {\n  const cache = service === RampsApiService.Regions ? '-cache' : '';\n\n  switch (environment) {\n    case RampsEnvironment.Production:\n      return `https://on-ramp${cache}.api.cx.metamask.io`;\n    case RampsEnvironment.Staging:\n    case RampsEnvironment.Development:\n      return `https://on-ramp${cache}.uat-api.cx.metamask.io`;\n    default:\n      throw new Error(`Invalid environment: ${String(environment)}`);\n  }\n}\n\n/**\n * This service object is responsible for interacting with the Ramps API.\n *\n * @example\n *\n * ``` ts\n * import { Messenger } from '@metamask/messenger';\n * import type {\n *   RampsServiceActions,\n *   RampsServiceEvents,\n * } from '@metamask/ramps-controller';\n *\n * const rootMessenger = new Messenger<\n *   'Root',\n *   RampsServiceActions\n *   RampsServiceEvents\n * >({ namespace: 'Root' });\n * const rampsServiceMessenger = new Messenger<\n *   'RampsService',\n *   RampsServiceActions,\n *   RampsServiceEvents,\n *   typeof rootMessenger,\n * >({\n *   namespace: 'RampsService',\n *   parent: rootMessenger,\n * });\n * // Instantiate the service to register its actions on the messenger\n * new RampsService({\n *   messenger: rampsServiceMessenger,\n *   environment: RampsEnvironment.Production,\n *   context: 'mobile-ios',\n *   fetch,\n * });\n *\n * // Later...\n * // Get the user's geolocation\n * const geolocation = await rootMessenger.call(\n *   'RampsService:getGeolocation',\n * );\n * // ... Do something with the geolocation ...\n * ```\n */\nexport class RampsService {\n  /**\n   * The name of the service.\n   */\n  readonly name: typeof serviceName;\n\n  /**\n   * The messenger suited for this service.\n   */\n  readonly #messenger: ConstructorParameters<\n    typeof RampsService\n  >[0]['messenger'];\n\n  /**\n   * A function that can be used to make an HTTP request.\n   */\n  readonly #fetch: ConstructorParameters<typeof RampsService>[0]['fetch'];\n\n  /**\n   * The policy that wraps the request.\n   *\n   * @see {@link createServicePolicy}\n   */\n  readonly #policy: ServicePolicy;\n\n  /**\n   * The environment used for API requests.\n   */\n  readonly #environment: RampsEnvironment;\n\n  /**\n   * The context for API requests (e.g., 'mobile-ios', 'mobile-android').\n   */\n  readonly #context: string;\n\n  /**\n   * Constructs a new RampsService object.\n   *\n   * @param args - The constructor arguments.\n   * @param args.messenger - The messenger suited for this service.\n   * @param args.environment - The environment to use for API requests.\n   * @param args.context - The context for API requests (e.g., 'mobile-ios', 'mobile-android').\n   * @param args.fetch - A function that can be used to make an HTTP request. If\n   * your JavaScript environment supports `fetch` natively, you'll probably want\n   * to pass that; otherwise you can pass an equivalent (such as `fetch` via\n   * `node-fetch`).\n   * @param args.policyOptions - Options to pass to `createServicePolicy`, which\n   * is used to wrap each request. See {@link CreateServicePolicyOptions}.\n   */\n  constructor({\n    messenger,\n    environment = RampsEnvironment.Staging,\n    context,\n    fetch: fetchFunction,\n    policyOptions = {},\n  }: {\n    messenger: RampsServiceMessenger;\n    environment?: RampsEnvironment;\n    context: string;\n    fetch: typeof fetch;\n    policyOptions?: CreateServicePolicyOptions;\n  }) {\n    this.name = serviceName;\n    this.#messenger = messenger;\n    this.#fetch = fetchFunction;\n    this.#policy = createServicePolicy(policyOptions);\n    this.#environment = environment;\n    this.#context = context;\n\n    this.#messenger.registerMethodActionHandlers(\n      this,\n      MESSENGER_EXPOSED_METHODS,\n    );\n  }\n\n  /**\n   * Registers a handler that will be called after a request returns a non-500\n   * response, causing a retry. Primarily useful in tests where timers are being\n   * mocked.\n   *\n   * @param listener - The handler to be called.\n   * @returns An object that can be used to unregister the handler. See\n   * {@link CockatielEvent}.\n   * @see {@link createServicePolicy}\n   */\n  onRetry(\n    listener: Parameters<ServicePolicy['onRetry']>[0],\n  ): ReturnType<ServicePolicy['onRetry']> {\n    return this.#policy.onRetry(listener);\n  }\n\n  /**\n   * Registers a handler that will be called after a set number of retry rounds\n   * prove that requests to the API endpoint consistently return a 5xx response.\n   *\n   * @param listener - The handler to be called.\n   * @returns An object that can be used to unregister the handler. See\n   * {@link CockatielEvent}.\n   * @see {@link createServicePolicy}\n   */\n  onBreak(\n    listener: Parameters<ServicePolicy['onBreak']>[0],\n  ): ReturnType<ServicePolicy['onBreak']> {\n    return this.#policy.onBreak(listener);\n  }\n\n  /**\n   * Registers a handler that will be called under one of two circumstances:\n   *\n   * 1. After a set number of retries prove that requests to the API\n   * consistently result in one of the following failures:\n   *    1. A connection initiation error\n   *    2. A connection reset error\n   *    3. A timeout error\n   *    4. A non-JSON response\n   *    5. A 502, 503, or 504 response\n   * 2. After a successful request is made to the API, but the response takes\n   * longer than a set duration to return.\n   *\n   * @param listener - The handler to be called.\n   * @returns An object that can be used to unregister the handler. See\n   * {@link CockatielEvent}.\n   */\n  onDegraded(\n    listener: Parameters<ServicePolicy['onDegraded']>[0],\n  ): ReturnType<ServicePolicy['onDegraded']> {\n    return this.#policy.onDegraded(listener);\n  }\n\n  /**\n   * Adds common request parameters to a URL.\n   *\n   * @param url - The URL to add parameters to.\n   * @param action - The ramp action type (optional, not all endpoints require it).\n   */\n  #addCommonParams(url: URL, action?: 'buy' | 'sell'): void {\n    if (action) {\n      url.searchParams.set('action', action);\n    }\n    url.searchParams.set('sdk', RAMPS_SDK_VERSION);\n    url.searchParams.set('controller', packageJson.version);\n    url.searchParams.set('context', this.#context);\n  }\n\n  /**\n   * Makes an API request with retry policy and error handling.\n   *\n   * @param service - The API service type (determines base URL).\n   * @param path - The endpoint path.\n   * @param options - Request options.\n   * @param options.action - The ramp action type (optional).\n   * @param options.responseType - How to parse the response ('json' or 'text').\n   * @returns The parsed response data.\n   */\n  async #request<TResponse>(\n    service: RampsApiService,\n    path: string,\n    options: {\n      action?: 'buy' | 'sell';\n      responseType: 'json' | 'text';\n    },\n  ): Promise<TResponse> {\n    return this.#policy.execute(async () => {\n      const baseUrl = getBaseUrl(this.#environment, service);\n      const url = new URL(path, baseUrl);\n      this.#addCommonParams(url, options.action);\n\n      const response = await this.#fetch(url);\n      if (!response.ok) {\n        throw new HttpError(\n          response.status,\n          `Fetching '${url.toString()}' failed with status '${response.status}'`,\n        );\n      }\n\n      return options.responseType === 'json'\n        ? (response.json() as Promise<TResponse>)\n        : (response.text() as Promise<TResponse>);\n    });\n  }\n\n  /**\n   * Makes a request to the API in order to retrieve the user's geolocation\n   * based on their IP address.\n   *\n   * @returns The user's country/region code (e.g., \"US-UT\" for Utah, USA).\n   */\n  async getGeolocation(): Promise<string> {\n    const textResponse = await this.#request<string>(\n      RampsApiService.Orders,\n      'geolocation',\n      { responseType: 'text' },\n    );\n\n    const trimmedResponse = textResponse.trim();\n    if (trimmedResponse.length > 0) {\n      return trimmedResponse;\n    }\n\n    throw new Error('Malformed response received from geolocation API');\n  }\n\n  /**\n   * Makes a request to the cached API to retrieve the list of supported countries.\n   * Filters countries based on aggregator support (preserves OnRampSDK logic).\n   *\n   * @param action - The ramp action type ('buy' or 'sell').\n   * @returns An array of countries filtered by aggregator support.\n   */\n  async getCountries(action: 'buy' | 'sell' = 'buy'): Promise<Country[]> {\n    const countries = await this.#request<Country[]>(\n      RampsApiService.Regions,\n      'regions/countries',\n      { action, responseType: 'json' },\n    );\n\n    if (!Array.isArray(countries)) {\n      throw new Error('Malformed response received from countries API');\n    }\n\n    return countries.filter((country) => {\n      if (country.states && country.states.length > 0) {\n        const hasSupportedState = country.states.some(\n          (state) => state.supported !== false,\n        );\n        return country.supported || hasSupportedState;\n      }\n\n      return country.supported;\n    });\n  }\n\n  /**\n   * Fetches eligibility information for a specific region.\n   *\n   * @param isoCode - The ISO code for the region (e.g., \"us\", \"fr\", \"us-ny\").\n   * @returns Eligibility information for the region.\n   */\n  async getEligibility(isoCode: string): Promise<Eligibility> {\n    const normalizedIsoCode = isoCode.toLowerCase().trim();\n    return this.#request<Eligibility>(\n      RampsApiService.Regions,\n      `regions/countries/${normalizedIsoCode}`,\n      { responseType: 'json' },\n    );\n  }\n\n  /**\n   * Fetches the list of available tokens for a given region and action.\n   *\n   * @param region - The region code (e.g., \"us\", \"fr\", \"us-ny\").\n   * @param action - The ramp action type ('buy' or 'sell').\n   * @returns The tokens response containing topTokens and allTokens.\n   */\n  async getTokens(\n    region: string,\n    action: 'buy' | 'sell' = 'buy',\n  ): Promise<TokensResponse> {\n    const normalizedRegion = region.toLowerCase().trim();\n    const response = await this.#request<TokensResponse>(\n      RampsApiService.Regions,\n      `regions/${normalizedRegion}/tokens`,\n      { action, responseType: 'json' },\n    );\n\n    if (!response || typeof response !== 'object') {\n      throw new Error('Malformed response received from tokens API');\n    }\n\n    if (\n      !Array.isArray(response.topTokens) ||\n      !Array.isArray(response.allTokens)\n    ) {\n      throw new Error('Malformed response received from tokens API');\n    }\n\n    return response;\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"RampsService.mjs","sourceRoot":"","sources":["../src/RampsService.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  CreateServicePolicyOptions,\n  ServicePolicy,\n} from '@metamask/controller-utils';\nimport { createServicePolicy, HttpError } from '@metamask/controller-utils';\nimport type { Messenger } from '@metamask/messenger';\n\nimport type { RampsServiceMethodActions } from './RampsService-method-action-types';\nimport packageJson from '../package.json';\n\n/**\n * Represents phone number information for a country.\n */\nexport type CountryPhone = {\n  prefix: string;\n  placeholder: string;\n  template: string;\n};\n\n/**\n * Represents a state/province within a country.\n */\nexport type State = {\n  /**\n   * State identifier. Can be in path format (e.g., \"/regions/us-ut\") or ISO code format (e.g., \"us-ut\").\n   */\n  id?: string;\n  /**\n   * State name.\n   */\n  name?: string;\n  /**\n   * ISO state code (e.g., \"UT\", \"NY\").\n   */\n  stateId?: string;\n  /**\n   * Whether this state is supported for ramps.\n   */\n  supported?: boolean;\n  /**\n   * Whether this state is recommended.\n   */\n  recommended?: boolean;\n};\n\n/**\n * Represents eligibility information for a region.\n * Returned from the /regions/countries/{isoCode} endpoint.\n */\nexport type Eligibility = {\n  /**\n   * Whether aggregator providers are available.\n   */\n  aggregator?: boolean;\n  /**\n   * Whether deposit (buy) is available.\n   */\n  deposit?: boolean;\n  /**\n   * Whether global providers are available.\n   */\n  global?: boolean;\n};\n\n/**\n * Represents a provider link.\n */\nexport type ProviderLink = {\n  name: string;\n  url: string;\n};\n\n/**\n * Represents provider logos.\n */\nexport type ProviderLogos = {\n  light: string;\n  dark: string;\n  height: number;\n  width: number;\n};\n\n/**\n * Represents a ramp provider.\n */\nexport type Provider = {\n  id: string;\n  name: string;\n  environmentType: string;\n  description: string;\n  hqAddress: string;\n  links: ProviderLink[];\n  logos: ProviderLogos;\n};\n\n/**\n * Represents a country returned from the regions/countries API.\n */\nexport type Country = {\n  /**\n   * ISO-2 country code (e.g., \"US\", \"GB\").\n   */\n  isoCode: string;\n  /**\n   * Country identifier. Can be in path format (e.g., \"/regions/us\") or ISO code format.\n   * If not provided, defaults to isoCode.\n   */\n  id?: string;\n  /**\n   * Country flag emoji or code.\n   */\n  flag: string;\n  /**\n   * Country name.\n   */\n  name: string;\n  /**\n   * Phone number information.\n   */\n  phone: CountryPhone;\n  /**\n   * Default currency code.\n   */\n  currency: string;\n  /**\n   * Whether this country is supported for ramps.\n   */\n  supported: boolean;\n  /**\n   * Whether this country is recommended.\n   */\n  recommended?: boolean;\n  /**\n   * Array of state objects.\n   */\n  states?: State[];\n};\n\n/**\n * Represents a token returned from the regions/{region}/tokens API.\n */\nexport type RampsToken = {\n  /**\n   * The asset identifier in CAIP-19 format (e.g., \"eip155:1/erc20:0x...\").\n   */\n  assetId: string;\n  /**\n   * The chain identifier in CAIP-2 format (e.g., \"eip155:1\").\n   */\n  chainId: string;\n  /**\n   * Token name (e.g., \"USD Coin\").\n   */\n  name: string;\n  /**\n   * Token symbol (e.g., \"USDC\").\n   */\n  symbol: string;\n  /**\n   * Number of decimals for the token.\n   */\n  decimals: number;\n  /**\n   * URL to the token icon.\n   */\n  iconUrl: string;\n  /**\n   * Whether this token is supported.\n   */\n  tokenSupported: boolean;\n};\n\n/**\n * Response from the regions/{region}/tokens API.\n */\nexport type TokensResponse = {\n  /**\n   * Top/popular tokens for the region.\n   */\n  topTokens: RampsToken[];\n  /**\n   * All available tokens for the region.\n   */\n  allTokens: RampsToken[];\n};\n\n/**\n * The SDK version to send with API requests. (backwards-compatibility)\n */\nexport const RAMPS_SDK_VERSION = '2.1.6';\n\n// === GENERAL ===\n\n/**\n * The name of the {@link RampsService}, used to namespace the\n * service's actions and events.\n */\nexport const serviceName = 'RampsService';\n\n/**\n * The environment to use for API requests.\n */\nexport enum RampsEnvironment {\n  Production = 'production',\n  Staging = 'staging',\n  Development = 'development',\n}\n\n/**\n * The type of ramps API service.\n * Determines which base URL to use (cache vs standard).\n */\nexport enum RampsApiService {\n  Regions = 'regions',\n  Orders = 'orders',\n}\n\n// === MESSENGER ===\n\nconst MESSENGER_EXPOSED_METHODS = [\n  'getGeolocation',\n  'getCountries',\n  'getEligibility',\n  'getTokens',\n] as const;\n\n/**\n * Actions that {@link RampsService} exposes to other consumers.\n */\nexport type RampsServiceActions = RampsServiceMethodActions;\n\n/**\n * Actions from other messengers that {@link RampsService} calls.\n */\ntype AllowedActions = never;\n\n/**\n * Events that {@link RampsService} exposes to other consumers.\n */\nexport type RampsServiceEvents = never;\n\n/**\n * Events from other messengers that {@link RampsService} subscribes to.\n */\ntype AllowedEvents = never;\n\n/**\n * The messenger which is restricted to actions and events accessed by\n * {@link RampsService}.\n */\nexport type RampsServiceMessenger = Messenger<\n  typeof serviceName,\n  RampsServiceActions | AllowedActions,\n  RampsServiceEvents | AllowedEvents\n>;\n\n// === SERVICE DEFINITION ===\n\n/**\n * Gets the base URL for API requests based on the environment and service type.\n * The Regions service uses a cache URL, while other services use the standard URL.\n *\n * @param environment - The environment to use.\n * @param service - The API service type (determines if cache URL is used).\n * @returns The base URL for API requests.\n */\nfunction getBaseUrl(\n  environment: RampsEnvironment,\n  service: RampsApiService,\n): string {\n  const cache = service === RampsApiService.Regions ? '-cache' : '';\n\n  switch (environment) {\n    case RampsEnvironment.Production:\n      return `https://on-ramp${cache}.api.cx.metamask.io`;\n    case RampsEnvironment.Staging:\n    case RampsEnvironment.Development:\n      return `https://on-ramp${cache}.uat-api.cx.metamask.io`;\n    default:\n      throw new Error(`Invalid environment: ${String(environment)}`);\n  }\n}\n\n/**\n * This service object is responsible for interacting with the Ramps API.\n *\n * @example\n *\n * ``` ts\n * import { Messenger } from '@metamask/messenger';\n * import type {\n *   RampsServiceActions,\n *   RampsServiceEvents,\n * } from '@metamask/ramps-controller';\n *\n * const rootMessenger = new Messenger<\n *   'Root',\n *   RampsServiceActions\n *   RampsServiceEvents\n * >({ namespace: 'Root' });\n * const rampsServiceMessenger = new Messenger<\n *   'RampsService',\n *   RampsServiceActions,\n *   RampsServiceEvents,\n *   typeof rootMessenger,\n * >({\n *   namespace: 'RampsService',\n *   parent: rootMessenger,\n * });\n * // Instantiate the service to register its actions on the messenger\n * new RampsService({\n *   messenger: rampsServiceMessenger,\n *   environment: RampsEnvironment.Production,\n *   context: 'mobile-ios',\n *   fetch,\n * });\n *\n * // Later...\n * // Get the user's geolocation\n * const geolocation = await rootMessenger.call(\n *   'RampsService:getGeolocation',\n * );\n * // ... Do something with the geolocation ...\n * ```\n */\nexport class RampsService {\n  /**\n   * The name of the service.\n   */\n  readonly name: typeof serviceName;\n\n  /**\n   * The messenger suited for this service.\n   */\n  readonly #messenger: ConstructorParameters<\n    typeof RampsService\n  >[0]['messenger'];\n\n  /**\n   * A function that can be used to make an HTTP request.\n   */\n  readonly #fetch: ConstructorParameters<typeof RampsService>[0]['fetch'];\n\n  /**\n   * The policy that wraps the request.\n   *\n   * @see {@link createServicePolicy}\n   */\n  readonly #policy: ServicePolicy;\n\n  /**\n   * The environment used for API requests.\n   */\n  readonly #environment: RampsEnvironment;\n\n  /**\n   * The context for API requests (e.g., 'mobile-ios', 'mobile-android').\n   */\n  readonly #context: string;\n\n  /**\n   * Constructs a new RampsService object.\n   *\n   * @param args - The constructor arguments.\n   * @param args.messenger - The messenger suited for this service.\n   * @param args.environment - The environment to use for API requests.\n   * @param args.context - The context for API requests (e.g., 'mobile-ios', 'mobile-android').\n   * @param args.fetch - A function that can be used to make an HTTP request. If\n   * your JavaScript environment supports `fetch` natively, you'll probably want\n   * to pass that; otherwise you can pass an equivalent (such as `fetch` via\n   * `node-fetch`).\n   * @param args.policyOptions - Options to pass to `createServicePolicy`, which\n   * is used to wrap each request. See {@link CreateServicePolicyOptions}.\n   */\n  constructor({\n    messenger,\n    environment = RampsEnvironment.Staging,\n    context,\n    fetch: fetchFunction,\n    policyOptions = {},\n  }: {\n    messenger: RampsServiceMessenger;\n    environment?: RampsEnvironment;\n    context: string;\n    fetch: typeof fetch;\n    policyOptions?: CreateServicePolicyOptions;\n  }) {\n    this.name = serviceName;\n    this.#messenger = messenger;\n    this.#fetch = fetchFunction;\n    this.#policy = createServicePolicy(policyOptions);\n    this.#environment = environment;\n    this.#context = context;\n\n    this.#messenger.registerMethodActionHandlers(\n      this,\n      MESSENGER_EXPOSED_METHODS,\n    );\n  }\n\n  /**\n   * Registers a handler that will be called after a request returns a non-500\n   * response, causing a retry. Primarily useful in tests where timers are being\n   * mocked.\n   *\n   * @param listener - The handler to be called.\n   * @returns An object that can be used to unregister the handler. See\n   * {@link CockatielEvent}.\n   * @see {@link createServicePolicy}\n   */\n  onRetry(\n    listener: Parameters<ServicePolicy['onRetry']>[0],\n  ): ReturnType<ServicePolicy['onRetry']> {\n    return this.#policy.onRetry(listener);\n  }\n\n  /**\n   * Registers a handler that will be called after a set number of retry rounds\n   * prove that requests to the API endpoint consistently return a 5xx response.\n   *\n   * @param listener - The handler to be called.\n   * @returns An object that can be used to unregister the handler. See\n   * {@link CockatielEvent}.\n   * @see {@link createServicePolicy}\n   */\n  onBreak(\n    listener: Parameters<ServicePolicy['onBreak']>[0],\n  ): ReturnType<ServicePolicy['onBreak']> {\n    return this.#policy.onBreak(listener);\n  }\n\n  /**\n   * Registers a handler that will be called under one of two circumstances:\n   *\n   * 1. After a set number of retries prove that requests to the API\n   * consistently result in one of the following failures:\n   *    1. A connection initiation error\n   *    2. A connection reset error\n   *    3. A timeout error\n   *    4. A non-JSON response\n   *    5. A 502, 503, or 504 response\n   * 2. After a successful request is made to the API, but the response takes\n   * longer than a set duration to return.\n   *\n   * @param listener - The handler to be called.\n   * @returns An object that can be used to unregister the handler. See\n   * {@link CockatielEvent}.\n   */\n  onDegraded(\n    listener: Parameters<ServicePolicy['onDegraded']>[0],\n  ): ReturnType<ServicePolicy['onDegraded']> {\n    return this.#policy.onDegraded(listener);\n  }\n\n  /**\n   * Adds common request parameters to a URL.\n   *\n   * @param url - The URL to add parameters to.\n   * @param action - The ramp action type (optional, not all endpoints require it).\n   */\n  #addCommonParams(url: URL, action?: 'buy' | 'sell'): void {\n    if (action) {\n      url.searchParams.set('action', action);\n    }\n    url.searchParams.set('sdk', RAMPS_SDK_VERSION);\n    url.searchParams.set('controller', packageJson.version);\n    url.searchParams.set('context', this.#context);\n  }\n\n  /**\n   * Makes an API request with retry policy and error handling.\n   *\n   * @param service - The API service type (determines base URL).\n   * @param path - The endpoint path.\n   * @param options - Request options.\n   * @param options.action - The ramp action type (optional).\n   * @param options.responseType - How to parse the response ('json' or 'text').\n   * @returns The parsed response data.\n   */\n  async #request<TResponse>(\n    service: RampsApiService,\n    path: string,\n    options: {\n      action?: 'buy' | 'sell';\n      responseType: 'json' | 'text';\n    },\n  ): Promise<TResponse> {\n    return this.#policy.execute(async () => {\n      const baseUrl = getBaseUrl(this.#environment, service);\n      const url = new URL(path, baseUrl);\n      this.#addCommonParams(url, options.action);\n\n      const response = await this.#fetch(url);\n      if (!response.ok) {\n        throw new HttpError(\n          response.status,\n          `Fetching '${url.toString()}' failed with status '${response.status}'`,\n        );\n      }\n\n      return options.responseType === 'json'\n        ? (response.json() as Promise<TResponse>)\n        : (response.text() as Promise<TResponse>);\n    });\n  }\n\n  /**\n   * Makes a request to the API in order to retrieve the user's geolocation\n   * based on their IP address.\n   *\n   * @returns The user's country/region code (e.g., \"US-UT\" for Utah, USA).\n   */\n  async getGeolocation(): Promise<string> {\n    const textResponse = await this.#request<string>(\n      RampsApiService.Orders,\n      'geolocation',\n      { responseType: 'text' },\n    );\n\n    const trimmedResponse = textResponse.trim();\n    if (trimmedResponse.length > 0) {\n      return trimmedResponse;\n    }\n\n    throw new Error('Malformed response received from geolocation API');\n  }\n\n  /**\n   * Makes a request to the cached API to retrieve the list of supported countries.\n   * Filters countries based on aggregator support (preserves OnRampSDK logic).\n   *\n   * @param action - The ramp action type ('buy' or 'sell').\n   * @returns An array of countries filtered by aggregator support.\n   */\n  async getCountries(action: 'buy' | 'sell' = 'buy'): Promise<Country[]> {\n    const countries = await this.#request<Country[]>(\n      RampsApiService.Regions,\n      '/v2/regions/countries',\n      { action, responseType: 'json' },\n    );\n\n    if (!Array.isArray(countries)) {\n      throw new Error('Malformed response received from countries API');\n    }\n\n    return countries.filter((country) => {\n      if (country.states && country.states.length > 0) {\n        const hasSupportedState = country.states.some(\n          (state) => state.supported !== false,\n        );\n        return country.supported || hasSupportedState;\n      }\n\n      return country.supported;\n    });\n  }\n\n  /**\n   * Fetches eligibility information for a specific region.\n   *\n   * @param isoCode - The ISO code for the region (e.g., \"us\", \"fr\", \"us-ny\").\n   * @returns Eligibility information for the region.\n   */\n  async getEligibility(isoCode: string): Promise<Eligibility> {\n    const normalizedIsoCode = isoCode.toLowerCase().trim();\n    return this.#request<Eligibility>(\n      RampsApiService.Regions,\n      `regions/countries/${normalizedIsoCode}`,\n      { responseType: 'json' },\n    );\n  }\n\n  /**\n   * Fetches the list of available tokens for a given region and action.\n   *\n   * @param region - The region code (e.g., \"us\", \"fr\", \"us-ny\").\n   * @param action - The ramp action type ('buy' or 'sell').\n   * @returns The tokens response containing topTokens and allTokens.\n   */\n  async getTokens(\n    region: string,\n    action: 'buy' | 'sell' = 'buy',\n  ): Promise<TokensResponse> {\n    const normalizedRegion = region.toLowerCase().trim();\n    const response = await this.#request<TokensResponse>(\n      RampsApiService.Regions,\n      `regions/${normalizedRegion}/tokens`,\n      { action, responseType: 'json' },\n    );\n\n    if (!response || typeof response !== 'object') {\n      throw new Error('Malformed response received from tokens API');\n    }\n\n    if (\n      !Array.isArray(response.topTokens) ||\n      !Array.isArray(response.allTokens)\n    ) {\n      throw new Error('Malformed response received from tokens API');\n    }\n\n    return response;\n  }\n}\n"]}
\ No newline at end of file
diff --git a/dist/index.cjs.map b/dist/index.cjs.map
index 772a1a44c8e637b48df931cf974adf8e2459411d..34694c8a015ec3886084fde98f50ab2a8b2c7405 100644
--- a/dist/index.cjs.map
+++ b/dist/index.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"index.cjs","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;;AASA,yDAG2B;AAFzB,kHAAA,eAAe,OAAA;AACf,iIAAA,8BAA8B,OAAA;AAWhC,mDAKwB;AAJtB,4GAAA,YAAY,OAAA;AACZ,gHAAA,gBAAgB,OAAA;AAChB,+GAAA,eAAe,OAAA;AACf,iHAAA,iBAAiB,OAAA;AAanB,mDASwB;AARtB,6GAAA,aAAa,OAAA;AACb,yHAAA,yBAAyB,OAAA;AACzB,8HAAA,8BAA8B,OAAA;AAC9B,8GAAA,cAAc,OAAA;AACd,8GAAA,cAAc,OAAA;AACd,kHAAA,kBAAkB,OAAA;AAClB,kHAAA,kBAAkB,OAAA;AAClB,gHAAA,gBAAgB,OAAA;AAGlB,6CAAoD;AAA3C,kHAAA,qBAAqB,OAAA","sourcesContent":["export type {\n  RampsControllerActions,\n  RampsControllerEvents,\n  RampsControllerGetStateAction,\n  RampsControllerMessenger,\n  RampsControllerState,\n  RampsControllerStateChangeEvent,\n  RampsControllerOptions,\n} from './RampsController';\nexport {\n  RampsController,\n  getDefaultRampsControllerState,\n} from './RampsController';\nexport type {\n  RampsServiceActions,\n  RampsServiceEvents,\n  RampsServiceMessenger,\n  Country,\n  State,\n  Eligibility,\n  CountryPhone,\n} from './RampsService';\nexport {\n  RampsService,\n  RampsEnvironment,\n  RampsApiService,\n  RAMPS_SDK_VERSION,\n} from './RampsService';\nexport type {\n  RampsServiceGetGeolocationAction,\n  RampsServiceGetCountriesAction,\n  RampsServiceGetEligibilityAction,\n} from './RampsService-method-action-types';\nexport type {\n  RequestCache,\n  RequestState,\n  ExecuteRequestOptions,\n  PendingRequest,\n} from './RequestCache';\nexport {\n  RequestStatus,\n  DEFAULT_REQUEST_CACHE_TTL,\n  DEFAULT_REQUEST_CACHE_MAX_SIZE,\n  createCacheKey,\n  isCacheExpired,\n  createLoadingState,\n  createSuccessState,\n  createErrorState,\n} from './RequestCache';\nexport type { RequestSelectorResult } from './selectors';\nexport { createRequestSelector } from './selectors';\n"]}
\ No newline at end of file
+{"version":3,"file":"index.cjs","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;;AAUA,yDAG2B;AAFzB,kHAAA,eAAe,OAAA;AACf,iIAAA,8BAA8B,OAAA;AAchC,mDAKwB;AAJtB,4GAAA,YAAY,OAAA;AACZ,gHAAA,gBAAgB,OAAA;AAChB,+GAAA,eAAe,OAAA;AACf,iHAAA,iBAAiB,OAAA;AAanB,mDASwB;AARtB,6GAAA,aAAa,OAAA;AACb,yHAAA,yBAAyB,OAAA;AACzB,8HAAA,8BAA8B,OAAA;AAC9B,8GAAA,cAAc,OAAA;AACd,8GAAA,cAAc,OAAA;AACd,kHAAA,kBAAkB,OAAA;AAClB,kHAAA,kBAAkB,OAAA;AAClB,gHAAA,gBAAgB,OAAA;AAGlB,6CAAoD;AAA3C,kHAAA,qBAAqB,OAAA","sourcesContent":["export type {\n  RampsControllerActions,\n  RampsControllerEvents,\n  RampsControllerGetStateAction,\n  RampsControllerMessenger,\n  RampsControllerState,\n  RampsControllerStateChangeEvent,\n  RampsControllerOptions,\n  UserRegion,\n} from './RampsController';\nexport {\n  RampsController,\n  getDefaultRampsControllerState,\n} from './RampsController';\nexport type {\n  RampsServiceActions,\n  RampsServiceEvents,\n  RampsServiceMessenger,\n  Country,\n  State,\n  Eligibility,\n  CountryPhone,\n  Provider,\n  ProviderLink,\n  ProviderLogos,\n} from './RampsService';\nexport {\n  RampsService,\n  RampsEnvironment,\n  RampsApiService,\n  RAMPS_SDK_VERSION,\n} from './RampsService';\nexport type {\n  RampsServiceGetGeolocationAction,\n  RampsServiceGetCountriesAction,\n  RampsServiceGetEligibilityAction,\n} from './RampsService-method-action-types';\nexport type {\n  RequestCache,\n  RequestState,\n  ExecuteRequestOptions,\n  PendingRequest,\n} from './RequestCache';\nexport {\n  RequestStatus,\n  DEFAULT_REQUEST_CACHE_TTL,\n  DEFAULT_REQUEST_CACHE_MAX_SIZE,\n  createCacheKey,\n  isCacheExpired,\n  createLoadingState,\n  createSuccessState,\n  createErrorState,\n} from './RequestCache';\nexport type { RequestSelectorResult } from './selectors';\nexport { createRequestSelector } from './selectors';\n"]}
\ No newline at end of file
diff --git a/dist/index.d.cts b/dist/index.d.cts
index e49288b4f07e1fcfd29634f597d5f5cfee728374..ab56eb25d3116d17542f76182cf83cc5601d51b2 100644
--- a/dist/index.d.cts
+++ b/dist/index.d.cts
@@ -1,6 +1,6 @@
-export type { RampsControllerActions, RampsControllerEvents, RampsControllerGetStateAction, RampsControllerMessenger, RampsControllerState, RampsControllerStateChangeEvent, RampsControllerOptions, } from "./RampsController.cjs";
+export type { RampsControllerActions, RampsControllerEvents, RampsControllerGetStateAction, RampsControllerMessenger, RampsControllerState, RampsControllerStateChangeEvent, RampsControllerOptions, UserRegion, } from "./RampsController.cjs";
 export { RampsController, getDefaultRampsControllerState, } from "./RampsController.cjs";
-export type { RampsServiceActions, RampsServiceEvents, RampsServiceMessenger, Country, State, Eligibility, CountryPhone, } from "./RampsService.cjs";
+export type { RampsServiceActions, RampsServiceEvents, RampsServiceMessenger, Country, State, Eligibility, CountryPhone, Provider, ProviderLink, ProviderLogos, } from "./RampsService.cjs";
 export { RampsService, RampsEnvironment, RampsApiService, RAMPS_SDK_VERSION, } from "./RampsService.cjs";
 export type { RampsServiceGetGeolocationAction, RampsServiceGetCountriesAction, RampsServiceGetEligibilityAction, } from "./RampsService-method-action-types.cjs";
 export type { RequestCache, RequestState, ExecuteRequestOptions, PendingRequest, } from "./RequestCache.cjs";
diff --git a/dist/index.d.cts.map b/dist/index.d.cts.map
index 21c08db84557ed9943468978722776acbd2cc064..04b486a6139ea65899a18855c98b792b20240dcd 100644
--- a/dist/index.d.cts.map
+++ b/dist/index.d.cts.map
@@ -1 +1 @@
-{"version":3,"file":"index.d.cts","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"AAAA,YAAY,EACV,sBAAsB,EACtB,qBAAqB,EACrB,6BAA6B,EAC7B,wBAAwB,EACxB,oBAAoB,EACpB,+BAA+B,EAC/B,sBAAsB,GACvB,8BAA0B;AAC3B,OAAO,EACL,eAAe,EACf,8BAA8B,GAC/B,8BAA0B;AAC3B,YAAY,EACV,mBAAmB,EACnB,kBAAkB,EAClB,qBAAqB,EACrB,OAAO,EACP,KAAK,EACL,WAAW,EACX,YAAY,GACb,2BAAuB;AACxB,OAAO,EACL,YAAY,EACZ,gBAAgB,EAChB,eAAe,EACf,iBAAiB,GAClB,2BAAuB;AACxB,YAAY,EACV,gCAAgC,EAChC,8BAA8B,EAC9B,gCAAgC,GACjC,+CAA2C;AAC5C,YAAY,EACV,YAAY,EACZ,YAAY,EACZ,qBAAqB,EACrB,cAAc,GACf,2BAAuB;AACxB,OAAO,EACL,aAAa,EACb,yBAAyB,EACzB,8BAA8B,EAC9B,cAAc,EACd,cAAc,EACd,kBAAkB,EAClB,kBAAkB,EAClB,gBAAgB,GACjB,2BAAuB;AACxB,YAAY,EAAE,qBAAqB,EAAE,wBAAoB;AACzD,OAAO,EAAE,qBAAqB,EAAE,wBAAoB"}
\ No newline at end of file
+{"version":3,"file":"index.d.cts","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"AAAA,YAAY,EACV,sBAAsB,EACtB,qBAAqB,EACrB,6BAA6B,EAC7B,wBAAwB,EACxB,oBAAoB,EACpB,+BAA+B,EAC/B,sBAAsB,EACtB,UAAU,GACX,8BAA0B;AAC3B,OAAO,EACL,eAAe,EACf,8BAA8B,GAC/B,8BAA0B;AAC3B,YAAY,EACV,mBAAmB,EACnB,kBAAkB,EAClB,qBAAqB,EACrB,OAAO,EACP,KAAK,EACL,WAAW,EACX,YAAY,EACZ,QAAQ,EACR,YAAY,EACZ,aAAa,GACd,2BAAuB;AACxB,OAAO,EACL,YAAY,EACZ,gBAAgB,EAChB,eAAe,EACf,iBAAiB,GAClB,2BAAuB;AACxB,YAAY,EACV,gCAAgC,EAChC,8BAA8B,EAC9B,gCAAgC,GACjC,+CAA2C;AAC5C,YAAY,EACV,YAAY,EACZ,YAAY,EACZ,qBAAqB,EACrB,cAAc,GACf,2BAAuB;AACxB,OAAO,EACL,aAAa,EACb,yBAAyB,EACzB,8BAA8B,EAC9B,cAAc,EACd,cAAc,EACd,kBAAkB,EAClB,kBAAkB,EAClB,gBAAgB,GACjB,2BAAuB;AACxB,YAAY,EAAE,qBAAqB,EAAE,wBAAoB;AACzD,OAAO,EAAE,qBAAqB,EAAE,wBAAoB"}
\ No newline at end of file
diff --git a/dist/index.d.mts b/dist/index.d.mts
index fe0d1ac902d8410874bc5f726c39fde4c2ca96e0..e0e27e81805323f20ee2c8e79577b1591bac75b7 100644
--- a/dist/index.d.mts
+++ b/dist/index.d.mts
@@ -1,6 +1,6 @@
-export type { RampsControllerActions, RampsControllerEvents, RampsControllerGetStateAction, RampsControllerMessenger, RampsControllerState, RampsControllerStateChangeEvent, RampsControllerOptions, } from "./RampsController.mjs";
+export type { RampsControllerActions, RampsControllerEvents, RampsControllerGetStateAction, RampsControllerMessenger, RampsControllerState, RampsControllerStateChangeEvent, RampsControllerOptions, UserRegion, } from "./RampsController.mjs";
 export { RampsController, getDefaultRampsControllerState, } from "./RampsController.mjs";
-export type { RampsServiceActions, RampsServiceEvents, RampsServiceMessenger, Country, State, Eligibility, CountryPhone, } from "./RampsService.mjs";
+export type { RampsServiceActions, RampsServiceEvents, RampsServiceMessenger, Country, State, Eligibility, CountryPhone, Provider, ProviderLink, ProviderLogos, } from "./RampsService.mjs";
 export { RampsService, RampsEnvironment, RampsApiService, RAMPS_SDK_VERSION, } from "./RampsService.mjs";
 export type { RampsServiceGetGeolocationAction, RampsServiceGetCountriesAction, RampsServiceGetEligibilityAction, } from "./RampsService-method-action-types.mjs";
 export type { RequestCache, RequestState, ExecuteRequestOptions, PendingRequest, } from "./RequestCache.mjs";
diff --git a/dist/index.d.mts.map b/dist/index.d.mts.map
index 290302156df62c0d76aab2bac4a244407ee4fa8d..a85165ba23c5142710468702d30da3248943a376 100644
--- a/dist/index.d.mts.map
+++ b/dist/index.d.mts.map
@@ -1 +1 @@
-{"version":3,"file":"index.d.mts","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"AAAA,YAAY,EACV,sBAAsB,EACtB,qBAAqB,EACrB,6BAA6B,EAC7B,wBAAwB,EACxB,oBAAoB,EACpB,+BAA+B,EAC/B,sBAAsB,GACvB,8BAA0B;AAC3B,OAAO,EACL,eAAe,EACf,8BAA8B,GAC/B,8BAA0B;AAC3B,YAAY,EACV,mBAAmB,EACnB,kBAAkB,EAClB,qBAAqB,EACrB,OAAO,EACP,KAAK,EACL,WAAW,EACX,YAAY,GACb,2BAAuB;AACxB,OAAO,EACL,YAAY,EACZ,gBAAgB,EAChB,eAAe,EACf,iBAAiB,GAClB,2BAAuB;AACxB,YAAY,EACV,gCAAgC,EAChC,8BAA8B,EAC9B,gCAAgC,GACjC,+CAA2C;AAC5C,YAAY,EACV,YAAY,EACZ,YAAY,EACZ,qBAAqB,EACrB,cAAc,GACf,2BAAuB;AACxB,OAAO,EACL,aAAa,EACb,yBAAyB,EACzB,8BAA8B,EAC9B,cAAc,EACd,cAAc,EACd,kBAAkB,EAClB,kBAAkB,EAClB,gBAAgB,GACjB,2BAAuB;AACxB,YAAY,EAAE,qBAAqB,EAAE,wBAAoB;AACzD,OAAO,EAAE,qBAAqB,EAAE,wBAAoB"}
\ No newline at end of file
+{"version":3,"file":"index.d.mts","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"AAAA,YAAY,EACV,sBAAsB,EACtB,qBAAqB,EACrB,6BAA6B,EAC7B,wBAAwB,EACxB,oBAAoB,EACpB,+BAA+B,EAC/B,sBAAsB,EACtB,UAAU,GACX,8BAA0B;AAC3B,OAAO,EACL,eAAe,EACf,8BAA8B,GAC/B,8BAA0B;AAC3B,YAAY,EACV,mBAAmB,EACnB,kBAAkB,EAClB,qBAAqB,EACrB,OAAO,EACP,KAAK,EACL,WAAW,EACX,YAAY,EACZ,QAAQ,EACR,YAAY,EACZ,aAAa,GACd,2BAAuB;AACxB,OAAO,EACL,YAAY,EACZ,gBAAgB,EAChB,eAAe,EACf,iBAAiB,GAClB,2BAAuB;AACxB,YAAY,EACV,gCAAgC,EAChC,8BAA8B,EAC9B,gCAAgC,GACjC,+CAA2C;AAC5C,YAAY,EACV,YAAY,EACZ,YAAY,EACZ,qBAAqB,EACrB,cAAc,GACf,2BAAuB;AACxB,OAAO,EACL,aAAa,EACb,yBAAyB,EACzB,8BAA8B,EAC9B,cAAc,EACd,cAAc,EACd,kBAAkB,EAClB,kBAAkB,EAClB,gBAAgB,GACjB,2BAAuB;AACxB,YAAY,EAAE,qBAAqB,EAAE,wBAAoB;AACzD,OAAO,EAAE,qBAAqB,EAAE,wBAAoB"}
\ No newline at end of file
diff --git a/dist/index.mjs.map b/dist/index.mjs.map
index 74d87cf1cf26c01ac0bc9ff866910d9a6a2cc4b4..caf43795ea38d7ae17b3e6ce5debbf55dda46a94 100644
--- a/dist/index.mjs.map
+++ b/dist/index.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"index.mjs","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"AASA,OAAO,EACL,eAAe,EACf,8BAA8B,EAC/B,8BAA0B;AAU3B,OAAO,EACL,YAAY,EACZ,gBAAgB,EAChB,eAAe,EACf,iBAAiB,EAClB,2BAAuB;AAYxB,OAAO,EACL,aAAa,EACb,yBAAyB,EACzB,8BAA8B,EAC9B,cAAc,EACd,cAAc,EACd,kBAAkB,EAClB,kBAAkB,EAClB,gBAAgB,EACjB,2BAAuB;AAExB,OAAO,EAAE,qBAAqB,EAAE,wBAAoB","sourcesContent":["export type {\n  RampsControllerActions,\n  RampsControllerEvents,\n  RampsControllerGetStateAction,\n  RampsControllerMessenger,\n  RampsControllerState,\n  RampsControllerStateChangeEvent,\n  RampsControllerOptions,\n} from './RampsController';\nexport {\n  RampsController,\n  getDefaultRampsControllerState,\n} from './RampsController';\nexport type {\n  RampsServiceActions,\n  RampsServiceEvents,\n  RampsServiceMessenger,\n  Country,\n  State,\n  Eligibility,\n  CountryPhone,\n} from './RampsService';\nexport {\n  RampsService,\n  RampsEnvironment,\n  RampsApiService,\n  RAMPS_SDK_VERSION,\n} from './RampsService';\nexport type {\n  RampsServiceGetGeolocationAction,\n  RampsServiceGetCountriesAction,\n  RampsServiceGetEligibilityAction,\n} from './RampsService-method-action-types';\nexport type {\n  RequestCache,\n  RequestState,\n  ExecuteRequestOptions,\n  PendingRequest,\n} from './RequestCache';\nexport {\n  RequestStatus,\n  DEFAULT_REQUEST_CACHE_TTL,\n  DEFAULT_REQUEST_CACHE_MAX_SIZE,\n  createCacheKey,\n  isCacheExpired,\n  createLoadingState,\n  createSuccessState,\n  createErrorState,\n} from './RequestCache';\nexport type { RequestSelectorResult } from './selectors';\nexport { createRequestSelector } from './selectors';\n"]}
\ No newline at end of file
+{"version":3,"file":"index.mjs","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"AAUA,OAAO,EACL,eAAe,EACf,8BAA8B,EAC/B,8BAA0B;AAa3B,OAAO,EACL,YAAY,EACZ,gBAAgB,EAChB,eAAe,EACf,iBAAiB,EAClB,2BAAuB;AAYxB,OAAO,EACL,aAAa,EACb,yBAAyB,EACzB,8BAA8B,EAC9B,cAAc,EACd,cAAc,EACd,kBAAkB,EAClB,kBAAkB,EAClB,gBAAgB,EACjB,2BAAuB;AAExB,OAAO,EAAE,qBAAqB,EAAE,wBAAoB","sourcesContent":["export type {\n  RampsControllerActions,\n  RampsControllerEvents,\n  RampsControllerGetStateAction,\n  RampsControllerMessenger,\n  RampsControllerState,\n  RampsControllerStateChangeEvent,\n  RampsControllerOptions,\n  UserRegion,\n} from './RampsController';\nexport {\n  RampsController,\n  getDefaultRampsControllerState,\n} from './RampsController';\nexport type {\n  RampsServiceActions,\n  RampsServiceEvents,\n  RampsServiceMessenger,\n  Country,\n  State,\n  Eligibility,\n  CountryPhone,\n  Provider,\n  ProviderLink,\n  ProviderLogos,\n} from './RampsService';\nexport {\n  RampsService,\n  RampsEnvironment,\n  RampsApiService,\n  RAMPS_SDK_VERSION,\n} from './RampsService';\nexport type {\n  RampsServiceGetGeolocationAction,\n  RampsServiceGetCountriesAction,\n  RampsServiceGetEligibilityAction,\n} from './RampsService-method-action-types';\nexport type {\n  RequestCache,\n  RequestState,\n  ExecuteRequestOptions,\n  PendingRequest,\n} from './RequestCache';\nexport {\n  RequestStatus,\n  DEFAULT_REQUEST_CACHE_TTL,\n  DEFAULT_REQUEST_CACHE_MAX_SIZE,\n  createCacheKey,\n  isCacheExpired,\n  createLoadingState,\n  createSuccessState,\n  createErrorState,\n} from './RequestCache';\nexport type { RequestSelectorResult } from './selectors';\nexport { createRequestSelector } from './selectors';\n"]}
\ No newline at end of file
