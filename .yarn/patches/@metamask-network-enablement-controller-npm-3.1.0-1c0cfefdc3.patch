diff --git a/dist/NetworkEnablementController.cjs b/dist/NetworkEnablementController.cjs
index d4a40bea9e4ed3c28e347d96e309efe1ff889e81..42c0c72bdf04fadb12c3ef9db3ffdc00cce0eed9 100644
--- a/dist/NetworkEnablementController.cjs
+++ b/dist/NetworkEnablementController.cjs
@@ -19,30 +19,35 @@ const controllerName = 'NetworkEnablementController';
  *
  * @returns The default state with pre-enabled networks.
  */
-const getDefaultNetworkEnablementControllerState = () => ({
-    enabledNetworkMap: {
-        [utils_1.KnownCaipNamespace.Eip155]: {
-            [controller_utils_1.ChainId[controller_utils_1.BuiltInNetworkName.Mainnet]]: true,
-            [controller_utils_1.ChainId[controller_utils_1.BuiltInNetworkName.LineaMainnet]]: true,
-            [controller_utils_1.ChainId[controller_utils_1.BuiltInNetworkName.BaseMainnet]]: true,
-        },
-        [utils_1.KnownCaipNamespace.Solana]: {
-            [keyring_api_1.SolScope.Mainnet]: true,
-            [keyring_api_1.SolScope.Testnet]: false,
-            [keyring_api_1.SolScope.Devnet]: false,
-        },
-        [utils_1.KnownCaipNamespace.Bip122]: {
-            [keyring_api_1.BtcScope.Mainnet]: true,
-            [keyring_api_1.BtcScope.Testnet]: false,
-            [keyring_api_1.BtcScope.Signet]: false,
-        },
-        [utils_1.KnownCaipNamespace.Tron]: {
-            [keyring_api_1.TrxScope.Mainnet]: true,
-            [keyring_api_1.TrxScope.Nile]: false,
-            [keyring_api_1.TrxScope.Shasta]: false,
+const getDefaultNetworkEnablementControllerState = () => {
+    // Programmatically enable all popular networks for performance testing
+    const enabledEvmNetworks = constants_1.POPULAR_NETWORKS.reduce((acc, chainId) => ({
+        ...acc,
+        [chainId]: true,
+    }), {});
+    console.log('[NetworkEnablementController] Generating default state with', constants_1.POPULAR_NETWORKS.length, 'popular networks');
+    console.log('[NetworkEnablementController] Enabled EVM networks:', Object.keys(enabledEvmNetworks));
+    return {
+        enabledNetworkMap: {
+            [utils_1.KnownCaipNamespace.Eip155]: enabledEvmNetworks,
+            [utils_1.KnownCaipNamespace.Solana]: {
+                [keyring_api_1.SolScope.Mainnet]: true,
+                [keyring_api_1.SolScope.Testnet]: false,
+                [keyring_api_1.SolScope.Devnet]: false,
+            },
+            [utils_1.KnownCaipNamespace.Bip122]: {
+                [keyring_api_1.BtcScope.Mainnet]: true,
+                [keyring_api_1.BtcScope.Testnet]: false,
+                [keyring_api_1.BtcScope.Signet]: false,
+            },
+            [utils_1.KnownCaipNamespace.Tron]: {
+                [keyring_api_1.TrxScope.Mainnet]: true,
+                [keyring_api_1.TrxScope.Nile]: false,
+                [keyring_api_1.TrxScope.Shasta]: false,
+            },
         },
-    },
-});
+    };
+};
 // Metadata for the controller state
 const metadata = {
     enabledNetworkMap: {
@@ -70,14 +75,22 @@ class NetworkEnablementController extends base_controller_1.BaseController {
      * @param args.state - Initial state to set on this controller.
      */
     constructor({ messenger, state, }) {
+        const defaultState = getDefaultNetworkEnablementControllerState();
+        const finalState = {
+            ...defaultState,
+            ...state,
+        };
+        console.log('[NetworkEnablementController] Constructor - passed state:', state ? 'YES (will override defaults)' : 'NO (using defaults)');
+        console.log('[NetworkEnablementController] Constructor - default EVM networks count:', Object.keys(defaultState.enabledNetworkMap[utils_1.KnownCaipNamespace.Eip155])
+            .length);
+        console.log('[NetworkEnablementController] Constructor - final EVM networks count:', Object.keys(finalState.enabledNetworkMap[utils_1.KnownCaipNamespace.Eip155])
+            .length);
+        console.log('[NetworkEnablementController] Constructor - final enabled EVM networks:', Object.keys(finalState.enabledNetworkMap[utils_1.KnownCaipNamespace.Eip155]));
         super({
             messenger,
             metadata,
             name: controllerName,
-            state: {
-                ...getDefaultNetworkEnablementControllerState(),
-                ...state,
-            },
+            state: finalState,
         });
         _NetworkEnablementController_instances.add(this);
         messenger.subscribe('NetworkController:networkAdded', ({ chainId }) => {
@@ -105,20 +118,21 @@ class NetworkEnablementController extends base_controller_1.BaseController {
      */
     enableNetwork(chainId) {
         const { namespace, storageKey } = (0, utils_2.deriveKeys)(chainId);
-        this.update((s) => {
+        console.log('[NetworkEnablementController] enableNetwork called for:', chainId, 'namespace:', namespace, 'storageKey:', storageKey);
+        this.update((state) => {
             // disable all networks in all namespaces first
-            Object.keys(s.enabledNetworkMap).forEach((ns) => {
-                Object.keys(s.enabledNetworkMap[ns]).forEach((key) => {
-                    s.enabledNetworkMap[ns][key] = false;
+            Object.keys(state.enabledNetworkMap).forEach((ns) => {
+                Object.keys(state.enabledNetworkMap[ns]).forEach((key) => {
+                    state.enabledNetworkMap[ns][key] = false;
                 });
             });
             // if the namespace bucket does not exist, return
             // new nemespace are added only when a new network is added
-            if (!s.enabledNetworkMap[namespace]) {
+            if (!state.enabledNetworkMap[namespace]) {
                 return;
             }
             // enable the network
-            s.enabledNetworkMap[namespace][storageKey] = true;
+            state.enabledNetworkMap[namespace][storageKey] = true;
         });
     }
     /**
@@ -143,17 +157,17 @@ class NetworkEnablementController extends base_controller_1.BaseController {
         if (derivedNamespace !== namespace) {
             throw new Error(`Chain ID ${chainId} belongs to namespace ${derivedNamespace}, but namespace ${namespace} was specified`);
         }
-        this.update((s) => {
+        this.update((state) => {
             // Ensure the namespace bucket exists
-            __classPrivateFieldGet(this, _NetworkEnablementController_instances, "m", _NetworkEnablementController_ensureNamespaceBucket).call(this, s, namespace);
+            __classPrivateFieldGet(this, _NetworkEnablementController_instances, "m", _NetworkEnablementController_ensureNamespaceBucket).call(this, state, namespace);
             // Disable all networks in the specified namespace first
-            if (s.enabledNetworkMap[namespace]) {
-                Object.keys(s.enabledNetworkMap[namespace]).forEach((key) => {
-                    s.enabledNetworkMap[namespace][key] = false;
+            if (state.enabledNetworkMap[namespace]) {
+                Object.keys(state.enabledNetworkMap[namespace]).forEach((key) => {
+                    state.enabledNetworkMap[namespace][key] = false;
                 });
             }
             // Enable the target network in the specified namespace
-            s.enabledNetworkMap[namespace][storageKey] = true;
+            state.enabledNetworkMap[namespace][storageKey] = true;
         });
     }
     /**
@@ -167,51 +181,62 @@ class NetworkEnablementController extends base_controller_1.BaseController {
      * Popular networks that don't exist in NetworkController or MultichainNetworkController configurations will be skipped silently.
      */
     enableAllPopularNetworks() {
-        this.update((s) => {
+        console.log('[NetworkEnablementController] enableAllPopularNetworks called - attempting to enable', constants_1.POPULAR_NETWORKS.length, 'networks');
+        this.update((state) => {
             // First disable all networks across all namespaces
-            Object.keys(s.enabledNetworkMap).forEach((ns) => {
-                Object.keys(s.enabledNetworkMap[ns]).forEach((key) => {
-                    s.enabledNetworkMap[ns][key] = false;
+            Object.keys(state.enabledNetworkMap).forEach((ns) => {
+                Object.keys(state.enabledNetworkMap[ns]).forEach((key) => {
+                    state.enabledNetworkMap[ns][key] = false;
                 });
             });
             // Get current network configurations to check if networks exist
             const networkControllerState = this.messenger.call('NetworkController:getState');
             const multichainState = this.messenger.call('MultichainNetworkController:getState');
+            console.log('[NetworkEnablementController] NetworkController has', Object.keys(networkControllerState.networkConfigurationsByChainId)
+                .length, 'networks configured');
+            let enabledCount = 0;
             // Enable all popular EVM networks that exist in NetworkController configurations
             constants_1.POPULAR_NETWORKS.forEach((chainId) => {
                 const { namespace, storageKey } = (0, utils_2.deriveKeys)(chainId);
                 // Check if network exists in NetworkController configurations
                 if (networkControllerState.networkConfigurationsByChainId[chainId]) {
                     // Ensure namespace bucket exists
-                    __classPrivateFieldGet(this, _NetworkEnablementController_instances, "m", _NetworkEnablementController_ensureNamespaceBucket).call(this, s, namespace);
+                    __classPrivateFieldGet(this, _NetworkEnablementController_instances, "m", _NetworkEnablementController_ensureNamespaceBucket).call(this, state, namespace);
                     // Enable the network
-                    s.enabledNetworkMap[namespace][storageKey] = true;
+                    state.enabledNetworkMap[namespace][storageKey] = true;
+                    enabledCount += 1;
+                    console.log('[NetworkEnablementController] Enabled network:', chainId, storageKey);
+                }
+                else {
+                    console.log('[NetworkEnablementController] Network not found in NetworkController, skipping:', chainId);
                 }
             });
+            console.log('[NetworkEnablementController] Successfully enabled', enabledCount, 'of', constants_1.POPULAR_NETWORKS.length, 'popular networks');
             // Enable Solana mainnet if it exists in MultichainNetworkController configurations
             const solanaKeys = (0, utils_2.deriveKeys)(keyring_api_1.SolScope.Mainnet);
             if (multichainState.multichainNetworkConfigurationsByChainId[keyring_api_1.SolScope.Mainnet]) {
                 // Ensure namespace bucket exists
-                __classPrivateFieldGet(this, _NetworkEnablementController_instances, "m", _NetworkEnablementController_ensureNamespaceBucket).call(this, s, solanaKeys.namespace);
+                __classPrivateFieldGet(this, _NetworkEnablementController_instances, "m", _NetworkEnablementController_ensureNamespaceBucket).call(this, state, solanaKeys.namespace);
                 // Enable Solana mainnet
-                s.enabledNetworkMap[solanaKeys.namespace][solanaKeys.storageKey] = true;
+                state.enabledNetworkMap[solanaKeys.namespace][solanaKeys.storageKey] =
+                    true;
             }
             // Enable Bitcoin mainnet if it exists in MultichainNetworkController configurations
             const bitcoinKeys = (0, utils_2.deriveKeys)(keyring_api_1.BtcScope.Mainnet);
             if (multichainState.multichainNetworkConfigurationsByChainId[keyring_api_1.BtcScope.Mainnet]) {
                 // Ensure namespace bucket exists
-                __classPrivateFieldGet(this, _NetworkEnablementController_instances, "m", _NetworkEnablementController_ensureNamespaceBucket).call(this, s, bitcoinKeys.namespace);
+                __classPrivateFieldGet(this, _NetworkEnablementController_instances, "m", _NetworkEnablementController_ensureNamespaceBucket).call(this, state, bitcoinKeys.namespace);
                 // Enable Bitcoin mainnet
-                s.enabledNetworkMap[bitcoinKeys.namespace][bitcoinKeys.storageKey] =
+                state.enabledNetworkMap[bitcoinKeys.namespace][bitcoinKeys.storageKey] =
                     true;
             }
             // Enable Tron mainnet if it exists in MultichainNetworkController configurations
             const tronKeys = (0, utils_2.deriveKeys)(keyring_api_1.TrxScope.Mainnet);
             if (multichainState.multichainNetworkConfigurationsByChainId[keyring_api_1.TrxScope.Mainnet]) {
                 // Ensure namespace bucket exists
-                __classPrivateFieldGet(this, _NetworkEnablementController_instances, "m", _NetworkEnablementController_ensureNamespaceBucket).call(this, s, tronKeys.namespace);
+                __classPrivateFieldGet(this, _NetworkEnablementController_instances, "m", _NetworkEnablementController_ensureNamespaceBucket).call(this, state, tronKeys.namespace);
                 // Enable Tron mainnet
-                s.enabledNetworkMap[tronKeys.namespace][tronKeys.storageKey] = true;
+                state.enabledNetworkMap[tronKeys.namespace][tronKeys.storageKey] = true;
             }
         });
     }
@@ -227,28 +252,26 @@ class NetworkEnablementController extends base_controller_1.BaseController {
      * have been initialized and their configurations are available.
      */
     init() {
-        this.update((s) => {
+        this.update((state) => {
             // Get network configurations from NetworkController (EVM networks)
             const networkControllerState = this.messenger.call('NetworkController:getState');
             // Get network configurations from MultichainNetworkController (all networks)
             const multichainState = this.messenger.call('MultichainNetworkController:getState');
             // Initialize namespace buckets for EVM networks from NetworkController
             Object.keys(networkControllerState.networkConfigurationsByChainId).forEach((chainId) => {
+                var _a;
                 const { namespace, storageKey } = (0, utils_2.deriveKeys)(chainId);
-                __classPrivateFieldGet(this, _NetworkEnablementController_instances, "m", _NetworkEnablementController_ensureNamespaceBucket).call(this, s, namespace);
+                __classPrivateFieldGet(this, _NetworkEnablementController_instances, "m", _NetworkEnablementController_ensureNamespaceBucket).call(this, state, namespace);
                 // Only add network if it doesn't already exist in state (preserves user settings)
-                if (s.enabledNetworkMap[namespace][storageKey] === undefined) {
-                    s.enabledNetworkMap[namespace][storageKey] = false;
-                }
+                (_a = state.enabledNetworkMap[namespace])[storageKey] ?? (_a[storageKey] = false);
             });
             // Initialize namespace buckets for all networks from MultichainNetworkController
             Object.keys(multichainState.multichainNetworkConfigurationsByChainId).forEach((chainId) => {
+                var _a;
                 const { namespace, storageKey } = (0, utils_2.deriveKeys)(chainId);
-                __classPrivateFieldGet(this, _NetworkEnablementController_instances, "m", _NetworkEnablementController_ensureNamespaceBucket).call(this, s, namespace);
+                __classPrivateFieldGet(this, _NetworkEnablementController_instances, "m", _NetworkEnablementController_ensureNamespaceBucket).call(this, state, namespace);
                 // Only add network if it doesn't already exist in state (preserves user settings)
-                if (s.enabledNetworkMap[namespace][storageKey] === undefined) {
-                    s.enabledNetworkMap[namespace][storageKey] = false;
-                }
+                (_a = state.enabledNetworkMap[namespace])[storageKey] ?? (_a[storageKey] = false);
             });
         });
     }
@@ -269,8 +292,8 @@ class NetworkEnablementController extends base_controller_1.BaseController {
     disableNetwork(chainId) {
         const derivedKeys = (0, utils_2.deriveKeys)(chainId);
         const { namespace, storageKey } = derivedKeys;
-        this.update((s) => {
-            s.enabledNetworkMap[namespace][storageKey] = false;
+        this.update((state) => {
+            state.enabledNetworkMap[namespace][storageKey] = false;
         });
     }
     /**
@@ -310,21 +333,20 @@ _NetworkEnablementController_instances = new WeakSet(), _NetworkEnablementContro
 }, _NetworkEnablementController_removeNetworkEntry = function _NetworkEnablementController_removeNetworkEntry(chainId) {
     const derivedKeys = (0, utils_2.deriveKeys)(chainId);
     const { namespace, storageKey } = derivedKeys;
-    this.update((s) => {
+    this.update((state) => {
         // fallback and enable ethereum mainnet
         if ((0, utils_2.isOnlyNetworkEnabledInNamespace)(this.state, derivedKeys)) {
-            s.enabledNetworkMap[namespace][controller_utils_1.ChainId[controller_utils_1.BuiltInNetworkName.Mainnet]] =
-                true;
+            state.enabledNetworkMap[namespace][controller_utils_1.ChainId[controller_utils_1.BuiltInNetworkName.Mainnet]] = true;
         }
-        if (namespace in s.enabledNetworkMap) {
-            delete s.enabledNetworkMap[namespace][storageKey];
+        if (namespace in state.enabledNetworkMap) {
+            delete state.enabledNetworkMap[namespace][storageKey];
         }
     });
 }, _NetworkEnablementController_onAddNetwork = function _NetworkEnablementController_onAddNetwork(chainId) {
     const { namespace, storageKey, reference } = (0, utils_2.deriveKeys)(chainId);
-    this.update((s) => {
+    this.update((state) => {
         // Ensure the namespace bucket exists
-        __classPrivateFieldGet(this, _NetworkEnablementController_instances, "m", _NetworkEnablementController_ensureNamespaceBucket).call(this, s, namespace);
+        __classPrivateFieldGet(this, _NetworkEnablementController_instances, "m", _NetworkEnablementController_ensureNamespaceBucket).call(this, state, namespace);
         // Check if popular networks mode is active (>2 popular networks enabled)
         const inPopularNetworksMode = __classPrivateFieldGet(this, _NetworkEnablementController_instances, "m", _NetworkEnablementController_isInPopularNetworksMode).call(this);
         // Check if the network being added is a popular network
@@ -333,17 +355,17 @@ _NetworkEnablementController_instances = new WeakSet(), _NetworkEnablementContro
         const shouldKeepCurrentSelection = inPopularNetworksMode && isAddedNetworkPopular;
         if (shouldKeepCurrentSelection) {
             // Add the popular network but don't enable it (keep current selection)
-            s.enabledNetworkMap[namespace][storageKey] = true;
+            state.enabledNetworkMap[namespace][storageKey] = true;
         }
         else {
             // Switch to the newly added network (disable all others, enable this one)
-            Object.keys(s.enabledNetworkMap).forEach((ns) => {
-                Object.keys(s.enabledNetworkMap[ns]).forEach((key) => {
-                    s.enabledNetworkMap[ns][key] = false;
+            Object.keys(state.enabledNetworkMap).forEach((ns) => {
+                Object.keys(state.enabledNetworkMap[ns]).forEach((key) => {
+                    state.enabledNetworkMap[ns][key] = false;
                 });
             });
             // Enable the newly added network
-            s.enabledNetworkMap[namespace][storageKey] = true;
+            state.enabledNetworkMap[namespace][storageKey] = true;
         }
     });
 };
diff --git a/dist/NetworkEnablementController.cjs.map b/dist/NetworkEnablementController.cjs.map
index f96a4a7d26979e4880502784158c195a2db0da51..9bc25f0e3b3b414892f8c841d610ea10c8ffda38 100644
--- a/dist/NetworkEnablementController.cjs.map
+++ b/dist/NetworkEnablementController.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"NetworkEnablementController.cjs","sourceRoot":"","sources":["../src/NetworkEnablementController.ts"],"names":[],"mappings":"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","sourcesContent":["import { BaseController } from '@metamask/base-controller';\nimport type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n} from '@metamask/base-controller';\nimport { BuiltInNetworkName, ChainId } from '@metamask/controller-utils';\nimport { BtcScope, SolScope, TrxScope } from '@metamask/keyring-api';\nimport type { Messenger } from '@metamask/messenger';\nimport type { MultichainNetworkControllerGetStateAction } from '@metamask/multichain-network-controller';\nimport type {\n  NetworkControllerGetStateAction,\n  NetworkControllerNetworkAddedEvent,\n  NetworkControllerNetworkRemovedEvent,\n  NetworkControllerStateChangeEvent,\n} from '@metamask/network-controller';\nimport type { TransactionControllerTransactionSubmittedEvent } from '@metamask/transaction-controller';\nimport type { CaipChainId, CaipNamespace, Hex } from '@metamask/utils';\nimport { KnownCaipNamespace } from '@metamask/utils';\n\nimport { POPULAR_NETWORKS } from './constants';\nimport {\n  deriveKeys,\n  isOnlyNetworkEnabledInNamespace,\n  isPopularNetwork,\n} from './utils';\n\nconst controllerName = 'NetworkEnablementController';\n\n/**\n * Information about an ordered network.\n */\nexport type NetworksInfo = {\n  /**\n   * The network's chain id\n   */\n  networkId: CaipChainId;\n};\n\n/**\n * A map of enabled networks by CAIP namespace and chain ID.\n * For EIP-155 networks, the keys are Hex chain IDs.\n * For other networks, the keys are CAIP chain IDs.\n */\ntype EnabledMap = Record<CaipNamespace, Record<CaipChainId | Hex, boolean>>;\n\n// State shape for NetworkEnablementController\nexport type NetworkEnablementControllerState = {\n  enabledNetworkMap: EnabledMap;\n};\n\nexport type NetworkEnablementControllerGetStateAction =\n  ControllerGetStateAction<\n    typeof controllerName,\n    NetworkEnablementControllerState\n  >;\n\nexport type NetworkEnablementControllerSetEnabledNetworksAction = {\n  type: `${typeof controllerName}:enableNetwork`;\n  handler: NetworkEnablementController['enableNetwork'];\n};\n\nexport type NetworkEnablementControllerDisableNetworkAction = {\n  type: `${typeof controllerName}:disableNetwork`;\n  handler: NetworkEnablementController['disableNetwork'];\n};\n\n/**\n * All actions that {@link NetworkEnablementController} calls internally.\n */\nexport type AllowedActions =\n  | NetworkControllerGetStateAction\n  | MultichainNetworkControllerGetStateAction;\n\nexport type NetworkEnablementControllerActions =\n  | NetworkEnablementControllerGetStateAction\n  | NetworkEnablementControllerSetEnabledNetworksAction\n  | NetworkEnablementControllerDisableNetworkAction;\n\nexport type NetworkEnablementControllerStateChangeEvent =\n  ControllerStateChangeEvent<\n    typeof controllerName,\n    NetworkEnablementControllerState\n  >;\n\nexport type NetworkEnablementControllerEvents =\n  NetworkEnablementControllerStateChangeEvent;\n\n/**\n * All events that {@link NetworkEnablementController} subscribes to internally.\n */\nexport type AllowedEvents =\n  | NetworkControllerNetworkAddedEvent\n  | NetworkControllerNetworkRemovedEvent\n  | NetworkControllerStateChangeEvent\n  | TransactionControllerTransactionSubmittedEvent;\n\nexport type NetworkEnablementControllerMessenger = Messenger<\n  typeof controllerName,\n  NetworkEnablementControllerActions | AllowedActions,\n  NetworkEnablementControllerEvents | AllowedEvents\n>;\n\n/**\n * Gets the default state for the NetworkEnablementController.\n *\n * @returns The default state with pre-enabled networks.\n */\nconst getDefaultNetworkEnablementControllerState =\n  (): NetworkEnablementControllerState => ({\n    enabledNetworkMap: {\n      [KnownCaipNamespace.Eip155]: {\n        [ChainId[BuiltInNetworkName.Mainnet]]: true,\n        [ChainId[BuiltInNetworkName.LineaMainnet]]: true,\n        [ChainId[BuiltInNetworkName.BaseMainnet]]: true,\n      },\n      [KnownCaipNamespace.Solana]: {\n        [SolScope.Mainnet]: true,\n        [SolScope.Testnet]: false,\n        [SolScope.Devnet]: false,\n      },\n      [KnownCaipNamespace.Bip122]: {\n        [BtcScope.Mainnet]: true,\n        [BtcScope.Testnet]: false,\n        [BtcScope.Signet]: false,\n      },\n      [KnownCaipNamespace.Tron]: {\n        [TrxScope.Mainnet]: true,\n        [TrxScope.Nile]: false,\n        [TrxScope.Shasta]: false,\n      },\n    },\n  });\n\n// Metadata for the controller state\nconst metadata = {\n  enabledNetworkMap: {\n    includeInStateLogs: true,\n    persist: true,\n    includeInDebugSnapshot: true,\n    usedInUi: true,\n  },\n};\n\n/**\n * Controller responsible for managing network enablement state across different blockchain networks.\n *\n * This controller tracks which networks are enabled/disabled for the user and provides methods\n * to toggle network states. It supports both EVM (EIP-155) and non-EVM networks like Solana.\n *\n * The controller maintains a map of enabled networks organized by namespace (e.g., 'eip155', 'solana')\n * and provides methods to query and modify network enablement states.\n */\nexport class NetworkEnablementController extends BaseController<\n  typeof controllerName,\n  NetworkEnablementControllerState,\n  NetworkEnablementControllerMessenger\n> {\n  /**\n   * Creates a NetworkEnablementController instance.\n   *\n   * @param args - The arguments to this function.\n   * @param args.messenger - Messenger used to communicate with BaseV2 controller.\n   * @param args.state - Initial state to set on this controller.\n   */\n  constructor({\n    messenger,\n    state,\n  }: {\n    messenger: NetworkEnablementControllerMessenger;\n    state?: Partial<NetworkEnablementControllerState>;\n  }) {\n    super({\n      messenger,\n      metadata,\n      name: controllerName,\n      state: {\n        ...getDefaultNetworkEnablementControllerState(),\n        ...state,\n      },\n    });\n\n    messenger.subscribe('NetworkController:networkAdded', ({ chainId }) => {\n      this.#onAddNetwork(chainId);\n    });\n\n    messenger.subscribe('NetworkController:networkRemoved', ({ chainId }) => {\n      this.#removeNetworkEntry(chainId);\n    });\n  }\n\n  /**\n   * Enables or disables a network for the user.\n   *\n   * This method accepts either a Hex chain ID (for EVM networks) or a CAIP-2 chain ID\n   * (for any blockchain network). The method will automatically convert Hex chain IDs\n   * to CAIP-2 format internally. This dual parameter support allows for backward\n   * compatibility with existing EVM chain ID formats while supporting newer\n   * multi-chain standards.\n   *\n   * When enabling a non-popular network, this method will disable all other networks\n   * to ensure only one network is active at a time (exclusive mode).\n   *\n   * @param chainId - The chain ID of the network to enable or disable. Can be either:\n   * - A Hex string (e.g., '0x1' for Ethereum mainnet) for EVM networks\n   * - A CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet, 'solana:mainnet' for Solana)\n   */\n  enableNetwork(chainId: Hex | CaipChainId): void {\n    const { namespace, storageKey } = deriveKeys(chainId);\n\n    this.update((s) => {\n      // disable all networks in all namespaces first\n      Object.keys(s.enabledNetworkMap).forEach((ns) => {\n        Object.keys(s.enabledNetworkMap[ns]).forEach((key) => {\n          s.enabledNetworkMap[ns][key as CaipChainId | Hex] = false;\n        });\n      });\n\n      // if the namespace bucket does not exist, return\n      // new nemespace are added only when a new network is added\n      if (!s.enabledNetworkMap[namespace]) {\n        return;\n      }\n\n      // enable the network\n      s.enabledNetworkMap[namespace][storageKey] = true;\n    });\n  }\n\n  /**\n   * Enables a network for the user within a specific namespace.\n   *\n   * This method accepts either a Hex chain ID (for EVM networks) or a CAIP-2 chain ID\n   * (for any blockchain network) and enables it within the specified namespace.\n   * The method validates that the chainId belongs to the specified namespace for safety.\n   *\n   * Before enabling the target network, this method disables all other networks\n   * in the same namespace to ensure exclusive behavior within the namespace.\n   *\n   * @param chainId - The chain ID of the network to enable. Can be either:\n   * - A Hex string (e.g., '0x1' for Ethereum mainnet) for EVM networks\n   * - A CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet, 'solana:mainnet' for Solana)\n   * @param namespace - The CAIP namespace where the network should be enabled\n   * @throws Error if the chainId's derived namespace doesn't match the provided namespace\n   */\n  enableNetworkInNamespace(\n    chainId: Hex | CaipChainId,\n    namespace: CaipNamespace,\n  ): void {\n    const { namespace: derivedNamespace, storageKey } = deriveKeys(chainId);\n\n    // Validate that the derived namespace matches the provided namespace\n    if (derivedNamespace !== namespace) {\n      throw new Error(\n        `Chain ID ${chainId} belongs to namespace ${derivedNamespace}, but namespace ${namespace} was specified`,\n      );\n    }\n\n    this.update((s) => {\n      // Ensure the namespace bucket exists\n      this.#ensureNamespaceBucket(s, namespace);\n\n      // Disable all networks in the specified namespace first\n      if (s.enabledNetworkMap[namespace]) {\n        Object.keys(s.enabledNetworkMap[namespace]).forEach((key) => {\n          s.enabledNetworkMap[namespace][key as CaipChainId | Hex] = false;\n        });\n      }\n\n      // Enable the target network in the specified namespace\n      s.enabledNetworkMap[namespace][storageKey] = true;\n    });\n  }\n\n  /**\n   * Enables all popular networks and Solana mainnet.\n   *\n   * This method first disables all networks across all namespaces, then enables\n   * all networks defined in POPULAR_NETWORKS (EVM networks), Solana mainnet, and\n   * Bitcoin mainnet. This provides exclusive behavior - only popular networks will\n   * be enabled after calling this method.\n   *\n   * Popular networks that don't exist in NetworkController or MultichainNetworkController configurations will be skipped silently.\n   */\n  enableAllPopularNetworks(): void {\n    this.update((s) => {\n      // First disable all networks across all namespaces\n      Object.keys(s.enabledNetworkMap).forEach((ns) => {\n        Object.keys(s.enabledNetworkMap[ns]).forEach((key) => {\n          s.enabledNetworkMap[ns][key as CaipChainId | Hex] = false;\n        });\n      });\n\n      // Get current network configurations to check if networks exist\n      const networkControllerState = this.messenger.call(\n        'NetworkController:getState',\n      );\n      const multichainState = this.messenger.call(\n        'MultichainNetworkController:getState',\n      );\n\n      // Enable all popular EVM networks that exist in NetworkController configurations\n      POPULAR_NETWORKS.forEach((chainId) => {\n        const { namespace, storageKey } = deriveKeys(chainId as Hex);\n\n        // Check if network exists in NetworkController configurations\n        if (\n          networkControllerState.networkConfigurationsByChainId[chainId as Hex]\n        ) {\n          // Ensure namespace bucket exists\n          this.#ensureNamespaceBucket(s, namespace);\n          // Enable the network\n          s.enabledNetworkMap[namespace][storageKey] = true;\n        }\n      });\n\n      // Enable Solana mainnet if it exists in MultichainNetworkController configurations\n      const solanaKeys = deriveKeys(SolScope.Mainnet as CaipChainId);\n      if (\n        multichainState.multichainNetworkConfigurationsByChainId[\n          SolScope.Mainnet\n        ]\n      ) {\n        // Ensure namespace bucket exists\n        this.#ensureNamespaceBucket(s, solanaKeys.namespace);\n        // Enable Solana mainnet\n        s.enabledNetworkMap[solanaKeys.namespace][solanaKeys.storageKey] = true;\n      }\n\n      // Enable Bitcoin mainnet if it exists in MultichainNetworkController configurations\n      const bitcoinKeys = deriveKeys(BtcScope.Mainnet as CaipChainId);\n      if (\n        multichainState.multichainNetworkConfigurationsByChainId[\n          BtcScope.Mainnet\n        ]\n      ) {\n        // Ensure namespace bucket exists\n        this.#ensureNamespaceBucket(s, bitcoinKeys.namespace);\n        // Enable Bitcoin mainnet\n        s.enabledNetworkMap[bitcoinKeys.namespace][bitcoinKeys.storageKey] =\n          true;\n      }\n\n      // Enable Tron mainnet if it exists in MultichainNetworkController configurations\n      const tronKeys = deriveKeys(TrxScope.Mainnet as CaipChainId);\n      if (\n        multichainState.multichainNetworkConfigurationsByChainId[\n          TrxScope.Mainnet\n        ]\n      ) {\n        // Ensure namespace bucket exists\n        this.#ensureNamespaceBucket(s, tronKeys.namespace);\n        // Enable Tron mainnet\n        s.enabledNetworkMap[tronKeys.namespace][tronKeys.storageKey] = true;\n      }\n    });\n  }\n\n  /**\n   * Initializes the network enablement state from network controller configurations.\n   *\n   * This method reads the current network configurations from both NetworkController\n   * and MultichainNetworkController and syncs the enabled network map accordingly.\n   * It ensures proper namespace buckets exist for all configured networks and only\n   * adds missing networks with a default value of false, preserving existing user settings.\n   *\n   * This method should be called after the NetworkController and MultichainNetworkController\n   * have been initialized and their configurations are available.\n   */\n  init(): void {\n    this.update((s) => {\n      // Get network configurations from NetworkController (EVM networks)\n      const networkControllerState = this.messenger.call(\n        'NetworkController:getState',\n      );\n\n      // Get network configurations from MultichainNetworkController (all networks)\n      const multichainState = this.messenger.call(\n        'MultichainNetworkController:getState',\n      );\n\n      // Initialize namespace buckets for EVM networks from NetworkController\n      Object.keys(\n        networkControllerState.networkConfigurationsByChainId,\n      ).forEach((chainId) => {\n        const { namespace, storageKey } = deriveKeys(chainId as Hex);\n        this.#ensureNamespaceBucket(s, namespace);\n\n        // Only add network if it doesn't already exist in state (preserves user settings)\n        if (s.enabledNetworkMap[namespace][storageKey] === undefined) {\n          s.enabledNetworkMap[namespace][storageKey] = false;\n        }\n      });\n\n      // Initialize namespace buckets for all networks from MultichainNetworkController\n      Object.keys(\n        multichainState.multichainNetworkConfigurationsByChainId,\n      ).forEach((chainId) => {\n        const { namespace, storageKey } = deriveKeys(chainId as CaipChainId);\n        this.#ensureNamespaceBucket(s, namespace);\n\n        // Only add network if it doesn't already exist in state (preserves user settings)\n        if (s.enabledNetworkMap[namespace][storageKey] === undefined) {\n          s.enabledNetworkMap[namespace][storageKey] = false;\n        }\n      });\n    });\n  }\n\n  /**\n   * Disables a network for the user.\n   *\n   * This method accepts either a Hex chain ID (for EVM networks) or a CAIP-2 chain ID\n   * (for any blockchain network). The method will automatically convert Hex chain IDs\n   * to CAIP-2 format internally.\n   *\n   * Note: This method will prevent disabling the last remaining enabled network\n   * to ensure at least one network is always available.\n   *\n   * @param chainId - The chain ID of the network to disable. Can be either:\n   * - A Hex string (e.g., '0x1' for Ethereum mainnet) for EVM networks\n   * - A CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet, 'solana:mainnet' for Solana)\n   */\n  disableNetwork(chainId: Hex | CaipChainId): void {\n    const derivedKeys = deriveKeys(chainId);\n    const { namespace, storageKey } = derivedKeys;\n\n    this.update((s) => {\n      s.enabledNetworkMap[namespace][storageKey] = false;\n    });\n  }\n\n  /**\n   * Checks if a network is enabled.\n   *\n   * @param chainId - The chain ID of the network to check. Can be either:\n   * - A Hex string (e.g., '0x1' for Ethereum mainnet) for EVM networks\n   * - A CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet, 'solana:mainnet' for Solana)\n   * @returns True if the network is enabled, false otherwise\n   */\n  isNetworkEnabled(chainId: Hex | CaipChainId): boolean {\n    const derivedKeys = deriveKeys(chainId);\n    const { namespace, storageKey } = derivedKeys;\n    return this.state.enabledNetworkMap[namespace]?.[storageKey] ?? false;\n  }\n\n  /**\n   * Ensures that a namespace bucket exists in the state.\n   *\n   * This method creates the namespace entry in the enabledNetworkMap if it doesn't\n   * already exist. This is used to prepare the state structure before adding\n   * network entries.\n   *\n   * @param state - The current controller state\n   * @param ns - The CAIP namespace to ensure exists\n   */\n  #ensureNamespaceBucket(\n    state: NetworkEnablementControllerState,\n    ns: CaipNamespace,\n  ) {\n    if (!state.enabledNetworkMap[ns]) {\n      state.enabledNetworkMap[ns] = {};\n    }\n  }\n\n  /**\n   * Checks if popular networks mode is active (more than 2 popular networks enabled).\n   *\n   * This method counts how many networks defined in POPULAR_NETWORKS are currently\n   * enabled in the state and returns true if more than 2 are enabled. It only checks\n   * networks that actually exist in the NetworkController configurations.\n   *\n   * @returns True if more than 2 popular networks are enabled, false otherwise\n   */\n  #isInPopularNetworksMode(): boolean {\n    // Get current network configurations to check which popular networks exist\n    const networkControllerState = this.messenger.call(\n      'NetworkController:getState',\n    );\n\n    // Count how many popular networks are enabled\n    const enabledPopularNetworksCount = POPULAR_NETWORKS.reduce(\n      (count, chainId) => {\n        // Only check networks that actually exist in NetworkController configurations\n        if (\n          !networkControllerState.networkConfigurationsByChainId[chainId as Hex]\n        ) {\n          return count; // Skip networks that don't exist\n        }\n\n        const { namespace, storageKey } = deriveKeys(chainId as Hex);\n        const isEnabled = this.state.enabledNetworkMap[namespace]?.[storageKey];\n        return isEnabled ? count + 1 : count;\n      },\n      0,\n    );\n\n    // Return true if more than 2 popular networks are enabled\n    return enabledPopularNetworksCount > 1;\n  }\n\n  /**\n   * Removes a network entry from the state.\n   *\n   * This method is called when a network is removed from the system. It cleans up\n   * the network entry and ensures that at least one network remains enabled.\n   *\n   * @param chainId - The chain ID to remove (Hex or CAIP-2 format)\n   */\n  #removeNetworkEntry(chainId: Hex | CaipChainId): void {\n    const derivedKeys = deriveKeys(chainId);\n    const { namespace, storageKey } = derivedKeys;\n\n    this.update((s) => {\n      // fallback and enable ethereum mainnet\n      if (isOnlyNetworkEnabledInNamespace(this.state, derivedKeys)) {\n        s.enabledNetworkMap[namespace][ChainId[BuiltInNetworkName.Mainnet]] =\n          true;\n      }\n\n      if (namespace in s.enabledNetworkMap) {\n        delete s.enabledNetworkMap[namespace][storageKey];\n      }\n    });\n  }\n\n  /**\n   * Handles the addition of a new network to the controller.\n   *\n   * @param chainId - The chain ID to add (Hex or CAIP-2 format)\n   *\n   * @description\n   * - If in popular networks mode (>2 popular networks enabled) AND adding a popular network:\n   * - Keep current selection (add but don't enable the new network)\n   * - Otherwise:\n   * - Switch to the newly added network (disable all others, enable this one)\n   */\n  #onAddNetwork(chainId: Hex | CaipChainId): void {\n    const { namespace, storageKey, reference } = deriveKeys(chainId);\n\n    this.update((s) => {\n      // Ensure the namespace bucket exists\n      this.#ensureNamespaceBucket(s, namespace);\n\n      // Check if popular networks mode is active (>2 popular networks enabled)\n      const inPopularNetworksMode = this.#isInPopularNetworksMode();\n\n      // Check if the network being added is a popular network\n      const isAddedNetworkPopular = isPopularNetwork(reference);\n\n      // Keep current selection only if in popular networks mode AND adding a popular network\n      const shouldKeepCurrentSelection =\n        inPopularNetworksMode && isAddedNetworkPopular;\n\n      if (shouldKeepCurrentSelection) {\n        // Add the popular network but don't enable it (keep current selection)\n        s.enabledNetworkMap[namespace][storageKey] = true;\n      } else {\n        // Switch to the newly added network (disable all others, enable this one)\n        Object.keys(s.enabledNetworkMap).forEach((ns) => {\n          Object.keys(s.enabledNetworkMap[ns]).forEach((key) => {\n            s.enabledNetworkMap[ns][key as CaipChainId | Hex] = false;\n          });\n        });\n        // Enable the newly added network\n        s.enabledNetworkMap[namespace][storageKey] = true;\n      }\n    });\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"NetworkEnablementController.cjs","sourceRoot":"","sources":["../src/NetworkEnablementController.ts"],"names":[],"mappings":"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","sourcesContent":["import { BaseController } from '@metamask/base-controller';\nimport type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n} from '@metamask/base-controller';\nimport { BuiltInNetworkName, ChainId } from '@metamask/controller-utils';\nimport { BtcScope, SolScope, TrxScope } from '@metamask/keyring-api';\nimport type { Messenger } from '@metamask/messenger';\nimport type { MultichainNetworkControllerGetStateAction } from '@metamask/multichain-network-controller';\nimport type {\n  NetworkControllerGetStateAction,\n  NetworkControllerNetworkAddedEvent,\n  NetworkControllerNetworkRemovedEvent,\n  NetworkControllerStateChangeEvent,\n} from '@metamask/network-controller';\nimport type { TransactionControllerTransactionSubmittedEvent } from '@metamask/transaction-controller';\nimport type { CaipChainId, CaipNamespace, Hex } from '@metamask/utils';\nimport { KnownCaipNamespace } from '@metamask/utils';\n\nimport { POPULAR_NETWORKS } from './constants';\nimport {\n  deriveKeys,\n  isOnlyNetworkEnabledInNamespace,\n  isPopularNetwork,\n} from './utils';\n\nconst controllerName = 'NetworkEnablementController';\n\n/**\n * Information about an ordered network.\n */\nexport type NetworksInfo = {\n  /**\n   * The network's chain id\n   */\n  networkId: CaipChainId;\n};\n\n/**\n * A map of enabled networks by CAIP namespace and chain ID.\n * For EIP-155 networks, the keys are Hex chain IDs.\n * For other networks, the keys are CAIP chain IDs.\n */\ntype EnabledMap = Record<CaipNamespace, Record<CaipChainId | Hex, boolean>>;\n\n// State shape for NetworkEnablementController\nexport type NetworkEnablementControllerState = {\n  enabledNetworkMap: EnabledMap;\n};\n\nexport type NetworkEnablementControllerGetStateAction =\n  ControllerGetStateAction<\n    typeof controllerName,\n    NetworkEnablementControllerState\n  >;\n\nexport type NetworkEnablementControllerSetEnabledNetworksAction = {\n  type: `${typeof controllerName}:enableNetwork`;\n  handler: NetworkEnablementController['enableNetwork'];\n};\n\nexport type NetworkEnablementControllerDisableNetworkAction = {\n  type: `${typeof controllerName}:disableNetwork`;\n  handler: NetworkEnablementController['disableNetwork'];\n};\n\n/**\n * All actions that {@link NetworkEnablementController} calls internally.\n */\nexport type AllowedActions =\n  | NetworkControllerGetStateAction\n  | MultichainNetworkControllerGetStateAction;\n\nexport type NetworkEnablementControllerActions =\n  | NetworkEnablementControllerGetStateAction\n  | NetworkEnablementControllerSetEnabledNetworksAction\n  | NetworkEnablementControllerDisableNetworkAction;\n\nexport type NetworkEnablementControllerStateChangeEvent =\n  ControllerStateChangeEvent<\n    typeof controllerName,\n    NetworkEnablementControllerState\n  >;\n\nexport type NetworkEnablementControllerEvents =\n  NetworkEnablementControllerStateChangeEvent;\n\n/**\n * All events that {@link NetworkEnablementController} subscribes to internally.\n */\nexport type AllowedEvents =\n  | NetworkControllerNetworkAddedEvent\n  | NetworkControllerNetworkRemovedEvent\n  | NetworkControllerStateChangeEvent\n  | TransactionControllerTransactionSubmittedEvent;\n\nexport type NetworkEnablementControllerMessenger = Messenger<\n  typeof controllerName,\n  NetworkEnablementControllerActions | AllowedActions,\n  NetworkEnablementControllerEvents | AllowedEvents\n>;\n\n/**\n * Gets the default state for the NetworkEnablementController.\n *\n * @returns The default state with pre-enabled networks.\n */\nconst getDefaultNetworkEnablementControllerState =\n  (): NetworkEnablementControllerState => {\n    // Programmatically enable all popular networks for performance testing\n    const enabledEvmNetworks = POPULAR_NETWORKS.reduce<Record<string, boolean>>(\n      (acc, chainId) => ({\n        ...acc,\n        [chainId]: true,\n      }),\n      {},\n    );\n\n    console.log(\n      '[NetworkEnablementController] Generating default state with',\n      POPULAR_NETWORKS.length,\n      'popular networks',\n    );\n    console.log(\n      '[NetworkEnablementController] Enabled EVM networks:',\n      Object.keys(enabledEvmNetworks),\n    );\n\n    return {\n      enabledNetworkMap: {\n        [KnownCaipNamespace.Eip155]: enabledEvmNetworks,\n        [KnownCaipNamespace.Solana]: {\n          [SolScope.Mainnet]: true,\n          [SolScope.Testnet]: false,\n          [SolScope.Devnet]: false,\n        },\n        [KnownCaipNamespace.Bip122]: {\n          [BtcScope.Mainnet]: true,\n          [BtcScope.Testnet]: false,\n          [BtcScope.Signet]: false,\n        },\n        [KnownCaipNamespace.Tron]: {\n          [TrxScope.Mainnet]: true,\n          [TrxScope.Nile]: false,\n          [TrxScope.Shasta]: false,\n        },\n      },\n    };\n  };\n\n// Metadata for the controller state\nconst metadata = {\n  enabledNetworkMap: {\n    includeInStateLogs: true,\n    persist: true,\n    includeInDebugSnapshot: true,\n    usedInUi: true,\n  },\n};\n\n/**\n * Controller responsible for managing network enablement state across different blockchain networks.\n *\n * This controller tracks which networks are enabled/disabled for the user and provides methods\n * to toggle network states. It supports both EVM (EIP-155) and non-EVM networks like Solana.\n *\n * The controller maintains a map of enabled networks organized by namespace (e.g., 'eip155', 'solana')\n * and provides methods to query and modify network enablement states.\n */\nexport class NetworkEnablementController extends BaseController<\n  typeof controllerName,\n  NetworkEnablementControllerState,\n  NetworkEnablementControllerMessenger\n> {\n  /**\n   * Creates a NetworkEnablementController instance.\n   *\n   * @param args - The arguments to this function.\n   * @param args.messenger - Messenger used to communicate with BaseV2 controller.\n   * @param args.state - Initial state to set on this controller.\n   */\n  constructor({\n    messenger,\n    state,\n  }: {\n    messenger: NetworkEnablementControllerMessenger;\n    state?: Partial<NetworkEnablementControllerState>;\n  }) {\n    const defaultState = getDefaultNetworkEnablementControllerState();\n    const finalState = {\n      ...defaultState,\n      ...state,\n    };\n\n    console.log(\n      '[NetworkEnablementController] Constructor - passed state:',\n      state ? 'YES (will override defaults)' : 'NO (using defaults)',\n    );\n    console.log(\n      '[NetworkEnablementController] Constructor - default EVM networks count:',\n      Object.keys(defaultState.enabledNetworkMap[KnownCaipNamespace.Eip155])\n        .length,\n    );\n    console.log(\n      '[NetworkEnablementController] Constructor - final EVM networks count:',\n      Object.keys(finalState.enabledNetworkMap[KnownCaipNamespace.Eip155])\n        .length,\n    );\n    console.log(\n      '[NetworkEnablementController] Constructor - final enabled EVM networks:',\n      Object.keys(finalState.enabledNetworkMap[KnownCaipNamespace.Eip155]),\n    );\n\n    super({\n      messenger,\n      metadata,\n      name: controllerName,\n      state: finalState,\n    });\n\n    messenger.subscribe('NetworkController:networkAdded', ({ chainId }) => {\n      this.#onAddNetwork(chainId);\n    });\n\n    messenger.subscribe('NetworkController:networkRemoved', ({ chainId }) => {\n      this.#removeNetworkEntry(chainId);\n    });\n  }\n\n  /**\n   * Enables or disables a network for the user.\n   *\n   * This method accepts either a Hex chain ID (for EVM networks) or a CAIP-2 chain ID\n   * (for any blockchain network). The method will automatically convert Hex chain IDs\n   * to CAIP-2 format internally. This dual parameter support allows for backward\n   * compatibility with existing EVM chain ID formats while supporting newer\n   * multi-chain standards.\n   *\n   * When enabling a non-popular network, this method will disable all other networks\n   * to ensure only one network is active at a time (exclusive mode).\n   *\n   * @param chainId - The chain ID of the network to enable or disable. Can be either:\n   * - A Hex string (e.g., '0x1' for Ethereum mainnet) for EVM networks\n   * - A CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet, 'solana:mainnet' for Solana)\n   */\n  enableNetwork(chainId: Hex | CaipChainId): void {\n    const { namespace, storageKey } = deriveKeys(chainId);\n\n    console.log(\n      '[NetworkEnablementController] enableNetwork called for:',\n      chainId,\n      'namespace:',\n      namespace,\n      'storageKey:',\n      storageKey,\n    );\n\n    this.update((state) => {\n      // disable all networks in all namespaces first\n      Object.keys(state.enabledNetworkMap).forEach((ns) => {\n        Object.keys(state.enabledNetworkMap[ns]).forEach((key) => {\n          state.enabledNetworkMap[ns][key as CaipChainId | Hex] = false;\n        });\n      });\n\n      // if the namespace bucket does not exist, return\n      // new nemespace are added only when a new network is added\n      if (!state.enabledNetworkMap[namespace]) {\n        return;\n      }\n\n      // enable the network\n      state.enabledNetworkMap[namespace][storageKey] = true;\n    });\n  }\n\n  /**\n   * Enables a network for the user within a specific namespace.\n   *\n   * This method accepts either a Hex chain ID (for EVM networks) or a CAIP-2 chain ID\n   * (for any blockchain network) and enables it within the specified namespace.\n   * The method validates that the chainId belongs to the specified namespace for safety.\n   *\n   * Before enabling the target network, this method disables all other networks\n   * in the same namespace to ensure exclusive behavior within the namespace.\n   *\n   * @param chainId - The chain ID of the network to enable. Can be either:\n   * - A Hex string (e.g., '0x1' for Ethereum mainnet) for EVM networks\n   * - A CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet, 'solana:mainnet' for Solana)\n   * @param namespace - The CAIP namespace where the network should be enabled\n   * @throws Error if the chainId's derived namespace doesn't match the provided namespace\n   */\n  enableNetworkInNamespace(\n    chainId: Hex | CaipChainId,\n    namespace: CaipNamespace,\n  ): void {\n    const { namespace: derivedNamespace, storageKey } = deriveKeys(chainId);\n\n    // Validate that the derived namespace matches the provided namespace\n    if (derivedNamespace !== namespace) {\n      throw new Error(\n        `Chain ID ${chainId} belongs to namespace ${derivedNamespace}, but namespace ${namespace} was specified`,\n      );\n    }\n\n    this.update((state) => {\n      // Ensure the namespace bucket exists\n      this.#ensureNamespaceBucket(state, namespace);\n\n      // Disable all networks in the specified namespace first\n      if (state.enabledNetworkMap[namespace]) {\n        Object.keys(state.enabledNetworkMap[namespace]).forEach((key) => {\n          state.enabledNetworkMap[namespace][key as CaipChainId | Hex] = false;\n        });\n      }\n\n      // Enable the target network in the specified namespace\n      state.enabledNetworkMap[namespace][storageKey] = true;\n    });\n  }\n\n  /**\n   * Enables all popular networks and Solana mainnet.\n   *\n   * This method first disables all networks across all namespaces, then enables\n   * all networks defined in POPULAR_NETWORKS (EVM networks), Solana mainnet, and\n   * Bitcoin mainnet. This provides exclusive behavior - only popular networks will\n   * be enabled after calling this method.\n   *\n   * Popular networks that don't exist in NetworkController or MultichainNetworkController configurations will be skipped silently.\n   */\n  enableAllPopularNetworks(): void {\n    console.log(\n      '[NetworkEnablementController] enableAllPopularNetworks called - attempting to enable',\n      POPULAR_NETWORKS.length,\n      'networks',\n    );\n\n    this.update((state) => {\n      // First disable all networks across all namespaces\n      Object.keys(state.enabledNetworkMap).forEach((ns) => {\n        Object.keys(state.enabledNetworkMap[ns]).forEach((key) => {\n          state.enabledNetworkMap[ns][key as CaipChainId | Hex] = false;\n        });\n      });\n\n      // Get current network configurations to check if networks exist\n      const networkControllerState = this.messenger.call(\n        'NetworkController:getState',\n      );\n      const multichainState = this.messenger.call(\n        'MultichainNetworkController:getState',\n      );\n\n      console.log(\n        '[NetworkEnablementController] NetworkController has',\n        Object.keys(networkControllerState.networkConfigurationsByChainId)\n          .length,\n        'networks configured',\n      );\n\n      let enabledCount = 0;\n      // Enable all popular EVM networks that exist in NetworkController configurations\n      POPULAR_NETWORKS.forEach((chainId) => {\n        const { namespace, storageKey } = deriveKeys(chainId as Hex);\n\n        // Check if network exists in NetworkController configurations\n        if (\n          networkControllerState.networkConfigurationsByChainId[chainId as Hex]\n        ) {\n          // Ensure namespace bucket exists\n          this.#ensureNamespaceBucket(state, namespace);\n          // Enable the network\n          state.enabledNetworkMap[namespace][storageKey] = true;\n          enabledCount += 1;\n          console.log(\n            '[NetworkEnablementController] Enabled network:',\n            chainId,\n            storageKey,\n          );\n        } else {\n          console.log(\n            '[NetworkEnablementController] Network not found in NetworkController, skipping:',\n            chainId,\n          );\n        }\n      });\n\n      console.log(\n        '[NetworkEnablementController] Successfully enabled',\n        enabledCount,\n        'of',\n        POPULAR_NETWORKS.length,\n        'popular networks',\n      );\n\n      // Enable Solana mainnet if it exists in MultichainNetworkController configurations\n      const solanaKeys = deriveKeys(SolScope.Mainnet as CaipChainId);\n      if (\n        multichainState.multichainNetworkConfigurationsByChainId[\n          SolScope.Mainnet\n        ]\n      ) {\n        // Ensure namespace bucket exists\n        this.#ensureNamespaceBucket(state, solanaKeys.namespace);\n        // Enable Solana mainnet\n        state.enabledNetworkMap[solanaKeys.namespace][solanaKeys.storageKey] =\n          true;\n      }\n\n      // Enable Bitcoin mainnet if it exists in MultichainNetworkController configurations\n      const bitcoinKeys = deriveKeys(BtcScope.Mainnet as CaipChainId);\n      if (\n        multichainState.multichainNetworkConfigurationsByChainId[\n          BtcScope.Mainnet\n        ]\n      ) {\n        // Ensure namespace bucket exists\n        this.#ensureNamespaceBucket(state, bitcoinKeys.namespace);\n        // Enable Bitcoin mainnet\n        state.enabledNetworkMap[bitcoinKeys.namespace][bitcoinKeys.storageKey] =\n          true;\n      }\n\n      // Enable Tron mainnet if it exists in MultichainNetworkController configurations\n      const tronKeys = deriveKeys(TrxScope.Mainnet as CaipChainId);\n      if (\n        multichainState.multichainNetworkConfigurationsByChainId[\n          TrxScope.Mainnet\n        ]\n      ) {\n        // Ensure namespace bucket exists\n        this.#ensureNamespaceBucket(state, tronKeys.namespace);\n        // Enable Tron mainnet\n        state.enabledNetworkMap[tronKeys.namespace][tronKeys.storageKey] = true;\n      }\n    });\n  }\n\n  /**\n   * Initializes the network enablement state from network controller configurations.\n   *\n   * This method reads the current network configurations from both NetworkController\n   * and MultichainNetworkController and syncs the enabled network map accordingly.\n   * It ensures proper namespace buckets exist for all configured networks and only\n   * adds missing networks with a default value of false, preserving existing user settings.\n   *\n   * This method should be called after the NetworkController and MultichainNetworkController\n   * have been initialized and their configurations are available.\n   */\n  init(): void {\n    this.update((state) => {\n      // Get network configurations from NetworkController (EVM networks)\n      const networkControllerState = this.messenger.call(\n        'NetworkController:getState',\n      );\n\n      // Get network configurations from MultichainNetworkController (all networks)\n      const multichainState = this.messenger.call(\n        'MultichainNetworkController:getState',\n      );\n\n      // Initialize namespace buckets for EVM networks from NetworkController\n      Object.keys(\n        networkControllerState.networkConfigurationsByChainId,\n      ).forEach((chainId) => {\n        const { namespace, storageKey } = deriveKeys(chainId as Hex);\n        this.#ensureNamespaceBucket(state, namespace);\n\n        // Only add network if it doesn't already exist in state (preserves user settings)\n        state.enabledNetworkMap[namespace][storageKey] ??= false;\n      });\n\n      // Initialize namespace buckets for all networks from MultichainNetworkController\n      Object.keys(\n        multichainState.multichainNetworkConfigurationsByChainId,\n      ).forEach((chainId) => {\n        const { namespace, storageKey } = deriveKeys(chainId as CaipChainId);\n        this.#ensureNamespaceBucket(state, namespace);\n\n        // Only add network if it doesn't already exist in state (preserves user settings)\n        state.enabledNetworkMap[namespace][storageKey] ??= false;\n      });\n    });\n  }\n\n  /**\n   * Disables a network for the user.\n   *\n   * This method accepts either a Hex chain ID (for EVM networks) or a CAIP-2 chain ID\n   * (for any blockchain network). The method will automatically convert Hex chain IDs\n   * to CAIP-2 format internally.\n   *\n   * Note: This method will prevent disabling the last remaining enabled network\n   * to ensure at least one network is always available.\n   *\n   * @param chainId - The chain ID of the network to disable. Can be either:\n   * - A Hex string (e.g., '0x1' for Ethereum mainnet) for EVM networks\n   * - A CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet, 'solana:mainnet' for Solana)\n   */\n  disableNetwork(chainId: Hex | CaipChainId): void {\n    const derivedKeys = deriveKeys(chainId);\n    const { namespace, storageKey } = derivedKeys;\n\n    this.update((state) => {\n      state.enabledNetworkMap[namespace][storageKey] = false;\n    });\n  }\n\n  /**\n   * Checks if a network is enabled.\n   *\n   * @param chainId - The chain ID of the network to check. Can be either:\n   * - A Hex string (e.g., '0x1' for Ethereum mainnet) for EVM networks\n   * - A CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet, 'solana:mainnet' for Solana)\n   * @returns True if the network is enabled, false otherwise\n   */\n  isNetworkEnabled(chainId: Hex | CaipChainId): boolean {\n    const derivedKeys = deriveKeys(chainId);\n    const { namespace, storageKey } = derivedKeys;\n    return this.state.enabledNetworkMap[namespace]?.[storageKey] ?? false;\n  }\n\n  /**\n   * Ensures that a namespace bucket exists in the state.\n   *\n   * This method creates the namespace entry in the enabledNetworkMap if it doesn't\n   * already exist. This is used to prepare the state structure before adding\n   * network entries.\n   *\n   * @param state - The current controller state\n   * @param ns - The CAIP namespace to ensure exists\n   */\n  #ensureNamespaceBucket(\n    state: NetworkEnablementControllerState,\n    ns: CaipNamespace,\n  ): void {\n    if (!state.enabledNetworkMap[ns]) {\n      state.enabledNetworkMap[ns] = {};\n    }\n  }\n\n  /**\n   * Checks if popular networks mode is active (more than 2 popular networks enabled).\n   *\n   * This method counts how many networks defined in POPULAR_NETWORKS are currently\n   * enabled in the state and returns true if more than 2 are enabled. It only checks\n   * networks that actually exist in the NetworkController configurations.\n   *\n   * @returns True if more than 2 popular networks are enabled, false otherwise\n   */\n  #isInPopularNetworksMode(): boolean {\n    // Get current network configurations to check which popular networks exist\n    const networkControllerState = this.messenger.call(\n      'NetworkController:getState',\n    );\n\n    // Count how many popular networks are enabled\n    const enabledPopularNetworksCount = POPULAR_NETWORKS.reduce(\n      (count, chainId) => {\n        // Only check networks that actually exist in NetworkController configurations\n        if (\n          !networkControllerState.networkConfigurationsByChainId[chainId as Hex]\n        ) {\n          return count; // Skip networks that don't exist\n        }\n\n        const { namespace, storageKey } = deriveKeys(chainId as Hex);\n        const isEnabled = this.state.enabledNetworkMap[namespace]?.[storageKey];\n        return isEnabled ? count + 1 : count;\n      },\n      0,\n    );\n\n    // Return true if more than 2 popular networks are enabled\n    return enabledPopularNetworksCount > 1;\n  }\n\n  /**\n   * Removes a network entry from the state.\n   *\n   * This method is called when a network is removed from the system. It cleans up\n   * the network entry and ensures that at least one network remains enabled.\n   *\n   * @param chainId - The chain ID to remove (Hex or CAIP-2 format)\n   */\n  #removeNetworkEntry(chainId: Hex | CaipChainId): void {\n    const derivedKeys = deriveKeys(chainId);\n    const { namespace, storageKey } = derivedKeys;\n\n    this.update((state) => {\n      // fallback and enable ethereum mainnet\n      if (isOnlyNetworkEnabledInNamespace(this.state, derivedKeys)) {\n        state.enabledNetworkMap[namespace][\n          ChainId[BuiltInNetworkName.Mainnet]\n        ] = true;\n      }\n\n      if (namespace in state.enabledNetworkMap) {\n        delete state.enabledNetworkMap[namespace][storageKey];\n      }\n    });\n  }\n\n  /**\n   * Handles the addition of a new network to the controller.\n   *\n   * @param chainId - The chain ID to add (Hex or CAIP-2 format)\n   *\n   * @description\n   * - If in popular networks mode (>2 popular networks enabled) AND adding a popular network:\n   * - Keep current selection (add but don't enable the new network)\n   * - Otherwise:\n   * - Switch to the newly added network (disable all others, enable this one)\n   */\n  #onAddNetwork(chainId: Hex | CaipChainId): void {\n    const { namespace, storageKey, reference } = deriveKeys(chainId);\n\n    this.update((state) => {\n      // Ensure the namespace bucket exists\n      this.#ensureNamespaceBucket(state, namespace);\n\n      // Check if popular networks mode is active (>2 popular networks enabled)\n      const inPopularNetworksMode = this.#isInPopularNetworksMode();\n\n      // Check if the network being added is a popular network\n      const isAddedNetworkPopular = isPopularNetwork(reference);\n\n      // Keep current selection only if in popular networks mode AND adding a popular network\n      const shouldKeepCurrentSelection =\n        inPopularNetworksMode && isAddedNetworkPopular;\n\n      if (shouldKeepCurrentSelection) {\n        // Add the popular network but don't enable it (keep current selection)\n        state.enabledNetworkMap[namespace][storageKey] = true;\n      } else {\n        // Switch to the newly added network (disable all others, enable this one)\n        Object.keys(state.enabledNetworkMap).forEach((ns) => {\n          Object.keys(state.enabledNetworkMap[ns]).forEach((key) => {\n            state.enabledNetworkMap[ns][key as CaipChainId | Hex] = false;\n          });\n        });\n        // Enable the newly added network\n        state.enabledNetworkMap[namespace][storageKey] = true;\n      }\n    });\n  }\n}\n"]}
\ No newline at end of file
diff --git a/dist/NetworkEnablementController.d.cts.map b/dist/NetworkEnablementController.d.cts.map
index ae83d06ac6c69df41d666043f54f3e4b88bf13ad..a36a8670977dea4a3fc37ecdc3d9fba1f80c072a 100644
--- a/dist/NetworkEnablementController.d.cts.map
+++ b/dist/NetworkEnablementController.d.cts.map
@@ -1 +1 @@
-{"version":3,"file":"NetworkEnablementController.d.cts","sourceRoot":"","sources":["../src/NetworkEnablementController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"NetworkEnablementController.d.cts","sourceRoot":"","sources":["../src/NetworkEnablementController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/NetworkEnablementController.d.mts.map b/dist/NetworkEnablementController.d.mts.map
index 351117414527d9a22319f7817bc6395ee09a3aca..6f8aab88c4de5c44df7480ebffa95bbe31cb607d 100644
--- a/dist/NetworkEnablementController.d.mts.map
+++ b/dist/NetworkEnablementController.d.mts.map
@@ -1 +1 @@
-{"version":3,"file":"NetworkEnablementController.d.mts","sourceRoot":"","sources":["../src/NetworkEnablementController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"NetworkEnablementController.d.mts","sourceRoot":"","sources":["../src/NetworkEnablementController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/NetworkEnablementController.mjs b/dist/NetworkEnablementController.mjs
index f0354af26e0aa599a2d580b3e49c6a85eb768a58..a21764471b4872393125aea1e5db1996b4fc1169 100644
--- a/dist/NetworkEnablementController.mjs
+++ b/dist/NetworkEnablementController.mjs
@@ -16,30 +16,35 @@ const controllerName = 'NetworkEnablementController';
  *
  * @returns The default state with pre-enabled networks.
  */
-const getDefaultNetworkEnablementControllerState = () => ({
-    enabledNetworkMap: {
-        [KnownCaipNamespace.Eip155]: {
-            [ChainId[BuiltInNetworkName.Mainnet]]: true,
-            [ChainId[BuiltInNetworkName.LineaMainnet]]: true,
-            [ChainId[BuiltInNetworkName.BaseMainnet]]: true,
-        },
-        [KnownCaipNamespace.Solana]: {
-            [SolScope.Mainnet]: true,
-            [SolScope.Testnet]: false,
-            [SolScope.Devnet]: false,
-        },
-        [KnownCaipNamespace.Bip122]: {
-            [BtcScope.Mainnet]: true,
-            [BtcScope.Testnet]: false,
-            [BtcScope.Signet]: false,
-        },
-        [KnownCaipNamespace.Tron]: {
-            [TrxScope.Mainnet]: true,
-            [TrxScope.Nile]: false,
-            [TrxScope.Shasta]: false,
+const getDefaultNetworkEnablementControllerState = () => {
+    // Programmatically enable all popular networks for performance testing
+    const enabledEvmNetworks = POPULAR_NETWORKS.reduce((acc, chainId) => ({
+        ...acc,
+        [chainId]: true,
+    }), {});
+    console.log('[NetworkEnablementController] Generating default state with', POPULAR_NETWORKS.length, 'popular networks');
+    console.log('[NetworkEnablementController] Enabled EVM networks:', Object.keys(enabledEvmNetworks));
+    return {
+        enabledNetworkMap: {
+            [KnownCaipNamespace.Eip155]: enabledEvmNetworks,
+            [KnownCaipNamespace.Solana]: {
+                [SolScope.Mainnet]: true,
+                [SolScope.Testnet]: false,
+                [SolScope.Devnet]: false,
+            },
+            [KnownCaipNamespace.Bip122]: {
+                [BtcScope.Mainnet]: true,
+                [BtcScope.Testnet]: false,
+                [BtcScope.Signet]: false,
+            },
+            [KnownCaipNamespace.Tron]: {
+                [TrxScope.Mainnet]: true,
+                [TrxScope.Nile]: false,
+                [TrxScope.Shasta]: false,
+            },
         },
-    },
-});
+    };
+};
 // Metadata for the controller state
 const metadata = {
     enabledNetworkMap: {
@@ -67,14 +72,22 @@ export class NetworkEnablementController extends BaseController {
      * @param args.state - Initial state to set on this controller.
      */
     constructor({ messenger, state, }) {
+        const defaultState = getDefaultNetworkEnablementControllerState();
+        const finalState = {
+            ...defaultState,
+            ...state,
+        };
+        console.log('[NetworkEnablementController] Constructor - passed state:', state ? 'YES (will override defaults)' : 'NO (using defaults)');
+        console.log('[NetworkEnablementController] Constructor - default EVM networks count:', Object.keys(defaultState.enabledNetworkMap[KnownCaipNamespace.Eip155])
+            .length);
+        console.log('[NetworkEnablementController] Constructor - final EVM networks count:', Object.keys(finalState.enabledNetworkMap[KnownCaipNamespace.Eip155])
+            .length);
+        console.log('[NetworkEnablementController] Constructor - final enabled EVM networks:', Object.keys(finalState.enabledNetworkMap[KnownCaipNamespace.Eip155]));
         super({
             messenger,
             metadata,
             name: controllerName,
-            state: {
-                ...getDefaultNetworkEnablementControllerState(),
-                ...state,
-            },
+            state: finalState,
         });
         _NetworkEnablementController_instances.add(this);
         messenger.subscribe('NetworkController:networkAdded', ({ chainId }) => {
@@ -102,20 +115,21 @@ export class NetworkEnablementController extends BaseController {
      */
     enableNetwork(chainId) {
         const { namespace, storageKey } = deriveKeys(chainId);
-        this.update((s) => {
+        console.log('[NetworkEnablementController] enableNetwork called for:', chainId, 'namespace:', namespace, 'storageKey:', storageKey);
+        this.update((state) => {
             // disable all networks in all namespaces first
-            Object.keys(s.enabledNetworkMap).forEach((ns) => {
-                Object.keys(s.enabledNetworkMap[ns]).forEach((key) => {
-                    s.enabledNetworkMap[ns][key] = false;
+            Object.keys(state.enabledNetworkMap).forEach((ns) => {
+                Object.keys(state.enabledNetworkMap[ns]).forEach((key) => {
+                    state.enabledNetworkMap[ns][key] = false;
                 });
             });
             // if the namespace bucket does not exist, return
             // new nemespace are added only when a new network is added
-            if (!s.enabledNetworkMap[namespace]) {
+            if (!state.enabledNetworkMap[namespace]) {
                 return;
             }
             // enable the network
-            s.enabledNetworkMap[namespace][storageKey] = true;
+            state.enabledNetworkMap[namespace][storageKey] = true;
         });
     }
     /**
@@ -140,17 +154,17 @@ export class NetworkEnablementController extends BaseController {
         if (derivedNamespace !== namespace) {
             throw new Error(`Chain ID ${chainId} belongs to namespace ${derivedNamespace}, but namespace ${namespace} was specified`);
         }
-        this.update((s) => {
+        this.update((state) => {
             // Ensure the namespace bucket exists
-            __classPrivateFieldGet(this, _NetworkEnablementController_instances, "m", _NetworkEnablementController_ensureNamespaceBucket).call(this, s, namespace);
+            __classPrivateFieldGet(this, _NetworkEnablementController_instances, "m", _NetworkEnablementController_ensureNamespaceBucket).call(this, state, namespace);
             // Disable all networks in the specified namespace first
-            if (s.enabledNetworkMap[namespace]) {
-                Object.keys(s.enabledNetworkMap[namespace]).forEach((key) => {
-                    s.enabledNetworkMap[namespace][key] = false;
+            if (state.enabledNetworkMap[namespace]) {
+                Object.keys(state.enabledNetworkMap[namespace]).forEach((key) => {
+                    state.enabledNetworkMap[namespace][key] = false;
                 });
             }
             // Enable the target network in the specified namespace
-            s.enabledNetworkMap[namespace][storageKey] = true;
+            state.enabledNetworkMap[namespace][storageKey] = true;
         });
     }
     /**
@@ -164,51 +178,62 @@ export class NetworkEnablementController extends BaseController {
      * Popular networks that don't exist in NetworkController or MultichainNetworkController configurations will be skipped silently.
      */
     enableAllPopularNetworks() {
-        this.update((s) => {
+        console.log('[NetworkEnablementController] enableAllPopularNetworks called - attempting to enable', POPULAR_NETWORKS.length, 'networks');
+        this.update((state) => {
             // First disable all networks across all namespaces
-            Object.keys(s.enabledNetworkMap).forEach((ns) => {
-                Object.keys(s.enabledNetworkMap[ns]).forEach((key) => {
-                    s.enabledNetworkMap[ns][key] = false;
+            Object.keys(state.enabledNetworkMap).forEach((ns) => {
+                Object.keys(state.enabledNetworkMap[ns]).forEach((key) => {
+                    state.enabledNetworkMap[ns][key] = false;
                 });
             });
             // Get current network configurations to check if networks exist
             const networkControllerState = this.messenger.call('NetworkController:getState');
             const multichainState = this.messenger.call('MultichainNetworkController:getState');
+            console.log('[NetworkEnablementController] NetworkController has', Object.keys(networkControllerState.networkConfigurationsByChainId)
+                .length, 'networks configured');
+            let enabledCount = 0;
             // Enable all popular EVM networks that exist in NetworkController configurations
             POPULAR_NETWORKS.forEach((chainId) => {
                 const { namespace, storageKey } = deriveKeys(chainId);
                 // Check if network exists in NetworkController configurations
                 if (networkControllerState.networkConfigurationsByChainId[chainId]) {
                     // Ensure namespace bucket exists
-                    __classPrivateFieldGet(this, _NetworkEnablementController_instances, "m", _NetworkEnablementController_ensureNamespaceBucket).call(this, s, namespace);
+                    __classPrivateFieldGet(this, _NetworkEnablementController_instances, "m", _NetworkEnablementController_ensureNamespaceBucket).call(this, state, namespace);
                     // Enable the network
-                    s.enabledNetworkMap[namespace][storageKey] = true;
+                    state.enabledNetworkMap[namespace][storageKey] = true;
+                    enabledCount += 1;
+                    console.log('[NetworkEnablementController] Enabled network:', chainId, storageKey);
+                }
+                else {
+                    console.log('[NetworkEnablementController] Network not found in NetworkController, skipping:', chainId);
                 }
             });
+            console.log('[NetworkEnablementController] Successfully enabled', enabledCount, 'of', POPULAR_NETWORKS.length, 'popular networks');
             // Enable Solana mainnet if it exists in MultichainNetworkController configurations
             const solanaKeys = deriveKeys(SolScope.Mainnet);
             if (multichainState.multichainNetworkConfigurationsByChainId[SolScope.Mainnet]) {
                 // Ensure namespace bucket exists
-                __classPrivateFieldGet(this, _NetworkEnablementController_instances, "m", _NetworkEnablementController_ensureNamespaceBucket).call(this, s, solanaKeys.namespace);
+                __classPrivateFieldGet(this, _NetworkEnablementController_instances, "m", _NetworkEnablementController_ensureNamespaceBucket).call(this, state, solanaKeys.namespace);
                 // Enable Solana mainnet
-                s.enabledNetworkMap[solanaKeys.namespace][solanaKeys.storageKey] = true;
+                state.enabledNetworkMap[solanaKeys.namespace][solanaKeys.storageKey] =
+                    true;
             }
             // Enable Bitcoin mainnet if it exists in MultichainNetworkController configurations
             const bitcoinKeys = deriveKeys(BtcScope.Mainnet);
             if (multichainState.multichainNetworkConfigurationsByChainId[BtcScope.Mainnet]) {
                 // Ensure namespace bucket exists
-                __classPrivateFieldGet(this, _NetworkEnablementController_instances, "m", _NetworkEnablementController_ensureNamespaceBucket).call(this, s, bitcoinKeys.namespace);
+                __classPrivateFieldGet(this, _NetworkEnablementController_instances, "m", _NetworkEnablementController_ensureNamespaceBucket).call(this, state, bitcoinKeys.namespace);
                 // Enable Bitcoin mainnet
-                s.enabledNetworkMap[bitcoinKeys.namespace][bitcoinKeys.storageKey] =
+                state.enabledNetworkMap[bitcoinKeys.namespace][bitcoinKeys.storageKey] =
                     true;
             }
             // Enable Tron mainnet if it exists in MultichainNetworkController configurations
             const tronKeys = deriveKeys(TrxScope.Mainnet);
             if (multichainState.multichainNetworkConfigurationsByChainId[TrxScope.Mainnet]) {
                 // Ensure namespace bucket exists
-                __classPrivateFieldGet(this, _NetworkEnablementController_instances, "m", _NetworkEnablementController_ensureNamespaceBucket).call(this, s, tronKeys.namespace);
+                __classPrivateFieldGet(this, _NetworkEnablementController_instances, "m", _NetworkEnablementController_ensureNamespaceBucket).call(this, state, tronKeys.namespace);
                 // Enable Tron mainnet
-                s.enabledNetworkMap[tronKeys.namespace][tronKeys.storageKey] = true;
+                state.enabledNetworkMap[tronKeys.namespace][tronKeys.storageKey] = true;
             }
         });
     }
@@ -224,28 +249,26 @@ export class NetworkEnablementController extends BaseController {
      * have been initialized and their configurations are available.
      */
     init() {
-        this.update((s) => {
+        this.update((state) => {
             // Get network configurations from NetworkController (EVM networks)
             const networkControllerState = this.messenger.call('NetworkController:getState');
             // Get network configurations from MultichainNetworkController (all networks)
             const multichainState = this.messenger.call('MultichainNetworkController:getState');
             // Initialize namespace buckets for EVM networks from NetworkController
             Object.keys(networkControllerState.networkConfigurationsByChainId).forEach((chainId) => {
+                var _a;
                 const { namespace, storageKey } = deriveKeys(chainId);
-                __classPrivateFieldGet(this, _NetworkEnablementController_instances, "m", _NetworkEnablementController_ensureNamespaceBucket).call(this, s, namespace);
+                __classPrivateFieldGet(this, _NetworkEnablementController_instances, "m", _NetworkEnablementController_ensureNamespaceBucket).call(this, state, namespace);
                 // Only add network if it doesn't already exist in state (preserves user settings)
-                if (s.enabledNetworkMap[namespace][storageKey] === undefined) {
-                    s.enabledNetworkMap[namespace][storageKey] = false;
-                }
+                (_a = state.enabledNetworkMap[namespace])[storageKey] ?? (_a[storageKey] = false);
             });
             // Initialize namespace buckets for all networks from MultichainNetworkController
             Object.keys(multichainState.multichainNetworkConfigurationsByChainId).forEach((chainId) => {
+                var _a;
                 const { namespace, storageKey } = deriveKeys(chainId);
-                __classPrivateFieldGet(this, _NetworkEnablementController_instances, "m", _NetworkEnablementController_ensureNamespaceBucket).call(this, s, namespace);
+                __classPrivateFieldGet(this, _NetworkEnablementController_instances, "m", _NetworkEnablementController_ensureNamespaceBucket).call(this, state, namespace);
                 // Only add network if it doesn't already exist in state (preserves user settings)
-                if (s.enabledNetworkMap[namespace][storageKey] === undefined) {
-                    s.enabledNetworkMap[namespace][storageKey] = false;
-                }
+                (_a = state.enabledNetworkMap[namespace])[storageKey] ?? (_a[storageKey] = false);
             });
         });
     }
@@ -266,8 +289,8 @@ export class NetworkEnablementController extends BaseController {
     disableNetwork(chainId) {
         const derivedKeys = deriveKeys(chainId);
         const { namespace, storageKey } = derivedKeys;
-        this.update((s) => {
-            s.enabledNetworkMap[namespace][storageKey] = false;
+        this.update((state) => {
+            state.enabledNetworkMap[namespace][storageKey] = false;
         });
     }
     /**
@@ -306,21 +329,20 @@ _NetworkEnablementController_instances = new WeakSet(), _NetworkEnablementContro
 }, _NetworkEnablementController_removeNetworkEntry = function _NetworkEnablementController_removeNetworkEntry(chainId) {
     const derivedKeys = deriveKeys(chainId);
     const { namespace, storageKey } = derivedKeys;
-    this.update((s) => {
+    this.update((state) => {
         // fallback and enable ethereum mainnet
         if (isOnlyNetworkEnabledInNamespace(this.state, derivedKeys)) {
-            s.enabledNetworkMap[namespace][ChainId[BuiltInNetworkName.Mainnet]] =
-                true;
+            state.enabledNetworkMap[namespace][ChainId[BuiltInNetworkName.Mainnet]] = true;
         }
-        if (namespace in s.enabledNetworkMap) {
-            delete s.enabledNetworkMap[namespace][storageKey];
+        if (namespace in state.enabledNetworkMap) {
+            delete state.enabledNetworkMap[namespace][storageKey];
         }
     });
 }, _NetworkEnablementController_onAddNetwork = function _NetworkEnablementController_onAddNetwork(chainId) {
     const { namespace, storageKey, reference } = deriveKeys(chainId);
-    this.update((s) => {
+    this.update((state) => {
         // Ensure the namespace bucket exists
-        __classPrivateFieldGet(this, _NetworkEnablementController_instances, "m", _NetworkEnablementController_ensureNamespaceBucket).call(this, s, namespace);
+        __classPrivateFieldGet(this, _NetworkEnablementController_instances, "m", _NetworkEnablementController_ensureNamespaceBucket).call(this, state, namespace);
         // Check if popular networks mode is active (>2 popular networks enabled)
         const inPopularNetworksMode = __classPrivateFieldGet(this, _NetworkEnablementController_instances, "m", _NetworkEnablementController_isInPopularNetworksMode).call(this);
         // Check if the network being added is a popular network
@@ -329,17 +351,17 @@ _NetworkEnablementController_instances = new WeakSet(), _NetworkEnablementContro
         const shouldKeepCurrentSelection = inPopularNetworksMode && isAddedNetworkPopular;
         if (shouldKeepCurrentSelection) {
             // Add the popular network but don't enable it (keep current selection)
-            s.enabledNetworkMap[namespace][storageKey] = true;
+            state.enabledNetworkMap[namespace][storageKey] = true;
         }
         else {
             // Switch to the newly added network (disable all others, enable this one)
-            Object.keys(s.enabledNetworkMap).forEach((ns) => {
-                Object.keys(s.enabledNetworkMap[ns]).forEach((key) => {
-                    s.enabledNetworkMap[ns][key] = false;
+            Object.keys(state.enabledNetworkMap).forEach((ns) => {
+                Object.keys(state.enabledNetworkMap[ns]).forEach((key) => {
+                    state.enabledNetworkMap[ns][key] = false;
                 });
             });
             // Enable the newly added network
-            s.enabledNetworkMap[namespace][storageKey] = true;
+            state.enabledNetworkMap[namespace][storageKey] = true;
         }
     });
 };
diff --git a/dist/NetworkEnablementController.mjs.map b/dist/NetworkEnablementController.mjs.map
index a10329453b067507d79594a2dba5a02155235d34..0e53bf24fc0698407db49b1a4c977525cb845837 100644
--- a/dist/NetworkEnablementController.mjs.map
+++ b/dist/NetworkEnablementController.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"NetworkEnablementController.mjs","sourceRoot":"","sources":["../src/NetworkEnablementController.ts"],"names":[],"mappings":"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","sourcesContent":["import { BaseController } from '@metamask/base-controller';\nimport type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n} from '@metamask/base-controller';\nimport { BuiltInNetworkName, ChainId } from '@metamask/controller-utils';\nimport { BtcScope, SolScope, TrxScope } from '@metamask/keyring-api';\nimport type { Messenger } from '@metamask/messenger';\nimport type { MultichainNetworkControllerGetStateAction } from '@metamask/multichain-network-controller';\nimport type {\n  NetworkControllerGetStateAction,\n  NetworkControllerNetworkAddedEvent,\n  NetworkControllerNetworkRemovedEvent,\n  NetworkControllerStateChangeEvent,\n} from '@metamask/network-controller';\nimport type { TransactionControllerTransactionSubmittedEvent } from '@metamask/transaction-controller';\nimport type { CaipChainId, CaipNamespace, Hex } from '@metamask/utils';\nimport { KnownCaipNamespace } from '@metamask/utils';\n\nimport { POPULAR_NETWORKS } from './constants';\nimport {\n  deriveKeys,\n  isOnlyNetworkEnabledInNamespace,\n  isPopularNetwork,\n} from './utils';\n\nconst controllerName = 'NetworkEnablementController';\n\n/**\n * Information about an ordered network.\n */\nexport type NetworksInfo = {\n  /**\n   * The network's chain id\n   */\n  networkId: CaipChainId;\n};\n\n/**\n * A map of enabled networks by CAIP namespace and chain ID.\n * For EIP-155 networks, the keys are Hex chain IDs.\n * For other networks, the keys are CAIP chain IDs.\n */\ntype EnabledMap = Record<CaipNamespace, Record<CaipChainId | Hex, boolean>>;\n\n// State shape for NetworkEnablementController\nexport type NetworkEnablementControllerState = {\n  enabledNetworkMap: EnabledMap;\n};\n\nexport type NetworkEnablementControllerGetStateAction =\n  ControllerGetStateAction<\n    typeof controllerName,\n    NetworkEnablementControllerState\n  >;\n\nexport type NetworkEnablementControllerSetEnabledNetworksAction = {\n  type: `${typeof controllerName}:enableNetwork`;\n  handler: NetworkEnablementController['enableNetwork'];\n};\n\nexport type NetworkEnablementControllerDisableNetworkAction = {\n  type: `${typeof controllerName}:disableNetwork`;\n  handler: NetworkEnablementController['disableNetwork'];\n};\n\n/**\n * All actions that {@link NetworkEnablementController} calls internally.\n */\nexport type AllowedActions =\n  | NetworkControllerGetStateAction\n  | MultichainNetworkControllerGetStateAction;\n\nexport type NetworkEnablementControllerActions =\n  | NetworkEnablementControllerGetStateAction\n  | NetworkEnablementControllerSetEnabledNetworksAction\n  | NetworkEnablementControllerDisableNetworkAction;\n\nexport type NetworkEnablementControllerStateChangeEvent =\n  ControllerStateChangeEvent<\n    typeof controllerName,\n    NetworkEnablementControllerState\n  >;\n\nexport type NetworkEnablementControllerEvents =\n  NetworkEnablementControllerStateChangeEvent;\n\n/**\n * All events that {@link NetworkEnablementController} subscribes to internally.\n */\nexport type AllowedEvents =\n  | NetworkControllerNetworkAddedEvent\n  | NetworkControllerNetworkRemovedEvent\n  | NetworkControllerStateChangeEvent\n  | TransactionControllerTransactionSubmittedEvent;\n\nexport type NetworkEnablementControllerMessenger = Messenger<\n  typeof controllerName,\n  NetworkEnablementControllerActions | AllowedActions,\n  NetworkEnablementControllerEvents | AllowedEvents\n>;\n\n/**\n * Gets the default state for the NetworkEnablementController.\n *\n * @returns The default state with pre-enabled networks.\n */\nconst getDefaultNetworkEnablementControllerState =\n  (): NetworkEnablementControllerState => ({\n    enabledNetworkMap: {\n      [KnownCaipNamespace.Eip155]: {\n        [ChainId[BuiltInNetworkName.Mainnet]]: true,\n        [ChainId[BuiltInNetworkName.LineaMainnet]]: true,\n        [ChainId[BuiltInNetworkName.BaseMainnet]]: true,\n      },\n      [KnownCaipNamespace.Solana]: {\n        [SolScope.Mainnet]: true,\n        [SolScope.Testnet]: false,\n        [SolScope.Devnet]: false,\n      },\n      [KnownCaipNamespace.Bip122]: {\n        [BtcScope.Mainnet]: true,\n        [BtcScope.Testnet]: false,\n        [BtcScope.Signet]: false,\n      },\n      [KnownCaipNamespace.Tron]: {\n        [TrxScope.Mainnet]: true,\n        [TrxScope.Nile]: false,\n        [TrxScope.Shasta]: false,\n      },\n    },\n  });\n\n// Metadata for the controller state\nconst metadata = {\n  enabledNetworkMap: {\n    includeInStateLogs: true,\n    persist: true,\n    includeInDebugSnapshot: true,\n    usedInUi: true,\n  },\n};\n\n/**\n * Controller responsible for managing network enablement state across different blockchain networks.\n *\n * This controller tracks which networks are enabled/disabled for the user and provides methods\n * to toggle network states. It supports both EVM (EIP-155) and non-EVM networks like Solana.\n *\n * The controller maintains a map of enabled networks organized by namespace (e.g., 'eip155', 'solana')\n * and provides methods to query and modify network enablement states.\n */\nexport class NetworkEnablementController extends BaseController<\n  typeof controllerName,\n  NetworkEnablementControllerState,\n  NetworkEnablementControllerMessenger\n> {\n  /**\n   * Creates a NetworkEnablementController instance.\n   *\n   * @param args - The arguments to this function.\n   * @param args.messenger - Messenger used to communicate with BaseV2 controller.\n   * @param args.state - Initial state to set on this controller.\n   */\n  constructor({\n    messenger,\n    state,\n  }: {\n    messenger: NetworkEnablementControllerMessenger;\n    state?: Partial<NetworkEnablementControllerState>;\n  }) {\n    super({\n      messenger,\n      metadata,\n      name: controllerName,\n      state: {\n        ...getDefaultNetworkEnablementControllerState(),\n        ...state,\n      },\n    });\n\n    messenger.subscribe('NetworkController:networkAdded', ({ chainId }) => {\n      this.#onAddNetwork(chainId);\n    });\n\n    messenger.subscribe('NetworkController:networkRemoved', ({ chainId }) => {\n      this.#removeNetworkEntry(chainId);\n    });\n  }\n\n  /**\n   * Enables or disables a network for the user.\n   *\n   * This method accepts either a Hex chain ID (for EVM networks) or a CAIP-2 chain ID\n   * (for any blockchain network). The method will automatically convert Hex chain IDs\n   * to CAIP-2 format internally. This dual parameter support allows for backward\n   * compatibility with existing EVM chain ID formats while supporting newer\n   * multi-chain standards.\n   *\n   * When enabling a non-popular network, this method will disable all other networks\n   * to ensure only one network is active at a time (exclusive mode).\n   *\n   * @param chainId - The chain ID of the network to enable or disable. Can be either:\n   * - A Hex string (e.g., '0x1' for Ethereum mainnet) for EVM networks\n   * - A CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet, 'solana:mainnet' for Solana)\n   */\n  enableNetwork(chainId: Hex | CaipChainId): void {\n    const { namespace, storageKey } = deriveKeys(chainId);\n\n    this.update((s) => {\n      // disable all networks in all namespaces first\n      Object.keys(s.enabledNetworkMap).forEach((ns) => {\n        Object.keys(s.enabledNetworkMap[ns]).forEach((key) => {\n          s.enabledNetworkMap[ns][key as CaipChainId | Hex] = false;\n        });\n      });\n\n      // if the namespace bucket does not exist, return\n      // new nemespace are added only when a new network is added\n      if (!s.enabledNetworkMap[namespace]) {\n        return;\n      }\n\n      // enable the network\n      s.enabledNetworkMap[namespace][storageKey] = true;\n    });\n  }\n\n  /**\n   * Enables a network for the user within a specific namespace.\n   *\n   * This method accepts either a Hex chain ID (for EVM networks) or a CAIP-2 chain ID\n   * (for any blockchain network) and enables it within the specified namespace.\n   * The method validates that the chainId belongs to the specified namespace for safety.\n   *\n   * Before enabling the target network, this method disables all other networks\n   * in the same namespace to ensure exclusive behavior within the namespace.\n   *\n   * @param chainId - The chain ID of the network to enable. Can be either:\n   * - A Hex string (e.g., '0x1' for Ethereum mainnet) for EVM networks\n   * - A CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet, 'solana:mainnet' for Solana)\n   * @param namespace - The CAIP namespace where the network should be enabled\n   * @throws Error if the chainId's derived namespace doesn't match the provided namespace\n   */\n  enableNetworkInNamespace(\n    chainId: Hex | CaipChainId,\n    namespace: CaipNamespace,\n  ): void {\n    const { namespace: derivedNamespace, storageKey } = deriveKeys(chainId);\n\n    // Validate that the derived namespace matches the provided namespace\n    if (derivedNamespace !== namespace) {\n      throw new Error(\n        `Chain ID ${chainId} belongs to namespace ${derivedNamespace}, but namespace ${namespace} was specified`,\n      );\n    }\n\n    this.update((s) => {\n      // Ensure the namespace bucket exists\n      this.#ensureNamespaceBucket(s, namespace);\n\n      // Disable all networks in the specified namespace first\n      if (s.enabledNetworkMap[namespace]) {\n        Object.keys(s.enabledNetworkMap[namespace]).forEach((key) => {\n          s.enabledNetworkMap[namespace][key as CaipChainId | Hex] = false;\n        });\n      }\n\n      // Enable the target network in the specified namespace\n      s.enabledNetworkMap[namespace][storageKey] = true;\n    });\n  }\n\n  /**\n   * Enables all popular networks and Solana mainnet.\n   *\n   * This method first disables all networks across all namespaces, then enables\n   * all networks defined in POPULAR_NETWORKS (EVM networks), Solana mainnet, and\n   * Bitcoin mainnet. This provides exclusive behavior - only popular networks will\n   * be enabled after calling this method.\n   *\n   * Popular networks that don't exist in NetworkController or MultichainNetworkController configurations will be skipped silently.\n   */\n  enableAllPopularNetworks(): void {\n    this.update((s) => {\n      // First disable all networks across all namespaces\n      Object.keys(s.enabledNetworkMap).forEach((ns) => {\n        Object.keys(s.enabledNetworkMap[ns]).forEach((key) => {\n          s.enabledNetworkMap[ns][key as CaipChainId | Hex] = false;\n        });\n      });\n\n      // Get current network configurations to check if networks exist\n      const networkControllerState = this.messenger.call(\n        'NetworkController:getState',\n      );\n      const multichainState = this.messenger.call(\n        'MultichainNetworkController:getState',\n      );\n\n      // Enable all popular EVM networks that exist in NetworkController configurations\n      POPULAR_NETWORKS.forEach((chainId) => {\n        const { namespace, storageKey } = deriveKeys(chainId as Hex);\n\n        // Check if network exists in NetworkController configurations\n        if (\n          networkControllerState.networkConfigurationsByChainId[chainId as Hex]\n        ) {\n          // Ensure namespace bucket exists\n          this.#ensureNamespaceBucket(s, namespace);\n          // Enable the network\n          s.enabledNetworkMap[namespace][storageKey] = true;\n        }\n      });\n\n      // Enable Solana mainnet if it exists in MultichainNetworkController configurations\n      const solanaKeys = deriveKeys(SolScope.Mainnet as CaipChainId);\n      if (\n        multichainState.multichainNetworkConfigurationsByChainId[\n          SolScope.Mainnet\n        ]\n      ) {\n        // Ensure namespace bucket exists\n        this.#ensureNamespaceBucket(s, solanaKeys.namespace);\n        // Enable Solana mainnet\n        s.enabledNetworkMap[solanaKeys.namespace][solanaKeys.storageKey] = true;\n      }\n\n      // Enable Bitcoin mainnet if it exists in MultichainNetworkController configurations\n      const bitcoinKeys = deriveKeys(BtcScope.Mainnet as CaipChainId);\n      if (\n        multichainState.multichainNetworkConfigurationsByChainId[\n          BtcScope.Mainnet\n        ]\n      ) {\n        // Ensure namespace bucket exists\n        this.#ensureNamespaceBucket(s, bitcoinKeys.namespace);\n        // Enable Bitcoin mainnet\n        s.enabledNetworkMap[bitcoinKeys.namespace][bitcoinKeys.storageKey] =\n          true;\n      }\n\n      // Enable Tron mainnet if it exists in MultichainNetworkController configurations\n      const tronKeys = deriveKeys(TrxScope.Mainnet as CaipChainId);\n      if (\n        multichainState.multichainNetworkConfigurationsByChainId[\n          TrxScope.Mainnet\n        ]\n      ) {\n        // Ensure namespace bucket exists\n        this.#ensureNamespaceBucket(s, tronKeys.namespace);\n        // Enable Tron mainnet\n        s.enabledNetworkMap[tronKeys.namespace][tronKeys.storageKey] = true;\n      }\n    });\n  }\n\n  /**\n   * Initializes the network enablement state from network controller configurations.\n   *\n   * This method reads the current network configurations from both NetworkController\n   * and MultichainNetworkController and syncs the enabled network map accordingly.\n   * It ensures proper namespace buckets exist for all configured networks and only\n   * adds missing networks with a default value of false, preserving existing user settings.\n   *\n   * This method should be called after the NetworkController and MultichainNetworkController\n   * have been initialized and their configurations are available.\n   */\n  init(): void {\n    this.update((s) => {\n      // Get network configurations from NetworkController (EVM networks)\n      const networkControllerState = this.messenger.call(\n        'NetworkController:getState',\n      );\n\n      // Get network configurations from MultichainNetworkController (all networks)\n      const multichainState = this.messenger.call(\n        'MultichainNetworkController:getState',\n      );\n\n      // Initialize namespace buckets for EVM networks from NetworkController\n      Object.keys(\n        networkControllerState.networkConfigurationsByChainId,\n      ).forEach((chainId) => {\n        const { namespace, storageKey } = deriveKeys(chainId as Hex);\n        this.#ensureNamespaceBucket(s, namespace);\n\n        // Only add network if it doesn't already exist in state (preserves user settings)\n        if (s.enabledNetworkMap[namespace][storageKey] === undefined) {\n          s.enabledNetworkMap[namespace][storageKey] = false;\n        }\n      });\n\n      // Initialize namespace buckets for all networks from MultichainNetworkController\n      Object.keys(\n        multichainState.multichainNetworkConfigurationsByChainId,\n      ).forEach((chainId) => {\n        const { namespace, storageKey } = deriveKeys(chainId as CaipChainId);\n        this.#ensureNamespaceBucket(s, namespace);\n\n        // Only add network if it doesn't already exist in state (preserves user settings)\n        if (s.enabledNetworkMap[namespace][storageKey] === undefined) {\n          s.enabledNetworkMap[namespace][storageKey] = false;\n        }\n      });\n    });\n  }\n\n  /**\n   * Disables a network for the user.\n   *\n   * This method accepts either a Hex chain ID (for EVM networks) or a CAIP-2 chain ID\n   * (for any blockchain network). The method will automatically convert Hex chain IDs\n   * to CAIP-2 format internally.\n   *\n   * Note: This method will prevent disabling the last remaining enabled network\n   * to ensure at least one network is always available.\n   *\n   * @param chainId - The chain ID of the network to disable. Can be either:\n   * - A Hex string (e.g., '0x1' for Ethereum mainnet) for EVM networks\n   * - A CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet, 'solana:mainnet' for Solana)\n   */\n  disableNetwork(chainId: Hex | CaipChainId): void {\n    const derivedKeys = deriveKeys(chainId);\n    const { namespace, storageKey } = derivedKeys;\n\n    this.update((s) => {\n      s.enabledNetworkMap[namespace][storageKey] = false;\n    });\n  }\n\n  /**\n   * Checks if a network is enabled.\n   *\n   * @param chainId - The chain ID of the network to check. Can be either:\n   * - A Hex string (e.g., '0x1' for Ethereum mainnet) for EVM networks\n   * - A CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet, 'solana:mainnet' for Solana)\n   * @returns True if the network is enabled, false otherwise\n   */\n  isNetworkEnabled(chainId: Hex | CaipChainId): boolean {\n    const derivedKeys = deriveKeys(chainId);\n    const { namespace, storageKey } = derivedKeys;\n    return this.state.enabledNetworkMap[namespace]?.[storageKey] ?? false;\n  }\n\n  /**\n   * Ensures that a namespace bucket exists in the state.\n   *\n   * This method creates the namespace entry in the enabledNetworkMap if it doesn't\n   * already exist. This is used to prepare the state structure before adding\n   * network entries.\n   *\n   * @param state - The current controller state\n   * @param ns - The CAIP namespace to ensure exists\n   */\n  #ensureNamespaceBucket(\n    state: NetworkEnablementControllerState,\n    ns: CaipNamespace,\n  ) {\n    if (!state.enabledNetworkMap[ns]) {\n      state.enabledNetworkMap[ns] = {};\n    }\n  }\n\n  /**\n   * Checks if popular networks mode is active (more than 2 popular networks enabled).\n   *\n   * This method counts how many networks defined in POPULAR_NETWORKS are currently\n   * enabled in the state and returns true if more than 2 are enabled. It only checks\n   * networks that actually exist in the NetworkController configurations.\n   *\n   * @returns True if more than 2 popular networks are enabled, false otherwise\n   */\n  #isInPopularNetworksMode(): boolean {\n    // Get current network configurations to check which popular networks exist\n    const networkControllerState = this.messenger.call(\n      'NetworkController:getState',\n    );\n\n    // Count how many popular networks are enabled\n    const enabledPopularNetworksCount = POPULAR_NETWORKS.reduce(\n      (count, chainId) => {\n        // Only check networks that actually exist in NetworkController configurations\n        if (\n          !networkControllerState.networkConfigurationsByChainId[chainId as Hex]\n        ) {\n          return count; // Skip networks that don't exist\n        }\n\n        const { namespace, storageKey } = deriveKeys(chainId as Hex);\n        const isEnabled = this.state.enabledNetworkMap[namespace]?.[storageKey];\n        return isEnabled ? count + 1 : count;\n      },\n      0,\n    );\n\n    // Return true if more than 2 popular networks are enabled\n    return enabledPopularNetworksCount > 1;\n  }\n\n  /**\n   * Removes a network entry from the state.\n   *\n   * This method is called when a network is removed from the system. It cleans up\n   * the network entry and ensures that at least one network remains enabled.\n   *\n   * @param chainId - The chain ID to remove (Hex or CAIP-2 format)\n   */\n  #removeNetworkEntry(chainId: Hex | CaipChainId): void {\n    const derivedKeys = deriveKeys(chainId);\n    const { namespace, storageKey } = derivedKeys;\n\n    this.update((s) => {\n      // fallback and enable ethereum mainnet\n      if (isOnlyNetworkEnabledInNamespace(this.state, derivedKeys)) {\n        s.enabledNetworkMap[namespace][ChainId[BuiltInNetworkName.Mainnet]] =\n          true;\n      }\n\n      if (namespace in s.enabledNetworkMap) {\n        delete s.enabledNetworkMap[namespace][storageKey];\n      }\n    });\n  }\n\n  /**\n   * Handles the addition of a new network to the controller.\n   *\n   * @param chainId - The chain ID to add (Hex or CAIP-2 format)\n   *\n   * @description\n   * - If in popular networks mode (>2 popular networks enabled) AND adding a popular network:\n   * - Keep current selection (add but don't enable the new network)\n   * - Otherwise:\n   * - Switch to the newly added network (disable all others, enable this one)\n   */\n  #onAddNetwork(chainId: Hex | CaipChainId): void {\n    const { namespace, storageKey, reference } = deriveKeys(chainId);\n\n    this.update((s) => {\n      // Ensure the namespace bucket exists\n      this.#ensureNamespaceBucket(s, namespace);\n\n      // Check if popular networks mode is active (>2 popular networks enabled)\n      const inPopularNetworksMode = this.#isInPopularNetworksMode();\n\n      // Check if the network being added is a popular network\n      const isAddedNetworkPopular = isPopularNetwork(reference);\n\n      // Keep current selection only if in popular networks mode AND adding a popular network\n      const shouldKeepCurrentSelection =\n        inPopularNetworksMode && isAddedNetworkPopular;\n\n      if (shouldKeepCurrentSelection) {\n        // Add the popular network but don't enable it (keep current selection)\n        s.enabledNetworkMap[namespace][storageKey] = true;\n      } else {\n        // Switch to the newly added network (disable all others, enable this one)\n        Object.keys(s.enabledNetworkMap).forEach((ns) => {\n          Object.keys(s.enabledNetworkMap[ns]).forEach((key) => {\n            s.enabledNetworkMap[ns][key as CaipChainId | Hex] = false;\n          });\n        });\n        // Enable the newly added network\n        s.enabledNetworkMap[namespace][storageKey] = true;\n      }\n    });\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"NetworkEnablementController.mjs","sourceRoot":"","sources":["../src/NetworkEnablementController.ts"],"names":[],"mappings":"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","sourcesContent":["import { BaseController } from '@metamask/base-controller';\nimport type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n} from '@metamask/base-controller';\nimport { BuiltInNetworkName, ChainId } from '@metamask/controller-utils';\nimport { BtcScope, SolScope, TrxScope } from '@metamask/keyring-api';\nimport type { Messenger } from '@metamask/messenger';\nimport type { MultichainNetworkControllerGetStateAction } from '@metamask/multichain-network-controller';\nimport type {\n  NetworkControllerGetStateAction,\n  NetworkControllerNetworkAddedEvent,\n  NetworkControllerNetworkRemovedEvent,\n  NetworkControllerStateChangeEvent,\n} from '@metamask/network-controller';\nimport type { TransactionControllerTransactionSubmittedEvent } from '@metamask/transaction-controller';\nimport type { CaipChainId, CaipNamespace, Hex } from '@metamask/utils';\nimport { KnownCaipNamespace } from '@metamask/utils';\n\nimport { POPULAR_NETWORKS } from './constants';\nimport {\n  deriveKeys,\n  isOnlyNetworkEnabledInNamespace,\n  isPopularNetwork,\n} from './utils';\n\nconst controllerName = 'NetworkEnablementController';\n\n/**\n * Information about an ordered network.\n */\nexport type NetworksInfo = {\n  /**\n   * The network's chain id\n   */\n  networkId: CaipChainId;\n};\n\n/**\n * A map of enabled networks by CAIP namespace and chain ID.\n * For EIP-155 networks, the keys are Hex chain IDs.\n * For other networks, the keys are CAIP chain IDs.\n */\ntype EnabledMap = Record<CaipNamespace, Record<CaipChainId | Hex, boolean>>;\n\n// State shape for NetworkEnablementController\nexport type NetworkEnablementControllerState = {\n  enabledNetworkMap: EnabledMap;\n};\n\nexport type NetworkEnablementControllerGetStateAction =\n  ControllerGetStateAction<\n    typeof controllerName,\n    NetworkEnablementControllerState\n  >;\n\nexport type NetworkEnablementControllerSetEnabledNetworksAction = {\n  type: `${typeof controllerName}:enableNetwork`;\n  handler: NetworkEnablementController['enableNetwork'];\n};\n\nexport type NetworkEnablementControllerDisableNetworkAction = {\n  type: `${typeof controllerName}:disableNetwork`;\n  handler: NetworkEnablementController['disableNetwork'];\n};\n\n/**\n * All actions that {@link NetworkEnablementController} calls internally.\n */\nexport type AllowedActions =\n  | NetworkControllerGetStateAction\n  | MultichainNetworkControllerGetStateAction;\n\nexport type NetworkEnablementControllerActions =\n  | NetworkEnablementControllerGetStateAction\n  | NetworkEnablementControllerSetEnabledNetworksAction\n  | NetworkEnablementControllerDisableNetworkAction;\n\nexport type NetworkEnablementControllerStateChangeEvent =\n  ControllerStateChangeEvent<\n    typeof controllerName,\n    NetworkEnablementControllerState\n  >;\n\nexport type NetworkEnablementControllerEvents =\n  NetworkEnablementControllerStateChangeEvent;\n\n/**\n * All events that {@link NetworkEnablementController} subscribes to internally.\n */\nexport type AllowedEvents =\n  | NetworkControllerNetworkAddedEvent\n  | NetworkControllerNetworkRemovedEvent\n  | NetworkControllerStateChangeEvent\n  | TransactionControllerTransactionSubmittedEvent;\n\nexport type NetworkEnablementControllerMessenger = Messenger<\n  typeof controllerName,\n  NetworkEnablementControllerActions | AllowedActions,\n  NetworkEnablementControllerEvents | AllowedEvents\n>;\n\n/**\n * Gets the default state for the NetworkEnablementController.\n *\n * @returns The default state with pre-enabled networks.\n */\nconst getDefaultNetworkEnablementControllerState =\n  (): NetworkEnablementControllerState => {\n    // Programmatically enable all popular networks for performance testing\n    const enabledEvmNetworks = POPULAR_NETWORKS.reduce<Record<string, boolean>>(\n      (acc, chainId) => ({\n        ...acc,\n        [chainId]: true,\n      }),\n      {},\n    );\n\n    console.log(\n      '[NetworkEnablementController] Generating default state with',\n      POPULAR_NETWORKS.length,\n      'popular networks',\n    );\n    console.log(\n      '[NetworkEnablementController] Enabled EVM networks:',\n      Object.keys(enabledEvmNetworks),\n    );\n\n    return {\n      enabledNetworkMap: {\n        [KnownCaipNamespace.Eip155]: enabledEvmNetworks,\n        [KnownCaipNamespace.Solana]: {\n          [SolScope.Mainnet]: true,\n          [SolScope.Testnet]: false,\n          [SolScope.Devnet]: false,\n        },\n        [KnownCaipNamespace.Bip122]: {\n          [BtcScope.Mainnet]: true,\n          [BtcScope.Testnet]: false,\n          [BtcScope.Signet]: false,\n        },\n        [KnownCaipNamespace.Tron]: {\n          [TrxScope.Mainnet]: true,\n          [TrxScope.Nile]: false,\n          [TrxScope.Shasta]: false,\n        },\n      },\n    };\n  };\n\n// Metadata for the controller state\nconst metadata = {\n  enabledNetworkMap: {\n    includeInStateLogs: true,\n    persist: true,\n    includeInDebugSnapshot: true,\n    usedInUi: true,\n  },\n};\n\n/**\n * Controller responsible for managing network enablement state across different blockchain networks.\n *\n * This controller tracks which networks are enabled/disabled for the user and provides methods\n * to toggle network states. It supports both EVM (EIP-155) and non-EVM networks like Solana.\n *\n * The controller maintains a map of enabled networks organized by namespace (e.g., 'eip155', 'solana')\n * and provides methods to query and modify network enablement states.\n */\nexport class NetworkEnablementController extends BaseController<\n  typeof controllerName,\n  NetworkEnablementControllerState,\n  NetworkEnablementControllerMessenger\n> {\n  /**\n   * Creates a NetworkEnablementController instance.\n   *\n   * @param args - The arguments to this function.\n   * @param args.messenger - Messenger used to communicate with BaseV2 controller.\n   * @param args.state - Initial state to set on this controller.\n   */\n  constructor({\n    messenger,\n    state,\n  }: {\n    messenger: NetworkEnablementControllerMessenger;\n    state?: Partial<NetworkEnablementControllerState>;\n  }) {\n    const defaultState = getDefaultNetworkEnablementControllerState();\n    const finalState = {\n      ...defaultState,\n      ...state,\n    };\n\n    console.log(\n      '[NetworkEnablementController] Constructor - passed state:',\n      state ? 'YES (will override defaults)' : 'NO (using defaults)',\n    );\n    console.log(\n      '[NetworkEnablementController] Constructor - default EVM networks count:',\n      Object.keys(defaultState.enabledNetworkMap[KnownCaipNamespace.Eip155])\n        .length,\n    );\n    console.log(\n      '[NetworkEnablementController] Constructor - final EVM networks count:',\n      Object.keys(finalState.enabledNetworkMap[KnownCaipNamespace.Eip155])\n        .length,\n    );\n    console.log(\n      '[NetworkEnablementController] Constructor - final enabled EVM networks:',\n      Object.keys(finalState.enabledNetworkMap[KnownCaipNamespace.Eip155]),\n    );\n\n    super({\n      messenger,\n      metadata,\n      name: controllerName,\n      state: finalState,\n    });\n\n    messenger.subscribe('NetworkController:networkAdded', ({ chainId }) => {\n      this.#onAddNetwork(chainId);\n    });\n\n    messenger.subscribe('NetworkController:networkRemoved', ({ chainId }) => {\n      this.#removeNetworkEntry(chainId);\n    });\n  }\n\n  /**\n   * Enables or disables a network for the user.\n   *\n   * This method accepts either a Hex chain ID (for EVM networks) or a CAIP-2 chain ID\n   * (for any blockchain network). The method will automatically convert Hex chain IDs\n   * to CAIP-2 format internally. This dual parameter support allows for backward\n   * compatibility with existing EVM chain ID formats while supporting newer\n   * multi-chain standards.\n   *\n   * When enabling a non-popular network, this method will disable all other networks\n   * to ensure only one network is active at a time (exclusive mode).\n   *\n   * @param chainId - The chain ID of the network to enable or disable. Can be either:\n   * - A Hex string (e.g., '0x1' for Ethereum mainnet) for EVM networks\n   * - A CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet, 'solana:mainnet' for Solana)\n   */\n  enableNetwork(chainId: Hex | CaipChainId): void {\n    const { namespace, storageKey } = deriveKeys(chainId);\n\n    console.log(\n      '[NetworkEnablementController] enableNetwork called for:',\n      chainId,\n      'namespace:',\n      namespace,\n      'storageKey:',\n      storageKey,\n    );\n\n    this.update((state) => {\n      // disable all networks in all namespaces first\n      Object.keys(state.enabledNetworkMap).forEach((ns) => {\n        Object.keys(state.enabledNetworkMap[ns]).forEach((key) => {\n          state.enabledNetworkMap[ns][key as CaipChainId | Hex] = false;\n        });\n      });\n\n      // if the namespace bucket does not exist, return\n      // new nemespace are added only when a new network is added\n      if (!state.enabledNetworkMap[namespace]) {\n        return;\n      }\n\n      // enable the network\n      state.enabledNetworkMap[namespace][storageKey] = true;\n    });\n  }\n\n  /**\n   * Enables a network for the user within a specific namespace.\n   *\n   * This method accepts either a Hex chain ID (for EVM networks) or a CAIP-2 chain ID\n   * (for any blockchain network) and enables it within the specified namespace.\n   * The method validates that the chainId belongs to the specified namespace for safety.\n   *\n   * Before enabling the target network, this method disables all other networks\n   * in the same namespace to ensure exclusive behavior within the namespace.\n   *\n   * @param chainId - The chain ID of the network to enable. Can be either:\n   * - A Hex string (e.g., '0x1' for Ethereum mainnet) for EVM networks\n   * - A CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet, 'solana:mainnet' for Solana)\n   * @param namespace - The CAIP namespace where the network should be enabled\n   * @throws Error if the chainId's derived namespace doesn't match the provided namespace\n   */\n  enableNetworkInNamespace(\n    chainId: Hex | CaipChainId,\n    namespace: CaipNamespace,\n  ): void {\n    const { namespace: derivedNamespace, storageKey } = deriveKeys(chainId);\n\n    // Validate that the derived namespace matches the provided namespace\n    if (derivedNamespace !== namespace) {\n      throw new Error(\n        `Chain ID ${chainId} belongs to namespace ${derivedNamespace}, but namespace ${namespace} was specified`,\n      );\n    }\n\n    this.update((state) => {\n      // Ensure the namespace bucket exists\n      this.#ensureNamespaceBucket(state, namespace);\n\n      // Disable all networks in the specified namespace first\n      if (state.enabledNetworkMap[namespace]) {\n        Object.keys(state.enabledNetworkMap[namespace]).forEach((key) => {\n          state.enabledNetworkMap[namespace][key as CaipChainId | Hex] = false;\n        });\n      }\n\n      // Enable the target network in the specified namespace\n      state.enabledNetworkMap[namespace][storageKey] = true;\n    });\n  }\n\n  /**\n   * Enables all popular networks and Solana mainnet.\n   *\n   * This method first disables all networks across all namespaces, then enables\n   * all networks defined in POPULAR_NETWORKS (EVM networks), Solana mainnet, and\n   * Bitcoin mainnet. This provides exclusive behavior - only popular networks will\n   * be enabled after calling this method.\n   *\n   * Popular networks that don't exist in NetworkController or MultichainNetworkController configurations will be skipped silently.\n   */\n  enableAllPopularNetworks(): void {\n    console.log(\n      '[NetworkEnablementController] enableAllPopularNetworks called - attempting to enable',\n      POPULAR_NETWORKS.length,\n      'networks',\n    );\n\n    this.update((state) => {\n      // First disable all networks across all namespaces\n      Object.keys(state.enabledNetworkMap).forEach((ns) => {\n        Object.keys(state.enabledNetworkMap[ns]).forEach((key) => {\n          state.enabledNetworkMap[ns][key as CaipChainId | Hex] = false;\n        });\n      });\n\n      // Get current network configurations to check if networks exist\n      const networkControllerState = this.messenger.call(\n        'NetworkController:getState',\n      );\n      const multichainState = this.messenger.call(\n        'MultichainNetworkController:getState',\n      );\n\n      console.log(\n        '[NetworkEnablementController] NetworkController has',\n        Object.keys(networkControllerState.networkConfigurationsByChainId)\n          .length,\n        'networks configured',\n      );\n\n      let enabledCount = 0;\n      // Enable all popular EVM networks that exist in NetworkController configurations\n      POPULAR_NETWORKS.forEach((chainId) => {\n        const { namespace, storageKey } = deriveKeys(chainId as Hex);\n\n        // Check if network exists in NetworkController configurations\n        if (\n          networkControllerState.networkConfigurationsByChainId[chainId as Hex]\n        ) {\n          // Ensure namespace bucket exists\n          this.#ensureNamespaceBucket(state, namespace);\n          // Enable the network\n          state.enabledNetworkMap[namespace][storageKey] = true;\n          enabledCount += 1;\n          console.log(\n            '[NetworkEnablementController] Enabled network:',\n            chainId,\n            storageKey,\n          );\n        } else {\n          console.log(\n            '[NetworkEnablementController] Network not found in NetworkController, skipping:',\n            chainId,\n          );\n        }\n      });\n\n      console.log(\n        '[NetworkEnablementController] Successfully enabled',\n        enabledCount,\n        'of',\n        POPULAR_NETWORKS.length,\n        'popular networks',\n      );\n\n      // Enable Solana mainnet if it exists in MultichainNetworkController configurations\n      const solanaKeys = deriveKeys(SolScope.Mainnet as CaipChainId);\n      if (\n        multichainState.multichainNetworkConfigurationsByChainId[\n          SolScope.Mainnet\n        ]\n      ) {\n        // Ensure namespace bucket exists\n        this.#ensureNamespaceBucket(state, solanaKeys.namespace);\n        // Enable Solana mainnet\n        state.enabledNetworkMap[solanaKeys.namespace][solanaKeys.storageKey] =\n          true;\n      }\n\n      // Enable Bitcoin mainnet if it exists in MultichainNetworkController configurations\n      const bitcoinKeys = deriveKeys(BtcScope.Mainnet as CaipChainId);\n      if (\n        multichainState.multichainNetworkConfigurationsByChainId[\n          BtcScope.Mainnet\n        ]\n      ) {\n        // Ensure namespace bucket exists\n        this.#ensureNamespaceBucket(state, bitcoinKeys.namespace);\n        // Enable Bitcoin mainnet\n        state.enabledNetworkMap[bitcoinKeys.namespace][bitcoinKeys.storageKey] =\n          true;\n      }\n\n      // Enable Tron mainnet if it exists in MultichainNetworkController configurations\n      const tronKeys = deriveKeys(TrxScope.Mainnet as CaipChainId);\n      if (\n        multichainState.multichainNetworkConfigurationsByChainId[\n          TrxScope.Mainnet\n        ]\n      ) {\n        // Ensure namespace bucket exists\n        this.#ensureNamespaceBucket(state, tronKeys.namespace);\n        // Enable Tron mainnet\n        state.enabledNetworkMap[tronKeys.namespace][tronKeys.storageKey] = true;\n      }\n    });\n  }\n\n  /**\n   * Initializes the network enablement state from network controller configurations.\n   *\n   * This method reads the current network configurations from both NetworkController\n   * and MultichainNetworkController and syncs the enabled network map accordingly.\n   * It ensures proper namespace buckets exist for all configured networks and only\n   * adds missing networks with a default value of false, preserving existing user settings.\n   *\n   * This method should be called after the NetworkController and MultichainNetworkController\n   * have been initialized and their configurations are available.\n   */\n  init(): void {\n    this.update((state) => {\n      // Get network configurations from NetworkController (EVM networks)\n      const networkControllerState = this.messenger.call(\n        'NetworkController:getState',\n      );\n\n      // Get network configurations from MultichainNetworkController (all networks)\n      const multichainState = this.messenger.call(\n        'MultichainNetworkController:getState',\n      );\n\n      // Initialize namespace buckets for EVM networks from NetworkController\n      Object.keys(\n        networkControllerState.networkConfigurationsByChainId,\n      ).forEach((chainId) => {\n        const { namespace, storageKey } = deriveKeys(chainId as Hex);\n        this.#ensureNamespaceBucket(state, namespace);\n\n        // Only add network if it doesn't already exist in state (preserves user settings)\n        state.enabledNetworkMap[namespace][storageKey] ??= false;\n      });\n\n      // Initialize namespace buckets for all networks from MultichainNetworkController\n      Object.keys(\n        multichainState.multichainNetworkConfigurationsByChainId,\n      ).forEach((chainId) => {\n        const { namespace, storageKey } = deriveKeys(chainId as CaipChainId);\n        this.#ensureNamespaceBucket(state, namespace);\n\n        // Only add network if it doesn't already exist in state (preserves user settings)\n        state.enabledNetworkMap[namespace][storageKey] ??= false;\n      });\n    });\n  }\n\n  /**\n   * Disables a network for the user.\n   *\n   * This method accepts either a Hex chain ID (for EVM networks) or a CAIP-2 chain ID\n   * (for any blockchain network). The method will automatically convert Hex chain IDs\n   * to CAIP-2 format internally.\n   *\n   * Note: This method will prevent disabling the last remaining enabled network\n   * to ensure at least one network is always available.\n   *\n   * @param chainId - The chain ID of the network to disable. Can be either:\n   * - A Hex string (e.g., '0x1' for Ethereum mainnet) for EVM networks\n   * - A CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet, 'solana:mainnet' for Solana)\n   */\n  disableNetwork(chainId: Hex | CaipChainId): void {\n    const derivedKeys = deriveKeys(chainId);\n    const { namespace, storageKey } = derivedKeys;\n\n    this.update((state) => {\n      state.enabledNetworkMap[namespace][storageKey] = false;\n    });\n  }\n\n  /**\n   * Checks if a network is enabled.\n   *\n   * @param chainId - The chain ID of the network to check. Can be either:\n   * - A Hex string (e.g., '0x1' for Ethereum mainnet) for EVM networks\n   * - A CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet, 'solana:mainnet' for Solana)\n   * @returns True if the network is enabled, false otherwise\n   */\n  isNetworkEnabled(chainId: Hex | CaipChainId): boolean {\n    const derivedKeys = deriveKeys(chainId);\n    const { namespace, storageKey } = derivedKeys;\n    return this.state.enabledNetworkMap[namespace]?.[storageKey] ?? false;\n  }\n\n  /**\n   * Ensures that a namespace bucket exists in the state.\n   *\n   * This method creates the namespace entry in the enabledNetworkMap if it doesn't\n   * already exist. This is used to prepare the state structure before adding\n   * network entries.\n   *\n   * @param state - The current controller state\n   * @param ns - The CAIP namespace to ensure exists\n   */\n  #ensureNamespaceBucket(\n    state: NetworkEnablementControllerState,\n    ns: CaipNamespace,\n  ): void {\n    if (!state.enabledNetworkMap[ns]) {\n      state.enabledNetworkMap[ns] = {};\n    }\n  }\n\n  /**\n   * Checks if popular networks mode is active (more than 2 popular networks enabled).\n   *\n   * This method counts how many networks defined in POPULAR_NETWORKS are currently\n   * enabled in the state and returns true if more than 2 are enabled. It only checks\n   * networks that actually exist in the NetworkController configurations.\n   *\n   * @returns True if more than 2 popular networks are enabled, false otherwise\n   */\n  #isInPopularNetworksMode(): boolean {\n    // Get current network configurations to check which popular networks exist\n    const networkControllerState = this.messenger.call(\n      'NetworkController:getState',\n    );\n\n    // Count how many popular networks are enabled\n    const enabledPopularNetworksCount = POPULAR_NETWORKS.reduce(\n      (count, chainId) => {\n        // Only check networks that actually exist in NetworkController configurations\n        if (\n          !networkControllerState.networkConfigurationsByChainId[chainId as Hex]\n        ) {\n          return count; // Skip networks that don't exist\n        }\n\n        const { namespace, storageKey } = deriveKeys(chainId as Hex);\n        const isEnabled = this.state.enabledNetworkMap[namespace]?.[storageKey];\n        return isEnabled ? count + 1 : count;\n      },\n      0,\n    );\n\n    // Return true if more than 2 popular networks are enabled\n    return enabledPopularNetworksCount > 1;\n  }\n\n  /**\n   * Removes a network entry from the state.\n   *\n   * This method is called when a network is removed from the system. It cleans up\n   * the network entry and ensures that at least one network remains enabled.\n   *\n   * @param chainId - The chain ID to remove (Hex or CAIP-2 format)\n   */\n  #removeNetworkEntry(chainId: Hex | CaipChainId): void {\n    const derivedKeys = deriveKeys(chainId);\n    const { namespace, storageKey } = derivedKeys;\n\n    this.update((state) => {\n      // fallback and enable ethereum mainnet\n      if (isOnlyNetworkEnabledInNamespace(this.state, derivedKeys)) {\n        state.enabledNetworkMap[namespace][\n          ChainId[BuiltInNetworkName.Mainnet]\n        ] = true;\n      }\n\n      if (namespace in state.enabledNetworkMap) {\n        delete state.enabledNetworkMap[namespace][storageKey];\n      }\n    });\n  }\n\n  /**\n   * Handles the addition of a new network to the controller.\n   *\n   * @param chainId - The chain ID to add (Hex or CAIP-2 format)\n   *\n   * @description\n   * - If in popular networks mode (>2 popular networks enabled) AND adding a popular network:\n   * - Keep current selection (add but don't enable the new network)\n   * - Otherwise:\n   * - Switch to the newly added network (disable all others, enable this one)\n   */\n  #onAddNetwork(chainId: Hex | CaipChainId): void {\n    const { namespace, storageKey, reference } = deriveKeys(chainId);\n\n    this.update((state) => {\n      // Ensure the namespace bucket exists\n      this.#ensureNamespaceBucket(state, namespace);\n\n      // Check if popular networks mode is active (>2 popular networks enabled)\n      const inPopularNetworksMode = this.#isInPopularNetworksMode();\n\n      // Check if the network being added is a popular network\n      const isAddedNetworkPopular = isPopularNetwork(reference);\n\n      // Keep current selection only if in popular networks mode AND adding a popular network\n      const shouldKeepCurrentSelection =\n        inPopularNetworksMode && isAddedNetworkPopular;\n\n      if (shouldKeepCurrentSelection) {\n        // Add the popular network but don't enable it (keep current selection)\n        state.enabledNetworkMap[namespace][storageKey] = true;\n      } else {\n        // Switch to the newly added network (disable all others, enable this one)\n        Object.keys(state.enabledNetworkMap).forEach((ns) => {\n          Object.keys(state.enabledNetworkMap[ns]).forEach((key) => {\n            state.enabledNetworkMap[ns][key as CaipChainId | Hex] = false;\n          });\n        });\n        // Enable the newly added network\n        state.enabledNetworkMap[namespace][storageKey] = true;\n      }\n    });\n  }\n}\n"]}
\ No newline at end of file
diff --git a/dist/constants.cjs b/dist/constants.cjs
index d45d861dd20777a9c767ef6a4272d0b4fd53f895..8e1d4e678d60e9d4ce435078478662dc45546420 100644
--- a/dist/constants.cjs
+++ b/dist/constants.cjs
@@ -2,18 +2,28 @@
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.POPULAR_NETWORKS = void 0;
 exports.POPULAR_NETWORKS = [
-    '0x1',
-    '0xe708',
-    '0x2105',
-    '0xa4b1',
-    '0xa86a',
-    '0x38',
-    '0xa',
-    '0x89',
-    '0x531',
-    '0x144',
-    '0x2a15c308d',
-    '0x3e7',
-    '0x8f', // Monad (143)
+    '0x1', // Ethereum Mainnet
+    '0xe708', // Linea (59144)
+    '0x2105', // Base (8453)
+    '0xa4b1', // Arbitrum One (42161)
+    '0xa86a', // Avalanche C-Chain (43114)
+    '0x38', // BNB Smart Chain (56)
+    '0xa', // Optimism (10)
+    '0x89', // Polygon (137)
+    '0x531', // Sei (1329)
+    '0x144', // zkSync Era (324)
+    '0x2a15c308d', // Palm (11297108109)
+    '0x3e7', // HyperEVM (999)
+    '0x279f', // Monad Testnet (10143) - FIXED: was 0x8f (143)
+    '0x18c7', // MegaETH Testnet V2 (6343) - FIXED: was 0x10e6 (4326)
+    // New additions for 20+ network performance testing
+    '0xfa', // Fantom Opera (250)
+    '0x64', // Gnosis Chain (100)
+    '0xa4ec', // Celo (42220)
+    '0x19', // Cronos (25)
+    '0x4e454152', // Aurora (1313161554)
+    '0x504', // Moonbeam (1284)
+    '0x505', // Moonriver (1285)
+    '0x2019', // Klaytn (8217) - intentionally slow RPC for testing
 ];
 //# sourceMappingURL=constants.cjs.map
\ No newline at end of file
diff --git a/dist/constants.cjs.map b/dist/constants.cjs.map
index 92b2b9be006aa6110700d765e0d6e0f9ace32169..d4da9b7903f35bf02e5ec04bc548591a8993db70 100644
--- a/dist/constants.cjs.map
+++ b/dist/constants.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"constants.cjs","sourceRoot":"","sources":["../src/constants.ts"],"names":[],"mappings":";;;AAAa,QAAA,gBAAgB,GAAG;IAC9B,KAAK;IACL,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,MAAM;IACN,KAAK;IACL,MAAM;IACN,OAAO;IACP,OAAO;IACP,aAAa;IACb,OAAO;IACP,MAAM,EAAE,cAAc;CACvB,CAAC","sourcesContent":["export const POPULAR_NETWORKS = [\n  '0x1', // Ethereum Mainnet\n  '0xe708', // Linea (59144)\n  '0x2105', // Base (8453)\n  '0xa4b1', // Arbitrum One (42161)\n  '0xa86a', // Avalanche C-Chain (43114)\n  '0x38', // BNB Smart Chain (56)\n  '0xa', // Optimism (10)\n  '0x89', // Polygon (137)\n  '0x531', // Sei (Assuming 1329 used in EVM context)\n  '0x144', // zkSync Era (324)\n  '0x2a15c308d', // Palm (11297108109)\n  '0x3e7', // HyperEVM (999)\n  '0x8f', // Monad (143)\n];\n"]}
\ No newline at end of file
+{"version":3,"file":"constants.cjs","sourceRoot":"","sources":["../src/constants.ts"],"names":[],"mappings":";;;AAAa,QAAA,gBAAgB,GAAG;IAC9B,KAAK,EAAE,mBAAmB;IAC1B,QAAQ,EAAE,gBAAgB;IAC1B,QAAQ,EAAE,cAAc;IACxB,QAAQ,EAAE,uBAAuB;IACjC,QAAQ,EAAE,4BAA4B;IACtC,MAAM,EAAE,uBAAuB;IAC/B,KAAK,EAAE,gBAAgB;IACvB,MAAM,EAAE,gBAAgB;IACxB,OAAO,EAAE,aAAa;IACtB,OAAO,EAAE,mBAAmB;IAC5B,aAAa,EAAE,qBAAqB;IACpC,OAAO,EAAE,iBAAiB;IAC1B,QAAQ,EAAE,gDAAgD;IAC1D,QAAQ,EAAE,uDAAuD;IACjE,oDAAoD;IACpD,MAAM,EAAE,qBAAqB;IAC7B,MAAM,EAAE,qBAAqB;IAC7B,QAAQ,EAAE,eAAe;IACzB,MAAM,EAAE,cAAc;IACtB,YAAY,EAAE,sBAAsB;IACpC,OAAO,EAAE,kBAAkB;IAC3B,OAAO,EAAE,mBAAmB;IAC5B,QAAQ,EAAE,qDAAqD;CAChE,CAAC","sourcesContent":["export const POPULAR_NETWORKS = [\n  '0x1', // Ethereum Mainnet\n  '0xe708', // Linea (59144)\n  '0x2105', // Base (8453)\n  '0xa4b1', // Arbitrum One (42161)\n  '0xa86a', // Avalanche C-Chain (43114)\n  '0x38', // BNB Smart Chain (56)\n  '0xa', // Optimism (10)\n  '0x89', // Polygon (137)\n  '0x531', // Sei (1329)\n  '0x144', // zkSync Era (324)\n  '0x2a15c308d', // Palm (11297108109)\n  '0x3e7', // HyperEVM (999)\n  '0x279f', // Monad Testnet (10143) - FIXED: was 0x8f (143)\n  '0x18c7', // MegaETH Testnet V2 (6343) - FIXED: was 0x10e6 (4326)\n  // New additions for 20+ network performance testing\n  '0xfa', // Fantom Opera (250)\n  '0x64', // Gnosis Chain (100)\n  '0xa4ec', // Celo (42220)\n  '0x19', // Cronos (25)\n  '0x4e454152', // Aurora (1313161554)\n  '0x504', // Moonbeam (1284)\n  '0x505', // Moonriver (1285)\n  '0x2019', // Klaytn (8217) - intentionally slow RPC for testing\n];\n"]}
\ No newline at end of file
diff --git a/dist/constants.d.cts.map b/dist/constants.d.cts.map
index 5b7ce36f03b6405a4c74100bc18efbbcf126a1e5..803cefef609457254133f82faf48115026898612 100644
--- a/dist/constants.d.cts.map
+++ b/dist/constants.d.cts.map
@@ -1 +1 @@
-{"version":3,"file":"constants.d.cts","sourceRoot":"","sources":["../src/constants.ts"],"names":[],"mappings":"AAAA,eAAO,MAAM,gBAAgB,UAc5B,CAAC"}
\ No newline at end of file
+{"version":3,"file":"constants.d.cts","sourceRoot":"","sources":["../src/constants.ts"],"names":[],"mappings":"AAAA,eAAO,MAAM,gBAAgB,UAwB5B,CAAC"}
\ No newline at end of file
diff --git a/dist/constants.d.mts.map b/dist/constants.d.mts.map
index feed158293ac264ddf2c05f42abbd97fa38381b9..6230e2eae86fd10a6de25250e3b472a174f0eab3 100644
--- a/dist/constants.d.mts.map
+++ b/dist/constants.d.mts.map
@@ -1 +1 @@
-{"version":3,"file":"constants.d.mts","sourceRoot":"","sources":["../src/constants.ts"],"names":[],"mappings":"AAAA,eAAO,MAAM,gBAAgB,UAc5B,CAAC"}
\ No newline at end of file
+{"version":3,"file":"constants.d.mts","sourceRoot":"","sources":["../src/constants.ts"],"names":[],"mappings":"AAAA,eAAO,MAAM,gBAAgB,UAwB5B,CAAC"}
\ No newline at end of file
diff --git a/dist/constants.mjs b/dist/constants.mjs
index 2631e864148964ade93979ab4b17e936865288c7..1f7ddd8f0db19bc39ce477114d8cee7a49aa8b02 100644
--- a/dist/constants.mjs
+++ b/dist/constants.mjs
@@ -1,16 +1,26 @@
 export const POPULAR_NETWORKS = [
-    '0x1',
-    '0xe708',
-    '0x2105',
-    '0xa4b1',
-    '0xa86a',
-    '0x38',
-    '0xa',
-    '0x89',
-    '0x531',
-    '0x144',
-    '0x2a15c308d',
-    '0x3e7',
-    '0x8f', // Monad (143)
+    '0x1', // Ethereum Mainnet
+    '0xe708', // Linea (59144)
+    '0x2105', // Base (8453)
+    '0xa4b1', // Arbitrum One (42161)
+    '0xa86a', // Avalanche C-Chain (43114)
+    '0x38', // BNB Smart Chain (56)
+    '0xa', // Optimism (10)
+    '0x89', // Polygon (137)
+    '0x531', // Sei (1329)
+    '0x144', // zkSync Era (324)
+    '0x2a15c308d', // Palm (11297108109)
+    '0x3e7', // HyperEVM (999)
+    '0x279f', // Monad Testnet (10143) - FIXED: was 0x8f (143)
+    '0x18c7', // MegaETH Testnet V2 (6343) - FIXED: was 0x10e6 (4326)
+    // New additions for 20+ network performance testing
+    '0xfa', // Fantom Opera (250)
+    '0x64', // Gnosis Chain (100)
+    '0xa4ec', // Celo (42220)
+    '0x19', // Cronos (25)
+    '0x4e454152', // Aurora (1313161554)
+    '0x504', // Moonbeam (1284)
+    '0x505', // Moonriver (1285)
+    '0x2019', // Klaytn (8217) - intentionally slow RPC for testing
 ];
 //# sourceMappingURL=constants.mjs.map
\ No newline at end of file
diff --git a/dist/constants.mjs.map b/dist/constants.mjs.map
index 57b316c53cddf757c78d59e33a48b64deb50c172..257351920b75cabd23940c87bf01c50e7d051a68 100644
--- a/dist/constants.mjs.map
+++ b/dist/constants.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"constants.mjs","sourceRoot":"","sources":["../src/constants.ts"],"names":[],"mappings":"AAAA,MAAM,CAAC,MAAM,gBAAgB,GAAG;IAC9B,KAAK;IACL,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,MAAM;IACN,KAAK;IACL,MAAM;IACN,OAAO;IACP,OAAO;IACP,aAAa;IACb,OAAO;IACP,MAAM,EAAE,cAAc;CACvB,CAAC","sourcesContent":["export const POPULAR_NETWORKS = [\n  '0x1', // Ethereum Mainnet\n  '0xe708', // Linea (59144)\n  '0x2105', // Base (8453)\n  '0xa4b1', // Arbitrum One (42161)\n  '0xa86a', // Avalanche C-Chain (43114)\n  '0x38', // BNB Smart Chain (56)\n  '0xa', // Optimism (10)\n  '0x89', // Polygon (137)\n  '0x531', // Sei (Assuming 1329 used in EVM context)\n  '0x144', // zkSync Era (324)\n  '0x2a15c308d', // Palm (11297108109)\n  '0x3e7', // HyperEVM (999)\n  '0x8f', // Monad (143)\n];\n"]}
\ No newline at end of file
+{"version":3,"file":"constants.mjs","sourceRoot":"","sources":["../src/constants.ts"],"names":[],"mappings":"AAAA,MAAM,CAAC,MAAM,gBAAgB,GAAG;IAC9B,KAAK,EAAE,mBAAmB;IAC1B,QAAQ,EAAE,gBAAgB;IAC1B,QAAQ,EAAE,cAAc;IACxB,QAAQ,EAAE,uBAAuB;IACjC,QAAQ,EAAE,4BAA4B;IACtC,MAAM,EAAE,uBAAuB;IAC/B,KAAK,EAAE,gBAAgB;IACvB,MAAM,EAAE,gBAAgB;IACxB,OAAO,EAAE,aAAa;IACtB,OAAO,EAAE,mBAAmB;IAC5B,aAAa,EAAE,qBAAqB;IACpC,OAAO,EAAE,iBAAiB;IAC1B,QAAQ,EAAE,gDAAgD;IAC1D,QAAQ,EAAE,uDAAuD;IACjE,oDAAoD;IACpD,MAAM,EAAE,qBAAqB;IAC7B,MAAM,EAAE,qBAAqB;IAC7B,QAAQ,EAAE,eAAe;IACzB,MAAM,EAAE,cAAc;IACtB,YAAY,EAAE,sBAAsB;IACpC,OAAO,EAAE,kBAAkB;IAC3B,OAAO,EAAE,mBAAmB;IAC5B,QAAQ,EAAE,qDAAqD;CAChE,CAAC","sourcesContent":["export const POPULAR_NETWORKS = [\n  '0x1', // Ethereum Mainnet\n  '0xe708', // Linea (59144)\n  '0x2105', // Base (8453)\n  '0xa4b1', // Arbitrum One (42161)\n  '0xa86a', // Avalanche C-Chain (43114)\n  '0x38', // BNB Smart Chain (56)\n  '0xa', // Optimism (10)\n  '0x89', // Polygon (137)\n  '0x531', // Sei (1329)\n  '0x144', // zkSync Era (324)\n  '0x2a15c308d', // Palm (11297108109)\n  '0x3e7', // HyperEVM (999)\n  '0x279f', // Monad Testnet (10143) - FIXED: was 0x8f (143)\n  '0x18c7', // MegaETH Testnet V2 (6343) - FIXED: was 0x10e6 (4326)\n  // New additions for 20+ network performance testing\n  '0xfa', // Fantom Opera (250)\n  '0x64', // Gnosis Chain (100)\n  '0xa4ec', // Celo (42220)\n  '0x19', // Cronos (25)\n  '0x4e454152', // Aurora (1313161554)\n  '0x504', // Moonbeam (1284)\n  '0x505', // Moonriver (1285)\n  '0x2019', // Klaytn (8217) - intentionally slow RPC for testing\n];\n"]}
\ No newline at end of file
diff --git a/dist/selectors.cjs.map b/dist/selectors.cjs.map
index b02aa11d08c743b47d24e5c072be8e30b41a5b5d..ae25153fcfb89c05c59b08ebc28dfd660b35f7c7 100644
--- a/dist/selectors.cjs.map
+++ b/dist/selectors.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"selectors.cjs","sourceRoot":"","sources":["../src/selectors.ts"],"names":[],"mappings":";;;AACA,2CAAqD;AACrD,uCAA0C;AAG1C,uCAAqC;AAErC;;;;;GAKG;AACI,MAAM,uBAAuB,GAAG,CACrC,KAAuC,EACvC,EAAE,CAAC,KAAK,CAAC,iBAAiB,CAAC;AAFhB,QAAA,uBAAuB,2BAEP;AAE7B;;;;;;;;;GASG;AACI,MAAM,sBAAsB,GAAG,CAAC,OAA0B,EAAE,EAAE,CACnE,IAAA,yBAAc,EAAC,+BAAuB,EAAE,CAAC,iBAAiB,EAAE,EAAE;IAC5D,MAAM,EAAE,SAAS,EAAE,UAAU,EAAE,GAAG,IAAA,kBAAU,EAAC,OAAO,CAAC,CAAC;IAEtD,OAAO,CACL,SAAS,IAAI,iBAAiB;QAC9B,UAAU,IAAI,iBAAiB,CAAC,SAAS,CAAC;QAC1C,iBAAiB,CAAC,SAAS,CAAC,CAAC,UAAU,CAAC,CACzC,CAAC;AACJ,CAAC,CAAC,CAAC;AATQ,QAAA,sBAAsB,0BAS9B;AAEL;;;;;;;;GAQG;AACI,MAAM,4CAA4C,GAAG,CAC1D,SAAwB,EACxB,EAAE,CACF,IAAA,yBAAc,EAAC,+BAAuB,EAAE,CAAC,iBAAiB,EAAE,EAAE;IAC5D,OAAO,MAAM,CAAC,OAAO,CAAC,iBAAiB,CAAC,SAAS,CAAC,IAAI,EAAE,CAAC;SACtD,MAAM,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,EAAE,EAAE,CAAC,OAAO,CAAC;SAChC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,CAAC;AACvB,CAAC,CAAC,CAAC;AAPQ,QAAA,4CAA4C,gDAOpD;AAEL;;;;;;;GAOG;AACU,QAAA,wBAAwB,GAAG,IAAA,yBAAc,EACpD,+BAAuB,EACvB,CAAC,iBAAiB,EAAE,EAAE;IACpB,OAAQ,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAqB,CAAC,MAAM,CAC/D,CAAC,GAAG,EAAE,EAAE,EAAE,EAAE;QACV,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,OAAO,CAAC,iBAAiB,CAAC,EAAE,CAAC,CAAC;aAC5C,MAAM,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,EAAE,EAAE,CAAC,OAAO,CAAC;aAChC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,CAAC;QACrB,OAAO,GAAG,CAAC;IACb,CAAC,EACD,EAAqC,CACtC,CAAC;AACJ,CAAC,CACF,CAAC;AAEF;;;;GAIG;AACU,QAAA,0BAA0B,GAAG,IAAA,yBAAc,EACtD,gCAAwB,EACxB,CAAC,kBAAkB,EAAE,EAAE;IACrB,OAAO,MAAM,CAAC,MAAM,CAAC,kBAAkB,CAAC,CAAC,IAAI,EAAE,CAAC,MAAM,CAAC;AACzD,CAAC,CACF,CAAC;AAEF;;;;;;GAMG;AACU,QAAA,wBAAwB,GAAG,IAAA,yBAAc,EACpD,IAAA,oDAA4C,EAAC,0BAAkB,CAAC,MAAM,CAAC,EACvE,CAAC,kBAAkB,EAAE,EAAE,CAAC,kBAAkB,CAC3C,CAAC;AAEF;;;;;;GAMG;AACU,QAAA,2BAA2B,GAAG,IAAA,yBAAc,EACvD,IAAA,oDAA4C,EAAC,0BAAkB,CAAC,MAAM,CAAC,EACvE,CAAC,qBAAqB,EAAE,EAAE,CAAC,qBAAqB,CACjD,CAAC","sourcesContent":["import type { CaipChainId, CaipNamespace, Hex } from '@metamask/utils';\nimport { KnownCaipNamespace } from '@metamask/utils';\nimport { createSelector } from 'reselect';\n\nimport type { NetworkEnablementControllerState } from './NetworkEnablementController';\nimport { deriveKeys } from './utils';\n\n/**\n * Base selector to get the enabled network map from the controller state.\n *\n * @param state - The NetworkEnablementController state\n * @returns The enabled network map\n */\nexport const selectEnabledNetworkMap = (\n  state: NetworkEnablementControllerState,\n) => state.enabledNetworkMap;\n\n/**\n * Selector to check if a specific network is enabled.\n *\n * This selector accepts either a Hex chain ID (for EVM networks) or a CAIP-2 chain ID\n * (for any blockchain network) and returns whether the network is currently enabled.\n * It returns false for unknown networks or if there's an error parsing the chain ID.\n *\n * @param chainId - The chain ID to check (Hex or CAIP-2 format)\n * @returns A selector function that returns true if the network is enabled, false otherwise\n */\nexport const selectIsNetworkEnabled = (chainId: Hex | CaipChainId) =>\n  createSelector(selectEnabledNetworkMap, (enabledNetworkMap) => {\n    const { namespace, storageKey } = deriveKeys(chainId);\n\n    return (\n      namespace in enabledNetworkMap &&\n      storageKey in enabledNetworkMap[namespace] &&\n      enabledNetworkMap[namespace][storageKey]\n    );\n  });\n\n/**\n * Selector builder to get all enabled networks for a specific namespace.\n *\n * The selector returned by this function returns an array of chain IDs (as strings) for all enabled networks\n * within the specified namespace (e.g., 'eip155' for EVM networks, 'solana' for Solana).\n *\n * @param namespace - The CAIP namespace to get enabled networks for (e.g., 'eip155', 'solana')\n * @returns A selector function that returns an array of chain ID strings for enabled networks in the namespace\n */\nexport const createSelectorForEnabledNetworksForNamespace = (\n  namespace: CaipNamespace,\n) =>\n  createSelector(selectEnabledNetworkMap, (enabledNetworkMap) => {\n    return Object.entries(enabledNetworkMap[namespace] ?? {})\n      .filter(([, enabled]) => enabled)\n      .map(([id]) => id);\n  });\n\n/**\n * Selector to get all enabled networks across all namespaces.\n *\n * This selector returns a record where keys are CAIP namespaces and values are arrays\n * of enabled chain IDs within each namespace.\n *\n * @returns A selector function that returns a record mapping namespace to array of enabled chain IDs\n */\nexport const selectAllEnabledNetworks = createSelector(\n  selectEnabledNetworkMap,\n  (enabledNetworkMap) => {\n    return (Object.keys(enabledNetworkMap) as CaipNamespace[]).reduce(\n      (acc, ns) => {\n        acc[ns] = Object.entries(enabledNetworkMap[ns])\n          .filter(([, enabled]) => enabled)\n          .map(([id]) => id);\n        return acc;\n      },\n      {} as Record<CaipNamespace, string[]>,\n    );\n  },\n);\n\n/**\n * Selector to get the total count of enabled networks across all namespaces.\n *\n * @returns A selector function that returns the total number of enabled networks\n */\nexport const selectEnabledNetworksCount = createSelector(\n  selectAllEnabledNetworks,\n  (allEnabledNetworks) => {\n    return Object.values(allEnabledNetworks).flat().length;\n  },\n);\n\n/**\n * Selector to get all enabled EVM networks.\n *\n * This is a convenience selector that specifically targets EIP-155 networks.\n *\n * @returns A selector function that returns an array of enabled EVM chain IDs\n */\nexport const selectEnabledEvmNetworks = createSelector(\n  createSelectorForEnabledNetworksForNamespace(KnownCaipNamespace.Eip155),\n  (enabledEvmNetworks) => enabledEvmNetworks,\n);\n\n/**\n * Selector to get all enabled Solana networks.\n *\n * This is a convenience selector that specifically targets Solana networks.\n *\n * @returns A selector function that returns an array of enabled Solana chain IDs\n */\nexport const selectEnabledSolanaNetworks = createSelector(\n  createSelectorForEnabledNetworksForNamespace(KnownCaipNamespace.Solana),\n  (enabledSolanaNetworks) => enabledSolanaNetworks,\n);\n"]}
\ No newline at end of file
+{"version":3,"file":"selectors.cjs","sourceRoot":"","sources":["../src/selectors.ts"],"names":[],"mappings":";;;AACA,2CAAqD;AACrD,uCAA0C;AAG1C,uCAAqC;AAErC;;;;;GAKG;AACI,MAAM,uBAAuB,GAAG,CACrC,KAAuC,EACvC,EAAE,CAAC,KAAK,CAAC,iBAAiB,CAAC;AAFhB,QAAA,uBAAuB,2BAEP;AAE7B;;;;;;;;;GASG;AACI,MAAM,sBAAsB,GAAG,CAAC,OAA0B,EAAE,EAAE,CACnE,IAAA,yBAAc,EAAC,+BAAuB,EAAE,CAAC,iBAAiB,EAAE,EAAE;IAC5D,MAAM,EAAE,SAAS,EAAE,UAAU,EAAE,GAAG,IAAA,kBAAU,EAAC,OAAO,CAAC,CAAC;IAEtD,OAAO,CACL,SAAS,IAAI,iBAAiB;QAC9B,UAAU,IAAI,iBAAiB,CAAC,SAAS,CAAC;QAC1C,iBAAiB,CAAC,SAAS,CAAC,CAAC,UAAU,CAAC,CACzC,CAAC;AACJ,CAAC,CAAC,CAAC;AATQ,QAAA,sBAAsB,0BAS9B;AAEL;;;;;;;;GAQG;AACI,MAAM,4CAA4C,GAAG,CAC1D,SAAwB,EACxB,EAAE,CACF,IAAA,yBAAc,EAAC,+BAAuB,EAAE,CAAC,iBAAiB,EAAE,EAAE;IAC5D,OAAO,MAAM,CAAC,OAAO,CAAC,iBAAiB,CAAC,SAAS,CAAC,IAAI,EAAE,CAAC;SACtD,MAAM,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,EAAE,EAAE,CAAC,OAAO,CAAC;SAChC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,CAAC;AACvB,CAAC,CAAC,CAAC;AAPQ,QAAA,4CAA4C,gDAOpD;AAEL;;;;;;;GAOG;AACU,QAAA,wBAAwB,GAAG,IAAA,yBAAc,EACpD,+BAAuB,EACvB,CAAC,iBAAiB,EAAE,EAAE;IACpB,OAAO,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC,MAAM,CAE1C,CAAC,GAAG,EAAE,EAAE,EAAE,EAAE;QACZ,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,OAAO,CAAC,iBAAiB,CAAC,EAAE,CAAC,CAAC;aAC5C,MAAM,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,EAAE,EAAE,CAAC,OAAO,CAAC;aAChC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,CAAC;QACrB,OAAO,GAAG,CAAC;IACb,CAAC,EAAE,EAAE,CAAC,CAAC;AACT,CAAC,CACF,CAAC;AAEF;;;;GAIG;AACU,QAAA,0BAA0B,GAAG,IAAA,yBAAc,EACtD,gCAAwB,EACxB,CAAC,kBAAkB,EAAE,EAAE;IACrB,OAAO,MAAM,CAAC,MAAM,CAAC,kBAAkB,CAAC,CAAC,IAAI,EAAE,CAAC,MAAM,CAAC;AACzD,CAAC,CACF,CAAC;AAEF;;;;;;GAMG;AACU,QAAA,wBAAwB,GAAG,IAAA,yBAAc,EACpD,IAAA,oDAA4C,EAAC,0BAAkB,CAAC,MAAM,CAAC,EACvE,CAAC,kBAAkB,EAAE,EAAE,CAAC,kBAAkB,CAC3C,CAAC;AAEF;;;;;;GAMG;AACU,QAAA,2BAA2B,GAAG,IAAA,yBAAc,EACvD,IAAA,oDAA4C,EAAC,0BAAkB,CAAC,MAAM,CAAC,EACvE,CAAC,qBAAqB,EAAE,EAAE,CAAC,qBAAqB,CACjD,CAAC","sourcesContent":["import type { CaipChainId, CaipNamespace, Hex } from '@metamask/utils';\nimport { KnownCaipNamespace } from '@metamask/utils';\nimport { createSelector } from 'reselect';\n\nimport type { NetworkEnablementControllerState } from './NetworkEnablementController';\nimport { deriveKeys } from './utils';\n\n/**\n * Base selector to get the enabled network map from the controller state.\n *\n * @param state - The NetworkEnablementController state\n * @returns The enabled network map\n */\nexport const selectEnabledNetworkMap = (\n  state: NetworkEnablementControllerState,\n) => state.enabledNetworkMap;\n\n/**\n * Selector to check if a specific network is enabled.\n *\n * This selector accepts either a Hex chain ID (for EVM networks) or a CAIP-2 chain ID\n * (for any blockchain network) and returns whether the network is currently enabled.\n * It returns false for unknown networks or if there's an error parsing the chain ID.\n *\n * @param chainId - The chain ID to check (Hex or CAIP-2 format)\n * @returns A selector function that returns true if the network is enabled, false otherwise\n */\nexport const selectIsNetworkEnabled = (chainId: Hex | CaipChainId) =>\n  createSelector(selectEnabledNetworkMap, (enabledNetworkMap) => {\n    const { namespace, storageKey } = deriveKeys(chainId);\n\n    return (\n      namespace in enabledNetworkMap &&\n      storageKey in enabledNetworkMap[namespace] &&\n      enabledNetworkMap[namespace][storageKey]\n    );\n  });\n\n/**\n * Selector builder to get all enabled networks for a specific namespace.\n *\n * The selector returned by this function returns an array of chain IDs (as strings) for all enabled networks\n * within the specified namespace (e.g., 'eip155' for EVM networks, 'solana' for Solana).\n *\n * @param namespace - The CAIP namespace to get enabled networks for (e.g., 'eip155', 'solana')\n * @returns A selector function that returns an array of chain ID strings for enabled networks in the namespace\n */\nexport const createSelectorForEnabledNetworksForNamespace = (\n  namespace: CaipNamespace,\n) =>\n  createSelector(selectEnabledNetworkMap, (enabledNetworkMap) => {\n    return Object.entries(enabledNetworkMap[namespace] ?? {})\n      .filter(([, enabled]) => enabled)\n      .map(([id]) => id);\n  });\n\n/**\n * Selector to get all enabled networks across all namespaces.\n *\n * This selector returns a record where keys are CAIP namespaces and values are arrays\n * of enabled chain IDs within each namespace.\n *\n * @returns A selector function that returns a record mapping namespace to array of enabled chain IDs\n */\nexport const selectAllEnabledNetworks = createSelector(\n  selectEnabledNetworkMap,\n  (enabledNetworkMap) => {\n    return Object.keys(enabledNetworkMap).reduce<\n      Record<CaipNamespace, string[]>\n    >((acc, ns) => {\n      acc[ns] = Object.entries(enabledNetworkMap[ns])\n        .filter(([, enabled]) => enabled)\n        .map(([id]) => id);\n      return acc;\n    }, {});\n  },\n);\n\n/**\n * Selector to get the total count of enabled networks across all namespaces.\n *\n * @returns A selector function that returns the total number of enabled networks\n */\nexport const selectEnabledNetworksCount = createSelector(\n  selectAllEnabledNetworks,\n  (allEnabledNetworks) => {\n    return Object.values(allEnabledNetworks).flat().length;\n  },\n);\n\n/**\n * Selector to get all enabled EVM networks.\n *\n * This is a convenience selector that specifically targets EIP-155 networks.\n *\n * @returns A selector function that returns an array of enabled EVM chain IDs\n */\nexport const selectEnabledEvmNetworks = createSelector(\n  createSelectorForEnabledNetworksForNamespace(KnownCaipNamespace.Eip155),\n  (enabledEvmNetworks) => enabledEvmNetworks,\n);\n\n/**\n * Selector to get all enabled Solana networks.\n *\n * This is a convenience selector that specifically targets Solana networks.\n *\n * @returns A selector function that returns an array of enabled Solana chain IDs\n */\nexport const selectEnabledSolanaNetworks = createSelector(\n  createSelectorForEnabledNetworksForNamespace(KnownCaipNamespace.Solana),\n  (enabledSolanaNetworks) => enabledSolanaNetworks,\n);\n"]}
\ No newline at end of file
diff --git a/dist/selectors.d.cts.map b/dist/selectors.d.cts.map
index 7047b64d1e86fd588d7049be293e46f243de47b9..e2d0059af0488203d543833af04530b33bc0c827 100644
--- a/dist/selectors.d.cts.map
+++ b/dist/selectors.d.cts.map
@@ -1 +1 @@
-{"version":3,"file":"selectors.d.cts","sourceRoot":"","sources":["../src/selectors.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,WAAW,EAAE,aAAa,EAAE,GAAG,EAAE,wBAAwB;AAIvE,OAAO,KAAK,EAAE,gCAAgC,EAAE,0CAAsC;AAGtF;;;;;GAKG;AACH,eAAO,MAAM,uBAAuB,UAC3B,gCAAgC;;CACb,CAAC;AAE7B;;;;;;;;;GASG;AACH,eAAO,MAAM,sBAAsB,YAAa,GAAG,GAAG,WAAW;;;;;;;;;;;;;;;;2BAbxD,gCAAgC;;;;;;;;;;CAsBrC,CAAC;AAEL;;;;;;;;GAQG;AACH,eAAO,MAAM,4CAA4C,cAC5C,aAAa;;;;;;;;;;;;;;;;2BAlCjB,gCAAgC;;;;;;;;;;CAwCrC,CAAC;AAEL;;;;;;;GAOG;AACH,eAAO,MAAM,wBAAwB;;;;;;;;;;;;;;;;2BAlD5B,gCAAgC;;;;;;;;;;CA+DxC,CAAC;AAEF;;;;GAIG;AACH,eAAO,MAAM,0BAA0B;;;;;;;;;;;;;;;;;;;;;;;;;;;;+BAtE9B,gCAAgC;;;;;;;;;;;;;;;;;;CA2ExC,CAAC;AAEF;;;;;;GAMG;AACH,eAAO,MAAM,wBAAwB;;;;;;;;;;;;;;;;;;;;;;;;;;;;+BApF5B,gCAAgC;;;;;;;;;;;;;;;;;;CAuFxC,CAAC;AAEF;;;;;;GAMG;AACH,eAAO,MAAM,2BAA2B;;;;;;;;;;;;;;;;;;;;;;;;;;;;+BAhG/B,gCAAgC;;;;;;;;;;;;;;;;;;CAmGxC,CAAC"}
\ No newline at end of file
+{"version":3,"file":"selectors.d.cts","sourceRoot":"","sources":["../src/selectors.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,WAAW,EAAE,aAAa,EAAE,GAAG,EAAE,wBAAwB;AAIvE,OAAO,KAAK,EAAE,gCAAgC,EAAE,0CAAsC;AAGtF;;;;;GAKG;AACH,eAAO,MAAM,uBAAuB,UAC3B,gCAAgC;;CACb,CAAC;AAE7B;;;;;;;;;GASG;AACH,eAAO,MAAM,sBAAsB,YAAa,GAAG,GAAG,WAAW;;;;;;;;;;;;;;;;2BAbxD,gCAAgC;;;;;;;;;;CAsBrC,CAAC;AAEL;;;;;;;;GAQG;AACH,eAAO,MAAM,4CAA4C,cAC5C,aAAa;;;;;;;;;;;;;;;;2BAlCjB,gCAAgC;;;;;;;;;;CAwCrC,CAAC;AAEL;;;;;;;GAOG;AACH,eAAO,MAAM,wBAAwB;;;;;;;;;;;;;;;;2BAlD5B,gCAAgC;;;;;;;;;;CA8DxC,CAAC;AAEF;;;;GAIG;AACH,eAAO,MAAM,0BAA0B;;;;;;;;;;;;;;;;;;;;;;;;;;;;+BArE9B,gCAAgC;;;;;;;;;;;;;;;;;;CA0ExC,CAAC;AAEF;;;;;;GAMG;AACH,eAAO,MAAM,wBAAwB;;;;;;;;;;;;;;;;;;;;;;;;;;;;+BAnF5B,gCAAgC;;;;;;;;;;;;;;;;;;CAsFxC,CAAC;AAEF;;;;;;GAMG;AACH,eAAO,MAAM,2BAA2B;;;;;;;;;;;;;;;;;;;;;;;;;;;;+BA/F/B,gCAAgC;;;;;;;;;;;;;;;;;;CAkGxC,CAAC"}
\ No newline at end of file
diff --git a/dist/selectors.d.mts.map b/dist/selectors.d.mts.map
index 5d972c1441d6020630d74df815802c31d2f1747d..95e92db5ccfc4365e7b4f77d804d2dbb819826f1 100644
--- a/dist/selectors.d.mts.map
+++ b/dist/selectors.d.mts.map
@@ -1 +1 @@
-{"version":3,"file":"selectors.d.mts","sourceRoot":"","sources":["../src/selectors.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,WAAW,EAAE,aAAa,EAAE,GAAG,EAAE,wBAAwB;AAIvE,OAAO,KAAK,EAAE,gCAAgC,EAAE,0CAAsC;AAGtF;;;;;GAKG;AACH,eAAO,MAAM,uBAAuB,UAC3B,gCAAgC;;CACb,CAAC;AAE7B;;;;;;;;;GASG;AACH,eAAO,MAAM,sBAAsB,YAAa,GAAG,GAAG,WAAW;;;;;;;;;;;;;;;;2BAbxD,gCAAgC;;;;;;;;;;CAsBrC,CAAC;AAEL;;;;;;;;GAQG;AACH,eAAO,MAAM,4CAA4C,cAC5C,aAAa;;;;;;;;;;;;;;;;2BAlCjB,gCAAgC;;;;;;;;;;CAwCrC,CAAC;AAEL;;;;;;;GAOG;AACH,eAAO,MAAM,wBAAwB;;;;;;;;;;;;;;;;2BAlD5B,gCAAgC;;;;;;;;;;CA+DxC,CAAC;AAEF;;;;GAIG;AACH,eAAO,MAAM,0BAA0B;;;;;;;;;;;;;;;;;;;;;;;;;;;;+BAtE9B,gCAAgC;;;;;;;;;;;;;;;;;;CA2ExC,CAAC;AAEF;;;;;;GAMG;AACH,eAAO,MAAM,wBAAwB;;;;;;;;;;;;;;;;;;;;;;;;;;;;+BApF5B,gCAAgC;;;;;;;;;;;;;;;;;;CAuFxC,CAAC;AAEF;;;;;;GAMG;AACH,eAAO,MAAM,2BAA2B;;;;;;;;;;;;;;;;;;;;;;;;;;;;+BAhG/B,gCAAgC;;;;;;;;;;;;;;;;;;CAmGxC,CAAC"}
\ No newline at end of file
+{"version":3,"file":"selectors.d.mts","sourceRoot":"","sources":["../src/selectors.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,WAAW,EAAE,aAAa,EAAE,GAAG,EAAE,wBAAwB;AAIvE,OAAO,KAAK,EAAE,gCAAgC,EAAE,0CAAsC;AAGtF;;;;;GAKG;AACH,eAAO,MAAM,uBAAuB,UAC3B,gCAAgC;;CACb,CAAC;AAE7B;;;;;;;;;GASG;AACH,eAAO,MAAM,sBAAsB,YAAa,GAAG,GAAG,WAAW;;;;;;;;;;;;;;;;2BAbxD,gCAAgC;;;;;;;;;;CAsBrC,CAAC;AAEL;;;;;;;;GAQG;AACH,eAAO,MAAM,4CAA4C,cAC5C,aAAa;;;;;;;;;;;;;;;;2BAlCjB,gCAAgC;;;;;;;;;;CAwCrC,CAAC;AAEL;;;;;;;GAOG;AACH,eAAO,MAAM,wBAAwB;;;;;;;;;;;;;;;;2BAlD5B,gCAAgC;;;;;;;;;;CA8DxC,CAAC;AAEF;;;;GAIG;AACH,eAAO,MAAM,0BAA0B;;;;;;;;;;;;;;;;;;;;;;;;;;;;+BArE9B,gCAAgC;;;;;;;;;;;;;;;;;;CA0ExC,CAAC;AAEF;;;;;;GAMG;AACH,eAAO,MAAM,wBAAwB;;;;;;;;;;;;;;;;;;;;;;;;;;;;+BAnF5B,gCAAgC;;;;;;;;;;;;;;;;;;CAsFxC,CAAC;AAEF;;;;;;GAMG;AACH,eAAO,MAAM,2BAA2B;;;;;;;;;;;;;;;;;;;;;;;;;;;;+BA/F/B,gCAAgC;;;;;;;;;;;;;;;;;;CAkGxC,CAAC"}
\ No newline at end of file
diff --git a/dist/selectors.mjs.map b/dist/selectors.mjs.map
index 3f7630ef01bc68019868a3907d3d3e777f6e8262..0e817ca30ca395837f7623fab800366db957f530 100644
--- a/dist/selectors.mjs.map
+++ b/dist/selectors.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"selectors.mjs","sourceRoot":"","sources":["../src/selectors.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,kBAAkB,EAAE,wBAAwB;AACrD,OAAO,EAAE,cAAc,EAAE,iBAAiB;AAG1C,OAAO,EAAE,UAAU,EAAE,oBAAgB;AAErC;;;;;GAKG;AACH,MAAM,CAAC,MAAM,uBAAuB,GAAG,CACrC,KAAuC,EACvC,EAAE,CAAC,KAAK,CAAC,iBAAiB,CAAC;AAE7B;;;;;;;;;GASG;AACH,MAAM,CAAC,MAAM,sBAAsB,GAAG,CAAC,OAA0B,EAAE,EAAE,CACnE,cAAc,CAAC,uBAAuB,EAAE,CAAC,iBAAiB,EAAE,EAAE;IAC5D,MAAM,EAAE,SAAS,EAAE,UAAU,EAAE,GAAG,UAAU,CAAC,OAAO,CAAC,CAAC;IAEtD,OAAO,CACL,SAAS,IAAI,iBAAiB;QAC9B,UAAU,IAAI,iBAAiB,CAAC,SAAS,CAAC;QAC1C,iBAAiB,CAAC,SAAS,CAAC,CAAC,UAAU,CAAC,CACzC,CAAC;AACJ,CAAC,CAAC,CAAC;AAEL;;;;;;;;GAQG;AACH,MAAM,CAAC,MAAM,4CAA4C,GAAG,CAC1D,SAAwB,EACxB,EAAE,CACF,cAAc,CAAC,uBAAuB,EAAE,CAAC,iBAAiB,EAAE,EAAE;IAC5D,OAAO,MAAM,CAAC,OAAO,CAAC,iBAAiB,CAAC,SAAS,CAAC,IAAI,EAAE,CAAC;SACtD,MAAM,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,EAAE,EAAE,CAAC,OAAO,CAAC;SAChC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,CAAC;AACvB,CAAC,CAAC,CAAC;AAEL;;;;;;;GAOG;AACH,MAAM,CAAC,MAAM,wBAAwB,GAAG,cAAc,CACpD,uBAAuB,EACvB,CAAC,iBAAiB,EAAE,EAAE;IACpB,OAAQ,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAqB,CAAC,MAAM,CAC/D,CAAC,GAAG,EAAE,EAAE,EAAE,EAAE;QACV,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,OAAO,CAAC,iBAAiB,CAAC,EAAE,CAAC,CAAC;aAC5C,MAAM,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,EAAE,EAAE,CAAC,OAAO,CAAC;aAChC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,CAAC;QACrB,OAAO,GAAG,CAAC;IACb,CAAC,EACD,EAAqC,CACtC,CAAC;AACJ,CAAC,CACF,CAAC;AAEF;;;;GAIG;AACH,MAAM,CAAC,MAAM,0BAA0B,GAAG,cAAc,CACtD,wBAAwB,EACxB,CAAC,kBAAkB,EAAE,EAAE;IACrB,OAAO,MAAM,CAAC,MAAM,CAAC,kBAAkB,CAAC,CAAC,IAAI,EAAE,CAAC,MAAM,CAAC;AACzD,CAAC,CACF,CAAC;AAEF;;;;;;GAMG;AACH,MAAM,CAAC,MAAM,wBAAwB,GAAG,cAAc,CACpD,4CAA4C,CAAC,kBAAkB,CAAC,MAAM,CAAC,EACvE,CAAC,kBAAkB,EAAE,EAAE,CAAC,kBAAkB,CAC3C,CAAC;AAEF;;;;;;GAMG;AACH,MAAM,CAAC,MAAM,2BAA2B,GAAG,cAAc,CACvD,4CAA4C,CAAC,kBAAkB,CAAC,MAAM,CAAC,EACvE,CAAC,qBAAqB,EAAE,EAAE,CAAC,qBAAqB,CACjD,CAAC","sourcesContent":["import type { CaipChainId, CaipNamespace, Hex } from '@metamask/utils';\nimport { KnownCaipNamespace } from '@metamask/utils';\nimport { createSelector } from 'reselect';\n\nimport type { NetworkEnablementControllerState } from './NetworkEnablementController';\nimport { deriveKeys } from './utils';\n\n/**\n * Base selector to get the enabled network map from the controller state.\n *\n * @param state - The NetworkEnablementController state\n * @returns The enabled network map\n */\nexport const selectEnabledNetworkMap = (\n  state: NetworkEnablementControllerState,\n) => state.enabledNetworkMap;\n\n/**\n * Selector to check if a specific network is enabled.\n *\n * This selector accepts either a Hex chain ID (for EVM networks) or a CAIP-2 chain ID\n * (for any blockchain network) and returns whether the network is currently enabled.\n * It returns false for unknown networks or if there's an error parsing the chain ID.\n *\n * @param chainId - The chain ID to check (Hex or CAIP-2 format)\n * @returns A selector function that returns true if the network is enabled, false otherwise\n */\nexport const selectIsNetworkEnabled = (chainId: Hex | CaipChainId) =>\n  createSelector(selectEnabledNetworkMap, (enabledNetworkMap) => {\n    const { namespace, storageKey } = deriveKeys(chainId);\n\n    return (\n      namespace in enabledNetworkMap &&\n      storageKey in enabledNetworkMap[namespace] &&\n      enabledNetworkMap[namespace][storageKey]\n    );\n  });\n\n/**\n * Selector builder to get all enabled networks for a specific namespace.\n *\n * The selector returned by this function returns an array of chain IDs (as strings) for all enabled networks\n * within the specified namespace (e.g., 'eip155' for EVM networks, 'solana' for Solana).\n *\n * @param namespace - The CAIP namespace to get enabled networks for (e.g., 'eip155', 'solana')\n * @returns A selector function that returns an array of chain ID strings for enabled networks in the namespace\n */\nexport const createSelectorForEnabledNetworksForNamespace = (\n  namespace: CaipNamespace,\n) =>\n  createSelector(selectEnabledNetworkMap, (enabledNetworkMap) => {\n    return Object.entries(enabledNetworkMap[namespace] ?? {})\n      .filter(([, enabled]) => enabled)\n      .map(([id]) => id);\n  });\n\n/**\n * Selector to get all enabled networks across all namespaces.\n *\n * This selector returns a record where keys are CAIP namespaces and values are arrays\n * of enabled chain IDs within each namespace.\n *\n * @returns A selector function that returns a record mapping namespace to array of enabled chain IDs\n */\nexport const selectAllEnabledNetworks = createSelector(\n  selectEnabledNetworkMap,\n  (enabledNetworkMap) => {\n    return (Object.keys(enabledNetworkMap) as CaipNamespace[]).reduce(\n      (acc, ns) => {\n        acc[ns] = Object.entries(enabledNetworkMap[ns])\n          .filter(([, enabled]) => enabled)\n          .map(([id]) => id);\n        return acc;\n      },\n      {} as Record<CaipNamespace, string[]>,\n    );\n  },\n);\n\n/**\n * Selector to get the total count of enabled networks across all namespaces.\n *\n * @returns A selector function that returns the total number of enabled networks\n */\nexport const selectEnabledNetworksCount = createSelector(\n  selectAllEnabledNetworks,\n  (allEnabledNetworks) => {\n    return Object.values(allEnabledNetworks).flat().length;\n  },\n);\n\n/**\n * Selector to get all enabled EVM networks.\n *\n * This is a convenience selector that specifically targets EIP-155 networks.\n *\n * @returns A selector function that returns an array of enabled EVM chain IDs\n */\nexport const selectEnabledEvmNetworks = createSelector(\n  createSelectorForEnabledNetworksForNamespace(KnownCaipNamespace.Eip155),\n  (enabledEvmNetworks) => enabledEvmNetworks,\n);\n\n/**\n * Selector to get all enabled Solana networks.\n *\n * This is a convenience selector that specifically targets Solana networks.\n *\n * @returns A selector function that returns an array of enabled Solana chain IDs\n */\nexport const selectEnabledSolanaNetworks = createSelector(\n  createSelectorForEnabledNetworksForNamespace(KnownCaipNamespace.Solana),\n  (enabledSolanaNetworks) => enabledSolanaNetworks,\n);\n"]}
\ No newline at end of file
+{"version":3,"file":"selectors.mjs","sourceRoot":"","sources":["../src/selectors.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,kBAAkB,EAAE,wBAAwB;AACrD,OAAO,EAAE,cAAc,EAAE,iBAAiB;AAG1C,OAAO,EAAE,UAAU,EAAE,oBAAgB;AAErC;;;;;GAKG;AACH,MAAM,CAAC,MAAM,uBAAuB,GAAG,CACrC,KAAuC,EACvC,EAAE,CAAC,KAAK,CAAC,iBAAiB,CAAC;AAE7B;;;;;;;;;GASG;AACH,MAAM,CAAC,MAAM,sBAAsB,GAAG,CAAC,OAA0B,EAAE,EAAE,CACnE,cAAc,CAAC,uBAAuB,EAAE,CAAC,iBAAiB,EAAE,EAAE;IAC5D,MAAM,EAAE,SAAS,EAAE,UAAU,EAAE,GAAG,UAAU,CAAC,OAAO,CAAC,CAAC;IAEtD,OAAO,CACL,SAAS,IAAI,iBAAiB;QAC9B,UAAU,IAAI,iBAAiB,CAAC,SAAS,CAAC;QAC1C,iBAAiB,CAAC,SAAS,CAAC,CAAC,UAAU,CAAC,CACzC,CAAC;AACJ,CAAC,CAAC,CAAC;AAEL;;;;;;;;GAQG;AACH,MAAM,CAAC,MAAM,4CAA4C,GAAG,CAC1D,SAAwB,EACxB,EAAE,CACF,cAAc,CAAC,uBAAuB,EAAE,CAAC,iBAAiB,EAAE,EAAE;IAC5D,OAAO,MAAM,CAAC,OAAO,CAAC,iBAAiB,CAAC,SAAS,CAAC,IAAI,EAAE,CAAC;SACtD,MAAM,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,EAAE,EAAE,CAAC,OAAO,CAAC;SAChC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,CAAC;AACvB,CAAC,CAAC,CAAC;AAEL;;;;;;;GAOG;AACH,MAAM,CAAC,MAAM,wBAAwB,GAAG,cAAc,CACpD,uBAAuB,EACvB,CAAC,iBAAiB,EAAE,EAAE;IACpB,OAAO,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC,MAAM,CAE1C,CAAC,GAAG,EAAE,EAAE,EAAE,EAAE;QACZ,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,OAAO,CAAC,iBAAiB,CAAC,EAAE,CAAC,CAAC;aAC5C,MAAM,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,EAAE,EAAE,CAAC,OAAO,CAAC;aAChC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,CAAC;QACrB,OAAO,GAAG,CAAC;IACb,CAAC,EAAE,EAAE,CAAC,CAAC;AACT,CAAC,CACF,CAAC;AAEF;;;;GAIG;AACH,MAAM,CAAC,MAAM,0BAA0B,GAAG,cAAc,CACtD,wBAAwB,EACxB,CAAC,kBAAkB,EAAE,EAAE;IACrB,OAAO,MAAM,CAAC,MAAM,CAAC,kBAAkB,CAAC,CAAC,IAAI,EAAE,CAAC,MAAM,CAAC;AACzD,CAAC,CACF,CAAC;AAEF;;;;;;GAMG;AACH,MAAM,CAAC,MAAM,wBAAwB,GAAG,cAAc,CACpD,4CAA4C,CAAC,kBAAkB,CAAC,MAAM,CAAC,EACvE,CAAC,kBAAkB,EAAE,EAAE,CAAC,kBAAkB,CAC3C,CAAC;AAEF;;;;;;GAMG;AACH,MAAM,CAAC,MAAM,2BAA2B,GAAG,cAAc,CACvD,4CAA4C,CAAC,kBAAkB,CAAC,MAAM,CAAC,EACvE,CAAC,qBAAqB,EAAE,EAAE,CAAC,qBAAqB,CACjD,CAAC","sourcesContent":["import type { CaipChainId, CaipNamespace, Hex } from '@metamask/utils';\nimport { KnownCaipNamespace } from '@metamask/utils';\nimport { createSelector } from 'reselect';\n\nimport type { NetworkEnablementControllerState } from './NetworkEnablementController';\nimport { deriveKeys } from './utils';\n\n/**\n * Base selector to get the enabled network map from the controller state.\n *\n * @param state - The NetworkEnablementController state\n * @returns The enabled network map\n */\nexport const selectEnabledNetworkMap = (\n  state: NetworkEnablementControllerState,\n) => state.enabledNetworkMap;\n\n/**\n * Selector to check if a specific network is enabled.\n *\n * This selector accepts either a Hex chain ID (for EVM networks) or a CAIP-2 chain ID\n * (for any blockchain network) and returns whether the network is currently enabled.\n * It returns false for unknown networks or if there's an error parsing the chain ID.\n *\n * @param chainId - The chain ID to check (Hex or CAIP-2 format)\n * @returns A selector function that returns true if the network is enabled, false otherwise\n */\nexport const selectIsNetworkEnabled = (chainId: Hex | CaipChainId) =>\n  createSelector(selectEnabledNetworkMap, (enabledNetworkMap) => {\n    const { namespace, storageKey } = deriveKeys(chainId);\n\n    return (\n      namespace in enabledNetworkMap &&\n      storageKey in enabledNetworkMap[namespace] &&\n      enabledNetworkMap[namespace][storageKey]\n    );\n  });\n\n/**\n * Selector builder to get all enabled networks for a specific namespace.\n *\n * The selector returned by this function returns an array of chain IDs (as strings) for all enabled networks\n * within the specified namespace (e.g., 'eip155' for EVM networks, 'solana' for Solana).\n *\n * @param namespace - The CAIP namespace to get enabled networks for (e.g., 'eip155', 'solana')\n * @returns A selector function that returns an array of chain ID strings for enabled networks in the namespace\n */\nexport const createSelectorForEnabledNetworksForNamespace = (\n  namespace: CaipNamespace,\n) =>\n  createSelector(selectEnabledNetworkMap, (enabledNetworkMap) => {\n    return Object.entries(enabledNetworkMap[namespace] ?? {})\n      .filter(([, enabled]) => enabled)\n      .map(([id]) => id);\n  });\n\n/**\n * Selector to get all enabled networks across all namespaces.\n *\n * This selector returns a record where keys are CAIP namespaces and values are arrays\n * of enabled chain IDs within each namespace.\n *\n * @returns A selector function that returns a record mapping namespace to array of enabled chain IDs\n */\nexport const selectAllEnabledNetworks = createSelector(\n  selectEnabledNetworkMap,\n  (enabledNetworkMap) => {\n    return Object.keys(enabledNetworkMap).reduce<\n      Record<CaipNamespace, string[]>\n    >((acc, ns) => {\n      acc[ns] = Object.entries(enabledNetworkMap[ns])\n        .filter(([, enabled]) => enabled)\n        .map(([id]) => id);\n      return acc;\n    }, {});\n  },\n);\n\n/**\n * Selector to get the total count of enabled networks across all namespaces.\n *\n * @returns A selector function that returns the total number of enabled networks\n */\nexport const selectEnabledNetworksCount = createSelector(\n  selectAllEnabledNetworks,\n  (allEnabledNetworks) => {\n    return Object.values(allEnabledNetworks).flat().length;\n  },\n);\n\n/**\n * Selector to get all enabled EVM networks.\n *\n * This is a convenience selector that specifically targets EIP-155 networks.\n *\n * @returns A selector function that returns an array of enabled EVM chain IDs\n */\nexport const selectEnabledEvmNetworks = createSelector(\n  createSelectorForEnabledNetworksForNamespace(KnownCaipNamespace.Eip155),\n  (enabledEvmNetworks) => enabledEvmNetworks,\n);\n\n/**\n * Selector to get all enabled Solana networks.\n *\n * This is a convenience selector that specifically targets Solana networks.\n *\n * @returns A selector function that returns an array of enabled Solana chain IDs\n */\nexport const selectEnabledSolanaNetworks = createSelector(\n  createSelectorForEnabledNetworksForNamespace(KnownCaipNamespace.Solana),\n  (enabledSolanaNetworks) => enabledSolanaNetworks,\n);\n"]}
\ No newline at end of file
diff --git a/dist/utils.cjs.map b/dist/utils.cjs.map
index 363ac953fa9bc4d94a26a16552b1a0945ce836de..226a8a3b4c35c52a0a461885529eea2b6f30b9d6 100644
--- a/dist/utils.cjs.map
+++ b/dist/utils.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"utils.cjs","sourceRoot":"","sources":["../src/utils.ts"],"names":[],"mappings":";;;AAAA,iEAAmD;AACnD,2FAA2E;AAE3E,2CAKyB;AAEzB,+CAA+C;AAa/C;;;;;;;;;;;GAWG;AACH,SAAgB,UAAU,CAAC,OAA0B;IACnD,MAAM,WAAW,GAAG,IAAA,qBAAa,EAAC,OAAO,CAAC;QACxC,CAAC,CAAC,OAAO;QACT,CAAC,CAAC,IAAA,gDAAgB,EAAC,OAAO,CAAC,CAAC;IAE9B,MAAM,EAAE,SAAS,EAAE,SAAS,EAAE,GAAG,IAAA,wBAAgB,EAAC,WAAW,CAAC,CAAC;IAC/D,IAAI,UAAU,CAAC;IACf,IAAI,SAAS,KAAM,0BAAkB,CAAC,MAAiB,EAAE;QACvD,UAAU,GAAG,IAAA,mBAAW,EAAC,OAAO,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,IAAA,wBAAK,EAAC,SAAS,CAAC,CAAC;KAChE;SAAM;QACL,UAAU,GAAG,WAAW,CAAC;KAC1B;IACD,OAAO,EAAE,SAAS,EAAE,UAAU,EAAE,WAAW,EAAE,SAAS,EAAE,CAAC;AAC3D,CAAC;AAbD,gCAaC;AAED;;;;;;;;;GASG;AACH,SAAgB,+BAA+B,CAC7C,KAAuC,EACvC,WAAwB;IAExB,MAAM,EAAE,SAAS,EAAE,UAAU,EAAE,GAAG,WAAW,CAAC;IAE9C,0CAA0C;IAC1C,IAAI,CAAC,KAAK,CAAC,iBAAiB,CAAC,SAAS,CAAC,EAAE;QACvC,OAAO,KAAK,CAAC;KACd;IAED,MAAM,QAAQ,GAAG,KAAK,CAAC,iBAAiB,CAAC,SAAS,CAAC,CAAC;IAEpD,6CAA6C;IAC7C,MAAM,eAAe,GAAG,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,MAAM,CACrD,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,EAAE,EAAE,CAAC,OAAO,CAC1B,CAAC;IAEF,yEAAyE;IACzE,IAAI,eAAe,CAAC,MAAM,KAAK,CAAC,EAAE;QAChC,MAAM,CAAC,cAAc,CAAC,GAAG,eAAe,CAAC,CAAC,CAAC,CAAC;QAC5C,OAAO,cAAc,KAAK,UAAU,CAAC;KACtC;IAED,8DAA8D;IAC9D,OAAO,KAAK,CAAC;AACf,CAAC;AA1BD,0EA0BC;AAED;;;;;GAKG;AACH,SAAgB,gBAAgB,CAAC,SAAiB;IAChD,IAAI;QACF,OAAO,4BAAgB,CAAC,QAAQ,CAAC,IAAA,wBAAK,EAAC,SAAS,CAAC,CAAC,CAAC;KACpD;IAAC,MAAM;QACN,yEAAyE;QACzE,6BAA6B;QAC7B,OAAO,KAAK,CAAC;KACd;AACH,CAAC;AARD,4CAQC","sourcesContent":["import { toHex } from '@metamask/controller-utils';\nimport { toEvmCaipChainId } from '@metamask/multichain-network-controller';\nimport type { CaipChainId, CaipNamespace, Hex } from '@metamask/utils';\nimport {\n  isCaipChainId,\n  isHexString,\n  KnownCaipNamespace,\n  parseCaipChainId,\n} from '@metamask/utils';\n\nimport { POPULAR_NETWORKS } from './constants';\nimport type { NetworkEnablementControllerState } from './NetworkEnablementController';\n\n/**\n * Represents the parsed keys derived from a chain ID.\n */\nexport type DerivedKeys = {\n  namespace: CaipNamespace;\n  storageKey: Hex | CaipChainId;\n  caipChainId: CaipChainId;\n  reference: string;\n};\n\n/**\n * Derives the namespace, storage key, and CAIP chain ID from a given chain ID.\n *\n * This utility function handles the conversion between different chain ID formats.\n * For EVM networks, it converts Hex chain IDs to CAIP-2 format and determines\n * the appropriate storage key. For non-EVM networks, it parses the CAIP-2 chain ID\n * and uses the full chain ID as the storage key.\n *\n * @param chainId - The chain ID to derive keys from (Hex or CAIP-2 format)\n * @returns An object containing namespace, storageKey, and caipId\n * @throws Error if the chain ID cannot be parsed\n */\nexport function deriveKeys(chainId: Hex | CaipChainId): DerivedKeys {\n  const caipChainId = isCaipChainId(chainId)\n    ? chainId\n    : toEvmCaipChainId(chainId);\n\n  const { namespace, reference } = parseCaipChainId(caipChainId);\n  let storageKey;\n  if (namespace === (KnownCaipNamespace.Eip155 as string)) {\n    storageKey = isHexString(chainId) ? chainId : toHex(reference);\n  } else {\n    storageKey = caipChainId;\n  }\n  return { namespace, storageKey, caipChainId, reference };\n}\n\n/**\n * Checks if the specified network is the only enabled network in its namespace.\n *\n * This function is used to prevent unnecessary state updates when trying to enable\n * This method is used to prevent the last network in a namespace from being removed.\n *\n * @param state - The current controller state\n * @param derivedKeys - The parsed keys object containing namespace and storageKey\n * @returns True if the network is the only enabled network in the namespace, false otherwise\n */\nexport function isOnlyNetworkEnabledInNamespace(\n  state: NetworkEnablementControllerState,\n  derivedKeys: DerivedKeys,\n): boolean {\n  const { namespace, storageKey } = derivedKeys;\n\n  // Early return if namespace doesn't exist\n  if (!state.enabledNetworkMap[namespace]) {\n    return false;\n  }\n\n  const networks = state.enabledNetworkMap[namespace];\n\n  // Get all enabled networks in this namespace\n  const enabledNetworks = Object.entries(networks).filter(\n    ([_, enabled]) => enabled,\n  );\n\n  // Check if there's exactly one enabled network and it matches our target\n  if (enabledNetworks.length === 1) {\n    const [onlyEnabledKey] = enabledNetworks[0];\n    return onlyEnabledKey === storageKey;\n  }\n\n  // Return false if there are zero or multiple enabled networks\n  return false;\n}\n\n/**\n * Checks if a network is considered popular based on its reference.\n *\n * @param reference - The network reference (typically the chain ID reference part)\n * @returns True if the network is popular, false otherwise\n */\nexport function isPopularNetwork(reference: string): boolean {\n  try {\n    return POPULAR_NETWORKS.includes(toHex(reference));\n  } catch {\n    // If toHex fails (e.g., for non-decimal references like Bitcoin hashes),\n    // the network is not popular\n    return false;\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"utils.cjs","sourceRoot":"","sources":["../src/utils.ts"],"names":[],"mappings":";;;AAAA,iEAAmD;AACnD,2FAA2E;AAE3E,2CAKyB;AAEzB,+CAA+C;AAa/C;;;;;;;;;;;GAWG;AACH,SAAgB,UAAU,CAAC,OAA0B;IACnD,MAAM,WAAW,GAAG,IAAA,qBAAa,EAAC,OAAO,CAAC;QACxC,CAAC,CAAC,OAAO;QACT,CAAC,CAAC,IAAA,gDAAgB,EAAC,OAAO,CAAC,CAAC;IAE9B,MAAM,EAAE,SAAS,EAAE,SAAS,EAAE,GAAG,IAAA,wBAAgB,EAAC,WAAW,CAAC,CAAC;IAC/D,IAAI,UAAU,CAAC;IACf,IAAI,SAAS,KAAM,0BAAkB,CAAC,MAAiB,EAAE,CAAC;QACxD,UAAU,GAAG,IAAA,mBAAW,EAAC,OAAO,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,IAAA,wBAAK,EAAC,SAAS,CAAC,CAAC;IACjE,CAAC;SAAM,CAAC;QACN,UAAU,GAAG,WAAW,CAAC;IAC3B,CAAC;IACD,OAAO,EAAE,SAAS,EAAE,UAAU,EAAE,WAAW,EAAE,SAAS,EAAE,CAAC;AAC3D,CAAC;AAbD,gCAaC;AAED;;;;;;;;;GASG;AACH,SAAgB,+BAA+B,CAC7C,KAAuC,EACvC,WAAwB;IAExB,MAAM,EAAE,SAAS,EAAE,UAAU,EAAE,GAAG,WAAW,CAAC;IAE9C,0CAA0C;IAC1C,IAAI,CAAC,KAAK,CAAC,iBAAiB,CAAC,SAAS,CAAC,EAAE,CAAC;QACxC,OAAO,KAAK,CAAC;IACf,CAAC;IAED,MAAM,QAAQ,GAAG,KAAK,CAAC,iBAAiB,CAAC,SAAS,CAAC,CAAC;IAEpD,6CAA6C;IAC7C,MAAM,eAAe,GAAG,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,MAAM,CACrD,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,EAAE,EAAE,CAAC,OAAO,CAC1B,CAAC;IAEF,yEAAyE;IACzE,IAAI,eAAe,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QACjC,MAAM,CAAC,cAAc,CAAC,GAAG,eAAe,CAAC,CAAC,CAAC,CAAC;QAC5C,OAAO,cAAc,KAAK,UAAU,CAAC;IACvC,CAAC;IAED,8DAA8D;IAC9D,OAAO,KAAK,CAAC;AACf,CAAC;AA1BD,0EA0BC;AAED;;;;;GAKG;AACH,SAAgB,gBAAgB,CAAC,SAAiB;IAChD,IAAI,CAAC;QACH,OAAO,4BAAgB,CAAC,QAAQ,CAAC,IAAA,wBAAK,EAAC,SAAS,CAAC,CAAC,CAAC;IACrD,CAAC;IAAC,MAAM,CAAC;QACP,yEAAyE;QACzE,6BAA6B;QAC7B,OAAO,KAAK,CAAC;IACf,CAAC;AACH,CAAC;AARD,4CAQC","sourcesContent":["import { toHex } from '@metamask/controller-utils';\nimport { toEvmCaipChainId } from '@metamask/multichain-network-controller';\nimport type { CaipChainId, CaipNamespace, Hex } from '@metamask/utils';\nimport {\n  isCaipChainId,\n  isHexString,\n  KnownCaipNamespace,\n  parseCaipChainId,\n} from '@metamask/utils';\n\nimport { POPULAR_NETWORKS } from './constants';\nimport type { NetworkEnablementControllerState } from './NetworkEnablementController';\n\n/**\n * Represents the parsed keys derived from a chain ID.\n */\nexport type DerivedKeys = {\n  namespace: CaipNamespace;\n  storageKey: Hex | CaipChainId;\n  caipChainId: CaipChainId;\n  reference: string;\n};\n\n/**\n * Derives the namespace, storage key, and CAIP chain ID from a given chain ID.\n *\n * This utility function handles the conversion between different chain ID formats.\n * For EVM networks, it converts Hex chain IDs to CAIP-2 format and determines\n * the appropriate storage key. For non-EVM networks, it parses the CAIP-2 chain ID\n * and uses the full chain ID as the storage key.\n *\n * @param chainId - The chain ID to derive keys from (Hex or CAIP-2 format)\n * @returns An object containing namespace, storageKey, and caipId\n * @throws Error if the chain ID cannot be parsed\n */\nexport function deriveKeys(chainId: Hex | CaipChainId): DerivedKeys {\n  const caipChainId = isCaipChainId(chainId)\n    ? chainId\n    : toEvmCaipChainId(chainId);\n\n  const { namespace, reference } = parseCaipChainId(caipChainId);\n  let storageKey;\n  if (namespace === (KnownCaipNamespace.Eip155 as string)) {\n    storageKey = isHexString(chainId) ? chainId : toHex(reference);\n  } else {\n    storageKey = caipChainId;\n  }\n  return { namespace, storageKey, caipChainId, reference };\n}\n\n/**\n * Checks if the specified network is the only enabled network in its namespace.\n *\n * This function is used to prevent unnecessary state updates when trying to enable\n * This method is used to prevent the last network in a namespace from being removed.\n *\n * @param state - The current controller state\n * @param derivedKeys - The parsed keys object containing namespace and storageKey\n * @returns True if the network is the only enabled network in the namespace, false otherwise\n */\nexport function isOnlyNetworkEnabledInNamespace(\n  state: NetworkEnablementControllerState,\n  derivedKeys: DerivedKeys,\n): boolean {\n  const { namespace, storageKey } = derivedKeys;\n\n  // Early return if namespace doesn't exist\n  if (!state.enabledNetworkMap[namespace]) {\n    return false;\n  }\n\n  const networks = state.enabledNetworkMap[namespace];\n\n  // Get all enabled networks in this namespace\n  const enabledNetworks = Object.entries(networks).filter(\n    ([_, enabled]) => enabled,\n  );\n\n  // Check if there's exactly one enabled network and it matches our target\n  if (enabledNetworks.length === 1) {\n    const [onlyEnabledKey] = enabledNetworks[0];\n    return onlyEnabledKey === storageKey;\n  }\n\n  // Return false if there are zero or multiple enabled networks\n  return false;\n}\n\n/**\n * Checks if a network is considered popular based on its reference.\n *\n * @param reference - The network reference (typically the chain ID reference part)\n * @returns True if the network is popular, false otherwise\n */\nexport function isPopularNetwork(reference: string): boolean {\n  try {\n    return POPULAR_NETWORKS.includes(toHex(reference));\n  } catch {\n    // If toHex fails (e.g., for non-decimal references like Bitcoin hashes),\n    // the network is not popular\n    return false;\n  }\n}\n"]}
\ No newline at end of file
diff --git a/dist/utils.mjs.map b/dist/utils.mjs.map
index b6738fe729cb88615d0306594ccb3265eb060ca7..cf52104d40785c36a8d69ef5400a84ba5d38366e 100644
--- a/dist/utils.mjs.map
+++ b/dist/utils.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"utils.mjs","sourceRoot":"","sources":["../src/utils.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,KAAK,EAAE,mCAAmC;AACnD,OAAO,EAAE,gBAAgB,EAAE,gDAAgD;AAE3E,OAAO,EACL,aAAa,EACb,WAAW,EACX,kBAAkB,EAClB,gBAAgB,EACjB,wBAAwB;AAEzB,OAAO,EAAE,gBAAgB,EAAE,wBAAoB;AAa/C;;;;;;;;;;;GAWG;AACH,MAAM,UAAU,UAAU,CAAC,OAA0B;IACnD,MAAM,WAAW,GAAG,aAAa,CAAC,OAAO,CAAC;QACxC,CAAC,CAAC,OAAO;QACT,CAAC,CAAC,gBAAgB,CAAC,OAAO,CAAC,CAAC;IAE9B,MAAM,EAAE,SAAS,EAAE,SAAS,EAAE,GAAG,gBAAgB,CAAC,WAAW,CAAC,CAAC;IAC/D,IAAI,UAAU,CAAC;IACf,IAAI,SAAS,KAAM,kBAAkB,CAAC,MAAiB,EAAE;QACvD,UAAU,GAAG,WAAW,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;KAChE;SAAM;QACL,UAAU,GAAG,WAAW,CAAC;KAC1B;IACD,OAAO,EAAE,SAAS,EAAE,UAAU,EAAE,WAAW,EAAE,SAAS,EAAE,CAAC;AAC3D,CAAC;AAED;;;;;;;;;GASG;AACH,MAAM,UAAU,+BAA+B,CAC7C,KAAuC,EACvC,WAAwB;IAExB,MAAM,EAAE,SAAS,EAAE,UAAU,EAAE,GAAG,WAAW,CAAC;IAE9C,0CAA0C;IAC1C,IAAI,CAAC,KAAK,CAAC,iBAAiB,CAAC,SAAS,CAAC,EAAE;QACvC,OAAO,KAAK,CAAC;KACd;IAED,MAAM,QAAQ,GAAG,KAAK,CAAC,iBAAiB,CAAC,SAAS,CAAC,CAAC;IAEpD,6CAA6C;IAC7C,MAAM,eAAe,GAAG,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,MAAM,CACrD,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,EAAE,EAAE,CAAC,OAAO,CAC1B,CAAC;IAEF,yEAAyE;IACzE,IAAI,eAAe,CAAC,MAAM,KAAK,CAAC,EAAE;QAChC,MAAM,CAAC,cAAc,CAAC,GAAG,eAAe,CAAC,CAAC,CAAC,CAAC;QAC5C,OAAO,cAAc,KAAK,UAAU,CAAC;KACtC;IAED,8DAA8D;IAC9D,OAAO,KAAK,CAAC;AACf,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,gBAAgB,CAAC,SAAiB;IAChD,IAAI;QACF,OAAO,gBAAgB,CAAC,QAAQ,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC;KACpD;IAAC,MAAM;QACN,yEAAyE;QACzE,6BAA6B;QAC7B,OAAO,KAAK,CAAC;KACd;AACH,CAAC","sourcesContent":["import { toHex } from '@metamask/controller-utils';\nimport { toEvmCaipChainId } from '@metamask/multichain-network-controller';\nimport type { CaipChainId, CaipNamespace, Hex } from '@metamask/utils';\nimport {\n  isCaipChainId,\n  isHexString,\n  KnownCaipNamespace,\n  parseCaipChainId,\n} from '@metamask/utils';\n\nimport { POPULAR_NETWORKS } from './constants';\nimport type { NetworkEnablementControllerState } from './NetworkEnablementController';\n\n/**\n * Represents the parsed keys derived from a chain ID.\n */\nexport type DerivedKeys = {\n  namespace: CaipNamespace;\n  storageKey: Hex | CaipChainId;\n  caipChainId: CaipChainId;\n  reference: string;\n};\n\n/**\n * Derives the namespace, storage key, and CAIP chain ID from a given chain ID.\n *\n * This utility function handles the conversion between different chain ID formats.\n * For EVM networks, it converts Hex chain IDs to CAIP-2 format and determines\n * the appropriate storage key. For non-EVM networks, it parses the CAIP-2 chain ID\n * and uses the full chain ID as the storage key.\n *\n * @param chainId - The chain ID to derive keys from (Hex or CAIP-2 format)\n * @returns An object containing namespace, storageKey, and caipId\n * @throws Error if the chain ID cannot be parsed\n */\nexport function deriveKeys(chainId: Hex | CaipChainId): DerivedKeys {\n  const caipChainId = isCaipChainId(chainId)\n    ? chainId\n    : toEvmCaipChainId(chainId);\n\n  const { namespace, reference } = parseCaipChainId(caipChainId);\n  let storageKey;\n  if (namespace === (KnownCaipNamespace.Eip155 as string)) {\n    storageKey = isHexString(chainId) ? chainId : toHex(reference);\n  } else {\n    storageKey = caipChainId;\n  }\n  return { namespace, storageKey, caipChainId, reference };\n}\n\n/**\n * Checks if the specified network is the only enabled network in its namespace.\n *\n * This function is used to prevent unnecessary state updates when trying to enable\n * This method is used to prevent the last network in a namespace from being removed.\n *\n * @param state - The current controller state\n * @param derivedKeys - The parsed keys object containing namespace and storageKey\n * @returns True if the network is the only enabled network in the namespace, false otherwise\n */\nexport function isOnlyNetworkEnabledInNamespace(\n  state: NetworkEnablementControllerState,\n  derivedKeys: DerivedKeys,\n): boolean {\n  const { namespace, storageKey } = derivedKeys;\n\n  // Early return if namespace doesn't exist\n  if (!state.enabledNetworkMap[namespace]) {\n    return false;\n  }\n\n  const networks = state.enabledNetworkMap[namespace];\n\n  // Get all enabled networks in this namespace\n  const enabledNetworks = Object.entries(networks).filter(\n    ([_, enabled]) => enabled,\n  );\n\n  // Check if there's exactly one enabled network and it matches our target\n  if (enabledNetworks.length === 1) {\n    const [onlyEnabledKey] = enabledNetworks[0];\n    return onlyEnabledKey === storageKey;\n  }\n\n  // Return false if there are zero or multiple enabled networks\n  return false;\n}\n\n/**\n * Checks if a network is considered popular based on its reference.\n *\n * @param reference - The network reference (typically the chain ID reference part)\n * @returns True if the network is popular, false otherwise\n */\nexport function isPopularNetwork(reference: string): boolean {\n  try {\n    return POPULAR_NETWORKS.includes(toHex(reference));\n  } catch {\n    // If toHex fails (e.g., for non-decimal references like Bitcoin hashes),\n    // the network is not popular\n    return false;\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"utils.mjs","sourceRoot":"","sources":["../src/utils.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,KAAK,EAAE,mCAAmC;AACnD,OAAO,EAAE,gBAAgB,EAAE,gDAAgD;AAE3E,OAAO,EACL,aAAa,EACb,WAAW,EACX,kBAAkB,EAClB,gBAAgB,EACjB,wBAAwB;AAEzB,OAAO,EAAE,gBAAgB,EAAE,wBAAoB;AAa/C;;;;;;;;;;;GAWG;AACH,MAAM,UAAU,UAAU,CAAC,OAA0B;IACnD,MAAM,WAAW,GAAG,aAAa,CAAC,OAAO,CAAC;QACxC,CAAC,CAAC,OAAO;QACT,CAAC,CAAC,gBAAgB,CAAC,OAAO,CAAC,CAAC;IAE9B,MAAM,EAAE,SAAS,EAAE,SAAS,EAAE,GAAG,gBAAgB,CAAC,WAAW,CAAC,CAAC;IAC/D,IAAI,UAAU,CAAC;IACf,IAAI,SAAS,KAAM,kBAAkB,CAAC,MAAiB,EAAE,CAAC;QACxD,UAAU,GAAG,WAAW,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;IACjE,CAAC;SAAM,CAAC;QACN,UAAU,GAAG,WAAW,CAAC;IAC3B,CAAC;IACD,OAAO,EAAE,SAAS,EAAE,UAAU,EAAE,WAAW,EAAE,SAAS,EAAE,CAAC;AAC3D,CAAC;AAED;;;;;;;;;GASG;AACH,MAAM,UAAU,+BAA+B,CAC7C,KAAuC,EACvC,WAAwB;IAExB,MAAM,EAAE,SAAS,EAAE,UAAU,EAAE,GAAG,WAAW,CAAC;IAE9C,0CAA0C;IAC1C,IAAI,CAAC,KAAK,CAAC,iBAAiB,CAAC,SAAS,CAAC,EAAE,CAAC;QACxC,OAAO,KAAK,CAAC;IACf,CAAC;IAED,MAAM,QAAQ,GAAG,KAAK,CAAC,iBAAiB,CAAC,SAAS,CAAC,CAAC;IAEpD,6CAA6C;IAC7C,MAAM,eAAe,GAAG,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,MAAM,CACrD,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,EAAE,EAAE,CAAC,OAAO,CAC1B,CAAC;IAEF,yEAAyE;IACzE,IAAI,eAAe,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QACjC,MAAM,CAAC,cAAc,CAAC,GAAG,eAAe,CAAC,CAAC,CAAC,CAAC;QAC5C,OAAO,cAAc,KAAK,UAAU,CAAC;IACvC,CAAC;IAED,8DAA8D;IAC9D,OAAO,KAAK,CAAC;AACf,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,gBAAgB,CAAC,SAAiB;IAChD,IAAI,CAAC;QACH,OAAO,gBAAgB,CAAC,QAAQ,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC;IACrD,CAAC;IAAC,MAAM,CAAC;QACP,yEAAyE;QACzE,6BAA6B;QAC7B,OAAO,KAAK,CAAC;IACf,CAAC;AACH,CAAC","sourcesContent":["import { toHex } from '@metamask/controller-utils';\nimport { toEvmCaipChainId } from '@metamask/multichain-network-controller';\nimport type { CaipChainId, CaipNamespace, Hex } from '@metamask/utils';\nimport {\n  isCaipChainId,\n  isHexString,\n  KnownCaipNamespace,\n  parseCaipChainId,\n} from '@metamask/utils';\n\nimport { POPULAR_NETWORKS } from './constants';\nimport type { NetworkEnablementControllerState } from './NetworkEnablementController';\n\n/**\n * Represents the parsed keys derived from a chain ID.\n */\nexport type DerivedKeys = {\n  namespace: CaipNamespace;\n  storageKey: Hex | CaipChainId;\n  caipChainId: CaipChainId;\n  reference: string;\n};\n\n/**\n * Derives the namespace, storage key, and CAIP chain ID from a given chain ID.\n *\n * This utility function handles the conversion between different chain ID formats.\n * For EVM networks, it converts Hex chain IDs to CAIP-2 format and determines\n * the appropriate storage key. For non-EVM networks, it parses the CAIP-2 chain ID\n * and uses the full chain ID as the storage key.\n *\n * @param chainId - The chain ID to derive keys from (Hex or CAIP-2 format)\n * @returns An object containing namespace, storageKey, and caipId\n * @throws Error if the chain ID cannot be parsed\n */\nexport function deriveKeys(chainId: Hex | CaipChainId): DerivedKeys {\n  const caipChainId = isCaipChainId(chainId)\n    ? chainId\n    : toEvmCaipChainId(chainId);\n\n  const { namespace, reference } = parseCaipChainId(caipChainId);\n  let storageKey;\n  if (namespace === (KnownCaipNamespace.Eip155 as string)) {\n    storageKey = isHexString(chainId) ? chainId : toHex(reference);\n  } else {\n    storageKey = caipChainId;\n  }\n  return { namespace, storageKey, caipChainId, reference };\n}\n\n/**\n * Checks if the specified network is the only enabled network in its namespace.\n *\n * This function is used to prevent unnecessary state updates when trying to enable\n * This method is used to prevent the last network in a namespace from being removed.\n *\n * @param state - The current controller state\n * @param derivedKeys - The parsed keys object containing namespace and storageKey\n * @returns True if the network is the only enabled network in the namespace, false otherwise\n */\nexport function isOnlyNetworkEnabledInNamespace(\n  state: NetworkEnablementControllerState,\n  derivedKeys: DerivedKeys,\n): boolean {\n  const { namespace, storageKey } = derivedKeys;\n\n  // Early return if namespace doesn't exist\n  if (!state.enabledNetworkMap[namespace]) {\n    return false;\n  }\n\n  const networks = state.enabledNetworkMap[namespace];\n\n  // Get all enabled networks in this namespace\n  const enabledNetworks = Object.entries(networks).filter(\n    ([_, enabled]) => enabled,\n  );\n\n  // Check if there's exactly one enabled network and it matches our target\n  if (enabledNetworks.length === 1) {\n    const [onlyEnabledKey] = enabledNetworks[0];\n    return onlyEnabledKey === storageKey;\n  }\n\n  // Return false if there are zero or multiple enabled networks\n  return false;\n}\n\n/**\n * Checks if a network is considered popular based on its reference.\n *\n * @param reference - The network reference (typically the chain ID reference part)\n * @returns True if the network is popular, false otherwise\n */\nexport function isPopularNetwork(reference: string): boolean {\n  try {\n    return POPULAR_NETWORKS.includes(toHex(reference));\n  } catch {\n    // If toHex fails (e.g., for non-decimal references like Bitcoin hashes),\n    // the network is not popular\n    return false;\n  }\n}\n"]}
\ No newline at end of file
