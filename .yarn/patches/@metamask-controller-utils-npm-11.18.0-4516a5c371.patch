diff --git a/dist/constants.cjs b/dist/constants.cjs
index 7f76234eba50cc8ae6e6058caa83d66db5f9e748..d45e9d1692e20c5333e7b830ee53b083d6c0fbbd 100644
--- a/dist/constants.cjs
+++ b/dist/constants.cjs
@@ -56,6 +56,16 @@ exports.BUILT_IN_CUSTOM_NETWORKS_RPC = {
     'megaeth-testnet': 'https://carrot.megaeth.com/rpc',
     'megaeth-testnet-v2': 'https://carrot.megaeth.com/rpc',
     'monad-testnet': 'https://testnet-rpc.monad.xyz',
+    // Mainnet networks with custom RPC URLs
+    'hyper-evm-mainnet': 'https://rpc.hyperliquid.xyz/evm',
+    'zksync-era-mainnet': 'https://mainnet.era.zksync.io',
+    'megaeth-mainnet': 'https://mainnet.megaeth.com/rpc',
+    // Environment 3: Power User test networks
+    'fantom-mainnet': 'https://rpcapi.fantom.network',
+    'gnosis-mainnet': 'https://gnosis-mainnet.public.blastapi.io',
+    'cronos-mainnet': 'https://evm.cronos.org',
+    'moonbeam-mainnet': 'https://rpc.api.moonbeam.network',
+    'moonriver-mainnet': 'https://rpc.api.moonriver.moonbeam.network',
 };
 /**
  * Map of all build-in Infura networks to their network, ticker and chain IDs.
@@ -166,6 +176,90 @@ exports.BUILT_IN_NETWORKS = {
             blockExplorerUrl: types_1.BlockExplorerUrl['sei-mainnet'],
         },
     },
+    // Avalanche
+    [types_1.NetworkType['avalanche-mainnet']]: {
+        chainId: types_1.ChainId['avalanche-mainnet'],
+        ticker: types_1.NetworksTicker['avalanche-mainnet'],
+        rpcPrefs: {
+            blockExplorerUrl: types_1.BlockExplorerUrl['avalanche-mainnet'],
+        },
+    },
+    // HyperEVM
+    [types_1.NetworkType['hyper-evm-mainnet']]: {
+        chainId: types_1.ChainId['hyper-evm-mainnet'],
+        ticker: types_1.NetworksTicker['hyper-evm-mainnet'],
+        rpcPrefs: {
+            blockExplorerUrl: types_1.BlockExplorerUrl['hyper-evm-mainnet'],
+        },
+    },
+    // Palm
+    [types_1.NetworkType['palm-mainnet']]: {
+        chainId: types_1.ChainId['palm-mainnet'],
+        ticker: types_1.NetworksTicker['palm-mainnet'],
+        rpcPrefs: {
+            blockExplorerUrl: types_1.BlockExplorerUrl['palm-mainnet'],
+        },
+    },
+    // zkSync Era
+    [types_1.NetworkType['zksync-era-mainnet']]: {
+        chainId: types_1.ChainId['zksync-era-mainnet'],
+        ticker: types_1.NetworksTicker['zksync-era-mainnet'],
+        rpcPrefs: {
+            blockExplorerUrl: types_1.BlockExplorerUrl['zksync-era-mainnet'],
+        },
+    },
+    // Monad
+    [types_1.NetworkType['monad-mainnet']]: {
+        chainId: types_1.ChainId['monad-mainnet'],
+        ticker: types_1.NetworksTicker['monad-mainnet'],
+        rpcPrefs: {
+            blockExplorerUrl: types_1.BlockExplorerUrl['monad-mainnet'],
+        },
+    },
+    // MegaEth
+    [types_1.NetworkType['megaeth-mainnet']]: {
+        chainId: types_1.ChainId['megaeth-mainnet'],
+        ticker: types_1.NetworksTicker['megaeth-mainnet'],
+        rpcPrefs: {
+            blockExplorerUrl: types_1.BlockExplorerUrl['megaeth-mainnet'],
+        },
+    },
+    // Environment 3: Power User test networks
+    [types_1.NetworkType['fantom-mainnet']]: {
+        chainId: types_1.ChainId['fantom-mainnet'],
+        ticker: types_1.NetworksTicker['fantom-mainnet'],
+        rpcPrefs: {
+            blockExplorerUrl: types_1.BlockExplorerUrl['fantom-mainnet'],
+        },
+    },
+    [types_1.NetworkType['gnosis-mainnet']]: {
+        chainId: types_1.ChainId['gnosis-mainnet'],
+        ticker: types_1.NetworksTicker['gnosis-mainnet'],
+        rpcPrefs: {
+            blockExplorerUrl: types_1.BlockExplorerUrl['gnosis-mainnet'],
+        },
+    },
+    [types_1.NetworkType['cronos-mainnet']]: {
+        chainId: types_1.ChainId['cronos-mainnet'],
+        ticker: types_1.NetworksTicker['cronos-mainnet'],
+        rpcPrefs: {
+            blockExplorerUrl: types_1.BlockExplorerUrl['cronos-mainnet'],
+        },
+    },
+    [types_1.NetworkType['moonbeam-mainnet']]: {
+        chainId: types_1.ChainId['moonbeam-mainnet'],
+        ticker: types_1.NetworksTicker['moonbeam-mainnet'],
+        rpcPrefs: {
+            blockExplorerUrl: types_1.BlockExplorerUrl['moonbeam-mainnet'],
+        },
+    },
+    [types_1.NetworkType['moonriver-mainnet']]: {
+        chainId: types_1.ChainId['moonriver-mainnet'],
+        ticker: types_1.NetworksTicker['moonriver-mainnet'],
+        rpcPrefs: {
+            blockExplorerUrl: types_1.BlockExplorerUrl['moonriver-mainnet'],
+        },
+    },
     [types_1.NetworkType.rpc]: {
         chainId: undefined,
         blockExplorerUrl: undefined,
@@ -185,7 +279,7 @@ exports.NETWORKS_BYPASSING_VALIDATION = {
     '0x3e7': {
         name: 'HyperEVM',
         symbol: 'HYPE',
-        rpcUrl: 'https://rpc.hyperliquid.xyz',
+        rpcUrl: 'https://rpc.hyperliquid.xyz/evm',
     },
 };
 // APIs
diff --git a/dist/constants.cjs.map b/dist/constants.cjs.map
index 21d3be0d690c729140eff8d1a88273c3491064b5..f6d3caad5c517d98e9b46bd88623f72075570a41 100644
--- a/dist/constants.cjs.map
+++ b/dist/constants.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"constants.cjs","sourceRoot":"","sources":["../src/constants.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  NetworkType,\n  NetworksTicker,\n  ChainId,\n  BuiltInNetworkName,\n  BlockExplorerUrl,\n} from './types';\n\nexport const RPC = 'rpc';\nexport const FALL_BACK_VS_CURRENCY = 'ETH';\nexport const IPFS_DEFAULT_GATEWAY_URL = 'https://cloudflare-ipfs.com/ipfs/';\n\n// NETWORKS ID\n// `toHex` not invoked to avoid cyclic dependency\nexport const GANACHE_CHAIN_ID = '0x539'; // toHex(1337)\n/**\n * The largest possible chain ID we can handle.\n * Explanation: https://gist.github.com/rekmarks/a47bd5f2525936c4b8eee31a16345553\n */\nexport const MAX_SAFE_CHAIN_ID = 4503599627370476;\n\n// TOKEN STANDARDS\nexport const ERC721 = 'ERC721';\nexport const ERC1155 = 'ERC1155';\nexport const ERC20 = 'ERC20';\n\n// TOKEN INTERFACE IDS\nexport const ERC721_INTERFACE_ID = '0x80ac58cd';\nexport const ERC721_METADATA_INTERFACE_ID = '0x5b5e139f';\nexport const ERC721_ENUMERABLE_INTERFACE_ID = '0x780e9d63';\nexport const ERC1155_INTERFACE_ID = '0xd9b67a26';\nexport const ERC1155_METADATA_URI_INTERFACE_ID = '0x0e89341c';\nexport const ERC1155_TOKEN_RECEIVER_INTERFACE_ID = '0x4e2312e0';\n\n// UNITS\nexport const GWEI = 'gwei';\n\n// ASSET TYPES\nexport const ASSET_TYPES = {\n  NATIVE: 'NATIVE',\n  TOKEN: 'TOKEN',\n  NFT: 'NFT',\n  UNKNOWN: 'UNKNOWN',\n};\n\n// TICKER SYMBOLS\nexport const TESTNET_TICKER_SYMBOLS = {\n  GOERLI: 'GoerliETH',\n  SEPOLIA: 'SepoliaETH',\n  LINEA_GOERLI: 'LineaETH',\n  LINEA_SEPOLIA: 'LineaETH',\n  MEGAETH_TESTNET: 'MegaETH',\n  MEGAETH_TESTNET_V2: 'MegaETH',\n};\n\n/**\n * Map of all built-in custom networks to their RPC endpoints.\n */\nexport const BUILT_IN_CUSTOM_NETWORKS_RPC = {\n  /**\n   * @deprecated Please use `megaeth-testnet` instead.\n   */\n  MEGAETH_TESTNET: 'https://carrot.megaeth.com/rpc',\n  /**\n   * @deprecated Please use `megaeth-testnet-v2` instead.\n   */\n  'megaeth-testnet': 'https://carrot.megaeth.com/rpc',\n  'megaeth-testnet-v2': 'https://carrot.megaeth.com/rpc',\n  'monad-testnet': 'https://testnet-rpc.monad.xyz',\n};\n\n/**\n * Map of all build-in Infura networks to their network, ticker and chain IDs.\n */\nexport const BUILT_IN_NETWORKS = {\n  [NetworkType.goerli]: {\n    chainId: ChainId.goerli,\n    ticker: NetworksTicker.goerli,\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl.goerli,\n    },\n  },\n  [NetworkType.sepolia]: {\n    chainId: ChainId.sepolia,\n    ticker: NetworksTicker.sepolia,\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl.sepolia,\n    },\n  },\n  [NetworkType.mainnet]: {\n    chainId: ChainId.mainnet,\n    ticker: NetworksTicker.mainnet,\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl.mainnet,\n    },\n  },\n  [NetworkType['linea-goerli']]: {\n    chainId: ChainId['linea-goerli'],\n    ticker: NetworksTicker['linea-goerli'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['linea-goerli'],\n    },\n  },\n  [NetworkType['linea-sepolia']]: {\n    chainId: ChainId['linea-sepolia'],\n    ticker: NetworksTicker['linea-sepolia'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['linea-sepolia'],\n    },\n  },\n  [NetworkType['linea-mainnet']]: {\n    chainId: ChainId['linea-mainnet'],\n    ticker: NetworksTicker['linea-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['linea-mainnet'],\n    },\n  },\n  [NetworkType['megaeth-testnet']]: {\n    chainId: ChainId['megaeth-testnet'],\n    ticker: NetworksTicker['megaeth-testnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['megaeth-testnet'],\n    },\n  },\n  [NetworkType['megaeth-testnet-v2']]: {\n    chainId: ChainId['megaeth-testnet-v2'],\n    ticker: NetworksTicker['megaeth-testnet-v2'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['megaeth-testnet-v2'],\n    },\n  },\n  [NetworkType['monad-testnet']]: {\n    chainId: ChainId['monad-testnet'],\n    ticker: NetworksTicker['monad-testnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['monad-testnet'],\n    },\n  },\n  [NetworkType['base-mainnet']]: {\n    chainId: ChainId['base-mainnet'],\n    ticker: NetworksTicker['base-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['base-mainnet'],\n    },\n  },\n  [NetworkType['arbitrum-mainnet']]: {\n    chainId: ChainId['arbitrum-mainnet'],\n    ticker: NetworksTicker['arbitrum-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['arbitrum-mainnet'],\n    },\n  },\n  [NetworkType['bsc-mainnet']]: {\n    chainId: ChainId['bsc-mainnet'],\n    ticker: NetworksTicker['bsc-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['bsc-mainnet'],\n    },\n  },\n  [NetworkType['optimism-mainnet']]: {\n    chainId: ChainId['optimism-mainnet'],\n    ticker: NetworksTicker['optimism-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['optimism-mainnet'],\n    },\n  },\n  [NetworkType['polygon-mainnet']]: {\n    chainId: ChainId['polygon-mainnet'],\n    ticker: NetworksTicker['polygon-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['polygon-mainnet'],\n    },\n  },\n  [NetworkType['sei-mainnet']]: {\n    chainId: ChainId['sei-mainnet'],\n    ticker: NetworksTicker['sei-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['sei-mainnet'],\n    },\n  },\n  [NetworkType.rpc]: {\n    chainId: undefined,\n    blockExplorerUrl: undefined,\n    ticker: undefined,\n    rpcPrefs: undefined,\n  },\n} as const;\n\n/**\n * When a user adds a custom network to MetaMask, we perform some basic\n * validations on the network. For instance, usually a network cannot share the\n * same chain as another. In some cases, however, we want to allow networks that\n * would normally be invalid. This mapping contains networks that should bypass\n * validation.\n */\nexport const NETWORKS_BYPASSING_VALIDATION = {\n  // HyperEVM uses the same chain ID as Wanchain\n  '0x3e7': {\n    name: 'HyperEVM',\n    symbol: 'HYPE',\n    rpcUrl: 'https://rpc.hyperliquid.xyz',\n  },\n};\n\n// APIs\nexport const OPENSEA_PROXY_URL =\n  'https://proxy.api.cx.metamask.io/opensea/v1/api/v2';\n\nexport const NFT_API_BASE_URL = 'https://nft.api.cx.metamask.io';\n\nexport const NFT_API_VERSION = '1';\n\nexport const NFT_API_TIMEOUT = 15000;\n\n// Default origin for controllers\nexport const ORIGIN_METAMASK = 'metamask';\n\n/**\n * Approval request types for various operations.\n * These types are used by different controllers to create and manage\n * approval requests consistently.\n */\nexport enum ApprovalType {\n  AddEthereumChain = 'wallet_addEthereumChain',\n  ConnectAccounts = 'connect_accounts',\n  EthDecrypt = 'eth_decrypt',\n  EthGetEncryptionPublicKey = 'eth_getEncryptionPublicKey',\n  EthSignTypedData = 'eth_signTypedData',\n  PersonalSign = 'personal_sign',\n  ResultError = 'result_error',\n  ResultSuccess = 'result_success',\n  SnapDialogAlert = 'snap_dialog:alert',\n  SnapDialogConfirmation = 'snap_dialog:confirmation',\n  SnapDialogPrompt = 'snap_dialog:prompt',\n  SnapDialogDefault = 'snap_dialog',\n  SwitchEthereumChain = 'wallet_switchEthereumChain',\n  Transaction = 'transaction',\n  TransactionBatch = 'transaction_batch',\n  Unlock = 'unlock',\n  WalletConnect = 'wallet_connect',\n  WalletRequestPermissions = 'wallet_requestPermissions',\n  WatchAsset = 'wallet_watchAsset',\n}\n\n/**\n * Mapping of chain IDs to their network names for ENS functionality.\n * Note: MegaETH-testnet is intentionally excluded from this mapping as it doesn't support ENS.\n */\nexport const CHAIN_ID_TO_ETHERS_NETWORK_NAME_MAP: Record<\n  string,\n  BuiltInNetworkName\n> = {\n  [ChainId.goerli]: BuiltInNetworkName.Goerli,\n  [ChainId.sepolia]: BuiltInNetworkName.Sepolia,\n  [ChainId.mainnet]: BuiltInNetworkName.Mainnet,\n  [ChainId['linea-goerli']]: BuiltInNetworkName.LineaGoerli,\n  [ChainId['linea-sepolia']]: BuiltInNetworkName.LineaSepolia,\n  [ChainId['linea-mainnet']]: BuiltInNetworkName.LineaMainnet,\n  [ChainId.aurora]: BuiltInNetworkName.Aurora,\n};\n\n/**\n * The number of milliseconds in a second.\n */\nexport const SECOND = 1000;\n\n/**\n * The number of milliseconds in a second.\n */\nexport const SECONDS = SECOND;\n\n/**\n * The number of milliseconds in a minute.\n */\nexport const MINUTE = SECONDS * 60;\n\n/**\n * The number of milliseconds in a minute.\n */\nexport const MINUTES = MINUTE;\n\n/**\n * The number of milliseconds in a hour.\n */\nexport const HOUR = MINUTES * 60;\n\n/**\n * The number of milliseconds in a hour.\n */\nexport const HOURS = HOUR;\n\n/**\n * The number of milliseconds in a day.\n */\nexport const DAY = HOURS * 24;\n\n/**\n * The number of milliseconds in a day.\n */\nexport const DAYS = DAY;\n"]}
\ No newline at end of file
+{"version":3,"file":"constants.cjs","sourceRoot":"","sources":["../src/constants.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  NetworkType,\n  NetworksTicker,\n  ChainId,\n  BuiltInNetworkName,\n  BlockExplorerUrl,\n} from './types';\n\nexport const RPC = 'rpc';\nexport const FALL_BACK_VS_CURRENCY = 'ETH';\nexport const IPFS_DEFAULT_GATEWAY_URL = 'https://cloudflare-ipfs.com/ipfs/';\n\n// NETWORKS ID\n// `toHex` not invoked to avoid cyclic dependency\nexport const GANACHE_CHAIN_ID = '0x539'; // toHex(1337)\n/**\n * The largest possible chain ID we can handle.\n * Explanation: https://gist.github.com/rekmarks/a47bd5f2525936c4b8eee31a16345553\n */\nexport const MAX_SAFE_CHAIN_ID = 4503599627370476;\n\n// TOKEN STANDARDS\nexport const ERC721 = 'ERC721';\nexport const ERC1155 = 'ERC1155';\nexport const ERC20 = 'ERC20';\n\n// TOKEN INTERFACE IDS\nexport const ERC721_INTERFACE_ID = '0x80ac58cd';\nexport const ERC721_METADATA_INTERFACE_ID = '0x5b5e139f';\nexport const ERC721_ENUMERABLE_INTERFACE_ID = '0x780e9d63';\nexport const ERC1155_INTERFACE_ID = '0xd9b67a26';\nexport const ERC1155_METADATA_URI_INTERFACE_ID = '0x0e89341c';\nexport const ERC1155_TOKEN_RECEIVER_INTERFACE_ID = '0x4e2312e0';\n\n// UNITS\nexport const GWEI = 'gwei';\n\n// ASSET TYPES\nexport const ASSET_TYPES = {\n  NATIVE: 'NATIVE',\n  TOKEN: 'TOKEN',\n  NFT: 'NFT',\n  UNKNOWN: 'UNKNOWN',\n};\n\n// TICKER SYMBOLS\nexport const TESTNET_TICKER_SYMBOLS = {\n  GOERLI: 'GoerliETH',\n  SEPOLIA: 'SepoliaETH',\n  LINEA_GOERLI: 'LineaETH',\n  LINEA_SEPOLIA: 'LineaETH',\n  MEGAETH_TESTNET: 'MegaETH',\n  MEGAETH_TESTNET_V2: 'MegaETH',\n};\n\n/**\n * Map of all built-in custom networks to their RPC endpoints.\n */\nexport const BUILT_IN_CUSTOM_NETWORKS_RPC = {\n  /**\n   * @deprecated Please use `megaeth-testnet` instead.\n   */\n  MEGAETH_TESTNET: 'https://carrot.megaeth.com/rpc',\n  /**\n   * @deprecated Please use `megaeth-testnet-v2` instead.\n   */\n  'megaeth-testnet': 'https://carrot.megaeth.com/rpc',\n  'megaeth-testnet-v2': 'https://carrot.megaeth.com/rpc',\n  'monad-testnet': 'https://testnet-rpc.monad.xyz',\n  // Mainnet networks with custom RPC URLs\n  'hyper-evm-mainnet': 'https://rpc.hyperliquid.xyz/evm',\n  'zksync-era-mainnet': 'https://mainnet.era.zksync.io',\n  'megaeth-mainnet': 'https://mainnet.megaeth.com/rpc',\n  // Environment 3: Power User test networks\n  'fantom-mainnet': 'https://rpcapi.fantom.network',\n  'gnosis-mainnet': 'https://gnosis-mainnet.public.blastapi.io',\n  'cronos-mainnet': 'https://evm.cronos.org',\n  'moonbeam-mainnet': 'https://rpc.api.moonbeam.network',\n  'moonriver-mainnet': 'https://rpc.api.moonriver.moonbeam.network',\n};\n\n/**\n * Map of all build-in Infura networks to their network, ticker and chain IDs.\n */\nexport const BUILT_IN_NETWORKS = {\n  [NetworkType.goerli]: {\n    chainId: ChainId.goerli,\n    ticker: NetworksTicker.goerli,\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl.goerli,\n    },\n  },\n  [NetworkType.sepolia]: {\n    chainId: ChainId.sepolia,\n    ticker: NetworksTicker.sepolia,\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl.sepolia,\n    },\n  },\n  [NetworkType.mainnet]: {\n    chainId: ChainId.mainnet,\n    ticker: NetworksTicker.mainnet,\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl.mainnet,\n    },\n  },\n  [NetworkType['linea-goerli']]: {\n    chainId: ChainId['linea-goerli'],\n    ticker: NetworksTicker['linea-goerli'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['linea-goerli'],\n    },\n  },\n  [NetworkType['linea-sepolia']]: {\n    chainId: ChainId['linea-sepolia'],\n    ticker: NetworksTicker['linea-sepolia'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['linea-sepolia'],\n    },\n  },\n  [NetworkType['linea-mainnet']]: {\n    chainId: ChainId['linea-mainnet'],\n    ticker: NetworksTicker['linea-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['linea-mainnet'],\n    },\n  },\n  [NetworkType['megaeth-testnet']]: {\n    chainId: ChainId['megaeth-testnet'],\n    ticker: NetworksTicker['megaeth-testnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['megaeth-testnet'],\n    },\n  },\n  [NetworkType['megaeth-testnet-v2']]: {\n    chainId: ChainId['megaeth-testnet-v2'],\n    ticker: NetworksTicker['megaeth-testnet-v2'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['megaeth-testnet-v2'],\n    },\n  },\n  [NetworkType['monad-testnet']]: {\n    chainId: ChainId['monad-testnet'],\n    ticker: NetworksTicker['monad-testnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['monad-testnet'],\n    },\n  },\n  [NetworkType['base-mainnet']]: {\n    chainId: ChainId['base-mainnet'],\n    ticker: NetworksTicker['base-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['base-mainnet'],\n    },\n  },\n  [NetworkType['arbitrum-mainnet']]: {\n    chainId: ChainId['arbitrum-mainnet'],\n    ticker: NetworksTicker['arbitrum-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['arbitrum-mainnet'],\n    },\n  },\n  [NetworkType['bsc-mainnet']]: {\n    chainId: ChainId['bsc-mainnet'],\n    ticker: NetworksTicker['bsc-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['bsc-mainnet'],\n    },\n  },\n  [NetworkType['optimism-mainnet']]: {\n    chainId: ChainId['optimism-mainnet'],\n    ticker: NetworksTicker['optimism-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['optimism-mainnet'],\n    },\n  },\n  [NetworkType['polygon-mainnet']]: {\n    chainId: ChainId['polygon-mainnet'],\n    ticker: NetworksTicker['polygon-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['polygon-mainnet'],\n    },\n  },\n  [NetworkType['sei-mainnet']]: {\n    chainId: ChainId['sei-mainnet'],\n    ticker: NetworksTicker['sei-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['sei-mainnet'],\n    },\n  },\n  // Avalanche\n  [NetworkType['avalanche-mainnet']]: {\n    chainId: ChainId['avalanche-mainnet'],\n    ticker: NetworksTicker['avalanche-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['avalanche-mainnet'],\n    },\n  },\n  // HyperEVM\n  [NetworkType['hyper-evm-mainnet']]: {\n    chainId: ChainId['hyper-evm-mainnet'],\n    ticker: NetworksTicker['hyper-evm-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['hyper-evm-mainnet'],\n    },\n  },\n  // Palm\n  [NetworkType['palm-mainnet']]: {\n    chainId: ChainId['palm-mainnet'],\n    ticker: NetworksTicker['palm-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['palm-mainnet'],\n    },\n  },\n  // zkSync Era\n  [NetworkType['zksync-era-mainnet']]: {\n    chainId: ChainId['zksync-era-mainnet'],\n    ticker: NetworksTicker['zksync-era-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['zksync-era-mainnet'],\n    },\n  },\n  // Monad\n  [NetworkType['monad-mainnet']]: {\n    chainId: ChainId['monad-mainnet'],\n    ticker: NetworksTicker['monad-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['monad-mainnet'],\n    },\n  },\n  // MegaEth\n  [NetworkType['megaeth-mainnet']]: {\n    chainId: ChainId['megaeth-mainnet'],\n    ticker: NetworksTicker['megaeth-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['megaeth-mainnet'],\n    },\n  },\n  // Environment 3: Power User test networks\n  [NetworkType['fantom-mainnet']]: {\n    chainId: ChainId['fantom-mainnet'],\n    ticker: NetworksTicker['fantom-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['fantom-mainnet'],\n    },\n  },\n  [NetworkType['gnosis-mainnet']]: {\n    chainId: ChainId['gnosis-mainnet'],\n    ticker: NetworksTicker['gnosis-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['gnosis-mainnet'],\n    },\n  },\n  [NetworkType['cronos-mainnet']]: {\n    chainId: ChainId['cronos-mainnet'],\n    ticker: NetworksTicker['cronos-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['cronos-mainnet'],\n    },\n  },\n  [NetworkType['moonbeam-mainnet']]: {\n    chainId: ChainId['moonbeam-mainnet'],\n    ticker: NetworksTicker['moonbeam-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['moonbeam-mainnet'],\n    },\n  },\n  [NetworkType['moonriver-mainnet']]: {\n    chainId: ChainId['moonriver-mainnet'],\n    ticker: NetworksTicker['moonriver-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['moonriver-mainnet'],\n    },\n  },\n  [NetworkType.rpc]: {\n    chainId: undefined,\n    blockExplorerUrl: undefined,\n    ticker: undefined,\n    rpcPrefs: undefined,\n  },\n} as const;\n\n/**\n * When a user adds a custom network to MetaMask, we perform some basic\n * validations on the network. For instance, usually a network cannot share the\n * same chain as another. In some cases, however, we want to allow networks that\n * would normally be invalid. This mapping contains networks that should bypass\n * validation.\n */\nexport const NETWORKS_BYPASSING_VALIDATION = {\n  // HyperEVM uses the same chain ID as Wanchain\n  '0x3e7': {\n    name: 'HyperEVM',\n    symbol: 'HYPE',\n    rpcUrl: 'https://rpc.hyperliquid.xyz/evm',\n  },\n};\n\n// APIs\nexport const OPENSEA_PROXY_URL =\n  'https://proxy.api.cx.metamask.io/opensea/v1/api/v2';\n\nexport const NFT_API_BASE_URL = 'https://nft.api.cx.metamask.io';\n\nexport const NFT_API_VERSION = '1';\n\nexport const NFT_API_TIMEOUT = 15000;\n\n// Default origin for controllers\nexport const ORIGIN_METAMASK = 'metamask';\n\n/**\n * Approval request types for various operations.\n * These types are used by different controllers to create and manage\n * approval requests consistently.\n */\nexport enum ApprovalType {\n  AddEthereumChain = 'wallet_addEthereumChain',\n  ConnectAccounts = 'connect_accounts',\n  EthDecrypt = 'eth_decrypt',\n  EthGetEncryptionPublicKey = 'eth_getEncryptionPublicKey',\n  EthSignTypedData = 'eth_signTypedData',\n  PersonalSign = 'personal_sign',\n  ResultError = 'result_error',\n  ResultSuccess = 'result_success',\n  SnapDialogAlert = 'snap_dialog:alert',\n  SnapDialogConfirmation = 'snap_dialog:confirmation',\n  SnapDialogPrompt = 'snap_dialog:prompt',\n  SnapDialogDefault = 'snap_dialog',\n  SwitchEthereumChain = 'wallet_switchEthereumChain',\n  Transaction = 'transaction',\n  TransactionBatch = 'transaction_batch',\n  Unlock = 'unlock',\n  WalletConnect = 'wallet_connect',\n  WalletRequestPermissions = 'wallet_requestPermissions',\n  WatchAsset = 'wallet_watchAsset',\n}\n\n/**\n * Mapping of chain IDs to their network names for ENS functionality.\n * Note: MegaETH-testnet is intentionally excluded from this mapping as it doesn't support ENS.\n */\nexport const CHAIN_ID_TO_ETHERS_NETWORK_NAME_MAP: Record<\n  string,\n  BuiltInNetworkName\n> = {\n  [ChainId.goerli]: BuiltInNetworkName.Goerli,\n  [ChainId.sepolia]: BuiltInNetworkName.Sepolia,\n  [ChainId.mainnet]: BuiltInNetworkName.Mainnet,\n  [ChainId['linea-goerli']]: BuiltInNetworkName.LineaGoerli,\n  [ChainId['linea-sepolia']]: BuiltInNetworkName.LineaSepolia,\n  [ChainId['linea-mainnet']]: BuiltInNetworkName.LineaMainnet,\n  [ChainId.aurora]: BuiltInNetworkName.Aurora,\n};\n\n/**\n * The number of milliseconds in a second.\n */\nexport const SECOND = 1000;\n\n/**\n * The number of milliseconds in a second.\n */\nexport const SECONDS = SECOND;\n\n/**\n * The number of milliseconds in a minute.\n */\nexport const MINUTE = SECONDS * 60;\n\n/**\n * The number of milliseconds in a minute.\n */\nexport const MINUTES = MINUTE;\n\n/**\n * The number of milliseconds in a hour.\n */\nexport const HOUR = MINUTES * 60;\n\n/**\n * The number of milliseconds in a hour.\n */\nexport const HOURS = HOUR;\n\n/**\n * The number of milliseconds in a day.\n */\nexport const DAY = HOURS * 24;\n\n/**\n * The number of milliseconds in a day.\n */\nexport const DAYS = DAY;\n"]}
\ No newline at end of file
diff --git a/dist/constants.d.cts b/dist/constants.d.cts
index ae450bd8b828d34dbd236191192c723aec82bb83..f8ad9a23070be4503022ac2f09de5ba10ec5d856 100644
--- a/dist/constants.d.cts
+++ b/dist/constants.d.cts
@@ -46,6 +46,14 @@ export declare const BUILT_IN_CUSTOM_NETWORKS_RPC: {
     'megaeth-testnet': string;
     'megaeth-testnet-v2': string;
     'monad-testnet': string;
+    'hyper-evm-mainnet': string;
+    'zksync-era-mainnet': string;
+    'megaeth-mainnet': string;
+    'fantom-mainnet': string;
+    'gnosis-mainnet': string;
+    'cronos-mainnet': string;
+    'moonbeam-mainnet': string;
+    'moonriver-mainnet': string;
 };
 /**
  * Map of all build-in Infura networks to their network, ticker and chain IDs.
@@ -153,7 +161,84 @@ export declare const BUILT_IN_NETWORKS: {
         readonly chainId: "0x531";
         readonly ticker: (typeof NetworksTicker)["sei-mainnet"];
         readonly rpcPrefs: {
-            readonly blockExplorerUrl: "https://seitrace.com";
+            readonly blockExplorerUrl: "https://seitrace.com/";
+        };
+    };
+    readonly "avalanche-mainnet": {
+        readonly chainId: "0xa86a";
+        readonly ticker: (typeof NetworksTicker)["avalanche-mainnet"];
+        readonly rpcPrefs: {
+            readonly blockExplorerUrl: "https://snowtrace.io";
+        };
+    };
+    readonly "hyper-evm-mainnet": {
+        readonly chainId: "0x3e7";
+        readonly ticker: (typeof NetworksTicker)["hyper-evm-mainnet"];
+        readonly rpcPrefs: {
+            readonly blockExplorerUrl: "https://hyperevmscan.io/";
+        };
+    };
+    readonly "palm-mainnet": {
+        readonly chainId: "0x2a15c308d";
+        readonly ticker: (typeof NetworksTicker)["palm-mainnet"];
+        readonly rpcPrefs: {
+            readonly blockExplorerUrl: "https://palm.chainlens.com";
+        };
+    };
+    readonly "zksync-era-mainnet": {
+        readonly chainId: "0x144";
+        readonly ticker: (typeof NetworksTicker)["zksync-era-mainnet"];
+        readonly rpcPrefs: {
+            readonly blockExplorerUrl: "https://explorer.zksync.io/";
+        };
+    };
+    readonly "monad-mainnet": {
+        readonly chainId: "0x8f";
+        readonly ticker: (typeof NetworksTicker)["monad-mainnet"];
+        readonly rpcPrefs: {
+            readonly blockExplorerUrl: "https://monadscan.com/";
+        };
+    };
+    readonly "megaeth-mainnet": {
+        readonly chainId: "0x10e6";
+        readonly ticker: (typeof NetworksTicker)["megaeth-mainnet"];
+        readonly rpcPrefs: {
+            readonly blockExplorerUrl: "https://explorer.megaeth.com";
+        };
+    };
+    readonly "fantom-mainnet": {
+        readonly chainId: "0xfa";
+        readonly ticker: (typeof NetworksTicker)["fantom-mainnet"];
+        readonly rpcPrefs: {
+            readonly blockExplorerUrl: "https://ftmscan.com";
+        };
+    };
+    readonly "gnosis-mainnet": {
+        readonly chainId: "0x64";
+        readonly ticker: (typeof NetworksTicker)["gnosis-mainnet"];
+        readonly rpcPrefs: {
+            readonly blockExplorerUrl: "https://gnosisscan.io";
+        };
+    };
+    readonly "cronos-mainnet": {
+        readonly chainId: "0x19";
+        readonly ticker: (typeof NetworksTicker)["cronos-mainnet"];
+        readonly rpcPrefs: {
+            readonly blockExplorerUrl: "https://explorer.cronos.org";
+        };
+    };
+    readonly "moonbeam-mainnet": {
+        readonly chainId: "0x504";
+        readonly ticker: (typeof NetworksTicker)["moonbeam-mainnet"];
+        readonly rpcPrefs: {
+            readonly blockExplorerUrl: "https://moonscan.io";
+        };
+    };
+    readonly "moonriver-mainnet": {
+        readonly chainId: "0x505";
+        readonly ticker: (typeof NetworksTicker)["moonriver-mainnet"];
+        readonly rpcPrefs: {
+            readonly blockExplorerUrl: "https://moonriver.moonscan.io";
         };
     };
     readonly rpc: {
diff --git a/dist/constants.d.cts.map b/dist/constants.d.cts.map
index 0c6110b537352274a13a29f14ff20e949e82a754..4959d900b94818462dff42c23d257f362f7ed680 100644
--- a/dist/constants.d.cts.map
+++ b/dist/constants.d.cts.map
@@ -1 +1 @@
-{"version":3,"file":"constants.d.cts","sourceRoot":"","sources":["../src/constants.ts"],"names":[],"mappings":"AAAA,OAAO,EAEL,cAAc,EAEd,kBAAkB,EAEnB,oBAAgB;AAEjB,eAAO,MAAM,GAAG,QAAQ,CAAC;AACzB,eAAO,MAAM,qBAAqB,QAAQ,CAAC;AAC3C,eAAO,MAAM,wBAAwB,sCAAsC,CAAC;AAI5E,eAAO,MAAM,gBAAgB,UAAU,CAAC;AACxC;;;GAGG;AACH,eAAO,MAAM,iBAAiB,mBAAmB,CAAC;AAGlD,eAAO,MAAM,MAAM,WAAW,CAAC;AAC/B,eAAO,MAAM,OAAO,YAAY,CAAC;AACjC,eAAO,MAAM,KAAK,UAAU,CAAC;AAG7B,eAAO,MAAM,mBAAmB,eAAe,CAAC;AAChD,eAAO,MAAM,4BAA4B,eAAe,CAAC;AACzD,eAAO,MAAM,8BAA8B,eAAe,CAAC;AAC3D,eAAO,MAAM,oBAAoB,eAAe,CAAC;AACjD,eAAO,MAAM,iCAAiC,eAAe,CAAC;AAC9D,eAAO,MAAM,mCAAmC,eAAe,CAAC;AAGhE,eAAO,MAAM,IAAI,SAAS,CAAC;AAG3B,eAAO,MAAM,WAAW;;;;;CAKvB,CAAC;AAGF,eAAO,MAAM,sBAAsB;;;;;;;CAOlC,CAAC;AAEF;;GAEG;AACH,eAAO,MAAM,4BAA4B;IACvC;;OAEG;;IAEH;;OAEG;;;;CAIJ,CAAC;AAEF;;GAEG;AACH,eAAO,MAAM,iBAAiB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAgHpB,CAAC;AAEX;;;;;;GAMG;AACH,eAAO,MAAM,6BAA6B;;;;;;CAOzC,CAAC;AAGF,eAAO,MAAM,iBAAiB,uDACwB,CAAC;AAEvD,eAAO,MAAM,gBAAgB,mCAAmC,CAAC;AAEjE,eAAO,MAAM,eAAe,MAAM,CAAC;AAEnC,eAAO,MAAM,eAAe,QAAQ,CAAC;AAGrC,eAAO,MAAM,eAAe,aAAa,CAAC;AAE1C;;;;GAIG;AACH,oBAAY,YAAY;IACtB,gBAAgB,4BAA4B;IAC5C,eAAe,qBAAqB;IACpC,UAAU,gBAAgB;IAC1B,yBAAyB,+BAA+B;IACxD,gBAAgB,sBAAsB;IACtC,YAAY,kBAAkB;IAC9B,WAAW,iBAAiB;IAC5B,aAAa,mBAAmB;IAChC,eAAe,sBAAsB;IACrC,sBAAsB,6BAA6B;IACnD,gBAAgB,uBAAuB;IACvC,iBAAiB,gBAAgB;IACjC,mBAAmB,+BAA+B;IAClD,WAAW,gBAAgB;IAC3B,gBAAgB,sBAAsB;IACtC,MAAM,WAAW;IACjB,aAAa,mBAAmB;IAChC,wBAAwB,8BAA8B;IACtD,UAAU,sBAAsB;CACjC;AAED;;;GAGG;AACH,eAAO,MAAM,mCAAmC,EAAE,MAAM,CACtD,MAAM,EACN,kBAAkB,CASnB,CAAC;AAEF;;GAEG;AACH,eAAO,MAAM,MAAM,OAAO,CAAC;AAE3B;;GAEG;AACH,eAAO,MAAM,OAAO,OAAS,CAAC;AAE9B;;GAEG;AACH,eAAO,MAAM,MAAM,QAAe,CAAC;AAEnC;;GAEG;AACH,eAAO,MAAM,OAAO,QAAS,CAAC;AAE9B;;GAEG;AACH,eAAO,MAAM,IAAI,QAAe,CAAC;AAEjC;;GAEG;AACH,eAAO,MAAM,KAAK,QAAO,CAAC;AAE1B;;GAEG;AACH,eAAO,MAAM,GAAG,QAAa,CAAC;AAE9B;;GAEG;AACH,eAAO,MAAM,IAAI,QAAM,CAAC"}
\ No newline at end of file
+{"version":3,"file":"constants.d.cts","sourceRoot":"","sources":["../src/constants.ts"],"names":[],"mappings":"AAAA,OAAO,EAEL,cAAc,EAEd,kBAAkB,EAEnB,oBAAgB;AAEjB,eAAO,MAAM,GAAG,QAAQ,CAAC;AACzB,eAAO,MAAM,qBAAqB,QAAQ,CAAC;AAC3C,eAAO,MAAM,wBAAwB,sCAAsC,CAAC;AAI5E,eAAO,MAAM,gBAAgB,UAAU,CAAC;AACxC;;;GAGG;AACH,eAAO,MAAM,iBAAiB,mBAAmB,CAAC;AAGlD,eAAO,MAAM,MAAM,WAAW,CAAC;AAC/B,eAAO,MAAM,OAAO,YAAY,CAAC;AACjC,eAAO,MAAM,KAAK,UAAU,CAAC;AAG7B,eAAO,MAAM,mBAAmB,eAAe,CAAC;AAChD,eAAO,MAAM,4BAA4B,eAAe,CAAC;AACzD,eAAO,MAAM,8BAA8B,eAAe,CAAC;AAC3D,eAAO,MAAM,oBAAoB,eAAe,CAAC;AACjD,eAAO,MAAM,iCAAiC,eAAe,CAAC;AAC9D,eAAO,MAAM,mCAAmC,eAAe,CAAC;AAGhE,eAAO,MAAM,IAAI,SAAS,CAAC;AAG3B,eAAO,MAAM,WAAW;;;;;CAKvB,CAAC;AAGF,eAAO,MAAM,sBAAsB;;;;;;;CAOlC,CAAC;AAEF;;GAEG;AACH,eAAO,MAAM,4BAA4B;IACvC;;OAEG;;IAEH;;OAEG;;;;;;;;;;;;CAcJ,CAAC;AAEF;;GAEG;AACH,eAAO,MAAM,iBAAiB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAoMpB,CAAC;AAEX;;;;;;GAMG;AACH,eAAO,MAAM,6BAA6B;;;;;;CAOzC,CAAC;AAGF,eAAO,MAAM,iBAAiB,uDACwB,CAAC;AAEvD,eAAO,MAAM,gBAAgB,mCAAmC,CAAC;AAEjE,eAAO,MAAM,eAAe,MAAM,CAAC;AAEnC,eAAO,MAAM,eAAe,QAAQ,CAAC;AAGrC,eAAO,MAAM,eAAe,aAAa,CAAC;AAE1C;;;;GAIG;AACH,oBAAY,YAAY;IACtB,gBAAgB,4BAA4B;IAC5C,eAAe,qBAAqB;IACpC,UAAU,gBAAgB;IAC1B,yBAAyB,+BAA+B;IACxD,gBAAgB,sBAAsB;IACtC,YAAY,kBAAkB;IAC9B,WAAW,iBAAiB;IAC5B,aAAa,mBAAmB;IAChC,eAAe,sBAAsB;IACrC,sBAAsB,6BAA6B;IACnD,gBAAgB,uBAAuB;IACvC,iBAAiB,gBAAgB;IACjC,mBAAmB,+BAA+B;IAClD,WAAW,gBAAgB;IAC3B,gBAAgB,sBAAsB;IACtC,MAAM,WAAW;IACjB,aAAa,mBAAmB;IAChC,wBAAwB,8BAA8B;IACtD,UAAU,sBAAsB;CACjC;AAED;;;GAGG;AACH,eAAO,MAAM,mCAAmC,EAAE,MAAM,CACtD,MAAM,EACN,kBAAkB,CASnB,CAAC;AAEF;;GAEG;AACH,eAAO,MAAM,MAAM,OAAO,CAAC;AAE3B;;GAEG;AACH,eAAO,MAAM,OAAO,OAAS,CAAC;AAE9B;;GAEG;AACH,eAAO,MAAM,MAAM,QAAe,CAAC;AAEnC;;GAEG;AACH,eAAO,MAAM,OAAO,QAAS,CAAC;AAE9B;;GAEG;AACH,eAAO,MAAM,IAAI,QAAe,CAAC;AAEjC;;GAEG;AACH,eAAO,MAAM,KAAK,QAAO,CAAC;AAE1B;;GAEG;AACH,eAAO,MAAM,GAAG,QAAa,CAAC;AAE9B;;GAEG;AACH,eAAO,MAAM,IAAI,QAAM,CAAC"}
\ No newline at end of file
diff --git a/dist/constants.d.mts b/dist/constants.d.mts
index 8acf90657a7afd08bd71ca610ec597a589d7885e..7f3d86bc61fbc4b7960b3d4ba9d4432b945ed8d3 100644
--- a/dist/constants.d.mts
+++ b/dist/constants.d.mts
@@ -46,6 +46,14 @@ export declare const BUILT_IN_CUSTOM_NETWORKS_RPC: {
     'megaeth-testnet': string;
     'megaeth-testnet-v2': string;
     'monad-testnet': string;
+    'hyper-evm-mainnet': string;
+    'zksync-era-mainnet': string;
+    'megaeth-mainnet': string;
+    'fantom-mainnet': string;
+    'gnosis-mainnet': string;
+    'cronos-mainnet': string;
+    'moonbeam-mainnet': string;
+    'moonriver-mainnet': string;
 };
 /**
  * Map of all build-in Infura networks to their network, ticker and chain IDs.
@@ -153,7 +161,84 @@ export declare const BUILT_IN_NETWORKS: {
         readonly chainId: "0x531";
         readonly ticker: (typeof NetworksTicker)["sei-mainnet"];
         readonly rpcPrefs: {
-            readonly blockExplorerUrl: "https://seitrace.com";
+            readonly blockExplorerUrl: "https://seitrace.com/";
+        };
+    };
+    readonly "avalanche-mainnet": {
+        readonly chainId: "0xa86a";
+        readonly ticker: (typeof NetworksTicker)["avalanche-mainnet"];
+        readonly rpcPrefs: {
+            readonly blockExplorerUrl: "https://snowtrace.io";
+        };
+    };
+    readonly "hyper-evm-mainnet": {
+        readonly chainId: "0x3e7";
+        readonly ticker: (typeof NetworksTicker)["hyper-evm-mainnet"];
+        readonly rpcPrefs: {
+            readonly blockExplorerUrl: "https://hyperevmscan.io/";
+        };
+    };
+    readonly "palm-mainnet": {
+        readonly chainId: "0x2a15c308d";
+        readonly ticker: (typeof NetworksTicker)["palm-mainnet"];
+        readonly rpcPrefs: {
+            readonly blockExplorerUrl: "https://palm.chainlens.com";
+        };
+    };
+    readonly "zksync-era-mainnet": {
+        readonly chainId: "0x144";
+        readonly ticker: (typeof NetworksTicker)["zksync-era-mainnet"];
+        readonly rpcPrefs: {
+            readonly blockExplorerUrl: "https://explorer.zksync.io/";
+        };
+    };
+    readonly "monad-mainnet": {
+        readonly chainId: "0x8f";
+        readonly ticker: (typeof NetworksTicker)["monad-mainnet"];
+        readonly rpcPrefs: {
+            readonly blockExplorerUrl: "https://monadscan.com/";
+        };
+    };
+    readonly "megaeth-mainnet": {
+        readonly chainId: "0x10e6";
+        readonly ticker: (typeof NetworksTicker)["megaeth-mainnet"];
+        readonly rpcPrefs: {
+            readonly blockExplorerUrl: "https://explorer.megaeth.com";
+        };
+    };
+    readonly "fantom-mainnet": {
+        readonly chainId: "0xfa";
+        readonly ticker: (typeof NetworksTicker)["fantom-mainnet"];
+        readonly rpcPrefs: {
+            readonly blockExplorerUrl: "https://ftmscan.com";
+        };
+    };
+    readonly "gnosis-mainnet": {
+        readonly chainId: "0x64";
+        readonly ticker: (typeof NetworksTicker)["gnosis-mainnet"];
+        readonly rpcPrefs: {
+            readonly blockExplorerUrl: "https://gnosisscan.io";
+        };
+    };
+    readonly "cronos-mainnet": {
+        readonly chainId: "0x19";
+        readonly ticker: (typeof NetworksTicker)["cronos-mainnet"];
+        readonly rpcPrefs: {
+            readonly blockExplorerUrl: "https://explorer.cronos.org";
+        };
+    };
+    readonly "moonbeam-mainnet": {
+        readonly chainId: "0x504";
+        readonly ticker: (typeof NetworksTicker)["moonbeam-mainnet"];
+        readonly rpcPrefs: {
+            readonly blockExplorerUrl: "https://moonscan.io";
+        };
+    };
+    readonly "moonriver-mainnet": {
+        readonly chainId: "0x505";
+        readonly ticker: (typeof NetworksTicker)["moonriver-mainnet"];
+        readonly rpcPrefs: {
+            readonly blockExplorerUrl: "https://moonriver.moonscan.io";
         };
     };
     readonly rpc: {
diff --git a/dist/constants.d.mts.map b/dist/constants.d.mts.map
index 3284a4630681f59c3e0ec180f2e12d58c4fa687b..9f6cd65150b0f170dbcaa8b18fd457df0665dc60 100644
--- a/dist/constants.d.mts.map
+++ b/dist/constants.d.mts.map
@@ -1 +1 @@
-{"version":3,"file":"constants.d.mts","sourceRoot":"","sources":["../src/constants.ts"],"names":[],"mappings":"AAAA,OAAO,EAEL,cAAc,EAEd,kBAAkB,EAEnB,oBAAgB;AAEjB,eAAO,MAAM,GAAG,QAAQ,CAAC;AACzB,eAAO,MAAM,qBAAqB,QAAQ,CAAC;AAC3C,eAAO,MAAM,wBAAwB,sCAAsC,CAAC;AAI5E,eAAO,MAAM,gBAAgB,UAAU,CAAC;AACxC;;;GAGG;AACH,eAAO,MAAM,iBAAiB,mBAAmB,CAAC;AAGlD,eAAO,MAAM,MAAM,WAAW,CAAC;AAC/B,eAAO,MAAM,OAAO,YAAY,CAAC;AACjC,eAAO,MAAM,KAAK,UAAU,CAAC;AAG7B,eAAO,MAAM,mBAAmB,eAAe,CAAC;AAChD,eAAO,MAAM,4BAA4B,eAAe,CAAC;AACzD,eAAO,MAAM,8BAA8B,eAAe,CAAC;AAC3D,eAAO,MAAM,oBAAoB,eAAe,CAAC;AACjD,eAAO,MAAM,iCAAiC,eAAe,CAAC;AAC9D,eAAO,MAAM,mCAAmC,eAAe,CAAC;AAGhE,eAAO,MAAM,IAAI,SAAS,CAAC;AAG3B,eAAO,MAAM,WAAW;;;;;CAKvB,CAAC;AAGF,eAAO,MAAM,sBAAsB;;;;;;;CAOlC,CAAC;AAEF;;GAEG;AACH,eAAO,MAAM,4BAA4B;IACvC;;OAEG;;IAEH;;OAEG;;;;CAIJ,CAAC;AAEF;;GAEG;AACH,eAAO,MAAM,iBAAiB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAgHpB,CAAC;AAEX;;;;;;GAMG;AACH,eAAO,MAAM,6BAA6B;;;;;;CAOzC,CAAC;AAGF,eAAO,MAAM,iBAAiB,uDACwB,CAAC;AAEvD,eAAO,MAAM,gBAAgB,mCAAmC,CAAC;AAEjE,eAAO,MAAM,eAAe,MAAM,CAAC;AAEnC,eAAO,MAAM,eAAe,QAAQ,CAAC;AAGrC,eAAO,MAAM,eAAe,aAAa,CAAC;AAE1C;;;;GAIG;AACH,oBAAY,YAAY;IACtB,gBAAgB,4BAA4B;IAC5C,eAAe,qBAAqB;IACpC,UAAU,gBAAgB;IAC1B,yBAAyB,+BAA+B;IACxD,gBAAgB,sBAAsB;IACtC,YAAY,kBAAkB;IAC9B,WAAW,iBAAiB;IAC5B,aAAa,mBAAmB;IAChC,eAAe,sBAAsB;IACrC,sBAAsB,6BAA6B;IACnD,gBAAgB,uBAAuB;IACvC,iBAAiB,gBAAgB;IACjC,mBAAmB,+BAA+B;IAClD,WAAW,gBAAgB;IAC3B,gBAAgB,sBAAsB;IACtC,MAAM,WAAW;IACjB,aAAa,mBAAmB;IAChC,wBAAwB,8BAA8B;IACtD,UAAU,sBAAsB;CACjC;AAED;;;GAGG;AACH,eAAO,MAAM,mCAAmC,EAAE,MAAM,CACtD,MAAM,EACN,kBAAkB,CASnB,CAAC;AAEF;;GAEG;AACH,eAAO,MAAM,MAAM,OAAO,CAAC;AAE3B;;GAEG;AACH,eAAO,MAAM,OAAO,OAAS,CAAC;AAE9B;;GAEG;AACH,eAAO,MAAM,MAAM,QAAe,CAAC;AAEnC;;GAEG;AACH,eAAO,MAAM,OAAO,QAAS,CAAC;AAE9B;;GAEG;AACH,eAAO,MAAM,IAAI,QAAe,CAAC;AAEjC;;GAEG;AACH,eAAO,MAAM,KAAK,QAAO,CAAC;AAE1B;;GAEG;AACH,eAAO,MAAM,GAAG,QAAa,CAAC;AAE9B;;GAEG;AACH,eAAO,MAAM,IAAI,QAAM,CAAC"}
\ No newline at end of file
+{"version":3,"file":"constants.d.mts","sourceRoot":"","sources":["../src/constants.ts"],"names":[],"mappings":"AAAA,OAAO,EAEL,cAAc,EAEd,kBAAkB,EAEnB,oBAAgB;AAEjB,eAAO,MAAM,GAAG,QAAQ,CAAC;AACzB,eAAO,MAAM,qBAAqB,QAAQ,CAAC;AAC3C,eAAO,MAAM,wBAAwB,sCAAsC,CAAC;AAI5E,eAAO,MAAM,gBAAgB,UAAU,CAAC;AACxC;;;GAGG;AACH,eAAO,MAAM,iBAAiB,mBAAmB,CAAC;AAGlD,eAAO,MAAM,MAAM,WAAW,CAAC;AAC/B,eAAO,MAAM,OAAO,YAAY,CAAC;AACjC,eAAO,MAAM,KAAK,UAAU,CAAC;AAG7B,eAAO,MAAM,mBAAmB,eAAe,CAAC;AAChD,eAAO,MAAM,4BAA4B,eAAe,CAAC;AACzD,eAAO,MAAM,8BAA8B,eAAe,CAAC;AAC3D,eAAO,MAAM,oBAAoB,eAAe,CAAC;AACjD,eAAO,MAAM,iCAAiC,eAAe,CAAC;AAC9D,eAAO,MAAM,mCAAmC,eAAe,CAAC;AAGhE,eAAO,MAAM,IAAI,SAAS,CAAC;AAG3B,eAAO,MAAM,WAAW;;;;;CAKvB,CAAC;AAGF,eAAO,MAAM,sBAAsB;;;;;;;CAOlC,CAAC;AAEF;;GAEG;AACH,eAAO,MAAM,4BAA4B;IACvC;;OAEG;;IAEH;;OAEG;;;;;;;;;;;;CAcJ,CAAC;AAEF;;GAEG;AACH,eAAO,MAAM,iBAAiB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAoMpB,CAAC;AAEX;;;;;;GAMG;AACH,eAAO,MAAM,6BAA6B;;;;;;CAOzC,CAAC;AAGF,eAAO,MAAM,iBAAiB,uDACwB,CAAC;AAEvD,eAAO,MAAM,gBAAgB,mCAAmC,CAAC;AAEjE,eAAO,MAAM,eAAe,MAAM,CAAC;AAEnC,eAAO,MAAM,eAAe,QAAQ,CAAC;AAGrC,eAAO,MAAM,eAAe,aAAa,CAAC;AAE1C;;;;GAIG;AACH,oBAAY,YAAY;IACtB,gBAAgB,4BAA4B;IAC5C,eAAe,qBAAqB;IACpC,UAAU,gBAAgB;IAC1B,yBAAyB,+BAA+B;IACxD,gBAAgB,sBAAsB;IACtC,YAAY,kBAAkB;IAC9B,WAAW,iBAAiB;IAC5B,aAAa,mBAAmB;IAChC,eAAe,sBAAsB;IACrC,sBAAsB,6BAA6B;IACnD,gBAAgB,uBAAuB;IACvC,iBAAiB,gBAAgB;IACjC,mBAAmB,+BAA+B;IAClD,WAAW,gBAAgB;IAC3B,gBAAgB,sBAAsB;IACtC,MAAM,WAAW;IACjB,aAAa,mBAAmB;IAChC,wBAAwB,8BAA8B;IACtD,UAAU,sBAAsB;CACjC;AAED;;;GAGG;AACH,eAAO,MAAM,mCAAmC,EAAE,MAAM,CACtD,MAAM,EACN,kBAAkB,CASnB,CAAC;AAEF;;GAEG;AACH,eAAO,MAAM,MAAM,OAAO,CAAC;AAE3B;;GAEG;AACH,eAAO,MAAM,OAAO,OAAS,CAAC;AAE9B;;GAEG;AACH,eAAO,MAAM,MAAM,QAAe,CAAC;AAEnC;;GAEG;AACH,eAAO,MAAM,OAAO,QAAS,CAAC;AAE9B;;GAEG;AACH,eAAO,MAAM,IAAI,QAAe,CAAC;AAEjC;;GAEG;AACH,eAAO,MAAM,KAAK,QAAO,CAAC;AAE1B;;GAEG;AACH,eAAO,MAAM,GAAG,QAAa,CAAC;AAE9B;;GAEG;AACH,eAAO,MAAM,IAAI,QAAM,CAAC"}
\ No newline at end of file
diff --git a/dist/constants.mjs b/dist/constants.mjs
index a7cfa454dd19af1a58ed103f4aa5a19c61a9b5db..747cd45b1f09d01504e2e163994ee0b64f55f5d7 100644
--- a/dist/constants.mjs
+++ b/dist/constants.mjs
@@ -53,6 +53,16 @@ export const BUILT_IN_CUSTOM_NETWORKS_RPC = {
     'megaeth-testnet': 'https://carrot.megaeth.com/rpc',
     'megaeth-testnet-v2': 'https://carrot.megaeth.com/rpc',
     'monad-testnet': 'https://testnet-rpc.monad.xyz',
+    // Mainnet networks with custom RPC URLs
+    'hyper-evm-mainnet': 'https://rpc.hyperliquid.xyz/evm',
+    'zksync-era-mainnet': 'https://mainnet.era.zksync.io',
+    'megaeth-mainnet': 'https://mainnet.megaeth.com/rpc',
+    // Environment 3: Power User test networks
+    'fantom-mainnet': 'https://rpcapi.fantom.network',
+    'gnosis-mainnet': 'https://gnosis-mainnet.public.blastapi.io',
+    'cronos-mainnet': 'https://evm.cronos.org',
+    'moonbeam-mainnet': 'https://rpc.api.moonbeam.network',
+    'moonriver-mainnet': 'https://rpc.api.moonriver.moonbeam.network',
 };
 /**
  * Map of all build-in Infura networks to their network, ticker and chain IDs.
@@ -163,6 +173,90 @@ export const BUILT_IN_NETWORKS = {
             blockExplorerUrl: BlockExplorerUrl['sei-mainnet'],
         },
     },
+    // Avalanche
+    [NetworkType['avalanche-mainnet']]: {
+        chainId: ChainId['avalanche-mainnet'],
+        ticker: NetworksTicker['avalanche-mainnet'],
+        rpcPrefs: {
+            blockExplorerUrl: BlockExplorerUrl['avalanche-mainnet'],
+        },
+    },
+    // HyperEVM
+    [NetworkType['hyper-evm-mainnet']]: {
+        chainId: ChainId['hyper-evm-mainnet'],
+        ticker: NetworksTicker['hyper-evm-mainnet'],
+        rpcPrefs: {
+            blockExplorerUrl: BlockExplorerUrl['hyper-evm-mainnet'],
+        },
+    },
+    // Palm
+    [NetworkType['palm-mainnet']]: {
+        chainId: ChainId['palm-mainnet'],
+        ticker: NetworksTicker['palm-mainnet'],
+        rpcPrefs: {
+            blockExplorerUrl: BlockExplorerUrl['palm-mainnet'],
+        },
+    },
+    // zkSync Era
+    [NetworkType['zksync-era-mainnet']]: {
+        chainId: ChainId['zksync-era-mainnet'],
+        ticker: NetworksTicker['zksync-era-mainnet'],
+        rpcPrefs: {
+            blockExplorerUrl: BlockExplorerUrl['zksync-era-mainnet'],
+        },
+    },
+    // Monad
+    [NetworkType['monad-mainnet']]: {
+        chainId: ChainId['monad-mainnet'],
+        ticker: NetworksTicker['monad-mainnet'],
+        rpcPrefs: {
+            blockExplorerUrl: BlockExplorerUrl['monad-mainnet'],
+        },
+    },
+    // MegaEth
+    [NetworkType['megaeth-mainnet']]: {
+        chainId: ChainId['megaeth-mainnet'],
+        ticker: NetworksTicker['megaeth-mainnet'],
+        rpcPrefs: {
+            blockExplorerUrl: BlockExplorerUrl['megaeth-mainnet'],
+        },
+    },
+    // Environment 3: Power User test networks
+    [NetworkType['fantom-mainnet']]: {
+        chainId: ChainId['fantom-mainnet'],
+        ticker: NetworksTicker['fantom-mainnet'],
+        rpcPrefs: {
+            blockExplorerUrl: BlockExplorerUrl['fantom-mainnet'],
+        },
+    },
+    [NetworkType['gnosis-mainnet']]: {
+        chainId: ChainId['gnosis-mainnet'],
+        ticker: NetworksTicker['gnosis-mainnet'],
+        rpcPrefs: {
+            blockExplorerUrl: BlockExplorerUrl['gnosis-mainnet'],
+        },
+    },
+    [NetworkType['cronos-mainnet']]: {
+        chainId: ChainId['cronos-mainnet'],
+        ticker: NetworksTicker['cronos-mainnet'],
+        rpcPrefs: {
+            blockExplorerUrl: BlockExplorerUrl['cronos-mainnet'],
+        },
+    },
+    [NetworkType['moonbeam-mainnet']]: {
+        chainId: ChainId['moonbeam-mainnet'],
+        ticker: NetworksTicker['moonbeam-mainnet'],
+        rpcPrefs: {
+            blockExplorerUrl: BlockExplorerUrl['moonbeam-mainnet'],
+        },
+    },
+    [NetworkType['moonriver-mainnet']]: {
+        chainId: ChainId['moonriver-mainnet'],
+        ticker: NetworksTicker['moonriver-mainnet'],
+        rpcPrefs: {
+            blockExplorerUrl: BlockExplorerUrl['moonriver-mainnet'],
+        },
+    },
     [NetworkType.rpc]: {
         chainId: undefined,
         blockExplorerUrl: undefined,
@@ -182,7 +276,7 @@ export const NETWORKS_BYPASSING_VALIDATION = {
     '0x3e7': {
         name: 'HyperEVM',
         symbol: 'HYPE',
-        rpcUrl: 'https://rpc.hyperliquid.xyz',
+        rpcUrl: 'https://rpc.hyperliquid.xyz/evm',
     },
 };
 // APIs
diff --git a/dist/constants.mjs.map b/dist/constants.mjs.map
index 0269985d3ecf85304770ed1f2277d4b98cc36100..7131dfb3e6fe006b06df7bdc60c62f0073967eb2 100644
--- a/dist/constants.mjs.map
+++ b/dist/constants.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"constants.mjs","sourceRoot":"","sources":["../src/constants.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  NetworkType,\n  NetworksTicker,\n  ChainId,\n  BuiltInNetworkName,\n  BlockExplorerUrl,\n} from './types';\n\nexport const RPC = 'rpc';\nexport const FALL_BACK_VS_CURRENCY = 'ETH';\nexport const IPFS_DEFAULT_GATEWAY_URL = 'https://cloudflare-ipfs.com/ipfs/';\n\n// NETWORKS ID\n// `toHex` not invoked to avoid cyclic dependency\nexport const GANACHE_CHAIN_ID = '0x539'; // toHex(1337)\n/**\n * The largest possible chain ID we can handle.\n * Explanation: https://gist.github.com/rekmarks/a47bd5f2525936c4b8eee31a16345553\n */\nexport const MAX_SAFE_CHAIN_ID = 4503599627370476;\n\n// TOKEN STANDARDS\nexport const ERC721 = 'ERC721';\nexport const ERC1155 = 'ERC1155';\nexport const ERC20 = 'ERC20';\n\n// TOKEN INTERFACE IDS\nexport const ERC721_INTERFACE_ID = '0x80ac58cd';\nexport const ERC721_METADATA_INTERFACE_ID = '0x5b5e139f';\nexport const ERC721_ENUMERABLE_INTERFACE_ID = '0x780e9d63';\nexport const ERC1155_INTERFACE_ID = '0xd9b67a26';\nexport const ERC1155_METADATA_URI_INTERFACE_ID = '0x0e89341c';\nexport const ERC1155_TOKEN_RECEIVER_INTERFACE_ID = '0x4e2312e0';\n\n// UNITS\nexport const GWEI = 'gwei';\n\n// ASSET TYPES\nexport const ASSET_TYPES = {\n  NATIVE: 'NATIVE',\n  TOKEN: 'TOKEN',\n  NFT: 'NFT',\n  UNKNOWN: 'UNKNOWN',\n};\n\n// TICKER SYMBOLS\nexport const TESTNET_TICKER_SYMBOLS = {\n  GOERLI: 'GoerliETH',\n  SEPOLIA: 'SepoliaETH',\n  LINEA_GOERLI: 'LineaETH',\n  LINEA_SEPOLIA: 'LineaETH',\n  MEGAETH_TESTNET: 'MegaETH',\n  MEGAETH_TESTNET_V2: 'MegaETH',\n};\n\n/**\n * Map of all built-in custom networks to their RPC endpoints.\n */\nexport const BUILT_IN_CUSTOM_NETWORKS_RPC = {\n  /**\n   * @deprecated Please use `megaeth-testnet` instead.\n   */\n  MEGAETH_TESTNET: 'https://carrot.megaeth.com/rpc',\n  /**\n   * @deprecated Please use `megaeth-testnet-v2` instead.\n   */\n  'megaeth-testnet': 'https://carrot.megaeth.com/rpc',\n  'megaeth-testnet-v2': 'https://carrot.megaeth.com/rpc',\n  'monad-testnet': 'https://testnet-rpc.monad.xyz',\n};\n\n/**\n * Map of all build-in Infura networks to their network, ticker and chain IDs.\n */\nexport const BUILT_IN_NETWORKS = {\n  [NetworkType.goerli]: {\n    chainId: ChainId.goerli,\n    ticker: NetworksTicker.goerli,\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl.goerli,\n    },\n  },\n  [NetworkType.sepolia]: {\n    chainId: ChainId.sepolia,\n    ticker: NetworksTicker.sepolia,\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl.sepolia,\n    },\n  },\n  [NetworkType.mainnet]: {\n    chainId: ChainId.mainnet,\n    ticker: NetworksTicker.mainnet,\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl.mainnet,\n    },\n  },\n  [NetworkType['linea-goerli']]: {\n    chainId: ChainId['linea-goerli'],\n    ticker: NetworksTicker['linea-goerli'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['linea-goerli'],\n    },\n  },\n  [NetworkType['linea-sepolia']]: {\n    chainId: ChainId['linea-sepolia'],\n    ticker: NetworksTicker['linea-sepolia'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['linea-sepolia'],\n    },\n  },\n  [NetworkType['linea-mainnet']]: {\n    chainId: ChainId['linea-mainnet'],\n    ticker: NetworksTicker['linea-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['linea-mainnet'],\n    },\n  },\n  [NetworkType['megaeth-testnet']]: {\n    chainId: ChainId['megaeth-testnet'],\n    ticker: NetworksTicker['megaeth-testnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['megaeth-testnet'],\n    },\n  },\n  [NetworkType['megaeth-testnet-v2']]: {\n    chainId: ChainId['megaeth-testnet-v2'],\n    ticker: NetworksTicker['megaeth-testnet-v2'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['megaeth-testnet-v2'],\n    },\n  },\n  [NetworkType['monad-testnet']]: {\n    chainId: ChainId['monad-testnet'],\n    ticker: NetworksTicker['monad-testnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['monad-testnet'],\n    },\n  },\n  [NetworkType['base-mainnet']]: {\n    chainId: ChainId['base-mainnet'],\n    ticker: NetworksTicker['base-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['base-mainnet'],\n    },\n  },\n  [NetworkType['arbitrum-mainnet']]: {\n    chainId: ChainId['arbitrum-mainnet'],\n    ticker: NetworksTicker['arbitrum-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['arbitrum-mainnet'],\n    },\n  },\n  [NetworkType['bsc-mainnet']]: {\n    chainId: ChainId['bsc-mainnet'],\n    ticker: NetworksTicker['bsc-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['bsc-mainnet'],\n    },\n  },\n  [NetworkType['optimism-mainnet']]: {\n    chainId: ChainId['optimism-mainnet'],\n    ticker: NetworksTicker['optimism-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['optimism-mainnet'],\n    },\n  },\n  [NetworkType['polygon-mainnet']]: {\n    chainId: ChainId['polygon-mainnet'],\n    ticker: NetworksTicker['polygon-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['polygon-mainnet'],\n    },\n  },\n  [NetworkType['sei-mainnet']]: {\n    chainId: ChainId['sei-mainnet'],\n    ticker: NetworksTicker['sei-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['sei-mainnet'],\n    },\n  },\n  [NetworkType.rpc]: {\n    chainId: undefined,\n    blockExplorerUrl: undefined,\n    ticker: undefined,\n    rpcPrefs: undefined,\n  },\n} as const;\n\n/**\n * When a user adds a custom network to MetaMask, we perform some basic\n * validations on the network. For instance, usually a network cannot share the\n * same chain as another. In some cases, however, we want to allow networks that\n * would normally be invalid. This mapping contains networks that should bypass\n * validation.\n */\nexport const NETWORKS_BYPASSING_VALIDATION = {\n  // HyperEVM uses the same chain ID as Wanchain\n  '0x3e7': {\n    name: 'HyperEVM',\n    symbol: 'HYPE',\n    rpcUrl: 'https://rpc.hyperliquid.xyz',\n  },\n};\n\n// APIs\nexport const OPENSEA_PROXY_URL =\n  'https://proxy.api.cx.metamask.io/opensea/v1/api/v2';\n\nexport const NFT_API_BASE_URL = 'https://nft.api.cx.metamask.io';\n\nexport const NFT_API_VERSION = '1';\n\nexport const NFT_API_TIMEOUT = 15000;\n\n// Default origin for controllers\nexport const ORIGIN_METAMASK = 'metamask';\n\n/**\n * Approval request types for various operations.\n * These types are used by different controllers to create and manage\n * approval requests consistently.\n */\nexport enum ApprovalType {\n  AddEthereumChain = 'wallet_addEthereumChain',\n  ConnectAccounts = 'connect_accounts',\n  EthDecrypt = 'eth_decrypt',\n  EthGetEncryptionPublicKey = 'eth_getEncryptionPublicKey',\n  EthSignTypedData = 'eth_signTypedData',\n  PersonalSign = 'personal_sign',\n  ResultError = 'result_error',\n  ResultSuccess = 'result_success',\n  SnapDialogAlert = 'snap_dialog:alert',\n  SnapDialogConfirmation = 'snap_dialog:confirmation',\n  SnapDialogPrompt = 'snap_dialog:prompt',\n  SnapDialogDefault = 'snap_dialog',\n  SwitchEthereumChain = 'wallet_switchEthereumChain',\n  Transaction = 'transaction',\n  TransactionBatch = 'transaction_batch',\n  Unlock = 'unlock',\n  WalletConnect = 'wallet_connect',\n  WalletRequestPermissions = 'wallet_requestPermissions',\n  WatchAsset = 'wallet_watchAsset',\n}\n\n/**\n * Mapping of chain IDs to their network names for ENS functionality.\n * Note: MegaETH-testnet is intentionally excluded from this mapping as it doesn't support ENS.\n */\nexport const CHAIN_ID_TO_ETHERS_NETWORK_NAME_MAP: Record<\n  string,\n  BuiltInNetworkName\n> = {\n  [ChainId.goerli]: BuiltInNetworkName.Goerli,\n  [ChainId.sepolia]: BuiltInNetworkName.Sepolia,\n  [ChainId.mainnet]: BuiltInNetworkName.Mainnet,\n  [ChainId['linea-goerli']]: BuiltInNetworkName.LineaGoerli,\n  [ChainId['linea-sepolia']]: BuiltInNetworkName.LineaSepolia,\n  [ChainId['linea-mainnet']]: BuiltInNetworkName.LineaMainnet,\n  [ChainId.aurora]: BuiltInNetworkName.Aurora,\n};\n\n/**\n * The number of milliseconds in a second.\n */\nexport const SECOND = 1000;\n\n/**\n * The number of milliseconds in a second.\n */\nexport const SECONDS = SECOND;\n\n/**\n * The number of milliseconds in a minute.\n */\nexport const MINUTE = SECONDS * 60;\n\n/**\n * The number of milliseconds in a minute.\n */\nexport const MINUTES = MINUTE;\n\n/**\n * The number of milliseconds in a hour.\n */\nexport const HOUR = MINUTES * 60;\n\n/**\n * The number of milliseconds in a hour.\n */\nexport const HOURS = HOUR;\n\n/**\n * The number of milliseconds in a day.\n */\nexport const DAY = HOURS * 24;\n\n/**\n * The number of milliseconds in a day.\n */\nexport const DAYS = DAY;\n"]}
\ No newline at end of file
+{"version":3,"file":"constants.mjs","sourceRoot":"","sources":["../src/constants.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  NetworkType,\n  NetworksTicker,\n  ChainId,\n  BuiltInNetworkName,\n  BlockExplorerUrl,\n} from './types';\n\nexport const RPC = 'rpc';\nexport const FALL_BACK_VS_CURRENCY = 'ETH';\nexport const IPFS_DEFAULT_GATEWAY_URL = 'https://cloudflare-ipfs.com/ipfs/';\n\n// NETWORKS ID\n// `toHex` not invoked to avoid cyclic dependency\nexport const GANACHE_CHAIN_ID = '0x539'; // toHex(1337)\n/**\n * The largest possible chain ID we can handle.\n * Explanation: https://gist.github.com/rekmarks/a47bd5f2525936c4b8eee31a16345553\n */\nexport const MAX_SAFE_CHAIN_ID = 4503599627370476;\n\n// TOKEN STANDARDS\nexport const ERC721 = 'ERC721';\nexport const ERC1155 = 'ERC1155';\nexport const ERC20 = 'ERC20';\n\n// TOKEN INTERFACE IDS\nexport const ERC721_INTERFACE_ID = '0x80ac58cd';\nexport const ERC721_METADATA_INTERFACE_ID = '0x5b5e139f';\nexport const ERC721_ENUMERABLE_INTERFACE_ID = '0x780e9d63';\nexport const ERC1155_INTERFACE_ID = '0xd9b67a26';\nexport const ERC1155_METADATA_URI_INTERFACE_ID = '0x0e89341c';\nexport const ERC1155_TOKEN_RECEIVER_INTERFACE_ID = '0x4e2312e0';\n\n// UNITS\nexport const GWEI = 'gwei';\n\n// ASSET TYPES\nexport const ASSET_TYPES = {\n  NATIVE: 'NATIVE',\n  TOKEN: 'TOKEN',\n  NFT: 'NFT',\n  UNKNOWN: 'UNKNOWN',\n};\n\n// TICKER SYMBOLS\nexport const TESTNET_TICKER_SYMBOLS = {\n  GOERLI: 'GoerliETH',\n  SEPOLIA: 'SepoliaETH',\n  LINEA_GOERLI: 'LineaETH',\n  LINEA_SEPOLIA: 'LineaETH',\n  MEGAETH_TESTNET: 'MegaETH',\n  MEGAETH_TESTNET_V2: 'MegaETH',\n};\n\n/**\n * Map of all built-in custom networks to their RPC endpoints.\n */\nexport const BUILT_IN_CUSTOM_NETWORKS_RPC = {\n  /**\n   * @deprecated Please use `megaeth-testnet` instead.\n   */\n  MEGAETH_TESTNET: 'https://carrot.megaeth.com/rpc',\n  /**\n   * @deprecated Please use `megaeth-testnet-v2` instead.\n   */\n  'megaeth-testnet': 'https://carrot.megaeth.com/rpc',\n  'megaeth-testnet-v2': 'https://carrot.megaeth.com/rpc',\n  'monad-testnet': 'https://testnet-rpc.monad.xyz',\n  // Mainnet networks with custom RPC URLs\n  'hyper-evm-mainnet': 'https://rpc.hyperliquid.xyz/evm',\n  'zksync-era-mainnet': 'https://mainnet.era.zksync.io',\n  'megaeth-mainnet': 'https://mainnet.megaeth.com/rpc',\n  // Environment 3: Power User test networks\n  'fantom-mainnet': 'https://rpcapi.fantom.network',\n  'gnosis-mainnet': 'https://gnosis-mainnet.public.blastapi.io',\n  'cronos-mainnet': 'https://evm.cronos.org',\n  'moonbeam-mainnet': 'https://rpc.api.moonbeam.network',\n  'moonriver-mainnet': 'https://rpc.api.moonriver.moonbeam.network',\n};\n\n/**\n * Map of all build-in Infura networks to their network, ticker and chain IDs.\n */\nexport const BUILT_IN_NETWORKS = {\n  [NetworkType.goerli]: {\n    chainId: ChainId.goerli,\n    ticker: NetworksTicker.goerli,\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl.goerli,\n    },\n  },\n  [NetworkType.sepolia]: {\n    chainId: ChainId.sepolia,\n    ticker: NetworksTicker.sepolia,\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl.sepolia,\n    },\n  },\n  [NetworkType.mainnet]: {\n    chainId: ChainId.mainnet,\n    ticker: NetworksTicker.mainnet,\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl.mainnet,\n    },\n  },\n  [NetworkType['linea-goerli']]: {\n    chainId: ChainId['linea-goerli'],\n    ticker: NetworksTicker['linea-goerli'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['linea-goerli'],\n    },\n  },\n  [NetworkType['linea-sepolia']]: {\n    chainId: ChainId['linea-sepolia'],\n    ticker: NetworksTicker['linea-sepolia'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['linea-sepolia'],\n    },\n  },\n  [NetworkType['linea-mainnet']]: {\n    chainId: ChainId['linea-mainnet'],\n    ticker: NetworksTicker['linea-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['linea-mainnet'],\n    },\n  },\n  [NetworkType['megaeth-testnet']]: {\n    chainId: ChainId['megaeth-testnet'],\n    ticker: NetworksTicker['megaeth-testnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['megaeth-testnet'],\n    },\n  },\n  [NetworkType['megaeth-testnet-v2']]: {\n    chainId: ChainId['megaeth-testnet-v2'],\n    ticker: NetworksTicker['megaeth-testnet-v2'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['megaeth-testnet-v2'],\n    },\n  },\n  [NetworkType['monad-testnet']]: {\n    chainId: ChainId['monad-testnet'],\n    ticker: NetworksTicker['monad-testnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['monad-testnet'],\n    },\n  },\n  [NetworkType['base-mainnet']]: {\n    chainId: ChainId['base-mainnet'],\n    ticker: NetworksTicker['base-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['base-mainnet'],\n    },\n  },\n  [NetworkType['arbitrum-mainnet']]: {\n    chainId: ChainId['arbitrum-mainnet'],\n    ticker: NetworksTicker['arbitrum-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['arbitrum-mainnet'],\n    },\n  },\n  [NetworkType['bsc-mainnet']]: {\n    chainId: ChainId['bsc-mainnet'],\n    ticker: NetworksTicker['bsc-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['bsc-mainnet'],\n    },\n  },\n  [NetworkType['optimism-mainnet']]: {\n    chainId: ChainId['optimism-mainnet'],\n    ticker: NetworksTicker['optimism-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['optimism-mainnet'],\n    },\n  },\n  [NetworkType['polygon-mainnet']]: {\n    chainId: ChainId['polygon-mainnet'],\n    ticker: NetworksTicker['polygon-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['polygon-mainnet'],\n    },\n  },\n  [NetworkType['sei-mainnet']]: {\n    chainId: ChainId['sei-mainnet'],\n    ticker: NetworksTicker['sei-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['sei-mainnet'],\n    },\n  },\n  // Avalanche\n  [NetworkType['avalanche-mainnet']]: {\n    chainId: ChainId['avalanche-mainnet'],\n    ticker: NetworksTicker['avalanche-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['avalanche-mainnet'],\n    },\n  },\n  // HyperEVM\n  [NetworkType['hyper-evm-mainnet']]: {\n    chainId: ChainId['hyper-evm-mainnet'],\n    ticker: NetworksTicker['hyper-evm-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['hyper-evm-mainnet'],\n    },\n  },\n  // Palm\n  [NetworkType['palm-mainnet']]: {\n    chainId: ChainId['palm-mainnet'],\n    ticker: NetworksTicker['palm-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['palm-mainnet'],\n    },\n  },\n  // zkSync Era\n  [NetworkType['zksync-era-mainnet']]: {\n    chainId: ChainId['zksync-era-mainnet'],\n    ticker: NetworksTicker['zksync-era-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['zksync-era-mainnet'],\n    },\n  },\n  // Monad\n  [NetworkType['monad-mainnet']]: {\n    chainId: ChainId['monad-mainnet'],\n    ticker: NetworksTicker['monad-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['monad-mainnet'],\n    },\n  },\n  // MegaEth\n  [NetworkType['megaeth-mainnet']]: {\n    chainId: ChainId['megaeth-mainnet'],\n    ticker: NetworksTicker['megaeth-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['megaeth-mainnet'],\n    },\n  },\n  // Environment 3: Power User test networks\n  [NetworkType['fantom-mainnet']]: {\n    chainId: ChainId['fantom-mainnet'],\n    ticker: NetworksTicker['fantom-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['fantom-mainnet'],\n    },\n  },\n  [NetworkType['gnosis-mainnet']]: {\n    chainId: ChainId['gnosis-mainnet'],\n    ticker: NetworksTicker['gnosis-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['gnosis-mainnet'],\n    },\n  },\n  [NetworkType['cronos-mainnet']]: {\n    chainId: ChainId['cronos-mainnet'],\n    ticker: NetworksTicker['cronos-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['cronos-mainnet'],\n    },\n  },\n  [NetworkType['moonbeam-mainnet']]: {\n    chainId: ChainId['moonbeam-mainnet'],\n    ticker: NetworksTicker['moonbeam-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['moonbeam-mainnet'],\n    },\n  },\n  [NetworkType['moonriver-mainnet']]: {\n    chainId: ChainId['moonriver-mainnet'],\n    ticker: NetworksTicker['moonriver-mainnet'],\n    rpcPrefs: {\n      blockExplorerUrl: BlockExplorerUrl['moonriver-mainnet'],\n    },\n  },\n  [NetworkType.rpc]: {\n    chainId: undefined,\n    blockExplorerUrl: undefined,\n    ticker: undefined,\n    rpcPrefs: undefined,\n  },\n} as const;\n\n/**\n * When a user adds a custom network to MetaMask, we perform some basic\n * validations on the network. For instance, usually a network cannot share the\n * same chain as another. In some cases, however, we want to allow networks that\n * would normally be invalid. This mapping contains networks that should bypass\n * validation.\n */\nexport const NETWORKS_BYPASSING_VALIDATION = {\n  // HyperEVM uses the same chain ID as Wanchain\n  '0x3e7': {\n    name: 'HyperEVM',\n    symbol: 'HYPE',\n    rpcUrl: 'https://rpc.hyperliquid.xyz/evm',\n  },\n};\n\n// APIs\nexport const OPENSEA_PROXY_URL =\n  'https://proxy.api.cx.metamask.io/opensea/v1/api/v2';\n\nexport const NFT_API_BASE_URL = 'https://nft.api.cx.metamask.io';\n\nexport const NFT_API_VERSION = '1';\n\nexport const NFT_API_TIMEOUT = 15000;\n\n// Default origin for controllers\nexport const ORIGIN_METAMASK = 'metamask';\n\n/**\n * Approval request types for various operations.\n * These types are used by different controllers to create and manage\n * approval requests consistently.\n */\nexport enum ApprovalType {\n  AddEthereumChain = 'wallet_addEthereumChain',\n  ConnectAccounts = 'connect_accounts',\n  EthDecrypt = 'eth_decrypt',\n  EthGetEncryptionPublicKey = 'eth_getEncryptionPublicKey',\n  EthSignTypedData = 'eth_signTypedData',\n  PersonalSign = 'personal_sign',\n  ResultError = 'result_error',\n  ResultSuccess = 'result_success',\n  SnapDialogAlert = 'snap_dialog:alert',\n  SnapDialogConfirmation = 'snap_dialog:confirmation',\n  SnapDialogPrompt = 'snap_dialog:prompt',\n  SnapDialogDefault = 'snap_dialog',\n  SwitchEthereumChain = 'wallet_switchEthereumChain',\n  Transaction = 'transaction',\n  TransactionBatch = 'transaction_batch',\n  Unlock = 'unlock',\n  WalletConnect = 'wallet_connect',\n  WalletRequestPermissions = 'wallet_requestPermissions',\n  WatchAsset = 'wallet_watchAsset',\n}\n\n/**\n * Mapping of chain IDs to their network names for ENS functionality.\n * Note: MegaETH-testnet is intentionally excluded from this mapping as it doesn't support ENS.\n */\nexport const CHAIN_ID_TO_ETHERS_NETWORK_NAME_MAP: Record<\n  string,\n  BuiltInNetworkName\n> = {\n  [ChainId.goerli]: BuiltInNetworkName.Goerli,\n  [ChainId.sepolia]: BuiltInNetworkName.Sepolia,\n  [ChainId.mainnet]: BuiltInNetworkName.Mainnet,\n  [ChainId['linea-goerli']]: BuiltInNetworkName.LineaGoerli,\n  [ChainId['linea-sepolia']]: BuiltInNetworkName.LineaSepolia,\n  [ChainId['linea-mainnet']]: BuiltInNetworkName.LineaMainnet,\n  [ChainId.aurora]: BuiltInNetworkName.Aurora,\n};\n\n/**\n * The number of milliseconds in a second.\n */\nexport const SECOND = 1000;\n\n/**\n * The number of milliseconds in a second.\n */\nexport const SECONDS = SECOND;\n\n/**\n * The number of milliseconds in a minute.\n */\nexport const MINUTE = SECONDS * 60;\n\n/**\n * The number of milliseconds in a minute.\n */\nexport const MINUTES = MINUTE;\n\n/**\n * The number of milliseconds in a hour.\n */\nexport const HOUR = MINUTES * 60;\n\n/**\n * The number of milliseconds in a hour.\n */\nexport const HOURS = HOUR;\n\n/**\n * The number of milliseconds in a day.\n */\nexport const DAY = HOURS * 24;\n\n/**\n * The number of milliseconds in a day.\n */\nexport const DAYS = DAY;\n"]}
\ No newline at end of file
diff --git a/dist/types.cjs b/dist/types.cjs
index 36aa58f6b1c28a42ac0784c890428f5039610376..bbb8021052b4e069560af9602bc0df69717ece6e 100644
--- a/dist/types.cjs
+++ b/dist/types.cjs
@@ -17,6 +17,18 @@ exports.InfuraNetworkType = {
     'optimism-mainnet': 'optimism-mainnet',
     'polygon-mainnet': 'polygon-mainnet',
     'sei-mainnet': 'sei-mainnet',
+    // Avalanche
+    'avalanche-mainnet': 'avalanche-mainnet',
+    // HyperEVM
+    'hyper-evm-mainnet': 'hyper-evm-mainnet',
+    // Palm
+    'palm-mainnet': 'palm-mainnet',
+    // zkSync Era
+    'zksync-era-mainnet': 'zksync-era-mainnet',
+    // Monad
+    'monad-mainnet': 'monad-mainnet',
+    // MegaEth
+    'megaeth-mainnet': 'megaeth-mainnet',
 };
 /**
  * Custom network types that are not part of Infura.
@@ -28,6 +40,12 @@ exports.CustomNetworkType = {
     'megaeth-testnet': 'megaeth-testnet',
     'megaeth-testnet-v2': 'megaeth-testnet-v2',
     'monad-testnet': 'monad-testnet',
+    // Environment 3: Power User test networks
+    'fantom-mainnet': 'fantom-mainnet',
+    'gnosis-mainnet': 'gnosis-mainnet',
+    'cronos-mainnet': 'cronos-mainnet',
+    'moonbeam-mainnet': 'moonbeam-mainnet',
+    'moonriver-mainnet': 'moonriver-mainnet',
 };
 /**
  * The "network type"; either the name of a built-in network, or "rpc" for custom networks.
@@ -85,6 +103,18 @@ var BuiltInNetworkName;
     BuiltInNetworkName["OptimismMainnet"] = "optimism-mainnet";
     BuiltInNetworkName["PolygonMainnet"] = "polygon-mainnet";
     BuiltInNetworkName["SeiMainnet"] = "sei-mainnet";
+    BuiltInNetworkName["AvalancheMainnet"] = "avalanche-mainnet";
+    BuiltInNetworkName["HyperEVMMainnet"] = "hyper-evm-mainnet";
+    BuiltInNetworkName["PalmMainnet"] = "palm-mainnet";
+    BuiltInNetworkName["ZkSyncEraMainnet"] = "zksync-era-mainnet";
+    BuiltInNetworkName["MonadMainnet"] = "monad-mainnet";
+    BuiltInNetworkName["MegaEthMainnet"] = "megaeth-mainnet";
+    // Environment 3: Power User test networks
+    BuiltInNetworkName["FantomMainnet"] = "fantom-mainnet";
+    BuiltInNetworkName["GnosisMainnet"] = "gnosis-mainnet";
+    BuiltInNetworkName["CronosMainnet"] = "cronos-mainnet";
+    BuiltInNetworkName["MoonbeamMainnet"] = "moonbeam-mainnet";
+    BuiltInNetworkName["MoonriverMainnet"] = "moonriver-mainnet";
 })(BuiltInNetworkName || (exports.BuiltInNetworkName = BuiltInNetworkName = {}));
 /**
  * Decimal string chain IDs of built-in networks, by name.
@@ -111,6 +141,18 @@ exports.ChainId = {
     [BuiltInNetworkName.OptimismMainnet]: '0xa', // toHex(10)
     [BuiltInNetworkName.PolygonMainnet]: '0x89', // toHex(137)
     [BuiltInNetworkName.SeiMainnet]: '0x531', // toHex(1329)
+    [BuiltInNetworkName.AvalancheMainnet]: '0xa86a', // toHex(43114)
+    [BuiltInNetworkName.HyperEVMMainnet]: '0x3e7', // toHex(999)
+    [BuiltInNetworkName.PalmMainnet]: '0x2a15c308d', // toHex(11297108109)
+    [BuiltInNetworkName.ZkSyncEraMainnet]: '0x144', // toHex(324)
+    [BuiltInNetworkName.MonadMainnet]: '0x8f', // toHex(143)
+    [BuiltInNetworkName.MegaEthMainnet]: '0x10e6', // toHex(4326)
+    // Environment 3: Power User test networks
+    [BuiltInNetworkName.FantomMainnet]: '0xfa', // toHex(250)
+    [BuiltInNetworkName.GnosisMainnet]: '0x64', // toHex(100)
+    [BuiltInNetworkName.CronosMainnet]: '0x19', // toHex(25)
+    [BuiltInNetworkName.MoonbeamMainnet]: '0x504', // toHex(1284)
+    [BuiltInNetworkName.MoonriverMainnet]: '0x505', // toHex(1285)
 };
 /* eslint-disable @typescript-eslint/naming-convention */
 var NetworksTicker;
@@ -139,6 +181,18 @@ var NetworksTicker;
     NetworksTicker["optimism-mainnet"] = "ETH";
     NetworksTicker["polygon-mainnet"] = "POL";
     NetworksTicker["sei-mainnet"] = "SEI";
+    NetworksTicker["avalanche-mainnet"] = "AVAX";
+    NetworksTicker["hyper-evm-mainnet"] = "HYPE";
+    NetworksTicker["palm-mainnet"] = "PALM";
+    NetworksTicker["zksync-era-mainnet"] = "ZKSYNC";
+    NetworksTicker["monad-mainnet"] = "MONAD";
+    NetworksTicker["megaeth-mainnet"] = "MEGAETH";
+    // Environment 3: Power User test networks
+    NetworksTicker["fantom-mainnet"] = "FTM";
+    NetworksTicker["gnosis-mainnet"] = "xDAI";
+    NetworksTicker["cronos-mainnet"] = "CRO";
+    NetworksTicker["moonbeam-mainnet"] = "GLMR";
+    NetworksTicker["moonriver-mainnet"] = "MOVR";
     NetworksTicker["rpc"] = "";
 })(NetworksTicker || (exports.NetworksTicker = NetworksTicker = {}));
 /* eslint-enable @typescript-eslint/naming-convention */
@@ -160,7 +214,19 @@ exports.BlockExplorerUrl = {
     [BuiltInNetworkName.BscMainnet]: 'https://bscscan.com',
     [BuiltInNetworkName.OptimismMainnet]: 'https://optimistic.etherscan.io',
     [BuiltInNetworkName.PolygonMainnet]: 'https://polygonscan.com',
-    [BuiltInNetworkName.SeiMainnet]: 'https://seitrace.com',
+    [BuiltInNetworkName.SeiMainnet]: 'https://seitrace.com/',
+    [BuiltInNetworkName.AvalancheMainnet]: 'https://snowtrace.io',
+    [BuiltInNetworkName.HyperEVMMainnet]: 'https://hyperevmscan.io/',
+    [BuiltInNetworkName.PalmMainnet]: 'https://palm.chainlens.com',
+    [BuiltInNetworkName.ZkSyncEraMainnet]: 'https://explorer.zksync.io/',
+    [BuiltInNetworkName.MonadMainnet]: 'https://monadscan.com/',
+    [BuiltInNetworkName.MegaEthMainnet]: 'https://explorer.megaeth.com',
+    // Environment 3: Power User test networks
+    [BuiltInNetworkName.FantomMainnet]: 'https://ftmscan.com',
+    [BuiltInNetworkName.GnosisMainnet]: 'https://gnosisscan.io',
+    [BuiltInNetworkName.CronosMainnet]: 'https://explorer.cronos.org',
+    [BuiltInNetworkName.MoonbeamMainnet]: 'https://moonscan.io',
+    [BuiltInNetworkName.MoonriverMainnet]: 'https://moonriver.moonscan.io',
 };
 exports.NetworkNickname = {
     [BuiltInNetworkName.Mainnet]: 'Ethereum Mainnet',
@@ -181,5 +247,17 @@ exports.NetworkNickname = {
     [BuiltInNetworkName.OptimismMainnet]: 'Optimism Mainnet',
     [BuiltInNetworkName.PolygonMainnet]: 'Polygon Mainnet',
     [BuiltInNetworkName.SeiMainnet]: 'Sei Mainnet',
+    [BuiltInNetworkName.AvalancheMainnet]: 'Avalanche Mainnet',
+    [BuiltInNetworkName.HyperEVMMainnet]: 'HyperEVM Mainnet',
+    [BuiltInNetworkName.PalmMainnet]: 'Palm Mainnet',
+    [BuiltInNetworkName.ZkSyncEraMainnet]: 'zkSync Era Mainnet',
+    [BuiltInNetworkName.MonadMainnet]: 'Monad Mainnet',
+    [BuiltInNetworkName.MegaEthMainnet]: 'MegaETH Mainnet',
+    // Environment 3: Power User test networks
+    [BuiltInNetworkName.FantomMainnet]: 'Fantom Opera',
+    [BuiltInNetworkName.GnosisMainnet]: 'Gnosis',
+    [BuiltInNetworkName.CronosMainnet]: 'Cronos Mainnet',
+    [BuiltInNetworkName.MoonbeamMainnet]: 'Moonbeam',
+    [BuiltInNetworkName.MoonriverMainnet]: 'Moonriver',
 };
 //# sourceMappingURL=types.cjs.map
\ No newline at end of file
diff --git a/dist/types.cjs.map b/dist/types.cjs.map
index a726c8094cc8af67a6601b828f0dc078759356b4..6bdee25a618846999630713b933068f67b04b70d 100644
--- a/dist/types.cjs.map
+++ b/dist/types.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"types.cjs","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * The names of built-in Infura networks\n */\nexport const InfuraNetworkType = {\n  mainnet: 'mainnet',\n  goerli: 'goerli',\n  sepolia: 'sepolia',\n  'linea-goerli': 'linea-goerli',\n  'linea-sepolia': 'linea-sepolia',\n  'linea-mainnet': 'linea-mainnet',\n  'base-mainnet': 'base-mainnet',\n  'arbitrum-mainnet': 'arbitrum-mainnet',\n  'bsc-mainnet': 'bsc-mainnet',\n  'optimism-mainnet': 'optimism-mainnet',\n  'polygon-mainnet': 'polygon-mainnet',\n  'sei-mainnet': 'sei-mainnet',\n} as const;\n\nexport type InfuraNetworkType =\n  (typeof InfuraNetworkType)[keyof typeof InfuraNetworkType];\n\n/**\n * Custom network types that are not part of Infura.\n */\nexport const CustomNetworkType = {\n  /**\n   * @deprecated `megaeth-testnet` is migrated to `megaeth-testnet-v2`.\n   */\n  'megaeth-testnet': 'megaeth-testnet',\n  'megaeth-testnet-v2': 'megaeth-testnet-v2',\n  'monad-testnet': 'monad-testnet',\n} as const;\nexport type CustomNetworkType =\n  (typeof CustomNetworkType)[keyof typeof CustomNetworkType];\n\n/**\n * Network types supported including both Infura networks and other networks.\n */\nexport type BuiltInNetworkType = InfuraNetworkType | CustomNetworkType;\n\n/**\n * The \"network type\"; either the name of a built-in network, or \"rpc\" for custom networks.\n */\nexport const NetworkType = {\n  ...InfuraNetworkType,\n  ...CustomNetworkType,\n  rpc: 'rpc',\n} as const;\n\nexport type NetworkType = (typeof NetworkType)[keyof typeof NetworkType];\n\n/**\n * A helper to determine whether a given input is NetworkType.\n *\n * @param val - the value to check whether it is NetworkType or not.\n * @returns boolean indicating whether or not the argument is NetworkType.\n */\nexport function isNetworkType(val: string): val is NetworkType {\n  return Object.values(NetworkType).includes(val as NetworkType);\n}\n\n/**\n * A type guard to determine whether the input is an InfuraNetworkType.\n *\n * @param value - The value to check.\n * @returns True if the given value is within the InfuraNetworkType enum,\n * false otherwise.\n */\nexport function isInfuraNetworkType(\n  value: unknown,\n): value is InfuraNetworkType {\n  const infuraNetworkTypes: unknown[] = Object.keys(InfuraNetworkType);\n  return infuraNetworkTypes.includes(value);\n}\n\n/**\n * Names of networks built into the wallet.\n *\n * This includes both Infura and non-Infura networks.\n */\nexport enum BuiltInNetworkName {\n  Mainnet = 'mainnet',\n  Goerli = 'goerli',\n  Sepolia = 'sepolia',\n  LineaGoerli = 'linea-goerli',\n  LineaSepolia = 'linea-sepolia',\n  LineaMainnet = 'linea-mainnet',\n  Aurora = 'aurora',\n  /**\n   * @deprecated `MegaETHTestnet` is migrated to `MegaETHTestnetV2`.\n   */\n  MegaETHTestnet = 'megaeth-testnet',\n  MegaETHTestnetV2 = 'megaeth-testnet-v2',\n  MonadTestnet = 'monad-testnet',\n  BaseMainnet = 'base-mainnet',\n  ArbitrumOne = 'arbitrum-mainnet',\n  BscMainnet = 'bsc-mainnet',\n  OptimismMainnet = 'optimism-mainnet',\n  PolygonMainnet = 'polygon-mainnet',\n  SeiMainnet = 'sei-mainnet',\n}\n\n/**\n * Decimal string chain IDs of built-in networks, by name.\n *\n * `toHex` not invoked to avoid cyclic dependency\n */\nexport const ChainId = {\n  [BuiltInNetworkName.Mainnet]: '0x1', // toHex(1)\n  [BuiltInNetworkName.Goerli]: '0x5', // toHex(5)\n  [BuiltInNetworkName.Sepolia]: '0xaa36a7', // toHex(11155111)\n  [BuiltInNetworkName.Aurora]: '0x4e454152', // toHex(1313161554)\n  [BuiltInNetworkName.LineaGoerli]: '0xe704', // toHex(59140)\n  [BuiltInNetworkName.LineaSepolia]: '0xe705', // toHex(59141)\n  [BuiltInNetworkName.LineaMainnet]: '0xe708', // toHex(59144)\n  /**\n   * @deprecated `MegaETHTestnet` is migrated to `MegaETHTestnetV2`.\n   */\n  [BuiltInNetworkName.MegaETHTestnet]: '0x18c6', // toHex(6342)\n  [BuiltInNetworkName.MegaETHTestnetV2]: '0x18c7', // toHex(6343)\n  [BuiltInNetworkName.MonadTestnet]: '0x279f', // toHex(10143)\n  [BuiltInNetworkName.BaseMainnet]: '0x2105', // toHex(8453)\n  [BuiltInNetworkName.ArbitrumOne]: '0xa4b1', // toHex(42161)\n  [BuiltInNetworkName.BscMainnet]: '0x38', // toHex(56)\n  [BuiltInNetworkName.OptimismMainnet]: '0xa', // toHex(10)\n  [BuiltInNetworkName.PolygonMainnet]: '0x89', // toHex(137)\n  [BuiltInNetworkName.SeiMainnet]: '0x531', // toHex(1329)\n} as const;\nexport type ChainId = (typeof ChainId)[keyof typeof ChainId];\n\n/* eslint-disable @typescript-eslint/naming-convention */\nexport enum NetworksTicker {\n  mainnet = 'ETH',\n  goerli = 'GoerliETH',\n  sepolia = 'SepoliaETH',\n  'linea-goerli' = 'LineaETH',\n  // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values\n  'linea-sepolia' = 'LineaETH',\n  // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values\n  'linea-mainnet' = 'ETH',\n  /**\n   * @deprecated `megaeth-testnet` is migrated to `megaeth-testnet-v2`.\n   */\n  'megaeth-testnet' = 'MegaETH',\n  // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values\n  'megaeth-testnet-v2' = 'MegaETH',\n  'monad-testnet' = 'MON',\n  // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values\n  'base-mainnet' = 'ETH',\n  // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values\n  'arbitrum-mainnet' = 'ETH',\n  'bsc-mainnet' = 'BNB',\n  // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values\n  'optimism-mainnet' = 'ETH',\n  'polygon-mainnet' = 'POL',\n  'sei-mainnet' = 'SEI',\n  rpc = '',\n}\n/* eslint-enable @typescript-eslint/naming-convention */\n\nexport const BlockExplorerUrl = {\n  [BuiltInNetworkName.Mainnet]: 'https://etherscan.io',\n  [BuiltInNetworkName.Goerli]: 'https://goerli.etherscan.io',\n  [BuiltInNetworkName.Sepolia]: 'https://sepolia.etherscan.io',\n  [BuiltInNetworkName.LineaGoerli]: 'https://goerli.lineascan.build',\n  [BuiltInNetworkName.LineaSepolia]: 'https://sepolia.lineascan.build',\n  [BuiltInNetworkName.LineaMainnet]: 'https://lineascan.build',\n  /**\n   * @deprecated `MegaETHTestnet` is migrated to `MegaETHTestnetV2`.\n   */\n  [BuiltInNetworkName.MegaETHTestnet]: 'https://megaexplorer.xyz',\n  [BuiltInNetworkName.MegaETHTestnetV2]:\n    'https://megaeth-testnet-v2.blockscout.com',\n  [BuiltInNetworkName.MonadTestnet]: 'https://testnet.monadexplorer.com',\n  [BuiltInNetworkName.BaseMainnet]: 'https://basescan.org',\n  [BuiltInNetworkName.ArbitrumOne]: 'https://arbiscan.io',\n  [BuiltInNetworkName.BscMainnet]: 'https://bscscan.com',\n  [BuiltInNetworkName.OptimismMainnet]: 'https://optimistic.etherscan.io',\n  [BuiltInNetworkName.PolygonMainnet]: 'https://polygonscan.com',\n  [BuiltInNetworkName.SeiMainnet]: 'https://seitrace.com',\n} as const satisfies Record<BuiltInNetworkType, string>;\nexport type BlockExplorerUrl =\n  (typeof BlockExplorerUrl)[keyof typeof BlockExplorerUrl];\n\nexport const NetworkNickname = {\n  [BuiltInNetworkName.Mainnet]: 'Ethereum Mainnet',\n  [BuiltInNetworkName.Goerli]: 'Goerli',\n  [BuiltInNetworkName.Sepolia]: 'Sepolia',\n  [BuiltInNetworkName.LineaGoerli]: 'Linea Goerli',\n  [BuiltInNetworkName.LineaSepolia]: 'Linea Sepolia',\n  [BuiltInNetworkName.LineaMainnet]: 'Linea',\n  /**\n   * @deprecated `MegaETHTestnet` is migrated to `MegaETHTestnetV2`.\n   */\n  [BuiltInNetworkName.MegaETHTestnet]: 'Mega Testnet',\n  [BuiltInNetworkName.MegaETHTestnetV2]: 'MegaETH Testnet',\n  [BuiltInNetworkName.MonadTestnet]: 'Monad Testnet',\n  [BuiltInNetworkName.BaseMainnet]: 'Base Mainnet',\n  [BuiltInNetworkName.ArbitrumOne]: 'Arbitrum One',\n  [BuiltInNetworkName.BscMainnet]: 'BSC Mainnet',\n  [BuiltInNetworkName.OptimismMainnet]: 'Optimism Mainnet',\n  [BuiltInNetworkName.PolygonMainnet]: 'Polygon Mainnet',\n  [BuiltInNetworkName.SeiMainnet]: 'Sei Mainnet',\n} as const satisfies Record<BuiltInNetworkType, string>;\nexport type NetworkNickname =\n  (typeof NetworkNickname)[keyof typeof NetworkNickname];\n\n/**\n * Makes a selection of keys in a Record optional.\n *\n * @template Type - The Record that you want to operate on.\n * @template Key - The union of keys you want to make optional.\n */\n// TODO: Move to @metamask/utils\nexport type Partialize<Type, Key extends keyof Type> = Omit<Type, Key> &\n  Partial<Pick<Type, Key>>;\n\n/** A context in which to execute a trace, in order to generate nested timings. */\nexport type TraceContext = unknown;\n\n/** Request to trace an operation. */\nexport type TraceRequest = {\n  /** Additional data to include in the trace. */\n  data?: Record<string, number | string | boolean>;\n\n  /** Name of the operation. */\n  name: string;\n\n  /**\n   * Unique identifier for the trace.\n   * Required if starting a trace and not providing a callback.\n   */\n  id?: string;\n\n  /** Trace context in which to execute the operation. */\n  parentContext?: TraceContext;\n\n  /** Additional tags to include in the trace to filter results. */\n  tags?: Record<string, number | string | boolean>;\n};\n\n/** Callback that traces the performance of an operation. */\nexport type TraceCallback = <ReturnType>(\n  /** Request to trace the performance of an operation. */\n  request: TraceRequest,\n\n  /**\n   * Callback to trace.\n   * Thrown errors will not be caught, but the trace will still be recorded.\n   *\n   * @param context - The context in which the operation is running.\n   */\n  fn?: (context?: TraceContext) => ReturnType,\n) => Promise<ReturnType>;\n"]}
\ No newline at end of file
+{"version":3,"file":"types.cjs","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * The names of built-in Infura networks\n */\nexport const InfuraNetworkType = {\n  mainnet: 'mainnet',\n  goerli: 'goerli',\n  sepolia: 'sepolia',\n  'linea-goerli': 'linea-goerli',\n  'linea-sepolia': 'linea-sepolia',\n  'linea-mainnet': 'linea-mainnet',\n  'base-mainnet': 'base-mainnet',\n  'arbitrum-mainnet': 'arbitrum-mainnet',\n  'bsc-mainnet': 'bsc-mainnet',\n  'optimism-mainnet': 'optimism-mainnet',\n  'polygon-mainnet': 'polygon-mainnet',\n  'sei-mainnet': 'sei-mainnet',\n  // Avalanche\n  'avalanche-mainnet': 'avalanche-mainnet',\n  // HyperEVM\n  'hyper-evm-mainnet': 'hyper-evm-mainnet',\n  // Palm\n  'palm-mainnet': 'palm-mainnet',\n  // zkSync Era\n  'zksync-era-mainnet': 'zksync-era-mainnet',\n  // Monad\n  'monad-mainnet': 'monad-mainnet',\n  // MegaEth\n  'megaeth-mainnet': 'megaeth-mainnet',\n} as const;\n\nexport type InfuraNetworkType =\n  (typeof InfuraNetworkType)[keyof typeof InfuraNetworkType];\n\n/**\n * Custom network types that are not part of Infura.\n */\nexport const CustomNetworkType = {\n  /**\n   * @deprecated `megaeth-testnet` is migrated to `megaeth-testnet-v2`.\n   */\n  'megaeth-testnet': 'megaeth-testnet',\n  'megaeth-testnet-v2': 'megaeth-testnet-v2',\n  'monad-testnet': 'monad-testnet',\n  // Environment 3: Power User test networks\n  'fantom-mainnet': 'fantom-mainnet',\n  'gnosis-mainnet': 'gnosis-mainnet',\n  'cronos-mainnet': 'cronos-mainnet',\n  'moonbeam-mainnet': 'moonbeam-mainnet',\n  'moonriver-mainnet': 'moonriver-mainnet',\n} as const;\nexport type CustomNetworkType =\n  (typeof CustomNetworkType)[keyof typeof CustomNetworkType];\n\n/**\n * Network types supported including both Infura networks and other networks.\n */\nexport type BuiltInNetworkType = InfuraNetworkType | CustomNetworkType;\n\n/**\n * The \"network type\"; either the name of a built-in network, or \"rpc\" for custom networks.\n */\nexport const NetworkType = {\n  ...InfuraNetworkType,\n  ...CustomNetworkType,\n  rpc: 'rpc',\n} as const;\n\nexport type NetworkType = (typeof NetworkType)[keyof typeof NetworkType];\n\n/**\n * A helper to determine whether a given input is NetworkType.\n *\n * @param val - the value to check whether it is NetworkType or not.\n * @returns boolean indicating whether or not the argument is NetworkType.\n */\nexport function isNetworkType(val: string): val is NetworkType {\n  return Object.values(NetworkType).includes(val as NetworkType);\n}\n\n/**\n * A type guard to determine whether the input is an InfuraNetworkType.\n *\n * @param value - The value to check.\n * @returns True if the given value is within the InfuraNetworkType enum,\n * false otherwise.\n */\nexport function isInfuraNetworkType(\n  value: unknown,\n): value is InfuraNetworkType {\n  const infuraNetworkTypes: unknown[] = Object.keys(InfuraNetworkType);\n  return infuraNetworkTypes.includes(value);\n}\n\n/**\n * Names of networks built into the wallet.\n *\n * This includes both Infura and non-Infura networks.\n */\nexport enum BuiltInNetworkName {\n  Mainnet = 'mainnet',\n  Goerli = 'goerli',\n  Sepolia = 'sepolia',\n  LineaGoerli = 'linea-goerli',\n  LineaSepolia = 'linea-sepolia',\n  LineaMainnet = 'linea-mainnet',\n  Aurora = 'aurora',\n  /**\n   * @deprecated `MegaETHTestnet` is migrated to `MegaETHTestnetV2`.\n   */\n  MegaETHTestnet = 'megaeth-testnet',\n  MegaETHTestnetV2 = 'megaeth-testnet-v2',\n  MonadTestnet = 'monad-testnet',\n  BaseMainnet = 'base-mainnet',\n  ArbitrumOne = 'arbitrum-mainnet',\n  BscMainnet = 'bsc-mainnet',\n  OptimismMainnet = 'optimism-mainnet',\n  PolygonMainnet = 'polygon-mainnet',\n  SeiMainnet = 'sei-mainnet',\n  AvalancheMainnet = 'avalanche-mainnet',\n  HyperEVMMainnet = 'hyper-evm-mainnet',\n  PalmMainnet = 'palm-mainnet',\n  ZkSyncEraMainnet = 'zksync-era-mainnet',\n  MonadMainnet = 'monad-mainnet',\n  MegaEthMainnet = 'megaeth-mainnet',\n  // Environment 3: Power User test networks\n  FantomMainnet = 'fantom-mainnet',\n  GnosisMainnet = 'gnosis-mainnet',\n  CronosMainnet = 'cronos-mainnet',\n  MoonbeamMainnet = 'moonbeam-mainnet',\n  MoonriverMainnet = 'moonriver-mainnet',\n}\n\n/**\n * Decimal string chain IDs of built-in networks, by name.\n *\n * `toHex` not invoked to avoid cyclic dependency\n */\nexport const ChainId = {\n  [BuiltInNetworkName.Mainnet]: '0x1', // toHex(1)\n  [BuiltInNetworkName.Goerli]: '0x5', // toHex(5)\n  [BuiltInNetworkName.Sepolia]: '0xaa36a7', // toHex(11155111)\n  [BuiltInNetworkName.Aurora]: '0x4e454152', // toHex(1313161554)\n  [BuiltInNetworkName.LineaGoerli]: '0xe704', // toHex(59140)\n  [BuiltInNetworkName.LineaSepolia]: '0xe705', // toHex(59141)\n  [BuiltInNetworkName.LineaMainnet]: '0xe708', // toHex(59144)\n  /**\n   * @deprecated `MegaETHTestnet` is migrated to `MegaETHTestnetV2`.\n   */\n  [BuiltInNetworkName.MegaETHTestnet]: '0x18c6', // toHex(6342)\n  [BuiltInNetworkName.MegaETHTestnetV2]: '0x18c7', // toHex(6343)\n  [BuiltInNetworkName.MonadTestnet]: '0x279f', // toHex(10143)\n  [BuiltInNetworkName.BaseMainnet]: '0x2105', // toHex(8453)\n  [BuiltInNetworkName.ArbitrumOne]: '0xa4b1', // toHex(42161)\n  [BuiltInNetworkName.BscMainnet]: '0x38', // toHex(56)\n  [BuiltInNetworkName.OptimismMainnet]: '0xa', // toHex(10)\n  [BuiltInNetworkName.PolygonMainnet]: '0x89', // toHex(137)\n  [BuiltInNetworkName.SeiMainnet]: '0x531', // toHex(1329)\n  [BuiltInNetworkName.AvalancheMainnet]: '0xa86a', // toHex(43114)\n  [BuiltInNetworkName.HyperEVMMainnet]: '0x3e7', // toHex(999)\n  [BuiltInNetworkName.PalmMainnet]: '0x2a15c308d', // toHex(11297108109)\n  [BuiltInNetworkName.ZkSyncEraMainnet]: '0x144', // toHex(324)\n  [BuiltInNetworkName.MonadMainnet]: '0x8f', // toHex(143)\n  [BuiltInNetworkName.MegaEthMainnet]: '0x10e6', // toHex(4326)\n  // Environment 3: Power User test networks\n  [BuiltInNetworkName.FantomMainnet]: '0xfa', // toHex(250)\n  [BuiltInNetworkName.GnosisMainnet]: '0x64', // toHex(100)\n  [BuiltInNetworkName.CronosMainnet]: '0x19', // toHex(25)\n  [BuiltInNetworkName.MoonbeamMainnet]: '0x504', // toHex(1284)\n  [BuiltInNetworkName.MoonriverMainnet]: '0x505', // toHex(1285)\n} as const;\nexport type ChainId = (typeof ChainId)[keyof typeof ChainId];\n\n/* eslint-disable @typescript-eslint/naming-convention */\nexport enum NetworksTicker {\n  mainnet = 'ETH',\n  goerli = 'GoerliETH',\n  sepolia = 'SepoliaETH',\n  'linea-goerli' = 'LineaETH',\n  // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values\n  'linea-sepolia' = 'LineaETH',\n  // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values\n  'linea-mainnet' = 'ETH',\n  /**\n   * @deprecated `megaeth-testnet` is migrated to `megaeth-testnet-v2`.\n   */\n  'megaeth-testnet' = 'MegaETH',\n  // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values\n  'megaeth-testnet-v2' = 'MegaETH',\n  'monad-testnet' = 'MON',\n  // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values\n  'base-mainnet' = 'ETH',\n  // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values\n  'arbitrum-mainnet' = 'ETH',\n  'bsc-mainnet' = 'BNB',\n  // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values\n  'optimism-mainnet' = 'ETH',\n  'polygon-mainnet' = 'POL',\n  'sei-mainnet' = 'SEI',\n  'avalanche-mainnet' = 'AVAX',\n  'hyper-evm-mainnet' = 'HYPE',\n  'palm-mainnet' = 'PALM',\n  'zksync-era-mainnet' = 'ZKSYNC',\n  'monad-mainnet' = 'MONAD',\n  'megaeth-mainnet' = 'MEGAETH',\n  // Environment 3: Power User test networks\n  'fantom-mainnet' = 'FTM',\n  'gnosis-mainnet' = 'xDAI',\n  'cronos-mainnet' = 'CRO',\n  'moonbeam-mainnet' = 'GLMR',\n  'moonriver-mainnet' = 'MOVR',\n  rpc = '',\n}\n/* eslint-enable @typescript-eslint/naming-convention */\n\nexport const BlockExplorerUrl = {\n  [BuiltInNetworkName.Mainnet]: 'https://etherscan.io',\n  [BuiltInNetworkName.Goerli]: 'https://goerli.etherscan.io',\n  [BuiltInNetworkName.Sepolia]: 'https://sepolia.etherscan.io',\n  [BuiltInNetworkName.LineaGoerli]: 'https://goerli.lineascan.build',\n  [BuiltInNetworkName.LineaSepolia]: 'https://sepolia.lineascan.build',\n  [BuiltInNetworkName.LineaMainnet]: 'https://lineascan.build',\n  /**\n   * @deprecated `MegaETHTestnet` is migrated to `MegaETHTestnetV2`.\n   */\n  [BuiltInNetworkName.MegaETHTestnet]: 'https://megaexplorer.xyz',\n  [BuiltInNetworkName.MegaETHTestnetV2]:\n    'https://megaeth-testnet-v2.blockscout.com',\n  [BuiltInNetworkName.MonadTestnet]: 'https://testnet.monadexplorer.com',\n  [BuiltInNetworkName.BaseMainnet]: 'https://basescan.org',\n  [BuiltInNetworkName.ArbitrumOne]: 'https://arbiscan.io',\n  [BuiltInNetworkName.BscMainnet]: 'https://bscscan.com',\n  [BuiltInNetworkName.OptimismMainnet]: 'https://optimistic.etherscan.io',\n  [BuiltInNetworkName.PolygonMainnet]: 'https://polygonscan.com',\n  [BuiltInNetworkName.SeiMainnet]: 'https://seitrace.com/',\n  [BuiltInNetworkName.AvalancheMainnet]: 'https://snowtrace.io',\n  [BuiltInNetworkName.HyperEVMMainnet]: 'https://hyperevmscan.io/',\n  [BuiltInNetworkName.PalmMainnet]: 'https://palm.chainlens.com',\n  [BuiltInNetworkName.ZkSyncEraMainnet]: 'https://explorer.zksync.io/',\n  [BuiltInNetworkName.MonadMainnet]: 'https://monadscan.com/',\n  [BuiltInNetworkName.MegaEthMainnet]: 'https://explorer.megaeth.com',\n  // Environment 3: Power User test networks\n  [BuiltInNetworkName.FantomMainnet]: 'https://ftmscan.com',\n  [BuiltInNetworkName.GnosisMainnet]: 'https://gnosisscan.io',\n  [BuiltInNetworkName.CronosMainnet]: 'https://explorer.cronos.org',\n  [BuiltInNetworkName.MoonbeamMainnet]: 'https://moonscan.io',\n  [BuiltInNetworkName.MoonriverMainnet]: 'https://moonriver.moonscan.io',\n} as const satisfies Record<BuiltInNetworkType, string>;\nexport type BlockExplorerUrl =\n  (typeof BlockExplorerUrl)[keyof typeof BlockExplorerUrl];\n\nexport const NetworkNickname = {\n  [BuiltInNetworkName.Mainnet]: 'Ethereum Mainnet',\n  [BuiltInNetworkName.Goerli]: 'Goerli',\n  [BuiltInNetworkName.Sepolia]: 'Sepolia',\n  [BuiltInNetworkName.LineaGoerli]: 'Linea Goerli',\n  [BuiltInNetworkName.LineaSepolia]: 'Linea Sepolia',\n  [BuiltInNetworkName.LineaMainnet]: 'Linea',\n  /**\n   * @deprecated `MegaETHTestnet` is migrated to `MegaETHTestnetV2`.\n   */\n  [BuiltInNetworkName.MegaETHTestnet]: 'Mega Testnet',\n  [BuiltInNetworkName.MegaETHTestnetV2]: 'MegaETH Testnet',\n  [BuiltInNetworkName.MonadTestnet]: 'Monad Testnet',\n  [BuiltInNetworkName.BaseMainnet]: 'Base Mainnet',\n  [BuiltInNetworkName.ArbitrumOne]: 'Arbitrum One',\n  [BuiltInNetworkName.BscMainnet]: 'BSC Mainnet',\n  [BuiltInNetworkName.OptimismMainnet]: 'Optimism Mainnet',\n  [BuiltInNetworkName.PolygonMainnet]: 'Polygon Mainnet',\n  [BuiltInNetworkName.SeiMainnet]: 'Sei Mainnet',\n  [BuiltInNetworkName.AvalancheMainnet]: 'Avalanche Mainnet',\n  [BuiltInNetworkName.HyperEVMMainnet]: 'HyperEVM Mainnet',\n  [BuiltInNetworkName.PalmMainnet]: 'Palm Mainnet',\n  [BuiltInNetworkName.ZkSyncEraMainnet]: 'zkSync Era Mainnet',\n  [BuiltInNetworkName.MonadMainnet]: 'Monad Mainnet',\n  [BuiltInNetworkName.MegaEthMainnet]: 'MegaETH Mainnet',\n  // Environment 3: Power User test networks\n  [BuiltInNetworkName.FantomMainnet]: 'Fantom Opera',\n  [BuiltInNetworkName.GnosisMainnet]: 'Gnosis',\n  [BuiltInNetworkName.CronosMainnet]: 'Cronos Mainnet',\n  [BuiltInNetworkName.MoonbeamMainnet]: 'Moonbeam',\n  [BuiltInNetworkName.MoonriverMainnet]: 'Moonriver',\n} as const satisfies Record<BuiltInNetworkType, string>;\nexport type NetworkNickname =\n  (typeof NetworkNickname)[keyof typeof NetworkNickname];\n\n/**\n * Makes a selection of keys in a Record optional.\n *\n * @template Type - The Record that you want to operate on.\n * @template Key - The union of keys you want to make optional.\n */\n// TODO: Move to @metamask/utils\nexport type Partialize<Type, Key extends keyof Type> = Omit<Type, Key> &\n  Partial<Pick<Type, Key>>;\n\n/** A context in which to execute a trace, in order to generate nested timings. */\nexport type TraceContext = unknown;\n\n/** Request to trace an operation. */\nexport type TraceRequest = {\n  /** Additional data to include in the trace. */\n  data?: Record<string, number | string | boolean>;\n\n  /** Name of the operation. */\n  name: string;\n\n  /**\n   * Unique identifier for the trace.\n   * Required if starting a trace and not providing a callback.\n   */\n  id?: string;\n\n  /** Trace context in which to execute the operation. */\n  parentContext?: TraceContext;\n\n  /** Additional tags to include in the trace to filter results. */\n  tags?: Record<string, number | string | boolean>;\n};\n\n/** Callback that traces the performance of an operation. */\nexport type TraceCallback = <ReturnType>(\n  /** Request to trace the performance of an operation. */\n  request: TraceRequest,\n\n  /**\n   * Callback to trace.\n   * Thrown errors will not be caught, but the trace will still be recorded.\n   *\n   * @param context - The context in which the operation is running.\n   */\n  fn?: (context?: TraceContext) => ReturnType,\n) => Promise<ReturnType>;\n"]}
\ No newline at end of file
diff --git a/dist/types.d.cts b/dist/types.d.cts
index d16c9e022b4ec59536ea082bd12eef7ce6dcffe2..63f70f43ec03e9ac0833085bd1d53527b936c444 100644
--- a/dist/types.d.cts
+++ b/dist/types.d.cts
@@ -14,6 +14,12 @@ export declare const InfuraNetworkType: {
     readonly 'optimism-mainnet': "optimism-mainnet";
     readonly 'polygon-mainnet': "polygon-mainnet";
     readonly 'sei-mainnet': "sei-mainnet";
+    readonly 'avalanche-mainnet': "avalanche-mainnet";
+    readonly 'hyper-evm-mainnet': "hyper-evm-mainnet";
+    readonly 'palm-mainnet': "palm-mainnet";
+    readonly 'zksync-era-mainnet': "zksync-era-mainnet";
+    readonly 'monad-mainnet': "monad-mainnet";
+    readonly 'megaeth-mainnet': "megaeth-mainnet";
 };
 export type InfuraNetworkType = (typeof InfuraNetworkType)[keyof typeof InfuraNetworkType];
 /**
@@ -26,6 +32,11 @@ export declare const CustomNetworkType: {
     readonly 'megaeth-testnet': "megaeth-testnet";
     readonly 'megaeth-testnet-v2': "megaeth-testnet-v2";
     readonly 'monad-testnet': "monad-testnet";
+    readonly 'fantom-mainnet': "fantom-mainnet";
+    readonly 'gnosis-mainnet': "gnosis-mainnet";
+    readonly 'cronos-mainnet': "cronos-mainnet";
+    readonly 'moonbeam-mainnet': "moonbeam-mainnet";
+    readonly 'moonriver-mainnet': "moonriver-mainnet";
 };
 export type CustomNetworkType = (typeof CustomNetworkType)[keyof typeof CustomNetworkType];
 /**
@@ -43,6 +54,11 @@ export declare const NetworkType: {
     readonly 'megaeth-testnet': "megaeth-testnet";
     readonly 'megaeth-testnet-v2': "megaeth-testnet-v2";
     readonly 'monad-testnet': "monad-testnet";
+    readonly 'fantom-mainnet': "fantom-mainnet";
+    readonly 'gnosis-mainnet': "gnosis-mainnet";
+    readonly 'cronos-mainnet': "cronos-mainnet";
+    readonly 'moonbeam-mainnet': "moonbeam-mainnet";
+    readonly 'moonriver-mainnet': "moonriver-mainnet";
     readonly mainnet: "mainnet";
     readonly goerli: "goerli";
     readonly sepolia: "sepolia";
@@ -55,6 +71,12 @@ export declare const NetworkType: {
     readonly 'optimism-mainnet': "optimism-mainnet";
     readonly 'polygon-mainnet': "polygon-mainnet";
     readonly 'sei-mainnet': "sei-mainnet";
+    readonly 'avalanche-mainnet': "avalanche-mainnet";
+    readonly 'hyper-evm-mainnet': "hyper-evm-mainnet";
+    readonly 'palm-mainnet': "palm-mainnet";
+    readonly 'zksync-era-mainnet': "zksync-era-mainnet";
+    readonly 'monad-mainnet': "monad-mainnet";
+    readonly 'megaeth-mainnet': "megaeth-mainnet";
 };
 export type NetworkType = (typeof NetworkType)[keyof typeof NetworkType];
 /**
@@ -96,7 +118,18 @@ export declare enum BuiltInNetworkName {
     BscMainnet = "bsc-mainnet",
     OptimismMainnet = "optimism-mainnet",
     PolygonMainnet = "polygon-mainnet",
-    SeiMainnet = "sei-mainnet"
+    SeiMainnet = "sei-mainnet",
+    AvalancheMainnet = "avalanche-mainnet",
+    HyperEVMMainnet = "hyper-evm-mainnet",
+    PalmMainnet = "palm-mainnet",
+    ZkSyncEraMainnet = "zksync-era-mainnet",
+    MonadMainnet = "monad-mainnet",
+    MegaEthMainnet = "megaeth-mainnet",
+    FantomMainnet = "fantom-mainnet",
+    GnosisMainnet = "gnosis-mainnet",
+    CronosMainnet = "cronos-mainnet",
+    MoonbeamMainnet = "moonbeam-mainnet",
+    MoonriverMainnet = "moonriver-mainnet"
 }
 /**
  * Decimal string chain IDs of built-in networks, by name.
@@ -123,6 +156,17 @@ export declare const ChainId: {
     readonly "optimism-mainnet": "0xa";
     readonly "polygon-mainnet": "0x89";
     readonly "sei-mainnet": "0x531";
+    readonly "avalanche-mainnet": "0xa86a";
+    readonly "hyper-evm-mainnet": "0x3e7";
+    readonly "palm-mainnet": "0x2a15c308d";
+    readonly "zksync-era-mainnet": "0x144";
+    readonly "monad-mainnet": "0x8f";
+    readonly "megaeth-mainnet": "0x10e6";
+    readonly "fantom-mainnet": "0xfa";
+    readonly "gnosis-mainnet": "0x64";
+    readonly "cronos-mainnet": "0x19";
+    readonly "moonbeam-mainnet": "0x504";
+    readonly "moonriver-mainnet": "0x505";
 };
 export type ChainId = (typeof ChainId)[keyof typeof ChainId];
 export declare enum NetworksTicker {
@@ -144,6 +188,17 @@ export declare enum NetworksTicker {
     'optimism-mainnet' = "ETH",
     'polygon-mainnet' = "POL",
     'sei-mainnet' = "SEI",
+    'avalanche-mainnet' = "AVAX",
+    'hyper-evm-mainnet' = "HYPE",
+    'palm-mainnet' = "PALM",
+    'zksync-era-mainnet' = "ZKSYNC",
+    'monad-mainnet' = "MONAD",
+    'megaeth-mainnet' = "MEGAETH",
+    'fantom-mainnet' = "FTM",
+    'gnosis-mainnet' = "xDAI",
+    'cronos-mainnet' = "CRO",
+    'moonbeam-mainnet' = "GLMR",
+    'moonriver-mainnet' = "MOVR",
     rpc = ""
 }
 export declare const BlockExplorerUrl: {
@@ -164,7 +219,18 @@ export declare const BlockExplorerUrl: {
     readonly "bsc-mainnet": "https://bscscan.com";
     readonly "optimism-mainnet": "https://optimistic.etherscan.io";
     readonly "polygon-mainnet": "https://polygonscan.com";
-    readonly "sei-mainnet": "https://seitrace.com";
+    readonly "sei-mainnet": "https://seitrace.com/";
+    readonly "avalanche-mainnet": "https://snowtrace.io";
+    readonly "hyper-evm-mainnet": "https://hyperevmscan.io/";
+    readonly "palm-mainnet": "https://palm.chainlens.com";
+    readonly "zksync-era-mainnet": "https://explorer.zksync.io/";
+    readonly "monad-mainnet": "https://monadscan.com/";
+    readonly "megaeth-mainnet": "https://explorer.megaeth.com";
+    readonly "fantom-mainnet": "https://ftmscan.com";
+    readonly "gnosis-mainnet": "https://gnosisscan.io";
+    readonly "cronos-mainnet": "https://explorer.cronos.org";
+    readonly "moonbeam-mainnet": "https://moonscan.io";
+    readonly "moonriver-mainnet": "https://moonriver.moonscan.io";
 };
 export type BlockExplorerUrl = (typeof BlockExplorerUrl)[keyof typeof BlockExplorerUrl];
 export declare const NetworkNickname: {
@@ -186,6 +252,17 @@ export declare const NetworkNickname: {
     readonly "optimism-mainnet": "Optimism Mainnet";
     readonly "polygon-mainnet": "Polygon Mainnet";
     readonly "sei-mainnet": "Sei Mainnet";
+    readonly "avalanche-mainnet": "Avalanche Mainnet";
+    readonly "hyper-evm-mainnet": "HyperEVM Mainnet";
+    readonly "palm-mainnet": "Palm Mainnet";
+    readonly "zksync-era-mainnet": "zkSync Era Mainnet";
+    readonly "monad-mainnet": "Monad Mainnet";
+    readonly "megaeth-mainnet": "MegaETH Mainnet";
+    readonly "fantom-mainnet": "Fantom Opera";
+    readonly "gnosis-mainnet": "Gnosis";
+    readonly "cronos-mainnet": "Cronos Mainnet";
+    readonly "moonbeam-mainnet": "Moonbeam";
+    readonly "moonriver-mainnet": "Moonriver";
 };
 export type NetworkNickname = (typeof NetworkNickname)[keyof typeof NetworkNickname];
 /**
diff --git a/dist/types.d.cts.map b/dist/types.d.cts.map
index 7f569a95b78e59cd05dbaf50fdba2b72baa9a98e..a787a1ac33eef2e033213a0ff8f1b7140413a993 100644
--- a/dist/types.d.cts.map
+++ b/dist/types.d.cts.map
@@ -1 +1 @@
-{"version":3,"file":"types.d.cts","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"types.d.cts","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/types.d.mts b/dist/types.d.mts
index 5ac10af3c2e806a4a616c544cce1752af31ddccd..1cec611c6b15a0b87a17cd2d6f196283d33780ad 100644
--- a/dist/types.d.mts
+++ b/dist/types.d.mts
@@ -14,6 +14,12 @@ export declare const InfuraNetworkType: {
     readonly 'optimism-mainnet': "optimism-mainnet";
     readonly 'polygon-mainnet': "polygon-mainnet";
     readonly 'sei-mainnet': "sei-mainnet";
+    readonly 'avalanche-mainnet': "avalanche-mainnet";
+    readonly 'hyper-evm-mainnet': "hyper-evm-mainnet";
+    readonly 'palm-mainnet': "palm-mainnet";
+    readonly 'zksync-era-mainnet': "zksync-era-mainnet";
+    readonly 'monad-mainnet': "monad-mainnet";
+    readonly 'megaeth-mainnet': "megaeth-mainnet";
 };
 export type InfuraNetworkType = (typeof InfuraNetworkType)[keyof typeof InfuraNetworkType];
 /**
@@ -26,6 +32,11 @@ export declare const CustomNetworkType: {
     readonly 'megaeth-testnet': "megaeth-testnet";
     readonly 'megaeth-testnet-v2': "megaeth-testnet-v2";
     readonly 'monad-testnet': "monad-testnet";
+    readonly 'fantom-mainnet': "fantom-mainnet";
+    readonly 'gnosis-mainnet': "gnosis-mainnet";
+    readonly 'cronos-mainnet': "cronos-mainnet";
+    readonly 'moonbeam-mainnet': "moonbeam-mainnet";
+    readonly 'moonriver-mainnet': "moonriver-mainnet";
 };
 export type CustomNetworkType = (typeof CustomNetworkType)[keyof typeof CustomNetworkType];
 /**
@@ -43,6 +54,11 @@ export declare const NetworkType: {
     readonly 'megaeth-testnet': "megaeth-testnet";
     readonly 'megaeth-testnet-v2': "megaeth-testnet-v2";
     readonly 'monad-testnet': "monad-testnet";
+    readonly 'fantom-mainnet': "fantom-mainnet";
+    readonly 'gnosis-mainnet': "gnosis-mainnet";
+    readonly 'cronos-mainnet': "cronos-mainnet";
+    readonly 'moonbeam-mainnet': "moonbeam-mainnet";
+    readonly 'moonriver-mainnet': "moonriver-mainnet";
     readonly mainnet: "mainnet";
     readonly goerli: "goerli";
     readonly sepolia: "sepolia";
@@ -55,6 +71,12 @@ export declare const NetworkType: {
     readonly 'optimism-mainnet': "optimism-mainnet";
     readonly 'polygon-mainnet': "polygon-mainnet";
     readonly 'sei-mainnet': "sei-mainnet";
+    readonly 'avalanche-mainnet': "avalanche-mainnet";
+    readonly 'hyper-evm-mainnet': "hyper-evm-mainnet";
+    readonly 'palm-mainnet': "palm-mainnet";
+    readonly 'zksync-era-mainnet': "zksync-era-mainnet";
+    readonly 'monad-mainnet': "monad-mainnet";
+    readonly 'megaeth-mainnet': "megaeth-mainnet";
 };
 export type NetworkType = (typeof NetworkType)[keyof typeof NetworkType];
 /**
@@ -96,7 +118,18 @@ export declare enum BuiltInNetworkName {
     BscMainnet = "bsc-mainnet",
     OptimismMainnet = "optimism-mainnet",
     PolygonMainnet = "polygon-mainnet",
-    SeiMainnet = "sei-mainnet"
+    SeiMainnet = "sei-mainnet",
+    AvalancheMainnet = "avalanche-mainnet",
+    HyperEVMMainnet = "hyper-evm-mainnet",
+    PalmMainnet = "palm-mainnet",
+    ZkSyncEraMainnet = "zksync-era-mainnet",
+    MonadMainnet = "monad-mainnet",
+    MegaEthMainnet = "megaeth-mainnet",
+    FantomMainnet = "fantom-mainnet",
+    GnosisMainnet = "gnosis-mainnet",
+    CronosMainnet = "cronos-mainnet",
+    MoonbeamMainnet = "moonbeam-mainnet",
+    MoonriverMainnet = "moonriver-mainnet"
 }
 /**
  * Decimal string chain IDs of built-in networks, by name.
@@ -123,6 +156,17 @@ export declare const ChainId: {
     readonly "optimism-mainnet": "0xa";
     readonly "polygon-mainnet": "0x89";
     readonly "sei-mainnet": "0x531";
+    readonly "avalanche-mainnet": "0xa86a";
+    readonly "hyper-evm-mainnet": "0x3e7";
+    readonly "palm-mainnet": "0x2a15c308d";
+    readonly "zksync-era-mainnet": "0x144";
+    readonly "monad-mainnet": "0x8f";
+    readonly "megaeth-mainnet": "0x10e6";
+    readonly "fantom-mainnet": "0xfa";
+    readonly "gnosis-mainnet": "0x64";
+    readonly "cronos-mainnet": "0x19";
+    readonly "moonbeam-mainnet": "0x504";
+    readonly "moonriver-mainnet": "0x505";
 };
 export type ChainId = (typeof ChainId)[keyof typeof ChainId];
 export declare enum NetworksTicker {
@@ -144,6 +188,17 @@ export declare enum NetworksTicker {
     'optimism-mainnet' = "ETH",
     'polygon-mainnet' = "POL",
     'sei-mainnet' = "SEI",
+    'avalanche-mainnet' = "AVAX",
+    'hyper-evm-mainnet' = "HYPE",
+    'palm-mainnet' = "PALM",
+    'zksync-era-mainnet' = "ZKSYNC",
+    'monad-mainnet' = "MONAD",
+    'megaeth-mainnet' = "MEGAETH",
+    'fantom-mainnet' = "FTM",
+    'gnosis-mainnet' = "xDAI",
+    'cronos-mainnet' = "CRO",
+    'moonbeam-mainnet' = "GLMR",
+    'moonriver-mainnet' = "MOVR",
     rpc = ""
 }
 export declare const BlockExplorerUrl: {
@@ -164,7 +219,18 @@ export declare const BlockExplorerUrl: {
     readonly "bsc-mainnet": "https://bscscan.com";
     readonly "optimism-mainnet": "https://optimistic.etherscan.io";
     readonly "polygon-mainnet": "https://polygonscan.com";
-    readonly "sei-mainnet": "https://seitrace.com";
+    readonly "sei-mainnet": "https://seitrace.com/";
+    readonly "avalanche-mainnet": "https://snowtrace.io";
+    readonly "hyper-evm-mainnet": "https://hyperevmscan.io/";
+    readonly "palm-mainnet": "https://palm.chainlens.com";
+    readonly "zksync-era-mainnet": "https://explorer.zksync.io/";
+    readonly "monad-mainnet": "https://monadscan.com/";
+    readonly "megaeth-mainnet": "https://explorer.megaeth.com";
+    readonly "fantom-mainnet": "https://ftmscan.com";
+    readonly "gnosis-mainnet": "https://gnosisscan.io";
+    readonly "cronos-mainnet": "https://explorer.cronos.org";
+    readonly "moonbeam-mainnet": "https://moonscan.io";
+    readonly "moonriver-mainnet": "https://moonriver.moonscan.io";
 };
 export type BlockExplorerUrl = (typeof BlockExplorerUrl)[keyof typeof BlockExplorerUrl];
 export declare const NetworkNickname: {
@@ -186,6 +252,17 @@ export declare const NetworkNickname: {
     readonly "optimism-mainnet": "Optimism Mainnet";
     readonly "polygon-mainnet": "Polygon Mainnet";
     readonly "sei-mainnet": "Sei Mainnet";
+    readonly "avalanche-mainnet": "Avalanche Mainnet";
+    readonly "hyper-evm-mainnet": "HyperEVM Mainnet";
+    readonly "palm-mainnet": "Palm Mainnet";
+    readonly "zksync-era-mainnet": "zkSync Era Mainnet";
+    readonly "monad-mainnet": "Monad Mainnet";
+    readonly "megaeth-mainnet": "MegaETH Mainnet";
+    readonly "fantom-mainnet": "Fantom Opera";
+    readonly "gnosis-mainnet": "Gnosis";
+    readonly "cronos-mainnet": "Cronos Mainnet";
+    readonly "moonbeam-mainnet": "Moonbeam";
+    readonly "moonriver-mainnet": "Moonriver";
 };
 export type NetworkNickname = (typeof NetworkNickname)[keyof typeof NetworkNickname];
 /**
diff --git a/dist/types.d.mts.map b/dist/types.d.mts.map
index ed30889c0bcb27ec510e7edadcc1c9e09da9f17d..c47b962f919613bfb8fc212d98ad869df504d317 100644
--- a/dist/types.d.mts.map
+++ b/dist/types.d.mts.map
@@ -1 +1 @@
-{"version":3,"file":"types.d.mts","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"types.d.mts","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,eAAO,MAAM,iBAAiB;;;;;;;;;;;;;;;;;;;CAyBpB,CAAC;AAEX,MAAM,MAAM,iBAAiB,GAC3B,CAAC,OAAO,iBAAiB,CAAC,CAAC,MAAM,OAAO,iBAAiB,CAAC,CAAC;AAE7D;;GAEG;AACH,eAAO,MAAM,iBAAiB;IAC5B;;OAEG;;;;;;;;;CAUK,CAAC;AACX,MAAM,MAAM,iBAAiB,GAC3B,CAAC,OAAO,iBAAiB,CAAC,CAAC,MAAM,OAAO,iBAAiB,CAAC,CAAC;AAE7D;;GAEG;AACH,MAAM,MAAM,kBAAkB,GAAG,iBAAiB,GAAG,iBAAiB,CAAC;AAEvE;;GAEG;AACH,eAAO,MAAM,WAAW;;IAxBtB;;OAEG;;;;;;;;;;;;;;;;;;;;;;;;;;;CA0BK,CAAC;AAEX,MAAM,MAAM,WAAW,GAAG,CAAC,OAAO,WAAW,CAAC,CAAC,MAAM,OAAO,WAAW,CAAC,CAAC;AAEzE;;;;;GAKG;AACH,wBAAgB,aAAa,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,IAAI,WAAW,CAE7D;AAED;;;;;;GAMG;AACH,wBAAgB,mBAAmB,CACjC,KAAK,EAAE,OAAO,GACb,KAAK,IAAI,iBAAiB,CAG5B;AAED;;;;GAIG;AACH,oBAAY,kBAAkB;IAC5B,OAAO,YAAY;IACnB,MAAM,WAAW;IACjB,OAAO,YAAY;IACnB,WAAW,iBAAiB;IAC5B,YAAY,kBAAkB;IAC9B,YAAY,kBAAkB;IAC9B,MAAM,WAAW;IACjB;;OAEG;IACH,cAAc,oBAAoB;IAClC,gBAAgB,uBAAuB;IACvC,YAAY,kBAAkB;IAC9B,WAAW,iBAAiB;IAC5B,WAAW,qBAAqB;IAChC,UAAU,gBAAgB;IAC1B,eAAe,qBAAqB;IACpC,cAAc,oBAAoB;IAClC,UAAU,gBAAgB;IAC1B,gBAAgB,sBAAsB;IACtC,eAAe,sBAAsB;IACrC,WAAW,iBAAiB;IAC5B,gBAAgB,uBAAuB;IACvC,YAAY,kBAAkB;IAC9B,cAAc,oBAAoB;IAElC,aAAa,mBAAmB;IAChC,aAAa,mBAAmB;IAChC,aAAa,mBAAmB;IAChC,eAAe,qBAAqB;IACpC,gBAAgB,sBAAsB;CACvC;AAED;;;;GAIG;AACH,eAAO,MAAM,OAAO;;;;;;;;IAQlB;;OAEG;;;;;;;;;;;;;;;;;;;;;CAsBK,CAAC;AACX,MAAM,MAAM,OAAO,GAAG,CAAC,OAAO,OAAO,CAAC,CAAC,MAAM,OAAO,OAAO,CAAC,CAAC;AAG7D,oBAAY,cAAc;IACxB,OAAO,QAAQ;IACf,MAAM,cAAc;IACpB,OAAO,eAAe;IACtB,cAAc,aAAa;IAE3B,eAAe,aAAa;IAE5B,eAAe,QAAQ;IACvB;;OAEG;IACH,iBAAiB,YAAY;IAE7B,oBAAoB,YAAY;IAChC,eAAe,QAAQ;IAEvB,cAAc,QAAQ;IAEtB,kBAAkB,QAAQ;IAC1B,aAAa,QAAQ;IAErB,kBAAkB,QAAQ;IAC1B,iBAAiB,QAAQ;IACzB,aAAa,QAAQ;IACrB,mBAAmB,SAAS;IAC5B,mBAAmB,SAAS;IAC5B,cAAc,SAAS;IACvB,oBAAoB,WAAW;IAC/B,eAAe,UAAU;IACzB,iBAAiB,YAAY;IAE7B,gBAAgB,QAAQ;IACxB,gBAAgB,SAAS;IACzB,gBAAgB,QAAQ;IACxB,kBAAkB,SAAS;IAC3B,mBAAmB,SAAS;IAC5B,GAAG,KAAK;CACT;AAGD,eAAO,MAAM,gBAAgB;;;;;;;IAO3B;;OAEG;;;;;;;;;;;;;;;;;;;;;CAuBkD,CAAC;AACxD,MAAM,MAAM,gBAAgB,GAC1B,CAAC,OAAO,gBAAgB,CAAC,CAAC,MAAM,OAAO,gBAAgB,CAAC,CAAC;AAE3D,eAAO,MAAM,eAAe;;;;;;;IAO1B;;OAEG;;;;;;;;;;;;;;;;;;;;;CAsBkD,CAAC;AACxD,MAAM,MAAM,eAAe,GACzB,CAAC,OAAO,eAAe,CAAC,CAAC,MAAM,OAAO,eAAe,CAAC,CAAC;AAEzD;;;;;GAKG;AAEH,MAAM,MAAM,UAAU,CAAC,IAAI,EAAE,GAAG,SAAS,MAAM,IAAI,IAAI,IAAI,CAAC,IAAI,EAAE,GAAG,CAAC,GACpE,OAAO,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC,CAAC;AAE3B,kFAAkF;AAClF,MAAM,MAAM,YAAY,GAAG,OAAO,CAAC;AAEnC,qCAAqC;AACrC,MAAM,MAAM,YAAY,GAAG;IACzB,+CAA+C;IAC/C,IAAI,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,GAAG,MAAM,GAAG,OAAO,CAAC,CAAC;IAEjD,6BAA6B;IAC7B,IAAI,EAAE,MAAM,CAAC;IAEb;;;OAGG;IACH,EAAE,CAAC,EAAE,MAAM,CAAC;IAEZ,uDAAuD;IACvD,aAAa,CAAC,EAAE,YAAY,CAAC;IAE7B,iEAAiE;IACjE,IAAI,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,GAAG,MAAM,GAAG,OAAO,CAAC,CAAC;CAClD,CAAC;AAEF,4DAA4D;AAC5D,MAAM,MAAM,aAAa,GAAG,CAAC,UAAU;AACrC,wDAAwD;AACxD,OAAO,EAAE,YAAY;AAErB;;;;;GAKG;AACH,EAAE,CAAC,EAAE,CAAC,OAAO,CAAC,EAAE,YAAY,KAAK,UAAU,KACxC,OAAO,CAAC,UAAU,CAAC,CAAC"}
\ No newline at end of file
diff --git a/dist/types.mjs b/dist/types.mjs
index 5a82bed786b4f83196acf0153867aa214ff2d7d2..f1f7851eb1bc7adb6f990d3eaf536043fcafe9ff 100644
--- a/dist/types.mjs
+++ b/dist/types.mjs
@@ -14,6 +14,18 @@ export const InfuraNetworkType = {
     'optimism-mainnet': 'optimism-mainnet',
     'polygon-mainnet': 'polygon-mainnet',
     'sei-mainnet': 'sei-mainnet',
+    // Avalanche
+    'avalanche-mainnet': 'avalanche-mainnet',
+    // HyperEVM
+    'hyper-evm-mainnet': 'hyper-evm-mainnet',
+    // Palm
+    'palm-mainnet': 'palm-mainnet',
+    // zkSync Era
+    'zksync-era-mainnet': 'zksync-era-mainnet',
+    // Monad
+    'monad-mainnet': 'monad-mainnet',
+    // MegaEth
+    'megaeth-mainnet': 'megaeth-mainnet',
 };
 /**
  * Custom network types that are not part of Infura.
@@ -25,6 +37,12 @@ export const CustomNetworkType = {
     'megaeth-testnet': 'megaeth-testnet',
     'megaeth-testnet-v2': 'megaeth-testnet-v2',
     'monad-testnet': 'monad-testnet',
+    // Environment 3: Power User test networks
+    'fantom-mainnet': 'fantom-mainnet',
+    'gnosis-mainnet': 'gnosis-mainnet',
+    'cronos-mainnet': 'cronos-mainnet',
+    'moonbeam-mainnet': 'moonbeam-mainnet',
+    'moonriver-mainnet': 'moonriver-mainnet',
 };
 /**
  * The "network type"; either the name of a built-in network, or "rpc" for custom networks.
@@ -80,6 +98,18 @@ export var BuiltInNetworkName;
     BuiltInNetworkName["OptimismMainnet"] = "optimism-mainnet";
     BuiltInNetworkName["PolygonMainnet"] = "polygon-mainnet";
     BuiltInNetworkName["SeiMainnet"] = "sei-mainnet";
+    BuiltInNetworkName["AvalancheMainnet"] = "avalanche-mainnet";
+    BuiltInNetworkName["HyperEVMMainnet"] = "hyper-evm-mainnet";
+    BuiltInNetworkName["PalmMainnet"] = "palm-mainnet";
+    BuiltInNetworkName["ZkSyncEraMainnet"] = "zksync-era-mainnet";
+    BuiltInNetworkName["MonadMainnet"] = "monad-mainnet";
+    BuiltInNetworkName["MegaEthMainnet"] = "megaeth-mainnet";
+    // Environment 3: Power User test networks
+    BuiltInNetworkName["FantomMainnet"] = "fantom-mainnet";
+    BuiltInNetworkName["GnosisMainnet"] = "gnosis-mainnet";
+    BuiltInNetworkName["CronosMainnet"] = "cronos-mainnet";
+    BuiltInNetworkName["MoonbeamMainnet"] = "moonbeam-mainnet";
+    BuiltInNetworkName["MoonriverMainnet"] = "moonriver-mainnet";
 })(BuiltInNetworkName || (BuiltInNetworkName = {}));
 /**
  * Decimal string chain IDs of built-in networks, by name.
@@ -106,6 +136,18 @@ export const ChainId = {
     [BuiltInNetworkName.OptimismMainnet]: '0xa', // toHex(10)
     [BuiltInNetworkName.PolygonMainnet]: '0x89', // toHex(137)
     [BuiltInNetworkName.SeiMainnet]: '0x531', // toHex(1329)
+    [BuiltInNetworkName.AvalancheMainnet]: '0xa86a', // toHex(43114)
+    [BuiltInNetworkName.HyperEVMMainnet]: '0x3e7', // toHex(999)
+    [BuiltInNetworkName.PalmMainnet]: '0x2a15c308d', // toHex(11297108109)
+    [BuiltInNetworkName.ZkSyncEraMainnet]: '0x144', // toHex(324)
+    [BuiltInNetworkName.MonadMainnet]: '0x8f', // toHex(143)
+    [BuiltInNetworkName.MegaEthMainnet]: '0x10e6', // toHex(4326)
+    // Environment 3: Power User test networks
+    [BuiltInNetworkName.FantomMainnet]: '0xfa', // toHex(250)
+    [BuiltInNetworkName.GnosisMainnet]: '0x64', // toHex(100)
+    [BuiltInNetworkName.CronosMainnet]: '0x19', // toHex(25)
+    [BuiltInNetworkName.MoonbeamMainnet]: '0x504', // toHex(1284)
+    [BuiltInNetworkName.MoonriverMainnet]: '0x505', // toHex(1285)
 };
 /* eslint-disable @typescript-eslint/naming-convention */
 export var NetworksTicker;
@@ -134,6 +176,18 @@ export var NetworksTicker;
     NetworksTicker["optimism-mainnet"] = "ETH";
     NetworksTicker["polygon-mainnet"] = "POL";
     NetworksTicker["sei-mainnet"] = "SEI";
+    NetworksTicker["avalanche-mainnet"] = "AVAX";
+    NetworksTicker["hyper-evm-mainnet"] = "HYPE";
+    NetworksTicker["palm-mainnet"] = "PALM";
+    NetworksTicker["zksync-era-mainnet"] = "ZKSYNC";
+    NetworksTicker["monad-mainnet"] = "MONAD";
+    NetworksTicker["megaeth-mainnet"] = "MEGAETH";
+    // Environment 3: Power User test networks
+    NetworksTicker["fantom-mainnet"] = "FTM";
+    NetworksTicker["gnosis-mainnet"] = "xDAI";
+    NetworksTicker["cronos-mainnet"] = "CRO";
+    NetworksTicker["moonbeam-mainnet"] = "GLMR";
+    NetworksTicker["moonriver-mainnet"] = "MOVR";
     NetworksTicker["rpc"] = "";
 })(NetworksTicker || (NetworksTicker = {}));
 /* eslint-enable @typescript-eslint/naming-convention */
@@ -155,7 +209,19 @@ export const BlockExplorerUrl = {
     [BuiltInNetworkName.BscMainnet]: 'https://bscscan.com',
     [BuiltInNetworkName.OptimismMainnet]: 'https://optimistic.etherscan.io',
     [BuiltInNetworkName.PolygonMainnet]: 'https://polygonscan.com',
-    [BuiltInNetworkName.SeiMainnet]: 'https://seitrace.com',
+    [BuiltInNetworkName.SeiMainnet]: 'https://seitrace.com/',
+    [BuiltInNetworkName.AvalancheMainnet]: 'https://snowtrace.io',
+    [BuiltInNetworkName.HyperEVMMainnet]: 'https://hyperevmscan.io/',
+    [BuiltInNetworkName.PalmMainnet]: 'https://palm.chainlens.com',
+    [BuiltInNetworkName.ZkSyncEraMainnet]: 'https://explorer.zksync.io/',
+    [BuiltInNetworkName.MonadMainnet]: 'https://monadscan.com/',
+    [BuiltInNetworkName.MegaEthMainnet]: 'https://explorer.megaeth.com',
+    // Environment 3: Power User test networks
+    [BuiltInNetworkName.FantomMainnet]: 'https://ftmscan.com',
+    [BuiltInNetworkName.GnosisMainnet]: 'https://gnosisscan.io',
+    [BuiltInNetworkName.CronosMainnet]: 'https://explorer.cronos.org',
+    [BuiltInNetworkName.MoonbeamMainnet]: 'https://moonscan.io',
+    [BuiltInNetworkName.MoonriverMainnet]: 'https://moonriver.moonscan.io',
 };
 export const NetworkNickname = {
     [BuiltInNetworkName.Mainnet]: 'Ethereum Mainnet',
@@ -176,5 +242,17 @@ export const NetworkNickname = {
     [BuiltInNetworkName.OptimismMainnet]: 'Optimism Mainnet',
     [BuiltInNetworkName.PolygonMainnet]: 'Polygon Mainnet',
     [BuiltInNetworkName.SeiMainnet]: 'Sei Mainnet',
+    [BuiltInNetworkName.AvalancheMainnet]: 'Avalanche Mainnet',
+    [BuiltInNetworkName.HyperEVMMainnet]: 'HyperEVM Mainnet',
+    [BuiltInNetworkName.PalmMainnet]: 'Palm Mainnet',
+    [BuiltInNetworkName.ZkSyncEraMainnet]: 'zkSync Era Mainnet',
+    [BuiltInNetworkName.MonadMainnet]: 'Monad Mainnet',
+    [BuiltInNetworkName.MegaEthMainnet]: 'MegaETH Mainnet',
+    // Environment 3: Power User test networks
+    [BuiltInNetworkName.FantomMainnet]: 'Fantom Opera',
+    [BuiltInNetworkName.GnosisMainnet]: 'Gnosis',
+    [BuiltInNetworkName.CronosMainnet]: 'Cronos Mainnet',
+    [BuiltInNetworkName.MoonbeamMainnet]: 'Moonbeam',
+    [BuiltInNetworkName.MoonriverMainnet]: 'Moonriver',
 };
 //# sourceMappingURL=types.mjs.map
\ No newline at end of file
diff --git a/dist/types.mjs.map b/dist/types.mjs.map
index a3dc009c9602d3d909ee1d5e8b1f62325a26bd6c..fe50d01176bafd76663c11887d90646af9fb07d0 100644
--- a/dist/types.mjs.map
+++ b/dist/types.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"types.mjs","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * The names of built-in Infura networks\n */\nexport const InfuraNetworkType = {\n  mainnet: 'mainnet',\n  goerli: 'goerli',\n  sepolia: 'sepolia',\n  'linea-goerli': 'linea-goerli',\n  'linea-sepolia': 'linea-sepolia',\n  'linea-mainnet': 'linea-mainnet',\n  'base-mainnet': 'base-mainnet',\n  'arbitrum-mainnet': 'arbitrum-mainnet',\n  'bsc-mainnet': 'bsc-mainnet',\n  'optimism-mainnet': 'optimism-mainnet',\n  'polygon-mainnet': 'polygon-mainnet',\n  'sei-mainnet': 'sei-mainnet',\n} as const;\n\nexport type InfuraNetworkType =\n  (typeof InfuraNetworkType)[keyof typeof InfuraNetworkType];\n\n/**\n * Custom network types that are not part of Infura.\n */\nexport const CustomNetworkType = {\n  /**\n   * @deprecated `megaeth-testnet` is migrated to `megaeth-testnet-v2`.\n   */\n  'megaeth-testnet': 'megaeth-testnet',\n  'megaeth-testnet-v2': 'megaeth-testnet-v2',\n  'monad-testnet': 'monad-testnet',\n} as const;\nexport type CustomNetworkType =\n  (typeof CustomNetworkType)[keyof typeof CustomNetworkType];\n\n/**\n * Network types supported including both Infura networks and other networks.\n */\nexport type BuiltInNetworkType = InfuraNetworkType | CustomNetworkType;\n\n/**\n * The \"network type\"; either the name of a built-in network, or \"rpc\" for custom networks.\n */\nexport const NetworkType = {\n  ...InfuraNetworkType,\n  ...CustomNetworkType,\n  rpc: 'rpc',\n} as const;\n\nexport type NetworkType = (typeof NetworkType)[keyof typeof NetworkType];\n\n/**\n * A helper to determine whether a given input is NetworkType.\n *\n * @param val - the value to check whether it is NetworkType or not.\n * @returns boolean indicating whether or not the argument is NetworkType.\n */\nexport function isNetworkType(val: string): val is NetworkType {\n  return Object.values(NetworkType).includes(val as NetworkType);\n}\n\n/**\n * A type guard to determine whether the input is an InfuraNetworkType.\n *\n * @param value - The value to check.\n * @returns True if the given value is within the InfuraNetworkType enum,\n * false otherwise.\n */\nexport function isInfuraNetworkType(\n  value: unknown,\n): value is InfuraNetworkType {\n  const infuraNetworkTypes: unknown[] = Object.keys(InfuraNetworkType);\n  return infuraNetworkTypes.includes(value);\n}\n\n/**\n * Names of networks built into the wallet.\n *\n * This includes both Infura and non-Infura networks.\n */\nexport enum BuiltInNetworkName {\n  Mainnet = 'mainnet',\n  Goerli = 'goerli',\n  Sepolia = 'sepolia',\n  LineaGoerli = 'linea-goerli',\n  LineaSepolia = 'linea-sepolia',\n  LineaMainnet = 'linea-mainnet',\n  Aurora = 'aurora',\n  /**\n   * @deprecated `MegaETHTestnet` is migrated to `MegaETHTestnetV2`.\n   */\n  MegaETHTestnet = 'megaeth-testnet',\n  MegaETHTestnetV2 = 'megaeth-testnet-v2',\n  MonadTestnet = 'monad-testnet',\n  BaseMainnet = 'base-mainnet',\n  ArbitrumOne = 'arbitrum-mainnet',\n  BscMainnet = 'bsc-mainnet',\n  OptimismMainnet = 'optimism-mainnet',\n  PolygonMainnet = 'polygon-mainnet',\n  SeiMainnet = 'sei-mainnet',\n}\n\n/**\n * Decimal string chain IDs of built-in networks, by name.\n *\n * `toHex` not invoked to avoid cyclic dependency\n */\nexport const ChainId = {\n  [BuiltInNetworkName.Mainnet]: '0x1', // toHex(1)\n  [BuiltInNetworkName.Goerli]: '0x5', // toHex(5)\n  [BuiltInNetworkName.Sepolia]: '0xaa36a7', // toHex(11155111)\n  [BuiltInNetworkName.Aurora]: '0x4e454152', // toHex(1313161554)\n  [BuiltInNetworkName.LineaGoerli]: '0xe704', // toHex(59140)\n  [BuiltInNetworkName.LineaSepolia]: '0xe705', // toHex(59141)\n  [BuiltInNetworkName.LineaMainnet]: '0xe708', // toHex(59144)\n  /**\n   * @deprecated `MegaETHTestnet` is migrated to `MegaETHTestnetV2`.\n   */\n  [BuiltInNetworkName.MegaETHTestnet]: '0x18c6', // toHex(6342)\n  [BuiltInNetworkName.MegaETHTestnetV2]: '0x18c7', // toHex(6343)\n  [BuiltInNetworkName.MonadTestnet]: '0x279f', // toHex(10143)\n  [BuiltInNetworkName.BaseMainnet]: '0x2105', // toHex(8453)\n  [BuiltInNetworkName.ArbitrumOne]: '0xa4b1', // toHex(42161)\n  [BuiltInNetworkName.BscMainnet]: '0x38', // toHex(56)\n  [BuiltInNetworkName.OptimismMainnet]: '0xa', // toHex(10)\n  [BuiltInNetworkName.PolygonMainnet]: '0x89', // toHex(137)\n  [BuiltInNetworkName.SeiMainnet]: '0x531', // toHex(1329)\n} as const;\nexport type ChainId = (typeof ChainId)[keyof typeof ChainId];\n\n/* eslint-disable @typescript-eslint/naming-convention */\nexport enum NetworksTicker {\n  mainnet = 'ETH',\n  goerli = 'GoerliETH',\n  sepolia = 'SepoliaETH',\n  'linea-goerli' = 'LineaETH',\n  // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values\n  'linea-sepolia' = 'LineaETH',\n  // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values\n  'linea-mainnet' = 'ETH',\n  /**\n   * @deprecated `megaeth-testnet` is migrated to `megaeth-testnet-v2`.\n   */\n  'megaeth-testnet' = 'MegaETH',\n  // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values\n  'megaeth-testnet-v2' = 'MegaETH',\n  'monad-testnet' = 'MON',\n  // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values\n  'base-mainnet' = 'ETH',\n  // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values\n  'arbitrum-mainnet' = 'ETH',\n  'bsc-mainnet' = 'BNB',\n  // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values\n  'optimism-mainnet' = 'ETH',\n  'polygon-mainnet' = 'POL',\n  'sei-mainnet' = 'SEI',\n  rpc = '',\n}\n/* eslint-enable @typescript-eslint/naming-convention */\n\nexport const BlockExplorerUrl = {\n  [BuiltInNetworkName.Mainnet]: 'https://etherscan.io',\n  [BuiltInNetworkName.Goerli]: 'https://goerli.etherscan.io',\n  [BuiltInNetworkName.Sepolia]: 'https://sepolia.etherscan.io',\n  [BuiltInNetworkName.LineaGoerli]: 'https://goerli.lineascan.build',\n  [BuiltInNetworkName.LineaSepolia]: 'https://sepolia.lineascan.build',\n  [BuiltInNetworkName.LineaMainnet]: 'https://lineascan.build',\n  /**\n   * @deprecated `MegaETHTestnet` is migrated to `MegaETHTestnetV2`.\n   */\n  [BuiltInNetworkName.MegaETHTestnet]: 'https://megaexplorer.xyz',\n  [BuiltInNetworkName.MegaETHTestnetV2]:\n    'https://megaeth-testnet-v2.blockscout.com',\n  [BuiltInNetworkName.MonadTestnet]: 'https://testnet.monadexplorer.com',\n  [BuiltInNetworkName.BaseMainnet]: 'https://basescan.org',\n  [BuiltInNetworkName.ArbitrumOne]: 'https://arbiscan.io',\n  [BuiltInNetworkName.BscMainnet]: 'https://bscscan.com',\n  [BuiltInNetworkName.OptimismMainnet]: 'https://optimistic.etherscan.io',\n  [BuiltInNetworkName.PolygonMainnet]: 'https://polygonscan.com',\n  [BuiltInNetworkName.SeiMainnet]: 'https://seitrace.com',\n} as const satisfies Record<BuiltInNetworkType, string>;\nexport type BlockExplorerUrl =\n  (typeof BlockExplorerUrl)[keyof typeof BlockExplorerUrl];\n\nexport const NetworkNickname = {\n  [BuiltInNetworkName.Mainnet]: 'Ethereum Mainnet',\n  [BuiltInNetworkName.Goerli]: 'Goerli',\n  [BuiltInNetworkName.Sepolia]: 'Sepolia',\n  [BuiltInNetworkName.LineaGoerli]: 'Linea Goerli',\n  [BuiltInNetworkName.LineaSepolia]: 'Linea Sepolia',\n  [BuiltInNetworkName.LineaMainnet]: 'Linea',\n  /**\n   * @deprecated `MegaETHTestnet` is migrated to `MegaETHTestnetV2`.\n   */\n  [BuiltInNetworkName.MegaETHTestnet]: 'Mega Testnet',\n  [BuiltInNetworkName.MegaETHTestnetV2]: 'MegaETH Testnet',\n  [BuiltInNetworkName.MonadTestnet]: 'Monad Testnet',\n  [BuiltInNetworkName.BaseMainnet]: 'Base Mainnet',\n  [BuiltInNetworkName.ArbitrumOne]: 'Arbitrum One',\n  [BuiltInNetworkName.BscMainnet]: 'BSC Mainnet',\n  [BuiltInNetworkName.OptimismMainnet]: 'Optimism Mainnet',\n  [BuiltInNetworkName.PolygonMainnet]: 'Polygon Mainnet',\n  [BuiltInNetworkName.SeiMainnet]: 'Sei Mainnet',\n} as const satisfies Record<BuiltInNetworkType, string>;\nexport type NetworkNickname =\n  (typeof NetworkNickname)[keyof typeof NetworkNickname];\n\n/**\n * Makes a selection of keys in a Record optional.\n *\n * @template Type - The Record that you want to operate on.\n * @template Key - The union of keys you want to make optional.\n */\n// TODO: Move to @metamask/utils\nexport type Partialize<Type, Key extends keyof Type> = Omit<Type, Key> &\n  Partial<Pick<Type, Key>>;\n\n/** A context in which to execute a trace, in order to generate nested timings. */\nexport type TraceContext = unknown;\n\n/** Request to trace an operation. */\nexport type TraceRequest = {\n  /** Additional data to include in the trace. */\n  data?: Record<string, number | string | boolean>;\n\n  /** Name of the operation. */\n  name: string;\n\n  /**\n   * Unique identifier for the trace.\n   * Required if starting a trace and not providing a callback.\n   */\n  id?: string;\n\n  /** Trace context in which to execute the operation. */\n  parentContext?: TraceContext;\n\n  /** Additional tags to include in the trace to filter results. */\n  tags?: Record<string, number | string | boolean>;\n};\n\n/** Callback that traces the performance of an operation. */\nexport type TraceCallback = <ReturnType>(\n  /** Request to trace the performance of an operation. */\n  request: TraceRequest,\n\n  /**\n   * Callback to trace.\n   * Thrown errors will not be caught, but the trace will still be recorded.\n   *\n   * @param context - The context in which the operation is running.\n   */\n  fn?: (context?: TraceContext) => ReturnType,\n) => Promise<ReturnType>;\n"]}
\ No newline at end of file
+{"version":3,"file":"types.mjs","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * The names of built-in Infura networks\n */\nexport const InfuraNetworkType = {\n  mainnet: 'mainnet',\n  goerli: 'goerli',\n  sepolia: 'sepolia',\n  'linea-goerli': 'linea-goerli',\n  'linea-sepolia': 'linea-sepolia',\n  'linea-mainnet': 'linea-mainnet',\n  'base-mainnet': 'base-mainnet',\n  'arbitrum-mainnet': 'arbitrum-mainnet',\n  'bsc-mainnet': 'bsc-mainnet',\n  'optimism-mainnet': 'optimism-mainnet',\n  'polygon-mainnet': 'polygon-mainnet',\n  'sei-mainnet': 'sei-mainnet',\n  // Avalanche\n  'avalanche-mainnet': 'avalanche-mainnet',\n  // HyperEVM\n  'hyper-evm-mainnet': 'hyper-evm-mainnet',\n  // Palm\n  'palm-mainnet': 'palm-mainnet',\n  // zkSync Era\n  'zksync-era-mainnet': 'zksync-era-mainnet',\n  // Monad\n  'monad-mainnet': 'monad-mainnet',\n  // MegaEth\n  'megaeth-mainnet': 'megaeth-mainnet',\n} as const;\n\nexport type InfuraNetworkType =\n  (typeof InfuraNetworkType)[keyof typeof InfuraNetworkType];\n\n/**\n * Custom network types that are not part of Infura.\n */\nexport const CustomNetworkType = {\n  /**\n   * @deprecated `megaeth-testnet` is migrated to `megaeth-testnet-v2`.\n   */\n  'megaeth-testnet': 'megaeth-testnet',\n  'megaeth-testnet-v2': 'megaeth-testnet-v2',\n  'monad-testnet': 'monad-testnet',\n  // Environment 3: Power User test networks\n  'fantom-mainnet': 'fantom-mainnet',\n  'gnosis-mainnet': 'gnosis-mainnet',\n  'cronos-mainnet': 'cronos-mainnet',\n  'moonbeam-mainnet': 'moonbeam-mainnet',\n  'moonriver-mainnet': 'moonriver-mainnet',\n} as const;\nexport type CustomNetworkType =\n  (typeof CustomNetworkType)[keyof typeof CustomNetworkType];\n\n/**\n * Network types supported including both Infura networks and other networks.\n */\nexport type BuiltInNetworkType = InfuraNetworkType | CustomNetworkType;\n\n/**\n * The \"network type\"; either the name of a built-in network, or \"rpc\" for custom networks.\n */\nexport const NetworkType = {\n  ...InfuraNetworkType,\n  ...CustomNetworkType,\n  rpc: 'rpc',\n} as const;\n\nexport type NetworkType = (typeof NetworkType)[keyof typeof NetworkType];\n\n/**\n * A helper to determine whether a given input is NetworkType.\n *\n * @param val - the value to check whether it is NetworkType or not.\n * @returns boolean indicating whether or not the argument is NetworkType.\n */\nexport function isNetworkType(val: string): val is NetworkType {\n  return Object.values(NetworkType).includes(val as NetworkType);\n}\n\n/**\n * A type guard to determine whether the input is an InfuraNetworkType.\n *\n * @param value - The value to check.\n * @returns True if the given value is within the InfuraNetworkType enum,\n * false otherwise.\n */\nexport function isInfuraNetworkType(\n  value: unknown,\n): value is InfuraNetworkType {\n  const infuraNetworkTypes: unknown[] = Object.keys(InfuraNetworkType);\n  return infuraNetworkTypes.includes(value);\n}\n\n/**\n * Names of networks built into the wallet.\n *\n * This includes both Infura and non-Infura networks.\n */\nexport enum BuiltInNetworkName {\n  Mainnet = 'mainnet',\n  Goerli = 'goerli',\n  Sepolia = 'sepolia',\n  LineaGoerli = 'linea-goerli',\n  LineaSepolia = 'linea-sepolia',\n  LineaMainnet = 'linea-mainnet',\n  Aurora = 'aurora',\n  /**\n   * @deprecated `MegaETHTestnet` is migrated to `MegaETHTestnetV2`.\n   */\n  MegaETHTestnet = 'megaeth-testnet',\n  MegaETHTestnetV2 = 'megaeth-testnet-v2',\n  MonadTestnet = 'monad-testnet',\n  BaseMainnet = 'base-mainnet',\n  ArbitrumOne = 'arbitrum-mainnet',\n  BscMainnet = 'bsc-mainnet',\n  OptimismMainnet = 'optimism-mainnet',\n  PolygonMainnet = 'polygon-mainnet',\n  SeiMainnet = 'sei-mainnet',\n  AvalancheMainnet = 'avalanche-mainnet',\n  HyperEVMMainnet = 'hyper-evm-mainnet',\n  PalmMainnet = 'palm-mainnet',\n  ZkSyncEraMainnet = 'zksync-era-mainnet',\n  MonadMainnet = 'monad-mainnet',\n  MegaEthMainnet = 'megaeth-mainnet',\n  // Environment 3: Power User test networks\n  FantomMainnet = 'fantom-mainnet',\n  GnosisMainnet = 'gnosis-mainnet',\n  CronosMainnet = 'cronos-mainnet',\n  MoonbeamMainnet = 'moonbeam-mainnet',\n  MoonriverMainnet = 'moonriver-mainnet',\n}\n\n/**\n * Decimal string chain IDs of built-in networks, by name.\n *\n * `toHex` not invoked to avoid cyclic dependency\n */\nexport const ChainId = {\n  [BuiltInNetworkName.Mainnet]: '0x1', // toHex(1)\n  [BuiltInNetworkName.Goerli]: '0x5', // toHex(5)\n  [BuiltInNetworkName.Sepolia]: '0xaa36a7', // toHex(11155111)\n  [BuiltInNetworkName.Aurora]: '0x4e454152', // toHex(1313161554)\n  [BuiltInNetworkName.LineaGoerli]: '0xe704', // toHex(59140)\n  [BuiltInNetworkName.LineaSepolia]: '0xe705', // toHex(59141)\n  [BuiltInNetworkName.LineaMainnet]: '0xe708', // toHex(59144)\n  /**\n   * @deprecated `MegaETHTestnet` is migrated to `MegaETHTestnetV2`.\n   */\n  [BuiltInNetworkName.MegaETHTestnet]: '0x18c6', // toHex(6342)\n  [BuiltInNetworkName.MegaETHTestnetV2]: '0x18c7', // toHex(6343)\n  [BuiltInNetworkName.MonadTestnet]: '0x279f', // toHex(10143)\n  [BuiltInNetworkName.BaseMainnet]: '0x2105', // toHex(8453)\n  [BuiltInNetworkName.ArbitrumOne]: '0xa4b1', // toHex(42161)\n  [BuiltInNetworkName.BscMainnet]: '0x38', // toHex(56)\n  [BuiltInNetworkName.OptimismMainnet]: '0xa', // toHex(10)\n  [BuiltInNetworkName.PolygonMainnet]: '0x89', // toHex(137)\n  [BuiltInNetworkName.SeiMainnet]: '0x531', // toHex(1329)\n  [BuiltInNetworkName.AvalancheMainnet]: '0xa86a', // toHex(43114)\n  [BuiltInNetworkName.HyperEVMMainnet]: '0x3e7', // toHex(999)\n  [BuiltInNetworkName.PalmMainnet]: '0x2a15c308d', // toHex(11297108109)\n  [BuiltInNetworkName.ZkSyncEraMainnet]: '0x144', // toHex(324)\n  [BuiltInNetworkName.MonadMainnet]: '0x8f', // toHex(143)\n  [BuiltInNetworkName.MegaEthMainnet]: '0x10e6', // toHex(4326)\n  // Environment 3: Power User test networks\n  [BuiltInNetworkName.FantomMainnet]: '0xfa', // toHex(250)\n  [BuiltInNetworkName.GnosisMainnet]: '0x64', // toHex(100)\n  [BuiltInNetworkName.CronosMainnet]: '0x19', // toHex(25)\n  [BuiltInNetworkName.MoonbeamMainnet]: '0x504', // toHex(1284)\n  [BuiltInNetworkName.MoonriverMainnet]: '0x505', // toHex(1285)\n} as const;\nexport type ChainId = (typeof ChainId)[keyof typeof ChainId];\n\n/* eslint-disable @typescript-eslint/naming-convention */\nexport enum NetworksTicker {\n  mainnet = 'ETH',\n  goerli = 'GoerliETH',\n  sepolia = 'SepoliaETH',\n  'linea-goerli' = 'LineaETH',\n  // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values\n  'linea-sepolia' = 'LineaETH',\n  // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values\n  'linea-mainnet' = 'ETH',\n  /**\n   * @deprecated `megaeth-testnet` is migrated to `megaeth-testnet-v2`.\n   */\n  'megaeth-testnet' = 'MegaETH',\n  // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values\n  'megaeth-testnet-v2' = 'MegaETH',\n  'monad-testnet' = 'MON',\n  // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values\n  'base-mainnet' = 'ETH',\n  // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values\n  'arbitrum-mainnet' = 'ETH',\n  'bsc-mainnet' = 'BNB',\n  // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values\n  'optimism-mainnet' = 'ETH',\n  'polygon-mainnet' = 'POL',\n  'sei-mainnet' = 'SEI',\n  'avalanche-mainnet' = 'AVAX',\n  'hyper-evm-mainnet' = 'HYPE',\n  'palm-mainnet' = 'PALM',\n  'zksync-era-mainnet' = 'ZKSYNC',\n  'monad-mainnet' = 'MONAD',\n  'megaeth-mainnet' = 'MEGAETH',\n  // Environment 3: Power User test networks\n  'fantom-mainnet' = 'FTM',\n  'gnosis-mainnet' = 'xDAI',\n  'cronos-mainnet' = 'CRO',\n  'moonbeam-mainnet' = 'GLMR',\n  'moonriver-mainnet' = 'MOVR',\n  rpc = '',\n}\n/* eslint-enable @typescript-eslint/naming-convention */\n\nexport const BlockExplorerUrl = {\n  [BuiltInNetworkName.Mainnet]: 'https://etherscan.io',\n  [BuiltInNetworkName.Goerli]: 'https://goerli.etherscan.io',\n  [BuiltInNetworkName.Sepolia]: 'https://sepolia.etherscan.io',\n  [BuiltInNetworkName.LineaGoerli]: 'https://goerli.lineascan.build',\n  [BuiltInNetworkName.LineaSepolia]: 'https://sepolia.lineascan.build',\n  [BuiltInNetworkName.LineaMainnet]: 'https://lineascan.build',\n  /**\n   * @deprecated `MegaETHTestnet` is migrated to `MegaETHTestnetV2`.\n   */\n  [BuiltInNetworkName.MegaETHTestnet]: 'https://megaexplorer.xyz',\n  [BuiltInNetworkName.MegaETHTestnetV2]:\n    'https://megaeth-testnet-v2.blockscout.com',\n  [BuiltInNetworkName.MonadTestnet]: 'https://testnet.monadexplorer.com',\n  [BuiltInNetworkName.BaseMainnet]: 'https://basescan.org',\n  [BuiltInNetworkName.ArbitrumOne]: 'https://arbiscan.io',\n  [BuiltInNetworkName.BscMainnet]: 'https://bscscan.com',\n  [BuiltInNetworkName.OptimismMainnet]: 'https://optimistic.etherscan.io',\n  [BuiltInNetworkName.PolygonMainnet]: 'https://polygonscan.com',\n  [BuiltInNetworkName.SeiMainnet]: 'https://seitrace.com/',\n  [BuiltInNetworkName.AvalancheMainnet]: 'https://snowtrace.io',\n  [BuiltInNetworkName.HyperEVMMainnet]: 'https://hyperevmscan.io/',\n  [BuiltInNetworkName.PalmMainnet]: 'https://palm.chainlens.com',\n  [BuiltInNetworkName.ZkSyncEraMainnet]: 'https://explorer.zksync.io/',\n  [BuiltInNetworkName.MonadMainnet]: 'https://monadscan.com/',\n  [BuiltInNetworkName.MegaEthMainnet]: 'https://explorer.megaeth.com',\n  // Environment 3: Power User test networks\n  [BuiltInNetworkName.FantomMainnet]: 'https://ftmscan.com',\n  [BuiltInNetworkName.GnosisMainnet]: 'https://gnosisscan.io',\n  [BuiltInNetworkName.CronosMainnet]: 'https://explorer.cronos.org',\n  [BuiltInNetworkName.MoonbeamMainnet]: 'https://moonscan.io',\n  [BuiltInNetworkName.MoonriverMainnet]: 'https://moonriver.moonscan.io',\n} as const satisfies Record<BuiltInNetworkType, string>;\nexport type BlockExplorerUrl =\n  (typeof BlockExplorerUrl)[keyof typeof BlockExplorerUrl];\n\nexport const NetworkNickname = {\n  [BuiltInNetworkName.Mainnet]: 'Ethereum Mainnet',\n  [BuiltInNetworkName.Goerli]: 'Goerli',\n  [BuiltInNetworkName.Sepolia]: 'Sepolia',\n  [BuiltInNetworkName.LineaGoerli]: 'Linea Goerli',\n  [BuiltInNetworkName.LineaSepolia]: 'Linea Sepolia',\n  [BuiltInNetworkName.LineaMainnet]: 'Linea',\n  /**\n   * @deprecated `MegaETHTestnet` is migrated to `MegaETHTestnetV2`.\n   */\n  [BuiltInNetworkName.MegaETHTestnet]: 'Mega Testnet',\n  [BuiltInNetworkName.MegaETHTestnetV2]: 'MegaETH Testnet',\n  [BuiltInNetworkName.MonadTestnet]: 'Monad Testnet',\n  [BuiltInNetworkName.BaseMainnet]: 'Base Mainnet',\n  [BuiltInNetworkName.ArbitrumOne]: 'Arbitrum One',\n  [BuiltInNetworkName.BscMainnet]: 'BSC Mainnet',\n  [BuiltInNetworkName.OptimismMainnet]: 'Optimism Mainnet',\n  [BuiltInNetworkName.PolygonMainnet]: 'Polygon Mainnet',\n  [BuiltInNetworkName.SeiMainnet]: 'Sei Mainnet',\n  [BuiltInNetworkName.AvalancheMainnet]: 'Avalanche Mainnet',\n  [BuiltInNetworkName.HyperEVMMainnet]: 'HyperEVM Mainnet',\n  [BuiltInNetworkName.PalmMainnet]: 'Palm Mainnet',\n  [BuiltInNetworkName.ZkSyncEraMainnet]: 'zkSync Era Mainnet',\n  [BuiltInNetworkName.MonadMainnet]: 'Monad Mainnet',\n  [BuiltInNetworkName.MegaEthMainnet]: 'MegaETH Mainnet',\n  // Environment 3: Power User test networks\n  [BuiltInNetworkName.FantomMainnet]: 'Fantom Opera',\n  [BuiltInNetworkName.GnosisMainnet]: 'Gnosis',\n  [BuiltInNetworkName.CronosMainnet]: 'Cronos Mainnet',\n  [BuiltInNetworkName.MoonbeamMainnet]: 'Moonbeam',\n  [BuiltInNetworkName.MoonriverMainnet]: 'Moonriver',\n} as const satisfies Record<BuiltInNetworkType, string>;\nexport type NetworkNickname =\n  (typeof NetworkNickname)[keyof typeof NetworkNickname];\n\n/**\n * Makes a selection of keys in a Record optional.\n *\n * @template Type - The Record that you want to operate on.\n * @template Key - The union of keys you want to make optional.\n */\n// TODO: Move to @metamask/utils\nexport type Partialize<Type, Key extends keyof Type> = Omit<Type, Key> &\n  Partial<Pick<Type, Key>>;\n\n/** A context in which to execute a trace, in order to generate nested timings. */\nexport type TraceContext = unknown;\n\n/** Request to trace an operation. */\nexport type TraceRequest = {\n  /** Additional data to include in the trace. */\n  data?: Record<string, number | string | boolean>;\n\n  /** Name of the operation. */\n  name: string;\n\n  /**\n   * Unique identifier for the trace.\n   * Required if starting a trace and not providing a callback.\n   */\n  id?: string;\n\n  /** Trace context in which to execute the operation. */\n  parentContext?: TraceContext;\n\n  /** Additional tags to include in the trace to filter results. */\n  tags?: Record<string, number | string | boolean>;\n};\n\n/** Callback that traces the performance of an operation. */\nexport type TraceCallback = <ReturnType>(\n  /** Request to trace the performance of an operation. */\n  request: TraceRequest,\n\n  /**\n   * Callback to trace.\n   * Thrown errors will not be caught, but the trace will still be recorded.\n   *\n   * @param context - The context in which the operation is running.\n   */\n  fn?: (context?: TraceContext) => ReturnType,\n) => Promise<ReturnType>;\n"]}
\ No newline at end of file
diff --git a/jest.config.js b/jest.config.js
new file mode 100644
index 0000000000000000000000000000000000000000..8e0bb5320db6a5e586dc8823dbbdba182bf6ef19
--- /dev/null
+++ b/jest.config.js
@@ -0,0 +1,29 @@
+/*
+ * For a detailed explanation regarding each configuration property and type check, visit:
+ * https://jestjs.io/docs/configuration
+ */
+
+const merge = require('deepmerge');
+const path = require('path');
+
+const baseConfig = require('../../jest.config.packages');
+
+const displayName = path.basename(__dirname);
+
+module.exports = merge(baseConfig, {
+  // The display name when running multiple projects
+  displayName,
+
+  // An object that configures minimum threshold enforcement for coverage results
+  coverageThreshold: {
+    global: {
+      branches: 78.12,
+      functions: 77.58,
+      lines: 87.3,
+      statements: 86.5,
+    },
+  },
+
+  // We rely on `window` to make requests
+  testEnvironment: '<rootDir>/jest.environment.js',
+});
diff --git a/jest.environment.js b/jest.environment.js
new file mode 100644
index 0000000000000000000000000000000000000000..e53bbe624dfea899b333d6f5c53b2e1e30ff91cd
--- /dev/null
+++ b/jest.environment.js
@@ -0,0 +1,19 @@
+const JSDOMEnvironment = require('jest-environment-jsdom');
+
+// Custom test environment copied from https://github.com/jsdom/jsdom/issues/2524
+// in order to add TextEncoder to jsdom. TextEncoder is expected by @noble/hashes.
+
+module.exports = class CustomTestEnvironment extends JSDOMEnvironment {
+  async setup() {
+    await super.setup();
+    if (typeof this.global.TextEncoder === 'undefined') {
+      // Needed for the JSDOM environment.
+      // eslint-disable-next-line no-shadow, n/prefer-global/text-encoder, n/prefer-global/text-decoder
+      const { TextEncoder, TextDecoder } = require('util');
+      this.global.TextEncoder = TextEncoder;
+      this.global.TextDecoder = TextDecoder;
+      this.global.ArrayBuffer = ArrayBuffer;
+      this.global.Uint8Array = Uint8Array;
+    }
+  }
+};
diff --git a/src/constants.ts b/src/constants.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f669b95ab9d668d3dc74d9042099c774271b4ffb
--- /dev/null
+++ b/src/constants.ts
@@ -0,0 +1,394 @@
+import {
+  NetworkType,
+  NetworksTicker,
+  ChainId,
+  BuiltInNetworkName,
+  BlockExplorerUrl,
+} from './types';
+
+export const RPC = 'rpc';
+export const FALL_BACK_VS_CURRENCY = 'ETH';
+export const IPFS_DEFAULT_GATEWAY_URL = 'https://cloudflare-ipfs.com/ipfs/';
+
+// NETWORKS ID
+// `toHex` not invoked to avoid cyclic dependency
+export const GANACHE_CHAIN_ID = '0x539'; // toHex(1337)
+/**
+ * The largest possible chain ID we can handle.
+ * Explanation: https://gist.github.com/rekmarks/a47bd5f2525936c4b8eee31a16345553
+ */
+export const MAX_SAFE_CHAIN_ID = 4503599627370476;
+
+// TOKEN STANDARDS
+export const ERC721 = 'ERC721';
+export const ERC1155 = 'ERC1155';
+export const ERC20 = 'ERC20';
+
+// TOKEN INTERFACE IDS
+export const ERC721_INTERFACE_ID = '0x80ac58cd';
+export const ERC721_METADATA_INTERFACE_ID = '0x5b5e139f';
+export const ERC721_ENUMERABLE_INTERFACE_ID = '0x780e9d63';
+export const ERC1155_INTERFACE_ID = '0xd9b67a26';
+export const ERC1155_METADATA_URI_INTERFACE_ID = '0x0e89341c';
+export const ERC1155_TOKEN_RECEIVER_INTERFACE_ID = '0x4e2312e0';
+
+// UNITS
+export const GWEI = 'gwei';
+
+// ASSET TYPES
+export const ASSET_TYPES = {
+  NATIVE: 'NATIVE',
+  TOKEN: 'TOKEN',
+  NFT: 'NFT',
+  UNKNOWN: 'UNKNOWN',
+};
+
+// TICKER SYMBOLS
+export const TESTNET_TICKER_SYMBOLS = {
+  GOERLI: 'GoerliETH',
+  SEPOLIA: 'SepoliaETH',
+  LINEA_GOERLI: 'LineaETH',
+  LINEA_SEPOLIA: 'LineaETH',
+  MEGAETH_TESTNET: 'MegaETH',
+  MEGAETH_TESTNET_V2: 'MegaETH',
+};
+
+/**
+ * Map of all built-in custom networks to their RPC endpoints.
+ */
+export const BUILT_IN_CUSTOM_NETWORKS_RPC = {
+  /**
+   * @deprecated Please use `megaeth-testnet` instead.
+   */
+  MEGAETH_TESTNET: 'https://carrot.megaeth.com/rpc',
+  /**
+   * @deprecated Please use `megaeth-testnet-v2` instead.
+   */
+  'megaeth-testnet': 'https://carrot.megaeth.com/rpc',
+  'megaeth-testnet-v2': 'https://carrot.megaeth.com/rpc',
+  'monad-testnet': 'https://testnet-rpc.monad.xyz',
+  // Mainnet networks with custom RPC URLs
+  'hyper-evm-mainnet': 'https://rpc.hyperliquid.xyz/evm',
+  'zksync-era-mainnet': 'https://mainnet.era.zksync.io',
+  'megaeth-mainnet': 'https://mainnet.megaeth.com/rpc',
+  // Environment 3: Power User test networks
+  'fantom-mainnet': 'https://rpcapi.fantom.network',
+  'gnosis-mainnet': 'https://gnosis-mainnet.public.blastapi.io',
+  'cronos-mainnet': 'https://evm.cronos.org',
+  'moonbeam-mainnet': 'https://rpc.api.moonbeam.network',
+  'moonriver-mainnet': 'https://rpc.api.moonriver.moonbeam.network',
+};
+
+/**
+ * Map of all build-in Infura networks to their network, ticker and chain IDs.
+ */
+export const BUILT_IN_NETWORKS = {
+  [NetworkType.goerli]: {
+    chainId: ChainId.goerli,
+    ticker: NetworksTicker.goerli,
+    rpcPrefs: {
+      blockExplorerUrl: BlockExplorerUrl.goerli,
+    },
+  },
+  [NetworkType.sepolia]: {
+    chainId: ChainId.sepolia,
+    ticker: NetworksTicker.sepolia,
+    rpcPrefs: {
+      blockExplorerUrl: BlockExplorerUrl.sepolia,
+    },
+  },
+  [NetworkType.mainnet]: {
+    chainId: ChainId.mainnet,
+    ticker: NetworksTicker.mainnet,
+    rpcPrefs: {
+      blockExplorerUrl: BlockExplorerUrl.mainnet,
+    },
+  },
+  [NetworkType['linea-goerli']]: {
+    chainId: ChainId['linea-goerli'],
+    ticker: NetworksTicker['linea-goerli'],
+    rpcPrefs: {
+      blockExplorerUrl: BlockExplorerUrl['linea-goerli'],
+    },
+  },
+  [NetworkType['linea-sepolia']]: {
+    chainId: ChainId['linea-sepolia'],
+    ticker: NetworksTicker['linea-sepolia'],
+    rpcPrefs: {
+      blockExplorerUrl: BlockExplorerUrl['linea-sepolia'],
+    },
+  },
+  [NetworkType['linea-mainnet']]: {
+    chainId: ChainId['linea-mainnet'],
+    ticker: NetworksTicker['linea-mainnet'],
+    rpcPrefs: {
+      blockExplorerUrl: BlockExplorerUrl['linea-mainnet'],
+    },
+  },
+  [NetworkType['megaeth-testnet']]: {
+    chainId: ChainId['megaeth-testnet'],
+    ticker: NetworksTicker['megaeth-testnet'],
+    rpcPrefs: {
+      blockExplorerUrl: BlockExplorerUrl['megaeth-testnet'],
+    },
+  },
+  [NetworkType['megaeth-testnet-v2']]: {
+    chainId: ChainId['megaeth-testnet-v2'],
+    ticker: NetworksTicker['megaeth-testnet-v2'],
+    rpcPrefs: {
+      blockExplorerUrl: BlockExplorerUrl['megaeth-testnet-v2'],
+    },
+  },
+  [NetworkType['monad-testnet']]: {
+    chainId: ChainId['monad-testnet'],
+    ticker: NetworksTicker['monad-testnet'],
+    rpcPrefs: {
+      blockExplorerUrl: BlockExplorerUrl['monad-testnet'],
+    },
+  },
+  [NetworkType['base-mainnet']]: {
+    chainId: ChainId['base-mainnet'],
+    ticker: NetworksTicker['base-mainnet'],
+    rpcPrefs: {
+      blockExplorerUrl: BlockExplorerUrl['base-mainnet'],
+    },
+  },
+  [NetworkType['arbitrum-mainnet']]: {
+    chainId: ChainId['arbitrum-mainnet'],
+    ticker: NetworksTicker['arbitrum-mainnet'],
+    rpcPrefs: {
+      blockExplorerUrl: BlockExplorerUrl['arbitrum-mainnet'],
+    },
+  },
+  [NetworkType['bsc-mainnet']]: {
+    chainId: ChainId['bsc-mainnet'],
+    ticker: NetworksTicker['bsc-mainnet'],
+    rpcPrefs: {
+      blockExplorerUrl: BlockExplorerUrl['bsc-mainnet'],
+    },
+  },
+  [NetworkType['optimism-mainnet']]: {
+    chainId: ChainId['optimism-mainnet'],
+    ticker: NetworksTicker['optimism-mainnet'],
+    rpcPrefs: {
+      blockExplorerUrl: BlockExplorerUrl['optimism-mainnet'],
+    },
+  },
+  [NetworkType['polygon-mainnet']]: {
+    chainId: ChainId['polygon-mainnet'],
+    ticker: NetworksTicker['polygon-mainnet'],
+    rpcPrefs: {
+      blockExplorerUrl: BlockExplorerUrl['polygon-mainnet'],
+    },
+  },
+  [NetworkType['sei-mainnet']]: {
+    chainId: ChainId['sei-mainnet'],
+    ticker: NetworksTicker['sei-mainnet'],
+    rpcPrefs: {
+      blockExplorerUrl: BlockExplorerUrl['sei-mainnet'],
+    },
+  },
+  // Avalanche
+  [NetworkType['avalanche-mainnet']]: {
+    chainId: ChainId['avalanche-mainnet'],
+    ticker: NetworksTicker['avalanche-mainnet'],
+    rpcPrefs: {
+      blockExplorerUrl: BlockExplorerUrl['avalanche-mainnet'],
+    },
+  },
+  // HyperEVM
+  [NetworkType['hyper-evm-mainnet']]: {
+    chainId: ChainId['hyper-evm-mainnet'],
+    ticker: NetworksTicker['hyper-evm-mainnet'],
+    rpcPrefs: {
+      blockExplorerUrl: BlockExplorerUrl['hyper-evm-mainnet'],
+    },
+  },
+  // Palm
+  [NetworkType['palm-mainnet']]: {
+    chainId: ChainId['palm-mainnet'],
+    ticker: NetworksTicker['palm-mainnet'],
+    rpcPrefs: {
+      blockExplorerUrl: BlockExplorerUrl['palm-mainnet'],
+    },
+  },
+  // zkSync Era
+  [NetworkType['zksync-era-mainnet']]: {
+    chainId: ChainId['zksync-era-mainnet'],
+    ticker: NetworksTicker['zksync-era-mainnet'],
+    rpcPrefs: {
+      blockExplorerUrl: BlockExplorerUrl['zksync-era-mainnet'],
+    },
+  },
+  // Monad
+  [NetworkType['monad-mainnet']]: {
+    chainId: ChainId['monad-mainnet'],
+    ticker: NetworksTicker['monad-mainnet'],
+    rpcPrefs: {
+      blockExplorerUrl: BlockExplorerUrl['monad-mainnet'],
+    },
+  },
+  // MegaEth
+  [NetworkType['megaeth-mainnet']]: {
+    chainId: ChainId['megaeth-mainnet'],
+    ticker: NetworksTicker['megaeth-mainnet'],
+    rpcPrefs: {
+      blockExplorerUrl: BlockExplorerUrl['megaeth-mainnet'],
+    },
+  },
+  // Environment 3: Power User test networks
+  [NetworkType['fantom-mainnet']]: {
+    chainId: ChainId['fantom-mainnet'],
+    ticker: NetworksTicker['fantom-mainnet'],
+    rpcPrefs: {
+      blockExplorerUrl: BlockExplorerUrl['fantom-mainnet'],
+    },
+  },
+  [NetworkType['gnosis-mainnet']]: {
+    chainId: ChainId['gnosis-mainnet'],
+    ticker: NetworksTicker['gnosis-mainnet'],
+    rpcPrefs: {
+      blockExplorerUrl: BlockExplorerUrl['gnosis-mainnet'],
+    },
+  },
+  [NetworkType['cronos-mainnet']]: {
+    chainId: ChainId['cronos-mainnet'],
+    ticker: NetworksTicker['cronos-mainnet'],
+    rpcPrefs: {
+      blockExplorerUrl: BlockExplorerUrl['cronos-mainnet'],
+    },
+  },
+  [NetworkType['moonbeam-mainnet']]: {
+    chainId: ChainId['moonbeam-mainnet'],
+    ticker: NetworksTicker['moonbeam-mainnet'],
+    rpcPrefs: {
+      blockExplorerUrl: BlockExplorerUrl['moonbeam-mainnet'],
+    },
+  },
+  [NetworkType['moonriver-mainnet']]: {
+    chainId: ChainId['moonriver-mainnet'],
+    ticker: NetworksTicker['moonriver-mainnet'],
+    rpcPrefs: {
+      blockExplorerUrl: BlockExplorerUrl['moonriver-mainnet'],
+    },
+  },
+  [NetworkType.rpc]: {
+    chainId: undefined,
+    blockExplorerUrl: undefined,
+    ticker: undefined,
+    rpcPrefs: undefined,
+  },
+} as const;
+
+/**
+ * When a user adds a custom network to MetaMask, we perform some basic
+ * validations on the network. For instance, usually a network cannot share the
+ * same chain as another. In some cases, however, we want to allow networks that
+ * would normally be invalid. This mapping contains networks that should bypass
+ * validation.
+ */
+export const NETWORKS_BYPASSING_VALIDATION = {
+  // HyperEVM uses the same chain ID as Wanchain
+  '0x3e7': {
+    name: 'HyperEVM',
+    symbol: 'HYPE',
+    rpcUrl: 'https://rpc.hyperliquid.xyz/evm',
+  },
+};
+
+// APIs
+export const OPENSEA_PROXY_URL =
+  'https://proxy.api.cx.metamask.io/opensea/v1/api/v2';
+
+export const NFT_API_BASE_URL = 'https://nft.api.cx.metamask.io';
+
+export const NFT_API_VERSION = '1';
+
+export const NFT_API_TIMEOUT = 15000;
+
+// Default origin for controllers
+export const ORIGIN_METAMASK = 'metamask';
+
+/**
+ * Approval request types for various operations.
+ * These types are used by different controllers to create and manage
+ * approval requests consistently.
+ */
+export enum ApprovalType {
+  AddEthereumChain = 'wallet_addEthereumChain',
+  ConnectAccounts = 'connect_accounts',
+  EthDecrypt = 'eth_decrypt',
+  EthGetEncryptionPublicKey = 'eth_getEncryptionPublicKey',
+  EthSignTypedData = 'eth_signTypedData',
+  PersonalSign = 'personal_sign',
+  ResultError = 'result_error',
+  ResultSuccess = 'result_success',
+  SnapDialogAlert = 'snap_dialog:alert',
+  SnapDialogConfirmation = 'snap_dialog:confirmation',
+  SnapDialogPrompt = 'snap_dialog:prompt',
+  SnapDialogDefault = 'snap_dialog',
+  SwitchEthereumChain = 'wallet_switchEthereumChain',
+  Transaction = 'transaction',
+  TransactionBatch = 'transaction_batch',
+  Unlock = 'unlock',
+  WalletConnect = 'wallet_connect',
+  WalletRequestPermissions = 'wallet_requestPermissions',
+  WatchAsset = 'wallet_watchAsset',
+}
+
+/**
+ * Mapping of chain IDs to their network names for ENS functionality.
+ * Note: MegaETH-testnet is intentionally excluded from this mapping as it doesn't support ENS.
+ */
+export const CHAIN_ID_TO_ETHERS_NETWORK_NAME_MAP: Record<
+  string,
+  BuiltInNetworkName
+> = {
+  [ChainId.goerli]: BuiltInNetworkName.Goerli,
+  [ChainId.sepolia]: BuiltInNetworkName.Sepolia,
+  [ChainId.mainnet]: BuiltInNetworkName.Mainnet,
+  [ChainId['linea-goerli']]: BuiltInNetworkName.LineaGoerli,
+  [ChainId['linea-sepolia']]: BuiltInNetworkName.LineaSepolia,
+  [ChainId['linea-mainnet']]: BuiltInNetworkName.LineaMainnet,
+  [ChainId.aurora]: BuiltInNetworkName.Aurora,
+};
+
+/**
+ * The number of milliseconds in a second.
+ */
+export const SECOND = 1000;
+
+/**
+ * The number of milliseconds in a second.
+ */
+export const SECONDS = SECOND;
+
+/**
+ * The number of milliseconds in a minute.
+ */
+export const MINUTE = SECONDS * 60;
+
+/**
+ * The number of milliseconds in a minute.
+ */
+export const MINUTES = MINUTE;
+
+/**
+ * The number of milliseconds in a hour.
+ */
+export const HOUR = MINUTES * 60;
+
+/**
+ * The number of milliseconds in a hour.
+ */
+export const HOURS = HOUR;
+
+/**
+ * The number of milliseconds in a day.
+ */
+export const DAY = HOURS * 24;
+
+/**
+ * The number of milliseconds in a day.
+ */
+export const DAYS = DAY;
diff --git a/src/create-service-policy.test.ts b/src/create-service-policy.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11efc7fe909ee7720c7f94c8b4593ef043c76c09
--- /dev/null
+++ b/src/create-service-policy.test.ts
@@ -0,0 +1,3569 @@
+import { CircuitState, handleWhen } from 'cockatiel';
+import { useFakeTimers } from 'sinon';
+import type { SinonFakeTimers } from 'sinon';
+
+import {
+  createServicePolicy,
+  DEFAULT_CIRCUIT_BREAK_DURATION,
+  DEFAULT_DEGRADED_THRESHOLD,
+  DEFAULT_MAX_CONSECUTIVE_FAILURES,
+  DEFAULT_MAX_RETRIES,
+} from './create-service-policy';
+
+describe('createServicePolicy', () => {
+  let clock: SinonFakeTimers;
+
+  beforeEach(() => {
+    clock = useFakeTimers();
+  });
+
+  afterEach(() => {
+    clock.restore();
+  });
+
+  describe('wrapping a service that succeeds on the first try', () => {
+    it('returns a policy that returns what the service returns', async () => {
+      const mockService = jest.fn(() => ({ some: 'data' }));
+      const policy = createServicePolicy();
+
+      const returnValue = await policy.execute(mockService);
+
+      expect(returnValue).toStrictEqual({ some: 'data' });
+    });
+
+    it('only calls the service once before returning', async () => {
+      const mockService = jest.fn();
+      const policy = createServicePolicy();
+
+      await policy.execute(mockService);
+
+      expect(mockService).toHaveBeenCalledTimes(1);
+    });
+
+    it('does not call onBreak listeners, since the circuit never opens', async () => {
+      const mockService = jest.fn();
+      const onBreakListener = jest.fn();
+      const policy = createServicePolicy();
+
+      policy.onBreak(onBreakListener);
+
+      await policy.execute(mockService);
+
+      expect(onBreakListener).not.toHaveBeenCalled();
+    });
+
+    describe.each([
+      {
+        desc: `the default degraded threshold (${DEFAULT_DEGRADED_THRESHOLD})`,
+        threshold: DEFAULT_DEGRADED_THRESHOLD,
+        options: {},
+      },
+      {
+        desc: 'a custom degraded threshold',
+        threshold: 2000,
+        options: { degradedThreshold: 2000 },
+      },
+    ])('using $desc', ({ threshold, options }) => {
+      describe('if the service execution time is below the threshold', () => {
+        it('does not call onDegraded listeners', async () => {
+          const mockService = jest.fn();
+          const onDegradedListener = jest.fn();
+          const policy = createServicePolicy(options);
+          policy.onDegraded(onDegradedListener);
+
+          await policy.execute(mockService);
+
+          expect(onDegradedListener).not.toHaveBeenCalled();
+        });
+
+        it('calls onAvailable listeners once, even if the service is called more than once', async () => {
+          const mockService = jest.fn();
+          const onAvailableListener = jest.fn();
+          const policy = createServicePolicy(options);
+          policy.onAvailable(onAvailableListener);
+
+          await policy.execute(mockService);
+          await policy.execute(mockService);
+
+          expect(onAvailableListener).toHaveBeenCalledTimes(1);
+        });
+      });
+
+      describe('if the service execution time is beyond the threshold', () => {
+        it('calls onDegraded listeners once', async () => {
+          const delay = threshold + 1;
+          const mockService = jest.fn(() => {
+            return new Promise<void>((resolve) => {
+              setTimeout(() => resolve(), delay);
+            });
+          });
+          const onDegradedListener = jest.fn();
+          const policy = createServicePolicy(options);
+          policy.onDegraded(onDegradedListener);
+
+          const promise = policy.execute(mockService);
+          clock.tick(delay);
+          await promise;
+
+          expect(onDegradedListener).toHaveBeenCalledTimes(1);
+        });
+
+        it('does not call onAvailable listeners', async () => {
+          const delay = threshold + 1;
+          const mockService = jest.fn(() => {
+            return new Promise<void>((resolve) => {
+              setTimeout(() => resolve(), delay);
+            });
+          });
+          const onAvailableListener = jest.fn();
+          const policy = createServicePolicy(options);
+          policy.onAvailable(onAvailableListener);
+
+          const promise = policy.execute(mockService);
+          clock.tick(delay);
+          await promise;
+
+          expect(onAvailableListener).not.toHaveBeenCalled();
+        });
+      });
+    });
+  });
+
+  describe('wrapping a service that always fails', () => {
+    describe('if a custom retry filter policy is given and the retry filter policy filters out the thrown error', () => {
+      it('throws what the service throws', async () => {
+        const error = new Error('failure');
+        const mockService = jest.fn(() => {
+          throw error;
+        });
+        const policy = createServicePolicy({
+          retryFilterPolicy: handleWhen(
+            (caughtError) => caughtError.message !== 'failure',
+          ),
+        });
+
+        const promise = policy.execute(mockService);
+
+        await expect(promise).rejects.toThrow(error);
+      });
+
+      it('calls the service once and only once', async () => {
+        const error = new Error('failure');
+        const mockService = jest.fn(() => {
+          throw error;
+        });
+        const policy = createServicePolicy({
+          retryFilterPolicy: handleWhen(
+            (caughtError) => caughtError.message !== 'failure',
+          ),
+        });
+
+        const promise = policy.execute(mockService);
+        await ignoreRejection(promise);
+
+        expect(mockService).toHaveBeenCalledTimes(1);
+      });
+
+      it('does not call onRetry listeners', async () => {
+        const error = new Error('failure');
+        const mockService = jest.fn(() => {
+          throw error;
+        });
+        const onRetryListener = jest.fn();
+        const policy = createServicePolicy({
+          retryFilterPolicy: handleWhen(
+            (caughtError) => caughtError.message !== 'failure',
+          ),
+        });
+        policy.onRetry(onRetryListener);
+
+        const promise = policy.execute(mockService);
+        await ignoreRejection(promise);
+
+        expect(onRetryListener).not.toHaveBeenCalled();
+      });
+
+      it('does not call onBreak listeners', async () => {
+        const error = new Error('failure');
+        const mockService = jest.fn(() => {
+          throw error;
+        });
+        const onBreakListener = jest.fn();
+        const policy = createServicePolicy({
+          retryFilterPolicy: handleWhen(
+            (caughtError) => caughtError.message !== 'failure',
+          ),
+        });
+
+        policy.onBreak(onBreakListener);
+
+        const promise = policy.execute(mockService);
+        // It's safe not to await this promise; adding it to the promise queue
+        // is enough to prevent this test from running indefinitely.
+        // eslint-disable-next-line @typescript-eslint/no-floating-promises
+        clock.runAllAsync();
+        await ignoreRejection(promise);
+
+        expect(onBreakListener).not.toHaveBeenCalled();
+      });
+
+      it('does not call onDegraded listeners', async () => {
+        const error = new Error('failure');
+        const mockService = jest.fn(() => {
+          throw error;
+        });
+        const onDegradedListener = jest.fn();
+        const policy = createServicePolicy({
+          retryFilterPolicy: handleWhen(
+            (caughtError) => caughtError.message !== 'failure',
+          ),
+        });
+        policy.onDegraded(onDegradedListener);
+
+        const promise = policy.execute(mockService);
+        // It's safe not to await this promise; adding it to the promise queue
+        // is enough to prevent this test from running indefinitely.
+        // eslint-disable-next-line @typescript-eslint/no-floating-promises
+        clock.runAllAsync();
+        await ignoreRejection(promise);
+
+        expect(onDegradedListener).not.toHaveBeenCalled();
+      });
+
+      it('does not call onAvailable listeners', async () => {
+        const error = new Error('failure');
+        const mockService = jest.fn(() => {
+          throw error;
+        });
+        const onAvailableListener = jest.fn();
+        const policy = createServicePolicy({
+          retryFilterPolicy: handleWhen(
+            (caughtError) => caughtError.message !== 'failure',
+          ),
+        });
+        policy.onAvailable(onAvailableListener);
+
+        const promise = policy.execute(mockService);
+        // It's safe not to await this promise; adding it to the promise queue
+        // is enough to prevent this test from running indefinitely.
+        // eslint-disable-next-line @typescript-eslint/no-floating-promises
+        clock.runAllAsync();
+        await ignoreRejection(promise);
+
+        expect(onAvailableListener).not.toHaveBeenCalled();
+      });
+    });
+
+    describe('using the default retry filter policy (which retries all errors)', () => {
+      describe(`using the default max retries (${DEFAULT_MAX_RETRIES})`, () => {
+        it(`calls the service a total of ${
+          1 + DEFAULT_MAX_RETRIES
+        } times, delaying each retry using a backoff formula`, async () => {
+          const error = new Error('failure');
+          const mockService = jest.fn(() => {
+            throw error;
+          });
+          const policy = createServicePolicy();
+          // Each retry delay is randomized using a decorrelated jitter formula,
+          // so we need to prevent that
+          jest.spyOn(Math, 'random').mockReturnValue(0);
+
+          const promise = policy.execute(mockService);
+          // It's safe not to await these promises; adding them to the promise
+          // queue is enough to prevent this test from running indefinitely.
+          // eslint-disable-next-line @typescript-eslint/no-floating-promises
+          clock.tickAsync(0);
+          // eslint-disable-next-line @typescript-eslint/no-floating-promises
+          clock.tickAsync(176.27932892814937);
+          // eslint-disable-next-line @typescript-eslint/no-floating-promises
+          clock.tickAsync(186.8886145345685);
+          await ignoreRejection(promise);
+
+          expect(mockService).toHaveBeenCalledTimes(1 + DEFAULT_MAX_RETRIES);
+        });
+
+        it('calls onRetry listeners once per retry', async () => {
+          const error = new Error('failure');
+          const mockService = jest.fn(() => {
+            throw error;
+          });
+          const onRetryListener = jest.fn();
+          const policy = createServicePolicy();
+          policy.onRetry(onRetryListener);
+
+          const promise = policy.execute(mockService);
+          // It's safe not to await this promise; adding it to the promise queue is
+          // enough to prevent this test from running indefinitely.
+          // eslint-disable-next-line @typescript-eslint/no-floating-promises
+          clock.runAllAsync();
+          await ignoreRejection(promise);
+
+          expect(onRetryListener).toHaveBeenCalledTimes(DEFAULT_MAX_RETRIES);
+        });
+
+        describe(`using the default max number of consecutive failures (${DEFAULT_MAX_CONSECUTIVE_FAILURES})`, () => {
+          it('throws what the service throws', async () => {
+            const error = new Error('failure');
+            const mockService = jest.fn(() => {
+              throw error;
+            });
+            const policy = createServicePolicy();
+
+            const promise = policy.execute(mockService);
+            // It's safe not to await this promise; adding it to the promise
+            // queue is enough to prevent this test from running indefinitely.
+            // eslint-disable-next-line @typescript-eslint/no-floating-promises
+            clock.runAllAsync();
+
+            await expect(promise).rejects.toThrow(error);
+          });
+
+          it('does not call onBreak listeners, since the max number of consecutive failures is never reached', async () => {
+            const error = new Error('failure');
+            const mockService = jest.fn(() => {
+              throw error;
+            });
+            const onBreakListener = jest.fn();
+            const policy = createServicePolicy();
+
+            policy.onBreak(onBreakListener);
+
+            const promise = policy.execute(mockService);
+            // It's safe not to await this promise; adding it to the promise
+            // queue is enough to prevent this test from running indefinitely.
+            // eslint-disable-next-line @typescript-eslint/no-floating-promises
+            clock.runAllAsync();
+            await ignoreRejection(promise);
+
+            expect(onBreakListener).not.toHaveBeenCalled();
+          });
+
+          it('calls onDegraded listeners once with the error, since the circuit is still closed', async () => {
+            const error = new Error('failure');
+            const mockService = jest.fn(() => {
+              throw error;
+            });
+            const onDegradedListener = jest.fn();
+            const policy = createServicePolicy();
+            policy.onDegraded(onDegradedListener);
+
+            const promise = policy.execute(mockService);
+            // It's safe not to await this promise; adding it to the promise
+            // queue is enough to prevent this test from running indefinitely.
+            // eslint-disable-next-line @typescript-eslint/no-floating-promises
+            clock.runAllAsync();
+            await ignoreRejection(promise);
+
+            expect(onDegradedListener).toHaveBeenCalledTimes(1);
+            expect(onDegradedListener).toHaveBeenCalledWith({ error });
+          });
+
+          it('does not call onAvailable listeners', async () => {
+            const error = new Error('failure');
+            const mockService = jest.fn(() => {
+              throw error;
+            });
+            const onAvailableListener = jest.fn();
+            const policy = createServicePolicy();
+            policy.onAvailable(onAvailableListener);
+
+            const promise = policy.execute(mockService);
+            // It's safe not to await this promise; adding it to the promise
+            // queue is enough to prevent this test from running indefinitely.
+            // eslint-disable-next-line @typescript-eslint/no-floating-promises
+            clock.runAllAsync();
+            await ignoreRejection(promise);
+
+            expect(onAvailableListener).not.toHaveBeenCalled();
+          });
+        });
+
+        describe('using a custom max number of consecutive failures', () => {
+          describe('if the initial run + retries is less than the max number of consecutive failures', () => {
+            it('throws what the service throws', async () => {
+              const maxConsecutiveFailures = DEFAULT_MAX_RETRIES + 2;
+              const error = new Error('failure');
+              const mockService = jest.fn(() => {
+                throw error;
+              });
+              const policy = createServicePolicy({
+                maxConsecutiveFailures,
+              });
+
+              const promise = policy.execute(mockService);
+              // It's safe not to await this promise; adding it to the promise
+              // queue is enough to prevent this test from running indefinitely.
+              // eslint-disable-next-line @typescript-eslint/no-floating-promises
+              clock.runAllAsync();
+
+              await expect(promise).rejects.toThrow(error);
+            });
+
+            it('does not call onBreak listeners', async () => {
+              const maxConsecutiveFailures = DEFAULT_MAX_RETRIES + 2;
+              const error = new Error('failure');
+              const mockService = jest.fn(() => {
+                throw error;
+              });
+              const onBreakListener = jest.fn();
+              const policy = createServicePolicy({
+                maxConsecutiveFailures,
+              });
+
+              policy.onBreak(onBreakListener);
+
+              const promise = policy.execute(mockService);
+              // It's safe not to await this promise; adding it to the promise
+              // queue is enough to prevent this test from running indefinitely.
+              // eslint-disable-next-line @typescript-eslint/no-floating-promises
+              clock.runAllAsync();
+              await ignoreRejection(promise);
+
+              expect(onBreakListener).not.toHaveBeenCalled();
+            });
+
+            it('calls onDegraded listeners once with the error', async () => {
+              const maxConsecutiveFailures = DEFAULT_MAX_RETRIES + 2;
+              const error = new Error('failure');
+              const mockService = jest.fn(() => {
+                throw error;
+              });
+              const onDegradedListener = jest.fn();
+              const policy = createServicePolicy({
+                maxConsecutiveFailures,
+              });
+              policy.onDegraded(onDegradedListener);
+
+              const promise = policy.execute(mockService);
+              // It's safe not to await this promise; adding it to the promise
+              // queue is enough to prevent this test from running indefinitely.
+              // eslint-disable-next-line @typescript-eslint/no-floating-promises
+              clock.runAllAsync();
+              await ignoreRejection(promise);
+
+              expect(onDegradedListener).toHaveBeenCalledTimes(1);
+              expect(onDegradedListener).toHaveBeenCalledWith({ error });
+            });
+
+            it('does not call onAvailable listeners', async () => {
+              const maxConsecutiveFailures = DEFAULT_MAX_RETRIES + 2;
+              const error = new Error('failure');
+              const mockService = jest.fn(() => {
+                throw error;
+              });
+              const onAvailableListener = jest.fn();
+              const policy = createServicePolicy({
+                maxConsecutiveFailures,
+              });
+              policy.onAvailable(onAvailableListener);
+
+              const promise = policy.execute(mockService);
+              // It's safe not to await this promise; adding it to the promise
+              // queue is enough to prevent this test from running indefinitely.
+              // eslint-disable-next-line @typescript-eslint/no-floating-promises
+              clock.runAllAsync();
+              await ignoreRejection(promise);
+
+              expect(onAvailableListener).not.toHaveBeenCalled();
+            });
+          });
+
+          describe('if the initial run + retries is equal to the max number of consecutive failures', () => {
+            it('throws what the service throws', async () => {
+              const maxConsecutiveFailures = DEFAULT_MAX_RETRIES + 1;
+              const error = new Error('failure');
+              const mockService = jest.fn(() => {
+                throw error;
+              });
+              const policy = createServicePolicy({
+                maxConsecutiveFailures,
+              });
+
+              const promise = policy.execute(mockService);
+              // It's safe not to await this promise; adding it to the promise
+              // queue is enough to prevent this test from running indefinitely.
+              // eslint-disable-next-line @typescript-eslint/no-floating-promises
+              clock.runAllAsync();
+
+              await expect(promise).rejects.toThrow(error);
+            });
+
+            it('calls onBreak listeners once with the error', async () => {
+              const maxConsecutiveFailures = DEFAULT_MAX_RETRIES + 1;
+              const error = new Error('failure');
+              const mockService = jest.fn(() => {
+                throw error;
+              });
+              const onBreakListener = jest.fn();
+              const policy = createServicePolicy({
+                maxConsecutiveFailures,
+              });
+
+              policy.onBreak(onBreakListener);
+
+              const promise = policy.execute(mockService);
+              // It's safe not to await this promise; adding it to the promise
+              // queue is enough to prevent this test from running indefinitely.
+              // eslint-disable-next-line @typescript-eslint/no-floating-promises
+              clock.runAllAsync();
+              await ignoreRejection(promise);
+
+              expect(onBreakListener).toHaveBeenCalledTimes(1);
+              expect(onBreakListener).toHaveBeenCalledWith({ error });
+            });
+
+            it('never calls onDegraded listeners, since the circuit is open', async () => {
+              const maxConsecutiveFailures = DEFAULT_MAX_RETRIES + 1;
+              const error = new Error('failure');
+              const mockService = jest.fn(() => {
+                throw error;
+              });
+              const onDegradedListener = jest.fn();
+              const policy = createServicePolicy({
+                maxConsecutiveFailures,
+              });
+              policy.onDegraded(onDegradedListener);
+
+              const promise = policy.execute(mockService);
+              // It's safe not to await this promise; adding it to the promise
+              // queue is enough to prevent this test from running indefinitely.
+              // eslint-disable-next-line @typescript-eslint/no-floating-promises
+              clock.runAllAsync();
+              await ignoreRejection(promise);
+
+              expect(onDegradedListener).not.toHaveBeenCalled();
+            });
+
+            it('does not call onAvailable listeners', async () => {
+              const maxConsecutiveFailures = DEFAULT_MAX_RETRIES + 1;
+              const error = new Error('failure');
+              const mockService = jest.fn(() => {
+                throw error;
+              });
+              const onAvailableListener = jest.fn();
+              const policy = createServicePolicy({
+                maxConsecutiveFailures,
+              });
+              policy.onAvailable(onAvailableListener);
+
+              const promise = policy.execute(mockService);
+              // It's safe not to await this promise; adding it to the promise
+              // queue is enough to prevent this test from running indefinitely.
+              // eslint-disable-next-line @typescript-eslint/no-floating-promises
+              clock.runAllAsync();
+              await ignoreRejection(promise);
+
+              expect(onAvailableListener).not.toHaveBeenCalled();
+            });
+
+            it('throws a BrokenCircuitError instead of whatever error the service produces if the service is executed again', async () => {
+              const maxConsecutiveFailures = DEFAULT_MAX_RETRIES + 1;
+              const error = new Error('failure');
+              const mockService = jest.fn(() => {
+                throw error;
+              });
+              const policy = createServicePolicy({
+                maxConsecutiveFailures,
+              });
+
+              const firstExecution = policy.execute(mockService);
+              // It's safe not to await this promise; adding it to the promise
+              // queue is enough to prevent this test from running indefinitely.
+              // eslint-disable-next-line @typescript-eslint/no-floating-promises
+              clock.runAllAsync();
+              await ignoreRejection(firstExecution);
+
+              const secondExecution = policy.execute(mockService);
+              await expect(secondExecution).rejects.toThrow(
+                new Error(
+                  'Execution prevented because the circuit breaker is open',
+                ),
+              );
+            });
+          });
+
+          describe('if the initial run + retries is greater than the max number of consecutive failures', () => {
+            it('throws a BrokenCircuitError instead of whatever error the service produces', async () => {
+              const maxConsecutiveFailures = DEFAULT_MAX_RETRIES;
+              const error = new Error('failure');
+              const mockService = jest.fn(() => {
+                throw error;
+              });
+              const policy = createServicePolicy({
+                maxConsecutiveFailures,
+              });
+
+              const promise = policy.execute(mockService);
+              // It's safe not to await this promise; adding it to the promise
+              // queue is enough to prevent this test from running indefinitely.
+              // eslint-disable-next-line @typescript-eslint/no-floating-promises
+              clock.runAllAsync();
+
+              await expect(promise).rejects.toThrow(
+                new Error(
+                  'Execution prevented because the circuit breaker is open',
+                ),
+              );
+            });
+
+            it('calls onBreak listeners once with the error', async () => {
+              const maxConsecutiveFailures = DEFAULT_MAX_RETRIES;
+              const error = new Error('failure');
+              const mockService = jest.fn(() => {
+                throw error;
+              });
+              const onBreakListener = jest.fn();
+              const policy = createServicePolicy({
+                maxConsecutiveFailures,
+              });
+
+              policy.onBreak(onBreakListener);
+
+              const promise = policy.execute(mockService);
+              // It's safe not to await this promise; adding it to the promise
+              // queue is enough to prevent this test from running indefinitely.
+              // eslint-disable-next-line @typescript-eslint/no-floating-promises
+              clock.runAllAsync();
+              await ignoreRejection(promise);
+
+              expect(onBreakListener).toHaveBeenCalledTimes(1);
+              expect(onBreakListener).toHaveBeenCalledWith({ error });
+            });
+
+            it('never calls onDegraded listeners, since the circuit is open', async () => {
+              const maxConsecutiveFailures = DEFAULT_MAX_RETRIES;
+              const error = new Error('failure');
+              const mockService = jest.fn(() => {
+                throw error;
+              });
+              const onDegradedListener = jest.fn();
+              const policy = createServicePolicy({
+                maxConsecutiveFailures,
+              });
+              policy.onDegraded(onDegradedListener);
+
+              const promise = policy.execute(mockService);
+              // It's safe not to await this promise; adding it to the promise
+              // queue is enough to prevent this test from running indefinitely.
+              // eslint-disable-next-line @typescript-eslint/no-floating-promises
+              clock.runAllAsync();
+              await ignoreRejection(promise);
+
+              expect(onDegradedListener).not.toHaveBeenCalled();
+            });
+
+            it('does not call onAvailable listeners', async () => {
+              const maxConsecutiveFailures = DEFAULT_MAX_RETRIES;
+              const error = new Error('failure');
+              const mockService = jest.fn(() => {
+                throw error;
+              });
+              const onAvailableListener = jest.fn();
+              const policy = createServicePolicy({
+                maxConsecutiveFailures,
+              });
+              policy.onAvailable(onAvailableListener);
+
+              const promise = policy.execute(mockService);
+              // It's safe not to await this promise; adding it to the promise
+              // queue is enough to prevent this test from running indefinitely.
+              // eslint-disable-next-line @typescript-eslint/no-floating-promises
+              clock.runAllAsync();
+              await ignoreRejection(promise);
+
+              expect(onAvailableListener).not.toHaveBeenCalled();
+            });
+          });
+        });
+      });
+
+      describe('using a custom max number of retries', () => {
+        it(`calls the service a total of 1 + <maxRetries> times, delaying each retry using a backoff formula`, async () => {
+          const maxRetries = 5;
+          const error = new Error('failure');
+          const mockService = jest.fn(() => {
+            throw error;
+          });
+          const policy = createServicePolicy({ maxRetries });
+          // Each retry delay is randomized using a decorrelated jitter formula,
+          // so we need to prevent that
+          jest.spyOn(Math, 'random').mockReturnValue(0);
+
+          const promise = policy.execute(mockService);
+          // It's safe not to await these promises; adding them to the promise
+          // queue is enough to prevent this test from running indefinitely.
+          // eslint-disable-next-line @typescript-eslint/no-floating-promises
+          clock.tickAsync(0);
+          // eslint-disable-next-line @typescript-eslint/no-floating-promises
+          clock.tickAsync(176.27932892814937);
+          // eslint-disable-next-line @typescript-eslint/no-floating-promises
+          clock.tickAsync(186.8886145345685);
+          // eslint-disable-next-line @typescript-eslint/no-floating-promises
+          clock.tickAsync(366.8287823691078);
+          // eslint-disable-next-line @typescript-eslint/no-floating-promises
+          clock.tickAsync(731.8792783578953);
+          await ignoreRejection(promise);
+
+          expect(mockService).toHaveBeenCalledTimes(1 + maxRetries);
+        });
+
+        it('calls onRetry listeners once per retry', async () => {
+          const maxRetries = 5;
+          const error = new Error('failure');
+          const mockService = jest.fn(() => {
+            throw error;
+          });
+          const onRetryListener = jest.fn();
+          const policy = createServicePolicy({
+            maxRetries,
+          });
+          policy.onRetry(onRetryListener);
+
+          const promise = policy.execute(mockService);
+          // It's safe not to await this promise; adding it to the promise queue is
+          // enough to prevent this test from running indefinitely.
+          // eslint-disable-next-line @typescript-eslint/no-floating-promises
+          clock.runAllAsync();
+          await ignoreRejection(promise);
+
+          expect(onRetryListener).toHaveBeenCalledTimes(maxRetries);
+        });
+
+        describe(`using the default max number of consecutive failures (${DEFAULT_MAX_CONSECUTIVE_FAILURES})`, () => {
+          describe('if the initial run + retries is less than the max number of consecutive failures', () => {
+            it('throws what the service throws', async () => {
+              const maxRetries = DEFAULT_MAX_CONSECUTIVE_FAILURES - 2;
+              const error = new Error('failure');
+              const mockService = jest.fn(() => {
+                throw error;
+              });
+              const policy = createServicePolicy({ maxRetries });
+
+              const promise = policy.execute(mockService);
+              // It's safe not to await this promise; adding it to the promise
+              // queue is enough to prevent this test from running indefinitely.
+              // eslint-disable-next-line @typescript-eslint/no-floating-promises
+              clock.runAllAsync();
+
+              await expect(promise).rejects.toThrow(error);
+            });
+
+            it('does not call onBreak listeners', async () => {
+              const maxRetries = DEFAULT_MAX_CONSECUTIVE_FAILURES - 2;
+              const error = new Error('failure');
+              const mockService = jest.fn(() => {
+                throw error;
+              });
+              const onBreakListener = jest.fn();
+              const policy = createServicePolicy({ maxRetries });
+
+              policy.onBreak(onBreakListener);
+
+              const promise = policy.execute(mockService);
+              // It's safe not to await this promise; adding it to the promise
+              // queue is enough to prevent this test from running indefinitely.
+              // eslint-disable-next-line @typescript-eslint/no-floating-promises
+              clock.runAllAsync();
+              await ignoreRejection(promise);
+
+              expect(onBreakListener).not.toHaveBeenCalled();
+            });
+
+            it('calls onDegraded listeners once with the error', async () => {
+              const maxRetries = DEFAULT_MAX_CONSECUTIVE_FAILURES - 2;
+              const error = new Error('failure');
+              const mockService = jest.fn(() => {
+                throw error;
+              });
+              const onDegradedListener = jest.fn();
+              const policy = createServicePolicy({ maxRetries });
+              policy.onDegraded(onDegradedListener);
+
+              const promise = policy.execute(mockService);
+              // It's safe not to await this promise; adding it to the promise
+              // queue is enough to prevent this test from running indefinitely.
+              // eslint-disable-next-line @typescript-eslint/no-floating-promises
+              clock.runAllAsync();
+              await ignoreRejection(promise);
+
+              expect(onDegradedListener).toHaveBeenCalledTimes(1);
+              expect(onDegradedListener).toHaveBeenCalledWith({ error });
+            });
+
+            it('does not call onAvailable listeners', async () => {
+              const maxRetries = DEFAULT_MAX_CONSECUTIVE_FAILURES - 2;
+              const error = new Error('failure');
+              const mockService = jest.fn(() => {
+                throw error;
+              });
+              const onAvailableListener = jest.fn();
+              const policy = createServicePolicy({ maxRetries });
+              policy.onAvailable(onAvailableListener);
+
+              const promise = policy.execute(mockService);
+              // It's safe not to await this promise; adding it to the promise
+              // queue is enough to prevent this test from running indefinitely.
+              // eslint-disable-next-line @typescript-eslint/no-floating-promises
+              clock.runAllAsync();
+              await ignoreRejection(promise);
+
+              expect(onAvailableListener).not.toHaveBeenCalled();
+            });
+          });
+
+          describe('if the initial run + retries is equal to the max number of consecutive failures', () => {
+            it('throws what the service throws', async () => {
+              const maxRetries = DEFAULT_MAX_CONSECUTIVE_FAILURES - 1;
+              const error = new Error('failure');
+              const mockService = jest.fn(() => {
+                throw error;
+              });
+              const policy = createServicePolicy({ maxRetries });
+
+              const promise = policy.execute(mockService);
+              // It's safe not to await this promise; adding it to the promise
+              // queue is enough to prevent this test from running indefinitely.
+              // eslint-disable-next-line @typescript-eslint/no-floating-promises
+              clock.runAllAsync();
+
+              await expect(promise).rejects.toThrow(error);
+            });
+
+            it('calls onBreak listeners once with the error', async () => {
+              const maxRetries = DEFAULT_MAX_CONSECUTIVE_FAILURES - 1;
+              const error = new Error('failure');
+              const mockService = jest.fn(() => {
+                throw error;
+              });
+              const onBreakListener = jest.fn();
+              const policy = createServicePolicy({ maxRetries });
+
+              policy.onBreak(onBreakListener);
+
+              const promise = policy.execute(mockService);
+              // It's safe not to await this promise; adding it to the promise
+              // queue is enough to prevent this test from running indefinitely.
+              // eslint-disable-next-line @typescript-eslint/no-floating-promises
+              clock.runAllAsync();
+              await ignoreRejection(promise);
+
+              expect(onBreakListener).toHaveBeenCalledTimes(1);
+              expect(onBreakListener).toHaveBeenCalledWith({ error });
+            });
+
+            it('never calls onDegraded listeners, since the circuit is open', async () => {
+              const maxRetries = DEFAULT_MAX_CONSECUTIVE_FAILURES - 1;
+              const error = new Error('failure');
+              const mockService = jest.fn(() => {
+                throw error;
+              });
+              const onDegradedListener = jest.fn();
+              const policy = createServicePolicy({ maxRetries });
+              policy.onDegraded(onDegradedListener);
+
+              const promise = policy.execute(mockService);
+              // It's safe not to await this promise; adding it to the promise
+              // queue is enough to prevent this test from running indefinitely.
+              // eslint-disable-next-line @typescript-eslint/no-floating-promises
+              clock.runAllAsync();
+              await ignoreRejection(promise);
+
+              expect(onDegradedListener).not.toHaveBeenCalled();
+            });
+
+            it('does not call onAvailable listeners', async () => {
+              const maxRetries = DEFAULT_MAX_CONSECUTIVE_FAILURES - 1;
+              const error = new Error('failure');
+              const mockService = jest.fn(() => {
+                throw error;
+              });
+              const onAvailableListener = jest.fn();
+              const policy = createServicePolicy({ maxRetries });
+              policy.onAvailable(onAvailableListener);
+
+              const promise = policy.execute(mockService);
+              // It's safe not to await this promise; adding it to the promise
+              // queue is enough to prevent this test from running indefinitely.
+              // eslint-disable-next-line @typescript-eslint/no-floating-promises
+              clock.runAllAsync();
+              await ignoreRejection(promise);
+
+              expect(onAvailableListener).not.toHaveBeenCalled();
+            });
+
+            it('throws a BrokenCircuitError instead of whatever error the service produces if the policy is executed again', async () => {
+              const maxRetries = DEFAULT_MAX_CONSECUTIVE_FAILURES - 1;
+              const error = new Error('failure');
+              const mockService = jest.fn(() => {
+                throw error;
+              });
+              const policy = createServicePolicy({ maxRetries });
+
+              const firstExecution = policy.execute(mockService);
+              // It's safe not to await this promise; adding it to the promise
+              // queue is enough to prevent this test from running indefinitely.
+              // eslint-disable-next-line @typescript-eslint/no-floating-promises
+              clock.runAllAsync();
+              await ignoreRejection(firstExecution);
+
+              const secondExecution = policy.execute(mockService);
+              await expect(secondExecution).rejects.toThrow(
+                new Error(
+                  'Execution prevented because the circuit breaker is open',
+                ),
+              );
+            });
+          });
+
+          describe('if the initial run + retries is greater than the max number of consecutive failures', () => {
+            it('throws a BrokenCircuitError instead of whatever error the service produces', async () => {
+              const maxRetries = DEFAULT_MAX_CONSECUTIVE_FAILURES;
+              const mockService = jest.fn(() => {
+                throw new Error('failure');
+              });
+              const policy = createServicePolicy({ maxRetries });
+
+              const promise = policy.execute(mockService);
+              // It's safe not to await this promise; adding it to the promise
+              // queue is enough to prevent this test from running indefinitely.
+              // eslint-disable-next-line @typescript-eslint/no-floating-promises
+              clock.runAllAsync();
+
+              await expect(promise).rejects.toThrow(
+                new Error(
+                  'Execution prevented because the circuit breaker is open',
+                ),
+              );
+            });
+
+            it('calls onBreak listeners once with the error', async () => {
+              const maxRetries = DEFAULT_MAX_CONSECUTIVE_FAILURES;
+              const error = new Error('failure');
+              const mockService = jest.fn(() => {
+                throw error;
+              });
+              const onBreakListener = jest.fn();
+              const policy = createServicePolicy({ maxRetries });
+
+              policy.onBreak(onBreakListener);
+
+              const promise = policy.execute(mockService);
+              // It's safe not to await this promise; adding it to the promise
+              // queue is enough to prevent this test from running indefinitely.
+              // eslint-disable-next-line @typescript-eslint/no-floating-promises
+              clock.runAllAsync();
+              await ignoreRejection(promise);
+
+              expect(onBreakListener).toHaveBeenCalledTimes(1);
+              expect(onBreakListener).toHaveBeenCalledWith({ error });
+            });
+
+            it('never calls onDegraded listeners, since the circuit is open', async () => {
+              const maxRetries = DEFAULT_MAX_CONSECUTIVE_FAILURES;
+              const error = new Error('failure');
+              const mockService = jest.fn(() => {
+                throw error;
+              });
+              const onDegradedListener = jest.fn();
+              const policy = createServicePolicy({ maxRetries });
+              policy.onDegraded(onDegradedListener);
+
+              const promise = policy.execute(mockService);
+              // It's safe not to await this promise; adding it to the promise
+              // queue is enough to prevent this test from running indefinitely.
+              // eslint-disable-next-line @typescript-eslint/no-floating-promises
+              clock.runAllAsync();
+              await ignoreRejection(promise);
+
+              expect(onDegradedListener).not.toHaveBeenCalled();
+            });
+
+            it('does not call onAvailable listeners', async () => {
+              const maxRetries = DEFAULT_MAX_CONSECUTIVE_FAILURES;
+              const error = new Error('failure');
+              const mockService = jest.fn(() => {
+                throw error;
+              });
+              const onAvailableListener = jest.fn();
+              const policy = createServicePolicy({ maxRetries });
+              policy.onAvailable(onAvailableListener);
+
+              const promise = policy.execute(mockService);
+              // It's safe not to await this promise; adding it to the promise
+              // queue is enough to prevent this test from running indefinitely.
+              // eslint-disable-next-line @typescript-eslint/no-floating-promises
+              clock.runAllAsync();
+              await ignoreRejection(promise);
+
+              expect(onAvailableListener).not.toHaveBeenCalled();
+            });
+          });
+        });
+
+        describe('using a custom max number of consecutive failures', () => {
+          describe('if the initial run + retries is less than the max number of consecutive failures', () => {
+            it('throws what the service throws', async () => {
+              const maxConsecutiveFailures = 5;
+              const maxRetries = maxConsecutiveFailures - 2;
+              const error = new Error('failure');
+              const mockService = jest.fn(() => {
+                throw error;
+              });
+              const policy = createServicePolicy({
+                maxRetries,
+                maxConsecutiveFailures,
+              });
+
+              const promise = policy.execute(mockService);
+              // It's safe not to await this promise; adding it to the promise
+              // queue is enough to prevent this test from running indefinitely.
+              // eslint-disable-next-line @typescript-eslint/no-floating-promises
+              clock.runAllAsync();
+
+              await expect(promise).rejects.toThrow(error);
+            });
+
+            it('does not call onBreak listeners', async () => {
+              const maxConsecutiveFailures = 5;
+              const maxRetries = maxConsecutiveFailures - 2;
+              const error = new Error('failure');
+              const mockService = jest.fn(() => {
+                throw error;
+              });
+              const onBreakListener = jest.fn();
+              const policy = createServicePolicy({
+                maxRetries,
+                maxConsecutiveFailures,
+              });
+
+              policy.onBreak(onBreakListener);
+
+              const promise = policy.execute(mockService);
+              // It's safe not to await this promise; adding it to the promise
+              // queue is enough to prevent this test from running indefinitely.
+              // eslint-disable-next-line @typescript-eslint/no-floating-promises
+              clock.runAllAsync();
+              await ignoreRejection(promise);
+
+              expect(onBreakListener).not.toHaveBeenCalled();
+            });
+
+            it('calls onDegraded listeners once with the error', async () => {
+              const maxConsecutiveFailures = 5;
+              const maxRetries = maxConsecutiveFailures - 2;
+              const error = new Error('failure');
+              const mockService = jest.fn(() => {
+                throw error;
+              });
+              const onDegradedListener = jest.fn();
+              const policy = createServicePolicy({
+                maxRetries,
+                maxConsecutiveFailures,
+              });
+              policy.onDegraded(onDegradedListener);
+
+              const promise = policy.execute(mockService);
+              // It's safe not to await this promise; adding it to the promise
+              // queue is enough to prevent this test from running indefinitely.
+              // eslint-disable-next-line @typescript-eslint/no-floating-promises
+              clock.runAllAsync();
+              await ignoreRejection(promise);
+
+              expect(onDegradedListener).toHaveBeenCalledTimes(1);
+              expect(onDegradedListener).toHaveBeenCalledWith({ error });
+            });
+
+            it('does not call onAvailable listeners', async () => {
+              const maxConsecutiveFailures = 5;
+              const maxRetries = maxConsecutiveFailures - 2;
+              const error = new Error('failure');
+              const mockService = jest.fn(() => {
+                throw error;
+              });
+              const onAvailableListener = jest.fn();
+              const policy = createServicePolicy({
+                maxRetries,
+                maxConsecutiveFailures,
+              });
+              policy.onAvailable(onAvailableListener);
+
+              const promise = policy.execute(mockService);
+              // It's safe not to await this promise; adding it to the promise
+              // queue is enough to prevent this test from running indefinitely.
+              // eslint-disable-next-line @typescript-eslint/no-floating-promises
+              clock.runAllAsync();
+              await ignoreRejection(promise);
+
+              expect(onAvailableListener).not.toHaveBeenCalled();
+            });
+          });
+
+          describe('if the initial run + retries is equal to the max number of consecutive failures', () => {
+            it('throws what the service throws', async () => {
+              const maxConsecutiveFailures = 5;
+              const maxRetries = maxConsecutiveFailures - 1;
+              const error = new Error('failure');
+              const mockService = jest.fn(() => {
+                throw error;
+              });
+              const policy = createServicePolicy({
+                maxRetries,
+                maxConsecutiveFailures,
+              });
+
+              const promise = policy.execute(mockService);
+              // It's safe not to await this promise; adding it to the promise
+              // queue is enough to prevent this test from running indefinitely.
+              // eslint-disable-next-line @typescript-eslint/no-floating-promises
+              clock.runAllAsync();
+
+              await expect(promise).rejects.toThrow(error);
+            });
+
+            it('calls onBreak listeners once with the error', async () => {
+              const maxConsecutiveFailures = 5;
+              const maxRetries = maxConsecutiveFailures - 1;
+              const error = new Error('failure');
+              const mockService = jest.fn(() => {
+                throw error;
+              });
+              const onBreakListener = jest.fn();
+              const policy = createServicePolicy({
+                maxRetries,
+                maxConsecutiveFailures,
+              });
+
+              policy.onBreak(onBreakListener);
+
+              const promise = policy.execute(mockService);
+              // It's safe not to await this promise; adding it to the promise
+              // queue is enough to prevent this test from running indefinitely.
+              // eslint-disable-next-line @typescript-eslint/no-floating-promises
+              clock.runAllAsync();
+              await ignoreRejection(promise);
+
+              expect(onBreakListener).toHaveBeenCalledTimes(1);
+              expect(onBreakListener).toHaveBeenCalledWith({ error });
+            });
+
+            it('never calls onDegraded listeners, since the circuit is open', async () => {
+              const maxConsecutiveFailures = 5;
+              const maxRetries = maxConsecutiveFailures - 1;
+              const error = new Error('failure');
+              const mockService = jest.fn(() => {
+                throw error;
+              });
+              const onDegradedListener = jest.fn();
+              const policy = createServicePolicy({
+                maxRetries,
+                maxConsecutiveFailures,
+              });
+              policy.onDegraded(onDegradedListener);
+
+              const promise = policy.execute(mockService);
+              // It's safe not to await this promise; adding it to the promise
+              // queue is enough to prevent this test from running indefinitely.
+              // eslint-disable-next-line @typescript-eslint/no-floating-promises
+              clock.runAllAsync();
+              await ignoreRejection(promise);
+
+              expect(onDegradedListener).not.toHaveBeenCalled();
+            });
+
+            it('never calls onAvailable listeners', async () => {
+              const maxConsecutiveFailures = 5;
+              const maxRetries = maxConsecutiveFailures - 1;
+              const error = new Error('failure');
+              const mockService = jest.fn(() => {
+                throw error;
+              });
+              const onAvailableListener = jest.fn();
+              const policy = createServicePolicy({
+                maxRetries,
+                maxConsecutiveFailures,
+              });
+              policy.onAvailable(onAvailableListener);
+
+              const promise = policy.execute(mockService);
+              // It's safe not to await this promise; adding it to the promise
+              // queue is enough to prevent this test from running indefinitely.
+              // eslint-disable-next-line @typescript-eslint/no-floating-promises
+              clock.runAllAsync();
+              await ignoreRejection(promise);
+
+              expect(onAvailableListener).not.toHaveBeenCalled();
+            });
+
+            it('throws a BrokenCircuitError instead of whatever error the service produces if the policy is executed again', async () => {
+              const maxConsecutiveFailures = 5;
+              const maxRetries = maxConsecutiveFailures - 1;
+              const error = new Error('failure');
+              const mockService = jest.fn(() => {
+                throw error;
+              });
+              const policy = createServicePolicy({
+                maxRetries,
+                maxConsecutiveFailures,
+              });
+
+              const firstExecution = policy.execute(mockService);
+              // It's safe not to await this promise; adding it to the promise
+              // queue is enough to prevent this test from running indefinitely.
+              // eslint-disable-next-line @typescript-eslint/no-floating-promises
+              clock.runAllAsync();
+              await ignoreRejection(firstExecution);
+
+              const secondExecution = policy.execute(mockService);
+              await expect(secondExecution).rejects.toThrow(
+                new Error(
+                  'Execution prevented because the circuit breaker is open',
+                ),
+              );
+            });
+          });
+
+          describe('if the initial run + retries is greater than the max number of consecutive failures', () => {
+            it('throws a BrokenCircuitError instead of whatever error the service produces', async () => {
+              const maxConsecutiveFailures = 5;
+              const maxRetries = maxConsecutiveFailures;
+              const error = new Error('failure');
+              const mockService = jest.fn(() => {
+                throw error;
+              });
+              const policy = createServicePolicy({
+                maxRetries,
+                maxConsecutiveFailures,
+              });
+
+              const promise = policy.execute(mockService);
+              // It's safe not to await this promise; adding it to the promise
+              // queue is enough to prevent this test from running indefinitely.
+              // eslint-disable-next-line @typescript-eslint/no-floating-promises
+              clock.runAllAsync();
+
+              await expect(promise).rejects.toThrow(
+                new Error(
+                  'Execution prevented because the circuit breaker is open',
+                ),
+              );
+            });
+
+            it('calls onBreak listeners once with the error', async () => {
+              const maxConsecutiveFailures = 5;
+              const maxRetries = maxConsecutiveFailures;
+              const error = new Error('failure');
+              const mockService = jest.fn(() => {
+                throw error;
+              });
+              const onBreakListener = jest.fn();
+              const policy = createServicePolicy({
+                maxRetries,
+                maxConsecutiveFailures,
+              });
+
+              policy.onBreak(onBreakListener);
+
+              const promise = policy.execute(mockService);
+              // It's safe not to await this promise; adding it to the promise
+              // queue is enough to prevent this test from running indefinitely.
+              // eslint-disable-next-line @typescript-eslint/no-floating-promises
+              clock.runAllAsync();
+              await ignoreRejection(promise);
+
+              expect(onBreakListener).toHaveBeenCalledTimes(1);
+              expect(onBreakListener).toHaveBeenCalledWith({ error });
+            });
+
+            it('never calls onDegraded listeners, since the circuit is open', async () => {
+              const maxConsecutiveFailures = 5;
+              const maxRetries = maxConsecutiveFailures;
+              const error = new Error('failure');
+              const mockService = jest.fn(() => {
+                throw error;
+              });
+              const onDegradedListener = jest.fn();
+              const policy = createServicePolicy({
+                maxRetries,
+                maxConsecutiveFailures,
+              });
+              policy.onDegraded(onDegradedListener);
+
+              const promise = policy.execute(mockService);
+              // It's safe not to await this promise; adding it to the promise
+              // queue is enough to prevent this test from running indefinitely.
+              // eslint-disable-next-line @typescript-eslint/no-floating-promises
+              clock.runAllAsync();
+              await ignoreRejection(promise);
+
+              expect(onDegradedListener).not.toHaveBeenCalled();
+            });
+
+            it('does not call onAvailable listeners', async () => {
+              const maxConsecutiveFailures = 5;
+              const maxRetries = maxConsecutiveFailures;
+              const error = new Error('failure');
+              const mockService = jest.fn(() => {
+                throw error;
+              });
+              const onAvailableListener = jest.fn();
+              const policy = createServicePolicy({
+                maxRetries,
+                maxConsecutiveFailures,
+              });
+              policy.onAvailable(onAvailableListener);
+
+              const promise = policy.execute(mockService);
+              // It's safe not to await this promise; adding it to the promise
+              // queue is enough to prevent this test from running indefinitely.
+              // eslint-disable-next-line @typescript-eslint/no-floating-promises
+              clock.runAllAsync();
+              await ignoreRejection(promise);
+
+              expect(onAvailableListener).not.toHaveBeenCalled();
+            });
+          });
+        });
+      });
+    });
+  });
+
+  describe('wrapping a service that fails continuously and then succeeds on the final try', () => {
+    // NOTE: Using a custom retry filter policy is not tested here since the
+    // same thing would happen as above if the error is filtered out
+
+    describe(`using the default max retries (${DEFAULT_MAX_RETRIES})`, () => {
+      it(`calls the service a total of ${
+        1 + DEFAULT_MAX_RETRIES
+      } times, delaying each retry using a backoff formula`, async () => {
+        let invocationCounter = 0;
+        const mockService = jest.fn(() => {
+          invocationCounter += 1;
+          if (invocationCounter === DEFAULT_MAX_RETRIES + 1) {
+            return { some: 'data' };
+          }
+          throw new Error('failure');
+        });
+        const policy = createServicePolicy();
+        // Each retry delay is randomized using a decorrelated jitter formula,
+        // so we need to prevent that
+        jest.spyOn(Math, 'random').mockReturnValue(0);
+
+        const promise = policy.execute(mockService);
+        // It's safe not to await these promises; adding them to the promise
+        // queue is enough to prevent this test from running indefinitely.
+        // eslint-disable-next-line @typescript-eslint/no-floating-promises
+        clock.tickAsync(0);
+        // eslint-disable-next-line @typescript-eslint/no-floating-promises
+        clock.tickAsync(176.27932892814937);
+        // eslint-disable-next-line @typescript-eslint/no-floating-promises
+        clock.tickAsync(186.8886145345685);
+        await promise;
+
+        expect(mockService).toHaveBeenCalledTimes(1 + DEFAULT_MAX_RETRIES);
+      });
+
+      describe(`using the default max number of consecutive failures (${DEFAULT_MAX_CONSECUTIVE_FAILURES})`, () => {
+        it('returns what the service returns', async () => {
+          let invocationCounter = 0;
+          const mockService = (): { some: string } => {
+            invocationCounter += 1;
+            if (invocationCounter === DEFAULT_MAX_RETRIES + 1) {
+              return { some: 'data' };
+            }
+            throw new Error('failure');
+          };
+          const policy = createServicePolicy();
+
+          const promise = policy.execute(mockService);
+          // It's safe not to await this promise; adding it to the promise queue
+          // is enough to prevent this test from running indefinitely.
+          // eslint-disable-next-line @typescript-eslint/no-floating-promises
+          clock.runAllAsync();
+
+          expect(await promise).toStrictEqual({ some: 'data' });
+        });
+
+        it('does not call onBreak listeners, since the max number of consecutive failures is never reached', async () => {
+          let invocationCounter = 0;
+          const mockService = (): { some: string } => {
+            invocationCounter += 1;
+            if (invocationCounter === DEFAULT_MAX_RETRIES + 1) {
+              return { some: 'data' };
+            }
+            throw new Error('failure');
+          };
+          const onBreakListener = jest.fn();
+          const policy = createServicePolicy();
+
+          policy.onBreak(onBreakListener);
+
+          const promise = policy.execute(mockService);
+          // It's safe not to await this promise; adding it to the promise queue
+          // is enough to prevent this test from running indefinitely.
+          // eslint-disable-next-line @typescript-eslint/no-floating-promises
+          clock.runAllAsync();
+          await promise;
+
+          expect(onBreakListener).not.toHaveBeenCalled();
+        });
+
+        describe.each([
+          {
+            desc: `the default degraded threshold (${DEFAULT_DEGRADED_THRESHOLD})`,
+            threshold: DEFAULT_DEGRADED_THRESHOLD,
+            options: {},
+          },
+          {
+            desc: 'a custom degraded threshold',
+            threshold: 2000,
+            options: { degradedThreshold: 2000 },
+          },
+        ])('using $desc', ({ threshold, options }) => {
+          describe('if the service execution time is below the threshold', () => {
+            it('does not call onDegraded listeners', async () => {
+              let invocationCounter = 0;
+              const mockService = (): { some: string } => {
+                invocationCounter += 1;
+                if (invocationCounter === DEFAULT_MAX_RETRIES + 1) {
+                  return { some: 'data' };
+                }
+                throw new Error('failure');
+              };
+              const onDegradedListener = jest.fn();
+              const policy = createServicePolicy(options);
+              policy.onDegraded(onDegradedListener);
+
+              const promise = policy.execute(mockService);
+              // It's safe not to await this promise; adding it to the promise
+              // queue is enough to prevent this test from running indefinitely.
+              // eslint-disable-next-line @typescript-eslint/no-floating-promises
+              clock.runAllAsync();
+              await promise;
+
+              expect(onDegradedListener).not.toHaveBeenCalled();
+            });
+
+            it('calls onAvailable listeners once, even if the service is called more than once', async () => {
+              let invocationCounter = 0;
+              const mockService = (): { some: string } => {
+                invocationCounter += 1;
+                if (
+                  invocationCounter > 0 &&
+                  invocationCounter % (DEFAULT_MAX_RETRIES + 1) === 0
+                ) {
+                  return { some: 'data' };
+                }
+                throw new Error('failure');
+              };
+              const onAvailableListener = jest.fn();
+              const policy = createServicePolicy(options);
+              policy.onAvailable(onAvailableListener);
+
+              const promise1 = policy.execute(mockService);
+              // It's safe not to await this promise; adding it to the promise
+              // queue is enough to prevent this test from running indefinitely.
+              // eslint-disable-next-line @typescript-eslint/no-floating-promises
+              clock.runAllAsync();
+              await promise1;
+              const promise2 = policy.execute(mockService);
+              // It's safe not to await this promise; adding it to the promise
+              // queue is enough to prevent this test from running indefinitely.
+              // eslint-disable-next-line @typescript-eslint/no-floating-promises
+              clock.runAllAsync();
+              await promise2;
+
+              expect(onAvailableListener).toHaveBeenCalledTimes(1);
+            });
+          });
+
+          describe('if the service execution time is beyond the threshold', () => {
+            it('calls onDegraded listeners once', async () => {
+              let invocationCounter = 0;
+              const delay = threshold + 1;
+              const mockService = (): Promise<{ some: string }> => {
+                invocationCounter += 1;
+                return new Promise((resolve, reject) => {
+                  if (invocationCounter === DEFAULT_MAX_RETRIES + 1) {
+                    setTimeout(() => resolve({ some: 'data' }), delay);
+                  } else {
+                    reject(new Error('failure'));
+                  }
+                });
+              };
+              const onDegradedListener = jest.fn();
+              const policy = createServicePolicy(options);
+              policy.onDegraded(onDegradedListener);
+
+              const promise = policy.execute(mockService);
+              // It's safe not to await this promise; adding it to the promise
+              // queue is enough to prevent this test from running indefinitely.
+              // eslint-disable-next-line @typescript-eslint/no-floating-promises
+              clock.runAllAsync();
+              await promise;
+
+              expect(onDegradedListener).toHaveBeenCalledTimes(1);
+            });
+
+            it('does not call onAvailable listeners', async () => {
+              let invocationCounter = 0;
+              const delay = DEFAULT_DEGRADED_THRESHOLD + 1;
+              const mockService = (): Promise<{ some: string }> => {
+                invocationCounter += 1;
+                return new Promise((resolve, reject) => {
+                  if (invocationCounter === DEFAULT_MAX_RETRIES + 1) {
+                    setTimeout(() => resolve({ some: 'data' }), delay);
+                  } else {
+                    reject(new Error('failure'));
+                  }
+                });
+              };
+              const onAvailableListener = jest.fn();
+              const policy = createServicePolicy(options);
+              policy.onAvailable(onAvailableListener);
+
+              const promise = policy.execute(mockService);
+              // It's safe not to await this promise; adding it to the promise
+              // queue is enough to prevent this test from running indefinitely.
+              // eslint-disable-next-line @typescript-eslint/no-floating-promises
+              clock.runAllAsync();
+              await promise;
+
+              expect(onAvailableListener).not.toHaveBeenCalled();
+            });
+          });
+        });
+      });
+
+      describe('using a custom max number of consecutive failures', () => {
+        describe('if the initial run + retries is less than the max number of consecutive failures', () => {
+          it('returns what the service returns', async () => {
+            const maxConsecutiveFailures = DEFAULT_MAX_RETRIES + 2;
+            let invocationCounter = 0;
+            const mockService = (): { some: string } => {
+              invocationCounter += 1;
+              if (invocationCounter === DEFAULT_MAX_RETRIES + 1) {
+                return { some: 'data' };
+              }
+              throw new Error('failure');
+            };
+            const policy = createServicePolicy({
+              maxConsecutiveFailures,
+            });
+
+            const promise = policy.execute(mockService);
+            // It's safe not to await this promise; adding it to the promise
+            // queue is enough to prevent this test from running indefinitely.
+            // eslint-disable-next-line @typescript-eslint/no-floating-promises
+            clock.runAllAsync();
+
+            expect(await promise).toStrictEqual({ some: 'data' });
+          });
+
+          it('does not call onBreak listeners', async () => {
+            const maxConsecutiveFailures = DEFAULT_MAX_RETRIES + 2;
+            let invocationCounter = 0;
+            const mockService = (): { some: string } => {
+              invocationCounter += 1;
+              if (invocationCounter === DEFAULT_MAX_RETRIES + 1) {
+                return { some: 'data' };
+              }
+              throw new Error('failure');
+            };
+            const onBreakListener = jest.fn();
+            const policy = createServicePolicy({
+              maxConsecutiveFailures,
+            });
+
+            policy.onBreak(onBreakListener);
+
+            const promise = policy.execute(mockService);
+            // It's safe not to await this promise; adding it to the promise
+            // queue is enough to prevent this test from running indefinitely.
+            // eslint-disable-next-line @typescript-eslint/no-floating-promises
+            clock.runAllAsync();
+            await promise;
+
+            expect(onBreakListener).not.toHaveBeenCalled();
+          });
+
+          describe.each([
+            {
+              desc: `the default degraded threshold (${DEFAULT_DEGRADED_THRESHOLD})`,
+              threshold: DEFAULT_DEGRADED_THRESHOLD,
+              options: {},
+            },
+            {
+              desc: 'a custom degraded threshold',
+              threshold: 2000,
+              options: { degradedThreshold: 2000 },
+            },
+          ])('using $desc', ({ threshold, options }) => {
+            describe('if the service execution time is below the threshold', () => {
+              it('does not call onDegraded listeners', async () => {
+                const maxConsecutiveFailures = DEFAULT_MAX_RETRIES + 2;
+                let invocationCounter = 0;
+                const mockService = (): { some: string } => {
+                  invocationCounter += 1;
+                  if (invocationCounter === DEFAULT_MAX_RETRIES + 1) {
+                    return { some: 'data' };
+                  }
+                  throw new Error('failure');
+                };
+                const onDegradedListener = jest.fn();
+                const policy = createServicePolicy({
+                  maxConsecutiveFailures,
+                  ...options,
+                });
+                policy.onDegraded(onDegradedListener);
+
+                const promise = policy.execute(mockService);
+                // It's safe not to await this promise; adding it to the promise
+                // queue is enough to prevent this test from running indefinitely.
+                // eslint-disable-next-line @typescript-eslint/no-floating-promises
+                clock.runAllAsync();
+                await promise;
+
+                expect(onDegradedListener).not.toHaveBeenCalled();
+              });
+
+              it('calls onAvailable listeners once, even if the service is called more than once', async () => {
+                const maxConsecutiveFailures = DEFAULT_MAX_RETRIES + 2;
+                let invocationCounter = 0;
+                const mockService = (): { some: string } => {
+                  invocationCounter += 1;
+                  if (invocationCounter >= DEFAULT_MAX_RETRIES + 1) {
+                    return { some: 'data' };
+                  }
+                  throw new Error('failure');
+                };
+                const onAvailableListener = jest.fn();
+                const policy = createServicePolicy({
+                  maxConsecutiveFailures,
+                  ...options,
+                });
+                policy.onAvailable(onAvailableListener);
+
+                const promise1 = policy.execute(mockService);
+                // It's safe not to await this promise; adding it to the promise
+                // queue is enough to prevent this test from running indefinitely.
+                // eslint-disable-next-line @typescript-eslint/no-floating-promises
+                clock.runAllAsync();
+                await promise1;
+                const promise2 = policy.execute(mockService);
+                // It's safe not to await this promise; adding it to the promise
+                // queue is enough to prevent this test from running indefinitely.
+                // eslint-disable-next-line @typescript-eslint/no-floating-promises
+                clock.runAllAsync();
+                await promise2;
+
+                expect(onAvailableListener).toHaveBeenCalledTimes(1);
+              });
+            });
+
+            describe('if the service execution time is beyond the threshold', () => {
+              it('calls onDegraded listeners once', async () => {
+                const maxConsecutiveFailures = DEFAULT_MAX_RETRIES + 2;
+                const delay = threshold + 1;
+                let invocationCounter = 0;
+                const mockService = (): Promise<{ some: string }> => {
+                  invocationCounter += 1;
+                  return new Promise((resolve, reject) => {
+                    if (invocationCounter === DEFAULT_MAX_RETRIES + 1) {
+                      setTimeout(() => resolve({ some: 'data' }), delay);
+                    } else {
+                      reject(new Error('failure'));
+                    }
+                  });
+                };
+                const onDegradedListener = jest.fn();
+                const policy = createServicePolicy({
+                  maxConsecutiveFailures,
+                  ...options,
+                });
+                policy.onDegraded(onDegradedListener);
+
+                const promise = policy.execute(mockService);
+                // It's safe not to await this promise; adding it to the promise
+                // queue is enough to prevent this test from running indefinitely.
+                // eslint-disable-next-line @typescript-eslint/no-floating-promises
+                clock.runAllAsync();
+                await promise;
+
+                expect(onDegradedListener).toHaveBeenCalledTimes(1);
+              });
+
+              it('does not call onAvailable listeners', async () => {
+                const maxConsecutiveFailures = DEFAULT_MAX_RETRIES + 2;
+                const delay = threshold + 1;
+                let invocationCounter = 0;
+                const mockService = (): Promise<{ some: string }> => {
+                  invocationCounter += 1;
+                  return new Promise((resolve, reject) => {
+                    if (invocationCounter === DEFAULT_MAX_RETRIES + 1) {
+                      setTimeout(() => resolve({ some: 'data' }), delay);
+                    } else {
+                      reject(new Error('failure'));
+                    }
+                  });
+                };
+                const onAvailableListener = jest.fn();
+                const policy = createServicePolicy({
+                  maxConsecutiveFailures,
+                  ...options,
+                });
+                policy.onAvailable(onAvailableListener);
+
+                const promise = policy.execute(mockService);
+                // It's safe not to await this promise; adding it to the promise
+                // queue is enough to prevent this test from running indefinitely.
+                // eslint-disable-next-line @typescript-eslint/no-floating-promises
+                clock.runAllAsync();
+                await promise;
+
+                expect(onAvailableListener).not.toHaveBeenCalled();
+              });
+            });
+          });
+        });
+
+        describe('if the initial run + retries is equal to the max number of consecutive failures', () => {
+          it('returns what the service returns', async () => {
+            const maxConsecutiveFailures = DEFAULT_MAX_RETRIES + 1;
+            let invocationCounter = 0;
+            const mockService = (): { some: string } => {
+              invocationCounter += 1;
+              if (invocationCounter === DEFAULT_MAX_RETRIES + 1) {
+                return { some: 'data' };
+              }
+              throw new Error('failure');
+            };
+            const policy = createServicePolicy({
+              maxConsecutiveFailures,
+            });
+
+            const promise = policy.execute(mockService);
+            // It's safe not to await this promise; adding it to the promise
+            // queue is enough to prevent this test from running indefinitely.
+            // eslint-disable-next-line @typescript-eslint/no-floating-promises
+            clock.runAllAsync();
+
+            expect(await promise).toStrictEqual({ some: 'data' });
+          });
+
+          it('does not call onBreak listeners', async () => {
+            const maxConsecutiveFailures = DEFAULT_MAX_RETRIES + 1;
+            let invocationCounter = 0;
+            const error = new Error('failure');
+            const mockService = (): { some: string } => {
+              invocationCounter += 1;
+              if (invocationCounter === DEFAULT_MAX_RETRIES + 1) {
+                return { some: 'data' };
+              }
+              throw error;
+            };
+            const onBreakListener = jest.fn();
+            const policy = createServicePolicy({
+              maxConsecutiveFailures,
+            });
+
+            policy.onBreak(onBreakListener);
+
+            const promise = policy.execute(mockService);
+            // It's safe not to await this promise; adding it to the promise
+            // queue is enough to prevent this test from running indefinitely.
+            // eslint-disable-next-line @typescript-eslint/no-floating-promises
+            clock.runAllAsync();
+            await promise;
+
+            expect(onBreakListener).not.toHaveBeenCalled();
+          });
+
+          describe.each([
+            {
+              desc: `the default degraded threshold (${DEFAULT_DEGRADED_THRESHOLD})`,
+              threshold: DEFAULT_DEGRADED_THRESHOLD,
+              options: {},
+            },
+            {
+              desc: 'a custom degraded threshold',
+              threshold: 2000,
+              options: { degradedThreshold: 2000 },
+            },
+          ])('using $desc', ({ threshold, options }) => {
+            describe('if the service execution time is below the threshold', () => {
+              it('does not call onDegraded listeners', async () => {
+                const maxConsecutiveFailures = DEFAULT_MAX_RETRIES + 1;
+                let invocationCounter = 0;
+                const error = new Error('failure');
+                const mockService = (): { some: string } => {
+                  invocationCounter += 1;
+                  if (invocationCounter === DEFAULT_MAX_RETRIES + 1) {
+                    return { some: 'data' };
+                  }
+                  throw error;
+                };
+                const onDegradedListener = jest.fn();
+                const policy = createServicePolicy({
+                  maxConsecutiveFailures,
+                  ...options,
+                });
+                policy.onDegraded(onDegradedListener);
+
+                const promise = policy.execute(mockService);
+                // It's safe not to await this promise; adding it to the promise
+                // queue is enough to prevent this test from running indefinitely.
+                // eslint-disable-next-line @typescript-eslint/no-floating-promises
+                clock.runAllAsync();
+                await promise;
+
+                expect(onDegradedListener).not.toHaveBeenCalled();
+              });
+
+              it('calls onAvailable listeners once, even if the service is called more than once', async () => {
+                const maxConsecutiveFailures = DEFAULT_MAX_RETRIES + 1;
+                let invocationCounter = 0;
+                const error = new Error('failure');
+                const mockService = (): { some: string } => {
+                  invocationCounter += 1;
+                  if (invocationCounter >= DEFAULT_MAX_RETRIES + 1) {
+                    return { some: 'data' };
+                  }
+                  throw error;
+                };
+                const onAvailableListener = jest.fn();
+                const policy = createServicePolicy({
+                  maxConsecutiveFailures,
+                  ...options,
+                });
+                policy.onAvailable(onAvailableListener);
+
+                const promise1 = policy.execute(mockService);
+                // It's safe not to await this promise; adding it to the promise
+                // queue is enough to prevent this test from running indefinitely.
+                // eslint-disable-next-line @typescript-eslint/no-floating-promises
+                clock.runAllAsync();
+                await promise1;
+                const promise2 = policy.execute(mockService);
+                // It's safe not to await this promise; adding it to the promise
+                // queue is enough to prevent this test from running indefinitely.
+                // eslint-disable-next-line @typescript-eslint/no-floating-promises
+                clock.runAllAsync();
+                await promise2;
+
+                expect(onAvailableListener).toHaveBeenCalledTimes(1);
+              });
+            });
+
+            describe('if the service execution time is beyond the threshold', () => {
+              it('calls onDegraded listeners once', async () => {
+                const maxConsecutiveFailures = DEFAULT_MAX_RETRIES + 1;
+                const delay = threshold + 1;
+                let invocationCounter = 0;
+                const mockService = (): Promise<{ some: string }> => {
+                  invocationCounter += 1;
+                  return new Promise((resolve, reject) => {
+                    if (invocationCounter === DEFAULT_MAX_RETRIES + 1) {
+                      setTimeout(() => resolve({ some: 'data' }), delay);
+                    } else {
+                      reject(new Error('failure'));
+                    }
+                  });
+                };
+                const onDegradedListener = jest.fn();
+                const policy = createServicePolicy({
+                  maxConsecutiveFailures,
+                  ...options,
+                });
+                policy.onDegraded(onDegradedListener);
+
+                const promise = policy.execute(mockService);
+                // It's safe not to await this promise; adding it to the promise
+                // queue is enough to prevent this test from running indefinitely.
+                // eslint-disable-next-line @typescript-eslint/no-floating-promises
+                clock.runAllAsync();
+                await promise;
+
+                expect(onDegradedListener).toHaveBeenCalledTimes(1);
+              });
+
+              it('does not call onAvailable listeners', async () => {
+                const maxConsecutiveFailures = DEFAULT_MAX_RETRIES + 1;
+                const delay = threshold + 1;
+                let invocationCounter = 0;
+                const mockService = (): Promise<{ some: string }> => {
+                  invocationCounter += 1;
+                  return new Promise((resolve, reject) => {
+                    if (invocationCounter === DEFAULT_MAX_RETRIES + 1) {
+                      setTimeout(() => resolve({ some: 'data' }), delay);
+                    } else {
+                      reject(new Error('failure'));
+                    }
+                  });
+                };
+                const onAvailableListener = jest.fn();
+                const policy = createServicePolicy({
+                  maxConsecutiveFailures,
+                  ...options,
+                });
+                policy.onAvailable(onAvailableListener);
+
+                const promise = policy.execute(mockService);
+                // It's safe not to await this promise; adding it to the promise
+                // queue is enough to prevent this test from running indefinitely.
+                // eslint-disable-next-line @typescript-eslint/no-floating-promises
+                clock.runAllAsync();
+                await promise;
+
+                expect(onAvailableListener).not.toHaveBeenCalled();
+              });
+            });
+          });
+        });
+
+        describe('if the initial run + retries is greater than the max number of consecutive failures', () => {
+          it('throws a BrokenCircuitError before the service can succeed', async () => {
+            const maxConsecutiveFailures = DEFAULT_MAX_RETRIES;
+            let invocationCounter = 0;
+            const error = new Error('failure');
+            const mockService = (): { some: string } => {
+              invocationCounter += 1;
+              if (invocationCounter === DEFAULT_MAX_RETRIES + 1) {
+                return { some: 'data' };
+              }
+              throw error;
+            };
+            const policy = createServicePolicy({
+              maxConsecutiveFailures,
+            });
+
+            const promise = policy.execute(mockService);
+            // It's safe not to await this promise; adding it to the promise
+            // queue is enough to prevent this test from running indefinitely.
+            // eslint-disable-next-line @typescript-eslint/no-floating-promises
+            clock.runAllAsync();
+            await expect(promise).rejects.toThrow(
+              new Error(
+                'Execution prevented because the circuit breaker is open',
+              ),
+            );
+          });
+
+          it('calls onBreak listeners once with the error', async () => {
+            const maxConsecutiveFailures = DEFAULT_MAX_RETRIES;
+            let invocationCounter = 0;
+            const error = new Error('failure');
+            const mockService = (): { some: string } => {
+              invocationCounter += 1;
+              if (invocationCounter === DEFAULT_MAX_RETRIES + 1) {
+                return { some: 'data' };
+              }
+              throw error;
+            };
+            const onBreakListener = jest.fn();
+            const policy = createServicePolicy({
+              maxConsecutiveFailures,
+            });
+
+            policy.onBreak(onBreakListener);
+
+            const promise = policy.execute(mockService);
+            // It's safe not to await this promise; adding it to the promise
+            // queue is enough to prevent this test from running indefinitely.
+            // eslint-disable-next-line @typescript-eslint/no-floating-promises
+            clock.runAllAsync();
+            await ignoreRejection(promise);
+
+            expect(onBreakListener).toHaveBeenCalledTimes(1);
+            expect(onBreakListener).toHaveBeenCalledWith({ error });
+          });
+
+          it('does not call onDegraded listeners', async () => {
+            const maxConsecutiveFailures = DEFAULT_MAX_RETRIES;
+            let invocationCounter = 0;
+            const error = new Error('failure');
+            const mockService = (): { some: string } => {
+              invocationCounter += 1;
+              if (invocationCounter === DEFAULT_MAX_RETRIES + 1) {
+                return { some: 'data' };
+              }
+              throw error;
+            };
+            const onDegradedListener = jest.fn();
+            const policy = createServicePolicy({
+              maxConsecutiveFailures,
+            });
+            policy.onDegraded(onDegradedListener);
+
+            const promise = policy.execute(mockService);
+            // It's safe not to await this promise; adding it to the promise
+            // queue is enough to prevent this test from running indefinitely.
+            // eslint-disable-next-line @typescript-eslint/no-floating-promises
+            clock.runAllAsync();
+            await ignoreRejection(promise);
+
+            expect(onDegradedListener).not.toHaveBeenCalled();
+          });
+
+          it('does not call onAvailable listeners', async () => {
+            const maxConsecutiveFailures = DEFAULT_MAX_RETRIES;
+            let invocationCounter = 0;
+            const error = new Error('failure');
+            const mockService = (): { some: string } => {
+              invocationCounter += 1;
+              if (invocationCounter === DEFAULT_MAX_RETRIES + 1) {
+                return { some: 'data' };
+              }
+              throw error;
+            };
+            const onAvailableListener = jest.fn();
+            const policy = createServicePolicy({
+              maxConsecutiveFailures,
+            });
+            policy.onAvailable(onAvailableListener);
+
+            const promise = policy.execute(mockService);
+            // It's safe not to await this promise; adding it to the promise
+            // queue is enough to prevent this test from running indefinitely.
+            // eslint-disable-next-line @typescript-eslint/no-floating-promises
+            clock.runAllAsync();
+            await ignoreRejection(promise);
+
+            expect(onAvailableListener).not.toHaveBeenCalled();
+          });
+
+          describe('after the circuit break duration has elapsed', () => {
+            describe.each([
+              {
+                desc: `the default circuit break duration (${DEFAULT_CIRCUIT_BREAK_DURATION})`,
+                duration: DEFAULT_CIRCUIT_BREAK_DURATION,
+                options: {},
+              },
+              {
+                desc: 'a custom circuit break duration',
+                duration: 5_000,
+                options: {
+                  // This has to be high enough to exceed the exponential backoff
+                  circuitBreakDuration: 5_000,
+                },
+              },
+            ])('using $desc', ({ duration, options }) => {
+              it('returns what the service returns', async () => {
+                const maxConsecutiveFailures = DEFAULT_MAX_RETRIES;
+                let invocationCounter = 0;
+                const error = new Error('failure');
+                const mockService = (): { some: string } => {
+                  invocationCounter += 1;
+                  if (invocationCounter === DEFAULT_MAX_RETRIES + 1) {
+                    return { some: 'data' };
+                  }
+                  throw error;
+                };
+                const policy = createServicePolicy({
+                  maxConsecutiveFailures,
+                  ...options,
+                });
+
+                const firstExecution = policy.execute(mockService);
+                // It's safe not to await this promise; adding it to the promise
+                // queue is enough to prevent this test from running indefinitely.
+                // eslint-disable-next-line @typescript-eslint/no-floating-promises
+                clock.runAllAsync();
+                await ignoreRejection(firstExecution);
+                clock.tick(duration);
+                const result = await policy.execute(mockService);
+
+                expect(result).toStrictEqual({ some: 'data' });
+              });
+
+              it('calls onAvailable listeners once, even if the service is called more than once', async () => {
+                const maxConsecutiveFailures = DEFAULT_MAX_RETRIES;
+                let invocationCounter = 0;
+                const error = new Error('failure');
+                const mockService = (): { some: string } => {
+                  invocationCounter += 1;
+                  if (invocationCounter >= DEFAULT_MAX_RETRIES + 1) {
+                    return { some: 'data' };
+                  }
+                  throw error;
+                };
+                const onAvailableListener = jest.fn();
+                const policy = createServicePolicy({
+                  maxConsecutiveFailures,
+                  ...options,
+                });
+                policy.onAvailable(onAvailableListener);
+
+                const firstExecution = policy.execute(mockService);
+                // It's safe not to await this promise; adding it to the promise
+                // queue is enough to prevent this test from running indefinitely.
+                // eslint-disable-next-line @typescript-eslint/no-floating-promises
+                clock.runAllAsync();
+                await ignoreRejection(firstExecution);
+                clock.tick(duration);
+                await policy.execute(mockService);
+                await policy.execute(mockService);
+
+                expect(onAvailableListener).toHaveBeenCalledTimes(1);
+              });
+            });
+          });
+        });
+      });
+    });
+
+    describe('using a custom max number of retries', () => {
+      it(`calls the service a total of 1 + <maxRetries> times, delaying each retry using a backoff formula`, async () => {
+        const maxRetries = 5;
+        let invocationCounter = 0;
+        const error = new Error('failure');
+        const mockService = jest.fn(() => {
+          invocationCounter += 1;
+          if (invocationCounter === maxRetries + 1) {
+            return { some: 'data' };
+          }
+          throw error;
+        });
+        const policy = createServicePolicy({ maxRetries });
+        // Each retry delay is randomized using a decorrelated jitter formula,
+        // so we need to prevent that
+        jest.spyOn(Math, 'random').mockReturnValue(0);
+
+        const promise = policy.execute(mockService);
+        // It's safe not to await these promises; adding them to the promise
+        // queue is enough to prevent this test from running indefinitely.
+        // eslint-disable-next-line @typescript-eslint/no-floating-promises
+        clock.tickAsync(0);
+        // eslint-disable-next-line @typescript-eslint/no-floating-promises
+        clock.tickAsync(176.27932892814937);
+        // eslint-disable-next-line @typescript-eslint/no-floating-promises
+        clock.tickAsync(186.8886145345685);
+        // eslint-disable-next-line @typescript-eslint/no-floating-promises
+        clock.tickAsync(366.8287823691078);
+        // eslint-disable-next-line @typescript-eslint/no-floating-promises
+        clock.tickAsync(731.8792783578953);
+        await promise;
+
+        expect(mockService).toHaveBeenCalledTimes(1 + maxRetries);
+      });
+
+      describe(`using the default max number of consecutive failures (${DEFAULT_MAX_CONSECUTIVE_FAILURES})`, () => {
+        describe('if the initial run + retries is less than the max number of consecutive failures', () => {
+          it('returns what the service returns', async () => {
+            const maxRetries = DEFAULT_MAX_CONSECUTIVE_FAILURES - 2;
+            let invocationCounter = 0;
+            const error = new Error('failure');
+            const mockService = (): { some: string } => {
+              invocationCounter += 1;
+              if (invocationCounter === maxRetries + 1) {
+                return { some: 'data' };
+              }
+              throw error;
+            };
+            const policy = createServicePolicy({ maxRetries });
+
+            const promise = policy.execute(mockService);
+            // It's safe not to await this promise; adding it to the promise
+            // queue is enough to prevent this test from running indefinitely.
+            // eslint-disable-next-line @typescript-eslint/no-floating-promises
+            clock.runAllAsync();
+
+            expect(await promise).toStrictEqual({ some: 'data' });
+          });
+
+          it('does not call onBreak listeners', async () => {
+            const maxRetries = DEFAULT_MAX_CONSECUTIVE_FAILURES - 2;
+            let invocationCounter = 0;
+            const error = new Error('failure');
+            const mockService = (): { some: string } => {
+              invocationCounter += 1;
+              if (invocationCounter === maxRetries + 1) {
+                return { some: 'data' };
+              }
+              throw error;
+            };
+            const onBreakListener = jest.fn();
+            const policy = createServicePolicy({ maxRetries });
+
+            policy.onBreak(onBreakListener);
+
+            const promise = policy.execute(mockService);
+            // It's safe not to await this promise; adding it to the promise
+            // queue is enough to prevent this test from running indefinitely.
+            // eslint-disable-next-line @typescript-eslint/no-floating-promises
+            clock.runAllAsync();
+            await promise;
+
+            expect(onBreakListener).not.toHaveBeenCalled();
+          });
+
+          describe.each([
+            {
+              desc: `the default degraded threshold (${DEFAULT_DEGRADED_THRESHOLD})`,
+              threshold: DEFAULT_DEGRADED_THRESHOLD,
+              options: {},
+            },
+            {
+              desc: 'a custom degraded threshold',
+              threshold: 2000,
+              options: { degradedThreshold: 2000 },
+            },
+          ])('using $desc', ({ threshold, options }) => {
+            describe('if the service execution time is below the threshold', () => {
+              it('does not call onDegraded listeners', async () => {
+                const maxRetries = DEFAULT_MAX_CONSECUTIVE_FAILURES - 2;
+                let invocationCounter = 0;
+                const error = new Error('failure');
+                const mockService = (): { some: string } => {
+                  invocationCounter += 1;
+                  if (invocationCounter === maxRetries + 1) {
+                    return { some: 'data' };
+                  }
+                  throw error;
+                };
+                const onDegradedListener = jest.fn();
+                const policy = createServicePolicy({ ...options, maxRetries });
+                policy.onDegraded(onDegradedListener);
+
+                const promise = policy.execute(mockService);
+                // It's safe not to await this promise; adding it to the promise
+                // queue is enough to prevent this test from running indefinitely.
+                // eslint-disable-next-line @typescript-eslint/no-floating-promises
+                clock.runAllAsync();
+                await promise;
+
+                expect(onDegradedListener).not.toHaveBeenCalled();
+              });
+
+              it('calls onAvailable listeners once, even if the service is called more than once', async () => {
+                const maxRetries = DEFAULT_MAX_CONSECUTIVE_FAILURES - 2;
+                let invocationCounter = 0;
+                const error = new Error('failure');
+                const mockService = (): { some: string } => {
+                  invocationCounter += 1;
+                  if (invocationCounter >= maxRetries + 1) {
+                    return { some: 'data' };
+                  }
+                  throw error;
+                };
+                const onAvailableListener = jest.fn();
+                const policy = createServicePolicy({ ...options, maxRetries });
+                policy.onAvailable(onAvailableListener);
+
+                const promise = policy.execute(mockService);
+                // It's safe not to await this promise; adding it to the promise
+                // queue is enough to prevent this test from running indefinitely.
+                // eslint-disable-next-line @typescript-eslint/no-floating-promises
+                clock.runAllAsync();
+                await promise;
+                await policy.execute(mockService);
+
+                expect(onAvailableListener).toHaveBeenCalledTimes(1);
+              });
+            });
+
+            describe('if the service execution time is beyond the threshold', () => {
+              it('calls onDegraded listeners once', async () => {
+                const maxRetries = DEFAULT_MAX_CONSECUTIVE_FAILURES - 2;
+                const delay = threshold + 1;
+                let invocationCounter = 0;
+                const mockService = (): Promise<{ some: string }> => {
+                  invocationCounter += 1;
+                  return new Promise((resolve, reject) => {
+                    if (invocationCounter === DEFAULT_MAX_RETRIES + 1) {
+                      setTimeout(() => resolve({ some: 'data' }), delay);
+                    } else {
+                      reject(new Error('failure'));
+                    }
+                  });
+                };
+                const onDegradedListener = jest.fn();
+                const policy = createServicePolicy({ ...options, maxRetries });
+                policy.onDegraded(onDegradedListener);
+
+                const promise = policy.execute(mockService);
+                // It's safe not to await this promise; adding it to the promise
+                // queue is enough to prevent this test from running indefinitely.
+                // eslint-disable-next-line @typescript-eslint/no-floating-promises
+                clock.runAllAsync();
+                await promise;
+
+                expect(onDegradedListener).toHaveBeenCalledTimes(1);
+              });
+
+              it('does not call onAvailable listeners', async () => {
+                const maxRetries = DEFAULT_MAX_CONSECUTIVE_FAILURES - 2;
+                const delay = threshold + 1;
+                let invocationCounter = 0;
+                const mockService = (): Promise<{ some: string }> => {
+                  invocationCounter += 1;
+                  return new Promise((resolve, reject) => {
+                    if (invocationCounter === DEFAULT_MAX_RETRIES + 1) {
+                      setTimeout(() => resolve({ some: 'data' }), delay);
+                    } else {
+                      reject(new Error('failure'));
+                    }
+                  });
+                };
+                const onAvailableListener = jest.fn();
+                const policy = createServicePolicy({ ...options, maxRetries });
+                policy.onAvailable(onAvailableListener);
+
+                const promise = policy.execute(mockService);
+                // It's safe not to await this promise; adding it to the promise
+                // queue is enough to prevent this test from running indefinitely.
+                // eslint-disable-next-line @typescript-eslint/no-floating-promises
+                clock.runAllAsync();
+                await promise;
+
+                expect(onAvailableListener).not.toHaveBeenCalled();
+              });
+            });
+          });
+        });
+
+        describe('if the initial run + retries is equal to the max number of consecutive failures', () => {
+          it('returns what the service returns', async () => {
+            const maxRetries = DEFAULT_MAX_CONSECUTIVE_FAILURES - 1;
+            let invocationCounter = 0;
+            const error = new Error('failure');
+            const mockService = (): { some: string } => {
+              invocationCounter += 1;
+              if (invocationCounter === maxRetries + 1) {
+                return { some: 'data' };
+              }
+              throw error;
+            };
+            const policy = createServicePolicy({ maxRetries });
+
+            const promise = policy.execute(mockService);
+            // It's safe not to await this promise; adding it to the promise
+            // queue is enough to prevent this test from running indefinitely.
+            // eslint-disable-next-line @typescript-eslint/no-floating-promises
+            clock.runAllAsync();
+
+            expect(await promise).toStrictEqual({ some: 'data' });
+          });
+
+          it('does not call onBreak listeners', async () => {
+            const maxRetries = DEFAULT_MAX_CONSECUTIVE_FAILURES - 1;
+            let invocationCounter = 0;
+            const error = new Error('failure');
+            const mockService = (): { some: string } => {
+              invocationCounter += 1;
+              if (invocationCounter === maxRetries + 1) {
+                return { some: 'data' };
+              }
+              throw error;
+            };
+            const onBreakListener = jest.fn();
+            const policy = createServicePolicy({ maxRetries });
+
+            policy.onBreak(onBreakListener);
+
+            const promise = policy.execute(mockService);
+            // It's safe not to await this promise; adding it to the promise
+            // queue is enough to prevent this test from running indefinitely.
+            // eslint-disable-next-line @typescript-eslint/no-floating-promises
+            clock.runAllAsync();
+            await promise;
+
+            expect(onBreakListener).not.toHaveBeenCalled();
+          });
+
+          describe.each([
+            {
+              desc: `the default degraded threshold (${DEFAULT_DEGRADED_THRESHOLD})`,
+              threshold: DEFAULT_DEGRADED_THRESHOLD,
+              options: {},
+            },
+            {
+              desc: 'a custom degraded threshold',
+              threshold: 2000,
+              options: { degradedThreshold: 2000 },
+            },
+          ])('using $desc', () => {
+            describe('if the service execution time is below the threshold', () => {
+              it('does not call onDegraded listeners', async () => {
+                const maxRetries = DEFAULT_MAX_CONSECUTIVE_FAILURES - 1;
+                let invocationCounter = 0;
+                const error = new Error('failure');
+                const mockService = (): { some: string } => {
+                  invocationCounter += 1;
+                  if (invocationCounter === maxRetries + 1) {
+                    return { some: 'data' };
+                  }
+                  throw error;
+                };
+                const onDegradedListener = jest.fn();
+                const policy = createServicePolicy({ maxRetries });
+                policy.onDegraded(onDegradedListener);
+
+                const promise = policy.execute(mockService);
+                // It's safe not to await this promise; adding it to the promise
+                // queue is enough to prevent this test from running indefinitely.
+                // eslint-disable-next-line @typescript-eslint/no-floating-promises
+                clock.runAllAsync();
+                await promise;
+
+                expect(onDegradedListener).not.toHaveBeenCalled();
+              });
+
+              it('calls onAvailable listeners once, even if the service is called more than once', async () => {
+                const maxRetries = DEFAULT_MAX_CONSECUTIVE_FAILURES - 1;
+                let invocationCounter = 0;
+                const error = new Error('failure');
+                const mockService = (): { some: string } => {
+                  invocationCounter += 1;
+                  if (invocationCounter >= maxRetries + 1) {
+                    return { some: 'data' };
+                  }
+                  throw error;
+                };
+                const onAvailableListener = jest.fn();
+                const policy = createServicePolicy({ maxRetries });
+                policy.onAvailable(onAvailableListener);
+
+                const promise = policy.execute(mockService);
+                // It's safe not to await this promise; adding it to the promise
+                // queue is enough to prevent this test from running indefinitely.
+                // eslint-disable-next-line @typescript-eslint/no-floating-promises
+                clock.runAllAsync();
+                await promise;
+                await policy.execute(mockService);
+
+                expect(onAvailableListener).toHaveBeenCalledTimes(1);
+              });
+            });
+
+            describe('if the service execution time is beyond the threshold', () => {
+              it('calls onDegraded listeners once', async () => {
+                const maxRetries = DEFAULT_MAX_CONSECUTIVE_FAILURES - 1;
+                const delay = DEFAULT_DEGRADED_THRESHOLD + 1;
+                let invocationCounter = 0;
+                const mockService = (): Promise<{ some: string }> => {
+                  invocationCounter += 1;
+                  return new Promise((resolve, reject) => {
+                    if (invocationCounter === DEFAULT_MAX_RETRIES + 1) {
+                      setTimeout(() => resolve({ some: 'data' }), delay);
+                    } else {
+                      reject(new Error('failure'));
+                    }
+                  });
+                };
+                const onDegradedListener = jest.fn();
+                const policy = createServicePolicy({ maxRetries });
+                policy.onDegraded(onDegradedListener);
+
+                const promise = policy.execute(mockService);
+                // It's safe not to await this promise; adding it to the promise
+                // queue is enough to prevent this test from running indefinitely.
+                // eslint-disable-next-line @typescript-eslint/no-floating-promises
+                clock.runAllAsync();
+                await promise;
+
+                expect(onDegradedListener).toHaveBeenCalledTimes(1);
+              });
+
+              it('does not call onAvailable listeners', async () => {
+                const maxRetries = DEFAULT_MAX_CONSECUTIVE_FAILURES - 1;
+                const delay = DEFAULT_DEGRADED_THRESHOLD + 1;
+                let invocationCounter = 0;
+                const mockService = (): Promise<{ some: string }> => {
+                  invocationCounter += 1;
+                  return new Promise((resolve, reject) => {
+                    if (invocationCounter === DEFAULT_MAX_RETRIES + 1) {
+                      setTimeout(() => resolve({ some: 'data' }), delay);
+                    } else {
+                      reject(new Error('failure'));
+                    }
+                  });
+                };
+                const onAvailableListener = jest.fn();
+                const policy = createServicePolicy({ maxRetries });
+                policy.onAvailable(onAvailableListener);
+
+                const promise = policy.execute(mockService);
+                // It's safe not to await this promise; adding it to the promise
+                // queue is enough to prevent this test from running indefinitely.
+                // eslint-disable-next-line @typescript-eslint/no-floating-promises
+                clock.runAllAsync();
+                await promise;
+
+                expect(onAvailableListener).not.toHaveBeenCalled();
+              });
+            });
+          });
+        });
+
+        describe('if the initial run + retries is greater than the max number of consecutive failures', () => {
+          it('throws a BrokenCircuitError before the service can succeed', async () => {
+            const maxRetries = DEFAULT_MAX_CONSECUTIVE_FAILURES;
+            let invocationCounter = 0;
+            const error = new Error('failure');
+            const mockService = (): { some: string } => {
+              invocationCounter += 1;
+              if (invocationCounter === maxRetries + 1) {
+                return { some: 'data' };
+              }
+              throw error;
+            };
+            const policy = createServicePolicy({ maxRetries });
+
+            const promise = policy.execute(mockService);
+            // It's safe not to await this promise; adding it to the promise
+            // queue is enough to prevent this test from running indefinitely.
+            // eslint-disable-next-line @typescript-eslint/no-floating-promises
+            clock.runAllAsync();
+
+            await expect(promise).rejects.toThrow(
+              new Error(
+                'Execution prevented because the circuit breaker is open',
+              ),
+            );
+          });
+
+          it('calls onBreak listeners once with the error', async () => {
+            const maxRetries = DEFAULT_MAX_CONSECUTIVE_FAILURES;
+            let invocationCounter = 0;
+            const error = new Error('failure');
+            const mockService = (): { some: string } => {
+              invocationCounter += 1;
+              if (invocationCounter === maxRetries + 1) {
+                return { some: 'data' };
+              }
+              throw error;
+            };
+            const onBreakListener = jest.fn();
+            const policy = createServicePolicy({ maxRetries });
+
+            policy.onBreak(onBreakListener);
+
+            const promise = policy.execute(mockService);
+            // It's safe not to await this promise; adding it to the promise
+            // queue is enough to prevent this test from running indefinitely.
+            // eslint-disable-next-line @typescript-eslint/no-floating-promises
+            clock.runAllAsync();
+            await ignoreRejection(promise);
+
+            expect(onBreakListener).toHaveBeenCalledTimes(1);
+            expect(onBreakListener).toHaveBeenCalledWith({ error });
+          });
+
+          it('does not call onDegraded listeners', async () => {
+            const maxRetries = DEFAULT_MAX_CONSECUTIVE_FAILURES;
+            let invocationCounter = 0;
+            const error = new Error('failure');
+            const mockService = (): { some: string } => {
+              invocationCounter += 1;
+              if (invocationCounter === maxRetries + 1) {
+                return { some: 'data' };
+              }
+              throw error;
+            };
+            const onDegradedListener = jest.fn();
+            const policy = createServicePolicy({ maxRetries });
+            policy.onDegraded(onDegradedListener);
+
+            const promise = policy.execute(mockService);
+            // It's safe not to await this promise; adding it to the promise
+            // queue is enough to prevent this test from running indefinitely.
+            // eslint-disable-next-line @typescript-eslint/no-floating-promises
+            clock.runAllAsync();
+            await ignoreRejection(promise);
+
+            expect(onDegradedListener).not.toHaveBeenCalled();
+          });
+
+          it('does not call onAvailable listeners', async () => {
+            const maxRetries = DEFAULT_MAX_CONSECUTIVE_FAILURES;
+            let invocationCounter = 0;
+            const error = new Error('failure');
+            const mockService = (): { some: string } => {
+              invocationCounter += 1;
+              if (invocationCounter === maxRetries + 1) {
+                return { some: 'data' };
+              }
+              throw error;
+            };
+            const onAvailableListener = jest.fn();
+            const policy = createServicePolicy({ maxRetries });
+            policy.onAvailable(onAvailableListener);
+
+            const promise = policy.execute(mockService);
+            // It's safe not to await this promise; adding it to the promise
+            // queue is enough to prevent this test from running indefinitely.
+            // eslint-disable-next-line @typescript-eslint/no-floating-promises
+            clock.runAllAsync();
+            await ignoreRejection(promise);
+
+            expect(onAvailableListener).not.toHaveBeenCalled();
+          });
+
+          describe('after the circuit break duration has elapsed', () => {
+            describe.each([
+              {
+                desc: `the default circuit break duration (${DEFAULT_CIRCUIT_BREAK_DURATION})`,
+                duration: DEFAULT_CIRCUIT_BREAK_DURATION,
+                options: {},
+              },
+              {
+                desc: 'a custom circuit break duration',
+                duration: 5_000,
+                options: {
+                  // This has to be high enough to exceed the exponential backoff
+                  circuitBreakDuration: 50_000,
+                },
+              },
+            ])('using $desc', ({ duration, options }) => {
+              it('returns what the service returns', async () => {
+                const maxRetries = DEFAULT_MAX_CONSECUTIVE_FAILURES;
+                let invocationCounter = 0;
+                const error = new Error('failure');
+                const mockService = (): { some: string } => {
+                  invocationCounter += 1;
+                  if (invocationCounter === maxRetries + 1) {
+                    return { some: 'data' };
+                  }
+                  throw error;
+                };
+                const policy = createServicePolicy({ maxRetries, ...options });
+
+                const firstExecution = policy.execute(mockService);
+                // It's safe not to await this promise; adding it to the promise
+                // queue is enough to prevent this test from running indefinitely.
+                // eslint-disable-next-line @typescript-eslint/no-floating-promises
+                clock.runAllAsync();
+                await ignoreRejection(firstExecution);
+                clock.tick(duration);
+                const result = await policy.execute(mockService);
+
+                expect(result).toStrictEqual({ some: 'data' });
+              });
+
+              it('calls onAvailable listeners once, even if the service is called more than once', async () => {
+                const maxRetries = DEFAULT_MAX_CONSECUTIVE_FAILURES;
+                let invocationCounter = 0;
+                const error = new Error('failure');
+                const mockService = (): { some: string } => {
+                  invocationCounter += 1;
+                  if (invocationCounter >= maxRetries + 1) {
+                    return { some: 'data' };
+                  }
+                  throw error;
+                };
+                const onAvailableListener = jest.fn();
+                const policy = createServicePolicy({ maxRetries, ...options });
+                policy.onAvailable(onAvailableListener);
+
+                const firstExecution = policy.execute(mockService);
+                // It's safe not to await this promise; adding it to the promise
+                // queue is enough to prevent this test from running indefinitely.
+                // eslint-disable-next-line @typescript-eslint/no-floating-promises
+                clock.runAllAsync();
+                await ignoreRejection(firstExecution);
+                clock.tick(duration);
+                await policy.execute(mockService);
+                await policy.execute(mockService);
+
+                expect(onAvailableListener).toHaveBeenCalledTimes(1);
+              });
+            });
+          });
+        });
+      });
+
+      describe('using a custom max number of consecutive failures', () => {
+        describe('if the initial run + retries is less than the max number of consecutive failures', () => {
+          it('returns what the service returns', async () => {
+            const maxConsecutiveFailures = 5;
+            const maxRetries = maxConsecutiveFailures - 2;
+            let invocationCounter = 0;
+            const error = new Error('failure');
+            const mockService = (): { some: string } => {
+              invocationCounter += 1;
+              if (invocationCounter === maxRetries + 1) {
+                return { some: 'data' };
+              }
+              throw error;
+            };
+            const policy = createServicePolicy({
+              maxRetries,
+              maxConsecutiveFailures,
+            });
+
+            const promise = policy.execute(mockService);
+            // It's safe not to await this promise; adding it to the promise
+            // queue is enough to prevent this test from running indefinitely.
+            // eslint-disable-next-line @typescript-eslint/no-floating-promises
+            clock.runAllAsync();
+
+            expect(await promise).toStrictEqual({ some: 'data' });
+          });
+
+          it('does not call onBreak listeners', async () => {
+            const maxConsecutiveFailures = 5;
+            const maxRetries = maxConsecutiveFailures - 2;
+            let invocationCounter = 0;
+            const error = new Error('failure');
+            const mockService = (): { some: string } => {
+              invocationCounter += 1;
+              if (invocationCounter === maxRetries + 1) {
+                return { some: 'data' };
+              }
+              throw error;
+            };
+            const onBreakListener = jest.fn();
+            const policy = createServicePolicy({
+              maxRetries,
+              maxConsecutiveFailures,
+            });
+
+            policy.onBreak(onBreakListener);
+
+            const promise = policy.execute(mockService);
+            // It's safe not to await this promise; adding it to the promise
+            // queue is enough to prevent this test from running indefinitely.
+            // eslint-disable-next-line @typescript-eslint/no-floating-promises
+            clock.runAllAsync();
+            await promise;
+
+            expect(onBreakListener).not.toHaveBeenCalled();
+          });
+
+          describe.each([
+            {
+              desc: `the default degraded threshold (${DEFAULT_DEGRADED_THRESHOLD})`,
+              threshold: DEFAULT_DEGRADED_THRESHOLD,
+              options: {},
+            },
+            {
+              desc: 'a custom degraded threshold',
+              threshold: 2000,
+              options: { degradedThreshold: 2000 },
+            },
+          ])('using $desc', ({ threshold, options }) => {
+            describe('if the service execution time is below the threshold', () => {
+              it('does not call onDegraded listeners', async () => {
+                const maxConsecutiveFailures = 5;
+                const maxRetries = maxConsecutiveFailures - 2;
+                let invocationCounter = 0;
+                const error = new Error('failure');
+                const mockService = (): { some: string } => {
+                  invocationCounter += 1;
+                  if (invocationCounter === maxRetries + 1) {
+                    return { some: 'data' };
+                  }
+                  throw error;
+                };
+                const onDegradedListener = jest.fn();
+                const policy = createServicePolicy({
+                  maxRetries,
+                  maxConsecutiveFailures,
+                  ...options,
+                });
+                policy.onDegraded(onDegradedListener);
+
+                const promise = policy.execute(mockService);
+                // It's safe not to await this promise; adding it to the promise
+                // queue is enough to prevent this test from running indefinitely.
+                // eslint-disable-next-line @typescript-eslint/no-floating-promises
+                clock.runAllAsync();
+                await promise;
+
+                expect(onDegradedListener).not.toHaveBeenCalled();
+              });
+
+              it('calls onAvailable listeners once, even if the service is called more than once', async () => {
+                const maxConsecutiveFailures = 5;
+                const maxRetries = maxConsecutiveFailures - 2;
+                let invocationCounter = 0;
+                const error = new Error('failure');
+                const mockService = (): { some: string } => {
+                  invocationCounter += 1;
+                  if (invocationCounter >= maxRetries + 1) {
+                    return { some: 'data' };
+                  }
+                  throw error;
+                };
+                const onAvailableListener = jest.fn();
+                const policy = createServicePolicy({
+                  maxRetries,
+                  maxConsecutiveFailures,
+                  ...options,
+                });
+                policy.onAvailable(onAvailableListener);
+
+                const promise1 = policy.execute(mockService);
+                // It's safe not to await this promise; adding it to the promise
+                // queue is enough to prevent this test from running indefinitely.
+                // eslint-disable-next-line @typescript-eslint/no-floating-promises
+                clock.runAllAsync();
+                await promise1;
+                const promise2 = policy.execute(mockService);
+                // It's safe not to await this promise; adding it to the promise
+                // queue is enough to prevent this test from running indefinitely.
+                // eslint-disable-next-line @typescript-eslint/no-floating-promises
+                clock.runAllAsync();
+                await promise2;
+
+                expect(onAvailableListener).toHaveBeenCalledTimes(1);
+              });
+            });
+
+            describe('if the service execution time is beyond the threshold', () => {
+              it('calls onDegraded listeners once', async () => {
+                const maxConsecutiveFailures = 5;
+                const maxRetries = maxConsecutiveFailures - 2;
+                const delay = DEFAULT_DEGRADED_THRESHOLD + 1;
+                let invocationCounter = 0;
+                const mockService = (): Promise<{ some: string }> => {
+                  invocationCounter += 1;
+                  return new Promise((resolve, reject) => {
+                    if (invocationCounter === DEFAULT_MAX_RETRIES + 1) {
+                      setTimeout(() => resolve({ some: 'data' }), delay);
+                    } else {
+                      reject(new Error('failure'));
+                    }
+                  });
+                };
+                const onDegradedListener = jest.fn();
+                const policy = createServicePolicy({
+                  maxRetries,
+                  maxConsecutiveFailures,
+                  ...options,
+                });
+                policy.onDegraded(onDegradedListener);
+
+                const promise = policy.execute(mockService);
+                // It's safe not to await this promise; adding it to the promise
+                // queue is enough to prevent this test from running indefinitely.
+                // eslint-disable-next-line @typescript-eslint/no-floating-promises
+                clock.runAllAsync();
+                await promise;
+
+                expect(onDegradedListener).toHaveBeenCalledTimes(1);
+              });
+
+              it('does not call onAvailable listeners', async () => {
+                const maxConsecutiveFailures = 5;
+                const maxRetries = maxConsecutiveFailures - 2;
+                const delay = threshold + 1;
+                let invocationCounter = 0;
+                const mockService = (): Promise<{ some: string }> => {
+                  invocationCounter += 1;
+                  return new Promise((resolve, reject) => {
+                    if (invocationCounter === DEFAULT_MAX_RETRIES + 1) {
+                      setTimeout(() => resolve({ some: 'data' }), delay);
+                    } else {
+                      reject(new Error('failure'));
+                    }
+                  });
+                };
+                const onAvailableListener = jest.fn();
+                const policy = createServicePolicy({
+                  maxRetries,
+                  maxConsecutiveFailures,
+                  ...options,
+                });
+                policy.onAvailable(onAvailableListener);
+
+                const promise = policy.execute(mockService);
+                // It's safe not to await this promise; adding it to the promise
+                // queue is enough to prevent this test from running indefinitely.
+                // eslint-disable-next-line @typescript-eslint/no-floating-promises
+                clock.runAllAsync();
+                await promise;
+
+                expect(onAvailableListener).not.toHaveBeenCalled();
+              });
+            });
+          });
+        });
+
+        describe('if the initial run + retries is equal to the max number of consecutive failures', () => {
+          it('returns what the service returns', async () => {
+            const maxConsecutiveFailures = 5;
+            const maxRetries = maxConsecutiveFailures - 1;
+            let invocationCounter = 0;
+            const error = new Error('failure');
+            const mockService = (): { some: string } => {
+              invocationCounter += 1;
+              if (invocationCounter === maxRetries + 1) {
+                return { some: 'data' };
+              }
+              throw error;
+            };
+            const policy = createServicePolicy({
+              maxRetries,
+              maxConsecutiveFailures,
+            });
+
+            const promise = policy.execute(mockService);
+            // It's safe not to await this promise; adding it to the promise
+            // queue is enough to prevent this test from running indefinitely.
+            // eslint-disable-next-line @typescript-eslint/no-floating-promises
+            clock.runAllAsync();
+
+            expect(await promise).toStrictEqual({ some: 'data' });
+          });
+
+          it('does not call onBreak listeners', async () => {
+            const maxConsecutiveFailures = 5;
+            const maxRetries = maxConsecutiveFailures - 1;
+            let invocationCounter = 0;
+            const error = new Error('failure');
+            const mockService = (): { some: string } => {
+              invocationCounter += 1;
+              if (invocationCounter === maxRetries + 1) {
+                return { some: 'data' };
+              }
+              throw error;
+            };
+            const onBreakListener = jest.fn();
+            const policy = createServicePolicy({
+              maxRetries,
+              maxConsecutiveFailures,
+            });
+
+            policy.onBreak(onBreakListener);
+
+            const promise = policy.execute(mockService);
+            // It's safe not to await this promise; adding it to the promise
+            // queue is enough to prevent this test from running indefinitely.
+            // eslint-disable-next-line @typescript-eslint/no-floating-promises
+            clock.runAllAsync();
+            await promise;
+
+            expect(onBreakListener).not.toHaveBeenCalled();
+          });
+
+          describe.each([
+            {
+              desc: `the default degraded threshold (${DEFAULT_DEGRADED_THRESHOLD})`,
+              threshold: DEFAULT_DEGRADED_THRESHOLD,
+              options: {},
+            },
+            {
+              desc: 'a custom degraded threshold',
+              threshold: 2000,
+              options: { degradedThreshold: 2000 },
+            },
+          ])('using $desc', ({ threshold, options }) => {
+            describe('if the service execution time is below the threshold', () => {
+              it('does not call onDegraded listeners', async () => {
+                const maxConsecutiveFailures = 5;
+                const maxRetries = maxConsecutiveFailures - 1;
+                let invocationCounter = 0;
+                const error = new Error('failure');
+                const mockService = (): { some: string } => {
+                  invocationCounter += 1;
+                  if (invocationCounter === maxRetries + 1) {
+                    return { some: 'data' };
+                  }
+                  throw error;
+                };
+                const onDegradedListener = jest.fn();
+                const policy = createServicePolicy({
+                  maxRetries,
+                  maxConsecutiveFailures,
+                  ...options,
+                });
+                policy.onDegraded(onDegradedListener);
+
+                const promise = policy.execute(mockService);
+                // It's safe not to await this promise; adding it to the promise
+                // queue is enough to prevent this test from running indefinitely.
+                // eslint-disable-next-line @typescript-eslint/no-floating-promises
+                clock.runAllAsync();
+                await promise;
+
+                expect(onDegradedListener).not.toHaveBeenCalled();
+              });
+
+              it('calls onAvailable listeners once, even if the service is called more than once', async () => {
+                const maxConsecutiveFailures = 5;
+                const maxRetries = maxConsecutiveFailures - 1;
+                let invocationCounter = 0;
+                const error = new Error('failure');
+                const mockService = (): { some: string } => {
+                  invocationCounter += 1;
+                  if (invocationCounter % (maxRetries + 1) === 0) {
+                    return { some: 'data' };
+                  }
+                  throw error;
+                };
+                const onAvailableListener = jest.fn();
+                const policy = createServicePolicy({
+                  maxRetries,
+                  maxConsecutiveFailures,
+                  ...options,
+                });
+                policy.onAvailable(onAvailableListener);
+
+                const promise1 = policy.execute(mockService);
+                // It's safe not to await this promise; adding it to the promise
+                // queue is enough to prevent this test from running indefinitely.
+                // eslint-disable-next-line @typescript-eslint/no-floating-promises
+                clock.runAllAsync();
+                await promise1;
+                const promise2 = policy.execute(mockService);
+                // It's safe not to await this promise; adding it to the promise
+                // queue is enough to prevent this test from running indefinitely.
+                // eslint-disable-next-line @typescript-eslint/no-floating-promises
+                clock.runAllAsync();
+                await promise2;
+
+                expect(onAvailableListener).toHaveBeenCalledTimes(1);
+              });
+            });
+
+            describe('if the service execution time is beyond the threshold', () => {
+              it('calls onDegraded listeners once', async () => {
+                const maxConsecutiveFailures = 5;
+                const maxRetries = maxConsecutiveFailures - 1;
+                const delay = threshold + 1;
+                let invocationCounter = 0;
+                const mockService = (): Promise<{ some: string }> => {
+                  invocationCounter += 1;
+                  return new Promise((resolve, reject) => {
+                    if (invocationCounter === DEFAULT_MAX_RETRIES + 1) {
+                      setTimeout(() => resolve({ some: 'data' }), delay);
+                    } else {
+                      reject(new Error('failure'));
+                    }
+                  });
+                };
+                const onDegradedListener = jest.fn();
+                const policy = createServicePolicy({
+                  maxRetries,
+                  maxConsecutiveFailures,
+                  ...options,
+                });
+                policy.onDegraded(onDegradedListener);
+
+                const promise = policy.execute(mockService);
+                // It's safe not to await this promise; adding it to the promise
+                // queue is enough to prevent this test from running indefinitely.
+                // eslint-disable-next-line @typescript-eslint/no-floating-promises
+                clock.runAllAsync();
+                await promise;
+
+                expect(onDegradedListener).toHaveBeenCalledTimes(1);
+              });
+
+              it('does not call onAvailable listeners', async () => {
+                const maxConsecutiveFailures = 5;
+                const maxRetries = maxConsecutiveFailures - 1;
+                const delay = threshold + 1;
+                let invocationCounter = 0;
+                const mockService = (): Promise<{ some: string }> => {
+                  invocationCounter += 1;
+                  return new Promise((resolve, reject) => {
+                    if (invocationCounter === DEFAULT_MAX_RETRIES + 1) {
+                      setTimeout(() => resolve({ some: 'data' }), delay);
+                    } else {
+                      reject(new Error('failure'));
+                    }
+                  });
+                };
+                const onAvailableListener = jest.fn();
+                const policy = createServicePolicy({
+                  maxRetries,
+                  maxConsecutiveFailures,
+                  ...options,
+                });
+                policy.onAvailable(onAvailableListener);
+
+                const promise = policy.execute(mockService);
+                // It's safe not to await this promise; adding it to the promise
+                // queue is enough to prevent this test from running indefinitely.
+                // eslint-disable-next-line @typescript-eslint/no-floating-promises
+                clock.runAllAsync();
+                await promise;
+
+                expect(onAvailableListener).not.toHaveBeenCalled();
+              });
+            });
+          });
+        });
+
+        describe('if the initial run + retries is greater than the max number of consecutive failures', () => {
+          it('throws a BrokenCircuitError before the service can succeed', async () => {
+            const maxConsecutiveFailures = 5;
+            const maxRetries = maxConsecutiveFailures;
+            let invocationCounter = 0;
+            const error = new Error('failure');
+            const mockService = (): { some: string } => {
+              invocationCounter += 1;
+              if (invocationCounter === maxRetries + 1) {
+                return { some: 'data' };
+              }
+              throw error;
+            };
+            const policy = createServicePolicy({
+              maxRetries,
+              maxConsecutiveFailures,
+            });
+
+            const promise = policy.execute(mockService);
+            // It's safe not to await this promise; adding it to the promise
+            // queue is enough to prevent this test from running indefinitely.
+            // eslint-disable-next-line @typescript-eslint/no-floating-promises
+            clock.runAllAsync();
+            await ignoreRejection(promise);
+
+            await expect(promise).rejects.toThrow(
+              new Error(
+                'Execution prevented because the circuit breaker is open',
+              ),
+            );
+          });
+
+          it('calls onBreak listeners once with the error', async () => {
+            const maxConsecutiveFailures = 5;
+            const maxRetries = maxConsecutiveFailures;
+            let invocationCounter = 0;
+            const error = new Error('failure');
+            const mockService = (): { some: string } => {
+              invocationCounter += 1;
+              if (invocationCounter === maxRetries + 1) {
+                return { some: 'data' };
+              }
+              throw error;
+            };
+            const onBreakListener = jest.fn();
+            const policy = createServicePolicy({
+              maxRetries,
+              maxConsecutiveFailures,
+            });
+
+            policy.onBreak(onBreakListener);
+
+            const promise = policy.execute(mockService);
+            // It's safe not to await this promise; adding it to the promise
+            // queue is enough to prevent this test from running indefinitely.
+            // eslint-disable-next-line @typescript-eslint/no-floating-promises
+            clock.runAllAsync();
+            await ignoreRejection(promise);
+
+            expect(onBreakListener).toHaveBeenCalledTimes(1);
+            expect(onBreakListener).toHaveBeenCalledWith({ error });
+          });
+
+          it('does not call onDegraded listeners', async () => {
+            const maxConsecutiveFailures = 5;
+            const maxRetries = maxConsecutiveFailures;
+            let invocationCounter = 0;
+            const error = new Error('failure');
+            const mockService = (): { some: string } => {
+              invocationCounter += 1;
+              if (invocationCounter === maxRetries + 1) {
+                return { some: 'data' };
+              }
+              throw error;
+            };
+            const onDegradedListener = jest.fn();
+            const policy = createServicePolicy({
+              maxRetries,
+              maxConsecutiveFailures,
+            });
+            policy.onDegraded(onDegradedListener);
+
+            const promise = policy.execute(mockService);
+            // It's safe not to await this promise; adding it to the promise
+            // queue is enough to prevent this test from running indefinitely.
+            // eslint-disable-next-line @typescript-eslint/no-floating-promises
+            clock.runAllAsync();
+            await ignoreRejection(promise);
+
+            expect(onDegradedListener).not.toHaveBeenCalled();
+          });
+
+          it('does not call onAvailable listeners', async () => {
+            const maxConsecutiveFailures = 5;
+            const maxRetries = maxConsecutiveFailures;
+            let invocationCounter = 0;
+            const error = new Error('failure');
+            const mockService = (): { some: string } => {
+              invocationCounter += 1;
+              if (invocationCounter === maxRetries + 1) {
+                return { some: 'data' };
+              }
+              throw error;
+            };
+            const onAvailableListener = jest.fn();
+            const policy = createServicePolicy({
+              maxRetries,
+              maxConsecutiveFailures,
+            });
+            policy.onAvailable(onAvailableListener);
+
+            const promise = policy.execute(mockService);
+            // It's safe not to await this promise; adding it to the promise
+            // queue is enough to prevent this test from running indefinitely.
+            // eslint-disable-next-line @typescript-eslint/no-floating-promises
+            clock.runAllAsync();
+            await ignoreRejection(promise);
+
+            expect(onAvailableListener).not.toHaveBeenCalled();
+          });
+
+          describe('after the circuit break duration has elapsed', () => {
+            describe.each([
+              {
+                desc: `the default circuit break duration (${DEFAULT_CIRCUIT_BREAK_DURATION})`,
+                duration: DEFAULT_CIRCUIT_BREAK_DURATION,
+                options: {},
+              },
+              {
+                desc: 'a custom circuit break duration',
+                duration: 5_000,
+                options: {
+                  // This has to be high enough to exceed the exponential backoff
+                  circuitBreakDuration: 5_000,
+                },
+              },
+            ])('using $desc', ({ duration, options }) => {
+              it('returns what the service returns', async () => {
+                const maxConsecutiveFailures = 5;
+                const maxRetries = maxConsecutiveFailures;
+                let invocationCounter = 0;
+                const error = new Error('failure');
+                const mockService = (): { some: string } => {
+                  invocationCounter += 1;
+                  if (invocationCounter === maxRetries + 1) {
+                    return { some: 'data' };
+                  }
+                  throw error;
+                };
+                const policy = createServicePolicy({
+                  maxRetries,
+                  maxConsecutiveFailures,
+                  ...options,
+                });
+
+                const firstExecution = policy.execute(mockService);
+                // It's safe not to await this promise; adding it to the promise
+                // queue is enough to prevent this test from running indefinitely.
+                // eslint-disable-next-line @typescript-eslint/no-floating-promises
+                clock.runAllAsync();
+                await ignoreRejection(firstExecution);
+                clock.tick(duration);
+                const result = await policy.execute(mockService);
+
+                expect(result).toStrictEqual({ some: 'data' });
+              });
+
+              it('calls onAvailable listeners once, even if the service is called more than once', async () => {
+                const maxConsecutiveFailures = 5;
+                const maxRetries = maxConsecutiveFailures;
+                let invocationCounter = 0;
+                const error = new Error('failure');
+                const mockService = (): { some: string } => {
+                  invocationCounter += 1;
+                  if (invocationCounter >= maxRetries + 1) {
+                    return { some: 'data' };
+                  }
+                  throw error;
+                };
+                const onAvailableListener = jest.fn();
+                const policy = createServicePolicy({
+                  maxRetries,
+                  maxConsecutiveFailures,
+                  ...options,
+                });
+                policy.onAvailable(onAvailableListener);
+
+                const firstExecution = policy.execute(mockService);
+                // It's safe not to await this promise; adding it to the promise
+                // queue is enough to prevent this test from running indefinitely.
+                // eslint-disable-next-line @typescript-eslint/no-floating-promises
+                clock.runAllAsync();
+                await ignoreRejection(firstExecution);
+                clock.tick(duration);
+                await policy.execute(mockService);
+                await policy.execute(mockService);
+
+                expect(onAvailableListener).toHaveBeenCalledTimes(1);
+              });
+            });
+          });
+        });
+      });
+    });
+  });
+
+  describe('wrapping a service that succeeds at first and then fails enough to break the circuit', () => {
+    describe.each([
+      {
+        desc: `the default max number of consecutive failures (${DEFAULT_MAX_CONSECUTIVE_FAILURES})`,
+        maxConsecutiveFailures: DEFAULT_MAX_CONSECUTIVE_FAILURES,
+        optionsWithMaxConsecutiveFailures: {},
+      },
+      {
+        desc: 'a custom max number of consecutive failures',
+        maxConsecutiveFailures: DEFAULT_MAX_RETRIES + 1,
+        optionsWithMaxConsecutiveFailures: {
+          maxConsecutiveFailures: DEFAULT_MAX_RETRIES + 1,
+        },
+      },
+    ])(
+      'using $desc',
+      ({ maxConsecutiveFailures, optionsWithMaxConsecutiveFailures }) => {
+        describe.each([
+          {
+            desc: `the default circuit break duration (${DEFAULT_CIRCUIT_BREAK_DURATION})`,
+            circuitBreakDuration: DEFAULT_CIRCUIT_BREAK_DURATION,
+            optionsWithCircuitBreakDuration: {},
+          },
+          {
+            desc: 'a custom circuit break duration',
+            circuitBreakDuration: DEFAULT_CIRCUIT_BREAK_DURATION,
+            optionsWithCircuitBreakDuration: {
+              // This has to be high enough to exceed the exponential backoff
+              circuitBreakDuration: 5_000,
+            },
+          },
+        ])(
+          'using $desc',
+          ({ circuitBreakDuration, optionsWithCircuitBreakDuration }) => {
+            it('calls onAvailable listeners if the service finally succeeds', async () => {
+              let invocationCounter = 0;
+              const mockService = jest.fn(() => {
+                invocationCounter += 1;
+                if (
+                  invocationCounter === 1 ||
+                  invocationCounter === maxConsecutiveFailures + 2
+                ) {
+                  return { some: 'data' };
+                }
+                throw new Error('failure');
+              });
+              const onAvailableListener = jest.fn();
+              const policy = createServicePolicy({
+                ...optionsWithMaxConsecutiveFailures,
+                ...optionsWithCircuitBreakDuration,
+              });
+              policy.onRetry(() => {
+                clock.next();
+              });
+              policy.onAvailable(onAvailableListener);
+
+              // Execute the service successfully once
+              await policy.execute(mockService);
+              expect(onAvailableListener).toHaveBeenCalledTimes(1);
+
+              // Execute and retry until we break the circuit
+              await ignoreRejection(policy.execute(mockService));
+              await ignoreRejection(policy.execute(mockService));
+              await ignoreRejection(policy.execute(mockService));
+              clock.tick(circuitBreakDuration);
+
+              await policy.execute(mockService);
+              expect(onAvailableListener).toHaveBeenCalledTimes(2);
+            });
+
+            it('does not call onAvailable listeners if the service finally fails', async () => {
+              let invocationCounter = 0;
+              const mockService = jest.fn(() => {
+                invocationCounter += 1;
+                if (invocationCounter === 1) {
+                  return { some: 'data' };
+                }
+                throw new Error('failure');
+              });
+              const onAvailableListener = jest.fn();
+              const policy = createServicePolicy({
+                ...optionsWithMaxConsecutiveFailures,
+                ...optionsWithCircuitBreakDuration,
+              });
+              policy.onRetry(() => {
+                clock.next();
+              });
+              policy.onAvailable(onAvailableListener);
+
+              // Execute the service successfully once
+              await policy.execute(mockService);
+              expect(onAvailableListener).toHaveBeenCalledTimes(1);
+
+              // Execute and retry until we break the circuit
+              await ignoreRejection(policy.execute(mockService));
+              await ignoreRejection(policy.execute(mockService));
+              await ignoreRejection(policy.execute(mockService));
+              clock.tick(circuitBreakDuration);
+
+              await ignoreRejection(policy.execute(mockService));
+              expect(onAvailableListener).toHaveBeenCalledTimes(1);
+            });
+          },
+        );
+      },
+    );
+  });
+
+  describe('getRemainingCircuitOpenDuration', () => {
+    it('returns the number of milliseconds before the circuit will transition from open to half-open', async () => {
+      const mockService = (): never => {
+        throw new Error('failure');
+      };
+      const policy = createServicePolicy();
+      policy.onRetry(() => {
+        clock.next();
+      });
+      // Retry until we break the circuit
+      await ignoreRejection(policy.execute(mockService));
+      await ignoreRejection(policy.execute(mockService));
+      await ignoreRejection(policy.execute(mockService));
+      clock.tick(1000);
+
+      expect(policy.getRemainingCircuitOpenDuration()).toBe(
+        DEFAULT_CIRCUIT_BREAK_DURATION - 1000,
+      );
+    });
+
+    it('returns null if the circuit is closed', () => {
+      const policy = createServicePolicy();
+
+      expect(policy.getRemainingCircuitOpenDuration()).toBeNull();
+    });
+  });
+
+  describe('getCircuitState', () => {
+    it('returns the state of the circuit', async () => {
+      const mockService = (): never => {
+        throw new Error('failure');
+      };
+      const policy = createServicePolicy();
+      policy.onRetry(() => {
+        clock.next();
+      });
+
+      expect(policy.getCircuitState()).toBe(CircuitState.Closed);
+
+      // Retry until we break the circuit
+      await ignoreRejection(policy.execute(mockService));
+      await ignoreRejection(policy.execute(mockService));
+      await ignoreRejection(policy.execute(mockService));
+      expect(policy.getCircuitState()).toBe(CircuitState.Open);
+
+      clock.tick(DEFAULT_CIRCUIT_BREAK_DURATION);
+      const promise = ignoreRejection(policy.execute(mockService));
+      expect(policy.getCircuitState()).toBe(CircuitState.HalfOpen);
+      await promise;
+      expect(policy.getCircuitState()).toBe(CircuitState.Open);
+    });
+  });
+
+  describe('reset', () => {
+    it('resets the state of the circuit to "closed"', async () => {
+      let invocationCounter = 0;
+      const mockService = jest.fn(() => {
+        invocationCounter += 1;
+        if (invocationCounter === DEFAULT_MAX_CONSECUTIVE_FAILURES + 1) {
+          return { some: 'data' };
+        }
+        throw new Error('failure');
+      });
+      const policy = createServicePolicy();
+      policy.onRetry(() => {
+        clock.next();
+      });
+      // Retry until we break the circuit
+      await ignoreRejection(policy.execute(mockService));
+      await ignoreRejection(policy.execute(mockService));
+      await ignoreRejection(policy.execute(mockService));
+      expect(policy.getCircuitState()).toBe(CircuitState.Open);
+
+      policy.reset();
+
+      expect(policy.getCircuitState()).toBe(CircuitState.Closed);
+    });
+
+    it('allows the service to be executed successfully again if its circuit has broken after resetting', async () => {
+      let invocationCounter = 0;
+      const mockService = jest.fn(() => {
+        invocationCounter += 1;
+        if (invocationCounter === DEFAULT_MAX_CONSECUTIVE_FAILURES + 1) {
+          return { some: 'data' };
+        }
+        throw new Error('failure');
+      });
+      const policy = createServicePolicy();
+      policy.onRetry(() => {
+        clock.next();
+      });
+      // Retry until we break the circuit
+      await ignoreRejection(policy.execute(mockService));
+      await ignoreRejection(policy.execute(mockService));
+      await ignoreRejection(policy.execute(mockService));
+
+      policy.reset();
+
+      expect(await policy.execute(mockService)).toStrictEqual({ some: 'data' });
+    });
+
+    it('calls onAvailable listeners if the service was executed successfully, its circuit broke, it was reset, and executes again, successfully', async () => {
+      let invocationCounter = 0;
+      const mockService = jest.fn(() => {
+        invocationCounter += 1;
+        if (
+          invocationCounter === 1 ||
+          invocationCounter === DEFAULT_MAX_CONSECUTIVE_FAILURES + 2
+        ) {
+          return { some: 'data' };
+        }
+        throw new Error('failure');
+      });
+      const onAvailableListener = jest.fn();
+      const policy = createServicePolicy();
+      policy.onRetry(() => {
+        clock.next();
+      });
+      policy.onAvailable(onAvailableListener);
+
+      // Execute the service successfully once
+      await policy.execute(mockService);
+      expect(onAvailableListener).toHaveBeenCalledTimes(1);
+
+      // Execute and retry until we break the circuit
+      await ignoreRejection(policy.execute(mockService));
+      await ignoreRejection(policy.execute(mockService));
+      await ignoreRejection(policy.execute(mockService));
+
+      policy.reset();
+
+      await policy.execute(mockService);
+      expect(onAvailableListener).toHaveBeenCalledTimes(2);
+    });
+
+    it('allows the service to be executed unsuccessfully again if its circuit has broken after resetting', async () => {
+      const mockService = jest.fn(() => {
+        throw new Error('failure');
+      });
+      const policy = createServicePolicy();
+      policy.onRetry(() => {
+        clock.next();
+      });
+      // Retry until we break the circuit
+      await ignoreRejection(policy.execute(mockService));
+      await ignoreRejection(policy.execute(mockService));
+      await ignoreRejection(policy.execute(mockService));
+
+      policy.reset();
+
+      await expect(policy.execute(mockService)).rejects.toThrow('failure');
+    });
+  });
+});
+
+/**
+ * Some tests involve a rejected promise that is not necessarily the focus of
+ * the test. In these cases we don't want to ignore the error in case the
+ * promise _isn't_ rejected, but we don't want to highlight the assertion,
+ * either.
+ *
+ * @param promise - A promise that rejects.
+ */
+async function ignoreRejection<Type>(promise: Promise<Type>): Promise<void> {
+  await expect(promise).rejects.toThrow(expect.any(Error));
+}
diff --git a/src/create-service-policy.ts b/src/create-service-policy.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dc394bca76c2d3ae88eb6fa056212886baaa0bbe
--- /dev/null
+++ b/src/create-service-policy.ts
@@ -0,0 +1,410 @@
+import {
+  BrokenCircuitError,
+  CircuitState,
+  EventEmitter as CockatielEventEmitter,
+  ConsecutiveBreaker,
+  ExponentialBackoff,
+  ConstantBackoff,
+  circuitBreaker,
+  handleAll,
+  handleWhen,
+  retry,
+  wrap,
+} from 'cockatiel';
+import type {
+  CircuitBreakerPolicy,
+  Event as CockatielEvent,
+  FailureReason,
+  IBackoffFactory,
+  IPolicy,
+  Policy,
+  RetryPolicy,
+} from 'cockatiel';
+
+export {
+  BrokenCircuitError,
+  CockatielEventEmitter,
+  CircuitState,
+  ConstantBackoff,
+  ExponentialBackoff,
+  handleAll,
+  handleWhen,
+};
+
+export type { CockatielEvent, FailureReason as CockatielFailureReason };
+
+/**
+ * The options for `createServicePolicy`.
+ */
+export type CreateServicePolicyOptions = {
+  /**
+   * The backoff strategy to use. Mainly useful for testing so that a constant
+   * backoff can be used when mocking timers. Defaults to an instance of
+   * ExponentialBackoff.
+   */
+  backoff?: IBackoffFactory<unknown>;
+  /**
+   * The length of time (in milliseconds) to pause retries of the action after
+   * the number of failures reaches `maxConsecutiveFailures`.
+   */
+  circuitBreakDuration?: number;
+  /**
+   * The length of time (in milliseconds) that governs when the service is
+   * regarded as degraded (affecting when `onDegraded` is called).
+   */
+  degradedThreshold?: number;
+  /**
+   * The maximum number of times that the service is allowed to fail before
+   * pausing further retries.
+   */
+  maxConsecutiveFailures?: number;
+  /**
+   * The maximum number of times that a failing service should be re-invoked
+   * before giving up.
+   */
+  maxRetries?: number;
+  /**
+   * The policy used to control when the service should be retried based on
+   * either the result of the service or an error that it throws. For instance,
+   * you could use this to retry only certain errors. See `handleWhen` and
+   * friends from Cockatiel for more.
+   */
+  retryFilterPolicy?: Policy;
+};
+
+/**
+ * The service policy object.
+ */
+export type ServicePolicy = IPolicy & {
+  /**
+   * The Cockatiel circuit breaker policy that the service policy uses
+   * internally.
+   */
+  circuitBreakerPolicy: CircuitBreakerPolicy;
+  /**
+   * The amount of time to pause requests to the service if the number of
+   * maximum consecutive failures is reached.
+   */
+  circuitBreakDuration: number;
+  /**
+   * @returns The state of the underlying circuit.
+   */
+  getCircuitState: () => CircuitState;
+  /**
+   * If the circuit is open and ongoing requests are paused, returns the number
+   * of milliseconds before the requests will be attempted again. If the circuit
+   * is not open, returns null.
+   */
+  getRemainingCircuitOpenDuration: () => number | null;
+  /**
+   * Resets the internal circuit breaker policy (if it is open, it will now be
+   * closed).
+   */
+  reset: () => void;
+  /**
+   * The Cockatiel retry policy that the service policy uses internally.
+   */
+  retryPolicy: RetryPolicy;
+  /**
+   * A function which is called when the number of times that the service fails
+   * in a row meets the set maximum number of consecutive failures.
+   */
+  onBreak: CircuitBreakerPolicy['onBreak'];
+  /**
+   * A function which is called in two circumstances: 1) when the service
+   * succeeds before the maximum number of consecutive failures is reached, but
+   * takes more time than the `degradedThreshold` to run, or 2) if the service
+   * never succeeds before the retry policy gives up and before the maximum
+   * number of consecutive failures has been reached.
+   */
+  onDegraded: CockatielEvent<FailureReason<unknown> | void>;
+  /**
+   * A function which is called when the service succeeds for the first time,
+   * or when the service fails enough times to cause the circuit to break and
+   * then recovers.
+   */
+  onAvailable: CockatielEvent<void>;
+  /**
+   * A function which will be called by the retry policy each time the service
+   * fails and the policy kicks off a timer to re-run the service. This is
+   * primarily useful in tests where we are mocking timers.
+   */
+  onRetry: RetryPolicy['onRetry'];
+};
+
+/**
+ * Parts of the circuit breaker's internal and external state as necessary in
+ * order to compute the time remaining before the circuit will reopen.
+ */
+type InternalCircuitState =
+  | {
+      state: CircuitState.Open;
+      openedAt: number;
+    }
+  | { state: Exclude<CircuitState, CircuitState.Open> };
+
+/**
+ * Availability statuses that the service can be in.
+ *
+ * Used to keep track of whether the `onAvailable` event should be fired.
+ */
+const AVAILABILITY_STATUSES = {
+  Available: 'available',
+  Degraded: 'degraded',
+  Unavailable: 'unavailable',
+  Unknown: 'unknown',
+} as const;
+
+/**
+ * Availability statuses that the service can be in.
+ *
+ * Used to keep track of whether the `onAvailable` event should be fired.
+ */
+type AvailabilityStatus =
+  (typeof AVAILABILITY_STATUSES)[keyof typeof AVAILABILITY_STATUSES];
+
+/**
+ * The maximum number of times that a failing service should be re-run before
+ * giving up.
+ */
+export const DEFAULT_MAX_RETRIES = 3;
+
+/**
+ * The maximum number of times that the service is allowed to fail before
+ * pausing further retries. This is set to a value such that if given a
+ * service that continually fails, the policy needs to be executed 3 times
+ * before further retries are paused.
+ */
+export const DEFAULT_MAX_CONSECUTIVE_FAILURES = (1 + DEFAULT_MAX_RETRIES) * 3;
+
+/**
+ * The default length of time (in milliseconds) to temporarily pause retries of
+ * the service after enough consecutive failures.
+ */
+export const DEFAULT_CIRCUIT_BREAK_DURATION = 30 * 60 * 1000;
+
+/**
+ * The default length of time (in milliseconds) that governs when the service is
+ * regarded as degraded (affecting when `onDegraded` is called).
+ */
+export const DEFAULT_DEGRADED_THRESHOLD = 5_000;
+
+const isServiceFailure = (error: unknown): boolean => {
+  if (
+    typeof error === 'object' &&
+    error !== null &&
+    'httpStatus' in error &&
+    typeof error.httpStatus === 'number'
+  ) {
+    return error.httpStatus >= 500;
+  }
+
+  // If the error is not an object, or doesn't have a numeric code property,
+  // consider it a service failure (e.g., network errors, timeouts, etc.)
+  return true;
+};
+
+/**
+ * The circuit breaker policy inside of the Cockatiel library exposes some of
+ * its state, but not all of it. Notably, the time that the circuit opened is
+ * not publicly accessible. So we have to record this ourselves.
+ *
+ * This function therefore allows us to obtain the circuit breaker state that we
+ * wish we could access.
+ *
+ * @param state - The public state of a circuit breaker policy.
+ * @returns if the circuit is open, the state of the circuit breaker policy plus
+ * the time that it opened, otherwise just the circuit state.
+ */
+function getInternalCircuitState(state: CircuitState): InternalCircuitState {
+  if (state === CircuitState.Open) {
+    return { state, openedAt: Date.now() };
+  }
+  return { state };
+}
+
+/**
+ * Constructs an object exposing an `execute` method which, given a function 
+ * hereafter called the "service"  will retry that service with ever increasing
+ * delays until it succeeds. If the policy detects too many consecutive
+ * failures, it will block further retries until a designated time period has
+ * passed; this particular behavior is primarily designed for services that wrap
+ * API calls so as not to make needless HTTP requests when the API is down and
+ * to be able to recover when the API comes back up. In addition, hooks allow
+ * for responding to certain events, one of which can be used to detect when an
+ * HTTP request is performing slowly.
+ *
+ * Internally, this function makes use of the retry and circuit breaker policies
+ * from the [Cockatiel](https://www.npmjs.com/package/cockatiel) library; see
+ * there for more.
+ *
+ * @param options - The options to this function. See
+ * {@link CreateServicePolicyOptions}.
+ * @returns The service policy.
+ * @example
+ * This function is designed to be used in the context of a service class like
+ * this:
+ * ``` ts
+ * class Service {
+ *   constructor() {
+ *     this.#policy = createServicePolicy({
+ *       maxRetries: 3,
+ *       retryFilterPolicy: handleWhen((error) => {
+ *         return error.message.includes('oops');
+ *       }),
+ *       maxConsecutiveFailures: 3,
+ *       circuitBreakDuration: 5000,
+ *       degradedThreshold: 2000,
+ *       onBreak: () => {
+ *         console.log('Circuit broke');
+ *       },
+ *       onDegraded: () => {
+ *         console.log('Service is degraded');
+ *       },
+ *     });
+ *   }
+ *
+ *   async fetch() {
+ *     return await this.#policy.execute(async () => {
+ *       const response = await fetch('https://some/url');
+ *       return await response.json();
+ *     });
+ *   }
+ * }
+ * ```
+ */
+export function createServicePolicy(
+  options: CreateServicePolicyOptions = {},
+): ServicePolicy {
+  const {
+    maxRetries = DEFAULT_MAX_RETRIES,
+    retryFilterPolicy = handleAll,
+    maxConsecutiveFailures = DEFAULT_MAX_CONSECUTIVE_FAILURES,
+    circuitBreakDuration = DEFAULT_CIRCUIT_BREAK_DURATION,
+    degradedThreshold = DEFAULT_DEGRADED_THRESHOLD,
+    backoff = new ExponentialBackoff(),
+  } = options;
+
+  let availabilityStatus: AvailabilityStatus = AVAILABILITY_STATUSES.Unknown;
+
+  const retryPolicy = retry(retryFilterPolicy, {
+    // Note that although the option here is called "max attempts", it's really
+    // maximum number of *retries* (attempts past the initial attempt).
+    maxAttempts: maxRetries,
+    // Retries of the service will be executed following ever increasing delays,
+    // determined by a backoff formula.
+    backoff,
+  });
+  const onRetry = retryPolicy.onRetry.bind(retryPolicy);
+
+  const consecutiveBreaker = new ConsecutiveBreaker(maxConsecutiveFailures);
+  const circuitBreakerPolicy = circuitBreaker(handleWhen(isServiceFailure), {
+    // While the circuit is open, any additional invocations of the service
+    // passed to the policy (either via automatic retries or by manually
+    // executing the policy again) will result in a BrokenCircuitError. This
+    // will remain the case until `circuitBreakDuration` passes, after which the
+    // service will be allowed to run again. If the service succeeds, the
+    // circuit will close, otherwise it will remain open.
+    halfOpenAfter: circuitBreakDuration,
+    breaker: consecutiveBreaker,
+  });
+
+  let internalCircuitState: InternalCircuitState = getInternalCircuitState(
+    circuitBreakerPolicy.state,
+  );
+  circuitBreakerPolicy.onStateChange((state) => {
+    internalCircuitState = getInternalCircuitState(state);
+  });
+
+  circuitBreakerPolicy.onBreak(() => {
+    availabilityStatus = AVAILABILITY_STATUSES.Unavailable;
+  });
+  const onBreak = circuitBreakerPolicy.onBreak.bind(circuitBreakerPolicy);
+
+  const onDegradedEventEmitter =
+    new CockatielEventEmitter<FailureReason<unknown> | void>();
+  const onDegraded = onDegradedEventEmitter.addListener;
+
+  const onAvailableEventEmitter = new CockatielEventEmitter<void>();
+  const onAvailable = onAvailableEventEmitter.addListener;
+
+  retryPolicy.onGiveUp((data) => {
+    if (circuitBreakerPolicy.state === CircuitState.Closed) {
+      availabilityStatus = AVAILABILITY_STATUSES.Degraded;
+      onDegradedEventEmitter.emit(data);
+    }
+  });
+  retryPolicy.onSuccess(({ duration }) => {
+    if (circuitBreakerPolicy.state === CircuitState.Closed) {
+      if (duration > degradedThreshold) {
+        availabilityStatus = AVAILABILITY_STATUSES.Degraded;
+        onDegradedEventEmitter.emit();
+      } else if (availabilityStatus !== AVAILABILITY_STATUSES.Available) {
+        availabilityStatus = AVAILABILITY_STATUSES.Available;
+        onAvailableEventEmitter.emit();
+      }
+    }
+  });
+
+  // Every time the retry policy makes an attempt, it executes the circuit
+  // breaker policy, which executes the service.
+  //
+  // Calling:
+  //
+  //   policy.execute(() => {
+  //     // do what the service does
+  //   })
+  //
+  // is equivalent to:
+  //
+  //   retryPolicy.execute(() => {
+  //     circuitBreakerPolicy.execute(() => {
+  //       // do what the service does
+  //     });
+  //   });
+  //
+  // So if the retry policy succeeds or fails, it is because the circuit breaker
+  // policy succeeded or failed. And if there are any event listeners registered
+  // on the retry policy, by the time they are called, the state of the circuit
+  // breaker will have already changed.
+  const policy = wrap(retryPolicy, circuitBreakerPolicy);
+
+  const getRemainingCircuitOpenDuration = (): number | null => {
+    if (internalCircuitState.state === CircuitState.Open) {
+      return internalCircuitState.openedAt + circuitBreakDuration - Date.now();
+    }
+    return null;
+  };
+
+  const getCircuitState = (): CircuitState => {
+    return circuitBreakerPolicy.state;
+  };
+
+  const reset = (): void => {
+    // Set the state of the policy to "isolated" regardless of its current state
+    const { dispose } = circuitBreakerPolicy.isolate();
+    // Reset the state to "closed"
+    dispose();
+
+    // Reset the counter on the breaker as well
+    consecutiveBreaker.success();
+
+    // Re-initialize the availability status so that if the service is executed
+    // successfully, onAvailable listeners will be called again
+    availabilityStatus = AVAILABILITY_STATUSES.Unknown;
+  };
+
+  return {
+    ...policy,
+    circuitBreakerPolicy,
+    circuitBreakDuration,
+    getCircuitState,
+    getRemainingCircuitOpenDuration,
+    reset,
+    retryPolicy,
+    onBreak,
+    onDegraded,
+    onAvailable,
+    onRetry,
+  };
+}
diff --git a/src/index.test.ts b/src/index.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1167bdcdfade4a93346b423fc397e05085efe3f4
--- /dev/null
+++ b/src/index.test.ts
@@ -0,0 +1,98 @@
+import * as allExports from '.';
+
+describe('@metamask/controller-utils', () => {
+  it('has expected JavaScript exports', () => {
+    expect(Object.keys(allExports)).toMatchInlineSnapshot(`
+      Array [
+        "BrokenCircuitError",
+        "CircuitState",
+        "CockatielEventEmitter",
+        "ConstantBackoff",
+        "DEFAULT_CIRCUIT_BREAK_DURATION",
+        "DEFAULT_DEGRADED_THRESHOLD",
+        "DEFAULT_MAX_CONSECUTIVE_FAILURES",
+        "DEFAULT_MAX_RETRIES",
+        "ExponentialBackoff",
+        "createServicePolicy",
+        "handleAll",
+        "handleWhen",
+        "RPC",
+        "FALL_BACK_VS_CURRENCY",
+        "IPFS_DEFAULT_GATEWAY_URL",
+        "GANACHE_CHAIN_ID",
+        "MAX_SAFE_CHAIN_ID",
+        "ERC721",
+        "ERC1155",
+        "ERC20",
+        "ERC721_INTERFACE_ID",
+        "ERC721_METADATA_INTERFACE_ID",
+        "ERC721_ENUMERABLE_INTERFACE_ID",
+        "ERC1155_INTERFACE_ID",
+        "ERC1155_METADATA_URI_INTERFACE_ID",
+        "ERC1155_TOKEN_RECEIVER_INTERFACE_ID",
+        "GWEI",
+        "ASSET_TYPES",
+        "TESTNET_TICKER_SYMBOLS",
+        "BUILT_IN_CUSTOM_NETWORKS_RPC",
+        "BUILT_IN_NETWORKS",
+        "OPENSEA_PROXY_URL",
+        "NFT_API_BASE_URL",
+        "NFT_API_VERSION",
+        "NFT_API_TIMEOUT",
+        "ORIGIN_METAMASK",
+        "ApprovalType",
+        "CHAIN_ID_TO_ETHERS_NETWORK_NAME_MAP",
+        "SECOND",
+        "SECONDS",
+        "MINUTE",
+        "MINUTES",
+        "HOUR",
+        "HOURS",
+        "DAY",
+        "DAYS",
+        "NETWORKS_BYPASSING_VALIDATION",
+        "BNToHex",
+        "convertHexToDecimal",
+        "fetchWithErrorHandling",
+        "fractionBN",
+        "fromHex",
+        "getBuyURL",
+        "gweiDecToWEIBN",
+        "handleFetch",
+        "hexToBN",
+        "hexToText",
+        "HttpError",
+        "isNonEmptyArray",
+        "isPlainObject",
+        "isSafeChainId",
+        "isSafeDynamicKey",
+        "isSmartContractCode",
+        "isValidJson",
+        "isValidHexAddress",
+        "normalizeEnsName",
+        "query",
+        "safelyExecute",
+        "safelyExecuteWithTimeout",
+        "successfulFetch",
+        "timeoutFetch",
+        "toChecksumHexAddress",
+        "toHex",
+        "weiHexToGweiDec",
+        "isEqualCaseInsensitive",
+        "InfuraNetworkType",
+        "CustomNetworkType",
+        "NetworkType",
+        "isNetworkType",
+        "isInfuraNetworkType",
+        "BuiltInNetworkName",
+        "ChainId",
+        "NetworksTicker",
+        "BlockExplorerUrl",
+        "NetworkNickname",
+        "parseDomainParts",
+        "isValidSIWEOrigin",
+        "detectSIWE",
+      ]
+    `);
+  });
+});
diff --git a/src/index.ts b/src/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c07b7df7dfaff29b69a481bad82a710f6b2f2c20
--- /dev/null
+++ b/src/index.ts
@@ -0,0 +1,90 @@
+export {
+  BrokenCircuitError,
+  CircuitState,
+  CockatielEventEmitter,
+  ConstantBackoff,
+  DEFAULT_CIRCUIT_BREAK_DURATION,
+  DEFAULT_DEGRADED_THRESHOLD,
+  DEFAULT_MAX_CONSECUTIVE_FAILURES,
+  DEFAULT_MAX_RETRIES,
+  ExponentialBackoff,
+  createServicePolicy,
+  handleAll,
+  handleWhen,
+} from './create-service-policy';
+export type {
+  CockatielEvent,
+  CreateServicePolicyOptions,
+  CockatielFailureReason,
+  ServicePolicy,
+} from './create-service-policy';
+export {
+  RPC,
+  FALL_BACK_VS_CURRENCY,
+  IPFS_DEFAULT_GATEWAY_URL,
+  GANACHE_CHAIN_ID,
+  MAX_SAFE_CHAIN_ID,
+  ERC721,
+  ERC1155,
+  ERC20,
+  ERC721_INTERFACE_ID,
+  ERC721_METADATA_INTERFACE_ID,
+  ERC721_ENUMERABLE_INTERFACE_ID,
+  ERC1155_INTERFACE_ID,
+  ERC1155_METADATA_URI_INTERFACE_ID,
+  ERC1155_TOKEN_RECEIVER_INTERFACE_ID,
+  GWEI,
+  ASSET_TYPES,
+  TESTNET_TICKER_SYMBOLS,
+  BUILT_IN_CUSTOM_NETWORKS_RPC,
+  BUILT_IN_NETWORKS,
+  OPENSEA_PROXY_URL,
+  NFT_API_BASE_URL,
+  NFT_API_VERSION,
+  NFT_API_TIMEOUT,
+  ORIGIN_METAMASK,
+  ApprovalType,
+  CHAIN_ID_TO_ETHERS_NETWORK_NAME_MAP,
+  SECOND,
+  SECONDS,
+  MINUTE,
+  MINUTES,
+  HOUR,
+  HOURS,
+  DAY,
+  DAYS,
+  NETWORKS_BYPASSING_VALIDATION,
+} from './constants';
+export type { NonEmptyArray } from './util';
+export {
+  BNToHex,
+  convertHexToDecimal,
+  fetchWithErrorHandling,
+  fractionBN,
+  fromHex,
+  getBuyURL,
+  gweiDecToWEIBN,
+  handleFetch,
+  hexToBN,
+  hexToText,
+  HttpError,
+  isNonEmptyArray,
+  isPlainObject,
+  isSafeChainId,
+  isSafeDynamicKey,
+  isSmartContractCode,
+  isValidJson,
+  isValidHexAddress,
+  normalizeEnsName,
+  query,
+  safelyExecute,
+  safelyExecuteWithTimeout,
+  successfulFetch,
+  timeoutFetch,
+  toChecksumHexAddress,
+  toHex,
+  weiHexToGweiDec,
+  isEqualCaseInsensitive,
+} from './util';
+export * from './types';
+export * from './siwe';
diff --git a/src/logger.ts b/src/logger.ts
new file mode 100644
index 0000000000000000000000000000000000000000..488f8177d21e29992f00ad8b53b02fb2c37ed571
--- /dev/null
+++ b/src/logger.ts
@@ -0,0 +1,5 @@
+import { createProjectLogger, createModuleLogger } from '@metamask/utils';
+
+export const projectLogger = createProjectLogger('controller-utils');
+
+export { createModuleLogger };
diff --git a/src/siwe.test.ts b/src/siwe.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c792ac3499fb2b82aa81a40e0e11e6ca55352353
--- /dev/null
+++ b/src/siwe.test.ts
@@ -0,0 +1,258 @@
+import { ParsedMessage } from '@spruceid/siwe-parser';
+
+import { detectSIWE, isValidSIWEOrigin } from './siwe';
+
+const siweMessage =
+  'example.com wants you to sign in with your Ethereum account:\n0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\n\n\nURI: https://example.com/login\nVersion: 1\nChain ID: 1\nNonce: 32891756\nIssued At: 2021-09-30T16:25:24Z';
+const parsedMessage = new ParsedMessage(siweMessage);
+
+describe('siwe', () => {
+  describe('detectSIWE', () => {
+    const textAsHex = (string: string): string => {
+      return Buffer.from(string, 'utf8').toString('hex');
+    };
+
+    it('returns an object with isSIWEMessage set to true and parsedMessage', () => {
+      const result = detectSIWE({ data: textAsHex(siweMessage) });
+      expect(result.isSIWEMessage).toBe(true);
+      expect(result.parsedMessage).toStrictEqual(parsedMessage);
+    });
+
+    it('returns an object with isSIWEMessage set to true and parsedMessage when scheme is provided', () => {
+      const messageWithScheme = `https://${siweMessage}`;
+      const parsedMessageWithScheme = new ParsedMessage(messageWithScheme);
+      const result = detectSIWE({ data: textAsHex(messageWithScheme) });
+
+      expect(result.isSIWEMessage).toBe(true);
+      expect(result.parsedMessage).toStrictEqual(parsedMessageWithScheme);
+    });
+
+    it('returns an object with isSIWEMessage set to false and parsedMessage set to null', () => {
+      const result = detectSIWE({ data: '0xINVALIDDATA' });
+      expect(result.isSIWEMessage).toBe(false);
+      expect(result.parsedMessage).toBeNull();
+    });
+  });
+
+  describe('isValidSIWEOrigin', () => {
+    const checks = [
+      {
+        name: 'identical domain',
+        expected: true,
+        cases: [
+          {
+            domain: 'example.com',
+            origin: 'https://example.com',
+          },
+          {
+            domain: 'example.com',
+            origin: 'http://example.com',
+          },
+          {
+            domain: 'example.com',
+            origin: 'https://example.com:443',
+          },
+          {
+            domain: 'example.com',
+            origin: 'http://example.com:80',
+          },
+          {
+            domain: 'eXAMPLe.cOM',
+            origin: 'hTtp://ExamPLE.CoM',
+          },
+          {
+            domain: 'example.com',
+            origin: 'https://user:password@example.com',
+          },
+          {
+            domain: 'example.com',
+            origin: 'https://user@example.com',
+          },
+          {
+            domain: 'example.com',
+            origin: 'http://user:password@example.com:8090',
+          },
+          {
+            domain: 'example.com',
+            origin: 'http://user@example.com:8090',
+          },
+          {
+            domain: 'example.com',
+            origin: 'http://example.com:8090',
+          },
+          {
+            domain: 'example.com',
+            origin: 'https://example.com:8090',
+          },
+        ],
+      },
+      {
+        name: 'matching domain and port',
+        expected: true,
+        cases: [
+          {
+            domain: 'example.com:443',
+            origin: 'https://example.com:443',
+          },
+          {
+            domain: 'example.com:443',
+            origin: 'https://example.com',
+          },
+          {
+            domain: 'example.com:443',
+            origin: 'http://example.com:443',
+          },
+          {
+            domain: 'example.com:80',
+            origin: 'http://example.com',
+          },
+          {
+            domain: 'example.com:80',
+            origin: 'http://example.com:80',
+          },
+          {
+            domain: 'example.com:80',
+            origin: 'https://example.com:80',
+          },
+          {
+            domain: 'example.com:8090',
+            origin: 'http://example.com:8090',
+          },
+          {
+            domain: 'example.com:8080',
+            origin: 'https://example.com:8080',
+          },
+        ],
+      },
+      {
+        name: 'matching userinfo',
+        expected: true,
+        cases: [
+          {
+            domain: 'alice@example.com',
+            origin: 'https://alice:password@example.com',
+          },
+          {
+            domain: 'alice@example.com',
+            origin: 'https://alice@example.com',
+          },
+          {
+            domain: 'alice@example.com:8090',
+            origin: 'https://alice@example.com:8090',
+          },
+        ],
+      },
+      {
+        name: 'mismatching userinfo',
+        expected: false,
+        cases: [
+          {
+            domain: 'alice@example.com',
+            origin: 'https://bob@example.com',
+          },
+          {
+            domain: 'alice@example.com',
+            origin: 'https://example.com',
+          },
+          {
+            domain: 'alice@example.com:8090',
+            origin: 'https://bob:alice@example.com:8090',
+          },
+        ],
+      },
+      {
+        name: 'mismatching domain',
+        expected: false,
+        cases: [
+          {
+            domain: 'example.com',
+            origin: 'http://www.example.com',
+          },
+          {
+            domain: 'www.example.com',
+            origin: 'http://example.com',
+          },
+          {
+            domain: 'example.com',
+            origin: 'https://foo.example.com',
+          },
+          {
+            domain: 'foo.example.com',
+            origin: 'https://example.com',
+          },
+          {
+            domain: 'localhost',
+            origin: 'http://127.0.0.1',
+          },
+          {
+            domain: '127.0.0.1',
+            origin: 'http://localhost',
+          },
+        ],
+      },
+      {
+        name: 'mismatching port',
+        expected: false,
+        cases: [
+          {
+            domain: 'www.example.com:8091',
+            origin: 'http://www.example.com:8090',
+          },
+          {
+            domain: 'www.example.com:8091',
+            origin: 'https://www.example.com:8090',
+          },
+          {
+            domain: 'example.com:8090',
+            origin: 'http://example.com',
+          },
+          {
+            domain: '127.0.0.1:8090',
+            origin: 'https://127.0.0.1',
+          },
+          {
+            domain: 'localhost:8090',
+            origin: 'http://localhost',
+          },
+          {
+            domain: '127.0.0.1:8090',
+            origin: 'https://localhost',
+          },
+          {
+            domain: '127.0.0.1:8090',
+            origin: 'https://localhost:8091',
+          },
+          {
+            domain: 'example.com:443',
+            origin: 'http://example.com',
+          },
+          {
+            domain: 'example.com:80',
+            origin: 'https://example.com',
+          },
+        ],
+      },
+    ];
+    for (const { name, expected, cases } of checks) {
+      for (const { domain, origin } of cases) {
+        it(`should return ${expected} for ${name} ${JSON.stringify({
+          domain,
+          origin,
+        })}`, () => {
+          const result = isValidSIWEOrigin({
+            from: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2',
+            origin,
+            siwe: {
+              isSIWEMessage: true,
+              parsedMessage: {
+                ...parsedMessage,
+                domain,
+              },
+            },
+          });
+          expect(result).toBe(expected);
+        });
+      }
+    }
+  });
+});
diff --git a/src/siwe.ts b/src/siwe.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f82574a38de5b9ee17df1d3256f18be5b01a3974
--- /dev/null
+++ b/src/siwe.ts
@@ -0,0 +1,186 @@
+import { remove0x } from '@metamask/utils';
+import { ParsedMessage } from '@spruceid/siwe-parser';
+
+import { projectLogger, createModuleLogger } from './logger';
+
+const log = createModuleLogger(projectLogger, 'detect-siwe');
+
+/**
+ * This function strips the hex prefix from a string if it has one.
+ * If the input is not a string, return it unmodified.
+ *
+ * @param str - The string to check
+ * @returns The string without the hex prefix
+ */
+function safeStripHexPrefix(str: string): string {
+  if (typeof str !== 'string') {
+    return str;
+  }
+  return remove0x(str);
+}
+
+/**
+ * This function converts a hex string to text if it's not a 32 byte hex string.
+ *
+ * @param hexValue - The hex string to convert to text
+ * @returns The text representation of the hex string
+ */
+function msgHexToText(hexValue: string): string {
+  try {
+    const stripped = safeStripHexPrefix(hexValue);
+    // TODO: Use `@metamask/utils` version of this function to avoid Buffer
+    // usage here.
+    // eslint-disable-next-line no-restricted-globals
+    const buff = Buffer.from(stripped, 'hex');
+    return buff.length === 32 ? hexValue : buff.toString('utf8');
+  } catch (error) {
+    log(error);
+    return hexValue;
+  }
+}
+
+/**
+ * @type WrappedSIWERequest
+ *
+ * Sign-In With Ethereum (SIWE)(EIP-4361) message with request metadata
+ *
+ * @property from - Subject account address
+ * @property origin - The RFC 3986 originating authority of the signing request, including scheme
+ * @property siwe - The data parsed from the message
+ */
+// This interface was created before this ESLint rule was added.
+// Convert to a `type` in a future major version.
+// eslint-disable-next-line @typescript-eslint/consistent-type-definitions
+export interface WrappedSIWERequest {
+  from: string;
+  origin: string;
+  siwe: SIWEMessage;
+}
+
+// This interface was created before this ESLint rule was added.
+// Convert to a `type` in a future major version.
+// eslint-disable-next-line @typescript-eslint/consistent-type-definitions
+interface DomainParts {
+  username?: string;
+  hostname: string;
+  port?: string;
+}
+
+const DEFAULT_PORTS_BY_PROTOCOL = {
+  'http:': '80',
+  'https:': '443',
+} as Record<string, string>;
+
+/**
+ * Parses parts from RFC 3986 authority from EIP-4361 `domain` field.
+ *
+ * @param domain - input string
+ * @param originProtocol - implied protocol from origin
+ * @returns parsed parts
+ */
+export const parseDomainParts = (
+  domain: string,
+  originProtocol: string,
+): DomainParts => {
+  if (domain.match(/^[^/:]*:\/\//u)) {
+    return new URL(domain);
+  }
+  return new URL(`${originProtocol}//${domain}`);
+};
+
+/**
+ * Validates origin of a Sign-In With Ethereum (SIWE)(EIP-4361) request.
+ * As per spec:
+ * hostname must match.
+ * port and username must match iff specified.
+ * Protocol binding and full same-origin are currently not performed.
+ *
+ * @param req - Signature request
+ * @returns true if origin matches domain; false otherwise
+ */
+export const isValidSIWEOrigin = (req: WrappedSIWERequest): boolean => {
+  try {
+    const { origin, siwe } = req;
+
+    // origin = scheme://[user[:password]@]domain[:port]
+    // origin is supplied by environment and must match domain claim in message
+    if (!origin || !siwe?.parsedMessage?.domain) {
+      return false;
+    }
+
+    const originParts = new URL(origin);
+    const domainParts = parseDomainParts(
+      siwe.parsedMessage.domain,
+      originParts.protocol,
+    );
+
+    if (
+      domainParts.hostname.localeCompare(originParts.hostname, undefined, {
+        sensitivity: 'accent',
+      }) !== 0
+    ) {
+      return false;
+    }
+
+    if (domainParts.port !== '' && domainParts.port !== originParts.port) {
+      // If origin port is not specified, protocol default is implied
+      return (
+        originParts.port === '' &&
+        domainParts.port === DEFAULT_PORTS_BY_PROTOCOL[originParts.protocol]
+      );
+    }
+
+    if (
+      domainParts.username !== '' &&
+      domainParts.username !== originParts.username
+    ) {
+      return false;
+    }
+
+    return true;
+  } catch (error) {
+    log(error);
+    return false;
+  }
+};
+
+/**
+ * A locally defined object used to provide data to identify a Sign-In With Ethereum (SIWE)(EIP-4361) message and provide the parsed message
+ *
+ * @typedef SIWEMessage
+ * @param {boolean} isSIWEMessage - Does the intercepted message conform to the SIWE specification?
+ * @param {ParsedMessage} parsedMessage - The data parsed out of the message
+ */
+export type SIWEMessage =
+  | { isSIWEMessage: true; parsedMessage: ParsedMessage }
+  | { isSIWEMessage: false; parsedMessage: null };
+
+/**
+ * This function intercepts a sign message, detects if it's a
+ * Sign-In With Ethereum (SIWE)(EIP-4361) message, and returns an object with
+ * relevant SIWE data.
+ *
+ * {@see {@link https://eips.ethereum.org/EIPS/eip-4361}}
+ *
+ * @param msgParams - The params of the message to sign
+ * @param msgParams.data - The data of the message to sign
+ * @returns An object with the relevant SIWE data
+ */
+export const detectSIWE = (msgParams: { data: string }): SIWEMessage => {
+  try {
+    const { data } = msgParams;
+    const message = msgHexToText(data);
+    const parsedMessage = new ParsedMessage(message);
+
+    return {
+      isSIWEMessage: true,
+      parsedMessage,
+    };
+  } catch {
+    // ignore error, it's not a valid SIWE message
+    return {
+      isSIWEMessage: false,
+      parsedMessage: null,
+    };
+  }
+};
diff --git a/src/types.test.ts b/src/types.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f42e7e2fb199612f007c2073c7ddc52160e99f29
--- /dev/null
+++ b/src/types.test.ts
@@ -0,0 +1,19 @@
+import { isNetworkType, NetworkType } from './types';
+
+describe('types', () => {
+  it('isNetworkType', () => {
+    // @ts-expect-error We are intentionally passing bad input.
+    expect(isNetworkType({})).toBe(false);
+    // @ts-expect-error We are intentionally passing bad input.
+    expect(isNetworkType(1)).toBe(false);
+    expect(isNetworkType('test')).toBe(false);
+    expect(isNetworkType('mainnet')).toBe(true);
+    expect(isNetworkType(NetworkType.mainnet)).toBe(true);
+    expect(isNetworkType(NetworkType.goerli)).toBe(true);
+    expect(isNetworkType(NetworkType.sepolia)).toBe(true);
+    expect(isNetworkType(NetworkType['linea-goerli'])).toBe(true);
+    expect(isNetworkType(NetworkType['linea-sepolia'])).toBe(true);
+    expect(isNetworkType(NetworkType['linea-mainnet'])).toBe(true);
+    expect(isNetworkType(NetworkType.rpc)).toBe(true);
+  });
+});
diff --git a/src/types.ts b/src/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5e7f5b1296b9ec8bd9691cd9be24b73a415dc02b
--- /dev/null
+++ b/src/types.ts
@@ -0,0 +1,332 @@
+/**
+ * The names of built-in Infura networks
+ */
+export const InfuraNetworkType = {
+  mainnet: 'mainnet',
+  goerli: 'goerli',
+  sepolia: 'sepolia',
+  'linea-goerli': 'linea-goerli',
+  'linea-sepolia': 'linea-sepolia',
+  'linea-mainnet': 'linea-mainnet',
+  'base-mainnet': 'base-mainnet',
+  'arbitrum-mainnet': 'arbitrum-mainnet',
+  'bsc-mainnet': 'bsc-mainnet',
+  'optimism-mainnet': 'optimism-mainnet',
+  'polygon-mainnet': 'polygon-mainnet',
+  'sei-mainnet': 'sei-mainnet',
+  // Avalanche
+  'avalanche-mainnet': 'avalanche-mainnet',
+  // HyperEVM
+  'hyper-evm-mainnet': 'hyper-evm-mainnet',
+  // Palm
+  'palm-mainnet': 'palm-mainnet',
+  // zkSync Era
+  'zksync-era-mainnet': 'zksync-era-mainnet',
+  // Monad
+  'monad-mainnet': 'monad-mainnet',
+  // MegaEth
+  'megaeth-mainnet': 'megaeth-mainnet',
+} as const;
+
+export type InfuraNetworkType =
+  (typeof InfuraNetworkType)[keyof typeof InfuraNetworkType];
+
+/**
+ * Custom network types that are not part of Infura.
+ */
+export const CustomNetworkType = {
+  /**
+   * @deprecated `megaeth-testnet` is migrated to `megaeth-testnet-v2`.
+   */
+  'megaeth-testnet': 'megaeth-testnet',
+  'megaeth-testnet-v2': 'megaeth-testnet-v2',
+  'monad-testnet': 'monad-testnet',
+  // Environment 3: Power User test networks
+  'fantom-mainnet': 'fantom-mainnet',
+  'gnosis-mainnet': 'gnosis-mainnet',
+  'cronos-mainnet': 'cronos-mainnet',
+  'moonbeam-mainnet': 'moonbeam-mainnet',
+  'moonriver-mainnet': 'moonriver-mainnet',
+} as const;
+export type CustomNetworkType =
+  (typeof CustomNetworkType)[keyof typeof CustomNetworkType];
+
+/**
+ * Network types supported including both Infura networks and other networks.
+ */
+export type BuiltInNetworkType = InfuraNetworkType | CustomNetworkType;
+
+/**
+ * The "network type"; either the name of a built-in network, or "rpc" for custom networks.
+ */
+export const NetworkType = {
+  ...InfuraNetworkType,
+  ...CustomNetworkType,
+  rpc: 'rpc',
+} as const;
+
+export type NetworkType = (typeof NetworkType)[keyof typeof NetworkType];
+
+/**
+ * A helper to determine whether a given input is NetworkType.
+ *
+ * @param val - the value to check whether it is NetworkType or not.
+ * @returns boolean indicating whether or not the argument is NetworkType.
+ */
+export function isNetworkType(val: string): val is NetworkType {
+  return Object.values(NetworkType).includes(val as NetworkType);
+}
+
+/**
+ * A type guard to determine whether the input is an InfuraNetworkType.
+ *
+ * @param value - The value to check.
+ * @returns True if the given value is within the InfuraNetworkType enum,
+ * false otherwise.
+ */
+export function isInfuraNetworkType(
+  value: unknown,
+): value is InfuraNetworkType {
+  const infuraNetworkTypes: unknown[] = Object.keys(InfuraNetworkType);
+  return infuraNetworkTypes.includes(value);
+}
+
+/**
+ * Names of networks built into the wallet.
+ *
+ * This includes both Infura and non-Infura networks.
+ */
+export enum BuiltInNetworkName {
+  Mainnet = 'mainnet',
+  Goerli = 'goerli',
+  Sepolia = 'sepolia',
+  LineaGoerli = 'linea-goerli',
+  LineaSepolia = 'linea-sepolia',
+  LineaMainnet = 'linea-mainnet',
+  Aurora = 'aurora',
+  /**
+   * @deprecated `MegaETHTestnet` is migrated to `MegaETHTestnetV2`.
+   */
+  MegaETHTestnet = 'megaeth-testnet',
+  MegaETHTestnetV2 = 'megaeth-testnet-v2',
+  MonadTestnet = 'monad-testnet',
+  BaseMainnet = 'base-mainnet',
+  ArbitrumOne = 'arbitrum-mainnet',
+  BscMainnet = 'bsc-mainnet',
+  OptimismMainnet = 'optimism-mainnet',
+  PolygonMainnet = 'polygon-mainnet',
+  SeiMainnet = 'sei-mainnet',
+  AvalancheMainnet = 'avalanche-mainnet',
+  HyperEVMMainnet = 'hyper-evm-mainnet',
+  PalmMainnet = 'palm-mainnet',
+  ZkSyncEraMainnet = 'zksync-era-mainnet',
+  MonadMainnet = 'monad-mainnet',
+  MegaEthMainnet = 'megaeth-mainnet',
+  // Environment 3: Power User test networks
+  FantomMainnet = 'fantom-mainnet',
+  GnosisMainnet = 'gnosis-mainnet',
+  CronosMainnet = 'cronos-mainnet',
+  MoonbeamMainnet = 'moonbeam-mainnet',
+  MoonriverMainnet = 'moonriver-mainnet',
+}
+
+/**
+ * Decimal string chain IDs of built-in networks, by name.
+ *
+ * `toHex` not invoked to avoid cyclic dependency
+ */
+export const ChainId = {
+  [BuiltInNetworkName.Mainnet]: '0x1', // toHex(1)
+  [BuiltInNetworkName.Goerli]: '0x5', // toHex(5)
+  [BuiltInNetworkName.Sepolia]: '0xaa36a7', // toHex(11155111)
+  [BuiltInNetworkName.Aurora]: '0x4e454152', // toHex(1313161554)
+  [BuiltInNetworkName.LineaGoerli]: '0xe704', // toHex(59140)
+  [BuiltInNetworkName.LineaSepolia]: '0xe705', // toHex(59141)
+  [BuiltInNetworkName.LineaMainnet]: '0xe708', // toHex(59144)
+  /**
+   * @deprecated `MegaETHTestnet` is migrated to `MegaETHTestnetV2`.
+   */
+  [BuiltInNetworkName.MegaETHTestnet]: '0x18c6', // toHex(6342)
+  [BuiltInNetworkName.MegaETHTestnetV2]: '0x18c7', // toHex(6343)
+  [BuiltInNetworkName.MonadTestnet]: '0x279f', // toHex(10143)
+  [BuiltInNetworkName.BaseMainnet]: '0x2105', // toHex(8453)
+  [BuiltInNetworkName.ArbitrumOne]: '0xa4b1', // toHex(42161)
+  [BuiltInNetworkName.BscMainnet]: '0x38', // toHex(56)
+  [BuiltInNetworkName.OptimismMainnet]: '0xa', // toHex(10)
+  [BuiltInNetworkName.PolygonMainnet]: '0x89', // toHex(137)
+  [BuiltInNetworkName.SeiMainnet]: '0x531', // toHex(1329)
+  [BuiltInNetworkName.AvalancheMainnet]: '0xa86a', // toHex(43114)
+  [BuiltInNetworkName.HyperEVMMainnet]: '0x3e7', // toHex(999)
+  [BuiltInNetworkName.PalmMainnet]: '0x2a15c308d', // toHex(11297108109)
+  [BuiltInNetworkName.ZkSyncEraMainnet]: '0x144', // toHex(324)
+  [BuiltInNetworkName.MonadMainnet]: '0x8f', // toHex(143)
+  [BuiltInNetworkName.MegaEthMainnet]: '0x10e6', // toHex(4326)
+  // Environment 3: Power User test networks
+  [BuiltInNetworkName.FantomMainnet]: '0xfa', // toHex(250)
+  [BuiltInNetworkName.GnosisMainnet]: '0x64', // toHex(100)
+  [BuiltInNetworkName.CronosMainnet]: '0x19', // toHex(25)
+  [BuiltInNetworkName.MoonbeamMainnet]: '0x504', // toHex(1284)
+  [BuiltInNetworkName.MoonriverMainnet]: '0x505', // toHex(1285)
+} as const;
+export type ChainId = (typeof ChainId)[keyof typeof ChainId];
+
+/* eslint-disable @typescript-eslint/naming-convention */
+export enum NetworksTicker {
+  mainnet = 'ETH',
+  goerli = 'GoerliETH',
+  sepolia = 'SepoliaETH',
+  'linea-goerli' = 'LineaETH',
+  // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values
+  'linea-sepolia' = 'LineaETH',
+  // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values
+  'linea-mainnet' = 'ETH',
+  /**
+   * @deprecated `megaeth-testnet` is migrated to `megaeth-testnet-v2`.
+   */
+  'megaeth-testnet' = 'MegaETH',
+  // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values
+  'megaeth-testnet-v2' = 'MegaETH',
+  'monad-testnet' = 'MON',
+  // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values
+  'base-mainnet' = 'ETH',
+  // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values
+  'arbitrum-mainnet' = 'ETH',
+  'bsc-mainnet' = 'BNB',
+  // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values
+  'optimism-mainnet' = 'ETH',
+  'polygon-mainnet' = 'POL',
+  'sei-mainnet' = 'SEI',
+  'avalanche-mainnet' = 'AVAX',
+  'hyper-evm-mainnet' = 'HYPE',
+  'palm-mainnet' = 'PALM',
+  'zksync-era-mainnet' = 'ZKSYNC',
+  'monad-mainnet' = 'MONAD',
+  'megaeth-mainnet' = 'MEGAETH',
+  // Environment 3: Power User test networks
+  'fantom-mainnet' = 'FTM',
+  'gnosis-mainnet' = 'xDAI',
+  'cronos-mainnet' = 'CRO',
+  'moonbeam-mainnet' = 'GLMR',
+  'moonriver-mainnet' = 'MOVR',
+  rpc = '',
+}
+/* eslint-enable @typescript-eslint/naming-convention */
+
+export const BlockExplorerUrl = {
+  [BuiltInNetworkName.Mainnet]: 'https://etherscan.io',
+  [BuiltInNetworkName.Goerli]: 'https://goerli.etherscan.io',
+  [BuiltInNetworkName.Sepolia]: 'https://sepolia.etherscan.io',
+  [BuiltInNetworkName.LineaGoerli]: 'https://goerli.lineascan.build',
+  [BuiltInNetworkName.LineaSepolia]: 'https://sepolia.lineascan.build',
+  [BuiltInNetworkName.LineaMainnet]: 'https://lineascan.build',
+  /**
+   * @deprecated `MegaETHTestnet` is migrated to `MegaETHTestnetV2`.
+   */
+  [BuiltInNetworkName.MegaETHTestnet]: 'https://megaexplorer.xyz',
+  [BuiltInNetworkName.MegaETHTestnetV2]:
+    'https://megaeth-testnet-v2.blockscout.com',
+  [BuiltInNetworkName.MonadTestnet]: 'https://testnet.monadexplorer.com',
+  [BuiltInNetworkName.BaseMainnet]: 'https://basescan.org',
+  [BuiltInNetworkName.ArbitrumOne]: 'https://arbiscan.io',
+  [BuiltInNetworkName.BscMainnet]: 'https://bscscan.com',
+  [BuiltInNetworkName.OptimismMainnet]: 'https://optimistic.etherscan.io',
+  [BuiltInNetworkName.PolygonMainnet]: 'https://polygonscan.com',
+  [BuiltInNetworkName.SeiMainnet]: 'https://seitrace.com/',
+  [BuiltInNetworkName.AvalancheMainnet]: 'https://snowtrace.io',
+  [BuiltInNetworkName.HyperEVMMainnet]: 'https://hyperevmscan.io/',
+  [BuiltInNetworkName.PalmMainnet]: 'https://palm.chainlens.com',
+  [BuiltInNetworkName.ZkSyncEraMainnet]: 'https://explorer.zksync.io/',
+  [BuiltInNetworkName.MonadMainnet]: 'https://monadscan.com/',
+  [BuiltInNetworkName.MegaEthMainnet]: 'https://explorer.megaeth.com',
+  // Environment 3: Power User test networks
+  [BuiltInNetworkName.FantomMainnet]: 'https://ftmscan.com',
+  [BuiltInNetworkName.GnosisMainnet]: 'https://gnosisscan.io',
+  [BuiltInNetworkName.CronosMainnet]: 'https://explorer.cronos.org',
+  [BuiltInNetworkName.MoonbeamMainnet]: 'https://moonscan.io',
+  [BuiltInNetworkName.MoonriverMainnet]: 'https://moonriver.moonscan.io',
+} as const satisfies Record<BuiltInNetworkType, string>;
+export type BlockExplorerUrl =
+  (typeof BlockExplorerUrl)[keyof typeof BlockExplorerUrl];
+
+export const NetworkNickname = {
+  [BuiltInNetworkName.Mainnet]: 'Ethereum Mainnet',
+  [BuiltInNetworkName.Goerli]: 'Goerli',
+  [BuiltInNetworkName.Sepolia]: 'Sepolia',
+  [BuiltInNetworkName.LineaGoerli]: 'Linea Goerli',
+  [BuiltInNetworkName.LineaSepolia]: 'Linea Sepolia',
+  [BuiltInNetworkName.LineaMainnet]: 'Linea',
+  /**
+   * @deprecated `MegaETHTestnet` is migrated to `MegaETHTestnetV2`.
+   */
+  [BuiltInNetworkName.MegaETHTestnet]: 'Mega Testnet',
+  [BuiltInNetworkName.MegaETHTestnetV2]: 'MegaETH Testnet',
+  [BuiltInNetworkName.MonadTestnet]: 'Monad Testnet',
+  [BuiltInNetworkName.BaseMainnet]: 'Base Mainnet',
+  [BuiltInNetworkName.ArbitrumOne]: 'Arbitrum One',
+  [BuiltInNetworkName.BscMainnet]: 'BSC Mainnet',
+  [BuiltInNetworkName.OptimismMainnet]: 'Optimism Mainnet',
+  [BuiltInNetworkName.PolygonMainnet]: 'Polygon Mainnet',
+  [BuiltInNetworkName.SeiMainnet]: 'Sei Mainnet',
+  [BuiltInNetworkName.AvalancheMainnet]: 'Avalanche Mainnet',
+  [BuiltInNetworkName.HyperEVMMainnet]: 'HyperEVM Mainnet',
+  [BuiltInNetworkName.PalmMainnet]: 'Palm Mainnet',
+  [BuiltInNetworkName.ZkSyncEraMainnet]: 'zkSync Era Mainnet',
+  [BuiltInNetworkName.MonadMainnet]: 'Monad Mainnet',
+  [BuiltInNetworkName.MegaEthMainnet]: 'MegaETH Mainnet',
+  // Environment 3: Power User test networks
+  [BuiltInNetworkName.FantomMainnet]: 'Fantom Opera',
+  [BuiltInNetworkName.GnosisMainnet]: 'Gnosis',
+  [BuiltInNetworkName.CronosMainnet]: 'Cronos Mainnet',
+  [BuiltInNetworkName.MoonbeamMainnet]: 'Moonbeam',
+  [BuiltInNetworkName.MoonriverMainnet]: 'Moonriver',
+} as const satisfies Record<BuiltInNetworkType, string>;
+export type NetworkNickname =
+  (typeof NetworkNickname)[keyof typeof NetworkNickname];
+
+/**
+ * Makes a selection of keys in a Record optional.
+ *
+ * @template Type - The Record that you want to operate on.
+ * @template Key - The union of keys you want to make optional.
+ */
+// TODO: Move to @metamask/utils
+export type Partialize<Type, Key extends keyof Type> = Omit<Type, Key> &
+  Partial<Pick<Type, Key>>;
+
+/** A context in which to execute a trace, in order to generate nested timings. */
+export type TraceContext = unknown;
+
+/** Request to trace an operation. */
+export type TraceRequest = {
+  /** Additional data to include in the trace. */
+  data?: Record<string, number | string | boolean>;
+
+  /** Name of the operation. */
+  name: string;
+
+  /**
+   * Unique identifier for the trace.
+   * Required if starting a trace and not providing a callback.
+   */
+  id?: string;
+
+  /** Trace context in which to execute the operation. */
+  parentContext?: TraceContext;
+
+  /** Additional tags to include in the trace to filter results. */
+  tags?: Record<string, number | string | boolean>;
+};
+
+/** Callback that traces the performance of an operation. */
+export type TraceCallback = <ReturnType>(
+  /** Request to trace the performance of an operation. */
+  request: TraceRequest,
+
+  /**
+   * Callback to trace.
+   * Thrown errors will not be caught, but the trace will still be recorded.
+   *
+   * @param context - The context in which the operation is running.
+   */
+  fn?: (context?: TraceContext) => ReturnType,
+) => Promise<ReturnType>;
diff --git a/src/util.test.ts b/src/util.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..69f807dd94048c21e620cdbcf5d327a33a795c33
--- /dev/null
+++ b/src/util.test.ts
@@ -0,0 +1,818 @@
+import EthQuery from '@metamask/eth-query';
+import { assert, JsonRpcParams } from '@metamask/utils';
+import { BigNumber } from 'bignumber.js';
+import BN from 'bn.js';
+import nock from 'nock';
+
+import { MAX_SAFE_CHAIN_ID } from './constants';
+import * as util from './util';
+import { FakeProvider } from '../../../tests/fake-provider';
+
+type EverythingButNull =
+  | string
+  | number
+  | boolean
+  | object
+  | symbol
+  | undefined;
+
+type SendAsyncCallback<Result> = (
+  ...args:
+    | [error: EverythingButNull, result: undefined]
+    | [error: null, result: Result]
+) => void;
+
+const VALID = '4e1fF7229BDdAf0A73DF183a88d9c3a04cc975e0';
+const SOME_API = 'https://someapi.com';
+const SOME_FAILING_API = 'https://somefailingapi.com';
+
+describe('util', () => {
+  it('isSafeDynamicKey', () => {
+    expect(util.isSafeDynamicKey(util.toHex(MAX_SAFE_CHAIN_ID))).toBe(true);
+    expect(util.isSafeDynamicKey('')).toBe(true);
+    for (const badKey of util.PROTOTYPE_POLLUTION_BLOCKLIST) {
+      expect(util.isSafeDynamicKey(badKey)).toBe(false);
+    }
+    // @ts-expect-error - ensure that non-string input return false.
+    expect(util.isSafeDynamicKey(null)).toBe(false);
+  });
+  it('isSafeChainId', () => {
+    expect(util.isSafeChainId(util.toHex(MAX_SAFE_CHAIN_ID + 1))).toBe(false);
+    expect(util.isSafeChainId(util.toHex(MAX_SAFE_CHAIN_ID))).toBe(true);
+    expect(util.isSafeChainId(util.toHex(0))).toBe(false);
+    expect(util.isSafeChainId('0xinvalid')).toBe(false);
+    // @ts-expect-error - ensure that non-string args return false.
+    expect(util.isSafeChainId('test')).toBe(false);
+  });
+
+  it('bNToHex', () => {
+    expect(util.BNToHex(new BN('1337'))).toBe('0x539');
+    expect(util.BNToHex(new BigNumber('1337'))).toBe('0x539');
+  });
+
+  it('fractionBN', () => {
+    expect(util.fractionBN(new BN('1337'), 9, 10).toNumber()).toBe(1203);
+  });
+
+  it('getBuyURL', () => {
+    expect(util.getBuyURL(undefined, 'foo', 1337)).toBe(
+      'https://buy.coinbase.com/?code=9ec56d01-7e81-5017-930c-513daa27bb6a&amount=1337&address=foo&crypto_currency=ETH',
+    );
+
+    expect(util.getBuyURL('1', 'foo', 1337)).toBe(
+      'https://buy.coinbase.com/?code=9ec56d01-7e81-5017-930c-513daa27bb6a&amount=1337&address=foo&crypto_currency=ETH',
+    );
+    expect(util.getBuyURL('5')).toBe('https://goerli-faucet.slock.it/');
+    expect(util.getBuyURL('11155111')).toBe('https://sepoliafaucet.net/');
+    expect(util.getBuyURL('unrecognized network ID')).toBeUndefined();
+  });
+
+  it('hexToBN', () => {
+    expect(util.hexToBN('0x1337').toNumber()).toBe(4919);
+  });
+
+  describe('fromHex', () => {
+    it('converts a string that represents a number in hexadecimal format with leading "0x" into a BN', () => {
+      expect(util.fromHex('0x1337')).toStrictEqual(new BN(4919));
+    });
+
+    it('converts a string that represents a number in hexadecimal format without leading "0x" into a BN', () => {
+      expect(util.fromHex('1337')).toStrictEqual(new BN(4919));
+    });
+
+    it('does nothing to a BN', () => {
+      const bn = new BN(4919);
+      expect(util.fromHex(bn)).toBe(bn);
+    });
+  });
+
+  describe('toHex', () => {
+    it('converts a BN to a hex string prepended with "0x"', () => {
+      expect(util.toHex(new BN(4919))).toBe('0x1337');
+    });
+
+    it('converts a bigint to a string prepended with "0x"', () => {
+      expect(util.toHex(4919n)).toBe('0x1337');
+    });
+
+    it('parses a string as a number in decimal format and converts it to a hex string prepended with "0x"', () => {
+      expect(util.toHex('4919')).toBe('0x1337');
+    });
+
+    it('throws an error if given a string with decimals', () => {
+      expect(() => util.toHex('4919.3')).toThrow('Invalid character');
+    });
+
+    it('converts a number to a hex string prepended with "0x"', () => {
+      expect(util.toHex(4919)).toBe('0x1337');
+    });
+
+    it('throws an error if given a float', () => {
+      expect(() => util.toHex(4919.3)).toThrow('Invalid character');
+    });
+
+    it('does nothing to a string that is already a "0x"-prepended hex value', () => {
+      expect(util.toHex('0x1337')).toBe('0x1337');
+    });
+
+    it('throws an error if given a non-"0x"-prepended string that is not a valid hex value', () => {
+      expect(() => util.toHex('zzzz')).toThrow('Invalid character');
+    });
+  });
+
+  describe('gweiDecToWEIBN', () => {
+    it('should convert a whole number to WEI', () => {
+      expect(util.gweiDecToWEIBN(1).toNumber()).toBe(1000000000);
+      expect(util.gweiDecToWEIBN(123).toNumber()).toBe(123000000000);
+      expect(util.gweiDecToWEIBN(101).toNumber()).toBe(101000000000);
+      expect(util.gweiDecToWEIBN(1234).toNumber()).toBe(1234000000000);
+      expect(util.gweiDecToWEIBN(1000).toNumber()).toBe(1000000000000);
+    });
+
+    it('should convert a number with a decimal part to WEI', () => {
+      expect(util.gweiDecToWEIBN(1.1).toNumber()).toBe(1100000000);
+      expect(util.gweiDecToWEIBN(123.01).toNumber()).toBe(123010000000);
+      expect(util.gweiDecToWEIBN(101.001).toNumber()).toBe(101001000000);
+      expect(util.gweiDecToWEIBN(100.001).toNumber()).toBe(100001000000);
+      expect(util.gweiDecToWEIBN(1234.567).toNumber()).toBe(1234567000000);
+    });
+
+    it('should convert a number < 1 to WEI', () => {
+      expect(util.gweiDecToWEIBN(0.1).toNumber()).toBe(100000000);
+      expect(util.gweiDecToWEIBN(0.01).toNumber()).toBe(10000000);
+      expect(util.gweiDecToWEIBN(0.001).toNumber()).toBe(1000000);
+      expect(util.gweiDecToWEIBN(0.567).toNumber()).toBe(567000000);
+    });
+
+    it('should round to whole WEI numbers', () => {
+      expect(util.gweiDecToWEIBN(0.1001).toNumber()).toBe(100100000);
+      expect(util.gweiDecToWEIBN(0.0109).toNumber()).toBe(10900000);
+      expect(util.gweiDecToWEIBN(0.0014).toNumber()).toBe(1400000);
+      expect(util.gweiDecToWEIBN(0.5676).toNumber()).toBe(567600000);
+    });
+
+    it('should handle inputs with more than 9 decimal places', () => {
+      expect(util.gweiDecToWEIBN(1.0000000162).toNumber()).toBe(1000000016);
+      expect(util.gweiDecToWEIBN(1.0000000165).toNumber()).toBe(1000000017);
+      expect(util.gweiDecToWEIBN(1.0000000199).toNumber()).toBe(1000000020);
+      expect(util.gweiDecToWEIBN(1.9999999999).toNumber()).toBe(2000000000);
+      expect(util.gweiDecToWEIBN(1.0000005998).toNumber()).toBe(1000000600);
+      expect(util.gweiDecToWEIBN(123456.0000005998).toNumber()).toBe(
+        123456000000600,
+      );
+      expect(util.gweiDecToWEIBN(1.000000016025).toNumber()).toBe(1000000016);
+      expect(util.gweiDecToWEIBN('1.0000000160000028').toNumber()).toBe(
+        1000000016,
+      );
+      expect(util.gweiDecToWEIBN(1.000000016522).toNumber()).toBe(1000000017);
+      expect(util.gweiDecToWEIBN(1.000000016800022).toNumber()).toBe(
+        1000000017,
+      );
+    });
+
+    it('should work if there are extraneous trailing decimal zeroes', () => {
+      expect(util.gweiDecToWEIBN('0.5000').toNumber()).toBe(500000000);
+      expect(util.gweiDecToWEIBN('123.002300').toNumber()).toBe(123002300000);
+      expect(util.gweiDecToWEIBN('123.002300000000').toNumber()).toBe(
+        123002300000,
+      );
+      expect(util.gweiDecToWEIBN('0.00000200000').toNumber()).toBe(2000);
+    });
+
+    it('should work if there is no whole number specified', () => {
+      expect(util.gweiDecToWEIBN('.1').toNumber()).toBe(100000000);
+      expect(util.gweiDecToWEIBN('.01').toNumber()).toBe(10000000);
+      expect(util.gweiDecToWEIBN('.001').toNumber()).toBe(1000000);
+      expect(util.gweiDecToWEIBN('.567').toNumber()).toBe(567000000);
+    });
+
+    it('should handle NaN', () => {
+      expect(util.gweiDecToWEIBN(NaN).toNumber()).toBe(0);
+    });
+  });
+
+  describe('weiHexToGweiDec', () => {
+    it('should convert a whole number to WEI', () => {
+      const testData = [
+        {
+          input: '3b9aca00',
+          expectedResult: '1',
+        },
+        {
+          input: '1ca35f0e00',
+          expectedResult: '123',
+        },
+        {
+          input: '178411b200',
+          expectedResult: '101',
+        },
+        {
+          input: '11f5021b400',
+          expectedResult: '1234',
+        },
+      ];
+      testData.forEach(({ input, expectedResult }) => {
+        expect(util.weiHexToGweiDec(input)).toBe(expectedResult);
+      });
+    });
+
+    it('should convert a number with a decimal part to WEI', () => {
+      const testData = [
+        {
+          input: '4190ab00',
+          expectedResult: '1.1',
+        },
+        {
+          input: '1ca3f7a480',
+          expectedResult: '123.01',
+        },
+        {
+          input: '178420f440',
+          expectedResult: '101.001',
+        },
+        {
+          input: '11f71ed6fc0',
+          expectedResult: '1234.567',
+        },
+      ];
+
+      testData.forEach(({ input, expectedResult }) => {
+        expect(util.weiHexToGweiDec(input)).toBe(expectedResult);
+      });
+    });
+
+    it('should convert a number < 1 to WEI', () => {
+      const testData = [
+        {
+          input: '5f5e100',
+          expectedResult: '0.1',
+        },
+        {
+          input: '989680',
+          expectedResult: '0.01',
+        },
+        {
+          input: 'f4240',
+          expectedResult: '0.001',
+        },
+        {
+          input: '21cbbbc0',
+          expectedResult: '0.567',
+        },
+      ];
+
+      testData.forEach(({ input, expectedResult }) => {
+        expect(util.weiHexToGweiDec(input)).toBe(expectedResult);
+      });
+    });
+
+    it('should work with 0x prefixed values', () => {
+      expect(util.weiHexToGweiDec('0x5f48b0f7')).toBe('1.598599415');
+    });
+  });
+
+  describe('safelyExecute', () => {
+    it('should swallow errors', async () => {
+      expect(
+        await util.safelyExecute(() => {
+          throw new Error('ahh');
+        }),
+      ).toBeUndefined();
+    });
+  });
+
+  describe('safelyExecuteWithTimeout', () => {
+    it('should swallow errors', async () => {
+      expect(
+        await util.safelyExecuteWithTimeout(() => {
+          throw new Error('ahh');
+        }),
+      ).toBeUndefined();
+    });
+
+    it('should resolve', async () => {
+      const response = await util.safelyExecuteWithTimeout(() => {
+        return new Promise((resolve) =>
+          setTimeout(() => resolve('response'), 200),
+        );
+      });
+      expect(response).toBe('response');
+    });
+
+    it('should timeout', async () => {
+      expect(
+        await util.safelyExecuteWithTimeout(() => {
+          return new Promise((resolve) => setTimeout(resolve, 800));
+        }),
+      ).toBeUndefined();
+    });
+  });
+
+  describe('toChecksumHexAddress', () => {
+    it('should return an 0x-prefixed checksum address untouched', () => {
+      const address = '0x4e1fF7229BDdAf0A73DF183a88d9c3a04cc975e0';
+      expect(util.toChecksumHexAddress(address)).toBe(address);
+    });
+
+    it('should prefix a non-0x-prefixed checksum address with 0x', () => {
+      expect(
+        util.toChecksumHexAddress('4e1fF7229BDdAf0A73DF183a88d9c3a04cc975e0'),
+      ).toBe('0x4e1fF7229BDdAf0A73DF183a88d9c3a04cc975e0');
+    });
+
+    it('should convert a non-checksum address to a checksum address', () => {
+      expect(
+        util.toChecksumHexAddress('0x4e1ff7229bddaf0a73df183a88d9c3a04cc975e0'),
+      ).toBe('0x4e1fF7229BDdAf0A73DF183a88d9c3a04cc975e0');
+    });
+
+    it('should return "0x" if given an empty string', () => {
+      expect(util.toChecksumHexAddress('')).toBe('0x');
+    });
+
+    it('should return the input untouched if it is undefined', () => {
+      expect(util.toChecksumHexAddress(undefined)).toBeUndefined();
+    });
+
+    it('should return the input untouched if it is null', () => {
+      expect(util.toChecksumHexAddress(null)).toBeNull();
+    });
+
+    it('should return the address untouched if it is not a valid hex address', () => {
+      expect(util.toChecksumHexAddress('0x1')).toBe('0x1');
+    });
+
+    it('should memoize results for same input', () => {
+      const testAddress = '4e1ff7229bddaf0a73df183a88d9c3a04cc975e0';
+
+      // Call the function multiple times with the same input
+      const result1 = util.toChecksumHexAddress(testAddress);
+      const result2 = util.toChecksumHexAddress(testAddress);
+      const result3 = util.toChecksumHexAddress(testAddress);
+
+      // All results should be identical
+      expect(result1).toBe('0x4e1fF7229BDdAf0A73DF183a88d9c3a04cc975e0');
+      expect(result2).toBe(result1);
+      expect(result3).toBe(result1);
+    });
+
+    it('should return different results for different inputs but still memoize each', () => {
+      const testAddress1 = '4e1ff7229bddaf0a73df183a88d9c3a04cc975e0';
+      const testAddress2 = '742d35cc6ba4c0a2b7e8b4c0b1b0c2b2b2b2b2b2';
+
+      // Call with first address multiple times
+      const result1a = util.toChecksumHexAddress(testAddress1);
+      const result1b = util.toChecksumHexAddress(testAddress1);
+
+      // Call with second address multiple times
+      const result2a = util.toChecksumHexAddress(testAddress2);
+      const result2b = util.toChecksumHexAddress(testAddress2);
+
+      // Results for same address should be identical
+      expect(result1b).toBe(result1a);
+      expect(result2b).toBe(result2a);
+
+      // Results for different addresses should be different
+      expect(result1a).not.toBe(result2a);
+    });
+
+    it('should memoize based on complete argument signature', () => {
+      const testAddress = '4e1ff7229bddaf0a73df183a88d9c3a04cc975e0';
+
+      // Call with string argument
+      const result1 = util.toChecksumHexAddress(testAddress);
+      const result2 = util.toChecksumHexAddress(testAddress);
+
+      // Both should be memoized and return the same result
+      expect(result2).toBe(result1);
+      expect(result1).toBe('0x4e1fF7229BDdAf0A73DF183a88d9c3a04cc975e0');
+    });
+  });
+
+  describe('isValidHexAddress', () => {
+    it('should return true for valid address', () => {
+      expect(util.isValidHexAddress(VALID)).toBe(true);
+    });
+
+    it('should return false for invalid address', () => {
+      expect(util.isValidHexAddress('0x00')).toBe(false);
+    });
+
+    it('should allow allowNonPrefixed to be false', () => {
+      expect(util.isValidHexAddress('0x00', { allowNonPrefixed: false })).toBe(
+        false,
+      );
+    });
+
+    it('should memoize results for same input', () => {
+      const validAddress = '4e1fF7229BDdAf0A73DF183a88d9c3a04cc975e0';
+
+      // Call the function multiple times with the same input
+      const result1 = util.isValidHexAddress(validAddress);
+      const result2 = util.isValidHexAddress(validAddress);
+      const result3 = util.isValidHexAddress(validAddress);
+
+      // All results should be identical
+      expect(result1).toBe(true);
+      expect(result2).toBe(result1);
+      expect(result3).toBe(result1);
+    });
+
+    it('should memoize results for same input with options', () => {
+      const validAddress = '4e1fF7229BDdAf0A73DF183a88d9c3a04cc975e0';
+      const options = { allowNonPrefixed: true };
+
+      // Call the function multiple times with the same input and options
+      const result1 = util.isValidHexAddress(validAddress, options);
+      const result2 = util.isValidHexAddress(validAddress, options);
+      const result3 = util.isValidHexAddress(validAddress, options);
+
+      // All results should be identical
+      expect(result1).toBe(true);
+      expect(result2).toBe(result1);
+      expect(result3).toBe(result1);
+    });
+
+    it('should return different results for different option combinations', () => {
+      const addressWithoutPrefix = '4e1fF7229BDdAf0A73DF183a88d9c3a04cc975e0';
+
+      // Call with different options
+      const result1 = util.isValidHexAddress(addressWithoutPrefix, {
+        allowNonPrefixed: true,
+      });
+      const result2 = util.isValidHexAddress(addressWithoutPrefix, {
+        allowNonPrefixed: false,
+      });
+
+      // Should return different results for different options
+      expect(result1).toBe(true);
+      expect(result2).toBe(false);
+
+      // But calling again with same options should return memoized results
+      const result1Again = util.isValidHexAddress(addressWithoutPrefix, {
+        allowNonPrefixed: true,
+      });
+      const result2Again = util.isValidHexAddress(addressWithoutPrefix, {
+        allowNonPrefixed: false,
+      });
+
+      expect(result1Again).toBe(result1);
+      expect(result2Again).toBe(result2);
+    });
+
+    it('should handle memoization with different address inputs', () => {
+      const validAddress = '4e1fF7229BDdAf0A73DF183a88d9c3a04cc975e0';
+      const invalidAddress = '0x00';
+
+      // Call with valid address multiple times
+      const validResult1 = util.isValidHexAddress(validAddress);
+      const validResult2 = util.isValidHexAddress(validAddress);
+
+      // Call with invalid address multiple times
+      const invalidResult1 = util.isValidHexAddress(invalidAddress);
+      const invalidResult2 = util.isValidHexAddress(invalidAddress);
+
+      // Results for same address should be identical
+      expect(validResult2).toBe(validResult1);
+      expect(invalidResult2).toBe(invalidResult1);
+
+      // Results should be correct
+      expect(validResult1).toBe(true);
+      expect(invalidResult1).toBe(false);
+    });
+  });
+
+  it('messageHexToString', () => {
+    const str = util.hexToText('68656c6c6f207468657265');
+    expect(str).toBe('hello there');
+  });
+
+  it('isSmartContractCode', () => {
+    const toSmartContract1 = util.isSmartContractCode('');
+    const toSmartContract2 = util.isSmartContractCode('0x');
+    const toSmartContract3 = util.isSmartContractCode('0x0');
+    const toSmartContract4 = util.isSmartContractCode('0x01234');
+    expect(toSmartContract1).toBe(false);
+    expect(toSmartContract2).toBe(false);
+    expect(toSmartContract3).toBe(false);
+    expect(toSmartContract4).toBe(true);
+  });
+
+  describe('HttpError', () => {
+    it('stores the status as an instance variable', () => {
+      const httpError = new util.HttpError(500);
+
+      expect(httpError.httpStatus).toBe(500);
+    });
+
+    it('has the expected default message', () => {
+      const httpError = new util.HttpError(500);
+
+      expect(httpError.message).toBe(`Fetch failed with status '500'`);
+    });
+
+    it('allows setting a custom message', () => {
+      const httpError = new util.HttpError(500, 'custom message');
+
+      expect(httpError.message).toBe('custom message');
+    });
+  });
+
+  describe('successfulFetch', () => {
+    beforeEach(() => {
+      nock(SOME_API).get(/.+/u).reply(200, { foo: 'bar' }).persist();
+      nock(SOME_FAILING_API).get(/.+/u).reply(500).persist();
+    });
+
+    it('should return successful fetch response', async () => {
+      const res = await util.successfulFetch(SOME_API);
+      const parsed = await res.json();
+      expect(parsed).toStrictEqual({ foo: 'bar' });
+    });
+
+    it('should throw error for an unsuccessful fetch', async () => {
+      await expect(util.successfulFetch(SOME_FAILING_API)).rejects.toThrow(
+        `Fetch failed with status '500' for request '${SOME_FAILING_API}'`,
+      );
+    });
+
+    it('throws an HttpError', async () => {
+      await expect(util.successfulFetch(SOME_FAILING_API)).rejects.toThrow(
+        util.HttpError,
+      );
+    });
+  });
+
+  describe('timeoutFetch', () => {
+    beforeEach(() => {
+      nock(SOME_API).get(/.+/u).delay(300).reply(200, {}).persist();
+    });
+
+    it('should fetch first if response is faster than timeout', async () => {
+      const res = await util.timeoutFetch(SOME_API);
+      const parsed = await res.json();
+      expect(parsed).toStrictEqual({});
+    });
+
+    it('should fail fetch with timeout', async () => {
+      await expect(util.timeoutFetch(SOME_API, {}, 100)).rejects.toThrow(
+        'timeout',
+      );
+    });
+  });
+
+  describe('normalizeEnsName', () => {
+    it('should normalize with valid 2LD', async () => {
+      let valid = util.normalizeEnsName('metamask.eth');
+      expect(valid).toBe('metamask.eth');
+      valid = util.normalizeEnsName('foobar1.eth');
+      expect(valid).toBe('foobar1.eth');
+      valid = util.normalizeEnsName('foo-bar.eth');
+      expect(valid).toBe('foo-bar.eth');
+      valid = util.normalizeEnsName('1-foo-bar.eth');
+      expect(valid).toBe('1-foo-bar.eth');
+    });
+
+    it('should normalize with valid 2LD and "test" TLD', async () => {
+      const valid = util.normalizeEnsName('metamask.test');
+      expect(valid).toBe('metamask.test');
+    });
+
+    it('should normalize with valid 2LD and 3LD', async () => {
+      let valid = util.normalizeEnsName('a.metamask.eth');
+      expect(valid).toBe('a.metamask.eth');
+      valid = util.normalizeEnsName('aa.metamask.eth');
+      expect(valid).toBe('aa.metamask.eth');
+      valid = util.normalizeEnsName('a-a.metamask.eth');
+      expect(valid).toBe('a-a.metamask.eth');
+      valid = util.normalizeEnsName('1-a.metamask.eth');
+      expect(valid).toBe('1-a.metamask.eth');
+      valid = util.normalizeEnsName('1-2.metamask.eth');
+      expect(valid).toBe('1-2.metamask.eth');
+    });
+
+    it('should return null with invalid 2LD', async () => {
+      let invalid = util.normalizeEnsName('me.eth');
+      expect(invalid).toBeNull();
+      invalid = util.normalizeEnsName('metamask-.eth');
+      expect(invalid).toBeNull();
+      invalid = util.normalizeEnsName('-metamask.eth');
+      expect(invalid).toBeNull();
+      invalid = util.normalizeEnsName('@metamask.eth');
+      expect(invalid).toBeNull();
+      invalid = util.normalizeEnsName('foobar.eth');
+      expect(invalid).toBeNull();
+    });
+
+    it('should return null with valid 2LD and invalid 3LD', async () => {
+      let invalid = util.normalizeEnsName('-.metamask.eth');
+      expect(invalid).toBeNull();
+      invalid = util.normalizeEnsName('abc-.metamask.eth');
+      expect(invalid).toBeNull();
+      invalid = util.normalizeEnsName('-abc.metamask.eth');
+      expect(invalid).toBeNull();
+      invalid = util.normalizeEnsName('.metamask.eth');
+      expect(invalid).toBeNull();
+      invalid = util.normalizeEnsName('f@o.metamask.eth');
+      expect(invalid).toBeNull();
+    });
+
+    it('should return null with invalid 2LD and valid 3LD', async () => {
+      const invalid = util.normalizeEnsName('foo.barbaz.eth');
+      expect(invalid).toBeNull();
+    });
+
+    it('should return null with invalid TLD', async () => {
+      const invalid = util.normalizeEnsName('a.metamask.com');
+      expect(invalid).toBeNull();
+    });
+
+    it('should return null with repeated periods', async () => {
+      let invalid = util.normalizeEnsName('foo..metamask.eth');
+      expect(invalid).toBeNull();
+      invalid = util.normalizeEnsName('foo.metamask..eth');
+      expect(invalid).toBeNull();
+    });
+
+    it('should return null with empty string', async () => {
+      const invalid = util.normalizeEnsName('');
+      expect(invalid).toBeNull();
+    });
+  });
+
+  describe('query', () => {
+    describe('when the given method exists directly on the EthQuery', () => {
+      it('should call the method on the EthQuery and, if it is successful, return a promise that resolves to the result', async () => {
+        class MockEthQuery extends EthQuery {
+          getBlockByHash(
+            blockId: unknown,
+            callback: (error: Error | null, value: unknown) => void,
+          ): void {
+            callback(null, { id: blockId });
+          }
+        }
+        const result = await util.query(
+          new MockEthQuery(new FakeProvider()),
+          'getBlockByHash',
+          ['0x1234'],
+        );
+        expect(result).toStrictEqual({ id: '0x1234' });
+      });
+
+      it('should call the method on the EthQuery and, if it errors, return a promise that is rejected with the error', async () => {
+        class MockEthQuery extends EthQuery {
+          getBlockByHash(
+            _blockId: unknown,
+            callback: (error: Error | null, value: unknown) => void,
+          ): void {
+            callback(new Error('uh oh'), null);
+          }
+        }
+        await expect(
+          util.query(new MockEthQuery(new FakeProvider()), 'getBlockByHash', [
+            '0x1234',
+          ]),
+        ).rejects.toThrow('uh oh');
+      });
+    });
+
+    describe('when the given method does not exist directly on the EthQuery', () => {
+      it('should use sendAsync to call the RPC endpoint and, if it is successful, return a promise that resolves to the result', async () => {
+        class MockEthQuery extends EthQuery {
+          sendAsync<Result>(
+            { method, params }: { method?: string; params?: JsonRpcParams },
+            callback: SendAsyncCallback<Result>,
+          ): void {
+            if (method === 'eth_getBlockByHash') {
+              assert(Array.isArray(params));
+              return callback(null, { id: params[0] } as Result);
+            }
+            throw new Error(`Unsupported method ${method}`);
+          }
+        }
+        const result = await util.query(
+          new MockEthQuery(new FakeProvider()),
+          'eth_getBlockByHash',
+          ['0x1234'],
+        );
+        expect(result).toStrictEqual({ id: '0x1234' });
+      });
+
+      it('should use sendAsync to call the RPC endpoint and, if it errors, return a promise that is rejected with the error', async () => {
+        class MockEthQuery extends EthQuery {
+          sendAsync<Result>(
+            _args: unknown,
+            callback: SendAsyncCallback<Result>,
+          ): void {
+            callback(new Error('uh oh'), undefined);
+          }
+        }
+        await expect(
+          util.query(
+            new MockEthQuery(new FakeProvider()),
+            'eth_getBlockByHash',
+            ['0x1234'],
+          ),
+        ).rejects.toThrow('uh oh');
+      });
+    });
+  });
+
+  describe('convertHexToDecimal', () => {
+    it('should convert hex price to decimal', () => {
+      expect(util.convertHexToDecimal('0x50fd51da')).toBe(1358778842);
+    });
+
+    it('should return zero when undefined', () => {
+      expect(util.convertHexToDecimal(undefined)).toBe(0);
+    });
+
+    it('should return a decimal string as the same decimal number', () => {
+      expect(util.convertHexToDecimal('1611')).toBe(1611);
+    });
+
+    it('should return 0 when passed an invalid hex string', () => {
+      expect(util.convertHexToDecimal('0x12398u12')).toBe(0);
+    });
+  });
+
+  describe('isPlainObject', () => {
+    it('returns false for null values', () => {
+      expect(util.isPlainObject(null)).toBe(false);
+      expect(util.isPlainObject(undefined)).toBe(false);
+    });
+
+    it('returns false for non objects', () => {
+      expect(util.isPlainObject(5)).toBe(false);
+      expect(util.isPlainObject('foo')).toBe(false);
+    });
+
+    it('returns false for arrays', () => {
+      expect(util.isPlainObject(['foo'])).toBe(false);
+      expect(util.isPlainObject([{}])).toBe(false);
+    });
+
+    it('returns true for objects', () => {
+      expect(util.isPlainObject({ foo: 'bar' })).toBe(true);
+      expect(util.isPlainObject({ foo: 'bar', test: { value: 5 } })).toBe(true);
+    });
+  });
+
+  describe('isNonEmptyArray', () => {
+    it('returns false non arrays', () => {
+      // @ts-expect-error Invalid type for testing purposes
+      expect(util.isNonEmptyArray(null)).toBe(false);
+      // @ts-expect-error Invalid type for testing purposes
+      expect(util.isNonEmptyArray(undefined)).toBe(false);
+    });
+
+    it('returns false for empty array', () => {
+      expect(util.isNonEmptyArray([])).toBe(false);
+    });
+
+    it('returns true arrays with at least one item', () => {
+      expect(util.isNonEmptyArray([1])).toBe(true);
+      expect(util.isNonEmptyArray([1, 2, 3, 4])).toBe(true);
+    });
+  });
+
+  describe('isValidJson', () => {
+    it('returns false for class instances', () => {
+      expect(util.isValidJson(new Map())).toBe(false);
+    });
+
+    it('returns true for valid JSON', () => {
+      expect(util.isValidJson({ foo: 'bar', test: { value: 5 } })).toBe(true);
+    });
+  });
+});
+
+describe('isEqualCaseInsensitive', () => {
+  it('returns false for non-string values', () => {
+    // @ts-expect-error Invalid type for testing purposes
+    expect(util.isEqualCaseInsensitive(null, null)).toBe(false);
+    // @ts-expect-error Invalid type for testing purposes
+    expect(util.isEqualCaseInsensitive(5, 5)).toBe(false);
+    // @ts-expect-error Invalid type for testing purposes
+    expect(util.isEqualCaseInsensitive(null, 'test')).toBe(false);
+    // @ts-expect-error Invalid type for testing purposes
+    expect(util.isEqualCaseInsensitive('test', null)).toBe(false);
+    // @ts-expect-error Invalid type for testing purposes
+    expect(util.isEqualCaseInsensitive(5, 'test')).toBe(false);
+    // @ts-expect-error Invalid type for testing purposes
+    expect(util.isEqualCaseInsensitive('test', 5)).toBe(false);
+  });
+
+  it('returns false for strings that are not equal', () => {
+    expect(util.isEqualCaseInsensitive('test', 'test1')).toBe(false);
+    expect(util.isEqualCaseInsensitive('test1', 'test')).toBe(false);
+  });
+
+  it('returns true for strings that are equal', () => {
+    expect(util.isEqualCaseInsensitive('test', 'TEST')).toBe(true);
+    expect(util.isEqualCaseInsensitive('test', 'test')).toBe(true);
+    expect(util.isEqualCaseInsensitive('TEST', 'TEST')).toBe(true);
+    expect(util.isEqualCaseInsensitive('test', 'Test')).toBe(true);
+    expect(util.isEqualCaseInsensitive('Test', 'test')).toBe(true);
+  });
+});
diff --git a/src/util.ts b/src/util.ts
new file mode 100644
index 0000000000000000000000000000000000000000..193c37c62c87a6bd80d0ffc861a7c10609141bfd
--- /dev/null
+++ b/src/util.ts
@@ -0,0 +1,702 @@
+import type EthQuery from '@metamask/eth-query';
+import { fromWei, toWei } from '@metamask/ethjs-unit';
+import type { Hex, Json } from '@metamask/utils';
+import {
+  isStrictHexString,
+  add0x,
+  isHexString,
+  remove0x,
+  getChecksumAddress,
+  isHexChecksumAddress,
+} from '@metamask/utils';
+import type { BigNumber } from 'bignumber.js';
+import BN from 'bn.js';
+import ensNamehash from 'eth-ens-namehash';
+import deepEqual from 'fast-deep-equal';
+import { memoize } from 'lodash';
+
+import { MAX_SAFE_CHAIN_ID } from './constants';
+
+export type { BigNumber };
+
+const TIMEOUT_ERROR = new Error('timeout');
+
+export const PROTOTYPE_POLLUTION_BLOCKLIST = [
+  '__proto__',
+  'constructor',
+  'prototype',
+] as const;
+
+/**
+ * Checks whether a dynamic property key could be used in
+ * a [prototype pollution attack](https://portswigger.net/web-security/prototype-pollution).
+ *
+ * @param key - The dynamic key to validate.
+ * @returns Whether the given dynamic key is safe to use.
+ */
+export function isSafeDynamicKey(key: string): boolean {
+  return (
+    typeof key === 'string' &&
+    !PROTOTYPE_POLLUTION_BLOCKLIST.some((blockedKey) => key === blockedKey)
+  );
+}
+
+/**
+ * Checks whether the given number primitive chain ID is safe.
+ * Because some cryptographic libraries we use expect the chain ID to be a
+ * number primitive, it must not exceed a certain size.
+ *
+ * @param chainId - The chain ID to check for safety.
+ * @returns Whether the given chain ID is safe.
+ */
+export function isSafeChainId(chainId: Hex): boolean {
+  if (!isHexString(chainId)) {
+    return false;
+  }
+  const decimalChainId = Number.parseInt(
+    chainId,
+    isStrictHexString(chainId) ? 16 : 10,
+  );
+  return (
+    Number.isSafeInteger(decimalChainId) &&
+    decimalChainId > 0 &&
+    decimalChainId <= MAX_SAFE_CHAIN_ID
+  );
+}
+/**
+ * Converts a BN or BigNumber object to a hex string with a '0x' prefix.
+ *
+ * @param inputBn - BN|BigNumber instance to convert to a hex string.
+ * @returns A '0x'-prefixed hex string.
+ */
+// TODO: Fix naming convention.
+// eslint-disable-next-line @typescript-eslint/naming-convention
+export function BNToHex(inputBn: BN | BigNumber): Hex {
+  return add0x(inputBn.toString(16));
+}
+
+/**
+ * Used to multiply a BN by a fraction.
+ *
+ * @param targetBN - Number to multiply by a fraction.
+ * @param numerator - Numerator of the fraction multiplier.
+ * @param denominator - Denominator of the fraction multiplier.
+ * @returns Product of the multiplication.
+ */
+export function fractionBN(
+  targetBN: BN,
+  numerator: number | string,
+  denominator: number | string,
+): BN {
+  const numBN = new BN(numerator);
+  const denomBN = new BN(denominator);
+  return targetBN.mul(numBN).div(denomBN);
+}
+
+/**
+ * Used to convert a base-10 number from GWEI to WEI. Can handle numbers with decimal parts.
+ *
+ * @param value - The base 10 number to convert to WEI.
+ * @returns The number in WEI, as a BN.
+ */
+export function gweiDecToWEIBN(value: number | string): BN {
+  if (Number.isNaN(value)) {
+    return new BN(0);
+  }
+
+  const parts = value.toString().split('.');
+  const wholePart = parts[0] || '0';
+  let decimalPart = parts[1] || '';
+
+  if (!decimalPart) {
+    return toWei(wholePart, 'gwei');
+  }
+
+  if (decimalPart.length <= 9) {
+    return toWei(`${wholePart}.${decimalPart}`, 'gwei');
+  }
+
+  const decimalPartToRemove = decimalPart.slice(9);
+  const decimalRoundingDigit = decimalPartToRemove[0];
+
+  decimalPart = decimalPart.slice(0, 9);
+  let wei = toWei(`${wholePart}.${decimalPart}`, 'gwei');
+
+  if (Number(decimalRoundingDigit) >= 5) {
+    wei = wei.add(new BN(1));
+  }
+
+  return wei;
+}
+
+/**
+ * Used to convert values from wei hex format to dec gwei format.
+ *
+ * @param hexValue - The value in hex wei.
+ * @returns The value in dec gwei as string.
+ */
+export function weiHexToGweiDec(hexValue: string): string {
+  const hexWei = new BN(remove0x(hexValue), 16);
+  return fromWei(hexWei, 'gwei');
+}
+
+/**
+ * Return a URL that can be used to obtain ETH for a given network.
+ *
+ * @param networkCode - Network code of desired network.
+ * @param address - Address to deposit obtained ETH.
+ * @param amount - How much ETH is desired.
+ * @returns URL to buy ETH based on network.
+ */
+export function getBuyURL(
+  networkCode = '1',
+  address?: string,
+  amount = 5,
+): string | undefined {
+  switch (networkCode) {
+    case '1':
+      return `https://buy.coinbase.com/?code=9ec56d01-7e81-5017-930c-513daa27bb6a&amount=${amount}&address=${address}&crypto_currency=ETH`;
+    case '5':
+      return 'https://goerli-faucet.slock.it/';
+    case '11155111':
+      return 'https://sepoliafaucet.net/';
+    default:
+      return undefined;
+  }
+}
+
+/**
+ * Converts a hex string to a BN object.
+ *
+ * @param inputHex - Number represented as a hex string.
+ * @returns A BN instance.
+ */
+export function hexToBN(inputHex: string): BN {
+  return inputHex ? new BN(remove0x(inputHex), 16) : new BN(0);
+}
+
+/**
+ * A helper function that converts hex data to human readable string.
+ *
+ * @param hexValue - The hex string to convert to string.
+ * @returns A human readable string conversion.
+ */
+export function hexToText(hexValue: string): string {
+  try {
+    const stripped = remove0x(hexValue);
+    // TODO: Use `@metamask/utils` version of this function to avoid use of
+    // Buffer.
+    // eslint-disable-next-line no-restricted-globals
+    const buff = Buffer.from(stripped, 'hex');
+    return buff.toString('utf8');
+  } catch {
+    /* istanbul ignore next */
+    return hexValue;
+  }
+}
+
+/**
+ * Parses a hex string and converts it into a number that can be operated on in a bignum-safe,
+ * base-10 way.
+ *
+ * @param value - A base-16 number encoded as a string.
+ * @returns The number as a BN object in base-16 mode.
+ */
+export function fromHex(value: string | BN): BN {
+  if (BN.isBN(value)) {
+    return value;
+  }
+  return new BN(hexToBN(value).toString(10));
+}
+
+/**
+ * Converts an integer to a hexadecimal representation.
+ *
+ * @param value - An integer, an integer encoded as a base-10 string, or a BN.
+ * @returns The integer encoded as a hex string.
+ */
+export function toHex(value: number | bigint | string | BN): Hex {
+  if (typeof value === 'string' && isStrictHexString(value)) {
+    return value;
+  }
+  const hexString =
+    BN.isBN(value) || typeof value === 'bigint'
+      ? value.toString(16)
+      : new BN(value.toString(), 10).toString(16);
+  return `0x${hexString}`;
+}
+
+/**
+ * Execute and return an asynchronous operation without throwing errors.
+ *
+ * @param operation - Function returning a Promise.
+ * @param logError - Determines if the error should be logged.
+ * @template Result - Type of the result of the async operation
+ * @returns Promise resolving to the result of the async operation.
+ */
+export async function safelyExecute<Result>(
+  operation: () => Promise<Result>,
+  logError = false,
+): Promise<Result | undefined> {
+  try {
+    return await operation();
+  } catch (error) {
+    /* istanbul ignore next */
+    if (logError) {
+      console.error(error);
+    }
+    return undefined;
+  }
+}
+
+/**
+ * Execute and return an asynchronous operation with a timeout.
+ *
+ * @param operation - Function returning a Promise.
+ * @param logError - Determines if the error should be logged.
+ * @param timeout - Timeout to fail the operation.
+ * @template Result - Type of the result of the async operation
+ * @returns Promise resolving to the result of the async operation.
+ */
+export async function safelyExecuteWithTimeout<Result>(
+  operation: () => Promise<Result>,
+  logError = false,
+  timeout = 500,
+): Promise<Result | undefined> {
+  try {
+    return await Promise.race([
+      operation(),
+      new Promise<never>((_resolve, reject) =>
+        setTimeout(() => {
+          reject(TIMEOUT_ERROR);
+        }, timeout),
+      ),
+    ]);
+  } catch (error) {
+    /* istanbul ignore next */
+    if (logError) {
+      console.error(error);
+    }
+    return undefined;
+  }
+}
+
+/**
+ * Convert an address to a checksummed hexadecimal address.
+ *
+ * @param address - The address to convert.
+ * @returns The address in 0x-prefixed hexadecimal checksummed form if it is valid.
+ */
+function toChecksumHexAddressUnmemoized(address: string): string;
+
+/**
+ * Convert an address to a checksummed hexadecimal address.
+ *
+ * Note that this particular overload does nothing.
+ *
+ * @param address - A value that is not a string (e.g. `undefined` or `null`).
+ * @returns The `address` untouched.
+ * @deprecated This overload is designed to gracefully handle an invalid input
+ * and is only present for backward compatibility. It may be removed in a future
+ * major version. Please pass a string to `toChecksumHexAddress` instead.
+ */
+function toChecksumHexAddressUnmemoized<Type>(address: Type): Type;
+
+function toChecksumHexAddressUnmemoized(address: unknown): unknown {
+  if (typeof address !== 'string') {
+    // Mimic behavior of `addHexPrefix` from `ethereumjs-util` (which this
+    // function was previously using) for backward compatibility.
+    return address;
+  }
+
+  const hexPrefixed = add0x(address);
+
+  if (!isHexString(hexPrefixed)) {
+    // Version 5.1 of ethereumjs-util would have returned '0xY' for input 'y'
+    // but we shouldn't waste effort trying to change case on a clearly invalid
+    // string. Instead just return the hex prefixed original string which most
+    // closely mimics the original behavior.
+    return hexPrefixed;
+  }
+
+  try {
+    return getChecksumAddress(hexPrefixed);
+  } catch (error) {
+    // This is necessary for backward compatibility with the old behavior of
+    // `ethereumjs-util` which would return the original string if the address
+    // was invalid.
+    if (error instanceof Error && error.message === 'Invalid hex address.') {
+      return hexPrefixed;
+    }
+    throw error;
+  }
+}
+
+/**
+ * Convert an address to a checksummed hexadecimal address.
+ *
+ * @param address - The address to convert. For backward compatibility reasons,
+ * this can be anything, even a non-hex string with an 0x prefix, but that usage
+ * is deprecated. Please use a valid hex string (with or without the `0x`
+ * prefix).
+ * @returns A 0x-prefixed checksummed version of `address` if it is a valid hex
+ * string, or the address as given otherwise.
+ */
+export const toChecksumHexAddress: {
+  (address: string): string;
+  <Type>(address: Type): Type;
+} = memoize(toChecksumHexAddressUnmemoized);
+
+function isValidHexAddressUnmemoized(
+  possibleAddress: string,
+  { allowNonPrefixed = true } = {},
+): boolean {
+  const addressToCheck = allowNonPrefixed
+    ? add0x(possibleAddress)
+    : possibleAddress;
+  if (!isStrictHexString(addressToCheck)) {
+    return false;
+  }
+
+  // We used to rely on `isValidAddress` from `@ethereumjs/util` which allows
+  // for upper-case characters too. So we preserve this behavior and use our
+  // faster and memoized validation function instead.
+  return isHexChecksumAddress(addressToCheck);
+}
+
+/**
+ * Validates that the input is a hex address. This utility method is a thin
+ * wrapper around `isValidHexAddress` from `@metamask/utils`, with the exception
+ * that it may return true for non-0x-prefixed hex strings (depending on the
+ * option below).
+ *
+ * @param possibleAddress - Input parameter to check against.
+ * @param options - The validation options.
+ * @param options.allowNonPrefixed - If true will regard addresses without a
+ * `0x` prefix as valid.
+ * @returns Whether or not the input is a valid hex address.
+ */
+export const isValidHexAddress: (
+  possibleAddress: string,
+  options?: { allowNonPrefixed?: boolean },
+) => boolean = memoize(
+  isValidHexAddressUnmemoized,
+  (possibleAddress, { allowNonPrefixed = true } = {}) =>
+    `${possibleAddress}-${allowNonPrefixed}`,
+);
+
+/**
+ * Returns whether the given code corresponds to a smart contract.
+ *
+ * @param code - The potential smart contract code.
+ * @returns Whether the code was smart contract code or not.
+ */
+export function isSmartContractCode(code: string): boolean {
+  /* istanbul ignore if */
+  if (!code) {
+    return false;
+  }
+  // Geth will return '0x', and ganache-core v2.2.1 will return '0x0'
+  const smartContractCode = code !== '0x' && code !== '0x0';
+  return smartContractCode;
+}
+
+/**
+ * An error representing a non-200 HTTP response.
+ */
+export class HttpError extends Error {
+  public httpStatus: number;
+
+  /**
+   * Construct an HTTP error.
+   *
+   * @param status - The HTTP response status.
+   * @param message - The error message.
+   */
+  constructor(status: number, message?: string) {
+    super(message ?? `Fetch failed with status '${status}'`);
+    this.httpStatus = status;
+  }
+}
+
+/**
+ * Execute fetch and verify that the response was successful.
+ *
+ * @param request - Request information.
+ * @param options - Fetch options.
+ * @returns The fetch response.
+ */
+export async function successfulFetch(
+  request: URL | RequestInfo,
+  options?: RequestInit,
+): Promise<Response> {
+  const response = await fetch(request, options);
+  if (!response.ok) {
+    throw new HttpError(
+      response.status,
+      // TODO: Replace `String` with more specific conversion.
+      // eslint-disable-next-line @typescript-eslint/no-base-to-string
+      `Fetch failed with status '${response.status}' for request '${String(request)}'`,
+    );
+  }
+  return response;
+}
+
+/**
+ * Execute fetch and return object response.
+ *
+ * @param request - The request information.
+ * @param options - The fetch options.
+ * @returns The fetch response JSON data.
+ */
+export async function handleFetch(
+  request: URL | RequestInfo,
+  options?: RequestInit,
+  // TODO: Replace `any` with more specific type.
+  // eslint-disable-next-line @typescript-eslint/no-explicit-any
+): Promise<any> {
+  const response = await successfulFetch(request, options);
+  const object = await response.json();
+  return object;
+}
+
+/**
+ * Execute fetch and return object response, log if known error thrown, otherwise rethrow error.
+ *
+ * @param request - the request options object
+ * @param request.url - The request url to query.
+ * @param request.options - The fetch options.
+ * @param request.timeout - Timeout to fail request
+ * @param request.errorCodesToCatch - array of error codes for errors we want to catch in a particular context
+ * @returns The fetch response JSON data or undefined (if error occurs).
+ */
+export async function fetchWithErrorHandling({
+  url,
+  options,
+  timeout,
+  errorCodesToCatch,
+}: {
+  url: string;
+  options?: RequestInit;
+  timeout?: number;
+  errorCodesToCatch?: number[];
+  // TODO: Replace `any` with more specific type.
+  // eslint-disable-next-line @typescript-eslint/no-explicit-any
+}): Promise<any> {
+  let result;
+  try {
+    if (timeout) {
+      result = Promise.race([
+        await handleFetch(url, options),
+        new Promise<Response>((_resolve, reject) =>
+          setTimeout(() => {
+            reject(TIMEOUT_ERROR);
+          }, timeout),
+        ),
+      ]);
+    } else {
+      result = await handleFetch(url, options);
+    }
+  } catch (error) {
+    logOrRethrowError(error, errorCodesToCatch);
+  }
+  return result;
+}
+
+/**
+ * Fetch that fails after timeout.
+ *
+ * @param url - Url to fetch.
+ * @param options - Options to send with the request.
+ * @param timeout - Timeout to fail request.
+ * @returns Promise resolving the request.
+ */
+export async function timeoutFetch(
+  url: string,
+  options?: RequestInit,
+  timeout = 500,
+): Promise<Response> {
+  return Promise.race([
+    successfulFetch(url, options),
+    new Promise<Response>((_resolve, reject) =>
+      setTimeout(() => {
+        reject(TIMEOUT_ERROR);
+      }, timeout),
+    ),
+  ]);
+}
+
+/**
+ * Normalizes the given ENS name.
+ *
+ * @param ensName - The ENS name.
+ * @returns The normalized ENS name string.
+ */
+export function normalizeEnsName(ensName: string): string | null {
+  // `.` refers to the registry root contract
+  if (ensName === '.') {
+    return ensName;
+  }
+  if (ensName && typeof ensName === 'string') {
+    try {
+      const normalized = ensNamehash.normalize(ensName.trim());
+      // this regex is only sufficient with the above call to ensNamehash.normalize
+      // TODO: change 7 in regex to 3 when shorter ENS domains are live
+      if (normalized.match(/^(([\w\d-]+)\.)*[\w\d-]{7,}\.(eth|test)$/u)) {
+        return normalized;
+      }
+    } catch {
+      // do nothing
+    }
+  }
+  return null;
+}
+
+/**
+ * Wrapper method to handle EthQuery requests.
+ *
+ * @param ethQuery - EthQuery object initialized with a provider.
+ * @param method - Method to request.
+ * @param args - Arguments to send.
+ * @returns Promise resolving the request.
+ */
+export function query(
+  ethQuery: EthQuery,
+  method: string,
+  // TODO: Replace `any` with type
+  // eslint-disable-next-line @typescript-eslint/no-explicit-any
+  args: any[] = [],
+  // TODO: Replace `any` with type
+  // eslint-disable-next-line @typescript-eslint/no-explicit-any
+): Promise<any> {
+  return new Promise((resolve, reject) => {
+    const callback = (error: unknown, result: unknown): void => {
+      if (error) {
+        // We don't control the error object returned by eth-query, so
+        // we can't guarantee it's an instance of Error.
+        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors
+        reject(error);
+        return;
+      }
+      resolve(result);
+    };
+
+    // Using `in` rather than `hasProperty` so that we look up the prototype
+    // chain for the method.
+    if (method in ethQuery && typeof ethQuery[method] === 'function') {
+      ethQuery[method](...args, callback);
+    } else {
+      ethQuery.sendAsync({ method, params: args }, callback);
+    }
+  });
+}
+
+/**
+ * Converts valid hex strings to decimal numbers, and handles unexpected arg types.
+ *
+ * @param value - a string that is either a hexadecimal with `0x` prefix or a decimal string.
+ * @returns a decimal number.
+ */
+export const convertHexToDecimal = (
+  value: string | undefined = '0x0',
+): number => {
+  if (isStrictHexString(value)) {
+    return parseInt(value, 16);
+  }
+
+  return Number(value) ? Number(value) : 0;
+};
+
+type PlainObject = Record<number | string | symbol, unknown>;
+
+/**
+ * Determines whether a value is a "plain" object.
+ *
+ * @param value - A value to check
+ * @returns True if the passed value is a plain object
+ */
+export function isPlainObject(value: unknown): value is PlainObject {
+  return Boolean(value) && typeof value === 'object' && !Array.isArray(value);
+}
+
+/**
+ * Like {@link Array}, but always non-empty.
+ *
+ * @template T - The non-empty array member type.
+ */
+export type NonEmptyArray<Type> = [Type, ...Type[]];
+
+/**
+ * Type guard for {@link NonEmptyArray}.
+ *
+ * @template T - The non-empty array member type.
+ * @param value - The value to check.
+ * @returns Whether the value is a non-empty array.
+ */
+export function isNonEmptyArray<Type>(
+  value: Type[],
+): value is NonEmptyArray<Type> {
+  return Array.isArray(value) && value.length > 0;
+}
+
+/**
+ * Type guard for {@link Json}.
+ *
+ * @param value - The value to check.
+ * @returns Whether the value is valid JSON.
+ */
+export function isValidJson(value: unknown): value is Json {
+  try {
+    return deepEqual(value, JSON.parse(JSON.stringify(value)));
+  } catch {
+    return false;
+  }
+}
+
+/**
+ * Utility method to log if error is a common fetch error and otherwise rethrow it.
+ *
+ * @param error - Caught error that we should either rethrow or log to console
+ * @param codesToCatch - array of error codes for errors we want to catch and log in a particular context
+ */
+function logOrRethrowError(error: unknown, codesToCatch: number[] = []): void {
+  if (!error) {
+    return;
+  }
+
+  if (error instanceof Error) {
+    const includesErrorCodeToCatch = codesToCatch.some((code) =>
+      error.message.includes(`Fetch failed with status '${code}'`),
+    );
+
+    if (
+      includesErrorCodeToCatch ||
+      error.message.includes('Failed to fetch') ||
+      error === TIMEOUT_ERROR
+    ) {
+      console.error(error);
+    } else {
+      throw error;
+    }
+  } else {
+    // eslint-disable-next-line @typescript-eslint/only-throw-error
+    throw error;
+  }
+}
+
+/**
+ * Checks if two strings are equal, ignoring case.
+ *
+ * @param value1 - The first string to compare.
+ * @param value2 - The second string to compare.
+ * @returns `true` if the strings are equal, ignoring case; otherwise, `false`.
+ */
+export function isEqualCaseInsensitive(
+  value1: string,
+  value2: string,
+): boolean {
+  if (typeof value1 !== 'string' || typeof value2 !== 'string') {
+    return false;
+  }
+  return value1.toLowerCase() === value2.toLowerCase();
+}
diff --git a/tsconfig.build.json b/tsconfig.build.json
new file mode 100644
index 0000000000000000000000000000000000000000..0df910b2151ce376a15259c1f59d4c80e60d8fc8
--- /dev/null
+++ b/tsconfig.build.json
@@ -0,0 +1,9 @@
+{
+  "extends": "../../tsconfig.packages.build.json",
+  "compilerOptions": {
+    "baseUrl": "./",
+    "outDir": "./dist",
+    "rootDir": "./src"
+  },
+  "include": ["../../types", "./src"]
+}
diff --git a/tsconfig.build.tsbuildinfo b/tsconfig.build.tsbuildinfo
new file mode 100644
index 0000000000000000000000000000000000000000..8dc1b43e87686a2a9e1ce52da7b4d16f9c6eea5c
--- /dev/null
+++ b/tsconfig.build.tsbuildinfo
@@ -0,0 +1 @@
+{"version":"5.3.3"}
\ No newline at end of file
diff --git a/tsconfig.json b/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..ee9de925a21f10f53e5d76edeaebf553443c8825
--- /dev/null
+++ b/tsconfig.json
@@ -0,0 +1,7 @@
+{
+  "extends": "../../tsconfig.packages.json",
+  "compilerOptions": {
+    "baseUrl": "./"
+  },
+  "include": ["../../types", "./src"]
+}
diff --git a/typedoc.json b/typedoc.json
new file mode 100644
index 0000000000000000000000000000000000000000..c9da015dbf8a0e0e3d39dd61f7c0386efac96ddc
--- /dev/null
+++ b/typedoc.json
@@ -0,0 +1,7 @@
+{
+  "entryPoints": ["./src/index.ts"],
+  "excludePrivate": true,
+  "hideGenerator": true,
+  "out": "docs",
+  "tsconfig": "./tsconfig.build.json"
+}
