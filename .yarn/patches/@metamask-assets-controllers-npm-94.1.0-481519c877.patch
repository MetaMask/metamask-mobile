diff --git a/dist/TokenListController.cjs b/dist/TokenListController.cjs
index 8c22212fc3fc9c2a58fbea7a2c15c90109062ee8..c26bf3d11b3d076073b735a52c703b912b07b460 100644
--- a/dist/TokenListController.cjs
+++ b/dist/TokenListController.cjs
@@ -4,7 +4,13 @@ var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (
     if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
     return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
 };
-var _TokenListController_instances, _TokenListController_onNetworkControllerStateChange, _TokenListController_startDeprecatedPolling;
+var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
+    if (kind === "m") throw new TypeError("Private method is not writable");
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
+    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
+};
+var _TokenListController_instances, _a, _TokenListController_mutex, _TokenListController_storageKeyPrefix, _TokenListController_getChainStorageKey, _TokenListController_intervalId, _TokenListController_intervalDelay, _TokenListController_cacheRefreshThreshold, _TokenListController_chainId, _TokenListController_abortController, _TokenListController_loadCacheFromStorage, _TokenListController_saveChainCacheToStorage, _TokenListController_migrateStateToStorage, _TokenListController_onNetworkControllerStateChange, _TokenListController_stopPolling, _TokenListController_startDeprecatedPolling;
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.TokenListController = exports.getDefaultTokenListState = void 0;
 const controller_utils_1 = require("@metamask/controller-utils");
@@ -18,7 +24,7 @@ const name = 'TokenListController';
 const metadata = {
     tokensChainsCache: {
         includeInStateLogs: false,
-        persist: true,
+        persist: false, // Persisted separately via StorageService
         includeInDebugSnapshot: true,
         usedInUi: true,
     },
@@ -60,13 +66,27 @@ class TokenListController extends (0, polling_controller_1.StaticIntervalPolling
             state: { ...(0, exports.getDefaultTokenListState)(), ...state },
         });
         _TokenListController_instances.add(this);
-        this.mutex = new async_mutex_1.Mutex();
-        this.intervalDelay = interval;
+        _TokenListController_mutex.set(this, new async_mutex_1.Mutex());
+        _TokenListController_intervalId.set(this, void 0);
+        _TokenListController_intervalDelay.set(this, void 0);
+        _TokenListController_cacheRefreshThreshold.set(this, void 0);
+        _TokenListController_chainId.set(this, void 0);
+        _TokenListController_abortController.set(this, void 0);
+        __classPrivateFieldSet(this, _TokenListController_intervalDelay, interval, "f");
         this.setIntervalLength(interval);
-        this.cacheRefreshThreshold = cacheRefreshThreshold;
-        this.chainId = chainId;
+        __classPrivateFieldSet(this, _TokenListController_cacheRefreshThreshold, cacheRefreshThreshold, "f");
+        __classPrivateFieldSet(this, _TokenListController_chainId, chainId, "f");
         this.updatePreventPollingOnNetworkRestart(preventPollingOnNetworkRestart);
-        this.abortController = new AbortController();
+        __classPrivateFieldSet(this, _TokenListController_abortController, new AbortController(), "f");
+        // Load cache from StorageService on initialization and handle migration
+        __classPrivateFieldGet(this, _TokenListController_instances, "m", _TokenListController_loadCacheFromStorage).call(this)
+            .then(() => {
+            // Migrate existing cache from state to StorageService if needed
+            return __classPrivateFieldGet(this, _TokenListController_instances, "m", _TokenListController_migrateStateToStorage).call(this);
+        })
+            .catch((error) => {
+            console.error('TokenListController: Failed to load cache from storage:', error);
+        });
         if (onNetworkStateChange) {
             // TODO: Either fix this lint violation or explain why it's necessary to ignore.
             // eslint-disable-next-line @typescript-eslint/no-misused-promises
@@ -92,7 +112,7 @@ class TokenListController extends (0, polling_controller_1.StaticIntervalPolling
      * Consider using the new polling approach instead
      */
     async start() {
-        if (!(0, assetsUtil_1.isTokenListSupportedForNetwork)(this.chainId)) {
+        if (!(0, assetsUtil_1.isTokenListSupportedForNetwork)(__classPrivateFieldGet(this, _TokenListController_chainId, "f"))) {
             return;
         }
         await __classPrivateFieldGet(this, _TokenListController_instances, "m", _TokenListController_startDeprecatedPolling).call(this);
@@ -104,7 +124,7 @@ class TokenListController extends (0, polling_controller_1.StaticIntervalPolling
      * Consider using the new polling approach instead
      */
     async restart() {
-        this.stopPolling();
+        __classPrivateFieldGet(this, _TokenListController_instances, "m", _TokenListController_stopPolling).call(this);
         await __classPrivateFieldGet(this, _TokenListController_instances, "m", _TokenListController_startDeprecatedPolling).call(this);
     }
     /**
@@ -114,7 +134,7 @@ class TokenListController extends (0, polling_controller_1.StaticIntervalPolling
      * Consider using the new polling approach instead
      */
     stop() {
-        this.stopPolling();
+        __classPrivateFieldGet(this, _TokenListController_instances, "m", _TokenListController_stopPolling).call(this);
     }
     /**
      * This stops any active polling.
@@ -124,18 +144,7 @@ class TokenListController extends (0, polling_controller_1.StaticIntervalPolling
      */
     destroy() {
         super.destroy();
-        this.stopPolling();
-    }
-    /**
-     * This stops any active polling intervals.
-     *
-     * @deprecated This method is deprecated and will be removed in the future.
-     * Consider using the new polling approach instead
-     */
-    stopPolling() {
-        if (this.intervalId) {
-            clearInterval(this.intervalId);
-        }
+        __classPrivateFieldGet(this, _TokenListController_instances, "m", _TokenListController_stopPolling).call(this);
     }
     /**
      * This starts a new polling loop for any given chain. Under the hood it is deduping polls
@@ -148,18 +157,19 @@ class TokenListController extends (0, polling_controller_1.StaticIntervalPolling
         return this.fetchTokenList(chainId);
     }
     /**
-     * Fetching token list from the Token Service API. This will fetch tokens across chains. It will update tokensChainsCache (scoped across chains), and also the tokenList (scoped for the selected chain)
+     * Fetching token list from the Token Service API. This will fetch tokens across chains.
+     * Updates state and persists to StorageService separately.
      *
      * @param chainId - The chainId of the current chain triggering the fetch.
      */
     async fetchTokenList(chainId) {
-        const releaseLock = await this.mutex.acquire();
+        const releaseLock = await __classPrivateFieldGet(this, _TokenListController_mutex, "f").acquire();
         try {
             if (this.isCacheValid(chainId)) {
                 return;
             }
             // Fetch fresh token list from the API
-            const tokensFromAPI = await (0, controller_utils_1.safelyExecute)(() => (0, token_service_1.fetchTokenListByChainId)(chainId, this.abortController.signal));
+            const tokensFromAPI = await (0, controller_utils_1.safelyExecute)(() => (0, token_service_1.fetchTokenListByChainId)(chainId, __classPrivateFieldGet(this, _TokenListController_abortController, "f").signal));
             // Have response - process and update list
             if (tokensFromAPI) {
                 // Format tokens from API (HTTP) and update tokenList
@@ -174,23 +184,28 @@ class TokenListController extends (0, polling_controller_1.StaticIntervalPolling
                         }),
                     };
                 }
+                // Update state
+                const newDataCache = {
+                    data: tokenList,
+                    timestamp: Date.now(),
+                };
                 this.update((state) => {
-                    var _a;
-                    const newDataCache = { data: {}, timestamp: Date.now() };
-                    (_a = state.tokensChainsCache)[chainId] ?? (_a[chainId] = newDataCache);
-                    state.tokensChainsCache[chainId].data = tokenList;
-                    state.tokensChainsCache[chainId].timestamp = Date.now();
+                    state.tokensChainsCache[chainId] = newDataCache;
                 });
+                // Persist only this chain to StorageService (reduces write amplification)
+                await __classPrivateFieldGet(this, _TokenListController_instances, "m", _TokenListController_saveChainCacheToStorage).call(this, chainId);
                 return;
             }
             // No response - fallback to previous state, or initialise empty
             if (!tokensFromAPI) {
+                const newDataCache = { data: {}, timestamp: Date.now() };
                 this.update((state) => {
-                    var _a;
-                    const newDataCache = { data: {}, timestamp: Date.now() };
-                    (_a = state.tokensChainsCache)[chainId] ?? (_a[chainId] = newDataCache);
+                    var _b;
+                    (_b = state.tokensChainsCache)[chainId] ?? (_b[chainId] = newDataCache);
                     state.tokensChainsCache[chainId].timestamp = Date.now();
                 });
+                // Persist only this chain to StorageService
+                await __classPrivateFieldGet(this, _TokenListController_instances, "m", _TokenListController_saveChainCacheToStorage).call(this, chainId);
             }
         }
         finally {
@@ -201,18 +216,29 @@ class TokenListController extends (0, polling_controller_1.StaticIntervalPolling
         const { tokensChainsCache } = this.state;
         const timestamp = tokensChainsCache[chainId]?.timestamp;
         const now = Date.now();
-        return (timestamp !== undefined && now - timestamp < this.cacheRefreshThreshold);
+        return (timestamp !== undefined && now - timestamp < __classPrivateFieldGet(this, _TokenListController_cacheRefreshThreshold, "f"));
     }
     /**
      * Clearing tokenList and tokensChainsCache explicitly.
+     * This clears both state and all per-chain files in StorageService.
      */
-    clearingTokenListData() {
-        this.update(() => {
-            return {
-                ...this.state,
-                tokensChainsCache: {},
-            };
+    async clearingTokenListData() {
+        // Clear state
+        this.update((state) => {
+            state.tokensChainsCache = {};
         });
+        // Clear all per-chain files from StorageService
+        try {
+            const allKeys = await this.messenger.call('StorageService:getAllKeys', name);
+            // Filter and remove all tokensChainsCache keys
+            const cacheKeys = allKeys.filter((key) => key.startsWith(`${__classPrivateFieldGet(_a, _a, "f", _TokenListController_storageKeyPrefix)}:`));
+            await Promise.all(cacheKeys.map((key) => this.messenger.call('StorageService:removeItem', name, key)));
+            // Also remove old single-file storage if it exists (cleanup)
+            await this.messenger.call('StorageService:removeItem', name, __classPrivateFieldGet(_a, _a, "f", _TokenListController_storageKeyPrefix));
+        }
+        catch (error) {
+            console.error('TokenListController: Failed to clear cache from storage:', error);
+        }
     }
     /**
      * Updates preventPollingOnNetworkRestart from extension.
@@ -229,7 +255,105 @@ class TokenListController extends (0, polling_controller_1.StaticIntervalPolling
     }
 }
 exports.TokenListController = TokenListController;
-_TokenListController_instances = new WeakSet(), _TokenListController_onNetworkControllerStateChange = 
+_a = TokenListController, _TokenListController_mutex = new WeakMap(), _TokenListController_intervalId = new WeakMap(), _TokenListController_intervalDelay = new WeakMap(), _TokenListController_cacheRefreshThreshold = new WeakMap(), _TokenListController_chainId = new WeakMap(), _TokenListController_abortController = new WeakMap(), _TokenListController_instances = new WeakSet(), _TokenListController_getChainStorageKey = function _TokenListController_getChainStorageKey(chainId) {
+    return `${__classPrivateFieldGet(_a, _a, "f", _TokenListController_storageKeyPrefix)}:${chainId}`;
+}, _TokenListController_loadCacheFromStorage = 
+/**
+ * Load tokensChainsCache from StorageService into state.
+ * Loads all cached chains from separate per-chain files in parallel.
+ * Called during initialization to restore cached data.
+ *
+ * @returns A promise that resolves when loading is complete.
+ */
+async function _TokenListController_loadCacheFromStorage() {
+    try {
+        // Get all keys for this controller
+        const allKeys = await this.messenger.call('StorageService:getAllKeys', name);
+        // Filter keys that belong to tokensChainsCache (per-chain files)
+        const cacheKeys = allKeys.filter((key) => key.startsWith(`${__classPrivateFieldGet(_a, _a, "f", _TokenListController_storageKeyPrefix)}:`));
+        if (cacheKeys.length === 0) {
+            return; // No cached data
+        }
+        // Load all chains in parallel
+        const chainCaches = await Promise.all(cacheKeys.map(async (key) => {
+            // Extract chainId from key: 'tokensChainsCache:0x1' → '0x1'
+            const chainId = key.split(':')[1];
+            const { result, error } = await this.messenger.call('StorageService:getItem', name, key);
+            if (error) {
+                console.error(`TokenListController: Error loading cache for ${chainId}:`, error);
+                return null;
+            }
+            return result ? { chainId, data: result } : null;
+        }));
+        // Build complete cache from loaded chains
+        const loadedCache = {};
+        chainCaches.forEach((chainCache) => {
+            if (chainCache) {
+                loadedCache[chainCache.chainId] = chainCache.data;
+            }
+        });
+        // Load into state (all chains available for TokenDetectionController)
+        if (Object.keys(loadedCache).length > 0) {
+            this.update((state) => {
+                state.tokensChainsCache = loadedCache;
+            });
+        }
+    }
+    catch (error) {
+        console.error('TokenListController: Failed to load cache from storage:', error);
+    }
+}, _TokenListController_saveChainCacheToStorage = 
+/**
+ * Save a specific chain's cache to StorageService.
+ * This persists only the updated chain's data, reducing write amplification.
+ *
+ * @param chainId - The chain ID to save.
+ * @returns A promise that resolves when saving is complete.
+ */
+async function _TokenListController_saveChainCacheToStorage(chainId) {
+    try {
+        const chainData = this.state.tokensChainsCache[chainId];
+        if (!chainData) {
+            console.warn(`TokenListController: No cache data for chain ${chainId}`);
+            return;
+        }
+        const storageKey = __classPrivateFieldGet(_a, _a, "m", _TokenListController_getChainStorageKey).call(_a, chainId);
+        await this.messenger.call('StorageService:setItem', name, storageKey, chainData);
+    }
+    catch (error) {
+        console.error(`TokenListController: Failed to save cache for ${chainId}:`, error);
+    }
+}, _TokenListController_migrateStateToStorage = 
+/**
+ * Migrate tokensChainsCache from old persisted state to per-chain files.
+ * Handles backward compatibility for users upgrading from the old
+ * framework-managed state (persist: true) to StorageService.
+ *
+ * @returns A promise that resolves when migration is complete.
+ */
+async function _TokenListController_migrateStateToStorage() {
+    try {
+        // Check if we have data in state that needs migration
+        if (!this.state.tokensChainsCache ||
+            Object.keys(this.state.tokensChainsCache).length === 0) {
+            return; // No data to migrate
+        }
+        // Check if per-chain files already exist (migration already done)
+        const allKeys = await this.messenger.call('StorageService:getAllKeys', name);
+        const hasPerChainFiles = allKeys.some((key) => key.startsWith(`${__classPrivateFieldGet(_a, _a, "f", _TokenListController_storageKeyPrefix)}:`));
+        if (hasPerChainFiles) {
+            return; // Already migrated
+        }
+        // Migrate from old persisted state to per-chain files
+        console.log('TokenListController: Migrating from persisted state to per-chain storage');
+        // Split into per-chain files
+        await Promise.all(Object.keys(this.state.tokensChainsCache).map((chainId) => __classPrivateFieldGet(this, _TokenListController_instances, "m", _TokenListController_saveChainCacheToStorage).call(this, chainId)));
+        console.log('TokenListController: Migration to per-chain storage complete');
+    }
+    catch (error) {
+        console.error('TokenListController: Failed to migrate cache to storage:', error);
+    }
+}, _TokenListController_onNetworkControllerStateChange = 
 /**
  * Updates state and restarts polling on changes to the network controller
  * state.
@@ -239,14 +363,20 @@ _TokenListController_instances = new WeakSet(), _TokenListController_onNetworkCo
 async function _TokenListController_onNetworkControllerStateChange(networkControllerState) {
     const selectedNetworkClient = this.messenger.call('NetworkController:getNetworkClientById', networkControllerState.selectedNetworkClientId);
     const { chainId } = selectedNetworkClient.configuration;
-    if (this.chainId !== chainId) {
-        this.abortController.abort();
-        this.abortController = new AbortController();
-        this.chainId = chainId;
+    if (__classPrivateFieldGet(this, _TokenListController_chainId, "f") !== chainId) {
+        __classPrivateFieldGet(this, _TokenListController_abortController, "f").abort();
+        __classPrivateFieldSet(this, _TokenListController_abortController, new AbortController(), "f");
+        __classPrivateFieldSet(this, _TokenListController_chainId, chainId, "f");
         if (this.state.preventPollingOnNetworkRestart) {
-            this.clearingTokenListData();
+            this.clearingTokenListData().catch((error) => {
+                console.error('Failed to clear token list data:', error);
+            });
         }
     }
+}, _TokenListController_stopPolling = function _TokenListController_stopPolling() {
+    if (__classPrivateFieldGet(this, _TokenListController_intervalId, "f")) {
+        clearInterval(__classPrivateFieldGet(this, _TokenListController_intervalId, "f"));
+    }
 }, _TokenListController_startDeprecatedPolling = 
 /**
  * Starts a new polling interval for a given chainId (this should be deprecated in favor of _executePoll)
@@ -256,12 +386,14 @@ async function _TokenListController_onNetworkControllerStateChange(networkContro
  */
 async function _TokenListController_startDeprecatedPolling() {
     // renaming this to avoid collision with base class
-    await (0, controller_utils_1.safelyExecute)(() => this.fetchTokenList(this.chainId));
+    await (0, controller_utils_1.safelyExecute)(() => this.fetchTokenList(__classPrivateFieldGet(this, _TokenListController_chainId, "f")));
     // TODO: Either fix this lint violation or explain why it's necessary to ignore.
     // eslint-disable-next-line @typescript-eslint/no-misused-promises
-    this.intervalId = setInterval(async () => {
-        await (0, controller_utils_1.safelyExecute)(() => this.fetchTokenList(this.chainId));
-    }, this.intervalDelay);
+    __classPrivateFieldSet(this, _TokenListController_intervalId, setInterval(async () => {
+        await (0, controller_utils_1.safelyExecute)(() => this.fetchTokenList(__classPrivateFieldGet(this, _TokenListController_chainId, "f")));
+    }, __classPrivateFieldGet(this, _TokenListController_intervalDelay, "f")), "f");
 };
+// Storage key prefix for per-chain files
+_TokenListController_storageKeyPrefix = { value: 'tokensChainsCache' };
 exports.default = TokenListController;
 //# sourceMappingURL=TokenListController.cjs.map
\ No newline at end of file
diff --git a/dist/TokenListController.d.cts b/dist/TokenListController.d.cts
index 40adcaa21918cd023cb710fb83000ed5b5bac361..cd803f7cea284240120a0915d9bb1e70fae481c5 100644
--- a/dist/TokenListController.d.cts
+++ b/dist/TokenListController.d.cts
@@ -1,6 +1,7 @@
 import type { ControllerGetStateAction, ControllerStateChangeEvent } from "@metamask/base-controller";
 import type { Messenger } from "@metamask/messenger";
 import type { NetworkControllerStateChangeEvent, NetworkState, NetworkControllerGetNetworkClientByIdAction } from "@metamask/network-controller";
+import type { StorageServiceSetItemAction, StorageServiceGetItemAction, StorageServiceRemoveItemAction, StorageServiceGetAllKeysAction } from "@metamask/storage-service";
 import type { Hex } from "@metamask/utils";
 declare const name = "TokenListController";
 export type TokenListToken = {
@@ -13,7 +14,7 @@ export type TokenListToken = {
     iconUrl: string;
 };
 export type TokenListMap = Record<string, TokenListToken>;
-type DataCache = {
+export type DataCache = {
     timestamp: number;
     data: TokenListMap;
 };
@@ -28,7 +29,7 @@ export type TokenListStateChange = ControllerStateChangeEvent<typeof name, Token
 export type TokenListControllerEvents = TokenListStateChange;
 export type GetTokenListState = ControllerGetStateAction<typeof name, TokenListState>;
 export type TokenListControllerActions = GetTokenListState;
-type AllowedActions = NetworkControllerGetNetworkClientByIdAction;
+type AllowedActions = NetworkControllerGetNetworkClientByIdAction | StorageServiceSetItemAction | StorageServiceGetItemAction | StorageServiceRemoveItemAction | StorageServiceGetAllKeysAction;
 type AllowedEvents = NetworkControllerStateChangeEvent;
 export type TokenListControllerMessenger = Messenger<typeof name, TokenListControllerActions | AllowedActions, TokenListControllerEvents | AllowedEvents>;
 export declare const getDefaultTokenListState: () => TokenListState;
@@ -56,12 +57,6 @@ declare const TokenListController_base: (abstract new (...args: any[]) => {
  */
 export declare class TokenListController extends TokenListController_base<typeof name, TokenListState, TokenListControllerMessenger> {
     #private;
-    private readonly mutex;
-    private intervalId?;
-    private readonly intervalDelay;
-    private readonly cacheRefreshThreshold;
-    private chainId;
-    private abortController;
     /**
      * Creates a TokenListController instance.
      *
@@ -111,13 +106,6 @@ export declare class TokenListController extends TokenListController_base<typeof
      * Consider using the new polling approach instead
      */
     destroy(): void;
-    /**
-     * This stops any active polling intervals.
-     *
-     * @deprecated This method is deprecated and will be removed in the future.
-     * Consider using the new polling approach instead
-     */
-    private stopPolling;
     /**
      * This starts a new polling loop for any given chain. Under the hood it is deduping polls
      *
@@ -127,7 +115,8 @@ export declare class TokenListController extends TokenListController_base<typeof
      */
     _executePoll({ chainId }: TokenListPollingInput): Promise<void>;
     /**
-     * Fetching token list from the Token Service API. This will fetch tokens across chains. It will update tokensChainsCache (scoped across chains), and also the tokenList (scoped for the selected chain)
+     * Fetching token list from the Token Service API. This will fetch tokens across chains.
+     * Updates state and persists to StorageService separately.
      *
      * @param chainId - The chainId of the current chain triggering the fetch.
      */
@@ -135,8 +124,9 @@ export declare class TokenListController extends TokenListController_base<typeof
     isCacheValid(chainId: Hex): boolean;
     /**
      * Clearing tokenList and tokensChainsCache explicitly.
+     * This clears both state and all per-chain files in StorageService.
      */
-    clearingTokenListData(): void;
+    clearingTokenListData(): Promise<void>;
     /**
      * Updates preventPollingOnNetworkRestart from extension.
      *
diff --git a/dist/TokenListController.mjs b/dist/TokenListController.mjs
index d82b9e5495c666cdd49e080ca7db3ba5437efe9d..c57d5f66e24f4b8fa9dd5c67ea51ff23a6e1955f 100644
--- a/dist/TokenListController.mjs
+++ b/dist/TokenListController.mjs
@@ -3,7 +3,13 @@ var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (
     if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
     return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
 };
-var _TokenListController_instances, _TokenListController_onNetworkControllerStateChange, _TokenListController_startDeprecatedPolling;
+var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
+    if (kind === "m") throw new TypeError("Private method is not writable");
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
+    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
+};
+var _TokenListController_instances, _a, _TokenListController_mutex, _TokenListController_storageKeyPrefix, _TokenListController_getChainStorageKey, _TokenListController_intervalId, _TokenListController_intervalDelay, _TokenListController_cacheRefreshThreshold, _TokenListController_chainId, _TokenListController_abortController, _TokenListController_loadCacheFromStorage, _TokenListController_saveChainCacheToStorage, _TokenListController_migrateStateToStorage, _TokenListController_onNetworkControllerStateChange, _TokenListController_stopPolling, _TokenListController_startDeprecatedPolling;
 import { safelyExecute } from "@metamask/controller-utils";
 import { StaticIntervalPollingController } from "@metamask/polling-controller";
 import { Mutex } from "async-mutex";
@@ -15,7 +21,7 @@ const name = 'TokenListController';
 const metadata = {
     tokensChainsCache: {
         includeInStateLogs: false,
-        persist: true,
+        persist: false, // Persisted separately via StorageService
         includeInDebugSnapshot: true,
         usedInUi: true,
     },
@@ -56,13 +62,27 @@ export class TokenListController extends StaticIntervalPollingController() {
             state: { ...getDefaultTokenListState(), ...state },
         });
         _TokenListController_instances.add(this);
-        this.mutex = new Mutex();
-        this.intervalDelay = interval;
+        _TokenListController_mutex.set(this, new Mutex());
+        _TokenListController_intervalId.set(this, void 0);
+        _TokenListController_intervalDelay.set(this, void 0);
+        _TokenListController_cacheRefreshThreshold.set(this, void 0);
+        _TokenListController_chainId.set(this, void 0);
+        _TokenListController_abortController.set(this, void 0);
+        __classPrivateFieldSet(this, _TokenListController_intervalDelay, interval, "f");
         this.setIntervalLength(interval);
-        this.cacheRefreshThreshold = cacheRefreshThreshold;
-        this.chainId = chainId;
+        __classPrivateFieldSet(this, _TokenListController_cacheRefreshThreshold, cacheRefreshThreshold, "f");
+        __classPrivateFieldSet(this, _TokenListController_chainId, chainId, "f");
         this.updatePreventPollingOnNetworkRestart(preventPollingOnNetworkRestart);
-        this.abortController = new AbortController();
+        __classPrivateFieldSet(this, _TokenListController_abortController, new AbortController(), "f");
+        // Load cache from StorageService on initialization and handle migration
+        __classPrivateFieldGet(this, _TokenListController_instances, "m", _TokenListController_loadCacheFromStorage).call(this)
+            .then(() => {
+            // Migrate existing cache from state to StorageService if needed
+            return __classPrivateFieldGet(this, _TokenListController_instances, "m", _TokenListController_migrateStateToStorage).call(this);
+        })
+            .catch((error) => {
+            console.error('TokenListController: Failed to load cache from storage:', error);
+        });
         if (onNetworkStateChange) {
             // TODO: Either fix this lint violation or explain why it's necessary to ignore.
             // eslint-disable-next-line @typescript-eslint/no-misused-promises
@@ -88,7 +108,7 @@ export class TokenListController extends StaticIntervalPollingController() {
      * Consider using the new polling approach instead
      */
     async start() {
-        if (!isTokenListSupportedForNetwork(this.chainId)) {
+        if (!isTokenListSupportedForNetwork(__classPrivateFieldGet(this, _TokenListController_chainId, "f"))) {
             return;
         }
         await __classPrivateFieldGet(this, _TokenListController_instances, "m", _TokenListController_startDeprecatedPolling).call(this);
@@ -100,7 +120,7 @@ export class TokenListController extends StaticIntervalPollingController() {
      * Consider using the new polling approach instead
      */
     async restart() {
-        this.stopPolling();
+        __classPrivateFieldGet(this, _TokenListController_instances, "m", _TokenListController_stopPolling).call(this);
         await __classPrivateFieldGet(this, _TokenListController_instances, "m", _TokenListController_startDeprecatedPolling).call(this);
     }
     /**
@@ -110,7 +130,7 @@ export class TokenListController extends StaticIntervalPollingController() {
      * Consider using the new polling approach instead
      */
     stop() {
-        this.stopPolling();
+        __classPrivateFieldGet(this, _TokenListController_instances, "m", _TokenListController_stopPolling).call(this);
     }
     /**
      * This stops any active polling.
@@ -120,18 +140,7 @@ export class TokenListController extends StaticIntervalPollingController() {
      */
     destroy() {
         super.destroy();
-        this.stopPolling();
-    }
-    /**
-     * This stops any active polling intervals.
-     *
-     * @deprecated This method is deprecated and will be removed in the future.
-     * Consider using the new polling approach instead
-     */
-    stopPolling() {
-        if (this.intervalId) {
-            clearInterval(this.intervalId);
-        }
+        __classPrivateFieldGet(this, _TokenListController_instances, "m", _TokenListController_stopPolling).call(this);
     }
     /**
      * This starts a new polling loop for any given chain. Under the hood it is deduping polls
@@ -144,18 +153,19 @@ export class TokenListController extends StaticIntervalPollingController() {
         return this.fetchTokenList(chainId);
     }
     /**
-     * Fetching token list from the Token Service API. This will fetch tokens across chains. It will update tokensChainsCache (scoped across chains), and also the tokenList (scoped for the selected chain)
+     * Fetching token list from the Token Service API. This will fetch tokens across chains.
+     * Updates state and persists to StorageService separately.
      *
      * @param chainId - The chainId of the current chain triggering the fetch.
      */
     async fetchTokenList(chainId) {
-        const releaseLock = await this.mutex.acquire();
+        const releaseLock = await __classPrivateFieldGet(this, _TokenListController_mutex, "f").acquire();
         try {
             if (this.isCacheValid(chainId)) {
                 return;
             }
             // Fetch fresh token list from the API
-            const tokensFromAPI = await safelyExecute(() => fetchTokenListByChainId(chainId, this.abortController.signal));
+            const tokensFromAPI = await safelyExecute(() => fetchTokenListByChainId(chainId, __classPrivateFieldGet(this, _TokenListController_abortController, "f").signal));
             // Have response - process and update list
             if (tokensFromAPI) {
                 // Format tokens from API (HTTP) and update tokenList
@@ -170,23 +180,28 @@ export class TokenListController extends StaticIntervalPollingController() {
                         }),
                     };
                 }
+                // Update state
+                const newDataCache = {
+                    data: tokenList,
+                    timestamp: Date.now(),
+                };
                 this.update((state) => {
-                    var _a;
-                    const newDataCache = { data: {}, timestamp: Date.now() };
-                    (_a = state.tokensChainsCache)[chainId] ?? (_a[chainId] = newDataCache);
-                    state.tokensChainsCache[chainId].data = tokenList;
-                    state.tokensChainsCache[chainId].timestamp = Date.now();
+                    state.tokensChainsCache[chainId] = newDataCache;
                 });
+                // Persist only this chain to StorageService (reduces write amplification)
+                await __classPrivateFieldGet(this, _TokenListController_instances, "m", _TokenListController_saveChainCacheToStorage).call(this, chainId);
                 return;
             }
             // No response - fallback to previous state, or initialise empty
             if (!tokensFromAPI) {
+                const newDataCache = { data: {}, timestamp: Date.now() };
                 this.update((state) => {
-                    var _a;
-                    const newDataCache = { data: {}, timestamp: Date.now() };
-                    (_a = state.tokensChainsCache)[chainId] ?? (_a[chainId] = newDataCache);
+                    var _b;
+                    (_b = state.tokensChainsCache)[chainId] ?? (_b[chainId] = newDataCache);
                     state.tokensChainsCache[chainId].timestamp = Date.now();
                 });
+                // Persist only this chain to StorageService
+                await __classPrivateFieldGet(this, _TokenListController_instances, "m", _TokenListController_saveChainCacheToStorage).call(this, chainId);
             }
         }
         finally {
@@ -197,18 +212,29 @@ export class TokenListController extends StaticIntervalPollingController() {
         const { tokensChainsCache } = this.state;
         const timestamp = tokensChainsCache[chainId]?.timestamp;
         const now = Date.now();
-        return (timestamp !== undefined && now - timestamp < this.cacheRefreshThreshold);
+        return (timestamp !== undefined && now - timestamp < __classPrivateFieldGet(this, _TokenListController_cacheRefreshThreshold, "f"));
     }
     /**
      * Clearing tokenList and tokensChainsCache explicitly.
+     * This clears both state and all per-chain files in StorageService.
      */
-    clearingTokenListData() {
-        this.update(() => {
-            return {
-                ...this.state,
-                tokensChainsCache: {},
-            };
+    async clearingTokenListData() {
+        // Clear state
+        this.update((state) => {
+            state.tokensChainsCache = {};
         });
+        // Clear all per-chain files from StorageService
+        try {
+            const allKeys = await this.messenger.call('StorageService:getAllKeys', name);
+            // Filter and remove all tokensChainsCache keys
+            const cacheKeys = allKeys.filter((key) => key.startsWith(`${__classPrivateFieldGet(_a, _a, "f", _TokenListController_storageKeyPrefix)}:`));
+            await Promise.all(cacheKeys.map((key) => this.messenger.call('StorageService:removeItem', name, key)));
+            // Also remove old single-file storage if it exists (cleanup)
+            await this.messenger.call('StorageService:removeItem', name, __classPrivateFieldGet(_a, _a, "f", _TokenListController_storageKeyPrefix));
+        }
+        catch (error) {
+            console.error('TokenListController: Failed to clear cache from storage:', error);
+        }
     }
     /**
      * Updates preventPollingOnNetworkRestart from extension.
@@ -224,7 +250,105 @@ export class TokenListController extends StaticIntervalPollingController() {
         });
     }
 }
-_TokenListController_instances = new WeakSet(), _TokenListController_onNetworkControllerStateChange = 
+_a = TokenListController, _TokenListController_mutex = new WeakMap(), _TokenListController_intervalId = new WeakMap(), _TokenListController_intervalDelay = new WeakMap(), _TokenListController_cacheRefreshThreshold = new WeakMap(), _TokenListController_chainId = new WeakMap(), _TokenListController_abortController = new WeakMap(), _TokenListController_instances = new WeakSet(), _TokenListController_getChainStorageKey = function _TokenListController_getChainStorageKey(chainId) {
+    return `${__classPrivateFieldGet(_a, _a, "f", _TokenListController_storageKeyPrefix)}:${chainId}`;
+}, _TokenListController_loadCacheFromStorage = 
+/**
+ * Load tokensChainsCache from StorageService into state.
+ * Loads all cached chains from separate per-chain files in parallel.
+ * Called during initialization to restore cached data.
+ *
+ * @returns A promise that resolves when loading is complete.
+ */
+async function _TokenListController_loadCacheFromStorage() {
+    try {
+        // Get all keys for this controller
+        const allKeys = await this.messenger.call('StorageService:getAllKeys', name);
+        // Filter keys that belong to tokensChainsCache (per-chain files)
+        const cacheKeys = allKeys.filter((key) => key.startsWith(`${__classPrivateFieldGet(_a, _a, "f", _TokenListController_storageKeyPrefix)}:`));
+        if (cacheKeys.length === 0) {
+            return; // No cached data
+        }
+        // Load all chains in parallel
+        const chainCaches = await Promise.all(cacheKeys.map(async (key) => {
+            // Extract chainId from key: 'tokensChainsCache:0x1' → '0x1'
+            const chainId = key.split(':')[1];
+            const { result, error } = await this.messenger.call('StorageService:getItem', name, key);
+            if (error) {
+                console.error(`TokenListController: Error loading cache for ${chainId}:`, error);
+                return null;
+            }
+            return result ? { chainId, data: result } : null;
+        }));
+        // Build complete cache from loaded chains
+        const loadedCache = {};
+        chainCaches.forEach((chainCache) => {
+            if (chainCache) {
+                loadedCache[chainCache.chainId] = chainCache.data;
+            }
+        });
+        // Load into state (all chains available for TokenDetectionController)
+        if (Object.keys(loadedCache).length > 0) {
+            this.update((state) => {
+                state.tokensChainsCache = loadedCache;
+            });
+        }
+    }
+    catch (error) {
+        console.error('TokenListController: Failed to load cache from storage:', error);
+    }
+}, _TokenListController_saveChainCacheToStorage = 
+/**
+ * Save a specific chain's cache to StorageService.
+ * This persists only the updated chain's data, reducing write amplification.
+ *
+ * @param chainId - The chain ID to save.
+ * @returns A promise that resolves when saving is complete.
+ */
+async function _TokenListController_saveChainCacheToStorage(chainId) {
+    try {
+        const chainData = this.state.tokensChainsCache[chainId];
+        if (!chainData) {
+            console.warn(`TokenListController: No cache data for chain ${chainId}`);
+            return;
+        }
+        const storageKey = __classPrivateFieldGet(_a, _a, "m", _TokenListController_getChainStorageKey).call(_a, chainId);
+        await this.messenger.call('StorageService:setItem', name, storageKey, chainData);
+    }
+    catch (error) {
+        console.error(`TokenListController: Failed to save cache for ${chainId}:`, error);
+    }
+}, _TokenListController_migrateStateToStorage = 
+/**
+ * Migrate tokensChainsCache from old persisted state to per-chain files.
+ * Handles backward compatibility for users upgrading from the old
+ * framework-managed state (persist: true) to StorageService.
+ *
+ * @returns A promise that resolves when migration is complete.
+ */
+async function _TokenListController_migrateStateToStorage() {
+    try {
+        // Check if we have data in state that needs migration
+        if (!this.state.tokensChainsCache ||
+            Object.keys(this.state.tokensChainsCache).length === 0) {
+            return; // No data to migrate
+        }
+        // Check if per-chain files already exist (migration already done)
+        const allKeys = await this.messenger.call('StorageService:getAllKeys', name);
+        const hasPerChainFiles = allKeys.some((key) => key.startsWith(`${__classPrivateFieldGet(_a, _a, "f", _TokenListController_storageKeyPrefix)}:`));
+        if (hasPerChainFiles) {
+            return; // Already migrated
+        }
+        // Migrate from old persisted state to per-chain files
+        console.log('TokenListController: Migrating from persisted state to per-chain storage');
+        // Split into per-chain files
+        await Promise.all(Object.keys(this.state.tokensChainsCache).map((chainId) => __classPrivateFieldGet(this, _TokenListController_instances, "m", _TokenListController_saveChainCacheToStorage).call(this, chainId)));
+        console.log('TokenListController: Migration to per-chain storage complete');
+    }
+    catch (error) {
+        console.error('TokenListController: Failed to migrate cache to storage:', error);
+    }
+}, _TokenListController_onNetworkControllerStateChange = 
 /**
  * Updates state and restarts polling on changes to the network controller
  * state.
@@ -234,14 +358,20 @@ _TokenListController_instances = new WeakSet(), _TokenListController_onNetworkCo
 async function _TokenListController_onNetworkControllerStateChange(networkControllerState) {
     const selectedNetworkClient = this.messenger.call('NetworkController:getNetworkClientById', networkControllerState.selectedNetworkClientId);
     const { chainId } = selectedNetworkClient.configuration;
-    if (this.chainId !== chainId) {
-        this.abortController.abort();
-        this.abortController = new AbortController();
-        this.chainId = chainId;
+    if (__classPrivateFieldGet(this, _TokenListController_chainId, "f") !== chainId) {
+        __classPrivateFieldGet(this, _TokenListController_abortController, "f").abort();
+        __classPrivateFieldSet(this, _TokenListController_abortController, new AbortController(), "f");
+        __classPrivateFieldSet(this, _TokenListController_chainId, chainId, "f");
         if (this.state.preventPollingOnNetworkRestart) {
-            this.clearingTokenListData();
+            this.clearingTokenListData().catch((error) => {
+                console.error('Failed to clear token list data:', error);
+            });
         }
     }
+}, _TokenListController_stopPolling = function _TokenListController_stopPolling() {
+    if (__classPrivateFieldGet(this, _TokenListController_intervalId, "f")) {
+        clearInterval(__classPrivateFieldGet(this, _TokenListController_intervalId, "f"));
+    }
 }, _TokenListController_startDeprecatedPolling = 
 /**
  * Starts a new polling interval for a given chainId (this should be deprecated in favor of _executePoll)
@@ -251,12 +381,14 @@ async function _TokenListController_onNetworkControllerStateChange(networkContro
  */
 async function _TokenListController_startDeprecatedPolling() {
     // renaming this to avoid collision with base class
-    await safelyExecute(() => this.fetchTokenList(this.chainId));
+    await safelyExecute(() => this.fetchTokenList(__classPrivateFieldGet(this, _TokenListController_chainId, "f")));
     // TODO: Either fix this lint violation or explain why it's necessary to ignore.
     // eslint-disable-next-line @typescript-eslint/no-misused-promises
-    this.intervalId = setInterval(async () => {
-        await safelyExecute(() => this.fetchTokenList(this.chainId));
-    }, this.intervalDelay);
+    __classPrivateFieldSet(this, _TokenListController_intervalId, setInterval(async () => {
+        await safelyExecute(() => this.fetchTokenList(__classPrivateFieldGet(this, _TokenListController_chainId, "f")));
+    }, __classPrivateFieldGet(this, _TokenListController_intervalDelay, "f")), "f");
 };
+// Storage key prefix for per-chain files
+_TokenListController_storageKeyPrefix = { value: 'tokensChainsCache' };
 export default TokenListController;
 //# sourceMappingURL=TokenListController.mjs.map
\ No newline at end of file
diff --git a/package.json b/package.json
index 10ce42f17a74fff6e42bbbec25468a35ab62c919..314c22490e348e7a4f945036fcee33f9722ddb6f 100644
--- a/package.json
+++ b/package.json
@@ -90,7 +90,8 @@
     "multiformats": "^9.9.0",
     "reselect": "^5.1.1",
     "single-call-balance-checker-abi": "^1.0.0",
-    "uuid": "^8.3.2"
+    "uuid": "^8.3.2",
+    "@metamask/storage-service": "^0.0.1"
   },
   "devDependencies": {
     "@babel/runtime": "^7.23.9",
