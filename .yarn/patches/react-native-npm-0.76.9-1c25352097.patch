diff --git a/Libraries/Pressability/Pressability.js b/Libraries/Pressability/Pressability.js
index 1bd6853b4202e4f726e80709660f6d049a4fc741..550651260129f3fb5081601a970775ec478de105 100644
--- a/Libraries/Pressability/Pressability.js
+++ b/Libraries/Pressability/Pressability.js
@@ -806,7 +806,11 @@ export default class Pressability {
     if (typeof this._responderID === 'number') {
       UIManager.measure(this._responderID, this._measureCallback);
     } else {
-      this._responderID.measure(this._measureCallback);
+      if (Platform.OS === "android") {
+        this._responderID.measureAsyncOnUI(this._measureCallback);
+      } else {
+        this._responderID.measure(this._measureCallback);
+      }
     }
   }
  
diff --git a/Libraries/ReactNative/FabricUIManager.js b/Libraries/ReactNative/FabricUIManager.js
index a31fe41f232a4b5e79f37c2a98f51ee8208c9585..d77b10e87657987092e92fcd2ecbe9b368eb03eb 100644
--- a/Libraries/ReactNative/FabricUIManager.js
+++ b/Libraries/ReactNative/FabricUIManager.js
@@ -41,6 +41,10 @@ export interface Spec {
   +appendChildToSet: (childSet: NodeSet, child: Node) => void;
   +completeRoot: (rootTag: RootTag, childSet: NodeSet) => void;
   +measure: (node: Node, callback: MeasureOnSuccessCallback) => void;
+  +measureAsyncOnUI: (
+    node: Node | NativeElementReference,
+    callback: MeasureOnSuccessCallback,
+  ) => void;
   +measureInWindow: (
     node: Node,
     callback: MeasureInWindowOnSuccessCallback,
@@ -98,6 +102,7 @@ const CACHED_PROPERTIES = [
   'appendChildToSet',
   'completeRoot',
   'measure',
+  'measureAsyncOnUI',
   'measureInWindow',
   'measureLayout',
   'configureNextLayoutAnimation',
diff --git a/Libraries/ReactNative/ReactFabricPublicInstance/ReactFabricHostComponent.js b/Libraries/ReactNative/ReactFabricPublicInstance/ReactFabricHostComponent.js
index b7a06c89ed74a519f79c5abb680376c364b777a6..397d213f7fb9a5b547b57082d666832eff6cf684 100644
--- a/Libraries/ReactNative/ReactFabricPublicInstance/ReactFabricHostComponent.js
+++ b/Libraries/ReactNative/ReactFabricPublicInstance/ReactFabricHostComponent.js
@@ -28,6 +28,7 @@ import nullthrows from 'nullthrows';
 
 const {
   measure: fabricMeasure,
+  measureAsyncOnUI: fabricMeasureAsyncOnUI,
   measureInWindow: fabricMeasureInWindow,
   measureLayout: fabricMeasureLayout,
   getBoundingClientRect: fabricGetBoundingClientRect,
@@ -75,6 +76,15 @@ export default class ReactFabricHostComponent implements INativeMethods {
     }
   }
 
+  measureAsyncOnUI(callback: MeasureOnSuccessCallback) {
+    const node = getNodeFromInternalInstanceHandle(
+      this.__internalInstanceHandle,
+    );
+    if (node != null) {
+      fabricMeasureAsyncOnUI(node, callback);
+    }
+  }
+
   measureInWindow(callback: MeasureInWindowOnSuccessCallback) {
     const node = getNodeFromInternalInstanceHandle(
       this.__internalInstanceHandle,
diff --git a/React/Fabric/Mounting/RCTMountingManager.h b/React/Fabric/Mounting/RCTMountingManager.h
index 127b06fd474a67de8545d8e0afd0822e7e0bfef3..c3830a3bdddc2bf9aa3f6c5f910875fe3c896852 100644
--- a/React/Fabric/Mounting/RCTMountingManager.h
+++ b/React/Fabric/Mounting/RCTMountingManager.h
@@ -69,6 +69,8 @@ NS_ASSUME_NONNULL_BEGIN
 - (void)synchronouslyUpdateViewOnUIThread:(ReactTag)reactTag
                              changedProps:(NSDictionary *)props
                       componentDescriptor:(const facebook::react::ComponentDescriptor &)componentDescriptor;
+
+- (void)measure:(ReactTag)reactTag callback:(const std::function<void (folly::dynamic)> &)callback;
 @end
 
 NS_ASSUME_NONNULL_END
diff --git a/React/Fabric/Mounting/RCTMountingManager.mm b/React/Fabric/Mounting/RCTMountingManager.mm
index ec4354583ac04fa8df6de7c1896902a4c7d5c4b4..d372b05e17749b73e94bc51616b9123ca3d70bf8 100644
--- a/React/Fabric/Mounting/RCTMountingManager.mm
+++ b/React/Fabric/Mounting/RCTMountingManager.mm
@@ -6,6 +6,7 @@
  */
 
 #import "RCTMountingManager.h"
+#import "UIView+React.h"
 
 #import <QuartzCore/QuartzCore.h>
 
@@ -337,4 +338,38 @@ - (void)synchronouslyDispatchAccessbilityEventOnUIThread:(ReactTag)reactTag even
   }
 }
 
+- (void)measure:(ReactTag)reactTag callback:(const std::function<void (folly::dynamic)> &)callback {
+  std::function<void (folly::dynamic)> callbackCopy = callback;
+  RCTExecuteOnMainQueue(^{
+    UIView<RCTComponentViewProtocol> *view = [self->_componentViewRegistry findComponentViewWithTag:reactTag];
+    if (!view) {
+      // this view was probably collapsed out
+      RCTLogWarn(@"measure cannot find view with tag #%@", @(reactTag));
+      callbackCopy({});
+      return;
+    }
+    
+    // If in a <Modal>, rootView will be the root of the modal container.
+    UIView *rootView = view;
+    while (rootView.superview && ![rootView isReactRootView]) {
+      rootView = rootView.superview;
+    }
+
+    // By convention, all coordinates, whether they be touch coordinates, or
+    // measurement coordinates are with respect to the root view.
+    CGRect frame = view.frame;
+    CGRect globalBounds = [view convertRect:view.bounds toView:rootView];
+
+    callbackCopy(
+             folly::dynamic::array(frame.origin.x,
+                                   frame.origin.y,
+                                   globalBounds.size.width,
+                                   globalBounds.size.height,
+                                   globalBounds.origin.x,
+                                   globalBounds.origin.y)
+             );
+  });
+}
+
+
 @end
diff --git a/React/Fabric/RCTScheduler.h b/React/Fabric/RCTScheduler.h
index 379db1a6cbf415f356a2419b113e2edf236c25c5..fdee5dd04681e64d2920db6b05cc269032ff2fbb 100644
--- a/React/Fabric/RCTScheduler.h
+++ b/React/Fabric/RCTScheduler.h
@@ -41,6 +41,10 @@ NS_ASSUME_NONNULL_BEGIN
                 blockNativeResponder:(BOOL)blockNativeResponder
                        forShadowView:(const facebook::react::ShadowView &)shadowView;
 
+
+- (void)schedulerMeasureAsync:(const facebook::react::ShadowView &)shadowView
+            callback:(const std::function<void(folly::dynamic)> &)callback;
+
 @end
 
 /**
diff --git a/React/Fabric/RCTScheduler.mm b/React/Fabric/RCTScheduler.mm
index 29ea406343dde1a6655c8d8523ec71919a188c82..747a4ea7bf92f4ea6986908526a9236c75e59437 100644
--- a/React/Fabric/RCTScheduler.mm
+++ b/React/Fabric/RCTScheduler.mm
@@ -68,6 +68,12 @@ void schedulerDidSendAccessibilityEvent(const ShadowView &shadowView, const std:
     [scheduler.delegate schedulerDidSendAccessibilityEvent:shadowView eventType:eventType];
   }
 
+
+  void schedulerMeasureAsync(const ShadowView& shadowView, const std::function<void(folly::dynamic)> &callback) override {
+    RCTScheduler *scheduler = (__bridge RCTScheduler *)scheduler_;
+    [scheduler.delegate schedulerMeasureAsync:shadowView callback:callback];
+  }
+
  private:
   void *scheduler_;
 };
diff --git a/React/Fabric/RCTSurfacePresenter.mm b/React/Fabric/RCTSurfacePresenter.mm
index 5d6f02e91430d8bea322ca7711b21f97c00b78a1..797f6163a1e0255d57ae4320178000641d63fc1e 100644
--- a/React/Fabric/RCTSurfacePresenter.mm
+++ b/React/Fabric/RCTSurfacePresenter.mm
@@ -338,6 +338,11 @@ - (void)schedulerDidSetIsJSResponder:(BOOL)isJSResponder
   [_mountingManager setIsJSResponder:isJSResponder blockNativeResponder:blockNativeResponder forShadowView:shadowView];
 }
 
+- (void)schedulerMeasureAsync:(const facebook::react::ShadowView &)shadowView callback:(const std::function<void (folly::dynamic)> &)callback {
+  ReactTag tag = shadowView.tag;
+  [_mountingManager measure:tag callback:callback];
+}
+
 - (void)addObserver:(id<RCTSurfacePresenterObserver>)observer
 {
   std::unique_lock lock(_observerListMutex);
diff --git a/ReactAndroid/src/main/java/com/facebook/react/fabric/FabricUIManager.java b/ReactAndroid/src/main/java/com/facebook/react/fabric/FabricUIManager.java
index b3ba97cfe098f4809c366f65da4be3e3d73f56ca..82978ecdc4f88570427d4e67a46f1de1c29bdc86 100644
--- a/ReactAndroid/src/main/java/com/facebook/react/fabric/FabricUIManager.java
+++ b/ReactAndroid/src/main/java/com/facebook/react/fabric/FabricUIManager.java
@@ -32,6 +32,7 @@ import androidx.annotation.UiThread;
 import com.facebook.common.logging.FLog;
 import com.facebook.infer.annotation.ThreadConfined;
 import com.facebook.proguard.annotations.DoNotStripAny;
+import com.facebook.react.bridge.Callback;
 import com.facebook.react.bridge.ColorPropConverter;
 import com.facebook.react.bridge.GuardedRunnable;
 import com.facebook.react.bridge.LifecycleEventListener;
@@ -1190,6 +1191,27 @@ public class FabricUIManager
         });
   }
 
+  public void measureAsync(int surfaceId, int reactTag, final Callback callback) {
+    mMountItemDispatcher.addMountItem(
+      new MountItem() {
+        @Override
+        public void execute(@NonNull MountingManager mountingManager) {
+          mMountingManager.measure(surfaceId, reactTag, callback);
+        }
+
+        @Override
+        public int getSurfaceId() {
+          return surfaceId;
+        }
+
+        @NonNull
+        @Override
+        public String toString() {
+          return "MEASURE_VIEW";
+        }
+      });
+  }
+
   @Override
   public void profileNextBatch() {
     // TODO T31905686: Remove this method and add support for multi-threading performance counters
diff --git a/ReactAndroid/src/main/java/com/facebook/react/fabric/mounting/MountingManager.java b/ReactAndroid/src/main/java/com/facebook/react/fabric/mounting/MountingManager.java
index 6f0cca01c97d9607f80ef2113147fe5ffa98b402..84e08164026fc7cc00db3de332104d2cf064a8ef 100644
--- a/ReactAndroid/src/main/java/com/facebook/react/fabric/mounting/MountingManager.java
+++ b/ReactAndroid/src/main/java/com/facebook/react/fabric/mounting/MountingManager.java
@@ -10,13 +10,18 @@ package com.facebook.react.fabric.mounting;
 import static com.facebook.infer.annotation.ThreadConfined.ANY;
 import static com.facebook.infer.annotation.ThreadConfined.UI;
 
+import android.graphics.Matrix;
+import android.graphics.RectF;
 import android.view.View;
+import android.view.ViewParent;
+
 import androidx.annotation.AnyThread;
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import androidx.annotation.UiThread;
 import com.facebook.common.logging.FLog;
 import com.facebook.infer.annotation.ThreadConfined;
+import com.facebook.react.bridge.Callback;
 import com.facebook.react.bridge.ReactContext;
 import com.facebook.react.bridge.ReactSoftExceptionLogger;
 import com.facebook.react.bridge.ReadableArray;
@@ -29,7 +34,10 @@ import com.facebook.react.fabric.FabricUIManager;
 import com.facebook.react.fabric.events.EventEmitterWrapper;
 import com.facebook.react.fabric.mounting.mountitems.MountItem;
 import com.facebook.react.touch.JSResponderHandler;
+import com.facebook.react.uimanager.IllegalViewOperationException;
+import com.facebook.react.uimanager.PixelUtil;
 import com.facebook.react.uimanager.RootViewManager;
+import com.facebook.react.uimanager.RootViewUtil;
 import com.facebook.react.uimanager.ThemedReactContext;
 import com.facebook.react.uimanager.ViewManagerRegistry;
 import com.facebook.react.uimanager.common.ViewUtil;
@@ -448,4 +456,76 @@ public class MountingManager {
         ? getSurfaceManagerForView(reactTag)
         : getSurfaceManager(surfaceId));
   }
+
+  public synchronized void measure(int surfaceId, int reactTag, final Callback callback) {
+    UiThreadUtil.assertOnUiThread();
+    SurfaceMountingManager smm = getSurfaceMountingManager(surfaceId, reactTag);
+    View view;
+    try {
+      view = smm.getView(reactTag);
+    } catch (IllegalViewOperationException ex) {
+      FLog.e(TAG, "Failed to find view for tag: %d. Error: %s", reactTag, ex.getMessage());
+      return;
+    }
+    int[] mMeasureBuffer = new int[4];
+    View rootView = (View) RootViewUtil.getRootView(view);
+    if (rootView == null) {
+      FLog.e(TAG, "Failed to get root view for surfaceId: %d", surfaceId);
+      return; // Simply omit the measure call, we assume that we are in the process of tearing down
+      // the surface and all its children, so we don't care at this point about delivering
+    }
+
+    measure(rootView, view, mMeasureBuffer);
+
+    float x = PixelUtil.toDIPFromPixel(mMeasureBuffer[0]);
+    float y = PixelUtil.toDIPFromPixel(mMeasureBuffer[1]);
+    float width = PixelUtil.toDIPFromPixel(mMeasureBuffer[2]);
+    float height = PixelUtil.toDIPFromPixel(mMeasureBuffer[3]);
+    callback.invoke(0, 0, width, height, x, y);
+  }
+
+  public synchronized void measure(View rootView, View v, int[] outputBuffer) {
+    computeBoundingBox(rootView, outputBuffer);
+    int rootX = outputBuffer[0];
+    int rootY = outputBuffer[1];
+    computeBoundingBox(v, outputBuffer);
+    outputBuffer[0] -= rootX;
+    outputBuffer[1] -= rootY;
+  }
+
+  private void computeBoundingBox(View view, int[] outputBuffer) {
+    RectF mBoundingBox = new RectF();
+    mBoundingBox.set(0, 0, view.getWidth(), view.getHeight());
+    mapRectFromViewToWindowCoords(view, mBoundingBox);
+
+    outputBuffer[0] = Math.round(mBoundingBox.left);
+    outputBuffer[1] = Math.round(mBoundingBox.top);
+    outputBuffer[2] = Math.round(mBoundingBox.right - mBoundingBox.left);
+    outputBuffer[3] = Math.round(mBoundingBox.bottom - mBoundingBox.top);
+  }
+
+  private void mapRectFromViewToWindowCoords(View view, RectF rect) {
+    Matrix matrix = view.getMatrix();
+    if (!matrix.isIdentity()) {
+      matrix.mapRect(rect);
+    }
+
+    rect.offset(view.getLeft(), view.getTop());
+
+    ViewParent parent = view.getParent();
+    while (parent instanceof View) {
+      View parentView = (View) parent;
+
+      rect.offset(-parentView.getScrollX(), -parentView.getScrollY());
+
+      matrix = parentView.getMatrix();
+      if (!matrix.isIdentity()) {
+        matrix.mapRect(rect);
+      }
+
+      rect.offset(parentView.getLeft(), parentView.getTop());
+
+      parent = parentView.getParent();
+    }
+  }
 }
diff --git a/ReactAndroid/src/main/jni/react/fabric/Binding.cpp b/ReactAndroid/src/main/jni/react/fabric/Binding.cpp
index 2b9d616fcfef0294533f55561352b9670d50e5fd..b99fcc205bfca6746f1f6aa441f0eea20d41465d 100644
--- a/ReactAndroid/src/main/jni/react/fabric/Binding.cpp
+++ b/ReactAndroid/src/main/jni/react/fabric/Binding.cpp
@@ -574,6 +574,14 @@ void Binding::onAnimationStarted() {
   mountingManager->onAnimationStarted();
 }
 
+void Binding::schedulerMeasureAsync(
+  const ShadowView& shadowView,
+  const std::function<void(folly::dynamic)>& callback) {
+  if (mountingManager_) {
+    mountingManager_->measureAsync(shadowView, callback);
+  }
+}
+
 void Binding::onAllAnimationsComplete() {
   auto mountingManager = getMountingManager("onAnimationComplete");
   if (!mountingManager) {
diff --git a/ReactAndroid/src/main/jni/react/fabric/Binding.h b/ReactAndroid/src/main/jni/react/fabric/Binding.h
index 17c09e46d9b76678cc38669de7a11c405e6c3d6e..6ec23182c9c6ac0a82936690a73055898570b169 100644
--- a/ReactAndroid/src/main/jni/react/fabric/Binding.h
+++ b/ReactAndroid/src/main/jni/react/fabric/Binding.h
@@ -122,6 +122,10 @@ class Binding : public jni::HybridClass<Binding, JBinding>,
       bool isJSResponder,
       bool blockNativeResponder) override;
 
+  void schedulerMeasureAsync(
+    const ShadowView& shadowView,
+    const std::function<void(folly::dynamic)>& callback) override;  
+
   void setPixelDensity(float pointScaleFactor);
 
   void driveCxxAnimations();
diff --git a/ReactAndroid/src/main/jni/react/fabric/FabricMountingManager.cpp b/ReactAndroid/src/main/jni/react/fabric/FabricMountingManager.cpp
index 1515bd60909b99daf86eebcfe145587db5711020..b6c62e2088ebf6b18a5addcfa0893470500ac5da 100644
--- a/ReactAndroid/src/main/jni/react/fabric/FabricMountingManager.cpp
+++ b/ReactAndroid/src/main/jni/react/fabric/FabricMountingManager.cpp
@@ -14,6 +14,7 @@
 #include <cxxreact/SystraceSection.h>
 #include <react/featureflags/ReactNativeFeatureFlags.h>
 #include <react/jni/ReadableNativeMap.h>
+#include <react/jni/JCallback.h>
 #include <react/renderer/components/scrollview/ScrollViewProps.h>
 #include <react/renderer/core/conversions.h>
 #include <react/renderer/mounting/MountingTransaction.h>
@@ -949,4 +950,16 @@ void FabricMountingManager::onAllAnimationsComplete() {
   allAnimationsCompleteJNI(javaUIManager_);
 }
 
+void FabricMountingManager::measureAsync(
+  const ShadowView& shadowView,
+  const std::function<void(folly::dynamic)>& callback) {
+static auto measureJNI =
+    JFabricUIManager::javaClassStatic()->getMethod<void(jint, jint, jni::alias_ref<JCallback>)>(
+        "measureAsync");
+
+auto javaCallback = JCxxCallbackImpl::newObjectCxxArgs(callback);
+
+measureJNI(javaUIManager_, shadowView.surfaceId, shadowView.tag, javaCallback);
+}
+
 } // namespace facebook::react
diff --git a/ReactAndroid/src/main/jni/react/fabric/FabricMountingManager.h b/ReactAndroid/src/main/jni/react/fabric/FabricMountingManager.h
index 0cc42f23f7b1ec83e9f7192b9dfbe9367b0bdc3f..c414127810929b95687357ebaa56be57eb8707f4 100644
--- a/ReactAndroid/src/main/jni/react/fabric/FabricMountingManager.h
+++ b/ReactAndroid/src/main/jni/react/fabric/FabricMountingManager.h
@@ -60,6 +60,10 @@ class FabricMountingManager final {
 
   void onAllAnimationsComplete();
 
+  void measureAsync(
+    const ShadowView& shadowView,
+    const std::function<void(folly::dynamic)>& callback);
+
  private:
   bool isOnMainThread();
 
diff --git a/ReactCommon/react/nativemodule/dom/NativeDOM.cpp b/ReactCommon/react/nativemodule/dom/NativeDOM.cpp
index 490a692808f58e4839bf0b5e0ce4dc0e2f99bda6..3ece33249c3760860c9f384b5569b25652ab7a97 100644
--- a/ReactCommon/react/nativemodule/dom/NativeDOM.cpp
+++ b/ReactCommon/react/nativemodule/dom/NativeDOM.cpp
@@ -11,6 +11,8 @@
 #include <react/renderer/uimanager/PointerEventsProcessor.h>
 #include <react/renderer/uimanager/UIManagerBinding.h>
 
+#include <utility>
+
 #ifdef RN_DISABLE_OSS_PLUGIN_HEADER
 #include "Plugins.h"
 #endif
diff --git a/ReactCommon/react/renderer/scheduler/Scheduler.cpp b/ReactCommon/react/renderer/scheduler/Scheduler.cpp
index 188b23d8666906f9b152d265ab705da233a73450..3a0f17909e98b96832c351bf884dd4ed19aa10d3 100644
--- a/ReactCommon/react/renderer/scheduler/Scheduler.cpp
+++ b/ReactCommon/react/renderer/scheduler/Scheduler.cpp
@@ -360,6 +360,15 @@ void Scheduler::uiManagerDidSetIsJSResponder(
   }
 }
 
+void Scheduler::uiManagerMeasureAsync(
+  const ShadowNode::Shared& shadowNode,
+  const std::function<void(folly::dynamic)>& callback) {
+  if (delegate_ != nullptr) {
+    auto shadowView = ShadowView(*shadowNode);
+    delegate_->schedulerMeasureAsync(shadowView, callback);
+  }
+}
+
 void Scheduler::reportMount(SurfaceId surfaceId) const {
   uiManager_->reportMount(surfaceId);
 }
diff --git a/ReactCommon/react/renderer/scheduler/Scheduler.h b/ReactCommon/react/renderer/scheduler/Scheduler.h
index 3977cbc2467957c5d07d5b5e2888cb661fa60840..2c5aedfe692789d60fafaa4d18708e1fde40ac4c 100644
--- a/ReactCommon/react/renderer/scheduler/Scheduler.h
+++ b/ReactCommon/react/renderer/scheduler/Scheduler.h
@@ -99,6 +99,9 @@ class Scheduler final : public UIManagerDelegate {
       const ShadowNode::Shared& shadowNode,
       bool isJSResponder,
       bool blockNativeResponder) override;
+  void uiManagerMeasureAsync(
+      const ShadowNode::Shared& shadowNode,
+      const std::function<void(folly::dynamic)>& callback) override;
 
 #pragma mark - ContextContainer
   ContextContainer::Shared getContextContainer() const;
diff --git a/ReactCommon/react/renderer/scheduler/SchedulerDelegate.h b/ReactCommon/react/renderer/scheduler/SchedulerDelegate.h
index e29ed8f465a54b937cd7a46bfca6284abe4c17e9..d34644d04693005b60b8b25964e43b00f52b8b9c 100644
--- a/ReactCommon/react/renderer/scheduler/SchedulerDelegate.h
+++ b/ReactCommon/react/renderer/scheduler/SchedulerDelegate.h
@@ -62,6 +62,10 @@ class SchedulerDelegate {
       bool isJSResponder,
       bool blockNativeResponder) = 0;
 
+  virtual void schedulerMeasureAsync(
+    const ShadowView& shadowView,
+    const std::function<void(folly::dynamic)>& callback) = 0;  
+
   virtual ~SchedulerDelegate() noexcept = default;
 };
 
diff --git a/ReactCommon/react/renderer/uimanager/UIManagerBinding.cpp b/ReactCommon/react/renderer/uimanager/UIManagerBinding.cpp
index de07a2847b647bacb8130df901aa76818c831154..03eb507bbf62d87f10cf7baa10fd59a5b23987de 100644
--- a/ReactCommon/react/renderer/uimanager/UIManagerBinding.cpp
+++ b/ReactCommon/react/renderer/uimanager/UIManagerBinding.cpp
@@ -673,6 +673,46 @@ jsi::Value UIManagerBinding::get(
         });
   }
 
+  if (methodName == "measureAsyncOnUI") {
+    auto paramCount = 2;
+    return jsi::Function::createFromHostFunction(
+        runtime,
+        name,
+        paramCount,
+        [uiManager, methodName, paramCount](
+            jsi::Runtime& runtime,
+            const jsi::Value& /*thisValue*/,
+            const jsi::Value* arguments,
+            size_t count) {
+          validateArgumentCount(runtime, methodName, paramCount, count);
+
+          auto shadowNode = shadowNodeFromValue(runtime, arguments[0]);
+          auto callbackFunction =
+              arguments[1].getObject(runtime).getFunction(runtime);
+
+          auto sharedCallback = std::make_shared<jsi::Function>(std::move(callbackFunction));
+          auto runtimeExecutor = uiManager->runtimeExecutor_;
+          std::function<void(folly::dynamic)> jsCallback = [sharedCallback, runtimeExecutor](folly::dynamic args) {
+            // Schedule call on JS
+            runtimeExecutor([sharedCallback, args](jsi::Runtime& jsRuntime) {
+              // Invoke the actual callback we got from JS
+              sharedCallback->call(jsRuntime, {
+                                                  jsi::Value{jsRuntime, args.at(0).getDouble()},
+                                                  jsi::Value{jsRuntime, args.at(1).getDouble()},
+                                                  jsi::Value{jsRuntime, args.at(2).getDouble()},
+                                                  jsi::Value{jsRuntime, args.at(3).getDouble()},
+                                                  jsi::Value{jsRuntime, args.at(4).getDouble()},
+                                                  jsi::Value{jsRuntime, args.at(5).getDouble()},
+                                              });
+            });
+          };
+
+          uiManager->getDelegate()->uiManagerMeasureAsync(shadowNode, std::move(jsCallback));
+
+          return jsi::Value::undefined();
+        });
+  }
+
   if (methodName == "measureInWindow") {
     auto paramCount = 2;
     return jsi::Function::createFromHostFunction(
diff --git a/ReactCommon/react/renderer/uimanager/UIManagerDelegate.h b/ReactCommon/react/renderer/uimanager/UIManagerDelegate.h
index 4b196f4101c4cb2e24cfd08f86e54a610548d285..bec908c866667bba10b50691099e64c585b7a4a7 100644
--- a/ReactCommon/react/renderer/uimanager/UIManagerDelegate.h
+++ b/ReactCommon/react/renderer/uimanager/UIManagerDelegate.h
@@ -58,6 +58,10 @@ class UIManagerDelegate {
       bool isJSResponder,
       bool blockNativeResponder) = 0;
 
+  virtual void uiManagerMeasureAsync(
+    const ShadowNode::Shared& shadowNode,
+    const std::function<void(folly::dynamic)>& callback) = 0;
+
   virtual ~UIManagerDelegate() noexcept = default;
 };
 
diff --git a/jest/setup.js b/jest/setup.js
index a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0..b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1 100644
--- a/jest/setup.js
+++ b/jest/setup.js
@@ -99,6 +99,7 @@ jest
     measure: jest.fn(),
     manageChildren: jest.fn(),
     setChildren: jest.fn(),
+    measureAsyncOnUI: jest.fn(),
     updateView: jest.fn(),
     AndroidDrawerLayout: {
       Constants: {
diff --git a/src/private/webapis/dom/nodes/ReactNativeElement.js b/src/private/webapis/dom/nodes/ReactNativeElement.js
index f091f3555b7be5f74178eca2ee7f4ded2f9b55e2..3e2b437b8c5dac042391b064b471587c1dc8ab11 100644
--- a/src/private/webapis/dom/nodes/ReactNativeElement.js
+++ b/src/private/webapis/dom/nodes/ReactNativeElement.js
@@ -135,6 +135,10 @@ export default class ReactNativeElement
     }
   }
 
+  measureAsyncOnUI(callback: MeasureOnSuccessCallback) {
+    this.measure(callback);
+  }
+
   measureInWindow(callback: MeasureInWindowOnSuccessCallback) {
     const node = getShadowNode(this);
     if (node != null) {
