diff --git a/dist/RampsController.cjs b/dist/RampsController.cjs
index 279d92e7749e5e6fd979e3f38df03d9081162b2f..bb91d1b66dde612518bf3743cc35544c39335f11 100644
--- a/dist/RampsController.cjs
+++ b/dist/RampsController.cjs
@@ -452,7 +452,8 @@ class RampsController extends base_controller_1.BaseController {
      *
      * @param region - The region code (e.g., "us", "fr", "us-ny"). If not provided, uses the user's region from controller state.
      * @param action - The ramp action type ('buy' or 'sell').
-     * @param options - Options for cache behavior.
+     * @param options - Options for cache behavior and query filters.
+     * @param options.provider - Provider ID(s) to filter by.
      * @returns The tokens response containing topTokens and allTokens.
      */
     async getTokens(region, action = 'buy', options) {
@@ -461,9 +462,15 @@ class RampsController extends base_controller_1.BaseController {
             throw new Error('Region is required. Either provide a region parameter or ensure userRegion is set in controller state.');
         }
         const normalizedRegion = regionToUse.toLowerCase().trim();
-        const cacheKey = (0, RequestCache_1.createCacheKey)('getTokens', [normalizedRegion, action]);
+        const cacheKey = (0, RequestCache_1.createCacheKey)('getTokens', [
+            normalizedRegion,
+            action,
+            options?.provider,
+        ]);
         const tokens = await this.executeRequest(cacheKey, async () => {
-            return this.messenger.call('RampsService:getTokens', normalizedRegion, action);
+            return this.messenger.call('RampsService:getTokens', normalizedRegion, action, {
+                provider: options?.provider,
+            });
         }, options);
         this.update((state) => {
             const userRegionCode = state.userRegion?.regionCode;
@@ -514,6 +521,66 @@ class RampsController extends base_controller_1.BaseController {
         });
         return { providers };
     }
+    // ============================================================
+    // Sync Trigger Methods
+    // These fire-and-forget methods are for use in React effects.
+    // Errors are stored in state and available via selectors.
+    // ============================================================
+    /**
+     * Triggers a user region update without throwing.
+     *
+     * @param options - Options for cache behavior.
+     */
+    triggerUpdateUserRegion(options) {
+        this.updateUserRegion(options).catch(() => {
+            // Error stored in state
+        });
+    }
+    /**
+     * Triggers setting the user region without throwing.
+     *
+     * @param region - The region code to set (e.g., "US-CA").
+     * @param options - Options for cache behavior.
+     */
+    triggerSetUserRegion(region, options) {
+        this.setUserRegion(region, options).catch(() => {
+            // Error stored in state
+        });
+    }
+    /**
+     * Triggers fetching countries without throwing.
+     *
+     * @param action - The ramp action type ('buy' or 'sell').
+     * @param options - Options for cache behavior.
+     */
+    triggerGetCountries(action = 'buy', options) {
+        this.getCountries(action, options).catch(() => {
+            // Error stored in state
+        });
+    }
+    /**
+     * Triggers fetching tokens without throwing.
+     *
+     * @param region - The region code. If not provided, uses userRegion from state.
+     * @param action - The ramp action type ('buy' or 'sell').
+     * @param options - Options for cache behavior.
+     */
+    triggerGetTokens(region, action = 'buy', options) {
+        this.getTokens(region, action, options).catch(() => {
+            // Error stored in state
+        });
+    }
+    /**
+     * Triggers fetching providers without throwing.
+     *
+     * @param region - The region code. If not provided, uses userRegion from state.
+     * @param options - Options for cache behavior and query filters.
+     */
+    triggerGetProviders(region, options) {
+        this.getProviders(region, options).catch(() => {
+            // Error stored in state
+        });
+    }
 }
 exports.RampsController = RampsController;
 _RampsController_requestCacheTTL = new WeakMap(), _RampsController_requestCacheMaxSize = new WeakMap(), _RampsController_pendingRequests = new WeakMap(), _RampsController_instances = new WeakSet(), _RampsController_removeRequestState = function _RampsController_removeRequestState(cacheKey) {
diff --git a/dist/RampsController.cjs.map b/dist/RampsController.cjs.map
index 6bcbadf95f5dd5eae822f4edaa623d3085b2301a..8ec2437e69ec267ce05c077fdd0d3a61e4447845 100644
--- a/dist/RampsController.cjs.map
+++ b/dist/RampsController.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"RampsController.cjs","sourceRoot":"","sources":["../src/RampsController.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n  StateMetadata,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport type { Messenger } from '@metamask/messenger';\nimport type { Json } from '@metamask/utils';\n\nimport type { Country, TokensResponse, Provider, State } from './RampsService';\nimport type {\n  RampsServiceGetGeolocationAction,\n  RampsServiceGetCountriesAction,\n  RampsServiceGetTokensAction,\n  RampsServiceGetProvidersAction,\n} from './RampsService-method-action-types';\nimport type {\n  RequestCache as RequestCacheType,\n  RequestState,\n  ExecuteRequestOptions,\n  PendingRequest,\n} from './RequestCache';\nimport {\n  DEFAULT_REQUEST_CACHE_TTL,\n  DEFAULT_REQUEST_CACHE_MAX_SIZE,\n  createCacheKey,\n  isCacheExpired,\n  createLoadingState,\n  createSuccessState,\n  createErrorState,\n} from './RequestCache';\n\n// === GENERAL ===\n\n/**\n * The name of the {@link RampsController}, used to namespace the\n * controller's actions and events and to namespace the controller's state data\n * when composed with other controllers.\n */\nexport const controllerName = 'RampsController';\n\n// === STATE ===\n\n/**\n * Represents the user's selected region with full country and state objects.\n */\nexport type UserRegion = {\n  /**\n   * The country object for the selected region.\n   */\n  country: Country;\n  /**\n   * The state object if a state was selected, null if only country was selected.\n   */\n  state: State | null;\n  /**\n   * The region code string (e.g., \"us-ut\" or \"fr\") used for API calls.\n   */\n  regionCode: string;\n};\n\n/**\n * Describes the shape of the state object for {@link RampsController}.\n */\nexport type RampsControllerState = {\n  /**\n   * The user's selected region with full country and state objects.\n   * Initially set via geolocation fetch, but can be manually changed by the user.\n   * Once set (either via geolocation or manual selection), it will not be overwritten\n   * by subsequent geolocation fetches.\n   */\n  userRegion: UserRegion | null;\n  /**\n   * The user's preferred provider.\n   * Can be manually set by the user.\n   */\n  preferredProvider: Provider | null;\n  /**\n   * List of providers available for the current region.\n   */\n  providers: Provider[];\n  /**\n   * Tokens fetched for the current region and action.\n   * Contains topTokens and allTokens arrays.\n   */\n  tokens: TokensResponse | null;\n  /**\n   * Cache of request states, keyed by cache key.\n   * This stores loading, success, and error states for API requests.\n   */\n  requests: RequestCacheType;\n};\n\n/**\n * The metadata for each property in {@link RampsControllerState}.\n */\nconst rampsControllerMetadata = {\n  userRegion: {\n    persist: true,\n    includeInDebugSnapshot: true,\n    includeInStateLogs: true,\n    usedInUi: true,\n  },\n  preferredProvider: {\n    persist: true,\n    includeInDebugSnapshot: true,\n    includeInStateLogs: true,\n    usedInUi: true,\n  },\n  providers: {\n    persist: true,\n    includeInDebugSnapshot: true,\n    includeInStateLogs: true,\n    usedInUi: true,\n  },\n  tokens: {\n    persist: true,\n    includeInDebugSnapshot: true,\n    includeInStateLogs: true,\n    usedInUi: true,\n  },\n  requests: {\n    persist: false,\n    includeInDebugSnapshot: true,\n    includeInStateLogs: false,\n    usedInUi: true,\n  },\n} satisfies StateMetadata<RampsControllerState>;\n\n/**\n * Constructs the default {@link RampsController} state. This allows\n * consumers to provide a partial state object when initializing the controller\n * and also helps in constructing complete state objects for this controller in\n * tests.\n *\n * @returns The default {@link RampsController} state.\n */\nexport function getDefaultRampsControllerState(): RampsControllerState {\n  return {\n    userRegion: null,\n    preferredProvider: null,\n    providers: [],\n    tokens: null,\n    requests: {},\n  };\n}\n\n// === MESSENGER ===\n\n/**\n * Retrieves the state of the {@link RampsController}.\n */\nexport type RampsControllerGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  RampsControllerState\n>;\n\n/**\n * Actions that {@link RampsControllerMessenger} exposes to other consumers.\n */\nexport type RampsControllerActions = RampsControllerGetStateAction;\n\n/**\n * Actions from other messengers that {@link RampsController} calls.\n */\ntype AllowedActions =\n  | RampsServiceGetGeolocationAction\n  | RampsServiceGetCountriesAction\n  | RampsServiceGetTokensAction\n  | RampsServiceGetProvidersAction;\n\n/**\n * Published when the state of {@link RampsController} changes.\n */\nexport type RampsControllerStateChangeEvent = ControllerStateChangeEvent<\n  typeof controllerName,\n  RampsControllerState\n>;\n\n/**\n * Events that {@link RampsControllerMessenger} exposes to other consumers.\n */\nexport type RampsControllerEvents = RampsControllerStateChangeEvent;\n\n/**\n * Events from other messengers that {@link RampsController} subscribes to.\n */\ntype AllowedEvents = never;\n\n/**\n * The messenger restricted to actions and events accessed by\n * {@link RampsController}.\n */\nexport type RampsControllerMessenger = Messenger<\n  typeof controllerName,\n  RampsControllerActions | AllowedActions,\n  RampsControllerEvents | AllowedEvents\n>;\n\n/**\n * Configuration options for the RampsController.\n */\nexport type RampsControllerOptions = {\n  /** The messenger suited for this controller. */\n  messenger: RampsControllerMessenger;\n  /** The desired state with which to initialize this controller. */\n  state?: Partial<RampsControllerState>;\n  /** Time to live for cached requests in milliseconds. Defaults to 15 minutes. */\n  requestCacheTTL?: number;\n  /** Maximum number of entries in the request cache. Defaults to 250. */\n  requestCacheMaxSize?: number;\n};\n\n// === HELPER FUNCTIONS ===\n\n/**\n * Finds a country and state from a region code string.\n *\n * @param regionCode - The region code (e.g., \"us-ca\" or \"us\").\n * @param countries - Array of countries to search.\n * @returns UserRegion object with country and state, or null if not found.\n */\nfunction findRegionFromCode(\n  regionCode: string,\n  countries: Country[],\n): UserRegion | null {\n  const normalizedCode = regionCode.toLowerCase().trim();\n  const parts = normalizedCode.split('-');\n  const countryCode = parts[0];\n  const stateCode = parts[1];\n\n  const country = countries.find((countryItem) => {\n    if (countryItem.isoCode?.toLowerCase() === countryCode) {\n      return true;\n    }\n    if (countryItem.id) {\n      const id = countryItem.id.toLowerCase();\n      if (id.startsWith('/regions/')) {\n        const extractedCode = id.replace('/regions/', '').split('/')[0];\n        return extractedCode === countryCode;\n      }\n      return id === countryCode || id.endsWith(`/${countryCode}`);\n    }\n    return false;\n  });\n\n  if (!country) {\n    return null;\n  }\n\n  let state: State | null = null;\n  if (stateCode && country.states) {\n    state =\n      country.states.find((stateItem) => {\n        if (stateItem.stateId?.toLowerCase() === stateCode) {\n          return true;\n        }\n        if (stateItem.id) {\n          const stateId = stateItem.id.toLowerCase();\n          if (\n            stateId.includes(`-${stateCode}`) ||\n            stateId.endsWith(`/${stateCode}`)\n          ) {\n            return true;\n          }\n        }\n        return false;\n      }) ?? null;\n  }\n\n  return {\n    country,\n    state,\n    regionCode: normalizedCode,\n  };\n}\n\n// === CONTROLLER DEFINITION ===\n\n/**\n * Manages cryptocurrency on/off ramps functionality.\n */\nexport class RampsController extends BaseController<\n  typeof controllerName,\n  RampsControllerState,\n  RampsControllerMessenger\n> {\n  /**\n   * Default TTL for cached requests.\n   */\n  readonly #requestCacheTTL: number;\n\n  /**\n   * Maximum number of entries in the request cache.\n   */\n  readonly #requestCacheMaxSize: number;\n\n  /**\n   * Map of pending requests for deduplication.\n   * Key is the cache key, value is the pending request with abort controller.\n   */\n  readonly #pendingRequests: Map<string, PendingRequest> = new Map();\n\n  /**\n   * Constructs a new {@link RampsController}.\n   *\n   * @param args - The constructor arguments.\n   * @param args.messenger - The messenger suited for this controller.\n   * @param args.state - The desired state with which to initialize this\n   * controller. Missing properties will be filled in with defaults.\n   * @param args.requestCacheTTL - Time to live for cached requests in milliseconds.\n   * @param args.requestCacheMaxSize - Maximum number of entries in the request cache.\n   */\n  constructor({\n    messenger,\n    state = {},\n    requestCacheTTL = DEFAULT_REQUEST_CACHE_TTL,\n    requestCacheMaxSize = DEFAULT_REQUEST_CACHE_MAX_SIZE,\n  }: RampsControllerOptions) {\n    super({\n      messenger,\n      metadata: rampsControllerMetadata,\n      name: controllerName,\n      state: {\n        ...getDefaultRampsControllerState(),\n        ...state,\n        // Always reset requests cache on initialization (non-persisted)\n        requests: {},\n      },\n    });\n\n    this.#requestCacheTTL = requestCacheTTL;\n    this.#requestCacheMaxSize = requestCacheMaxSize;\n  }\n\n  /**\n   * Executes a request with caching and deduplication.\n   *\n   * If a request with the same cache key is already in flight, returns the\n   * existing promise. If valid cached data exists, returns it without making\n   * a new request.\n   *\n   * @param cacheKey - Unique identifier for this request.\n   * @param fetcher - Function that performs the actual fetch. Receives an AbortSignal.\n   * @param options - Options for cache behavior.\n   * @returns The result of the request.\n   */\n  async executeRequest<TResult>(\n    cacheKey: string,\n    fetcher: (signal: AbortSignal) => Promise<TResult>,\n    options?: ExecuteRequestOptions,\n  ): Promise<TResult> {\n    const ttl = options?.ttl ?? this.#requestCacheTTL;\n\n    // Check for existing pending request - join it instead of making a duplicate\n    const pending = this.#pendingRequests.get(cacheKey);\n    if (pending) {\n      return pending.promise as Promise<TResult>;\n    }\n\n    // Check cache validity (unless force refresh)\n    if (!options?.forceRefresh) {\n      const cached = this.state.requests[cacheKey];\n      if (cached && !isCacheExpired(cached, ttl)) {\n        return cached.data as TResult;\n      }\n    }\n\n    // Create abort controller for this request\n    const abortController = new AbortController();\n    const lastFetchedAt = Date.now();\n\n    // Update state to loading\n    this.#updateRequestState(cacheKey, createLoadingState());\n\n    // Create the fetch promise\n    const promise = (async (): Promise<TResult> => {\n      try {\n        const data = await fetcher(abortController.signal);\n\n        // Don't update state if aborted\n        if (abortController.signal.aborted) {\n          throw new Error('Request was aborted');\n        }\n\n        this.#updateRequestState(\n          cacheKey,\n          createSuccessState(data as Json, lastFetchedAt),\n        );\n        return data;\n      } catch (error) {\n        // Don't update state if aborted\n        if (abortController.signal.aborted) {\n          throw error;\n        }\n\n        const errorMessage = (error as Error)?.message;\n\n        this.#updateRequestState(\n          cacheKey,\n          createErrorState(errorMessage ?? 'Unknown error', lastFetchedAt),\n        );\n        throw error;\n      } finally {\n        // Only delete if this is still our entry (not replaced by a new request)\n        const currentPending = this.#pendingRequests.get(cacheKey);\n        if (currentPending?.abortController === abortController) {\n          this.#pendingRequests.delete(cacheKey);\n        }\n      }\n    })();\n\n    // Store pending request for deduplication\n    this.#pendingRequests.set(cacheKey, { promise, abortController });\n\n    return promise;\n  }\n\n  /**\n   * Aborts a pending request if one exists.\n   *\n   * @param cacheKey - The cache key of the request to abort.\n   * @returns True if a request was aborted.\n   */\n  abortRequest(cacheKey: string): boolean {\n    const pending = this.#pendingRequests.get(cacheKey);\n    if (pending) {\n      pending.abortController.abort();\n      this.#pendingRequests.delete(cacheKey);\n      this.#removeRequestState(cacheKey);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Removes a request state from the cache.\n   *\n   * @param cacheKey - The cache key to remove.\n   */\n  #removeRequestState(cacheKey: string): void {\n    this.update((state) => {\n      const requests = state.requests as unknown as Record<\n        string,\n        RequestState | undefined\n      >;\n      delete requests[cacheKey];\n    });\n  }\n\n  /**\n   * Gets the state of a specific cached request.\n   *\n   * @param cacheKey - The cache key to look up.\n   * @returns The request state, or undefined if not cached.\n   */\n  getRequestState(cacheKey: string): RequestState | undefined {\n    return this.state.requests[cacheKey];\n  }\n\n  /**\n   * Updates the state for a specific request.\n   *\n   * @param cacheKey - The cache key.\n   * @param requestState - The new state for the request.\n   */\n  #updateRequestState(cacheKey: string, requestState: RequestState): void {\n    const maxSize = this.#requestCacheMaxSize;\n\n    this.update((state) => {\n      const requests = state.requests as unknown as Record<\n        string,\n        RequestState | undefined\n      >;\n      requests[cacheKey] = requestState;\n\n      // Evict oldest entries if cache exceeds max size\n      const keys = Object.keys(requests);\n\n      if (keys.length > maxSize) {\n        // Sort by timestamp (oldest first)\n        const sortedKeys = keys.sort((a, b) => {\n          const aTime = requests[a]?.timestamp ?? 0;\n          const bTime = requests[b]?.timestamp ?? 0;\n          return aTime - bTime;\n        });\n\n        // Remove oldest entries until we're under the limit\n        const entriesToRemove = keys.length - maxSize;\n        for (let i = 0; i < entriesToRemove; i++) {\n          const keyToRemove = sortedKeys[i];\n          if (keyToRemove) {\n            delete requests[keyToRemove];\n          }\n        }\n      }\n    });\n  }\n\n  /**\n   * Updates the user's region by fetching geolocation.\n   * This method calls the RampsService to get the geolocation.\n   *\n   * @param options - Options for cache behavior.\n   * @returns The user region object.\n   */\n  async updateUserRegion(\n    options?: ExecuteRequestOptions,\n  ): Promise<UserRegion | null> {\n    // If a userRegion already exists and forceRefresh is not requested,\n    // return it immediately without fetching geolocation.\n    // This ensures that once a region is set (either via geolocation or manual selection),\n    // it will not be overwritten by subsequent geolocation fetches.\n    if (this.state.userRegion && !options?.forceRefresh) {\n      return this.state.userRegion;\n    }\n\n    // When forceRefresh is true, clear the existing region, tokens, and providers before fetching\n    if (options?.forceRefresh) {\n      this.update((state) => {\n        state.userRegion = null;\n        state.tokens = null;\n        state.providers = [];\n      });\n    }\n\n    const cacheKey = createCacheKey('updateUserRegion', []);\n\n    const regionCode = await this.executeRequest(\n      cacheKey,\n      async () => {\n        const result = await this.messenger.call('RampsService:getGeolocation');\n        return result;\n      },\n      options,\n    );\n\n    if (!regionCode) {\n      this.update((state) => {\n        state.userRegion = null;\n        state.tokens = null;\n        state.providers = [];\n      });\n      return null;\n    }\n\n    const normalizedRegion = regionCode.toLowerCase().trim();\n\n    try {\n      const countries = await this.getCountries('buy', options);\n      const userRegion = findRegionFromCode(normalizedRegion, countries);\n\n      if (userRegion) {\n        this.update((state) => {\n          const regionChanged =\n            state.userRegion?.regionCode !== userRegion.regionCode;\n          state.userRegion = userRegion;\n          // Clear tokens and providers when region changes\n          if (regionChanged) {\n            state.tokens = null;\n            state.providers = [];\n          }\n        });\n\n        // Fetch providers for the new region\n        if (userRegion.regionCode) {\n          try {\n            await this.getProviders(userRegion.regionCode, options);\n          } catch {\n            // Provider fetch failed - error state will be available via selectors\n          }\n        }\n\n        return userRegion;\n      }\n\n      // Region not found in countries data\n      this.update((state) => {\n        state.userRegion = null;\n        state.tokens = null;\n        state.providers = [];\n      });\n\n      return null;\n    } catch {\n      // If countries fetch fails, we can't create a valid UserRegion\n      // Return null to indicate we don't have valid country data\n      this.update((state) => {\n        state.userRegion = null;\n        state.tokens = null;\n        state.providers = [];\n      });\n\n      return null;\n    }\n  }\n\n  /**\n   * Sets the user's region manually (without fetching geolocation).\n   * This allows users to override the detected region.\n   *\n   * @param region - The region code to set (e.g., \"US-CA\").\n   * @param options - Options for cache behavior.\n   * @returns The user region object.\n   */\n  async setUserRegion(\n    region: string,\n    options?: ExecuteRequestOptions,\n  ): Promise<UserRegion> {\n    const normalizedRegion = region.toLowerCase().trim();\n\n    try {\n      const countries = await this.getCountries('buy', options);\n      const userRegion = findRegionFromCode(normalizedRegion, countries);\n\n      if (userRegion) {\n        this.update((state) => {\n          state.userRegion = userRegion;\n          state.tokens = null;\n          state.providers = [];\n        });\n\n        // Fetch providers for the new region\n        try {\n          await this.getProviders(userRegion.regionCode, options);\n        } catch {\n          // Provider fetch failed - error state will be available via selectors\n        }\n\n        return userRegion;\n      }\n\n      // Region not found in countries data\n      this.update((state) => {\n        state.userRegion = null;\n        state.tokens = null;\n        state.providers = [];\n      });\n      throw new Error(\n        `Region \"${normalizedRegion}\" not found in countries data. Cannot set user region without valid country information.`,\n      );\n    } catch (error) {\n      // If the error is \"not found\", re-throw it\n      // Otherwise, it's from countries fetch failure\n      if (error instanceof Error && error.message.includes('not found')) {\n        throw error;\n      }\n      // Countries fetch failed\n      this.update((state) => {\n        state.userRegion = null;\n        state.tokens = null;\n        state.providers = [];\n      });\n      throw new Error(\n        'Failed to fetch countries data. Cannot set user region without valid country information.',\n      );\n    }\n  }\n\n  /**\n   * Sets the user's preferred provider.\n   * This allows users to set their preferred ramp provider.\n   *\n   * @param provider - The provider object to set.\n   */\n  setPreferredProvider(provider: Provider | null): void {\n    this.update((state) => {\n      state.preferredProvider = provider;\n    });\n  }\n\n  /**\n   * Initializes the controller by fetching the user's region from geolocation.\n   * This should be called once at app startup to set up the initial region.\n   * After the region is set, tokens are fetched and saved to state.\n   *\n   * If a userRegion already exists (from persistence or manual selection),\n   * this method will skip geolocation fetch and only fetch tokens if needed.\n   *\n   * @param options - Options for cache behavior.\n   * @returns Promise that resolves when initialization is complete.\n   */\n  async init(options?: ExecuteRequestOptions): Promise<void> {\n    const userRegion = await this.updateUserRegion(options).catch(() => {\n      // User region fetch failed - error state will be available via selectors\n      return null;\n    });\n\n    if (userRegion) {\n      try {\n        await this.getTokens(userRegion.regionCode, 'buy', options);\n      } catch {\n        // Token fetch failed - error state will be available via selectors\n      }\n\n      try {\n        await this.getProviders(userRegion.regionCode, options);\n      } catch {\n        // Provider fetch failed - error state will be available via selectors\n      }\n    }\n  }\n\n  /**\n   * Fetches the list of supported countries for a given ramp action.\n   *\n   * @param action - The ramp action type ('buy' or 'sell').\n   * @param options - Options for cache behavior.\n   * @returns An array of countries.\n   */\n  async getCountries(\n    action: 'buy' | 'sell' = 'buy',\n    options?: ExecuteRequestOptions,\n  ): Promise<Country[]> {\n    const cacheKey = createCacheKey('getCountries', [action]);\n\n    return this.executeRequest(\n      cacheKey,\n      async () => {\n        return this.messenger.call('RampsService:getCountries', action);\n      },\n      options,\n    );\n  }\n\n  /**\n   * Fetches the list of available tokens for a given region and action.\n   * The tokens are saved in the controller state once fetched.\n   *\n   * @param region - The region code (e.g., \"us\", \"fr\", \"us-ny\"). If not provided, uses the user's region from controller state.\n   * @param action - The ramp action type ('buy' or 'sell').\n   * @param options - Options for cache behavior.\n   * @returns The tokens response containing topTokens and allTokens.\n   */\n  async getTokens(\n    region?: string,\n    action: 'buy' | 'sell' = 'buy',\n    options?: ExecuteRequestOptions,\n  ): Promise<TokensResponse> {\n    const regionToUse = region ?? this.state.userRegion?.regionCode;\n\n    if (!regionToUse) {\n      throw new Error(\n        'Region is required. Either provide a region parameter or ensure userRegion is set in controller state.',\n      );\n    }\n\n    const normalizedRegion = regionToUse.toLowerCase().trim();\n    const cacheKey = createCacheKey('getTokens', [normalizedRegion, action]);\n\n    const tokens = await this.executeRequest(\n      cacheKey,\n      async () => {\n        return this.messenger.call(\n          'RampsService:getTokens',\n          normalizedRegion,\n          action,\n        );\n      },\n      options,\n    );\n\n    this.update((state) => {\n      const userRegionCode = state.userRegion?.regionCode;\n\n      if (userRegionCode === undefined || userRegionCode === normalizedRegion) {\n        state.tokens = tokens;\n      }\n    });\n\n    return tokens;\n  }\n\n  /**\n   * Fetches the list of providers for a given region.\n   * The providers are saved in the controller state once fetched.\n   *\n   * @param region - The region code (e.g., \"us\", \"fr\", \"us-ny\"). If not provided, uses the user's region from controller state.\n   * @param options - Options for cache behavior and query filters.\n   * @param options.provider - Provider ID(s) to filter by.\n   * @param options.crypto - Crypto currency ID(s) to filter by.\n   * @param options.fiat - Fiat currency ID(s) to filter by.\n   * @param options.payments - Payment method ID(s) to filter by.\n   * @returns The providers response containing providers array.\n   */\n  async getProviders(\n    region?: string,\n    options?: ExecuteRequestOptions & {\n      provider?: string | string[];\n      crypto?: string | string[];\n      fiat?: string | string[];\n      payments?: string | string[];\n    },\n  ): Promise<{ providers: Provider[] }> {\n    const regionToUse = region ?? this.state.userRegion?.regionCode;\n\n    if (!regionToUse) {\n      throw new Error(\n        'Region is required. Either provide a region parameter or ensure userRegion is set in controller state.',\n      );\n    }\n\n    const normalizedRegion = regionToUse.toLowerCase().trim();\n    const cacheKey = createCacheKey('getProviders', [\n      normalizedRegion,\n      options?.provider,\n      options?.crypto,\n      options?.fiat,\n      options?.payments,\n    ]);\n\n    const { providers } = await this.executeRequest(\n      cacheKey,\n      async () => {\n        return this.messenger.call(\n          'RampsService:getProviders',\n          normalizedRegion,\n          {\n            provider: options?.provider,\n            crypto: options?.crypto,\n            fiat: options?.fiat,\n            payments: options?.payments,\n          },\n        );\n      },\n      options,\n    );\n\n    this.update((state) => {\n      const userRegionCode = state.userRegion?.regionCode;\n\n      if (userRegionCode === undefined || userRegionCode === normalizedRegion) {\n        state.providers = providers;\n      }\n    });\n\n    return { providers };\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"RampsController.cjs","sourceRoot":"","sources":["../src/RampsController.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n  StateMetadata,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport type { Messenger } from '@metamask/messenger';\nimport type { Json } from '@metamask/utils';\n\nimport type {\n  Country,\n  TokensResponse,\n  Provider,\n  State,\n  RampAction,\n} from './RampsService';\nimport type {\n  RampsServiceGetGeolocationAction,\n  RampsServiceGetCountriesAction,\n  RampsServiceGetTokensAction,\n  RampsServiceGetProvidersAction,\n} from './RampsService-method-action-types';\nimport type {\n  RequestCache as RequestCacheType,\n  RequestState,\n  ExecuteRequestOptions,\n  PendingRequest,\n} from './RequestCache';\nimport {\n  DEFAULT_REQUEST_CACHE_TTL,\n  DEFAULT_REQUEST_CACHE_MAX_SIZE,\n  createCacheKey,\n  isCacheExpired,\n  createLoadingState,\n  createSuccessState,\n  createErrorState,\n} from './RequestCache';\n\n// === GENERAL ===\n\n/**\n * The name of the {@link RampsController}, used to namespace the\n * controller's actions and events and to namespace the controller's state data\n * when composed with other controllers.\n */\nexport const controllerName = 'RampsController';\n\n// === STATE ===\n\n/**\n * Represents the user's selected region with full country and state objects.\n */\nexport type UserRegion = {\n  /**\n   * The country object for the selected region.\n   */\n  country: Country;\n  /**\n   * The state object if a state was selected, null if only country was selected.\n   */\n  state: State | null;\n  /**\n   * The region code string (e.g., \"us-ut\" or \"fr\") used for API calls.\n   */\n  regionCode: string;\n};\n\n/**\n * Describes the shape of the state object for {@link RampsController}.\n */\nexport type RampsControllerState = {\n  /**\n   * The user's selected region with full country and state objects.\n   * Initially set via geolocation fetch, but can be manually changed by the user.\n   * Once set (either via geolocation or manual selection), it will not be overwritten\n   * by subsequent geolocation fetches.\n   */\n  userRegion: UserRegion | null;\n  /**\n   * The user's preferred provider.\n   * Can be manually set by the user.\n   */\n  preferredProvider: Provider | null;\n  /**\n   * List of providers available for the current region.\n   */\n  providers: Provider[];\n  /**\n   * Tokens fetched for the current region and action.\n   * Contains topTokens and allTokens arrays.\n   */\n  tokens: TokensResponse | null;\n  /**\n   * Cache of request states, keyed by cache key.\n   * This stores loading, success, and error states for API requests.\n   */\n  requests: RequestCacheType;\n};\n\n/**\n * The metadata for each property in {@link RampsControllerState}.\n */\nconst rampsControllerMetadata = {\n  userRegion: {\n    persist: true,\n    includeInDebugSnapshot: true,\n    includeInStateLogs: true,\n    usedInUi: true,\n  },\n  preferredProvider: {\n    persist: true,\n    includeInDebugSnapshot: true,\n    includeInStateLogs: true,\n    usedInUi: true,\n  },\n  providers: {\n    persist: true,\n    includeInDebugSnapshot: true,\n    includeInStateLogs: true,\n    usedInUi: true,\n  },\n  tokens: {\n    persist: true,\n    includeInDebugSnapshot: true,\n    includeInStateLogs: true,\n    usedInUi: true,\n  },\n  requests: {\n    persist: false,\n    includeInDebugSnapshot: true,\n    includeInStateLogs: false,\n    usedInUi: true,\n  },\n} satisfies StateMetadata<RampsControllerState>;\n\n/**\n * Constructs the default {@link RampsController} state. This allows\n * consumers to provide a partial state object when initializing the controller\n * and also helps in constructing complete state objects for this controller in\n * tests.\n *\n * @returns The default {@link RampsController} state.\n */\nexport function getDefaultRampsControllerState(): RampsControllerState {\n  return {\n    userRegion: null,\n    preferredProvider: null,\n    providers: [],\n    tokens: null,\n    requests: {},\n  };\n}\n\n// === MESSENGER ===\n\n/**\n * Retrieves the state of the {@link RampsController}.\n */\nexport type RampsControllerGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  RampsControllerState\n>;\n\n/**\n * Actions that {@link RampsControllerMessenger} exposes to other consumers.\n */\nexport type RampsControllerActions = RampsControllerGetStateAction;\n\n/**\n * Actions from other messengers that {@link RampsController} calls.\n */\ntype AllowedActions =\n  | RampsServiceGetGeolocationAction\n  | RampsServiceGetCountriesAction\n  | RampsServiceGetTokensAction\n  | RampsServiceGetProvidersAction;\n\n/**\n * Published when the state of {@link RampsController} changes.\n */\nexport type RampsControllerStateChangeEvent = ControllerStateChangeEvent<\n  typeof controllerName,\n  RampsControllerState\n>;\n\n/**\n * Events that {@link RampsControllerMessenger} exposes to other consumers.\n */\nexport type RampsControllerEvents = RampsControllerStateChangeEvent;\n\n/**\n * Events from other messengers that {@link RampsController} subscribes to.\n */\ntype AllowedEvents = never;\n\n/**\n * The messenger restricted to actions and events accessed by\n * {@link RampsController}.\n */\nexport type RampsControllerMessenger = Messenger<\n  typeof controllerName,\n  RampsControllerActions | AllowedActions,\n  RampsControllerEvents | AllowedEvents\n>;\n\n/**\n * Configuration options for the RampsController.\n */\nexport type RampsControllerOptions = {\n  /** The messenger suited for this controller. */\n  messenger: RampsControllerMessenger;\n  /** The desired state with which to initialize this controller. */\n  state?: Partial<RampsControllerState>;\n  /** Time to live for cached requests in milliseconds. Defaults to 15 minutes. */\n  requestCacheTTL?: number;\n  /** Maximum number of entries in the request cache. Defaults to 250. */\n  requestCacheMaxSize?: number;\n};\n\n// === HELPER FUNCTIONS ===\n\n/**\n * Finds a country and state from a region code string.\n *\n * @param regionCode - The region code (e.g., \"us-ca\" or \"us\").\n * @param countries - Array of countries to search.\n * @returns UserRegion object with country and state, or null if not found.\n */\nfunction findRegionFromCode(\n  regionCode: string,\n  countries: Country[],\n): UserRegion | null {\n  const normalizedCode = regionCode.toLowerCase().trim();\n  const parts = normalizedCode.split('-');\n  const countryCode = parts[0];\n  const stateCode = parts[1];\n\n  const country = countries.find((countryItem) => {\n    if (countryItem.isoCode?.toLowerCase() === countryCode) {\n      return true;\n    }\n    if (countryItem.id) {\n      const id = countryItem.id.toLowerCase();\n      if (id.startsWith('/regions/')) {\n        const extractedCode = id.replace('/regions/', '').split('/')[0];\n        return extractedCode === countryCode;\n      }\n      return id === countryCode || id.endsWith(`/${countryCode}`);\n    }\n    return false;\n  });\n\n  if (!country) {\n    return null;\n  }\n\n  let state: State | null = null;\n  if (stateCode && country.states) {\n    state =\n      country.states.find((stateItem) => {\n        if (stateItem.stateId?.toLowerCase() === stateCode) {\n          return true;\n        }\n        if (stateItem.id) {\n          const stateId = stateItem.id.toLowerCase();\n          if (\n            stateId.includes(`-${stateCode}`) ||\n            stateId.endsWith(`/${stateCode}`)\n          ) {\n            return true;\n          }\n        }\n        return false;\n      }) ?? null;\n  }\n\n  return {\n    country,\n    state,\n    regionCode: normalizedCode,\n  };\n}\n\n// === CONTROLLER DEFINITION ===\n\n/**\n * Manages cryptocurrency on/off ramps functionality.\n */\nexport class RampsController extends BaseController<\n  typeof controllerName,\n  RampsControllerState,\n  RampsControllerMessenger\n> {\n  /**\n   * Default TTL for cached requests.\n   */\n  readonly #requestCacheTTL: number;\n\n  /**\n   * Maximum number of entries in the request cache.\n   */\n  readonly #requestCacheMaxSize: number;\n\n  /**\n   * Map of pending requests for deduplication.\n   * Key is the cache key, value is the pending request with abort controller.\n   */\n  readonly #pendingRequests: Map<string, PendingRequest> = new Map();\n\n  /**\n   * Constructs a new {@link RampsController}.\n   *\n   * @param args - The constructor arguments.\n   * @param args.messenger - The messenger suited for this controller.\n   * @param args.state - The desired state with which to initialize this\n   * controller. Missing properties will be filled in with defaults.\n   * @param args.requestCacheTTL - Time to live for cached requests in milliseconds.\n   * @param args.requestCacheMaxSize - Maximum number of entries in the request cache.\n   */\n  constructor({\n    messenger,\n    state = {},\n    requestCacheTTL = DEFAULT_REQUEST_CACHE_TTL,\n    requestCacheMaxSize = DEFAULT_REQUEST_CACHE_MAX_SIZE,\n  }: RampsControllerOptions) {\n    super({\n      messenger,\n      metadata: rampsControllerMetadata,\n      name: controllerName,\n      state: {\n        ...getDefaultRampsControllerState(),\n        ...state,\n        // Always reset requests cache on initialization (non-persisted)\n        requests: {},\n      },\n    });\n\n    this.#requestCacheTTL = requestCacheTTL;\n    this.#requestCacheMaxSize = requestCacheMaxSize;\n  }\n\n  /**\n   * Executes a request with caching and deduplication.\n   *\n   * If a request with the same cache key is already in flight, returns the\n   * existing promise. If valid cached data exists, returns it without making\n   * a new request.\n   *\n   * @param cacheKey - Unique identifier for this request.\n   * @param fetcher - Function that performs the actual fetch. Receives an AbortSignal.\n   * @param options - Options for cache behavior.\n   * @returns The result of the request.\n   */\n  async executeRequest<TResult>(\n    cacheKey: string,\n    fetcher: (signal: AbortSignal) => Promise<TResult>,\n    options?: ExecuteRequestOptions,\n  ): Promise<TResult> {\n    const ttl = options?.ttl ?? this.#requestCacheTTL;\n\n    // Check for existing pending request - join it instead of making a duplicate\n    const pending = this.#pendingRequests.get(cacheKey);\n    if (pending) {\n      return pending.promise as Promise<TResult>;\n    }\n\n    // Check cache validity (unless force refresh)\n    if (!options?.forceRefresh) {\n      const cached = this.state.requests[cacheKey];\n      if (cached && !isCacheExpired(cached, ttl)) {\n        return cached.data as TResult;\n      }\n    }\n\n    // Create abort controller for this request\n    const abortController = new AbortController();\n    const lastFetchedAt = Date.now();\n\n    // Update state to loading\n    this.#updateRequestState(cacheKey, createLoadingState());\n\n    // Create the fetch promise\n    const promise = (async (): Promise<TResult> => {\n      try {\n        const data = await fetcher(abortController.signal);\n\n        // Don't update state if aborted\n        if (abortController.signal.aborted) {\n          throw new Error('Request was aborted');\n        }\n\n        this.#updateRequestState(\n          cacheKey,\n          createSuccessState(data as Json, lastFetchedAt),\n        );\n        return data;\n      } catch (error) {\n        // Don't update state if aborted\n        if (abortController.signal.aborted) {\n          throw error;\n        }\n\n        const errorMessage = (error as Error)?.message;\n\n        this.#updateRequestState(\n          cacheKey,\n          createErrorState(errorMessage ?? 'Unknown error', lastFetchedAt),\n        );\n        throw error;\n      } finally {\n        // Only delete if this is still our entry (not replaced by a new request)\n        const currentPending = this.#pendingRequests.get(cacheKey);\n        if (currentPending?.abortController === abortController) {\n          this.#pendingRequests.delete(cacheKey);\n        }\n      }\n    })();\n\n    // Store pending request for deduplication\n    this.#pendingRequests.set(cacheKey, { promise, abortController });\n\n    return promise;\n  }\n\n  /**\n   * Aborts a pending request if one exists.\n   *\n   * @param cacheKey - The cache key of the request to abort.\n   * @returns True if a request was aborted.\n   */\n  abortRequest(cacheKey: string): boolean {\n    const pending = this.#pendingRequests.get(cacheKey);\n    if (pending) {\n      pending.abortController.abort();\n      this.#pendingRequests.delete(cacheKey);\n      this.#removeRequestState(cacheKey);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Removes a request state from the cache.\n   *\n   * @param cacheKey - The cache key to remove.\n   */\n  #removeRequestState(cacheKey: string): void {\n    this.update((state) => {\n      const requests = state.requests as unknown as Record<\n        string,\n        RequestState | undefined\n      >;\n      delete requests[cacheKey];\n    });\n  }\n\n  /**\n   * Gets the state of a specific cached request.\n   *\n   * @param cacheKey - The cache key to look up.\n   * @returns The request state, or undefined if not cached.\n   */\n  getRequestState(cacheKey: string): RequestState | undefined {\n    return this.state.requests[cacheKey];\n  }\n\n  /**\n   * Updates the state for a specific request.\n   *\n   * @param cacheKey - The cache key.\n   * @param requestState - The new state for the request.\n   */\n  #updateRequestState(cacheKey: string, requestState: RequestState): void {\n    const maxSize = this.#requestCacheMaxSize;\n\n    this.update((state) => {\n      const requests = state.requests as unknown as Record<\n        string,\n        RequestState | undefined\n      >;\n      requests[cacheKey] = requestState;\n\n      // Evict oldest entries if cache exceeds max size\n      const keys = Object.keys(requests);\n\n      if (keys.length > maxSize) {\n        // Sort by timestamp (oldest first)\n        const sortedKeys = keys.sort((a, b) => {\n          const aTime = requests[a]?.timestamp ?? 0;\n          const bTime = requests[b]?.timestamp ?? 0;\n          return aTime - bTime;\n        });\n\n        // Remove oldest entries until we're under the limit\n        const entriesToRemove = keys.length - maxSize;\n        for (let i = 0; i < entriesToRemove; i++) {\n          const keyToRemove = sortedKeys[i];\n          if (keyToRemove) {\n            delete requests[keyToRemove];\n          }\n        }\n      }\n    });\n  }\n\n  /**\n   * Updates the user's region by fetching geolocation.\n   * This method calls the RampsService to get the geolocation.\n   *\n   * @param options - Options for cache behavior.\n   * @returns The user region object.\n   */\n  async updateUserRegion(\n    options?: ExecuteRequestOptions,\n  ): Promise<UserRegion | null> {\n    // If a userRegion already exists and forceRefresh is not requested,\n    // return it immediately without fetching geolocation.\n    // This ensures that once a region is set (either via geolocation or manual selection),\n    // it will not be overwritten by subsequent geolocation fetches.\n    if (this.state.userRegion && !options?.forceRefresh) {\n      return this.state.userRegion;\n    }\n\n    // When forceRefresh is true, clear the existing region, tokens, and providers before fetching\n    if (options?.forceRefresh) {\n      this.update((state) => {\n        state.userRegion = null;\n        state.tokens = null;\n        state.providers = [];\n      });\n    }\n\n    const cacheKey = createCacheKey('updateUserRegion', []);\n\n    const regionCode = await this.executeRequest(\n      cacheKey,\n      async () => {\n        const result = await this.messenger.call('RampsService:getGeolocation');\n        return result;\n      },\n      options,\n    );\n\n    if (!regionCode) {\n      this.update((state) => {\n        state.userRegion = null;\n        state.tokens = null;\n        state.providers = [];\n      });\n      return null;\n    }\n\n    const normalizedRegion = regionCode.toLowerCase().trim();\n\n    try {\n      const countries = await this.getCountries('buy', options);\n      const userRegion = findRegionFromCode(normalizedRegion, countries);\n\n      if (userRegion) {\n        this.update((state) => {\n          const regionChanged =\n            state.userRegion?.regionCode !== userRegion.regionCode;\n          state.userRegion = userRegion;\n          // Clear tokens and providers when region changes\n          if (regionChanged) {\n            state.tokens = null;\n            state.providers = [];\n          }\n        });\n\n        // Fetch providers for the new region\n        if (userRegion.regionCode) {\n          try {\n            await this.getProviders(userRegion.regionCode, options);\n          } catch {\n            // Provider fetch failed - error state will be available via selectors\n          }\n        }\n\n        return userRegion;\n      }\n\n      // Region not found in countries data\n      this.update((state) => {\n        state.userRegion = null;\n        state.tokens = null;\n        state.providers = [];\n      });\n\n      return null;\n    } catch {\n      // If countries fetch fails, we can't create a valid UserRegion\n      // Return null to indicate we don't have valid country data\n      this.update((state) => {\n        state.userRegion = null;\n        state.tokens = null;\n        state.providers = [];\n      });\n\n      return null;\n    }\n  }\n\n  /**\n   * Sets the user's region manually (without fetching geolocation).\n   * This allows users to override the detected region.\n   *\n   * @param region - The region code to set (e.g., \"US-CA\").\n   * @param options - Options for cache behavior.\n   * @returns The user region object.\n   */\n  async setUserRegion(\n    region: string,\n    options?: ExecuteRequestOptions,\n  ): Promise<UserRegion> {\n    const normalizedRegion = region.toLowerCase().trim();\n\n    try {\n      const countries = await this.getCountries('buy', options);\n      const userRegion = findRegionFromCode(normalizedRegion, countries);\n\n      if (userRegion) {\n        this.update((state) => {\n          state.userRegion = userRegion;\n          state.tokens = null;\n          state.providers = [];\n        });\n\n        // Fetch providers for the new region\n        try {\n          await this.getProviders(userRegion.regionCode, options);\n        } catch {\n          // Provider fetch failed - error state will be available via selectors\n        }\n\n        return userRegion;\n      }\n\n      // Region not found in countries data\n      this.update((state) => {\n        state.userRegion = null;\n        state.tokens = null;\n        state.providers = [];\n      });\n      throw new Error(\n        `Region \"${normalizedRegion}\" not found in countries data. Cannot set user region without valid country information.`,\n      );\n    } catch (error) {\n      // If the error is \"not found\", re-throw it\n      // Otherwise, it's from countries fetch failure\n      if (error instanceof Error && error.message.includes('not found')) {\n        throw error;\n      }\n      // Countries fetch failed\n      this.update((state) => {\n        state.userRegion = null;\n        state.tokens = null;\n        state.providers = [];\n      });\n      throw new Error(\n        'Failed to fetch countries data. Cannot set user region without valid country information.',\n      );\n    }\n  }\n\n  /**\n   * Sets the user's preferred provider.\n   * This allows users to set their preferred ramp provider.\n   *\n   * @param provider - The provider object to set.\n   */\n  setPreferredProvider(provider: Provider | null): void {\n    this.update((state) => {\n      state.preferredProvider = provider;\n    });\n  }\n\n  /**\n   * Initializes the controller by fetching the user's region from geolocation.\n   * This should be called once at app startup to set up the initial region.\n   * After the region is set, tokens are fetched and saved to state.\n   *\n   * If a userRegion already exists (from persistence or manual selection),\n   * this method will skip geolocation fetch and only fetch tokens if needed.\n   *\n   * @param options - Options for cache behavior.\n   * @returns Promise that resolves when initialization is complete.\n   */\n  async init(options?: ExecuteRequestOptions): Promise<void> {\n    const userRegion = await this.updateUserRegion(options).catch(() => {\n      // User region fetch failed - error state will be available via selectors\n      return null;\n    });\n\n    if (userRegion) {\n      try {\n        await this.getTokens(userRegion.regionCode, 'buy', options);\n      } catch {\n        // Token fetch failed - error state will be available via selectors\n      }\n\n      try {\n        await this.getProviders(userRegion.regionCode, options);\n      } catch {\n        // Provider fetch failed - error state will be available via selectors\n      }\n    }\n  }\n\n  /**\n   * Fetches the list of supported countries for a given ramp action.\n   *\n   * @param action - The ramp action type ('buy' or 'sell').\n   * @param options - Options for cache behavior.\n   * @returns An array of countries.\n   */\n  async getCountries(\n    action: RampAction = 'buy',\n    options?: ExecuteRequestOptions,\n  ): Promise<Country[]> {\n    const cacheKey = createCacheKey('getCountries', [action]);\n\n    return this.executeRequest(\n      cacheKey,\n      async () => {\n        return this.messenger.call('RampsService:getCountries', action);\n      },\n      options,\n    );\n  }\n\n  /**\n   * Fetches the list of available tokens for a given region and action.\n   * The tokens are saved in the controller state once fetched.\n   *\n   * @param region - The region code (e.g., \"us\", \"fr\", \"us-ny\"). If not provided, uses the user's region from controller state.\n   * @param action - The ramp action type ('buy' or 'sell').\n   * @param options - Options for cache behavior and query filters.\n   * @param options.provider - Provider ID(s) to filter by.\n   * @returns The tokens response containing topTokens and allTokens.\n   */\n  async getTokens(\n    region?: string,\n    action: RampAction = 'buy',\n    options?: ExecuteRequestOptions & {\n      provider?: string | string[];\n    },\n  ): Promise<TokensResponse> {\n    const regionToUse = region ?? this.state.userRegion?.regionCode;\n\n    if (!regionToUse) {\n      throw new Error(\n        'Region is required. Either provide a region parameter or ensure userRegion is set in controller state.',\n      );\n    }\n\n    const normalizedRegion = regionToUse.toLowerCase().trim();\n    const cacheKey = createCacheKey('getTokens', [\n      normalizedRegion,\n      action,\n      options?.provider,\n    ]);\n\n    const tokens = await this.executeRequest(\n      cacheKey,\n      async () => {\n        return this.messenger.call(\n          'RampsService:getTokens',\n          normalizedRegion,\n          action,\n          {\n            provider: options?.provider,\n          },\n        );\n      },\n      options,\n    );\n\n    this.update((state) => {\n      const userRegionCode = state.userRegion?.regionCode;\n\n      if (userRegionCode === undefined || userRegionCode === normalizedRegion) {\n        state.tokens = tokens;\n      }\n    });\n\n    return tokens;\n  }\n\n  /**\n   * Fetches the list of providers for a given region.\n   * The providers are saved in the controller state once fetched.\n   *\n   * @param region - The region code (e.g., \"us\", \"fr\", \"us-ny\"). If not provided, uses the user's region from controller state.\n   * @param options - Options for cache behavior and query filters.\n   * @param options.provider - Provider ID(s) to filter by.\n   * @param options.crypto - Crypto currency ID(s) to filter by.\n   * @param options.fiat - Fiat currency ID(s) to filter by.\n   * @param options.payments - Payment method ID(s) to filter by.\n   * @returns The providers response containing providers array.\n   */\n  async getProviders(\n    region?: string,\n    options?: ExecuteRequestOptions & {\n      provider?: string | string[];\n      crypto?: string | string[];\n      fiat?: string | string[];\n      payments?: string | string[];\n    },\n  ): Promise<{ providers: Provider[] }> {\n    const regionToUse = region ?? this.state.userRegion?.regionCode;\n\n    if (!regionToUse) {\n      throw new Error(\n        'Region is required. Either provide a region parameter or ensure userRegion is set in controller state.',\n      );\n    }\n\n    const normalizedRegion = regionToUse.toLowerCase().trim();\n    const cacheKey = createCacheKey('getProviders', [\n      normalizedRegion,\n      options?.provider,\n      options?.crypto,\n      options?.fiat,\n      options?.payments,\n    ]);\n\n    const { providers } = await this.executeRequest(\n      cacheKey,\n      async () => {\n        return this.messenger.call(\n          'RampsService:getProviders',\n          normalizedRegion,\n          {\n            provider: options?.provider,\n            crypto: options?.crypto,\n            fiat: options?.fiat,\n            payments: options?.payments,\n          },\n        );\n      },\n      options,\n    );\n\n    this.update((state) => {\n      const userRegionCode = state.userRegion?.regionCode;\n\n      if (userRegionCode === undefined || userRegionCode === normalizedRegion) {\n        state.providers = providers;\n      }\n    });\n\n    return { providers };\n  }\n\n  // ============================================================\n  // Sync Trigger Methods\n  // These fire-and-forget methods are for use in React effects.\n  // Errors are stored in state and available via selectors.\n  // ============================================================\n\n  /**\n   * Triggers a user region update without throwing.\n   *\n   * @param options - Options for cache behavior.\n   */\n  triggerUpdateUserRegion(options?: ExecuteRequestOptions): void {\n    this.updateUserRegion(options).catch(() => {\n      // Error stored in state\n    });\n  }\n\n  /**\n   * Triggers setting the user region without throwing.\n   *\n   * @param region - The region code to set (e.g., \"US-CA\").\n   * @param options - Options for cache behavior.\n   */\n  triggerSetUserRegion(region: string, options?: ExecuteRequestOptions): void {\n    this.setUserRegion(region, options).catch(() => {\n      // Error stored in state\n    });\n  }\n\n  /**\n   * Triggers fetching countries without throwing.\n   *\n   * @param action - The ramp action type ('buy' or 'sell').\n   * @param options - Options for cache behavior.\n   */\n  triggerGetCountries(\n    action: 'buy' | 'sell' = 'buy',\n    options?: ExecuteRequestOptions,\n  ): void {\n    this.getCountries(action, options).catch(() => {\n      // Error stored in state\n    });\n  }\n\n  /**\n   * Triggers fetching tokens without throwing.\n   *\n   * @param region - The region code. If not provided, uses userRegion from state.\n   * @param action - The ramp action type ('buy' or 'sell').\n   * @param options - Options for cache behavior.\n   */\n  triggerGetTokens(\n    region?: string,\n    action: 'buy' | 'sell' = 'buy',\n    options?: ExecuteRequestOptions,\n  ): void {\n    this.getTokens(region, action, options).catch(() => {\n      // Error stored in state\n    });\n  }\n\n  /**\n   * Triggers fetching providers without throwing.\n   *\n   * @param region - The region code. If not provided, uses userRegion from state.\n   * @param options - Options for cache behavior and query filters.\n   */\n  triggerGetProviders(\n    region?: string,\n    options?: ExecuteRequestOptions & {\n      provider?: string | string[];\n      crypto?: string | string[];\n      fiat?: string | string[];\n      payments?: string | string[];\n    },\n  ): void {\n    this.getProviders(region, options).catch(() => {\n      // Error stored in state\n    });\n  }\n}\n"]}
\ No newline at end of file
diff --git a/dist/RampsController.d.cts b/dist/RampsController.d.cts
index f940ab1712fbc73dbb501736048a0735ce8f9aa7..53745de1759c37fca4a82eaef55763cf449dc312 100644
--- a/dist/RampsController.d.cts
+++ b/dist/RampsController.d.cts
@@ -1,7 +1,7 @@
 import type { ControllerGetStateAction, ControllerStateChangeEvent } from "@metamask/base-controller";
 import { BaseController } from "@metamask/base-controller";
 import type { Messenger } from "@metamask/messenger";
-import type { Country, TokensResponse, Provider, State } from "./RampsService.cjs";
+import type { Country, TokensResponse, Provider, State, RampAction } from "./RampsService.cjs";
 import type { RampsServiceGetGeolocationAction, RampsServiceGetCountriesAction, RampsServiceGetTokensAction, RampsServiceGetProvidersAction } from "./RampsService-method-action-types.cjs";
 import type { RequestCache as RequestCacheType, RequestState, ExecuteRequestOptions } from "./RequestCache.cjs";
 /**
@@ -195,17 +195,20 @@ export declare class RampsController extends BaseController<typeof controllerNam
      * @param options - Options for cache behavior.
      * @returns An array of countries.
      */
-    getCountries(action?: 'buy' | 'sell', options?: ExecuteRequestOptions): Promise<Country[]>;
+    getCountries(action?: RampAction, options?: ExecuteRequestOptions): Promise<Country[]>;
     /**
      * Fetches the list of available tokens for a given region and action.
      * The tokens are saved in the controller state once fetched.
      *
      * @param region - The region code (e.g., "us", "fr", "us-ny"). If not provided, uses the user's region from controller state.
      * @param action - The ramp action type ('buy' or 'sell').
-     * @param options - Options for cache behavior.
+     * @param options - Options for cache behavior and query filters.
+     * @param options.provider - Provider ID(s) to filter by.
      * @returns The tokens response containing topTokens and allTokens.
      */
-    getTokens(region?: string, action?: 'buy' | 'sell', options?: ExecuteRequestOptions): Promise<TokensResponse>;
+    getTokens(region?: string, action?: RampAction, options?: ExecuteRequestOptions & {
+        provider?: string | string[];
+    }): Promise<TokensResponse>;
     /**
      * Fetches the list of providers for a given region.
      * The providers are saved in the controller state once fetched.
@@ -226,6 +229,46 @@ export declare class RampsController extends BaseController<typeof controllerNam
     }): Promise<{
         providers: Provider[];
     }>;
+    /**
+     * Triggers a user region update without throwing.
+     *
+     * @param options - Options for cache behavior.
+     */
+    triggerUpdateUserRegion(options?: ExecuteRequestOptions): void;
+    /**
+     * Triggers setting the user region without throwing.
+     *
+     * @param region - The region code to set (e.g., "US-CA").
+     * @param options - Options for cache behavior.
+     */
+    triggerSetUserRegion(region: string, options?: ExecuteRequestOptions): void;
+    /**
+     * Triggers fetching countries without throwing.
+     *
+     * @param action - The ramp action type ('buy' or 'sell').
+     * @param options - Options for cache behavior.
+     */
+    triggerGetCountries(action?: 'buy' | 'sell', options?: ExecuteRequestOptions): void;
+    /**
+     * Triggers fetching tokens without throwing.
+     *
+     * @param region - The region code. If not provided, uses userRegion from state.
+     * @param action - The ramp action type ('buy' or 'sell').
+     * @param options - Options for cache behavior.
+     */
+    triggerGetTokens(region?: string, action?: 'buy' | 'sell', options?: ExecuteRequestOptions): void;
+    /**
+     * Triggers fetching providers without throwing.
+     *
+     * @param region - The region code. If not provided, uses userRegion from state.
+     * @param options - Options for cache behavior and query filters.
+     */
+    triggerGetProviders(region?: string, options?: ExecuteRequestOptions & {
+        provider?: string | string[];
+        crypto?: string | string[];
+        fiat?: string | string[];
+        payments?: string | string[];
+    }): void;
 }
 export {};
 //# sourceMappingURL=RampsController.d.cts.map
\ No newline at end of file
diff --git a/dist/RampsController.d.cts.map b/dist/RampsController.d.cts.map
index 59b6f269f39748e611da80d8b812484016670810..59673b6e4cbaf0e0e85d4549a7abe5b7c592c54b 100644
--- a/dist/RampsController.d.cts.map
+++ b/dist/RampsController.d.cts.map
@@ -1 +1 @@
-{"version":3,"file":"RampsController.d.cts","sourceRoot":"","sources":["../src/RampsController.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EACV,wBAAwB,EACxB,0BAA0B,EAE3B,kCAAkC;AACnC,OAAO,EAAE,cAAc,EAAE,kCAAkC;AAC3D,OAAO,KAAK,EAAE,SAAS,EAAE,4BAA4B;AAGrD,OAAO,KAAK,EAAE,OAAO,EAAE,cAAc,EAAE,QAAQ,EAAE,KAAK,EAAE,2BAAuB;AAC/E,OAAO,KAAK,EACV,gCAAgC,EAChC,8BAA8B,EAC9B,2BAA2B,EAC3B,8BAA8B,EAC/B,+CAA2C;AAC5C,OAAO,KAAK,EACV,YAAY,IAAI,gBAAgB,EAChC,YAAY,EACZ,qBAAqB,EAEtB,2BAAuB;AAaxB;;;;GAIG;AACH,eAAO,MAAM,cAAc,oBAAoB,CAAC;AAIhD;;GAEG;AACH,MAAM,MAAM,UAAU,GAAG;IACvB;;OAEG;IACH,OAAO,EAAE,OAAO,CAAC;IACjB;;OAEG;IACH,KAAK,EAAE,KAAK,GAAG,IAAI,CAAC;IACpB;;OAEG;IACH,UAAU,EAAE,MAAM,CAAC;CACpB,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,oBAAoB,GAAG;IACjC;;;;;OAKG;IACH,UAAU,EAAE,UAAU,GAAG,IAAI,CAAC;IAC9B;;;OAGG;IACH,iBAAiB,EAAE,QAAQ,GAAG,IAAI,CAAC;IACnC;;OAEG;IACH,SAAS,EAAE,QAAQ,EAAE,CAAC;IACtB;;;OAGG;IACH,MAAM,EAAE,cAAc,GAAG,IAAI,CAAC;IAC9B;;;OAGG;IACH,QAAQ,EAAE,gBAAgB,CAAC;CAC5B,CAAC;AAsCF;;;;;;;GAOG;AACH,wBAAgB,8BAA8B,IAAI,oBAAoB,CAQrE;AAID;;GAEG;AACH,MAAM,MAAM,6BAA6B,GAAG,wBAAwB,CAClE,OAAO,cAAc,EACrB,oBAAoB,CACrB,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,sBAAsB,GAAG,6BAA6B,CAAC;AAEnE;;GAEG;AACH,KAAK,cAAc,GACf,gCAAgC,GAChC,8BAA8B,GAC9B,2BAA2B,GAC3B,8BAA8B,CAAC;AAEnC;;GAEG;AACH,MAAM,MAAM,+BAA+B,GAAG,0BAA0B,CACtE,OAAO,cAAc,EACrB,oBAAoB,CACrB,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,qBAAqB,GAAG,+BAA+B,CAAC;AAEpE;;GAEG;AACH,KAAK,aAAa,GAAG,KAAK,CAAC;AAE3B;;;GAGG;AACH,MAAM,MAAM,wBAAwB,GAAG,SAAS,CAC9C,OAAO,cAAc,EACrB,sBAAsB,GAAG,cAAc,EACvC,qBAAqB,GAAG,aAAa,CACtC,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,sBAAsB,GAAG;IACnC,gDAAgD;IAChD,SAAS,EAAE,wBAAwB,CAAC;IACpC,kEAAkE;IAClE,KAAK,CAAC,EAAE,OAAO,CAAC,oBAAoB,CAAC,CAAC;IACtC,gFAAgF;IAChF,eAAe,CAAC,EAAE,MAAM,CAAC;IACzB,uEAAuE;IACvE,mBAAmB,CAAC,EAAE,MAAM,CAAC;CAC9B,CAAC;AAoEF;;GAEG;AACH,qBAAa,eAAgB,SAAQ,cAAc,CACjD,OAAO,cAAc,EACrB,oBAAoB,EACpB,wBAAwB,CACzB;;IAiBC;;;;;;;;;OASG;gBACS,EACV,SAAS,EACT,KAAU,EACV,eAA2C,EAC3C,mBAAoD,GACrD,EAAE,sBAAsB;IAiBzB;;;;;;;;;;;OAWG;IACG,cAAc,CAAC,OAAO,EAC1B,QAAQ,EAAE,MAAM,EAChB,OAAO,EAAE,CAAC,MAAM,EAAE,WAAW,KAAK,OAAO,CAAC,OAAO,CAAC,EAClD,OAAO,CAAC,EAAE,qBAAqB,GAC9B,OAAO,CAAC,OAAO,CAAC;IAmEnB;;;;;OAKG;IACH,YAAY,CAAC,QAAQ,EAAE,MAAM,GAAG,OAAO;IA0BvC;;;;;OAKG;IACH,eAAe,CAAC,QAAQ,EAAE,MAAM,GAAG,YAAY,GAAG,SAAS;IA2C3D;;;;;;OAMG;IACG,gBAAgB,CACpB,OAAO,CAAC,EAAE,qBAAqB,GAC9B,OAAO,CAAC,UAAU,GAAG,IAAI,CAAC;IAyF7B;;;;;;;OAOG;IACG,aAAa,CACjB,MAAM,EAAE,MAAM,EACd,OAAO,CAAC,EAAE,qBAAqB,GAC9B,OAAO,CAAC,UAAU,CAAC;IAmDtB;;;;;OAKG;IACH,oBAAoB,CAAC,QAAQ,EAAE,QAAQ,GAAG,IAAI,GAAG,IAAI;IAMrD;;;;;;;;;;OAUG;IACG,IAAI,CAAC,OAAO,CAAC,EAAE,qBAAqB,GAAG,OAAO,CAAC,IAAI,CAAC;IAqB1D;;;;;;OAMG;IACG,YAAY,CAChB,MAAM,GAAE,KAAK,GAAG,MAAc,EAC9B,OAAO,CAAC,EAAE,qBAAqB,GAC9B,OAAO,CAAC,OAAO,EAAE,CAAC;IAYrB;;;;;;;;OAQG;IACG,SAAS,CACb,MAAM,CAAC,EAAE,MAAM,EACf,MAAM,GAAE,KAAK,GAAG,MAAc,EAC9B,OAAO,CAAC,EAAE,qBAAqB,GAC9B,OAAO,CAAC,cAAc,CAAC;IAmC1B;;;;;;;;;;;OAWG;IACG,YAAY,CAChB,MAAM,CAAC,EAAE,MAAM,EACf,OAAO,CAAC,EAAE,qBAAqB,GAAG;QAChC,QAAQ,CAAC,EAAE,MAAM,GAAG,MAAM,EAAE,CAAC;QAC7B,MAAM,CAAC,EAAE,MAAM,GAAG,MAAM,EAAE,CAAC;QAC3B,IAAI,CAAC,EAAE,MAAM,GAAG,MAAM,EAAE,CAAC;QACzB,QAAQ,CAAC,EAAE,MAAM,GAAG,MAAM,EAAE,CAAC;KAC9B,GACA,OAAO,CAAC;QAAE,SAAS,EAAE,QAAQ,EAAE,CAAA;KAAE,CAAC;CA6CtC"}
\ No newline at end of file
+{"version":3,"file":"RampsController.d.cts","sourceRoot":"","sources":["../src/RampsController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/RampsController.d.mts b/dist/RampsController.d.mts
index 888751d8aea60b59d32978d485e0c1941b3a96d0..92fccc8388c19bf18660529863cae8c0d67a2529 100644
--- a/dist/RampsController.d.mts
+++ b/dist/RampsController.d.mts
@@ -1,7 +1,7 @@
 import type { ControllerGetStateAction, ControllerStateChangeEvent } from "@metamask/base-controller";
 import { BaseController } from "@metamask/base-controller";
 import type { Messenger } from "@metamask/messenger";
-import type { Country, TokensResponse, Provider, State } from "./RampsService.mjs";
+import type { Country, TokensResponse, Provider, State, RampAction } from "./RampsService.mjs";
 import type { RampsServiceGetGeolocationAction, RampsServiceGetCountriesAction, RampsServiceGetTokensAction, RampsServiceGetProvidersAction } from "./RampsService-method-action-types.mjs";
 import type { RequestCache as RequestCacheType, RequestState, ExecuteRequestOptions } from "./RequestCache.mjs";
 /**
@@ -195,17 +195,20 @@ export declare class RampsController extends BaseController<typeof controllerNam
      * @param options - Options for cache behavior.
      * @returns An array of countries.
      */
-    getCountries(action?: 'buy' | 'sell', options?: ExecuteRequestOptions): Promise<Country[]>;
+    getCountries(action?: RampAction, options?: ExecuteRequestOptions): Promise<Country[]>;
     /**
      * Fetches the list of available tokens for a given region and action.
      * The tokens are saved in the controller state once fetched.
      *
      * @param region - The region code (e.g., "us", "fr", "us-ny"). If not provided, uses the user's region from controller state.
      * @param action - The ramp action type ('buy' or 'sell').
-     * @param options - Options for cache behavior.
+     * @param options - Options for cache behavior and query filters.
+     * @param options.provider - Provider ID(s) to filter by.
      * @returns The tokens response containing topTokens and allTokens.
      */
-    getTokens(region?: string, action?: 'buy' | 'sell', options?: ExecuteRequestOptions): Promise<TokensResponse>;
+    getTokens(region?: string, action?: RampAction, options?: ExecuteRequestOptions & {
+        provider?: string | string[];
+    }): Promise<TokensResponse>;
     /**
      * Fetches the list of providers for a given region.
      * The providers are saved in the controller state once fetched.
@@ -226,6 +229,46 @@ export declare class RampsController extends BaseController<typeof controllerNam
     }): Promise<{
         providers: Provider[];
     }>;
+    /**
+     * Triggers a user region update without throwing.
+     *
+     * @param options - Options for cache behavior.
+     */
+    triggerUpdateUserRegion(options?: ExecuteRequestOptions): void;
+    /**
+     * Triggers setting the user region without throwing.
+     *
+     * @param region - The region code to set (e.g., "US-CA").
+     * @param options - Options for cache behavior.
+     */
+    triggerSetUserRegion(region: string, options?: ExecuteRequestOptions): void;
+    /**
+     * Triggers fetching countries without throwing.
+     *
+     * @param action - The ramp action type ('buy' or 'sell').
+     * @param options - Options for cache behavior.
+     */
+    triggerGetCountries(action?: 'buy' | 'sell', options?: ExecuteRequestOptions): void;
+    /**
+     * Triggers fetching tokens without throwing.
+     *
+     * @param region - The region code. If not provided, uses userRegion from state.
+     * @param action - The ramp action type ('buy' or 'sell').
+     * @param options - Options for cache behavior.
+     */
+    triggerGetTokens(region?: string, action?: 'buy' | 'sell', options?: ExecuteRequestOptions): void;
+    /**
+     * Triggers fetching providers without throwing.
+     *
+     * @param region - The region code. If not provided, uses userRegion from state.
+     * @param options - Options for cache behavior and query filters.
+     */
+    triggerGetProviders(region?: string, options?: ExecuteRequestOptions & {
+        provider?: string | string[];
+        crypto?: string | string[];
+        fiat?: string | string[];
+        payments?: string | string[];
+    }): void;
 }
 export {};
 //# sourceMappingURL=RampsController.d.mts.map
\ No newline at end of file
diff --git a/dist/RampsController.d.mts.map b/dist/RampsController.d.mts.map
index 3f97fa60edc24337cf8a607e529928cbe92c920e..e960964ad904770bf81a1bfbc40fa2d028f07f92 100644
--- a/dist/RampsController.d.mts.map
+++ b/dist/RampsController.d.mts.map
@@ -1 +1 @@
-{"version":3,"file":"RampsController.d.mts","sourceRoot":"","sources":["../src/RampsController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"RampsController.d.mts","sourceRoot":"","sources":["../src/RampsController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/RampsController.mjs b/dist/RampsController.mjs
index db01dffcc763d6abadfb528b9f4d433f83f0afa3..fd7a809185c288efa52f6cb84b3f23353ccea483 100644
--- a/dist/RampsController.mjs
+++ b/dist/RampsController.mjs
@@ -448,7 +448,8 @@ export class RampsController extends BaseController {
      *
      * @param region - The region code (e.g., "us", "fr", "us-ny"). If not provided, uses the user's region from controller state.
      * @param action - The ramp action type ('buy' or 'sell').
-     * @param options - Options for cache behavior.
+     * @param options - Options for cache behavior and query filters.
+     * @param options.provider - Provider ID(s) to filter by.
      * @returns The tokens response containing topTokens and allTokens.
      */
     async getTokens(region, action = 'buy', options) {
@@ -457,9 +458,15 @@ export class RampsController extends BaseController {
             throw new Error('Region is required. Either provide a region parameter or ensure userRegion is set in controller state.');
         }
         const normalizedRegion = regionToUse.toLowerCase().trim();
-        const cacheKey = createCacheKey('getTokens', [normalizedRegion, action]);
+        const cacheKey = createCacheKey('getTokens', [
+            normalizedRegion,
+            action,
+            options?.provider,
+        ]);
         const tokens = await this.executeRequest(cacheKey, async () => {
-            return this.messenger.call('RampsService:getTokens', normalizedRegion, action);
+            return this.messenger.call('RampsService:getTokens', normalizedRegion, action, {
+                provider: options?.provider,
+            });
         }, options);
         this.update((state) => {
             const userRegionCode = state.userRegion?.regionCode;
@@ -510,6 +517,66 @@ export class RampsController extends BaseController {
         });
         return { providers };
     }
+    // ============================================================
+    // Sync Trigger Methods
+    // These fire-and-forget methods are for use in React effects.
+    // Errors are stored in state and available via selectors.
+    // ============================================================
+    /**
+     * Triggers a user region update without throwing.
+     *
+     * @param options - Options for cache behavior.
+     */
+    triggerUpdateUserRegion(options) {
+        this.updateUserRegion(options).catch(() => {
+            // Error stored in state
+        });
+    }
+    /**
+     * Triggers setting the user region without throwing.
+     *
+     * @param region - The region code to set (e.g., "US-CA").
+     * @param options - Options for cache behavior.
+     */
+    triggerSetUserRegion(region, options) {
+        this.setUserRegion(region, options).catch(() => {
+            // Error stored in state
+        });
+    }
+    /**
+     * Triggers fetching countries without throwing.
+     *
+     * @param action - The ramp action type ('buy' or 'sell').
+     * @param options - Options for cache behavior.
+     */
+    triggerGetCountries(action = 'buy', options) {
+        this.getCountries(action, options).catch(() => {
+            // Error stored in state
+        });
+    }
+    /**
+     * Triggers fetching tokens without throwing.
+     *
+     * @param region - The region code. If not provided, uses userRegion from state.
+     * @param action - The ramp action type ('buy' or 'sell').
+     * @param options - Options for cache behavior.
+     */
+    triggerGetTokens(region, action = 'buy', options) {
+        this.getTokens(region, action, options).catch(() => {
+            // Error stored in state
+        });
+    }
+    /**
+     * Triggers fetching providers without throwing.
+     *
+     * @param region - The region code. If not provided, uses userRegion from state.
+     * @param options - Options for cache behavior and query filters.
+     */
+    triggerGetProviders(region, options) {
+        this.getProviders(region, options).catch(() => {
+            // Error stored in state
+        });
+    }
 }
 _RampsController_requestCacheTTL = new WeakMap(), _RampsController_requestCacheMaxSize = new WeakMap(), _RampsController_pendingRequests = new WeakMap(), _RampsController_instances = new WeakSet(), _RampsController_removeRequestState = function _RampsController_removeRequestState(cacheKey) {
     this.update((state) => {
diff --git a/dist/RampsController.mjs.map b/dist/RampsController.mjs.map
index c2272242df7de0a7d7d5b77629af68e7cd86a8b4..d0f04c35fc20599c7a1e63b7728d91e59ef86bef 100644
--- a/dist/RampsController.mjs.map
+++ b/dist/RampsController.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"RampsController.mjs","sourceRoot":"","sources":["../src/RampsController.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n  StateMetadata,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport type { Messenger } from '@metamask/messenger';\nimport type { Json } from '@metamask/utils';\n\nimport type { Country, TokensResponse, Provider, State } from './RampsService';\nimport type {\n  RampsServiceGetGeolocationAction,\n  RampsServiceGetCountriesAction,\n  RampsServiceGetTokensAction,\n  RampsServiceGetProvidersAction,\n} from './RampsService-method-action-types';\nimport type {\n  RequestCache as RequestCacheType,\n  RequestState,\n  ExecuteRequestOptions,\n  PendingRequest,\n} from './RequestCache';\nimport {\n  DEFAULT_REQUEST_CACHE_TTL,\n  DEFAULT_REQUEST_CACHE_MAX_SIZE,\n  createCacheKey,\n  isCacheExpired,\n  createLoadingState,\n  createSuccessState,\n  createErrorState,\n} from './RequestCache';\n\n// === GENERAL ===\n\n/**\n * The name of the {@link RampsController}, used to namespace the\n * controller's actions and events and to namespace the controller's state data\n * when composed with other controllers.\n */\nexport const controllerName = 'RampsController';\n\n// === STATE ===\n\n/**\n * Represents the user's selected region with full country and state objects.\n */\nexport type UserRegion = {\n  /**\n   * The country object for the selected region.\n   */\n  country: Country;\n  /**\n   * The state object if a state was selected, null if only country was selected.\n   */\n  state: State | null;\n  /**\n   * The region code string (e.g., \"us-ut\" or \"fr\") used for API calls.\n   */\n  regionCode: string;\n};\n\n/**\n * Describes the shape of the state object for {@link RampsController}.\n */\nexport type RampsControllerState = {\n  /**\n   * The user's selected region with full country and state objects.\n   * Initially set via geolocation fetch, but can be manually changed by the user.\n   * Once set (either via geolocation or manual selection), it will not be overwritten\n   * by subsequent geolocation fetches.\n   */\n  userRegion: UserRegion | null;\n  /**\n   * The user's preferred provider.\n   * Can be manually set by the user.\n   */\n  preferredProvider: Provider | null;\n  /**\n   * List of providers available for the current region.\n   */\n  providers: Provider[];\n  /**\n   * Tokens fetched for the current region and action.\n   * Contains topTokens and allTokens arrays.\n   */\n  tokens: TokensResponse | null;\n  /**\n   * Cache of request states, keyed by cache key.\n   * This stores loading, success, and error states for API requests.\n   */\n  requests: RequestCacheType;\n};\n\n/**\n * The metadata for each property in {@link RampsControllerState}.\n */\nconst rampsControllerMetadata = {\n  userRegion: {\n    persist: true,\n    includeInDebugSnapshot: true,\n    includeInStateLogs: true,\n    usedInUi: true,\n  },\n  preferredProvider: {\n    persist: true,\n    includeInDebugSnapshot: true,\n    includeInStateLogs: true,\n    usedInUi: true,\n  },\n  providers: {\n    persist: true,\n    includeInDebugSnapshot: true,\n    includeInStateLogs: true,\n    usedInUi: true,\n  },\n  tokens: {\n    persist: true,\n    includeInDebugSnapshot: true,\n    includeInStateLogs: true,\n    usedInUi: true,\n  },\n  requests: {\n    persist: false,\n    includeInDebugSnapshot: true,\n    includeInStateLogs: false,\n    usedInUi: true,\n  },\n} satisfies StateMetadata<RampsControllerState>;\n\n/**\n * Constructs the default {@link RampsController} state. This allows\n * consumers to provide a partial state object when initializing the controller\n * and also helps in constructing complete state objects for this controller in\n * tests.\n *\n * @returns The default {@link RampsController} state.\n */\nexport function getDefaultRampsControllerState(): RampsControllerState {\n  return {\n    userRegion: null,\n    preferredProvider: null,\n    providers: [],\n    tokens: null,\n    requests: {},\n  };\n}\n\n// === MESSENGER ===\n\n/**\n * Retrieves the state of the {@link RampsController}.\n */\nexport type RampsControllerGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  RampsControllerState\n>;\n\n/**\n * Actions that {@link RampsControllerMessenger} exposes to other consumers.\n */\nexport type RampsControllerActions = RampsControllerGetStateAction;\n\n/**\n * Actions from other messengers that {@link RampsController} calls.\n */\ntype AllowedActions =\n  | RampsServiceGetGeolocationAction\n  | RampsServiceGetCountriesAction\n  | RampsServiceGetTokensAction\n  | RampsServiceGetProvidersAction;\n\n/**\n * Published when the state of {@link RampsController} changes.\n */\nexport type RampsControllerStateChangeEvent = ControllerStateChangeEvent<\n  typeof controllerName,\n  RampsControllerState\n>;\n\n/**\n * Events that {@link RampsControllerMessenger} exposes to other consumers.\n */\nexport type RampsControllerEvents = RampsControllerStateChangeEvent;\n\n/**\n * Events from other messengers that {@link RampsController} subscribes to.\n */\ntype AllowedEvents = never;\n\n/**\n * The messenger restricted to actions and events accessed by\n * {@link RampsController}.\n */\nexport type RampsControllerMessenger = Messenger<\n  typeof controllerName,\n  RampsControllerActions | AllowedActions,\n  RampsControllerEvents | AllowedEvents\n>;\n\n/**\n * Configuration options for the RampsController.\n */\nexport type RampsControllerOptions = {\n  /** The messenger suited for this controller. */\n  messenger: RampsControllerMessenger;\n  /** The desired state with which to initialize this controller. */\n  state?: Partial<RampsControllerState>;\n  /** Time to live for cached requests in milliseconds. Defaults to 15 minutes. */\n  requestCacheTTL?: number;\n  /** Maximum number of entries in the request cache. Defaults to 250. */\n  requestCacheMaxSize?: number;\n};\n\n// === HELPER FUNCTIONS ===\n\n/**\n * Finds a country and state from a region code string.\n *\n * @param regionCode - The region code (e.g., \"us-ca\" or \"us\").\n * @param countries - Array of countries to search.\n * @returns UserRegion object with country and state, or null if not found.\n */\nfunction findRegionFromCode(\n  regionCode: string,\n  countries: Country[],\n): UserRegion | null {\n  const normalizedCode = regionCode.toLowerCase().trim();\n  const parts = normalizedCode.split('-');\n  const countryCode = parts[0];\n  const stateCode = parts[1];\n\n  const country = countries.find((countryItem) => {\n    if (countryItem.isoCode?.toLowerCase() === countryCode) {\n      return true;\n    }\n    if (countryItem.id) {\n      const id = countryItem.id.toLowerCase();\n      if (id.startsWith('/regions/')) {\n        const extractedCode = id.replace('/regions/', '').split('/')[0];\n        return extractedCode === countryCode;\n      }\n      return id === countryCode || id.endsWith(`/${countryCode}`);\n    }\n    return false;\n  });\n\n  if (!country) {\n    return null;\n  }\n\n  let state: State | null = null;\n  if (stateCode && country.states) {\n    state =\n      country.states.find((stateItem) => {\n        if (stateItem.stateId?.toLowerCase() === stateCode) {\n          return true;\n        }\n        if (stateItem.id) {\n          const stateId = stateItem.id.toLowerCase();\n          if (\n            stateId.includes(`-${stateCode}`) ||\n            stateId.endsWith(`/${stateCode}`)\n          ) {\n            return true;\n          }\n        }\n        return false;\n      }) ?? null;\n  }\n\n  return {\n    country,\n    state,\n    regionCode: normalizedCode,\n  };\n}\n\n// === CONTROLLER DEFINITION ===\n\n/**\n * Manages cryptocurrency on/off ramps functionality.\n */\nexport class RampsController extends BaseController<\n  typeof controllerName,\n  RampsControllerState,\n  RampsControllerMessenger\n> {\n  /**\n   * Default TTL for cached requests.\n   */\n  readonly #requestCacheTTL: number;\n\n  /**\n   * Maximum number of entries in the request cache.\n   */\n  readonly #requestCacheMaxSize: number;\n\n  /**\n   * Map of pending requests for deduplication.\n   * Key is the cache key, value is the pending request with abort controller.\n   */\n  readonly #pendingRequests: Map<string, PendingRequest> = new Map();\n\n  /**\n   * Constructs a new {@link RampsController}.\n   *\n   * @param args - The constructor arguments.\n   * @param args.messenger - The messenger suited for this controller.\n   * @param args.state - The desired state with which to initialize this\n   * controller. Missing properties will be filled in with defaults.\n   * @param args.requestCacheTTL - Time to live for cached requests in milliseconds.\n   * @param args.requestCacheMaxSize - Maximum number of entries in the request cache.\n   */\n  constructor({\n    messenger,\n    state = {},\n    requestCacheTTL = DEFAULT_REQUEST_CACHE_TTL,\n    requestCacheMaxSize = DEFAULT_REQUEST_CACHE_MAX_SIZE,\n  }: RampsControllerOptions) {\n    super({\n      messenger,\n      metadata: rampsControllerMetadata,\n      name: controllerName,\n      state: {\n        ...getDefaultRampsControllerState(),\n        ...state,\n        // Always reset requests cache on initialization (non-persisted)\n        requests: {},\n      },\n    });\n\n    this.#requestCacheTTL = requestCacheTTL;\n    this.#requestCacheMaxSize = requestCacheMaxSize;\n  }\n\n  /**\n   * Executes a request with caching and deduplication.\n   *\n   * If a request with the same cache key is already in flight, returns the\n   * existing promise. If valid cached data exists, returns it without making\n   * a new request.\n   *\n   * @param cacheKey - Unique identifier for this request.\n   * @param fetcher - Function that performs the actual fetch. Receives an AbortSignal.\n   * @param options - Options for cache behavior.\n   * @returns The result of the request.\n   */\n  async executeRequest<TResult>(\n    cacheKey: string,\n    fetcher: (signal: AbortSignal) => Promise<TResult>,\n    options?: ExecuteRequestOptions,\n  ): Promise<TResult> {\n    const ttl = options?.ttl ?? this.#requestCacheTTL;\n\n    // Check for existing pending request - join it instead of making a duplicate\n    const pending = this.#pendingRequests.get(cacheKey);\n    if (pending) {\n      return pending.promise as Promise<TResult>;\n    }\n\n    // Check cache validity (unless force refresh)\n    if (!options?.forceRefresh) {\n      const cached = this.state.requests[cacheKey];\n      if (cached && !isCacheExpired(cached, ttl)) {\n        return cached.data as TResult;\n      }\n    }\n\n    // Create abort controller for this request\n    const abortController = new AbortController();\n    const lastFetchedAt = Date.now();\n\n    // Update state to loading\n    this.#updateRequestState(cacheKey, createLoadingState());\n\n    // Create the fetch promise\n    const promise = (async (): Promise<TResult> => {\n      try {\n        const data = await fetcher(abortController.signal);\n\n        // Don't update state if aborted\n        if (abortController.signal.aborted) {\n          throw new Error('Request was aborted');\n        }\n\n        this.#updateRequestState(\n          cacheKey,\n          createSuccessState(data as Json, lastFetchedAt),\n        );\n        return data;\n      } catch (error) {\n        // Don't update state if aborted\n        if (abortController.signal.aborted) {\n          throw error;\n        }\n\n        const errorMessage = (error as Error)?.message;\n\n        this.#updateRequestState(\n          cacheKey,\n          createErrorState(errorMessage ?? 'Unknown error', lastFetchedAt),\n        );\n        throw error;\n      } finally {\n        // Only delete if this is still our entry (not replaced by a new request)\n        const currentPending = this.#pendingRequests.get(cacheKey);\n        if (currentPending?.abortController === abortController) {\n          this.#pendingRequests.delete(cacheKey);\n        }\n      }\n    })();\n\n    // Store pending request for deduplication\n    this.#pendingRequests.set(cacheKey, { promise, abortController });\n\n    return promise;\n  }\n\n  /**\n   * Aborts a pending request if one exists.\n   *\n   * @param cacheKey - The cache key of the request to abort.\n   * @returns True if a request was aborted.\n   */\n  abortRequest(cacheKey: string): boolean {\n    const pending = this.#pendingRequests.get(cacheKey);\n    if (pending) {\n      pending.abortController.abort();\n      this.#pendingRequests.delete(cacheKey);\n      this.#removeRequestState(cacheKey);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Removes a request state from the cache.\n   *\n   * @param cacheKey - The cache key to remove.\n   */\n  #removeRequestState(cacheKey: string): void {\n    this.update((state) => {\n      const requests = state.requests as unknown as Record<\n        string,\n        RequestState | undefined\n      >;\n      delete requests[cacheKey];\n    });\n  }\n\n  /**\n   * Gets the state of a specific cached request.\n   *\n   * @param cacheKey - The cache key to look up.\n   * @returns The request state, or undefined if not cached.\n   */\n  getRequestState(cacheKey: string): RequestState | undefined {\n    return this.state.requests[cacheKey];\n  }\n\n  /**\n   * Updates the state for a specific request.\n   *\n   * @param cacheKey - The cache key.\n   * @param requestState - The new state for the request.\n   */\n  #updateRequestState(cacheKey: string, requestState: RequestState): void {\n    const maxSize = this.#requestCacheMaxSize;\n\n    this.update((state) => {\n      const requests = state.requests as unknown as Record<\n        string,\n        RequestState | undefined\n      >;\n      requests[cacheKey] = requestState;\n\n      // Evict oldest entries if cache exceeds max size\n      const keys = Object.keys(requests);\n\n      if (keys.length > maxSize) {\n        // Sort by timestamp (oldest first)\n        const sortedKeys = keys.sort((a, b) => {\n          const aTime = requests[a]?.timestamp ?? 0;\n          const bTime = requests[b]?.timestamp ?? 0;\n          return aTime - bTime;\n        });\n\n        // Remove oldest entries until we're under the limit\n        const entriesToRemove = keys.length - maxSize;\n        for (let i = 0; i < entriesToRemove; i++) {\n          const keyToRemove = sortedKeys[i];\n          if (keyToRemove) {\n            delete requests[keyToRemove];\n          }\n        }\n      }\n    });\n  }\n\n  /**\n   * Updates the user's region by fetching geolocation.\n   * This method calls the RampsService to get the geolocation.\n   *\n   * @param options - Options for cache behavior.\n   * @returns The user region object.\n   */\n  async updateUserRegion(\n    options?: ExecuteRequestOptions,\n  ): Promise<UserRegion | null> {\n    // If a userRegion already exists and forceRefresh is not requested,\n    // return it immediately without fetching geolocation.\n    // This ensures that once a region is set (either via geolocation or manual selection),\n    // it will not be overwritten by subsequent geolocation fetches.\n    if (this.state.userRegion && !options?.forceRefresh) {\n      return this.state.userRegion;\n    }\n\n    // When forceRefresh is true, clear the existing region, tokens, and providers before fetching\n    if (options?.forceRefresh) {\n      this.update((state) => {\n        state.userRegion = null;\n        state.tokens = null;\n        state.providers = [];\n      });\n    }\n\n    const cacheKey = createCacheKey('updateUserRegion', []);\n\n    const regionCode = await this.executeRequest(\n      cacheKey,\n      async () => {\n        const result = await this.messenger.call('RampsService:getGeolocation');\n        return result;\n      },\n      options,\n    );\n\n    if (!regionCode) {\n      this.update((state) => {\n        state.userRegion = null;\n        state.tokens = null;\n        state.providers = [];\n      });\n      return null;\n    }\n\n    const normalizedRegion = regionCode.toLowerCase().trim();\n\n    try {\n      const countries = await this.getCountries('buy', options);\n      const userRegion = findRegionFromCode(normalizedRegion, countries);\n\n      if (userRegion) {\n        this.update((state) => {\n          const regionChanged =\n            state.userRegion?.regionCode !== userRegion.regionCode;\n          state.userRegion = userRegion;\n          // Clear tokens and providers when region changes\n          if (regionChanged) {\n            state.tokens = null;\n            state.providers = [];\n          }\n        });\n\n        // Fetch providers for the new region\n        if (userRegion.regionCode) {\n          try {\n            await this.getProviders(userRegion.regionCode, options);\n          } catch {\n            // Provider fetch failed - error state will be available via selectors\n          }\n        }\n\n        return userRegion;\n      }\n\n      // Region not found in countries data\n      this.update((state) => {\n        state.userRegion = null;\n        state.tokens = null;\n        state.providers = [];\n      });\n\n      return null;\n    } catch {\n      // If countries fetch fails, we can't create a valid UserRegion\n      // Return null to indicate we don't have valid country data\n      this.update((state) => {\n        state.userRegion = null;\n        state.tokens = null;\n        state.providers = [];\n      });\n\n      return null;\n    }\n  }\n\n  /**\n   * Sets the user's region manually (without fetching geolocation).\n   * This allows users to override the detected region.\n   *\n   * @param region - The region code to set (e.g., \"US-CA\").\n   * @param options - Options for cache behavior.\n   * @returns The user region object.\n   */\n  async setUserRegion(\n    region: string,\n    options?: ExecuteRequestOptions,\n  ): Promise<UserRegion> {\n    const normalizedRegion = region.toLowerCase().trim();\n\n    try {\n      const countries = await this.getCountries('buy', options);\n      const userRegion = findRegionFromCode(normalizedRegion, countries);\n\n      if (userRegion) {\n        this.update((state) => {\n          state.userRegion = userRegion;\n          state.tokens = null;\n          state.providers = [];\n        });\n\n        // Fetch providers for the new region\n        try {\n          await this.getProviders(userRegion.regionCode, options);\n        } catch {\n          // Provider fetch failed - error state will be available via selectors\n        }\n\n        return userRegion;\n      }\n\n      // Region not found in countries data\n      this.update((state) => {\n        state.userRegion = null;\n        state.tokens = null;\n        state.providers = [];\n      });\n      throw new Error(\n        `Region \"${normalizedRegion}\" not found in countries data. Cannot set user region without valid country information.`,\n      );\n    } catch (error) {\n      // If the error is \"not found\", re-throw it\n      // Otherwise, it's from countries fetch failure\n      if (error instanceof Error && error.message.includes('not found')) {\n        throw error;\n      }\n      // Countries fetch failed\n      this.update((state) => {\n        state.userRegion = null;\n        state.tokens = null;\n        state.providers = [];\n      });\n      throw new Error(\n        'Failed to fetch countries data. Cannot set user region without valid country information.',\n      );\n    }\n  }\n\n  /**\n   * Sets the user's preferred provider.\n   * This allows users to set their preferred ramp provider.\n   *\n   * @param provider - The provider object to set.\n   */\n  setPreferredProvider(provider: Provider | null): void {\n    this.update((state) => {\n      state.preferredProvider = provider;\n    });\n  }\n\n  /**\n   * Initializes the controller by fetching the user's region from geolocation.\n   * This should be called once at app startup to set up the initial region.\n   * After the region is set, tokens are fetched and saved to state.\n   *\n   * If a userRegion already exists (from persistence or manual selection),\n   * this method will skip geolocation fetch and only fetch tokens if needed.\n   *\n   * @param options - Options for cache behavior.\n   * @returns Promise that resolves when initialization is complete.\n   */\n  async init(options?: ExecuteRequestOptions): Promise<void> {\n    const userRegion = await this.updateUserRegion(options).catch(() => {\n      // User region fetch failed - error state will be available via selectors\n      return null;\n    });\n\n    if (userRegion) {\n      try {\n        await this.getTokens(userRegion.regionCode, 'buy', options);\n      } catch {\n        // Token fetch failed - error state will be available via selectors\n      }\n\n      try {\n        await this.getProviders(userRegion.regionCode, options);\n      } catch {\n        // Provider fetch failed - error state will be available via selectors\n      }\n    }\n  }\n\n  /**\n   * Fetches the list of supported countries for a given ramp action.\n   *\n   * @param action - The ramp action type ('buy' or 'sell').\n   * @param options - Options for cache behavior.\n   * @returns An array of countries.\n   */\n  async getCountries(\n    action: 'buy' | 'sell' = 'buy',\n    options?: ExecuteRequestOptions,\n  ): Promise<Country[]> {\n    const cacheKey = createCacheKey('getCountries', [action]);\n\n    return this.executeRequest(\n      cacheKey,\n      async () => {\n        return this.messenger.call('RampsService:getCountries', action);\n      },\n      options,\n    );\n  }\n\n  /**\n   * Fetches the list of available tokens for a given region and action.\n   * The tokens are saved in the controller state once fetched.\n   *\n   * @param region - The region code (e.g., \"us\", \"fr\", \"us-ny\"). If not provided, uses the user's region from controller state.\n   * @param action - The ramp action type ('buy' or 'sell').\n   * @param options - Options for cache behavior.\n   * @returns The tokens response containing topTokens and allTokens.\n   */\n  async getTokens(\n    region?: string,\n    action: 'buy' | 'sell' = 'buy',\n    options?: ExecuteRequestOptions,\n  ): Promise<TokensResponse> {\n    const regionToUse = region ?? this.state.userRegion?.regionCode;\n\n    if (!regionToUse) {\n      throw new Error(\n        'Region is required. Either provide a region parameter or ensure userRegion is set in controller state.',\n      );\n    }\n\n    const normalizedRegion = regionToUse.toLowerCase().trim();\n    const cacheKey = createCacheKey('getTokens', [normalizedRegion, action]);\n\n    const tokens = await this.executeRequest(\n      cacheKey,\n      async () => {\n        return this.messenger.call(\n          'RampsService:getTokens',\n          normalizedRegion,\n          action,\n        );\n      },\n      options,\n    );\n\n    this.update((state) => {\n      const userRegionCode = state.userRegion?.regionCode;\n\n      if (userRegionCode === undefined || userRegionCode === normalizedRegion) {\n        state.tokens = tokens;\n      }\n    });\n\n    return tokens;\n  }\n\n  /**\n   * Fetches the list of providers for a given region.\n   * The providers are saved in the controller state once fetched.\n   *\n   * @param region - The region code (e.g., \"us\", \"fr\", \"us-ny\"). If not provided, uses the user's region from controller state.\n   * @param options - Options for cache behavior and query filters.\n   * @param options.provider - Provider ID(s) to filter by.\n   * @param options.crypto - Crypto currency ID(s) to filter by.\n   * @param options.fiat - Fiat currency ID(s) to filter by.\n   * @param options.payments - Payment method ID(s) to filter by.\n   * @returns The providers response containing providers array.\n   */\n  async getProviders(\n    region?: string,\n    options?: ExecuteRequestOptions & {\n      provider?: string | string[];\n      crypto?: string | string[];\n      fiat?: string | string[];\n      payments?: string | string[];\n    },\n  ): Promise<{ providers: Provider[] }> {\n    const regionToUse = region ?? this.state.userRegion?.regionCode;\n\n    if (!regionToUse) {\n      throw new Error(\n        'Region is required. Either provide a region parameter or ensure userRegion is set in controller state.',\n      );\n    }\n\n    const normalizedRegion = regionToUse.toLowerCase().trim();\n    const cacheKey = createCacheKey('getProviders', [\n      normalizedRegion,\n      options?.provider,\n      options?.crypto,\n      options?.fiat,\n      options?.payments,\n    ]);\n\n    const { providers } = await this.executeRequest(\n      cacheKey,\n      async () => {\n        return this.messenger.call(\n          'RampsService:getProviders',\n          normalizedRegion,\n          {\n            provider: options?.provider,\n            crypto: options?.crypto,\n            fiat: options?.fiat,\n            payments: options?.payments,\n          },\n        );\n      },\n      options,\n    );\n\n    this.update((state) => {\n      const userRegionCode = state.userRegion?.regionCode;\n\n      if (userRegionCode === undefined || userRegionCode === normalizedRegion) {\n        state.providers = providers;\n      }\n    });\n\n    return { providers };\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"RampsController.mjs","sourceRoot":"","sources":["../src/RampsController.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n  StateMetadata,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport type { Messenger } from '@metamask/messenger';\nimport type { Json } from '@metamask/utils';\n\nimport type {\n  Country,\n  TokensResponse,\n  Provider,\n  State,\n  RampAction,\n} from './RampsService';\nimport type {\n  RampsServiceGetGeolocationAction,\n  RampsServiceGetCountriesAction,\n  RampsServiceGetTokensAction,\n  RampsServiceGetProvidersAction,\n} from './RampsService-method-action-types';\nimport type {\n  RequestCache as RequestCacheType,\n  RequestState,\n  ExecuteRequestOptions,\n  PendingRequest,\n} from './RequestCache';\nimport {\n  DEFAULT_REQUEST_CACHE_TTL,\n  DEFAULT_REQUEST_CACHE_MAX_SIZE,\n  createCacheKey,\n  isCacheExpired,\n  createLoadingState,\n  createSuccessState,\n  createErrorState,\n} from './RequestCache';\n\n// === GENERAL ===\n\n/**\n * The name of the {@link RampsController}, used to namespace the\n * controller's actions and events and to namespace the controller's state data\n * when composed with other controllers.\n */\nexport const controllerName = 'RampsController';\n\n// === STATE ===\n\n/**\n * Represents the user's selected region with full country and state objects.\n */\nexport type UserRegion = {\n  /**\n   * The country object for the selected region.\n   */\n  country: Country;\n  /**\n   * The state object if a state was selected, null if only country was selected.\n   */\n  state: State | null;\n  /**\n   * The region code string (e.g., \"us-ut\" or \"fr\") used for API calls.\n   */\n  regionCode: string;\n};\n\n/**\n * Describes the shape of the state object for {@link RampsController}.\n */\nexport type RampsControllerState = {\n  /**\n   * The user's selected region with full country and state objects.\n   * Initially set via geolocation fetch, but can be manually changed by the user.\n   * Once set (either via geolocation or manual selection), it will not be overwritten\n   * by subsequent geolocation fetches.\n   */\n  userRegion: UserRegion | null;\n  /**\n   * The user's preferred provider.\n   * Can be manually set by the user.\n   */\n  preferredProvider: Provider | null;\n  /**\n   * List of providers available for the current region.\n   */\n  providers: Provider[];\n  /**\n   * Tokens fetched for the current region and action.\n   * Contains topTokens and allTokens arrays.\n   */\n  tokens: TokensResponse | null;\n  /**\n   * Cache of request states, keyed by cache key.\n   * This stores loading, success, and error states for API requests.\n   */\n  requests: RequestCacheType;\n};\n\n/**\n * The metadata for each property in {@link RampsControllerState}.\n */\nconst rampsControllerMetadata = {\n  userRegion: {\n    persist: true,\n    includeInDebugSnapshot: true,\n    includeInStateLogs: true,\n    usedInUi: true,\n  },\n  preferredProvider: {\n    persist: true,\n    includeInDebugSnapshot: true,\n    includeInStateLogs: true,\n    usedInUi: true,\n  },\n  providers: {\n    persist: true,\n    includeInDebugSnapshot: true,\n    includeInStateLogs: true,\n    usedInUi: true,\n  },\n  tokens: {\n    persist: true,\n    includeInDebugSnapshot: true,\n    includeInStateLogs: true,\n    usedInUi: true,\n  },\n  requests: {\n    persist: false,\n    includeInDebugSnapshot: true,\n    includeInStateLogs: false,\n    usedInUi: true,\n  },\n} satisfies StateMetadata<RampsControllerState>;\n\n/**\n * Constructs the default {@link RampsController} state. This allows\n * consumers to provide a partial state object when initializing the controller\n * and also helps in constructing complete state objects for this controller in\n * tests.\n *\n * @returns The default {@link RampsController} state.\n */\nexport function getDefaultRampsControllerState(): RampsControllerState {\n  return {\n    userRegion: null,\n    preferredProvider: null,\n    providers: [],\n    tokens: null,\n    requests: {},\n  };\n}\n\n// === MESSENGER ===\n\n/**\n * Retrieves the state of the {@link RampsController}.\n */\nexport type RampsControllerGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  RampsControllerState\n>;\n\n/**\n * Actions that {@link RampsControllerMessenger} exposes to other consumers.\n */\nexport type RampsControllerActions = RampsControllerGetStateAction;\n\n/**\n * Actions from other messengers that {@link RampsController} calls.\n */\ntype AllowedActions =\n  | RampsServiceGetGeolocationAction\n  | RampsServiceGetCountriesAction\n  | RampsServiceGetTokensAction\n  | RampsServiceGetProvidersAction;\n\n/**\n * Published when the state of {@link RampsController} changes.\n */\nexport type RampsControllerStateChangeEvent = ControllerStateChangeEvent<\n  typeof controllerName,\n  RampsControllerState\n>;\n\n/**\n * Events that {@link RampsControllerMessenger} exposes to other consumers.\n */\nexport type RampsControllerEvents = RampsControllerStateChangeEvent;\n\n/**\n * Events from other messengers that {@link RampsController} subscribes to.\n */\ntype AllowedEvents = never;\n\n/**\n * The messenger restricted to actions and events accessed by\n * {@link RampsController}.\n */\nexport type RampsControllerMessenger = Messenger<\n  typeof controllerName,\n  RampsControllerActions | AllowedActions,\n  RampsControllerEvents | AllowedEvents\n>;\n\n/**\n * Configuration options for the RampsController.\n */\nexport type RampsControllerOptions = {\n  /** The messenger suited for this controller. */\n  messenger: RampsControllerMessenger;\n  /** The desired state with which to initialize this controller. */\n  state?: Partial<RampsControllerState>;\n  /** Time to live for cached requests in milliseconds. Defaults to 15 minutes. */\n  requestCacheTTL?: number;\n  /** Maximum number of entries in the request cache. Defaults to 250. */\n  requestCacheMaxSize?: number;\n};\n\n// === HELPER FUNCTIONS ===\n\n/**\n * Finds a country and state from a region code string.\n *\n * @param regionCode - The region code (e.g., \"us-ca\" or \"us\").\n * @param countries - Array of countries to search.\n * @returns UserRegion object with country and state, or null if not found.\n */\nfunction findRegionFromCode(\n  regionCode: string,\n  countries: Country[],\n): UserRegion | null {\n  const normalizedCode = regionCode.toLowerCase().trim();\n  const parts = normalizedCode.split('-');\n  const countryCode = parts[0];\n  const stateCode = parts[1];\n\n  const country = countries.find((countryItem) => {\n    if (countryItem.isoCode?.toLowerCase() === countryCode) {\n      return true;\n    }\n    if (countryItem.id) {\n      const id = countryItem.id.toLowerCase();\n      if (id.startsWith('/regions/')) {\n        const extractedCode = id.replace('/regions/', '').split('/')[0];\n        return extractedCode === countryCode;\n      }\n      return id === countryCode || id.endsWith(`/${countryCode}`);\n    }\n    return false;\n  });\n\n  if (!country) {\n    return null;\n  }\n\n  let state: State | null = null;\n  if (stateCode && country.states) {\n    state =\n      country.states.find((stateItem) => {\n        if (stateItem.stateId?.toLowerCase() === stateCode) {\n          return true;\n        }\n        if (stateItem.id) {\n          const stateId = stateItem.id.toLowerCase();\n          if (\n            stateId.includes(`-${stateCode}`) ||\n            stateId.endsWith(`/${stateCode}`)\n          ) {\n            return true;\n          }\n        }\n        return false;\n      }) ?? null;\n  }\n\n  return {\n    country,\n    state,\n    regionCode: normalizedCode,\n  };\n}\n\n// === CONTROLLER DEFINITION ===\n\n/**\n * Manages cryptocurrency on/off ramps functionality.\n */\nexport class RampsController extends BaseController<\n  typeof controllerName,\n  RampsControllerState,\n  RampsControllerMessenger\n> {\n  /**\n   * Default TTL for cached requests.\n   */\n  readonly #requestCacheTTL: number;\n\n  /**\n   * Maximum number of entries in the request cache.\n   */\n  readonly #requestCacheMaxSize: number;\n\n  /**\n   * Map of pending requests for deduplication.\n   * Key is the cache key, value is the pending request with abort controller.\n   */\n  readonly #pendingRequests: Map<string, PendingRequest> = new Map();\n\n  /**\n   * Constructs a new {@link RampsController}.\n   *\n   * @param args - The constructor arguments.\n   * @param args.messenger - The messenger suited for this controller.\n   * @param args.state - The desired state with which to initialize this\n   * controller. Missing properties will be filled in with defaults.\n   * @param args.requestCacheTTL - Time to live for cached requests in milliseconds.\n   * @param args.requestCacheMaxSize - Maximum number of entries in the request cache.\n   */\n  constructor({\n    messenger,\n    state = {},\n    requestCacheTTL = DEFAULT_REQUEST_CACHE_TTL,\n    requestCacheMaxSize = DEFAULT_REQUEST_CACHE_MAX_SIZE,\n  }: RampsControllerOptions) {\n    super({\n      messenger,\n      metadata: rampsControllerMetadata,\n      name: controllerName,\n      state: {\n        ...getDefaultRampsControllerState(),\n        ...state,\n        // Always reset requests cache on initialization (non-persisted)\n        requests: {},\n      },\n    });\n\n    this.#requestCacheTTL = requestCacheTTL;\n    this.#requestCacheMaxSize = requestCacheMaxSize;\n  }\n\n  /**\n   * Executes a request with caching and deduplication.\n   *\n   * If a request with the same cache key is already in flight, returns the\n   * existing promise. If valid cached data exists, returns it without making\n   * a new request.\n   *\n   * @param cacheKey - Unique identifier for this request.\n   * @param fetcher - Function that performs the actual fetch. Receives an AbortSignal.\n   * @param options - Options for cache behavior.\n   * @returns The result of the request.\n   */\n  async executeRequest<TResult>(\n    cacheKey: string,\n    fetcher: (signal: AbortSignal) => Promise<TResult>,\n    options?: ExecuteRequestOptions,\n  ): Promise<TResult> {\n    const ttl = options?.ttl ?? this.#requestCacheTTL;\n\n    // Check for existing pending request - join it instead of making a duplicate\n    const pending = this.#pendingRequests.get(cacheKey);\n    if (pending) {\n      return pending.promise as Promise<TResult>;\n    }\n\n    // Check cache validity (unless force refresh)\n    if (!options?.forceRefresh) {\n      const cached = this.state.requests[cacheKey];\n      if (cached && !isCacheExpired(cached, ttl)) {\n        return cached.data as TResult;\n      }\n    }\n\n    // Create abort controller for this request\n    const abortController = new AbortController();\n    const lastFetchedAt = Date.now();\n\n    // Update state to loading\n    this.#updateRequestState(cacheKey, createLoadingState());\n\n    // Create the fetch promise\n    const promise = (async (): Promise<TResult> => {\n      try {\n        const data = await fetcher(abortController.signal);\n\n        // Don't update state if aborted\n        if (abortController.signal.aborted) {\n          throw new Error('Request was aborted');\n        }\n\n        this.#updateRequestState(\n          cacheKey,\n          createSuccessState(data as Json, lastFetchedAt),\n        );\n        return data;\n      } catch (error) {\n        // Don't update state if aborted\n        if (abortController.signal.aborted) {\n          throw error;\n        }\n\n        const errorMessage = (error as Error)?.message;\n\n        this.#updateRequestState(\n          cacheKey,\n          createErrorState(errorMessage ?? 'Unknown error', lastFetchedAt),\n        );\n        throw error;\n      } finally {\n        // Only delete if this is still our entry (not replaced by a new request)\n        const currentPending = this.#pendingRequests.get(cacheKey);\n        if (currentPending?.abortController === abortController) {\n          this.#pendingRequests.delete(cacheKey);\n        }\n      }\n    })();\n\n    // Store pending request for deduplication\n    this.#pendingRequests.set(cacheKey, { promise, abortController });\n\n    return promise;\n  }\n\n  /**\n   * Aborts a pending request if one exists.\n   *\n   * @param cacheKey - The cache key of the request to abort.\n   * @returns True if a request was aborted.\n   */\n  abortRequest(cacheKey: string): boolean {\n    const pending = this.#pendingRequests.get(cacheKey);\n    if (pending) {\n      pending.abortController.abort();\n      this.#pendingRequests.delete(cacheKey);\n      this.#removeRequestState(cacheKey);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Removes a request state from the cache.\n   *\n   * @param cacheKey - The cache key to remove.\n   */\n  #removeRequestState(cacheKey: string): void {\n    this.update((state) => {\n      const requests = state.requests as unknown as Record<\n        string,\n        RequestState | undefined\n      >;\n      delete requests[cacheKey];\n    });\n  }\n\n  /**\n   * Gets the state of a specific cached request.\n   *\n   * @param cacheKey - The cache key to look up.\n   * @returns The request state, or undefined if not cached.\n   */\n  getRequestState(cacheKey: string): RequestState | undefined {\n    return this.state.requests[cacheKey];\n  }\n\n  /**\n   * Updates the state for a specific request.\n   *\n   * @param cacheKey - The cache key.\n   * @param requestState - The new state for the request.\n   */\n  #updateRequestState(cacheKey: string, requestState: RequestState): void {\n    const maxSize = this.#requestCacheMaxSize;\n\n    this.update((state) => {\n      const requests = state.requests as unknown as Record<\n        string,\n        RequestState | undefined\n      >;\n      requests[cacheKey] = requestState;\n\n      // Evict oldest entries if cache exceeds max size\n      const keys = Object.keys(requests);\n\n      if (keys.length > maxSize) {\n        // Sort by timestamp (oldest first)\n        const sortedKeys = keys.sort((a, b) => {\n          const aTime = requests[a]?.timestamp ?? 0;\n          const bTime = requests[b]?.timestamp ?? 0;\n          return aTime - bTime;\n        });\n\n        // Remove oldest entries until we're under the limit\n        const entriesToRemove = keys.length - maxSize;\n        for (let i = 0; i < entriesToRemove; i++) {\n          const keyToRemove = sortedKeys[i];\n          if (keyToRemove) {\n            delete requests[keyToRemove];\n          }\n        }\n      }\n    });\n  }\n\n  /**\n   * Updates the user's region by fetching geolocation.\n   * This method calls the RampsService to get the geolocation.\n   *\n   * @param options - Options for cache behavior.\n   * @returns The user region object.\n   */\n  async updateUserRegion(\n    options?: ExecuteRequestOptions,\n  ): Promise<UserRegion | null> {\n    // If a userRegion already exists and forceRefresh is not requested,\n    // return it immediately without fetching geolocation.\n    // This ensures that once a region is set (either via geolocation or manual selection),\n    // it will not be overwritten by subsequent geolocation fetches.\n    if (this.state.userRegion && !options?.forceRefresh) {\n      return this.state.userRegion;\n    }\n\n    // When forceRefresh is true, clear the existing region, tokens, and providers before fetching\n    if (options?.forceRefresh) {\n      this.update((state) => {\n        state.userRegion = null;\n        state.tokens = null;\n        state.providers = [];\n      });\n    }\n\n    const cacheKey = createCacheKey('updateUserRegion', []);\n\n    const regionCode = await this.executeRequest(\n      cacheKey,\n      async () => {\n        const result = await this.messenger.call('RampsService:getGeolocation');\n        return result;\n      },\n      options,\n    );\n\n    if (!regionCode) {\n      this.update((state) => {\n        state.userRegion = null;\n        state.tokens = null;\n        state.providers = [];\n      });\n      return null;\n    }\n\n    const normalizedRegion = regionCode.toLowerCase().trim();\n\n    try {\n      const countries = await this.getCountries('buy', options);\n      const userRegion = findRegionFromCode(normalizedRegion, countries);\n\n      if (userRegion) {\n        this.update((state) => {\n          const regionChanged =\n            state.userRegion?.regionCode !== userRegion.regionCode;\n          state.userRegion = userRegion;\n          // Clear tokens and providers when region changes\n          if (regionChanged) {\n            state.tokens = null;\n            state.providers = [];\n          }\n        });\n\n        // Fetch providers for the new region\n        if (userRegion.regionCode) {\n          try {\n            await this.getProviders(userRegion.regionCode, options);\n          } catch {\n            // Provider fetch failed - error state will be available via selectors\n          }\n        }\n\n        return userRegion;\n      }\n\n      // Region not found in countries data\n      this.update((state) => {\n        state.userRegion = null;\n        state.tokens = null;\n        state.providers = [];\n      });\n\n      return null;\n    } catch {\n      // If countries fetch fails, we can't create a valid UserRegion\n      // Return null to indicate we don't have valid country data\n      this.update((state) => {\n        state.userRegion = null;\n        state.tokens = null;\n        state.providers = [];\n      });\n\n      return null;\n    }\n  }\n\n  /**\n   * Sets the user's region manually (without fetching geolocation).\n   * This allows users to override the detected region.\n   *\n   * @param region - The region code to set (e.g., \"US-CA\").\n   * @param options - Options for cache behavior.\n   * @returns The user region object.\n   */\n  async setUserRegion(\n    region: string,\n    options?: ExecuteRequestOptions,\n  ): Promise<UserRegion> {\n    const normalizedRegion = region.toLowerCase().trim();\n\n    try {\n      const countries = await this.getCountries('buy', options);\n      const userRegion = findRegionFromCode(normalizedRegion, countries);\n\n      if (userRegion) {\n        this.update((state) => {\n          state.userRegion = userRegion;\n          state.tokens = null;\n          state.providers = [];\n        });\n\n        // Fetch providers for the new region\n        try {\n          await this.getProviders(userRegion.regionCode, options);\n        } catch {\n          // Provider fetch failed - error state will be available via selectors\n        }\n\n        return userRegion;\n      }\n\n      // Region not found in countries data\n      this.update((state) => {\n        state.userRegion = null;\n        state.tokens = null;\n        state.providers = [];\n      });\n      throw new Error(\n        `Region \"${normalizedRegion}\" not found in countries data. Cannot set user region without valid country information.`,\n      );\n    } catch (error) {\n      // If the error is \"not found\", re-throw it\n      // Otherwise, it's from countries fetch failure\n      if (error instanceof Error && error.message.includes('not found')) {\n        throw error;\n      }\n      // Countries fetch failed\n      this.update((state) => {\n        state.userRegion = null;\n        state.tokens = null;\n        state.providers = [];\n      });\n      throw new Error(\n        'Failed to fetch countries data. Cannot set user region without valid country information.',\n      );\n    }\n  }\n\n  /**\n   * Sets the user's preferred provider.\n   * This allows users to set their preferred ramp provider.\n   *\n   * @param provider - The provider object to set.\n   */\n  setPreferredProvider(provider: Provider | null): void {\n    this.update((state) => {\n      state.preferredProvider = provider;\n    });\n  }\n\n  /**\n   * Initializes the controller by fetching the user's region from geolocation.\n   * This should be called once at app startup to set up the initial region.\n   * After the region is set, tokens are fetched and saved to state.\n   *\n   * If a userRegion already exists (from persistence or manual selection),\n   * this method will skip geolocation fetch and only fetch tokens if needed.\n   *\n   * @param options - Options for cache behavior.\n   * @returns Promise that resolves when initialization is complete.\n   */\n  async init(options?: ExecuteRequestOptions): Promise<void> {\n    const userRegion = await this.updateUserRegion(options).catch(() => {\n      // User region fetch failed - error state will be available via selectors\n      return null;\n    });\n\n    if (userRegion) {\n      try {\n        await this.getTokens(userRegion.regionCode, 'buy', options);\n      } catch {\n        // Token fetch failed - error state will be available via selectors\n      }\n\n      try {\n        await this.getProviders(userRegion.regionCode, options);\n      } catch {\n        // Provider fetch failed - error state will be available via selectors\n      }\n    }\n  }\n\n  /**\n   * Fetches the list of supported countries for a given ramp action.\n   *\n   * @param action - The ramp action type ('buy' or 'sell').\n   * @param options - Options for cache behavior.\n   * @returns An array of countries.\n   */\n  async getCountries(\n    action: RampAction = 'buy',\n    options?: ExecuteRequestOptions,\n  ): Promise<Country[]> {\n    const cacheKey = createCacheKey('getCountries', [action]);\n\n    return this.executeRequest(\n      cacheKey,\n      async () => {\n        return this.messenger.call('RampsService:getCountries', action);\n      },\n      options,\n    );\n  }\n\n  /**\n   * Fetches the list of available tokens for a given region and action.\n   * The tokens are saved in the controller state once fetched.\n   *\n   * @param region - The region code (e.g., \"us\", \"fr\", \"us-ny\"). If not provided, uses the user's region from controller state.\n   * @param action - The ramp action type ('buy' or 'sell').\n   * @param options - Options for cache behavior and query filters.\n   * @param options.provider - Provider ID(s) to filter by.\n   * @returns The tokens response containing topTokens and allTokens.\n   */\n  async getTokens(\n    region?: string,\n    action: RampAction = 'buy',\n    options?: ExecuteRequestOptions & {\n      provider?: string | string[];\n    },\n  ): Promise<TokensResponse> {\n    const regionToUse = region ?? this.state.userRegion?.regionCode;\n\n    if (!regionToUse) {\n      throw new Error(\n        'Region is required. Either provide a region parameter or ensure userRegion is set in controller state.',\n      );\n    }\n\n    const normalizedRegion = regionToUse.toLowerCase().trim();\n    const cacheKey = createCacheKey('getTokens', [\n      normalizedRegion,\n      action,\n      options?.provider,\n    ]);\n\n    const tokens = await this.executeRequest(\n      cacheKey,\n      async () => {\n        return this.messenger.call(\n          'RampsService:getTokens',\n          normalizedRegion,\n          action,\n          {\n            provider: options?.provider,\n          },\n        );\n      },\n      options,\n    );\n\n    this.update((state) => {\n      const userRegionCode = state.userRegion?.regionCode;\n\n      if (userRegionCode === undefined || userRegionCode === normalizedRegion) {\n        state.tokens = tokens;\n      }\n    });\n\n    return tokens;\n  }\n\n  /**\n   * Fetches the list of providers for a given region.\n   * The providers are saved in the controller state once fetched.\n   *\n   * @param region - The region code (e.g., \"us\", \"fr\", \"us-ny\"). If not provided, uses the user's region from controller state.\n   * @param options - Options for cache behavior and query filters.\n   * @param options.provider - Provider ID(s) to filter by.\n   * @param options.crypto - Crypto currency ID(s) to filter by.\n   * @param options.fiat - Fiat currency ID(s) to filter by.\n   * @param options.payments - Payment method ID(s) to filter by.\n   * @returns The providers response containing providers array.\n   */\n  async getProviders(\n    region?: string,\n    options?: ExecuteRequestOptions & {\n      provider?: string | string[];\n      crypto?: string | string[];\n      fiat?: string | string[];\n      payments?: string | string[];\n    },\n  ): Promise<{ providers: Provider[] }> {\n    const regionToUse = region ?? this.state.userRegion?.regionCode;\n\n    if (!regionToUse) {\n      throw new Error(\n        'Region is required. Either provide a region parameter or ensure userRegion is set in controller state.',\n      );\n    }\n\n    const normalizedRegion = regionToUse.toLowerCase().trim();\n    const cacheKey = createCacheKey('getProviders', [\n      normalizedRegion,\n      options?.provider,\n      options?.crypto,\n      options?.fiat,\n      options?.payments,\n    ]);\n\n    const { providers } = await this.executeRequest(\n      cacheKey,\n      async () => {\n        return this.messenger.call(\n          'RampsService:getProviders',\n          normalizedRegion,\n          {\n            provider: options?.provider,\n            crypto: options?.crypto,\n            fiat: options?.fiat,\n            payments: options?.payments,\n          },\n        );\n      },\n      options,\n    );\n\n    this.update((state) => {\n      const userRegionCode = state.userRegion?.regionCode;\n\n      if (userRegionCode === undefined || userRegionCode === normalizedRegion) {\n        state.providers = providers;\n      }\n    });\n\n    return { providers };\n  }\n\n  // ============================================================\n  // Sync Trigger Methods\n  // These fire-and-forget methods are for use in React effects.\n  // Errors are stored in state and available via selectors.\n  // ============================================================\n\n  /**\n   * Triggers a user region update without throwing.\n   *\n   * @param options - Options for cache behavior.\n   */\n  triggerUpdateUserRegion(options?: ExecuteRequestOptions): void {\n    this.updateUserRegion(options).catch(() => {\n      // Error stored in state\n    });\n  }\n\n  /**\n   * Triggers setting the user region without throwing.\n   *\n   * @param region - The region code to set (e.g., \"US-CA\").\n   * @param options - Options for cache behavior.\n   */\n  triggerSetUserRegion(region: string, options?: ExecuteRequestOptions): void {\n    this.setUserRegion(region, options).catch(() => {\n      // Error stored in state\n    });\n  }\n\n  /**\n   * Triggers fetching countries without throwing.\n   *\n   * @param action - The ramp action type ('buy' or 'sell').\n   * @param options - Options for cache behavior.\n   */\n  triggerGetCountries(\n    action: 'buy' | 'sell' = 'buy',\n    options?: ExecuteRequestOptions,\n  ): void {\n    this.getCountries(action, options).catch(() => {\n      // Error stored in state\n    });\n  }\n\n  /**\n   * Triggers fetching tokens without throwing.\n   *\n   * @param region - The region code. If not provided, uses userRegion from state.\n   * @param action - The ramp action type ('buy' or 'sell').\n   * @param options - Options for cache behavior.\n   */\n  triggerGetTokens(\n    region?: string,\n    action: 'buy' | 'sell' = 'buy',\n    options?: ExecuteRequestOptions,\n  ): void {\n    this.getTokens(region, action, options).catch(() => {\n      // Error stored in state\n    });\n  }\n\n  /**\n   * Triggers fetching providers without throwing.\n   *\n   * @param region - The region code. If not provided, uses userRegion from state.\n   * @param options - Options for cache behavior and query filters.\n   */\n  triggerGetProviders(\n    region?: string,\n    options?: ExecuteRequestOptions & {\n      provider?: string | string[];\n      crypto?: string | string[];\n      fiat?: string | string[];\n      payments?: string | string[];\n    },\n  ): void {\n    this.getProviders(region, options).catch(() => {\n      // Error stored in state\n    });\n  }\n}\n"]}
\ No newline at end of file
diff --git a/dist/RampsService-method-action-types.cjs.map b/dist/RampsService-method-action-types.cjs.map
index 799548b52c293ad9404288b2521a41c49ab7274a..8819901f2dd6d5f589eea65dd0d411a8701085a8 100644
--- a/dist/RampsService-method-action-types.cjs.map
+++ b/dist/RampsService-method-action-types.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"RampsService-method-action-types.cjs","sourceRoot":"","sources":["../src/RampsService-method-action-types.ts"],"names":[],"mappings":";AAAA;;;GAGG","sourcesContent":["/**\n * This file is auto generated by `scripts/generate-method-action-types.ts`.\n * Do not edit manually.\n */\n\nimport type { RampsService } from './RampsService';\n\n/**\n * Makes a request to the API in order to retrieve the user's geolocation\n * based on their IP address.\n *\n * @returns The user's country/region code (e.g., \"US-UT\" for Utah, USA).\n */\nexport type RampsServiceGetGeolocationAction = {\n  type: `RampsService:getGeolocation`;\n  handler: RampsService['getGeolocation'];\n};\n\n/**\n * Makes a request to the cached API to retrieve the list of supported countries.\n * Filters countries based on aggregator support (preserves OnRampSDK logic).\n *\n * @param action - The ramp action type ('buy' or 'sell').\n * @returns An array of countries filtered by aggregator support.\n */\nexport type RampsServiceGetCountriesAction = {\n  type: `RampsService:getCountries`;\n  handler: RampsService['getCountries'];\n};\n\n/**\n * Fetches the list of available tokens for a given region and action.\n *\n * @param region - The region code (e.g., \"us\", \"fr\", \"us-ny\").\n * @param action - The ramp action type ('buy' or 'sell').\n * @returns The tokens response containing topTokens and allTokens.\n */\nexport type RampsServiceGetTokensAction = {\n  type: `RampsService:getTokens`;\n  handler: RampsService['getTokens'];\n};\n\n/**\n * Fetches the list of providers for a given region.\n * Supports optional query filters: provider, crypto, fiat, payments.\n *\n * @param regionCode - The region code (e.g., \"us\", \"fr\", \"us-ny\").\n * @param options - Optional query parameters for filtering providers.\n * @param options.provider - Provider ID(s) to filter by.\n * @param options.crypto - Crypto currency ID(s) to filter by.\n * @param options.fiat - Fiat currency ID(s) to filter by.\n * @param options.payments - Payment method ID(s) to filter by.\n * @returns The providers response containing providers array.\n */\nexport type RampsServiceGetProvidersAction = {\n  type: `RampsService:getProviders`;\n  handler: RampsService['getProviders'];\n};\n\n/**\n * Union of all RampsService action types.\n */\nexport type RampsServiceMethodActions =\n  | RampsServiceGetGeolocationAction\n  | RampsServiceGetCountriesAction\n  | RampsServiceGetTokensAction\n  | RampsServiceGetProvidersAction;\n"]}
\ No newline at end of file
+{"version":3,"file":"RampsService-method-action-types.cjs","sourceRoot":"","sources":["../src/RampsService-method-action-types.ts"],"names":[],"mappings":";AAAA;;;GAGG","sourcesContent":["/**\n * This file is auto generated by `scripts/generate-method-action-types.ts`.\n * Do not edit manually.\n */\n\nimport type { RampsService } from './RampsService';\n\n/**\n * Makes a request to the API in order to retrieve the user's geolocation\n * based on their IP address.\n *\n * @returns The user's country/region code (e.g., \"US-UT\" for Utah, USA).\n */\nexport type RampsServiceGetGeolocationAction = {\n  type: `RampsService:getGeolocation`;\n  handler: RampsService['getGeolocation'];\n};\n\n/**\n * Makes a request to the cached API to retrieve the list of supported countries.\n * Filters countries based on aggregator support (preserves OnRampSDK logic).\n *\n * @param action - The ramp action type ('buy' or 'sell').\n * @returns An array of countries filtered by aggregator support.\n */\nexport type RampsServiceGetCountriesAction = {\n  type: `RampsService:getCountries`;\n  handler: RampsService['getCountries'];\n};\n\n/**\n * Fetches the list of available tokens for a given region and action.\n * Supports optional provider filter.\n *\n * @param region - The region code (e.g., \"us\", \"fr\", \"us-ny\").\n * @param action - The ramp action type ('buy' or 'sell').\n * @param options - Optional query parameters for filtering tokens.\n * @param options.provider - Provider ID(s) to filter by.\n * @returns The tokens response containing topTokens and allTokens.\n */\nexport type RampsServiceGetTokensAction = {\n  type: `RampsService:getTokens`;\n  handler: RampsService['getTokens'];\n};\n\n/**\n * Fetches the list of providers for a given region.\n * Supports optional query filters: provider, crypto, fiat, payments.\n *\n * @param regionCode - The region code (e.g., \"us\", \"fr\", \"us-ny\").\n * @param options - Optional query parameters for filtering providers.\n * @param options.provider - Provider ID(s) to filter by.\n * @param options.crypto - Crypto currency ID(s) to filter by.\n * @param options.fiat - Fiat currency ID(s) to filter by.\n * @param options.payments - Payment method ID(s) to filter by.\n * @returns The providers response containing providers array.\n */\nexport type RampsServiceGetProvidersAction = {\n  type: `RampsService:getProviders`;\n  handler: RampsService['getProviders'];\n};\n\n/**\n * Union of all RampsService action types.\n */\nexport type RampsServiceMethodActions =\n  | RampsServiceGetGeolocationAction\n  | RampsServiceGetCountriesAction\n  | RampsServiceGetTokensAction\n  | RampsServiceGetProvidersAction;\n"]}
\ No newline at end of file
diff --git a/dist/RampsService-method-action-types.d.cts b/dist/RampsService-method-action-types.d.cts
index a809a4d4f3b3b0f9918c7d26386793846554cf33..c45142e72711bd36ae06fbaef6ea499188560339 100644
--- a/dist/RampsService-method-action-types.d.cts
+++ b/dist/RampsService-method-action-types.d.cts
@@ -26,9 +26,12 @@ export type RampsServiceGetCountriesAction = {
 };
 /**
  * Fetches the list of available tokens for a given region and action.
+ * Supports optional provider filter.
  *
  * @param region - The region code (e.g., "us", "fr", "us-ny").
  * @param action - The ramp action type ('buy' or 'sell').
+ * @param options - Optional query parameters for filtering tokens.
+ * @param options.provider - Provider ID(s) to filter by.
  * @returns The tokens response containing topTokens and allTokens.
  */
 export type RampsServiceGetTokensAction = {
diff --git a/dist/RampsService-method-action-types.d.cts.map b/dist/RampsService-method-action-types.d.cts.map
index 133944f75bd38da47927fea06a3ab7387fb5d1d3..d9e8bb5401ad9bcd8013945b5283053db91f080d 100644
--- a/dist/RampsService-method-action-types.d.cts.map
+++ b/dist/RampsService-method-action-types.d.cts.map
@@ -1 +1 @@
-{"version":3,"file":"RampsService-method-action-types.d.cts","sourceRoot":"","sources":["../src/RampsService-method-action-types.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAEH,OAAO,KAAK,EAAE,YAAY,EAAE,2BAAuB;AAEnD;;;;;GAKG;AACH,MAAM,MAAM,gCAAgC,GAAG;IAC7C,IAAI,EAAE,6BAA6B,CAAC;IACpC,OAAO,EAAE,YAAY,CAAC,gBAAgB,CAAC,CAAC;CACzC,CAAC;AAEF;;;;;;GAMG;AACH,MAAM,MAAM,8BAA8B,GAAG;IAC3C,IAAI,EAAE,2BAA2B,CAAC;IAClC,OAAO,EAAE,YAAY,CAAC,cAAc,CAAC,CAAC;CACvC,CAAC;AAEF;;;;;;GAMG;AACH,MAAM,MAAM,2BAA2B,GAAG;IACxC,IAAI,EAAE,wBAAwB,CAAC;IAC/B,OAAO,EAAE,YAAY,CAAC,WAAW,CAAC,CAAC;CACpC,CAAC;AAEF;;;;;;;;;;;GAWG;AACH,MAAM,MAAM,8BAA8B,GAAG;IAC3C,IAAI,EAAE,2BAA2B,CAAC;IAClC,OAAO,EAAE,YAAY,CAAC,cAAc,CAAC,CAAC;CACvC,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,yBAAyB,GACjC,gCAAgC,GAChC,8BAA8B,GAC9B,2BAA2B,GAC3B,8BAA8B,CAAC"}
\ No newline at end of file
+{"version":3,"file":"RampsService-method-action-types.d.cts","sourceRoot":"","sources":["../src/RampsService-method-action-types.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAEH,OAAO,KAAK,EAAE,YAAY,EAAE,2BAAuB;AAEnD;;;;;GAKG;AACH,MAAM,MAAM,gCAAgC,GAAG;IAC7C,IAAI,EAAE,6BAA6B,CAAC;IACpC,OAAO,EAAE,YAAY,CAAC,gBAAgB,CAAC,CAAC;CACzC,CAAC;AAEF;;;;;;GAMG;AACH,MAAM,MAAM,8BAA8B,GAAG;IAC3C,IAAI,EAAE,2BAA2B,CAAC;IAClC,OAAO,EAAE,YAAY,CAAC,cAAc,CAAC,CAAC;CACvC,CAAC;AAEF;;;;;;;;;GASG;AACH,MAAM,MAAM,2BAA2B,GAAG;IACxC,IAAI,EAAE,wBAAwB,CAAC;IAC/B,OAAO,EAAE,YAAY,CAAC,WAAW,CAAC,CAAC;CACpC,CAAC;AAEF;;;;;;;;;;;GAWG;AACH,MAAM,MAAM,8BAA8B,GAAG;IAC3C,IAAI,EAAE,2BAA2B,CAAC;IAClC,OAAO,EAAE,YAAY,CAAC,cAAc,CAAC,CAAC;CACvC,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,yBAAyB,GACjC,gCAAgC,GAChC,8BAA8B,GAC9B,2BAA2B,GAC3B,8BAA8B,CAAC"}
\ No newline at end of file
diff --git a/dist/RampsService-method-action-types.d.mts b/dist/RampsService-method-action-types.d.mts
index 5bf7b6d0ab4d161f63c3a0f57499e37091203fb6..4db101610daf042c98e0a8f6567dccfa2302fc51 100644
--- a/dist/RampsService-method-action-types.d.mts
+++ b/dist/RampsService-method-action-types.d.mts
@@ -26,9 +26,12 @@ export type RampsServiceGetCountriesAction = {
 };
 /**
  * Fetches the list of available tokens for a given region and action.
+ * Supports optional provider filter.
  *
  * @param region - The region code (e.g., "us", "fr", "us-ny").
  * @param action - The ramp action type ('buy' or 'sell').
+ * @param options - Optional query parameters for filtering tokens.
+ * @param options.provider - Provider ID(s) to filter by.
  * @returns The tokens response containing topTokens and allTokens.
  */
 export type RampsServiceGetTokensAction = {
diff --git a/dist/RampsService-method-action-types.d.mts.map b/dist/RampsService-method-action-types.d.mts.map
index 07788cd682fa8b79e575e6df867d178c75bd410f..7e349cf467ee41b5d6d25ed9ea05716a6062f291 100644
--- a/dist/RampsService-method-action-types.d.mts.map
+++ b/dist/RampsService-method-action-types.d.mts.map
@@ -1 +1 @@
-{"version":3,"file":"RampsService-method-action-types.d.mts","sourceRoot":"","sources":["../src/RampsService-method-action-types.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAEH,OAAO,KAAK,EAAE,YAAY,EAAE,2BAAuB;AAEnD;;;;;GAKG;AACH,MAAM,MAAM,gCAAgC,GAAG;IAC7C,IAAI,EAAE,6BAA6B,CAAC;IACpC,OAAO,EAAE,YAAY,CAAC,gBAAgB,CAAC,CAAC;CACzC,CAAC;AAEF;;;;;;GAMG;AACH,MAAM,MAAM,8BAA8B,GAAG;IAC3C,IAAI,EAAE,2BAA2B,CAAC;IAClC,OAAO,EAAE,YAAY,CAAC,cAAc,CAAC,CAAC;CACvC,CAAC;AAEF;;;;;;GAMG;AACH,MAAM,MAAM,2BAA2B,GAAG;IACxC,IAAI,EAAE,wBAAwB,CAAC;IAC/B,OAAO,EAAE,YAAY,CAAC,WAAW,CAAC,CAAC;CACpC,CAAC;AAEF;;;;;;;;;;;GAWG;AACH,MAAM,MAAM,8BAA8B,GAAG;IAC3C,IAAI,EAAE,2BAA2B,CAAC;IAClC,OAAO,EAAE,YAAY,CAAC,cAAc,CAAC,CAAC;CACvC,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,yBAAyB,GACjC,gCAAgC,GAChC,8BAA8B,GAC9B,2BAA2B,GAC3B,8BAA8B,CAAC"}
\ No newline at end of file
+{"version":3,"file":"RampsService-method-action-types.d.mts","sourceRoot":"","sources":["../src/RampsService-method-action-types.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAEH,OAAO,KAAK,EAAE,YAAY,EAAE,2BAAuB;AAEnD;;;;;GAKG;AACH,MAAM,MAAM,gCAAgC,GAAG;IAC7C,IAAI,EAAE,6BAA6B,CAAC;IACpC,OAAO,EAAE,YAAY,CAAC,gBAAgB,CAAC,CAAC;CACzC,CAAC;AAEF;;;;;;GAMG;AACH,MAAM,MAAM,8BAA8B,GAAG;IAC3C,IAAI,EAAE,2BAA2B,CAAC;IAClC,OAAO,EAAE,YAAY,CAAC,cAAc,CAAC,CAAC;CACvC,CAAC;AAEF;;;;;;;;;GASG;AACH,MAAM,MAAM,2BAA2B,GAAG;IACxC,IAAI,EAAE,wBAAwB,CAAC;IAC/B,OAAO,EAAE,YAAY,CAAC,WAAW,CAAC,CAAC;CACpC,CAAC;AAEF;;;;;;;;;;;GAWG;AACH,MAAM,MAAM,8BAA8B,GAAG;IAC3C,IAAI,EAAE,2BAA2B,CAAC;IAClC,OAAO,EAAE,YAAY,CAAC,cAAc,CAAC,CAAC;CACvC,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,yBAAyB,GACjC,gCAAgC,GAChC,8BAA8B,GAC9B,2BAA2B,GAC3B,8BAA8B,CAAC"}
\ No newline at end of file
diff --git a/dist/RampsService-method-action-types.mjs.map b/dist/RampsService-method-action-types.mjs.map
index 183a1907787c345b278d27fc1cc1b25d23bb4875..9226c7de832a5d03c7ed3d3312c62837f4e68101 100644
--- a/dist/RampsService-method-action-types.mjs.map
+++ b/dist/RampsService-method-action-types.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"RampsService-method-action-types.mjs","sourceRoot":"","sources":["../src/RampsService-method-action-types.ts"],"names":[],"mappings":"AAAA;;;GAGG","sourcesContent":["/**\n * This file is auto generated by `scripts/generate-method-action-types.ts`.\n * Do not edit manually.\n */\n\nimport type { RampsService } from './RampsService';\n\n/**\n * Makes a request to the API in order to retrieve the user's geolocation\n * based on their IP address.\n *\n * @returns The user's country/region code (e.g., \"US-UT\" for Utah, USA).\n */\nexport type RampsServiceGetGeolocationAction = {\n  type: `RampsService:getGeolocation`;\n  handler: RampsService['getGeolocation'];\n};\n\n/**\n * Makes a request to the cached API to retrieve the list of supported countries.\n * Filters countries based on aggregator support (preserves OnRampSDK logic).\n *\n * @param action - The ramp action type ('buy' or 'sell').\n * @returns An array of countries filtered by aggregator support.\n */\nexport type RampsServiceGetCountriesAction = {\n  type: `RampsService:getCountries`;\n  handler: RampsService['getCountries'];\n};\n\n/**\n * Fetches the list of available tokens for a given region and action.\n *\n * @param region - The region code (e.g., \"us\", \"fr\", \"us-ny\").\n * @param action - The ramp action type ('buy' or 'sell').\n * @returns The tokens response containing topTokens and allTokens.\n */\nexport type RampsServiceGetTokensAction = {\n  type: `RampsService:getTokens`;\n  handler: RampsService['getTokens'];\n};\n\n/**\n * Fetches the list of providers for a given region.\n * Supports optional query filters: provider, crypto, fiat, payments.\n *\n * @param regionCode - The region code (e.g., \"us\", \"fr\", \"us-ny\").\n * @param options - Optional query parameters for filtering providers.\n * @param options.provider - Provider ID(s) to filter by.\n * @param options.crypto - Crypto currency ID(s) to filter by.\n * @param options.fiat - Fiat currency ID(s) to filter by.\n * @param options.payments - Payment method ID(s) to filter by.\n * @returns The providers response containing providers array.\n */\nexport type RampsServiceGetProvidersAction = {\n  type: `RampsService:getProviders`;\n  handler: RampsService['getProviders'];\n};\n\n/**\n * Union of all RampsService action types.\n */\nexport type RampsServiceMethodActions =\n  | RampsServiceGetGeolocationAction\n  | RampsServiceGetCountriesAction\n  | RampsServiceGetTokensAction\n  | RampsServiceGetProvidersAction;\n"]}
\ No newline at end of file
+{"version":3,"file":"RampsService-method-action-types.mjs","sourceRoot":"","sources":["../src/RampsService-method-action-types.ts"],"names":[],"mappings":"AAAA;;;GAGG","sourcesContent":["/**\n * This file is auto generated by `scripts/generate-method-action-types.ts`.\n * Do not edit manually.\n */\n\nimport type { RampsService } from './RampsService';\n\n/**\n * Makes a request to the API in order to retrieve the user's geolocation\n * based on their IP address.\n *\n * @returns The user's country/region code (e.g., \"US-UT\" for Utah, USA).\n */\nexport type RampsServiceGetGeolocationAction = {\n  type: `RampsService:getGeolocation`;\n  handler: RampsService['getGeolocation'];\n};\n\n/**\n * Makes a request to the cached API to retrieve the list of supported countries.\n * Filters countries based on aggregator support (preserves OnRampSDK logic).\n *\n * @param action - The ramp action type ('buy' or 'sell').\n * @returns An array of countries filtered by aggregator support.\n */\nexport type RampsServiceGetCountriesAction = {\n  type: `RampsService:getCountries`;\n  handler: RampsService['getCountries'];\n};\n\n/**\n * Fetches the list of available tokens for a given region and action.\n * Supports optional provider filter.\n *\n * @param region - The region code (e.g., \"us\", \"fr\", \"us-ny\").\n * @param action - The ramp action type ('buy' or 'sell').\n * @param options - Optional query parameters for filtering tokens.\n * @param options.provider - Provider ID(s) to filter by.\n * @returns The tokens response containing topTokens and allTokens.\n */\nexport type RampsServiceGetTokensAction = {\n  type: `RampsService:getTokens`;\n  handler: RampsService['getTokens'];\n};\n\n/**\n * Fetches the list of providers for a given region.\n * Supports optional query filters: provider, crypto, fiat, payments.\n *\n * @param regionCode - The region code (e.g., \"us\", \"fr\", \"us-ny\").\n * @param options - Optional query parameters for filtering providers.\n * @param options.provider - Provider ID(s) to filter by.\n * @param options.crypto - Crypto currency ID(s) to filter by.\n * @param options.fiat - Fiat currency ID(s) to filter by.\n * @param options.payments - Payment method ID(s) to filter by.\n * @returns The providers response containing providers array.\n */\nexport type RampsServiceGetProvidersAction = {\n  type: `RampsService:getProviders`;\n  handler: RampsService['getProviders'];\n};\n\n/**\n * Union of all RampsService action types.\n */\nexport type RampsServiceMethodActions =\n  | RampsServiceGetGeolocationAction\n  | RampsServiceGetCountriesAction\n  | RampsServiceGetTokensAction\n  | RampsServiceGetProvidersAction;\n"]}
\ No newline at end of file
diff --git a/dist/RampsService.cjs b/dist/RampsService.cjs
index f6bb3af132361342db66423ea2b1ca7f1b15bdc1..4b03dacea941c7869ce1f7a8a360d4c0146827b5 100644
--- a/dist/RampsService.cjs
+++ b/dist/RampsService.cjs
@@ -254,14 +254,31 @@ class RampsService {
     }
     /**
      * Fetches the list of available tokens for a given region and action.
+     * Supports optional provider filter.
      *
      * @param region - The region code (e.g., "us", "fr", "us-ny").
      * @param action - The ramp action type ('buy' or 'sell').
+     * @param options - Optional query parameters for filtering tokens.
+     * @param options.provider - Provider ID(s) to filter by.
      * @returns The tokens response containing topTokens and allTokens.
      */
-    async getTokens(region, action = 'buy') {
+    async getTokens(region, action = 'buy', options) {
         const normalizedRegion = region.toLowerCase().trim();
-        const response = await __classPrivateFieldGet(this, _RampsService_instances, "m", _RampsService_request).call(this, RampsApiService.Regions, `regions/${normalizedRegion}/tokens`, { action, responseType: 'json' });
+        const url = new URL(getApiPath(`regions/${normalizedRegion}/topTokens`), getBaseUrl(__classPrivateFieldGet(this, _RampsService_environment, "f"), RampsApiService.Regions));
+        __classPrivateFieldGet(this, _RampsService_instances, "m", _RampsService_addCommonParams).call(this, url, action);
+        if (options?.provider) {
+            const providerIds = Array.isArray(options.provider)
+                ? options.provider
+                : [options.provider];
+            providerIds.forEach((id) => url.searchParams.append('provider', id));
+        }
+        const response = await __classPrivateFieldGet(this, _RampsService_policy, "f").execute(async () => {
+            const fetchResponse = await __classPrivateFieldGet(this, _RampsService_fetch, "f").call(this, url);
+            if (!fetchResponse.ok) {
+                throw new controller_utils_1.HttpError(fetchResponse.status, `Fetching '${url.toString()}' failed with status '${fetchResponse.status}'`);
+            }
+            return fetchResponse.json();
+        });
         if (!response || typeof response !== 'object') {
             throw new Error('Malformed response received from tokens API');
         }
diff --git a/dist/RampsService.cjs.map b/dist/RampsService.cjs.map
index 5aeefe740ce44a39c84467b4bbce8cd5a10c2714..1581b7a97aabf4d2c08d9581f83e70054549b5fd 100644
--- a/dist/RampsService.cjs.map
+++ b/dist/RampsService.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"RampsService.cjs","sourceRoot":"","sources":["../src/RampsService.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  CreateServicePolicyOptions,\n  ServicePolicy,\n} from '@metamask/controller-utils';\nimport { createServicePolicy, HttpError } from '@metamask/controller-utils';\nimport type { Messenger } from '@metamask/messenger';\n\nimport type { RampsServiceMethodActions } from './RampsService-method-action-types';\nimport packageJson from '../package.json';\n\n/**\n * Represents phone number information for a country.\n */\nexport type CountryPhone = {\n  prefix: string;\n  placeholder: string;\n  template: string;\n};\n\n/**\n * Represents a state/province within a country.\n */\nexport type State = {\n  /**\n   * State identifier. Can be in path format (e.g., \"/regions/us-ut\") or ISO code format (e.g., \"us-ut\").\n   */\n  id?: string;\n  /**\n   * State name.\n   */\n  name?: string;\n  /**\n   * ISO state code (e.g., \"UT\", \"NY\").\n   */\n  stateId?: string;\n  /**\n   * Whether this state is supported for ramps.\n   */\n  supported?: boolean;\n  /**\n   * Whether this state is recommended.\n   */\n  recommended?: boolean;\n};\n\n/**\n * Represents a provider link.\n */\nexport type ProviderLink = {\n  name: string;\n  url: string;\n};\n\n/**\n * Represents provider logos.\n */\nexport type ProviderLogos = {\n  light: string;\n  dark: string;\n  height: number;\n  width: number;\n};\n\n/**\n * Represents a ramp provider.\n */\nexport type Provider = {\n  id: string;\n  name: string;\n  environmentType: string;\n  description: string;\n  hqAddress: string;\n  links: ProviderLink[];\n  logos: ProviderLogos;\n};\n\n/**\n * Represents a country returned from the regions/countries API.\n */\nexport type Country = {\n  /**\n   * ISO-2 country code (e.g., \"US\", \"GB\").\n   */\n  isoCode: string;\n  /**\n   * Country identifier. Can be in path format (e.g., \"/regions/us\") or ISO code format.\n   * If not provided, defaults to isoCode.\n   */\n  id?: string;\n  /**\n   * Country flag emoji or code.\n   */\n  flag: string;\n  /**\n   * Country name.\n   */\n  name: string;\n  /**\n   * Phone number information.\n   */\n  phone: CountryPhone;\n  /**\n   * Default currency code.\n   */\n  currency: string;\n  /**\n   * Whether this country is supported for ramps.\n   */\n  supported: boolean;\n  /**\n   * Whether this country is recommended.\n   */\n  recommended?: boolean;\n  /**\n   * Array of state objects.\n   */\n  states?: State[];\n  /**\n   * Default amount for ramps transactions.\n   */\n  defaultAmount?: number;\n  /**\n   * Quick amount options for ramps transactions.\n   */\n  quickAmounts?: number[];\n};\n\n/**\n * Represents a token returned from the regions/{region}/tokens API.\n */\nexport type RampsToken = {\n  /**\n   * The asset identifier in CAIP-19 format (e.g., \"eip155:1/erc20:0x...\").\n   */\n  assetId: string;\n  /**\n   * The chain identifier in CAIP-2 format (e.g., \"eip155:1\").\n   */\n  chainId: string;\n  /**\n   * Token name (e.g., \"USD Coin\").\n   */\n  name: string;\n  /**\n   * Token symbol (e.g., \"USDC\").\n   */\n  symbol: string;\n  /**\n   * Number of decimals for the token.\n   */\n  decimals: number;\n  /**\n   * URL to the token icon.\n   */\n  iconUrl: string;\n  /**\n   * Whether this token is supported.\n   */\n  tokenSupported: boolean;\n};\n\n/**\n * Response from the regions/{region}/tokens API.\n */\nexport type TokensResponse = {\n  /**\n   * Top/popular tokens for the region.\n   */\n  topTokens: RampsToken[];\n  /**\n   * All available tokens for the region.\n   */\n  allTokens: RampsToken[];\n};\n\n/**\n * The SDK version to send with API requests. (backwards-compatibility)\n */\nexport const RAMPS_SDK_VERSION = '2.1.6';\n\n// === GENERAL ===\n\n/**\n * The name of the {@link RampsService}, used to namespace the\n * service's actions and events.\n */\nexport const serviceName = 'RampsService';\n\n/**\n * The environment to use for API requests.\n */\nexport enum RampsEnvironment {\n  Production = 'production',\n  Staging = 'staging',\n  Development = 'development',\n}\n\n/**\n * The type of ramps API service.\n * Determines which base URL to use (cache vs standard).\n */\nexport enum RampsApiService {\n  Regions = 'regions',\n  Orders = 'orders',\n}\n\n// === MESSENGER ===\n\nconst MESSENGER_EXPOSED_METHODS = [\n  'getGeolocation',\n  'getCountries',\n  'getTokens',\n  'getProviders',\n] as const;\n\n/**\n * Actions that {@link RampsService} exposes to other consumers.\n */\nexport type RampsServiceActions = RampsServiceMethodActions;\n\n/**\n * Actions from other messengers that {@link RampsService} calls.\n */\ntype AllowedActions = never;\n\n/**\n * Events that {@link RampsService} exposes to other consumers.\n */\nexport type RampsServiceEvents = never;\n\n/**\n * Events from other messengers that {@link RampsService} subscribes to.\n */\ntype AllowedEvents = never;\n\n/**\n * The messenger which is restricted to actions and events accessed by\n * {@link RampsService}.\n */\nexport type RampsServiceMessenger = Messenger<\n  typeof serviceName,\n  RampsServiceActions | AllowedActions,\n  RampsServiceEvents | AllowedEvents\n>;\n\n// === SERVICE DEFINITION ===\n\n/**\n * Gets the base URL for API requests based on the environment and service type.\n * The Regions service uses a cache URL, while other services use the standard URL.\n *\n * @param environment - The environment to use.\n * @param service - The API service type (determines if cache URL is used).\n * @returns The base URL for API requests.\n */\nfunction getBaseUrl(\n  environment: RampsEnvironment,\n  service: RampsApiService,\n): string {\n  const cache = service === RampsApiService.Regions ? '-cache' : '';\n\n  switch (environment) {\n    case RampsEnvironment.Production:\n      return `https://on-ramp${cache}.api.cx.metamask.io`;\n    case RampsEnvironment.Staging:\n    case RampsEnvironment.Development:\n      return `https://on-ramp${cache}.uat-api.cx.metamask.io`;\n    default:\n      throw new Error(`Invalid environment: ${String(environment)}`);\n  }\n}\n\n/**\n * Constructs an API path with a version prefix.\n *\n * @param path - The API endpoint path.\n * @param version - The API version prefix. Defaults to 'v2'.\n * @returns The versioned API path.\n */\nfunction getApiPath(path: string, version: string = 'v2'): string {\n  return `${version}/${path}`;\n}\n\n/**\n * This service object is responsible for interacting with the Ramps API.\n *\n * @example\n *\n * ``` ts\n * import { Messenger } from '@metamask/messenger';\n * import type {\n *   RampsServiceActions,\n *   RampsServiceEvents,\n * } from '@metamask/ramps-controller';\n *\n * const rootMessenger = new Messenger<\n *   'Root',\n *   RampsServiceActions\n *   RampsServiceEvents\n * >({ namespace: 'Root' });\n * const rampsServiceMessenger = new Messenger<\n *   'RampsService',\n *   RampsServiceActions,\n *   RampsServiceEvents,\n *   typeof rootMessenger,\n * >({\n *   namespace: 'RampsService',\n *   parent: rootMessenger,\n * });\n * // Instantiate the service to register its actions on the messenger\n * new RampsService({\n *   messenger: rampsServiceMessenger,\n *   environment: RampsEnvironment.Production,\n *   context: 'mobile-ios',\n *   fetch,\n * });\n *\n * // Later...\n * // Get the user's geolocation\n * const geolocation = await rootMessenger.call(\n *   'RampsService:getGeolocation',\n * );\n * // ... Do something with the geolocation ...\n * ```\n */\nexport class RampsService {\n  /**\n   * The name of the service.\n   */\n  readonly name: typeof serviceName;\n\n  /**\n   * The messenger suited for this service.\n   */\n  readonly #messenger: ConstructorParameters<\n    typeof RampsService\n  >[0]['messenger'];\n\n  /**\n   * A function that can be used to make an HTTP request.\n   */\n  readonly #fetch: ConstructorParameters<typeof RampsService>[0]['fetch'];\n\n  /**\n   * The policy that wraps the request.\n   *\n   * @see {@link createServicePolicy}\n   */\n  readonly #policy: ServicePolicy;\n\n  /**\n   * The environment used for API requests.\n   */\n  readonly #environment: RampsEnvironment;\n\n  /**\n   * The context for API requests (e.g., 'mobile-ios', 'mobile-android').\n   */\n  readonly #context: string;\n\n  /**\n   * Constructs a new RampsService object.\n   *\n   * @param args - The constructor arguments.\n   * @param args.messenger - The messenger suited for this service.\n   * @param args.environment - The environment to use for API requests.\n   * @param args.context - The context for API requests (e.g., 'mobile-ios', 'mobile-android').\n   * @param args.fetch - A function that can be used to make an HTTP request. If\n   * your JavaScript environment supports `fetch` natively, you'll probably want\n   * to pass that; otherwise you can pass an equivalent (such as `fetch` via\n   * `node-fetch`).\n   * @param args.policyOptions - Options to pass to `createServicePolicy`, which\n   * is used to wrap each request. See {@link CreateServicePolicyOptions}.\n   */\n  constructor({\n    messenger,\n    environment = RampsEnvironment.Staging,\n    context,\n    fetch: fetchFunction,\n    policyOptions = {},\n  }: {\n    messenger: RampsServiceMessenger;\n    environment?: RampsEnvironment;\n    context: string;\n    fetch: typeof fetch;\n    policyOptions?: CreateServicePolicyOptions;\n  }) {\n    this.name = serviceName;\n    this.#messenger = messenger;\n    this.#fetch = fetchFunction;\n    this.#policy = createServicePolicy(policyOptions);\n    this.#environment = environment;\n    this.#context = context;\n\n    this.#messenger.registerMethodActionHandlers(\n      this,\n      MESSENGER_EXPOSED_METHODS,\n    );\n  }\n\n  /**\n   * Registers a handler that will be called after a request returns a non-500\n   * response, causing a retry. Primarily useful in tests where timers are being\n   * mocked.\n   *\n   * @param listener - The handler to be called.\n   * @returns An object that can be used to unregister the handler. See\n   * {@link CockatielEvent}.\n   * @see {@link createServicePolicy}\n   */\n  onRetry(\n    listener: Parameters<ServicePolicy['onRetry']>[0],\n  ): ReturnType<ServicePolicy['onRetry']> {\n    return this.#policy.onRetry(listener);\n  }\n\n  /**\n   * Registers a handler that will be called after a set number of retry rounds\n   * prove that requests to the API endpoint consistently return a 5xx response.\n   *\n   * @param listener - The handler to be called.\n   * @returns An object that can be used to unregister the handler. See\n   * {@link CockatielEvent}.\n   * @see {@link createServicePolicy}\n   */\n  onBreak(\n    listener: Parameters<ServicePolicy['onBreak']>[0],\n  ): ReturnType<ServicePolicy['onBreak']> {\n    return this.#policy.onBreak(listener);\n  }\n\n  /**\n   * Registers a handler that will be called under one of two circumstances:\n   *\n   * 1. After a set number of retries prove that requests to the API\n   * consistently result in one of the following failures:\n   *    1. A connection initiation error\n   *    2. A connection reset error\n   *    3. A timeout error\n   *    4. A non-JSON response\n   *    5. A 502, 503, or 504 response\n   * 2. After a successful request is made to the API, but the response takes\n   * longer than a set duration to return.\n   *\n   * @param listener - The handler to be called.\n   * @returns An object that can be used to unregister the handler. See\n   * {@link CockatielEvent}.\n   */\n  onDegraded(\n    listener: Parameters<ServicePolicy['onDegraded']>[0],\n  ): ReturnType<ServicePolicy['onDegraded']> {\n    return this.#policy.onDegraded(listener);\n  }\n\n  /**\n   * Adds common request parameters to a URL.\n   *\n   * @param url - The URL to add parameters to.\n   * @param action - The ramp action type (optional, not all endpoints require it).\n   */\n  #addCommonParams(url: URL, action?: 'buy' | 'sell'): void {\n    if (action) {\n      url.searchParams.set('action', action);\n    }\n    url.searchParams.set('sdk', RAMPS_SDK_VERSION);\n    url.searchParams.set('controller', packageJson.version);\n    url.searchParams.set('context', this.#context);\n  }\n\n  /**\n   * Makes an API request with retry policy and error handling.\n   *\n   * @param service - The API service type (determines base URL).\n   * @param path - The endpoint path.\n   * @param options - Request options.\n   * @param options.action - The ramp action type (optional).\n   * @param options.responseType - How to parse the response ('json' or 'text').\n   * @returns The parsed response data.\n   */\n  async #request<TResponse>(\n    service: RampsApiService,\n    path: string,\n    options: {\n      action?: 'buy' | 'sell';\n      responseType: 'json' | 'text';\n    },\n  ): Promise<TResponse> {\n    return this.#policy.execute(async () => {\n      const baseUrl = getBaseUrl(this.#environment, service);\n      const url = new URL(path, baseUrl);\n      this.#addCommonParams(url, options.action);\n\n      const response = await this.#fetch(url);\n      if (!response.ok) {\n        throw new HttpError(\n          response.status,\n          `Fetching '${url.toString()}' failed with status '${response.status}'`,\n        );\n      }\n\n      return options.responseType === 'json'\n        ? (response.json() as Promise<TResponse>)\n        : (response.text() as Promise<TResponse>);\n    });\n  }\n\n  /**\n   * Makes a request to the API in order to retrieve the user's geolocation\n   * based on their IP address.\n   *\n   * @returns The user's country/region code (e.g., \"US-UT\" for Utah, USA).\n   */\n  async getGeolocation(): Promise<string> {\n    const textResponse = await this.#request<string>(\n      RampsApiService.Orders,\n      'geolocation',\n      { responseType: 'text' },\n    );\n\n    const trimmedResponse = textResponse.trim();\n    if (trimmedResponse.length > 0) {\n      return trimmedResponse;\n    }\n\n    throw new Error('Malformed response received from geolocation API');\n  }\n\n  /**\n   * Makes a request to the cached API to retrieve the list of supported countries.\n   * Filters countries based on aggregator support (preserves OnRampSDK logic).\n   *\n   * @param action - The ramp action type ('buy' or 'sell').\n   * @returns An array of countries filtered by aggregator support.\n   */\n  async getCountries(action: 'buy' | 'sell' = 'buy'): Promise<Country[]> {\n    const countries = await this.#request<Country[]>(\n      RampsApiService.Regions,\n      getApiPath('regions/countries'),\n      { action, responseType: 'json' },\n    );\n\n    if (!Array.isArray(countries)) {\n      throw new Error('Malformed response received from countries API');\n    }\n\n    return countries.filter((country) => {\n      if (country.states && country.states.length > 0) {\n        const hasSupportedState = country.states.some(\n          (state) => state.supported !== false,\n        );\n        return country.supported || hasSupportedState;\n      }\n\n      return country.supported;\n    });\n  }\n\n  /**\n   * Fetches the list of available tokens for a given region and action.\n   *\n   * @param region - The region code (e.g., \"us\", \"fr\", \"us-ny\").\n   * @param action - The ramp action type ('buy' or 'sell').\n   * @returns The tokens response containing topTokens and allTokens.\n   */\n  async getTokens(\n    region: string,\n    action: 'buy' | 'sell' = 'buy',\n  ): Promise<TokensResponse> {\n    const normalizedRegion = region.toLowerCase().trim();\n    const response = await this.#request<TokensResponse>(\n      RampsApiService.Regions,\n      `regions/${normalizedRegion}/tokens`,\n      { action, responseType: 'json' },\n    );\n\n    if (!response || typeof response !== 'object') {\n      throw new Error('Malformed response received from tokens API');\n    }\n\n    if (\n      !Array.isArray(response.topTokens) ||\n      !Array.isArray(response.allTokens)\n    ) {\n      throw new Error('Malformed response received from tokens API');\n    }\n\n    return response;\n  }\n\n  /**\n   * Fetches the list of providers for a given region.\n   * Supports optional query filters: provider, crypto, fiat, payments.\n   *\n   * @param regionCode - The region code (e.g., \"us\", \"fr\", \"us-ny\").\n   * @param options - Optional query parameters for filtering providers.\n   * @param options.provider - Provider ID(s) to filter by.\n   * @param options.crypto - Crypto currency ID(s) to filter by.\n   * @param options.fiat - Fiat currency ID(s) to filter by.\n   * @param options.payments - Payment method ID(s) to filter by.\n   * @returns The providers response containing providers array.\n   */\n  async getProviders(\n    regionCode: string,\n    options?: {\n      provider?: string | string[];\n      crypto?: string | string[];\n      fiat?: string | string[];\n      payments?: string | string[];\n    },\n  ): Promise<{ providers: Provider[] }> {\n    const normalizedRegion = regionCode.toLowerCase().trim();\n    const url = new URL(\n      getApiPath(`regions/${normalizedRegion}/providers`),\n      getBaseUrl(this.#environment, RampsApiService.Regions),\n    );\n    this.#addCommonParams(url);\n\n    if (options?.provider) {\n      const providerIds = Array.isArray(options.provider)\n        ? options.provider\n        : [options.provider];\n      providerIds.forEach((id) => url.searchParams.append('provider', id));\n    }\n\n    if (options?.crypto) {\n      const cryptoIds = Array.isArray(options.crypto)\n        ? options.crypto\n        : [options.crypto];\n      cryptoIds.forEach((id) => url.searchParams.append('crypto', id));\n    }\n\n    if (options?.fiat) {\n      const fiatIds = Array.isArray(options.fiat)\n        ? options.fiat\n        : [options.fiat];\n      fiatIds.forEach((id) => url.searchParams.append('fiat', id));\n    }\n\n    if (options?.payments) {\n      const paymentIds = Array.isArray(options.payments)\n        ? options.payments\n        : [options.payments];\n      paymentIds.forEach((id) => url.searchParams.append('payments', id));\n    }\n\n    const response = await this.#policy.execute(async () => {\n      const fetchResponse = await this.#fetch(url);\n      if (!fetchResponse.ok) {\n        throw new HttpError(\n          fetchResponse.status,\n          `Fetching '${url.toString()}' failed with status '${fetchResponse.status}'`,\n        );\n      }\n      return fetchResponse.json() as Promise<{ providers: Provider[] }>;\n    });\n\n    if (!response || typeof response !== 'object') {\n      throw new Error('Malformed response received from providers API');\n    }\n\n    if (!Array.isArray(response.providers)) {\n      throw new Error('Malformed response received from providers API');\n    }\n\n    return response;\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"RampsService.cjs","sourceRoot":"","sources":["../src/RampsService.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  CreateServicePolicyOptions,\n  ServicePolicy,\n} from '@metamask/controller-utils';\nimport { createServicePolicy, HttpError } from '@metamask/controller-utils';\nimport type { Messenger } from '@metamask/messenger';\n\nimport type { RampsServiceMethodActions } from './RampsService-method-action-types';\nimport packageJson from '../package.json';\n\n/**\n * Represents phone number information for a country.\n */\nexport type CountryPhone = {\n  prefix: string;\n  placeholder: string;\n  template: string;\n};\n\n/**\n * Represents a state/province within a country.\n */\nexport type State = {\n  /**\n   * State identifier. Can be in path format (e.g., \"/regions/us-ut\") or ISO code format (e.g., \"us-ut\").\n   */\n  id?: string;\n  /**\n   * State name.\n   */\n  name?: string;\n  /**\n   * ISO state code (e.g., \"UT\", \"NY\").\n   */\n  stateId?: string;\n  /**\n   * Whether this state is supported for ramps.\n   */\n  supported?: boolean;\n  /**\n   * Whether this state is recommended.\n   */\n  recommended?: boolean;\n};\n\n/**\n * Represents a provider link.\n */\nexport type ProviderLink = {\n  name: string;\n  url: string;\n};\n\n/**\n * Represents provider logos.\n */\nexport type ProviderLogos = {\n  light: string;\n  dark: string;\n  height: number;\n  width: number;\n};\n\n/**\n * Represents a ramp provider.\n */\nexport type Provider = {\n  id: string;\n  name: string;\n  environmentType: string;\n  description: string;\n  hqAddress: string;\n  links: ProviderLink[];\n  logos: ProviderLogos;\n};\n\n/**\n * Represents a country returned from the regions/countries API.\n */\nexport type Country = {\n  /**\n   * ISO-2 country code (e.g., \"US\", \"GB\").\n   */\n  isoCode: string;\n  /**\n   * Country identifier. Can be in path format (e.g., \"/regions/us\") or ISO code format.\n   * If not provided, defaults to isoCode.\n   */\n  id?: string;\n  /**\n   * Country flag emoji or code.\n   */\n  flag: string;\n  /**\n   * Country name.\n   */\n  name: string;\n  /**\n   * Phone number information.\n   */\n  phone: CountryPhone;\n  /**\n   * Default currency code.\n   */\n  currency: string;\n  /**\n   * Whether this country is supported for ramps.\n   */\n  supported: boolean;\n  /**\n   * Whether this country is recommended.\n   */\n  recommended?: boolean;\n  /**\n   * Array of state objects.\n   */\n  states?: State[];\n  /**\n   * Default amount for ramps transactions.\n   */\n  defaultAmount?: number;\n  /**\n   * Quick amount options for ramps transactions.\n   */\n  quickAmounts?: number[];\n};\n\n/**\n * Represents a token returned from the regions/{region}/tokens API.\n */\nexport type RampsToken = {\n  /**\n   * The asset identifier in CAIP-19 format (e.g., \"eip155:1/erc20:0x...\").\n   */\n  assetId: string;\n  /**\n   * The chain identifier in CAIP-2 format (e.g., \"eip155:1\").\n   */\n  chainId: string;\n  /**\n   * Token name (e.g., \"USD Coin\").\n   */\n  name: string;\n  /**\n   * Token symbol (e.g., \"USDC\").\n   */\n  symbol: string;\n  /**\n   * Number of decimals for the token.\n   */\n  decimals: number;\n  /**\n   * URL to the token icon.\n   */\n  iconUrl: string;\n  /**\n   * Whether this token is supported.\n   */\n  tokenSupported: boolean;\n};\n\n/**\n * Response from the regions/{region}/tokens API.\n */\nexport type TokensResponse = {\n  /**\n   * Top/popular tokens for the region.\n   */\n  topTokens: RampsToken[];\n  /**\n   * All available tokens for the region.\n   */\n  allTokens: RampsToken[];\n};\n\n/**\n * The SDK version to send with API requests. (backwards-compatibility)\n */\nexport const RAMPS_SDK_VERSION = '2.1.6';\n\n/**\n * The type of ramp action: 'buy' or 'sell'.\n */\nexport type RampAction = 'buy' | 'sell';\n\n// === GENERAL ===\n\n/**\n * The name of the {@link RampsService}, used to namespace the\n * service's actions and events.\n */\nexport const serviceName = 'RampsService';\n\n/**\n * The environment to use for API requests.\n */\nexport enum RampsEnvironment {\n  Production = 'production',\n  Staging = 'staging',\n  Development = 'development',\n}\n\n/**\n * The type of ramps API service.\n * Determines which base URL to use (cache vs standard).\n */\nexport enum RampsApiService {\n  Regions = 'regions',\n  Orders = 'orders',\n}\n\n// === MESSENGER ===\n\nconst MESSENGER_EXPOSED_METHODS = [\n  'getGeolocation',\n  'getCountries',\n  'getTokens',\n  'getProviders',\n] as const;\n\n/**\n * Actions that {@link RampsService} exposes to other consumers.\n */\nexport type RampsServiceActions = RampsServiceMethodActions;\n\n/**\n * Actions from other messengers that {@link RampsService} calls.\n */\ntype AllowedActions = never;\n\n/**\n * Events that {@link RampsService} exposes to other consumers.\n */\nexport type RampsServiceEvents = never;\n\n/**\n * Events from other messengers that {@link RampsService} subscribes to.\n */\ntype AllowedEvents = never;\n\n/**\n * The messenger which is restricted to actions and events accessed by\n * {@link RampsService}.\n */\nexport type RampsServiceMessenger = Messenger<\n  typeof serviceName,\n  RampsServiceActions | AllowedActions,\n  RampsServiceEvents | AllowedEvents\n>;\n\n// === SERVICE DEFINITION ===\n\n/**\n * Gets the base URL for API requests based on the environment and service type.\n * The Regions service uses a cache URL, while other services use the standard URL.\n *\n * @param environment - The environment to use.\n * @param service - The API service type (determines if cache URL is used).\n * @returns The base URL for API requests.\n */\nfunction getBaseUrl(\n  environment: RampsEnvironment,\n  service: RampsApiService,\n): string {\n  const cache = service === RampsApiService.Regions ? '-cache' : '';\n\n  switch (environment) {\n    case RampsEnvironment.Production:\n      return `https://on-ramp${cache}.api.cx.metamask.io`;\n    case RampsEnvironment.Staging:\n    case RampsEnvironment.Development:\n      return `https://on-ramp${cache}.uat-api.cx.metamask.io`;\n    default:\n      throw new Error(`Invalid environment: ${String(environment)}`);\n  }\n}\n\n/**\n * Constructs an API path with a version prefix.\n *\n * @param path - The API endpoint path.\n * @param version - The API version prefix. Defaults to 'v2'.\n * @returns The versioned API path.\n */\nfunction getApiPath(path: string, version: string = 'v2'): string {\n  return `${version}/${path}`;\n}\n\n/**\n * This service object is responsible for interacting with the Ramps API.\n *\n * @example\n *\n * ``` ts\n * import { Messenger } from '@metamask/messenger';\n * import type {\n *   RampsServiceActions,\n *   RampsServiceEvents,\n * } from '@metamask/ramps-controller';\n *\n * const rootMessenger = new Messenger<\n *   'Root',\n *   RampsServiceActions\n *   RampsServiceEvents\n * >({ namespace: 'Root' });\n * const rampsServiceMessenger = new Messenger<\n *   'RampsService',\n *   RampsServiceActions,\n *   RampsServiceEvents,\n *   typeof rootMessenger,\n * >({\n *   namespace: 'RampsService',\n *   parent: rootMessenger,\n * });\n * // Instantiate the service to register its actions on the messenger\n * new RampsService({\n *   messenger: rampsServiceMessenger,\n *   environment: RampsEnvironment.Production,\n *   context: 'mobile-ios',\n *   fetch,\n * });\n *\n * // Later...\n * // Get the user's geolocation\n * const geolocation = await rootMessenger.call(\n *   'RampsService:getGeolocation',\n * );\n * // ... Do something with the geolocation ...\n * ```\n */\nexport class RampsService {\n  /**\n   * The name of the service.\n   */\n  readonly name: typeof serviceName;\n\n  /**\n   * The messenger suited for this service.\n   */\n  readonly #messenger: ConstructorParameters<\n    typeof RampsService\n  >[0]['messenger'];\n\n  /**\n   * A function that can be used to make an HTTP request.\n   */\n  readonly #fetch: ConstructorParameters<typeof RampsService>[0]['fetch'];\n\n  /**\n   * The policy that wraps the request.\n   *\n   * @see {@link createServicePolicy}\n   */\n  readonly #policy: ServicePolicy;\n\n  /**\n   * The environment used for API requests.\n   */\n  readonly #environment: RampsEnvironment;\n\n  /**\n   * The context for API requests (e.g., 'mobile-ios', 'mobile-android').\n   */\n  readonly #context: string;\n\n  /**\n   * Constructs a new RampsService object.\n   *\n   * @param args - The constructor arguments.\n   * @param args.messenger - The messenger suited for this service.\n   * @param args.environment - The environment to use for API requests.\n   * @param args.context - The context for API requests (e.g., 'mobile-ios', 'mobile-android').\n   * @param args.fetch - A function that can be used to make an HTTP request. If\n   * your JavaScript environment supports `fetch` natively, you'll probably want\n   * to pass that; otherwise you can pass an equivalent (such as `fetch` via\n   * `node-fetch`).\n   * @param args.policyOptions - Options to pass to `createServicePolicy`, which\n   * is used to wrap each request. See {@link CreateServicePolicyOptions}.\n   */\n  constructor({\n    messenger,\n    environment = RampsEnvironment.Staging,\n    context,\n    fetch: fetchFunction,\n    policyOptions = {},\n  }: {\n    messenger: RampsServiceMessenger;\n    environment?: RampsEnvironment;\n    context: string;\n    fetch: typeof fetch;\n    policyOptions?: CreateServicePolicyOptions;\n  }) {\n    this.name = serviceName;\n    this.#messenger = messenger;\n    this.#fetch = fetchFunction;\n    this.#policy = createServicePolicy(policyOptions);\n    this.#environment = environment;\n    this.#context = context;\n\n    this.#messenger.registerMethodActionHandlers(\n      this,\n      MESSENGER_EXPOSED_METHODS,\n    );\n  }\n\n  /**\n   * Registers a handler that will be called after a request returns a non-500\n   * response, causing a retry. Primarily useful in tests where timers are being\n   * mocked.\n   *\n   * @param listener - The handler to be called.\n   * @returns An object that can be used to unregister the handler. See\n   * {@link CockatielEvent}.\n   * @see {@link createServicePolicy}\n   */\n  onRetry(\n    listener: Parameters<ServicePolicy['onRetry']>[0],\n  ): ReturnType<ServicePolicy['onRetry']> {\n    return this.#policy.onRetry(listener);\n  }\n\n  /**\n   * Registers a handler that will be called after a set number of retry rounds\n   * prove that requests to the API endpoint consistently return a 5xx response.\n   *\n   * @param listener - The handler to be called.\n   * @returns An object that can be used to unregister the handler. See\n   * {@link CockatielEvent}.\n   * @see {@link createServicePolicy}\n   */\n  onBreak(\n    listener: Parameters<ServicePolicy['onBreak']>[0],\n  ): ReturnType<ServicePolicy['onBreak']> {\n    return this.#policy.onBreak(listener);\n  }\n\n  /**\n   * Registers a handler that will be called under one of two circumstances:\n   *\n   * 1. After a set number of retries prove that requests to the API\n   * consistently result in one of the following failures:\n   *    1. A connection initiation error\n   *    2. A connection reset error\n   *    3. A timeout error\n   *    4. A non-JSON response\n   *    5. A 502, 503, or 504 response\n   * 2. After a successful request is made to the API, but the response takes\n   * longer than a set duration to return.\n   *\n   * @param listener - The handler to be called.\n   * @returns An object that can be used to unregister the handler. See\n   * {@link CockatielEvent}.\n   */\n  onDegraded(\n    listener: Parameters<ServicePolicy['onDegraded']>[0],\n  ): ReturnType<ServicePolicy['onDegraded']> {\n    return this.#policy.onDegraded(listener);\n  }\n\n  /**\n   * Adds common request parameters to a URL.\n   *\n   * @param url - The URL to add parameters to.\n   * @param action - The ramp action type (optional, not all endpoints require it).\n   */\n  #addCommonParams(url: URL, action?: RampAction): void {\n    if (action) {\n      url.searchParams.set('action', action);\n    }\n    url.searchParams.set('sdk', RAMPS_SDK_VERSION);\n    url.searchParams.set('controller', packageJson.version);\n    url.searchParams.set('context', this.#context);\n  }\n\n  /**\n   * Makes an API request with retry policy and error handling.\n   *\n   * @param service - The API service type (determines base URL).\n   * @param path - The endpoint path.\n   * @param options - Request options.\n   * @param options.action - The ramp action type (optional).\n   * @param options.responseType - How to parse the response ('json' or 'text').\n   * @returns The parsed response data.\n   */\n  async #request<TResponse>(\n    service: RampsApiService,\n    path: string,\n    options: {\n      action?: RampAction;\n      responseType: 'json' | 'text';\n    },\n  ): Promise<TResponse> {\n    return this.#policy.execute(async () => {\n      const baseUrl = getBaseUrl(this.#environment, service);\n      const url = new URL(path, baseUrl);\n      this.#addCommonParams(url, options.action);\n\n      const response = await this.#fetch(url);\n      if (!response.ok) {\n        throw new HttpError(\n          response.status,\n          `Fetching '${url.toString()}' failed with status '${response.status}'`,\n        );\n      }\n\n      return options.responseType === 'json'\n        ? (response.json() as Promise<TResponse>)\n        : (response.text() as Promise<TResponse>);\n    });\n  }\n\n  /**\n   * Makes a request to the API in order to retrieve the user's geolocation\n   * based on their IP address.\n   *\n   * @returns The user's country/region code (e.g., \"US-UT\" for Utah, USA).\n   */\n  async getGeolocation(): Promise<string> {\n    const textResponse = await this.#request<string>(\n      RampsApiService.Orders,\n      'geolocation',\n      { responseType: 'text' },\n    );\n\n    const trimmedResponse = textResponse.trim();\n    if (trimmedResponse.length > 0) {\n      return trimmedResponse;\n    }\n\n    throw new Error('Malformed response received from geolocation API');\n  }\n\n  /**\n   * Makes a request to the cached API to retrieve the list of supported countries.\n   * Filters countries based on aggregator support (preserves OnRampSDK logic).\n   *\n   * @param action - The ramp action type ('buy' or 'sell').\n   * @returns An array of countries filtered by aggregator support.\n   */\n  async getCountries(action: RampAction = 'buy'): Promise<Country[]> {\n    const countries = await this.#request<Country[]>(\n      RampsApiService.Regions,\n      getApiPath('regions/countries'),\n      { action, responseType: 'json' },\n    );\n\n    if (!Array.isArray(countries)) {\n      throw new Error('Malformed response received from countries API');\n    }\n\n    return countries.filter((country) => {\n      if (country.states && country.states.length > 0) {\n        const hasSupportedState = country.states.some(\n          (state) => state.supported !== false,\n        );\n        return country.supported || hasSupportedState;\n      }\n\n      return country.supported;\n    });\n  }\n\n  /**\n   * Fetches the list of available tokens for a given region and action.\n   * Supports optional provider filter.\n   *\n   * @param region - The region code (e.g., \"us\", \"fr\", \"us-ny\").\n   * @param action - The ramp action type ('buy' or 'sell').\n   * @param options - Optional query parameters for filtering tokens.\n   * @param options.provider - Provider ID(s) to filter by.\n   * @returns The tokens response containing topTokens and allTokens.\n   */\n  async getTokens(\n    region: string,\n    action: RampAction = 'buy',\n    options?: {\n      provider?: string | string[];\n    },\n  ): Promise<TokensResponse> {\n    const normalizedRegion = region.toLowerCase().trim();\n    const url = new URL(\n      getApiPath(`regions/${normalizedRegion}/topTokens`),\n      getBaseUrl(this.#environment, RampsApiService.Regions),\n    );\n    this.#addCommonParams(url, action);\n\n    if (options?.provider) {\n      const providerIds = Array.isArray(options.provider)\n        ? options.provider\n        : [options.provider];\n      providerIds.forEach((id) => url.searchParams.append('provider', id));\n    }\n\n    const response = await this.#policy.execute(async () => {\n      const fetchResponse = await this.#fetch(url);\n      if (!fetchResponse.ok) {\n        throw new HttpError(\n          fetchResponse.status,\n          `Fetching '${url.toString()}' failed with status '${fetchResponse.status}'`,\n        );\n      }\n      return fetchResponse.json() as Promise<TokensResponse>;\n    });\n\n    if (!response || typeof response !== 'object') {\n      throw new Error('Malformed response received from tokens API');\n    }\n\n    if (\n      !Array.isArray(response.topTokens) ||\n      !Array.isArray(response.allTokens)\n    ) {\n      throw new Error('Malformed response received from tokens API');\n    }\n\n    return response;\n  }\n\n  /**\n   * Fetches the list of providers for a given region.\n   * Supports optional query filters: provider, crypto, fiat, payments.\n   *\n   * @param regionCode - The region code (e.g., \"us\", \"fr\", \"us-ny\").\n   * @param options - Optional query parameters for filtering providers.\n   * @param options.provider - Provider ID(s) to filter by.\n   * @param options.crypto - Crypto currency ID(s) to filter by.\n   * @param options.fiat - Fiat currency ID(s) to filter by.\n   * @param options.payments - Payment method ID(s) to filter by.\n   * @returns The providers response containing providers array.\n   */\n  async getProviders(\n    regionCode: string,\n    options?: {\n      provider?: string | string[];\n      crypto?: string | string[];\n      fiat?: string | string[];\n      payments?: string | string[];\n    },\n  ): Promise<{ providers: Provider[] }> {\n    const normalizedRegion = regionCode.toLowerCase().trim();\n    const url = new URL(\n      getApiPath(`regions/${normalizedRegion}/providers`),\n      getBaseUrl(this.#environment, RampsApiService.Regions),\n    );\n    this.#addCommonParams(url);\n\n    if (options?.provider) {\n      const providerIds = Array.isArray(options.provider)\n        ? options.provider\n        : [options.provider];\n      providerIds.forEach((id) => url.searchParams.append('provider', id));\n    }\n\n    if (options?.crypto) {\n      const cryptoIds = Array.isArray(options.crypto)\n        ? options.crypto\n        : [options.crypto];\n      cryptoIds.forEach((id) => url.searchParams.append('crypto', id));\n    }\n\n    if (options?.fiat) {\n      const fiatIds = Array.isArray(options.fiat)\n        ? options.fiat\n        : [options.fiat];\n      fiatIds.forEach((id) => url.searchParams.append('fiat', id));\n    }\n\n    if (options?.payments) {\n      const paymentIds = Array.isArray(options.payments)\n        ? options.payments\n        : [options.payments];\n      paymentIds.forEach((id) => url.searchParams.append('payments', id));\n    }\n\n    const response = await this.#policy.execute(async () => {\n      const fetchResponse = await this.#fetch(url);\n      if (!fetchResponse.ok) {\n        throw new HttpError(\n          fetchResponse.status,\n          `Fetching '${url.toString()}' failed with status '${fetchResponse.status}'`,\n        );\n      }\n      return fetchResponse.json() as Promise<{ providers: Provider[] }>;\n    });\n\n    if (!response || typeof response !== 'object') {\n      throw new Error('Malformed response received from providers API');\n    }\n\n    if (!Array.isArray(response.providers)) {\n      throw new Error('Malformed response received from providers API');\n    }\n\n    return response;\n  }\n}\n"]}
\ No newline at end of file
diff --git a/dist/RampsService.d.cts b/dist/RampsService.d.cts
index 46d5190259b4dfc4fa768cb3409e3b22cc2a7da5..b33b709d4fdb3615dc0b628f6f7f68d4e235bd00 100644
--- a/dist/RampsService.d.cts
+++ b/dist/RampsService.d.cts
@@ -162,6 +162,10 @@ export type TokensResponse = {
  * The SDK version to send with API requests. (backwards-compatibility)
  */
 export declare const RAMPS_SDK_VERSION = "2.1.6";
+/**
+ * The type of ramp action: 'buy' or 'sell'.
+ */
+export type RampAction = 'buy' | 'sell';
 /**
  * The name of the {@link RampsService}, used to namespace the
  * service's actions and events.
@@ -326,15 +330,20 @@ export declare class RampsService {
      * @param action - The ramp action type ('buy' or 'sell').
      * @returns An array of countries filtered by aggregator support.
      */
-    getCountries(action?: 'buy' | 'sell'): Promise<Country[]>;
+    getCountries(action?: RampAction): Promise<Country[]>;
     /**
      * Fetches the list of available tokens for a given region and action.
+     * Supports optional provider filter.
      *
      * @param region - The region code (e.g., "us", "fr", "us-ny").
      * @param action - The ramp action type ('buy' or 'sell').
+     * @param options - Optional query parameters for filtering tokens.
+     * @param options.provider - Provider ID(s) to filter by.
      * @returns The tokens response containing topTokens and allTokens.
      */
-    getTokens(region: string, action?: 'buy' | 'sell'): Promise<TokensResponse>;
+    getTokens(region: string, action?: RampAction, options?: {
+        provider?: string | string[];
+    }): Promise<TokensResponse>;
     /**
      * Fetches the list of providers for a given region.
      * Supports optional query filters: provider, crypto, fiat, payments.
diff --git a/dist/RampsService.d.cts.map b/dist/RampsService.d.cts.map
index 518262a429a260ae3b39875e2d1fb3249b79faa6..550dc5a8612372780989645c24291758d1817c15 100644
--- a/dist/RampsService.d.cts.map
+++ b/dist/RampsService.d.cts.map
@@ -1 +1 @@
-{"version":3,"file":"RampsService.d.cts","sourceRoot":"","sources":["../src/RampsService.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"RampsService.d.cts","sourceRoot":"","sources":["../src/RampsService.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/RampsService.d.mts b/dist/RampsService.d.mts
index 0ac25566286dfca08c2161f3f7be647e283513ac..ab4b8c17993b0c28b1471f6fcd3120af355336a3 100644
--- a/dist/RampsService.d.mts
+++ b/dist/RampsService.d.mts
@@ -162,6 +162,10 @@ export type TokensResponse = {
  * The SDK version to send with API requests. (backwards-compatibility)
  */
 export declare const RAMPS_SDK_VERSION = "2.1.6";
+/**
+ * The type of ramp action: 'buy' or 'sell'.
+ */
+export type RampAction = 'buy' | 'sell';
 /**
  * The name of the {@link RampsService}, used to namespace the
  * service's actions and events.
@@ -326,15 +330,20 @@ export declare class RampsService {
      * @param action - The ramp action type ('buy' or 'sell').
      * @returns An array of countries filtered by aggregator support.
      */
-    getCountries(action?: 'buy' | 'sell'): Promise<Country[]>;
+    getCountries(action?: RampAction): Promise<Country[]>;
     /**
      * Fetches the list of available tokens for a given region and action.
+     * Supports optional provider filter.
      *
      * @param region - The region code (e.g., "us", "fr", "us-ny").
      * @param action - The ramp action type ('buy' or 'sell').
+     * @param options - Optional query parameters for filtering tokens.
+     * @param options.provider - Provider ID(s) to filter by.
      * @returns The tokens response containing topTokens and allTokens.
      */
-    getTokens(region: string, action?: 'buy' | 'sell'): Promise<TokensResponse>;
+    getTokens(region: string, action?: RampAction, options?: {
+        provider?: string | string[];
+    }): Promise<TokensResponse>;
     /**
      * Fetches the list of providers for a given region.
      * Supports optional query filters: provider, crypto, fiat, payments.
diff --git a/dist/RampsService.d.mts.map b/dist/RampsService.d.mts.map
index 8acdba186be8b3698fd55b9e796ae2581c63af47..33b484a29522a51e7506fa35fc58b8aeb9466969 100644
--- a/dist/RampsService.d.mts.map
+++ b/dist/RampsService.d.mts.map
@@ -1 +1 @@
-{"version":3,"file":"RampsService.d.mts","sourceRoot":"","sources":["../src/RampsService.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EACV,0BAA0B,EAC1B,aAAa,EACd,mCAAmC;AAEpC,OAAO,KAAK,EAAE,SAAS,EAAE,4BAA4B;AAErD,OAAO,KAAK,EAAE,yBAAyB,EAAE,+CAA2C;AAGpF;;GAEG;AACH,MAAM,MAAM,YAAY,GAAG;IACzB,MAAM,EAAE,MAAM,CAAC;IACf,WAAW,EAAE,MAAM,CAAC;IACpB,QAAQ,EAAE,MAAM,CAAC;CAClB,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,KAAK,GAAG;IAClB;;OAEG;IACH,EAAE,CAAC,EAAE,MAAM,CAAC;IACZ;;OAEG;IACH,IAAI,CAAC,EAAE,MAAM,CAAC;IACd;;OAEG;IACH,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB;;OAEG;IACH,SAAS,CAAC,EAAE,OAAO,CAAC;IACpB;;OAEG;IACH,WAAW,CAAC,EAAE,OAAO,CAAC;CACvB,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,YAAY,GAAG;IACzB,IAAI,EAAE,MAAM,CAAC;IACb,GAAG,EAAE,MAAM,CAAC;CACb,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,aAAa,GAAG;IAC1B,KAAK,EAAE,MAAM,CAAC;IACd,IAAI,EAAE,MAAM,CAAC;IACb,MAAM,EAAE,MAAM,CAAC;IACf,KAAK,EAAE,MAAM,CAAC;CACf,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,QAAQ,GAAG;IACrB,EAAE,EAAE,MAAM,CAAC;IACX,IAAI,EAAE,MAAM,CAAC;IACb,eAAe,EAAE,MAAM,CAAC;IACxB,WAAW,EAAE,MAAM,CAAC;IACpB,SAAS,EAAE,MAAM,CAAC;IAClB,KAAK,EAAE,YAAY,EAAE,CAAC;IACtB,KAAK,EAAE,aAAa,CAAC;CACtB,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,OAAO,GAAG;IACpB;;OAEG;IACH,OAAO,EAAE,MAAM,CAAC;IAChB;;;OAGG;IACH,EAAE,CAAC,EAAE,MAAM,CAAC;IACZ;;OAEG;IACH,IAAI,EAAE,MAAM,CAAC;IACb;;OAEG;IACH,IAAI,EAAE,MAAM,CAAC;IACb;;OAEG;IACH,KAAK,EAAE,YAAY,CAAC;IACpB;;OAEG;IACH,QAAQ,EAAE,MAAM,CAAC;IACjB;;OAEG;IACH,SAAS,EAAE,OAAO,CAAC;IACnB;;OAEG;IACH,WAAW,CAAC,EAAE,OAAO,CAAC;IACtB;;OAEG;IACH,MAAM,CAAC,EAAE,KAAK,EAAE,CAAC;IACjB;;OAEG;IACH,aAAa,CAAC,EAAE,MAAM,CAAC;IACvB;;OAEG;IACH,YAAY,CAAC,EAAE,MAAM,EAAE,CAAC;CACzB,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,UAAU,GAAG;IACvB;;OAEG;IACH,OAAO,EAAE,MAAM,CAAC;IAChB;;OAEG;IACH,OAAO,EAAE,MAAM,CAAC;IAChB;;OAEG;IACH,IAAI,EAAE,MAAM,CAAC;IACb;;OAEG;IACH,MAAM,EAAE,MAAM,CAAC;IACf;;OAEG;IACH,QAAQ,EAAE,MAAM,CAAC;IACjB;;OAEG;IACH,OAAO,EAAE,MAAM,CAAC;IAChB;;OAEG;IACH,cAAc,EAAE,OAAO,CAAC;CACzB,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,cAAc,GAAG;IAC3B;;OAEG;IACH,SAAS,EAAE,UAAU,EAAE,CAAC;IACxB;;OAEG;IACH,SAAS,EAAE,UAAU,EAAE,CAAC;CACzB,CAAC;AAEF;;GAEG;AACH,eAAO,MAAM,iBAAiB,UAAU,CAAC;AAIzC;;;GAGG;AACH,eAAO,MAAM,WAAW,iBAAiB,CAAC;AAE1C;;GAEG;AACH,oBAAY,gBAAgB;IAC1B,UAAU,eAAe;IACzB,OAAO,YAAY;IACnB,WAAW,gBAAgB;CAC5B;AAED;;;GAGG;AACH,oBAAY,eAAe;IACzB,OAAO,YAAY;IACnB,MAAM,WAAW;CAClB;AAWD;;GAEG;AACH,MAAM,MAAM,mBAAmB,GAAG,yBAAyB,CAAC;AAE5D;;GAEG;AACH,KAAK,cAAc,GAAG,KAAK,CAAC;AAE5B;;GAEG;AACH,MAAM,MAAM,kBAAkB,GAAG,KAAK,CAAC;AAEvC;;GAEG;AACH,KAAK,aAAa,GAAG,KAAK,CAAC;AAE3B;;;GAGG;AACH,MAAM,MAAM,qBAAqB,GAAG,SAAS,CAC3C,OAAO,WAAW,EAClB,mBAAmB,GAAG,cAAc,EACpC,kBAAkB,GAAG,aAAa,CACnC,CAAC;AAwCF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAyCG;AACH,qBAAa,YAAY;;IACvB;;OAEG;IACH,QAAQ,CAAC,IAAI,EAAE,OAAO,WAAW,CAAC;IA+BlC;;;;;;;;;;;;;OAaG;gBACS,EACV,SAAS,EACT,WAAsC,EACtC,OAAO,EACP,KAAK,EAAE,aAAa,EACpB,aAAkB,GACnB,EAAE;QACD,SAAS,EAAE,qBAAqB,CAAC;QACjC,WAAW,CAAC,EAAE,gBAAgB,CAAC;QAC/B,OAAO,EAAE,MAAM,CAAC;QAChB,KAAK,EAAE,OAAO,KAAK,CAAC;QACpB,aAAa,CAAC,EAAE,0BAA0B,CAAC;KAC5C;IAcD;;;;;;;;;OASG;IACH,OAAO,CACL,QAAQ,EAAE,UAAU,CAAC,aAAa,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,GAChD,UAAU,CAAC,aAAa,CAAC,SAAS,CAAC,CAAC;IAIvC;;;;;;;;OAQG;IACH,OAAO,CACL,QAAQ,EAAE,UAAU,CAAC,aAAa,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,GAChD,UAAU,CAAC,aAAa,CAAC,SAAS,CAAC,CAAC;IAIvC;;;;;;;;;;;;;;;;OAgBG;IACH,UAAU,CACR,QAAQ,EAAE,UAAU,CAAC,aAAa,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC,GACnD,UAAU,CAAC,aAAa,CAAC,YAAY,CAAC,CAAC;IAwD1C;;;;;OAKG;IACG,cAAc,IAAI,OAAO,CAAC,MAAM,CAAC;IAevC;;;;;;OAMG;IACG,YAAY,CAAC,MAAM,GAAE,KAAK,GAAG,MAAc,GAAG,OAAO,CAAC,OAAO,EAAE,CAAC;IAuBtE;;;;;;OAMG;IACG,SAAS,CACb,MAAM,EAAE,MAAM,EACd,MAAM,GAAE,KAAK,GAAG,MAAc,GAC7B,OAAO,CAAC,cAAc,CAAC;IAsB1B;;;;;;;;;;;OAWG;IACG,YAAY,CAChB,UAAU,EAAE,MAAM,EAClB,OAAO,CAAC,EAAE;QACR,QAAQ,CAAC,EAAE,MAAM,GAAG,MAAM,EAAE,CAAC;QAC7B,MAAM,CAAC,EAAE,MAAM,GAAG,MAAM,EAAE,CAAC;QAC3B,IAAI,CAAC,EAAE,MAAM,GAAG,MAAM,EAAE,CAAC;QACzB,QAAQ,CAAC,EAAE,MAAM,GAAG,MAAM,EAAE,CAAC;KAC9B,GACA,OAAO,CAAC;QAAE,SAAS,EAAE,QAAQ,EAAE,CAAA;KAAE,CAAC;CAyDtC"}
\ No newline at end of file
+{"version":3,"file":"RampsService.d.mts","sourceRoot":"","sources":["../src/RampsService.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/RampsService.mjs b/dist/RampsService.mjs
index 56abb1b613eebe785dda8fe7a33986ac516141fb..17849c564057ba421daaf0aff82557fe855ec94d 100644
--- a/dist/RampsService.mjs
+++ b/dist/RampsService.mjs
@@ -248,14 +248,31 @@ export class RampsService {
     }
     /**
      * Fetches the list of available tokens for a given region and action.
+     * Supports optional provider filter.
      *
      * @param region - The region code (e.g., "us", "fr", "us-ny").
      * @param action - The ramp action type ('buy' or 'sell').
+     * @param options - Optional query parameters for filtering tokens.
+     * @param options.provider - Provider ID(s) to filter by.
      * @returns The tokens response containing topTokens and allTokens.
      */
-    async getTokens(region, action = 'buy') {
+    async getTokens(region, action = 'buy', options) {
         const normalizedRegion = region.toLowerCase().trim();
-        const response = await __classPrivateFieldGet(this, _RampsService_instances, "m", _RampsService_request).call(this, RampsApiService.Regions, `regions/${normalizedRegion}/tokens`, { action, responseType: 'json' });
+        const url = new URL(getApiPath(`regions/${normalizedRegion}/topTokens`), getBaseUrl(__classPrivateFieldGet(this, _RampsService_environment, "f"), RampsApiService.Regions));
+        __classPrivateFieldGet(this, _RampsService_instances, "m", _RampsService_addCommonParams).call(this, url, action);
+        if (options?.provider) {
+            const providerIds = Array.isArray(options.provider)
+                ? options.provider
+                : [options.provider];
+            providerIds.forEach((id) => url.searchParams.append('provider', id));
+        }
+        const response = await __classPrivateFieldGet(this, _RampsService_policy, "f").execute(async () => {
+            const fetchResponse = await __classPrivateFieldGet(this, _RampsService_fetch, "f").call(this, url);
+            if (!fetchResponse.ok) {
+                throw new HttpError(fetchResponse.status, `Fetching '${url.toString()}' failed with status '${fetchResponse.status}'`);
+            }
+            return fetchResponse.json();
+        });
         if (!response || typeof response !== 'object') {
             throw new Error('Malformed response received from tokens API');
         }
diff --git a/dist/RampsService.mjs.map b/dist/RampsService.mjs.map
index 3623d894dac120690abe1103d432093cc7d716c3..7aefd161e1570dff70f713d75f0628ecf120654a 100644
--- a/dist/RampsService.mjs.map
+++ b/dist/RampsService.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"RampsService.mjs","sourceRoot":"","sources":["../src/RampsService.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  CreateServicePolicyOptions,\n  ServicePolicy,\n} from '@metamask/controller-utils';\nimport { createServicePolicy, HttpError } from '@metamask/controller-utils';\nimport type { Messenger } from '@metamask/messenger';\n\nimport type { RampsServiceMethodActions } from './RampsService-method-action-types';\nimport packageJson from '../package.json';\n\n/**\n * Represents phone number information for a country.\n */\nexport type CountryPhone = {\n  prefix: string;\n  placeholder: string;\n  template: string;\n};\n\n/**\n * Represents a state/province within a country.\n */\nexport type State = {\n  /**\n   * State identifier. Can be in path format (e.g., \"/regions/us-ut\") or ISO code format (e.g., \"us-ut\").\n   */\n  id?: string;\n  /**\n   * State name.\n   */\n  name?: string;\n  /**\n   * ISO state code (e.g., \"UT\", \"NY\").\n   */\n  stateId?: string;\n  /**\n   * Whether this state is supported for ramps.\n   */\n  supported?: boolean;\n  /**\n   * Whether this state is recommended.\n   */\n  recommended?: boolean;\n};\n\n/**\n * Represents a provider link.\n */\nexport type ProviderLink = {\n  name: string;\n  url: string;\n};\n\n/**\n * Represents provider logos.\n */\nexport type ProviderLogos = {\n  light: string;\n  dark: string;\n  height: number;\n  width: number;\n};\n\n/**\n * Represents a ramp provider.\n */\nexport type Provider = {\n  id: string;\n  name: string;\n  environmentType: string;\n  description: string;\n  hqAddress: string;\n  links: ProviderLink[];\n  logos: ProviderLogos;\n};\n\n/**\n * Represents a country returned from the regions/countries API.\n */\nexport type Country = {\n  /**\n   * ISO-2 country code (e.g., \"US\", \"GB\").\n   */\n  isoCode: string;\n  /**\n   * Country identifier. Can be in path format (e.g., \"/regions/us\") or ISO code format.\n   * If not provided, defaults to isoCode.\n   */\n  id?: string;\n  /**\n   * Country flag emoji or code.\n   */\n  flag: string;\n  /**\n   * Country name.\n   */\n  name: string;\n  /**\n   * Phone number information.\n   */\n  phone: CountryPhone;\n  /**\n   * Default currency code.\n   */\n  currency: string;\n  /**\n   * Whether this country is supported for ramps.\n   */\n  supported: boolean;\n  /**\n   * Whether this country is recommended.\n   */\n  recommended?: boolean;\n  /**\n   * Array of state objects.\n   */\n  states?: State[];\n  /**\n   * Default amount for ramps transactions.\n   */\n  defaultAmount?: number;\n  /**\n   * Quick amount options for ramps transactions.\n   */\n  quickAmounts?: number[];\n};\n\n/**\n * Represents a token returned from the regions/{region}/tokens API.\n */\nexport type RampsToken = {\n  /**\n   * The asset identifier in CAIP-19 format (e.g., \"eip155:1/erc20:0x...\").\n   */\n  assetId: string;\n  /**\n   * The chain identifier in CAIP-2 format (e.g., \"eip155:1\").\n   */\n  chainId: string;\n  /**\n   * Token name (e.g., \"USD Coin\").\n   */\n  name: string;\n  /**\n   * Token symbol (e.g., \"USDC\").\n   */\n  symbol: string;\n  /**\n   * Number of decimals for the token.\n   */\n  decimals: number;\n  /**\n   * URL to the token icon.\n   */\n  iconUrl: string;\n  /**\n   * Whether this token is supported.\n   */\n  tokenSupported: boolean;\n};\n\n/**\n * Response from the regions/{region}/tokens API.\n */\nexport type TokensResponse = {\n  /**\n   * Top/popular tokens for the region.\n   */\n  topTokens: RampsToken[];\n  /**\n   * All available tokens for the region.\n   */\n  allTokens: RampsToken[];\n};\n\n/**\n * The SDK version to send with API requests. (backwards-compatibility)\n */\nexport const RAMPS_SDK_VERSION = '2.1.6';\n\n// === GENERAL ===\n\n/**\n * The name of the {@link RampsService}, used to namespace the\n * service's actions and events.\n */\nexport const serviceName = 'RampsService';\n\n/**\n * The environment to use for API requests.\n */\nexport enum RampsEnvironment {\n  Production = 'production',\n  Staging = 'staging',\n  Development = 'development',\n}\n\n/**\n * The type of ramps API service.\n * Determines which base URL to use (cache vs standard).\n */\nexport enum RampsApiService {\n  Regions = 'regions',\n  Orders = 'orders',\n}\n\n// === MESSENGER ===\n\nconst MESSENGER_EXPOSED_METHODS = [\n  'getGeolocation',\n  'getCountries',\n  'getTokens',\n  'getProviders',\n] as const;\n\n/**\n * Actions that {@link RampsService} exposes to other consumers.\n */\nexport type RampsServiceActions = RampsServiceMethodActions;\n\n/**\n * Actions from other messengers that {@link RampsService} calls.\n */\ntype AllowedActions = never;\n\n/**\n * Events that {@link RampsService} exposes to other consumers.\n */\nexport type RampsServiceEvents = never;\n\n/**\n * Events from other messengers that {@link RampsService} subscribes to.\n */\ntype AllowedEvents = never;\n\n/**\n * The messenger which is restricted to actions and events accessed by\n * {@link RampsService}.\n */\nexport type RampsServiceMessenger = Messenger<\n  typeof serviceName,\n  RampsServiceActions | AllowedActions,\n  RampsServiceEvents | AllowedEvents\n>;\n\n// === SERVICE DEFINITION ===\n\n/**\n * Gets the base URL for API requests based on the environment and service type.\n * The Regions service uses a cache URL, while other services use the standard URL.\n *\n * @param environment - The environment to use.\n * @param service - The API service type (determines if cache URL is used).\n * @returns The base URL for API requests.\n */\nfunction getBaseUrl(\n  environment: RampsEnvironment,\n  service: RampsApiService,\n): string {\n  const cache = service === RampsApiService.Regions ? '-cache' : '';\n\n  switch (environment) {\n    case RampsEnvironment.Production:\n      return `https://on-ramp${cache}.api.cx.metamask.io`;\n    case RampsEnvironment.Staging:\n    case RampsEnvironment.Development:\n      return `https://on-ramp${cache}.uat-api.cx.metamask.io`;\n    default:\n      throw new Error(`Invalid environment: ${String(environment)}`);\n  }\n}\n\n/**\n * Constructs an API path with a version prefix.\n *\n * @param path - The API endpoint path.\n * @param version - The API version prefix. Defaults to 'v2'.\n * @returns The versioned API path.\n */\nfunction getApiPath(path: string, version: string = 'v2'): string {\n  return `${version}/${path}`;\n}\n\n/**\n * This service object is responsible for interacting with the Ramps API.\n *\n * @example\n *\n * ``` ts\n * import { Messenger } from '@metamask/messenger';\n * import type {\n *   RampsServiceActions,\n *   RampsServiceEvents,\n * } from '@metamask/ramps-controller';\n *\n * const rootMessenger = new Messenger<\n *   'Root',\n *   RampsServiceActions\n *   RampsServiceEvents\n * >({ namespace: 'Root' });\n * const rampsServiceMessenger = new Messenger<\n *   'RampsService',\n *   RampsServiceActions,\n *   RampsServiceEvents,\n *   typeof rootMessenger,\n * >({\n *   namespace: 'RampsService',\n *   parent: rootMessenger,\n * });\n * // Instantiate the service to register its actions on the messenger\n * new RampsService({\n *   messenger: rampsServiceMessenger,\n *   environment: RampsEnvironment.Production,\n *   context: 'mobile-ios',\n *   fetch,\n * });\n *\n * // Later...\n * // Get the user's geolocation\n * const geolocation = await rootMessenger.call(\n *   'RampsService:getGeolocation',\n * );\n * // ... Do something with the geolocation ...\n * ```\n */\nexport class RampsService {\n  /**\n   * The name of the service.\n   */\n  readonly name: typeof serviceName;\n\n  /**\n   * The messenger suited for this service.\n   */\n  readonly #messenger: ConstructorParameters<\n    typeof RampsService\n  >[0]['messenger'];\n\n  /**\n   * A function that can be used to make an HTTP request.\n   */\n  readonly #fetch: ConstructorParameters<typeof RampsService>[0]['fetch'];\n\n  /**\n   * The policy that wraps the request.\n   *\n   * @see {@link createServicePolicy}\n   */\n  readonly #policy: ServicePolicy;\n\n  /**\n   * The environment used for API requests.\n   */\n  readonly #environment: RampsEnvironment;\n\n  /**\n   * The context for API requests (e.g., 'mobile-ios', 'mobile-android').\n   */\n  readonly #context: string;\n\n  /**\n   * Constructs a new RampsService object.\n   *\n   * @param args - The constructor arguments.\n   * @param args.messenger - The messenger suited for this service.\n   * @param args.environment - The environment to use for API requests.\n   * @param args.context - The context for API requests (e.g., 'mobile-ios', 'mobile-android').\n   * @param args.fetch - A function that can be used to make an HTTP request. If\n   * your JavaScript environment supports `fetch` natively, you'll probably want\n   * to pass that; otherwise you can pass an equivalent (such as `fetch` via\n   * `node-fetch`).\n   * @param args.policyOptions - Options to pass to `createServicePolicy`, which\n   * is used to wrap each request. See {@link CreateServicePolicyOptions}.\n   */\n  constructor({\n    messenger,\n    environment = RampsEnvironment.Staging,\n    context,\n    fetch: fetchFunction,\n    policyOptions = {},\n  }: {\n    messenger: RampsServiceMessenger;\n    environment?: RampsEnvironment;\n    context: string;\n    fetch: typeof fetch;\n    policyOptions?: CreateServicePolicyOptions;\n  }) {\n    this.name = serviceName;\n    this.#messenger = messenger;\n    this.#fetch = fetchFunction;\n    this.#policy = createServicePolicy(policyOptions);\n    this.#environment = environment;\n    this.#context = context;\n\n    this.#messenger.registerMethodActionHandlers(\n      this,\n      MESSENGER_EXPOSED_METHODS,\n    );\n  }\n\n  /**\n   * Registers a handler that will be called after a request returns a non-500\n   * response, causing a retry. Primarily useful in tests where timers are being\n   * mocked.\n   *\n   * @param listener - The handler to be called.\n   * @returns An object that can be used to unregister the handler. See\n   * {@link CockatielEvent}.\n   * @see {@link createServicePolicy}\n   */\n  onRetry(\n    listener: Parameters<ServicePolicy['onRetry']>[0],\n  ): ReturnType<ServicePolicy['onRetry']> {\n    return this.#policy.onRetry(listener);\n  }\n\n  /**\n   * Registers a handler that will be called after a set number of retry rounds\n   * prove that requests to the API endpoint consistently return a 5xx response.\n   *\n   * @param listener - The handler to be called.\n   * @returns An object that can be used to unregister the handler. See\n   * {@link CockatielEvent}.\n   * @see {@link createServicePolicy}\n   */\n  onBreak(\n    listener: Parameters<ServicePolicy['onBreak']>[0],\n  ): ReturnType<ServicePolicy['onBreak']> {\n    return this.#policy.onBreak(listener);\n  }\n\n  /**\n   * Registers a handler that will be called under one of two circumstances:\n   *\n   * 1. After a set number of retries prove that requests to the API\n   * consistently result in one of the following failures:\n   *    1. A connection initiation error\n   *    2. A connection reset error\n   *    3. A timeout error\n   *    4. A non-JSON response\n   *    5. A 502, 503, or 504 response\n   * 2. After a successful request is made to the API, but the response takes\n   * longer than a set duration to return.\n   *\n   * @param listener - The handler to be called.\n   * @returns An object that can be used to unregister the handler. See\n   * {@link CockatielEvent}.\n   */\n  onDegraded(\n    listener: Parameters<ServicePolicy['onDegraded']>[0],\n  ): ReturnType<ServicePolicy['onDegraded']> {\n    return this.#policy.onDegraded(listener);\n  }\n\n  /**\n   * Adds common request parameters to a URL.\n   *\n   * @param url - The URL to add parameters to.\n   * @param action - The ramp action type (optional, not all endpoints require it).\n   */\n  #addCommonParams(url: URL, action?: 'buy' | 'sell'): void {\n    if (action) {\n      url.searchParams.set('action', action);\n    }\n    url.searchParams.set('sdk', RAMPS_SDK_VERSION);\n    url.searchParams.set('controller', packageJson.version);\n    url.searchParams.set('context', this.#context);\n  }\n\n  /**\n   * Makes an API request with retry policy and error handling.\n   *\n   * @param service - The API service type (determines base URL).\n   * @param path - The endpoint path.\n   * @param options - Request options.\n   * @param options.action - The ramp action type (optional).\n   * @param options.responseType - How to parse the response ('json' or 'text').\n   * @returns The parsed response data.\n   */\n  async #request<TResponse>(\n    service: RampsApiService,\n    path: string,\n    options: {\n      action?: 'buy' | 'sell';\n      responseType: 'json' | 'text';\n    },\n  ): Promise<TResponse> {\n    return this.#policy.execute(async () => {\n      const baseUrl = getBaseUrl(this.#environment, service);\n      const url = new URL(path, baseUrl);\n      this.#addCommonParams(url, options.action);\n\n      const response = await this.#fetch(url);\n      if (!response.ok) {\n        throw new HttpError(\n          response.status,\n          `Fetching '${url.toString()}' failed with status '${response.status}'`,\n        );\n      }\n\n      return options.responseType === 'json'\n        ? (response.json() as Promise<TResponse>)\n        : (response.text() as Promise<TResponse>);\n    });\n  }\n\n  /**\n   * Makes a request to the API in order to retrieve the user's geolocation\n   * based on their IP address.\n   *\n   * @returns The user's country/region code (e.g., \"US-UT\" for Utah, USA).\n   */\n  async getGeolocation(): Promise<string> {\n    const textResponse = await this.#request<string>(\n      RampsApiService.Orders,\n      'geolocation',\n      { responseType: 'text' },\n    );\n\n    const trimmedResponse = textResponse.trim();\n    if (trimmedResponse.length > 0) {\n      return trimmedResponse;\n    }\n\n    throw new Error('Malformed response received from geolocation API');\n  }\n\n  /**\n   * Makes a request to the cached API to retrieve the list of supported countries.\n   * Filters countries based on aggregator support (preserves OnRampSDK logic).\n   *\n   * @param action - The ramp action type ('buy' or 'sell').\n   * @returns An array of countries filtered by aggregator support.\n   */\n  async getCountries(action: 'buy' | 'sell' = 'buy'): Promise<Country[]> {\n    const countries = await this.#request<Country[]>(\n      RampsApiService.Regions,\n      getApiPath('regions/countries'),\n      { action, responseType: 'json' },\n    );\n\n    if (!Array.isArray(countries)) {\n      throw new Error('Malformed response received from countries API');\n    }\n\n    return countries.filter((country) => {\n      if (country.states && country.states.length > 0) {\n        const hasSupportedState = country.states.some(\n          (state) => state.supported !== false,\n        );\n        return country.supported || hasSupportedState;\n      }\n\n      return country.supported;\n    });\n  }\n\n  /**\n   * Fetches the list of available tokens for a given region and action.\n   *\n   * @param region - The region code (e.g., \"us\", \"fr\", \"us-ny\").\n   * @param action - The ramp action type ('buy' or 'sell').\n   * @returns The tokens response containing topTokens and allTokens.\n   */\n  async getTokens(\n    region: string,\n    action: 'buy' | 'sell' = 'buy',\n  ): Promise<TokensResponse> {\n    const normalizedRegion = region.toLowerCase().trim();\n    const response = await this.#request<TokensResponse>(\n      RampsApiService.Regions,\n      `regions/${normalizedRegion}/tokens`,\n      { action, responseType: 'json' },\n    );\n\n    if (!response || typeof response !== 'object') {\n      throw new Error('Malformed response received from tokens API');\n    }\n\n    if (\n      !Array.isArray(response.topTokens) ||\n      !Array.isArray(response.allTokens)\n    ) {\n      throw new Error('Malformed response received from tokens API');\n    }\n\n    return response;\n  }\n\n  /**\n   * Fetches the list of providers for a given region.\n   * Supports optional query filters: provider, crypto, fiat, payments.\n   *\n   * @param regionCode - The region code (e.g., \"us\", \"fr\", \"us-ny\").\n   * @param options - Optional query parameters for filtering providers.\n   * @param options.provider - Provider ID(s) to filter by.\n   * @param options.crypto - Crypto currency ID(s) to filter by.\n   * @param options.fiat - Fiat currency ID(s) to filter by.\n   * @param options.payments - Payment method ID(s) to filter by.\n   * @returns The providers response containing providers array.\n   */\n  async getProviders(\n    regionCode: string,\n    options?: {\n      provider?: string | string[];\n      crypto?: string | string[];\n      fiat?: string | string[];\n      payments?: string | string[];\n    },\n  ): Promise<{ providers: Provider[] }> {\n    const normalizedRegion = regionCode.toLowerCase().trim();\n    const url = new URL(\n      getApiPath(`regions/${normalizedRegion}/providers`),\n      getBaseUrl(this.#environment, RampsApiService.Regions),\n    );\n    this.#addCommonParams(url);\n\n    if (options?.provider) {\n      const providerIds = Array.isArray(options.provider)\n        ? options.provider\n        : [options.provider];\n      providerIds.forEach((id) => url.searchParams.append('provider', id));\n    }\n\n    if (options?.crypto) {\n      const cryptoIds = Array.isArray(options.crypto)\n        ? options.crypto\n        : [options.crypto];\n      cryptoIds.forEach((id) => url.searchParams.append('crypto', id));\n    }\n\n    if (options?.fiat) {\n      const fiatIds = Array.isArray(options.fiat)\n        ? options.fiat\n        : [options.fiat];\n      fiatIds.forEach((id) => url.searchParams.append('fiat', id));\n    }\n\n    if (options?.payments) {\n      const paymentIds = Array.isArray(options.payments)\n        ? options.payments\n        : [options.payments];\n      paymentIds.forEach((id) => url.searchParams.append('payments', id));\n    }\n\n    const response = await this.#policy.execute(async () => {\n      const fetchResponse = await this.#fetch(url);\n      if (!fetchResponse.ok) {\n        throw new HttpError(\n          fetchResponse.status,\n          `Fetching '${url.toString()}' failed with status '${fetchResponse.status}'`,\n        );\n      }\n      return fetchResponse.json() as Promise<{ providers: Provider[] }>;\n    });\n\n    if (!response || typeof response !== 'object') {\n      throw new Error('Malformed response received from providers API');\n    }\n\n    if (!Array.isArray(response.providers)) {\n      throw new Error('Malformed response received from providers API');\n    }\n\n    return response;\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"RampsService.mjs","sourceRoot":"","sources":["../src/RampsService.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  CreateServicePolicyOptions,\n  ServicePolicy,\n} from '@metamask/controller-utils';\nimport { createServicePolicy, HttpError } from '@metamask/controller-utils';\nimport type { Messenger } from '@metamask/messenger';\n\nimport type { RampsServiceMethodActions } from './RampsService-method-action-types';\nimport packageJson from '../package.json';\n\n/**\n * Represents phone number information for a country.\n */\nexport type CountryPhone = {\n  prefix: string;\n  placeholder: string;\n  template: string;\n};\n\n/**\n * Represents a state/province within a country.\n */\nexport type State = {\n  /**\n   * State identifier. Can be in path format (e.g., \"/regions/us-ut\") or ISO code format (e.g., \"us-ut\").\n   */\n  id?: string;\n  /**\n   * State name.\n   */\n  name?: string;\n  /**\n   * ISO state code (e.g., \"UT\", \"NY\").\n   */\n  stateId?: string;\n  /**\n   * Whether this state is supported for ramps.\n   */\n  supported?: boolean;\n  /**\n   * Whether this state is recommended.\n   */\n  recommended?: boolean;\n};\n\n/**\n * Represents a provider link.\n */\nexport type ProviderLink = {\n  name: string;\n  url: string;\n};\n\n/**\n * Represents provider logos.\n */\nexport type ProviderLogos = {\n  light: string;\n  dark: string;\n  height: number;\n  width: number;\n};\n\n/**\n * Represents a ramp provider.\n */\nexport type Provider = {\n  id: string;\n  name: string;\n  environmentType: string;\n  description: string;\n  hqAddress: string;\n  links: ProviderLink[];\n  logos: ProviderLogos;\n};\n\n/**\n * Represents a country returned from the regions/countries API.\n */\nexport type Country = {\n  /**\n   * ISO-2 country code (e.g., \"US\", \"GB\").\n   */\n  isoCode: string;\n  /**\n   * Country identifier. Can be in path format (e.g., \"/regions/us\") or ISO code format.\n   * If not provided, defaults to isoCode.\n   */\n  id?: string;\n  /**\n   * Country flag emoji or code.\n   */\n  flag: string;\n  /**\n   * Country name.\n   */\n  name: string;\n  /**\n   * Phone number information.\n   */\n  phone: CountryPhone;\n  /**\n   * Default currency code.\n   */\n  currency: string;\n  /**\n   * Whether this country is supported for ramps.\n   */\n  supported: boolean;\n  /**\n   * Whether this country is recommended.\n   */\n  recommended?: boolean;\n  /**\n   * Array of state objects.\n   */\n  states?: State[];\n  /**\n   * Default amount for ramps transactions.\n   */\n  defaultAmount?: number;\n  /**\n   * Quick amount options for ramps transactions.\n   */\n  quickAmounts?: number[];\n};\n\n/**\n * Represents a token returned from the regions/{region}/tokens API.\n */\nexport type RampsToken = {\n  /**\n   * The asset identifier in CAIP-19 format (e.g., \"eip155:1/erc20:0x...\").\n   */\n  assetId: string;\n  /**\n   * The chain identifier in CAIP-2 format (e.g., \"eip155:1\").\n   */\n  chainId: string;\n  /**\n   * Token name (e.g., \"USD Coin\").\n   */\n  name: string;\n  /**\n   * Token symbol (e.g., \"USDC\").\n   */\n  symbol: string;\n  /**\n   * Number of decimals for the token.\n   */\n  decimals: number;\n  /**\n   * URL to the token icon.\n   */\n  iconUrl: string;\n  /**\n   * Whether this token is supported.\n   */\n  tokenSupported: boolean;\n};\n\n/**\n * Response from the regions/{region}/tokens API.\n */\nexport type TokensResponse = {\n  /**\n   * Top/popular tokens for the region.\n   */\n  topTokens: RampsToken[];\n  /**\n   * All available tokens for the region.\n   */\n  allTokens: RampsToken[];\n};\n\n/**\n * The SDK version to send with API requests. (backwards-compatibility)\n */\nexport const RAMPS_SDK_VERSION = '2.1.6';\n\n/**\n * The type of ramp action: 'buy' or 'sell'.\n */\nexport type RampAction = 'buy' | 'sell';\n\n// === GENERAL ===\n\n/**\n * The name of the {@link RampsService}, used to namespace the\n * service's actions and events.\n */\nexport const serviceName = 'RampsService';\n\n/**\n * The environment to use for API requests.\n */\nexport enum RampsEnvironment {\n  Production = 'production',\n  Staging = 'staging',\n  Development = 'development',\n}\n\n/**\n * The type of ramps API service.\n * Determines which base URL to use (cache vs standard).\n */\nexport enum RampsApiService {\n  Regions = 'regions',\n  Orders = 'orders',\n}\n\n// === MESSENGER ===\n\nconst MESSENGER_EXPOSED_METHODS = [\n  'getGeolocation',\n  'getCountries',\n  'getTokens',\n  'getProviders',\n] as const;\n\n/**\n * Actions that {@link RampsService} exposes to other consumers.\n */\nexport type RampsServiceActions = RampsServiceMethodActions;\n\n/**\n * Actions from other messengers that {@link RampsService} calls.\n */\ntype AllowedActions = never;\n\n/**\n * Events that {@link RampsService} exposes to other consumers.\n */\nexport type RampsServiceEvents = never;\n\n/**\n * Events from other messengers that {@link RampsService} subscribes to.\n */\ntype AllowedEvents = never;\n\n/**\n * The messenger which is restricted to actions and events accessed by\n * {@link RampsService}.\n */\nexport type RampsServiceMessenger = Messenger<\n  typeof serviceName,\n  RampsServiceActions | AllowedActions,\n  RampsServiceEvents | AllowedEvents\n>;\n\n// === SERVICE DEFINITION ===\n\n/**\n * Gets the base URL for API requests based on the environment and service type.\n * The Regions service uses a cache URL, while other services use the standard URL.\n *\n * @param environment - The environment to use.\n * @param service - The API service type (determines if cache URL is used).\n * @returns The base URL for API requests.\n */\nfunction getBaseUrl(\n  environment: RampsEnvironment,\n  service: RampsApiService,\n): string {\n  const cache = service === RampsApiService.Regions ? '-cache' : '';\n\n  switch (environment) {\n    case RampsEnvironment.Production:\n      return `https://on-ramp${cache}.api.cx.metamask.io`;\n    case RampsEnvironment.Staging:\n    case RampsEnvironment.Development:\n      return `https://on-ramp${cache}.uat-api.cx.metamask.io`;\n    default:\n      throw new Error(`Invalid environment: ${String(environment)}`);\n  }\n}\n\n/**\n * Constructs an API path with a version prefix.\n *\n * @param path - The API endpoint path.\n * @param version - The API version prefix. Defaults to 'v2'.\n * @returns The versioned API path.\n */\nfunction getApiPath(path: string, version: string = 'v2'): string {\n  return `${version}/${path}`;\n}\n\n/**\n * This service object is responsible for interacting with the Ramps API.\n *\n * @example\n *\n * ``` ts\n * import { Messenger } from '@metamask/messenger';\n * import type {\n *   RampsServiceActions,\n *   RampsServiceEvents,\n * } from '@metamask/ramps-controller';\n *\n * const rootMessenger = new Messenger<\n *   'Root',\n *   RampsServiceActions\n *   RampsServiceEvents\n * >({ namespace: 'Root' });\n * const rampsServiceMessenger = new Messenger<\n *   'RampsService',\n *   RampsServiceActions,\n *   RampsServiceEvents,\n *   typeof rootMessenger,\n * >({\n *   namespace: 'RampsService',\n *   parent: rootMessenger,\n * });\n * // Instantiate the service to register its actions on the messenger\n * new RampsService({\n *   messenger: rampsServiceMessenger,\n *   environment: RampsEnvironment.Production,\n *   context: 'mobile-ios',\n *   fetch,\n * });\n *\n * // Later...\n * // Get the user's geolocation\n * const geolocation = await rootMessenger.call(\n *   'RampsService:getGeolocation',\n * );\n * // ... Do something with the geolocation ...\n * ```\n */\nexport class RampsService {\n  /**\n   * The name of the service.\n   */\n  readonly name: typeof serviceName;\n\n  /**\n   * The messenger suited for this service.\n   */\n  readonly #messenger: ConstructorParameters<\n    typeof RampsService\n  >[0]['messenger'];\n\n  /**\n   * A function that can be used to make an HTTP request.\n   */\n  readonly #fetch: ConstructorParameters<typeof RampsService>[0]['fetch'];\n\n  /**\n   * The policy that wraps the request.\n   *\n   * @see {@link createServicePolicy}\n   */\n  readonly #policy: ServicePolicy;\n\n  /**\n   * The environment used for API requests.\n   */\n  readonly #environment: RampsEnvironment;\n\n  /**\n   * The context for API requests (e.g., 'mobile-ios', 'mobile-android').\n   */\n  readonly #context: string;\n\n  /**\n   * Constructs a new RampsService object.\n   *\n   * @param args - The constructor arguments.\n   * @param args.messenger - The messenger suited for this service.\n   * @param args.environment - The environment to use for API requests.\n   * @param args.context - The context for API requests (e.g., 'mobile-ios', 'mobile-android').\n   * @param args.fetch - A function that can be used to make an HTTP request. If\n   * your JavaScript environment supports `fetch` natively, you'll probably want\n   * to pass that; otherwise you can pass an equivalent (such as `fetch` via\n   * `node-fetch`).\n   * @param args.policyOptions - Options to pass to `createServicePolicy`, which\n   * is used to wrap each request. See {@link CreateServicePolicyOptions}.\n   */\n  constructor({\n    messenger,\n    environment = RampsEnvironment.Staging,\n    context,\n    fetch: fetchFunction,\n    policyOptions = {},\n  }: {\n    messenger: RampsServiceMessenger;\n    environment?: RampsEnvironment;\n    context: string;\n    fetch: typeof fetch;\n    policyOptions?: CreateServicePolicyOptions;\n  }) {\n    this.name = serviceName;\n    this.#messenger = messenger;\n    this.#fetch = fetchFunction;\n    this.#policy = createServicePolicy(policyOptions);\n    this.#environment = environment;\n    this.#context = context;\n\n    this.#messenger.registerMethodActionHandlers(\n      this,\n      MESSENGER_EXPOSED_METHODS,\n    );\n  }\n\n  /**\n   * Registers a handler that will be called after a request returns a non-500\n   * response, causing a retry. Primarily useful in tests where timers are being\n   * mocked.\n   *\n   * @param listener - The handler to be called.\n   * @returns An object that can be used to unregister the handler. See\n   * {@link CockatielEvent}.\n   * @see {@link createServicePolicy}\n   */\n  onRetry(\n    listener: Parameters<ServicePolicy['onRetry']>[0],\n  ): ReturnType<ServicePolicy['onRetry']> {\n    return this.#policy.onRetry(listener);\n  }\n\n  /**\n   * Registers a handler that will be called after a set number of retry rounds\n   * prove that requests to the API endpoint consistently return a 5xx response.\n   *\n   * @param listener - The handler to be called.\n   * @returns An object that can be used to unregister the handler. See\n   * {@link CockatielEvent}.\n   * @see {@link createServicePolicy}\n   */\n  onBreak(\n    listener: Parameters<ServicePolicy['onBreak']>[0],\n  ): ReturnType<ServicePolicy['onBreak']> {\n    return this.#policy.onBreak(listener);\n  }\n\n  /**\n   * Registers a handler that will be called under one of two circumstances:\n   *\n   * 1. After a set number of retries prove that requests to the API\n   * consistently result in one of the following failures:\n   *    1. A connection initiation error\n   *    2. A connection reset error\n   *    3. A timeout error\n   *    4. A non-JSON response\n   *    5. A 502, 503, or 504 response\n   * 2. After a successful request is made to the API, but the response takes\n   * longer than a set duration to return.\n   *\n   * @param listener - The handler to be called.\n   * @returns An object that can be used to unregister the handler. See\n   * {@link CockatielEvent}.\n   */\n  onDegraded(\n    listener: Parameters<ServicePolicy['onDegraded']>[0],\n  ): ReturnType<ServicePolicy['onDegraded']> {\n    return this.#policy.onDegraded(listener);\n  }\n\n  /**\n   * Adds common request parameters to a URL.\n   *\n   * @param url - The URL to add parameters to.\n   * @param action - The ramp action type (optional, not all endpoints require it).\n   */\n  #addCommonParams(url: URL, action?: RampAction): void {\n    if (action) {\n      url.searchParams.set('action', action);\n    }\n    url.searchParams.set('sdk', RAMPS_SDK_VERSION);\n    url.searchParams.set('controller', packageJson.version);\n    url.searchParams.set('context', this.#context);\n  }\n\n  /**\n   * Makes an API request with retry policy and error handling.\n   *\n   * @param service - The API service type (determines base URL).\n   * @param path - The endpoint path.\n   * @param options - Request options.\n   * @param options.action - The ramp action type (optional).\n   * @param options.responseType - How to parse the response ('json' or 'text').\n   * @returns The parsed response data.\n   */\n  async #request<TResponse>(\n    service: RampsApiService,\n    path: string,\n    options: {\n      action?: RampAction;\n      responseType: 'json' | 'text';\n    },\n  ): Promise<TResponse> {\n    return this.#policy.execute(async () => {\n      const baseUrl = getBaseUrl(this.#environment, service);\n      const url = new URL(path, baseUrl);\n      this.#addCommonParams(url, options.action);\n\n      const response = await this.#fetch(url);\n      if (!response.ok) {\n        throw new HttpError(\n          response.status,\n          `Fetching '${url.toString()}' failed with status '${response.status}'`,\n        );\n      }\n\n      return options.responseType === 'json'\n        ? (response.json() as Promise<TResponse>)\n        : (response.text() as Promise<TResponse>);\n    });\n  }\n\n  /**\n   * Makes a request to the API in order to retrieve the user's geolocation\n   * based on their IP address.\n   *\n   * @returns The user's country/region code (e.g., \"US-UT\" for Utah, USA).\n   */\n  async getGeolocation(): Promise<string> {\n    const textResponse = await this.#request<string>(\n      RampsApiService.Orders,\n      'geolocation',\n      { responseType: 'text' },\n    );\n\n    const trimmedResponse = textResponse.trim();\n    if (trimmedResponse.length > 0) {\n      return trimmedResponse;\n    }\n\n    throw new Error('Malformed response received from geolocation API');\n  }\n\n  /**\n   * Makes a request to the cached API to retrieve the list of supported countries.\n   * Filters countries based on aggregator support (preserves OnRampSDK logic).\n   *\n   * @param action - The ramp action type ('buy' or 'sell').\n   * @returns An array of countries filtered by aggregator support.\n   */\n  async getCountries(action: RampAction = 'buy'): Promise<Country[]> {\n    const countries = await this.#request<Country[]>(\n      RampsApiService.Regions,\n      getApiPath('regions/countries'),\n      { action, responseType: 'json' },\n    );\n\n    if (!Array.isArray(countries)) {\n      throw new Error('Malformed response received from countries API');\n    }\n\n    return countries.filter((country) => {\n      if (country.states && country.states.length > 0) {\n        const hasSupportedState = country.states.some(\n          (state) => state.supported !== false,\n        );\n        return country.supported || hasSupportedState;\n      }\n\n      return country.supported;\n    });\n  }\n\n  /**\n   * Fetches the list of available tokens for a given region and action.\n   * Supports optional provider filter.\n   *\n   * @param region - The region code (e.g., \"us\", \"fr\", \"us-ny\").\n   * @param action - The ramp action type ('buy' or 'sell').\n   * @param options - Optional query parameters for filtering tokens.\n   * @param options.provider - Provider ID(s) to filter by.\n   * @returns The tokens response containing topTokens and allTokens.\n   */\n  async getTokens(\n    region: string,\n    action: RampAction = 'buy',\n    options?: {\n      provider?: string | string[];\n    },\n  ): Promise<TokensResponse> {\n    const normalizedRegion = region.toLowerCase().trim();\n    const url = new URL(\n      getApiPath(`regions/${normalizedRegion}/topTokens`),\n      getBaseUrl(this.#environment, RampsApiService.Regions),\n    );\n    this.#addCommonParams(url, action);\n\n    if (options?.provider) {\n      const providerIds = Array.isArray(options.provider)\n        ? options.provider\n        : [options.provider];\n      providerIds.forEach((id) => url.searchParams.append('provider', id));\n    }\n\n    const response = await this.#policy.execute(async () => {\n      const fetchResponse = await this.#fetch(url);\n      if (!fetchResponse.ok) {\n        throw new HttpError(\n          fetchResponse.status,\n          `Fetching '${url.toString()}' failed with status '${fetchResponse.status}'`,\n        );\n      }\n      return fetchResponse.json() as Promise<TokensResponse>;\n    });\n\n    if (!response || typeof response !== 'object') {\n      throw new Error('Malformed response received from tokens API');\n    }\n\n    if (\n      !Array.isArray(response.topTokens) ||\n      !Array.isArray(response.allTokens)\n    ) {\n      throw new Error('Malformed response received from tokens API');\n    }\n\n    return response;\n  }\n\n  /**\n   * Fetches the list of providers for a given region.\n   * Supports optional query filters: provider, crypto, fiat, payments.\n   *\n   * @param regionCode - The region code (e.g., \"us\", \"fr\", \"us-ny\").\n   * @param options - Optional query parameters for filtering providers.\n   * @param options.provider - Provider ID(s) to filter by.\n   * @param options.crypto - Crypto currency ID(s) to filter by.\n   * @param options.fiat - Fiat currency ID(s) to filter by.\n   * @param options.payments - Payment method ID(s) to filter by.\n   * @returns The providers response containing providers array.\n   */\n  async getProviders(\n    regionCode: string,\n    options?: {\n      provider?: string | string[];\n      crypto?: string | string[];\n      fiat?: string | string[];\n      payments?: string | string[];\n    },\n  ): Promise<{ providers: Provider[] }> {\n    const normalizedRegion = regionCode.toLowerCase().trim();\n    const url = new URL(\n      getApiPath(`regions/${normalizedRegion}/providers`),\n      getBaseUrl(this.#environment, RampsApiService.Regions),\n    );\n    this.#addCommonParams(url);\n\n    if (options?.provider) {\n      const providerIds = Array.isArray(options.provider)\n        ? options.provider\n        : [options.provider];\n      providerIds.forEach((id) => url.searchParams.append('provider', id));\n    }\n\n    if (options?.crypto) {\n      const cryptoIds = Array.isArray(options.crypto)\n        ? options.crypto\n        : [options.crypto];\n      cryptoIds.forEach((id) => url.searchParams.append('crypto', id));\n    }\n\n    if (options?.fiat) {\n      const fiatIds = Array.isArray(options.fiat)\n        ? options.fiat\n        : [options.fiat];\n      fiatIds.forEach((id) => url.searchParams.append('fiat', id));\n    }\n\n    if (options?.payments) {\n      const paymentIds = Array.isArray(options.payments)\n        ? options.payments\n        : [options.payments];\n      paymentIds.forEach((id) => url.searchParams.append('payments', id));\n    }\n\n    const response = await this.#policy.execute(async () => {\n      const fetchResponse = await this.#fetch(url);\n      if (!fetchResponse.ok) {\n        throw new HttpError(\n          fetchResponse.status,\n          `Fetching '${url.toString()}' failed with status '${fetchResponse.status}'`,\n        );\n      }\n      return fetchResponse.json() as Promise<{ providers: Provider[] }>;\n    });\n\n    if (!response || typeof response !== 'object') {\n      throw new Error('Malformed response received from providers API');\n    }\n\n    if (!Array.isArray(response.providers)) {\n      throw new Error('Malformed response received from providers API');\n    }\n\n    return response;\n  }\n}\n"]}
\ No newline at end of file
