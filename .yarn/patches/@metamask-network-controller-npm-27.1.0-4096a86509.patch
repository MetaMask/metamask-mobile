diff --git a/dist/NetworkController.cjs b/dist/NetworkController.cjs
index b7bfe76b4398bba90a60be972fc357c2fada6d72..ec62b6eb97d19b34cb94753e0d7fa9d8be487b82 100644
--- a/dist/NetworkController.cjs
+++ b/dist/NetworkController.cjs
@@ -160,11 +160,27 @@ function getDefaultCustomNetworkConfigurationsByChainId() {
     // Create the `networkConfigurationsByChainId` objects explicitly,
     // Because it is not always guaranteed that the custom networks are included in the
     // default networks.
-    return {
+    const configs = {
         [controller_utils_1.ChainId['megaeth-testnet']]: getCustomNetworkConfiguration(controller_utils_1.CustomNetworkType['megaeth-testnet']),
         [controller_utils_1.ChainId['megaeth-testnet-v2']]: getCustomNetworkConfiguration(controller_utils_1.CustomNetworkType['megaeth-testnet-v2']),
         [controller_utils_1.ChainId['monad-testnet']]: getCustomNetworkConfiguration(controller_utils_1.CustomNetworkType['monad-testnet']),
+        // New additions for 20+ network performance testing
+        [controller_utils_1.ChainId[controller_utils_1.BuiltInNetworkName.FantomMainnet]]: getCustomNetworkConfiguration(controller_utils_1.CustomNetworkType['fantom-mainnet']),
+        [controller_utils_1.ChainId[controller_utils_1.BuiltInNetworkName.GnosisMainnet]]: getCustomNetworkConfiguration(controller_utils_1.CustomNetworkType['gnosis-mainnet']),
+        [controller_utils_1.ChainId[controller_utils_1.BuiltInNetworkName.CeloMainnet]]: getCustomNetworkConfiguration(controller_utils_1.CustomNetworkType['celo-mainnet']),
+        [controller_utils_1.ChainId[controller_utils_1.BuiltInNetworkName.CronosMainnet]]: getCustomNetworkConfiguration(controller_utils_1.CustomNetworkType['cronos-mainnet']),
+        [controller_utils_1.ChainId[controller_utils_1.BuiltInNetworkName.Aurora]]: getCustomNetworkConfiguration(controller_utils_1.CustomNetworkType.aurora),
+        [controller_utils_1.ChainId[controller_utils_1.BuiltInNetworkName.MoonbeamMainnet]]: getCustomNetworkConfiguration(controller_utils_1.CustomNetworkType['moonbeam-mainnet']),
+        [controller_utils_1.ChainId[controller_utils_1.BuiltInNetworkName.MoonriverMainnet]]: getCustomNetworkConfiguration(controller_utils_1.CustomNetworkType['moonriver-mainnet']),
+        [controller_utils_1.ChainId[controller_utils_1.BuiltInNetworkName.KlaytnMainnet]]: getCustomNetworkConfiguration(controller_utils_1.CustomNetworkType['klaytn-mainnet']),
+        [controller_utils_1.ChainId[controller_utils_1.BuiltInNetworkName.AvalancheMainnet]]: getCustomNetworkConfiguration(controller_utils_1.CustomNetworkType['avalanche-mainnet']),
+        [controller_utils_1.ChainId[controller_utils_1.BuiltInNetworkName.ZkSyncEraMainnet]]: getCustomNetworkConfiguration(controller_utils_1.CustomNetworkType['zksync-era-mainnet']),
+        [controller_utils_1.ChainId[controller_utils_1.BuiltInNetworkName.PalmMainnet]]: getCustomNetworkConfiguration(controller_utils_1.CustomNetworkType['palm-mainnet']),
+        [controller_utils_1.ChainId[controller_utils_1.BuiltInNetworkName.HyperEvmMainnet]]: getCustomNetworkConfiguration(controller_utils_1.CustomNetworkType['hypervm-mainnet']),
     };
+    console.log('[NetworkController] getDefaultCustomNetworkConfigurationsByChainId - returning', Object.keys(configs).length, 'custom network configurations');
+    console.log('[NetworkController] Custom network chain IDs:', Object.keys(configs));
+    return configs;
 }
 /**
  * Constructs a `NetworkConfiguration` object by `CustomNetworkType`.
@@ -339,14 +355,14 @@ function correctInitialState(state, messenger) {
         if (!availableNetworkClientIds.includes(state.selectedNetworkClientId)) {
             const firstNetworkConfiguration = networkConfigurationsSortedByChainId[0];
             const newSelectedNetworkClientId = firstNetworkConfiguration.rpcEndpoints[firstNetworkConfiguration.defaultRpcEndpointIndex].networkClientId;
-            messenger.call('ErrorReportingService:captureException', new Error(`\`selectedNetworkClientId\` '${state.selectedNetworkClientId}' does not refer to an RPC endpoint within a network configuration; correcting to '${newSelectedNetworkClientId}'`));
+            messenger.captureException?.(new Error(`\`selectedNetworkClientId\` '${state.selectedNetworkClientId}' does not refer to an RPC endpoint within a network configuration; correcting to '${newSelectedNetworkClientId}'`));
             newState.selectedNetworkClientId = newSelectedNetworkClientId;
         }
         if (invalidNetworkClientIdsWithMetadata.length > 0) {
             for (const invalidNetworkClientId of invalidNetworkClientIdsWithMetadata) {
                 delete newState.networksMetadata[invalidNetworkClientId];
             }
-            messenger.call('ErrorReportingService:captureException', new Error('`networksMetadata` had invalid network client IDs, which have been removed'));
+            messenger.captureException?.(new Error('`networksMetadata` had invalid network client IDs, which have been removed'));
         }
     });
 }
diff --git a/dist/NetworkController.cjs.map b/dist/NetworkController.cjs.map
index 79658ce441511a2a1345c07304650b3bfcb71bea..c4878584c74facf1ad8a4cda6fb78288c6845010 100644
--- a/dist/NetworkController.cjs.map
+++ b/dist/NetworkController.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"NetworkController.cjs","sourceRoot":"","sources":["../src/NetworkController.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport type { Partialize } from '@metamask/controller-utils';\nimport {\n  InfuraNetworkType,\n  CustomNetworkType,\n  NetworkType,\n  isSafeChainId,\n  isInfuraNetworkType,\n  ChainId,\n  NetworksTicker,\n  NetworkNickname,\n  BUILT_IN_CUSTOM_NETWORKS_RPC,\n  BUILT_IN_NETWORKS,\n} from '@metamask/controller-utils';\nimport type { ErrorReportingServiceCaptureExceptionAction } from '@metamask/error-reporting-service';\nimport type { PollingBlockTrackerOptions } from '@metamask/eth-block-tracker';\nimport EthQuery from '@metamask/eth-query';\nimport type { Messenger } from '@metamask/messenger';\nimport { errorCodes } from '@metamask/rpc-errors';\nimport {\n  createEventEmitterProxy,\n  createSwappableProxy,\n} from '@metamask/swappable-obj-proxy';\nimport type { SwappableProxy } from '@metamask/swappable-obj-proxy';\nimport type { Hex } from '@metamask/utils';\nimport { hasProperty, isPlainObject, isStrictHexString } from '@metamask/utils';\nimport deepEqual from 'fast-deep-equal';\nimport type { Draft } from 'immer';\nimport { produce } from 'immer';\nimport { cloneDeep } from 'lodash';\nimport type { Logger } from 'loglevel';\nimport { createSelector } from 'reselect';\nimport * as URI from 'uri-js';\nimport { v4 as uuidV4 } from 'uuid';\n\nimport {\n  DEPRECATED_NETWORKS,\n  INFURA_BLOCKED_KEY,\n  NetworkStatus,\n} from './constants';\nimport type {\n  AutoManagedNetworkClient,\n  ProxyWithAccessibleTarget,\n} from './create-auto-managed-network-client';\nimport { createAutoManagedNetworkClient } from './create-auto-managed-network-client';\nimport { projectLogger, createModuleLogger } from './logger';\nimport type { RpcServiceOptions } from './rpc-service/rpc-service';\nimport { NetworkClientType } from './types';\nimport type {\n  BlockTracker,\n  Provider,\n  CustomNetworkClientConfiguration,\n  InfuraNetworkClientConfiguration,\n  NetworkClientConfiguration,\n  AdditionalDefaultNetwork,\n} from './types';\n\nconst debugLog = createModuleLogger(projectLogger, 'NetworkController');\n\nconst INFURA_URL_REGEX =\n  /^https:\\/\\/(?<networkName>[^.]+)\\.infura\\.io\\/v\\d+\\/(?<apiKey>.+)$/u;\n\nexport type Block = {\n  baseFeePerGas?: string;\n};\n\n/**\n * Information about a network not held by any other part of state.\n */\nexport type NetworkMetadata = {\n  /**\n   * EIPs supported by the network.\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  EIPS: {\n    [eipNumber: number]: boolean;\n  };\n  /**\n   * Indicates the availability of the network\n   */\n  status: NetworkStatus;\n};\n\n/**\n * The type of an RPC endpoint.\n *\n * @see {@link CustomRpcEndpoint}\n * @see {@link InfuraRpcEndpoint}\n */\nexport enum RpcEndpointType {\n  Custom = 'custom',\n  Infura = 'infura',\n}\n\n/**\n * An Infura RPC endpoint is a reference to a specific network that Infura\n * supports as well as an Infura account we own that we allow users to make use\n * of for free. We need to disambiguate these endpoints from custom RPC\n * endpoints, because while the types for these kinds of object both have the\n * same interface, the URL for an Infura endpoint contains the Infura project\n * ID, and we don't want this to be present in state. We therefore hide it by\n * representing it in the URL as `{infuraProjectId}`, which we replace this when\n * create network clients. But we need to know somehow that we only need to do\n * this replacement for Infura endpoints and not custom endpoints â€” hence the\n * separate type.\n */\nexport type InfuraRpcEndpoint = {\n  /**\n   * Alternate RPC endpoints to use when this endpoint is down.\n   */\n  failoverUrls?: string[];\n  /**\n   * The optional user-facing nickname of the endpoint.\n   */\n  name?: string;\n  /**\n   * The identifier for the network client that has been created for this RPC\n   * endpoint. This is also used to uniquely identify the RPC endpoint in a\n   * set of RPC endpoints as well: once assigned, it is used to determine\n   * whether the `name`, `type`, or `url` of the RPC endpoint has changed.\n   */\n  networkClientId: BuiltInNetworkClientId;\n  /**\n   * The type of this endpoint, always \"default\".\n   */\n  type: RpcEndpointType.Infura;\n  /**\n   * The URL of the endpoint. Expected to be a template with the string\n   * `{infuraProjectId}`, which will get replaced with the Infura project ID\n   * when the network client is created.\n   */\n  url: `https://${InfuraNetworkType}.infura.io/v3/{infuraProjectId}`;\n};\n\n/**\n * A custom RPC endpoint is a reference to a user-defined server which fronts an\n * EVM chain. It may refer to an Infura network, but only by coincidence.\n */\nexport type CustomRpcEndpoint = {\n  /**\n   * Alternate RPC endpoints to use when this endpoint is down.\n   */\n  failoverUrls?: string[];\n  /**\n   * The optional user-facing nickname of the endpoint.\n   */\n  name?: string;\n  /**\n   * The identifier for the network client that has been created for this RPC\n   * endpoint. This is also used to uniquely identify the RPC endpoint in a\n   * set of RPC endpoints as well: once assigned, it is used to determine\n   * whether the `name`, `type`, or `url` of the RPC endpoint has changed.\n   */\n  networkClientId: CustomNetworkClientId;\n  /**\n   * The type of this endpoint, always \"custom\".\n   */\n  type: RpcEndpointType.Custom;\n  /**\n   * The URL of the endpoint.\n   */\n  url: string;\n};\n\n/**\n * An RPC endpoint is a reference to a server which fronts an EVM chain. There\n * are two varieties of RPC endpoints: Infura and custom.\n *\n * @see {@link CustomRpcEndpoint}\n * @see {@link InfuraRpcEndpoint}\n */\nexport type RpcEndpoint = InfuraRpcEndpoint | CustomRpcEndpoint;\n\n/**\n * From a user perspective, a network configuration holds information about a\n * network that a user can select through the client. A \"network\" in this sense\n * can explicitly refer to an EVM chain that the user explicitly adds or doesn't\n * need to add (because it comes shipped with the client). The properties here\n * therefore directly map to fields that a user sees and can edit for a network\n * within the client.\n *\n * Internally, a network configuration represents a single conceptual EVM chain,\n * which is represented tangibly via multiple RPC endpoints. A \"network\" is then\n * something for which a network client object is created automatically or\n * created on demand when it is added to the client.\n */\nexport type NetworkConfiguration = {\n  /**\n   * A set of URLs that allows the user to view activity that has occurred on\n   * the chain.\n   */\n  blockExplorerUrls: string[];\n  /**\n   * The ID of the chain. Represented in hexadecimal format with a leading \"0x\"\n   * instead of decimal format so that when viewed out of context it can be\n   * unambiguously interpreted.\n   */\n  chainId: Hex;\n  /**\n   * A reference to a URL that the client will use by default to allow the user\n   * to view activity that has occurred on the chain. This index must refer to\n   * an item in `blockExplorerUrls`.\n   */\n  defaultBlockExplorerUrlIndex?: number;\n  /**\n   * A reference to an RPC endpoint that all requests will use by default in order to\n   * interact with the chain. This index must refer to an item in\n   * `rpcEndpoints`.\n   */\n  defaultRpcEndpointIndex: number;\n  /**\n   * The user-facing nickname assigned to the chain.\n   */\n  name: string;\n  /**\n   * The name of the currency to use for the chain.\n   */\n  nativeCurrency: string;\n  /**\n   * The collection of possible RPC endpoints that the client can use to\n   * interact with the chain.\n   */\n  rpcEndpoints: RpcEndpoint[];\n  /**\n   * Profile Sync - Network Sync field.\n   * Allows comparison of local network state with state to sync.\n   */\n  lastUpdatedAt?: number;\n};\n\n/**\n * A custom RPC endpoint in a new network configuration, meant to be used in\n * conjunction with `AddNetworkFields`.\n *\n * Custom RPC endpoints do not need a `networkClientId` property because it is\n * assumed that they have not already been added and therefore network clients\n * do not exist for them yet (and hence IDs need to be generated).\n */\nexport type AddNetworkCustomRpcEndpointFields = Omit<\n  CustomRpcEndpoint,\n  'networkClientId'\n>;\n\n/**\n * A new network configuration that `addNetwork` takes.\n *\n * Custom RPC endpoints do not need a `networkClientId` property because it is\n * assumed that they have not already been added and are not represented by\n * network clients yet.\n */\nexport type AddNetworkFields = Omit<NetworkConfiguration, 'rpcEndpoints'> & {\n  rpcEndpoints: (InfuraRpcEndpoint | AddNetworkCustomRpcEndpointFields)[];\n};\n\n/**\n * A custom RPC endpoint in an updated representation of a network\n * configuration, meant to be used in conjunction with `UpdateNetworkFields`.\n *\n * Custom RPC endpoints do not need a `networkClientId` property because it is\n * assumed that they have not already been added and therefore network clients\n * do not exist for them yet (and hence IDs need to be generated).\n */\nexport type UpdateNetworkCustomRpcEndpointFields = Partialize<\n  CustomRpcEndpoint,\n  'networkClientId'\n>;\n\n/**\n * An updated representation of an existing network configuration that\n * `updateNetwork` takes.\n *\n * Custom RPC endpoints may or may not have a `networkClientId` property; if\n * they do, then it is assumed that they already exist, and if not, then it is\n * assumed that they are new and are not represented by network clients yet.\n */\nexport type UpdateNetworkFields = Omit<NetworkConfiguration, 'rpcEndpoints'> & {\n  rpcEndpoints: (InfuraRpcEndpoint | UpdateNetworkCustomRpcEndpointFields)[];\n};\n\n/**\n * `Object.keys()` is intentionally generic: it returns the keys of an object,\n * but it cannot make guarantees about the contents of that object, so the type\n * of the keys is merely `string[]`. While this is technically accurate, it is\n * also unnecessary if we have an object that we own and whose contents are\n * known exactly.\n *\n * TODO: Move to @metamask/utils.\n *\n * @param object - The object.\n * @returns The keys of an object, typed according to the type of the object\n * itself.\n */\nexport function knownKeysOf<Key extends PropertyKey>(\n  // TODO: Replace `any` with type\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  object: Partial<Record<Key, any>>,\n): Key[] {\n  return Object.keys(object) as Key[];\n}\n\n/**\n * Type guard for determining whether the given value is an error object with a\n * `code` property, such as an instance of Error.\n *\n * TODO: Move this to @metamask/utils.\n *\n * @param error - The object to check.\n * @returns True if `error` has a `code`, false otherwise.\n */\nfunction isErrorWithCode(error: unknown): error is { code: string | number } {\n  return typeof error === 'object' && error !== null && 'code' in error;\n}\n\n/**\n * The string that uniquely identifies an Infura network client.\n */\nexport type BuiltInNetworkClientId = InfuraNetworkType;\n\n/**\n * The string that uniquely identifies a custom network client.\n */\nexport type CustomNetworkClientId = string;\n\n/**\n * The string that uniquely identifies a network client.\n */\nexport type NetworkClientId = BuiltInNetworkClientId | CustomNetworkClientId;\n\n/**\n * Extra information about each network, such as whether it is accessible or\n * blocked and whether it supports EIP-1559, keyed by network client ID.\n */\nexport type NetworksMetadata = Record<NetworkClientId, NetworkMetadata>;\n\n/**\n * The state that NetworkController stores.\n */\nexport type NetworkState = {\n  /**\n   * The ID of the network client that the proxies returned by\n   * `getSelectedNetworkClient` currently point to.\n   */\n  selectedNetworkClientId: NetworkClientId;\n  /**\n   * The registry of networks and corresponding RPC endpoints that the\n   * controller can use to make requests for various chains.\n   *\n   * @see {@link NetworkConfiguration}\n   */\n  networkConfigurationsByChainId: Record<Hex, NetworkConfiguration>;\n  /**\n   * Extra information about each network, such as whether it is accessible or\n   * blocked and whether it supports EIP-1559, keyed by network client ID.\n   */\n  networksMetadata: NetworksMetadata;\n};\n\nconst controllerName = 'NetworkController';\n\n/**\n * Represents the block tracker for the currently selected network. (Note that\n * this is a proxy around a proxy: the inner one exists so that the block\n * tracker doesn't have to exist until it's used, and the outer one exists so\n * that the currently selected network can change without consumers needing to\n * refresh the object reference to that network.)\n */\nexport type BlockTrackerProxy = SwappableProxy<\n  ProxyWithAccessibleTarget<BlockTracker>\n>;\n\n/**\n * Represents the provider for the currently selected network. (Note that this\n * is a proxy around a proxy: the inner one exists so that the provider doesn't\n * have to exist until it's used, and the outer one exists so that the currently\n * selected network can change without consumers needing to refresh the object\n * reference to that network.)\n */\nexport type ProviderProxy = SwappableProxy<ProxyWithAccessibleTarget<Provider>>;\n\nexport type NetworkControllerStateChangeEvent = ControllerStateChangeEvent<\n  typeof controllerName,\n  NetworkState\n>;\n\n/**\n * `networkWillChange` is published when the current network is about to be\n * switched, but the new provider has not been created and no state changes have\n * occurred yet.\n */\nexport type NetworkControllerNetworkWillChangeEvent = {\n  type: 'NetworkController:networkWillChange';\n  payload: [NetworkState];\n};\n\n/**\n * `networkDidChange` is published after a provider has been created for a newly\n * switched network (but before the network has been confirmed to be available).\n */\nexport type NetworkControllerNetworkDidChangeEvent = {\n  type: 'NetworkController:networkDidChange';\n  payload: [NetworkState];\n};\n\n/**\n * `infuraIsBlocked` is published after the network is switched to an Infura\n * network, but when Infura returns an error blocking the user based on their\n * location.\n */\nexport type NetworkControllerInfuraIsBlockedEvent = {\n  type: 'NetworkController:infuraIsBlocked';\n  payload: [];\n};\n\n/**\n * `infuraIsBlocked` is published either after the network is switched to an\n * Infura network and Infura does not return an error blocking the user based on\n * their location, or the network is switched to a non-Infura network.\n */\nexport type NetworkControllerInfuraIsUnblockedEvent = {\n  type: 'NetworkController:infuraIsUnblocked';\n  payload: [];\n};\n\n/**\n * `networkAdded` is published after a network configuration is added to the\n * network configuration registry and network clients are created for it.\n */\nexport type NetworkControllerNetworkAddedEvent = {\n  type: 'NetworkController:networkAdded';\n  payload: [networkConfiguration: NetworkConfiguration];\n};\n\n/**\n * `networkRemoved` is published after a network configuration is removed from the\n * network configuration registry and once the network clients have been removed.\n */\nexport type NetworkControllerNetworkRemovedEvent = {\n  type: 'NetworkController:networkRemoved';\n  payload: [networkConfiguration: NetworkConfiguration];\n};\n\n/**\n * `NetworkController:rpcEndpointChainUnavailable` is published when, after\n * trying all endpoints in an endpoint chain, the last failover reaches a\n * maximum number of consecutive 5xx responses, breaking the underlying circuit.\n *\n * In other words, this event will not be published if a failover is available,\n * even if the primary is not.\n *\n * @param payload - The event payload.\n * @param payload.chainId - The target network's chain ID.\n * @param payload.error - The last error produced by the last failover in the\n * endpoint chain.\n * @param payload.networkClientId - The target network's client ID.\n */\nexport type NetworkControllerRpcEndpointChainUnavailableEvent = {\n  type: 'NetworkController:rpcEndpointChainUnavailable';\n  payload: [\n    {\n      chainId: Hex;\n      error: unknown;\n      networkClientId: NetworkClientId;\n    },\n  ];\n};\n\n/**\n * `NetworkController:rpcEndpointUnavailable` is published when any\n * endpoint in an endpoint chain reaches a maximum number of consecutive 5xx\n * responses, breaking the underlying circuit.\n *\n * In other words, this event will be published if a primary is not available,\n * even if a failover is.\n *\n * @param payload - The event payload.\n * @param payload.chainId - The target network's chain ID.\n * @param payload.endpointUrl - The URL of the endpoint which reached the\n * maximum number of consecutive 5xx responses. You can compare this to\n * `primaryEndpointUrl` to know whether it was a failover or a primary.\n * @param payload.error - The last error produced by the endpoint.\n * @param payload.networkClientId - The target network's client ID.\n * @param payload.primaryEndpointUrl - The endpoint chain's primary URL.\n */\nexport type NetworkControllerRpcEndpointUnavailableEvent = {\n  type: 'NetworkController:rpcEndpointUnavailable';\n  payload: [\n    {\n      chainId: Hex;\n      endpointUrl: string;\n      error: unknown;\n      networkClientId: NetworkClientId;\n      primaryEndpointUrl: string;\n    },\n  ];\n};\n\n/**\n * `NetworkController:rpcEndpointChainDegraded` is published for any of the\n * endpoints in an endpoint chain when one of the following two conditions hold\n * (and the chain is not already in a degraded state):\n *\n * 1. A successful (2xx) request, even after being retried, cannot be made to\n * the endpoint.\n * 2. A successful (2xx) request can be made to the endpoint, but it takes\n * longer than expected to complete.\n *\n * Note that this event will be published even if there are local connectivity\n * issues which prevent requests from being initiated. This is intentional.\n *\n * @param payload - The event payload.\n * @param payload.chainId - The target network's chain ID.\n * @param payload.error - The last error produced by the endpoint (or\n * `undefined` if the request was slow).\n * @param payload.networkClientId - The target network's client ID.\n */\nexport type NetworkControllerRpcEndpointChainDegradedEvent = {\n  type: 'NetworkController:rpcEndpointChainDegraded';\n  payload: [\n    {\n      chainId: Hex;\n      error: unknown;\n      networkClientId: NetworkClientId;\n    },\n  ];\n};\n\n/**\n *\n * `NetworkController:rpcEndpointDegraded` is published for any of the endpoints\n * in an endpoint chain when:\n *\n * 1. A successful (2xx) request, even after being retried, cannot be made to\n * the endpoint.\n * 2. A successful (2xx) request can be made to the endpoint, but it takes\n * longer than expected to complete.\n *\n * Note that this event will be published even if there are local connectivity\n * issues which prevent requests from being initiated. This is intentional.\n *\n * @param payload - The event payload.\n * @param payload.chainId - The target network's chain ID.\n * @param payload.endpointUrl - The URL of the endpoint for which requests\n * failed or were slow to complete. You can compare this to `primaryEndpointUrl`\n * to know whether it was a failover or a primary.\n * @param payload.error - The last error produced by the endpoint (or\n * `undefined` if the request was slow).\n * @param payload.networkClientId - The target network's client ID.\n * @param payload.primaryEndpointUrl - The endpoint chain's primary URL.\n */\nexport type NetworkControllerRpcEndpointDegradedEvent = {\n  type: 'NetworkController:rpcEndpointDegraded';\n  payload: [\n    {\n      chainId: Hex;\n      endpointUrl: string;\n      error: unknown;\n      networkClientId: NetworkClientId;\n      primaryEndpointUrl: string;\n    },\n  ];\n};\n\n/**\n * `NetworkController:rpcEndpointChainAvailable` is published in one of two\n * cases:\n *\n * 1. The first time that a 2xx request is made to any of the endpoints in an\n * endpoint chain.\n * 2. When requests to any of the endpoints previously failed (placing the\n * endpoint in a degraded or unavailable status), but are now succeeding again.\n *\n * @param payload - The event payload.\n * @param payload.chainId - The target network's chain ID.\n * @param payload.networkClientId - The target network's client ID.\n */\nexport type NetworkControllerRpcEndpointChainAvailableEvent = {\n  type: 'NetworkController:rpcEndpointChainAvailable';\n  payload: [\n    {\n      chainId: Hex;\n      networkClientId: NetworkClientId;\n    },\n  ];\n};\n\n/**\n * `NetworkController:rpcEndpointRetried` is published before a request to any\n * endpoint in an endpoint chain is retried.\n *\n * This is mainly useful for tests.\n *\n * @param payload - The event payload.\n * @param payload.attempt - The current attempt counter for the endpoint\n * (starting from 0).\n * @param payload.chainId - The target network's chain ID.\n * @param payload.endpointUrl - The URL of the endpoint being retried.\n * @param payload.networkClientId - The target network's client ID.\n * @param payload.primaryEndpointUrl - The endpoint chain's primary URL.\n * @see {@link RpcService} for the list of retriable errors.\n */\nexport type NetworkControllerRpcEndpointRetriedEvent = {\n  type: 'NetworkController:rpcEndpointRetried';\n  payload: [\n    {\n      attempt: number;\n      chainId: Hex;\n      endpointUrl: string;\n      networkClientId: NetworkClientId;\n      primaryEndpointUrl: string;\n    },\n  ];\n};\n\nexport type NetworkControllerEvents =\n  | NetworkControllerStateChangeEvent\n  | NetworkControllerNetworkWillChangeEvent\n  | NetworkControllerNetworkDidChangeEvent\n  | NetworkControllerInfuraIsBlockedEvent\n  | NetworkControllerInfuraIsUnblockedEvent\n  | NetworkControllerNetworkAddedEvent\n  | NetworkControllerNetworkRemovedEvent\n  | NetworkControllerRpcEndpointChainUnavailableEvent\n  | NetworkControllerRpcEndpointUnavailableEvent\n  | NetworkControllerRpcEndpointChainDegradedEvent\n  | NetworkControllerRpcEndpointDegradedEvent\n  | NetworkControllerRpcEndpointChainAvailableEvent\n  | NetworkControllerRpcEndpointRetriedEvent;\n\n/**\n * All events that {@link NetworkController} calls internally.\n */\ntype AllowedEvents = never;\n\nexport type NetworkControllerGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  NetworkState\n>;\n\nexport type NetworkControllerGetEthQueryAction = {\n  type: `NetworkController:getEthQuery`;\n  handler: () => EthQuery | undefined;\n};\n\nexport type NetworkControllerGetNetworkClientByIdAction = {\n  type: `NetworkController:getNetworkClientById`;\n  handler: NetworkController['getNetworkClientById'];\n};\n\nexport type NetworkControllerGetSelectedNetworkClientAction = {\n  type: `NetworkController:getSelectedNetworkClient`;\n  handler: NetworkController['getSelectedNetworkClient'];\n};\n\nexport type NetworkControllerGetSelectedChainIdAction = {\n  type: 'NetworkController:getSelectedChainId';\n  handler: NetworkController['getSelectedChainId'];\n};\n\nexport type NetworkControllerGetEIP1559CompatibilityAction = {\n  type: `NetworkController:getEIP1559Compatibility`;\n  handler: NetworkController['getEIP1559Compatibility'];\n};\n\nexport type NetworkControllerFindNetworkClientIdByChainIdAction = {\n  type: `NetworkController:findNetworkClientIdByChainId`;\n  handler: NetworkController['findNetworkClientIdByChainId'];\n};\n\n/**\n * Change the currently selected network to the given built-in network type.\n *\n * @deprecated This action has been replaced by `setActiveNetwork`, and will be\n * removed in a future release.\n */\nexport type NetworkControllerSetProviderTypeAction = {\n  type: `NetworkController:setProviderType`;\n  handler: NetworkController['setProviderType'];\n};\n\nexport type NetworkControllerSetActiveNetworkAction = {\n  type: `NetworkController:setActiveNetwork`;\n  handler: NetworkController['setActiveNetwork'];\n};\n\nexport type NetworkControllerGetNetworkConfigurationByChainId = {\n  type: `NetworkController:getNetworkConfigurationByChainId`;\n  handler: NetworkController['getNetworkConfigurationByChainId'];\n};\n\nexport type NetworkControllerGetNetworkConfigurationByNetworkClientId = {\n  type: `NetworkController:getNetworkConfigurationByNetworkClientId`;\n  handler: NetworkController['getNetworkConfigurationByNetworkClientId'];\n};\n\nexport type NetworkControllerAddNetworkAction = {\n  type: 'NetworkController:addNetwork';\n  handler: NetworkController['addNetwork'];\n};\n\nexport type NetworkControllerRemoveNetworkAction = {\n  type: 'NetworkController:removeNetwork';\n  handler: NetworkController['removeNetwork'];\n};\n\nexport type NetworkControllerUpdateNetworkAction = {\n  type: 'NetworkController:updateNetwork';\n  handler: NetworkController['updateNetwork'];\n};\n\nexport type NetworkControllerActions =\n  | NetworkControllerGetStateAction\n  | NetworkControllerGetEthQueryAction\n  | NetworkControllerGetNetworkClientByIdAction\n  | NetworkControllerGetSelectedNetworkClientAction\n  | NetworkControllerGetSelectedChainIdAction\n  | NetworkControllerGetEIP1559CompatibilityAction\n  | NetworkControllerFindNetworkClientIdByChainIdAction\n  | NetworkControllerSetActiveNetworkAction\n  | NetworkControllerSetProviderTypeAction\n  | NetworkControllerGetNetworkConfigurationByChainId\n  | NetworkControllerGetNetworkConfigurationByNetworkClientId\n  | NetworkControllerAddNetworkAction\n  | NetworkControllerRemoveNetworkAction\n  | NetworkControllerUpdateNetworkAction;\n\n/**\n * All actions that {@link NetworkController} calls internally.\n */\ntype AllowedActions = ErrorReportingServiceCaptureExceptionAction;\n\nexport type NetworkControllerMessenger = Messenger<\n  typeof controllerName,\n  NetworkControllerActions | AllowedActions,\n  NetworkControllerEvents | AllowedEvents\n>;\n\n/**\n * Options for the NetworkController constructor.\n */\nexport type NetworkControllerOptions = {\n  /**\n   * The messenger suited for this controller.\n   */\n  messenger: NetworkControllerMessenger;\n  /**\n   * The API key for Infura, used to make requests to Infura.\n   */\n  infuraProjectId: string;\n  /**\n   * The desired state with which to initialize this controller.\n   * Missing properties will be filled in with defaults. For instance, if not\n   * specified, `networkConfigurationsByChainId` will default to a basic set of\n   * network configurations (see {@link InfuraNetworkType} for the list).\n   */\n  state?: Partial<NetworkState>;\n  /**\n   * A `loglevel` logger object.\n   */\n  log?: Logger;\n  /**\n   * A function that can be used to customize a RPC service constructed for an\n   * RPC endpoint. The function takes the URL of the endpoint and should return\n   * an object with type {@link RpcServiceOptions}, minus `failoverService`\n   * and `endpointUrl` (as they are filled in automatically).\n   */\n  getRpcServiceOptions: (\n    rpcEndpointUrl: string,\n  ) => Omit<RpcServiceOptions, 'failoverService' | 'endpointUrl'>;\n  /**\n   * A function that can be used to customize a block tracker constructed for an\n   * RPC endpoint. The function takes the URL of the endpoint and should return\n   * an object of type {@link PollingBlockTrackerOptions}, minus `provider` (as\n   * it is filled in automatically).\n   */\n  getBlockTrackerOptions?: (\n    rpcEndpointUrl: string,\n  ) => Omit<PollingBlockTrackerOptions, 'provider'>;\n  /**\n   * An array of Hex Chain IDs representing the additional networks to be included as default.\n   */\n  additionalDefaultNetworks?: AdditionalDefaultNetwork[];\n  /**\n   * Whether or not requests sent to unavailable RPC endpoints should be\n   * automatically diverted to configured failover RPC endpoints.\n   */\n  isRpcFailoverEnabled?: boolean;\n};\n\n/**\n * Constructs a value for the state property `networkConfigurationsByChainId`\n * which will be used if it has not been provided to the constructor.\n *\n * @param [additionalDefaultNetworks] - An array of Hex Chain IDs representing the additional networks to be included as default.\n * @returns The default value for `networkConfigurationsByChainId`.\n */\nfunction getDefaultNetworkConfigurationsByChainId(\n  additionalDefaultNetworks: AdditionalDefaultNetwork[] = [],\n): Record<Hex, NetworkConfiguration> {\n  const infuraNetworks = getDefaultInfuraNetworkConfigurationsByChainId();\n  const customNetworks = getDefaultCustomNetworkConfigurationsByChainId();\n\n  return additionalDefaultNetworks.reduce<Record<Hex, NetworkConfiguration>>(\n    (obj, chainId) => {\n      if (hasProperty(customNetworks, chainId)) {\n        obj[chainId] = customNetworks[chainId];\n      }\n      return obj;\n    },\n    // Always include the infura networks in the default networks\n    infuraNetworks,\n  );\n}\n\n/**\n * Constructs a `networkConfigurationsByChainId` object for all default Infura networks.\n *\n * @returns The `networkConfigurationsByChainId` object of all Infura networks.\n */\nfunction getDefaultInfuraNetworkConfigurationsByChainId(): Record<\n  Hex,\n  NetworkConfiguration\n> {\n  return Object.values(InfuraNetworkType).reduce<\n    Record<Hex, NetworkConfiguration>\n  >((obj, infuraNetworkType) => {\n    const chainId = ChainId[infuraNetworkType];\n\n    // Skip deprecated network as default network.\n    if (DEPRECATED_NETWORKS.has(chainId)) {\n      return obj;\n    }\n\n    const rpcEndpointUrl =\n      `https://${infuraNetworkType}.infura.io/v3/{infuraProjectId}` as const;\n\n    const networkConfiguration: NetworkConfiguration = {\n      blockExplorerUrls: [],\n      chainId,\n      defaultRpcEndpointIndex: 0,\n      name: NetworkNickname[infuraNetworkType],\n      nativeCurrency: NetworksTicker[infuraNetworkType],\n      rpcEndpoints: [\n        {\n          failoverUrls: [],\n          networkClientId: infuraNetworkType,\n          type: RpcEndpointType.Infura,\n          url: rpcEndpointUrl,\n        },\n      ],\n    };\n\n    return { ...obj, [chainId]: networkConfiguration };\n  }, {});\n}\n\n/**\n * Constructs a `networkConfigurationsByChainId` object for all default custom networks.\n *\n * @returns The `networkConfigurationsByChainId` object of all custom networks.\n */\nfunction getDefaultCustomNetworkConfigurationsByChainId(): Record<\n  Hex,\n  NetworkConfiguration\n> {\n  // Create the `networkConfigurationsByChainId` objects explicitly,\n  // Because it is not always guaranteed that the custom networks are included in the\n  // default networks.\n  return {\n    [ChainId['megaeth-testnet']]: getCustomNetworkConfiguration(\n      CustomNetworkType['megaeth-testnet'],\n    ),\n    [ChainId['megaeth-testnet-v2']]: getCustomNetworkConfiguration(\n      CustomNetworkType['megaeth-testnet-v2'],\n    ),\n    [ChainId['monad-testnet']]: getCustomNetworkConfiguration(\n      CustomNetworkType['monad-testnet'],\n    ),\n  };\n}\n\n/**\n * Constructs a `NetworkConfiguration` object by `CustomNetworkType`.\n *\n * @param customNetworkType - The type of the custom network.\n * @returns The `NetworkConfiguration` object.\n */\nfunction getCustomNetworkConfiguration(\n  customNetworkType: CustomNetworkType,\n): NetworkConfiguration {\n  const { ticker, rpcPrefs } = BUILT_IN_NETWORKS[customNetworkType];\n  const rpcEndpointUrl = BUILT_IN_CUSTOM_NETWORKS_RPC[customNetworkType];\n\n  return {\n    blockExplorerUrls: [rpcPrefs.blockExplorerUrl],\n    chainId: ChainId[customNetworkType],\n    defaultRpcEndpointIndex: 0,\n    defaultBlockExplorerUrlIndex: 0,\n    name: NetworkNickname[customNetworkType],\n    nativeCurrency: ticker,\n    rpcEndpoints: [\n      {\n        failoverUrls: [],\n        networkClientId: customNetworkType,\n        type: RpcEndpointType.Custom,\n        url: rpcEndpointUrl,\n      },\n    ],\n  };\n}\n\n/**\n * Constructs properties for the NetworkController state whose values will be\n * used if not provided to the constructor.\n *\n * @param [additionalDefaultNetworks] - An array of Hex Chain IDs representing the additional networks to be included as default.\n * @returns The default NetworkController state.\n */\nexport function getDefaultNetworkControllerState(\n  additionalDefaultNetworks?: AdditionalDefaultNetwork[],\n): NetworkState {\n  const networksMetadata = {};\n  const networkConfigurationsByChainId =\n    getDefaultNetworkConfigurationsByChainId(additionalDefaultNetworks);\n\n  return {\n    selectedNetworkClientId: InfuraNetworkType.mainnet,\n    networksMetadata,\n    networkConfigurationsByChainId,\n  };\n}\n\n/**\n * Redux selector for getting all network configurations from NetworkController\n * state, keyed by chain ID.\n *\n * @param state - NetworkController state\n * @returns All registered network configurations, keyed by chain ID.\n */\nconst selectNetworkConfigurationsByChainId = (\n  state: NetworkState,\n): Record<`0x${string}`, NetworkConfiguration> =>\n  state.networkConfigurationsByChainId;\n\n/**\n * Get a list of all network configurations.\n *\n * @param state - NetworkController state\n * @returns A list of all available network configurations\n */\nexport function getNetworkConfigurations(\n  state: NetworkState,\n): NetworkConfiguration[] {\n  return Object.values(state.networkConfigurationsByChainId);\n}\n\n/**\n * Redux selector for getting a list of all network configurations from\n * NetworkController state.\n *\n * @param state - NetworkController state\n * @returns A list of all available network configurations\n */\nexport const selectNetworkConfigurations = createSelector(\n  selectNetworkConfigurationsByChainId,\n  (networkConfigurationsByChainId) =>\n    Object.values(networkConfigurationsByChainId),\n);\n\n/**\n * Get a list of all available network client IDs from a list of network\n * configurations.\n *\n * @param networkConfigurations - The array of network configurations\n * @returns A list of all available client IDs\n */\nexport function getAvailableNetworkClientIds(\n  networkConfigurations: NetworkConfiguration[],\n): string[] {\n  return networkConfigurations.flatMap((networkConfiguration) =>\n    networkConfiguration.rpcEndpoints.map(\n      (rpcEndpoint) => rpcEndpoint.networkClientId,\n    ),\n  );\n}\n\n/**\n * Redux selector for getting a list of all available network client IDs\n * from NetworkController state.\n *\n * @param state - NetworkController state\n * @returns A list of all available network client IDs.\n */\nexport const selectAvailableNetworkClientIds = createSelector(\n  selectNetworkConfigurations,\n  getAvailableNetworkClientIds,\n);\n\n/**\n * The collection of auto-managed network clients that map to Infura networks.\n */\nexport type AutoManagedBuiltInNetworkClientRegistry = Record<\n  BuiltInNetworkClientId,\n  AutoManagedNetworkClient<InfuraNetworkClientConfiguration>\n>;\n\n/**\n * The collection of auto-managed network clients that map to Infura networks.\n */\nexport type AutoManagedCustomNetworkClientRegistry = Record<\n  CustomNetworkClientId,\n  AutoManagedNetworkClient<CustomNetworkClientConfiguration>\n>;\n\n/**\n * The collection of auto-managed network clients that map to Infura networks\n * as well as custom networks that users have added.\n */\nexport type AutoManagedNetworkClientRegistry = {\n  [NetworkClientType.Infura]: AutoManagedBuiltInNetworkClientRegistry;\n  [NetworkClientType.Custom]: AutoManagedCustomNetworkClientRegistry;\n};\n\n/**\n * Instructs `addNetwork` and `updateNetwork` to create a network client for an\n * RPC endpoint.\n *\n * @see {@link NetworkClientOperation}\n */\ntype AddNetworkClientOperation = {\n  type: 'add';\n  rpcEndpoint: RpcEndpoint;\n};\n\n/**\n * Instructs `updateNetwork` and `removeNetwork` to remove a network client for\n * an RPC endpoint.\n *\n * @see {@link NetworkClientOperation}\n */\ntype RemoveNetworkClientOperation = {\n  type: 'remove';\n  rpcEndpoint: RpcEndpoint;\n};\n\n/**\n * Instructs `addNetwork` and `updateNetwork` to replace the network client for\n * an RPC endpoint.\n *\n * @see {@link NetworkClientOperation}\n */\ntype ReplaceNetworkClientOperation = {\n  type: 'replace';\n  oldRpcEndpoint: RpcEndpoint;\n  newRpcEndpoint: RpcEndpoint;\n};\n\n/**\n * Instructs `addNetwork` and `updateNetwork` not to do anything with an RPC\n * endpoint, as far as the network client registry is concerned.\n *\n * @see {@link NetworkClientOperation}\n */\ntype NoopNetworkClientOperation = {\n  type: 'noop';\n  rpcEndpoint: RpcEndpoint;\n};\n\n/**\n * Instructs `addNetwork`, `updateNetwork`, and `removeNetwork` how to\n * update the network client registry.\n *\n * - When `addNetwork` is called, represents a network client that should be\n * created for a new RPC endpoint.\n * - When `removeNetwork` is called, represents a network client that should be\n * destroyed for a previously existing RPC endpoint.\n * - When `updateNetwork` is called, represents either:\n *   - a network client that should be added for a new RPC endpoint\n *   - a network client that should be removed for a previously existing RPC\n *   endpoint\n *   - a network client that should be replaced for an RPC endpoint that was\n *   changed in a non-major way, or\n *   - a network client that should be unchanged for an RPC endpoint that was\n *   also unchanged.\n */\ntype NetworkClientOperation =\n  | AddNetworkClientOperation\n  | RemoveNetworkClientOperation\n  | ReplaceNetworkClientOperation\n  | NoopNetworkClientOperation;\n\n/**\n * Determines whether the given URL is valid by attempting to parse it.\n *\n * @param url - The URL to test.\n * @returns True if the URL is valid, false otherwise.\n */\nfunction isValidUrl(url: string): boolean {\n  const uri = URI.parse(url);\n  return (\n    uri.error === undefined && (uri.scheme === 'http' || uri.scheme === 'https')\n  );\n}\n\n/**\n * Given an Infura API URL, extracts the subdomain that identifies the Infura\n * network.\n *\n * @param rpcEndpointUrl - The URL to operate on.\n * @returns The Infura network name that the URL references.\n * @throws if the URL is not an Infura API URL, or if an Infura network is not\n * present in the URL.\n */\nfunction deriveInfuraNetworkNameFromRpcEndpointUrl(\n  rpcEndpointUrl: string,\n): InfuraNetworkType {\n  const match = INFURA_URL_REGEX.exec(rpcEndpointUrl);\n\n  if (match?.groups) {\n    if (isInfuraNetworkType(match.groups.networkName)) {\n      return match.groups.networkName;\n    }\n\n    throw new Error(`Unknown Infura network '${match.groups.networkName}'`);\n  }\n\n  throw new Error('Could not derive Infura network from RPC endpoint URL');\n}\n\n/**\n * Performs a series of checks that the given NetworkController state is\n * internally consistent â€” that all parts of state that are supposed to match in\n * fact do â€” so that working with the state later on doesn't cause unexpected\n * errors.\n *\n * In the case of NetworkController, there are several parts of state that need\n * to match. For instance, `defaultRpcEndpointIndex` needs to match an entry\n * within `rpcEndpoints`, and `selectedNetworkClientId` needs to point to an RPC\n * endpoint within a network configuration.\n *\n * @param state - The NetworkController state to verify.\n * @throws if the state is invalid in some way.\n */\nfunction validateInitialState(state: NetworkState): void {\n  const networkConfigurationEntries = Object.entries(\n    state.networkConfigurationsByChainId,\n  );\n  const networkClientIds = getAvailableNetworkClientIds(\n    getNetworkConfigurations(state),\n  );\n\n  if (networkConfigurationEntries.length === 0) {\n    throw new Error(\n      'NetworkController state is invalid: `networkConfigurationsByChainId` cannot be empty',\n    );\n  }\n\n  for (const [chainId, networkConfiguration] of networkConfigurationEntries) {\n    if (chainId !== networkConfiguration.chainId) {\n      throw new Error(\n        `NetworkController state has invalid \\`networkConfigurationsByChainId\\`: Network configuration '${networkConfiguration.name}' is filed under '${chainId}' which does not match its \\`chainId\\` of '${networkConfiguration.chainId}'`,\n      );\n    }\n\n    const isInvalidDefaultBlockExplorerUrlIndex =\n      networkConfiguration.blockExplorerUrls.length > 0\n        ? networkConfiguration.defaultBlockExplorerUrlIndex === undefined ||\n          networkConfiguration.blockExplorerUrls[\n            networkConfiguration.defaultBlockExplorerUrlIndex\n          ] === undefined\n        : networkConfiguration.defaultBlockExplorerUrlIndex !== undefined;\n\n    if (isInvalidDefaultBlockExplorerUrlIndex) {\n      throw new Error(\n        `NetworkController state has invalid \\`networkConfigurationsByChainId\\`: Network configuration '${networkConfiguration.name}' has a \\`defaultBlockExplorerUrlIndex\\` that does not refer to an entry in \\`blockExplorerUrls\\``,\n      );\n    }\n\n    if (\n      networkConfiguration.rpcEndpoints[\n        networkConfiguration.defaultRpcEndpointIndex\n      ] === undefined\n    ) {\n      throw new Error(\n        `NetworkController state has invalid \\`networkConfigurationsByChainId\\`: Network configuration '${networkConfiguration.name}' has a \\`defaultRpcEndpointIndex\\` that does not refer to an entry in \\`rpcEndpoints\\``,\n      );\n    }\n  }\n\n  if ([...new Set(networkClientIds)].length < networkClientIds.length) {\n    throw new Error(\n      'NetworkController state has invalid `networkConfigurationsByChainId`: Every RPC endpoint across all network configurations must have a unique `networkClientId`',\n    );\n  }\n}\n\n/**\n * Checks that the given initial NetworkController state is internally\n * consistent similar to `validateInitialState`, but if an anomaly is detected,\n * it does its best to correct the state and logs an error to Sentry.\n *\n * @param state - The NetworkController state to verify.\n * @param messenger - The NetworkController messenger.\n * @returns The corrected state.\n */\nfunction correctInitialState(\n  state: NetworkState,\n  messenger: NetworkControllerMessenger,\n): NetworkState {\n  const networkConfigurationsSortedByChainId = getNetworkConfigurations(\n    state,\n  ).sort((a, b) => a.chainId.localeCompare(b.chainId));\n  const availableNetworkClientIds = getAvailableNetworkClientIds(\n    networkConfigurationsSortedByChainId,\n  );\n  const invalidNetworkClientIdsWithMetadata = Object.keys(\n    state.networksMetadata,\n  ).filter(\n    (networkClientId) => !availableNetworkClientIds.includes(networkClientId),\n  );\n\n  return produce(state, (newState) => {\n    if (!availableNetworkClientIds.includes(state.selectedNetworkClientId)) {\n      const firstNetworkConfiguration = networkConfigurationsSortedByChainId[0];\n      const newSelectedNetworkClientId =\n        firstNetworkConfiguration.rpcEndpoints[\n          firstNetworkConfiguration.defaultRpcEndpointIndex\n        ].networkClientId;\n      messenger.call(\n        'ErrorReportingService:captureException',\n        new Error(\n          `\\`selectedNetworkClientId\\` '${state.selectedNetworkClientId}' does not refer to an RPC endpoint within a network configuration; correcting to '${newSelectedNetworkClientId}'`,\n        ),\n      );\n      newState.selectedNetworkClientId = newSelectedNetworkClientId;\n    }\n\n    if (invalidNetworkClientIdsWithMetadata.length > 0) {\n      for (const invalidNetworkClientId of invalidNetworkClientIdsWithMetadata) {\n        delete newState.networksMetadata[invalidNetworkClientId];\n      }\n      messenger.call(\n        'ErrorReportingService:captureException',\n        new Error(\n          '`networksMetadata` had invalid network client IDs, which have been removed',\n        ),\n      );\n    }\n  });\n}\n\n/**\n * Transforms a map of chain ID to network configuration to a map of network\n * client ID to network configuration.\n *\n * @param networkConfigurationsByChainId - The network configurations, keyed by\n * chain ID.\n * @returns The network configurations, keyed by network client ID.\n */\nfunction buildNetworkConfigurationsByNetworkClientId(\n  networkConfigurationsByChainId: Record<Hex, NetworkConfiguration>,\n): Map<NetworkClientId, NetworkConfiguration> {\n  return new Map(\n    Object.values(networkConfigurationsByChainId).flatMap(\n      (networkConfiguration) => {\n        return networkConfiguration.rpcEndpoints.map((rpcEndpoint) => {\n          return [rpcEndpoint.networkClientId, networkConfiguration];\n        });\n      },\n    ),\n  );\n}\n\n/**\n * Controller that creates and manages an Ethereum network provider.\n */\nexport class NetworkController extends BaseController<\n  typeof controllerName,\n  NetworkState,\n  NetworkControllerMessenger\n> {\n  #ethQuery?: EthQuery;\n\n  readonly #infuraProjectId: string;\n\n  #previouslySelectedNetworkClientId: string;\n\n  #providerProxy: ProviderProxy | undefined;\n\n  #blockTrackerProxy: BlockTrackerProxy | undefined;\n\n  #autoManagedNetworkClientRegistry?: AutoManagedNetworkClientRegistry;\n\n  #autoManagedNetworkClient?:\n    | AutoManagedNetworkClient<CustomNetworkClientConfiguration>\n    | AutoManagedNetworkClient<InfuraNetworkClientConfiguration>;\n\n  readonly #log: Logger | undefined;\n\n  readonly #getRpcServiceOptions: NetworkControllerOptions['getRpcServiceOptions'];\n\n  readonly #getBlockTrackerOptions: NetworkControllerOptions['getBlockTrackerOptions'];\n\n  #networkConfigurationsByNetworkClientId: Map<\n    NetworkClientId,\n    NetworkConfiguration\n  >;\n\n  #isRpcFailoverEnabled: Exclude<\n    NetworkControllerOptions['isRpcFailoverEnabled'],\n    undefined\n  >;\n\n  /**\n   * Constructs a NetworkController.\n   *\n   * @param options - The options; see {@link NetworkControllerOptions}.\n   */\n  constructor(options: NetworkControllerOptions) {\n    const {\n      messenger,\n      state,\n      infuraProjectId,\n      log,\n      getRpcServiceOptions,\n      getBlockTrackerOptions,\n      additionalDefaultNetworks,\n      isRpcFailoverEnabled = false,\n    } = options;\n    const initialState = {\n      ...getDefaultNetworkControllerState(additionalDefaultNetworks),\n      ...state,\n    };\n    validateInitialState(initialState);\n    const correctedInitialState = correctInitialState(initialState, messenger);\n\n    if (!infuraProjectId || typeof infuraProjectId !== 'string') {\n      throw new Error('Invalid Infura project ID');\n    }\n\n    super({\n      name: controllerName,\n      metadata: {\n        selectedNetworkClientId: {\n          includeInStateLogs: true,\n          persist: true,\n          includeInDebugSnapshot: false,\n          usedInUi: true,\n        },\n        networksMetadata: {\n          includeInStateLogs: true,\n          persist: true,\n          includeInDebugSnapshot: false,\n          usedInUi: true,\n        },\n        networkConfigurationsByChainId: {\n          includeInStateLogs: true,\n          persist: true,\n          includeInDebugSnapshot: false,\n          usedInUi: true,\n        },\n      },\n      messenger,\n      state: correctedInitialState,\n    });\n\n    this.#infuraProjectId = infuraProjectId;\n    this.#log = log;\n    this.#getRpcServiceOptions = getRpcServiceOptions;\n    this.#getBlockTrackerOptions = getBlockTrackerOptions;\n    this.#isRpcFailoverEnabled = isRpcFailoverEnabled;\n\n    this.#previouslySelectedNetworkClientId =\n      this.state.selectedNetworkClientId;\n    this.#networkConfigurationsByNetworkClientId =\n      buildNetworkConfigurationsByNetworkClientId(\n        this.state.networkConfigurationsByChainId,\n      );\n\n    this.messenger.registerActionHandler(`${this.name}:getEthQuery`, () => {\n      return this.#ethQuery;\n    });\n\n    this.messenger.registerActionHandler(\n      `${this.name}:getNetworkClientById`,\n      this.getNetworkClientById.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${this.name}:getEIP1559Compatibility`,\n      this.getEIP1559Compatibility.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${this.name}:setActiveNetwork`,\n      this.setActiveNetwork.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${this.name}:setProviderType`,\n      this.setProviderType.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${this.name}:findNetworkClientIdByChainId`,\n      this.findNetworkClientIdByChainId.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${this.name}:getNetworkConfigurationByChainId`,\n      this.getNetworkConfigurationByChainId.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${this.name}:getNetworkConfigurationByNetworkClientId`,\n      this.getNetworkConfigurationByNetworkClientId.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${this.name}:getSelectedNetworkClient`,\n      this.getSelectedNetworkClient.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${this.name}:getSelectedChainId`,\n      this.getSelectedChainId.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${this.name}:addNetwork`,\n      this.addNetwork.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${this.name}:removeNetwork`,\n      this.removeNetwork.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${this.name}:updateNetwork`,\n      this.updateNetwork.bind(this),\n    );\n\n    this.messenger.subscribe(\n      `${this.name}:rpcEndpointChainUnavailable`,\n      ({ networkClientId }) => {\n        this.#updateMetadataForNetwork(networkClientId, {\n          networkStatus: NetworkStatus.Unavailable,\n        });\n      },\n    );\n    this.messenger.subscribe(\n      `${this.name}:rpcEndpointChainDegraded`,\n      ({ networkClientId }) => {\n        this.#updateMetadataForNetwork(networkClientId, {\n          networkStatus: NetworkStatus.Degraded,\n        });\n      },\n    );\n    this.messenger.subscribe(\n      `${this.name}:rpcEndpointChainAvailable`,\n      ({ networkClientId }) => {\n        this.#updateMetadataForNetwork(networkClientId, {\n          networkStatus: NetworkStatus.Available,\n        });\n      },\n    );\n  }\n\n  /**\n   * Enables the RPC failover functionality. That is, if any RPC endpoints are\n   * configured with failover URLs, then traffic will automatically be diverted\n   * to them if those RPC endpoints are unavailable.\n   */\n  enableRpcFailover(): void {\n    this.#updateRpcFailoverEnabled(true);\n  }\n\n  /**\n   * Disables the RPC failover functionality. That is, even if any RPC endpoints\n   * are configured with failover URLs, then traffic will not automatically be\n   * diverted to them if those RPC endpoints are unavailable.\n   */\n  disableRpcFailover(): void {\n    this.#updateRpcFailoverEnabled(false);\n  }\n\n  /**\n   * Enables or disables the RPC failover functionality, depending on the\n   * boolean given. This is done by reconstructing all network clients that were\n   * originally configured with failover URLs so that those URLs are either\n   * honored or ignored. Network client IDs will be preserved so as not to\n   * invalidate state in other controllers.\n   *\n   * @param newIsRpcFailoverEnabled - Whether or not to enable or disable the\n   * RPC failover functionality.\n   */\n  #updateRpcFailoverEnabled(newIsRpcFailoverEnabled: boolean): void {\n    if (this.#isRpcFailoverEnabled === newIsRpcFailoverEnabled) {\n      return;\n    }\n\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    for (const networkClientsById of Object.values(\n      autoManagedNetworkClientRegistry,\n    )) {\n      for (const networkClientId of Object.keys(networkClientsById)) {\n        // Type assertion: We can assume that `networkClientId` is valid here.\n        const networkClient =\n          networkClientsById[\n            networkClientId as keyof typeof networkClientsById\n          ];\n        if (\n          networkClient.configuration.failoverRpcUrls &&\n          networkClient.configuration.failoverRpcUrls.length > 0\n        ) {\n          newIsRpcFailoverEnabled\n            ? networkClient.enableRpcFailover()\n            : networkClient.disableRpcFailover();\n        }\n      }\n    }\n\n    this.#isRpcFailoverEnabled = newIsRpcFailoverEnabled;\n  }\n\n  /**\n   * Accesses the provider and block tracker for the currently selected network.\n   *\n   * @returns The proxy and block tracker proxies.\n   * @deprecated This method has been replaced by `getSelectedNetworkClient` (which has a more easily used return type) and will be removed in a future release.\n   */\n  getProviderAndBlockTracker(): {\n    provider: SwappableProxy<ProxyWithAccessibleTarget<Provider>> | undefined;\n    blockTracker:\n      | SwappableProxy<ProxyWithAccessibleTarget<BlockTracker>>\n      | undefined;\n  } {\n    return {\n      provider: this.#providerProxy,\n      blockTracker: this.#blockTrackerProxy,\n    };\n  }\n\n  /**\n   * Accesses the provider and block tracker for the currently selected network.\n   *\n   * @returns an object with the provider and block tracker proxies for the currently selected network.\n   */\n  getSelectedNetworkClient():\n    | {\n        provider: SwappableProxy<ProxyWithAccessibleTarget<Provider>>;\n        blockTracker: SwappableProxy<ProxyWithAccessibleTarget<BlockTracker>>;\n      }\n    | undefined {\n    if (this.#providerProxy && this.#blockTrackerProxy) {\n      return {\n        provider: this.#providerProxy,\n        blockTracker: this.#blockTrackerProxy,\n      };\n    }\n    return undefined;\n  }\n\n  /**\n   * Accesses the chain ID from the selected network client.\n   *\n   * @returns The chain ID of the selected network client in hex format or undefined if there is no network client.\n   */\n  getSelectedChainId(): Hex | undefined {\n    const networkConfiguration = this.getNetworkConfigurationByNetworkClientId(\n      this.state.selectedNetworkClientId,\n    );\n    return networkConfiguration?.chainId;\n  }\n\n  /**\n   * Internally, the Infura and custom network clients are categorized by type\n   * so that when accessing either kind of network client, TypeScript knows\n   * which type to assign to the network client. For some cases it's more useful\n   * to be able to access network clients by ID instead of by type and then ID,\n   * so this function makes that possible.\n   *\n   * @returns The network clients registered so far, keyed by ID.\n   */\n  getNetworkClientRegistry(): AutoManagedBuiltInNetworkClientRegistry &\n    AutoManagedCustomNetworkClientRegistry {\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    return Object.assign(\n      {},\n      autoManagedNetworkClientRegistry[NetworkClientType.Infura],\n      autoManagedNetworkClientRegistry[NetworkClientType.Custom],\n    );\n  }\n\n  /**\n   * Returns the Infura network client with the given ID.\n   *\n   * @param infuraNetworkClientId - An Infura network client ID.\n   * @returns The Infura network client.\n   * @throws If an Infura network client does not exist with the given ID.\n   */\n  getNetworkClientById(\n    infuraNetworkClientId: BuiltInNetworkClientId,\n  ): AutoManagedNetworkClient<InfuraNetworkClientConfiguration>;\n\n  /**\n   * Returns the custom network client with the given ID.\n   *\n   * @param customNetworkClientId - A custom network client ID.\n   * @returns The custom network client.\n   * @throws If a custom network client does not exist with the given ID.\n   */\n  getNetworkClientById(\n    customNetworkClientId: CustomNetworkClientId,\n  ): AutoManagedNetworkClient<CustomNetworkClientConfiguration>;\n\n  getNetworkClientById(\n    networkClientId: NetworkClientId,\n  ): AutoManagedNetworkClient<NetworkClientConfiguration> {\n    if (!networkClientId) {\n      throw new Error('No network client ID was provided.');\n    }\n\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    if (isInfuraNetworkType(networkClientId)) {\n      const infuraNetworkClient =\n        autoManagedNetworkClientRegistry[NetworkClientType.Infura][\n          networkClientId\n        ];\n      // This is impossible to reach\n      /* istanbul ignore if */\n      if (!infuraNetworkClient) {\n        throw new Error(\n          `No Infura network client was found with the ID \"${networkClientId}\".`,\n        );\n      }\n      return infuraNetworkClient;\n    }\n\n    const customNetworkClient =\n      autoManagedNetworkClientRegistry[NetworkClientType.Custom][\n        networkClientId\n      ];\n    if (!customNetworkClient) {\n      throw new Error(\n        `No custom network client was found with the ID \"${networkClientId}\".`,\n      );\n    }\n    return customNetworkClient;\n  }\n\n  /**\n   * Executes a series of steps to switch the network:\n   *\n   * 1. Notifies subscribers via the messenger that the network is about to be\n   * switched (and, really, that the global provider and block tracker proxies\n   * will be re-pointed to a new network).\n   * 2. Looks up a known and preinitialized network client matching the given\n   * ID and uses it to re-point the aforementioned provider and block tracker\n   * proxies.\n   * 3. Notifies subscribers via the messenger that the network has switched.\n   * 4. Captures metadata for the newly switched network in state.\n   *\n   * @param networkClientId - The ID of a network client that requests will be\n   * routed through (either the name of an Infura network or the ID of a custom\n   * network configuration).\n   * @param options - Options for this method.\n   * @param options.updateState - Allows for updating state.\n   */\n  async #refreshNetwork(\n    networkClientId: string,\n    options: {\n      updateState?: (state: Draft<NetworkState>) => void;\n    } = {},\n  ): Promise<void> {\n    this.messenger.publish('NetworkController:networkWillChange', this.state);\n    this.#applyNetworkSelection(networkClientId, options);\n    this.messenger.publish('NetworkController:networkDidChange', this.state);\n    await this.lookupNetwork();\n  }\n\n  /**\n   * Creates proxies for accessing the global network client and its block\n   * tracker. You must call this method in order to use\n   * `getProviderAndBlockTracker` (or its replacement,\n   * `getSelectedNetworkClient`).\n   *\n   * @param options - Optional arguments.\n   * @param options.lookupNetwork - Usually, metadata for the global network\n   * will be populated via a call to `lookupNetwork` after creating the provider\n   * and block tracker proxies. This allows for responding to the status of the\n   * global network after initializing this controller; however, it requires\n   * making a request to the network to do so. In the clients, where controllers\n   * are initialized before the UI is shown, this may be undesirable, as it\n   * means that if the user has just installed MetaMask, their IP address may be\n   * shared with a third party before they have a chance to finish onboarding.\n   * You can pass `false` if you'd like to disable this request and call\n   * `lookupNetwork` yourself.\n   */\n  initializeProvider(options: { lookupNetwork: false }): void;\n\n  /**\n   * Creates proxies for accessing the global network client and its block\n   * tracker. You must call this method in order to use\n   * `getProviderAndBlockTracker` (or its replacement,\n   * `getSelectedNetworkClient`).\n   *\n   * @param options - Optional arguments.\n   * @param options.lookupNetwork - Usually, metadata for the global network\n   * will be populated via a call to `lookupNetwork` after creating the provider\n   * and block tracker proxies. This allows for responding to the status of the\n   * global network after initializing this controller; however, it requires\n   * making a request to the network to do so. In the clients, where controllers\n   * are initialized before the UI is shown, this may be undesirable, as it\n   * means that if the user has just installed MetaMask, their IP address may be\n   * shared with a third party before they have a chance to finish onboarding.\n   * You can pass `false` if you'd like to disable this request and call\n   * `lookupNetwork` yourself.\n   * @returns A promise that resolves when the network lookup completes.\n   */\n  initializeProvider(options?: { lookupNetwork?: boolean }): Promise<void>;\n\n  initializeProvider({\n    lookupNetwork = true,\n  }: {\n    lookupNetwork?: boolean;\n  } = {}): Promise<void> | undefined {\n    this.#applyNetworkSelection(this.state.selectedNetworkClientId);\n\n    if (lookupNetwork) {\n      return this.lookupNetwork();\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Uses a request for the latest block to gather the following information on\n   * the given network:\n   *\n   * - The connectivity status: whether it is available, geo-blocked (Infura\n   * only), unavailable, or unknown\n   * - The capabilities status: whether it supports EIP-1559, whether it does\n   * not, or whether it is unknown\n   *\n   * @param networkClientId - The ID of the network client to inspect.\n   * If no ID is provided, uses the currently selected network.\n   * @returns The resulting metadata for the network.\n   */\n  async #determineNetworkMetadata(networkClientId: NetworkClientId): Promise<{\n    isInfura: boolean;\n    networkStatus:\n      | NetworkStatus.Available\n      | NetworkStatus.Unknown\n      | NetworkStatus.Unavailable\n      | NetworkStatus.Blocked;\n    isEIP1559Compatible: undefined | boolean;\n  }> {\n    // Force TypeScript to use one of the two overloads explicitly\n    const networkClient = isInfuraNetworkType(networkClientId)\n      ? this.getNetworkClientById(networkClientId)\n      : this.getNetworkClientById(networkClientId);\n\n    const isInfura =\n      networkClient.configuration.type === NetworkClientType.Infura;\n    let networkStatus: NetworkStatus;\n    let isEIP1559Compatible: boolean | undefined;\n\n    try {\n      isEIP1559Compatible =\n        await this.#determineEIP1559Compatibility(networkClientId);\n      networkStatus = NetworkStatus.Available;\n    } catch (error) {\n      debugLog('NetworkController: lookupNetwork: ', error);\n\n      if (isErrorWithCode(error)) {\n        let responseBody;\n        if (\n          isInfura &&\n          hasProperty(error, 'message') &&\n          typeof error.message === 'string'\n        ) {\n          try {\n            responseBody = JSON.parse(error.message);\n          } catch {\n            // error.message must not be JSON\n            this.#log?.warn(\n              'NetworkController: lookupNetwork: json parse error: ',\n              error,\n            );\n          }\n        }\n\n        if (\n          isPlainObject(responseBody) &&\n          responseBody.error === INFURA_BLOCKED_KEY\n        ) {\n          networkStatus = NetworkStatus.Blocked;\n        } else if (error.code === errorCodes.rpc.internal) {\n          networkStatus = NetworkStatus.Unknown;\n          this.#log?.warn(\n            'NetworkController: lookupNetwork: rpc internal error: ',\n            error,\n          );\n        } else {\n          networkStatus = NetworkStatus.Unavailable;\n          this.#log?.warn('NetworkController: lookupNetwork: ', error);\n        }\n      } else {\n        debugLog(\n          'NetworkController - could not determine network status',\n          error,\n        );\n        networkStatus = NetworkStatus.Unknown;\n        this.#log?.warn('NetworkController: lookupNetwork: ', error);\n      }\n    }\n\n    return { isInfura, networkStatus, isEIP1559Compatible };\n  }\n\n  /**\n   * Uses a request for the latest block to gather the following information on\n   * the given or selected network, persisting it to state:\n   *\n   * - The connectivity status: whether it is available, geo-blocked (Infura\n   * only), unavailable, or unknown\n   * - The capabilities status: whether it supports EIP-1559, whether it does\n   * not, or whether it is unknown\n   *\n   * @param networkClientId - The ID of the network client to inspect.\n   * If no ID is provided, uses the currently selected network.\n   */\n  async lookupNetwork(networkClientId?: NetworkClientId): Promise<void> {\n    if (networkClientId) {\n      await this.#lookupGivenNetwork(networkClientId);\n    } else {\n      await this.#lookupSelectedNetwork();\n    }\n  }\n\n  /**\n   * Uses a request for the latest block to gather the following information on\n   * the given network, persisting it to state:\n   *\n   * - The connectivity status: whether the network is available, geo-blocked\n   * (Infura only), unavailable, or unknown\n   * - The feature compatibility status: whether the network supports EIP-1559,\n   * whether it does not, or whether it is unknown\n   *\n   * @param networkClientId - The ID of the network client to inspect.\n   * @deprecated Please use `lookupNetwork` and pass a network client ID\n   * instead. This method will be removed in a future major version.\n   */\n  // We are planning on removing this so we aren't interested in testing this\n  // right now.\n  /* istanbul ignore next */\n  async lookupNetworkByClientId(\n    networkClientId: NetworkClientId,\n  ): Promise<void> {\n    await this.#lookupGivenNetwork(networkClientId);\n  }\n\n  /**\n   * Uses a request for the latest block to gather the following information on\n   * the given network, persisting it to state:\n   *\n   * - The connectivity status: whether the network is available, geo-blocked\n   * (Infura only), unavailable, or unknown\n   * - The feature compatibility status: whether the network supports EIP-1559,\n   * whether it does not, or whether it is unknown\n   *\n   * @param networkClientId - The ID of the network client to inspect.\n   */\n  async #lookupGivenNetwork(networkClientId: NetworkClientId): Promise<void> {\n    const { networkStatus, isEIP1559Compatible } =\n      await this.#determineNetworkMetadata(networkClientId);\n\n    this.#updateMetadataForNetwork(networkClientId, {\n      networkStatus,\n      isEIP1559Compatible,\n    });\n  }\n\n  /**\n   * Uses a request for the latest block to gather the following information on\n   * the currently selected network, persisting it to state:\n   *\n   * - The connectivity status: whether the network is available, geo-blocked\n   * (Infura only), unavailable, or unknown\n   * - The feature compatibility status: whether the network supports EIP-1559,\n   * whether it does not, or whether it is unknown\n   *\n   * Note that it is possible for the current network to be switched while this\n   * method is running. If that is the case, it will exit early (as this method\n   * will also run for the new network).\n   */\n  async #lookupSelectedNetwork(): Promise<void> {\n    if (!this.#ethQuery) {\n      return;\n    }\n\n    let networkChanged = false;\n    const listener = (): void => {\n      networkChanged = true;\n      try {\n        this.messenger.unsubscribe(\n          'NetworkController:networkDidChange',\n          listener,\n        );\n      } catch (error) {\n        // In theory, this `catch` should not be necessary given that this error\n        // would occur \"inside\" of the call to `#determineEIP1559Compatibility`\n        // below and so it should be caught by the `try`/`catch` below (it is\n        // impossible to reproduce in tests for that reason). However, somehow\n        // it occurs within Mobile and so we have to add our own `try`/`catch`\n        // here.\n        /* istanbul ignore next */\n        if (\n          !(error instanceof Error) ||\n          error.message !==\n            'Subscription not found for event: NetworkController:networkDidChange'\n        ) {\n          // Again, this error should not happen and is impossible to reproduce\n          // in tests.\n          /* istanbul ignore next */\n          throw error;\n        }\n      }\n    };\n    this.messenger.subscribe('NetworkController:networkDidChange', listener);\n\n    const { isInfura, networkStatus, isEIP1559Compatible } =\n      await this.#determineNetworkMetadata(this.state.selectedNetworkClientId);\n\n    if (networkChanged) {\n      // If the network has changed, then `lookupNetwork` either has been or is\n      // in the process of being called, so we don't need to go further.\n      return;\n    }\n\n    try {\n      this.messenger.unsubscribe(\n        'NetworkController:networkDidChange',\n        listener,\n      );\n    } catch (error) {\n      if (\n        !(error instanceof Error) ||\n        error.message !==\n          'Subscription not found for event: NetworkController:networkDidChange'\n      ) {\n        throw error;\n      }\n    }\n\n    this.#updateMetadataForNetwork(this.state.selectedNetworkClientId, {\n      networkStatus,\n      isEIP1559Compatible,\n    });\n\n    if (isInfura) {\n      if (networkStatus === NetworkStatus.Available) {\n        this.messenger.publish('NetworkController:infuraIsUnblocked');\n      } else if (networkStatus === NetworkStatus.Blocked) {\n        this.messenger.publish('NetworkController:infuraIsBlocked');\n      }\n    } else {\n      // Always publish infuraIsUnblocked regardless of network status to\n      // prevent consumers from being stuck in a blocked state if they were\n      // previously connected to an Infura network that was blocked\n      this.messenger.publish('NetworkController:infuraIsUnblocked');\n    }\n  }\n\n  /**\n   * Updates the metadata for the given network in state.\n   *\n   * @param networkClientId - The associated network client ID.\n   * @param metadata - The metadata to store in state.\n   * @param metadata.networkStatus - The network status to store in state.\n   * @param metadata.isEIP1559Compatible - The EIP-1559 compatibility status to\n   * store in state.\n   */\n  #updateMetadataForNetwork(\n    networkClientId: NetworkClientId,\n    metadata: {\n      networkStatus: NetworkStatus;\n      isEIP1559Compatible?: boolean | undefined;\n    },\n  ): void {\n    this.update((state) => {\n      state.networksMetadata[networkClientId] ??= {\n        status: NetworkStatus.Unknown,\n        EIPS: {},\n      };\n\n      const newMetadata = state.networksMetadata[networkClientId];\n      newMetadata.status = metadata.networkStatus;\n\n      if ('isEIP1559Compatible' in metadata) {\n        if (metadata.isEIP1559Compatible === undefined) {\n          delete newMetadata.EIPS[1559];\n        } else {\n          newMetadata.EIPS[1559] = metadata.isEIP1559Compatible;\n        }\n      }\n    });\n  }\n\n  /**\n   * Convenience method to update provider network type settings.\n   *\n   * @param type - Human readable network name.\n   * @deprecated This has been replaced by `setActiveNetwork`, and will be\n   * removed in a future release\n   */\n  async setProviderType(type: InfuraNetworkType): Promise<void> {\n    if ((type as unknown) === NetworkType.rpc) {\n      throw new Error(\n        `NetworkController - cannot call \"setProviderType\" with type \"${NetworkType.rpc}\". Use \"setActiveNetwork\"`,\n      );\n    }\n    if (!isInfuraNetworkType(type)) {\n      throw new Error(`Unknown Infura provider type \"${String(type)}\".`);\n    }\n\n    await this.setActiveNetwork(type);\n  }\n\n  /**\n   * Changes the selected network.\n   *\n   * @param networkClientId - The ID of a network client that will be used to\n   * make requests.\n   * @param options - Options for this method.\n   * @param options.updateState - Allows for updating state.\n   * @throws if no network client is associated with the given\n   * network client ID.\n   */\n  async setActiveNetwork(\n    networkClientId: string,\n    options: {\n      updateState?: (state: Draft<NetworkState>) => void;\n    } = {},\n  ): Promise<void> {\n    this.#previouslySelectedNetworkClientId =\n      this.state.selectedNetworkClientId;\n\n    await this.#refreshNetwork(networkClientId, options);\n  }\n\n  /**\n   * Fetches the latest block for the network.\n   *\n   * @param networkClientId - The networkClientId to fetch the correct provider against which to check the latest block. Defaults to the selectedNetworkClientId.\n   * @returns A promise that either resolves to the block header or null if\n   * there is no latest block, or rejects with an error.\n   */\n  #getLatestBlock(\n    networkClientId: NetworkClientId = this.state.selectedNetworkClientId,\n  ): Promise<Block> {\n    const networkClient = this.getNetworkClientById(networkClientId);\n    const ethQuery = new EthQuery(networkClient.provider);\n\n    return new Promise((resolve, reject) => {\n      ethQuery.sendAsync(\n        { method: 'eth_getBlockByNumber', params: ['latest', false] },\n        (error: unknown, block?: unknown) => {\n          if (error) {\n            // This error comes from JsonRpcEngine, we don't control it.\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            reject(error);\n          } else {\n            // TODO: Validate this type\n            resolve(block as Block);\n          }\n        },\n      );\n    });\n  }\n\n  /**\n   * Determines whether the network supports EIP-1559 by checking whether the\n   * latest block has a `baseFeePerGas` property, then updates state\n   * appropriately.\n   *\n   * @param networkClientId - The networkClientId to fetch the correct provider against which to check 1559 compatibility.\n   * @returns A promise that resolves to true if the network supports EIP-1559\n   * , false otherwise, or `undefined` if unable to determine the compatibility.\n   */\n  async getEIP1559Compatibility(\n    networkClientId?: NetworkClientId,\n  ): Promise<undefined | boolean> {\n    if (networkClientId) {\n      return this.get1559CompatibilityWithNetworkClientId(networkClientId);\n    }\n    if (!this.#ethQuery) {\n      return false;\n    }\n\n    const { EIPS } =\n      this.state.networksMetadata[this.state.selectedNetworkClientId];\n\n    if (EIPS[1559] !== undefined) {\n      return EIPS[1559];\n    }\n\n    const isEIP1559Compatible = await this.#determineEIP1559Compatibility(\n      this.state.selectedNetworkClientId,\n    );\n    this.update((state) => {\n      if (isEIP1559Compatible !== undefined) {\n        state.networksMetadata[state.selectedNetworkClientId].EIPS[1559] =\n          isEIP1559Compatible;\n      }\n    });\n    return isEIP1559Compatible;\n  }\n\n  async get1559CompatibilityWithNetworkClientId(\n    networkClientId: NetworkClientId,\n  ): Promise<boolean> {\n    let metadata = this.state.networksMetadata[networkClientId];\n    if (metadata?.EIPS[1559] === undefined) {\n      await this.lookupNetwork(networkClientId);\n      metadata = this.state.networksMetadata[networkClientId];\n    }\n    const { EIPS } = metadata;\n\n    // may want to include some 'freshness' value - something to make sure we refetch this from time to time\n    return EIPS[1559];\n  }\n\n  /**\n   * Retrieves and checks the latest block from the currently selected\n   * network; if the block has a `baseFeePerGas` property, then we know\n   * that the network supports EIP-1559; otherwise it doesn't.\n   *\n   * @param networkClientId - The networkClientId to fetch the correct provider against which to check 1559 compatibility\n   * @returns A promise that resolves to `true` if the network supports EIP-1559,\n   * `false` otherwise, or `undefined` if unable to retrieve the last block.\n   */\n  async #determineEIP1559Compatibility(\n    networkClientId: NetworkClientId,\n  ): Promise<boolean | undefined> {\n    const latestBlock = await this.#getLatestBlock(networkClientId);\n\n    if (!latestBlock) {\n      return undefined;\n    }\n\n    return latestBlock.baseFeePerGas !== undefined;\n  }\n\n  /**\n   * Ensures that the provider and block tracker proxies are pointed to the\n   * currently selected network and refreshes the metadata for the\n   */\n  async resetConnection(): Promise<void> {\n    await this.#refreshNetwork(this.state.selectedNetworkClientId);\n  }\n\n  /**\n   * Returns the network configuration that has been filed under the given chain\n   * ID.\n   *\n   * @param chainId - The chain ID to use as a key.\n   * @returns The network configuration if one exists, or undefined.\n   */\n  getNetworkConfigurationByChainId(\n    chainId: Hex,\n  ): NetworkConfiguration | undefined {\n    return this.state.networkConfigurationsByChainId[chainId];\n  }\n\n  /**\n   * Returns the network configuration that contains an RPC endpoint with the\n   * given network client ID.\n   *\n   * @param networkClientId - The network client ID to use as a key.\n   * @returns The network configuration if one exists, or undefined.\n   */\n  getNetworkConfigurationByNetworkClientId(\n    networkClientId: NetworkClientId,\n  ): NetworkConfiguration | undefined {\n    return this.#networkConfigurationsByNetworkClientId.get(networkClientId);\n  }\n\n  /**\n   * Creates and registers network clients for the collection of Infura and\n   * custom RPC endpoints that can be used to make requests for a particular\n   * chain, storing the given configuration object in state for later reference.\n   *\n   * @param fields - The object that describes the new network/chain and lists\n   * the RPC endpoints which front that chain.\n   * @returns The newly added network configuration.\n   * @throws if any part of `fields` would produce invalid state.\n   * @see {@link NetworkConfiguration}\n   */\n  addNetwork(fields: AddNetworkFields): NetworkConfiguration {\n    const { rpcEndpoints: setOfRpcEndpointFields } = fields;\n\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    this.#validateNetworkFields({\n      mode: 'add',\n      networkFields: fields,\n      autoManagedNetworkClientRegistry,\n    });\n\n    const networkClientOperations = setOfRpcEndpointFields.map(\n      (defaultOrCustomRpcEndpointFields) => {\n        const rpcEndpoint =\n          defaultOrCustomRpcEndpointFields.type === RpcEndpointType.Custom\n            ? {\n                ...defaultOrCustomRpcEndpointFields,\n                networkClientId: uuidV4(),\n              }\n            : defaultOrCustomRpcEndpointFields;\n        return {\n          type: 'add' as const,\n          rpcEndpoint,\n        };\n      },\n    );\n\n    const newNetworkConfiguration =\n      this.#determineNetworkConfigurationToPersist({\n        networkFields: fields,\n        networkClientOperations,\n      });\n    this.#registerNetworkClientsAsNeeded({\n      networkFields: fields,\n      networkClientOperations,\n      autoManagedNetworkClientRegistry,\n    });\n    this.update((state) => {\n      this.#updateNetworkConfigurations({\n        state,\n        mode: 'add',\n        networkFields: fields,\n        networkConfigurationToPersist: newNetworkConfiguration,\n      });\n    });\n\n    this.messenger.publish(\n      `${controllerName}:networkAdded`,\n      newNetworkConfiguration,\n    );\n\n    return newNetworkConfiguration;\n  }\n\n  /**\n   * Updates the configuration for a previously stored network filed under the\n   * given chain ID, creating + registering new network clients to represent RPC\n   * endpoints that have been added and destroying + unregistering existing\n   * network clients for RPC endpoints that have been removed.\n   *\n   * Note that if `chainId` is changed, then all network clients associated with\n   * that chain will be removed and re-added, even if none of the RPC endpoints\n   * have changed.\n   *\n   * @param chainId - The chain ID associated with an existing network.\n   * @param fields - The object that describes the updates to the network/chain,\n   * including the new set of RPC endpoints which should front that chain.\n   * @param options - Options to provide.\n   * @param options.replacementSelectedRpcEndpointIndex - Usually you cannot\n   * remove an RPC endpoint that is being represented by the currently selected\n   * network client. This option allows you to specify another RPC endpoint\n   * (either an existing one or a new one) that should be used to select a new\n   * network instead.\n   * @returns The updated network configuration.\n   * @throws if `chainId` does not refer to an existing network configuration,\n   * if any part of `fields` would produce invalid state, etc.\n   * @see {@link NetworkConfiguration}\n   */\n  async updateNetwork(\n    chainId: Hex,\n    fields: UpdateNetworkFields,\n    {\n      replacementSelectedRpcEndpointIndex,\n    }: { replacementSelectedRpcEndpointIndex?: number } = {},\n  ): Promise<NetworkConfiguration> {\n    const existingNetworkConfiguration =\n      this.state.networkConfigurationsByChainId[chainId];\n\n    if (existingNetworkConfiguration === undefined) {\n      throw new Error(\n        `Could not update network: Cannot find network configuration for chain '${chainId}'`,\n      );\n    }\n\n    const existingChainId = chainId;\n    const { chainId: newChainId, rpcEndpoints: setOfNewRpcEndpointFields } =\n      fields;\n\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    this.#validateNetworkFields({\n      mode: 'update',\n      networkFields: fields,\n      existingNetworkConfiguration,\n      autoManagedNetworkClientRegistry,\n    });\n\n    const networkClientOperations: NetworkClientOperation[] = [];\n\n    for (const newRpcEndpointFields of setOfNewRpcEndpointFields) {\n      const existingRpcEndpointForNoop =\n        existingNetworkConfiguration.rpcEndpoints.find((rpcEndpoint) => {\n          return (\n            rpcEndpoint.type === newRpcEndpointFields.type &&\n            rpcEndpoint.url === newRpcEndpointFields.url &&\n            (rpcEndpoint.networkClientId ===\n              newRpcEndpointFields.networkClientId ||\n              newRpcEndpointFields.networkClientId === undefined)\n          );\n        });\n      const existingRpcEndpointForReplaceWhenChainChanged =\n        existingNetworkConfiguration.rpcEndpoints.find((rpcEndpoint) => {\n          return (\n            (rpcEndpoint.type === RpcEndpointType.Infura &&\n              newRpcEndpointFields.type === RpcEndpointType.Infura) ||\n            (rpcEndpoint.type === newRpcEndpointFields.type &&\n              rpcEndpoint.networkClientId ===\n                newRpcEndpointFields.networkClientId &&\n              rpcEndpoint.url === newRpcEndpointFields.url)\n          );\n        });\n      const existingRpcEndpointForReplaceWhenChainNotChanged =\n        existingNetworkConfiguration.rpcEndpoints.find((rpcEndpoint) => {\n          return (\n            rpcEndpoint.type === newRpcEndpointFields.type &&\n            (rpcEndpoint.url === newRpcEndpointFields.url ||\n              rpcEndpoint.networkClientId ===\n                newRpcEndpointFields.networkClientId)\n          );\n        });\n\n      if (\n        newChainId !== existingChainId &&\n        existingRpcEndpointForReplaceWhenChainChanged !== undefined\n      ) {\n        const newRpcEndpoint =\n          newRpcEndpointFields.type === RpcEndpointType.Infura\n            ? newRpcEndpointFields\n            : { ...newRpcEndpointFields, networkClientId: uuidV4() };\n\n        networkClientOperations.push({\n          type: 'replace' as const,\n          oldRpcEndpoint: existingRpcEndpointForReplaceWhenChainChanged,\n          newRpcEndpoint,\n        });\n      } else if (existingRpcEndpointForNoop !== undefined) {\n        let newRpcEndpoint;\n        if (existingRpcEndpointForNoop.type === RpcEndpointType.Infura) {\n          newRpcEndpoint = existingRpcEndpointForNoop;\n        } else {\n          // `networkClientId` shouldn't be missing at this point; if it is,\n          // that's a mistake, so fill it back in\n          newRpcEndpoint = Object.assign({}, newRpcEndpointFields, {\n            networkClientId: existingRpcEndpointForNoop.networkClientId,\n          });\n        }\n        networkClientOperations.push({\n          type: 'noop' as const,\n          rpcEndpoint: newRpcEndpoint,\n        });\n      } else if (\n        existingRpcEndpointForReplaceWhenChainNotChanged === undefined\n      ) {\n        const newRpcEndpoint =\n          newRpcEndpointFields.type === RpcEndpointType.Infura\n            ? newRpcEndpointFields\n            : { ...newRpcEndpointFields, networkClientId: uuidV4() };\n        const networkClientOperation = {\n          type: 'add' as const,\n          rpcEndpoint: newRpcEndpoint,\n        };\n        networkClientOperations.push(networkClientOperation);\n      } else {\n        let newRpcEndpoint;\n        /* istanbul ignore if */\n        if (newRpcEndpointFields.type === RpcEndpointType.Infura) {\n          // This case can't actually happen. If we're here, it means that some\n          // part of the RPC endpoint changed. But there is no part of an Infura\n          // RPC endpoint that can be changed (as it would immediately make that\n          // RPC endpoint self-inconsistent). This is just here to appease\n          // TypeScript.\n          newRpcEndpoint = newRpcEndpointFields;\n        } else {\n          newRpcEndpoint = {\n            ...newRpcEndpointFields,\n            networkClientId: uuidV4(),\n          };\n        }\n\n        networkClientOperations.push({\n          type: 'replace' as const,\n          oldRpcEndpoint: existingRpcEndpointForReplaceWhenChainNotChanged,\n          newRpcEndpoint,\n        });\n      }\n    }\n\n    for (const existingRpcEndpoint of existingNetworkConfiguration.rpcEndpoints) {\n      if (\n        !networkClientOperations.some((networkClientOperation) => {\n          const otherRpcEndpoint =\n            networkClientOperation.type === 'replace'\n              ? networkClientOperation.oldRpcEndpoint\n              : networkClientOperation.rpcEndpoint;\n          return (\n            otherRpcEndpoint.type === existingRpcEndpoint.type &&\n            otherRpcEndpoint.networkClientId ===\n              existingRpcEndpoint.networkClientId &&\n            otherRpcEndpoint.url === existingRpcEndpoint.url\n          );\n        })\n      ) {\n        const networkClientOperation = {\n          type: 'remove' as const,\n          rpcEndpoint: existingRpcEndpoint,\n        };\n        networkClientOperations.push(networkClientOperation);\n      }\n    }\n\n    const updatedNetworkConfiguration =\n      this.#determineNetworkConfigurationToPersist({\n        networkFields: fields,\n        networkClientOperations,\n      });\n\n    if (\n      replacementSelectedRpcEndpointIndex === undefined &&\n      networkClientOperations.some((networkClientOperation) => {\n        return (\n          networkClientOperation.type === 'remove' &&\n          networkClientOperation.rpcEndpoint.networkClientId ===\n            this.state.selectedNetworkClientId\n        );\n      }) &&\n      !networkClientOperations.some((networkClientOperation) => {\n        return (\n          networkClientOperation.type === 'replace' &&\n          networkClientOperation.oldRpcEndpoint.networkClientId ===\n            this.state.selectedNetworkClientId\n        );\n      })\n    ) {\n      throw new Error(\n        `Could not update network: Cannot update RPC endpoints in such a way that the selected network '${this.state.selectedNetworkClientId}' would be removed without a replacement. Choose a different RPC endpoint as the selected network via the \\`replacementSelectedRpcEndpointIndex\\` option.`,\n      );\n    }\n\n    this.#registerNetworkClientsAsNeeded({\n      networkFields: fields,\n      networkClientOperations,\n      autoManagedNetworkClientRegistry,\n    });\n\n    const replacementSelectedRpcEndpointWithIndex = networkClientOperations\n      .map(\n        (networkClientOperation, index) =>\n          [networkClientOperation, index] as const,\n      )\n      .find(([networkClientOperation, _index]) => {\n        return (\n          networkClientOperation.type === 'replace' &&\n          networkClientOperation.oldRpcEndpoint.networkClientId ===\n            this.state.selectedNetworkClientId\n        );\n      });\n    const correctedReplacementSelectedRpcEndpointIndex =\n      replacementSelectedRpcEndpointIndex ??\n      replacementSelectedRpcEndpointWithIndex?.[1];\n\n    let rpcEndpointToSelect: RpcEndpoint | undefined;\n    if (correctedReplacementSelectedRpcEndpointIndex !== undefined) {\n      rpcEndpointToSelect =\n        updatedNetworkConfiguration.rpcEndpoints[\n          correctedReplacementSelectedRpcEndpointIndex\n        ];\n\n      if (rpcEndpointToSelect === undefined) {\n        throw new Error(\n          `Could not update network: \\`replacementSelectedRpcEndpointIndex\\` ${correctedReplacementSelectedRpcEndpointIndex} does not refer to an entry in \\`rpcEndpoints\\``,\n        );\n      }\n    }\n\n    if (\n      rpcEndpointToSelect &&\n      rpcEndpointToSelect.networkClientId !== this.state.selectedNetworkClientId\n    ) {\n      await this.setActiveNetwork(rpcEndpointToSelect.networkClientId, {\n        updateState: (state) => {\n          this.#updateNetworkConfigurations({\n            state,\n            mode: 'update',\n            networkFields: fields,\n            networkConfigurationToPersist: updatedNetworkConfiguration,\n            existingNetworkConfiguration,\n          });\n        },\n      });\n    } else {\n      this.update((state) => {\n        this.#updateNetworkConfigurations({\n          state,\n          mode: 'update',\n          networkFields: fields,\n          networkConfigurationToPersist: updatedNetworkConfiguration,\n          existingNetworkConfiguration,\n        });\n      });\n    }\n\n    this.#unregisterNetworkClientsAsNeeded({\n      networkClientOperations,\n      autoManagedNetworkClientRegistry,\n    });\n\n    return updatedNetworkConfiguration;\n  }\n\n  /**\n   * Destroys and unregisters the network identified by the given chain ID, also\n   * removing the associated network configuration from state.\n   *\n   * @param chainId - The chain ID associated with an existing network.\n   * @throws if `chainId` does not refer to an existing network configuration,\n   * or if the currently selected network is being removed.\n   * @see {@link NetworkConfiguration}\n   */\n  removeNetwork(chainId: Hex): void {\n    const existingNetworkConfiguration =\n      this.state.networkConfigurationsByChainId[chainId];\n\n    if (existingNetworkConfiguration === undefined) {\n      throw new Error(\n        `Cannot find network configuration for chain '${chainId}'`,\n      );\n    }\n\n    if (\n      existingNetworkConfiguration.rpcEndpoints.some(\n        (rpcEndpoint) =>\n          rpcEndpoint.networkClientId === this.state.selectedNetworkClientId,\n      )\n    ) {\n      throw new Error(`Cannot remove the currently selected network`);\n    }\n\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    const networkClientOperations =\n      existingNetworkConfiguration.rpcEndpoints.map((rpcEndpoint) => {\n        return {\n          type: 'remove' as const,\n          rpcEndpoint,\n        };\n      });\n\n    this.#unregisterNetworkClientsAsNeeded({\n      networkClientOperations,\n      autoManagedNetworkClientRegistry,\n    });\n    this.update((state) => {\n      this.#updateNetworkConfigurations({\n        state,\n        mode: 'remove',\n        existingNetworkConfiguration,\n      });\n\n      for (const rpcEndpoint of existingNetworkConfiguration.rpcEndpoints) {\n        delete state.networksMetadata[rpcEndpoint.networkClientId];\n      }\n    });\n\n    this.messenger.publish(\n      'NetworkController:networkRemoved',\n      existingNetworkConfiguration,\n    );\n  }\n\n  /**\n   * Assuming that the network has been previously switched, switches to this\n   * new network.\n   *\n   * If the network has not been previously switched, this method is equivalent\n   * to {@link resetConnection}.\n   */\n  async rollbackToPreviousProvider(): Promise<void> {\n    await this.#refreshNetwork(this.#previouslySelectedNetworkClientId);\n  }\n\n  /**\n   * Deactivates the controller, stopping any ongoing polling.\n   *\n   * In-progress requests will not be aborted.\n   */\n  // We're intentionally changing the signature of an extended method.\n  // eslint-disable-next-line @typescript-eslint/no-misused-promises\n  async destroy(): Promise<void> {\n    await this.#blockTrackerProxy?.destroy();\n  }\n\n  /**\n   * Merges the given backup data into controller state.\n   *\n   * @param backup - The data that has been backed up.\n   * @param backup.networkConfigurationsByChainId - Network configurations,\n   * keyed by chain ID.\n   */\n  loadBackup({\n    networkConfigurationsByChainId,\n  }: Pick<NetworkState, 'networkConfigurationsByChainId'>): void {\n    this.update((state) => {\n      state.networkConfigurationsByChainId = {\n        ...state.networkConfigurationsByChainId,\n        ...networkConfigurationsByChainId,\n      };\n    });\n  }\n\n  /**\n   * Searches for the default RPC endpoint configured for the given chain and\n   * returns its network client ID. This can then be passed to\n   * {@link getNetworkClientById} to retrieve the network client.\n   *\n   * @param chainId - Chain ID to search for.\n   * @returns The ID of the network client created for the chain's default RPC\n   * endpoint.\n   */\n  findNetworkClientIdByChainId(chainId: Hex): NetworkClientId {\n    const networkConfiguration =\n      this.state.networkConfigurationsByChainId[chainId];\n\n    if (!networkConfiguration) {\n      throw new Error(`Invalid chain ID \"${chainId}\"`);\n    }\n\n    const { networkClientId } =\n      networkConfiguration.rpcEndpoints[\n        networkConfiguration.defaultRpcEndpointIndex\n      ];\n    return networkClientId;\n  }\n\n  /**\n   * Ensure that the given fields which will be used to either add or update a\n   * network are valid.\n   *\n   * @param args - The arguments.\n   */\n  #validateNetworkFields(\n    args: {\n      autoManagedNetworkClientRegistry: AutoManagedNetworkClientRegistry;\n    } & (\n      | {\n          mode: 'add';\n          networkFields: AddNetworkFields;\n        }\n      | {\n          mode: 'update';\n          existingNetworkConfiguration: NetworkConfiguration;\n          networkFields: UpdateNetworkFields;\n        }\n    ),\n  ): void {\n    const { mode, networkFields, autoManagedNetworkClientRegistry } = args;\n    const existingNetworkConfiguration =\n      'existingNetworkConfiguration' in args\n        ? args.existingNetworkConfiguration\n        : null;\n\n    const errorMessagePrefix =\n      mode === 'update' ? 'Could not update network' : 'Could not add network';\n\n    if (\n      !isStrictHexString(networkFields.chainId) ||\n      !isSafeChainId(networkFields.chainId)\n    ) {\n      throw new Error(\n        `${errorMessagePrefix}: Invalid \\`chainId\\` '${networkFields.chainId}' (must start with \"0x\" and not exceed the maximum)`,\n      );\n    }\n\n    if (\n      existingNetworkConfiguration === null ||\n      networkFields.chainId !== existingNetworkConfiguration.chainId\n    ) {\n      const existingNetworkConfigurationViaChainId =\n        this.state.networkConfigurationsByChainId[networkFields.chainId];\n      if (existingNetworkConfigurationViaChainId !== undefined) {\n        if (existingNetworkConfiguration === null) {\n          throw new Error(\n            `Could not add network for chain ${args.networkFields.chainId} as another network for that chain already exists ('${existingNetworkConfigurationViaChainId.name}')`,\n          );\n        } else {\n          throw new Error(\n            `Cannot move network from chain ${existingNetworkConfiguration.chainId} to ${networkFields.chainId} as another network for that chain already exists ('${existingNetworkConfigurationViaChainId.name}')`,\n          );\n        }\n      }\n    }\n\n    const isInvalidDefaultBlockExplorerUrlIndex =\n      networkFields.blockExplorerUrls.length > 0\n        ? networkFields.defaultBlockExplorerUrlIndex === undefined ||\n          networkFields.blockExplorerUrls[\n            networkFields.defaultBlockExplorerUrlIndex\n          ] === undefined\n        : networkFields.defaultBlockExplorerUrlIndex !== undefined;\n\n    if (isInvalidDefaultBlockExplorerUrlIndex) {\n      throw new Error(\n        `${errorMessagePrefix}: \\`defaultBlockExplorerUrlIndex\\` must refer to an entry in \\`blockExplorerUrls\\``,\n      );\n    }\n\n    if (networkFields.rpcEndpoints.length === 0) {\n      throw new Error(\n        `${errorMessagePrefix}: \\`rpcEndpoints\\` must be a non-empty array`,\n      );\n    }\n    for (const rpcEndpointFields of networkFields.rpcEndpoints) {\n      if (!isValidUrl(rpcEndpointFields.url)) {\n        throw new Error(\n          `${errorMessagePrefix}: An entry in \\`rpcEndpoints\\` has invalid URL '${rpcEndpointFields.url}'`,\n        );\n      }\n      const networkClientId =\n        'networkClientId' in rpcEndpointFields\n          ? rpcEndpointFields.networkClientId\n          : undefined;\n\n      if (\n        rpcEndpointFields.type === RpcEndpointType.Custom &&\n        networkClientId !== undefined &&\n        isInfuraNetworkType(networkClientId)\n      ) {\n        throw new Error(\n          `${errorMessagePrefix}: Custom RPC endpoint '${rpcEndpointFields.url}' has invalid network client ID '${networkClientId}'`,\n        );\n      }\n\n      if (\n        mode === 'update' &&\n        networkClientId !== undefined &&\n        rpcEndpointFields.type === RpcEndpointType.Custom &&\n        !Object.values(autoManagedNetworkClientRegistry).some(\n          (networkClientsById) => networkClientId in networkClientsById,\n        )\n      ) {\n        throw new Error(\n          `${errorMessagePrefix}: RPC endpoint '${rpcEndpointFields.url}' refers to network client '${networkClientId}' that does not exist`,\n        );\n      }\n\n      if (\n        networkFields.rpcEndpoints.some(\n          (otherRpcEndpointFields) =>\n            otherRpcEndpointFields !== rpcEndpointFields &&\n            URI.equal(otherRpcEndpointFields.url, rpcEndpointFields.url),\n        )\n      ) {\n        throw new Error(\n          `${errorMessagePrefix}: Each entry in rpcEndpoints must have a unique URL`,\n        );\n      }\n\n      const networkConfigurationsForOtherChains = Object.values(\n        this.state.networkConfigurationsByChainId,\n      ).filter((networkConfiguration) =>\n        existingNetworkConfiguration\n          ? networkConfiguration.chainId !==\n            existingNetworkConfiguration.chainId\n          : true,\n      );\n      for (const networkConfiguration of networkConfigurationsForOtherChains) {\n        const rpcEndpoint = networkConfiguration.rpcEndpoints.find(\n          (existingRpcEndpoint) =>\n            URI.equal(rpcEndpointFields.url, existingRpcEndpoint.url),\n        );\n        if (rpcEndpoint) {\n          if (mode === 'update') {\n            throw new Error(\n              `Could not update network to point to same RPC endpoint as existing network for chain ${networkConfiguration.chainId} ('${networkConfiguration.name}')`,\n            );\n          } else {\n            throw new Error(\n              `Could not add network that points to same RPC endpoint as existing network for chain ${networkConfiguration.chainId} ('${networkConfiguration.name}')`,\n            );\n          }\n        }\n      }\n    }\n\n    if (\n      [...new Set(networkFields.rpcEndpoints)].length <\n      networkFields.rpcEndpoints.length\n    ) {\n      throw new Error(\n        `${errorMessagePrefix}: Each entry in rpcEndpoints must be unique`,\n      );\n    }\n\n    const networkClientIds = networkFields.rpcEndpoints\n      .map((rpcEndpoint) =>\n        'networkClientId' in rpcEndpoint\n          ? rpcEndpoint.networkClientId\n          : undefined,\n      )\n      .filter(\n        (networkClientId): networkClientId is NetworkClientId =>\n          networkClientId !== undefined,\n      );\n    if ([...new Set(networkClientIds)].length < networkClientIds.length) {\n      throw new Error(\n        `${errorMessagePrefix}: Each entry in rpcEndpoints must have a unique networkClientId`,\n      );\n    }\n\n    const infuraRpcEndpoints = networkFields.rpcEndpoints.filter(\n      (rpcEndpointFields): rpcEndpointFields is InfuraRpcEndpoint =>\n        rpcEndpointFields.type === RpcEndpointType.Infura,\n    );\n    if (infuraRpcEndpoints.length > 1) {\n      throw new Error(\n        `${errorMessagePrefix}: There cannot be more than one Infura RPC endpoint`,\n      );\n    }\n\n    const soleInfuraRpcEndpoint = infuraRpcEndpoints[0];\n    if (soleInfuraRpcEndpoint) {\n      const infuraNetworkName = deriveInfuraNetworkNameFromRpcEndpointUrl(\n        soleInfuraRpcEndpoint.url,\n      );\n      const infuraNetworkNickname = NetworkNickname[infuraNetworkName];\n      const infuraChainId = ChainId[infuraNetworkName];\n      if (networkFields.chainId !== infuraChainId) {\n        throw new Error(\n          mode === 'add'\n            ? `Could not add network with chain ID ${networkFields.chainId} and Infura RPC endpoint for '${infuraNetworkNickname}' which represents ${infuraChainId}, as the two conflict`\n            : `Could not update network with chain ID ${networkFields.chainId} and Infura RPC endpoint for '${infuraNetworkNickname}' which represents ${infuraChainId}, as the two conflict`,\n        );\n      }\n    }\n\n    if (\n      networkFields.rpcEndpoints[networkFields.defaultRpcEndpointIndex] ===\n      undefined\n    ) {\n      throw new Error(\n        `${errorMessagePrefix}: \\`defaultRpcEndpointIndex\\` must refer to an entry in \\`rpcEndpoints\\``,\n      );\n    }\n  }\n\n  /**\n   * Constructs a network configuration that will be persisted to state when\n   * adding or updating a network.\n   *\n   * @param args - The arguments to this function.\n   * @param args.networkFields - The fields used to add or update a network.\n   * @param args.networkClientOperations - Operations which were calculated for\n   * updating the network client registry but which also map back to RPC\n   * endpoints (and so can be used to save those RPC endpoints).\n   * @returns The network configuration to persist.\n   */\n  #determineNetworkConfigurationToPersist({\n    networkFields,\n    networkClientOperations,\n  }: {\n    networkFields: AddNetworkFields | UpdateNetworkFields;\n    networkClientOperations: NetworkClientOperation[];\n  }): NetworkConfiguration {\n    const rpcEndpointsToPersist = networkClientOperations\n      .filter(\n        (\n          networkClientOperation,\n        ): networkClientOperation is\n          | AddNetworkClientOperation\n          | NoopNetworkClientOperation => {\n          return (\n            networkClientOperation.type === 'add' ||\n            networkClientOperation.type === 'noop'\n          );\n        },\n      )\n      .map((networkClientOperation) => networkClientOperation.rpcEndpoint)\n      .concat(\n        networkClientOperations\n          .filter(\n            (\n              networkClientOperation,\n            ): networkClientOperation is ReplaceNetworkClientOperation => {\n              return networkClientOperation.type === 'replace';\n            },\n          )\n          .map(\n            (networkClientOperation) => networkClientOperation.newRpcEndpoint,\n          ),\n      );\n\n    return { ...networkFields, rpcEndpoints: rpcEndpointsToPersist };\n  }\n\n  /**\n   * Creates and registers network clients using the given operations calculated\n   * as a part of adding or updating a network.\n   *\n   * @param args - The arguments to this function.\n   * @param args.networkFields - The fields used to add or update a network.\n   * @param args.networkClientOperations - Dictate which network clients need to\n   * be created.\n   * @param args.autoManagedNetworkClientRegistry - The network client registry\n   * to update.\n   */\n  #registerNetworkClientsAsNeeded({\n    networkFields,\n    networkClientOperations,\n    autoManagedNetworkClientRegistry,\n  }: {\n    networkFields: AddNetworkFields | UpdateNetworkFields;\n    networkClientOperations: NetworkClientOperation[];\n    autoManagedNetworkClientRegistry: AutoManagedNetworkClientRegistry;\n  }): void {\n    const addedRpcEndpoints = networkClientOperations\n      .filter(\n        (\n          networkClientOperation,\n        ): networkClientOperation is AddNetworkClientOperation => {\n          return networkClientOperation.type === 'add';\n        },\n      )\n      .map((networkClientOperation) => networkClientOperation.rpcEndpoint)\n      .concat(\n        networkClientOperations\n          .filter(\n            (\n              networkClientOperation,\n            ): networkClientOperation is ReplaceNetworkClientOperation => {\n              return networkClientOperation.type === 'replace';\n            },\n          )\n          .map(\n            (networkClientOperation) => networkClientOperation.newRpcEndpoint,\n          ),\n      );\n\n    for (const addedRpcEndpoint of addedRpcEndpoints) {\n      if (addedRpcEndpoint.type === RpcEndpointType.Infura) {\n        autoManagedNetworkClientRegistry[NetworkClientType.Infura][\n          addedRpcEndpoint.networkClientId\n        ] = createAutoManagedNetworkClient({\n          networkClientId: addedRpcEndpoint.networkClientId,\n          networkClientConfiguration: {\n            type: NetworkClientType.Infura,\n            chainId: networkFields.chainId,\n            network: addedRpcEndpoint.networkClientId,\n            failoverRpcUrls: addedRpcEndpoint.failoverUrls,\n            infuraProjectId: this.#infuraProjectId,\n            ticker: networkFields.nativeCurrency,\n          },\n          getRpcServiceOptions: this.#getRpcServiceOptions,\n          getBlockTrackerOptions: this.#getBlockTrackerOptions,\n          messenger: this.messenger,\n          isRpcFailoverEnabled: this.#isRpcFailoverEnabled,\n          logger: this.#log,\n        });\n      } else {\n        autoManagedNetworkClientRegistry[NetworkClientType.Custom][\n          addedRpcEndpoint.networkClientId\n        ] = createAutoManagedNetworkClient({\n          networkClientId: addedRpcEndpoint.networkClientId,\n          networkClientConfiguration: {\n            type: NetworkClientType.Custom,\n            chainId: networkFields.chainId,\n            failoverRpcUrls: addedRpcEndpoint.failoverUrls,\n            rpcUrl: addedRpcEndpoint.url,\n            ticker: networkFields.nativeCurrency,\n          },\n          getRpcServiceOptions: this.#getRpcServiceOptions,\n          getBlockTrackerOptions: this.#getBlockTrackerOptions,\n          messenger: this.messenger,\n          isRpcFailoverEnabled: this.#isRpcFailoverEnabled,\n          logger: this.#log,\n        });\n      }\n    }\n  }\n\n  /**\n   * Destroys and removes network clients using the given operations calculated\n   * as a part of updating or removing a network.\n   *\n   * @param args - The arguments to this function.\n   * @param args.networkClientOperations - Dictate which network clients to\n   * remove.\n   * @param args.autoManagedNetworkClientRegistry - The network client registry\n   * to update.\n   */\n  #unregisterNetworkClientsAsNeeded({\n    networkClientOperations,\n    autoManagedNetworkClientRegistry,\n  }: {\n    networkClientOperations: NetworkClientOperation[];\n    autoManagedNetworkClientRegistry: AutoManagedNetworkClientRegistry;\n  }): void {\n    const removedRpcEndpoints = networkClientOperations\n      .filter(\n        (\n          networkClientOperation,\n        ): networkClientOperation is RemoveNetworkClientOperation => {\n          return networkClientOperation.type === 'remove';\n        },\n      )\n      .map((networkClientOperation) => networkClientOperation.rpcEndpoint)\n      .concat(\n        networkClientOperations\n          .filter(\n            (\n              networkClientOperation,\n            ): networkClientOperation is ReplaceNetworkClientOperation => {\n              return networkClientOperation.type === 'replace';\n            },\n          )\n          .map(\n            (networkClientOperation) => networkClientOperation.oldRpcEndpoint,\n          ),\n      );\n\n    for (const rpcEndpoint of removedRpcEndpoints) {\n      const networkClient = this.getNetworkClientById(\n        rpcEndpoint.networkClientId,\n      );\n      networkClient.destroy();\n      delete autoManagedNetworkClientRegistry[networkClient.configuration.type][\n        rpcEndpoint.networkClientId\n      ];\n    }\n  }\n\n  /**\n   * Updates `networkConfigurationsByChainId` in state depending on whether a\n   * network is being added, updated, or removed.\n   *\n   * - The existing network configuration will be removed when a network is\n   * being filed under a different chain or removed.\n   * - A network configuration will be stored when a network is being added or\n   * when a network is being updated.\n   *\n   * @param args - The arguments to this function.\n   */\n  #updateNetworkConfigurations(\n    args: { state: Draft<NetworkState> } & (\n      | {\n          mode: 'add';\n          networkFields: AddNetworkFields;\n          networkConfigurationToPersist: NetworkConfiguration;\n        }\n      | {\n          mode: 'update';\n          networkFields: UpdateNetworkFields;\n          networkConfigurationToPersist: NetworkConfiguration;\n          existingNetworkConfiguration: NetworkConfiguration;\n        }\n      | {\n          mode: 'remove';\n          existingNetworkConfiguration: NetworkConfiguration;\n        }\n    ),\n  ): void {\n    const { state, mode } = args;\n\n    if (\n      mode === 'remove' ||\n      (mode === 'update' &&\n        args.networkFields.chainId !==\n          args.existingNetworkConfiguration.chainId)\n    ) {\n      delete state.networkConfigurationsByChainId[\n        args.existingNetworkConfiguration.chainId\n      ];\n    }\n\n    if (mode === 'add' || mode === 'update') {\n      if (\n        !deepEqual(\n          state.networkConfigurationsByChainId[args.networkFields.chainId],\n          args.networkConfigurationToPersist,\n        )\n      ) {\n        args.networkConfigurationToPersist.lastUpdatedAt = Date.now();\n      }\n      state.networkConfigurationsByChainId[args.networkFields.chainId] =\n        args.networkConfigurationToPersist;\n    }\n\n    this.#networkConfigurationsByNetworkClientId =\n      buildNetworkConfigurationsByNetworkClientId(\n        cloneDeep(state.networkConfigurationsByChainId),\n      );\n  }\n\n  /**\n   * Before accessing or switching the network, the registry of network clients\n   * needs to be populated. Otherwise, `#applyNetworkSelection` and\n   * `getNetworkClientRegistry` will throw an error. This method checks to see if the\n   * population step has happened yet, and if not, makes it happen.\n   *\n   * @returns The populated network client registry.\n   */\n  #ensureAutoManagedNetworkClientRegistryPopulated(): AutoManagedNetworkClientRegistry {\n    return (this.#autoManagedNetworkClientRegistry ??=\n      this.#createAutoManagedNetworkClientRegistry());\n  }\n\n  /**\n   * Constructs the registry of network clients based on the set of default\n   * and custom networks in state.\n   *\n   * @returns The network clients keyed by ID.\n   */\n  #createAutoManagedNetworkClientRegistry(): AutoManagedNetworkClientRegistry {\n    const chainIds = knownKeysOf(this.state.networkConfigurationsByChainId);\n    const networkClientsWithIds = chainIds.flatMap((chainId) => {\n      const networkConfiguration =\n        this.state.networkConfigurationsByChainId[chainId];\n      return networkConfiguration.rpcEndpoints.map((rpcEndpoint) => {\n        if (rpcEndpoint.type === RpcEndpointType.Infura) {\n          const infuraNetworkName = deriveInfuraNetworkNameFromRpcEndpointUrl(\n            rpcEndpoint.url,\n          );\n          return [\n            rpcEndpoint.networkClientId,\n            createAutoManagedNetworkClient({\n              networkClientId: rpcEndpoint.networkClientId,\n              networkClientConfiguration: {\n                type: NetworkClientType.Infura,\n                network: infuraNetworkName,\n                failoverRpcUrls: rpcEndpoint.failoverUrls,\n                infuraProjectId: this.#infuraProjectId,\n                chainId: networkConfiguration.chainId,\n                ticker: networkConfiguration.nativeCurrency,\n              },\n              getRpcServiceOptions: this.#getRpcServiceOptions,\n              getBlockTrackerOptions: this.#getBlockTrackerOptions,\n              messenger: this.messenger,\n              isRpcFailoverEnabled: this.#isRpcFailoverEnabled,\n              logger: this.#log,\n            }),\n          ] as const;\n        }\n        return [\n          rpcEndpoint.networkClientId,\n          createAutoManagedNetworkClient({\n            networkClientId: rpcEndpoint.networkClientId,\n            networkClientConfiguration: {\n              type: NetworkClientType.Custom,\n              chainId: networkConfiguration.chainId,\n              failoverRpcUrls: rpcEndpoint.failoverUrls,\n              rpcUrl: rpcEndpoint.url,\n              ticker: networkConfiguration.nativeCurrency,\n            },\n            getRpcServiceOptions: this.#getRpcServiceOptions,\n            getBlockTrackerOptions: this.#getBlockTrackerOptions,\n            messenger: this.messenger,\n            isRpcFailoverEnabled: this.#isRpcFailoverEnabled,\n            logger: this.#log,\n          }),\n        ] as const;\n      });\n    });\n\n    return networkClientsWithIds.reduce(\n      (\n        obj: {\n          [NetworkClientType.Custom]: Partial<AutoManagedCustomNetworkClientRegistry>;\n          [NetworkClientType.Infura]: Partial<AutoManagedBuiltInNetworkClientRegistry>;\n        },\n        [networkClientId, networkClient],\n      ) => {\n        return {\n          ...obj,\n          [networkClient.configuration.type]: {\n            ...obj[networkClient.configuration.type],\n            [networkClientId]: networkClient,\n          },\n        };\n      },\n      {\n        [NetworkClientType.Custom]: {},\n        [NetworkClientType.Infura]: {},\n      },\n    ) as AutoManagedNetworkClientRegistry;\n  }\n\n  /**\n   * Updates the global provider and block tracker proxies (accessible via\n   * {@link getSelectedNetworkClient}) to point to the same ones within the\n   * given network client, thereby magically switching any consumers using these\n   * proxies to use the new network.\n   *\n   * Also refreshes the EthQuery instance accessible via the `getEthQuery`\n   * action to wrap the provider from the new network client. Note that this is\n   * not a proxy, so consumers will need to call `getEthQuery` again after the\n   * network switch.\n   *\n   * @param networkClientId - The ID of a network client that requests will be\n   * routed through (either the name of an Infura network or the ID of a custom\n   * network configuration).\n   * @param options - Options for this method.\n   * @param options.updateState - Allows for updating state.\n   * @throws if no network client could be found matching the given ID.\n   */\n  #applyNetworkSelection(\n    networkClientId: string,\n    {\n      updateState,\n    }: {\n      updateState?: (state: Draft<NetworkState>) => void;\n    } = {},\n  ): void {\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    let autoManagedNetworkClient:\n      | AutoManagedNetworkClient<CustomNetworkClientConfiguration>\n      | AutoManagedNetworkClient<InfuraNetworkClientConfiguration>;\n\n    if (isInfuraNetworkType(networkClientId)) {\n      const possibleAutoManagedNetworkClient =\n        autoManagedNetworkClientRegistry[NetworkClientType.Infura][\n          networkClientId\n        ];\n\n      // This is impossible to reach\n      /* istanbul ignore if */\n      if (!possibleAutoManagedNetworkClient) {\n        throw new Error(\n          `No Infura network client found with ID '${networkClientId}'`,\n        );\n      }\n\n      autoManagedNetworkClient = possibleAutoManagedNetworkClient;\n    } else {\n      const possibleAutoManagedNetworkClient =\n        autoManagedNetworkClientRegistry[NetworkClientType.Custom][\n          networkClientId\n        ];\n\n      if (!possibleAutoManagedNetworkClient) {\n        throw new Error(`No network client found with ID '${networkClientId}'`);\n      }\n\n      autoManagedNetworkClient = possibleAutoManagedNetworkClient;\n    }\n\n    this.#autoManagedNetworkClient = autoManagedNetworkClient;\n\n    this.update((state) => {\n      state.selectedNetworkClientId = networkClientId;\n      state.networksMetadata[networkClientId] ??= {\n        status: NetworkStatus.Unknown,\n        EIPS: {},\n      };\n\n      updateState?.(state);\n    });\n\n    if (this.#providerProxy) {\n      this.#providerProxy.setTarget(this.#autoManagedNetworkClient.provider);\n    } else {\n      this.#providerProxy = createSwappableProxy(\n        this.#autoManagedNetworkClient.provider,\n      );\n    }\n\n    if (this.#blockTrackerProxy) {\n      this.#blockTrackerProxy.setTarget(\n        this.#autoManagedNetworkClient.blockTracker,\n      );\n    } else {\n      this.#blockTrackerProxy = createEventEmitterProxy(\n        this.#autoManagedNetworkClient.blockTracker,\n        {\n          eventFilter: 'skipInternal',\n        },\n      );\n    }\n\n    this.#ethQuery = new EthQuery(this.#providerProxy);\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"NetworkController.cjs","sourceRoot":"","sources":["../src/NetworkController.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport type { Partialize } from '@metamask/controller-utils';\nimport {\n  InfuraNetworkType,\n  CustomNetworkType,\n  NetworkType,\n  isSafeChainId,\n  isInfuraNetworkType,\n  ChainId,\n  NetworksTicker,\n  NetworkNickname,\n  BUILT_IN_CUSTOM_NETWORKS_RPC,\n  BUILT_IN_NETWORKS,\n  BuiltInNetworkName,\n} from '@metamask/controller-utils';\nimport type { PollingBlockTrackerOptions } from '@metamask/eth-block-tracker';\nimport EthQuery from '@metamask/eth-query';\nimport type { Messenger } from '@metamask/messenger';\nimport { errorCodes } from '@metamask/rpc-errors';\nimport {\n  createEventEmitterProxy,\n  createSwappableProxy,\n} from '@metamask/swappable-obj-proxy';\nimport type { SwappableProxy } from '@metamask/swappable-obj-proxy';\nimport type { Hex } from '@metamask/utils';\nimport { hasProperty, isPlainObject, isStrictHexString } from '@metamask/utils';\nimport deepEqual from 'fast-deep-equal';\nimport type { Draft } from 'immer';\nimport { produce } from 'immer';\nimport { cloneDeep } from 'lodash';\nimport type { Logger } from 'loglevel';\nimport { createSelector } from 'reselect';\nimport * as URI from 'uri-js';\nimport { v4 as uuidV4 } from 'uuid';\n\nimport {\n  DEPRECATED_NETWORKS,\n  INFURA_BLOCKED_KEY,\n  NetworkStatus,\n} from './constants';\nimport type {\n  AutoManagedNetworkClient,\n  ProxyWithAccessibleTarget,\n} from './create-auto-managed-network-client';\nimport { createAutoManagedNetworkClient } from './create-auto-managed-network-client';\nimport { projectLogger, createModuleLogger } from './logger';\nimport type { RpcServiceOptions } from './rpc-service/rpc-service';\nimport { NetworkClientType } from './types';\nimport type {\n  BlockTracker,\n  Provider,\n  CustomNetworkClientConfiguration,\n  InfuraNetworkClientConfiguration,\n  NetworkClientConfiguration,\n  AdditionalDefaultNetwork,\n} from './types';\n\nconst debugLog = createModuleLogger(projectLogger, 'NetworkController');\n\nconst INFURA_URL_REGEX =\n  /^https:\\/\\/(?<networkName>[^.]+)\\.infura\\.io\\/v\\d+\\/(?<apiKey>.+)$/u;\n\nexport type Block = {\n  baseFeePerGas?: string;\n};\n\n/**\n * Information about a network not held by any other part of state.\n */\nexport type NetworkMetadata = {\n  /**\n   * EIPs supported by the network.\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  EIPS: {\n    [eipNumber: number]: boolean;\n  };\n  /**\n   * Indicates the availability of the network\n   */\n  status: NetworkStatus;\n};\n\n/**\n * The type of an RPC endpoint.\n *\n * @see {@link CustomRpcEndpoint}\n * @see {@link InfuraRpcEndpoint}\n */\nexport enum RpcEndpointType {\n  Custom = 'custom',\n  Infura = 'infura',\n}\n\n/**\n * An Infura RPC endpoint is a reference to a specific network that Infura\n * supports as well as an Infura account we own that we allow users to make use\n * of for free. We need to disambiguate these endpoints from custom RPC\n * endpoints, because while the types for these kinds of object both have the\n * same interface, the URL for an Infura endpoint contains the Infura project\n * ID, and we don't want this to be present in state. We therefore hide it by\n * representing it in the URL as `{infuraProjectId}`, which we replace this when\n * create network clients. But we need to know somehow that we only need to do\n * this replacement for Infura endpoints and not custom endpoints â€” hence the\n * separate type.\n */\nexport type InfuraRpcEndpoint = {\n  /**\n   * Alternate RPC endpoints to use when this endpoint is down.\n   */\n  failoverUrls?: string[];\n  /**\n   * The optional user-facing nickname of the endpoint.\n   */\n  name?: string;\n  /**\n   * The identifier for the network client that has been created for this RPC\n   * endpoint. This is also used to uniquely identify the RPC endpoint in a\n   * set of RPC endpoints as well: once assigned, it is used to determine\n   * whether the `name`, `type`, or `url` of the RPC endpoint has changed.\n   */\n  networkClientId: BuiltInNetworkClientId;\n  /**\n   * The type of this endpoint, always \"default\".\n   */\n  type: RpcEndpointType.Infura;\n  /**\n   * The URL of the endpoint. Expected to be a template with the string\n   * `{infuraProjectId}`, which will get replaced with the Infura project ID\n   * when the network client is created.\n   */\n  url: `https://${InfuraNetworkType}.infura.io/v3/{infuraProjectId}`;\n};\n\n/**\n * A custom RPC endpoint is a reference to a user-defined server which fronts an\n * EVM chain. It may refer to an Infura network, but only by coincidence.\n */\nexport type CustomRpcEndpoint = {\n  /**\n   * Alternate RPC endpoints to use when this endpoint is down.\n   */\n  failoverUrls?: string[];\n  /**\n   * The optional user-facing nickname of the endpoint.\n   */\n  name?: string;\n  /**\n   * The identifier for the network client that has been created for this RPC\n   * endpoint. This is also used to uniquely identify the RPC endpoint in a\n   * set of RPC endpoints as well: once assigned, it is used to determine\n   * whether the `name`, `type`, or `url` of the RPC endpoint has changed.\n   */\n  networkClientId: CustomNetworkClientId;\n  /**\n   * The type of this endpoint, always \"custom\".\n   */\n  type: RpcEndpointType.Custom;\n  /**\n   * The URL of the endpoint.\n   */\n  url: string;\n};\n\n/**\n * An RPC endpoint is a reference to a server which fronts an EVM chain. There\n * are two varieties of RPC endpoints: Infura and custom.\n *\n * @see {@link CustomRpcEndpoint}\n * @see {@link InfuraRpcEndpoint}\n */\nexport type RpcEndpoint = InfuraRpcEndpoint | CustomRpcEndpoint;\n\n/**\n * From a user perspective, a network configuration holds information about a\n * network that a user can select through the client. A \"network\" in this sense\n * can explicitly refer to an EVM chain that the user explicitly adds or doesn't\n * need to add (because it comes shipped with the client). The properties here\n * therefore directly map to fields that a user sees and can edit for a network\n * within the client.\n *\n * Internally, a network configuration represents a single conceptual EVM chain,\n * which is represented tangibly via multiple RPC endpoints. A \"network\" is then\n * something for which a network client object is created automatically or\n * created on demand when it is added to the client.\n */\nexport type NetworkConfiguration = {\n  /**\n   * A set of URLs that allows the user to view activity that has occurred on\n   * the chain.\n   */\n  blockExplorerUrls: string[];\n  /**\n   * The ID of the chain. Represented in hexadecimal format with a leading \"0x\"\n   * instead of decimal format so that when viewed out of context it can be\n   * unambiguously interpreted.\n   */\n  chainId: Hex;\n  /**\n   * A reference to a URL that the client will use by default to allow the user\n   * to view activity that has occurred on the chain. This index must refer to\n   * an item in `blockExplorerUrls`.\n   */\n  defaultBlockExplorerUrlIndex?: number;\n  /**\n   * A reference to an RPC endpoint that all requests will use by default in order to\n   * interact with the chain. This index must refer to an item in\n   * `rpcEndpoints`.\n   */\n  defaultRpcEndpointIndex: number;\n  /**\n   * The user-facing nickname assigned to the chain.\n   */\n  name: string;\n  /**\n   * The name of the currency to use for the chain.\n   */\n  nativeCurrency: string;\n  /**\n   * The collection of possible RPC endpoints that the client can use to\n   * interact with the chain.\n   */\n  rpcEndpoints: RpcEndpoint[];\n  /**\n   * Profile Sync - Network Sync field.\n   * Allows comparison of local network state with state to sync.\n   */\n  lastUpdatedAt?: number;\n};\n\n/**\n * A custom RPC endpoint in a new network configuration, meant to be used in\n * conjunction with `AddNetworkFields`.\n *\n * Custom RPC endpoints do not need a `networkClientId` property because it is\n * assumed that they have not already been added and therefore network clients\n * do not exist for them yet (and hence IDs need to be generated).\n */\nexport type AddNetworkCustomRpcEndpointFields = Omit<\n  CustomRpcEndpoint,\n  'networkClientId'\n>;\n\n/**\n * A new network configuration that `addNetwork` takes.\n *\n * Custom RPC endpoints do not need a `networkClientId` property because it is\n * assumed that they have not already been added and are not represented by\n * network clients yet.\n */\nexport type AddNetworkFields = Omit<NetworkConfiguration, 'rpcEndpoints'> & {\n  rpcEndpoints: (InfuraRpcEndpoint | AddNetworkCustomRpcEndpointFields)[];\n};\n\n/**\n * A custom RPC endpoint in an updated representation of a network\n * configuration, meant to be used in conjunction with `UpdateNetworkFields`.\n *\n * Custom RPC endpoints do not need a `networkClientId` property because it is\n * assumed that they have not already been added and therefore network clients\n * do not exist for them yet (and hence IDs need to be generated).\n */\nexport type UpdateNetworkCustomRpcEndpointFields = Partialize<\n  CustomRpcEndpoint,\n  'networkClientId'\n>;\n\n/**\n * An updated representation of an existing network configuration that\n * `updateNetwork` takes.\n *\n * Custom RPC endpoints may or may not have a `networkClientId` property; if\n * they do, then it is assumed that they already exist, and if not, then it is\n * assumed that they are new and are not represented by network clients yet.\n */\nexport type UpdateNetworkFields = Omit<NetworkConfiguration, 'rpcEndpoints'> & {\n  rpcEndpoints: (InfuraRpcEndpoint | UpdateNetworkCustomRpcEndpointFields)[];\n};\n\n/**\n * `Object.keys()` is intentionally generic: it returns the keys of an object,\n * but it cannot make guarantees about the contents of that object, so the type\n * of the keys is merely `string[]`. While this is technically accurate, it is\n * also unnecessary if we have an object that we own and whose contents are\n * known exactly.\n *\n * TODO: Move to @metamask/utils.\n *\n * @param object - The object.\n * @returns The keys of an object, typed according to the type of the object\n * itself.\n */\nexport function knownKeysOf<Key extends PropertyKey>(\n  // TODO: Replace `any` with type\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  object: Partial<Record<Key, any>>,\n): Key[] {\n  return Object.keys(object) as Key[];\n}\n\n/**\n * Type guard for determining whether the given value is an error object with a\n * `code` property, such as an instance of Error.\n *\n * TODO: Move this to @metamask/utils.\n *\n * @param error - The object to check.\n * @returns True if `error` has a `code`, false otherwise.\n */\nfunction isErrorWithCode(error: unknown): error is { code: string | number } {\n  return typeof error === 'object' && error !== null && 'code' in error;\n}\n\n/**\n * The string that uniquely identifies an Infura network client.\n */\nexport type BuiltInNetworkClientId = InfuraNetworkType;\n\n/**\n * The string that uniquely identifies a custom network client.\n */\nexport type CustomNetworkClientId = string;\n\n/**\n * The string that uniquely identifies a network client.\n */\nexport type NetworkClientId = BuiltInNetworkClientId | CustomNetworkClientId;\n\n/**\n * Extra information about each network, such as whether it is accessible or\n * blocked and whether it supports EIP-1559, keyed by network client ID.\n */\nexport type NetworksMetadata = Record<NetworkClientId, NetworkMetadata>;\n\n/**\n * The state that NetworkController stores.\n */\nexport type NetworkState = {\n  /**\n   * The ID of the network client that the proxies returned by\n   * `getSelectedNetworkClient` currently point to.\n   */\n  selectedNetworkClientId: NetworkClientId;\n  /**\n   * The registry of networks and corresponding RPC endpoints that the\n   * controller can use to make requests for various chains.\n   *\n   * @see {@link NetworkConfiguration}\n   */\n  networkConfigurationsByChainId: Record<Hex, NetworkConfiguration>;\n  /**\n   * Extra information about each network, such as whether it is accessible or\n   * blocked and whether it supports EIP-1559, keyed by network client ID.\n   */\n  networksMetadata: NetworksMetadata;\n};\n\nconst controllerName = 'NetworkController';\n\n/**\n * Represents the block tracker for the currently selected network. (Note that\n * this is a proxy around a proxy: the inner one exists so that the block\n * tracker doesn't have to exist until it's used, and the outer one exists so\n * that the currently selected network can change without consumers needing to\n * refresh the object reference to that network.)\n */\nexport type BlockTrackerProxy = SwappableProxy<\n  ProxyWithAccessibleTarget<BlockTracker>\n>;\n\n/**\n * Represents the provider for the currently selected network. (Note that this\n * is a proxy around a proxy: the inner one exists so that the provider doesn't\n * have to exist until it's used, and the outer one exists so that the currently\n * selected network can change without consumers needing to refresh the object\n * reference to that network.)\n */\nexport type ProviderProxy = SwappableProxy<ProxyWithAccessibleTarget<Provider>>;\n\nexport type NetworkControllerStateChangeEvent = ControllerStateChangeEvent<\n  typeof controllerName,\n  NetworkState\n>;\n\n/**\n * `networkWillChange` is published when the current network is about to be\n * switched, but the new provider has not been created and no state changes have\n * occurred yet.\n */\nexport type NetworkControllerNetworkWillChangeEvent = {\n  type: 'NetworkController:networkWillChange';\n  payload: [NetworkState];\n};\n\n/**\n * `networkDidChange` is published after a provider has been created for a newly\n * switched network (but before the network has been confirmed to be available).\n */\nexport type NetworkControllerNetworkDidChangeEvent = {\n  type: 'NetworkController:networkDidChange';\n  payload: [NetworkState];\n};\n\n/**\n * `infuraIsBlocked` is published after the network is switched to an Infura\n * network, but when Infura returns an error blocking the user based on their\n * location.\n */\nexport type NetworkControllerInfuraIsBlockedEvent = {\n  type: 'NetworkController:infuraIsBlocked';\n  payload: [];\n};\n\n/**\n * `infuraIsBlocked` is published either after the network is switched to an\n * Infura network and Infura does not return an error blocking the user based on\n * their location, or the network is switched to a non-Infura network.\n */\nexport type NetworkControllerInfuraIsUnblockedEvent = {\n  type: 'NetworkController:infuraIsUnblocked';\n  payload: [];\n};\n\n/**\n * `networkAdded` is published after a network configuration is added to the\n * network configuration registry and network clients are created for it.\n */\nexport type NetworkControllerNetworkAddedEvent = {\n  type: 'NetworkController:networkAdded';\n  payload: [networkConfiguration: NetworkConfiguration];\n};\n\n/**\n * `networkRemoved` is published after a network configuration is removed from the\n * network configuration registry and once the network clients have been removed.\n */\nexport type NetworkControllerNetworkRemovedEvent = {\n  type: 'NetworkController:networkRemoved';\n  payload: [networkConfiguration: NetworkConfiguration];\n};\n\n/**\n * `NetworkController:rpcEndpointChainUnavailable` is published when, after\n * trying all endpoints in an endpoint chain, the last failover reaches a\n * maximum number of consecutive 5xx responses, breaking the underlying circuit.\n *\n * In other words, this event will not be published if a failover is available,\n * even if the primary is not.\n *\n * @param payload - The event payload.\n * @param payload.chainId - The target network's chain ID.\n * @param payload.error - The last error produced by the last failover in the\n * endpoint chain.\n * @param payload.networkClientId - The target network's client ID.\n */\nexport type NetworkControllerRpcEndpointChainUnavailableEvent = {\n  type: 'NetworkController:rpcEndpointChainUnavailable';\n  payload: [\n    {\n      chainId: Hex;\n      error: unknown;\n      networkClientId: NetworkClientId;\n    },\n  ];\n};\n\n/**\n * `NetworkController:rpcEndpointUnavailable` is published when any\n * endpoint in an endpoint chain reaches a maximum number of consecutive 5xx\n * responses, breaking the underlying circuit.\n *\n * In other words, this event will be published if a primary is not available,\n * even if a failover is.\n *\n * @param payload - The event payload.\n * @param payload.chainId - The target network's chain ID.\n * @param payload.endpointUrl - The URL of the endpoint which reached the\n * maximum number of consecutive 5xx responses. You can compare this to\n * `primaryEndpointUrl` to know whether it was a failover or a primary.\n * @param payload.error - The last error produced by the endpoint.\n * @param payload.networkClientId - The target network's client ID.\n * @param payload.primaryEndpointUrl - The endpoint chain's primary URL.\n */\nexport type NetworkControllerRpcEndpointUnavailableEvent = {\n  type: 'NetworkController:rpcEndpointUnavailable';\n  payload: [\n    {\n      chainId: Hex;\n      endpointUrl: string;\n      error: unknown;\n      networkClientId: NetworkClientId;\n      primaryEndpointUrl: string;\n    },\n  ];\n};\n\n/**\n * `NetworkController:rpcEndpointChainDegraded` is published for any of the\n * endpoints in an endpoint chain when one of the following two conditions hold\n * (and the chain is not already in a degraded state):\n *\n * 1. A successful (2xx) request, even after being retried, cannot be made to\n * the endpoint.\n * 2. A successful (2xx) request can be made to the endpoint, but it takes\n * longer than expected to complete.\n *\n * Note that this event will be published even if there are local connectivity\n * issues which prevent requests from being initiated. This is intentional.\n *\n * @param payload - The event payload.\n * @param payload.chainId - The target network's chain ID.\n * @param payload.error - The last error produced by the endpoint (or\n * `undefined` if the request was slow).\n * @param payload.networkClientId - The target network's client ID.\n */\nexport type NetworkControllerRpcEndpointChainDegradedEvent = {\n  type: 'NetworkController:rpcEndpointChainDegraded';\n  payload: [\n    {\n      chainId: Hex;\n      error: unknown;\n      networkClientId: NetworkClientId;\n    },\n  ];\n};\n\n/**\n *\n * `NetworkController:rpcEndpointDegraded` is published for any of the endpoints\n * in an endpoint chain when:\n *\n * 1. A successful (2xx) request, even after being retried, cannot be made to\n * the endpoint.\n * 2. A successful (2xx) request can be made to the endpoint, but it takes\n * longer than expected to complete.\n *\n * Note that this event will be published even if there are local connectivity\n * issues which prevent requests from being initiated. This is intentional.\n *\n * @param payload - The event payload.\n * @param payload.chainId - The target network's chain ID.\n * @param payload.endpointUrl - The URL of the endpoint for which requests\n * failed or were slow to complete. You can compare this to `primaryEndpointUrl`\n * to know whether it was a failover or a primary.\n * @param payload.error - The last error produced by the endpoint (or\n * `undefined` if the request was slow).\n * @param payload.networkClientId - The target network's client ID.\n * @param payload.primaryEndpointUrl - The endpoint chain's primary URL.\n */\nexport type NetworkControllerRpcEndpointDegradedEvent = {\n  type: 'NetworkController:rpcEndpointDegraded';\n  payload: [\n    {\n      chainId: Hex;\n      endpointUrl: string;\n      error: unknown;\n      networkClientId: NetworkClientId;\n      primaryEndpointUrl: string;\n    },\n  ];\n};\n\n/**\n * `NetworkController:rpcEndpointChainAvailable` is published in one of two\n * cases:\n *\n * 1. The first time that a 2xx request is made to any of the endpoints in an\n * endpoint chain.\n * 2. When requests to any of the endpoints previously failed (placing the\n * endpoint in a degraded or unavailable status), but are now succeeding again.\n *\n * @param payload - The event payload.\n * @param payload.chainId - The target network's chain ID.\n * @param payload.networkClientId - The target network's client ID.\n */\nexport type NetworkControllerRpcEndpointChainAvailableEvent = {\n  type: 'NetworkController:rpcEndpointChainAvailable';\n  payload: [\n    {\n      chainId: Hex;\n      networkClientId: NetworkClientId;\n    },\n  ];\n};\n\n/**\n * `NetworkController:rpcEndpointRetried` is published before a request to any\n * endpoint in an endpoint chain is retried.\n *\n * This is mainly useful for tests.\n *\n * @param payload - The event payload.\n * @param payload.attempt - The current attempt counter for the endpoint\n * (starting from 0).\n * @param payload.chainId - The target network's chain ID.\n * @param payload.endpointUrl - The URL of the endpoint being retried.\n * @param payload.networkClientId - The target network's client ID.\n * @param payload.primaryEndpointUrl - The endpoint chain's primary URL.\n * @see {@link RpcService} for the list of retriable errors.\n */\nexport type NetworkControllerRpcEndpointRetriedEvent = {\n  type: 'NetworkController:rpcEndpointRetried';\n  payload: [\n    {\n      attempt: number;\n      chainId: Hex;\n      endpointUrl: string;\n      networkClientId: NetworkClientId;\n      primaryEndpointUrl: string;\n    },\n  ];\n};\n\nexport type NetworkControllerEvents =\n  | NetworkControllerStateChangeEvent\n  | NetworkControllerNetworkWillChangeEvent\n  | NetworkControllerNetworkDidChangeEvent\n  | NetworkControllerInfuraIsBlockedEvent\n  | NetworkControllerInfuraIsUnblockedEvent\n  | NetworkControllerNetworkAddedEvent\n  | NetworkControllerNetworkRemovedEvent\n  | NetworkControllerRpcEndpointChainUnavailableEvent\n  | NetworkControllerRpcEndpointUnavailableEvent\n  | NetworkControllerRpcEndpointChainDegradedEvent\n  | NetworkControllerRpcEndpointDegradedEvent\n  | NetworkControllerRpcEndpointChainAvailableEvent\n  | NetworkControllerRpcEndpointRetriedEvent;\n\n/**\n * All events that {@link NetworkController} calls internally.\n */\ntype AllowedEvents = never;\n\nexport type NetworkControllerGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  NetworkState\n>;\n\nexport type NetworkControllerGetEthQueryAction = {\n  type: `NetworkController:getEthQuery`;\n  handler: () => EthQuery | undefined;\n};\n\nexport type NetworkControllerGetNetworkClientByIdAction = {\n  type: `NetworkController:getNetworkClientById`;\n  handler: NetworkController['getNetworkClientById'];\n};\n\nexport type NetworkControllerGetSelectedNetworkClientAction = {\n  type: `NetworkController:getSelectedNetworkClient`;\n  handler: NetworkController['getSelectedNetworkClient'];\n};\n\nexport type NetworkControllerGetSelectedChainIdAction = {\n  type: 'NetworkController:getSelectedChainId';\n  handler: NetworkController['getSelectedChainId'];\n};\n\nexport type NetworkControllerGetEIP1559CompatibilityAction = {\n  type: `NetworkController:getEIP1559Compatibility`;\n  handler: NetworkController['getEIP1559Compatibility'];\n};\n\nexport type NetworkControllerFindNetworkClientIdByChainIdAction = {\n  type: `NetworkController:findNetworkClientIdByChainId`;\n  handler: NetworkController['findNetworkClientIdByChainId'];\n};\n\n/**\n * Change the currently selected network to the given built-in network type.\n *\n * @deprecated This action has been replaced by `setActiveNetwork`, and will be\n * removed in a future release.\n */\nexport type NetworkControllerSetProviderTypeAction = {\n  type: `NetworkController:setProviderType`;\n  handler: NetworkController['setProviderType'];\n};\n\nexport type NetworkControllerSetActiveNetworkAction = {\n  type: `NetworkController:setActiveNetwork`;\n  handler: NetworkController['setActiveNetwork'];\n};\n\nexport type NetworkControllerGetNetworkConfigurationByChainId = {\n  type: `NetworkController:getNetworkConfigurationByChainId`;\n  handler: NetworkController['getNetworkConfigurationByChainId'];\n};\n\nexport type NetworkControllerGetNetworkConfigurationByNetworkClientId = {\n  type: `NetworkController:getNetworkConfigurationByNetworkClientId`;\n  handler: NetworkController['getNetworkConfigurationByNetworkClientId'];\n};\n\nexport type NetworkControllerAddNetworkAction = {\n  type: 'NetworkController:addNetwork';\n  handler: NetworkController['addNetwork'];\n};\n\nexport type NetworkControllerRemoveNetworkAction = {\n  type: 'NetworkController:removeNetwork';\n  handler: NetworkController['removeNetwork'];\n};\n\nexport type NetworkControllerUpdateNetworkAction = {\n  type: 'NetworkController:updateNetwork';\n  handler: NetworkController['updateNetwork'];\n};\n\nexport type NetworkControllerActions =\n  | NetworkControllerGetStateAction\n  | NetworkControllerGetEthQueryAction\n  | NetworkControllerGetNetworkClientByIdAction\n  | NetworkControllerGetSelectedNetworkClientAction\n  | NetworkControllerGetSelectedChainIdAction\n  | NetworkControllerGetEIP1559CompatibilityAction\n  | NetworkControllerFindNetworkClientIdByChainIdAction\n  | NetworkControllerSetActiveNetworkAction\n  | NetworkControllerSetProviderTypeAction\n  | NetworkControllerGetNetworkConfigurationByChainId\n  | NetworkControllerGetNetworkConfigurationByNetworkClientId\n  | NetworkControllerAddNetworkAction\n  | NetworkControllerRemoveNetworkAction\n  | NetworkControllerUpdateNetworkAction;\n\n/**\n * All actions that {@link NetworkController} calls internally.\n */\ntype AllowedActions = never;\n\nexport type NetworkControllerMessenger = Messenger<\n  typeof controllerName,\n  NetworkControllerActions | AllowedActions,\n  NetworkControllerEvents | AllowedEvents\n>;\n\n/**\n * Options for the NetworkController constructor.\n */\nexport type NetworkControllerOptions = {\n  /**\n   * The messenger suited for this controller.\n   */\n  messenger: NetworkControllerMessenger;\n  /**\n   * The API key for Infura, used to make requests to Infura.\n   */\n  infuraProjectId: string;\n  /**\n   * The desired state with which to initialize this controller.\n   * Missing properties will be filled in with defaults. For instance, if not\n   * specified, `networkConfigurationsByChainId` will default to a basic set of\n   * network configurations (see {@link InfuraNetworkType} for the list).\n   */\n  state?: Partial<NetworkState>;\n  /**\n   * A `loglevel` logger object.\n   */\n  log?: Logger;\n  /**\n   * A function that can be used to customize a RPC service constructed for an\n   * RPC endpoint. The function takes the URL of the endpoint and should return\n   * an object with type {@link RpcServiceOptions}, minus `failoverService`\n   * and `endpointUrl` (as they are filled in automatically).\n   */\n  getRpcServiceOptions: (\n    rpcEndpointUrl: string,\n  ) => Omit<RpcServiceOptions, 'failoverService' | 'endpointUrl'>;\n  /**\n   * A function that can be used to customize a block tracker constructed for an\n   * RPC endpoint. The function takes the URL of the endpoint and should return\n   * an object of type {@link PollingBlockTrackerOptions}, minus `provider` (as\n   * it is filled in automatically).\n   */\n  getBlockTrackerOptions?: (\n    rpcEndpointUrl: string,\n  ) => Omit<PollingBlockTrackerOptions, 'provider'>;\n  /**\n   * An array of Hex Chain IDs representing the additional networks to be included as default.\n   */\n  additionalDefaultNetworks?: AdditionalDefaultNetwork[];\n  /**\n   * Whether or not requests sent to unavailable RPC endpoints should be\n   * automatically diverted to configured failover RPC endpoints.\n   */\n  isRpcFailoverEnabled?: boolean;\n};\n\n/**\n * Constructs a value for the state property `networkConfigurationsByChainId`\n * which will be used if it has not been provided to the constructor.\n *\n * @param [additionalDefaultNetworks] - An array of Hex Chain IDs representing the additional networks to be included as default.\n * @returns The default value for `networkConfigurationsByChainId`.\n */\nfunction getDefaultNetworkConfigurationsByChainId(\n  additionalDefaultNetworks: AdditionalDefaultNetwork[] = [],\n): Record<Hex, NetworkConfiguration> {\n  const infuraNetworks = getDefaultInfuraNetworkConfigurationsByChainId();\n  const customNetworks = getDefaultCustomNetworkConfigurationsByChainId();\n\n  return additionalDefaultNetworks.reduce<Record<Hex, NetworkConfiguration>>(\n    (obj, chainId) => {\n      if (hasProperty(customNetworks, chainId)) {\n        obj[chainId] = customNetworks[chainId];\n      }\n      return obj;\n    },\n    // Always include the infura networks in the default networks\n    infuraNetworks,\n  );\n}\n\n/**\n * Constructs a `networkConfigurationsByChainId` object for all default Infura networks.\n *\n * @returns The `networkConfigurationsByChainId` object of all Infura networks.\n */\nfunction getDefaultInfuraNetworkConfigurationsByChainId(): Record<\n  Hex,\n  NetworkConfiguration\n> {\n  return Object.values(InfuraNetworkType).reduce<\n    Record<Hex, NetworkConfiguration>\n  >((obj, infuraNetworkType) => {\n    const chainId = ChainId[infuraNetworkType];\n\n    // Skip deprecated network as default network.\n    if (DEPRECATED_NETWORKS.has(chainId)) {\n      return obj;\n    }\n\n    const rpcEndpointUrl =\n      `https://${infuraNetworkType}.infura.io/v3/{infuraProjectId}` as const;\n\n    const networkConfiguration: NetworkConfiguration = {\n      blockExplorerUrls: [],\n      chainId,\n      defaultRpcEndpointIndex: 0,\n      name: NetworkNickname[infuraNetworkType],\n      nativeCurrency: NetworksTicker[infuraNetworkType],\n      rpcEndpoints: [\n        {\n          failoverUrls: [],\n          networkClientId: infuraNetworkType,\n          type: RpcEndpointType.Infura,\n          url: rpcEndpointUrl,\n        },\n      ],\n    };\n\n    return { ...obj, [chainId]: networkConfiguration };\n  }, {});\n}\n\n/**\n * Constructs a `networkConfigurationsByChainId` object for all default custom networks.\n *\n * @returns The `networkConfigurationsByChainId` object of all custom networks.\n */\nfunction getDefaultCustomNetworkConfigurationsByChainId(): Record<\n  Hex,\n  NetworkConfiguration\n> {\n  // Create the `networkConfigurationsByChainId` objects explicitly,\n  // Because it is not always guaranteed that the custom networks are included in the\n  // default networks.\n  const configs = {\n    [ChainId['megaeth-testnet']]: getCustomNetworkConfiguration(\n      CustomNetworkType['megaeth-testnet'],\n    ),\n    [ChainId['megaeth-testnet-v2']]: getCustomNetworkConfiguration(\n      CustomNetworkType['megaeth-testnet-v2'],\n    ),\n    [ChainId['monad-testnet']]: getCustomNetworkConfiguration(\n      CustomNetworkType['monad-testnet'],\n    ),\n    // New additions for 20+ network performance testing\n    [ChainId[BuiltInNetworkName.FantomMainnet]]: getCustomNetworkConfiguration(\n      CustomNetworkType['fantom-mainnet'],\n    ),\n    [ChainId[BuiltInNetworkName.GnosisMainnet]]: getCustomNetworkConfiguration(\n      CustomNetworkType['gnosis-mainnet'],\n    ),\n    [ChainId[BuiltInNetworkName.CeloMainnet]]: getCustomNetworkConfiguration(\n      CustomNetworkType['celo-mainnet'],\n    ),\n    [ChainId[BuiltInNetworkName.CronosMainnet]]: getCustomNetworkConfiguration(\n      CustomNetworkType['cronos-mainnet'],\n    ),\n    [ChainId[BuiltInNetworkName.Aurora]]: getCustomNetworkConfiguration(\n      CustomNetworkType.aurora,\n    ),\n    [ChainId[BuiltInNetworkName.MoonbeamMainnet]]:\n      getCustomNetworkConfiguration(CustomNetworkType['moonbeam-mainnet']),\n    [ChainId[BuiltInNetworkName.MoonriverMainnet]]:\n      getCustomNetworkConfiguration(CustomNetworkType['moonriver-mainnet']),\n    [ChainId[BuiltInNetworkName.KlaytnMainnet]]: getCustomNetworkConfiguration(\n      CustomNetworkType['klaytn-mainnet'],\n    ),\n    [ChainId[BuiltInNetworkName.AvalancheMainnet]]:\n      getCustomNetworkConfiguration(CustomNetworkType['avalanche-mainnet']),\n    [ChainId[BuiltInNetworkName.ZkSyncEraMainnet]]:\n      getCustomNetworkConfiguration(CustomNetworkType['zksync-era-mainnet']),\n    [ChainId[BuiltInNetworkName.PalmMainnet]]: getCustomNetworkConfiguration(\n      CustomNetworkType['palm-mainnet'],\n    ),\n    [ChainId[BuiltInNetworkName.HyperEvmMainnet]]:\n      getCustomNetworkConfiguration(CustomNetworkType['hypervm-mainnet']),\n  };\n\n  console.log(\n    '[NetworkController] getDefaultCustomNetworkConfigurationsByChainId - returning',\n    Object.keys(configs).length,\n    'custom network configurations',\n  );\n  console.log(\n    '[NetworkController] Custom network chain IDs:',\n    Object.keys(configs),\n  );\n\n  return configs;\n}\n\n/**\n * Constructs a `NetworkConfiguration` object by `CustomNetworkType`.\n *\n * @param customNetworkType - The type of the custom network.\n * @returns The `NetworkConfiguration` object.\n */\nfunction getCustomNetworkConfiguration(\n  customNetworkType: CustomNetworkType,\n): NetworkConfiguration {\n  const { ticker, rpcPrefs } = BUILT_IN_NETWORKS[customNetworkType];\n  const rpcEndpointUrl = BUILT_IN_CUSTOM_NETWORKS_RPC[customNetworkType];\n\n  return {\n    blockExplorerUrls: [rpcPrefs.blockExplorerUrl],\n    chainId: ChainId[customNetworkType],\n    defaultRpcEndpointIndex: 0,\n    defaultBlockExplorerUrlIndex: 0,\n    name: NetworkNickname[customNetworkType],\n    nativeCurrency: ticker,\n    rpcEndpoints: [\n      {\n        failoverUrls: [],\n        networkClientId: customNetworkType,\n        type: RpcEndpointType.Custom,\n        url: rpcEndpointUrl,\n      },\n    ],\n  };\n}\n\n/**\n * Constructs properties for the NetworkController state whose values will be\n * used if not provided to the constructor.\n *\n * @param [additionalDefaultNetworks] - An array of Hex Chain IDs representing the additional networks to be included as default.\n * @returns The default NetworkController state.\n */\nexport function getDefaultNetworkControllerState(\n  additionalDefaultNetworks?: AdditionalDefaultNetwork[],\n): NetworkState {\n  const networksMetadata = {};\n  const networkConfigurationsByChainId =\n    getDefaultNetworkConfigurationsByChainId(additionalDefaultNetworks);\n\n  return {\n    selectedNetworkClientId: InfuraNetworkType.mainnet,\n    networksMetadata,\n    networkConfigurationsByChainId,\n  };\n}\n\n/**\n * Redux selector for getting all network configurations from NetworkController\n * state, keyed by chain ID.\n *\n * @param state - NetworkController state\n * @returns All registered network configurations, keyed by chain ID.\n */\nconst selectNetworkConfigurationsByChainId = (\n  state: NetworkState,\n): Record<`0x${string}`, NetworkConfiguration> =>\n  state.networkConfigurationsByChainId;\n\n/**\n * Get a list of all network configurations.\n *\n * @param state - NetworkController state\n * @returns A list of all available network configurations\n */\nexport function getNetworkConfigurations(\n  state: NetworkState,\n): NetworkConfiguration[] {\n  return Object.values(state.networkConfigurationsByChainId);\n}\n\n/**\n * Redux selector for getting a list of all network configurations from\n * NetworkController state.\n *\n * @param state - NetworkController state\n * @returns A list of all available network configurations\n */\nexport const selectNetworkConfigurations = createSelector(\n  selectNetworkConfigurationsByChainId,\n  (networkConfigurationsByChainId) =>\n    Object.values(networkConfigurationsByChainId),\n);\n\n/**\n * Get a list of all available network client IDs from a list of network\n * configurations.\n *\n * @param networkConfigurations - The array of network configurations\n * @returns A list of all available client IDs\n */\nexport function getAvailableNetworkClientIds(\n  networkConfigurations: NetworkConfiguration[],\n): string[] {\n  return networkConfigurations.flatMap((networkConfiguration) =>\n    networkConfiguration.rpcEndpoints.map(\n      (rpcEndpoint) => rpcEndpoint.networkClientId,\n    ),\n  );\n}\n\n/**\n * Redux selector for getting a list of all available network client IDs\n * from NetworkController state.\n *\n * @param state - NetworkController state\n * @returns A list of all available network client IDs.\n */\nexport const selectAvailableNetworkClientIds = createSelector(\n  selectNetworkConfigurations,\n  getAvailableNetworkClientIds,\n);\n\n/**\n * The collection of auto-managed network clients that map to Infura networks.\n */\nexport type AutoManagedBuiltInNetworkClientRegistry = Record<\n  BuiltInNetworkClientId,\n  AutoManagedNetworkClient<InfuraNetworkClientConfiguration>\n>;\n\n/**\n * The collection of auto-managed network clients that map to Infura networks.\n */\nexport type AutoManagedCustomNetworkClientRegistry = Record<\n  CustomNetworkClientId,\n  AutoManagedNetworkClient<CustomNetworkClientConfiguration>\n>;\n\n/**\n * The collection of auto-managed network clients that map to Infura networks\n * as well as custom networks that users have added.\n */\nexport type AutoManagedNetworkClientRegistry = {\n  [NetworkClientType.Infura]: AutoManagedBuiltInNetworkClientRegistry;\n  [NetworkClientType.Custom]: AutoManagedCustomNetworkClientRegistry;\n};\n\n/**\n * Instructs `addNetwork` and `updateNetwork` to create a network client for an\n * RPC endpoint.\n *\n * @see {@link NetworkClientOperation}\n */\ntype AddNetworkClientOperation = {\n  type: 'add';\n  rpcEndpoint: RpcEndpoint;\n};\n\n/**\n * Instructs `updateNetwork` and `removeNetwork` to remove a network client for\n * an RPC endpoint.\n *\n * @see {@link NetworkClientOperation}\n */\ntype RemoveNetworkClientOperation = {\n  type: 'remove';\n  rpcEndpoint: RpcEndpoint;\n};\n\n/**\n * Instructs `addNetwork` and `updateNetwork` to replace the network client for\n * an RPC endpoint.\n *\n * @see {@link NetworkClientOperation}\n */\ntype ReplaceNetworkClientOperation = {\n  type: 'replace';\n  oldRpcEndpoint: RpcEndpoint;\n  newRpcEndpoint: RpcEndpoint;\n};\n\n/**\n * Instructs `addNetwork` and `updateNetwork` not to do anything with an RPC\n * endpoint, as far as the network client registry is concerned.\n *\n * @see {@link NetworkClientOperation}\n */\ntype NoopNetworkClientOperation = {\n  type: 'noop';\n  rpcEndpoint: RpcEndpoint;\n};\n\n/**\n * Instructs `addNetwork`, `updateNetwork`, and `removeNetwork` how to\n * update the network client registry.\n *\n * - When `addNetwork` is called, represents a network client that should be\n * created for a new RPC endpoint.\n * - When `removeNetwork` is called, represents a network client that should be\n * destroyed for a previously existing RPC endpoint.\n * - When `updateNetwork` is called, represents either:\n *   - a network client that should be added for a new RPC endpoint\n *   - a network client that should be removed for a previously existing RPC\n *   endpoint\n *   - a network client that should be replaced for an RPC endpoint that was\n *   changed in a non-major way, or\n *   - a network client that should be unchanged for an RPC endpoint that was\n *   also unchanged.\n */\ntype NetworkClientOperation =\n  | AddNetworkClientOperation\n  | RemoveNetworkClientOperation\n  | ReplaceNetworkClientOperation\n  | NoopNetworkClientOperation;\n\n/**\n * Determines whether the given URL is valid by attempting to parse it.\n *\n * @param url - The URL to test.\n * @returns True if the URL is valid, false otherwise.\n */\nfunction isValidUrl(url: string): boolean {\n  const uri = URI.parse(url);\n  return (\n    uri.error === undefined && (uri.scheme === 'http' || uri.scheme === 'https')\n  );\n}\n\n/**\n * Given an Infura API URL, extracts the subdomain that identifies the Infura\n * network.\n *\n * @param rpcEndpointUrl - The URL to operate on.\n * @returns The Infura network name that the URL references.\n * @throws if the URL is not an Infura API URL, or if an Infura network is not\n * present in the URL.\n */\nfunction deriveInfuraNetworkNameFromRpcEndpointUrl(\n  rpcEndpointUrl: string,\n): InfuraNetworkType {\n  const match = INFURA_URL_REGEX.exec(rpcEndpointUrl);\n\n  if (match?.groups) {\n    if (isInfuraNetworkType(match.groups.networkName)) {\n      return match.groups.networkName;\n    }\n\n    throw new Error(`Unknown Infura network '${match.groups.networkName}'`);\n  }\n\n  throw new Error('Could not derive Infura network from RPC endpoint URL');\n}\n\n/**\n * Performs a series of checks that the given NetworkController state is\n * internally consistent â€” that all parts of state that are supposed to match in\n * fact do â€” so that working with the state later on doesn't cause unexpected\n * errors.\n *\n * In the case of NetworkController, there are several parts of state that need\n * to match. For instance, `defaultRpcEndpointIndex` needs to match an entry\n * within `rpcEndpoints`, and `selectedNetworkClientId` needs to point to an RPC\n * endpoint within a network configuration.\n *\n * @param state - The NetworkController state to verify.\n * @throws if the state is invalid in some way.\n */\nfunction validateInitialState(state: NetworkState): void {\n  const networkConfigurationEntries = Object.entries(\n    state.networkConfigurationsByChainId,\n  );\n  const networkClientIds = getAvailableNetworkClientIds(\n    getNetworkConfigurations(state),\n  );\n\n  if (networkConfigurationEntries.length === 0) {\n    throw new Error(\n      'NetworkController state is invalid: `networkConfigurationsByChainId` cannot be empty',\n    );\n  }\n\n  for (const [chainId, networkConfiguration] of networkConfigurationEntries) {\n    if (chainId !== networkConfiguration.chainId) {\n      throw new Error(\n        `NetworkController state has invalid \\`networkConfigurationsByChainId\\`: Network configuration '${networkConfiguration.name}' is filed under '${chainId}' which does not match its \\`chainId\\` of '${networkConfiguration.chainId}'`,\n      );\n    }\n\n    const isInvalidDefaultBlockExplorerUrlIndex =\n      networkConfiguration.blockExplorerUrls.length > 0\n        ? networkConfiguration.defaultBlockExplorerUrlIndex === undefined ||\n          networkConfiguration.blockExplorerUrls[\n            networkConfiguration.defaultBlockExplorerUrlIndex\n          ] === undefined\n        : networkConfiguration.defaultBlockExplorerUrlIndex !== undefined;\n\n    if (isInvalidDefaultBlockExplorerUrlIndex) {\n      throw new Error(\n        `NetworkController state has invalid \\`networkConfigurationsByChainId\\`: Network configuration '${networkConfiguration.name}' has a \\`defaultBlockExplorerUrlIndex\\` that does not refer to an entry in \\`blockExplorerUrls\\``,\n      );\n    }\n\n    if (\n      networkConfiguration.rpcEndpoints[\n        networkConfiguration.defaultRpcEndpointIndex\n      ] === undefined\n    ) {\n      throw new Error(\n        `NetworkController state has invalid \\`networkConfigurationsByChainId\\`: Network configuration '${networkConfiguration.name}' has a \\`defaultRpcEndpointIndex\\` that does not refer to an entry in \\`rpcEndpoints\\``,\n      );\n    }\n  }\n\n  if ([...new Set(networkClientIds)].length < networkClientIds.length) {\n    throw new Error(\n      'NetworkController state has invalid `networkConfigurationsByChainId`: Every RPC endpoint across all network configurations must have a unique `networkClientId`',\n    );\n  }\n}\n\n/**\n * Checks that the given initial NetworkController state is internally\n * consistent similar to `validateInitialState`, but if an anomaly is detected,\n * it does its best to correct the state and logs an error to Sentry.\n *\n * @param state - The NetworkController state to verify.\n * @param messenger - The NetworkController messenger.\n * @returns The corrected state.\n */\nfunction correctInitialState(\n  state: NetworkState,\n  messenger: NetworkControllerMessenger,\n): NetworkState {\n  const networkConfigurationsSortedByChainId = getNetworkConfigurations(\n    state,\n  ).sort((a, b) => a.chainId.localeCompare(b.chainId));\n  const availableNetworkClientIds = getAvailableNetworkClientIds(\n    networkConfigurationsSortedByChainId,\n  );\n  const invalidNetworkClientIdsWithMetadata = Object.keys(\n    state.networksMetadata,\n  ).filter(\n    (networkClientId) => !availableNetworkClientIds.includes(networkClientId),\n  );\n\n  return produce(state, (newState) => {\n    if (!availableNetworkClientIds.includes(state.selectedNetworkClientId)) {\n      const firstNetworkConfiguration = networkConfigurationsSortedByChainId[0];\n      const newSelectedNetworkClientId =\n        firstNetworkConfiguration.rpcEndpoints[\n          firstNetworkConfiguration.defaultRpcEndpointIndex\n        ].networkClientId;\n      messenger.captureException?.(\n        new Error(\n          `\\`selectedNetworkClientId\\` '${state.selectedNetworkClientId}' does not refer to an RPC endpoint within a network configuration; correcting to '${newSelectedNetworkClientId}'`,\n        ),\n      );\n      newState.selectedNetworkClientId = newSelectedNetworkClientId;\n    }\n\n    if (invalidNetworkClientIdsWithMetadata.length > 0) {\n      for (const invalidNetworkClientId of invalidNetworkClientIdsWithMetadata) {\n        delete newState.networksMetadata[invalidNetworkClientId];\n      }\n      messenger.captureException?.(\n        new Error(\n          '`networksMetadata` had invalid network client IDs, which have been removed',\n        ),\n      );\n    }\n  });\n}\n\n/**\n * Transforms a map of chain ID to network configuration to a map of network\n * client ID to network configuration.\n *\n * @param networkConfigurationsByChainId - The network configurations, keyed by\n * chain ID.\n * @returns The network configurations, keyed by network client ID.\n */\nfunction buildNetworkConfigurationsByNetworkClientId(\n  networkConfigurationsByChainId: Record<Hex, NetworkConfiguration>,\n): Map<NetworkClientId, NetworkConfiguration> {\n  return new Map(\n    Object.values(networkConfigurationsByChainId).flatMap(\n      (networkConfiguration) => {\n        return networkConfiguration.rpcEndpoints.map((rpcEndpoint) => {\n          return [rpcEndpoint.networkClientId, networkConfiguration];\n        });\n      },\n    ),\n  );\n}\n\n/**\n * Controller that creates and manages an Ethereum network provider.\n */\nexport class NetworkController extends BaseController<\n  typeof controllerName,\n  NetworkState,\n  NetworkControllerMessenger\n> {\n  #ethQuery?: EthQuery;\n\n  readonly #infuraProjectId: string;\n\n  #previouslySelectedNetworkClientId: string;\n\n  #providerProxy: ProviderProxy | undefined;\n\n  #blockTrackerProxy: BlockTrackerProxy | undefined;\n\n  #autoManagedNetworkClientRegistry?: AutoManagedNetworkClientRegistry;\n\n  #autoManagedNetworkClient?:\n    | AutoManagedNetworkClient<CustomNetworkClientConfiguration>\n    | AutoManagedNetworkClient<InfuraNetworkClientConfiguration>;\n\n  readonly #log: Logger | undefined;\n\n  readonly #getRpcServiceOptions: NetworkControllerOptions['getRpcServiceOptions'];\n\n  readonly #getBlockTrackerOptions: NetworkControllerOptions['getBlockTrackerOptions'];\n\n  #networkConfigurationsByNetworkClientId: Map<\n    NetworkClientId,\n    NetworkConfiguration\n  >;\n\n  #isRpcFailoverEnabled: Exclude<\n    NetworkControllerOptions['isRpcFailoverEnabled'],\n    undefined\n  >;\n\n  /**\n   * Constructs a NetworkController.\n   *\n   * @param options - The options; see {@link NetworkControllerOptions}.\n   */\n  constructor(options: NetworkControllerOptions) {\n    const {\n      messenger,\n      state,\n      infuraProjectId,\n      log,\n      getRpcServiceOptions,\n      getBlockTrackerOptions,\n      additionalDefaultNetworks,\n      isRpcFailoverEnabled = false,\n    } = options;\n    const initialState = {\n      ...getDefaultNetworkControllerState(additionalDefaultNetworks),\n      ...state,\n    };\n    validateInitialState(initialState);\n    const correctedInitialState = correctInitialState(initialState, messenger);\n\n    if (!infuraProjectId || typeof infuraProjectId !== 'string') {\n      throw new Error('Invalid Infura project ID');\n    }\n\n    super({\n      name: controllerName,\n      metadata: {\n        selectedNetworkClientId: {\n          includeInStateLogs: true,\n          persist: true,\n          includeInDebugSnapshot: false,\n          usedInUi: true,\n        },\n        networksMetadata: {\n          includeInStateLogs: true,\n          persist: true,\n          includeInDebugSnapshot: false,\n          usedInUi: true,\n        },\n        networkConfigurationsByChainId: {\n          includeInStateLogs: true,\n          persist: true,\n          includeInDebugSnapshot: false,\n          usedInUi: true,\n        },\n      },\n      messenger,\n      state: correctedInitialState,\n    });\n\n    this.#infuraProjectId = infuraProjectId;\n    this.#log = log;\n    this.#getRpcServiceOptions = getRpcServiceOptions;\n    this.#getBlockTrackerOptions = getBlockTrackerOptions;\n    this.#isRpcFailoverEnabled = isRpcFailoverEnabled;\n\n    this.#previouslySelectedNetworkClientId =\n      this.state.selectedNetworkClientId;\n    this.#networkConfigurationsByNetworkClientId =\n      buildNetworkConfigurationsByNetworkClientId(\n        this.state.networkConfigurationsByChainId,\n      );\n\n    this.messenger.registerActionHandler(`${this.name}:getEthQuery`, () => {\n      return this.#ethQuery;\n    });\n\n    this.messenger.registerActionHandler(\n      `${this.name}:getNetworkClientById`,\n      this.getNetworkClientById.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${this.name}:getEIP1559Compatibility`,\n      this.getEIP1559Compatibility.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${this.name}:setActiveNetwork`,\n      this.setActiveNetwork.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${this.name}:setProviderType`,\n      this.setProviderType.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${this.name}:findNetworkClientIdByChainId`,\n      this.findNetworkClientIdByChainId.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${this.name}:getNetworkConfigurationByChainId`,\n      this.getNetworkConfigurationByChainId.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${this.name}:getNetworkConfigurationByNetworkClientId`,\n      this.getNetworkConfigurationByNetworkClientId.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${this.name}:getSelectedNetworkClient`,\n      this.getSelectedNetworkClient.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${this.name}:getSelectedChainId`,\n      this.getSelectedChainId.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${this.name}:addNetwork`,\n      this.addNetwork.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${this.name}:removeNetwork`,\n      this.removeNetwork.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${this.name}:updateNetwork`,\n      this.updateNetwork.bind(this),\n    );\n\n    this.messenger.subscribe(\n      `${this.name}:rpcEndpointChainUnavailable`,\n      ({ networkClientId }) => {\n        this.#updateMetadataForNetwork(networkClientId, {\n          networkStatus: NetworkStatus.Unavailable,\n        });\n      },\n    );\n    this.messenger.subscribe(\n      `${this.name}:rpcEndpointChainDegraded`,\n      ({ networkClientId }) => {\n        this.#updateMetadataForNetwork(networkClientId, {\n          networkStatus: NetworkStatus.Degraded,\n        });\n      },\n    );\n    this.messenger.subscribe(\n      `${this.name}:rpcEndpointChainAvailable`,\n      ({ networkClientId }) => {\n        this.#updateMetadataForNetwork(networkClientId, {\n          networkStatus: NetworkStatus.Available,\n        });\n      },\n    );\n  }\n\n  /**\n   * Enables the RPC failover functionality. That is, if any RPC endpoints are\n   * configured with failover URLs, then traffic will automatically be diverted\n   * to them if those RPC endpoints are unavailable.\n   */\n  enableRpcFailover(): void {\n    this.#updateRpcFailoverEnabled(true);\n  }\n\n  /**\n   * Disables the RPC failover functionality. That is, even if any RPC endpoints\n   * are configured with failover URLs, then traffic will not automatically be\n   * diverted to them if those RPC endpoints are unavailable.\n   */\n  disableRpcFailover(): void {\n    this.#updateRpcFailoverEnabled(false);\n  }\n\n  /**\n   * Enables or disables the RPC failover functionality, depending on the\n   * boolean given. This is done by reconstructing all network clients that were\n   * originally configured with failover URLs so that those URLs are either\n   * honored or ignored. Network client IDs will be preserved so as not to\n   * invalidate state in other controllers.\n   *\n   * @param newIsRpcFailoverEnabled - Whether or not to enable or disable the\n   * RPC failover functionality.\n   */\n  #updateRpcFailoverEnabled(newIsRpcFailoverEnabled: boolean): void {\n    if (this.#isRpcFailoverEnabled === newIsRpcFailoverEnabled) {\n      return;\n    }\n\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    for (const networkClientsById of Object.values(\n      autoManagedNetworkClientRegistry,\n    )) {\n      for (const networkClientId of Object.keys(networkClientsById)) {\n        // Type assertion: We can assume that `networkClientId` is valid here.\n        const networkClient =\n          networkClientsById[\n            networkClientId as keyof typeof networkClientsById\n          ];\n        if (\n          networkClient.configuration.failoverRpcUrls &&\n          networkClient.configuration.failoverRpcUrls.length > 0\n        ) {\n          newIsRpcFailoverEnabled\n            ? networkClient.enableRpcFailover()\n            : networkClient.disableRpcFailover();\n        }\n      }\n    }\n\n    this.#isRpcFailoverEnabled = newIsRpcFailoverEnabled;\n  }\n\n  /**\n   * Accesses the provider and block tracker for the currently selected network.\n   *\n   * @returns The proxy and block tracker proxies.\n   * @deprecated This method has been replaced by `getSelectedNetworkClient` (which has a more easily used return type) and will be removed in a future release.\n   */\n  getProviderAndBlockTracker(): {\n    provider: SwappableProxy<ProxyWithAccessibleTarget<Provider>> | undefined;\n    blockTracker:\n      | SwappableProxy<ProxyWithAccessibleTarget<BlockTracker>>\n      | undefined;\n  } {\n    return {\n      provider: this.#providerProxy,\n      blockTracker: this.#blockTrackerProxy,\n    };\n  }\n\n  /**\n   * Accesses the provider and block tracker for the currently selected network.\n   *\n   * @returns an object with the provider and block tracker proxies for the currently selected network.\n   */\n  getSelectedNetworkClient():\n    | {\n        provider: SwappableProxy<ProxyWithAccessibleTarget<Provider>>;\n        blockTracker: SwappableProxy<ProxyWithAccessibleTarget<BlockTracker>>;\n      }\n    | undefined {\n    if (this.#providerProxy && this.#blockTrackerProxy) {\n      return {\n        provider: this.#providerProxy,\n        blockTracker: this.#blockTrackerProxy,\n      };\n    }\n    return undefined;\n  }\n\n  /**\n   * Accesses the chain ID from the selected network client.\n   *\n   * @returns The chain ID of the selected network client in hex format or undefined if there is no network client.\n   */\n  getSelectedChainId(): Hex | undefined {\n    const networkConfiguration = this.getNetworkConfigurationByNetworkClientId(\n      this.state.selectedNetworkClientId,\n    );\n    return networkConfiguration?.chainId;\n  }\n\n  /**\n   * Internally, the Infura and custom network clients are categorized by type\n   * so that when accessing either kind of network client, TypeScript knows\n   * which type to assign to the network client. For some cases it's more useful\n   * to be able to access network clients by ID instead of by type and then ID,\n   * so this function makes that possible.\n   *\n   * @returns The network clients registered so far, keyed by ID.\n   */\n  getNetworkClientRegistry(): AutoManagedBuiltInNetworkClientRegistry &\n    AutoManagedCustomNetworkClientRegistry {\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    return Object.assign(\n      {},\n      autoManagedNetworkClientRegistry[NetworkClientType.Infura],\n      autoManagedNetworkClientRegistry[NetworkClientType.Custom],\n    );\n  }\n\n  /**\n   * Returns the Infura network client with the given ID.\n   *\n   * @param infuraNetworkClientId - An Infura network client ID.\n   * @returns The Infura network client.\n   * @throws If an Infura network client does not exist with the given ID.\n   */\n  getNetworkClientById(\n    infuraNetworkClientId: BuiltInNetworkClientId,\n  ): AutoManagedNetworkClient<InfuraNetworkClientConfiguration>;\n\n  /**\n   * Returns the custom network client with the given ID.\n   *\n   * @param customNetworkClientId - A custom network client ID.\n   * @returns The custom network client.\n   * @throws If a custom network client does not exist with the given ID.\n   */\n  getNetworkClientById(\n    customNetworkClientId: CustomNetworkClientId,\n  ): AutoManagedNetworkClient<CustomNetworkClientConfiguration>;\n\n  getNetworkClientById(\n    networkClientId: NetworkClientId,\n  ): AutoManagedNetworkClient<NetworkClientConfiguration> {\n    if (!networkClientId) {\n      throw new Error('No network client ID was provided.');\n    }\n\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    if (isInfuraNetworkType(networkClientId)) {\n      const infuraNetworkClient =\n        autoManagedNetworkClientRegistry[NetworkClientType.Infura][\n          networkClientId\n        ];\n      // This is impossible to reach\n      /* istanbul ignore if */\n      if (!infuraNetworkClient) {\n        throw new Error(\n          `No Infura network client was found with the ID \"${networkClientId}\".`,\n        );\n      }\n      return infuraNetworkClient;\n    }\n\n    const customNetworkClient =\n      autoManagedNetworkClientRegistry[NetworkClientType.Custom][\n        networkClientId\n      ];\n    if (!customNetworkClient) {\n      throw new Error(\n        `No custom network client was found with the ID \"${networkClientId}\".`,\n      );\n    }\n    return customNetworkClient;\n  }\n\n  /**\n   * Executes a series of steps to switch the network:\n   *\n   * 1. Notifies subscribers via the messenger that the network is about to be\n   * switched (and, really, that the global provider and block tracker proxies\n   * will be re-pointed to a new network).\n   * 2. Looks up a known and preinitialized network client matching the given\n   * ID and uses it to re-point the aforementioned provider and block tracker\n   * proxies.\n   * 3. Notifies subscribers via the messenger that the network has switched.\n   * 4. Captures metadata for the newly switched network in state.\n   *\n   * @param networkClientId - The ID of a network client that requests will be\n   * routed through (either the name of an Infura network or the ID of a custom\n   * network configuration).\n   * @param options - Options for this method.\n   * @param options.updateState - Allows for updating state.\n   */\n  async #refreshNetwork(\n    networkClientId: string,\n    options: {\n      updateState?: (state: Draft<NetworkState>) => void;\n    } = {},\n  ): Promise<void> {\n    this.messenger.publish('NetworkController:networkWillChange', this.state);\n    this.#applyNetworkSelection(networkClientId, options);\n    this.messenger.publish('NetworkController:networkDidChange', this.state);\n    await this.lookupNetwork();\n  }\n\n  /**\n   * Creates proxies for accessing the global network client and its block\n   * tracker. You must call this method in order to use\n   * `getProviderAndBlockTracker` (or its replacement,\n   * `getSelectedNetworkClient`).\n   *\n   * @param options - Optional arguments.\n   * @param options.lookupNetwork - Usually, metadata for the global network\n   * will be populated via a call to `lookupNetwork` after creating the provider\n   * and block tracker proxies. This allows for responding to the status of the\n   * global network after initializing this controller; however, it requires\n   * making a request to the network to do so. In the clients, where controllers\n   * are initialized before the UI is shown, this may be undesirable, as it\n   * means that if the user has just installed MetaMask, their IP address may be\n   * shared with a third party before they have a chance to finish onboarding.\n   * You can pass `false` if you'd like to disable this request and call\n   * `lookupNetwork` yourself.\n   */\n  initializeProvider(options: { lookupNetwork: false }): void;\n\n  /**\n   * Creates proxies for accessing the global network client and its block\n   * tracker. You must call this method in order to use\n   * `getProviderAndBlockTracker` (or its replacement,\n   * `getSelectedNetworkClient`).\n   *\n   * @param options - Optional arguments.\n   * @param options.lookupNetwork - Usually, metadata for the global network\n   * will be populated via a call to `lookupNetwork` after creating the provider\n   * and block tracker proxies. This allows for responding to the status of the\n   * global network after initializing this controller; however, it requires\n   * making a request to the network to do so. In the clients, where controllers\n   * are initialized before the UI is shown, this may be undesirable, as it\n   * means that if the user has just installed MetaMask, their IP address may be\n   * shared with a third party before they have a chance to finish onboarding.\n   * You can pass `false` if you'd like to disable this request and call\n   * `lookupNetwork` yourself.\n   * @returns A promise that resolves when the network lookup completes.\n   */\n  initializeProvider(options?: { lookupNetwork?: boolean }): Promise<void>;\n\n  initializeProvider({\n    lookupNetwork = true,\n  }: {\n    lookupNetwork?: boolean;\n  } = {}): Promise<void> | undefined {\n    this.#applyNetworkSelection(this.state.selectedNetworkClientId);\n\n    if (lookupNetwork) {\n      return this.lookupNetwork();\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Uses a request for the latest block to gather the following information on\n   * the given network:\n   *\n   * - The connectivity status: whether it is available, geo-blocked (Infura\n   * only), unavailable, or unknown\n   * - The capabilities status: whether it supports EIP-1559, whether it does\n   * not, or whether it is unknown\n   *\n   * @param networkClientId - The ID of the network client to inspect.\n   * If no ID is provided, uses the currently selected network.\n   * @returns The resulting metadata for the network.\n   */\n  async #determineNetworkMetadata(networkClientId: NetworkClientId): Promise<{\n    isInfura: boolean;\n    networkStatus:\n      | NetworkStatus.Available\n      | NetworkStatus.Unknown\n      | NetworkStatus.Unavailable\n      | NetworkStatus.Blocked;\n    isEIP1559Compatible: undefined | boolean;\n  }> {\n    // Force TypeScript to use one of the two overloads explicitly\n    const networkClient = isInfuraNetworkType(networkClientId)\n      ? this.getNetworkClientById(networkClientId)\n      : this.getNetworkClientById(networkClientId);\n\n    const isInfura =\n      networkClient.configuration.type === NetworkClientType.Infura;\n    let networkStatus: NetworkStatus;\n    let isEIP1559Compatible: boolean | undefined;\n\n    try {\n      isEIP1559Compatible =\n        await this.#determineEIP1559Compatibility(networkClientId);\n      networkStatus = NetworkStatus.Available;\n    } catch (error) {\n      debugLog('NetworkController: lookupNetwork: ', error);\n\n      if (isErrorWithCode(error)) {\n        let responseBody;\n        if (\n          isInfura &&\n          hasProperty(error, 'message') &&\n          typeof error.message === 'string'\n        ) {\n          try {\n            responseBody = JSON.parse(error.message);\n          } catch {\n            // error.message must not be JSON\n            this.#log?.warn(\n              'NetworkController: lookupNetwork: json parse error: ',\n              error,\n            );\n          }\n        }\n\n        if (\n          isPlainObject(responseBody) &&\n          responseBody.error === INFURA_BLOCKED_KEY\n        ) {\n          networkStatus = NetworkStatus.Blocked;\n        } else if (error.code === errorCodes.rpc.internal) {\n          networkStatus = NetworkStatus.Unknown;\n          this.#log?.warn(\n            'NetworkController: lookupNetwork: rpc internal error: ',\n            error,\n          );\n        } else {\n          networkStatus = NetworkStatus.Unavailable;\n          this.#log?.warn('NetworkController: lookupNetwork: ', error);\n        }\n      } else {\n        debugLog(\n          'NetworkController - could not determine network status',\n          error,\n        );\n        networkStatus = NetworkStatus.Unknown;\n        this.#log?.warn('NetworkController: lookupNetwork: ', error);\n      }\n    }\n\n    return { isInfura, networkStatus, isEIP1559Compatible };\n  }\n\n  /**\n   * Uses a request for the latest block to gather the following information on\n   * the given or selected network, persisting it to state:\n   *\n   * - The connectivity status: whether it is available, geo-blocked (Infura\n   * only), unavailable, or unknown\n   * - The capabilities status: whether it supports EIP-1559, whether it does\n   * not, or whether it is unknown\n   *\n   * @param networkClientId - The ID of the network client to inspect.\n   * If no ID is provided, uses the currently selected network.\n   */\n  async lookupNetwork(networkClientId?: NetworkClientId): Promise<void> {\n    if (networkClientId) {\n      await this.#lookupGivenNetwork(networkClientId);\n    } else {\n      await this.#lookupSelectedNetwork();\n    }\n  }\n\n  /**\n   * Uses a request for the latest block to gather the following information on\n   * the given network, persisting it to state:\n   *\n   * - The connectivity status: whether the network is available, geo-blocked\n   * (Infura only), unavailable, or unknown\n   * - The feature compatibility status: whether the network supports EIP-1559,\n   * whether it does not, or whether it is unknown\n   *\n   * @param networkClientId - The ID of the network client to inspect.\n   * @deprecated Please use `lookupNetwork` and pass a network client ID\n   * instead. This method will be removed in a future major version.\n   */\n  // We are planning on removing this so we aren't interested in testing this\n  // right now.\n  /* istanbul ignore next */\n  async lookupNetworkByClientId(\n    networkClientId: NetworkClientId,\n  ): Promise<void> {\n    await this.#lookupGivenNetwork(networkClientId);\n  }\n\n  /**\n   * Uses a request for the latest block to gather the following information on\n   * the given network, persisting it to state:\n   *\n   * - The connectivity status: whether the network is available, geo-blocked\n   * (Infura only), unavailable, or unknown\n   * - The feature compatibility status: whether the network supports EIP-1559,\n   * whether it does not, or whether it is unknown\n   *\n   * @param networkClientId - The ID of the network client to inspect.\n   */\n  async #lookupGivenNetwork(networkClientId: NetworkClientId): Promise<void> {\n    const { networkStatus, isEIP1559Compatible } =\n      await this.#determineNetworkMetadata(networkClientId);\n\n    this.#updateMetadataForNetwork(networkClientId, {\n      networkStatus,\n      isEIP1559Compatible,\n    });\n  }\n\n  /**\n   * Uses a request for the latest block to gather the following information on\n   * the currently selected network, persisting it to state:\n   *\n   * - The connectivity status: whether the network is available, geo-blocked\n   * (Infura only), unavailable, or unknown\n   * - The feature compatibility status: whether the network supports EIP-1559,\n   * whether it does not, or whether it is unknown\n   *\n   * Note that it is possible for the current network to be switched while this\n   * method is running. If that is the case, it will exit early (as this method\n   * will also run for the new network).\n   */\n  async #lookupSelectedNetwork(): Promise<void> {\n    if (!this.#ethQuery) {\n      return;\n    }\n\n    let networkChanged = false;\n    const listener = (): void => {\n      networkChanged = true;\n      try {\n        this.messenger.unsubscribe(\n          'NetworkController:networkDidChange',\n          listener,\n        );\n      } catch (error) {\n        // In theory, this `catch` should not be necessary given that this error\n        // would occur \"inside\" of the call to `#determineEIP1559Compatibility`\n        // below and so it should be caught by the `try`/`catch` below (it is\n        // impossible to reproduce in tests for that reason). However, somehow\n        // it occurs within Mobile and so we have to add our own `try`/`catch`\n        // here.\n        /* istanbul ignore next */\n        if (\n          !(error instanceof Error) ||\n          error.message !==\n            'Subscription not found for event: NetworkController:networkDidChange'\n        ) {\n          // Again, this error should not happen and is impossible to reproduce\n          // in tests.\n          /* istanbul ignore next */\n          throw error;\n        }\n      }\n    };\n    this.messenger.subscribe('NetworkController:networkDidChange', listener);\n\n    const { isInfura, networkStatus, isEIP1559Compatible } =\n      await this.#determineNetworkMetadata(this.state.selectedNetworkClientId);\n\n    if (networkChanged) {\n      // If the network has changed, then `lookupNetwork` either has been or is\n      // in the process of being called, so we don't need to go further.\n      return;\n    }\n\n    try {\n      this.messenger.unsubscribe(\n        'NetworkController:networkDidChange',\n        listener,\n      );\n    } catch (error) {\n      if (\n        !(error instanceof Error) ||\n        error.message !==\n          'Subscription not found for event: NetworkController:networkDidChange'\n      ) {\n        throw error;\n      }\n    }\n\n    this.#updateMetadataForNetwork(this.state.selectedNetworkClientId, {\n      networkStatus,\n      isEIP1559Compatible,\n    });\n\n    if (isInfura) {\n      if (networkStatus === NetworkStatus.Available) {\n        this.messenger.publish('NetworkController:infuraIsUnblocked');\n      } else if (networkStatus === NetworkStatus.Blocked) {\n        this.messenger.publish('NetworkController:infuraIsBlocked');\n      }\n    } else {\n      // Always publish infuraIsUnblocked regardless of network status to\n      // prevent consumers from being stuck in a blocked state if they were\n      // previously connected to an Infura network that was blocked\n      this.messenger.publish('NetworkController:infuraIsUnblocked');\n    }\n  }\n\n  /**\n   * Updates the metadata for the given network in state.\n   *\n   * @param networkClientId - The associated network client ID.\n   * @param metadata - The metadata to store in state.\n   * @param metadata.networkStatus - The network status to store in state.\n   * @param metadata.isEIP1559Compatible - The EIP-1559 compatibility status to\n   * store in state.\n   */\n  #updateMetadataForNetwork(\n    networkClientId: NetworkClientId,\n    metadata: {\n      networkStatus: NetworkStatus;\n      isEIP1559Compatible?: boolean | undefined;\n    },\n  ): void {\n    this.update((state) => {\n      state.networksMetadata[networkClientId] ??= {\n        status: NetworkStatus.Unknown,\n        EIPS: {},\n      };\n\n      const newMetadata = state.networksMetadata[networkClientId];\n      newMetadata.status = metadata.networkStatus;\n\n      if ('isEIP1559Compatible' in metadata) {\n        if (metadata.isEIP1559Compatible === undefined) {\n          delete newMetadata.EIPS[1559];\n        } else {\n          newMetadata.EIPS[1559] = metadata.isEIP1559Compatible;\n        }\n      }\n    });\n  }\n\n  /**\n   * Convenience method to update provider network type settings.\n   *\n   * @param type - Human readable network name.\n   * @deprecated This has been replaced by `setActiveNetwork`, and will be\n   * removed in a future release\n   */\n  async setProviderType(type: InfuraNetworkType): Promise<void> {\n    if ((type as unknown) === NetworkType.rpc) {\n      throw new Error(\n        `NetworkController - cannot call \"setProviderType\" with type \"${NetworkType.rpc}\". Use \"setActiveNetwork\"`,\n      );\n    }\n    if (!isInfuraNetworkType(type)) {\n      throw new Error(`Unknown Infura provider type \"${String(type)}\".`);\n    }\n\n    await this.setActiveNetwork(type);\n  }\n\n  /**\n   * Changes the selected network.\n   *\n   * @param networkClientId - The ID of a network client that will be used to\n   * make requests.\n   * @param options - Options for this method.\n   * @param options.updateState - Allows for updating state.\n   * @throws if no network client is associated with the given\n   * network client ID.\n   */\n  async setActiveNetwork(\n    networkClientId: string,\n    options: {\n      updateState?: (state: Draft<NetworkState>) => void;\n    } = {},\n  ): Promise<void> {\n    this.#previouslySelectedNetworkClientId =\n      this.state.selectedNetworkClientId;\n\n    await this.#refreshNetwork(networkClientId, options);\n  }\n\n  /**\n   * Fetches the latest block for the network.\n   *\n   * @param networkClientId - The networkClientId to fetch the correct provider against which to check the latest block. Defaults to the selectedNetworkClientId.\n   * @returns A promise that either resolves to the block header or null if\n   * there is no latest block, or rejects with an error.\n   */\n  #getLatestBlock(\n    networkClientId: NetworkClientId = this.state.selectedNetworkClientId,\n  ): Promise<Block> {\n    const networkClient = this.getNetworkClientById(networkClientId);\n    const ethQuery = new EthQuery(networkClient.provider);\n\n    return new Promise((resolve, reject) => {\n      ethQuery.sendAsync(\n        { method: 'eth_getBlockByNumber', params: ['latest', false] },\n        (error: unknown, block?: unknown) => {\n          if (error) {\n            // This error comes from JsonRpcEngine, we don't control it.\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            reject(error);\n          } else {\n            // TODO: Validate this type\n            resolve(block as Block);\n          }\n        },\n      );\n    });\n  }\n\n  /**\n   * Determines whether the network supports EIP-1559 by checking whether the\n   * latest block has a `baseFeePerGas` property, then updates state\n   * appropriately.\n   *\n   * @param networkClientId - The networkClientId to fetch the correct provider against which to check 1559 compatibility.\n   * @returns A promise that resolves to true if the network supports EIP-1559\n   * , false otherwise, or `undefined` if unable to determine the compatibility.\n   */\n  async getEIP1559Compatibility(\n    networkClientId?: NetworkClientId,\n  ): Promise<undefined | boolean> {\n    if (networkClientId) {\n      return this.get1559CompatibilityWithNetworkClientId(networkClientId);\n    }\n    if (!this.#ethQuery) {\n      return false;\n    }\n\n    const { EIPS } =\n      this.state.networksMetadata[this.state.selectedNetworkClientId];\n\n    if (EIPS[1559] !== undefined) {\n      return EIPS[1559];\n    }\n\n    const isEIP1559Compatible = await this.#determineEIP1559Compatibility(\n      this.state.selectedNetworkClientId,\n    );\n    this.update((state) => {\n      if (isEIP1559Compatible !== undefined) {\n        state.networksMetadata[state.selectedNetworkClientId].EIPS[1559] =\n          isEIP1559Compatible;\n      }\n    });\n    return isEIP1559Compatible;\n  }\n\n  async get1559CompatibilityWithNetworkClientId(\n    networkClientId: NetworkClientId,\n  ): Promise<boolean> {\n    let metadata = this.state.networksMetadata[networkClientId];\n    if (metadata?.EIPS[1559] === undefined) {\n      await this.lookupNetwork(networkClientId);\n      metadata = this.state.networksMetadata[networkClientId];\n    }\n    const { EIPS } = metadata;\n\n    // may want to include some 'freshness' value - something to make sure we refetch this from time to time\n    return EIPS[1559];\n  }\n\n  /**\n   * Retrieves and checks the latest block from the currently selected\n   * network; if the block has a `baseFeePerGas` property, then we know\n   * that the network supports EIP-1559; otherwise it doesn't.\n   *\n   * @param networkClientId - The networkClientId to fetch the correct provider against which to check 1559 compatibility\n   * @returns A promise that resolves to `true` if the network supports EIP-1559,\n   * `false` otherwise, or `undefined` if unable to retrieve the last block.\n   */\n  async #determineEIP1559Compatibility(\n    networkClientId: NetworkClientId,\n  ): Promise<boolean | undefined> {\n    const latestBlock = await this.#getLatestBlock(networkClientId);\n\n    if (!latestBlock) {\n      return undefined;\n    }\n\n    return latestBlock.baseFeePerGas !== undefined;\n  }\n\n  /**\n   * Ensures that the provider and block tracker proxies are pointed to the\n   * currently selected network and refreshes the metadata for the\n   */\n  async resetConnection(): Promise<void> {\n    await this.#refreshNetwork(this.state.selectedNetworkClientId);\n  }\n\n  /**\n   * Returns the network configuration that has been filed under the given chain\n   * ID.\n   *\n   * @param chainId - The chain ID to use as a key.\n   * @returns The network configuration if one exists, or undefined.\n   */\n  getNetworkConfigurationByChainId(\n    chainId: Hex,\n  ): NetworkConfiguration | undefined {\n    return this.state.networkConfigurationsByChainId[chainId];\n  }\n\n  /**\n   * Returns the network configuration that contains an RPC endpoint with the\n   * given network client ID.\n   *\n   * @param networkClientId - The network client ID to use as a key.\n   * @returns The network configuration if one exists, or undefined.\n   */\n  getNetworkConfigurationByNetworkClientId(\n    networkClientId: NetworkClientId,\n  ): NetworkConfiguration | undefined {\n    return this.#networkConfigurationsByNetworkClientId.get(networkClientId);\n  }\n\n  /**\n   * Creates and registers network clients for the collection of Infura and\n   * custom RPC endpoints that can be used to make requests for a particular\n   * chain, storing the given configuration object in state for later reference.\n   *\n   * @param fields - The object that describes the new network/chain and lists\n   * the RPC endpoints which front that chain.\n   * @returns The newly added network configuration.\n   * @throws if any part of `fields` would produce invalid state.\n   * @see {@link NetworkConfiguration}\n   */\n  addNetwork(fields: AddNetworkFields): NetworkConfiguration {\n    const { rpcEndpoints: setOfRpcEndpointFields } = fields;\n\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    this.#validateNetworkFields({\n      mode: 'add',\n      networkFields: fields,\n      autoManagedNetworkClientRegistry,\n    });\n\n    const networkClientOperations = setOfRpcEndpointFields.map(\n      (defaultOrCustomRpcEndpointFields) => {\n        const rpcEndpoint =\n          defaultOrCustomRpcEndpointFields.type === RpcEndpointType.Custom\n            ? {\n                ...defaultOrCustomRpcEndpointFields,\n                networkClientId: uuidV4(),\n              }\n            : defaultOrCustomRpcEndpointFields;\n        return {\n          type: 'add' as const,\n          rpcEndpoint,\n        };\n      },\n    );\n\n    const newNetworkConfiguration =\n      this.#determineNetworkConfigurationToPersist({\n        networkFields: fields,\n        networkClientOperations,\n      });\n    this.#registerNetworkClientsAsNeeded({\n      networkFields: fields,\n      networkClientOperations,\n      autoManagedNetworkClientRegistry,\n    });\n    this.update((state) => {\n      this.#updateNetworkConfigurations({\n        state,\n        mode: 'add',\n        networkFields: fields,\n        networkConfigurationToPersist: newNetworkConfiguration,\n      });\n    });\n\n    this.messenger.publish(\n      `${controllerName}:networkAdded`,\n      newNetworkConfiguration,\n    );\n\n    return newNetworkConfiguration;\n  }\n\n  /**\n   * Updates the configuration for a previously stored network filed under the\n   * given chain ID, creating + registering new network clients to represent RPC\n   * endpoints that have been added and destroying + unregistering existing\n   * network clients for RPC endpoints that have been removed.\n   *\n   * Note that if `chainId` is changed, then all network clients associated with\n   * that chain will be removed and re-added, even if none of the RPC endpoints\n   * have changed.\n   *\n   * @param chainId - The chain ID associated with an existing network.\n   * @param fields - The object that describes the updates to the network/chain,\n   * including the new set of RPC endpoints which should front that chain.\n   * @param options - Options to provide.\n   * @param options.replacementSelectedRpcEndpointIndex - Usually you cannot\n   * remove an RPC endpoint that is being represented by the currently selected\n   * network client. This option allows you to specify another RPC endpoint\n   * (either an existing one or a new one) that should be used to select a new\n   * network instead.\n   * @returns The updated network configuration.\n   * @throws if `chainId` does not refer to an existing network configuration,\n   * if any part of `fields` would produce invalid state, etc.\n   * @see {@link NetworkConfiguration}\n   */\n  async updateNetwork(\n    chainId: Hex,\n    fields: UpdateNetworkFields,\n    {\n      replacementSelectedRpcEndpointIndex,\n    }: { replacementSelectedRpcEndpointIndex?: number } = {},\n  ): Promise<NetworkConfiguration> {\n    const existingNetworkConfiguration =\n      this.state.networkConfigurationsByChainId[chainId];\n\n    if (existingNetworkConfiguration === undefined) {\n      throw new Error(\n        `Could not update network: Cannot find network configuration for chain '${chainId}'`,\n      );\n    }\n\n    const existingChainId = chainId;\n    const { chainId: newChainId, rpcEndpoints: setOfNewRpcEndpointFields } =\n      fields;\n\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    this.#validateNetworkFields({\n      mode: 'update',\n      networkFields: fields,\n      existingNetworkConfiguration,\n      autoManagedNetworkClientRegistry,\n    });\n\n    const networkClientOperations: NetworkClientOperation[] = [];\n\n    for (const newRpcEndpointFields of setOfNewRpcEndpointFields) {\n      const existingRpcEndpointForNoop =\n        existingNetworkConfiguration.rpcEndpoints.find((rpcEndpoint) => {\n          return (\n            rpcEndpoint.type === newRpcEndpointFields.type &&\n            rpcEndpoint.url === newRpcEndpointFields.url &&\n            (rpcEndpoint.networkClientId ===\n              newRpcEndpointFields.networkClientId ||\n              newRpcEndpointFields.networkClientId === undefined)\n          );\n        });\n      const existingRpcEndpointForReplaceWhenChainChanged =\n        existingNetworkConfiguration.rpcEndpoints.find((rpcEndpoint) => {\n          return (\n            (rpcEndpoint.type === RpcEndpointType.Infura &&\n              newRpcEndpointFields.type === RpcEndpointType.Infura) ||\n            (rpcEndpoint.type === newRpcEndpointFields.type &&\n              rpcEndpoint.networkClientId ===\n                newRpcEndpointFields.networkClientId &&\n              rpcEndpoint.url === newRpcEndpointFields.url)\n          );\n        });\n      const existingRpcEndpointForReplaceWhenChainNotChanged =\n        existingNetworkConfiguration.rpcEndpoints.find((rpcEndpoint) => {\n          return (\n            rpcEndpoint.type === newRpcEndpointFields.type &&\n            (rpcEndpoint.url === newRpcEndpointFields.url ||\n              rpcEndpoint.networkClientId ===\n                newRpcEndpointFields.networkClientId)\n          );\n        });\n\n      if (\n        newChainId !== existingChainId &&\n        existingRpcEndpointForReplaceWhenChainChanged !== undefined\n      ) {\n        const newRpcEndpoint =\n          newRpcEndpointFields.type === RpcEndpointType.Infura\n            ? newRpcEndpointFields\n            : { ...newRpcEndpointFields, networkClientId: uuidV4() };\n\n        networkClientOperations.push({\n          type: 'replace' as const,\n          oldRpcEndpoint: existingRpcEndpointForReplaceWhenChainChanged,\n          newRpcEndpoint,\n        });\n      } else if (existingRpcEndpointForNoop !== undefined) {\n        let newRpcEndpoint;\n        if (existingRpcEndpointForNoop.type === RpcEndpointType.Infura) {\n          newRpcEndpoint = existingRpcEndpointForNoop;\n        } else {\n          // `networkClientId` shouldn't be missing at this point; if it is,\n          // that's a mistake, so fill it back in\n          newRpcEndpoint = Object.assign({}, newRpcEndpointFields, {\n            networkClientId: existingRpcEndpointForNoop.networkClientId,\n          });\n        }\n        networkClientOperations.push({\n          type: 'noop' as const,\n          rpcEndpoint: newRpcEndpoint,\n        });\n      } else if (\n        existingRpcEndpointForReplaceWhenChainNotChanged === undefined\n      ) {\n        const newRpcEndpoint =\n          newRpcEndpointFields.type === RpcEndpointType.Infura\n            ? newRpcEndpointFields\n            : { ...newRpcEndpointFields, networkClientId: uuidV4() };\n        const networkClientOperation = {\n          type: 'add' as const,\n          rpcEndpoint: newRpcEndpoint,\n        };\n        networkClientOperations.push(networkClientOperation);\n      } else {\n        let newRpcEndpoint;\n        /* istanbul ignore if */\n        if (newRpcEndpointFields.type === RpcEndpointType.Infura) {\n          // This case can't actually happen. If we're here, it means that some\n          // part of the RPC endpoint changed. But there is no part of an Infura\n          // RPC endpoint that can be changed (as it would immediately make that\n          // RPC endpoint self-inconsistent). This is just here to appease\n          // TypeScript.\n          newRpcEndpoint = newRpcEndpointFields;\n        } else {\n          newRpcEndpoint = {\n            ...newRpcEndpointFields,\n            networkClientId: uuidV4(),\n          };\n        }\n\n        networkClientOperations.push({\n          type: 'replace' as const,\n          oldRpcEndpoint: existingRpcEndpointForReplaceWhenChainNotChanged,\n          newRpcEndpoint,\n        });\n      }\n    }\n\n    for (const existingRpcEndpoint of existingNetworkConfiguration.rpcEndpoints) {\n      if (\n        !networkClientOperations.some((networkClientOperation) => {\n          const otherRpcEndpoint =\n            networkClientOperation.type === 'replace'\n              ? networkClientOperation.oldRpcEndpoint\n              : networkClientOperation.rpcEndpoint;\n          return (\n            otherRpcEndpoint.type === existingRpcEndpoint.type &&\n            otherRpcEndpoint.networkClientId ===\n              existingRpcEndpoint.networkClientId &&\n            otherRpcEndpoint.url === existingRpcEndpoint.url\n          );\n        })\n      ) {\n        const networkClientOperation = {\n          type: 'remove' as const,\n          rpcEndpoint: existingRpcEndpoint,\n        };\n        networkClientOperations.push(networkClientOperation);\n      }\n    }\n\n    const updatedNetworkConfiguration =\n      this.#determineNetworkConfigurationToPersist({\n        networkFields: fields,\n        networkClientOperations,\n      });\n\n    if (\n      replacementSelectedRpcEndpointIndex === undefined &&\n      networkClientOperations.some((networkClientOperation) => {\n        return (\n          networkClientOperation.type === 'remove' &&\n          networkClientOperation.rpcEndpoint.networkClientId ===\n            this.state.selectedNetworkClientId\n        );\n      }) &&\n      !networkClientOperations.some((networkClientOperation) => {\n        return (\n          networkClientOperation.type === 'replace' &&\n          networkClientOperation.oldRpcEndpoint.networkClientId ===\n            this.state.selectedNetworkClientId\n        );\n      })\n    ) {\n      throw new Error(\n        `Could not update network: Cannot update RPC endpoints in such a way that the selected network '${this.state.selectedNetworkClientId}' would be removed without a replacement. Choose a different RPC endpoint as the selected network via the \\`replacementSelectedRpcEndpointIndex\\` option.`,\n      );\n    }\n\n    this.#registerNetworkClientsAsNeeded({\n      networkFields: fields,\n      networkClientOperations,\n      autoManagedNetworkClientRegistry,\n    });\n\n    const replacementSelectedRpcEndpointWithIndex = networkClientOperations\n      .map(\n        (networkClientOperation, index) =>\n          [networkClientOperation, index] as const,\n      )\n      .find(([networkClientOperation, _index]) => {\n        return (\n          networkClientOperation.type === 'replace' &&\n          networkClientOperation.oldRpcEndpoint.networkClientId ===\n            this.state.selectedNetworkClientId\n        );\n      });\n    const correctedReplacementSelectedRpcEndpointIndex =\n      replacementSelectedRpcEndpointIndex ??\n      replacementSelectedRpcEndpointWithIndex?.[1];\n\n    let rpcEndpointToSelect: RpcEndpoint | undefined;\n    if (correctedReplacementSelectedRpcEndpointIndex !== undefined) {\n      rpcEndpointToSelect =\n        updatedNetworkConfiguration.rpcEndpoints[\n          correctedReplacementSelectedRpcEndpointIndex\n        ];\n\n      if (rpcEndpointToSelect === undefined) {\n        throw new Error(\n          `Could not update network: \\`replacementSelectedRpcEndpointIndex\\` ${correctedReplacementSelectedRpcEndpointIndex} does not refer to an entry in \\`rpcEndpoints\\``,\n        );\n      }\n    }\n\n    if (\n      rpcEndpointToSelect &&\n      rpcEndpointToSelect.networkClientId !== this.state.selectedNetworkClientId\n    ) {\n      await this.setActiveNetwork(rpcEndpointToSelect.networkClientId, {\n        updateState: (state) => {\n          this.#updateNetworkConfigurations({\n            state,\n            mode: 'update',\n            networkFields: fields,\n            networkConfigurationToPersist: updatedNetworkConfiguration,\n            existingNetworkConfiguration,\n          });\n        },\n      });\n    } else {\n      this.update((state) => {\n        this.#updateNetworkConfigurations({\n          state,\n          mode: 'update',\n          networkFields: fields,\n          networkConfigurationToPersist: updatedNetworkConfiguration,\n          existingNetworkConfiguration,\n        });\n      });\n    }\n\n    this.#unregisterNetworkClientsAsNeeded({\n      networkClientOperations,\n      autoManagedNetworkClientRegistry,\n    });\n\n    return updatedNetworkConfiguration;\n  }\n\n  /**\n   * Destroys and unregisters the network identified by the given chain ID, also\n   * removing the associated network configuration from state.\n   *\n   * @param chainId - The chain ID associated with an existing network.\n   * @throws if `chainId` does not refer to an existing network configuration,\n   * or if the currently selected network is being removed.\n   * @see {@link NetworkConfiguration}\n   */\n  removeNetwork(chainId: Hex): void {\n    const existingNetworkConfiguration =\n      this.state.networkConfigurationsByChainId[chainId];\n\n    if (existingNetworkConfiguration === undefined) {\n      throw new Error(\n        `Cannot find network configuration for chain '${chainId}'`,\n      );\n    }\n\n    if (\n      existingNetworkConfiguration.rpcEndpoints.some(\n        (rpcEndpoint) =>\n          rpcEndpoint.networkClientId === this.state.selectedNetworkClientId,\n      )\n    ) {\n      throw new Error(`Cannot remove the currently selected network`);\n    }\n\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    const networkClientOperations =\n      existingNetworkConfiguration.rpcEndpoints.map((rpcEndpoint) => {\n        return {\n          type: 'remove' as const,\n          rpcEndpoint,\n        };\n      });\n\n    this.#unregisterNetworkClientsAsNeeded({\n      networkClientOperations,\n      autoManagedNetworkClientRegistry,\n    });\n    this.update((state) => {\n      this.#updateNetworkConfigurations({\n        state,\n        mode: 'remove',\n        existingNetworkConfiguration,\n      });\n\n      for (const rpcEndpoint of existingNetworkConfiguration.rpcEndpoints) {\n        delete state.networksMetadata[rpcEndpoint.networkClientId];\n      }\n    });\n\n    this.messenger.publish(\n      'NetworkController:networkRemoved',\n      existingNetworkConfiguration,\n    );\n  }\n\n  /**\n   * Assuming that the network has been previously switched, switches to this\n   * new network.\n   *\n   * If the network has not been previously switched, this method is equivalent\n   * to {@link resetConnection}.\n   */\n  async rollbackToPreviousProvider(): Promise<void> {\n    await this.#refreshNetwork(this.#previouslySelectedNetworkClientId);\n  }\n\n  /**\n   * Deactivates the controller, stopping any ongoing polling.\n   *\n   * In-progress requests will not be aborted.\n   */\n  // We're intentionally changing the signature of an extended method.\n  // eslint-disable-next-line @typescript-eslint/no-misused-promises\n  async destroy(): Promise<void> {\n    await this.#blockTrackerProxy?.destroy();\n  }\n\n  /**\n   * Merges the given backup data into controller state.\n   *\n   * @param backup - The data that has been backed up.\n   * @param backup.networkConfigurationsByChainId - Network configurations,\n   * keyed by chain ID.\n   */\n  loadBackup({\n    networkConfigurationsByChainId,\n  }: Pick<NetworkState, 'networkConfigurationsByChainId'>): void {\n    this.update((state) => {\n      state.networkConfigurationsByChainId = {\n        ...state.networkConfigurationsByChainId,\n        ...networkConfigurationsByChainId,\n      };\n    });\n  }\n\n  /**\n   * Searches for the default RPC endpoint configured for the given chain and\n   * returns its network client ID. This can then be passed to\n   * {@link getNetworkClientById} to retrieve the network client.\n   *\n   * @param chainId - Chain ID to search for.\n   * @returns The ID of the network client created for the chain's default RPC\n   * endpoint.\n   */\n  findNetworkClientIdByChainId(chainId: Hex): NetworkClientId {\n    const networkConfiguration =\n      this.state.networkConfigurationsByChainId[chainId];\n\n    if (!networkConfiguration) {\n      throw new Error(`Invalid chain ID \"${chainId}\"`);\n    }\n\n    const { networkClientId } =\n      networkConfiguration.rpcEndpoints[\n        networkConfiguration.defaultRpcEndpointIndex\n      ];\n    return networkClientId;\n  }\n\n  /**\n   * Ensure that the given fields which will be used to either add or update a\n   * network are valid.\n   *\n   * @param args - The arguments.\n   */\n  #validateNetworkFields(\n    args: {\n      autoManagedNetworkClientRegistry: AutoManagedNetworkClientRegistry;\n    } & (\n      | {\n          mode: 'add';\n          networkFields: AddNetworkFields;\n        }\n      | {\n          mode: 'update';\n          existingNetworkConfiguration: NetworkConfiguration;\n          networkFields: UpdateNetworkFields;\n        }\n    ),\n  ): void {\n    const { mode, networkFields, autoManagedNetworkClientRegistry } = args;\n    const existingNetworkConfiguration =\n      'existingNetworkConfiguration' in args\n        ? args.existingNetworkConfiguration\n        : null;\n\n    const errorMessagePrefix =\n      mode === 'update' ? 'Could not update network' : 'Could not add network';\n\n    if (\n      !isStrictHexString(networkFields.chainId) ||\n      !isSafeChainId(networkFields.chainId)\n    ) {\n      throw new Error(\n        `${errorMessagePrefix}: Invalid \\`chainId\\` '${networkFields.chainId}' (must start with \"0x\" and not exceed the maximum)`,\n      );\n    }\n\n    if (\n      existingNetworkConfiguration === null ||\n      networkFields.chainId !== existingNetworkConfiguration.chainId\n    ) {\n      const existingNetworkConfigurationViaChainId =\n        this.state.networkConfigurationsByChainId[networkFields.chainId];\n      if (existingNetworkConfigurationViaChainId !== undefined) {\n        if (existingNetworkConfiguration === null) {\n          throw new Error(\n            `Could not add network for chain ${args.networkFields.chainId} as another network for that chain already exists ('${existingNetworkConfigurationViaChainId.name}')`,\n          );\n        } else {\n          throw new Error(\n            `Cannot move network from chain ${existingNetworkConfiguration.chainId} to ${networkFields.chainId} as another network for that chain already exists ('${existingNetworkConfigurationViaChainId.name}')`,\n          );\n        }\n      }\n    }\n\n    const isInvalidDefaultBlockExplorerUrlIndex =\n      networkFields.blockExplorerUrls.length > 0\n        ? networkFields.defaultBlockExplorerUrlIndex === undefined ||\n          networkFields.blockExplorerUrls[\n            networkFields.defaultBlockExplorerUrlIndex\n          ] === undefined\n        : networkFields.defaultBlockExplorerUrlIndex !== undefined;\n\n    if (isInvalidDefaultBlockExplorerUrlIndex) {\n      throw new Error(\n        `${errorMessagePrefix}: \\`defaultBlockExplorerUrlIndex\\` must refer to an entry in \\`blockExplorerUrls\\``,\n      );\n    }\n\n    if (networkFields.rpcEndpoints.length === 0) {\n      throw new Error(\n        `${errorMessagePrefix}: \\`rpcEndpoints\\` must be a non-empty array`,\n      );\n    }\n    for (const rpcEndpointFields of networkFields.rpcEndpoints) {\n      if (!isValidUrl(rpcEndpointFields.url)) {\n        throw new Error(\n          `${errorMessagePrefix}: An entry in \\`rpcEndpoints\\` has invalid URL '${rpcEndpointFields.url}'`,\n        );\n      }\n      const networkClientId =\n        'networkClientId' in rpcEndpointFields\n          ? rpcEndpointFields.networkClientId\n          : undefined;\n\n      if (\n        rpcEndpointFields.type === RpcEndpointType.Custom &&\n        networkClientId !== undefined &&\n        isInfuraNetworkType(networkClientId)\n      ) {\n        throw new Error(\n          `${errorMessagePrefix}: Custom RPC endpoint '${rpcEndpointFields.url}' has invalid network client ID '${networkClientId}'`,\n        );\n      }\n\n      if (\n        mode === 'update' &&\n        networkClientId !== undefined &&\n        rpcEndpointFields.type === RpcEndpointType.Custom &&\n        !Object.values(autoManagedNetworkClientRegistry).some(\n          (networkClientsById) => networkClientId in networkClientsById,\n        )\n      ) {\n        throw new Error(\n          `${errorMessagePrefix}: RPC endpoint '${rpcEndpointFields.url}' refers to network client '${networkClientId}' that does not exist`,\n        );\n      }\n\n      if (\n        networkFields.rpcEndpoints.some(\n          (otherRpcEndpointFields) =>\n            otherRpcEndpointFields !== rpcEndpointFields &&\n            URI.equal(otherRpcEndpointFields.url, rpcEndpointFields.url),\n        )\n      ) {\n        throw new Error(\n          `${errorMessagePrefix}: Each entry in rpcEndpoints must have a unique URL`,\n        );\n      }\n\n      const networkConfigurationsForOtherChains = Object.values(\n        this.state.networkConfigurationsByChainId,\n      ).filter((networkConfiguration) =>\n        existingNetworkConfiguration\n          ? networkConfiguration.chainId !==\n            existingNetworkConfiguration.chainId\n          : true,\n      );\n      for (const networkConfiguration of networkConfigurationsForOtherChains) {\n        const rpcEndpoint = networkConfiguration.rpcEndpoints.find(\n          (existingRpcEndpoint) =>\n            URI.equal(rpcEndpointFields.url, existingRpcEndpoint.url),\n        );\n        if (rpcEndpoint) {\n          if (mode === 'update') {\n            throw new Error(\n              `Could not update network to point to same RPC endpoint as existing network for chain ${networkConfiguration.chainId} ('${networkConfiguration.name}')`,\n            );\n          } else {\n            throw new Error(\n              `Could not add network that points to same RPC endpoint as existing network for chain ${networkConfiguration.chainId} ('${networkConfiguration.name}')`,\n            );\n          }\n        }\n      }\n    }\n\n    if (\n      [...new Set(networkFields.rpcEndpoints)].length <\n      networkFields.rpcEndpoints.length\n    ) {\n      throw new Error(\n        `${errorMessagePrefix}: Each entry in rpcEndpoints must be unique`,\n      );\n    }\n\n    const networkClientIds = networkFields.rpcEndpoints\n      .map((rpcEndpoint) =>\n        'networkClientId' in rpcEndpoint\n          ? rpcEndpoint.networkClientId\n          : undefined,\n      )\n      .filter(\n        (networkClientId): networkClientId is NetworkClientId =>\n          networkClientId !== undefined,\n      );\n    if ([...new Set(networkClientIds)].length < networkClientIds.length) {\n      throw new Error(\n        `${errorMessagePrefix}: Each entry in rpcEndpoints must have a unique networkClientId`,\n      );\n    }\n\n    const infuraRpcEndpoints = networkFields.rpcEndpoints.filter(\n      (rpcEndpointFields): rpcEndpointFields is InfuraRpcEndpoint =>\n        rpcEndpointFields.type === RpcEndpointType.Infura,\n    );\n    if (infuraRpcEndpoints.length > 1) {\n      throw new Error(\n        `${errorMessagePrefix}: There cannot be more than one Infura RPC endpoint`,\n      );\n    }\n\n    const soleInfuraRpcEndpoint = infuraRpcEndpoints[0];\n    if (soleInfuraRpcEndpoint) {\n      const infuraNetworkName = deriveInfuraNetworkNameFromRpcEndpointUrl(\n        soleInfuraRpcEndpoint.url,\n      );\n      const infuraNetworkNickname = NetworkNickname[infuraNetworkName];\n      const infuraChainId = ChainId[infuraNetworkName];\n      if (networkFields.chainId !== infuraChainId) {\n        throw new Error(\n          mode === 'add'\n            ? `Could not add network with chain ID ${networkFields.chainId} and Infura RPC endpoint for '${infuraNetworkNickname}' which represents ${infuraChainId}, as the two conflict`\n            : `Could not update network with chain ID ${networkFields.chainId} and Infura RPC endpoint for '${infuraNetworkNickname}' which represents ${infuraChainId}, as the two conflict`,\n        );\n      }\n    }\n\n    if (\n      networkFields.rpcEndpoints[networkFields.defaultRpcEndpointIndex] ===\n      undefined\n    ) {\n      throw new Error(\n        `${errorMessagePrefix}: \\`defaultRpcEndpointIndex\\` must refer to an entry in \\`rpcEndpoints\\``,\n      );\n    }\n  }\n\n  /**\n   * Constructs a network configuration that will be persisted to state when\n   * adding or updating a network.\n   *\n   * @param args - The arguments to this function.\n   * @param args.networkFields - The fields used to add or update a network.\n   * @param args.networkClientOperations - Operations which were calculated for\n   * updating the network client registry but which also map back to RPC\n   * endpoints (and so can be used to save those RPC endpoints).\n   * @returns The network configuration to persist.\n   */\n  #determineNetworkConfigurationToPersist({\n    networkFields,\n    networkClientOperations,\n  }: {\n    networkFields: AddNetworkFields | UpdateNetworkFields;\n    networkClientOperations: NetworkClientOperation[];\n  }): NetworkConfiguration {\n    const rpcEndpointsToPersist = networkClientOperations\n      .filter(\n        (\n          networkClientOperation,\n        ): networkClientOperation is\n          | AddNetworkClientOperation\n          | NoopNetworkClientOperation => {\n          return (\n            networkClientOperation.type === 'add' ||\n            networkClientOperation.type === 'noop'\n          );\n        },\n      )\n      .map((networkClientOperation) => networkClientOperation.rpcEndpoint)\n      .concat(\n        networkClientOperations\n          .filter(\n            (\n              networkClientOperation,\n            ): networkClientOperation is ReplaceNetworkClientOperation => {\n              return networkClientOperation.type === 'replace';\n            },\n          )\n          .map(\n            (networkClientOperation) => networkClientOperation.newRpcEndpoint,\n          ),\n      );\n\n    return { ...networkFields, rpcEndpoints: rpcEndpointsToPersist };\n  }\n\n  /**\n   * Creates and registers network clients using the given operations calculated\n   * as a part of adding or updating a network.\n   *\n   * @param args - The arguments to this function.\n   * @param args.networkFields - The fields used to add or update a network.\n   * @param args.networkClientOperations - Dictate which network clients need to\n   * be created.\n   * @param args.autoManagedNetworkClientRegistry - The network client registry\n   * to update.\n   */\n  #registerNetworkClientsAsNeeded({\n    networkFields,\n    networkClientOperations,\n    autoManagedNetworkClientRegistry,\n  }: {\n    networkFields: AddNetworkFields | UpdateNetworkFields;\n    networkClientOperations: NetworkClientOperation[];\n    autoManagedNetworkClientRegistry: AutoManagedNetworkClientRegistry;\n  }): void {\n    const addedRpcEndpoints = networkClientOperations\n      .filter(\n        (\n          networkClientOperation,\n        ): networkClientOperation is AddNetworkClientOperation => {\n          return networkClientOperation.type === 'add';\n        },\n      )\n      .map((networkClientOperation) => networkClientOperation.rpcEndpoint)\n      .concat(\n        networkClientOperations\n          .filter(\n            (\n              networkClientOperation,\n            ): networkClientOperation is ReplaceNetworkClientOperation => {\n              return networkClientOperation.type === 'replace';\n            },\n          )\n          .map(\n            (networkClientOperation) => networkClientOperation.newRpcEndpoint,\n          ),\n      );\n\n    for (const addedRpcEndpoint of addedRpcEndpoints) {\n      if (addedRpcEndpoint.type === RpcEndpointType.Infura) {\n        autoManagedNetworkClientRegistry[NetworkClientType.Infura][\n          addedRpcEndpoint.networkClientId\n        ] = createAutoManagedNetworkClient({\n          networkClientId: addedRpcEndpoint.networkClientId,\n          networkClientConfiguration: {\n            type: NetworkClientType.Infura,\n            chainId: networkFields.chainId,\n            network: addedRpcEndpoint.networkClientId,\n            failoverRpcUrls: addedRpcEndpoint.failoverUrls,\n            infuraProjectId: this.#infuraProjectId,\n            ticker: networkFields.nativeCurrency,\n          },\n          getRpcServiceOptions: this.#getRpcServiceOptions,\n          getBlockTrackerOptions: this.#getBlockTrackerOptions,\n          messenger: this.messenger,\n          isRpcFailoverEnabled: this.#isRpcFailoverEnabled,\n          logger: this.#log,\n        });\n      } else {\n        autoManagedNetworkClientRegistry[NetworkClientType.Custom][\n          addedRpcEndpoint.networkClientId\n        ] = createAutoManagedNetworkClient({\n          networkClientId: addedRpcEndpoint.networkClientId,\n          networkClientConfiguration: {\n            type: NetworkClientType.Custom,\n            chainId: networkFields.chainId,\n            failoverRpcUrls: addedRpcEndpoint.failoverUrls,\n            rpcUrl: addedRpcEndpoint.url,\n            ticker: networkFields.nativeCurrency,\n          },\n          getRpcServiceOptions: this.#getRpcServiceOptions,\n          getBlockTrackerOptions: this.#getBlockTrackerOptions,\n          messenger: this.messenger,\n          isRpcFailoverEnabled: this.#isRpcFailoverEnabled,\n          logger: this.#log,\n        });\n      }\n    }\n  }\n\n  /**\n   * Destroys and removes network clients using the given operations calculated\n   * as a part of updating or removing a network.\n   *\n   * @param args - The arguments to this function.\n   * @param args.networkClientOperations - Dictate which network clients to\n   * remove.\n   * @param args.autoManagedNetworkClientRegistry - The network client registry\n   * to update.\n   */\n  #unregisterNetworkClientsAsNeeded({\n    networkClientOperations,\n    autoManagedNetworkClientRegistry,\n  }: {\n    networkClientOperations: NetworkClientOperation[];\n    autoManagedNetworkClientRegistry: AutoManagedNetworkClientRegistry;\n  }): void {\n    const removedRpcEndpoints = networkClientOperations\n      .filter(\n        (\n          networkClientOperation,\n        ): networkClientOperation is RemoveNetworkClientOperation => {\n          return networkClientOperation.type === 'remove';\n        },\n      )\n      .map((networkClientOperation) => networkClientOperation.rpcEndpoint)\n      .concat(\n        networkClientOperations\n          .filter(\n            (\n              networkClientOperation,\n            ): networkClientOperation is ReplaceNetworkClientOperation => {\n              return networkClientOperation.type === 'replace';\n            },\n          )\n          .map(\n            (networkClientOperation) => networkClientOperation.oldRpcEndpoint,\n          ),\n      );\n\n    for (const rpcEndpoint of removedRpcEndpoints) {\n      const networkClient = this.getNetworkClientById(\n        rpcEndpoint.networkClientId,\n      );\n      networkClient.destroy();\n      delete autoManagedNetworkClientRegistry[networkClient.configuration.type][\n        rpcEndpoint.networkClientId\n      ];\n    }\n  }\n\n  /**\n   * Updates `networkConfigurationsByChainId` in state depending on whether a\n   * network is being added, updated, or removed.\n   *\n   * - The existing network configuration will be removed when a network is\n   * being filed under a different chain or removed.\n   * - A network configuration will be stored when a network is being added or\n   * when a network is being updated.\n   *\n   * @param args - The arguments to this function.\n   */\n  #updateNetworkConfigurations(\n    args: { state: Draft<NetworkState> } & (\n      | {\n          mode: 'add';\n          networkFields: AddNetworkFields;\n          networkConfigurationToPersist: NetworkConfiguration;\n        }\n      | {\n          mode: 'update';\n          networkFields: UpdateNetworkFields;\n          networkConfigurationToPersist: NetworkConfiguration;\n          existingNetworkConfiguration: NetworkConfiguration;\n        }\n      | {\n          mode: 'remove';\n          existingNetworkConfiguration: NetworkConfiguration;\n        }\n    ),\n  ): void {\n    const { state, mode } = args;\n\n    if (\n      mode === 'remove' ||\n      (mode === 'update' &&\n        args.networkFields.chainId !==\n          args.existingNetworkConfiguration.chainId)\n    ) {\n      delete state.networkConfigurationsByChainId[\n        args.existingNetworkConfiguration.chainId\n      ];\n    }\n\n    if (mode === 'add' || mode === 'update') {\n      if (\n        !deepEqual(\n          state.networkConfigurationsByChainId[args.networkFields.chainId],\n          args.networkConfigurationToPersist,\n        )\n      ) {\n        args.networkConfigurationToPersist.lastUpdatedAt = Date.now();\n      }\n      state.networkConfigurationsByChainId[args.networkFields.chainId] =\n        args.networkConfigurationToPersist;\n    }\n\n    this.#networkConfigurationsByNetworkClientId =\n      buildNetworkConfigurationsByNetworkClientId(\n        cloneDeep(state.networkConfigurationsByChainId),\n      );\n  }\n\n  /**\n   * Before accessing or switching the network, the registry of network clients\n   * needs to be populated. Otherwise, `#applyNetworkSelection` and\n   * `getNetworkClientRegistry` will throw an error. This method checks to see if the\n   * population step has happened yet, and if not, makes it happen.\n   *\n   * @returns The populated network client registry.\n   */\n  #ensureAutoManagedNetworkClientRegistryPopulated(): AutoManagedNetworkClientRegistry {\n    return (this.#autoManagedNetworkClientRegistry ??=\n      this.#createAutoManagedNetworkClientRegistry());\n  }\n\n  /**\n   * Constructs the registry of network clients based on the set of default\n   * and custom networks in state.\n   *\n   * @returns The network clients keyed by ID.\n   */\n  #createAutoManagedNetworkClientRegistry(): AutoManagedNetworkClientRegistry {\n    const chainIds = knownKeysOf(this.state.networkConfigurationsByChainId);\n    const networkClientsWithIds = chainIds.flatMap((chainId) => {\n      const networkConfiguration =\n        this.state.networkConfigurationsByChainId[chainId];\n      return networkConfiguration.rpcEndpoints.map((rpcEndpoint) => {\n        if (rpcEndpoint.type === RpcEndpointType.Infura) {\n          const infuraNetworkName = deriveInfuraNetworkNameFromRpcEndpointUrl(\n            rpcEndpoint.url,\n          );\n          return [\n            rpcEndpoint.networkClientId,\n            createAutoManagedNetworkClient({\n              networkClientId: rpcEndpoint.networkClientId,\n              networkClientConfiguration: {\n                type: NetworkClientType.Infura,\n                network: infuraNetworkName,\n                failoverRpcUrls: rpcEndpoint.failoverUrls,\n                infuraProjectId: this.#infuraProjectId,\n                chainId: networkConfiguration.chainId,\n                ticker: networkConfiguration.nativeCurrency,\n              },\n              getRpcServiceOptions: this.#getRpcServiceOptions,\n              getBlockTrackerOptions: this.#getBlockTrackerOptions,\n              messenger: this.messenger,\n              isRpcFailoverEnabled: this.#isRpcFailoverEnabled,\n              logger: this.#log,\n            }),\n          ] as const;\n        }\n        return [\n          rpcEndpoint.networkClientId,\n          createAutoManagedNetworkClient({\n            networkClientId: rpcEndpoint.networkClientId,\n            networkClientConfiguration: {\n              type: NetworkClientType.Custom,\n              chainId: networkConfiguration.chainId,\n              failoverRpcUrls: rpcEndpoint.failoverUrls,\n              rpcUrl: rpcEndpoint.url,\n              ticker: networkConfiguration.nativeCurrency,\n            },\n            getRpcServiceOptions: this.#getRpcServiceOptions,\n            getBlockTrackerOptions: this.#getBlockTrackerOptions,\n            messenger: this.messenger,\n            isRpcFailoverEnabled: this.#isRpcFailoverEnabled,\n            logger: this.#log,\n          }),\n        ] as const;\n      });\n    });\n\n    return networkClientsWithIds.reduce(\n      (\n        obj: {\n          [NetworkClientType.Custom]: Partial<AutoManagedCustomNetworkClientRegistry>;\n          [NetworkClientType.Infura]: Partial<AutoManagedBuiltInNetworkClientRegistry>;\n        },\n        [networkClientId, networkClient],\n      ) => {\n        return {\n          ...obj,\n          [networkClient.configuration.type]: {\n            ...obj[networkClient.configuration.type],\n            [networkClientId]: networkClient,\n          },\n        };\n      },\n      {\n        [NetworkClientType.Custom]: {},\n        [NetworkClientType.Infura]: {},\n      },\n    ) as AutoManagedNetworkClientRegistry;\n  }\n\n  /**\n   * Updates the global provider and block tracker proxies (accessible via\n   * {@link getSelectedNetworkClient}) to point to the same ones within the\n   * given network client, thereby magically switching any consumers using these\n   * proxies to use the new network.\n   *\n   * Also refreshes the EthQuery instance accessible via the `getEthQuery`\n   * action to wrap the provider from the new network client. Note that this is\n   * not a proxy, so consumers will need to call `getEthQuery` again after the\n   * network switch.\n   *\n   * @param networkClientId - The ID of a network client that requests will be\n   * routed through (either the name of an Infura network or the ID of a custom\n   * network configuration).\n   * @param options - Options for this method.\n   * @param options.updateState - Allows for updating state.\n   * @throws if no network client could be found matching the given ID.\n   */\n  #applyNetworkSelection(\n    networkClientId: string,\n    {\n      updateState,\n    }: {\n      updateState?: (state: Draft<NetworkState>) => void;\n    } = {},\n  ): void {\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    let autoManagedNetworkClient:\n      | AutoManagedNetworkClient<CustomNetworkClientConfiguration>\n      | AutoManagedNetworkClient<InfuraNetworkClientConfiguration>;\n\n    if (isInfuraNetworkType(networkClientId)) {\n      const possibleAutoManagedNetworkClient =\n        autoManagedNetworkClientRegistry[NetworkClientType.Infura][\n          networkClientId\n        ];\n\n      // This is impossible to reach\n      /* istanbul ignore if */\n      if (!possibleAutoManagedNetworkClient) {\n        throw new Error(\n          `No Infura network client found with ID '${networkClientId}'`,\n        );\n      }\n\n      autoManagedNetworkClient = possibleAutoManagedNetworkClient;\n    } else {\n      const possibleAutoManagedNetworkClient =\n        autoManagedNetworkClientRegistry[NetworkClientType.Custom][\n          networkClientId\n        ];\n\n      if (!possibleAutoManagedNetworkClient) {\n        throw new Error(`No network client found with ID '${networkClientId}'`);\n      }\n\n      autoManagedNetworkClient = possibleAutoManagedNetworkClient;\n    }\n\n    this.#autoManagedNetworkClient = autoManagedNetworkClient;\n\n    this.update((state) => {\n      state.selectedNetworkClientId = networkClientId;\n      state.networksMetadata[networkClientId] ??= {\n        status: NetworkStatus.Unknown,\n        EIPS: {},\n      };\n\n      updateState?.(state);\n    });\n\n    if (this.#providerProxy) {\n      this.#providerProxy.setTarget(this.#autoManagedNetworkClient.provider);\n    } else {\n      this.#providerProxy = createSwappableProxy(\n        this.#autoManagedNetworkClient.provider,\n      );\n    }\n\n    if (this.#blockTrackerProxy) {\n      this.#blockTrackerProxy.setTarget(\n        this.#autoManagedNetworkClient.blockTracker,\n      );\n    } else {\n      this.#blockTrackerProxy = createEventEmitterProxy(\n        this.#autoManagedNetworkClient.blockTracker,\n        {\n          eventFilter: 'skipInternal',\n        },\n      );\n    }\n\n    this.#ethQuery = new EthQuery(this.#providerProxy);\n  }\n}\n"]}
\ No newline at end of file
diff --git a/dist/NetworkController.d.cts b/dist/NetworkController.d.cts
index bd369098ce285a3abcc5c368d9d183fec964a13b..78bdd55d2ad6ea55226e8c5bf9b9af7b4fb4e35b 100644
--- a/dist/NetworkController.d.cts
+++ b/dist/NetworkController.d.cts
@@ -2,7 +2,6 @@ import type { ControllerGetStateAction, ControllerStateChangeEvent } from "@meta
 import { BaseController } from "@metamask/base-controller";
 import type { Partialize } from "@metamask/controller-utils";
 import { InfuraNetworkType } from "@metamask/controller-utils";
-import type { ErrorReportingServiceCaptureExceptionAction } from "@metamask/error-reporting-service";
 import type { PollingBlockTrackerOptions } from "@metamask/eth-block-tracker";
 import EthQuery from "@metamask/eth-query";
 import type { Messenger } from "@metamask/messenger";
@@ -570,7 +569,7 @@ export type NetworkControllerActions = NetworkControllerGetStateAction | Network
 /**
  * All actions that {@link NetworkController} calls internally.
  */
-type AllowedActions = ErrorReportingServiceCaptureExceptionAction;
+type AllowedActions = never;
 export type NetworkControllerMessenger = Messenger<typeof controllerName, NetworkControllerActions | AllowedActions, NetworkControllerEvents | AllowedEvents>;
 /**
  * Options for the NetworkController constructor.
diff --git a/dist/NetworkController.d.cts.map b/dist/NetworkController.d.cts.map
index 22e8f7d03df13a79d5124b6b6dc0ea0b0da66a20..e28f5a55df949d1180140cc6063e8d5fcac9a9d4 100644
--- a/dist/NetworkController.d.cts.map
+++ b/dist/NetworkController.d.cts.map
@@ -1 +1 @@
-{"version":3,"file":"NetworkController.d.cts","sourceRoot":"","sources":["../src/NetworkController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"NetworkController.d.cts","sourceRoot":"","sources":["../src/NetworkController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/NetworkController.d.mts b/dist/NetworkController.d.mts
index d3b6430aa8d131f9418eb96c5e5c5cb3a0c5d482..f0c5202edb98ad53d73ed95b44745a1ad224bc20 100644
--- a/dist/NetworkController.d.mts
+++ b/dist/NetworkController.d.mts
@@ -2,7 +2,6 @@ import type { ControllerGetStateAction, ControllerStateChangeEvent } from "@meta
 import { BaseController } from "@metamask/base-controller";
 import type { Partialize } from "@metamask/controller-utils";
 import { InfuraNetworkType } from "@metamask/controller-utils";
-import type { ErrorReportingServiceCaptureExceptionAction } from "@metamask/error-reporting-service";
 import type { PollingBlockTrackerOptions } from "@metamask/eth-block-tracker";
 import EthQuery from "@metamask/eth-query";
 import type { Messenger } from "@metamask/messenger";
@@ -570,7 +569,7 @@ export type NetworkControllerActions = NetworkControllerGetStateAction | Network
 /**
  * All actions that {@link NetworkController} calls internally.
  */
-type AllowedActions = ErrorReportingServiceCaptureExceptionAction;
+type AllowedActions = never;
 export type NetworkControllerMessenger = Messenger<typeof controllerName, NetworkControllerActions | AllowedActions, NetworkControllerEvents | AllowedEvents>;
 /**
  * Options for the NetworkController constructor.
diff --git a/dist/NetworkController.d.mts.map b/dist/NetworkController.d.mts.map
index d3c4a6ac41b6681dfdf95a1f7ce86a0ace89169d..b3dd5724dcd86d727463773def11ae4171c1bcf5 100644
--- a/dist/NetworkController.d.mts.map
+++ b/dist/NetworkController.d.mts.map
@@ -1 +1 @@
-{"version":3,"file":"NetworkController.d.mts","sourceRoot":"","sources":["../src/NetworkController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"NetworkController.d.mts","sourceRoot":"","sources":["../src/NetworkController.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EACV,wBAAwB,EACxB,0BAA0B,EAC3B,kCAAkC;AACnC,OAAO,EAAE,cAAc,EAAE,kCAAkC;AAC3D,OAAO,KAAK,EAAE,UAAU,EAAE,mCAAmC;AAC7D,OAAO,EACL,iBAAiB,EAWlB,mCAAmC;AACpC,OAAO,KAAK,EAAE,0BAA0B,EAAE,oCAAoC;AAC9E,OAAO,QAAQ,4BAA4B;AAC3C,OAAO,KAAK,EAAE,SAAS,EAAE,4BAA4B;AAMrD,OAAO,KAAK,EAAE,cAAc,EAAE,sCAAsC;AACpE,OAAO,KAAK,EAAE,GAAG,EAAE,wBAAwB;AAG3C,OAAO,KAAK,EAAE,KAAK,EAAE,cAAc;AAGnC,OAAO,KAAK,EAAE,MAAM,EAAE,iBAAiB;AAKvC,OAAO,EAGL,aAAa,EACd,wBAAoB;AACrB,OAAO,KAAK,EACV,wBAAwB,EACxB,yBAAyB,EAC1B,iDAA6C;AAG9C,OAAO,KAAK,EAAE,iBAAiB,EAAE,sCAAkC;AACnE,OAAO,EAAE,iBAAiB,EAAE,oBAAgB;AAC5C,OAAO,KAAK,EACV,YAAY,EACZ,QAAQ,EACR,gCAAgC,EAChC,gCAAgC,EAEhC,wBAAwB,EACzB,oBAAgB;AAOjB,MAAM,MAAM,KAAK,GAAG;IAClB,aAAa,CAAC,EAAE,MAAM,CAAC;CACxB,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,eAAe,GAAG;IAC5B;;OAEG;IAEH,IAAI,EAAE;QACJ,CAAC,SAAS,EAAE,MAAM,GAAG,OAAO,CAAC;KAC9B,CAAC;IACF;;OAEG;IACH,MAAM,EAAE,aAAa,CAAC;CACvB,CAAC;AAEF;;;;;GAKG;AACH,oBAAY,eAAe;IACzB,MAAM,WAAW;IACjB,MAAM,WAAW;CAClB;AAED;;;;;;;;;;;GAWG;AACH,MAAM,MAAM,iBAAiB,GAAG;IAC9B;;OAEG;IACH,YAAY,CAAC,EAAE,MAAM,EAAE,CAAC;IACxB;;OAEG;IACH,IAAI,CAAC,EAAE,MAAM,CAAC;IACd;;;;;OAKG;IACH,eAAe,EAAE,sBAAsB,CAAC;IACxC;;OAEG;IACH,IAAI,EAAE,eAAe,CAAC,MAAM,CAAC;IAC7B;;;;OAIG;IACH,GAAG,EAAE,WAAW,iBAAiB,iCAAiC,CAAC;CACpE,CAAC;AAEF;;;GAGG;AACH,MAAM,MAAM,iBAAiB,GAAG;IAC9B;;OAEG;IACH,YAAY,CAAC,EAAE,MAAM,EAAE,CAAC;IACxB;;OAEG;IACH,IAAI,CAAC,EAAE,MAAM,CAAC;IACd;;;;;OAKG;IACH,eAAe,EAAE,qBAAqB,CAAC;IACvC;;OAEG;IACH,IAAI,EAAE,eAAe,CAAC,MAAM,CAAC;IAC7B;;OAEG;IACH,GAAG,EAAE,MAAM,CAAC;CACb,CAAC;AAEF;;;;;;GAMG;AACH,MAAM,MAAM,WAAW,GAAG,iBAAiB,GAAG,iBAAiB,CAAC;AAEhE;;;;;;;;;;;;GAYG;AACH,MAAM,MAAM,oBAAoB,GAAG;IACjC;;;OAGG;IACH,iBAAiB,EAAE,MAAM,EAAE,CAAC;IAC5B;;;;OAIG;IACH,OAAO,EAAE,GAAG,CAAC;IACb;;;;OAIG;IACH,4BAA4B,CAAC,EAAE,MAAM,CAAC;IACtC;;;;OAIG;IACH,uBAAuB,EAAE,MAAM,CAAC;IAChC;;OAEG;IACH,IAAI,EAAE,MAAM,CAAC;IACb;;OAEG;IACH,cAAc,EAAE,MAAM,CAAC;IACvB;;;OAGG;IACH,YAAY,EAAE,WAAW,EAAE,CAAC;IAC5B;;;OAGG;IACH,aAAa,CAAC,EAAE,MAAM,CAAC;CACxB,CAAC;AAEF;;;;;;;GAOG;AACH,MAAM,MAAM,iCAAiC,GAAG,IAAI,CAClD,iBAAiB,EACjB,iBAAiB,CAClB,CAAC;AAEF;;;;;;GAMG;AACH,MAAM,MAAM,gBAAgB,GAAG,IAAI,CAAC,oBAAoB,EAAE,cAAc,CAAC,GAAG;IAC1E,YAAY,EAAE,CAAC,iBAAiB,GAAG,iCAAiC,CAAC,EAAE,CAAC;CACzE,CAAC;AAEF;;;;;;;GAOG;AACH,MAAM,MAAM,oCAAoC,GAAG,UAAU,CAC3D,iBAAiB,EACjB,iBAAiB,CAClB,CAAC;AAEF;;;;;;;GAOG;AACH,MAAM,MAAM,mBAAmB,GAAG,IAAI,CAAC,oBAAoB,EAAE,cAAc,CAAC,GAAG;IAC7E,YAAY,EAAE,CAAC,iBAAiB,GAAG,oCAAoC,CAAC,EAAE,CAAC;CAC5E,CAAC;AAEF;;;;;;;;;;;;GAYG;AACH,wBAAgB,WAAW,CAAC,GAAG,SAAS,WAAW,EAGjD,MAAM,EAAE,OAAO,CAAC,MAAM,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,GAChC,GAAG,EAAE,CAEP;AAeD;;GAEG;AACH,MAAM,MAAM,sBAAsB,GAAG,iBAAiB,CAAC;AAEvD;;GAEG;AACH,MAAM,MAAM,qBAAqB,GAAG,MAAM,CAAC;AAE3C;;GAEG;AACH,MAAM,MAAM,eAAe,GAAG,sBAAsB,GAAG,qBAAqB,CAAC;AAE7E;;;GAGG;AACH,MAAM,MAAM,gBAAgB,GAAG,MAAM,CAAC,eAAe,EAAE,eAAe,CAAC,CAAC;AAExE;;GAEG;AACH,MAAM,MAAM,YAAY,GAAG;IACzB;;;OAGG;IACH,uBAAuB,EAAE,eAAe,CAAC;IACzC;;;;;OAKG;IACH,8BAA8B,EAAE,MAAM,CAAC,GAAG,EAAE,oBAAoB,CAAC,CAAC;IAClE;;;OAGG;IACH,gBAAgB,EAAE,gBAAgB,CAAC;CACpC,CAAC;AAEF,QAAA,MAAM,cAAc,sBAAsB,CAAC;AAE3C;;;;;;GAMG;AACH,MAAM,MAAM,iBAAiB,GAAG,cAAc,CAC5C,yBAAyB,CAAC,YAAY,CAAC,CACxC,CAAC;AAEF;;;;;;GAMG;AACH,MAAM,MAAM,aAAa,GAAG,cAAc,CAAC,yBAAyB,CAAC,QAAQ,CAAC,CAAC,CAAC;AAEhF,MAAM,MAAM,iCAAiC,GAAG,0BAA0B,CACxE,OAAO,cAAc,EACrB,YAAY,CACb,CAAC;AAEF;;;;GAIG;AACH,MAAM,MAAM,uCAAuC,GAAG;IACpD,IAAI,EAAE,qCAAqC,CAAC;IAC5C,OAAO,EAAE,CAAC,YAAY,CAAC,CAAC;CACzB,CAAC;AAEF;;;GAGG;AACH,MAAM,MAAM,sCAAsC,GAAG;IACnD,IAAI,EAAE,oCAAoC,CAAC;IAC3C,OAAO,EAAE,CAAC,YAAY,CAAC,CAAC;CACzB,CAAC;AAEF;;;;GAIG;AACH,MAAM,MAAM,qCAAqC,GAAG;IAClD,IAAI,EAAE,mCAAmC,CAAC;IAC1C,OAAO,EAAE,EAAE,CAAC;CACb,CAAC;AAEF;;;;GAIG;AACH,MAAM,MAAM,uCAAuC,GAAG;IACpD,IAAI,EAAE,qCAAqC,CAAC;IAC5C,OAAO,EAAE,EAAE,CAAC;CACb,CAAC;AAEF;;;GAGG;AACH,MAAM,MAAM,kCAAkC,GAAG;IAC/C,IAAI,EAAE,gCAAgC,CAAC;IACvC,OAAO,EAAE,CAAC,oBAAoB,EAAE,oBAAoB,CAAC,CAAC;CACvD,CAAC;AAEF;;;GAGG;AACH,MAAM,MAAM,oCAAoC,GAAG;IACjD,IAAI,EAAE,kCAAkC,CAAC;IACzC,OAAO,EAAE,CAAC,oBAAoB,EAAE,oBAAoB,CAAC,CAAC;CACvD,CAAC;AAEF;;;;;;;;;;;;;GAaG;AACH,MAAM,MAAM,iDAAiD,GAAG;IAC9D,IAAI,EAAE,+CAA+C,CAAC;IACtD,OAAO,EAAE;QACP;YACE,OAAO,EAAE,GAAG,CAAC;YACb,KAAK,EAAE,OAAO,CAAC;YACf,eAAe,EAAE,eAAe,CAAC;SAClC;KACF,CAAC;CACH,CAAC;AAEF;;;;;;;;;;;;;;;;GAgBG;AACH,MAAM,MAAM,4CAA4C,GAAG;IACzD,IAAI,EAAE,0CAA0C,CAAC;IACjD,OAAO,EAAE;QACP;YACE,OAAO,EAAE,GAAG,CAAC;YACb,WAAW,EAAE,MAAM,CAAC;YACpB,KAAK,EAAE,OAAO,CAAC;YACf,eAAe,EAAE,eAAe,CAAC;YACjC,kBAAkB,EAAE,MAAM,CAAC;SAC5B;KACF,CAAC;CACH,CAAC;AAEF;;;;;;;;;;;;;;;;;;GAkBG;AACH,MAAM,MAAM,8CAA8C,GAAG;IAC3D,IAAI,EAAE,4CAA4C,CAAC;IACnD,OAAO,EAAE;QACP;YACE,OAAO,EAAE,GAAG,CAAC;YACb,KAAK,EAAE,OAAO,CAAC;YACf,eAAe,EAAE,eAAe,CAAC;SAClC;KACF,CAAC;CACH,CAAC;AAEF;;;;;;;;;;;;;;;;;;;;;;GAsBG;AACH,MAAM,MAAM,yCAAyC,GAAG;IACtD,IAAI,EAAE,uCAAuC,CAAC;IAC9C,OAAO,EAAE;QACP;YACE,OAAO,EAAE,GAAG,CAAC;YACb,WAAW,EAAE,MAAM,CAAC;YACpB,KAAK,EAAE,OAAO,CAAC;YACf,eAAe,EAAE,eAAe,CAAC;YACjC,kBAAkB,EAAE,MAAM,CAAC;SAC5B;KACF,CAAC;CACH,CAAC;AAEF;;;;;;;;;;;;GAYG;AACH,MAAM,MAAM,+CAA+C,GAAG;IAC5D,IAAI,EAAE,6CAA6C,CAAC;IACpD,OAAO,EAAE;QACP;YACE,OAAO,EAAE,GAAG,CAAC;YACb,eAAe,EAAE,eAAe,CAAC;SAClC;KACF,CAAC;CACH,CAAC;AAEF;;;;;;;;;;;;;;GAcG;AACH,MAAM,MAAM,wCAAwC,GAAG;IACrD,IAAI,EAAE,sCAAsC,CAAC;IAC7C,OAAO,EAAE;QACP;YACE,OAAO,EAAE,MAAM,CAAC;YAChB,OAAO,EAAE,GAAG,CAAC;YACb,WAAW,EAAE,MAAM,CAAC;YACpB,eAAe,EAAE,eAAe,CAAC;YACjC,kBAAkB,EAAE,MAAM,CAAC;SAC5B;KACF,CAAC;CACH,CAAC;AAEF,MAAM,MAAM,uBAAuB,GAC/B,iCAAiC,GACjC,uCAAuC,GACvC,sCAAsC,GACtC,qCAAqC,GACrC,uCAAuC,GACvC,kCAAkC,GAClC,oCAAoC,GACpC,iDAAiD,GACjD,4CAA4C,GAC5C,8CAA8C,GAC9C,yCAAyC,GACzC,+CAA+C,GAC/C,wCAAwC,CAAC;AAE7C;;GAEG;AACH,KAAK,aAAa,GAAG,KAAK,CAAC;AAE3B,MAAM,MAAM,+BAA+B,GAAG,wBAAwB,CACpE,OAAO,cAAc,EACrB,YAAY,CACb,CAAC;AAEF,MAAM,MAAM,kCAAkC,GAAG;IAC/C,IAAI,EAAE,+BAA+B,CAAC;IACtC,OAAO,EAAE,MAAM,QAAQ,GAAG,SAAS,CAAC;CACrC,CAAC;AAEF,MAAM,MAAM,2CAA2C,GAAG;IACxD,IAAI,EAAE,wCAAwC,CAAC;IAC/C,OAAO,EAAE,iBAAiB,CAAC,sBAAsB,CAAC,CAAC;CACpD,CAAC;AAEF,MAAM,MAAM,+CAA+C,GAAG;IAC5D,IAAI,EAAE,4CAA4C,CAAC;IACnD,OAAO,EAAE,iBAAiB,CAAC,0BAA0B,CAAC,CAAC;CACxD,CAAC;AAEF,MAAM,MAAM,yCAAyC,GAAG;IACtD,IAAI,EAAE,sCAAsC,CAAC;IAC7C,OAAO,EAAE,iBAAiB,CAAC,oBAAoB,CAAC,CAAC;CAClD,CAAC;AAEF,MAAM,MAAM,8CAA8C,GAAG;IAC3D,IAAI,EAAE,2CAA2C,CAAC;IAClD,OAAO,EAAE,iBAAiB,CAAC,yBAAyB,CAAC,CAAC;CACvD,CAAC;AAEF,MAAM,MAAM,mDAAmD,GAAG;IAChE,IAAI,EAAE,gDAAgD,CAAC;IACvD,OAAO,EAAE,iBAAiB,CAAC,8BAA8B,CAAC,CAAC;CAC5D,CAAC;AAEF;;;;;GAKG;AACH,MAAM,MAAM,sCAAsC,GAAG;IACnD,IAAI,EAAE,mCAAmC,CAAC;IAC1C,OAAO,EAAE,iBAAiB,CAAC,iBAAiB,CAAC,CAAC;CAC/C,CAAC;AAEF,MAAM,MAAM,uCAAuC,GAAG;IACpD,IAAI,EAAE,oCAAoC,CAAC;IAC3C,OAAO,EAAE,iBAAiB,CAAC,kBAAkB,CAAC,CAAC;CAChD,CAAC;AAEF,MAAM,MAAM,iDAAiD,GAAG;IAC9D,IAAI,EAAE,oDAAoD,CAAC;IAC3D,OAAO,EAAE,iBAAiB,CAAC,kCAAkC,CAAC,CAAC;CAChE,CAAC;AAEF,MAAM,MAAM,yDAAyD,GAAG;IACtE,IAAI,EAAE,4DAA4D,CAAC;IACnE,OAAO,EAAE,iBAAiB,CAAC,0CAA0C,CAAC,CAAC;CACxE,CAAC;AAEF,MAAM,MAAM,iCAAiC,GAAG;IAC9C,IAAI,EAAE,8BAA8B,CAAC;IACrC,OAAO,EAAE,iBAAiB,CAAC,YAAY,CAAC,CAAC;CAC1C,CAAC;AAEF,MAAM,MAAM,oCAAoC,GAAG;IACjD,IAAI,EAAE,iCAAiC,CAAC;IACxC,OAAO,EAAE,iBAAiB,CAAC,eAAe,CAAC,CAAC;CAC7C,CAAC;AAEF,MAAM,MAAM,oCAAoC,GAAG;IACjD,IAAI,EAAE,iCAAiC,CAAC;IACxC,OAAO,EAAE,iBAAiB,CAAC,eAAe,CAAC,CAAC;CAC7C,CAAC;AAEF,MAAM,MAAM,wBAAwB,GAChC,+BAA+B,GAC/B,kCAAkC,GAClC,2CAA2C,GAC3C,+CAA+C,GAC/C,yCAAyC,GACzC,8CAA8C,GAC9C,mDAAmD,GACnD,uCAAuC,GACvC,sCAAsC,GACtC,iDAAiD,GACjD,yDAAyD,GACzD,iCAAiC,GACjC,oCAAoC,GACpC,oCAAoC,CAAC;AAEzC;;GAEG;AACH,KAAK,cAAc,GAAG,KAAK,CAAC;AAE5B,MAAM,MAAM,0BAA0B,GAAG,SAAS,CAChD,OAAO,cAAc,EACrB,wBAAwB,GAAG,cAAc,EACzC,uBAAuB,GAAG,aAAa,CACxC,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,wBAAwB,GAAG;IACrC;;OAEG;IACH,SAAS,EAAE,0BAA0B,CAAC;IACtC;;OAEG;IACH,eAAe,EAAE,MAAM,CAAC;IACxB;;;;;OAKG;IACH,KAAK,CAAC,EAAE,OAAO,CAAC,YAAY,CAAC,CAAC;IAC9B;;OAEG;IACH,GAAG,CAAC,EAAE,MAAM,CAAC;IACb;;;;;OAKG;IACH,oBAAoB,EAAE,CACpB,cAAc,EAAE,MAAM,KACnB,IAAI,CAAC,iBAAiB,EAAE,iBAAiB,GAAG,aAAa,CAAC,CAAC;IAChE;;;;;OAKG;IACH,sBAAsB,CAAC,EAAE,CACvB,cAAc,EAAE,MAAM,KACnB,IAAI,CAAC,0BAA0B,EAAE,UAAU,CAAC,CAAC;IAClD;;OAEG;IACH,yBAAyB,CAAC,EAAE,wBAAwB,EAAE,CAAC;IACvD;;;OAGG;IACH,oBAAoB,CAAC,EAAE,OAAO,CAAC;CAChC,CAAC;AAwKF;;;;;;GAMG;AACH,wBAAgB,gCAAgC,CAC9C,yBAAyB,CAAC,EAAE,wBAAwB,EAAE,GACrD,YAAY,CAUd;AAcD;;;;;GAKG;AACH,wBAAgB,wBAAwB,CACtC,KAAK,EAAE,YAAY,GAClB,oBAAoB,EAAE,CAExB;AAED;;;;;;GAMG;AACH,eAAO,MAAM,2BAA2B;;;;;;;;;;;;2BAvB/B,YAAY,KAClB,OAAO,KAAK,MAAM,EAAE,EAAE,oBAAoB,CAAC;;;;;;;;CA0B7C,CAAC;AAEF;;;;;;GAMG;AACH,wBAAgB,4BAA4B,CAC1C,qBAAqB,EAAE,oBAAoB,EAAE,GAC5C,MAAM,EAAE,CAMV;AAED;;;;;;GAMG;AACH,eAAO,MAAM,+BAA+B;;;;;;;;;;;;;;;;;;;;;;;;+BArDnC,YAAY,KAClB,OAAO,KAAK,MAAM,EAAE,EAAE,oBAAoB,CAAC;;;;;;;;;;;;;;;;CAuD7C,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,uCAAuC,GAAG,MAAM,CAC1D,sBAAsB,EACtB,wBAAwB,CAAC,gCAAgC,CAAC,CAC3D,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,sCAAsC,GAAG,MAAM,CACzD,qBAAqB,EACrB,wBAAwB,CAAC,gCAAgC,CAAC,CAC3D,CAAC;AAEF;;;GAGG;AACH,MAAM,MAAM,gCAAgC,GAAG;IAC7C,CAAC,iBAAiB,CAAC,MAAM,CAAC,EAAE,uCAAuC,CAAC;IACpE,CAAC,iBAAiB,CAAC,MAAM,CAAC,EAAE,sCAAsC,CAAC;CACpE,CAAC;AA0PF;;GAEG;AACH,qBAAa,iBAAkB,SAAQ,cAAc,CACnD,OAAO,cAAc,EACrB,YAAY,EACZ,0BAA0B,CAC3B;;IAiCC;;;;OAIG;gBACS,OAAO,EAAE,wBAAwB;IAuJ7C;;;;OAIG;IACH,iBAAiB,IAAI,IAAI;IAIzB;;;;OAIG;IACH,kBAAkB,IAAI,IAAI;IA6C1B;;;;;OAKG;IACH,0BAA0B,IAAI;QAC5B,QAAQ,EAAE,cAAc,CAAC,yBAAyB,CAAC,QAAQ,CAAC,CAAC,GAAG,SAAS,CAAC;QAC1E,YAAY,EACR,cAAc,CAAC,yBAAyB,CAAC,YAAY,CAAC,CAAC,GACvD,SAAS,CAAC;KACf;IAOD;;;;OAIG;IACH,wBAAwB,IACpB;QACE,QAAQ,EAAE,cAAc,CAAC,yBAAyB,CAAC,QAAQ,CAAC,CAAC,CAAC;QAC9D,YAAY,EAAE,cAAc,CAAC,yBAAyB,CAAC,YAAY,CAAC,CAAC,CAAC;KACvE,GACD,SAAS;IAUb;;;;OAIG;IACH,kBAAkB,IAAI,GAAG,GAAG,SAAS;IAOrC;;;;;;;;OAQG;IACH,wBAAwB,IAAI,uCAAuC,GACjE,sCAAsC;IAWxC;;;;;;OAMG;IACH,oBAAoB,CAClB,qBAAqB,EAAE,sBAAsB,GAC5C,wBAAwB,CAAC,gCAAgC,CAAC;IAE7D;;;;;;OAMG;IACH,oBAAoB,CAClB,qBAAqB,EAAE,qBAAqB,GAC3C,wBAAwB,CAAC,gCAAgC,CAAC;IAqE7D;;;;;;;;;;;;;;;;;OAiBG;IACH,kBAAkB,CAAC,OAAO,EAAE;QAAE,aAAa,EAAE,KAAK,CAAA;KAAE,GAAG,IAAI;IAE3D;;;;;;;;;;;;;;;;;;OAkBG;IACH,kBAAkB,CAAC,OAAO,CAAC,EAAE;QAAE,aAAa,CAAC,EAAE,OAAO,CAAA;KAAE,GAAG,OAAO,CAAC,IAAI,CAAC;IAqGxE;;;;;;;;;;;OAWG;IACG,aAAa,CAAC,eAAe,CAAC,EAAE,eAAe,GAAG,OAAO,CAAC,IAAI,CAAC;IAQrE;;;;;;;;;;;;OAYG;IAIG,uBAAuB,CAC3B,eAAe,EAAE,eAAe,GAC/B,OAAO,CAAC,IAAI,CAAC;IAuJhB;;;;;;OAMG;IACG,eAAe,CAAC,IAAI,EAAE,iBAAiB,GAAG,OAAO,CAAC,IAAI,CAAC;IAa7D;;;;;;;;;OASG;IACG,gBAAgB,CACpB,eAAe,EAAE,MAAM,EACvB,OAAO,GAAE;QACP,WAAW,CAAC,EAAE,CAAC,KAAK,EAAE,KAAK,CAAC,YAAY,CAAC,KAAK,IAAI,CAAC;KAC/C,GACL,OAAO,CAAC,IAAI,CAAC;IAqChB;;;;;;;;OAQG;IACG,uBAAuB,CAC3B,eAAe,CAAC,EAAE,eAAe,GAChC,OAAO,CAAC,SAAS,GAAG,OAAO,CAAC;IA2BzB,uCAAuC,CAC3C,eAAe,EAAE,eAAe,GAC/B,OAAO,CAAC,OAAO,CAAC;IAiCnB;;;OAGG;IACG,eAAe,IAAI,OAAO,CAAC,IAAI,CAAC;IAItC;;;;;;OAMG;IACH,gCAAgC,CAC9B,OAAO,EAAE,GAAG,GACX,oBAAoB,GAAG,SAAS;IAInC;;;;;;OAMG;IACH,wCAAwC,CACtC,eAAe,EAAE,eAAe,GAC/B,oBAAoB,GAAG,SAAS;IAInC;;;;;;;;;;OAUG;IACH,UAAU,CAAC,MAAM,EAAE,gBAAgB,GAAG,oBAAoB;IAuD1D;;;;;;;;;;;;;;;;;;;;;;;OAuBG;IACG,aAAa,CACjB,OAAO,EAAE,GAAG,EACZ,MAAM,EAAE,mBAAmB,EAC3B,EACE,mCAAmC,GACpC,GAAE;QAAE,mCAAmC,CAAC,EAAE,MAAM,CAAA;KAAO,GACvD,OAAO,CAAC,oBAAoB,CAAC;IAsPhC;;;;;;;;OAQG;IACH,aAAa,CAAC,OAAO,EAAE,GAAG,GAAG,IAAI;IAoDjC;;;;;;OAMG;IACG,0BAA0B,IAAI,OAAO,CAAC,IAAI,CAAC;IAIjD;;;;OAIG;IAGG,OAAO,IAAI,OAAO,CAAC,IAAI,CAAC;IAI9B;;;;;;OAMG;IACH,UAAU,CAAC,EACT,8BAA8B,GAC/B,EAAE,IAAI,CAAC,YAAY,EAAE,gCAAgC,CAAC,GAAG,IAAI;IAS9D;;;;;;;;OAQG;IACH,4BAA4B,CAAC,OAAO,EAAE,GAAG,GAAG,eAAe;CAspB5D"}
\ No newline at end of file
diff --git a/dist/NetworkController.mjs b/dist/NetworkController.mjs
index cd8edc9585f8b0286c2e22ccdc53d9430d764c77..3b85f402ea7d472bb297eccc4b235f72abfdb753 100644
--- a/dist/NetworkController.mjs
+++ b/dist/NetworkController.mjs
@@ -17,7 +17,7 @@ function $importDefault(module) {
     return module;
 }
 import { BaseController } from "@metamask/base-controller";
-import { InfuraNetworkType, CustomNetworkType, NetworkType, isSafeChainId, isInfuraNetworkType, ChainId, NetworksTicker, NetworkNickname, BUILT_IN_CUSTOM_NETWORKS_RPC, BUILT_IN_NETWORKS } from "@metamask/controller-utils";
+import { InfuraNetworkType, CustomNetworkType, NetworkType, isSafeChainId, isInfuraNetworkType, ChainId, NetworksTicker, NetworkNickname, BUILT_IN_CUSTOM_NETWORKS_RPC, BUILT_IN_NETWORKS, BuiltInNetworkName } from "@metamask/controller-utils";
 import $EthQuery from "@metamask/eth-query";
 const EthQuery = $importDefault($EthQuery);
 import { errorCodes } from "@metamask/rpc-errors";
@@ -139,11 +139,27 @@ function getDefaultCustomNetworkConfigurationsByChainId() {
     // Create the `networkConfigurationsByChainId` objects explicitly,
     // Because it is not always guaranteed that the custom networks are included in the
     // default networks.
-    return {
+    const configs = {
         [ChainId['megaeth-testnet']]: getCustomNetworkConfiguration(CustomNetworkType['megaeth-testnet']),
         [ChainId['megaeth-testnet-v2']]: getCustomNetworkConfiguration(CustomNetworkType['megaeth-testnet-v2']),
         [ChainId['monad-testnet']]: getCustomNetworkConfiguration(CustomNetworkType['monad-testnet']),
+        // New additions for 20+ network performance testing
+        [ChainId[BuiltInNetworkName.FantomMainnet]]: getCustomNetworkConfiguration(CustomNetworkType['fantom-mainnet']),
+        [ChainId[BuiltInNetworkName.GnosisMainnet]]: getCustomNetworkConfiguration(CustomNetworkType['gnosis-mainnet']),
+        [ChainId[BuiltInNetworkName.CeloMainnet]]: getCustomNetworkConfiguration(CustomNetworkType['celo-mainnet']),
+        [ChainId[BuiltInNetworkName.CronosMainnet]]: getCustomNetworkConfiguration(CustomNetworkType['cronos-mainnet']),
+        [ChainId[BuiltInNetworkName.Aurora]]: getCustomNetworkConfiguration(CustomNetworkType.aurora),
+        [ChainId[BuiltInNetworkName.MoonbeamMainnet]]: getCustomNetworkConfiguration(CustomNetworkType['moonbeam-mainnet']),
+        [ChainId[BuiltInNetworkName.MoonriverMainnet]]: getCustomNetworkConfiguration(CustomNetworkType['moonriver-mainnet']),
+        [ChainId[BuiltInNetworkName.KlaytnMainnet]]: getCustomNetworkConfiguration(CustomNetworkType['klaytn-mainnet']),
+        [ChainId[BuiltInNetworkName.AvalancheMainnet]]: getCustomNetworkConfiguration(CustomNetworkType['avalanche-mainnet']),
+        [ChainId[BuiltInNetworkName.ZkSyncEraMainnet]]: getCustomNetworkConfiguration(CustomNetworkType['zksync-era-mainnet']),
+        [ChainId[BuiltInNetworkName.PalmMainnet]]: getCustomNetworkConfiguration(CustomNetworkType['palm-mainnet']),
+        [ChainId[BuiltInNetworkName.HyperEvmMainnet]]: getCustomNetworkConfiguration(CustomNetworkType['hypervm-mainnet']),
     };
+    console.log('[NetworkController] getDefaultCustomNetworkConfigurationsByChainId - returning', Object.keys(configs).length, 'custom network configurations');
+    console.log('[NetworkController] Custom network chain IDs:', Object.keys(configs));
+    return configs;
 }
 /**
  * Constructs a `NetworkConfiguration` object by `CustomNetworkType`.
@@ -315,14 +331,14 @@ function correctInitialState(state, messenger) {
         if (!availableNetworkClientIds.includes(state.selectedNetworkClientId)) {
             const firstNetworkConfiguration = networkConfigurationsSortedByChainId[0];
             const newSelectedNetworkClientId = firstNetworkConfiguration.rpcEndpoints[firstNetworkConfiguration.defaultRpcEndpointIndex].networkClientId;
-            messenger.call('ErrorReportingService:captureException', new Error(`\`selectedNetworkClientId\` '${state.selectedNetworkClientId}' does not refer to an RPC endpoint within a network configuration; correcting to '${newSelectedNetworkClientId}'`));
+            messenger.captureException?.(new Error(`\`selectedNetworkClientId\` '${state.selectedNetworkClientId}' does not refer to an RPC endpoint within a network configuration; correcting to '${newSelectedNetworkClientId}'`));
             newState.selectedNetworkClientId = newSelectedNetworkClientId;
         }
         if (invalidNetworkClientIdsWithMetadata.length > 0) {
             for (const invalidNetworkClientId of invalidNetworkClientIdsWithMetadata) {
                 delete newState.networksMetadata[invalidNetworkClientId];
             }
-            messenger.call('ErrorReportingService:captureException', new Error('`networksMetadata` had invalid network client IDs, which have been removed'));
+            messenger.captureException?.(new Error('`networksMetadata` had invalid network client IDs, which have been removed'));
         }
     });
 }
diff --git a/dist/NetworkController.mjs.map b/dist/NetworkController.mjs.map
index aa2276c67a41e0e015c0d5378bec79df038b4e6c..e5f1208bd06b3e45573aac0f7a925537e7f66121 100644
--- a/dist/NetworkController.mjs.map
+++ b/dist/NetworkController.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"NetworkController.mjs","sourceRoot":"","sources":["../src/NetworkController.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport type { Partialize } from '@metamask/controller-utils';\nimport {\n  InfuraNetworkType,\n  CustomNetworkType,\n  NetworkType,\n  isSafeChainId,\n  isInfuraNetworkType,\n  ChainId,\n  NetworksTicker,\n  NetworkNickname,\n  BUILT_IN_CUSTOM_NETWORKS_RPC,\n  BUILT_IN_NETWORKS,\n} from '@metamask/controller-utils';\nimport type { ErrorReportingServiceCaptureExceptionAction } from '@metamask/error-reporting-service';\nimport type { PollingBlockTrackerOptions } from '@metamask/eth-block-tracker';\nimport EthQuery from '@metamask/eth-query';\nimport type { Messenger } from '@metamask/messenger';\nimport { errorCodes } from '@metamask/rpc-errors';\nimport {\n  createEventEmitterProxy,\n  createSwappableProxy,\n} from '@metamask/swappable-obj-proxy';\nimport type { SwappableProxy } from '@metamask/swappable-obj-proxy';\nimport type { Hex } from '@metamask/utils';\nimport { hasProperty, isPlainObject, isStrictHexString } from '@metamask/utils';\nimport deepEqual from 'fast-deep-equal';\nimport type { Draft } from 'immer';\nimport { produce } from 'immer';\nimport { cloneDeep } from 'lodash';\nimport type { Logger } from 'loglevel';\nimport { createSelector } from 'reselect';\nimport * as URI from 'uri-js';\nimport { v4 as uuidV4 } from 'uuid';\n\nimport {\n  DEPRECATED_NETWORKS,\n  INFURA_BLOCKED_KEY,\n  NetworkStatus,\n} from './constants';\nimport type {\n  AutoManagedNetworkClient,\n  ProxyWithAccessibleTarget,\n} from './create-auto-managed-network-client';\nimport { createAutoManagedNetworkClient } from './create-auto-managed-network-client';\nimport { projectLogger, createModuleLogger } from './logger';\nimport type { RpcServiceOptions } from './rpc-service/rpc-service';\nimport { NetworkClientType } from './types';\nimport type {\n  BlockTracker,\n  Provider,\n  CustomNetworkClientConfiguration,\n  InfuraNetworkClientConfiguration,\n  NetworkClientConfiguration,\n  AdditionalDefaultNetwork,\n} from './types';\n\nconst debugLog = createModuleLogger(projectLogger, 'NetworkController');\n\nconst INFURA_URL_REGEX =\n  /^https:\\/\\/(?<networkName>[^.]+)\\.infura\\.io\\/v\\d+\\/(?<apiKey>.+)$/u;\n\nexport type Block = {\n  baseFeePerGas?: string;\n};\n\n/**\n * Information about a network not held by any other part of state.\n */\nexport type NetworkMetadata = {\n  /**\n   * EIPs supported by the network.\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  EIPS: {\n    [eipNumber: number]: boolean;\n  };\n  /**\n   * Indicates the availability of the network\n   */\n  status: NetworkStatus;\n};\n\n/**\n * The type of an RPC endpoint.\n *\n * @see {@link CustomRpcEndpoint}\n * @see {@link InfuraRpcEndpoint}\n */\nexport enum RpcEndpointType {\n  Custom = 'custom',\n  Infura = 'infura',\n}\n\n/**\n * An Infura RPC endpoint is a reference to a specific network that Infura\n * supports as well as an Infura account we own that we allow users to make use\n * of for free. We need to disambiguate these endpoints from custom RPC\n * endpoints, because while the types for these kinds of object both have the\n * same interface, the URL for an Infura endpoint contains the Infura project\n * ID, and we don't want this to be present in state. We therefore hide it by\n * representing it in the URL as `{infuraProjectId}`, which we replace this when\n * create network clients. But we need to know somehow that we only need to do\n * this replacement for Infura endpoints and not custom endpoints â€” hence the\n * separate type.\n */\nexport type InfuraRpcEndpoint = {\n  /**\n   * Alternate RPC endpoints to use when this endpoint is down.\n   */\n  failoverUrls?: string[];\n  /**\n   * The optional user-facing nickname of the endpoint.\n   */\n  name?: string;\n  /**\n   * The identifier for the network client that has been created for this RPC\n   * endpoint. This is also used to uniquely identify the RPC endpoint in a\n   * set of RPC endpoints as well: once assigned, it is used to determine\n   * whether the `name`, `type`, or `url` of the RPC endpoint has changed.\n   */\n  networkClientId: BuiltInNetworkClientId;\n  /**\n   * The type of this endpoint, always \"default\".\n   */\n  type: RpcEndpointType.Infura;\n  /**\n   * The URL of the endpoint. Expected to be a template with the string\n   * `{infuraProjectId}`, which will get replaced with the Infura project ID\n   * when the network client is created.\n   */\n  url: `https://${InfuraNetworkType}.infura.io/v3/{infuraProjectId}`;\n};\n\n/**\n * A custom RPC endpoint is a reference to a user-defined server which fronts an\n * EVM chain. It may refer to an Infura network, but only by coincidence.\n */\nexport type CustomRpcEndpoint = {\n  /**\n   * Alternate RPC endpoints to use when this endpoint is down.\n   */\n  failoverUrls?: string[];\n  /**\n   * The optional user-facing nickname of the endpoint.\n   */\n  name?: string;\n  /**\n   * The identifier for the network client that has been created for this RPC\n   * endpoint. This is also used to uniquely identify the RPC endpoint in a\n   * set of RPC endpoints as well: once assigned, it is used to determine\n   * whether the `name`, `type`, or `url` of the RPC endpoint has changed.\n   */\n  networkClientId: CustomNetworkClientId;\n  /**\n   * The type of this endpoint, always \"custom\".\n   */\n  type: RpcEndpointType.Custom;\n  /**\n   * The URL of the endpoint.\n   */\n  url: string;\n};\n\n/**\n * An RPC endpoint is a reference to a server which fronts an EVM chain. There\n * are two varieties of RPC endpoints: Infura and custom.\n *\n * @see {@link CustomRpcEndpoint}\n * @see {@link InfuraRpcEndpoint}\n */\nexport type RpcEndpoint = InfuraRpcEndpoint | CustomRpcEndpoint;\n\n/**\n * From a user perspective, a network configuration holds information about a\n * network that a user can select through the client. A \"network\" in this sense\n * can explicitly refer to an EVM chain that the user explicitly adds or doesn't\n * need to add (because it comes shipped with the client). The properties here\n * therefore directly map to fields that a user sees and can edit for a network\n * within the client.\n *\n * Internally, a network configuration represents a single conceptual EVM chain,\n * which is represented tangibly via multiple RPC endpoints. A \"network\" is then\n * something for which a network client object is created automatically or\n * created on demand when it is added to the client.\n */\nexport type NetworkConfiguration = {\n  /**\n   * A set of URLs that allows the user to view activity that has occurred on\n   * the chain.\n   */\n  blockExplorerUrls: string[];\n  /**\n   * The ID of the chain. Represented in hexadecimal format with a leading \"0x\"\n   * instead of decimal format so that when viewed out of context it can be\n   * unambiguously interpreted.\n   */\n  chainId: Hex;\n  /**\n   * A reference to a URL that the client will use by default to allow the user\n   * to view activity that has occurred on the chain. This index must refer to\n   * an item in `blockExplorerUrls`.\n   */\n  defaultBlockExplorerUrlIndex?: number;\n  /**\n   * A reference to an RPC endpoint that all requests will use by default in order to\n   * interact with the chain. This index must refer to an item in\n   * `rpcEndpoints`.\n   */\n  defaultRpcEndpointIndex: number;\n  /**\n   * The user-facing nickname assigned to the chain.\n   */\n  name: string;\n  /**\n   * The name of the currency to use for the chain.\n   */\n  nativeCurrency: string;\n  /**\n   * The collection of possible RPC endpoints that the client can use to\n   * interact with the chain.\n   */\n  rpcEndpoints: RpcEndpoint[];\n  /**\n   * Profile Sync - Network Sync field.\n   * Allows comparison of local network state with state to sync.\n   */\n  lastUpdatedAt?: number;\n};\n\n/**\n * A custom RPC endpoint in a new network configuration, meant to be used in\n * conjunction with `AddNetworkFields`.\n *\n * Custom RPC endpoints do not need a `networkClientId` property because it is\n * assumed that they have not already been added and therefore network clients\n * do not exist for them yet (and hence IDs need to be generated).\n */\nexport type AddNetworkCustomRpcEndpointFields = Omit<\n  CustomRpcEndpoint,\n  'networkClientId'\n>;\n\n/**\n * A new network configuration that `addNetwork` takes.\n *\n * Custom RPC endpoints do not need a `networkClientId` property because it is\n * assumed that they have not already been added and are not represented by\n * network clients yet.\n */\nexport type AddNetworkFields = Omit<NetworkConfiguration, 'rpcEndpoints'> & {\n  rpcEndpoints: (InfuraRpcEndpoint | AddNetworkCustomRpcEndpointFields)[];\n};\n\n/**\n * A custom RPC endpoint in an updated representation of a network\n * configuration, meant to be used in conjunction with `UpdateNetworkFields`.\n *\n * Custom RPC endpoints do not need a `networkClientId` property because it is\n * assumed that they have not already been added and therefore network clients\n * do not exist for them yet (and hence IDs need to be generated).\n */\nexport type UpdateNetworkCustomRpcEndpointFields = Partialize<\n  CustomRpcEndpoint,\n  'networkClientId'\n>;\n\n/**\n * An updated representation of an existing network configuration that\n * `updateNetwork` takes.\n *\n * Custom RPC endpoints may or may not have a `networkClientId` property; if\n * they do, then it is assumed that they already exist, and if not, then it is\n * assumed that they are new and are not represented by network clients yet.\n */\nexport type UpdateNetworkFields = Omit<NetworkConfiguration, 'rpcEndpoints'> & {\n  rpcEndpoints: (InfuraRpcEndpoint | UpdateNetworkCustomRpcEndpointFields)[];\n};\n\n/**\n * `Object.keys()` is intentionally generic: it returns the keys of an object,\n * but it cannot make guarantees about the contents of that object, so the type\n * of the keys is merely `string[]`. While this is technically accurate, it is\n * also unnecessary if we have an object that we own and whose contents are\n * known exactly.\n *\n * TODO: Move to @metamask/utils.\n *\n * @param object - The object.\n * @returns The keys of an object, typed according to the type of the object\n * itself.\n */\nexport function knownKeysOf<Key extends PropertyKey>(\n  // TODO: Replace `any` with type\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  object: Partial<Record<Key, any>>,\n): Key[] {\n  return Object.keys(object) as Key[];\n}\n\n/**\n * Type guard for determining whether the given value is an error object with a\n * `code` property, such as an instance of Error.\n *\n * TODO: Move this to @metamask/utils.\n *\n * @param error - The object to check.\n * @returns True if `error` has a `code`, false otherwise.\n */\nfunction isErrorWithCode(error: unknown): error is { code: string | number } {\n  return typeof error === 'object' && error !== null && 'code' in error;\n}\n\n/**\n * The string that uniquely identifies an Infura network client.\n */\nexport type BuiltInNetworkClientId = InfuraNetworkType;\n\n/**\n * The string that uniquely identifies a custom network client.\n */\nexport type CustomNetworkClientId = string;\n\n/**\n * The string that uniquely identifies a network client.\n */\nexport type NetworkClientId = BuiltInNetworkClientId | CustomNetworkClientId;\n\n/**\n * Extra information about each network, such as whether it is accessible or\n * blocked and whether it supports EIP-1559, keyed by network client ID.\n */\nexport type NetworksMetadata = Record<NetworkClientId, NetworkMetadata>;\n\n/**\n * The state that NetworkController stores.\n */\nexport type NetworkState = {\n  /**\n   * The ID of the network client that the proxies returned by\n   * `getSelectedNetworkClient` currently point to.\n   */\n  selectedNetworkClientId: NetworkClientId;\n  /**\n   * The registry of networks and corresponding RPC endpoints that the\n   * controller can use to make requests for various chains.\n   *\n   * @see {@link NetworkConfiguration}\n   */\n  networkConfigurationsByChainId: Record<Hex, NetworkConfiguration>;\n  /**\n   * Extra information about each network, such as whether it is accessible or\n   * blocked and whether it supports EIP-1559, keyed by network client ID.\n   */\n  networksMetadata: NetworksMetadata;\n};\n\nconst controllerName = 'NetworkController';\n\n/**\n * Represents the block tracker for the currently selected network. (Note that\n * this is a proxy around a proxy: the inner one exists so that the block\n * tracker doesn't have to exist until it's used, and the outer one exists so\n * that the currently selected network can change without consumers needing to\n * refresh the object reference to that network.)\n */\nexport type BlockTrackerProxy = SwappableProxy<\n  ProxyWithAccessibleTarget<BlockTracker>\n>;\n\n/**\n * Represents the provider for the currently selected network. (Note that this\n * is a proxy around a proxy: the inner one exists so that the provider doesn't\n * have to exist until it's used, and the outer one exists so that the currently\n * selected network can change without consumers needing to refresh the object\n * reference to that network.)\n */\nexport type ProviderProxy = SwappableProxy<ProxyWithAccessibleTarget<Provider>>;\n\nexport type NetworkControllerStateChangeEvent = ControllerStateChangeEvent<\n  typeof controllerName,\n  NetworkState\n>;\n\n/**\n * `networkWillChange` is published when the current network is about to be\n * switched, but the new provider has not been created and no state changes have\n * occurred yet.\n */\nexport type NetworkControllerNetworkWillChangeEvent = {\n  type: 'NetworkController:networkWillChange';\n  payload: [NetworkState];\n};\n\n/**\n * `networkDidChange` is published after a provider has been created for a newly\n * switched network (but before the network has been confirmed to be available).\n */\nexport type NetworkControllerNetworkDidChangeEvent = {\n  type: 'NetworkController:networkDidChange';\n  payload: [NetworkState];\n};\n\n/**\n * `infuraIsBlocked` is published after the network is switched to an Infura\n * network, but when Infura returns an error blocking the user based on their\n * location.\n */\nexport type NetworkControllerInfuraIsBlockedEvent = {\n  type: 'NetworkController:infuraIsBlocked';\n  payload: [];\n};\n\n/**\n * `infuraIsBlocked` is published either after the network is switched to an\n * Infura network and Infura does not return an error blocking the user based on\n * their location, or the network is switched to a non-Infura network.\n */\nexport type NetworkControllerInfuraIsUnblockedEvent = {\n  type: 'NetworkController:infuraIsUnblocked';\n  payload: [];\n};\n\n/**\n * `networkAdded` is published after a network configuration is added to the\n * network configuration registry and network clients are created for it.\n */\nexport type NetworkControllerNetworkAddedEvent = {\n  type: 'NetworkController:networkAdded';\n  payload: [networkConfiguration: NetworkConfiguration];\n};\n\n/**\n * `networkRemoved` is published after a network configuration is removed from the\n * network configuration registry and once the network clients have been removed.\n */\nexport type NetworkControllerNetworkRemovedEvent = {\n  type: 'NetworkController:networkRemoved';\n  payload: [networkConfiguration: NetworkConfiguration];\n};\n\n/**\n * `NetworkController:rpcEndpointChainUnavailable` is published when, after\n * trying all endpoints in an endpoint chain, the last failover reaches a\n * maximum number of consecutive 5xx responses, breaking the underlying circuit.\n *\n * In other words, this event will not be published if a failover is available,\n * even if the primary is not.\n *\n * @param payload - The event payload.\n * @param payload.chainId - The target network's chain ID.\n * @param payload.error - The last error produced by the last failover in the\n * endpoint chain.\n * @param payload.networkClientId - The target network's client ID.\n */\nexport type NetworkControllerRpcEndpointChainUnavailableEvent = {\n  type: 'NetworkController:rpcEndpointChainUnavailable';\n  payload: [\n    {\n      chainId: Hex;\n      error: unknown;\n      networkClientId: NetworkClientId;\n    },\n  ];\n};\n\n/**\n * `NetworkController:rpcEndpointUnavailable` is published when any\n * endpoint in an endpoint chain reaches a maximum number of consecutive 5xx\n * responses, breaking the underlying circuit.\n *\n * In other words, this event will be published if a primary is not available,\n * even if a failover is.\n *\n * @param payload - The event payload.\n * @param payload.chainId - The target network's chain ID.\n * @param payload.endpointUrl - The URL of the endpoint which reached the\n * maximum number of consecutive 5xx responses. You can compare this to\n * `primaryEndpointUrl` to know whether it was a failover or a primary.\n * @param payload.error - The last error produced by the endpoint.\n * @param payload.networkClientId - The target network's client ID.\n * @param payload.primaryEndpointUrl - The endpoint chain's primary URL.\n */\nexport type NetworkControllerRpcEndpointUnavailableEvent = {\n  type: 'NetworkController:rpcEndpointUnavailable';\n  payload: [\n    {\n      chainId: Hex;\n      endpointUrl: string;\n      error: unknown;\n      networkClientId: NetworkClientId;\n      primaryEndpointUrl: string;\n    },\n  ];\n};\n\n/**\n * `NetworkController:rpcEndpointChainDegraded` is published for any of the\n * endpoints in an endpoint chain when one of the following two conditions hold\n * (and the chain is not already in a degraded state):\n *\n * 1. A successful (2xx) request, even after being retried, cannot be made to\n * the endpoint.\n * 2. A successful (2xx) request can be made to the endpoint, but it takes\n * longer than expected to complete.\n *\n * Note that this event will be published even if there are local connectivity\n * issues which prevent requests from being initiated. This is intentional.\n *\n * @param payload - The event payload.\n * @param payload.chainId - The target network's chain ID.\n * @param payload.error - The last error produced by the endpoint (or\n * `undefined` if the request was slow).\n * @param payload.networkClientId - The target network's client ID.\n */\nexport type NetworkControllerRpcEndpointChainDegradedEvent = {\n  type: 'NetworkController:rpcEndpointChainDegraded';\n  payload: [\n    {\n      chainId: Hex;\n      error: unknown;\n      networkClientId: NetworkClientId;\n    },\n  ];\n};\n\n/**\n *\n * `NetworkController:rpcEndpointDegraded` is published for any of the endpoints\n * in an endpoint chain when:\n *\n * 1. A successful (2xx) request, even after being retried, cannot be made to\n * the endpoint.\n * 2. A successful (2xx) request can be made to the endpoint, but it takes\n * longer than expected to complete.\n *\n * Note that this event will be published even if there are local connectivity\n * issues which prevent requests from being initiated. This is intentional.\n *\n * @param payload - The event payload.\n * @param payload.chainId - The target network's chain ID.\n * @param payload.endpointUrl - The URL of the endpoint for which requests\n * failed or were slow to complete. You can compare this to `primaryEndpointUrl`\n * to know whether it was a failover or a primary.\n * @param payload.error - The last error produced by the endpoint (or\n * `undefined` if the request was slow).\n * @param payload.networkClientId - The target network's client ID.\n * @param payload.primaryEndpointUrl - The endpoint chain's primary URL.\n */\nexport type NetworkControllerRpcEndpointDegradedEvent = {\n  type: 'NetworkController:rpcEndpointDegraded';\n  payload: [\n    {\n      chainId: Hex;\n      endpointUrl: string;\n      error: unknown;\n      networkClientId: NetworkClientId;\n      primaryEndpointUrl: string;\n    },\n  ];\n};\n\n/**\n * `NetworkController:rpcEndpointChainAvailable` is published in one of two\n * cases:\n *\n * 1. The first time that a 2xx request is made to any of the endpoints in an\n * endpoint chain.\n * 2. When requests to any of the endpoints previously failed (placing the\n * endpoint in a degraded or unavailable status), but are now succeeding again.\n *\n * @param payload - The event payload.\n * @param payload.chainId - The target network's chain ID.\n * @param payload.networkClientId - The target network's client ID.\n */\nexport type NetworkControllerRpcEndpointChainAvailableEvent = {\n  type: 'NetworkController:rpcEndpointChainAvailable';\n  payload: [\n    {\n      chainId: Hex;\n      networkClientId: NetworkClientId;\n    },\n  ];\n};\n\n/**\n * `NetworkController:rpcEndpointRetried` is published before a request to any\n * endpoint in an endpoint chain is retried.\n *\n * This is mainly useful for tests.\n *\n * @param payload - The event payload.\n * @param payload.attempt - The current attempt counter for the endpoint\n * (starting from 0).\n * @param payload.chainId - The target network's chain ID.\n * @param payload.endpointUrl - The URL of the endpoint being retried.\n * @param payload.networkClientId - The target network's client ID.\n * @param payload.primaryEndpointUrl - The endpoint chain's primary URL.\n * @see {@link RpcService} for the list of retriable errors.\n */\nexport type NetworkControllerRpcEndpointRetriedEvent = {\n  type: 'NetworkController:rpcEndpointRetried';\n  payload: [\n    {\n      attempt: number;\n      chainId: Hex;\n      endpointUrl: string;\n      networkClientId: NetworkClientId;\n      primaryEndpointUrl: string;\n    },\n  ];\n};\n\nexport type NetworkControllerEvents =\n  | NetworkControllerStateChangeEvent\n  | NetworkControllerNetworkWillChangeEvent\n  | NetworkControllerNetworkDidChangeEvent\n  | NetworkControllerInfuraIsBlockedEvent\n  | NetworkControllerInfuraIsUnblockedEvent\n  | NetworkControllerNetworkAddedEvent\n  | NetworkControllerNetworkRemovedEvent\n  | NetworkControllerRpcEndpointChainUnavailableEvent\n  | NetworkControllerRpcEndpointUnavailableEvent\n  | NetworkControllerRpcEndpointChainDegradedEvent\n  | NetworkControllerRpcEndpointDegradedEvent\n  | NetworkControllerRpcEndpointChainAvailableEvent\n  | NetworkControllerRpcEndpointRetriedEvent;\n\n/**\n * All events that {@link NetworkController} calls internally.\n */\ntype AllowedEvents = never;\n\nexport type NetworkControllerGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  NetworkState\n>;\n\nexport type NetworkControllerGetEthQueryAction = {\n  type: `NetworkController:getEthQuery`;\n  handler: () => EthQuery | undefined;\n};\n\nexport type NetworkControllerGetNetworkClientByIdAction = {\n  type: `NetworkController:getNetworkClientById`;\n  handler: NetworkController['getNetworkClientById'];\n};\n\nexport type NetworkControllerGetSelectedNetworkClientAction = {\n  type: `NetworkController:getSelectedNetworkClient`;\n  handler: NetworkController['getSelectedNetworkClient'];\n};\n\nexport type NetworkControllerGetSelectedChainIdAction = {\n  type: 'NetworkController:getSelectedChainId';\n  handler: NetworkController['getSelectedChainId'];\n};\n\nexport type NetworkControllerGetEIP1559CompatibilityAction = {\n  type: `NetworkController:getEIP1559Compatibility`;\n  handler: NetworkController['getEIP1559Compatibility'];\n};\n\nexport type NetworkControllerFindNetworkClientIdByChainIdAction = {\n  type: `NetworkController:findNetworkClientIdByChainId`;\n  handler: NetworkController['findNetworkClientIdByChainId'];\n};\n\n/**\n * Change the currently selected network to the given built-in network type.\n *\n * @deprecated This action has been replaced by `setActiveNetwork`, and will be\n * removed in a future release.\n */\nexport type NetworkControllerSetProviderTypeAction = {\n  type: `NetworkController:setProviderType`;\n  handler: NetworkController['setProviderType'];\n};\n\nexport type NetworkControllerSetActiveNetworkAction = {\n  type: `NetworkController:setActiveNetwork`;\n  handler: NetworkController['setActiveNetwork'];\n};\n\nexport type NetworkControllerGetNetworkConfigurationByChainId = {\n  type: `NetworkController:getNetworkConfigurationByChainId`;\n  handler: NetworkController['getNetworkConfigurationByChainId'];\n};\n\nexport type NetworkControllerGetNetworkConfigurationByNetworkClientId = {\n  type: `NetworkController:getNetworkConfigurationByNetworkClientId`;\n  handler: NetworkController['getNetworkConfigurationByNetworkClientId'];\n};\n\nexport type NetworkControllerAddNetworkAction = {\n  type: 'NetworkController:addNetwork';\n  handler: NetworkController['addNetwork'];\n};\n\nexport type NetworkControllerRemoveNetworkAction = {\n  type: 'NetworkController:removeNetwork';\n  handler: NetworkController['removeNetwork'];\n};\n\nexport type NetworkControllerUpdateNetworkAction = {\n  type: 'NetworkController:updateNetwork';\n  handler: NetworkController['updateNetwork'];\n};\n\nexport type NetworkControllerActions =\n  | NetworkControllerGetStateAction\n  | NetworkControllerGetEthQueryAction\n  | NetworkControllerGetNetworkClientByIdAction\n  | NetworkControllerGetSelectedNetworkClientAction\n  | NetworkControllerGetSelectedChainIdAction\n  | NetworkControllerGetEIP1559CompatibilityAction\n  | NetworkControllerFindNetworkClientIdByChainIdAction\n  | NetworkControllerSetActiveNetworkAction\n  | NetworkControllerSetProviderTypeAction\n  | NetworkControllerGetNetworkConfigurationByChainId\n  | NetworkControllerGetNetworkConfigurationByNetworkClientId\n  | NetworkControllerAddNetworkAction\n  | NetworkControllerRemoveNetworkAction\n  | NetworkControllerUpdateNetworkAction;\n\n/**\n * All actions that {@link NetworkController} calls internally.\n */\ntype AllowedActions = ErrorReportingServiceCaptureExceptionAction;\n\nexport type NetworkControllerMessenger = Messenger<\n  typeof controllerName,\n  NetworkControllerActions | AllowedActions,\n  NetworkControllerEvents | AllowedEvents\n>;\n\n/**\n * Options for the NetworkController constructor.\n */\nexport type NetworkControllerOptions = {\n  /**\n   * The messenger suited for this controller.\n   */\n  messenger: NetworkControllerMessenger;\n  /**\n   * The API key for Infura, used to make requests to Infura.\n   */\n  infuraProjectId: string;\n  /**\n   * The desired state with which to initialize this controller.\n   * Missing properties will be filled in with defaults. For instance, if not\n   * specified, `networkConfigurationsByChainId` will default to a basic set of\n   * network configurations (see {@link InfuraNetworkType} for the list).\n   */\n  state?: Partial<NetworkState>;\n  /**\n   * A `loglevel` logger object.\n   */\n  log?: Logger;\n  /**\n   * A function that can be used to customize a RPC service constructed for an\n   * RPC endpoint. The function takes the URL of the endpoint and should return\n   * an object with type {@link RpcServiceOptions}, minus `failoverService`\n   * and `endpointUrl` (as they are filled in automatically).\n   */\n  getRpcServiceOptions: (\n    rpcEndpointUrl: string,\n  ) => Omit<RpcServiceOptions, 'failoverService' | 'endpointUrl'>;\n  /**\n   * A function that can be used to customize a block tracker constructed for an\n   * RPC endpoint. The function takes the URL of the endpoint and should return\n   * an object of type {@link PollingBlockTrackerOptions}, minus `provider` (as\n   * it is filled in automatically).\n   */\n  getBlockTrackerOptions?: (\n    rpcEndpointUrl: string,\n  ) => Omit<PollingBlockTrackerOptions, 'provider'>;\n  /**\n   * An array of Hex Chain IDs representing the additional networks to be included as default.\n   */\n  additionalDefaultNetworks?: AdditionalDefaultNetwork[];\n  /**\n   * Whether or not requests sent to unavailable RPC endpoints should be\n   * automatically diverted to configured failover RPC endpoints.\n   */\n  isRpcFailoverEnabled?: boolean;\n};\n\n/**\n * Constructs a value for the state property `networkConfigurationsByChainId`\n * which will be used if it has not been provided to the constructor.\n *\n * @param [additionalDefaultNetworks] - An array of Hex Chain IDs representing the additional networks to be included as default.\n * @returns The default value for `networkConfigurationsByChainId`.\n */\nfunction getDefaultNetworkConfigurationsByChainId(\n  additionalDefaultNetworks: AdditionalDefaultNetwork[] = [],\n): Record<Hex, NetworkConfiguration> {\n  const infuraNetworks = getDefaultInfuraNetworkConfigurationsByChainId();\n  const customNetworks = getDefaultCustomNetworkConfigurationsByChainId();\n\n  return additionalDefaultNetworks.reduce<Record<Hex, NetworkConfiguration>>(\n    (obj, chainId) => {\n      if (hasProperty(customNetworks, chainId)) {\n        obj[chainId] = customNetworks[chainId];\n      }\n      return obj;\n    },\n    // Always include the infura networks in the default networks\n    infuraNetworks,\n  );\n}\n\n/**\n * Constructs a `networkConfigurationsByChainId` object for all default Infura networks.\n *\n * @returns The `networkConfigurationsByChainId` object of all Infura networks.\n */\nfunction getDefaultInfuraNetworkConfigurationsByChainId(): Record<\n  Hex,\n  NetworkConfiguration\n> {\n  return Object.values(InfuraNetworkType).reduce<\n    Record<Hex, NetworkConfiguration>\n  >((obj, infuraNetworkType) => {\n    const chainId = ChainId[infuraNetworkType];\n\n    // Skip deprecated network as default network.\n    if (DEPRECATED_NETWORKS.has(chainId)) {\n      return obj;\n    }\n\n    const rpcEndpointUrl =\n      `https://${infuraNetworkType}.infura.io/v3/{infuraProjectId}` as const;\n\n    const networkConfiguration: NetworkConfiguration = {\n      blockExplorerUrls: [],\n      chainId,\n      defaultRpcEndpointIndex: 0,\n      name: NetworkNickname[infuraNetworkType],\n      nativeCurrency: NetworksTicker[infuraNetworkType],\n      rpcEndpoints: [\n        {\n          failoverUrls: [],\n          networkClientId: infuraNetworkType,\n          type: RpcEndpointType.Infura,\n          url: rpcEndpointUrl,\n        },\n      ],\n    };\n\n    return { ...obj, [chainId]: networkConfiguration };\n  }, {});\n}\n\n/**\n * Constructs a `networkConfigurationsByChainId` object for all default custom networks.\n *\n * @returns The `networkConfigurationsByChainId` object of all custom networks.\n */\nfunction getDefaultCustomNetworkConfigurationsByChainId(): Record<\n  Hex,\n  NetworkConfiguration\n> {\n  // Create the `networkConfigurationsByChainId` objects explicitly,\n  // Because it is not always guaranteed that the custom networks are included in the\n  // default networks.\n  return {\n    [ChainId['megaeth-testnet']]: getCustomNetworkConfiguration(\n      CustomNetworkType['megaeth-testnet'],\n    ),\n    [ChainId['megaeth-testnet-v2']]: getCustomNetworkConfiguration(\n      CustomNetworkType['megaeth-testnet-v2'],\n    ),\n    [ChainId['monad-testnet']]: getCustomNetworkConfiguration(\n      CustomNetworkType['monad-testnet'],\n    ),\n  };\n}\n\n/**\n * Constructs a `NetworkConfiguration` object by `CustomNetworkType`.\n *\n * @param customNetworkType - The type of the custom network.\n * @returns The `NetworkConfiguration` object.\n */\nfunction getCustomNetworkConfiguration(\n  customNetworkType: CustomNetworkType,\n): NetworkConfiguration {\n  const { ticker, rpcPrefs } = BUILT_IN_NETWORKS[customNetworkType];\n  const rpcEndpointUrl = BUILT_IN_CUSTOM_NETWORKS_RPC[customNetworkType];\n\n  return {\n    blockExplorerUrls: [rpcPrefs.blockExplorerUrl],\n    chainId: ChainId[customNetworkType],\n    defaultRpcEndpointIndex: 0,\n    defaultBlockExplorerUrlIndex: 0,\n    name: NetworkNickname[customNetworkType],\n    nativeCurrency: ticker,\n    rpcEndpoints: [\n      {\n        failoverUrls: [],\n        networkClientId: customNetworkType,\n        type: RpcEndpointType.Custom,\n        url: rpcEndpointUrl,\n      },\n    ],\n  };\n}\n\n/**\n * Constructs properties for the NetworkController state whose values will be\n * used if not provided to the constructor.\n *\n * @param [additionalDefaultNetworks] - An array of Hex Chain IDs representing the additional networks to be included as default.\n * @returns The default NetworkController state.\n */\nexport function getDefaultNetworkControllerState(\n  additionalDefaultNetworks?: AdditionalDefaultNetwork[],\n): NetworkState {\n  const networksMetadata = {};\n  const networkConfigurationsByChainId =\n    getDefaultNetworkConfigurationsByChainId(additionalDefaultNetworks);\n\n  return {\n    selectedNetworkClientId: InfuraNetworkType.mainnet,\n    networksMetadata,\n    networkConfigurationsByChainId,\n  };\n}\n\n/**\n * Redux selector for getting all network configurations from NetworkController\n * state, keyed by chain ID.\n *\n * @param state - NetworkController state\n * @returns All registered network configurations, keyed by chain ID.\n */\nconst selectNetworkConfigurationsByChainId = (\n  state: NetworkState,\n): Record<`0x${string}`, NetworkConfiguration> =>\n  state.networkConfigurationsByChainId;\n\n/**\n * Get a list of all network configurations.\n *\n * @param state - NetworkController state\n * @returns A list of all available network configurations\n */\nexport function getNetworkConfigurations(\n  state: NetworkState,\n): NetworkConfiguration[] {\n  return Object.values(state.networkConfigurationsByChainId);\n}\n\n/**\n * Redux selector for getting a list of all network configurations from\n * NetworkController state.\n *\n * @param state - NetworkController state\n * @returns A list of all available network configurations\n */\nexport const selectNetworkConfigurations = createSelector(\n  selectNetworkConfigurationsByChainId,\n  (networkConfigurationsByChainId) =>\n    Object.values(networkConfigurationsByChainId),\n);\n\n/**\n * Get a list of all available network client IDs from a list of network\n * configurations.\n *\n * @param networkConfigurations - The array of network configurations\n * @returns A list of all available client IDs\n */\nexport function getAvailableNetworkClientIds(\n  networkConfigurations: NetworkConfiguration[],\n): string[] {\n  return networkConfigurations.flatMap((networkConfiguration) =>\n    networkConfiguration.rpcEndpoints.map(\n      (rpcEndpoint) => rpcEndpoint.networkClientId,\n    ),\n  );\n}\n\n/**\n * Redux selector for getting a list of all available network client IDs\n * from NetworkController state.\n *\n * @param state - NetworkController state\n * @returns A list of all available network client IDs.\n */\nexport const selectAvailableNetworkClientIds = createSelector(\n  selectNetworkConfigurations,\n  getAvailableNetworkClientIds,\n);\n\n/**\n * The collection of auto-managed network clients that map to Infura networks.\n */\nexport type AutoManagedBuiltInNetworkClientRegistry = Record<\n  BuiltInNetworkClientId,\n  AutoManagedNetworkClient<InfuraNetworkClientConfiguration>\n>;\n\n/**\n * The collection of auto-managed network clients that map to Infura networks.\n */\nexport type AutoManagedCustomNetworkClientRegistry = Record<\n  CustomNetworkClientId,\n  AutoManagedNetworkClient<CustomNetworkClientConfiguration>\n>;\n\n/**\n * The collection of auto-managed network clients that map to Infura networks\n * as well as custom networks that users have added.\n */\nexport type AutoManagedNetworkClientRegistry = {\n  [NetworkClientType.Infura]: AutoManagedBuiltInNetworkClientRegistry;\n  [NetworkClientType.Custom]: AutoManagedCustomNetworkClientRegistry;\n};\n\n/**\n * Instructs `addNetwork` and `updateNetwork` to create a network client for an\n * RPC endpoint.\n *\n * @see {@link NetworkClientOperation}\n */\ntype AddNetworkClientOperation = {\n  type: 'add';\n  rpcEndpoint: RpcEndpoint;\n};\n\n/**\n * Instructs `updateNetwork` and `removeNetwork` to remove a network client for\n * an RPC endpoint.\n *\n * @see {@link NetworkClientOperation}\n */\ntype RemoveNetworkClientOperation = {\n  type: 'remove';\n  rpcEndpoint: RpcEndpoint;\n};\n\n/**\n * Instructs `addNetwork` and `updateNetwork` to replace the network client for\n * an RPC endpoint.\n *\n * @see {@link NetworkClientOperation}\n */\ntype ReplaceNetworkClientOperation = {\n  type: 'replace';\n  oldRpcEndpoint: RpcEndpoint;\n  newRpcEndpoint: RpcEndpoint;\n};\n\n/**\n * Instructs `addNetwork` and `updateNetwork` not to do anything with an RPC\n * endpoint, as far as the network client registry is concerned.\n *\n * @see {@link NetworkClientOperation}\n */\ntype NoopNetworkClientOperation = {\n  type: 'noop';\n  rpcEndpoint: RpcEndpoint;\n};\n\n/**\n * Instructs `addNetwork`, `updateNetwork`, and `removeNetwork` how to\n * update the network client registry.\n *\n * - When `addNetwork` is called, represents a network client that should be\n * created for a new RPC endpoint.\n * - When `removeNetwork` is called, represents a network client that should be\n * destroyed for a previously existing RPC endpoint.\n * - When `updateNetwork` is called, represents either:\n *   - a network client that should be added for a new RPC endpoint\n *   - a network client that should be removed for a previously existing RPC\n *   endpoint\n *   - a network client that should be replaced for an RPC endpoint that was\n *   changed in a non-major way, or\n *   - a network client that should be unchanged for an RPC endpoint that was\n *   also unchanged.\n */\ntype NetworkClientOperation =\n  | AddNetworkClientOperation\n  | RemoveNetworkClientOperation\n  | ReplaceNetworkClientOperation\n  | NoopNetworkClientOperation;\n\n/**\n * Determines whether the given URL is valid by attempting to parse it.\n *\n * @param url - The URL to test.\n * @returns True if the URL is valid, false otherwise.\n */\nfunction isValidUrl(url: string): boolean {\n  const uri = URI.parse(url);\n  return (\n    uri.error === undefined && (uri.scheme === 'http' || uri.scheme === 'https')\n  );\n}\n\n/**\n * Given an Infura API URL, extracts the subdomain that identifies the Infura\n * network.\n *\n * @param rpcEndpointUrl - The URL to operate on.\n * @returns The Infura network name that the URL references.\n * @throws if the URL is not an Infura API URL, or if an Infura network is not\n * present in the URL.\n */\nfunction deriveInfuraNetworkNameFromRpcEndpointUrl(\n  rpcEndpointUrl: string,\n): InfuraNetworkType {\n  const match = INFURA_URL_REGEX.exec(rpcEndpointUrl);\n\n  if (match?.groups) {\n    if (isInfuraNetworkType(match.groups.networkName)) {\n      return match.groups.networkName;\n    }\n\n    throw new Error(`Unknown Infura network '${match.groups.networkName}'`);\n  }\n\n  throw new Error('Could not derive Infura network from RPC endpoint URL');\n}\n\n/**\n * Performs a series of checks that the given NetworkController state is\n * internally consistent â€” that all parts of state that are supposed to match in\n * fact do â€” so that working with the state later on doesn't cause unexpected\n * errors.\n *\n * In the case of NetworkController, there are several parts of state that need\n * to match. For instance, `defaultRpcEndpointIndex` needs to match an entry\n * within `rpcEndpoints`, and `selectedNetworkClientId` needs to point to an RPC\n * endpoint within a network configuration.\n *\n * @param state - The NetworkController state to verify.\n * @throws if the state is invalid in some way.\n */\nfunction validateInitialState(state: NetworkState): void {\n  const networkConfigurationEntries = Object.entries(\n    state.networkConfigurationsByChainId,\n  );\n  const networkClientIds = getAvailableNetworkClientIds(\n    getNetworkConfigurations(state),\n  );\n\n  if (networkConfigurationEntries.length === 0) {\n    throw new Error(\n      'NetworkController state is invalid: `networkConfigurationsByChainId` cannot be empty',\n    );\n  }\n\n  for (const [chainId, networkConfiguration] of networkConfigurationEntries) {\n    if (chainId !== networkConfiguration.chainId) {\n      throw new Error(\n        `NetworkController state has invalid \\`networkConfigurationsByChainId\\`: Network configuration '${networkConfiguration.name}' is filed under '${chainId}' which does not match its \\`chainId\\` of '${networkConfiguration.chainId}'`,\n      );\n    }\n\n    const isInvalidDefaultBlockExplorerUrlIndex =\n      networkConfiguration.blockExplorerUrls.length > 0\n        ? networkConfiguration.defaultBlockExplorerUrlIndex === undefined ||\n          networkConfiguration.blockExplorerUrls[\n            networkConfiguration.defaultBlockExplorerUrlIndex\n          ] === undefined\n        : networkConfiguration.defaultBlockExplorerUrlIndex !== undefined;\n\n    if (isInvalidDefaultBlockExplorerUrlIndex) {\n      throw new Error(\n        `NetworkController state has invalid \\`networkConfigurationsByChainId\\`: Network configuration '${networkConfiguration.name}' has a \\`defaultBlockExplorerUrlIndex\\` that does not refer to an entry in \\`blockExplorerUrls\\``,\n      );\n    }\n\n    if (\n      networkConfiguration.rpcEndpoints[\n        networkConfiguration.defaultRpcEndpointIndex\n      ] === undefined\n    ) {\n      throw new Error(\n        `NetworkController state has invalid \\`networkConfigurationsByChainId\\`: Network configuration '${networkConfiguration.name}' has a \\`defaultRpcEndpointIndex\\` that does not refer to an entry in \\`rpcEndpoints\\``,\n      );\n    }\n  }\n\n  if ([...new Set(networkClientIds)].length < networkClientIds.length) {\n    throw new Error(\n      'NetworkController state has invalid `networkConfigurationsByChainId`: Every RPC endpoint across all network configurations must have a unique `networkClientId`',\n    );\n  }\n}\n\n/**\n * Checks that the given initial NetworkController state is internally\n * consistent similar to `validateInitialState`, but if an anomaly is detected,\n * it does its best to correct the state and logs an error to Sentry.\n *\n * @param state - The NetworkController state to verify.\n * @param messenger - The NetworkController messenger.\n * @returns The corrected state.\n */\nfunction correctInitialState(\n  state: NetworkState,\n  messenger: NetworkControllerMessenger,\n): NetworkState {\n  const networkConfigurationsSortedByChainId = getNetworkConfigurations(\n    state,\n  ).sort((a, b) => a.chainId.localeCompare(b.chainId));\n  const availableNetworkClientIds = getAvailableNetworkClientIds(\n    networkConfigurationsSortedByChainId,\n  );\n  const invalidNetworkClientIdsWithMetadata = Object.keys(\n    state.networksMetadata,\n  ).filter(\n    (networkClientId) => !availableNetworkClientIds.includes(networkClientId),\n  );\n\n  return produce(state, (newState) => {\n    if (!availableNetworkClientIds.includes(state.selectedNetworkClientId)) {\n      const firstNetworkConfiguration = networkConfigurationsSortedByChainId[0];\n      const newSelectedNetworkClientId =\n        firstNetworkConfiguration.rpcEndpoints[\n          firstNetworkConfiguration.defaultRpcEndpointIndex\n        ].networkClientId;\n      messenger.call(\n        'ErrorReportingService:captureException',\n        new Error(\n          `\\`selectedNetworkClientId\\` '${state.selectedNetworkClientId}' does not refer to an RPC endpoint within a network configuration; correcting to '${newSelectedNetworkClientId}'`,\n        ),\n      );\n      newState.selectedNetworkClientId = newSelectedNetworkClientId;\n    }\n\n    if (invalidNetworkClientIdsWithMetadata.length > 0) {\n      for (const invalidNetworkClientId of invalidNetworkClientIdsWithMetadata) {\n        delete newState.networksMetadata[invalidNetworkClientId];\n      }\n      messenger.call(\n        'ErrorReportingService:captureException',\n        new Error(\n          '`networksMetadata` had invalid network client IDs, which have been removed',\n        ),\n      );\n    }\n  });\n}\n\n/**\n * Transforms a map of chain ID to network configuration to a map of network\n * client ID to network configuration.\n *\n * @param networkConfigurationsByChainId - The network configurations, keyed by\n * chain ID.\n * @returns The network configurations, keyed by network client ID.\n */\nfunction buildNetworkConfigurationsByNetworkClientId(\n  networkConfigurationsByChainId: Record<Hex, NetworkConfiguration>,\n): Map<NetworkClientId, NetworkConfiguration> {\n  return new Map(\n    Object.values(networkConfigurationsByChainId).flatMap(\n      (networkConfiguration) => {\n        return networkConfiguration.rpcEndpoints.map((rpcEndpoint) => {\n          return [rpcEndpoint.networkClientId, networkConfiguration];\n        });\n      },\n    ),\n  );\n}\n\n/**\n * Controller that creates and manages an Ethereum network provider.\n */\nexport class NetworkController extends BaseController<\n  typeof controllerName,\n  NetworkState,\n  NetworkControllerMessenger\n> {\n  #ethQuery?: EthQuery;\n\n  readonly #infuraProjectId: string;\n\n  #previouslySelectedNetworkClientId: string;\n\n  #providerProxy: ProviderProxy | undefined;\n\n  #blockTrackerProxy: BlockTrackerProxy | undefined;\n\n  #autoManagedNetworkClientRegistry?: AutoManagedNetworkClientRegistry;\n\n  #autoManagedNetworkClient?:\n    | AutoManagedNetworkClient<CustomNetworkClientConfiguration>\n    | AutoManagedNetworkClient<InfuraNetworkClientConfiguration>;\n\n  readonly #log: Logger | undefined;\n\n  readonly #getRpcServiceOptions: NetworkControllerOptions['getRpcServiceOptions'];\n\n  readonly #getBlockTrackerOptions: NetworkControllerOptions['getBlockTrackerOptions'];\n\n  #networkConfigurationsByNetworkClientId: Map<\n    NetworkClientId,\n    NetworkConfiguration\n  >;\n\n  #isRpcFailoverEnabled: Exclude<\n    NetworkControllerOptions['isRpcFailoverEnabled'],\n    undefined\n  >;\n\n  /**\n   * Constructs a NetworkController.\n   *\n   * @param options - The options; see {@link NetworkControllerOptions}.\n   */\n  constructor(options: NetworkControllerOptions) {\n    const {\n      messenger,\n      state,\n      infuraProjectId,\n      log,\n      getRpcServiceOptions,\n      getBlockTrackerOptions,\n      additionalDefaultNetworks,\n      isRpcFailoverEnabled = false,\n    } = options;\n    const initialState = {\n      ...getDefaultNetworkControllerState(additionalDefaultNetworks),\n      ...state,\n    };\n    validateInitialState(initialState);\n    const correctedInitialState = correctInitialState(initialState, messenger);\n\n    if (!infuraProjectId || typeof infuraProjectId !== 'string') {\n      throw new Error('Invalid Infura project ID');\n    }\n\n    super({\n      name: controllerName,\n      metadata: {\n        selectedNetworkClientId: {\n          includeInStateLogs: true,\n          persist: true,\n          includeInDebugSnapshot: false,\n          usedInUi: true,\n        },\n        networksMetadata: {\n          includeInStateLogs: true,\n          persist: true,\n          includeInDebugSnapshot: false,\n          usedInUi: true,\n        },\n        networkConfigurationsByChainId: {\n          includeInStateLogs: true,\n          persist: true,\n          includeInDebugSnapshot: false,\n          usedInUi: true,\n        },\n      },\n      messenger,\n      state: correctedInitialState,\n    });\n\n    this.#infuraProjectId = infuraProjectId;\n    this.#log = log;\n    this.#getRpcServiceOptions = getRpcServiceOptions;\n    this.#getBlockTrackerOptions = getBlockTrackerOptions;\n    this.#isRpcFailoverEnabled = isRpcFailoverEnabled;\n\n    this.#previouslySelectedNetworkClientId =\n      this.state.selectedNetworkClientId;\n    this.#networkConfigurationsByNetworkClientId =\n      buildNetworkConfigurationsByNetworkClientId(\n        this.state.networkConfigurationsByChainId,\n      );\n\n    this.messenger.registerActionHandler(`${this.name}:getEthQuery`, () => {\n      return this.#ethQuery;\n    });\n\n    this.messenger.registerActionHandler(\n      `${this.name}:getNetworkClientById`,\n      this.getNetworkClientById.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${this.name}:getEIP1559Compatibility`,\n      this.getEIP1559Compatibility.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${this.name}:setActiveNetwork`,\n      this.setActiveNetwork.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${this.name}:setProviderType`,\n      this.setProviderType.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${this.name}:findNetworkClientIdByChainId`,\n      this.findNetworkClientIdByChainId.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${this.name}:getNetworkConfigurationByChainId`,\n      this.getNetworkConfigurationByChainId.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${this.name}:getNetworkConfigurationByNetworkClientId`,\n      this.getNetworkConfigurationByNetworkClientId.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${this.name}:getSelectedNetworkClient`,\n      this.getSelectedNetworkClient.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${this.name}:getSelectedChainId`,\n      this.getSelectedChainId.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${this.name}:addNetwork`,\n      this.addNetwork.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${this.name}:removeNetwork`,\n      this.removeNetwork.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${this.name}:updateNetwork`,\n      this.updateNetwork.bind(this),\n    );\n\n    this.messenger.subscribe(\n      `${this.name}:rpcEndpointChainUnavailable`,\n      ({ networkClientId }) => {\n        this.#updateMetadataForNetwork(networkClientId, {\n          networkStatus: NetworkStatus.Unavailable,\n        });\n      },\n    );\n    this.messenger.subscribe(\n      `${this.name}:rpcEndpointChainDegraded`,\n      ({ networkClientId }) => {\n        this.#updateMetadataForNetwork(networkClientId, {\n          networkStatus: NetworkStatus.Degraded,\n        });\n      },\n    );\n    this.messenger.subscribe(\n      `${this.name}:rpcEndpointChainAvailable`,\n      ({ networkClientId }) => {\n        this.#updateMetadataForNetwork(networkClientId, {\n          networkStatus: NetworkStatus.Available,\n        });\n      },\n    );\n  }\n\n  /**\n   * Enables the RPC failover functionality. That is, if any RPC endpoints are\n   * configured with failover URLs, then traffic will automatically be diverted\n   * to them if those RPC endpoints are unavailable.\n   */\n  enableRpcFailover(): void {\n    this.#updateRpcFailoverEnabled(true);\n  }\n\n  /**\n   * Disables the RPC failover functionality. That is, even if any RPC endpoints\n   * are configured with failover URLs, then traffic will not automatically be\n   * diverted to them if those RPC endpoints are unavailable.\n   */\n  disableRpcFailover(): void {\n    this.#updateRpcFailoverEnabled(false);\n  }\n\n  /**\n   * Enables or disables the RPC failover functionality, depending on the\n   * boolean given. This is done by reconstructing all network clients that were\n   * originally configured with failover URLs so that those URLs are either\n   * honored or ignored. Network client IDs will be preserved so as not to\n   * invalidate state in other controllers.\n   *\n   * @param newIsRpcFailoverEnabled - Whether or not to enable or disable the\n   * RPC failover functionality.\n   */\n  #updateRpcFailoverEnabled(newIsRpcFailoverEnabled: boolean): void {\n    if (this.#isRpcFailoverEnabled === newIsRpcFailoverEnabled) {\n      return;\n    }\n\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    for (const networkClientsById of Object.values(\n      autoManagedNetworkClientRegistry,\n    )) {\n      for (const networkClientId of Object.keys(networkClientsById)) {\n        // Type assertion: We can assume that `networkClientId` is valid here.\n        const networkClient =\n          networkClientsById[\n            networkClientId as keyof typeof networkClientsById\n          ];\n        if (\n          networkClient.configuration.failoverRpcUrls &&\n          networkClient.configuration.failoverRpcUrls.length > 0\n        ) {\n          newIsRpcFailoverEnabled\n            ? networkClient.enableRpcFailover()\n            : networkClient.disableRpcFailover();\n        }\n      }\n    }\n\n    this.#isRpcFailoverEnabled = newIsRpcFailoverEnabled;\n  }\n\n  /**\n   * Accesses the provider and block tracker for the currently selected network.\n   *\n   * @returns The proxy and block tracker proxies.\n   * @deprecated This method has been replaced by `getSelectedNetworkClient` (which has a more easily used return type) and will be removed in a future release.\n   */\n  getProviderAndBlockTracker(): {\n    provider: SwappableProxy<ProxyWithAccessibleTarget<Provider>> | undefined;\n    blockTracker:\n      | SwappableProxy<ProxyWithAccessibleTarget<BlockTracker>>\n      | undefined;\n  } {\n    return {\n      provider: this.#providerProxy,\n      blockTracker: this.#blockTrackerProxy,\n    };\n  }\n\n  /**\n   * Accesses the provider and block tracker for the currently selected network.\n   *\n   * @returns an object with the provider and block tracker proxies for the currently selected network.\n   */\n  getSelectedNetworkClient():\n    | {\n        provider: SwappableProxy<ProxyWithAccessibleTarget<Provider>>;\n        blockTracker: SwappableProxy<ProxyWithAccessibleTarget<BlockTracker>>;\n      }\n    | undefined {\n    if (this.#providerProxy && this.#blockTrackerProxy) {\n      return {\n        provider: this.#providerProxy,\n        blockTracker: this.#blockTrackerProxy,\n      };\n    }\n    return undefined;\n  }\n\n  /**\n   * Accesses the chain ID from the selected network client.\n   *\n   * @returns The chain ID of the selected network client in hex format or undefined if there is no network client.\n   */\n  getSelectedChainId(): Hex | undefined {\n    const networkConfiguration = this.getNetworkConfigurationByNetworkClientId(\n      this.state.selectedNetworkClientId,\n    );\n    return networkConfiguration?.chainId;\n  }\n\n  /**\n   * Internally, the Infura and custom network clients are categorized by type\n   * so that when accessing either kind of network client, TypeScript knows\n   * which type to assign to the network client. For some cases it's more useful\n   * to be able to access network clients by ID instead of by type and then ID,\n   * so this function makes that possible.\n   *\n   * @returns The network clients registered so far, keyed by ID.\n   */\n  getNetworkClientRegistry(): AutoManagedBuiltInNetworkClientRegistry &\n    AutoManagedCustomNetworkClientRegistry {\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    return Object.assign(\n      {},\n      autoManagedNetworkClientRegistry[NetworkClientType.Infura],\n      autoManagedNetworkClientRegistry[NetworkClientType.Custom],\n    );\n  }\n\n  /**\n   * Returns the Infura network client with the given ID.\n   *\n   * @param infuraNetworkClientId - An Infura network client ID.\n   * @returns The Infura network client.\n   * @throws If an Infura network client does not exist with the given ID.\n   */\n  getNetworkClientById(\n    infuraNetworkClientId: BuiltInNetworkClientId,\n  ): AutoManagedNetworkClient<InfuraNetworkClientConfiguration>;\n\n  /**\n   * Returns the custom network client with the given ID.\n   *\n   * @param customNetworkClientId - A custom network client ID.\n   * @returns The custom network client.\n   * @throws If a custom network client does not exist with the given ID.\n   */\n  getNetworkClientById(\n    customNetworkClientId: CustomNetworkClientId,\n  ): AutoManagedNetworkClient<CustomNetworkClientConfiguration>;\n\n  getNetworkClientById(\n    networkClientId: NetworkClientId,\n  ): AutoManagedNetworkClient<NetworkClientConfiguration> {\n    if (!networkClientId) {\n      throw new Error('No network client ID was provided.');\n    }\n\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    if (isInfuraNetworkType(networkClientId)) {\n      const infuraNetworkClient =\n        autoManagedNetworkClientRegistry[NetworkClientType.Infura][\n          networkClientId\n        ];\n      // This is impossible to reach\n      /* istanbul ignore if */\n      if (!infuraNetworkClient) {\n        throw new Error(\n          `No Infura network client was found with the ID \"${networkClientId}\".`,\n        );\n      }\n      return infuraNetworkClient;\n    }\n\n    const customNetworkClient =\n      autoManagedNetworkClientRegistry[NetworkClientType.Custom][\n        networkClientId\n      ];\n    if (!customNetworkClient) {\n      throw new Error(\n        `No custom network client was found with the ID \"${networkClientId}\".`,\n      );\n    }\n    return customNetworkClient;\n  }\n\n  /**\n   * Executes a series of steps to switch the network:\n   *\n   * 1. Notifies subscribers via the messenger that the network is about to be\n   * switched (and, really, that the global provider and block tracker proxies\n   * will be re-pointed to a new network).\n   * 2. Looks up a known and preinitialized network client matching the given\n   * ID and uses it to re-point the aforementioned provider and block tracker\n   * proxies.\n   * 3. Notifies subscribers via the messenger that the network has switched.\n   * 4. Captures metadata for the newly switched network in state.\n   *\n   * @param networkClientId - The ID of a network client that requests will be\n   * routed through (either the name of an Infura network or the ID of a custom\n   * network configuration).\n   * @param options - Options for this method.\n   * @param options.updateState - Allows for updating state.\n   */\n  async #refreshNetwork(\n    networkClientId: string,\n    options: {\n      updateState?: (state: Draft<NetworkState>) => void;\n    } = {},\n  ): Promise<void> {\n    this.messenger.publish('NetworkController:networkWillChange', this.state);\n    this.#applyNetworkSelection(networkClientId, options);\n    this.messenger.publish('NetworkController:networkDidChange', this.state);\n    await this.lookupNetwork();\n  }\n\n  /**\n   * Creates proxies for accessing the global network client and its block\n   * tracker. You must call this method in order to use\n   * `getProviderAndBlockTracker` (or its replacement,\n   * `getSelectedNetworkClient`).\n   *\n   * @param options - Optional arguments.\n   * @param options.lookupNetwork - Usually, metadata for the global network\n   * will be populated via a call to `lookupNetwork` after creating the provider\n   * and block tracker proxies. This allows for responding to the status of the\n   * global network after initializing this controller; however, it requires\n   * making a request to the network to do so. In the clients, where controllers\n   * are initialized before the UI is shown, this may be undesirable, as it\n   * means that if the user has just installed MetaMask, their IP address may be\n   * shared with a third party before they have a chance to finish onboarding.\n   * You can pass `false` if you'd like to disable this request and call\n   * `lookupNetwork` yourself.\n   */\n  initializeProvider(options: { lookupNetwork: false }): void;\n\n  /**\n   * Creates proxies for accessing the global network client and its block\n   * tracker. You must call this method in order to use\n   * `getProviderAndBlockTracker` (or its replacement,\n   * `getSelectedNetworkClient`).\n   *\n   * @param options - Optional arguments.\n   * @param options.lookupNetwork - Usually, metadata for the global network\n   * will be populated via a call to `lookupNetwork` after creating the provider\n   * and block tracker proxies. This allows for responding to the status of the\n   * global network after initializing this controller; however, it requires\n   * making a request to the network to do so. In the clients, where controllers\n   * are initialized before the UI is shown, this may be undesirable, as it\n   * means that if the user has just installed MetaMask, their IP address may be\n   * shared with a third party before they have a chance to finish onboarding.\n   * You can pass `false` if you'd like to disable this request and call\n   * `lookupNetwork` yourself.\n   * @returns A promise that resolves when the network lookup completes.\n   */\n  initializeProvider(options?: { lookupNetwork?: boolean }): Promise<void>;\n\n  initializeProvider({\n    lookupNetwork = true,\n  }: {\n    lookupNetwork?: boolean;\n  } = {}): Promise<void> | undefined {\n    this.#applyNetworkSelection(this.state.selectedNetworkClientId);\n\n    if (lookupNetwork) {\n      return this.lookupNetwork();\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Uses a request for the latest block to gather the following information on\n   * the given network:\n   *\n   * - The connectivity status: whether it is available, geo-blocked (Infura\n   * only), unavailable, or unknown\n   * - The capabilities status: whether it supports EIP-1559, whether it does\n   * not, or whether it is unknown\n   *\n   * @param networkClientId - The ID of the network client to inspect.\n   * If no ID is provided, uses the currently selected network.\n   * @returns The resulting metadata for the network.\n   */\n  async #determineNetworkMetadata(networkClientId: NetworkClientId): Promise<{\n    isInfura: boolean;\n    networkStatus:\n      | NetworkStatus.Available\n      | NetworkStatus.Unknown\n      | NetworkStatus.Unavailable\n      | NetworkStatus.Blocked;\n    isEIP1559Compatible: undefined | boolean;\n  }> {\n    // Force TypeScript to use one of the two overloads explicitly\n    const networkClient = isInfuraNetworkType(networkClientId)\n      ? this.getNetworkClientById(networkClientId)\n      : this.getNetworkClientById(networkClientId);\n\n    const isInfura =\n      networkClient.configuration.type === NetworkClientType.Infura;\n    let networkStatus: NetworkStatus;\n    let isEIP1559Compatible: boolean | undefined;\n\n    try {\n      isEIP1559Compatible =\n        await this.#determineEIP1559Compatibility(networkClientId);\n      networkStatus = NetworkStatus.Available;\n    } catch (error) {\n      debugLog('NetworkController: lookupNetwork: ', error);\n\n      if (isErrorWithCode(error)) {\n        let responseBody;\n        if (\n          isInfura &&\n          hasProperty(error, 'message') &&\n          typeof error.message === 'string'\n        ) {\n          try {\n            responseBody = JSON.parse(error.message);\n          } catch {\n            // error.message must not be JSON\n            this.#log?.warn(\n              'NetworkController: lookupNetwork: json parse error: ',\n              error,\n            );\n          }\n        }\n\n        if (\n          isPlainObject(responseBody) &&\n          responseBody.error === INFURA_BLOCKED_KEY\n        ) {\n          networkStatus = NetworkStatus.Blocked;\n        } else if (error.code === errorCodes.rpc.internal) {\n          networkStatus = NetworkStatus.Unknown;\n          this.#log?.warn(\n            'NetworkController: lookupNetwork: rpc internal error: ',\n            error,\n          );\n        } else {\n          networkStatus = NetworkStatus.Unavailable;\n          this.#log?.warn('NetworkController: lookupNetwork: ', error);\n        }\n      } else {\n        debugLog(\n          'NetworkController - could not determine network status',\n          error,\n        );\n        networkStatus = NetworkStatus.Unknown;\n        this.#log?.warn('NetworkController: lookupNetwork: ', error);\n      }\n    }\n\n    return { isInfura, networkStatus, isEIP1559Compatible };\n  }\n\n  /**\n   * Uses a request for the latest block to gather the following information on\n   * the given or selected network, persisting it to state:\n   *\n   * - The connectivity status: whether it is available, geo-blocked (Infura\n   * only), unavailable, or unknown\n   * - The capabilities status: whether it supports EIP-1559, whether it does\n   * not, or whether it is unknown\n   *\n   * @param networkClientId - The ID of the network client to inspect.\n   * If no ID is provided, uses the currently selected network.\n   */\n  async lookupNetwork(networkClientId?: NetworkClientId): Promise<void> {\n    if (networkClientId) {\n      await this.#lookupGivenNetwork(networkClientId);\n    } else {\n      await this.#lookupSelectedNetwork();\n    }\n  }\n\n  /**\n   * Uses a request for the latest block to gather the following information on\n   * the given network, persisting it to state:\n   *\n   * - The connectivity status: whether the network is available, geo-blocked\n   * (Infura only), unavailable, or unknown\n   * - The feature compatibility status: whether the network supports EIP-1559,\n   * whether it does not, or whether it is unknown\n   *\n   * @param networkClientId - The ID of the network client to inspect.\n   * @deprecated Please use `lookupNetwork` and pass a network client ID\n   * instead. This method will be removed in a future major version.\n   */\n  // We are planning on removing this so we aren't interested in testing this\n  // right now.\n  /* istanbul ignore next */\n  async lookupNetworkByClientId(\n    networkClientId: NetworkClientId,\n  ): Promise<void> {\n    await this.#lookupGivenNetwork(networkClientId);\n  }\n\n  /**\n   * Uses a request for the latest block to gather the following information on\n   * the given network, persisting it to state:\n   *\n   * - The connectivity status: whether the network is available, geo-blocked\n   * (Infura only), unavailable, or unknown\n   * - The feature compatibility status: whether the network supports EIP-1559,\n   * whether it does not, or whether it is unknown\n   *\n   * @param networkClientId - The ID of the network client to inspect.\n   */\n  async #lookupGivenNetwork(networkClientId: NetworkClientId): Promise<void> {\n    const { networkStatus, isEIP1559Compatible } =\n      await this.#determineNetworkMetadata(networkClientId);\n\n    this.#updateMetadataForNetwork(networkClientId, {\n      networkStatus,\n      isEIP1559Compatible,\n    });\n  }\n\n  /**\n   * Uses a request for the latest block to gather the following information on\n   * the currently selected network, persisting it to state:\n   *\n   * - The connectivity status: whether the network is available, geo-blocked\n   * (Infura only), unavailable, or unknown\n   * - The feature compatibility status: whether the network supports EIP-1559,\n   * whether it does not, or whether it is unknown\n   *\n   * Note that it is possible for the current network to be switched while this\n   * method is running. If that is the case, it will exit early (as this method\n   * will also run for the new network).\n   */\n  async #lookupSelectedNetwork(): Promise<void> {\n    if (!this.#ethQuery) {\n      return;\n    }\n\n    let networkChanged = false;\n    const listener = (): void => {\n      networkChanged = true;\n      try {\n        this.messenger.unsubscribe(\n          'NetworkController:networkDidChange',\n          listener,\n        );\n      } catch (error) {\n        // In theory, this `catch` should not be necessary given that this error\n        // would occur \"inside\" of the call to `#determineEIP1559Compatibility`\n        // below and so it should be caught by the `try`/`catch` below (it is\n        // impossible to reproduce in tests for that reason). However, somehow\n        // it occurs within Mobile and so we have to add our own `try`/`catch`\n        // here.\n        /* istanbul ignore next */\n        if (\n          !(error instanceof Error) ||\n          error.message !==\n            'Subscription not found for event: NetworkController:networkDidChange'\n        ) {\n          // Again, this error should not happen and is impossible to reproduce\n          // in tests.\n          /* istanbul ignore next */\n          throw error;\n        }\n      }\n    };\n    this.messenger.subscribe('NetworkController:networkDidChange', listener);\n\n    const { isInfura, networkStatus, isEIP1559Compatible } =\n      await this.#determineNetworkMetadata(this.state.selectedNetworkClientId);\n\n    if (networkChanged) {\n      // If the network has changed, then `lookupNetwork` either has been or is\n      // in the process of being called, so we don't need to go further.\n      return;\n    }\n\n    try {\n      this.messenger.unsubscribe(\n        'NetworkController:networkDidChange',\n        listener,\n      );\n    } catch (error) {\n      if (\n        !(error instanceof Error) ||\n        error.message !==\n          'Subscription not found for event: NetworkController:networkDidChange'\n      ) {\n        throw error;\n      }\n    }\n\n    this.#updateMetadataForNetwork(this.state.selectedNetworkClientId, {\n      networkStatus,\n      isEIP1559Compatible,\n    });\n\n    if (isInfura) {\n      if (networkStatus === NetworkStatus.Available) {\n        this.messenger.publish('NetworkController:infuraIsUnblocked');\n      } else if (networkStatus === NetworkStatus.Blocked) {\n        this.messenger.publish('NetworkController:infuraIsBlocked');\n      }\n    } else {\n      // Always publish infuraIsUnblocked regardless of network status to\n      // prevent consumers from being stuck in a blocked state if they were\n      // previously connected to an Infura network that was blocked\n      this.messenger.publish('NetworkController:infuraIsUnblocked');\n    }\n  }\n\n  /**\n   * Updates the metadata for the given network in state.\n   *\n   * @param networkClientId - The associated network client ID.\n   * @param metadata - The metadata to store in state.\n   * @param metadata.networkStatus - The network status to store in state.\n   * @param metadata.isEIP1559Compatible - The EIP-1559 compatibility status to\n   * store in state.\n   */\n  #updateMetadataForNetwork(\n    networkClientId: NetworkClientId,\n    metadata: {\n      networkStatus: NetworkStatus;\n      isEIP1559Compatible?: boolean | undefined;\n    },\n  ): void {\n    this.update((state) => {\n      state.networksMetadata[networkClientId] ??= {\n        status: NetworkStatus.Unknown,\n        EIPS: {},\n      };\n\n      const newMetadata = state.networksMetadata[networkClientId];\n      newMetadata.status = metadata.networkStatus;\n\n      if ('isEIP1559Compatible' in metadata) {\n        if (metadata.isEIP1559Compatible === undefined) {\n          delete newMetadata.EIPS[1559];\n        } else {\n          newMetadata.EIPS[1559] = metadata.isEIP1559Compatible;\n        }\n      }\n    });\n  }\n\n  /**\n   * Convenience method to update provider network type settings.\n   *\n   * @param type - Human readable network name.\n   * @deprecated This has been replaced by `setActiveNetwork`, and will be\n   * removed in a future release\n   */\n  async setProviderType(type: InfuraNetworkType): Promise<void> {\n    if ((type as unknown) === NetworkType.rpc) {\n      throw new Error(\n        `NetworkController - cannot call \"setProviderType\" with type \"${NetworkType.rpc}\". Use \"setActiveNetwork\"`,\n      );\n    }\n    if (!isInfuraNetworkType(type)) {\n      throw new Error(`Unknown Infura provider type \"${String(type)}\".`);\n    }\n\n    await this.setActiveNetwork(type);\n  }\n\n  /**\n   * Changes the selected network.\n   *\n   * @param networkClientId - The ID of a network client that will be used to\n   * make requests.\n   * @param options - Options for this method.\n   * @param options.updateState - Allows for updating state.\n   * @throws if no network client is associated with the given\n   * network client ID.\n   */\n  async setActiveNetwork(\n    networkClientId: string,\n    options: {\n      updateState?: (state: Draft<NetworkState>) => void;\n    } = {},\n  ): Promise<void> {\n    this.#previouslySelectedNetworkClientId =\n      this.state.selectedNetworkClientId;\n\n    await this.#refreshNetwork(networkClientId, options);\n  }\n\n  /**\n   * Fetches the latest block for the network.\n   *\n   * @param networkClientId - The networkClientId to fetch the correct provider against which to check the latest block. Defaults to the selectedNetworkClientId.\n   * @returns A promise that either resolves to the block header or null if\n   * there is no latest block, or rejects with an error.\n   */\n  #getLatestBlock(\n    networkClientId: NetworkClientId = this.state.selectedNetworkClientId,\n  ): Promise<Block> {\n    const networkClient = this.getNetworkClientById(networkClientId);\n    const ethQuery = new EthQuery(networkClient.provider);\n\n    return new Promise((resolve, reject) => {\n      ethQuery.sendAsync(\n        { method: 'eth_getBlockByNumber', params: ['latest', false] },\n        (error: unknown, block?: unknown) => {\n          if (error) {\n            // This error comes from JsonRpcEngine, we don't control it.\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            reject(error);\n          } else {\n            // TODO: Validate this type\n            resolve(block as Block);\n          }\n        },\n      );\n    });\n  }\n\n  /**\n   * Determines whether the network supports EIP-1559 by checking whether the\n   * latest block has a `baseFeePerGas` property, then updates state\n   * appropriately.\n   *\n   * @param networkClientId - The networkClientId to fetch the correct provider against which to check 1559 compatibility.\n   * @returns A promise that resolves to true if the network supports EIP-1559\n   * , false otherwise, or `undefined` if unable to determine the compatibility.\n   */\n  async getEIP1559Compatibility(\n    networkClientId?: NetworkClientId,\n  ): Promise<undefined | boolean> {\n    if (networkClientId) {\n      return this.get1559CompatibilityWithNetworkClientId(networkClientId);\n    }\n    if (!this.#ethQuery) {\n      return false;\n    }\n\n    const { EIPS } =\n      this.state.networksMetadata[this.state.selectedNetworkClientId];\n\n    if (EIPS[1559] !== undefined) {\n      return EIPS[1559];\n    }\n\n    const isEIP1559Compatible = await this.#determineEIP1559Compatibility(\n      this.state.selectedNetworkClientId,\n    );\n    this.update((state) => {\n      if (isEIP1559Compatible !== undefined) {\n        state.networksMetadata[state.selectedNetworkClientId].EIPS[1559] =\n          isEIP1559Compatible;\n      }\n    });\n    return isEIP1559Compatible;\n  }\n\n  async get1559CompatibilityWithNetworkClientId(\n    networkClientId: NetworkClientId,\n  ): Promise<boolean> {\n    let metadata = this.state.networksMetadata[networkClientId];\n    if (metadata?.EIPS[1559] === undefined) {\n      await this.lookupNetwork(networkClientId);\n      metadata = this.state.networksMetadata[networkClientId];\n    }\n    const { EIPS } = metadata;\n\n    // may want to include some 'freshness' value - something to make sure we refetch this from time to time\n    return EIPS[1559];\n  }\n\n  /**\n   * Retrieves and checks the latest block from the currently selected\n   * network; if the block has a `baseFeePerGas` property, then we know\n   * that the network supports EIP-1559; otherwise it doesn't.\n   *\n   * @param networkClientId - The networkClientId to fetch the correct provider against which to check 1559 compatibility\n   * @returns A promise that resolves to `true` if the network supports EIP-1559,\n   * `false` otherwise, or `undefined` if unable to retrieve the last block.\n   */\n  async #determineEIP1559Compatibility(\n    networkClientId: NetworkClientId,\n  ): Promise<boolean | undefined> {\n    const latestBlock = await this.#getLatestBlock(networkClientId);\n\n    if (!latestBlock) {\n      return undefined;\n    }\n\n    return latestBlock.baseFeePerGas !== undefined;\n  }\n\n  /**\n   * Ensures that the provider and block tracker proxies are pointed to the\n   * currently selected network and refreshes the metadata for the\n   */\n  async resetConnection(): Promise<void> {\n    await this.#refreshNetwork(this.state.selectedNetworkClientId);\n  }\n\n  /**\n   * Returns the network configuration that has been filed under the given chain\n   * ID.\n   *\n   * @param chainId - The chain ID to use as a key.\n   * @returns The network configuration if one exists, or undefined.\n   */\n  getNetworkConfigurationByChainId(\n    chainId: Hex,\n  ): NetworkConfiguration | undefined {\n    return this.state.networkConfigurationsByChainId[chainId];\n  }\n\n  /**\n   * Returns the network configuration that contains an RPC endpoint with the\n   * given network client ID.\n   *\n   * @param networkClientId - The network client ID to use as a key.\n   * @returns The network configuration if one exists, or undefined.\n   */\n  getNetworkConfigurationByNetworkClientId(\n    networkClientId: NetworkClientId,\n  ): NetworkConfiguration | undefined {\n    return this.#networkConfigurationsByNetworkClientId.get(networkClientId);\n  }\n\n  /**\n   * Creates and registers network clients for the collection of Infura and\n   * custom RPC endpoints that can be used to make requests for a particular\n   * chain, storing the given configuration object in state for later reference.\n   *\n   * @param fields - The object that describes the new network/chain and lists\n   * the RPC endpoints which front that chain.\n   * @returns The newly added network configuration.\n   * @throws if any part of `fields` would produce invalid state.\n   * @see {@link NetworkConfiguration}\n   */\n  addNetwork(fields: AddNetworkFields): NetworkConfiguration {\n    const { rpcEndpoints: setOfRpcEndpointFields } = fields;\n\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    this.#validateNetworkFields({\n      mode: 'add',\n      networkFields: fields,\n      autoManagedNetworkClientRegistry,\n    });\n\n    const networkClientOperations = setOfRpcEndpointFields.map(\n      (defaultOrCustomRpcEndpointFields) => {\n        const rpcEndpoint =\n          defaultOrCustomRpcEndpointFields.type === RpcEndpointType.Custom\n            ? {\n                ...defaultOrCustomRpcEndpointFields,\n                networkClientId: uuidV4(),\n              }\n            : defaultOrCustomRpcEndpointFields;\n        return {\n          type: 'add' as const,\n          rpcEndpoint,\n        };\n      },\n    );\n\n    const newNetworkConfiguration =\n      this.#determineNetworkConfigurationToPersist({\n        networkFields: fields,\n        networkClientOperations,\n      });\n    this.#registerNetworkClientsAsNeeded({\n      networkFields: fields,\n      networkClientOperations,\n      autoManagedNetworkClientRegistry,\n    });\n    this.update((state) => {\n      this.#updateNetworkConfigurations({\n        state,\n        mode: 'add',\n        networkFields: fields,\n        networkConfigurationToPersist: newNetworkConfiguration,\n      });\n    });\n\n    this.messenger.publish(\n      `${controllerName}:networkAdded`,\n      newNetworkConfiguration,\n    );\n\n    return newNetworkConfiguration;\n  }\n\n  /**\n   * Updates the configuration for a previously stored network filed under the\n   * given chain ID, creating + registering new network clients to represent RPC\n   * endpoints that have been added and destroying + unregistering existing\n   * network clients for RPC endpoints that have been removed.\n   *\n   * Note that if `chainId` is changed, then all network clients associated with\n   * that chain will be removed and re-added, even if none of the RPC endpoints\n   * have changed.\n   *\n   * @param chainId - The chain ID associated with an existing network.\n   * @param fields - The object that describes the updates to the network/chain,\n   * including the new set of RPC endpoints which should front that chain.\n   * @param options - Options to provide.\n   * @param options.replacementSelectedRpcEndpointIndex - Usually you cannot\n   * remove an RPC endpoint that is being represented by the currently selected\n   * network client. This option allows you to specify another RPC endpoint\n   * (either an existing one or a new one) that should be used to select a new\n   * network instead.\n   * @returns The updated network configuration.\n   * @throws if `chainId` does not refer to an existing network configuration,\n   * if any part of `fields` would produce invalid state, etc.\n   * @see {@link NetworkConfiguration}\n   */\n  async updateNetwork(\n    chainId: Hex,\n    fields: UpdateNetworkFields,\n    {\n      replacementSelectedRpcEndpointIndex,\n    }: { replacementSelectedRpcEndpointIndex?: number } = {},\n  ): Promise<NetworkConfiguration> {\n    const existingNetworkConfiguration =\n      this.state.networkConfigurationsByChainId[chainId];\n\n    if (existingNetworkConfiguration === undefined) {\n      throw new Error(\n        `Could not update network: Cannot find network configuration for chain '${chainId}'`,\n      );\n    }\n\n    const existingChainId = chainId;\n    const { chainId: newChainId, rpcEndpoints: setOfNewRpcEndpointFields } =\n      fields;\n\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    this.#validateNetworkFields({\n      mode: 'update',\n      networkFields: fields,\n      existingNetworkConfiguration,\n      autoManagedNetworkClientRegistry,\n    });\n\n    const networkClientOperations: NetworkClientOperation[] = [];\n\n    for (const newRpcEndpointFields of setOfNewRpcEndpointFields) {\n      const existingRpcEndpointForNoop =\n        existingNetworkConfiguration.rpcEndpoints.find((rpcEndpoint) => {\n          return (\n            rpcEndpoint.type === newRpcEndpointFields.type &&\n            rpcEndpoint.url === newRpcEndpointFields.url &&\n            (rpcEndpoint.networkClientId ===\n              newRpcEndpointFields.networkClientId ||\n              newRpcEndpointFields.networkClientId === undefined)\n          );\n        });\n      const existingRpcEndpointForReplaceWhenChainChanged =\n        existingNetworkConfiguration.rpcEndpoints.find((rpcEndpoint) => {\n          return (\n            (rpcEndpoint.type === RpcEndpointType.Infura &&\n              newRpcEndpointFields.type === RpcEndpointType.Infura) ||\n            (rpcEndpoint.type === newRpcEndpointFields.type &&\n              rpcEndpoint.networkClientId ===\n                newRpcEndpointFields.networkClientId &&\n              rpcEndpoint.url === newRpcEndpointFields.url)\n          );\n        });\n      const existingRpcEndpointForReplaceWhenChainNotChanged =\n        existingNetworkConfiguration.rpcEndpoints.find((rpcEndpoint) => {\n          return (\n            rpcEndpoint.type === newRpcEndpointFields.type &&\n            (rpcEndpoint.url === newRpcEndpointFields.url ||\n              rpcEndpoint.networkClientId ===\n                newRpcEndpointFields.networkClientId)\n          );\n        });\n\n      if (\n        newChainId !== existingChainId &&\n        existingRpcEndpointForReplaceWhenChainChanged !== undefined\n      ) {\n        const newRpcEndpoint =\n          newRpcEndpointFields.type === RpcEndpointType.Infura\n            ? newRpcEndpointFields\n            : { ...newRpcEndpointFields, networkClientId: uuidV4() };\n\n        networkClientOperations.push({\n          type: 'replace' as const,\n          oldRpcEndpoint: existingRpcEndpointForReplaceWhenChainChanged,\n          newRpcEndpoint,\n        });\n      } else if (existingRpcEndpointForNoop !== undefined) {\n        let newRpcEndpoint;\n        if (existingRpcEndpointForNoop.type === RpcEndpointType.Infura) {\n          newRpcEndpoint = existingRpcEndpointForNoop;\n        } else {\n          // `networkClientId` shouldn't be missing at this point; if it is,\n          // that's a mistake, so fill it back in\n          newRpcEndpoint = Object.assign({}, newRpcEndpointFields, {\n            networkClientId: existingRpcEndpointForNoop.networkClientId,\n          });\n        }\n        networkClientOperations.push({\n          type: 'noop' as const,\n          rpcEndpoint: newRpcEndpoint,\n        });\n      } else if (\n        existingRpcEndpointForReplaceWhenChainNotChanged === undefined\n      ) {\n        const newRpcEndpoint =\n          newRpcEndpointFields.type === RpcEndpointType.Infura\n            ? newRpcEndpointFields\n            : { ...newRpcEndpointFields, networkClientId: uuidV4() };\n        const networkClientOperation = {\n          type: 'add' as const,\n          rpcEndpoint: newRpcEndpoint,\n        };\n        networkClientOperations.push(networkClientOperation);\n      } else {\n        let newRpcEndpoint;\n        /* istanbul ignore if */\n        if (newRpcEndpointFields.type === RpcEndpointType.Infura) {\n          // This case can't actually happen. If we're here, it means that some\n          // part of the RPC endpoint changed. But there is no part of an Infura\n          // RPC endpoint that can be changed (as it would immediately make that\n          // RPC endpoint self-inconsistent). This is just here to appease\n          // TypeScript.\n          newRpcEndpoint = newRpcEndpointFields;\n        } else {\n          newRpcEndpoint = {\n            ...newRpcEndpointFields,\n            networkClientId: uuidV4(),\n          };\n        }\n\n        networkClientOperations.push({\n          type: 'replace' as const,\n          oldRpcEndpoint: existingRpcEndpointForReplaceWhenChainNotChanged,\n          newRpcEndpoint,\n        });\n      }\n    }\n\n    for (const existingRpcEndpoint of existingNetworkConfiguration.rpcEndpoints) {\n      if (\n        !networkClientOperations.some((networkClientOperation) => {\n          const otherRpcEndpoint =\n            networkClientOperation.type === 'replace'\n              ? networkClientOperation.oldRpcEndpoint\n              : networkClientOperation.rpcEndpoint;\n          return (\n            otherRpcEndpoint.type === existingRpcEndpoint.type &&\n            otherRpcEndpoint.networkClientId ===\n              existingRpcEndpoint.networkClientId &&\n            otherRpcEndpoint.url === existingRpcEndpoint.url\n          );\n        })\n      ) {\n        const networkClientOperation = {\n          type: 'remove' as const,\n          rpcEndpoint: existingRpcEndpoint,\n        };\n        networkClientOperations.push(networkClientOperation);\n      }\n    }\n\n    const updatedNetworkConfiguration =\n      this.#determineNetworkConfigurationToPersist({\n        networkFields: fields,\n        networkClientOperations,\n      });\n\n    if (\n      replacementSelectedRpcEndpointIndex === undefined &&\n      networkClientOperations.some((networkClientOperation) => {\n        return (\n          networkClientOperation.type === 'remove' &&\n          networkClientOperation.rpcEndpoint.networkClientId ===\n            this.state.selectedNetworkClientId\n        );\n      }) &&\n      !networkClientOperations.some((networkClientOperation) => {\n        return (\n          networkClientOperation.type === 'replace' &&\n          networkClientOperation.oldRpcEndpoint.networkClientId ===\n            this.state.selectedNetworkClientId\n        );\n      })\n    ) {\n      throw new Error(\n        `Could not update network: Cannot update RPC endpoints in such a way that the selected network '${this.state.selectedNetworkClientId}' would be removed without a replacement. Choose a different RPC endpoint as the selected network via the \\`replacementSelectedRpcEndpointIndex\\` option.`,\n      );\n    }\n\n    this.#registerNetworkClientsAsNeeded({\n      networkFields: fields,\n      networkClientOperations,\n      autoManagedNetworkClientRegistry,\n    });\n\n    const replacementSelectedRpcEndpointWithIndex = networkClientOperations\n      .map(\n        (networkClientOperation, index) =>\n          [networkClientOperation, index] as const,\n      )\n      .find(([networkClientOperation, _index]) => {\n        return (\n          networkClientOperation.type === 'replace' &&\n          networkClientOperation.oldRpcEndpoint.networkClientId ===\n            this.state.selectedNetworkClientId\n        );\n      });\n    const correctedReplacementSelectedRpcEndpointIndex =\n      replacementSelectedRpcEndpointIndex ??\n      replacementSelectedRpcEndpointWithIndex?.[1];\n\n    let rpcEndpointToSelect: RpcEndpoint | undefined;\n    if (correctedReplacementSelectedRpcEndpointIndex !== undefined) {\n      rpcEndpointToSelect =\n        updatedNetworkConfiguration.rpcEndpoints[\n          correctedReplacementSelectedRpcEndpointIndex\n        ];\n\n      if (rpcEndpointToSelect === undefined) {\n        throw new Error(\n          `Could not update network: \\`replacementSelectedRpcEndpointIndex\\` ${correctedReplacementSelectedRpcEndpointIndex} does not refer to an entry in \\`rpcEndpoints\\``,\n        );\n      }\n    }\n\n    if (\n      rpcEndpointToSelect &&\n      rpcEndpointToSelect.networkClientId !== this.state.selectedNetworkClientId\n    ) {\n      await this.setActiveNetwork(rpcEndpointToSelect.networkClientId, {\n        updateState: (state) => {\n          this.#updateNetworkConfigurations({\n            state,\n            mode: 'update',\n            networkFields: fields,\n            networkConfigurationToPersist: updatedNetworkConfiguration,\n            existingNetworkConfiguration,\n          });\n        },\n      });\n    } else {\n      this.update((state) => {\n        this.#updateNetworkConfigurations({\n          state,\n          mode: 'update',\n          networkFields: fields,\n          networkConfigurationToPersist: updatedNetworkConfiguration,\n          existingNetworkConfiguration,\n        });\n      });\n    }\n\n    this.#unregisterNetworkClientsAsNeeded({\n      networkClientOperations,\n      autoManagedNetworkClientRegistry,\n    });\n\n    return updatedNetworkConfiguration;\n  }\n\n  /**\n   * Destroys and unregisters the network identified by the given chain ID, also\n   * removing the associated network configuration from state.\n   *\n   * @param chainId - The chain ID associated with an existing network.\n   * @throws if `chainId` does not refer to an existing network configuration,\n   * or if the currently selected network is being removed.\n   * @see {@link NetworkConfiguration}\n   */\n  removeNetwork(chainId: Hex): void {\n    const existingNetworkConfiguration =\n      this.state.networkConfigurationsByChainId[chainId];\n\n    if (existingNetworkConfiguration === undefined) {\n      throw new Error(\n        `Cannot find network configuration for chain '${chainId}'`,\n      );\n    }\n\n    if (\n      existingNetworkConfiguration.rpcEndpoints.some(\n        (rpcEndpoint) =>\n          rpcEndpoint.networkClientId === this.state.selectedNetworkClientId,\n      )\n    ) {\n      throw new Error(`Cannot remove the currently selected network`);\n    }\n\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    const networkClientOperations =\n      existingNetworkConfiguration.rpcEndpoints.map((rpcEndpoint) => {\n        return {\n          type: 'remove' as const,\n          rpcEndpoint,\n        };\n      });\n\n    this.#unregisterNetworkClientsAsNeeded({\n      networkClientOperations,\n      autoManagedNetworkClientRegistry,\n    });\n    this.update((state) => {\n      this.#updateNetworkConfigurations({\n        state,\n        mode: 'remove',\n        existingNetworkConfiguration,\n      });\n\n      for (const rpcEndpoint of existingNetworkConfiguration.rpcEndpoints) {\n        delete state.networksMetadata[rpcEndpoint.networkClientId];\n      }\n    });\n\n    this.messenger.publish(\n      'NetworkController:networkRemoved',\n      existingNetworkConfiguration,\n    );\n  }\n\n  /**\n   * Assuming that the network has been previously switched, switches to this\n   * new network.\n   *\n   * If the network has not been previously switched, this method is equivalent\n   * to {@link resetConnection}.\n   */\n  async rollbackToPreviousProvider(): Promise<void> {\n    await this.#refreshNetwork(this.#previouslySelectedNetworkClientId);\n  }\n\n  /**\n   * Deactivates the controller, stopping any ongoing polling.\n   *\n   * In-progress requests will not be aborted.\n   */\n  // We're intentionally changing the signature of an extended method.\n  // eslint-disable-next-line @typescript-eslint/no-misused-promises\n  async destroy(): Promise<void> {\n    await this.#blockTrackerProxy?.destroy();\n  }\n\n  /**\n   * Merges the given backup data into controller state.\n   *\n   * @param backup - The data that has been backed up.\n   * @param backup.networkConfigurationsByChainId - Network configurations,\n   * keyed by chain ID.\n   */\n  loadBackup({\n    networkConfigurationsByChainId,\n  }: Pick<NetworkState, 'networkConfigurationsByChainId'>): void {\n    this.update((state) => {\n      state.networkConfigurationsByChainId = {\n        ...state.networkConfigurationsByChainId,\n        ...networkConfigurationsByChainId,\n      };\n    });\n  }\n\n  /**\n   * Searches for the default RPC endpoint configured for the given chain and\n   * returns its network client ID. This can then be passed to\n   * {@link getNetworkClientById} to retrieve the network client.\n   *\n   * @param chainId - Chain ID to search for.\n   * @returns The ID of the network client created for the chain's default RPC\n   * endpoint.\n   */\n  findNetworkClientIdByChainId(chainId: Hex): NetworkClientId {\n    const networkConfiguration =\n      this.state.networkConfigurationsByChainId[chainId];\n\n    if (!networkConfiguration) {\n      throw new Error(`Invalid chain ID \"${chainId}\"`);\n    }\n\n    const { networkClientId } =\n      networkConfiguration.rpcEndpoints[\n        networkConfiguration.defaultRpcEndpointIndex\n      ];\n    return networkClientId;\n  }\n\n  /**\n   * Ensure that the given fields which will be used to either add or update a\n   * network are valid.\n   *\n   * @param args - The arguments.\n   */\n  #validateNetworkFields(\n    args: {\n      autoManagedNetworkClientRegistry: AutoManagedNetworkClientRegistry;\n    } & (\n      | {\n          mode: 'add';\n          networkFields: AddNetworkFields;\n        }\n      | {\n          mode: 'update';\n          existingNetworkConfiguration: NetworkConfiguration;\n          networkFields: UpdateNetworkFields;\n        }\n    ),\n  ): void {\n    const { mode, networkFields, autoManagedNetworkClientRegistry } = args;\n    const existingNetworkConfiguration =\n      'existingNetworkConfiguration' in args\n        ? args.existingNetworkConfiguration\n        : null;\n\n    const errorMessagePrefix =\n      mode === 'update' ? 'Could not update network' : 'Could not add network';\n\n    if (\n      !isStrictHexString(networkFields.chainId) ||\n      !isSafeChainId(networkFields.chainId)\n    ) {\n      throw new Error(\n        `${errorMessagePrefix}: Invalid \\`chainId\\` '${networkFields.chainId}' (must start with \"0x\" and not exceed the maximum)`,\n      );\n    }\n\n    if (\n      existingNetworkConfiguration === null ||\n      networkFields.chainId !== existingNetworkConfiguration.chainId\n    ) {\n      const existingNetworkConfigurationViaChainId =\n        this.state.networkConfigurationsByChainId[networkFields.chainId];\n      if (existingNetworkConfigurationViaChainId !== undefined) {\n        if (existingNetworkConfiguration === null) {\n          throw new Error(\n            `Could not add network for chain ${args.networkFields.chainId} as another network for that chain already exists ('${existingNetworkConfigurationViaChainId.name}')`,\n          );\n        } else {\n          throw new Error(\n            `Cannot move network from chain ${existingNetworkConfiguration.chainId} to ${networkFields.chainId} as another network for that chain already exists ('${existingNetworkConfigurationViaChainId.name}')`,\n          );\n        }\n      }\n    }\n\n    const isInvalidDefaultBlockExplorerUrlIndex =\n      networkFields.blockExplorerUrls.length > 0\n        ? networkFields.defaultBlockExplorerUrlIndex === undefined ||\n          networkFields.blockExplorerUrls[\n            networkFields.defaultBlockExplorerUrlIndex\n          ] === undefined\n        : networkFields.defaultBlockExplorerUrlIndex !== undefined;\n\n    if (isInvalidDefaultBlockExplorerUrlIndex) {\n      throw new Error(\n        `${errorMessagePrefix}: \\`defaultBlockExplorerUrlIndex\\` must refer to an entry in \\`blockExplorerUrls\\``,\n      );\n    }\n\n    if (networkFields.rpcEndpoints.length === 0) {\n      throw new Error(\n        `${errorMessagePrefix}: \\`rpcEndpoints\\` must be a non-empty array`,\n      );\n    }\n    for (const rpcEndpointFields of networkFields.rpcEndpoints) {\n      if (!isValidUrl(rpcEndpointFields.url)) {\n        throw new Error(\n          `${errorMessagePrefix}: An entry in \\`rpcEndpoints\\` has invalid URL '${rpcEndpointFields.url}'`,\n        );\n      }\n      const networkClientId =\n        'networkClientId' in rpcEndpointFields\n          ? rpcEndpointFields.networkClientId\n          : undefined;\n\n      if (\n        rpcEndpointFields.type === RpcEndpointType.Custom &&\n        networkClientId !== undefined &&\n        isInfuraNetworkType(networkClientId)\n      ) {\n        throw new Error(\n          `${errorMessagePrefix}: Custom RPC endpoint '${rpcEndpointFields.url}' has invalid network client ID '${networkClientId}'`,\n        );\n      }\n\n      if (\n        mode === 'update' &&\n        networkClientId !== undefined &&\n        rpcEndpointFields.type === RpcEndpointType.Custom &&\n        !Object.values(autoManagedNetworkClientRegistry).some(\n          (networkClientsById) => networkClientId in networkClientsById,\n        )\n      ) {\n        throw new Error(\n          `${errorMessagePrefix}: RPC endpoint '${rpcEndpointFields.url}' refers to network client '${networkClientId}' that does not exist`,\n        );\n      }\n\n      if (\n        networkFields.rpcEndpoints.some(\n          (otherRpcEndpointFields) =>\n            otherRpcEndpointFields !== rpcEndpointFields &&\n            URI.equal(otherRpcEndpointFields.url, rpcEndpointFields.url),\n        )\n      ) {\n        throw new Error(\n          `${errorMessagePrefix}: Each entry in rpcEndpoints must have a unique URL`,\n        );\n      }\n\n      const networkConfigurationsForOtherChains = Object.values(\n        this.state.networkConfigurationsByChainId,\n      ).filter((networkConfiguration) =>\n        existingNetworkConfiguration\n          ? networkConfiguration.chainId !==\n            existingNetworkConfiguration.chainId\n          : true,\n      );\n      for (const networkConfiguration of networkConfigurationsForOtherChains) {\n        const rpcEndpoint = networkConfiguration.rpcEndpoints.find(\n          (existingRpcEndpoint) =>\n            URI.equal(rpcEndpointFields.url, existingRpcEndpoint.url),\n        );\n        if (rpcEndpoint) {\n          if (mode === 'update') {\n            throw new Error(\n              `Could not update network to point to same RPC endpoint as existing network for chain ${networkConfiguration.chainId} ('${networkConfiguration.name}')`,\n            );\n          } else {\n            throw new Error(\n              `Could not add network that points to same RPC endpoint as existing network for chain ${networkConfiguration.chainId} ('${networkConfiguration.name}')`,\n            );\n          }\n        }\n      }\n    }\n\n    if (\n      [...new Set(networkFields.rpcEndpoints)].length <\n      networkFields.rpcEndpoints.length\n    ) {\n      throw new Error(\n        `${errorMessagePrefix}: Each entry in rpcEndpoints must be unique`,\n      );\n    }\n\n    const networkClientIds = networkFields.rpcEndpoints\n      .map((rpcEndpoint) =>\n        'networkClientId' in rpcEndpoint\n          ? rpcEndpoint.networkClientId\n          : undefined,\n      )\n      .filter(\n        (networkClientId): networkClientId is NetworkClientId =>\n          networkClientId !== undefined,\n      );\n    if ([...new Set(networkClientIds)].length < networkClientIds.length) {\n      throw new Error(\n        `${errorMessagePrefix}: Each entry in rpcEndpoints must have a unique networkClientId`,\n      );\n    }\n\n    const infuraRpcEndpoints = networkFields.rpcEndpoints.filter(\n      (rpcEndpointFields): rpcEndpointFields is InfuraRpcEndpoint =>\n        rpcEndpointFields.type === RpcEndpointType.Infura,\n    );\n    if (infuraRpcEndpoints.length > 1) {\n      throw new Error(\n        `${errorMessagePrefix}: There cannot be more than one Infura RPC endpoint`,\n      );\n    }\n\n    const soleInfuraRpcEndpoint = infuraRpcEndpoints[0];\n    if (soleInfuraRpcEndpoint) {\n      const infuraNetworkName = deriveInfuraNetworkNameFromRpcEndpointUrl(\n        soleInfuraRpcEndpoint.url,\n      );\n      const infuraNetworkNickname = NetworkNickname[infuraNetworkName];\n      const infuraChainId = ChainId[infuraNetworkName];\n      if (networkFields.chainId !== infuraChainId) {\n        throw new Error(\n          mode === 'add'\n            ? `Could not add network with chain ID ${networkFields.chainId} and Infura RPC endpoint for '${infuraNetworkNickname}' which represents ${infuraChainId}, as the two conflict`\n            : `Could not update network with chain ID ${networkFields.chainId} and Infura RPC endpoint for '${infuraNetworkNickname}' which represents ${infuraChainId}, as the two conflict`,\n        );\n      }\n    }\n\n    if (\n      networkFields.rpcEndpoints[networkFields.defaultRpcEndpointIndex] ===\n      undefined\n    ) {\n      throw new Error(\n        `${errorMessagePrefix}: \\`defaultRpcEndpointIndex\\` must refer to an entry in \\`rpcEndpoints\\``,\n      );\n    }\n  }\n\n  /**\n   * Constructs a network configuration that will be persisted to state when\n   * adding or updating a network.\n   *\n   * @param args - The arguments to this function.\n   * @param args.networkFields - The fields used to add or update a network.\n   * @param args.networkClientOperations - Operations which were calculated for\n   * updating the network client registry but which also map back to RPC\n   * endpoints (and so can be used to save those RPC endpoints).\n   * @returns The network configuration to persist.\n   */\n  #determineNetworkConfigurationToPersist({\n    networkFields,\n    networkClientOperations,\n  }: {\n    networkFields: AddNetworkFields | UpdateNetworkFields;\n    networkClientOperations: NetworkClientOperation[];\n  }): NetworkConfiguration {\n    const rpcEndpointsToPersist = networkClientOperations\n      .filter(\n        (\n          networkClientOperation,\n        ): networkClientOperation is\n          | AddNetworkClientOperation\n          | NoopNetworkClientOperation => {\n          return (\n            networkClientOperation.type === 'add' ||\n            networkClientOperation.type === 'noop'\n          );\n        },\n      )\n      .map((networkClientOperation) => networkClientOperation.rpcEndpoint)\n      .concat(\n        networkClientOperations\n          .filter(\n            (\n              networkClientOperation,\n            ): networkClientOperation is ReplaceNetworkClientOperation => {\n              return networkClientOperation.type === 'replace';\n            },\n          )\n          .map(\n            (networkClientOperation) => networkClientOperation.newRpcEndpoint,\n          ),\n      );\n\n    return { ...networkFields, rpcEndpoints: rpcEndpointsToPersist };\n  }\n\n  /**\n   * Creates and registers network clients using the given operations calculated\n   * as a part of adding or updating a network.\n   *\n   * @param args - The arguments to this function.\n   * @param args.networkFields - The fields used to add or update a network.\n   * @param args.networkClientOperations - Dictate which network clients need to\n   * be created.\n   * @param args.autoManagedNetworkClientRegistry - The network client registry\n   * to update.\n   */\n  #registerNetworkClientsAsNeeded({\n    networkFields,\n    networkClientOperations,\n    autoManagedNetworkClientRegistry,\n  }: {\n    networkFields: AddNetworkFields | UpdateNetworkFields;\n    networkClientOperations: NetworkClientOperation[];\n    autoManagedNetworkClientRegistry: AutoManagedNetworkClientRegistry;\n  }): void {\n    const addedRpcEndpoints = networkClientOperations\n      .filter(\n        (\n          networkClientOperation,\n        ): networkClientOperation is AddNetworkClientOperation => {\n          return networkClientOperation.type === 'add';\n        },\n      )\n      .map((networkClientOperation) => networkClientOperation.rpcEndpoint)\n      .concat(\n        networkClientOperations\n          .filter(\n            (\n              networkClientOperation,\n            ): networkClientOperation is ReplaceNetworkClientOperation => {\n              return networkClientOperation.type === 'replace';\n            },\n          )\n          .map(\n            (networkClientOperation) => networkClientOperation.newRpcEndpoint,\n          ),\n      );\n\n    for (const addedRpcEndpoint of addedRpcEndpoints) {\n      if (addedRpcEndpoint.type === RpcEndpointType.Infura) {\n        autoManagedNetworkClientRegistry[NetworkClientType.Infura][\n          addedRpcEndpoint.networkClientId\n        ] = createAutoManagedNetworkClient({\n          networkClientId: addedRpcEndpoint.networkClientId,\n          networkClientConfiguration: {\n            type: NetworkClientType.Infura,\n            chainId: networkFields.chainId,\n            network: addedRpcEndpoint.networkClientId,\n            failoverRpcUrls: addedRpcEndpoint.failoverUrls,\n            infuraProjectId: this.#infuraProjectId,\n            ticker: networkFields.nativeCurrency,\n          },\n          getRpcServiceOptions: this.#getRpcServiceOptions,\n          getBlockTrackerOptions: this.#getBlockTrackerOptions,\n          messenger: this.messenger,\n          isRpcFailoverEnabled: this.#isRpcFailoverEnabled,\n          logger: this.#log,\n        });\n      } else {\n        autoManagedNetworkClientRegistry[NetworkClientType.Custom][\n          addedRpcEndpoint.networkClientId\n        ] = createAutoManagedNetworkClient({\n          networkClientId: addedRpcEndpoint.networkClientId,\n          networkClientConfiguration: {\n            type: NetworkClientType.Custom,\n            chainId: networkFields.chainId,\n            failoverRpcUrls: addedRpcEndpoint.failoverUrls,\n            rpcUrl: addedRpcEndpoint.url,\n            ticker: networkFields.nativeCurrency,\n          },\n          getRpcServiceOptions: this.#getRpcServiceOptions,\n          getBlockTrackerOptions: this.#getBlockTrackerOptions,\n          messenger: this.messenger,\n          isRpcFailoverEnabled: this.#isRpcFailoverEnabled,\n          logger: this.#log,\n        });\n      }\n    }\n  }\n\n  /**\n   * Destroys and removes network clients using the given operations calculated\n   * as a part of updating or removing a network.\n   *\n   * @param args - The arguments to this function.\n   * @param args.networkClientOperations - Dictate which network clients to\n   * remove.\n   * @param args.autoManagedNetworkClientRegistry - The network client registry\n   * to update.\n   */\n  #unregisterNetworkClientsAsNeeded({\n    networkClientOperations,\n    autoManagedNetworkClientRegistry,\n  }: {\n    networkClientOperations: NetworkClientOperation[];\n    autoManagedNetworkClientRegistry: AutoManagedNetworkClientRegistry;\n  }): void {\n    const removedRpcEndpoints = networkClientOperations\n      .filter(\n        (\n          networkClientOperation,\n        ): networkClientOperation is RemoveNetworkClientOperation => {\n          return networkClientOperation.type === 'remove';\n        },\n      )\n      .map((networkClientOperation) => networkClientOperation.rpcEndpoint)\n      .concat(\n        networkClientOperations\n          .filter(\n            (\n              networkClientOperation,\n            ): networkClientOperation is ReplaceNetworkClientOperation => {\n              return networkClientOperation.type === 'replace';\n            },\n          )\n          .map(\n            (networkClientOperation) => networkClientOperation.oldRpcEndpoint,\n          ),\n      );\n\n    for (const rpcEndpoint of removedRpcEndpoints) {\n      const networkClient = this.getNetworkClientById(\n        rpcEndpoint.networkClientId,\n      );\n      networkClient.destroy();\n      delete autoManagedNetworkClientRegistry[networkClient.configuration.type][\n        rpcEndpoint.networkClientId\n      ];\n    }\n  }\n\n  /**\n   * Updates `networkConfigurationsByChainId` in state depending on whether a\n   * network is being added, updated, or removed.\n   *\n   * - The existing network configuration will be removed when a network is\n   * being filed under a different chain or removed.\n   * - A network configuration will be stored when a network is being added or\n   * when a network is being updated.\n   *\n   * @param args - The arguments to this function.\n   */\n  #updateNetworkConfigurations(\n    args: { state: Draft<NetworkState> } & (\n      | {\n          mode: 'add';\n          networkFields: AddNetworkFields;\n          networkConfigurationToPersist: NetworkConfiguration;\n        }\n      | {\n          mode: 'update';\n          networkFields: UpdateNetworkFields;\n          networkConfigurationToPersist: NetworkConfiguration;\n          existingNetworkConfiguration: NetworkConfiguration;\n        }\n      | {\n          mode: 'remove';\n          existingNetworkConfiguration: NetworkConfiguration;\n        }\n    ),\n  ): void {\n    const { state, mode } = args;\n\n    if (\n      mode === 'remove' ||\n      (mode === 'update' &&\n        args.networkFields.chainId !==\n          args.existingNetworkConfiguration.chainId)\n    ) {\n      delete state.networkConfigurationsByChainId[\n        args.existingNetworkConfiguration.chainId\n      ];\n    }\n\n    if (mode === 'add' || mode === 'update') {\n      if (\n        !deepEqual(\n          state.networkConfigurationsByChainId[args.networkFields.chainId],\n          args.networkConfigurationToPersist,\n        )\n      ) {\n        args.networkConfigurationToPersist.lastUpdatedAt = Date.now();\n      }\n      state.networkConfigurationsByChainId[args.networkFields.chainId] =\n        args.networkConfigurationToPersist;\n    }\n\n    this.#networkConfigurationsByNetworkClientId =\n      buildNetworkConfigurationsByNetworkClientId(\n        cloneDeep(state.networkConfigurationsByChainId),\n      );\n  }\n\n  /**\n   * Before accessing or switching the network, the registry of network clients\n   * needs to be populated. Otherwise, `#applyNetworkSelection` and\n   * `getNetworkClientRegistry` will throw an error. This method checks to see if the\n   * population step has happened yet, and if not, makes it happen.\n   *\n   * @returns The populated network client registry.\n   */\n  #ensureAutoManagedNetworkClientRegistryPopulated(): AutoManagedNetworkClientRegistry {\n    return (this.#autoManagedNetworkClientRegistry ??=\n      this.#createAutoManagedNetworkClientRegistry());\n  }\n\n  /**\n   * Constructs the registry of network clients based on the set of default\n   * and custom networks in state.\n   *\n   * @returns The network clients keyed by ID.\n   */\n  #createAutoManagedNetworkClientRegistry(): AutoManagedNetworkClientRegistry {\n    const chainIds = knownKeysOf(this.state.networkConfigurationsByChainId);\n    const networkClientsWithIds = chainIds.flatMap((chainId) => {\n      const networkConfiguration =\n        this.state.networkConfigurationsByChainId[chainId];\n      return networkConfiguration.rpcEndpoints.map((rpcEndpoint) => {\n        if (rpcEndpoint.type === RpcEndpointType.Infura) {\n          const infuraNetworkName = deriveInfuraNetworkNameFromRpcEndpointUrl(\n            rpcEndpoint.url,\n          );\n          return [\n            rpcEndpoint.networkClientId,\n            createAutoManagedNetworkClient({\n              networkClientId: rpcEndpoint.networkClientId,\n              networkClientConfiguration: {\n                type: NetworkClientType.Infura,\n                network: infuraNetworkName,\n                failoverRpcUrls: rpcEndpoint.failoverUrls,\n                infuraProjectId: this.#infuraProjectId,\n                chainId: networkConfiguration.chainId,\n                ticker: networkConfiguration.nativeCurrency,\n              },\n              getRpcServiceOptions: this.#getRpcServiceOptions,\n              getBlockTrackerOptions: this.#getBlockTrackerOptions,\n              messenger: this.messenger,\n              isRpcFailoverEnabled: this.#isRpcFailoverEnabled,\n              logger: this.#log,\n            }),\n          ] as const;\n        }\n        return [\n          rpcEndpoint.networkClientId,\n          createAutoManagedNetworkClient({\n            networkClientId: rpcEndpoint.networkClientId,\n            networkClientConfiguration: {\n              type: NetworkClientType.Custom,\n              chainId: networkConfiguration.chainId,\n              failoverRpcUrls: rpcEndpoint.failoverUrls,\n              rpcUrl: rpcEndpoint.url,\n              ticker: networkConfiguration.nativeCurrency,\n            },\n            getRpcServiceOptions: this.#getRpcServiceOptions,\n            getBlockTrackerOptions: this.#getBlockTrackerOptions,\n            messenger: this.messenger,\n            isRpcFailoverEnabled: this.#isRpcFailoverEnabled,\n            logger: this.#log,\n          }),\n        ] as const;\n      });\n    });\n\n    return networkClientsWithIds.reduce(\n      (\n        obj: {\n          [NetworkClientType.Custom]: Partial<AutoManagedCustomNetworkClientRegistry>;\n          [NetworkClientType.Infura]: Partial<AutoManagedBuiltInNetworkClientRegistry>;\n        },\n        [networkClientId, networkClient],\n      ) => {\n        return {\n          ...obj,\n          [networkClient.configuration.type]: {\n            ...obj[networkClient.configuration.type],\n            [networkClientId]: networkClient,\n          },\n        };\n      },\n      {\n        [NetworkClientType.Custom]: {},\n        [NetworkClientType.Infura]: {},\n      },\n    ) as AutoManagedNetworkClientRegistry;\n  }\n\n  /**\n   * Updates the global provider and block tracker proxies (accessible via\n   * {@link getSelectedNetworkClient}) to point to the same ones within the\n   * given network client, thereby magically switching any consumers using these\n   * proxies to use the new network.\n   *\n   * Also refreshes the EthQuery instance accessible via the `getEthQuery`\n   * action to wrap the provider from the new network client. Note that this is\n   * not a proxy, so consumers will need to call `getEthQuery` again after the\n   * network switch.\n   *\n   * @param networkClientId - The ID of a network client that requests will be\n   * routed through (either the name of an Infura network or the ID of a custom\n   * network configuration).\n   * @param options - Options for this method.\n   * @param options.updateState - Allows for updating state.\n   * @throws if no network client could be found matching the given ID.\n   */\n  #applyNetworkSelection(\n    networkClientId: string,\n    {\n      updateState,\n    }: {\n      updateState?: (state: Draft<NetworkState>) => void;\n    } = {},\n  ): void {\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    let autoManagedNetworkClient:\n      | AutoManagedNetworkClient<CustomNetworkClientConfiguration>\n      | AutoManagedNetworkClient<InfuraNetworkClientConfiguration>;\n\n    if (isInfuraNetworkType(networkClientId)) {\n      const possibleAutoManagedNetworkClient =\n        autoManagedNetworkClientRegistry[NetworkClientType.Infura][\n          networkClientId\n        ];\n\n      // This is impossible to reach\n      /* istanbul ignore if */\n      if (!possibleAutoManagedNetworkClient) {\n        throw new Error(\n          `No Infura network client found with ID '${networkClientId}'`,\n        );\n      }\n\n      autoManagedNetworkClient = possibleAutoManagedNetworkClient;\n    } else {\n      const possibleAutoManagedNetworkClient =\n        autoManagedNetworkClientRegistry[NetworkClientType.Custom][\n          networkClientId\n        ];\n\n      if (!possibleAutoManagedNetworkClient) {\n        throw new Error(`No network client found with ID '${networkClientId}'`);\n      }\n\n      autoManagedNetworkClient = possibleAutoManagedNetworkClient;\n    }\n\n    this.#autoManagedNetworkClient = autoManagedNetworkClient;\n\n    this.update((state) => {\n      state.selectedNetworkClientId = networkClientId;\n      state.networksMetadata[networkClientId] ??= {\n        status: NetworkStatus.Unknown,\n        EIPS: {},\n      };\n\n      updateState?.(state);\n    });\n\n    if (this.#providerProxy) {\n      this.#providerProxy.setTarget(this.#autoManagedNetworkClient.provider);\n    } else {\n      this.#providerProxy = createSwappableProxy(\n        this.#autoManagedNetworkClient.provider,\n      );\n    }\n\n    if (this.#blockTrackerProxy) {\n      this.#blockTrackerProxy.setTarget(\n        this.#autoManagedNetworkClient.blockTracker,\n      );\n    } else {\n      this.#blockTrackerProxy = createEventEmitterProxy(\n        this.#autoManagedNetworkClient.blockTracker,\n        {\n          eventFilter: 'skipInternal',\n        },\n      );\n    }\n\n    this.#ethQuery = new EthQuery(this.#providerProxy);\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"NetworkController.mjs","sourceRoot":"","sources":["../src/NetworkController.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport type { Partialize } from '@metamask/controller-utils';\nimport {\n  InfuraNetworkType,\n  CustomNetworkType,\n  NetworkType,\n  isSafeChainId,\n  isInfuraNetworkType,\n  ChainId,\n  NetworksTicker,\n  NetworkNickname,\n  BUILT_IN_CUSTOM_NETWORKS_RPC,\n  BUILT_IN_NETWORKS,\n  BuiltInNetworkName,\n} from '@metamask/controller-utils';\nimport type { PollingBlockTrackerOptions } from '@metamask/eth-block-tracker';\nimport EthQuery from '@metamask/eth-query';\nimport type { Messenger } from '@metamask/messenger';\nimport { errorCodes } from '@metamask/rpc-errors';\nimport {\n  createEventEmitterProxy,\n  createSwappableProxy,\n} from '@metamask/swappable-obj-proxy';\nimport type { SwappableProxy } from '@metamask/swappable-obj-proxy';\nimport type { Hex } from '@metamask/utils';\nimport { hasProperty, isPlainObject, isStrictHexString } from '@metamask/utils';\nimport deepEqual from 'fast-deep-equal';\nimport type { Draft } from 'immer';\nimport { produce } from 'immer';\nimport { cloneDeep } from 'lodash';\nimport type { Logger } from 'loglevel';\nimport { createSelector } from 'reselect';\nimport * as URI from 'uri-js';\nimport { v4 as uuidV4 } from 'uuid';\n\nimport {\n  DEPRECATED_NETWORKS,\n  INFURA_BLOCKED_KEY,\n  NetworkStatus,\n} from './constants';\nimport type {\n  AutoManagedNetworkClient,\n  ProxyWithAccessibleTarget,\n} from './create-auto-managed-network-client';\nimport { createAutoManagedNetworkClient } from './create-auto-managed-network-client';\nimport { projectLogger, createModuleLogger } from './logger';\nimport type { RpcServiceOptions } from './rpc-service/rpc-service';\nimport { NetworkClientType } from './types';\nimport type {\n  BlockTracker,\n  Provider,\n  CustomNetworkClientConfiguration,\n  InfuraNetworkClientConfiguration,\n  NetworkClientConfiguration,\n  AdditionalDefaultNetwork,\n} from './types';\n\nconst debugLog = createModuleLogger(projectLogger, 'NetworkController');\n\nconst INFURA_URL_REGEX =\n  /^https:\\/\\/(?<networkName>[^.]+)\\.infura\\.io\\/v\\d+\\/(?<apiKey>.+)$/u;\n\nexport type Block = {\n  baseFeePerGas?: string;\n};\n\n/**\n * Information about a network not held by any other part of state.\n */\nexport type NetworkMetadata = {\n  /**\n   * EIPs supported by the network.\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  EIPS: {\n    [eipNumber: number]: boolean;\n  };\n  /**\n   * Indicates the availability of the network\n   */\n  status: NetworkStatus;\n};\n\n/**\n * The type of an RPC endpoint.\n *\n * @see {@link CustomRpcEndpoint}\n * @see {@link InfuraRpcEndpoint}\n */\nexport enum RpcEndpointType {\n  Custom = 'custom',\n  Infura = 'infura',\n}\n\n/**\n * An Infura RPC endpoint is a reference to a specific network that Infura\n * supports as well as an Infura account we own that we allow users to make use\n * of for free. We need to disambiguate these endpoints from custom RPC\n * endpoints, because while the types for these kinds of object both have the\n * same interface, the URL for an Infura endpoint contains the Infura project\n * ID, and we don't want this to be present in state. We therefore hide it by\n * representing it in the URL as `{infuraProjectId}`, which we replace this when\n * create network clients. But we need to know somehow that we only need to do\n * this replacement for Infura endpoints and not custom endpoints â€” hence the\n * separate type.\n */\nexport type InfuraRpcEndpoint = {\n  /**\n   * Alternate RPC endpoints to use when this endpoint is down.\n   */\n  failoverUrls?: string[];\n  /**\n   * The optional user-facing nickname of the endpoint.\n   */\n  name?: string;\n  /**\n   * The identifier for the network client that has been created for this RPC\n   * endpoint. This is also used to uniquely identify the RPC endpoint in a\n   * set of RPC endpoints as well: once assigned, it is used to determine\n   * whether the `name`, `type`, or `url` of the RPC endpoint has changed.\n   */\n  networkClientId: BuiltInNetworkClientId;\n  /**\n   * The type of this endpoint, always \"default\".\n   */\n  type: RpcEndpointType.Infura;\n  /**\n   * The URL of the endpoint. Expected to be a template with the string\n   * `{infuraProjectId}`, which will get replaced with the Infura project ID\n   * when the network client is created.\n   */\n  url: `https://${InfuraNetworkType}.infura.io/v3/{infuraProjectId}`;\n};\n\n/**\n * A custom RPC endpoint is a reference to a user-defined server which fronts an\n * EVM chain. It may refer to an Infura network, but only by coincidence.\n */\nexport type CustomRpcEndpoint = {\n  /**\n   * Alternate RPC endpoints to use when this endpoint is down.\n   */\n  failoverUrls?: string[];\n  /**\n   * The optional user-facing nickname of the endpoint.\n   */\n  name?: string;\n  /**\n   * The identifier for the network client that has been created for this RPC\n   * endpoint. This is also used to uniquely identify the RPC endpoint in a\n   * set of RPC endpoints as well: once assigned, it is used to determine\n   * whether the `name`, `type`, or `url` of the RPC endpoint has changed.\n   */\n  networkClientId: CustomNetworkClientId;\n  /**\n   * The type of this endpoint, always \"custom\".\n   */\n  type: RpcEndpointType.Custom;\n  /**\n   * The URL of the endpoint.\n   */\n  url: string;\n};\n\n/**\n * An RPC endpoint is a reference to a server which fronts an EVM chain. There\n * are two varieties of RPC endpoints: Infura and custom.\n *\n * @see {@link CustomRpcEndpoint}\n * @see {@link InfuraRpcEndpoint}\n */\nexport type RpcEndpoint = InfuraRpcEndpoint | CustomRpcEndpoint;\n\n/**\n * From a user perspective, a network configuration holds information about a\n * network that a user can select through the client. A \"network\" in this sense\n * can explicitly refer to an EVM chain that the user explicitly adds or doesn't\n * need to add (because it comes shipped with the client). The properties here\n * therefore directly map to fields that a user sees and can edit for a network\n * within the client.\n *\n * Internally, a network configuration represents a single conceptual EVM chain,\n * which is represented tangibly via multiple RPC endpoints. A \"network\" is then\n * something for which a network client object is created automatically or\n * created on demand when it is added to the client.\n */\nexport type NetworkConfiguration = {\n  /**\n   * A set of URLs that allows the user to view activity that has occurred on\n   * the chain.\n   */\n  blockExplorerUrls: string[];\n  /**\n   * The ID of the chain. Represented in hexadecimal format with a leading \"0x\"\n   * instead of decimal format so that when viewed out of context it can be\n   * unambiguously interpreted.\n   */\n  chainId: Hex;\n  /**\n   * A reference to a URL that the client will use by default to allow the user\n   * to view activity that has occurred on the chain. This index must refer to\n   * an item in `blockExplorerUrls`.\n   */\n  defaultBlockExplorerUrlIndex?: number;\n  /**\n   * A reference to an RPC endpoint that all requests will use by default in order to\n   * interact with the chain. This index must refer to an item in\n   * `rpcEndpoints`.\n   */\n  defaultRpcEndpointIndex: number;\n  /**\n   * The user-facing nickname assigned to the chain.\n   */\n  name: string;\n  /**\n   * The name of the currency to use for the chain.\n   */\n  nativeCurrency: string;\n  /**\n   * The collection of possible RPC endpoints that the client can use to\n   * interact with the chain.\n   */\n  rpcEndpoints: RpcEndpoint[];\n  /**\n   * Profile Sync - Network Sync field.\n   * Allows comparison of local network state with state to sync.\n   */\n  lastUpdatedAt?: number;\n};\n\n/**\n * A custom RPC endpoint in a new network configuration, meant to be used in\n * conjunction with `AddNetworkFields`.\n *\n * Custom RPC endpoints do not need a `networkClientId` property because it is\n * assumed that they have not already been added and therefore network clients\n * do not exist for them yet (and hence IDs need to be generated).\n */\nexport type AddNetworkCustomRpcEndpointFields = Omit<\n  CustomRpcEndpoint,\n  'networkClientId'\n>;\n\n/**\n * A new network configuration that `addNetwork` takes.\n *\n * Custom RPC endpoints do not need a `networkClientId` property because it is\n * assumed that they have not already been added and are not represented by\n * network clients yet.\n */\nexport type AddNetworkFields = Omit<NetworkConfiguration, 'rpcEndpoints'> & {\n  rpcEndpoints: (InfuraRpcEndpoint | AddNetworkCustomRpcEndpointFields)[];\n};\n\n/**\n * A custom RPC endpoint in an updated representation of a network\n * configuration, meant to be used in conjunction with `UpdateNetworkFields`.\n *\n * Custom RPC endpoints do not need a `networkClientId` property because it is\n * assumed that they have not already been added and therefore network clients\n * do not exist for them yet (and hence IDs need to be generated).\n */\nexport type UpdateNetworkCustomRpcEndpointFields = Partialize<\n  CustomRpcEndpoint,\n  'networkClientId'\n>;\n\n/**\n * An updated representation of an existing network configuration that\n * `updateNetwork` takes.\n *\n * Custom RPC endpoints may or may not have a `networkClientId` property; if\n * they do, then it is assumed that they already exist, and if not, then it is\n * assumed that they are new and are not represented by network clients yet.\n */\nexport type UpdateNetworkFields = Omit<NetworkConfiguration, 'rpcEndpoints'> & {\n  rpcEndpoints: (InfuraRpcEndpoint | UpdateNetworkCustomRpcEndpointFields)[];\n};\n\n/**\n * `Object.keys()` is intentionally generic: it returns the keys of an object,\n * but it cannot make guarantees about the contents of that object, so the type\n * of the keys is merely `string[]`. While this is technically accurate, it is\n * also unnecessary if we have an object that we own and whose contents are\n * known exactly.\n *\n * TODO: Move to @metamask/utils.\n *\n * @param object - The object.\n * @returns The keys of an object, typed according to the type of the object\n * itself.\n */\nexport function knownKeysOf<Key extends PropertyKey>(\n  // TODO: Replace `any` with type\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  object: Partial<Record<Key, any>>,\n): Key[] {\n  return Object.keys(object) as Key[];\n}\n\n/**\n * Type guard for determining whether the given value is an error object with a\n * `code` property, such as an instance of Error.\n *\n * TODO: Move this to @metamask/utils.\n *\n * @param error - The object to check.\n * @returns True if `error` has a `code`, false otherwise.\n */\nfunction isErrorWithCode(error: unknown): error is { code: string | number } {\n  return typeof error === 'object' && error !== null && 'code' in error;\n}\n\n/**\n * The string that uniquely identifies an Infura network client.\n */\nexport type BuiltInNetworkClientId = InfuraNetworkType;\n\n/**\n * The string that uniquely identifies a custom network client.\n */\nexport type CustomNetworkClientId = string;\n\n/**\n * The string that uniquely identifies a network client.\n */\nexport type NetworkClientId = BuiltInNetworkClientId | CustomNetworkClientId;\n\n/**\n * Extra information about each network, such as whether it is accessible or\n * blocked and whether it supports EIP-1559, keyed by network client ID.\n */\nexport type NetworksMetadata = Record<NetworkClientId, NetworkMetadata>;\n\n/**\n * The state that NetworkController stores.\n */\nexport type NetworkState = {\n  /**\n   * The ID of the network client that the proxies returned by\n   * `getSelectedNetworkClient` currently point to.\n   */\n  selectedNetworkClientId: NetworkClientId;\n  /**\n   * The registry of networks and corresponding RPC endpoints that the\n   * controller can use to make requests for various chains.\n   *\n   * @see {@link NetworkConfiguration}\n   */\n  networkConfigurationsByChainId: Record<Hex, NetworkConfiguration>;\n  /**\n   * Extra information about each network, such as whether it is accessible or\n   * blocked and whether it supports EIP-1559, keyed by network client ID.\n   */\n  networksMetadata: NetworksMetadata;\n};\n\nconst controllerName = 'NetworkController';\n\n/**\n * Represents the block tracker for the currently selected network. (Note that\n * this is a proxy around a proxy: the inner one exists so that the block\n * tracker doesn't have to exist until it's used, and the outer one exists so\n * that the currently selected network can change without consumers needing to\n * refresh the object reference to that network.)\n */\nexport type BlockTrackerProxy = SwappableProxy<\n  ProxyWithAccessibleTarget<BlockTracker>\n>;\n\n/**\n * Represents the provider for the currently selected network. (Note that this\n * is a proxy around a proxy: the inner one exists so that the provider doesn't\n * have to exist until it's used, and the outer one exists so that the currently\n * selected network can change without consumers needing to refresh the object\n * reference to that network.)\n */\nexport type ProviderProxy = SwappableProxy<ProxyWithAccessibleTarget<Provider>>;\n\nexport type NetworkControllerStateChangeEvent = ControllerStateChangeEvent<\n  typeof controllerName,\n  NetworkState\n>;\n\n/**\n * `networkWillChange` is published when the current network is about to be\n * switched, but the new provider has not been created and no state changes have\n * occurred yet.\n */\nexport type NetworkControllerNetworkWillChangeEvent = {\n  type: 'NetworkController:networkWillChange';\n  payload: [NetworkState];\n};\n\n/**\n * `networkDidChange` is published after a provider has been created for a newly\n * switched network (but before the network has been confirmed to be available).\n */\nexport type NetworkControllerNetworkDidChangeEvent = {\n  type: 'NetworkController:networkDidChange';\n  payload: [NetworkState];\n};\n\n/**\n * `infuraIsBlocked` is published after the network is switched to an Infura\n * network, but when Infura returns an error blocking the user based on their\n * location.\n */\nexport type NetworkControllerInfuraIsBlockedEvent = {\n  type: 'NetworkController:infuraIsBlocked';\n  payload: [];\n};\n\n/**\n * `infuraIsBlocked` is published either after the network is switched to an\n * Infura network and Infura does not return an error blocking the user based on\n * their location, or the network is switched to a non-Infura network.\n */\nexport type NetworkControllerInfuraIsUnblockedEvent = {\n  type: 'NetworkController:infuraIsUnblocked';\n  payload: [];\n};\n\n/**\n * `networkAdded` is published after a network configuration is added to the\n * network configuration registry and network clients are created for it.\n */\nexport type NetworkControllerNetworkAddedEvent = {\n  type: 'NetworkController:networkAdded';\n  payload: [networkConfiguration: NetworkConfiguration];\n};\n\n/**\n * `networkRemoved` is published after a network configuration is removed from the\n * network configuration registry and once the network clients have been removed.\n */\nexport type NetworkControllerNetworkRemovedEvent = {\n  type: 'NetworkController:networkRemoved';\n  payload: [networkConfiguration: NetworkConfiguration];\n};\n\n/**\n * `NetworkController:rpcEndpointChainUnavailable` is published when, after\n * trying all endpoints in an endpoint chain, the last failover reaches a\n * maximum number of consecutive 5xx responses, breaking the underlying circuit.\n *\n * In other words, this event will not be published if a failover is available,\n * even if the primary is not.\n *\n * @param payload - The event payload.\n * @param payload.chainId - The target network's chain ID.\n * @param payload.error - The last error produced by the last failover in the\n * endpoint chain.\n * @param payload.networkClientId - The target network's client ID.\n */\nexport type NetworkControllerRpcEndpointChainUnavailableEvent = {\n  type: 'NetworkController:rpcEndpointChainUnavailable';\n  payload: [\n    {\n      chainId: Hex;\n      error: unknown;\n      networkClientId: NetworkClientId;\n    },\n  ];\n};\n\n/**\n * `NetworkController:rpcEndpointUnavailable` is published when any\n * endpoint in an endpoint chain reaches a maximum number of consecutive 5xx\n * responses, breaking the underlying circuit.\n *\n * In other words, this event will be published if a primary is not available,\n * even if a failover is.\n *\n * @param payload - The event payload.\n * @param payload.chainId - The target network's chain ID.\n * @param payload.endpointUrl - The URL of the endpoint which reached the\n * maximum number of consecutive 5xx responses. You can compare this to\n * `primaryEndpointUrl` to know whether it was a failover or a primary.\n * @param payload.error - The last error produced by the endpoint.\n * @param payload.networkClientId - The target network's client ID.\n * @param payload.primaryEndpointUrl - The endpoint chain's primary URL.\n */\nexport type NetworkControllerRpcEndpointUnavailableEvent = {\n  type: 'NetworkController:rpcEndpointUnavailable';\n  payload: [\n    {\n      chainId: Hex;\n      endpointUrl: string;\n      error: unknown;\n      networkClientId: NetworkClientId;\n      primaryEndpointUrl: string;\n    },\n  ];\n};\n\n/**\n * `NetworkController:rpcEndpointChainDegraded` is published for any of the\n * endpoints in an endpoint chain when one of the following two conditions hold\n * (and the chain is not already in a degraded state):\n *\n * 1. A successful (2xx) request, even after being retried, cannot be made to\n * the endpoint.\n * 2. A successful (2xx) request can be made to the endpoint, but it takes\n * longer than expected to complete.\n *\n * Note that this event will be published even if there are local connectivity\n * issues which prevent requests from being initiated. This is intentional.\n *\n * @param payload - The event payload.\n * @param payload.chainId - The target network's chain ID.\n * @param payload.error - The last error produced by the endpoint (or\n * `undefined` if the request was slow).\n * @param payload.networkClientId - The target network's client ID.\n */\nexport type NetworkControllerRpcEndpointChainDegradedEvent = {\n  type: 'NetworkController:rpcEndpointChainDegraded';\n  payload: [\n    {\n      chainId: Hex;\n      error: unknown;\n      networkClientId: NetworkClientId;\n    },\n  ];\n};\n\n/**\n *\n * `NetworkController:rpcEndpointDegraded` is published for any of the endpoints\n * in an endpoint chain when:\n *\n * 1. A successful (2xx) request, even after being retried, cannot be made to\n * the endpoint.\n * 2. A successful (2xx) request can be made to the endpoint, but it takes\n * longer than expected to complete.\n *\n * Note that this event will be published even if there are local connectivity\n * issues which prevent requests from being initiated. This is intentional.\n *\n * @param payload - The event payload.\n * @param payload.chainId - The target network's chain ID.\n * @param payload.endpointUrl - The URL of the endpoint for which requests\n * failed or were slow to complete. You can compare this to `primaryEndpointUrl`\n * to know whether it was a failover or a primary.\n * @param payload.error - The last error produced by the endpoint (or\n * `undefined` if the request was slow).\n * @param payload.networkClientId - The target network's client ID.\n * @param payload.primaryEndpointUrl - The endpoint chain's primary URL.\n */\nexport type NetworkControllerRpcEndpointDegradedEvent = {\n  type: 'NetworkController:rpcEndpointDegraded';\n  payload: [\n    {\n      chainId: Hex;\n      endpointUrl: string;\n      error: unknown;\n      networkClientId: NetworkClientId;\n      primaryEndpointUrl: string;\n    },\n  ];\n};\n\n/**\n * `NetworkController:rpcEndpointChainAvailable` is published in one of two\n * cases:\n *\n * 1. The first time that a 2xx request is made to any of the endpoints in an\n * endpoint chain.\n * 2. When requests to any of the endpoints previously failed (placing the\n * endpoint in a degraded or unavailable status), but are now succeeding again.\n *\n * @param payload - The event payload.\n * @param payload.chainId - The target network's chain ID.\n * @param payload.networkClientId - The target network's client ID.\n */\nexport type NetworkControllerRpcEndpointChainAvailableEvent = {\n  type: 'NetworkController:rpcEndpointChainAvailable';\n  payload: [\n    {\n      chainId: Hex;\n      networkClientId: NetworkClientId;\n    },\n  ];\n};\n\n/**\n * `NetworkController:rpcEndpointRetried` is published before a request to any\n * endpoint in an endpoint chain is retried.\n *\n * This is mainly useful for tests.\n *\n * @param payload - The event payload.\n * @param payload.attempt - The current attempt counter for the endpoint\n * (starting from 0).\n * @param payload.chainId - The target network's chain ID.\n * @param payload.endpointUrl - The URL of the endpoint being retried.\n * @param payload.networkClientId - The target network's client ID.\n * @param payload.primaryEndpointUrl - The endpoint chain's primary URL.\n * @see {@link RpcService} for the list of retriable errors.\n */\nexport type NetworkControllerRpcEndpointRetriedEvent = {\n  type: 'NetworkController:rpcEndpointRetried';\n  payload: [\n    {\n      attempt: number;\n      chainId: Hex;\n      endpointUrl: string;\n      networkClientId: NetworkClientId;\n      primaryEndpointUrl: string;\n    },\n  ];\n};\n\nexport type NetworkControllerEvents =\n  | NetworkControllerStateChangeEvent\n  | NetworkControllerNetworkWillChangeEvent\n  | NetworkControllerNetworkDidChangeEvent\n  | NetworkControllerInfuraIsBlockedEvent\n  | NetworkControllerInfuraIsUnblockedEvent\n  | NetworkControllerNetworkAddedEvent\n  | NetworkControllerNetworkRemovedEvent\n  | NetworkControllerRpcEndpointChainUnavailableEvent\n  | NetworkControllerRpcEndpointUnavailableEvent\n  | NetworkControllerRpcEndpointChainDegradedEvent\n  | NetworkControllerRpcEndpointDegradedEvent\n  | NetworkControllerRpcEndpointChainAvailableEvent\n  | NetworkControllerRpcEndpointRetriedEvent;\n\n/**\n * All events that {@link NetworkController} calls internally.\n */\ntype AllowedEvents = never;\n\nexport type NetworkControllerGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  NetworkState\n>;\n\nexport type NetworkControllerGetEthQueryAction = {\n  type: `NetworkController:getEthQuery`;\n  handler: () => EthQuery | undefined;\n};\n\nexport type NetworkControllerGetNetworkClientByIdAction = {\n  type: `NetworkController:getNetworkClientById`;\n  handler: NetworkController['getNetworkClientById'];\n};\n\nexport type NetworkControllerGetSelectedNetworkClientAction = {\n  type: `NetworkController:getSelectedNetworkClient`;\n  handler: NetworkController['getSelectedNetworkClient'];\n};\n\nexport type NetworkControllerGetSelectedChainIdAction = {\n  type: 'NetworkController:getSelectedChainId';\n  handler: NetworkController['getSelectedChainId'];\n};\n\nexport type NetworkControllerGetEIP1559CompatibilityAction = {\n  type: `NetworkController:getEIP1559Compatibility`;\n  handler: NetworkController['getEIP1559Compatibility'];\n};\n\nexport type NetworkControllerFindNetworkClientIdByChainIdAction = {\n  type: `NetworkController:findNetworkClientIdByChainId`;\n  handler: NetworkController['findNetworkClientIdByChainId'];\n};\n\n/**\n * Change the currently selected network to the given built-in network type.\n *\n * @deprecated This action has been replaced by `setActiveNetwork`, and will be\n * removed in a future release.\n */\nexport type NetworkControllerSetProviderTypeAction = {\n  type: `NetworkController:setProviderType`;\n  handler: NetworkController['setProviderType'];\n};\n\nexport type NetworkControllerSetActiveNetworkAction = {\n  type: `NetworkController:setActiveNetwork`;\n  handler: NetworkController['setActiveNetwork'];\n};\n\nexport type NetworkControllerGetNetworkConfigurationByChainId = {\n  type: `NetworkController:getNetworkConfigurationByChainId`;\n  handler: NetworkController['getNetworkConfigurationByChainId'];\n};\n\nexport type NetworkControllerGetNetworkConfigurationByNetworkClientId = {\n  type: `NetworkController:getNetworkConfigurationByNetworkClientId`;\n  handler: NetworkController['getNetworkConfigurationByNetworkClientId'];\n};\n\nexport type NetworkControllerAddNetworkAction = {\n  type: 'NetworkController:addNetwork';\n  handler: NetworkController['addNetwork'];\n};\n\nexport type NetworkControllerRemoveNetworkAction = {\n  type: 'NetworkController:removeNetwork';\n  handler: NetworkController['removeNetwork'];\n};\n\nexport type NetworkControllerUpdateNetworkAction = {\n  type: 'NetworkController:updateNetwork';\n  handler: NetworkController['updateNetwork'];\n};\n\nexport type NetworkControllerActions =\n  | NetworkControllerGetStateAction\n  | NetworkControllerGetEthQueryAction\n  | NetworkControllerGetNetworkClientByIdAction\n  | NetworkControllerGetSelectedNetworkClientAction\n  | NetworkControllerGetSelectedChainIdAction\n  | NetworkControllerGetEIP1559CompatibilityAction\n  | NetworkControllerFindNetworkClientIdByChainIdAction\n  | NetworkControllerSetActiveNetworkAction\n  | NetworkControllerSetProviderTypeAction\n  | NetworkControllerGetNetworkConfigurationByChainId\n  | NetworkControllerGetNetworkConfigurationByNetworkClientId\n  | NetworkControllerAddNetworkAction\n  | NetworkControllerRemoveNetworkAction\n  | NetworkControllerUpdateNetworkAction;\n\n/**\n * All actions that {@link NetworkController} calls internally.\n */\ntype AllowedActions = never;\n\nexport type NetworkControllerMessenger = Messenger<\n  typeof controllerName,\n  NetworkControllerActions | AllowedActions,\n  NetworkControllerEvents | AllowedEvents\n>;\n\n/**\n * Options for the NetworkController constructor.\n */\nexport type NetworkControllerOptions = {\n  /**\n   * The messenger suited for this controller.\n   */\n  messenger: NetworkControllerMessenger;\n  /**\n   * The API key for Infura, used to make requests to Infura.\n   */\n  infuraProjectId: string;\n  /**\n   * The desired state with which to initialize this controller.\n   * Missing properties will be filled in with defaults. For instance, if not\n   * specified, `networkConfigurationsByChainId` will default to a basic set of\n   * network configurations (see {@link InfuraNetworkType} for the list).\n   */\n  state?: Partial<NetworkState>;\n  /**\n   * A `loglevel` logger object.\n   */\n  log?: Logger;\n  /**\n   * A function that can be used to customize a RPC service constructed for an\n   * RPC endpoint. The function takes the URL of the endpoint and should return\n   * an object with type {@link RpcServiceOptions}, minus `failoverService`\n   * and `endpointUrl` (as they are filled in automatically).\n   */\n  getRpcServiceOptions: (\n    rpcEndpointUrl: string,\n  ) => Omit<RpcServiceOptions, 'failoverService' | 'endpointUrl'>;\n  /**\n   * A function that can be used to customize a block tracker constructed for an\n   * RPC endpoint. The function takes the URL of the endpoint and should return\n   * an object of type {@link PollingBlockTrackerOptions}, minus `provider` (as\n   * it is filled in automatically).\n   */\n  getBlockTrackerOptions?: (\n    rpcEndpointUrl: string,\n  ) => Omit<PollingBlockTrackerOptions, 'provider'>;\n  /**\n   * An array of Hex Chain IDs representing the additional networks to be included as default.\n   */\n  additionalDefaultNetworks?: AdditionalDefaultNetwork[];\n  /**\n   * Whether or not requests sent to unavailable RPC endpoints should be\n   * automatically diverted to configured failover RPC endpoints.\n   */\n  isRpcFailoverEnabled?: boolean;\n};\n\n/**\n * Constructs a value for the state property `networkConfigurationsByChainId`\n * which will be used if it has not been provided to the constructor.\n *\n * @param [additionalDefaultNetworks] - An array of Hex Chain IDs representing the additional networks to be included as default.\n * @returns The default value for `networkConfigurationsByChainId`.\n */\nfunction getDefaultNetworkConfigurationsByChainId(\n  additionalDefaultNetworks: AdditionalDefaultNetwork[] = [],\n): Record<Hex, NetworkConfiguration> {\n  const infuraNetworks = getDefaultInfuraNetworkConfigurationsByChainId();\n  const customNetworks = getDefaultCustomNetworkConfigurationsByChainId();\n\n  return additionalDefaultNetworks.reduce<Record<Hex, NetworkConfiguration>>(\n    (obj, chainId) => {\n      if (hasProperty(customNetworks, chainId)) {\n        obj[chainId] = customNetworks[chainId];\n      }\n      return obj;\n    },\n    // Always include the infura networks in the default networks\n    infuraNetworks,\n  );\n}\n\n/**\n * Constructs a `networkConfigurationsByChainId` object for all default Infura networks.\n *\n * @returns The `networkConfigurationsByChainId` object of all Infura networks.\n */\nfunction getDefaultInfuraNetworkConfigurationsByChainId(): Record<\n  Hex,\n  NetworkConfiguration\n> {\n  return Object.values(InfuraNetworkType).reduce<\n    Record<Hex, NetworkConfiguration>\n  >((obj, infuraNetworkType) => {\n    const chainId = ChainId[infuraNetworkType];\n\n    // Skip deprecated network as default network.\n    if (DEPRECATED_NETWORKS.has(chainId)) {\n      return obj;\n    }\n\n    const rpcEndpointUrl =\n      `https://${infuraNetworkType}.infura.io/v3/{infuraProjectId}` as const;\n\n    const networkConfiguration: NetworkConfiguration = {\n      blockExplorerUrls: [],\n      chainId,\n      defaultRpcEndpointIndex: 0,\n      name: NetworkNickname[infuraNetworkType],\n      nativeCurrency: NetworksTicker[infuraNetworkType],\n      rpcEndpoints: [\n        {\n          failoverUrls: [],\n          networkClientId: infuraNetworkType,\n          type: RpcEndpointType.Infura,\n          url: rpcEndpointUrl,\n        },\n      ],\n    };\n\n    return { ...obj, [chainId]: networkConfiguration };\n  }, {});\n}\n\n/**\n * Constructs a `networkConfigurationsByChainId` object for all default custom networks.\n *\n * @returns The `networkConfigurationsByChainId` object of all custom networks.\n */\nfunction getDefaultCustomNetworkConfigurationsByChainId(): Record<\n  Hex,\n  NetworkConfiguration\n> {\n  // Create the `networkConfigurationsByChainId` objects explicitly,\n  // Because it is not always guaranteed that the custom networks are included in the\n  // default networks.\n  const configs = {\n    [ChainId['megaeth-testnet']]: getCustomNetworkConfiguration(\n      CustomNetworkType['megaeth-testnet'],\n    ),\n    [ChainId['megaeth-testnet-v2']]: getCustomNetworkConfiguration(\n      CustomNetworkType['megaeth-testnet-v2'],\n    ),\n    [ChainId['monad-testnet']]: getCustomNetworkConfiguration(\n      CustomNetworkType['monad-testnet'],\n    ),\n    // New additions for 20+ network performance testing\n    [ChainId[BuiltInNetworkName.FantomMainnet]]: getCustomNetworkConfiguration(\n      CustomNetworkType['fantom-mainnet'],\n    ),\n    [ChainId[BuiltInNetworkName.GnosisMainnet]]: getCustomNetworkConfiguration(\n      CustomNetworkType['gnosis-mainnet'],\n    ),\n    [ChainId[BuiltInNetworkName.CeloMainnet]]: getCustomNetworkConfiguration(\n      CustomNetworkType['celo-mainnet'],\n    ),\n    [ChainId[BuiltInNetworkName.CronosMainnet]]: getCustomNetworkConfiguration(\n      CustomNetworkType['cronos-mainnet'],\n    ),\n    [ChainId[BuiltInNetworkName.Aurora]]: getCustomNetworkConfiguration(\n      CustomNetworkType.aurora,\n    ),\n    [ChainId[BuiltInNetworkName.MoonbeamMainnet]]:\n      getCustomNetworkConfiguration(CustomNetworkType['moonbeam-mainnet']),\n    [ChainId[BuiltInNetworkName.MoonriverMainnet]]:\n      getCustomNetworkConfiguration(CustomNetworkType['moonriver-mainnet']),\n    [ChainId[BuiltInNetworkName.KlaytnMainnet]]: getCustomNetworkConfiguration(\n      CustomNetworkType['klaytn-mainnet'],\n    ),\n    [ChainId[BuiltInNetworkName.AvalancheMainnet]]:\n      getCustomNetworkConfiguration(CustomNetworkType['avalanche-mainnet']),\n    [ChainId[BuiltInNetworkName.ZkSyncEraMainnet]]:\n      getCustomNetworkConfiguration(CustomNetworkType['zksync-era-mainnet']),\n    [ChainId[BuiltInNetworkName.PalmMainnet]]: getCustomNetworkConfiguration(\n      CustomNetworkType['palm-mainnet'],\n    ),\n    [ChainId[BuiltInNetworkName.HyperEvmMainnet]]:\n      getCustomNetworkConfiguration(CustomNetworkType['hypervm-mainnet']),\n  };\n\n  console.log(\n    '[NetworkController] getDefaultCustomNetworkConfigurationsByChainId - returning',\n    Object.keys(configs).length,\n    'custom network configurations',\n  );\n  console.log(\n    '[NetworkController] Custom network chain IDs:',\n    Object.keys(configs),\n  );\n\n  return configs;\n}\n\n/**\n * Constructs a `NetworkConfiguration` object by `CustomNetworkType`.\n *\n * @param customNetworkType - The type of the custom network.\n * @returns The `NetworkConfiguration` object.\n */\nfunction getCustomNetworkConfiguration(\n  customNetworkType: CustomNetworkType,\n): NetworkConfiguration {\n  const { ticker, rpcPrefs } = BUILT_IN_NETWORKS[customNetworkType];\n  const rpcEndpointUrl = BUILT_IN_CUSTOM_NETWORKS_RPC[customNetworkType];\n\n  return {\n    blockExplorerUrls: [rpcPrefs.blockExplorerUrl],\n    chainId: ChainId[customNetworkType],\n    defaultRpcEndpointIndex: 0,\n    defaultBlockExplorerUrlIndex: 0,\n    name: NetworkNickname[customNetworkType],\n    nativeCurrency: ticker,\n    rpcEndpoints: [\n      {\n        failoverUrls: [],\n        networkClientId: customNetworkType,\n        type: RpcEndpointType.Custom,\n        url: rpcEndpointUrl,\n      },\n    ],\n  };\n}\n\n/**\n * Constructs properties for the NetworkController state whose values will be\n * used if not provided to the constructor.\n *\n * @param [additionalDefaultNetworks] - An array of Hex Chain IDs representing the additional networks to be included as default.\n * @returns The default NetworkController state.\n */\nexport function getDefaultNetworkControllerState(\n  additionalDefaultNetworks?: AdditionalDefaultNetwork[],\n): NetworkState {\n  const networksMetadata = {};\n  const networkConfigurationsByChainId =\n    getDefaultNetworkConfigurationsByChainId(additionalDefaultNetworks);\n\n  return {\n    selectedNetworkClientId: InfuraNetworkType.mainnet,\n    networksMetadata,\n    networkConfigurationsByChainId,\n  };\n}\n\n/**\n * Redux selector for getting all network configurations from NetworkController\n * state, keyed by chain ID.\n *\n * @param state - NetworkController state\n * @returns All registered network configurations, keyed by chain ID.\n */\nconst selectNetworkConfigurationsByChainId = (\n  state: NetworkState,\n): Record<`0x${string}`, NetworkConfiguration> =>\n  state.networkConfigurationsByChainId;\n\n/**\n * Get a list of all network configurations.\n *\n * @param state - NetworkController state\n * @returns A list of all available network configurations\n */\nexport function getNetworkConfigurations(\n  state: NetworkState,\n): NetworkConfiguration[] {\n  return Object.values(state.networkConfigurationsByChainId);\n}\n\n/**\n * Redux selector for getting a list of all network configurations from\n * NetworkController state.\n *\n * @param state - NetworkController state\n * @returns A list of all available network configurations\n */\nexport const selectNetworkConfigurations = createSelector(\n  selectNetworkConfigurationsByChainId,\n  (networkConfigurationsByChainId) =>\n    Object.values(networkConfigurationsByChainId),\n);\n\n/**\n * Get a list of all available network client IDs from a list of network\n * configurations.\n *\n * @param networkConfigurations - The array of network configurations\n * @returns A list of all available client IDs\n */\nexport function getAvailableNetworkClientIds(\n  networkConfigurations: NetworkConfiguration[],\n): string[] {\n  return networkConfigurations.flatMap((networkConfiguration) =>\n    networkConfiguration.rpcEndpoints.map(\n      (rpcEndpoint) => rpcEndpoint.networkClientId,\n    ),\n  );\n}\n\n/**\n * Redux selector for getting a list of all available network client IDs\n * from NetworkController state.\n *\n * @param state - NetworkController state\n * @returns A list of all available network client IDs.\n */\nexport const selectAvailableNetworkClientIds = createSelector(\n  selectNetworkConfigurations,\n  getAvailableNetworkClientIds,\n);\n\n/**\n * The collection of auto-managed network clients that map to Infura networks.\n */\nexport type AutoManagedBuiltInNetworkClientRegistry = Record<\n  BuiltInNetworkClientId,\n  AutoManagedNetworkClient<InfuraNetworkClientConfiguration>\n>;\n\n/**\n * The collection of auto-managed network clients that map to Infura networks.\n */\nexport type AutoManagedCustomNetworkClientRegistry = Record<\n  CustomNetworkClientId,\n  AutoManagedNetworkClient<CustomNetworkClientConfiguration>\n>;\n\n/**\n * The collection of auto-managed network clients that map to Infura networks\n * as well as custom networks that users have added.\n */\nexport type AutoManagedNetworkClientRegistry = {\n  [NetworkClientType.Infura]: AutoManagedBuiltInNetworkClientRegistry;\n  [NetworkClientType.Custom]: AutoManagedCustomNetworkClientRegistry;\n};\n\n/**\n * Instructs `addNetwork` and `updateNetwork` to create a network client for an\n * RPC endpoint.\n *\n * @see {@link NetworkClientOperation}\n */\ntype AddNetworkClientOperation = {\n  type: 'add';\n  rpcEndpoint: RpcEndpoint;\n};\n\n/**\n * Instructs `updateNetwork` and `removeNetwork` to remove a network client for\n * an RPC endpoint.\n *\n * @see {@link NetworkClientOperation}\n */\ntype RemoveNetworkClientOperation = {\n  type: 'remove';\n  rpcEndpoint: RpcEndpoint;\n};\n\n/**\n * Instructs `addNetwork` and `updateNetwork` to replace the network client for\n * an RPC endpoint.\n *\n * @see {@link NetworkClientOperation}\n */\ntype ReplaceNetworkClientOperation = {\n  type: 'replace';\n  oldRpcEndpoint: RpcEndpoint;\n  newRpcEndpoint: RpcEndpoint;\n};\n\n/**\n * Instructs `addNetwork` and `updateNetwork` not to do anything with an RPC\n * endpoint, as far as the network client registry is concerned.\n *\n * @see {@link NetworkClientOperation}\n */\ntype NoopNetworkClientOperation = {\n  type: 'noop';\n  rpcEndpoint: RpcEndpoint;\n};\n\n/**\n * Instructs `addNetwork`, `updateNetwork`, and `removeNetwork` how to\n * update the network client registry.\n *\n * - When `addNetwork` is called, represents a network client that should be\n * created for a new RPC endpoint.\n * - When `removeNetwork` is called, represents a network client that should be\n * destroyed for a previously existing RPC endpoint.\n * - When `updateNetwork` is called, represents either:\n *   - a network client that should be added for a new RPC endpoint\n *   - a network client that should be removed for a previously existing RPC\n *   endpoint\n *   - a network client that should be replaced for an RPC endpoint that was\n *   changed in a non-major way, or\n *   - a network client that should be unchanged for an RPC endpoint that was\n *   also unchanged.\n */\ntype NetworkClientOperation =\n  | AddNetworkClientOperation\n  | RemoveNetworkClientOperation\n  | ReplaceNetworkClientOperation\n  | NoopNetworkClientOperation;\n\n/**\n * Determines whether the given URL is valid by attempting to parse it.\n *\n * @param url - The URL to test.\n * @returns True if the URL is valid, false otherwise.\n */\nfunction isValidUrl(url: string): boolean {\n  const uri = URI.parse(url);\n  return (\n    uri.error === undefined && (uri.scheme === 'http' || uri.scheme === 'https')\n  );\n}\n\n/**\n * Given an Infura API URL, extracts the subdomain that identifies the Infura\n * network.\n *\n * @param rpcEndpointUrl - The URL to operate on.\n * @returns The Infura network name that the URL references.\n * @throws if the URL is not an Infura API URL, or if an Infura network is not\n * present in the URL.\n */\nfunction deriveInfuraNetworkNameFromRpcEndpointUrl(\n  rpcEndpointUrl: string,\n): InfuraNetworkType {\n  const match = INFURA_URL_REGEX.exec(rpcEndpointUrl);\n\n  if (match?.groups) {\n    if (isInfuraNetworkType(match.groups.networkName)) {\n      return match.groups.networkName;\n    }\n\n    throw new Error(`Unknown Infura network '${match.groups.networkName}'`);\n  }\n\n  throw new Error('Could not derive Infura network from RPC endpoint URL');\n}\n\n/**\n * Performs a series of checks that the given NetworkController state is\n * internally consistent â€” that all parts of state that are supposed to match in\n * fact do â€” so that working with the state later on doesn't cause unexpected\n * errors.\n *\n * In the case of NetworkController, there are several parts of state that need\n * to match. For instance, `defaultRpcEndpointIndex` needs to match an entry\n * within `rpcEndpoints`, and `selectedNetworkClientId` needs to point to an RPC\n * endpoint within a network configuration.\n *\n * @param state - The NetworkController state to verify.\n * @throws if the state is invalid in some way.\n */\nfunction validateInitialState(state: NetworkState): void {\n  const networkConfigurationEntries = Object.entries(\n    state.networkConfigurationsByChainId,\n  );\n  const networkClientIds = getAvailableNetworkClientIds(\n    getNetworkConfigurations(state),\n  );\n\n  if (networkConfigurationEntries.length === 0) {\n    throw new Error(\n      'NetworkController state is invalid: `networkConfigurationsByChainId` cannot be empty',\n    );\n  }\n\n  for (const [chainId, networkConfiguration] of networkConfigurationEntries) {\n    if (chainId !== networkConfiguration.chainId) {\n      throw new Error(\n        `NetworkController state has invalid \\`networkConfigurationsByChainId\\`: Network configuration '${networkConfiguration.name}' is filed under '${chainId}' which does not match its \\`chainId\\` of '${networkConfiguration.chainId}'`,\n      );\n    }\n\n    const isInvalidDefaultBlockExplorerUrlIndex =\n      networkConfiguration.blockExplorerUrls.length > 0\n        ? networkConfiguration.defaultBlockExplorerUrlIndex === undefined ||\n          networkConfiguration.blockExplorerUrls[\n            networkConfiguration.defaultBlockExplorerUrlIndex\n          ] === undefined\n        : networkConfiguration.defaultBlockExplorerUrlIndex !== undefined;\n\n    if (isInvalidDefaultBlockExplorerUrlIndex) {\n      throw new Error(\n        `NetworkController state has invalid \\`networkConfigurationsByChainId\\`: Network configuration '${networkConfiguration.name}' has a \\`defaultBlockExplorerUrlIndex\\` that does not refer to an entry in \\`blockExplorerUrls\\``,\n      );\n    }\n\n    if (\n      networkConfiguration.rpcEndpoints[\n        networkConfiguration.defaultRpcEndpointIndex\n      ] === undefined\n    ) {\n      throw new Error(\n        `NetworkController state has invalid \\`networkConfigurationsByChainId\\`: Network configuration '${networkConfiguration.name}' has a \\`defaultRpcEndpointIndex\\` that does not refer to an entry in \\`rpcEndpoints\\``,\n      );\n    }\n  }\n\n  if ([...new Set(networkClientIds)].length < networkClientIds.length) {\n    throw new Error(\n      'NetworkController state has invalid `networkConfigurationsByChainId`: Every RPC endpoint across all network configurations must have a unique `networkClientId`',\n    );\n  }\n}\n\n/**\n * Checks that the given initial NetworkController state is internally\n * consistent similar to `validateInitialState`, but if an anomaly is detected,\n * it does its best to correct the state and logs an error to Sentry.\n *\n * @param state - The NetworkController state to verify.\n * @param messenger - The NetworkController messenger.\n * @returns The corrected state.\n */\nfunction correctInitialState(\n  state: NetworkState,\n  messenger: NetworkControllerMessenger,\n): NetworkState {\n  const networkConfigurationsSortedByChainId = getNetworkConfigurations(\n    state,\n  ).sort((a, b) => a.chainId.localeCompare(b.chainId));\n  const availableNetworkClientIds = getAvailableNetworkClientIds(\n    networkConfigurationsSortedByChainId,\n  );\n  const invalidNetworkClientIdsWithMetadata = Object.keys(\n    state.networksMetadata,\n  ).filter(\n    (networkClientId) => !availableNetworkClientIds.includes(networkClientId),\n  );\n\n  return produce(state, (newState) => {\n    if (!availableNetworkClientIds.includes(state.selectedNetworkClientId)) {\n      const firstNetworkConfiguration = networkConfigurationsSortedByChainId[0];\n      const newSelectedNetworkClientId =\n        firstNetworkConfiguration.rpcEndpoints[\n          firstNetworkConfiguration.defaultRpcEndpointIndex\n        ].networkClientId;\n      messenger.captureException?.(\n        new Error(\n          `\\`selectedNetworkClientId\\` '${state.selectedNetworkClientId}' does not refer to an RPC endpoint within a network configuration; correcting to '${newSelectedNetworkClientId}'`,\n        ),\n      );\n      newState.selectedNetworkClientId = newSelectedNetworkClientId;\n    }\n\n    if (invalidNetworkClientIdsWithMetadata.length > 0) {\n      for (const invalidNetworkClientId of invalidNetworkClientIdsWithMetadata) {\n        delete newState.networksMetadata[invalidNetworkClientId];\n      }\n      messenger.captureException?.(\n        new Error(\n          '`networksMetadata` had invalid network client IDs, which have been removed',\n        ),\n      );\n    }\n  });\n}\n\n/**\n * Transforms a map of chain ID to network configuration to a map of network\n * client ID to network configuration.\n *\n * @param networkConfigurationsByChainId - The network configurations, keyed by\n * chain ID.\n * @returns The network configurations, keyed by network client ID.\n */\nfunction buildNetworkConfigurationsByNetworkClientId(\n  networkConfigurationsByChainId: Record<Hex, NetworkConfiguration>,\n): Map<NetworkClientId, NetworkConfiguration> {\n  return new Map(\n    Object.values(networkConfigurationsByChainId).flatMap(\n      (networkConfiguration) => {\n        return networkConfiguration.rpcEndpoints.map((rpcEndpoint) => {\n          return [rpcEndpoint.networkClientId, networkConfiguration];\n        });\n      },\n    ),\n  );\n}\n\n/**\n * Controller that creates and manages an Ethereum network provider.\n */\nexport class NetworkController extends BaseController<\n  typeof controllerName,\n  NetworkState,\n  NetworkControllerMessenger\n> {\n  #ethQuery?: EthQuery;\n\n  readonly #infuraProjectId: string;\n\n  #previouslySelectedNetworkClientId: string;\n\n  #providerProxy: ProviderProxy | undefined;\n\n  #blockTrackerProxy: BlockTrackerProxy | undefined;\n\n  #autoManagedNetworkClientRegistry?: AutoManagedNetworkClientRegistry;\n\n  #autoManagedNetworkClient?:\n    | AutoManagedNetworkClient<CustomNetworkClientConfiguration>\n    | AutoManagedNetworkClient<InfuraNetworkClientConfiguration>;\n\n  readonly #log: Logger | undefined;\n\n  readonly #getRpcServiceOptions: NetworkControllerOptions['getRpcServiceOptions'];\n\n  readonly #getBlockTrackerOptions: NetworkControllerOptions['getBlockTrackerOptions'];\n\n  #networkConfigurationsByNetworkClientId: Map<\n    NetworkClientId,\n    NetworkConfiguration\n  >;\n\n  #isRpcFailoverEnabled: Exclude<\n    NetworkControllerOptions['isRpcFailoverEnabled'],\n    undefined\n  >;\n\n  /**\n   * Constructs a NetworkController.\n   *\n   * @param options - The options; see {@link NetworkControllerOptions}.\n   */\n  constructor(options: NetworkControllerOptions) {\n    const {\n      messenger,\n      state,\n      infuraProjectId,\n      log,\n      getRpcServiceOptions,\n      getBlockTrackerOptions,\n      additionalDefaultNetworks,\n      isRpcFailoverEnabled = false,\n    } = options;\n    const initialState = {\n      ...getDefaultNetworkControllerState(additionalDefaultNetworks),\n      ...state,\n    };\n    validateInitialState(initialState);\n    const correctedInitialState = correctInitialState(initialState, messenger);\n\n    if (!infuraProjectId || typeof infuraProjectId !== 'string') {\n      throw new Error('Invalid Infura project ID');\n    }\n\n    super({\n      name: controllerName,\n      metadata: {\n        selectedNetworkClientId: {\n          includeInStateLogs: true,\n          persist: true,\n          includeInDebugSnapshot: false,\n          usedInUi: true,\n        },\n        networksMetadata: {\n          includeInStateLogs: true,\n          persist: true,\n          includeInDebugSnapshot: false,\n          usedInUi: true,\n        },\n        networkConfigurationsByChainId: {\n          includeInStateLogs: true,\n          persist: true,\n          includeInDebugSnapshot: false,\n          usedInUi: true,\n        },\n      },\n      messenger,\n      state: correctedInitialState,\n    });\n\n    this.#infuraProjectId = infuraProjectId;\n    this.#log = log;\n    this.#getRpcServiceOptions = getRpcServiceOptions;\n    this.#getBlockTrackerOptions = getBlockTrackerOptions;\n    this.#isRpcFailoverEnabled = isRpcFailoverEnabled;\n\n    this.#previouslySelectedNetworkClientId =\n      this.state.selectedNetworkClientId;\n    this.#networkConfigurationsByNetworkClientId =\n      buildNetworkConfigurationsByNetworkClientId(\n        this.state.networkConfigurationsByChainId,\n      );\n\n    this.messenger.registerActionHandler(`${this.name}:getEthQuery`, () => {\n      return this.#ethQuery;\n    });\n\n    this.messenger.registerActionHandler(\n      `${this.name}:getNetworkClientById`,\n      this.getNetworkClientById.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${this.name}:getEIP1559Compatibility`,\n      this.getEIP1559Compatibility.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${this.name}:setActiveNetwork`,\n      this.setActiveNetwork.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${this.name}:setProviderType`,\n      this.setProviderType.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${this.name}:findNetworkClientIdByChainId`,\n      this.findNetworkClientIdByChainId.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${this.name}:getNetworkConfigurationByChainId`,\n      this.getNetworkConfigurationByChainId.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${this.name}:getNetworkConfigurationByNetworkClientId`,\n      this.getNetworkConfigurationByNetworkClientId.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${this.name}:getSelectedNetworkClient`,\n      this.getSelectedNetworkClient.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${this.name}:getSelectedChainId`,\n      this.getSelectedChainId.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${this.name}:addNetwork`,\n      this.addNetwork.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${this.name}:removeNetwork`,\n      this.removeNetwork.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${this.name}:updateNetwork`,\n      this.updateNetwork.bind(this),\n    );\n\n    this.messenger.subscribe(\n      `${this.name}:rpcEndpointChainUnavailable`,\n      ({ networkClientId }) => {\n        this.#updateMetadataForNetwork(networkClientId, {\n          networkStatus: NetworkStatus.Unavailable,\n        });\n      },\n    );\n    this.messenger.subscribe(\n      `${this.name}:rpcEndpointChainDegraded`,\n      ({ networkClientId }) => {\n        this.#updateMetadataForNetwork(networkClientId, {\n          networkStatus: NetworkStatus.Degraded,\n        });\n      },\n    );\n    this.messenger.subscribe(\n      `${this.name}:rpcEndpointChainAvailable`,\n      ({ networkClientId }) => {\n        this.#updateMetadataForNetwork(networkClientId, {\n          networkStatus: NetworkStatus.Available,\n        });\n      },\n    );\n  }\n\n  /**\n   * Enables the RPC failover functionality. That is, if any RPC endpoints are\n   * configured with failover URLs, then traffic will automatically be diverted\n   * to them if those RPC endpoints are unavailable.\n   */\n  enableRpcFailover(): void {\n    this.#updateRpcFailoverEnabled(true);\n  }\n\n  /**\n   * Disables the RPC failover functionality. That is, even if any RPC endpoints\n   * are configured with failover URLs, then traffic will not automatically be\n   * diverted to them if those RPC endpoints are unavailable.\n   */\n  disableRpcFailover(): void {\n    this.#updateRpcFailoverEnabled(false);\n  }\n\n  /**\n   * Enables or disables the RPC failover functionality, depending on the\n   * boolean given. This is done by reconstructing all network clients that were\n   * originally configured with failover URLs so that those URLs are either\n   * honored or ignored. Network client IDs will be preserved so as not to\n   * invalidate state in other controllers.\n   *\n   * @param newIsRpcFailoverEnabled - Whether or not to enable or disable the\n   * RPC failover functionality.\n   */\n  #updateRpcFailoverEnabled(newIsRpcFailoverEnabled: boolean): void {\n    if (this.#isRpcFailoverEnabled === newIsRpcFailoverEnabled) {\n      return;\n    }\n\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    for (const networkClientsById of Object.values(\n      autoManagedNetworkClientRegistry,\n    )) {\n      for (const networkClientId of Object.keys(networkClientsById)) {\n        // Type assertion: We can assume that `networkClientId` is valid here.\n        const networkClient =\n          networkClientsById[\n            networkClientId as keyof typeof networkClientsById\n          ];\n        if (\n          networkClient.configuration.failoverRpcUrls &&\n          networkClient.configuration.failoverRpcUrls.length > 0\n        ) {\n          newIsRpcFailoverEnabled\n            ? networkClient.enableRpcFailover()\n            : networkClient.disableRpcFailover();\n        }\n      }\n    }\n\n    this.#isRpcFailoverEnabled = newIsRpcFailoverEnabled;\n  }\n\n  /**\n   * Accesses the provider and block tracker for the currently selected network.\n   *\n   * @returns The proxy and block tracker proxies.\n   * @deprecated This method has been replaced by `getSelectedNetworkClient` (which has a more easily used return type) and will be removed in a future release.\n   */\n  getProviderAndBlockTracker(): {\n    provider: SwappableProxy<ProxyWithAccessibleTarget<Provider>> | undefined;\n    blockTracker:\n      | SwappableProxy<ProxyWithAccessibleTarget<BlockTracker>>\n      | undefined;\n  } {\n    return {\n      provider: this.#providerProxy,\n      blockTracker: this.#blockTrackerProxy,\n    };\n  }\n\n  /**\n   * Accesses the provider and block tracker for the currently selected network.\n   *\n   * @returns an object with the provider and block tracker proxies for the currently selected network.\n   */\n  getSelectedNetworkClient():\n    | {\n        provider: SwappableProxy<ProxyWithAccessibleTarget<Provider>>;\n        blockTracker: SwappableProxy<ProxyWithAccessibleTarget<BlockTracker>>;\n      }\n    | undefined {\n    if (this.#providerProxy && this.#blockTrackerProxy) {\n      return {\n        provider: this.#providerProxy,\n        blockTracker: this.#blockTrackerProxy,\n      };\n    }\n    return undefined;\n  }\n\n  /**\n   * Accesses the chain ID from the selected network client.\n   *\n   * @returns The chain ID of the selected network client in hex format or undefined if there is no network client.\n   */\n  getSelectedChainId(): Hex | undefined {\n    const networkConfiguration = this.getNetworkConfigurationByNetworkClientId(\n      this.state.selectedNetworkClientId,\n    );\n    return networkConfiguration?.chainId;\n  }\n\n  /**\n   * Internally, the Infura and custom network clients are categorized by type\n   * so that when accessing either kind of network client, TypeScript knows\n   * which type to assign to the network client. For some cases it's more useful\n   * to be able to access network clients by ID instead of by type and then ID,\n   * so this function makes that possible.\n   *\n   * @returns The network clients registered so far, keyed by ID.\n   */\n  getNetworkClientRegistry(): AutoManagedBuiltInNetworkClientRegistry &\n    AutoManagedCustomNetworkClientRegistry {\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    return Object.assign(\n      {},\n      autoManagedNetworkClientRegistry[NetworkClientType.Infura],\n      autoManagedNetworkClientRegistry[NetworkClientType.Custom],\n    );\n  }\n\n  /**\n   * Returns the Infura network client with the given ID.\n   *\n   * @param infuraNetworkClientId - An Infura network client ID.\n   * @returns The Infura network client.\n   * @throws If an Infura network client does not exist with the given ID.\n   */\n  getNetworkClientById(\n    infuraNetworkClientId: BuiltInNetworkClientId,\n  ): AutoManagedNetworkClient<InfuraNetworkClientConfiguration>;\n\n  /**\n   * Returns the custom network client with the given ID.\n   *\n   * @param customNetworkClientId - A custom network client ID.\n   * @returns The custom network client.\n   * @throws If a custom network client does not exist with the given ID.\n   */\n  getNetworkClientById(\n    customNetworkClientId: CustomNetworkClientId,\n  ): AutoManagedNetworkClient<CustomNetworkClientConfiguration>;\n\n  getNetworkClientById(\n    networkClientId: NetworkClientId,\n  ): AutoManagedNetworkClient<NetworkClientConfiguration> {\n    if (!networkClientId) {\n      throw new Error('No network client ID was provided.');\n    }\n\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    if (isInfuraNetworkType(networkClientId)) {\n      const infuraNetworkClient =\n        autoManagedNetworkClientRegistry[NetworkClientType.Infura][\n          networkClientId\n        ];\n      // This is impossible to reach\n      /* istanbul ignore if */\n      if (!infuraNetworkClient) {\n        throw new Error(\n          `No Infura network client was found with the ID \"${networkClientId}\".`,\n        );\n      }\n      return infuraNetworkClient;\n    }\n\n    const customNetworkClient =\n      autoManagedNetworkClientRegistry[NetworkClientType.Custom][\n        networkClientId\n      ];\n    if (!customNetworkClient) {\n      throw new Error(\n        `No custom network client was found with the ID \"${networkClientId}\".`,\n      );\n    }\n    return customNetworkClient;\n  }\n\n  /**\n   * Executes a series of steps to switch the network:\n   *\n   * 1. Notifies subscribers via the messenger that the network is about to be\n   * switched (and, really, that the global provider and block tracker proxies\n   * will be re-pointed to a new network).\n   * 2. Looks up a known and preinitialized network client matching the given\n   * ID and uses it to re-point the aforementioned provider and block tracker\n   * proxies.\n   * 3. Notifies subscribers via the messenger that the network has switched.\n   * 4. Captures metadata for the newly switched network in state.\n   *\n   * @param networkClientId - The ID of a network client that requests will be\n   * routed through (either the name of an Infura network or the ID of a custom\n   * network configuration).\n   * @param options - Options for this method.\n   * @param options.updateState - Allows for updating state.\n   */\n  async #refreshNetwork(\n    networkClientId: string,\n    options: {\n      updateState?: (state: Draft<NetworkState>) => void;\n    } = {},\n  ): Promise<void> {\n    this.messenger.publish('NetworkController:networkWillChange', this.state);\n    this.#applyNetworkSelection(networkClientId, options);\n    this.messenger.publish('NetworkController:networkDidChange', this.state);\n    await this.lookupNetwork();\n  }\n\n  /**\n   * Creates proxies for accessing the global network client and its block\n   * tracker. You must call this method in order to use\n   * `getProviderAndBlockTracker` (or its replacement,\n   * `getSelectedNetworkClient`).\n   *\n   * @param options - Optional arguments.\n   * @param options.lookupNetwork - Usually, metadata for the global network\n   * will be populated via a call to `lookupNetwork` after creating the provider\n   * and block tracker proxies. This allows for responding to the status of the\n   * global network after initializing this controller; however, it requires\n   * making a request to the network to do so. In the clients, where controllers\n   * are initialized before the UI is shown, this may be undesirable, as it\n   * means that if the user has just installed MetaMask, their IP address may be\n   * shared with a third party before they have a chance to finish onboarding.\n   * You can pass `false` if you'd like to disable this request and call\n   * `lookupNetwork` yourself.\n   */\n  initializeProvider(options: { lookupNetwork: false }): void;\n\n  /**\n   * Creates proxies for accessing the global network client and its block\n   * tracker. You must call this method in order to use\n   * `getProviderAndBlockTracker` (or its replacement,\n   * `getSelectedNetworkClient`).\n   *\n   * @param options - Optional arguments.\n   * @param options.lookupNetwork - Usually, metadata for the global network\n   * will be populated via a call to `lookupNetwork` after creating the provider\n   * and block tracker proxies. This allows for responding to the status of the\n   * global network after initializing this controller; however, it requires\n   * making a request to the network to do so. In the clients, where controllers\n   * are initialized before the UI is shown, this may be undesirable, as it\n   * means that if the user has just installed MetaMask, their IP address may be\n   * shared with a third party before they have a chance to finish onboarding.\n   * You can pass `false` if you'd like to disable this request and call\n   * `lookupNetwork` yourself.\n   * @returns A promise that resolves when the network lookup completes.\n   */\n  initializeProvider(options?: { lookupNetwork?: boolean }): Promise<void>;\n\n  initializeProvider({\n    lookupNetwork = true,\n  }: {\n    lookupNetwork?: boolean;\n  } = {}): Promise<void> | undefined {\n    this.#applyNetworkSelection(this.state.selectedNetworkClientId);\n\n    if (lookupNetwork) {\n      return this.lookupNetwork();\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Uses a request for the latest block to gather the following information on\n   * the given network:\n   *\n   * - The connectivity status: whether it is available, geo-blocked (Infura\n   * only), unavailable, or unknown\n   * - The capabilities status: whether it supports EIP-1559, whether it does\n   * not, or whether it is unknown\n   *\n   * @param networkClientId - The ID of the network client to inspect.\n   * If no ID is provided, uses the currently selected network.\n   * @returns The resulting metadata for the network.\n   */\n  async #determineNetworkMetadata(networkClientId: NetworkClientId): Promise<{\n    isInfura: boolean;\n    networkStatus:\n      | NetworkStatus.Available\n      | NetworkStatus.Unknown\n      | NetworkStatus.Unavailable\n      | NetworkStatus.Blocked;\n    isEIP1559Compatible: undefined | boolean;\n  }> {\n    // Force TypeScript to use one of the two overloads explicitly\n    const networkClient = isInfuraNetworkType(networkClientId)\n      ? this.getNetworkClientById(networkClientId)\n      : this.getNetworkClientById(networkClientId);\n\n    const isInfura =\n      networkClient.configuration.type === NetworkClientType.Infura;\n    let networkStatus: NetworkStatus;\n    let isEIP1559Compatible: boolean | undefined;\n\n    try {\n      isEIP1559Compatible =\n        await this.#determineEIP1559Compatibility(networkClientId);\n      networkStatus = NetworkStatus.Available;\n    } catch (error) {\n      debugLog('NetworkController: lookupNetwork: ', error);\n\n      if (isErrorWithCode(error)) {\n        let responseBody;\n        if (\n          isInfura &&\n          hasProperty(error, 'message') &&\n          typeof error.message === 'string'\n        ) {\n          try {\n            responseBody = JSON.parse(error.message);\n          } catch {\n            // error.message must not be JSON\n            this.#log?.warn(\n              'NetworkController: lookupNetwork: json parse error: ',\n              error,\n            );\n          }\n        }\n\n        if (\n          isPlainObject(responseBody) &&\n          responseBody.error === INFURA_BLOCKED_KEY\n        ) {\n          networkStatus = NetworkStatus.Blocked;\n        } else if (error.code === errorCodes.rpc.internal) {\n          networkStatus = NetworkStatus.Unknown;\n          this.#log?.warn(\n            'NetworkController: lookupNetwork: rpc internal error: ',\n            error,\n          );\n        } else {\n          networkStatus = NetworkStatus.Unavailable;\n          this.#log?.warn('NetworkController: lookupNetwork: ', error);\n        }\n      } else {\n        debugLog(\n          'NetworkController - could not determine network status',\n          error,\n        );\n        networkStatus = NetworkStatus.Unknown;\n        this.#log?.warn('NetworkController: lookupNetwork: ', error);\n      }\n    }\n\n    return { isInfura, networkStatus, isEIP1559Compatible };\n  }\n\n  /**\n   * Uses a request for the latest block to gather the following information on\n   * the given or selected network, persisting it to state:\n   *\n   * - The connectivity status: whether it is available, geo-blocked (Infura\n   * only), unavailable, or unknown\n   * - The capabilities status: whether it supports EIP-1559, whether it does\n   * not, or whether it is unknown\n   *\n   * @param networkClientId - The ID of the network client to inspect.\n   * If no ID is provided, uses the currently selected network.\n   */\n  async lookupNetwork(networkClientId?: NetworkClientId): Promise<void> {\n    if (networkClientId) {\n      await this.#lookupGivenNetwork(networkClientId);\n    } else {\n      await this.#lookupSelectedNetwork();\n    }\n  }\n\n  /**\n   * Uses a request for the latest block to gather the following information on\n   * the given network, persisting it to state:\n   *\n   * - The connectivity status: whether the network is available, geo-blocked\n   * (Infura only), unavailable, or unknown\n   * - The feature compatibility status: whether the network supports EIP-1559,\n   * whether it does not, or whether it is unknown\n   *\n   * @param networkClientId - The ID of the network client to inspect.\n   * @deprecated Please use `lookupNetwork` and pass a network client ID\n   * instead. This method will be removed in a future major version.\n   */\n  // We are planning on removing this so we aren't interested in testing this\n  // right now.\n  /* istanbul ignore next */\n  async lookupNetworkByClientId(\n    networkClientId: NetworkClientId,\n  ): Promise<void> {\n    await this.#lookupGivenNetwork(networkClientId);\n  }\n\n  /**\n   * Uses a request for the latest block to gather the following information on\n   * the given network, persisting it to state:\n   *\n   * - The connectivity status: whether the network is available, geo-blocked\n   * (Infura only), unavailable, or unknown\n   * - The feature compatibility status: whether the network supports EIP-1559,\n   * whether it does not, or whether it is unknown\n   *\n   * @param networkClientId - The ID of the network client to inspect.\n   */\n  async #lookupGivenNetwork(networkClientId: NetworkClientId): Promise<void> {\n    const { networkStatus, isEIP1559Compatible } =\n      await this.#determineNetworkMetadata(networkClientId);\n\n    this.#updateMetadataForNetwork(networkClientId, {\n      networkStatus,\n      isEIP1559Compatible,\n    });\n  }\n\n  /**\n   * Uses a request for the latest block to gather the following information on\n   * the currently selected network, persisting it to state:\n   *\n   * - The connectivity status: whether the network is available, geo-blocked\n   * (Infura only), unavailable, or unknown\n   * - The feature compatibility status: whether the network supports EIP-1559,\n   * whether it does not, or whether it is unknown\n   *\n   * Note that it is possible for the current network to be switched while this\n   * method is running. If that is the case, it will exit early (as this method\n   * will also run for the new network).\n   */\n  async #lookupSelectedNetwork(): Promise<void> {\n    if (!this.#ethQuery) {\n      return;\n    }\n\n    let networkChanged = false;\n    const listener = (): void => {\n      networkChanged = true;\n      try {\n        this.messenger.unsubscribe(\n          'NetworkController:networkDidChange',\n          listener,\n        );\n      } catch (error) {\n        // In theory, this `catch` should not be necessary given that this error\n        // would occur \"inside\" of the call to `#determineEIP1559Compatibility`\n        // below and so it should be caught by the `try`/`catch` below (it is\n        // impossible to reproduce in tests for that reason). However, somehow\n        // it occurs within Mobile and so we have to add our own `try`/`catch`\n        // here.\n        /* istanbul ignore next */\n        if (\n          !(error instanceof Error) ||\n          error.message !==\n            'Subscription not found for event: NetworkController:networkDidChange'\n        ) {\n          // Again, this error should not happen and is impossible to reproduce\n          // in tests.\n          /* istanbul ignore next */\n          throw error;\n        }\n      }\n    };\n    this.messenger.subscribe('NetworkController:networkDidChange', listener);\n\n    const { isInfura, networkStatus, isEIP1559Compatible } =\n      await this.#determineNetworkMetadata(this.state.selectedNetworkClientId);\n\n    if (networkChanged) {\n      // If the network has changed, then `lookupNetwork` either has been or is\n      // in the process of being called, so we don't need to go further.\n      return;\n    }\n\n    try {\n      this.messenger.unsubscribe(\n        'NetworkController:networkDidChange',\n        listener,\n      );\n    } catch (error) {\n      if (\n        !(error instanceof Error) ||\n        error.message !==\n          'Subscription not found for event: NetworkController:networkDidChange'\n      ) {\n        throw error;\n      }\n    }\n\n    this.#updateMetadataForNetwork(this.state.selectedNetworkClientId, {\n      networkStatus,\n      isEIP1559Compatible,\n    });\n\n    if (isInfura) {\n      if (networkStatus === NetworkStatus.Available) {\n        this.messenger.publish('NetworkController:infuraIsUnblocked');\n      } else if (networkStatus === NetworkStatus.Blocked) {\n        this.messenger.publish('NetworkController:infuraIsBlocked');\n      }\n    } else {\n      // Always publish infuraIsUnblocked regardless of network status to\n      // prevent consumers from being stuck in a blocked state if they were\n      // previously connected to an Infura network that was blocked\n      this.messenger.publish('NetworkController:infuraIsUnblocked');\n    }\n  }\n\n  /**\n   * Updates the metadata for the given network in state.\n   *\n   * @param networkClientId - The associated network client ID.\n   * @param metadata - The metadata to store in state.\n   * @param metadata.networkStatus - The network status to store in state.\n   * @param metadata.isEIP1559Compatible - The EIP-1559 compatibility status to\n   * store in state.\n   */\n  #updateMetadataForNetwork(\n    networkClientId: NetworkClientId,\n    metadata: {\n      networkStatus: NetworkStatus;\n      isEIP1559Compatible?: boolean | undefined;\n    },\n  ): void {\n    this.update((state) => {\n      state.networksMetadata[networkClientId] ??= {\n        status: NetworkStatus.Unknown,\n        EIPS: {},\n      };\n\n      const newMetadata = state.networksMetadata[networkClientId];\n      newMetadata.status = metadata.networkStatus;\n\n      if ('isEIP1559Compatible' in metadata) {\n        if (metadata.isEIP1559Compatible === undefined) {\n          delete newMetadata.EIPS[1559];\n        } else {\n          newMetadata.EIPS[1559] = metadata.isEIP1559Compatible;\n        }\n      }\n    });\n  }\n\n  /**\n   * Convenience method to update provider network type settings.\n   *\n   * @param type - Human readable network name.\n   * @deprecated This has been replaced by `setActiveNetwork`, and will be\n   * removed in a future release\n   */\n  async setProviderType(type: InfuraNetworkType): Promise<void> {\n    if ((type as unknown) === NetworkType.rpc) {\n      throw new Error(\n        `NetworkController - cannot call \"setProviderType\" with type \"${NetworkType.rpc}\". Use \"setActiveNetwork\"`,\n      );\n    }\n    if (!isInfuraNetworkType(type)) {\n      throw new Error(`Unknown Infura provider type \"${String(type)}\".`);\n    }\n\n    await this.setActiveNetwork(type);\n  }\n\n  /**\n   * Changes the selected network.\n   *\n   * @param networkClientId - The ID of a network client that will be used to\n   * make requests.\n   * @param options - Options for this method.\n   * @param options.updateState - Allows for updating state.\n   * @throws if no network client is associated with the given\n   * network client ID.\n   */\n  async setActiveNetwork(\n    networkClientId: string,\n    options: {\n      updateState?: (state: Draft<NetworkState>) => void;\n    } = {},\n  ): Promise<void> {\n    this.#previouslySelectedNetworkClientId =\n      this.state.selectedNetworkClientId;\n\n    await this.#refreshNetwork(networkClientId, options);\n  }\n\n  /**\n   * Fetches the latest block for the network.\n   *\n   * @param networkClientId - The networkClientId to fetch the correct provider against which to check the latest block. Defaults to the selectedNetworkClientId.\n   * @returns A promise that either resolves to the block header or null if\n   * there is no latest block, or rejects with an error.\n   */\n  #getLatestBlock(\n    networkClientId: NetworkClientId = this.state.selectedNetworkClientId,\n  ): Promise<Block> {\n    const networkClient = this.getNetworkClientById(networkClientId);\n    const ethQuery = new EthQuery(networkClient.provider);\n\n    return new Promise((resolve, reject) => {\n      ethQuery.sendAsync(\n        { method: 'eth_getBlockByNumber', params: ['latest', false] },\n        (error: unknown, block?: unknown) => {\n          if (error) {\n            // This error comes from JsonRpcEngine, we don't control it.\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            reject(error);\n          } else {\n            // TODO: Validate this type\n            resolve(block as Block);\n          }\n        },\n      );\n    });\n  }\n\n  /**\n   * Determines whether the network supports EIP-1559 by checking whether the\n   * latest block has a `baseFeePerGas` property, then updates state\n   * appropriately.\n   *\n   * @param networkClientId - The networkClientId to fetch the correct provider against which to check 1559 compatibility.\n   * @returns A promise that resolves to true if the network supports EIP-1559\n   * , false otherwise, or `undefined` if unable to determine the compatibility.\n   */\n  async getEIP1559Compatibility(\n    networkClientId?: NetworkClientId,\n  ): Promise<undefined | boolean> {\n    if (networkClientId) {\n      return this.get1559CompatibilityWithNetworkClientId(networkClientId);\n    }\n    if (!this.#ethQuery) {\n      return false;\n    }\n\n    const { EIPS } =\n      this.state.networksMetadata[this.state.selectedNetworkClientId];\n\n    if (EIPS[1559] !== undefined) {\n      return EIPS[1559];\n    }\n\n    const isEIP1559Compatible = await this.#determineEIP1559Compatibility(\n      this.state.selectedNetworkClientId,\n    );\n    this.update((state) => {\n      if (isEIP1559Compatible !== undefined) {\n        state.networksMetadata[state.selectedNetworkClientId].EIPS[1559] =\n          isEIP1559Compatible;\n      }\n    });\n    return isEIP1559Compatible;\n  }\n\n  async get1559CompatibilityWithNetworkClientId(\n    networkClientId: NetworkClientId,\n  ): Promise<boolean> {\n    let metadata = this.state.networksMetadata[networkClientId];\n    if (metadata?.EIPS[1559] === undefined) {\n      await this.lookupNetwork(networkClientId);\n      metadata = this.state.networksMetadata[networkClientId];\n    }\n    const { EIPS } = metadata;\n\n    // may want to include some 'freshness' value - something to make sure we refetch this from time to time\n    return EIPS[1559];\n  }\n\n  /**\n   * Retrieves and checks the latest block from the currently selected\n   * network; if the block has a `baseFeePerGas` property, then we know\n   * that the network supports EIP-1559; otherwise it doesn't.\n   *\n   * @param networkClientId - The networkClientId to fetch the correct provider against which to check 1559 compatibility\n   * @returns A promise that resolves to `true` if the network supports EIP-1559,\n   * `false` otherwise, or `undefined` if unable to retrieve the last block.\n   */\n  async #determineEIP1559Compatibility(\n    networkClientId: NetworkClientId,\n  ): Promise<boolean | undefined> {\n    const latestBlock = await this.#getLatestBlock(networkClientId);\n\n    if (!latestBlock) {\n      return undefined;\n    }\n\n    return latestBlock.baseFeePerGas !== undefined;\n  }\n\n  /**\n   * Ensures that the provider and block tracker proxies are pointed to the\n   * currently selected network and refreshes the metadata for the\n   */\n  async resetConnection(): Promise<void> {\n    await this.#refreshNetwork(this.state.selectedNetworkClientId);\n  }\n\n  /**\n   * Returns the network configuration that has been filed under the given chain\n   * ID.\n   *\n   * @param chainId - The chain ID to use as a key.\n   * @returns The network configuration if one exists, or undefined.\n   */\n  getNetworkConfigurationByChainId(\n    chainId: Hex,\n  ): NetworkConfiguration | undefined {\n    return this.state.networkConfigurationsByChainId[chainId];\n  }\n\n  /**\n   * Returns the network configuration that contains an RPC endpoint with the\n   * given network client ID.\n   *\n   * @param networkClientId - The network client ID to use as a key.\n   * @returns The network configuration if one exists, or undefined.\n   */\n  getNetworkConfigurationByNetworkClientId(\n    networkClientId: NetworkClientId,\n  ): NetworkConfiguration | undefined {\n    return this.#networkConfigurationsByNetworkClientId.get(networkClientId);\n  }\n\n  /**\n   * Creates and registers network clients for the collection of Infura and\n   * custom RPC endpoints that can be used to make requests for a particular\n   * chain, storing the given configuration object in state for later reference.\n   *\n   * @param fields - The object that describes the new network/chain and lists\n   * the RPC endpoints which front that chain.\n   * @returns The newly added network configuration.\n   * @throws if any part of `fields` would produce invalid state.\n   * @see {@link NetworkConfiguration}\n   */\n  addNetwork(fields: AddNetworkFields): NetworkConfiguration {\n    const { rpcEndpoints: setOfRpcEndpointFields } = fields;\n\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    this.#validateNetworkFields({\n      mode: 'add',\n      networkFields: fields,\n      autoManagedNetworkClientRegistry,\n    });\n\n    const networkClientOperations = setOfRpcEndpointFields.map(\n      (defaultOrCustomRpcEndpointFields) => {\n        const rpcEndpoint =\n          defaultOrCustomRpcEndpointFields.type === RpcEndpointType.Custom\n            ? {\n                ...defaultOrCustomRpcEndpointFields,\n                networkClientId: uuidV4(),\n              }\n            : defaultOrCustomRpcEndpointFields;\n        return {\n          type: 'add' as const,\n          rpcEndpoint,\n        };\n      },\n    );\n\n    const newNetworkConfiguration =\n      this.#determineNetworkConfigurationToPersist({\n        networkFields: fields,\n        networkClientOperations,\n      });\n    this.#registerNetworkClientsAsNeeded({\n      networkFields: fields,\n      networkClientOperations,\n      autoManagedNetworkClientRegistry,\n    });\n    this.update((state) => {\n      this.#updateNetworkConfigurations({\n        state,\n        mode: 'add',\n        networkFields: fields,\n        networkConfigurationToPersist: newNetworkConfiguration,\n      });\n    });\n\n    this.messenger.publish(\n      `${controllerName}:networkAdded`,\n      newNetworkConfiguration,\n    );\n\n    return newNetworkConfiguration;\n  }\n\n  /**\n   * Updates the configuration for a previously stored network filed under the\n   * given chain ID, creating + registering new network clients to represent RPC\n   * endpoints that have been added and destroying + unregistering existing\n   * network clients for RPC endpoints that have been removed.\n   *\n   * Note that if `chainId` is changed, then all network clients associated with\n   * that chain will be removed and re-added, even if none of the RPC endpoints\n   * have changed.\n   *\n   * @param chainId - The chain ID associated with an existing network.\n   * @param fields - The object that describes the updates to the network/chain,\n   * including the new set of RPC endpoints which should front that chain.\n   * @param options - Options to provide.\n   * @param options.replacementSelectedRpcEndpointIndex - Usually you cannot\n   * remove an RPC endpoint that is being represented by the currently selected\n   * network client. This option allows you to specify another RPC endpoint\n   * (either an existing one or a new one) that should be used to select a new\n   * network instead.\n   * @returns The updated network configuration.\n   * @throws if `chainId` does not refer to an existing network configuration,\n   * if any part of `fields` would produce invalid state, etc.\n   * @see {@link NetworkConfiguration}\n   */\n  async updateNetwork(\n    chainId: Hex,\n    fields: UpdateNetworkFields,\n    {\n      replacementSelectedRpcEndpointIndex,\n    }: { replacementSelectedRpcEndpointIndex?: number } = {},\n  ): Promise<NetworkConfiguration> {\n    const existingNetworkConfiguration =\n      this.state.networkConfigurationsByChainId[chainId];\n\n    if (existingNetworkConfiguration === undefined) {\n      throw new Error(\n        `Could not update network: Cannot find network configuration for chain '${chainId}'`,\n      );\n    }\n\n    const existingChainId = chainId;\n    const { chainId: newChainId, rpcEndpoints: setOfNewRpcEndpointFields } =\n      fields;\n\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    this.#validateNetworkFields({\n      mode: 'update',\n      networkFields: fields,\n      existingNetworkConfiguration,\n      autoManagedNetworkClientRegistry,\n    });\n\n    const networkClientOperations: NetworkClientOperation[] = [];\n\n    for (const newRpcEndpointFields of setOfNewRpcEndpointFields) {\n      const existingRpcEndpointForNoop =\n        existingNetworkConfiguration.rpcEndpoints.find((rpcEndpoint) => {\n          return (\n            rpcEndpoint.type === newRpcEndpointFields.type &&\n            rpcEndpoint.url === newRpcEndpointFields.url &&\n            (rpcEndpoint.networkClientId ===\n              newRpcEndpointFields.networkClientId ||\n              newRpcEndpointFields.networkClientId === undefined)\n          );\n        });\n      const existingRpcEndpointForReplaceWhenChainChanged =\n        existingNetworkConfiguration.rpcEndpoints.find((rpcEndpoint) => {\n          return (\n            (rpcEndpoint.type === RpcEndpointType.Infura &&\n              newRpcEndpointFields.type === RpcEndpointType.Infura) ||\n            (rpcEndpoint.type === newRpcEndpointFields.type &&\n              rpcEndpoint.networkClientId ===\n                newRpcEndpointFields.networkClientId &&\n              rpcEndpoint.url === newRpcEndpointFields.url)\n          );\n        });\n      const existingRpcEndpointForReplaceWhenChainNotChanged =\n        existingNetworkConfiguration.rpcEndpoints.find((rpcEndpoint) => {\n          return (\n            rpcEndpoint.type === newRpcEndpointFields.type &&\n            (rpcEndpoint.url === newRpcEndpointFields.url ||\n              rpcEndpoint.networkClientId ===\n                newRpcEndpointFields.networkClientId)\n          );\n        });\n\n      if (\n        newChainId !== existingChainId &&\n        existingRpcEndpointForReplaceWhenChainChanged !== undefined\n      ) {\n        const newRpcEndpoint =\n          newRpcEndpointFields.type === RpcEndpointType.Infura\n            ? newRpcEndpointFields\n            : { ...newRpcEndpointFields, networkClientId: uuidV4() };\n\n        networkClientOperations.push({\n          type: 'replace' as const,\n          oldRpcEndpoint: existingRpcEndpointForReplaceWhenChainChanged,\n          newRpcEndpoint,\n        });\n      } else if (existingRpcEndpointForNoop !== undefined) {\n        let newRpcEndpoint;\n        if (existingRpcEndpointForNoop.type === RpcEndpointType.Infura) {\n          newRpcEndpoint = existingRpcEndpointForNoop;\n        } else {\n          // `networkClientId` shouldn't be missing at this point; if it is,\n          // that's a mistake, so fill it back in\n          newRpcEndpoint = Object.assign({}, newRpcEndpointFields, {\n            networkClientId: existingRpcEndpointForNoop.networkClientId,\n          });\n        }\n        networkClientOperations.push({\n          type: 'noop' as const,\n          rpcEndpoint: newRpcEndpoint,\n        });\n      } else if (\n        existingRpcEndpointForReplaceWhenChainNotChanged === undefined\n      ) {\n        const newRpcEndpoint =\n          newRpcEndpointFields.type === RpcEndpointType.Infura\n            ? newRpcEndpointFields\n            : { ...newRpcEndpointFields, networkClientId: uuidV4() };\n        const networkClientOperation = {\n          type: 'add' as const,\n          rpcEndpoint: newRpcEndpoint,\n        };\n        networkClientOperations.push(networkClientOperation);\n      } else {\n        let newRpcEndpoint;\n        /* istanbul ignore if */\n        if (newRpcEndpointFields.type === RpcEndpointType.Infura) {\n          // This case can't actually happen. If we're here, it means that some\n          // part of the RPC endpoint changed. But there is no part of an Infura\n          // RPC endpoint that can be changed (as it would immediately make that\n          // RPC endpoint self-inconsistent). This is just here to appease\n          // TypeScript.\n          newRpcEndpoint = newRpcEndpointFields;\n        } else {\n          newRpcEndpoint = {\n            ...newRpcEndpointFields,\n            networkClientId: uuidV4(),\n          };\n        }\n\n        networkClientOperations.push({\n          type: 'replace' as const,\n          oldRpcEndpoint: existingRpcEndpointForReplaceWhenChainNotChanged,\n          newRpcEndpoint,\n        });\n      }\n    }\n\n    for (const existingRpcEndpoint of existingNetworkConfiguration.rpcEndpoints) {\n      if (\n        !networkClientOperations.some((networkClientOperation) => {\n          const otherRpcEndpoint =\n            networkClientOperation.type === 'replace'\n              ? networkClientOperation.oldRpcEndpoint\n              : networkClientOperation.rpcEndpoint;\n          return (\n            otherRpcEndpoint.type === existingRpcEndpoint.type &&\n            otherRpcEndpoint.networkClientId ===\n              existingRpcEndpoint.networkClientId &&\n            otherRpcEndpoint.url === existingRpcEndpoint.url\n          );\n        })\n      ) {\n        const networkClientOperation = {\n          type: 'remove' as const,\n          rpcEndpoint: existingRpcEndpoint,\n        };\n        networkClientOperations.push(networkClientOperation);\n      }\n    }\n\n    const updatedNetworkConfiguration =\n      this.#determineNetworkConfigurationToPersist({\n        networkFields: fields,\n        networkClientOperations,\n      });\n\n    if (\n      replacementSelectedRpcEndpointIndex === undefined &&\n      networkClientOperations.some((networkClientOperation) => {\n        return (\n          networkClientOperation.type === 'remove' &&\n          networkClientOperation.rpcEndpoint.networkClientId ===\n            this.state.selectedNetworkClientId\n        );\n      }) &&\n      !networkClientOperations.some((networkClientOperation) => {\n        return (\n          networkClientOperation.type === 'replace' &&\n          networkClientOperation.oldRpcEndpoint.networkClientId ===\n            this.state.selectedNetworkClientId\n        );\n      })\n    ) {\n      throw new Error(\n        `Could not update network: Cannot update RPC endpoints in such a way that the selected network '${this.state.selectedNetworkClientId}' would be removed without a replacement. Choose a different RPC endpoint as the selected network via the \\`replacementSelectedRpcEndpointIndex\\` option.`,\n      );\n    }\n\n    this.#registerNetworkClientsAsNeeded({\n      networkFields: fields,\n      networkClientOperations,\n      autoManagedNetworkClientRegistry,\n    });\n\n    const replacementSelectedRpcEndpointWithIndex = networkClientOperations\n      .map(\n        (networkClientOperation, index) =>\n          [networkClientOperation, index] as const,\n      )\n      .find(([networkClientOperation, _index]) => {\n        return (\n          networkClientOperation.type === 'replace' &&\n          networkClientOperation.oldRpcEndpoint.networkClientId ===\n            this.state.selectedNetworkClientId\n        );\n      });\n    const correctedReplacementSelectedRpcEndpointIndex =\n      replacementSelectedRpcEndpointIndex ??\n      replacementSelectedRpcEndpointWithIndex?.[1];\n\n    let rpcEndpointToSelect: RpcEndpoint | undefined;\n    if (correctedReplacementSelectedRpcEndpointIndex !== undefined) {\n      rpcEndpointToSelect =\n        updatedNetworkConfiguration.rpcEndpoints[\n          correctedReplacementSelectedRpcEndpointIndex\n        ];\n\n      if (rpcEndpointToSelect === undefined) {\n        throw new Error(\n          `Could not update network: \\`replacementSelectedRpcEndpointIndex\\` ${correctedReplacementSelectedRpcEndpointIndex} does not refer to an entry in \\`rpcEndpoints\\``,\n        );\n      }\n    }\n\n    if (\n      rpcEndpointToSelect &&\n      rpcEndpointToSelect.networkClientId !== this.state.selectedNetworkClientId\n    ) {\n      await this.setActiveNetwork(rpcEndpointToSelect.networkClientId, {\n        updateState: (state) => {\n          this.#updateNetworkConfigurations({\n            state,\n            mode: 'update',\n            networkFields: fields,\n            networkConfigurationToPersist: updatedNetworkConfiguration,\n            existingNetworkConfiguration,\n          });\n        },\n      });\n    } else {\n      this.update((state) => {\n        this.#updateNetworkConfigurations({\n          state,\n          mode: 'update',\n          networkFields: fields,\n          networkConfigurationToPersist: updatedNetworkConfiguration,\n          existingNetworkConfiguration,\n        });\n      });\n    }\n\n    this.#unregisterNetworkClientsAsNeeded({\n      networkClientOperations,\n      autoManagedNetworkClientRegistry,\n    });\n\n    return updatedNetworkConfiguration;\n  }\n\n  /**\n   * Destroys and unregisters the network identified by the given chain ID, also\n   * removing the associated network configuration from state.\n   *\n   * @param chainId - The chain ID associated with an existing network.\n   * @throws if `chainId` does not refer to an existing network configuration,\n   * or if the currently selected network is being removed.\n   * @see {@link NetworkConfiguration}\n   */\n  removeNetwork(chainId: Hex): void {\n    const existingNetworkConfiguration =\n      this.state.networkConfigurationsByChainId[chainId];\n\n    if (existingNetworkConfiguration === undefined) {\n      throw new Error(\n        `Cannot find network configuration for chain '${chainId}'`,\n      );\n    }\n\n    if (\n      existingNetworkConfiguration.rpcEndpoints.some(\n        (rpcEndpoint) =>\n          rpcEndpoint.networkClientId === this.state.selectedNetworkClientId,\n      )\n    ) {\n      throw new Error(`Cannot remove the currently selected network`);\n    }\n\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    const networkClientOperations =\n      existingNetworkConfiguration.rpcEndpoints.map((rpcEndpoint) => {\n        return {\n          type: 'remove' as const,\n          rpcEndpoint,\n        };\n      });\n\n    this.#unregisterNetworkClientsAsNeeded({\n      networkClientOperations,\n      autoManagedNetworkClientRegistry,\n    });\n    this.update((state) => {\n      this.#updateNetworkConfigurations({\n        state,\n        mode: 'remove',\n        existingNetworkConfiguration,\n      });\n\n      for (const rpcEndpoint of existingNetworkConfiguration.rpcEndpoints) {\n        delete state.networksMetadata[rpcEndpoint.networkClientId];\n      }\n    });\n\n    this.messenger.publish(\n      'NetworkController:networkRemoved',\n      existingNetworkConfiguration,\n    );\n  }\n\n  /**\n   * Assuming that the network has been previously switched, switches to this\n   * new network.\n   *\n   * If the network has not been previously switched, this method is equivalent\n   * to {@link resetConnection}.\n   */\n  async rollbackToPreviousProvider(): Promise<void> {\n    await this.#refreshNetwork(this.#previouslySelectedNetworkClientId);\n  }\n\n  /**\n   * Deactivates the controller, stopping any ongoing polling.\n   *\n   * In-progress requests will not be aborted.\n   */\n  // We're intentionally changing the signature of an extended method.\n  // eslint-disable-next-line @typescript-eslint/no-misused-promises\n  async destroy(): Promise<void> {\n    await this.#blockTrackerProxy?.destroy();\n  }\n\n  /**\n   * Merges the given backup data into controller state.\n   *\n   * @param backup - The data that has been backed up.\n   * @param backup.networkConfigurationsByChainId - Network configurations,\n   * keyed by chain ID.\n   */\n  loadBackup({\n    networkConfigurationsByChainId,\n  }: Pick<NetworkState, 'networkConfigurationsByChainId'>): void {\n    this.update((state) => {\n      state.networkConfigurationsByChainId = {\n        ...state.networkConfigurationsByChainId,\n        ...networkConfigurationsByChainId,\n      };\n    });\n  }\n\n  /**\n   * Searches for the default RPC endpoint configured for the given chain and\n   * returns its network client ID. This can then be passed to\n   * {@link getNetworkClientById} to retrieve the network client.\n   *\n   * @param chainId - Chain ID to search for.\n   * @returns The ID of the network client created for the chain's default RPC\n   * endpoint.\n   */\n  findNetworkClientIdByChainId(chainId: Hex): NetworkClientId {\n    const networkConfiguration =\n      this.state.networkConfigurationsByChainId[chainId];\n\n    if (!networkConfiguration) {\n      throw new Error(`Invalid chain ID \"${chainId}\"`);\n    }\n\n    const { networkClientId } =\n      networkConfiguration.rpcEndpoints[\n        networkConfiguration.defaultRpcEndpointIndex\n      ];\n    return networkClientId;\n  }\n\n  /**\n   * Ensure that the given fields which will be used to either add or update a\n   * network are valid.\n   *\n   * @param args - The arguments.\n   */\n  #validateNetworkFields(\n    args: {\n      autoManagedNetworkClientRegistry: AutoManagedNetworkClientRegistry;\n    } & (\n      | {\n          mode: 'add';\n          networkFields: AddNetworkFields;\n        }\n      | {\n          mode: 'update';\n          existingNetworkConfiguration: NetworkConfiguration;\n          networkFields: UpdateNetworkFields;\n        }\n    ),\n  ): void {\n    const { mode, networkFields, autoManagedNetworkClientRegistry } = args;\n    const existingNetworkConfiguration =\n      'existingNetworkConfiguration' in args\n        ? args.existingNetworkConfiguration\n        : null;\n\n    const errorMessagePrefix =\n      mode === 'update' ? 'Could not update network' : 'Could not add network';\n\n    if (\n      !isStrictHexString(networkFields.chainId) ||\n      !isSafeChainId(networkFields.chainId)\n    ) {\n      throw new Error(\n        `${errorMessagePrefix}: Invalid \\`chainId\\` '${networkFields.chainId}' (must start with \"0x\" and not exceed the maximum)`,\n      );\n    }\n\n    if (\n      existingNetworkConfiguration === null ||\n      networkFields.chainId !== existingNetworkConfiguration.chainId\n    ) {\n      const existingNetworkConfigurationViaChainId =\n        this.state.networkConfigurationsByChainId[networkFields.chainId];\n      if (existingNetworkConfigurationViaChainId !== undefined) {\n        if (existingNetworkConfiguration === null) {\n          throw new Error(\n            `Could not add network for chain ${args.networkFields.chainId} as another network for that chain already exists ('${existingNetworkConfigurationViaChainId.name}')`,\n          );\n        } else {\n          throw new Error(\n            `Cannot move network from chain ${existingNetworkConfiguration.chainId} to ${networkFields.chainId} as another network for that chain already exists ('${existingNetworkConfigurationViaChainId.name}')`,\n          );\n        }\n      }\n    }\n\n    const isInvalidDefaultBlockExplorerUrlIndex =\n      networkFields.blockExplorerUrls.length > 0\n        ? networkFields.defaultBlockExplorerUrlIndex === undefined ||\n          networkFields.blockExplorerUrls[\n            networkFields.defaultBlockExplorerUrlIndex\n          ] === undefined\n        : networkFields.defaultBlockExplorerUrlIndex !== undefined;\n\n    if (isInvalidDefaultBlockExplorerUrlIndex) {\n      throw new Error(\n        `${errorMessagePrefix}: \\`defaultBlockExplorerUrlIndex\\` must refer to an entry in \\`blockExplorerUrls\\``,\n      );\n    }\n\n    if (networkFields.rpcEndpoints.length === 0) {\n      throw new Error(\n        `${errorMessagePrefix}: \\`rpcEndpoints\\` must be a non-empty array`,\n      );\n    }\n    for (const rpcEndpointFields of networkFields.rpcEndpoints) {\n      if (!isValidUrl(rpcEndpointFields.url)) {\n        throw new Error(\n          `${errorMessagePrefix}: An entry in \\`rpcEndpoints\\` has invalid URL '${rpcEndpointFields.url}'`,\n        );\n      }\n      const networkClientId =\n        'networkClientId' in rpcEndpointFields\n          ? rpcEndpointFields.networkClientId\n          : undefined;\n\n      if (\n        rpcEndpointFields.type === RpcEndpointType.Custom &&\n        networkClientId !== undefined &&\n        isInfuraNetworkType(networkClientId)\n      ) {\n        throw new Error(\n          `${errorMessagePrefix}: Custom RPC endpoint '${rpcEndpointFields.url}' has invalid network client ID '${networkClientId}'`,\n        );\n      }\n\n      if (\n        mode === 'update' &&\n        networkClientId !== undefined &&\n        rpcEndpointFields.type === RpcEndpointType.Custom &&\n        !Object.values(autoManagedNetworkClientRegistry).some(\n          (networkClientsById) => networkClientId in networkClientsById,\n        )\n      ) {\n        throw new Error(\n          `${errorMessagePrefix}: RPC endpoint '${rpcEndpointFields.url}' refers to network client '${networkClientId}' that does not exist`,\n        );\n      }\n\n      if (\n        networkFields.rpcEndpoints.some(\n          (otherRpcEndpointFields) =>\n            otherRpcEndpointFields !== rpcEndpointFields &&\n            URI.equal(otherRpcEndpointFields.url, rpcEndpointFields.url),\n        )\n      ) {\n        throw new Error(\n          `${errorMessagePrefix}: Each entry in rpcEndpoints must have a unique URL`,\n        );\n      }\n\n      const networkConfigurationsForOtherChains = Object.values(\n        this.state.networkConfigurationsByChainId,\n      ).filter((networkConfiguration) =>\n        existingNetworkConfiguration\n          ? networkConfiguration.chainId !==\n            existingNetworkConfiguration.chainId\n          : true,\n      );\n      for (const networkConfiguration of networkConfigurationsForOtherChains) {\n        const rpcEndpoint = networkConfiguration.rpcEndpoints.find(\n          (existingRpcEndpoint) =>\n            URI.equal(rpcEndpointFields.url, existingRpcEndpoint.url),\n        );\n        if (rpcEndpoint) {\n          if (mode === 'update') {\n            throw new Error(\n              `Could not update network to point to same RPC endpoint as existing network for chain ${networkConfiguration.chainId} ('${networkConfiguration.name}')`,\n            );\n          } else {\n            throw new Error(\n              `Could not add network that points to same RPC endpoint as existing network for chain ${networkConfiguration.chainId} ('${networkConfiguration.name}')`,\n            );\n          }\n        }\n      }\n    }\n\n    if (\n      [...new Set(networkFields.rpcEndpoints)].length <\n      networkFields.rpcEndpoints.length\n    ) {\n      throw new Error(\n        `${errorMessagePrefix}: Each entry in rpcEndpoints must be unique`,\n      );\n    }\n\n    const networkClientIds = networkFields.rpcEndpoints\n      .map((rpcEndpoint) =>\n        'networkClientId' in rpcEndpoint\n          ? rpcEndpoint.networkClientId\n          : undefined,\n      )\n      .filter(\n        (networkClientId): networkClientId is NetworkClientId =>\n          networkClientId !== undefined,\n      );\n    if ([...new Set(networkClientIds)].length < networkClientIds.length) {\n      throw new Error(\n        `${errorMessagePrefix}: Each entry in rpcEndpoints must have a unique networkClientId`,\n      );\n    }\n\n    const infuraRpcEndpoints = networkFields.rpcEndpoints.filter(\n      (rpcEndpointFields): rpcEndpointFields is InfuraRpcEndpoint =>\n        rpcEndpointFields.type === RpcEndpointType.Infura,\n    );\n    if (infuraRpcEndpoints.length > 1) {\n      throw new Error(\n        `${errorMessagePrefix}: There cannot be more than one Infura RPC endpoint`,\n      );\n    }\n\n    const soleInfuraRpcEndpoint = infuraRpcEndpoints[0];\n    if (soleInfuraRpcEndpoint) {\n      const infuraNetworkName = deriveInfuraNetworkNameFromRpcEndpointUrl(\n        soleInfuraRpcEndpoint.url,\n      );\n      const infuraNetworkNickname = NetworkNickname[infuraNetworkName];\n      const infuraChainId = ChainId[infuraNetworkName];\n      if (networkFields.chainId !== infuraChainId) {\n        throw new Error(\n          mode === 'add'\n            ? `Could not add network with chain ID ${networkFields.chainId} and Infura RPC endpoint for '${infuraNetworkNickname}' which represents ${infuraChainId}, as the two conflict`\n            : `Could not update network with chain ID ${networkFields.chainId} and Infura RPC endpoint for '${infuraNetworkNickname}' which represents ${infuraChainId}, as the two conflict`,\n        );\n      }\n    }\n\n    if (\n      networkFields.rpcEndpoints[networkFields.defaultRpcEndpointIndex] ===\n      undefined\n    ) {\n      throw new Error(\n        `${errorMessagePrefix}: \\`defaultRpcEndpointIndex\\` must refer to an entry in \\`rpcEndpoints\\``,\n      );\n    }\n  }\n\n  /**\n   * Constructs a network configuration that will be persisted to state when\n   * adding or updating a network.\n   *\n   * @param args - The arguments to this function.\n   * @param args.networkFields - The fields used to add or update a network.\n   * @param args.networkClientOperations - Operations which were calculated for\n   * updating the network client registry but which also map back to RPC\n   * endpoints (and so can be used to save those RPC endpoints).\n   * @returns The network configuration to persist.\n   */\n  #determineNetworkConfigurationToPersist({\n    networkFields,\n    networkClientOperations,\n  }: {\n    networkFields: AddNetworkFields | UpdateNetworkFields;\n    networkClientOperations: NetworkClientOperation[];\n  }): NetworkConfiguration {\n    const rpcEndpointsToPersist = networkClientOperations\n      .filter(\n        (\n          networkClientOperation,\n        ): networkClientOperation is\n          | AddNetworkClientOperation\n          | NoopNetworkClientOperation => {\n          return (\n            networkClientOperation.type === 'add' ||\n            networkClientOperation.type === 'noop'\n          );\n        },\n      )\n      .map((networkClientOperation) => networkClientOperation.rpcEndpoint)\n      .concat(\n        networkClientOperations\n          .filter(\n            (\n              networkClientOperation,\n            ): networkClientOperation is ReplaceNetworkClientOperation => {\n              return networkClientOperation.type === 'replace';\n            },\n          )\n          .map(\n            (networkClientOperation) => networkClientOperation.newRpcEndpoint,\n          ),\n      );\n\n    return { ...networkFields, rpcEndpoints: rpcEndpointsToPersist };\n  }\n\n  /**\n   * Creates and registers network clients using the given operations calculated\n   * as a part of adding or updating a network.\n   *\n   * @param args - The arguments to this function.\n   * @param args.networkFields - The fields used to add or update a network.\n   * @param args.networkClientOperations - Dictate which network clients need to\n   * be created.\n   * @param args.autoManagedNetworkClientRegistry - The network client registry\n   * to update.\n   */\n  #registerNetworkClientsAsNeeded({\n    networkFields,\n    networkClientOperations,\n    autoManagedNetworkClientRegistry,\n  }: {\n    networkFields: AddNetworkFields | UpdateNetworkFields;\n    networkClientOperations: NetworkClientOperation[];\n    autoManagedNetworkClientRegistry: AutoManagedNetworkClientRegistry;\n  }): void {\n    const addedRpcEndpoints = networkClientOperations\n      .filter(\n        (\n          networkClientOperation,\n        ): networkClientOperation is AddNetworkClientOperation => {\n          return networkClientOperation.type === 'add';\n        },\n      )\n      .map((networkClientOperation) => networkClientOperation.rpcEndpoint)\n      .concat(\n        networkClientOperations\n          .filter(\n            (\n              networkClientOperation,\n            ): networkClientOperation is ReplaceNetworkClientOperation => {\n              return networkClientOperation.type === 'replace';\n            },\n          )\n          .map(\n            (networkClientOperation) => networkClientOperation.newRpcEndpoint,\n          ),\n      );\n\n    for (const addedRpcEndpoint of addedRpcEndpoints) {\n      if (addedRpcEndpoint.type === RpcEndpointType.Infura) {\n        autoManagedNetworkClientRegistry[NetworkClientType.Infura][\n          addedRpcEndpoint.networkClientId\n        ] = createAutoManagedNetworkClient({\n          networkClientId: addedRpcEndpoint.networkClientId,\n          networkClientConfiguration: {\n            type: NetworkClientType.Infura,\n            chainId: networkFields.chainId,\n            network: addedRpcEndpoint.networkClientId,\n            failoverRpcUrls: addedRpcEndpoint.failoverUrls,\n            infuraProjectId: this.#infuraProjectId,\n            ticker: networkFields.nativeCurrency,\n          },\n          getRpcServiceOptions: this.#getRpcServiceOptions,\n          getBlockTrackerOptions: this.#getBlockTrackerOptions,\n          messenger: this.messenger,\n          isRpcFailoverEnabled: this.#isRpcFailoverEnabled,\n          logger: this.#log,\n        });\n      } else {\n        autoManagedNetworkClientRegistry[NetworkClientType.Custom][\n          addedRpcEndpoint.networkClientId\n        ] = createAutoManagedNetworkClient({\n          networkClientId: addedRpcEndpoint.networkClientId,\n          networkClientConfiguration: {\n            type: NetworkClientType.Custom,\n            chainId: networkFields.chainId,\n            failoverRpcUrls: addedRpcEndpoint.failoverUrls,\n            rpcUrl: addedRpcEndpoint.url,\n            ticker: networkFields.nativeCurrency,\n          },\n          getRpcServiceOptions: this.#getRpcServiceOptions,\n          getBlockTrackerOptions: this.#getBlockTrackerOptions,\n          messenger: this.messenger,\n          isRpcFailoverEnabled: this.#isRpcFailoverEnabled,\n          logger: this.#log,\n        });\n      }\n    }\n  }\n\n  /**\n   * Destroys and removes network clients using the given operations calculated\n   * as a part of updating or removing a network.\n   *\n   * @param args - The arguments to this function.\n   * @param args.networkClientOperations - Dictate which network clients to\n   * remove.\n   * @param args.autoManagedNetworkClientRegistry - The network client registry\n   * to update.\n   */\n  #unregisterNetworkClientsAsNeeded({\n    networkClientOperations,\n    autoManagedNetworkClientRegistry,\n  }: {\n    networkClientOperations: NetworkClientOperation[];\n    autoManagedNetworkClientRegistry: AutoManagedNetworkClientRegistry;\n  }): void {\n    const removedRpcEndpoints = networkClientOperations\n      .filter(\n        (\n          networkClientOperation,\n        ): networkClientOperation is RemoveNetworkClientOperation => {\n          return networkClientOperation.type === 'remove';\n        },\n      )\n      .map((networkClientOperation) => networkClientOperation.rpcEndpoint)\n      .concat(\n        networkClientOperations\n          .filter(\n            (\n              networkClientOperation,\n            ): networkClientOperation is ReplaceNetworkClientOperation => {\n              return networkClientOperation.type === 'replace';\n            },\n          )\n          .map(\n            (networkClientOperation) => networkClientOperation.oldRpcEndpoint,\n          ),\n      );\n\n    for (const rpcEndpoint of removedRpcEndpoints) {\n      const networkClient = this.getNetworkClientById(\n        rpcEndpoint.networkClientId,\n      );\n      networkClient.destroy();\n      delete autoManagedNetworkClientRegistry[networkClient.configuration.type][\n        rpcEndpoint.networkClientId\n      ];\n    }\n  }\n\n  /**\n   * Updates `networkConfigurationsByChainId` in state depending on whether a\n   * network is being added, updated, or removed.\n   *\n   * - The existing network configuration will be removed when a network is\n   * being filed under a different chain or removed.\n   * - A network configuration will be stored when a network is being added or\n   * when a network is being updated.\n   *\n   * @param args - The arguments to this function.\n   */\n  #updateNetworkConfigurations(\n    args: { state: Draft<NetworkState> } & (\n      | {\n          mode: 'add';\n          networkFields: AddNetworkFields;\n          networkConfigurationToPersist: NetworkConfiguration;\n        }\n      | {\n          mode: 'update';\n          networkFields: UpdateNetworkFields;\n          networkConfigurationToPersist: NetworkConfiguration;\n          existingNetworkConfiguration: NetworkConfiguration;\n        }\n      | {\n          mode: 'remove';\n          existingNetworkConfiguration: NetworkConfiguration;\n        }\n    ),\n  ): void {\n    const { state, mode } = args;\n\n    if (\n      mode === 'remove' ||\n      (mode === 'update' &&\n        args.networkFields.chainId !==\n          args.existingNetworkConfiguration.chainId)\n    ) {\n      delete state.networkConfigurationsByChainId[\n        args.existingNetworkConfiguration.chainId\n      ];\n    }\n\n    if (mode === 'add' || mode === 'update') {\n      if (\n        !deepEqual(\n          state.networkConfigurationsByChainId[args.networkFields.chainId],\n          args.networkConfigurationToPersist,\n        )\n      ) {\n        args.networkConfigurationToPersist.lastUpdatedAt = Date.now();\n      }\n      state.networkConfigurationsByChainId[args.networkFields.chainId] =\n        args.networkConfigurationToPersist;\n    }\n\n    this.#networkConfigurationsByNetworkClientId =\n      buildNetworkConfigurationsByNetworkClientId(\n        cloneDeep(state.networkConfigurationsByChainId),\n      );\n  }\n\n  /**\n   * Before accessing or switching the network, the registry of network clients\n   * needs to be populated. Otherwise, `#applyNetworkSelection` and\n   * `getNetworkClientRegistry` will throw an error. This method checks to see if the\n   * population step has happened yet, and if not, makes it happen.\n   *\n   * @returns The populated network client registry.\n   */\n  #ensureAutoManagedNetworkClientRegistryPopulated(): AutoManagedNetworkClientRegistry {\n    return (this.#autoManagedNetworkClientRegistry ??=\n      this.#createAutoManagedNetworkClientRegistry());\n  }\n\n  /**\n   * Constructs the registry of network clients based on the set of default\n   * and custom networks in state.\n   *\n   * @returns The network clients keyed by ID.\n   */\n  #createAutoManagedNetworkClientRegistry(): AutoManagedNetworkClientRegistry {\n    const chainIds = knownKeysOf(this.state.networkConfigurationsByChainId);\n    const networkClientsWithIds = chainIds.flatMap((chainId) => {\n      const networkConfiguration =\n        this.state.networkConfigurationsByChainId[chainId];\n      return networkConfiguration.rpcEndpoints.map((rpcEndpoint) => {\n        if (rpcEndpoint.type === RpcEndpointType.Infura) {\n          const infuraNetworkName = deriveInfuraNetworkNameFromRpcEndpointUrl(\n            rpcEndpoint.url,\n          );\n          return [\n            rpcEndpoint.networkClientId,\n            createAutoManagedNetworkClient({\n              networkClientId: rpcEndpoint.networkClientId,\n              networkClientConfiguration: {\n                type: NetworkClientType.Infura,\n                network: infuraNetworkName,\n                failoverRpcUrls: rpcEndpoint.failoverUrls,\n                infuraProjectId: this.#infuraProjectId,\n                chainId: networkConfiguration.chainId,\n                ticker: networkConfiguration.nativeCurrency,\n              },\n              getRpcServiceOptions: this.#getRpcServiceOptions,\n              getBlockTrackerOptions: this.#getBlockTrackerOptions,\n              messenger: this.messenger,\n              isRpcFailoverEnabled: this.#isRpcFailoverEnabled,\n              logger: this.#log,\n            }),\n          ] as const;\n        }\n        return [\n          rpcEndpoint.networkClientId,\n          createAutoManagedNetworkClient({\n            networkClientId: rpcEndpoint.networkClientId,\n            networkClientConfiguration: {\n              type: NetworkClientType.Custom,\n              chainId: networkConfiguration.chainId,\n              failoverRpcUrls: rpcEndpoint.failoverUrls,\n              rpcUrl: rpcEndpoint.url,\n              ticker: networkConfiguration.nativeCurrency,\n            },\n            getRpcServiceOptions: this.#getRpcServiceOptions,\n            getBlockTrackerOptions: this.#getBlockTrackerOptions,\n            messenger: this.messenger,\n            isRpcFailoverEnabled: this.#isRpcFailoverEnabled,\n            logger: this.#log,\n          }),\n        ] as const;\n      });\n    });\n\n    return networkClientsWithIds.reduce(\n      (\n        obj: {\n          [NetworkClientType.Custom]: Partial<AutoManagedCustomNetworkClientRegistry>;\n          [NetworkClientType.Infura]: Partial<AutoManagedBuiltInNetworkClientRegistry>;\n        },\n        [networkClientId, networkClient],\n      ) => {\n        return {\n          ...obj,\n          [networkClient.configuration.type]: {\n            ...obj[networkClient.configuration.type],\n            [networkClientId]: networkClient,\n          },\n        };\n      },\n      {\n        [NetworkClientType.Custom]: {},\n        [NetworkClientType.Infura]: {},\n      },\n    ) as AutoManagedNetworkClientRegistry;\n  }\n\n  /**\n   * Updates the global provider and block tracker proxies (accessible via\n   * {@link getSelectedNetworkClient}) to point to the same ones within the\n   * given network client, thereby magically switching any consumers using these\n   * proxies to use the new network.\n   *\n   * Also refreshes the EthQuery instance accessible via the `getEthQuery`\n   * action to wrap the provider from the new network client. Note that this is\n   * not a proxy, so consumers will need to call `getEthQuery` again after the\n   * network switch.\n   *\n   * @param networkClientId - The ID of a network client that requests will be\n   * routed through (either the name of an Infura network or the ID of a custom\n   * network configuration).\n   * @param options - Options for this method.\n   * @param options.updateState - Allows for updating state.\n   * @throws if no network client could be found matching the given ID.\n   */\n  #applyNetworkSelection(\n    networkClientId: string,\n    {\n      updateState,\n    }: {\n      updateState?: (state: Draft<NetworkState>) => void;\n    } = {},\n  ): void {\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    let autoManagedNetworkClient:\n      | AutoManagedNetworkClient<CustomNetworkClientConfiguration>\n      | AutoManagedNetworkClient<InfuraNetworkClientConfiguration>;\n\n    if (isInfuraNetworkType(networkClientId)) {\n      const possibleAutoManagedNetworkClient =\n        autoManagedNetworkClientRegistry[NetworkClientType.Infura][\n          networkClientId\n        ];\n\n      // This is impossible to reach\n      /* istanbul ignore if */\n      if (!possibleAutoManagedNetworkClient) {\n        throw new Error(\n          `No Infura network client found with ID '${networkClientId}'`,\n        );\n      }\n\n      autoManagedNetworkClient = possibleAutoManagedNetworkClient;\n    } else {\n      const possibleAutoManagedNetworkClient =\n        autoManagedNetworkClientRegistry[NetworkClientType.Custom][\n          networkClientId\n        ];\n\n      if (!possibleAutoManagedNetworkClient) {\n        throw new Error(`No network client found with ID '${networkClientId}'`);\n      }\n\n      autoManagedNetworkClient = possibleAutoManagedNetworkClient;\n    }\n\n    this.#autoManagedNetworkClient = autoManagedNetworkClient;\n\n    this.update((state) => {\n      state.selectedNetworkClientId = networkClientId;\n      state.networksMetadata[networkClientId] ??= {\n        status: NetworkStatus.Unknown,\n        EIPS: {},\n      };\n\n      updateState?.(state);\n    });\n\n    if (this.#providerProxy) {\n      this.#providerProxy.setTarget(this.#autoManagedNetworkClient.provider);\n    } else {\n      this.#providerProxy = createSwappableProxy(\n        this.#autoManagedNetworkClient.provider,\n      );\n    }\n\n    if (this.#blockTrackerProxy) {\n      this.#blockTrackerProxy.setTarget(\n        this.#autoManagedNetworkClient.blockTracker,\n      );\n    } else {\n      this.#blockTrackerProxy = createEventEmitterProxy(\n        this.#autoManagedNetworkClient.blockTracker,\n        {\n          eventFilter: 'skipInternal',\n        },\n      );\n    }\n\n    this.#ethQuery = new EthQuery(this.#providerProxy);\n  }\n}\n"]}
\ No newline at end of file
diff --git a/dist/create-network-client.cjs b/dist/create-network-client.cjs
index 7a640d681f814dc4d5dd0a84ee63b18af183d847..144fcea5839f3d80d9f1902ef9217530c1cfcddc 100644
--- a/dist/create-network-client.cjs
+++ b/dist/create-network-client.cjs
@@ -2,6 +2,7 @@
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.createNetworkClient = void 0;
 const controller_utils_1 = require("@metamask/controller-utils");
+const throttled_fetch_1 = require("./throttled-fetch.cjs");
 const eth_block_tracker_1 = require("@metamask/eth-block-tracker");
 const eth_json_rpc_infura_1 = require("@metamask/eth-json-rpc-infura");
 const eth_json_rpc_middleware_1 = require("@metamask/eth-json-rpc-middleware");
@@ -113,11 +114,17 @@ function createRpcServiceChain({ id, primaryEndpointUrl, configuration, getRpcSe
     const availableEndpointUrls = isRpcFailoverEnabled
         ? [primaryEndpointUrl, ...(configuration.failoverRpcUrls ?? [])]
         : [primaryEndpointUrl];
-    const rpcServiceConfigurations = availableEndpointUrls.map((endpointUrl) => ({
-        ...getRpcServiceOptions(endpointUrl),
-        endpointUrl,
-        logger,
-    }));
+    const rpcServiceConfigurations = availableEndpointUrls.map((endpointUrl) => {
+        const options = getRpcServiceOptions(endpointUrl);
+        // Apply network throttling based on chain ID if configured
+        const throttledFetch = (0, throttled_fetch_1.createThrottledFetchForChainId)(endpointUrl, configuration.chainId, options.fetch);
+        return {
+            ...options,
+            fetch: throttledFetch,
+            endpointUrl,
+            logger,
+        };
+    });
     /**
      * Extracts the error from Cockatiel's `FailureReason` type received in
      * circuit breaker event handlers.
diff --git a/dist/create-network-client.cjs.map b/dist/create-network-client.cjs.map
index 9a7d894024ef24a0dd60e6394c491ae026eb829f..27619af39eaebda165d01447362efa0315f74743 100644
--- a/dist/create-network-client.cjs.map
+++ b/dist/create-network-client.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"create-network-client.cjs","sourceRoot":"","sources":["../src/create-network-client.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  CockatielFailureReason,\n  InfuraNetworkType,\n} from '@metamask/controller-utils';\nimport { ChainId } from '@metamask/controller-utils';\nimport type { PollingBlockTrackerOptions } from '@metamask/eth-block-tracker';\nimport { PollingBlockTracker } from '@metamask/eth-block-tracker';\nimport { createInfuraMiddleware } from '@metamask/eth-json-rpc-infura';\nimport {\n  createBlockCacheMiddleware,\n  createBlockRefMiddleware,\n  createBlockRefRewriteMiddleware,\n  createBlockTrackerInspectorMiddleware,\n  createInflightCacheMiddleware,\n  createFetchMiddleware,\n  createRetryOnEmptyMiddleware,\n} from '@metamask/eth-json-rpc-middleware';\nimport { InternalProvider } from '@metamask/eth-json-rpc-provider';\nimport { providerFromMiddlewareV2 } from '@metamask/eth-json-rpc-provider';\nimport { asV2Middleware } from '@metamask/json-rpc-engine';\nimport {\n  createScaffoldMiddleware,\n  JsonRpcEngineV2,\n} from '@metamask/json-rpc-engine/v2';\nimport type {\n  JsonRpcMiddleware,\n  MiddlewareContext,\n} from '@metamask/json-rpc-engine/v2';\nimport type { Hex, Json, JsonRpcRequest } from '@metamask/utils';\nimport type { Logger } from 'loglevel';\n\nimport type {\n  NetworkClientId,\n  NetworkControllerMessenger,\n} from './NetworkController';\nimport type { RpcServiceOptions } from './rpc-service/rpc-service';\nimport { RpcServiceChain } from './rpc-service/rpc-service-chain';\nimport type {\n  BlockTracker,\n  NetworkClientConfiguration,\n  Provider,\n} from './types';\nimport { NetworkClientType } from './types';\n\nconst SECOND = 1000;\n\n/**\n * The pair of provider / block tracker that can be used to interface with the\n * network and respond to new activity.\n */\nexport type NetworkClient = {\n  configuration: NetworkClientConfiguration;\n  provider: Provider;\n  blockTracker: BlockTracker;\n  destroy: () => void;\n};\n\ntype RpcApiMiddleware = JsonRpcMiddleware<\n  JsonRpcRequest,\n  Json,\n  MiddlewareContext<{ origin: string }>\n>;\n\n/**\n * Create a JSON RPC network client for a specific network.\n *\n * @param args - The arguments.\n * @param args.id - The ID that will be assigned to the new network client in\n * the registry.\n * @param args.configuration - The network configuration.\n * @param args.getRpcServiceOptions - Factory for constructing RPC service\n * options. See {@link NetworkControllerOptions.getRpcServiceOptions}.\n * @param args.getBlockTrackerOptions - Factory for constructing block tracker\n * options. See {@link NetworkControllerOptions.getBlockTrackerOptions}.\n * @param args.messenger - The network controller messenger.\n * @param args.isRpcFailoverEnabled - Whether or not requests sent to the\n * primary RPC endpoint for this network should be automatically diverted to\n * provided failover endpoints if the primary is unavailable. This effectively\n * causes the `failoverRpcUrls` property of the network client configuration\n * to be honored or ignored.\n * @param args.logger - A `loglevel` logger.\n * @returns The network client.\n */\nexport function createNetworkClient({\n  id,\n  configuration,\n  getRpcServiceOptions,\n  getBlockTrackerOptions,\n  messenger,\n  isRpcFailoverEnabled,\n  logger,\n}: {\n  id: NetworkClientId;\n  configuration: NetworkClientConfiguration;\n  getRpcServiceOptions: (\n    rpcEndpointUrl: string,\n  ) => Omit<RpcServiceOptions, 'failoverService' | 'endpointUrl'>;\n  getBlockTrackerOptions: (\n    rpcEndpointUrl: string,\n  ) => Omit<PollingBlockTrackerOptions, 'provider'>;\n  messenger: NetworkControllerMessenger;\n  isRpcFailoverEnabled: boolean;\n  logger?: Logger;\n}): NetworkClient {\n  const primaryEndpointUrl =\n    configuration.type === NetworkClientType.Infura\n      ? `https://${configuration.network}.infura.io/v3/${configuration.infuraProjectId}`\n      : configuration.rpcUrl;\n  const rpcServiceChain = createRpcServiceChain({\n    id,\n    primaryEndpointUrl,\n    configuration,\n    getRpcServiceOptions,\n    messenger,\n    isRpcFailoverEnabled,\n    logger,\n  });\n\n  let rpcApiMiddleware: RpcApiMiddleware;\n  if (configuration.type === NetworkClientType.Infura) {\n    rpcApiMiddleware = asV2Middleware(\n      createInfuraMiddleware({\n        rpcService: rpcServiceChain,\n        options: {\n          source: 'metamask',\n        },\n      }),\n    );\n  } else {\n    rpcApiMiddleware = createFetchMiddleware({ rpcService: rpcServiceChain });\n  }\n\n  const rpcProvider = providerFromMiddlewareV2(rpcApiMiddleware);\n\n  const blockTracker = createBlockTracker({\n    networkClientType: configuration.type,\n    endpointUrl: primaryEndpointUrl,\n    getOptions: getBlockTrackerOptions,\n    provider: rpcProvider,\n  });\n\n  const networkMiddleware =\n    configuration.type === NetworkClientType.Infura\n      ? createInfuraNetworkMiddleware({\n          blockTracker,\n          network: configuration.network,\n          rpcProvider,\n          rpcApiMiddleware,\n        })\n      : createCustomNetworkMiddleware({\n          blockTracker,\n          chainId: configuration.chainId,\n          rpcApiMiddleware,\n        });\n\n  const provider: Provider = new InternalProvider({\n    engine: JsonRpcEngineV2.create({\n      middleware: [networkMiddleware],\n    }),\n  });\n\n  const destroy = (): void => {\n    // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    blockTracker.destroy();\n  };\n\n  return { configuration, provider, blockTracker, destroy };\n}\n\n/**\n * Creates an RPC service chain, which represents the primary endpoint URL for\n * the network as well as its failover URLs.\n *\n * @param args - The arguments.\n * @param args.id - The ID that will be assigned to the new network client in\n * the registry.\n * @param args.primaryEndpointUrl - The primary endpoint URL.\n * @param args.configuration - The network configuration.\n * @param args.getRpcServiceOptions - Factory for constructing RPC service\n * options. See {@link NetworkControllerOptions.getRpcServiceOptions}.\n * @param args.messenger - The network controller messenger.\n * @param args.isRpcFailoverEnabled - Whether or not requests sent to the\n * primary RPC endpoint for this network should be automatically diverted to\n * provided failover endpoints if the primary is unavailable. This effectively\n * causes the `failoverRpcUrls` property of the network client configuration\n * to be honored or ignored.\n * @param args.logger - A `loglevel` logger.\n * @returns The RPC service chain.\n */\nfunction createRpcServiceChain({\n  id,\n  primaryEndpointUrl,\n  configuration,\n  getRpcServiceOptions,\n  messenger,\n  isRpcFailoverEnabled,\n  logger,\n}: {\n  id: NetworkClientId;\n  primaryEndpointUrl: string;\n  configuration: NetworkClientConfiguration;\n  getRpcServiceOptions: (\n    rpcEndpointUrl: string,\n  ) => Omit<RpcServiceOptions, 'failoverService' | 'endpointUrl'>;\n  messenger: NetworkControllerMessenger;\n  isRpcFailoverEnabled: boolean;\n  logger?: Logger;\n}): RpcServiceChain {\n  const availableEndpointUrls: [string, ...string[]] = isRpcFailoverEnabled\n    ? [primaryEndpointUrl, ...(configuration.failoverRpcUrls ?? [])]\n    : [primaryEndpointUrl];\n  const rpcServiceConfigurations = availableEndpointUrls.map((endpointUrl) => ({\n    ...getRpcServiceOptions(endpointUrl),\n    endpointUrl,\n    logger,\n  }));\n\n  /**\n   * Extracts the error from Cockatiel's `FailureReason` type received in\n   * circuit breaker event handlers.\n   *\n   * The `FailureReason` object can have two possible shapes:\n   * - `{ error: Error }` - When the RPC service throws an error (the common\n   * case for RPC failures).\n   * - `{ value: T }` - When the RPC service returns a value that the retry\n   * filter policy considers a failure.\n   *\n   * @param value - The event data object from the circuit breaker event\n   * listener (after destructuring known properties like `endpointUrl`). This\n   * represents Cockatiel's `FailureReason` type.\n   * @returns The error or failure value, or `undefined` if neither property\n   * exists (which shouldn't happen in practice unless the circuit breaker is\n   * manually isolated).\n   */\n  const getError = (\n    value: CockatielFailureReason<unknown> | Record<never, never>,\n  ): Error | unknown | undefined => {\n    if ('error' in value) {\n      return value.error;\n    } else if ('value' in value) {\n      return value.value;\n    }\n    return undefined;\n  };\n\n  const rpcServiceChain = new RpcServiceChain([\n    rpcServiceConfigurations[0],\n    ...rpcServiceConfigurations.slice(1),\n  ]);\n\n  rpcServiceChain.onBreak((data) => {\n    const error = getError(data);\n\n    if (error === undefined) {\n      // This error shouldn't happen in practice because we never call `.isolate`\n      // on the circuit breaker policy, but we need to appease TypeScript.\n      throw new Error('Could not make request to endpoint.');\n    }\n\n    messenger.publish('NetworkController:rpcEndpointChainUnavailable', {\n      chainId: configuration.chainId,\n      networkClientId: id,\n      error,\n    });\n  });\n\n  rpcServiceChain.onServiceBreak(\n    ({\n      endpointUrl,\n      primaryEndpointUrl: primaryEndpointUrlFromEvent,\n      ...rest\n    }) => {\n      const error = getError(rest);\n\n      if (error === undefined) {\n        // This error shouldn't happen in practice because we never call `.isolate`\n        // on the circuit breaker policy, but we need to appease TypeScript.\n        throw new Error('Could not make request to endpoint.');\n      }\n\n      messenger.publish('NetworkController:rpcEndpointUnavailable', {\n        chainId: configuration.chainId,\n        networkClientId: id,\n        primaryEndpointUrl: primaryEndpointUrlFromEvent,\n        endpointUrl,\n        error,\n      });\n    },\n  );\n\n  rpcServiceChain.onDegraded((data) => {\n    const error = getError(data);\n    messenger.publish('NetworkController:rpcEndpointChainDegraded', {\n      chainId: configuration.chainId,\n      networkClientId: id,\n      error,\n    });\n  });\n\n  rpcServiceChain.onServiceDegraded(\n    ({\n      endpointUrl,\n      primaryEndpointUrl: primaryEndpointUrlFromEvent,\n      ...rest\n    }) => {\n      const error = getError(rest);\n      messenger.publish('NetworkController:rpcEndpointDegraded', {\n        chainId: configuration.chainId,\n        networkClientId: id,\n        primaryEndpointUrl: primaryEndpointUrlFromEvent,\n        endpointUrl,\n        error,\n      });\n    },\n  );\n\n  rpcServiceChain.onAvailable(() => {\n    messenger.publish('NetworkController:rpcEndpointChainAvailable', {\n      chainId: configuration.chainId,\n      networkClientId: id,\n    });\n  });\n\n  rpcServiceChain.onServiceRetry(\n    ({\n      attempt,\n      endpointUrl,\n      primaryEndpointUrl: primaryEndpointUrlFromEvent,\n    }) => {\n      messenger.publish('NetworkController:rpcEndpointRetried', {\n        chainId: configuration.chainId,\n        networkClientId: id,\n        primaryEndpointUrl: primaryEndpointUrlFromEvent,\n        endpointUrl,\n        attempt,\n      });\n    },\n  );\n\n  return rpcServiceChain;\n}\n\n/**\n * Create the block tracker for the network.\n *\n * @param args - The arguments.\n * @param args.networkClientType - The type of the network client (\"infura\" or\n * \"custom\").\n * @param args.endpointUrl - The URL of the endpoint.\n * @param args.getOptions - Factory for the block tracker options.\n * @param args.provider - The EIP-1193 provider for the network's JSON-RPC\n * middleware stack.\n * @returns The created block tracker.\n */\nfunction createBlockTracker({\n  networkClientType,\n  endpointUrl,\n  getOptions,\n  provider,\n}: {\n  networkClientType: NetworkClientType;\n  endpointUrl: string;\n  getOptions: (\n    rpcEndpointUrl: string,\n  ) => Omit<PollingBlockTrackerOptions, 'provider'>;\n  provider: InternalProvider;\n}): PollingBlockTracker {\n  const testOptions =\n    // Needed for testing.\n    // eslint-disable-next-line no-restricted-globals\n    process.env.IN_TEST && networkClientType === NetworkClientType.Custom\n      ? { pollingInterval: SECOND }\n      : {};\n\n  return new PollingBlockTracker({\n    ...testOptions,\n    ...getOptions(endpointUrl),\n    provider,\n  });\n}\n\n/**\n * Create middleware for infura.\n *\n * @param args - The arguments.\n * @param args.blockTracker - The block tracker to use.\n * @param args.network - The Infura network to use.\n * @param args.rpcProvider - The RPC provider to use.\n * @param args.rpcApiMiddleware - Additional middleware.\n * @returns The collection of middleware that makes up the Infura client.\n */\nfunction createInfuraNetworkMiddleware({\n  blockTracker,\n  network,\n  rpcProvider,\n  rpcApiMiddleware,\n}: {\n  blockTracker: PollingBlockTracker;\n  network: InfuraNetworkType;\n  rpcProvider: InternalProvider;\n  rpcApiMiddleware: RpcApiMiddleware;\n}): JsonRpcMiddleware<\n  JsonRpcRequest,\n  Json,\n  MiddlewareContext<{ origin: string; skipCache: boolean }>\n> {\n  return JsonRpcEngineV2.create({\n    middleware: [\n      createNetworkAndChainIdMiddleware({ network }),\n      createBlockCacheMiddleware({ blockTracker }),\n      createInflightCacheMiddleware(),\n      createBlockRefMiddleware({ blockTracker, provider: rpcProvider }),\n      createRetryOnEmptyMiddleware({ blockTracker, provider: rpcProvider }),\n      createBlockTrackerInspectorMiddleware({ blockTracker }),\n      rpcApiMiddleware,\n    ],\n  }).asMiddleware();\n}\n\n/**\n * Creates static method middleware.\n *\n * @param args - The Arguments.\n * @param args.network - The Infura network to use.\n * @returns The middleware that implements the eth_chainId method.\n */\nfunction createNetworkAndChainIdMiddleware({\n  network,\n}: {\n  network: InfuraNetworkType;\n}): JsonRpcMiddleware<JsonRpcRequest> {\n  return createScaffoldMiddleware({\n    eth_chainId: ChainId[network],\n  });\n}\n\nconst createChainIdMiddleware = (\n  chainId: Hex,\n): JsonRpcMiddleware<JsonRpcRequest, Json> => {\n  return ({ request, next }) => {\n    if (request.method === 'eth_chainId') {\n      return chainId;\n    }\n    return next();\n  };\n};\n\n/**\n * Creates custom middleware.\n *\n * @param args - The arguments.\n * @param args.blockTracker - The block tracker to use.\n * @param args.chainId - The chain id to use.\n * @param args.rpcApiMiddleware - Additional middleware.\n * @returns The collection of middleware that makes up the Infura client.\n */\nfunction createCustomNetworkMiddleware({\n  blockTracker,\n  chainId,\n  rpcApiMiddleware,\n}: {\n  blockTracker: PollingBlockTracker;\n  chainId: Hex;\n  rpcApiMiddleware: RpcApiMiddleware;\n}): JsonRpcMiddleware<\n  JsonRpcRequest,\n  Json,\n  MiddlewareContext<{ origin: string; skipCache: boolean }>\n> {\n  // Needed for testing.\n  // eslint-disable-next-line no-restricted-globals\n  const testMiddlewares = process.env.IN_TEST\n    ? [createEstimateGasDelayTestMiddleware()]\n    : [];\n\n  return JsonRpcEngineV2.create({\n    middleware: [\n      ...testMiddlewares,\n      createChainIdMiddleware(chainId),\n      createBlockRefRewriteMiddleware({ blockTracker }),\n      createBlockCacheMiddleware({ blockTracker }),\n      createInflightCacheMiddleware(),\n      createBlockTrackerInspectorMiddleware({ blockTracker }),\n      rpcApiMiddleware,\n    ],\n  }).asMiddleware();\n}\n\n/**\n * For use in tests only.\n * Adds a delay to `eth_estimateGas` calls.\n *\n * @returns The middleware for delaying gas estimation calls by 2 seconds when in test.\n */\nfunction createEstimateGasDelayTestMiddleware(): JsonRpcMiddleware<\n  JsonRpcRequest,\n  Json\n> {\n  return async ({ request, next }) => {\n    if (request.method === 'eth_estimateGas') {\n      await new Promise((resolve) => setTimeout(resolve, SECOND * 2));\n    }\n    return next();\n  };\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"create-network-client.cjs","sourceRoot":"","sources":["../src/create-network-client.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  CockatielFailureReason,\n  InfuraNetworkType,\n} from '@metamask/controller-utils';\nimport { ChainId } from '@metamask/controller-utils';\n\nimport { createThrottledFetchForChainId } from './throttled-fetch';\n\nimport type { PollingBlockTrackerOptions } from '@metamask/eth-block-tracker';\nimport { PollingBlockTracker } from '@metamask/eth-block-tracker';\nimport { createInfuraMiddleware } from '@metamask/eth-json-rpc-infura';\nimport {\n  createBlockCacheMiddleware,\n  createBlockRefMiddleware,\n  createBlockRefRewriteMiddleware,\n  createBlockTrackerInspectorMiddleware,\n  createInflightCacheMiddleware,\n  createFetchMiddleware,\n  createRetryOnEmptyMiddleware,\n} from '@metamask/eth-json-rpc-middleware';\nimport { InternalProvider } from '@metamask/eth-json-rpc-provider';\nimport { providerFromMiddlewareV2 } from '@metamask/eth-json-rpc-provider';\nimport { asV2Middleware } from '@metamask/json-rpc-engine';\nimport {\n  createScaffoldMiddleware,\n  JsonRpcEngineV2,\n} from '@metamask/json-rpc-engine/v2';\nimport type {\n  JsonRpcMiddleware,\n  MiddlewareContext,\n} from '@metamask/json-rpc-engine/v2';\nimport type { Hex, Json, JsonRpcRequest } from '@metamask/utils';\nimport type { Logger } from 'loglevel';\n\nimport type {\n  NetworkClientId,\n  NetworkControllerMessenger,\n} from './NetworkController';\nimport type { RpcServiceOptions } from './rpc-service/rpc-service';\nimport { RpcServiceChain } from './rpc-service/rpc-service-chain';\nimport type {\n  BlockTracker,\n  NetworkClientConfiguration,\n  Provider,\n} from './types';\nimport { NetworkClientType } from './types';\n\nconst SECOND = 1000;\n\n/**\n * The pair of provider / block tracker that can be used to interface with the\n * network and respond to new activity.\n */\nexport type NetworkClient = {\n  configuration: NetworkClientConfiguration;\n  provider: Provider;\n  blockTracker: BlockTracker;\n  destroy: () => void;\n};\n\ntype RpcApiMiddleware = JsonRpcMiddleware<\n  JsonRpcRequest,\n  Json,\n  MiddlewareContext<{ origin: string }>\n>;\n\n/**\n * Create a JSON RPC network client for a specific network.\n *\n * @param args - The arguments.\n * @param args.id - The ID that will be assigned to the new network client in\n * the registry.\n * @param args.configuration - The network configuration.\n * @param args.getRpcServiceOptions - Factory for constructing RPC service\n * options. See {@link NetworkControllerOptions.getRpcServiceOptions}.\n * @param args.getBlockTrackerOptions - Factory for constructing block tracker\n * options. See {@link NetworkControllerOptions.getBlockTrackerOptions}.\n * @param args.messenger - The network controller messenger.\n * @param args.isRpcFailoverEnabled - Whether or not requests sent to the\n * primary RPC endpoint for this network should be automatically diverted to\n * provided failover endpoints if the primary is unavailable. This effectively\n * causes the `failoverRpcUrls` property of the network client configuration\n * to be honored or ignored.\n * @param args.logger - A `loglevel` logger.\n * @returns The network client.\n */\nexport function createNetworkClient({\n  id,\n  configuration,\n  getRpcServiceOptions,\n  getBlockTrackerOptions,\n  messenger,\n  isRpcFailoverEnabled,\n  logger,\n}: {\n  id: NetworkClientId;\n  configuration: NetworkClientConfiguration;\n  getRpcServiceOptions: (\n    rpcEndpointUrl: string,\n  ) => Omit<RpcServiceOptions, 'failoverService' | 'endpointUrl'>;\n  getBlockTrackerOptions: (\n    rpcEndpointUrl: string,\n  ) => Omit<PollingBlockTrackerOptions, 'provider'>;\n  messenger: NetworkControllerMessenger;\n  isRpcFailoverEnabled: boolean;\n  logger?: Logger;\n}): NetworkClient {\n  const primaryEndpointUrl =\n    configuration.type === NetworkClientType.Infura\n      ? `https://${configuration.network}.infura.io/v3/${configuration.infuraProjectId}`\n      : configuration.rpcUrl;\n  const rpcServiceChain = createRpcServiceChain({\n    id,\n    primaryEndpointUrl,\n    configuration,\n    getRpcServiceOptions,\n    messenger,\n    isRpcFailoverEnabled,\n    logger,\n  });\n\n  let rpcApiMiddleware: RpcApiMiddleware;\n  if (configuration.type === NetworkClientType.Infura) {\n    rpcApiMiddleware = asV2Middleware(\n      createInfuraMiddleware({\n        rpcService: rpcServiceChain,\n        options: {\n          source: 'metamask',\n        },\n      }),\n    );\n  } else {\n    rpcApiMiddleware = createFetchMiddleware({ rpcService: rpcServiceChain });\n  }\n\n  const rpcProvider = providerFromMiddlewareV2(rpcApiMiddleware);\n\n  const blockTracker = createBlockTracker({\n    networkClientType: configuration.type,\n    endpointUrl: primaryEndpointUrl,\n    getOptions: getBlockTrackerOptions,\n    provider: rpcProvider,\n  });\n\n  const networkMiddleware =\n    configuration.type === NetworkClientType.Infura\n      ? createInfuraNetworkMiddleware({\n          blockTracker,\n          network: configuration.network,\n          rpcProvider,\n          rpcApiMiddleware,\n        })\n      : createCustomNetworkMiddleware({\n          blockTracker,\n          chainId: configuration.chainId,\n          rpcApiMiddleware,\n        });\n\n  const provider: Provider = new InternalProvider({\n    engine: JsonRpcEngineV2.create({\n      middleware: [networkMiddleware],\n    }),\n  });\n\n  const destroy = (): void => {\n    // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    blockTracker.destroy();\n  };\n\n  return { configuration, provider, blockTracker, destroy };\n}\n\n/**\n * Creates an RPC service chain, which represents the primary endpoint URL for\n * the network as well as its failover URLs.\n *\n * @param args - The arguments.\n * @param args.id - The ID that will be assigned to the new network client in\n * the registry.\n * @param args.primaryEndpointUrl - The primary endpoint URL.\n * @param args.configuration - The network configuration.\n * @param args.getRpcServiceOptions - Factory for constructing RPC service\n * options. See {@link NetworkControllerOptions.getRpcServiceOptions}.\n * @param args.messenger - The network controller messenger.\n * @param args.isRpcFailoverEnabled - Whether or not requests sent to the\n * primary RPC endpoint for this network should be automatically diverted to\n * provided failover endpoints if the primary is unavailable. This effectively\n * causes the `failoverRpcUrls` property of the network client configuration\n * to be honored or ignored.\n * @param args.logger - A `loglevel` logger.\n * @returns The RPC service chain.\n */\nfunction createRpcServiceChain({\n  id,\n  primaryEndpointUrl,\n  configuration,\n  getRpcServiceOptions,\n  messenger,\n  isRpcFailoverEnabled,\n  logger,\n}: {\n  id: NetworkClientId;\n  primaryEndpointUrl: string;\n  configuration: NetworkClientConfiguration;\n  getRpcServiceOptions: (\n    rpcEndpointUrl: string,\n  ) => Omit<RpcServiceOptions, 'failoverService' | 'endpointUrl'>;\n  messenger: NetworkControllerMessenger;\n  isRpcFailoverEnabled: boolean;\n  logger?: Logger;\n}): RpcServiceChain {\n  const availableEndpointUrls: [string, ...string[]] = isRpcFailoverEnabled\n    ? [primaryEndpointUrl, ...(configuration.failoverRpcUrls ?? [])]\n    : [primaryEndpointUrl];\n  const rpcServiceConfigurations = availableEndpointUrls.map((endpointUrl) => {\n    const options = getRpcServiceOptions(endpointUrl);\n\n    // Apply network throttling based on chain ID if configured\n    const throttledFetch = createThrottledFetchForChainId(\n      endpointUrl,\n      configuration.chainId,\n      options.fetch,\n    );\n\n    return {\n      ...options,\n      fetch: throttledFetch,\n      endpointUrl,\n      logger,\n    };\n  });\n\n  /**\n   * Extracts the error from Cockatiel's `FailureReason` type received in\n   * circuit breaker event handlers.\n   *\n   * The `FailureReason` object can have two possible shapes:\n   * - `{ error: Error }` - When the RPC service throws an error (the common\n   * case for RPC failures).\n   * - `{ value: T }` - When the RPC service returns a value that the retry\n   * filter policy considers a failure.\n   *\n   * @param value - The event data object from the circuit breaker event\n   * listener (after destructuring known properties like `endpointUrl`). This\n   * represents Cockatiel's `FailureReason` type.\n   * @returns The error or failure value, or `undefined` if neither property\n   * exists (which shouldn't happen in practice unless the circuit breaker is\n   * manually isolated).\n   */\n  const getError = (\n    value: CockatielFailureReason<unknown> | Record<never, never>,\n  ): Error | unknown | undefined => {\n    if ('error' in value) {\n      return value.error;\n    } else if ('value' in value) {\n      return value.value;\n    }\n    return undefined;\n  };\n\n  const rpcServiceChain = new RpcServiceChain([\n    rpcServiceConfigurations[0],\n    ...rpcServiceConfigurations.slice(1),\n  ]);\n\n  rpcServiceChain.onBreak((data) => {\n    const error = getError(data);\n\n    if (error === undefined) {\n      // This error shouldn't happen in practice because we never call `.isolate`\n      // on the circuit breaker policy, but we need to appease TypeScript.\n      throw new Error('Could not make request to endpoint.');\n    }\n\n    messenger.publish('NetworkController:rpcEndpointChainUnavailable', {\n      chainId: configuration.chainId,\n      networkClientId: id,\n      error,\n    });\n  });\n\n  rpcServiceChain.onServiceBreak(\n    ({\n      endpointUrl,\n      primaryEndpointUrl: primaryEndpointUrlFromEvent,\n      ...rest\n    }) => {\n      const error = getError(rest);\n\n      if (error === undefined) {\n        // This error shouldn't happen in practice because we never call `.isolate`\n        // on the circuit breaker policy, but we need to appease TypeScript.\n        throw new Error('Could not make request to endpoint.');\n      }\n\n      messenger.publish('NetworkController:rpcEndpointUnavailable', {\n        chainId: configuration.chainId,\n        networkClientId: id,\n        primaryEndpointUrl: primaryEndpointUrlFromEvent,\n        endpointUrl,\n        error,\n      });\n    },\n  );\n\n  rpcServiceChain.onDegraded((data) => {\n    const error = getError(data);\n    messenger.publish('NetworkController:rpcEndpointChainDegraded', {\n      chainId: configuration.chainId,\n      networkClientId: id,\n      error,\n    });\n  });\n\n  rpcServiceChain.onServiceDegraded(\n    ({\n      endpointUrl,\n      primaryEndpointUrl: primaryEndpointUrlFromEvent,\n      ...rest\n    }) => {\n      const error = getError(rest);\n      messenger.publish('NetworkController:rpcEndpointDegraded', {\n        chainId: configuration.chainId,\n        networkClientId: id,\n        primaryEndpointUrl: primaryEndpointUrlFromEvent,\n        endpointUrl,\n        error,\n      });\n    },\n  );\n\n  rpcServiceChain.onAvailable(() => {\n    messenger.publish('NetworkController:rpcEndpointChainAvailable', {\n      chainId: configuration.chainId,\n      networkClientId: id,\n    });\n  });\n\n  rpcServiceChain.onServiceRetry(\n    ({\n      attempt,\n      endpointUrl,\n      primaryEndpointUrl: primaryEndpointUrlFromEvent,\n    }) => {\n      messenger.publish('NetworkController:rpcEndpointRetried', {\n        chainId: configuration.chainId,\n        networkClientId: id,\n        primaryEndpointUrl: primaryEndpointUrlFromEvent,\n        endpointUrl,\n        attempt,\n      });\n    },\n  );\n\n  return rpcServiceChain;\n}\n\n/**\n * Create the block tracker for the network.\n *\n * @param args - The arguments.\n * @param args.networkClientType - The type of the network client (\"infura\" or\n * \"custom\").\n * @param args.endpointUrl - The URL of the endpoint.\n * @param args.getOptions - Factory for the block tracker options.\n * @param args.provider - The EIP-1193 provider for the network's JSON-RPC\n * middleware stack.\n * @returns The created block tracker.\n */\nfunction createBlockTracker({\n  networkClientType,\n  endpointUrl,\n  getOptions,\n  provider,\n}: {\n  networkClientType: NetworkClientType;\n  endpointUrl: string;\n  getOptions: (\n    rpcEndpointUrl: string,\n  ) => Omit<PollingBlockTrackerOptions, 'provider'>;\n  provider: InternalProvider;\n}): PollingBlockTracker {\n  const testOptions =\n    // Needed for testing.\n    // eslint-disable-next-line no-restricted-globals\n    process.env.IN_TEST && networkClientType === NetworkClientType.Custom\n      ? { pollingInterval: SECOND }\n      : {};\n\n  return new PollingBlockTracker({\n    ...testOptions,\n    ...getOptions(endpointUrl),\n    provider,\n  });\n}\n\n/**\n * Create middleware for infura.\n *\n * @param args - The arguments.\n * @param args.blockTracker - The block tracker to use.\n * @param args.network - The Infura network to use.\n * @param args.rpcProvider - The RPC provider to use.\n * @param args.rpcApiMiddleware - Additional middleware.\n * @returns The collection of middleware that makes up the Infura client.\n */\nfunction createInfuraNetworkMiddleware({\n  blockTracker,\n  network,\n  rpcProvider,\n  rpcApiMiddleware,\n}: {\n  blockTracker: PollingBlockTracker;\n  network: InfuraNetworkType;\n  rpcProvider: InternalProvider;\n  rpcApiMiddleware: RpcApiMiddleware;\n}): JsonRpcMiddleware<\n  JsonRpcRequest,\n  Json,\n  MiddlewareContext<{ origin: string; skipCache: boolean }>\n> {\n  return JsonRpcEngineV2.create({\n    middleware: [\n      createNetworkAndChainIdMiddleware({ network }),\n      createBlockCacheMiddleware({ blockTracker }),\n      createInflightCacheMiddleware(),\n      createBlockRefMiddleware({ blockTracker, provider: rpcProvider }),\n      createRetryOnEmptyMiddleware({ blockTracker, provider: rpcProvider }),\n      createBlockTrackerInspectorMiddleware({ blockTracker }),\n      rpcApiMiddleware,\n    ],\n  }).asMiddleware();\n}\n\n/**\n * Creates static method middleware.\n *\n * @param args - The Arguments.\n * @param args.network - The Infura network to use.\n * @returns The middleware that implements the eth_chainId method.\n */\nfunction createNetworkAndChainIdMiddleware({\n  network,\n}: {\n  network: InfuraNetworkType;\n}): JsonRpcMiddleware<JsonRpcRequest> {\n  return createScaffoldMiddleware({\n    eth_chainId: ChainId[network],\n  });\n}\n\nconst createChainIdMiddleware = (\n  chainId: Hex,\n): JsonRpcMiddleware<JsonRpcRequest, Json> => {\n  return ({ request, next }) => {\n    if (request.method === 'eth_chainId') {\n      return chainId;\n    }\n    return next();\n  };\n};\n\n/**\n * Creates custom middleware.\n *\n * @param args - The arguments.\n * @param args.blockTracker - The block tracker to use.\n * @param args.chainId - The chain id to use.\n * @param args.rpcApiMiddleware - Additional middleware.\n * @returns The collection of middleware that makes up the Infura client.\n */\nfunction createCustomNetworkMiddleware({\n  blockTracker,\n  chainId,\n  rpcApiMiddleware,\n}: {\n  blockTracker: PollingBlockTracker;\n  chainId: Hex;\n  rpcApiMiddleware: RpcApiMiddleware;\n}): JsonRpcMiddleware<\n  JsonRpcRequest,\n  Json,\n  MiddlewareContext<{ origin: string; skipCache: boolean }>\n> {\n  // Needed for testing.\n  // eslint-disable-next-line no-restricted-globals\n  const testMiddlewares = process.env.IN_TEST\n    ? [createEstimateGasDelayTestMiddleware()]\n    : [];\n\n  return JsonRpcEngineV2.create({\n    middleware: [\n      ...testMiddlewares,\n      createChainIdMiddleware(chainId),\n      createBlockRefRewriteMiddleware({ blockTracker }),\n      createBlockCacheMiddleware({ blockTracker }),\n      createInflightCacheMiddleware(),\n      createBlockTrackerInspectorMiddleware({ blockTracker }),\n      rpcApiMiddleware,\n    ],\n  }).asMiddleware();\n}\n\n/**\n * For use in tests only.\n * Adds a delay to `eth_estimateGas` calls.\n *\n * @returns The middleware for delaying gas estimation calls by 2 seconds when in test.\n */\nfunction createEstimateGasDelayTestMiddleware(): JsonRpcMiddleware<\n  JsonRpcRequest,\n  Json\n> {\n  return async ({ request, next }) => {\n    if (request.method === 'eth_estimateGas') {\n      await new Promise((resolve) => setTimeout(resolve, SECOND * 2));\n    }\n    return next();\n  };\n}\n"]}
\ No newline at end of file
diff --git a/dist/create-network-client.d.cts.map b/dist/create-network-client.d.cts.map
index cf8a8c190da7b0f0208ce2ba9bcc95890a56b8ee..684c4c4e026c95cd51ee6b331b4e7ebf1d3017e8 100644
--- a/dist/create-network-client.d.cts.map
+++ b/dist/create-network-client.d.cts.map
@@ -1 +1 @@
-{"version":3,"file":"create-network-client.d.cts","sourceRoot":"","sources":["../src/create-network-client.ts"],"names":[],"mappings":"AAKA,OAAO,KAAK,EAAE,0BAA0B,EAAE,oCAAoC;AAwB9E,OAAO,KAAK,EAAE,MAAM,EAAE,iBAAiB;AAEvC,OAAO,KAAK,EACV,eAAe,EACf,0BAA0B,EAC3B,gCAA4B;AAC7B,OAAO,KAAK,EAAE,iBAAiB,EAAE,sCAAkC;AAEnE,OAAO,KAAK,EACV,YAAY,EACZ,0BAA0B,EAC1B,QAAQ,EACT,oBAAgB;AAKjB;;;GAGG;AACH,MAAM,MAAM,aAAa,GAAG;IAC1B,aAAa,EAAE,0BAA0B,CAAC;IAC1C,QAAQ,EAAE,QAAQ,CAAC;IACnB,YAAY,EAAE,YAAY,CAAC;IAC3B,OAAO,EAAE,MAAM,IAAI,CAAC;CACrB,CAAC;AAQF;;;;;;;;;;;;;;;;;;;GAmBG;AACH,wBAAgB,mBAAmB,CAAC,EAClC,EAAE,EACF,aAAa,EACb,oBAAoB,EACpB,sBAAsB,EACtB,SAAS,EACT,oBAAoB,EACpB,MAAM,GACP,EAAE;IACD,EAAE,EAAE,eAAe,CAAC;IACpB,aAAa,EAAE,0BAA0B,CAAC;IAC1C,oBAAoB,EAAE,CACpB,cAAc,EAAE,MAAM,KACnB,IAAI,CAAC,iBAAiB,EAAE,iBAAiB,GAAG,aAAa,CAAC,CAAC;IAChE,sBAAsB,EAAE,CACtB,cAAc,EAAE,MAAM,KACnB,IAAI,CAAC,0BAA0B,EAAE,UAAU,CAAC,CAAC;IAClD,SAAS,EAAE,0BAA0B,CAAC;IACtC,oBAAoB,EAAE,OAAO,CAAC;IAC9B,MAAM,CAAC,EAAE,MAAM,CAAC;CACjB,GAAG,aAAa,CAiEhB"}
\ No newline at end of file
+{"version":3,"file":"create-network-client.d.cts","sourceRoot":"","sources":["../src/create-network-client.ts"],"names":[],"mappings":"AAQA,OAAO,KAAK,EAAE,0BAA0B,EAAE,oCAAoC;AAwB9E,OAAO,KAAK,EAAE,MAAM,EAAE,iBAAiB;AAEvC,OAAO,KAAK,EACV,eAAe,EACf,0BAA0B,EAC3B,gCAA4B;AAC7B,OAAO,KAAK,EAAE,iBAAiB,EAAE,sCAAkC;AAEnE,OAAO,KAAK,EACV,YAAY,EACZ,0BAA0B,EAC1B,QAAQ,EACT,oBAAgB;AAKjB;;;GAGG;AACH,MAAM,MAAM,aAAa,GAAG;IAC1B,aAAa,EAAE,0BAA0B,CAAC;IAC1C,QAAQ,EAAE,QAAQ,CAAC;IACnB,YAAY,EAAE,YAAY,CAAC;IAC3B,OAAO,EAAE,MAAM,IAAI,CAAC;CACrB,CAAC;AAQF;;;;;;;;;;;;;;;;;;;GAmBG;AACH,wBAAgB,mBAAmB,CAAC,EAClC,EAAE,EACF,aAAa,EACb,oBAAoB,EACpB,sBAAsB,EACtB,SAAS,EACT,oBAAoB,EACpB,MAAM,GACP,EAAE;IACD,EAAE,EAAE,eAAe,CAAC;IACpB,aAAa,EAAE,0BAA0B,CAAC;IAC1C,oBAAoB,EAAE,CACpB,cAAc,EAAE,MAAM,KACnB,IAAI,CAAC,iBAAiB,EAAE,iBAAiB,GAAG,aAAa,CAAC,CAAC;IAChE,sBAAsB,EAAE,CACtB,cAAc,EAAE,MAAM,KACnB,IAAI,CAAC,0BAA0B,EAAE,UAAU,CAAC,CAAC;IAClD,SAAS,EAAE,0BAA0B,CAAC;IACtC,oBAAoB,EAAE,OAAO,CAAC;IAC9B,MAAM,CAAC,EAAE,MAAM,CAAC;CACjB,GAAG,aAAa,CAiEhB"}
\ No newline at end of file
diff --git a/dist/create-network-client.d.mts.map b/dist/create-network-client.d.mts.map
index 85b897be53f80a49bd20a8202bcdbb4f18d37437..cf1161677591b6da5b350ac4a549c889dacd0957 100644
--- a/dist/create-network-client.d.mts.map
+++ b/dist/create-network-client.d.mts.map
@@ -1 +1 @@
-{"version":3,"file":"create-network-client.d.mts","sourceRoot":"","sources":["../src/create-network-client.ts"],"names":[],"mappings":"AAKA,OAAO,KAAK,EAAE,0BAA0B,EAAE,oCAAoC;AAwB9E,OAAO,KAAK,EAAE,MAAM,EAAE,iBAAiB;AAEvC,OAAO,KAAK,EACV,eAAe,EACf,0BAA0B,EAC3B,gCAA4B;AAC7B,OAAO,KAAK,EAAE,iBAAiB,EAAE,sCAAkC;AAEnE,OAAO,KAAK,EACV,YAAY,EACZ,0BAA0B,EAC1B,QAAQ,EACT,oBAAgB;AAKjB;;;GAGG;AACH,MAAM,MAAM,aAAa,GAAG;IAC1B,aAAa,EAAE,0BAA0B,CAAC;IAC1C,QAAQ,EAAE,QAAQ,CAAC;IACnB,YAAY,EAAE,YAAY,CAAC;IAC3B,OAAO,EAAE,MAAM,IAAI,CAAC;CACrB,CAAC;AAQF;;;;;;;;;;;;;;;;;;;GAmBG;AACH,wBAAgB,mBAAmB,CAAC,EAClC,EAAE,EACF,aAAa,EACb,oBAAoB,EACpB,sBAAsB,EACtB,SAAS,EACT,oBAAoB,EACpB,MAAM,GACP,EAAE;IACD,EAAE,EAAE,eAAe,CAAC;IACpB,aAAa,EAAE,0BAA0B,CAAC;IAC1C,oBAAoB,EAAE,CACpB,cAAc,EAAE,MAAM,KACnB,IAAI,CAAC,iBAAiB,EAAE,iBAAiB,GAAG,aAAa,CAAC,CAAC;IAChE,sBAAsB,EAAE,CACtB,cAAc,EAAE,MAAM,KACnB,IAAI,CAAC,0BAA0B,EAAE,UAAU,CAAC,CAAC;IAClD,SAAS,EAAE,0BAA0B,CAAC;IACtC,oBAAoB,EAAE,OAAO,CAAC;IAC9B,MAAM,CAAC,EAAE,MAAM,CAAC;CACjB,GAAG,aAAa,CAiEhB"}
\ No newline at end of file
+{"version":3,"file":"create-network-client.d.mts","sourceRoot":"","sources":["../src/create-network-client.ts"],"names":[],"mappings":"AAQA,OAAO,KAAK,EAAE,0BAA0B,EAAE,oCAAoC;AAwB9E,OAAO,KAAK,EAAE,MAAM,EAAE,iBAAiB;AAEvC,OAAO,KAAK,EACV,eAAe,EACf,0BAA0B,EAC3B,gCAA4B;AAC7B,OAAO,KAAK,EAAE,iBAAiB,EAAE,sCAAkC;AAEnE,OAAO,KAAK,EACV,YAAY,EACZ,0BAA0B,EAC1B,QAAQ,EACT,oBAAgB;AAKjB;;;GAGG;AACH,MAAM,MAAM,aAAa,GAAG;IAC1B,aAAa,EAAE,0BAA0B,CAAC;IAC1C,QAAQ,EAAE,QAAQ,CAAC;IACnB,YAAY,EAAE,YAAY,CAAC;IAC3B,OAAO,EAAE,MAAM,IAAI,CAAC;CACrB,CAAC;AAQF;;;;;;;;;;;;;;;;;;;GAmBG;AACH,wBAAgB,mBAAmB,CAAC,EAClC,EAAE,EACF,aAAa,EACb,oBAAoB,EACpB,sBAAsB,EACtB,SAAS,EACT,oBAAoB,EACpB,MAAM,GACP,EAAE;IACD,EAAE,EAAE,eAAe,CAAC;IACpB,aAAa,EAAE,0BAA0B,CAAC;IAC1C,oBAAoB,EAAE,CACpB,cAAc,EAAE,MAAM,KACnB,IAAI,CAAC,iBAAiB,EAAE,iBAAiB,GAAG,aAAa,CAAC,CAAC;IAChE,sBAAsB,EAAE,CACtB,cAAc,EAAE,MAAM,KACnB,IAAI,CAAC,0BAA0B,EAAE,UAAU,CAAC,CAAC;IAClD,SAAS,EAAE,0BAA0B,CAAC;IACtC,oBAAoB,EAAE,OAAO,CAAC;IAC9B,MAAM,CAAC,EAAE,MAAM,CAAC;CACjB,GAAG,aAAa,CAiEhB"}
\ No newline at end of file
diff --git a/dist/create-network-client.mjs b/dist/create-network-client.mjs
index 50ee224b853f4aef1af3ba8f84b5dca56abbbfe7..fbdf5a5f722051031349dea712fbd4c75e1438a9 100644
--- a/dist/create-network-client.mjs
+++ b/dist/create-network-client.mjs
@@ -1,4 +1,5 @@
 import { ChainId } from "@metamask/controller-utils";
+import { createThrottledFetchForChainId } from "./throttled-fetch.mjs";
 import { PollingBlockTracker } from "@metamask/eth-block-tracker";
 import { createInfuraMiddleware } from "@metamask/eth-json-rpc-infura";
 import { createBlockCacheMiddleware, createBlockRefMiddleware, createBlockRefRewriteMiddleware, createBlockTrackerInspectorMiddleware, createInflightCacheMiddleware, createFetchMiddleware, createRetryOnEmptyMiddleware } from "@metamask/eth-json-rpc-middleware";
@@ -109,11 +110,17 @@ function createRpcServiceChain({ id, primaryEndpointUrl, configuration, getRpcSe
     const availableEndpointUrls = isRpcFailoverEnabled
         ? [primaryEndpointUrl, ...(configuration.failoverRpcUrls ?? [])]
         : [primaryEndpointUrl];
-    const rpcServiceConfigurations = availableEndpointUrls.map((endpointUrl) => ({
-        ...getRpcServiceOptions(endpointUrl),
-        endpointUrl,
-        logger,
-    }));
+    const rpcServiceConfigurations = availableEndpointUrls.map((endpointUrl) => {
+        const options = getRpcServiceOptions(endpointUrl);
+        // Apply network throttling based on chain ID if configured
+        const throttledFetch = createThrottledFetchForChainId(endpointUrl, configuration.chainId, options.fetch);
+        return {
+            ...options,
+            fetch: throttledFetch,
+            endpointUrl,
+            logger,
+        };
+    });
     /**
      * Extracts the error from Cockatiel's `FailureReason` type received in
      * circuit breaker event handlers.
diff --git a/dist/create-network-client.mjs.map b/dist/create-network-client.mjs.map
index 46a5c3bfcbbdc757f70305f6de279dac88962dad..76ace48f88bd611c171b2034120099f86670f0de 100644
--- a/dist/create-network-client.mjs.map
+++ b/dist/create-network-client.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"create-network-client.mjs","sourceRoot":"","sources":["../src/create-network-client.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  CockatielFailureReason,\n  InfuraNetworkType,\n} from '@metamask/controller-utils';\nimport { ChainId } from '@metamask/controller-utils';\nimport type { PollingBlockTrackerOptions } from '@metamask/eth-block-tracker';\nimport { PollingBlockTracker } from '@metamask/eth-block-tracker';\nimport { createInfuraMiddleware } from '@metamask/eth-json-rpc-infura';\nimport {\n  createBlockCacheMiddleware,\n  createBlockRefMiddleware,\n  createBlockRefRewriteMiddleware,\n  createBlockTrackerInspectorMiddleware,\n  createInflightCacheMiddleware,\n  createFetchMiddleware,\n  createRetryOnEmptyMiddleware,\n} from '@metamask/eth-json-rpc-middleware';\nimport { InternalProvider } from '@metamask/eth-json-rpc-provider';\nimport { providerFromMiddlewareV2 } from '@metamask/eth-json-rpc-provider';\nimport { asV2Middleware } from '@metamask/json-rpc-engine';\nimport {\n  createScaffoldMiddleware,\n  JsonRpcEngineV2,\n} from '@metamask/json-rpc-engine/v2';\nimport type {\n  JsonRpcMiddleware,\n  MiddlewareContext,\n} from '@metamask/json-rpc-engine/v2';\nimport type { Hex, Json, JsonRpcRequest } from '@metamask/utils';\nimport type { Logger } from 'loglevel';\n\nimport type {\n  NetworkClientId,\n  NetworkControllerMessenger,\n} from './NetworkController';\nimport type { RpcServiceOptions } from './rpc-service/rpc-service';\nimport { RpcServiceChain } from './rpc-service/rpc-service-chain';\nimport type {\n  BlockTracker,\n  NetworkClientConfiguration,\n  Provider,\n} from './types';\nimport { NetworkClientType } from './types';\n\nconst SECOND = 1000;\n\n/**\n * The pair of provider / block tracker that can be used to interface with the\n * network and respond to new activity.\n */\nexport type NetworkClient = {\n  configuration: NetworkClientConfiguration;\n  provider: Provider;\n  blockTracker: BlockTracker;\n  destroy: () => void;\n};\n\ntype RpcApiMiddleware = JsonRpcMiddleware<\n  JsonRpcRequest,\n  Json,\n  MiddlewareContext<{ origin: string }>\n>;\n\n/**\n * Create a JSON RPC network client for a specific network.\n *\n * @param args - The arguments.\n * @param args.id - The ID that will be assigned to the new network client in\n * the registry.\n * @param args.configuration - The network configuration.\n * @param args.getRpcServiceOptions - Factory for constructing RPC service\n * options. See {@link NetworkControllerOptions.getRpcServiceOptions}.\n * @param args.getBlockTrackerOptions - Factory for constructing block tracker\n * options. See {@link NetworkControllerOptions.getBlockTrackerOptions}.\n * @param args.messenger - The network controller messenger.\n * @param args.isRpcFailoverEnabled - Whether or not requests sent to the\n * primary RPC endpoint for this network should be automatically diverted to\n * provided failover endpoints if the primary is unavailable. This effectively\n * causes the `failoverRpcUrls` property of the network client configuration\n * to be honored or ignored.\n * @param args.logger - A `loglevel` logger.\n * @returns The network client.\n */\nexport function createNetworkClient({\n  id,\n  configuration,\n  getRpcServiceOptions,\n  getBlockTrackerOptions,\n  messenger,\n  isRpcFailoverEnabled,\n  logger,\n}: {\n  id: NetworkClientId;\n  configuration: NetworkClientConfiguration;\n  getRpcServiceOptions: (\n    rpcEndpointUrl: string,\n  ) => Omit<RpcServiceOptions, 'failoverService' | 'endpointUrl'>;\n  getBlockTrackerOptions: (\n    rpcEndpointUrl: string,\n  ) => Omit<PollingBlockTrackerOptions, 'provider'>;\n  messenger: NetworkControllerMessenger;\n  isRpcFailoverEnabled: boolean;\n  logger?: Logger;\n}): NetworkClient {\n  const primaryEndpointUrl =\n    configuration.type === NetworkClientType.Infura\n      ? `https://${configuration.network}.infura.io/v3/${configuration.infuraProjectId}`\n      : configuration.rpcUrl;\n  const rpcServiceChain = createRpcServiceChain({\n    id,\n    primaryEndpointUrl,\n    configuration,\n    getRpcServiceOptions,\n    messenger,\n    isRpcFailoverEnabled,\n    logger,\n  });\n\n  let rpcApiMiddleware: RpcApiMiddleware;\n  if (configuration.type === NetworkClientType.Infura) {\n    rpcApiMiddleware = asV2Middleware(\n      createInfuraMiddleware({\n        rpcService: rpcServiceChain,\n        options: {\n          source: 'metamask',\n        },\n      }),\n    );\n  } else {\n    rpcApiMiddleware = createFetchMiddleware({ rpcService: rpcServiceChain });\n  }\n\n  const rpcProvider = providerFromMiddlewareV2(rpcApiMiddleware);\n\n  const blockTracker = createBlockTracker({\n    networkClientType: configuration.type,\n    endpointUrl: primaryEndpointUrl,\n    getOptions: getBlockTrackerOptions,\n    provider: rpcProvider,\n  });\n\n  const networkMiddleware =\n    configuration.type === NetworkClientType.Infura\n      ? createInfuraNetworkMiddleware({\n          blockTracker,\n          network: configuration.network,\n          rpcProvider,\n          rpcApiMiddleware,\n        })\n      : createCustomNetworkMiddleware({\n          blockTracker,\n          chainId: configuration.chainId,\n          rpcApiMiddleware,\n        });\n\n  const provider: Provider = new InternalProvider({\n    engine: JsonRpcEngineV2.create({\n      middleware: [networkMiddleware],\n    }),\n  });\n\n  const destroy = (): void => {\n    // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    blockTracker.destroy();\n  };\n\n  return { configuration, provider, blockTracker, destroy };\n}\n\n/**\n * Creates an RPC service chain, which represents the primary endpoint URL for\n * the network as well as its failover URLs.\n *\n * @param args - The arguments.\n * @param args.id - The ID that will be assigned to the new network client in\n * the registry.\n * @param args.primaryEndpointUrl - The primary endpoint URL.\n * @param args.configuration - The network configuration.\n * @param args.getRpcServiceOptions - Factory for constructing RPC service\n * options. See {@link NetworkControllerOptions.getRpcServiceOptions}.\n * @param args.messenger - The network controller messenger.\n * @param args.isRpcFailoverEnabled - Whether or not requests sent to the\n * primary RPC endpoint for this network should be automatically diverted to\n * provided failover endpoints if the primary is unavailable. This effectively\n * causes the `failoverRpcUrls` property of the network client configuration\n * to be honored or ignored.\n * @param args.logger - A `loglevel` logger.\n * @returns The RPC service chain.\n */\nfunction createRpcServiceChain({\n  id,\n  primaryEndpointUrl,\n  configuration,\n  getRpcServiceOptions,\n  messenger,\n  isRpcFailoverEnabled,\n  logger,\n}: {\n  id: NetworkClientId;\n  primaryEndpointUrl: string;\n  configuration: NetworkClientConfiguration;\n  getRpcServiceOptions: (\n    rpcEndpointUrl: string,\n  ) => Omit<RpcServiceOptions, 'failoverService' | 'endpointUrl'>;\n  messenger: NetworkControllerMessenger;\n  isRpcFailoverEnabled: boolean;\n  logger?: Logger;\n}): RpcServiceChain {\n  const availableEndpointUrls: [string, ...string[]] = isRpcFailoverEnabled\n    ? [primaryEndpointUrl, ...(configuration.failoverRpcUrls ?? [])]\n    : [primaryEndpointUrl];\n  const rpcServiceConfigurations = availableEndpointUrls.map((endpointUrl) => ({\n    ...getRpcServiceOptions(endpointUrl),\n    endpointUrl,\n    logger,\n  }));\n\n  /**\n   * Extracts the error from Cockatiel's `FailureReason` type received in\n   * circuit breaker event handlers.\n   *\n   * The `FailureReason` object can have two possible shapes:\n   * - `{ error: Error }` - When the RPC service throws an error (the common\n   * case for RPC failures).\n   * - `{ value: T }` - When the RPC service returns a value that the retry\n   * filter policy considers a failure.\n   *\n   * @param value - The event data object from the circuit breaker event\n   * listener (after destructuring known properties like `endpointUrl`). This\n   * represents Cockatiel's `FailureReason` type.\n   * @returns The error or failure value, or `undefined` if neither property\n   * exists (which shouldn't happen in practice unless the circuit breaker is\n   * manually isolated).\n   */\n  const getError = (\n    value: CockatielFailureReason<unknown> | Record<never, never>,\n  ): Error | unknown | undefined => {\n    if ('error' in value) {\n      return value.error;\n    } else if ('value' in value) {\n      return value.value;\n    }\n    return undefined;\n  };\n\n  const rpcServiceChain = new RpcServiceChain([\n    rpcServiceConfigurations[0],\n    ...rpcServiceConfigurations.slice(1),\n  ]);\n\n  rpcServiceChain.onBreak((data) => {\n    const error = getError(data);\n\n    if (error === undefined) {\n      // This error shouldn't happen in practice because we never call `.isolate`\n      // on the circuit breaker policy, but we need to appease TypeScript.\n      throw new Error('Could not make request to endpoint.');\n    }\n\n    messenger.publish('NetworkController:rpcEndpointChainUnavailable', {\n      chainId: configuration.chainId,\n      networkClientId: id,\n      error,\n    });\n  });\n\n  rpcServiceChain.onServiceBreak(\n    ({\n      endpointUrl,\n      primaryEndpointUrl: primaryEndpointUrlFromEvent,\n      ...rest\n    }) => {\n      const error = getError(rest);\n\n      if (error === undefined) {\n        // This error shouldn't happen in practice because we never call `.isolate`\n        // on the circuit breaker policy, but we need to appease TypeScript.\n        throw new Error('Could not make request to endpoint.');\n      }\n\n      messenger.publish('NetworkController:rpcEndpointUnavailable', {\n        chainId: configuration.chainId,\n        networkClientId: id,\n        primaryEndpointUrl: primaryEndpointUrlFromEvent,\n        endpointUrl,\n        error,\n      });\n    },\n  );\n\n  rpcServiceChain.onDegraded((data) => {\n    const error = getError(data);\n    messenger.publish('NetworkController:rpcEndpointChainDegraded', {\n      chainId: configuration.chainId,\n      networkClientId: id,\n      error,\n    });\n  });\n\n  rpcServiceChain.onServiceDegraded(\n    ({\n      endpointUrl,\n      primaryEndpointUrl: primaryEndpointUrlFromEvent,\n      ...rest\n    }) => {\n      const error = getError(rest);\n      messenger.publish('NetworkController:rpcEndpointDegraded', {\n        chainId: configuration.chainId,\n        networkClientId: id,\n        primaryEndpointUrl: primaryEndpointUrlFromEvent,\n        endpointUrl,\n        error,\n      });\n    },\n  );\n\n  rpcServiceChain.onAvailable(() => {\n    messenger.publish('NetworkController:rpcEndpointChainAvailable', {\n      chainId: configuration.chainId,\n      networkClientId: id,\n    });\n  });\n\n  rpcServiceChain.onServiceRetry(\n    ({\n      attempt,\n      endpointUrl,\n      primaryEndpointUrl: primaryEndpointUrlFromEvent,\n    }) => {\n      messenger.publish('NetworkController:rpcEndpointRetried', {\n        chainId: configuration.chainId,\n        networkClientId: id,\n        primaryEndpointUrl: primaryEndpointUrlFromEvent,\n        endpointUrl,\n        attempt,\n      });\n    },\n  );\n\n  return rpcServiceChain;\n}\n\n/**\n * Create the block tracker for the network.\n *\n * @param args - The arguments.\n * @param args.networkClientType - The type of the network client (\"infura\" or\n * \"custom\").\n * @param args.endpointUrl - The URL of the endpoint.\n * @param args.getOptions - Factory for the block tracker options.\n * @param args.provider - The EIP-1193 provider for the network's JSON-RPC\n * middleware stack.\n * @returns The created block tracker.\n */\nfunction createBlockTracker({\n  networkClientType,\n  endpointUrl,\n  getOptions,\n  provider,\n}: {\n  networkClientType: NetworkClientType;\n  endpointUrl: string;\n  getOptions: (\n    rpcEndpointUrl: string,\n  ) => Omit<PollingBlockTrackerOptions, 'provider'>;\n  provider: InternalProvider;\n}): PollingBlockTracker {\n  const testOptions =\n    // Needed for testing.\n    // eslint-disable-next-line no-restricted-globals\n    process.env.IN_TEST && networkClientType === NetworkClientType.Custom\n      ? { pollingInterval: SECOND }\n      : {};\n\n  return new PollingBlockTracker({\n    ...testOptions,\n    ...getOptions(endpointUrl),\n    provider,\n  });\n}\n\n/**\n * Create middleware for infura.\n *\n * @param args - The arguments.\n * @param args.blockTracker - The block tracker to use.\n * @param args.network - The Infura network to use.\n * @param args.rpcProvider - The RPC provider to use.\n * @param args.rpcApiMiddleware - Additional middleware.\n * @returns The collection of middleware that makes up the Infura client.\n */\nfunction createInfuraNetworkMiddleware({\n  blockTracker,\n  network,\n  rpcProvider,\n  rpcApiMiddleware,\n}: {\n  blockTracker: PollingBlockTracker;\n  network: InfuraNetworkType;\n  rpcProvider: InternalProvider;\n  rpcApiMiddleware: RpcApiMiddleware;\n}): JsonRpcMiddleware<\n  JsonRpcRequest,\n  Json,\n  MiddlewareContext<{ origin: string; skipCache: boolean }>\n> {\n  return JsonRpcEngineV2.create({\n    middleware: [\n      createNetworkAndChainIdMiddleware({ network }),\n      createBlockCacheMiddleware({ blockTracker }),\n      createInflightCacheMiddleware(),\n      createBlockRefMiddleware({ blockTracker, provider: rpcProvider }),\n      createRetryOnEmptyMiddleware({ blockTracker, provider: rpcProvider }),\n      createBlockTrackerInspectorMiddleware({ blockTracker }),\n      rpcApiMiddleware,\n    ],\n  }).asMiddleware();\n}\n\n/**\n * Creates static method middleware.\n *\n * @param args - The Arguments.\n * @param args.network - The Infura network to use.\n * @returns The middleware that implements the eth_chainId method.\n */\nfunction createNetworkAndChainIdMiddleware({\n  network,\n}: {\n  network: InfuraNetworkType;\n}): JsonRpcMiddleware<JsonRpcRequest> {\n  return createScaffoldMiddleware({\n    eth_chainId: ChainId[network],\n  });\n}\n\nconst createChainIdMiddleware = (\n  chainId: Hex,\n): JsonRpcMiddleware<JsonRpcRequest, Json> => {\n  return ({ request, next }) => {\n    if (request.method === 'eth_chainId') {\n      return chainId;\n    }\n    return next();\n  };\n};\n\n/**\n * Creates custom middleware.\n *\n * @param args - The arguments.\n * @param args.blockTracker - The block tracker to use.\n * @param args.chainId - The chain id to use.\n * @param args.rpcApiMiddleware - Additional middleware.\n * @returns The collection of middleware that makes up the Infura client.\n */\nfunction createCustomNetworkMiddleware({\n  blockTracker,\n  chainId,\n  rpcApiMiddleware,\n}: {\n  blockTracker: PollingBlockTracker;\n  chainId: Hex;\n  rpcApiMiddleware: RpcApiMiddleware;\n}): JsonRpcMiddleware<\n  JsonRpcRequest,\n  Json,\n  MiddlewareContext<{ origin: string; skipCache: boolean }>\n> {\n  // Needed for testing.\n  // eslint-disable-next-line no-restricted-globals\n  const testMiddlewares = process.env.IN_TEST\n    ? [createEstimateGasDelayTestMiddleware()]\n    : [];\n\n  return JsonRpcEngineV2.create({\n    middleware: [\n      ...testMiddlewares,\n      createChainIdMiddleware(chainId),\n      createBlockRefRewriteMiddleware({ blockTracker }),\n      createBlockCacheMiddleware({ blockTracker }),\n      createInflightCacheMiddleware(),\n      createBlockTrackerInspectorMiddleware({ blockTracker }),\n      rpcApiMiddleware,\n    ],\n  }).asMiddleware();\n}\n\n/**\n * For use in tests only.\n * Adds a delay to `eth_estimateGas` calls.\n *\n * @returns The middleware for delaying gas estimation calls by 2 seconds when in test.\n */\nfunction createEstimateGasDelayTestMiddleware(): JsonRpcMiddleware<\n  JsonRpcRequest,\n  Json\n> {\n  return async ({ request, next }) => {\n    if (request.method === 'eth_estimateGas') {\n      await new Promise((resolve) => setTimeout(resolve, SECOND * 2));\n    }\n    return next();\n  };\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"create-network-client.mjs","sourceRoot":"","sources":["../src/create-network-client.ts"],"names":[],"mappings":"AAIA,OAAO,EAAE,OAAO,EAAE,mCAAmC;AAErD,OAAO,EAAE,8BAA8B,EAAE,8BAA0B;AAGnE,OAAO,EAAE,mBAAmB,EAAE,oCAAoC;AAClE,OAAO,EAAE,sBAAsB,EAAE,sCAAsC;AACvE,OAAO,EACL,0BAA0B,EAC1B,wBAAwB,EACxB,+BAA+B,EAC/B,qCAAqC,EACrC,6BAA6B,EAC7B,qBAAqB,EACrB,4BAA4B,EAC7B,0CAA0C;AAC3C,OAAO,EAAE,gBAAgB,EAAE,wCAAwC;AACnE,OAAO,EAAE,wBAAwB,EAAE,wCAAwC;AAC3E,OAAO,EAAE,cAAc,EAAE,kCAAkC;AAC3D,OAAO,EACL,wBAAwB,EACxB,eAAe,EAChB,qCAAqC;AAatC,OAAO,EAAE,eAAe,EAAE,4CAAwC;AAMlE,OAAO,EAAE,iBAAiB,EAAE,oBAAgB;AAE5C,MAAM,MAAM,GAAG,IAAI,CAAC;AAmBpB;;;;;;;;;;;;;;;;;;;GAmBG;AACH,MAAM,UAAU,mBAAmB,CAAC,EAClC,EAAE,EACF,aAAa,EACb,oBAAoB,EACpB,sBAAsB,EACtB,SAAS,EACT,oBAAoB,EACpB,MAAM,GAaP;IACC,MAAM,kBAAkB,GACtB,aAAa,CAAC,IAAI,KAAK,iBAAiB,CAAC,MAAM;QAC7C,CAAC,CAAC,WAAW,aAAa,CAAC,OAAO,iBAAiB,aAAa,CAAC,eAAe,EAAE;QAClF,CAAC,CAAC,aAAa,CAAC,MAAM,CAAC;IAC3B,MAAM,eAAe,GAAG,qBAAqB,CAAC;QAC5C,EAAE;QACF,kBAAkB;QAClB,aAAa;QACb,oBAAoB;QACpB,SAAS;QACT,oBAAoB;QACpB,MAAM;KACP,CAAC,CAAC;IAEH,IAAI,gBAAkC,CAAC;IACvC,IAAI,aAAa,CAAC,IAAI,KAAK,iBAAiB,CAAC,MAAM,EAAE,CAAC;QACpD,gBAAgB,GAAG,cAAc,CAC/B,sBAAsB,CAAC;YACrB,UAAU,EAAE,eAAe;YAC3B,OAAO,EAAE;gBACP,MAAM,EAAE,UAAU;aACnB;SACF,CAAC,CACH,CAAC;IACJ,CAAC;SAAM,CAAC;QACN,gBAAgB,GAAG,qBAAqB,CAAC,EAAE,UAAU,EAAE,eAAe,EAAE,CAAC,CAAC;IAC5E,CAAC;IAED,MAAM,WAAW,GAAG,wBAAwB,CAAC,gBAAgB,CAAC,CAAC;IAE/D,MAAM,YAAY,GAAG,kBAAkB,CAAC;QACtC,iBAAiB,EAAE,aAAa,CAAC,IAAI;QACrC,WAAW,EAAE,kBAAkB;QAC/B,UAAU,EAAE,sBAAsB;QAClC,QAAQ,EAAE,WAAW;KACtB,CAAC,CAAC;IAEH,MAAM,iBAAiB,GACrB,aAAa,CAAC,IAAI,KAAK,iBAAiB,CAAC,MAAM;QAC7C,CAAC,CAAC,6BAA6B,CAAC;YAC5B,YAAY;YACZ,OAAO,EAAE,aAAa,CAAC,OAAO;YAC9B,WAAW;YACX,gBAAgB;SACjB,CAAC;QACJ,CAAC,CAAC,6BAA6B,CAAC;YAC5B,YAAY;YACZ,OAAO,EAAE,aAAa,CAAC,OAAO;YAC9B,gBAAgB;SACjB,CAAC,CAAC;IAET,MAAM,QAAQ,GAAa,IAAI,gBAAgB,CAAC;QAC9C,MAAM,EAAE,eAAe,CAAC,MAAM,CAAC;YAC7B,UAAU,EAAE,CAAC,iBAAiB,CAAC;SAChC,CAAC;KACH,CAAC,CAAC;IAEH,MAAM,OAAO,GAAG,GAAS,EAAE;QACzB,gFAAgF;QAChF,mEAAmE;QACnE,YAAY,CAAC,OAAO,EAAE,CAAC;IACzB,CAAC,CAAC;IAEF,OAAO,EAAE,aAAa,EAAE,QAAQ,EAAE,YAAY,EAAE,OAAO,EAAE,CAAC;AAC5D,CAAC;AAED;;;;;;;;;;;;;;;;;;;GAmBG;AACH,SAAS,qBAAqB,CAAC,EAC7B,EAAE,EACF,kBAAkB,EAClB,aAAa,EACb,oBAAoB,EACpB,SAAS,EACT,oBAAoB,EACpB,MAAM,GAWP;IACC,MAAM,qBAAqB,GAA0B,oBAAoB;QACvE,CAAC,CAAC,CAAC,kBAAkB,EAAE,GAAG,CAAC,aAAa,CAAC,eAAe,IAAI,EAAE,CAAC,CAAC;QAChE,CAAC,CAAC,CAAC,kBAAkB,CAAC,CAAC;IACzB,MAAM,wBAAwB,GAAG,qBAAqB,CAAC,GAAG,CAAC,CAAC,WAAW,EAAE,EAAE;QACzE,MAAM,OAAO,GAAG,oBAAoB,CAAC,WAAW,CAAC,CAAC;QAElD,2DAA2D;QAC3D,MAAM,cAAc,GAAG,8BAA8B,CACnD,WAAW,EACX,aAAa,CAAC,OAAO,EACrB,OAAO,CAAC,KAAK,CACd,CAAC;QAEF,OAAO;YACL,GAAG,OAAO;YACV,KAAK,EAAE,cAAc;YACrB,WAAW;YACX,MAAM;SACP,CAAC;IACJ,CAAC,CAAC,CAAC;IAEH;;;;;;;;;;;;;;;;OAgBG;IACH,MAAM,QAAQ,GAAG,CACf,KAA6D,EAChC,EAAE;QAC/B,IAAI,OAAO,IAAI,KAAK,EAAE,CAAC;YACrB,OAAO,KAAK,CAAC,KAAK,CAAC;QACrB,CAAC;aAAM,IAAI,OAAO,IAAI,KAAK,EAAE,CAAC;YAC5B,OAAO,KAAK,CAAC,KAAK,CAAC;QACrB,CAAC;QACD,OAAO,SAAS,CAAC;IACnB,CAAC,CAAC;IAEF,MAAM,eAAe,GAAG,IAAI,eAAe,CAAC;QAC1C,wBAAwB,CAAC,CAAC,CAAC;QAC3B,GAAG,wBAAwB,CAAC,KAAK,CAAC,CAAC,CAAC;KACrC,CAAC,CAAC;IAEH,eAAe,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;QAC/B,MAAM,KAAK,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC;QAE7B,IAAI,KAAK,KAAK,SAAS,EAAE,CAAC;YACxB,2EAA2E;YAC3E,oEAAoE;YACpE,MAAM,IAAI,KAAK,CAAC,qCAAqC,CAAC,CAAC;QACzD,CAAC;QAED,SAAS,CAAC,OAAO,CAAC,+CAA+C,EAAE;YACjE,OAAO,EAAE,aAAa,CAAC,OAAO;YAC9B,eAAe,EAAE,EAAE;YACnB,KAAK;SACN,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;IAEH,eAAe,CAAC,cAAc,CAC5B,CAAC,EACC,WAAW,EACX,kBAAkB,EAAE,2BAA2B,EAC/C,GAAG,IAAI,EACR,EAAE,EAAE;QACH,MAAM,KAAK,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC;QAE7B,IAAI,KAAK,KAAK,SAAS,EAAE,CAAC;YACxB,2EAA2E;YAC3E,oEAAoE;YACpE,MAAM,IAAI,KAAK,CAAC,qCAAqC,CAAC,CAAC;QACzD,CAAC;QAED,SAAS,CAAC,OAAO,CAAC,0CAA0C,EAAE;YAC5D,OAAO,EAAE,aAAa,CAAC,OAAO;YAC9B,eAAe,EAAE,EAAE;YACnB,kBAAkB,EAAE,2BAA2B;YAC/C,WAAW;YACX,KAAK;SACN,CAAC,CAAC;IACL,CAAC,CACF,CAAC;IAEF,eAAe,CAAC,UAAU,CAAC,CAAC,IAAI,EAAE,EAAE;QAClC,MAAM,KAAK,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC;QAC7B,SAAS,CAAC,OAAO,CAAC,4CAA4C,EAAE;YAC9D,OAAO,EAAE,aAAa,CAAC,OAAO;YAC9B,eAAe,EAAE,EAAE;YACnB,KAAK;SACN,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;IAEH,eAAe,CAAC,iBAAiB,CAC/B,CAAC,EACC,WAAW,EACX,kBAAkB,EAAE,2BAA2B,EAC/C,GAAG,IAAI,EACR,EAAE,EAAE;QACH,MAAM,KAAK,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC;QAC7B,SAAS,CAAC,OAAO,CAAC,uCAAuC,EAAE;YACzD,OAAO,EAAE,aAAa,CAAC,OAAO;YAC9B,eAAe,EAAE,EAAE;YACnB,kBAAkB,EAAE,2BAA2B;YAC/C,WAAW;YACX,KAAK;SACN,CAAC,CAAC;IACL,CAAC,CACF,CAAC;IAEF,eAAe,CAAC,WAAW,CAAC,GAAG,EAAE;QAC/B,SAAS,CAAC,OAAO,CAAC,6CAA6C,EAAE;YAC/D,OAAO,EAAE,aAAa,CAAC,OAAO;YAC9B,eAAe,EAAE,EAAE;SACpB,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;IAEH,eAAe,CAAC,cAAc,CAC5B,CAAC,EACC,OAAO,EACP,WAAW,EACX,kBAAkB,EAAE,2BAA2B,GAChD,EAAE,EAAE;QACH,SAAS,CAAC,OAAO,CAAC,sCAAsC,EAAE;YACxD,OAAO,EAAE,aAAa,CAAC,OAAO;YAC9B,eAAe,EAAE,EAAE;YACnB,kBAAkB,EAAE,2BAA2B;YAC/C,WAAW;YACX,OAAO;SACR,CAAC,CAAC;IACL,CAAC,CACF,CAAC;IAEF,OAAO,eAAe,CAAC;AACzB,CAAC;AAED;;;;;;;;;;;GAWG;AACH,SAAS,kBAAkB,CAAC,EAC1B,iBAAiB,EACjB,WAAW,EACX,UAAU,EACV,QAAQ,GAQT;IACC,MAAM,WAAW;IACf,sBAAsB;IACtB,iDAAiD;IACjD,OAAO,CAAC,GAAG,CAAC,OAAO,IAAI,iBAAiB,KAAK,iBAAiB,CAAC,MAAM;QACnE,CAAC,CAAC,EAAE,eAAe,EAAE,MAAM,EAAE;QAC7B,CAAC,CAAC,EAAE,CAAC;IAET,OAAO,IAAI,mBAAmB,CAAC;QAC7B,GAAG,WAAW;QACd,GAAG,UAAU,CAAC,WAAW,CAAC;QAC1B,QAAQ;KACT,CAAC,CAAC;AACL,CAAC;AAED;;;;;;;;;GASG;AACH,SAAS,6BAA6B,CAAC,EACrC,YAAY,EACZ,OAAO,EACP,WAAW,EACX,gBAAgB,GAMjB;IAKC,OAAO,eAAe,CAAC,MAAM,CAAC;QAC5B,UAAU,EAAE;YACV,iCAAiC,CAAC,EAAE,OAAO,EAAE,CAAC;YAC9C,0BAA0B,CAAC,EAAE,YAAY,EAAE,CAAC;YAC5C,6BAA6B,EAAE;YAC/B,wBAAwB,CAAC,EAAE,YAAY,EAAE,QAAQ,EAAE,WAAW,EAAE,CAAC;YACjE,4BAA4B,CAAC,EAAE,YAAY,EAAE,QAAQ,EAAE,WAAW,EAAE,CAAC;YACrE,qCAAqC,CAAC,EAAE,YAAY,EAAE,CAAC;YACvD,gBAAgB;SACjB;KACF,CAAC,CAAC,YAAY,EAAE,CAAC;AACpB,CAAC;AAED;;;;;;GAMG;AACH,SAAS,iCAAiC,CAAC,EACzC,OAAO,GAGR;IACC,OAAO,wBAAwB,CAAC;QAC9B,WAAW,EAAE,OAAO,CAAC,OAAO,CAAC;KAC9B,CAAC,CAAC;AACL,CAAC;AAED,MAAM,uBAAuB,GAAG,CAC9B,OAAY,EAC6B,EAAE;IAC3C,OAAO,CAAC,EAAE,OAAO,EAAE,IAAI,EAAE,EAAE,EAAE;QAC3B,IAAI,OAAO,CAAC,MAAM,KAAK,aAAa,EAAE,CAAC;YACrC,OAAO,OAAO,CAAC;QACjB,CAAC;QACD,OAAO,IAAI,EAAE,CAAC;IAChB,CAAC,CAAC;AACJ,CAAC,CAAC;AAEF;;;;;;;;GAQG;AACH,SAAS,6BAA6B,CAAC,EACrC,YAAY,EACZ,OAAO,EACP,gBAAgB,GAKjB;IAKC,sBAAsB;IACtB,iDAAiD;IACjD,MAAM,eAAe,GAAG,OAAO,CAAC,GAAG,CAAC,OAAO;QACzC,CAAC,CAAC,CAAC,oCAAoC,EAAE,CAAC;QAC1C,CAAC,CAAC,EAAE,CAAC;IAEP,OAAO,eAAe,CAAC,MAAM,CAAC;QAC5B,UAAU,EAAE;YACV,GAAG,eAAe;YAClB,uBAAuB,CAAC,OAAO,CAAC;YAChC,+BAA+B,CAAC,EAAE,YAAY,EAAE,CAAC;YACjD,0BAA0B,CAAC,EAAE,YAAY,EAAE,CAAC;YAC5C,6BAA6B,EAAE;YAC/B,qCAAqC,CAAC,EAAE,YAAY,EAAE,CAAC;YACvD,gBAAgB;SACjB;KACF,CAAC,CAAC,YAAY,EAAE,CAAC;AACpB,CAAC;AAED;;;;;GAKG;AACH,SAAS,oCAAoC;IAI3C,OAAO,KAAK,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,EAAE,EAAE;QACjC,IAAI,OAAO,CAAC,MAAM,KAAK,iBAAiB,EAAE,CAAC;YACzC,MAAM,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,UAAU,CAAC,OAAO,EAAE,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;QAClE,CAAC;QACD,OAAO,IAAI,EAAE,CAAC;IAChB,CAAC,CAAC;AACJ,CAAC","sourcesContent":["import type {\n  CockatielFailureReason,\n  InfuraNetworkType,\n} from '@metamask/controller-utils';\nimport { ChainId } from '@metamask/controller-utils';\n\nimport { createThrottledFetchForChainId } from './throttled-fetch';\n\nimport type { PollingBlockTrackerOptions } from '@metamask/eth-block-tracker';\nimport { PollingBlockTracker } from '@metamask/eth-block-tracker';\nimport { createInfuraMiddleware } from '@metamask/eth-json-rpc-infura';\nimport {\n  createBlockCacheMiddleware,\n  createBlockRefMiddleware,\n  createBlockRefRewriteMiddleware,\n  createBlockTrackerInspectorMiddleware,\n  createInflightCacheMiddleware,\n  createFetchMiddleware,\n  createRetryOnEmptyMiddleware,\n} from '@metamask/eth-json-rpc-middleware';\nimport { InternalProvider } from '@metamask/eth-json-rpc-provider';\nimport { providerFromMiddlewareV2 } from '@metamask/eth-json-rpc-provider';\nimport { asV2Middleware } from '@metamask/json-rpc-engine';\nimport {\n  createScaffoldMiddleware,\n  JsonRpcEngineV2,\n} from '@metamask/json-rpc-engine/v2';\nimport type {\n  JsonRpcMiddleware,\n  MiddlewareContext,\n} from '@metamask/json-rpc-engine/v2';\nimport type { Hex, Json, JsonRpcRequest } from '@metamask/utils';\nimport type { Logger } from 'loglevel';\n\nimport type {\n  NetworkClientId,\n  NetworkControllerMessenger,\n} from './NetworkController';\nimport type { RpcServiceOptions } from './rpc-service/rpc-service';\nimport { RpcServiceChain } from './rpc-service/rpc-service-chain';\nimport type {\n  BlockTracker,\n  NetworkClientConfiguration,\n  Provider,\n} from './types';\nimport { NetworkClientType } from './types';\n\nconst SECOND = 1000;\n\n/**\n * The pair of provider / block tracker that can be used to interface with the\n * network and respond to new activity.\n */\nexport type NetworkClient = {\n  configuration: NetworkClientConfiguration;\n  provider: Provider;\n  blockTracker: BlockTracker;\n  destroy: () => void;\n};\n\ntype RpcApiMiddleware = JsonRpcMiddleware<\n  JsonRpcRequest,\n  Json,\n  MiddlewareContext<{ origin: string }>\n>;\n\n/**\n * Create a JSON RPC network client for a specific network.\n *\n * @param args - The arguments.\n * @param args.id - The ID that will be assigned to the new network client in\n * the registry.\n * @param args.configuration - The network configuration.\n * @param args.getRpcServiceOptions - Factory for constructing RPC service\n * options. See {@link NetworkControllerOptions.getRpcServiceOptions}.\n * @param args.getBlockTrackerOptions - Factory for constructing block tracker\n * options. See {@link NetworkControllerOptions.getBlockTrackerOptions}.\n * @param args.messenger - The network controller messenger.\n * @param args.isRpcFailoverEnabled - Whether or not requests sent to the\n * primary RPC endpoint for this network should be automatically diverted to\n * provided failover endpoints if the primary is unavailable. This effectively\n * causes the `failoverRpcUrls` property of the network client configuration\n * to be honored or ignored.\n * @param args.logger - A `loglevel` logger.\n * @returns The network client.\n */\nexport function createNetworkClient({\n  id,\n  configuration,\n  getRpcServiceOptions,\n  getBlockTrackerOptions,\n  messenger,\n  isRpcFailoverEnabled,\n  logger,\n}: {\n  id: NetworkClientId;\n  configuration: NetworkClientConfiguration;\n  getRpcServiceOptions: (\n    rpcEndpointUrl: string,\n  ) => Omit<RpcServiceOptions, 'failoverService' | 'endpointUrl'>;\n  getBlockTrackerOptions: (\n    rpcEndpointUrl: string,\n  ) => Omit<PollingBlockTrackerOptions, 'provider'>;\n  messenger: NetworkControllerMessenger;\n  isRpcFailoverEnabled: boolean;\n  logger?: Logger;\n}): NetworkClient {\n  const primaryEndpointUrl =\n    configuration.type === NetworkClientType.Infura\n      ? `https://${configuration.network}.infura.io/v3/${configuration.infuraProjectId}`\n      : configuration.rpcUrl;\n  const rpcServiceChain = createRpcServiceChain({\n    id,\n    primaryEndpointUrl,\n    configuration,\n    getRpcServiceOptions,\n    messenger,\n    isRpcFailoverEnabled,\n    logger,\n  });\n\n  let rpcApiMiddleware: RpcApiMiddleware;\n  if (configuration.type === NetworkClientType.Infura) {\n    rpcApiMiddleware = asV2Middleware(\n      createInfuraMiddleware({\n        rpcService: rpcServiceChain,\n        options: {\n          source: 'metamask',\n        },\n      }),\n    );\n  } else {\n    rpcApiMiddleware = createFetchMiddleware({ rpcService: rpcServiceChain });\n  }\n\n  const rpcProvider = providerFromMiddlewareV2(rpcApiMiddleware);\n\n  const blockTracker = createBlockTracker({\n    networkClientType: configuration.type,\n    endpointUrl: primaryEndpointUrl,\n    getOptions: getBlockTrackerOptions,\n    provider: rpcProvider,\n  });\n\n  const networkMiddleware =\n    configuration.type === NetworkClientType.Infura\n      ? createInfuraNetworkMiddleware({\n          blockTracker,\n          network: configuration.network,\n          rpcProvider,\n          rpcApiMiddleware,\n        })\n      : createCustomNetworkMiddleware({\n          blockTracker,\n          chainId: configuration.chainId,\n          rpcApiMiddleware,\n        });\n\n  const provider: Provider = new InternalProvider({\n    engine: JsonRpcEngineV2.create({\n      middleware: [networkMiddleware],\n    }),\n  });\n\n  const destroy = (): void => {\n    // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    blockTracker.destroy();\n  };\n\n  return { configuration, provider, blockTracker, destroy };\n}\n\n/**\n * Creates an RPC service chain, which represents the primary endpoint URL for\n * the network as well as its failover URLs.\n *\n * @param args - The arguments.\n * @param args.id - The ID that will be assigned to the new network client in\n * the registry.\n * @param args.primaryEndpointUrl - The primary endpoint URL.\n * @param args.configuration - The network configuration.\n * @param args.getRpcServiceOptions - Factory for constructing RPC service\n * options. See {@link NetworkControllerOptions.getRpcServiceOptions}.\n * @param args.messenger - The network controller messenger.\n * @param args.isRpcFailoverEnabled - Whether or not requests sent to the\n * primary RPC endpoint for this network should be automatically diverted to\n * provided failover endpoints if the primary is unavailable. This effectively\n * causes the `failoverRpcUrls` property of the network client configuration\n * to be honored or ignored.\n * @param args.logger - A `loglevel` logger.\n * @returns The RPC service chain.\n */\nfunction createRpcServiceChain({\n  id,\n  primaryEndpointUrl,\n  configuration,\n  getRpcServiceOptions,\n  messenger,\n  isRpcFailoverEnabled,\n  logger,\n}: {\n  id: NetworkClientId;\n  primaryEndpointUrl: string;\n  configuration: NetworkClientConfiguration;\n  getRpcServiceOptions: (\n    rpcEndpointUrl: string,\n  ) => Omit<RpcServiceOptions, 'failoverService' | 'endpointUrl'>;\n  messenger: NetworkControllerMessenger;\n  isRpcFailoverEnabled: boolean;\n  logger?: Logger;\n}): RpcServiceChain {\n  const availableEndpointUrls: [string, ...string[]] = isRpcFailoverEnabled\n    ? [primaryEndpointUrl, ...(configuration.failoverRpcUrls ?? [])]\n    : [primaryEndpointUrl];\n  const rpcServiceConfigurations = availableEndpointUrls.map((endpointUrl) => {\n    const options = getRpcServiceOptions(endpointUrl);\n\n    // Apply network throttling based on chain ID if configured\n    const throttledFetch = createThrottledFetchForChainId(\n      endpointUrl,\n      configuration.chainId,\n      options.fetch,\n    );\n\n    return {\n      ...options,\n      fetch: throttledFetch,\n      endpointUrl,\n      logger,\n    };\n  });\n\n  /**\n   * Extracts the error from Cockatiel's `FailureReason` type received in\n   * circuit breaker event handlers.\n   *\n   * The `FailureReason` object can have two possible shapes:\n   * - `{ error: Error }` - When the RPC service throws an error (the common\n   * case for RPC failures).\n   * - `{ value: T }` - When the RPC service returns a value that the retry\n   * filter policy considers a failure.\n   *\n   * @param value - The event data object from the circuit breaker event\n   * listener (after destructuring known properties like `endpointUrl`). This\n   * represents Cockatiel's `FailureReason` type.\n   * @returns The error or failure value, or `undefined` if neither property\n   * exists (which shouldn't happen in practice unless the circuit breaker is\n   * manually isolated).\n   */\n  const getError = (\n    value: CockatielFailureReason<unknown> | Record<never, never>,\n  ): Error | unknown | undefined => {\n    if ('error' in value) {\n      return value.error;\n    } else if ('value' in value) {\n      return value.value;\n    }\n    return undefined;\n  };\n\n  const rpcServiceChain = new RpcServiceChain([\n    rpcServiceConfigurations[0],\n    ...rpcServiceConfigurations.slice(1),\n  ]);\n\n  rpcServiceChain.onBreak((data) => {\n    const error = getError(data);\n\n    if (error === undefined) {\n      // This error shouldn't happen in practice because we never call `.isolate`\n      // on the circuit breaker policy, but we need to appease TypeScript.\n      throw new Error('Could not make request to endpoint.');\n    }\n\n    messenger.publish('NetworkController:rpcEndpointChainUnavailable', {\n      chainId: configuration.chainId,\n      networkClientId: id,\n      error,\n    });\n  });\n\n  rpcServiceChain.onServiceBreak(\n    ({\n      endpointUrl,\n      primaryEndpointUrl: primaryEndpointUrlFromEvent,\n      ...rest\n    }) => {\n      const error = getError(rest);\n\n      if (error === undefined) {\n        // This error shouldn't happen in practice because we never call `.isolate`\n        // on the circuit breaker policy, but we need to appease TypeScript.\n        throw new Error('Could not make request to endpoint.');\n      }\n\n      messenger.publish('NetworkController:rpcEndpointUnavailable', {\n        chainId: configuration.chainId,\n        networkClientId: id,\n        primaryEndpointUrl: primaryEndpointUrlFromEvent,\n        endpointUrl,\n        error,\n      });\n    },\n  );\n\n  rpcServiceChain.onDegraded((data) => {\n    const error = getError(data);\n    messenger.publish('NetworkController:rpcEndpointChainDegraded', {\n      chainId: configuration.chainId,\n      networkClientId: id,\n      error,\n    });\n  });\n\n  rpcServiceChain.onServiceDegraded(\n    ({\n      endpointUrl,\n      primaryEndpointUrl: primaryEndpointUrlFromEvent,\n      ...rest\n    }) => {\n      const error = getError(rest);\n      messenger.publish('NetworkController:rpcEndpointDegraded', {\n        chainId: configuration.chainId,\n        networkClientId: id,\n        primaryEndpointUrl: primaryEndpointUrlFromEvent,\n        endpointUrl,\n        error,\n      });\n    },\n  );\n\n  rpcServiceChain.onAvailable(() => {\n    messenger.publish('NetworkController:rpcEndpointChainAvailable', {\n      chainId: configuration.chainId,\n      networkClientId: id,\n    });\n  });\n\n  rpcServiceChain.onServiceRetry(\n    ({\n      attempt,\n      endpointUrl,\n      primaryEndpointUrl: primaryEndpointUrlFromEvent,\n    }) => {\n      messenger.publish('NetworkController:rpcEndpointRetried', {\n        chainId: configuration.chainId,\n        networkClientId: id,\n        primaryEndpointUrl: primaryEndpointUrlFromEvent,\n        endpointUrl,\n        attempt,\n      });\n    },\n  );\n\n  return rpcServiceChain;\n}\n\n/**\n * Create the block tracker for the network.\n *\n * @param args - The arguments.\n * @param args.networkClientType - The type of the network client (\"infura\" or\n * \"custom\").\n * @param args.endpointUrl - The URL of the endpoint.\n * @param args.getOptions - Factory for the block tracker options.\n * @param args.provider - The EIP-1193 provider for the network's JSON-RPC\n * middleware stack.\n * @returns The created block tracker.\n */\nfunction createBlockTracker({\n  networkClientType,\n  endpointUrl,\n  getOptions,\n  provider,\n}: {\n  networkClientType: NetworkClientType;\n  endpointUrl: string;\n  getOptions: (\n    rpcEndpointUrl: string,\n  ) => Omit<PollingBlockTrackerOptions, 'provider'>;\n  provider: InternalProvider;\n}): PollingBlockTracker {\n  const testOptions =\n    // Needed for testing.\n    // eslint-disable-next-line no-restricted-globals\n    process.env.IN_TEST && networkClientType === NetworkClientType.Custom\n      ? { pollingInterval: SECOND }\n      : {};\n\n  return new PollingBlockTracker({\n    ...testOptions,\n    ...getOptions(endpointUrl),\n    provider,\n  });\n}\n\n/**\n * Create middleware for infura.\n *\n * @param args - The arguments.\n * @param args.blockTracker - The block tracker to use.\n * @param args.network - The Infura network to use.\n * @param args.rpcProvider - The RPC provider to use.\n * @param args.rpcApiMiddleware - Additional middleware.\n * @returns The collection of middleware that makes up the Infura client.\n */\nfunction createInfuraNetworkMiddleware({\n  blockTracker,\n  network,\n  rpcProvider,\n  rpcApiMiddleware,\n}: {\n  blockTracker: PollingBlockTracker;\n  network: InfuraNetworkType;\n  rpcProvider: InternalProvider;\n  rpcApiMiddleware: RpcApiMiddleware;\n}): JsonRpcMiddleware<\n  JsonRpcRequest,\n  Json,\n  MiddlewareContext<{ origin: string; skipCache: boolean }>\n> {\n  return JsonRpcEngineV2.create({\n    middleware: [\n      createNetworkAndChainIdMiddleware({ network }),\n      createBlockCacheMiddleware({ blockTracker }),\n      createInflightCacheMiddleware(),\n      createBlockRefMiddleware({ blockTracker, provider: rpcProvider }),\n      createRetryOnEmptyMiddleware({ blockTracker, provider: rpcProvider }),\n      createBlockTrackerInspectorMiddleware({ blockTracker }),\n      rpcApiMiddleware,\n    ],\n  }).asMiddleware();\n}\n\n/**\n * Creates static method middleware.\n *\n * @param args - The Arguments.\n * @param args.network - The Infura network to use.\n * @returns The middleware that implements the eth_chainId method.\n */\nfunction createNetworkAndChainIdMiddleware({\n  network,\n}: {\n  network: InfuraNetworkType;\n}): JsonRpcMiddleware<JsonRpcRequest> {\n  return createScaffoldMiddleware({\n    eth_chainId: ChainId[network],\n  });\n}\n\nconst createChainIdMiddleware = (\n  chainId: Hex,\n): JsonRpcMiddleware<JsonRpcRequest, Json> => {\n  return ({ request, next }) => {\n    if (request.method === 'eth_chainId') {\n      return chainId;\n    }\n    return next();\n  };\n};\n\n/**\n * Creates custom middleware.\n *\n * @param args - The arguments.\n * @param args.blockTracker - The block tracker to use.\n * @param args.chainId - The chain id to use.\n * @param args.rpcApiMiddleware - Additional middleware.\n * @returns The collection of middleware that makes up the Infura client.\n */\nfunction createCustomNetworkMiddleware({\n  blockTracker,\n  chainId,\n  rpcApiMiddleware,\n}: {\n  blockTracker: PollingBlockTracker;\n  chainId: Hex;\n  rpcApiMiddleware: RpcApiMiddleware;\n}): JsonRpcMiddleware<\n  JsonRpcRequest,\n  Json,\n  MiddlewareContext<{ origin: string; skipCache: boolean }>\n> {\n  // Needed for testing.\n  // eslint-disable-next-line no-restricted-globals\n  const testMiddlewares = process.env.IN_TEST\n    ? [createEstimateGasDelayTestMiddleware()]\n    : [];\n\n  return JsonRpcEngineV2.create({\n    middleware: [\n      ...testMiddlewares,\n      createChainIdMiddleware(chainId),\n      createBlockRefRewriteMiddleware({ blockTracker }),\n      createBlockCacheMiddleware({ blockTracker }),\n      createInflightCacheMiddleware(),\n      createBlockTrackerInspectorMiddleware({ blockTracker }),\n      rpcApiMiddleware,\n    ],\n  }).asMiddleware();\n}\n\n/**\n * For use in tests only.\n * Adds a delay to `eth_estimateGas` calls.\n *\n * @returns The middleware for delaying gas estimation calls by 2 seconds when in test.\n */\nfunction createEstimateGasDelayTestMiddleware(): JsonRpcMiddleware<\n  JsonRpcRequest,\n  Json\n> {\n  return async ({ request, next }) => {\n    if (request.method === 'eth_estimateGas') {\n      await new Promise((resolve) => setTimeout(resolve, SECOND * 2));\n    }\n    return next();\n  };\n}\n"]}
\ No newline at end of file
diff --git a/dist/index.cjs b/dist/index.cjs
index 5b14760358bbc4a2405e5d34b1de1745e5e4e7f8..1bca1e15e948f7a9f34d7f9908b3502d272c1c9d 100644
--- a/dist/index.cjs
+++ b/dist/index.cjs
@@ -14,7 +14,7 @@ var __exportStar = (this && this.__exportStar) || function(m, exports) {
     for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
 };
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.isConnectionError = exports.NetworkClientType = exports.RpcEndpointType = exports.NetworkController = exports.knownKeysOf = exports.selectAvailableNetworkClientIds = exports.getDefaultNetworkControllerState = void 0;
+exports.createThrottledGetRpcServiceOptions = exports.createThrottledFetchForChainId = exports.createThrottledFetch = exports.NETWORK_THROTTLE_CONFIG = exports.isConnectionError = exports.NetworkClientType = exports.RpcEndpointType = exports.NetworkController = exports.knownKeysOf = exports.selectAvailableNetworkClientIds = exports.getDefaultNetworkControllerState = void 0;
 var NetworkController_1 = require("./NetworkController.cjs");
 Object.defineProperty(exports, "getDefaultNetworkControllerState", { enumerable: true, get: function () { return NetworkController_1.getDefaultNetworkControllerState; } });
 Object.defineProperty(exports, "selectAvailableNetworkClientIds", { enumerable: true, get: function () { return NetworkController_1.selectAvailableNetworkClientIds; } });
@@ -26,4 +26,9 @@ var types_1 = require("./types.cjs");
 Object.defineProperty(exports, "NetworkClientType", { enumerable: true, get: function () { return types_1.NetworkClientType; } });
 var rpc_service_1 = require("./rpc-service/rpc-service.cjs");
 Object.defineProperty(exports, "isConnectionError", { enumerable: true, get: function () { return rpc_service_1.isConnectionError; } });
+var throttled_fetch_1 = require("./throttled-fetch.cjs");
+Object.defineProperty(exports, "NETWORK_THROTTLE_CONFIG", { enumerable: true, get: function () { return throttled_fetch_1.NETWORK_THROTTLE_CONFIG; } });
+Object.defineProperty(exports, "createThrottledFetch", { enumerable: true, get: function () { return throttled_fetch_1.createThrottledFetch; } });
+Object.defineProperty(exports, "createThrottledFetchForChainId", { enumerable: true, get: function () { return throttled_fetch_1.createThrottledFetchForChainId; } });
+Object.defineProperty(exports, "createThrottledGetRpcServiceOptions", { enumerable: true, get: function () { return throttled_fetch_1.createThrottledGetRpcServiceOptions; } });
 //# sourceMappingURL=index.cjs.map
\ No newline at end of file
diff --git a/dist/index.cjs.map b/dist/index.cjs.map
index a217e79fd471c56839cf013b1ef87dc93841bd8f..418605904b158d7780c1015584a0464c2e9b88b9 100644
--- a/dist/index.cjs.map
+++ b/dist/index.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"index.cjs","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AA6CA,6DAM6B;AAL3B,qIAAA,gCAAgC,OAAA;AAChC,oIAAA,+BAA+B,OAAA;AAC/B,gHAAA,WAAW,OAAA;AACX,sHAAA,iBAAiB,OAAA;AACjB,oHAAA,eAAe,OAAA;AAEjB,kDAA4B;AAO5B,qCAA4C;AAAnC,0GAAA,iBAAiB,OAAA;AAI1B,6DAA8D;AAArD,gHAAA,iBAAiB,OAAA","sourcesContent":["export type { AutoManagedNetworkClient } from './create-auto-managed-network-client';\nexport type {\n  Block,\n  NetworkMetadata,\n  NetworkConfiguration,\n  BuiltInNetworkClientId,\n  CustomNetworkClientId,\n  NetworkClientId,\n  NetworksMetadata,\n  NetworkState,\n  BlockTrackerProxy,\n  ProviderProxy,\n  AddNetworkFields,\n  UpdateNetworkFields,\n  NetworkControllerStateChangeEvent,\n  NetworkControllerNetworkWillChangeEvent,\n  NetworkControllerNetworkDidChangeEvent,\n  NetworkControllerInfuraIsBlockedEvent,\n  NetworkControllerInfuraIsUnblockedEvent,\n  NetworkControllerNetworkAddedEvent,\n  NetworkControllerNetworkRemovedEvent,\n  NetworkControllerEvents,\n  NetworkControllerGetStateAction,\n  NetworkControllerGetEthQueryAction,\n  NetworkControllerGetNetworkClientByIdAction,\n  NetworkControllerGetSelectedNetworkClientAction,\n  NetworkControllerGetSelectedChainIdAction,\n  NetworkControllerGetEIP1559CompatibilityAction,\n  NetworkControllerFindNetworkClientIdByChainIdAction,\n  NetworkControllerSetProviderTypeAction,\n  NetworkControllerSetActiveNetworkAction,\n  NetworkControllerAddNetworkAction,\n  NetworkControllerRemoveNetworkAction,\n  NetworkControllerUpdateNetworkAction,\n  NetworkControllerGetNetworkConfigurationByNetworkClientId,\n  NetworkControllerActions,\n  NetworkControllerMessenger,\n  NetworkControllerOptions,\n  NetworkControllerRpcEndpointChainUnavailableEvent,\n  NetworkControllerRpcEndpointUnavailableEvent,\n  NetworkControllerRpcEndpointChainDegradedEvent,\n  NetworkControllerRpcEndpointDegradedEvent,\n  NetworkControllerRpcEndpointChainAvailableEvent,\n  NetworkControllerRpcEndpointRetriedEvent,\n} from './NetworkController';\nexport {\n  getDefaultNetworkControllerState,\n  selectAvailableNetworkClientIds,\n  knownKeysOf,\n  NetworkController,\n  RpcEndpointType,\n} from './NetworkController';\nexport * from './constants';\nexport type { BlockTracker, Provider } from './types';\nexport type {\n  NetworkClientConfiguration,\n  InfuraNetworkClientConfiguration,\n  CustomNetworkClientConfiguration,\n} from './types';\nexport { NetworkClientType } from './types';\nexport type { NetworkClient } from './create-network-client';\nexport type { AbstractRpcService } from './rpc-service/abstract-rpc-service';\nexport type { RpcServiceRequestable } from './rpc-service/rpc-service-requestable';\nexport { isConnectionError } from './rpc-service/rpc-service';\n"]}
\ No newline at end of file
+{"version":3,"file":"index.cjs","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AA6CA,6DAM6B;AAL3B,qIAAA,gCAAgC,OAAA;AAChC,oIAAA,+BAA+B,OAAA;AAC/B,gHAAA,WAAW,OAAA;AACX,sHAAA,iBAAiB,OAAA;AACjB,oHAAA,eAAe,OAAA;AAEjB,kDAA4B;AAO5B,qCAA4C;AAAnC,0GAAA,iBAAiB,OAAA;AAI1B,6DAA8D;AAArD,gHAAA,iBAAiB,OAAA;AAC1B,yDAK2B;AAJzB,0HAAA,uBAAuB,OAAA;AACvB,uHAAA,oBAAoB,OAAA;AACpB,iIAAA,8BAA8B,OAAA;AAC9B,sIAAA,mCAAmC,OAAA","sourcesContent":["export type { AutoManagedNetworkClient } from './create-auto-managed-network-client';\nexport type {\n  Block,\n  NetworkMetadata,\n  NetworkConfiguration,\n  BuiltInNetworkClientId,\n  CustomNetworkClientId,\n  NetworkClientId,\n  NetworksMetadata,\n  NetworkState,\n  BlockTrackerProxy,\n  ProviderProxy,\n  AddNetworkFields,\n  UpdateNetworkFields,\n  NetworkControllerStateChangeEvent,\n  NetworkControllerNetworkWillChangeEvent,\n  NetworkControllerNetworkDidChangeEvent,\n  NetworkControllerInfuraIsBlockedEvent,\n  NetworkControllerInfuraIsUnblockedEvent,\n  NetworkControllerNetworkAddedEvent,\n  NetworkControllerNetworkRemovedEvent,\n  NetworkControllerEvents,\n  NetworkControllerGetStateAction,\n  NetworkControllerGetEthQueryAction,\n  NetworkControllerGetNetworkClientByIdAction,\n  NetworkControllerGetSelectedNetworkClientAction,\n  NetworkControllerGetSelectedChainIdAction,\n  NetworkControllerGetEIP1559CompatibilityAction,\n  NetworkControllerFindNetworkClientIdByChainIdAction,\n  NetworkControllerSetProviderTypeAction,\n  NetworkControllerSetActiveNetworkAction,\n  NetworkControllerAddNetworkAction,\n  NetworkControllerRemoveNetworkAction,\n  NetworkControllerUpdateNetworkAction,\n  NetworkControllerGetNetworkConfigurationByNetworkClientId,\n  NetworkControllerActions,\n  NetworkControllerMessenger,\n  NetworkControllerOptions,\n  NetworkControllerRpcEndpointChainUnavailableEvent,\n  NetworkControllerRpcEndpointUnavailableEvent,\n  NetworkControllerRpcEndpointChainDegradedEvent,\n  NetworkControllerRpcEndpointDegradedEvent,\n  NetworkControllerRpcEndpointChainAvailableEvent,\n  NetworkControllerRpcEndpointRetriedEvent,\n} from './NetworkController';\nexport {\n  getDefaultNetworkControllerState,\n  selectAvailableNetworkClientIds,\n  knownKeysOf,\n  NetworkController,\n  RpcEndpointType,\n} from './NetworkController';\nexport * from './constants';\nexport type { BlockTracker, Provider } from './types';\nexport type {\n  NetworkClientConfiguration,\n  InfuraNetworkClientConfiguration,\n  CustomNetworkClientConfiguration,\n} from './types';\nexport { NetworkClientType } from './types';\nexport type { NetworkClient } from './create-network-client';\nexport type { AbstractRpcService } from './rpc-service/abstract-rpc-service';\nexport type { RpcServiceRequestable } from './rpc-service/rpc-service-requestable';\nexport { isConnectionError } from './rpc-service/rpc-service';\nexport {\n  NETWORK_THROTTLE_CONFIG,\n  createThrottledFetch,\n  createThrottledFetchForChainId,\n  createThrottledGetRpcServiceOptions,\n} from './throttled-fetch';\n"]}
\ No newline at end of file
diff --git a/dist/index.d.cts b/dist/index.d.cts
index 94ff310f82df8c5a114ec6a1644e736ae3e3f039..87a5a36779537a55b0100ac34211d09837dba2ca 100644
--- a/dist/index.d.cts
+++ b/dist/index.d.cts
@@ -9,4 +9,5 @@ export type { NetworkClient } from "./create-network-client.cjs";
 export type { AbstractRpcService } from "./rpc-service/abstract-rpc-service.cjs";
 export type { RpcServiceRequestable } from "./rpc-service/rpc-service-requestable.cjs";
 export { isConnectionError } from "./rpc-service/rpc-service.cjs";
+export { NETWORK_THROTTLE_CONFIG, createThrottledFetch, createThrottledFetchForChainId, createThrottledGetRpcServiceOptions, } from "./throttled-fetch.cjs";
 //# sourceMappingURL=index.d.cts.map
\ No newline at end of file
diff --git a/dist/index.d.cts.map b/dist/index.d.cts.map
index 7c8927ac994f18157eb73051ffd0f196b808fe3e..75c99838e275767f999acce77f7a306037995d52 100644
--- a/dist/index.d.cts.map
+++ b/dist/index.d.cts.map
@@ -1 +1 @@
-{"version":3,"file":"index.d.cts","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"AAAA,YAAY,EAAE,wBAAwB,EAAE,iDAA6C;AACrF,YAAY,EACV,KAAK,EACL,eAAe,EACf,oBAAoB,EACpB,sBAAsB,EACtB,qBAAqB,EACrB,eAAe,EACf,gBAAgB,EAChB,YAAY,EACZ,iBAAiB,EACjB,aAAa,EACb,gBAAgB,EAChB,mBAAmB,EACnB,iCAAiC,EACjC,uCAAuC,EACvC,sCAAsC,EACtC,qCAAqC,EACrC,uCAAuC,EACvC,kCAAkC,EAClC,oCAAoC,EACpC,uBAAuB,EACvB,+BAA+B,EAC/B,kCAAkC,EAClC,2CAA2C,EAC3C,+CAA+C,EAC/C,yCAAyC,EACzC,8CAA8C,EAC9C,mDAAmD,EACnD,sCAAsC,EACtC,uCAAuC,EACvC,iCAAiC,EACjC,oCAAoC,EACpC,oCAAoC,EACpC,yDAAyD,EACzD,wBAAwB,EACxB,0BAA0B,EAC1B,wBAAwB,EACxB,iDAAiD,EACjD,4CAA4C,EAC5C,8CAA8C,EAC9C,yCAAyC,EACzC,+CAA+C,EAC/C,wCAAwC,GACzC,gCAA4B;AAC7B,OAAO,EACL,gCAAgC,EAChC,+BAA+B,EAC/B,WAAW,EACX,iBAAiB,EACjB,eAAe,GAChB,gCAA4B;AAC7B,gCAA4B;AAC5B,YAAY,EAAE,YAAY,EAAE,QAAQ,EAAE,oBAAgB;AACtD,YAAY,EACV,0BAA0B,EAC1B,gCAAgC,EAChC,gCAAgC,GACjC,oBAAgB;AACjB,OAAO,EAAE,iBAAiB,EAAE,oBAAgB;AAC5C,YAAY,EAAE,aAAa,EAAE,oCAAgC;AAC7D,YAAY,EAAE,kBAAkB,EAAE,+CAA2C;AAC7E,YAAY,EAAE,qBAAqB,EAAE,kDAA8C;AACnF,OAAO,EAAE,iBAAiB,EAAE,sCAAkC"}
\ No newline at end of file
+{"version":3,"file":"index.d.cts","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"AAAA,YAAY,EAAE,wBAAwB,EAAE,iDAA6C;AACrF,YAAY,EACV,KAAK,EACL,eAAe,EACf,oBAAoB,EACpB,sBAAsB,EACtB,qBAAqB,EACrB,eAAe,EACf,gBAAgB,EAChB,YAAY,EACZ,iBAAiB,EACjB,aAAa,EACb,gBAAgB,EAChB,mBAAmB,EACnB,iCAAiC,EACjC,uCAAuC,EACvC,sCAAsC,EACtC,qCAAqC,EACrC,uCAAuC,EACvC,kCAAkC,EAClC,oCAAoC,EACpC,uBAAuB,EACvB,+BAA+B,EAC/B,kCAAkC,EAClC,2CAA2C,EAC3C,+CAA+C,EAC/C,yCAAyC,EACzC,8CAA8C,EAC9C,mDAAmD,EACnD,sCAAsC,EACtC,uCAAuC,EACvC,iCAAiC,EACjC,oCAAoC,EACpC,oCAAoC,EACpC,yDAAyD,EACzD,wBAAwB,EACxB,0BAA0B,EAC1B,wBAAwB,EACxB,iDAAiD,EACjD,4CAA4C,EAC5C,8CAA8C,EAC9C,yCAAyC,EACzC,+CAA+C,EAC/C,wCAAwC,GACzC,gCAA4B;AAC7B,OAAO,EACL,gCAAgC,EAChC,+BAA+B,EAC/B,WAAW,EACX,iBAAiB,EACjB,eAAe,GAChB,gCAA4B;AAC7B,gCAA4B;AAC5B,YAAY,EAAE,YAAY,EAAE,QAAQ,EAAE,oBAAgB;AACtD,YAAY,EACV,0BAA0B,EAC1B,gCAAgC,EAChC,gCAAgC,GACjC,oBAAgB;AACjB,OAAO,EAAE,iBAAiB,EAAE,oBAAgB;AAC5C,YAAY,EAAE,aAAa,EAAE,oCAAgC;AAC7D,YAAY,EAAE,kBAAkB,EAAE,+CAA2C;AAC7E,YAAY,EAAE,qBAAqB,EAAE,kDAA8C;AACnF,OAAO,EAAE,iBAAiB,EAAE,sCAAkC;AAC9D,OAAO,EACL,uBAAuB,EACvB,oBAAoB,EACpB,8BAA8B,EAC9B,mCAAmC,GACpC,8BAA0B"}
\ No newline at end of file
diff --git a/dist/index.d.mts b/dist/index.d.mts
index 4d941b456354ad8cd4379de46f659078c9762d6f..67a6e1ea8f91066b4da9d755bdf3cc482b8a7570 100644
--- a/dist/index.d.mts
+++ b/dist/index.d.mts
@@ -9,4 +9,5 @@ export type { NetworkClient } from "./create-network-client.mjs";
 export type { AbstractRpcService } from "./rpc-service/abstract-rpc-service.mjs";
 export type { RpcServiceRequestable } from "./rpc-service/rpc-service-requestable.mjs";
 export { isConnectionError } from "./rpc-service/rpc-service.mjs";
+export { NETWORK_THROTTLE_CONFIG, createThrottledFetch, createThrottledFetchForChainId, createThrottledGetRpcServiceOptions, } from "./throttled-fetch.mjs";
 //# sourceMappingURL=index.d.mts.map
\ No newline at end of file
diff --git a/dist/index.d.mts.map b/dist/index.d.mts.map
index 24fc819b43de366e2637b44f0f9e71644530c96b..b8e39a4c779b61d90917d43b6e0c9e404d3d3169 100644
--- a/dist/index.d.mts.map
+++ b/dist/index.d.mts.map
@@ -1 +1 @@
-{"version":3,"file":"index.d.mts","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"AAAA,YAAY,EAAE,wBAAwB,EAAE,iDAA6C;AACrF,YAAY,EACV,KAAK,EACL,eAAe,EACf,oBAAoB,EACpB,sBAAsB,EACtB,qBAAqB,EACrB,eAAe,EACf,gBAAgB,EAChB,YAAY,EACZ,iBAAiB,EACjB,aAAa,EACb,gBAAgB,EAChB,mBAAmB,EACnB,iCAAiC,EACjC,uCAAuC,EACvC,sCAAsC,EACtC,qCAAqC,EACrC,uCAAuC,EACvC,kCAAkC,EAClC,oCAAoC,EACpC,uBAAuB,EACvB,+BAA+B,EAC/B,kCAAkC,EAClC,2CAA2C,EAC3C,+CAA+C,EAC/C,yCAAyC,EACzC,8CAA8C,EAC9C,mDAAmD,EACnD,sCAAsC,EACtC,uCAAuC,EACvC,iCAAiC,EACjC,oCAAoC,EACpC,oCAAoC,EACpC,yDAAyD,EACzD,wBAAwB,EACxB,0BAA0B,EAC1B,wBAAwB,EACxB,iDAAiD,EACjD,4CAA4C,EAC5C,8CAA8C,EAC9C,yCAAyC,EACzC,+CAA+C,EAC/C,wCAAwC,GACzC,gCAA4B;AAC7B,OAAO,EACL,gCAAgC,EAChC,+BAA+B,EAC/B,WAAW,EACX,iBAAiB,EACjB,eAAe,GAChB,gCAA4B;AAC7B,gCAA4B;AAC5B,YAAY,EAAE,YAAY,EAAE,QAAQ,EAAE,oBAAgB;AACtD,YAAY,EACV,0BAA0B,EAC1B,gCAAgC,EAChC,gCAAgC,GACjC,oBAAgB;AACjB,OAAO,EAAE,iBAAiB,EAAE,oBAAgB;AAC5C,YAAY,EAAE,aAAa,EAAE,oCAAgC;AAC7D,YAAY,EAAE,kBAAkB,EAAE,+CAA2C;AAC7E,YAAY,EAAE,qBAAqB,EAAE,kDAA8C;AACnF,OAAO,EAAE,iBAAiB,EAAE,sCAAkC"}
\ No newline at end of file
+{"version":3,"file":"index.d.mts","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"AAAA,YAAY,EAAE,wBAAwB,EAAE,iDAA6C;AACrF,YAAY,EACV,KAAK,EACL,eAAe,EACf,oBAAoB,EACpB,sBAAsB,EACtB,qBAAqB,EACrB,eAAe,EACf,gBAAgB,EAChB,YAAY,EACZ,iBAAiB,EACjB,aAAa,EACb,gBAAgB,EAChB,mBAAmB,EACnB,iCAAiC,EACjC,uCAAuC,EACvC,sCAAsC,EACtC,qCAAqC,EACrC,uCAAuC,EACvC,kCAAkC,EAClC,oCAAoC,EACpC,uBAAuB,EACvB,+BAA+B,EAC/B,kCAAkC,EAClC,2CAA2C,EAC3C,+CAA+C,EAC/C,yCAAyC,EACzC,8CAA8C,EAC9C,mDAAmD,EACnD,sCAAsC,EACtC,uCAAuC,EACvC,iCAAiC,EACjC,oCAAoC,EACpC,oCAAoC,EACpC,yDAAyD,EACzD,wBAAwB,EACxB,0BAA0B,EAC1B,wBAAwB,EACxB,iDAAiD,EACjD,4CAA4C,EAC5C,8CAA8C,EAC9C,yCAAyC,EACzC,+CAA+C,EAC/C,wCAAwC,GACzC,gCAA4B;AAC7B,OAAO,EACL,gCAAgC,EAChC,+BAA+B,EAC/B,WAAW,EACX,iBAAiB,EACjB,eAAe,GAChB,gCAA4B;AAC7B,gCAA4B;AAC5B,YAAY,EAAE,YAAY,EAAE,QAAQ,EAAE,oBAAgB;AACtD,YAAY,EACV,0BAA0B,EAC1B,gCAAgC,EAChC,gCAAgC,GACjC,oBAAgB;AACjB,OAAO,EAAE,iBAAiB,EAAE,oBAAgB;AAC5C,YAAY,EAAE,aAAa,EAAE,oCAAgC;AAC7D,YAAY,EAAE,kBAAkB,EAAE,+CAA2C;AAC7E,YAAY,EAAE,qBAAqB,EAAE,kDAA8C;AACnF,OAAO,EAAE,iBAAiB,EAAE,sCAAkC;AAC9D,OAAO,EACL,uBAAuB,EACvB,oBAAoB,EACpB,8BAA8B,EAC9B,mCAAmC,GACpC,8BAA0B"}
\ No newline at end of file
diff --git a/dist/index.mjs b/dist/index.mjs
index 43e88ff4e43d3cc05de0ec43b5e129302f8117b6..f840a9f70120b41431c726878931ebd416f116a1 100644
--- a/dist/index.mjs
+++ b/dist/index.mjs
@@ -2,4 +2,5 @@ export { getDefaultNetworkControllerState, selectAvailableNetworkClientIds, know
 export * from "./constants.mjs";
 export { NetworkClientType } from "./types.mjs";
 export { isConnectionError } from "./rpc-service/rpc-service.mjs";
+export { NETWORK_THROTTLE_CONFIG, createThrottledFetch, createThrottledFetchForChainId, createThrottledGetRpcServiceOptions } from "./throttled-fetch.mjs";
 //# sourceMappingURL=index.mjs.map
\ No newline at end of file
diff --git a/dist/index.mjs.map b/dist/index.mjs.map
index 37626c8b8177a922bf501c30295c34817dbf58ce..78282b4057a86bb80b11d0624afe2357d8e93ac9 100644
--- a/dist/index.mjs.map
+++ b/dist/index.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"index.mjs","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"AA6CA,OAAO,EACL,gCAAgC,EAChC,+BAA+B,EAC/B,WAAW,EACX,iBAAiB,EACjB,eAAe,EAChB,gCAA4B;AAC7B,gCAA4B;AAO5B,OAAO,EAAE,iBAAiB,EAAE,oBAAgB;AAI5C,OAAO,EAAE,iBAAiB,EAAE,sCAAkC","sourcesContent":["export type { AutoManagedNetworkClient } from './create-auto-managed-network-client';\nexport type {\n  Block,\n  NetworkMetadata,\n  NetworkConfiguration,\n  BuiltInNetworkClientId,\n  CustomNetworkClientId,\n  NetworkClientId,\n  NetworksMetadata,\n  NetworkState,\n  BlockTrackerProxy,\n  ProviderProxy,\n  AddNetworkFields,\n  UpdateNetworkFields,\n  NetworkControllerStateChangeEvent,\n  NetworkControllerNetworkWillChangeEvent,\n  NetworkControllerNetworkDidChangeEvent,\n  NetworkControllerInfuraIsBlockedEvent,\n  NetworkControllerInfuraIsUnblockedEvent,\n  NetworkControllerNetworkAddedEvent,\n  NetworkControllerNetworkRemovedEvent,\n  NetworkControllerEvents,\n  NetworkControllerGetStateAction,\n  NetworkControllerGetEthQueryAction,\n  NetworkControllerGetNetworkClientByIdAction,\n  NetworkControllerGetSelectedNetworkClientAction,\n  NetworkControllerGetSelectedChainIdAction,\n  NetworkControllerGetEIP1559CompatibilityAction,\n  NetworkControllerFindNetworkClientIdByChainIdAction,\n  NetworkControllerSetProviderTypeAction,\n  NetworkControllerSetActiveNetworkAction,\n  NetworkControllerAddNetworkAction,\n  NetworkControllerRemoveNetworkAction,\n  NetworkControllerUpdateNetworkAction,\n  NetworkControllerGetNetworkConfigurationByNetworkClientId,\n  NetworkControllerActions,\n  NetworkControllerMessenger,\n  NetworkControllerOptions,\n  NetworkControllerRpcEndpointChainUnavailableEvent,\n  NetworkControllerRpcEndpointUnavailableEvent,\n  NetworkControllerRpcEndpointChainDegradedEvent,\n  NetworkControllerRpcEndpointDegradedEvent,\n  NetworkControllerRpcEndpointChainAvailableEvent,\n  NetworkControllerRpcEndpointRetriedEvent,\n} from './NetworkController';\nexport {\n  getDefaultNetworkControllerState,\n  selectAvailableNetworkClientIds,\n  knownKeysOf,\n  NetworkController,\n  RpcEndpointType,\n} from './NetworkController';\nexport * from './constants';\nexport type { BlockTracker, Provider } from './types';\nexport type {\n  NetworkClientConfiguration,\n  InfuraNetworkClientConfiguration,\n  CustomNetworkClientConfiguration,\n} from './types';\nexport { NetworkClientType } from './types';\nexport type { NetworkClient } from './create-network-client';\nexport type { AbstractRpcService } from './rpc-service/abstract-rpc-service';\nexport type { RpcServiceRequestable } from './rpc-service/rpc-service-requestable';\nexport { isConnectionError } from './rpc-service/rpc-service';\n"]}
\ No newline at end of file
+{"version":3,"file":"index.mjs","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"AA6CA,OAAO,EACL,gCAAgC,EAChC,+BAA+B,EAC/B,WAAW,EACX,iBAAiB,EACjB,eAAe,EAChB,gCAA4B;AAC7B,gCAA4B;AAO5B,OAAO,EAAE,iBAAiB,EAAE,oBAAgB;AAI5C,OAAO,EAAE,iBAAiB,EAAE,sCAAkC;AAC9D,OAAO,EACL,uBAAuB,EACvB,oBAAoB,EACpB,8BAA8B,EAC9B,mCAAmC,EACpC,8BAA0B","sourcesContent":["export type { AutoManagedNetworkClient } from './create-auto-managed-network-client';\nexport type {\n  Block,\n  NetworkMetadata,\n  NetworkConfiguration,\n  BuiltInNetworkClientId,\n  CustomNetworkClientId,\n  NetworkClientId,\n  NetworksMetadata,\n  NetworkState,\n  BlockTrackerProxy,\n  ProviderProxy,\n  AddNetworkFields,\n  UpdateNetworkFields,\n  NetworkControllerStateChangeEvent,\n  NetworkControllerNetworkWillChangeEvent,\n  NetworkControllerNetworkDidChangeEvent,\n  NetworkControllerInfuraIsBlockedEvent,\n  NetworkControllerInfuraIsUnblockedEvent,\n  NetworkControllerNetworkAddedEvent,\n  NetworkControllerNetworkRemovedEvent,\n  NetworkControllerEvents,\n  NetworkControllerGetStateAction,\n  NetworkControllerGetEthQueryAction,\n  NetworkControllerGetNetworkClientByIdAction,\n  NetworkControllerGetSelectedNetworkClientAction,\n  NetworkControllerGetSelectedChainIdAction,\n  NetworkControllerGetEIP1559CompatibilityAction,\n  NetworkControllerFindNetworkClientIdByChainIdAction,\n  NetworkControllerSetProviderTypeAction,\n  NetworkControllerSetActiveNetworkAction,\n  NetworkControllerAddNetworkAction,\n  NetworkControllerRemoveNetworkAction,\n  NetworkControllerUpdateNetworkAction,\n  NetworkControllerGetNetworkConfigurationByNetworkClientId,\n  NetworkControllerActions,\n  NetworkControllerMessenger,\n  NetworkControllerOptions,\n  NetworkControllerRpcEndpointChainUnavailableEvent,\n  NetworkControllerRpcEndpointUnavailableEvent,\n  NetworkControllerRpcEndpointChainDegradedEvent,\n  NetworkControllerRpcEndpointDegradedEvent,\n  NetworkControllerRpcEndpointChainAvailableEvent,\n  NetworkControllerRpcEndpointRetriedEvent,\n} from './NetworkController';\nexport {\n  getDefaultNetworkControllerState,\n  selectAvailableNetworkClientIds,\n  knownKeysOf,\n  NetworkController,\n  RpcEndpointType,\n} from './NetworkController';\nexport * from './constants';\nexport type { BlockTracker, Provider } from './types';\nexport type {\n  NetworkClientConfiguration,\n  InfuraNetworkClientConfiguration,\n  CustomNetworkClientConfiguration,\n} from './types';\nexport { NetworkClientType } from './types';\nexport type { NetworkClient } from './create-network-client';\nexport type { AbstractRpcService } from './rpc-service/abstract-rpc-service';\nexport type { RpcServiceRequestable } from './rpc-service/rpc-service-requestable';\nexport { isConnectionError } from './rpc-service/rpc-service';\nexport {\n  NETWORK_THROTTLE_CONFIG,\n  createThrottledFetch,\n  createThrottledFetchForChainId,\n  createThrottledGetRpcServiceOptions,\n} from './throttled-fetch';\n"]}
\ No newline at end of file
diff --git a/dist/throttled-fetch.cjs b/dist/throttled-fetch.cjs
new file mode 100644
index 0000000000000000000000000000000000000000..7cdecbdcee55534d229b7a047132aaf82c4d9a5b
--- /dev/null
+++ b/dist/throttled-fetch.cjs
@@ -0,0 +1,88 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.createThrottledGetRpcServiceOptions = exports.createThrottledFetchForChainId = exports.createThrottledFetch = exports.NETWORK_THROTTLE_CONFIG = void 0;
+/**
+ * Configuration for network throttling by chain ID.
+ * Maps chain IDs (in hex format) to delay in milliseconds.
+ */
+exports.NETWORK_THROTTLE_CONFIG = {
+    // '0x2019': 2000, // Klaytn - 2s delay
+    // '0x504': 1000, // Moonbeam - 1s delay
+    // '0x505': 1000, // Moonriver - 1s delay
+    // '0x4e454152': 1500, // Aurora - 1.5s delay
+    '0x1': 10000, // Ethereum Mainnet - 10s delay
+};
+/**
+ * Creates a throttled fetch function that adds artificial delays before making requests.
+ * Useful for testing slow network conditions.
+ *
+ * @param delayMs - The delay in milliseconds to add before each request
+ * @param originalFetch - The original fetch function to wrap
+ * @returns A throttled fetch function
+ */
+function createThrottledFetch(delayMs, originalFetch) {
+    if (delayMs <= 0) {
+        return originalFetch;
+    }
+    return async (input, init) => {
+        // Add artificial delay before making the request
+        await new Promise((resolve) => setTimeout(resolve, delayMs));
+        return originalFetch(input, init);
+    };
+}
+exports.createThrottledFetch = createThrottledFetch;
+/**
+ * Creates a fetch function that applies throttling based on the chain ID.
+ * Extracts chain ID from the RPC endpoint URL to determine the appropriate delay.
+ *
+ * @param rpcEndpointUrl - The RPC endpoint URL (may contain chain ID context)
+ * @param chainId - The chain ID in hex format (e.g., '0x2019')
+ * @param originalFetch - The original fetch function to wrap
+ * @param throttleConfig - Optional custom throttle configuration map
+ * @returns A throttled fetch function if configured for this chain, otherwise the original
+ */
+function createThrottledFetchForChainId(rpcEndpointUrl, chainId, originalFetch, throttleConfig = exports.NETWORK_THROTTLE_CONFIG) {
+    const delayMs = throttleConfig[chainId] || 0;
+    if (delayMs === 0) {
+        return originalFetch;
+    }
+    console.log(`[NetworkThrottle] Applying ${delayMs}ms delay to chain ${chainId} (${rpcEndpointUrl})`);
+    return createThrottledFetch(delayMs, originalFetch);
+}
+exports.createThrottledFetchForChainId = createThrottledFetchForChainId;
+/**
+ * Creates a wrapped getRpcServiceOptions function that applies network throttling
+ * based on chain ID. This is meant to be used in NetworkController initialization.
+ *
+ * @param originalGetRpcServiceOptions - The original getRpcServiceOptions function
+ * @param getChainIdForUrl - Function to get the chain ID for a given RPC endpoint URL
+ * @param throttleConfig - Optional custom throttle configuration map
+ * @returns A wrapped getRpcServiceOptions function that applies throttling
+ *
+ * @example
+ * ```typescript
+ * const networkController = new NetworkController({
+ *   getRpcServiceOptions: createThrottledGetRpcServiceOptions(
+ *     (rpcEndpointUrl) => ({ fetch, btoa }),
+ *     (rpcEndpointUrl) => '0x1', // Get chainId from your config
+ *   ),
+ *   // ... other options
+ * });
+ * ```
+ */
+function createThrottledGetRpcServiceOptions(originalGetRpcServiceOptions, getChainIdForUrl, throttleConfig = exports.NETWORK_THROTTLE_CONFIG) {
+    return (rpcEndpointUrl) => {
+        const options = originalGetRpcServiceOptions(rpcEndpointUrl);
+        const chainId = getChainIdForUrl(rpcEndpointUrl);
+        if (!chainId) {
+            return options;
+        }
+        const throttledFetch = createThrottledFetchForChainId(rpcEndpointUrl, chainId, options.fetch, throttleConfig);
+        return {
+            ...options,
+            fetch: throttledFetch,
+        };
+    };
+}
+exports.createThrottledGetRpcServiceOptions = createThrottledGetRpcServiceOptions;
+//# sourceMappingURL=throttled-fetch.cjs.map
\ No newline at end of file
diff --git a/dist/throttled-fetch.cjs.map b/dist/throttled-fetch.cjs.map
new file mode 100644
index 0000000000000000000000000000000000000000..f20e657144e64fe52d3ddbe5cfa6ed2401c71e04
--- /dev/null
+++ b/dist/throttled-fetch.cjs.map
@@ -0,0 +1 @@
+{"version":3,"file":"throttled-fetch.cjs","sourceRoot":"","sources":["../src/throttled-fetch.ts"],"names":[],"mappings":";;;AAAA;;;GAGG;AACU,QAAA,uBAAuB,GAA2B;IAC7D,uCAAuC;IACvC,wCAAwC;IACxC,yCAAyC;IACzC,6CAA6C;IAC7C,KAAK,EAAE,KAAK,EAAE,+BAA+B;CAC9C,CAAC;AAEF;;;;;;;GAOG;AACH,SAAgB,oBAAoB,CAClC,OAAe,EACf,aAA2B;IAE3B,IAAI,OAAO,IAAI,CAAC,EAAE,CAAC;QACjB,OAAO,aAAa,CAAC;IACvB,CAAC;IAED,OAAO,KAAK,EACV,KAAwB,EACxB,IAAkB,EACC,EAAE;QACrB,iDAAiD;QACjD,MAAM,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,UAAU,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC,CAAC;QAC7D,OAAO,aAAa,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;IACpC,CAAC,CAAC;AACJ,CAAC;AAhBD,oDAgBC;AAED;;;;;;;;;GASG;AACH,SAAgB,8BAA8B,CAC5C,cAAsB,EACtB,OAAe,EACf,aAA2B,EAC3B,iBAAyC,+BAAuB;IAEhE,MAAM,OAAO,GAAG,cAAc,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;IAE7C,IAAI,OAAO,KAAK,CAAC,EAAE,CAAC;QAClB,OAAO,aAAa,CAAC;IACvB,CAAC;IAED,OAAO,CAAC,GAAG,CACT,8BAA8B,OAAO,qBAAqB,OAAO,KAAK,cAAc,GAAG,CACxF,CAAC;IAEF,OAAO,oBAAoB,CAAC,OAAO,EAAE,aAAa,CAAC,CAAC;AACtD,CAAC;AAjBD,wEAiBC;AAED;;;;;;;;;;;;;;;;;;;GAmBG;AACH,SAAgB,mCAAmC,CACjD,4BAIC,EACD,gBAAgE,EAChE,iBAAyC,+BAAuB;IAEhE,OAAO,CAAC,cAAsB,EAAE,EAAE;QAChC,MAAM,OAAO,GAAG,4BAA4B,CAAC,cAAc,CAAC,CAAC;QAC7D,MAAM,OAAO,GAAG,gBAAgB,CAAC,cAAc,CAAC,CAAC;QAEjD,IAAI,CAAC,OAAO,EAAE,CAAC;YACb,OAAO,OAAO,CAAC;QACjB,CAAC;QAED,MAAM,cAAc,GAAG,8BAA8B,CACnD,cAAc,EACd,OAAO,EACP,OAAO,CAAC,KAAK,EACb,cAAc,CACf,CAAC;QAEF,OAAO;YACL,GAAG,OAAO;YACV,KAAK,EAAE,cAAc;SACtB,CAAC;IACJ,CAAC,CAAC;AACJ,CAAC;AA7BD,kFA6BC","sourcesContent":["/**\n * Configuration for network throttling by chain ID.\n * Maps chain IDs (in hex format) to delay in milliseconds.\n */\nexport const NETWORK_THROTTLE_CONFIG: Record<string, number> = {\n  // '0x2019': 2000, // Klaytn - 2s delay\n  // '0x504': 1000, // Moonbeam - 1s delay\n  // '0x505': 1000, // Moonriver - 1s delay\n  // '0x4e454152': 1500, // Aurora - 1.5s delay\n  '0x1': 10000, // Ethereum Mainnet - 10s delay\n};\n\n/**\n * Creates a throttled fetch function that adds artificial delays before making requests.\n * Useful for testing slow network conditions.\n *\n * @param delayMs - The delay in milliseconds to add before each request\n * @param originalFetch - The original fetch function to wrap\n * @returns A throttled fetch function\n */\nexport function createThrottledFetch(\n  delayMs: number,\n  originalFetch: typeof fetch,\n): typeof fetch {\n  if (delayMs <= 0) {\n    return originalFetch;\n  }\n\n  return async (\n    input: RequestInfo | URL,\n    init?: RequestInit,\n  ): Promise<Response> => {\n    // Add artificial delay before making the request\n    await new Promise((resolve) => setTimeout(resolve, delayMs));\n    return originalFetch(input, init);\n  };\n}\n\n/**\n * Creates a fetch function that applies throttling based on the chain ID.\n * Extracts chain ID from the RPC endpoint URL to determine the appropriate delay.\n *\n * @param rpcEndpointUrl - The RPC endpoint URL (may contain chain ID context)\n * @param chainId - The chain ID in hex format (e.g., '0x2019')\n * @param originalFetch - The original fetch function to wrap\n * @param throttleConfig - Optional custom throttle configuration map\n * @returns A throttled fetch function if configured for this chain, otherwise the original\n */\nexport function createThrottledFetchForChainId(\n  rpcEndpointUrl: string,\n  chainId: string,\n  originalFetch: typeof fetch,\n  throttleConfig: Record<string, number> = NETWORK_THROTTLE_CONFIG,\n): typeof fetch {\n  const delayMs = throttleConfig[chainId] || 0;\n\n  if (delayMs === 0) {\n    return originalFetch;\n  }\n\n  console.log(\n    `[NetworkThrottle] Applying ${delayMs}ms delay to chain ${chainId} (${rpcEndpointUrl})`,\n  );\n\n  return createThrottledFetch(delayMs, originalFetch);\n}\n\n/**\n * Creates a wrapped getRpcServiceOptions function that applies network throttling\n * based on chain ID. This is meant to be used in NetworkController initialization.\n *\n * @param originalGetRpcServiceOptions - The original getRpcServiceOptions function\n * @param getChainIdForUrl - Function to get the chain ID for a given RPC endpoint URL\n * @param throttleConfig - Optional custom throttle configuration map\n * @returns A wrapped getRpcServiceOptions function that applies throttling\n *\n * @example\n * ```typescript\n * const networkController = new NetworkController({\n *   getRpcServiceOptions: createThrottledGetRpcServiceOptions(\n *     (rpcEndpointUrl) => ({ fetch, btoa }),\n *     (rpcEndpointUrl) => '0x1', // Get chainId from your config\n *   ),\n *   // ... other options\n * });\n * ```\n */\nexport function createThrottledGetRpcServiceOptions(\n  originalGetRpcServiceOptions: (rpcEndpointUrl: string) => {\n    fetch: typeof fetch;\n    btoa: typeof btoa;\n    [key: string]: unknown;\n  },\n  getChainIdForUrl: (rpcEndpointUrl: string) => string | undefined,\n  throttleConfig: Record<string, number> = NETWORK_THROTTLE_CONFIG,\n): typeof originalGetRpcServiceOptions {\n  return (rpcEndpointUrl: string) => {\n    const options = originalGetRpcServiceOptions(rpcEndpointUrl);\n    const chainId = getChainIdForUrl(rpcEndpointUrl);\n\n    if (!chainId) {\n      return options;\n    }\n\n    const throttledFetch = createThrottledFetchForChainId(\n      rpcEndpointUrl,\n      chainId,\n      options.fetch,\n      throttleConfig,\n    );\n\n    return {\n      ...options,\n      fetch: throttledFetch,\n    };\n  };\n}\n"]}
\ No newline at end of file
diff --git a/dist/throttled-fetch.d.cts b/dist/throttled-fetch.d.cts
new file mode 100644
index 0000000000000000000000000000000000000000..7c6d30f682f8b8e97455c0a6b397e68734a70348
--- /dev/null
+++ b/dist/throttled-fetch.d.cts
@@ -0,0 +1,51 @@
+/**
+ * Configuration for network throttling by chain ID.
+ * Maps chain IDs (in hex format) to delay in milliseconds.
+ */
+export declare const NETWORK_THROTTLE_CONFIG: Record<string, number>;
+/**
+ * Creates a throttled fetch function that adds artificial delays before making requests.
+ * Useful for testing slow network conditions.
+ *
+ * @param delayMs - The delay in milliseconds to add before each request
+ * @param originalFetch - The original fetch function to wrap
+ * @returns A throttled fetch function
+ */
+export declare function createThrottledFetch(delayMs: number, originalFetch: typeof fetch): typeof fetch;
+/**
+ * Creates a fetch function that applies throttling based on the chain ID.
+ * Extracts chain ID from the RPC endpoint URL to determine the appropriate delay.
+ *
+ * @param rpcEndpointUrl - The RPC endpoint URL (may contain chain ID context)
+ * @param chainId - The chain ID in hex format (e.g., '0x2019')
+ * @param originalFetch - The original fetch function to wrap
+ * @param throttleConfig - Optional custom throttle configuration map
+ * @returns A throttled fetch function if configured for this chain, otherwise the original
+ */
+export declare function createThrottledFetchForChainId(rpcEndpointUrl: string, chainId: string, originalFetch: typeof fetch, throttleConfig?: Record<string, number>): typeof fetch;
+/**
+ * Creates a wrapped getRpcServiceOptions function that applies network throttling
+ * based on chain ID. This is meant to be used in NetworkController initialization.
+ *
+ * @param originalGetRpcServiceOptions - The original getRpcServiceOptions function
+ * @param getChainIdForUrl - Function to get the chain ID for a given RPC endpoint URL
+ * @param throttleConfig - Optional custom throttle configuration map
+ * @returns A wrapped getRpcServiceOptions function that applies throttling
+ *
+ * @example
+ * ```typescript
+ * const networkController = new NetworkController({
+ *   getRpcServiceOptions: createThrottledGetRpcServiceOptions(
+ *     (rpcEndpointUrl) => ({ fetch, btoa }),
+ *     (rpcEndpointUrl) => '0x1', // Get chainId from your config
+ *   ),
+ *   // ... other options
+ * });
+ * ```
+ */
+export declare function createThrottledGetRpcServiceOptions(originalGetRpcServiceOptions: (rpcEndpointUrl: string) => {
+    fetch: typeof fetch;
+    btoa: typeof btoa;
+    [key: string]: unknown;
+}, getChainIdForUrl: (rpcEndpointUrl: string) => string | undefined, throttleConfig?: Record<string, number>): typeof originalGetRpcServiceOptions;
+//# sourceMappingURL=throttled-fetch.d.cts.map
\ No newline at end of file
diff --git a/dist/throttled-fetch.d.cts.map b/dist/throttled-fetch.d.cts.map
new file mode 100644
index 0000000000000000000000000000000000000000..c81002886d9b9f777815f9e7516d3f4b5c1949c2
--- /dev/null
+++ b/dist/throttled-fetch.d.cts.map
@@ -0,0 +1 @@
+{"version":3,"file":"throttled-fetch.d.cts","sourceRoot":"","sources":["../src/throttled-fetch.ts"],"names":[],"mappings":"AAAA;;;GAGG;AACH,eAAO,MAAM,uBAAuB,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,CAM1D,CAAC;AAEF;;;;;;;GAOG;AACH,wBAAgB,oBAAoB,CAClC,OAAO,EAAE,MAAM,EACf,aAAa,EAAE,OAAO,KAAK,GAC1B,OAAO,KAAK,CAad;AAED;;;;;;;;;GASG;AACH,wBAAgB,8BAA8B,CAC5C,cAAc,EAAE,MAAM,EACtB,OAAO,EAAE,MAAM,EACf,aAAa,EAAE,OAAO,KAAK,EAC3B,cAAc,GAAE,MAAM,CAAC,MAAM,EAAE,MAAM,CAA2B,GAC/D,OAAO,KAAK,CAYd;AAED;;;;;;;;;;;;;;;;;;;GAmBG;AACH,wBAAgB,mCAAmC,CACjD,4BAA4B,EAAE,CAAC,cAAc,EAAE,MAAM,KAAK;IACxD,KAAK,EAAE,OAAO,KAAK,CAAC;IACpB,IAAI,EAAE,OAAO,IAAI,CAAC;IAClB,CAAC,GAAG,EAAE,MAAM,GAAG,OAAO,CAAC;CACxB,EACD,gBAAgB,EAAE,CAAC,cAAc,EAAE,MAAM,KAAK,MAAM,GAAG,SAAS,EAChE,cAAc,GAAE,MAAM,CAAC,MAAM,EAAE,MAAM,CAA2B,GAC/D,OAAO,4BAA4B,CAqBrC"}
\ No newline at end of file
diff --git a/dist/throttled-fetch.d.mts b/dist/throttled-fetch.d.mts
new file mode 100644
index 0000000000000000000000000000000000000000..09dfb7b2d6dc979f557f2d6fb8b2cdd153ef925b
--- /dev/null
+++ b/dist/throttled-fetch.d.mts
@@ -0,0 +1,51 @@
+/**
+ * Configuration for network throttling by chain ID.
+ * Maps chain IDs (in hex format) to delay in milliseconds.
+ */
+export declare const NETWORK_THROTTLE_CONFIG: Record<string, number>;
+/**
+ * Creates a throttled fetch function that adds artificial delays before making requests.
+ * Useful for testing slow network conditions.
+ *
+ * @param delayMs - The delay in milliseconds to add before each request
+ * @param originalFetch - The original fetch function to wrap
+ * @returns A throttled fetch function
+ */
+export declare function createThrottledFetch(delayMs: number, originalFetch: typeof fetch): typeof fetch;
+/**
+ * Creates a fetch function that applies throttling based on the chain ID.
+ * Extracts chain ID from the RPC endpoint URL to determine the appropriate delay.
+ *
+ * @param rpcEndpointUrl - The RPC endpoint URL (may contain chain ID context)
+ * @param chainId - The chain ID in hex format (e.g., '0x2019')
+ * @param originalFetch - The original fetch function to wrap
+ * @param throttleConfig - Optional custom throttle configuration map
+ * @returns A throttled fetch function if configured for this chain, otherwise the original
+ */
+export declare function createThrottledFetchForChainId(rpcEndpointUrl: string, chainId: string, originalFetch: typeof fetch, throttleConfig?: Record<string, number>): typeof fetch;
+/**
+ * Creates a wrapped getRpcServiceOptions function that applies network throttling
+ * based on chain ID. This is meant to be used in NetworkController initialization.
+ *
+ * @param originalGetRpcServiceOptions - The original getRpcServiceOptions function
+ * @param getChainIdForUrl - Function to get the chain ID for a given RPC endpoint URL
+ * @param throttleConfig - Optional custom throttle configuration map
+ * @returns A wrapped getRpcServiceOptions function that applies throttling
+ *
+ * @example
+ * ```typescript
+ * const networkController = new NetworkController({
+ *   getRpcServiceOptions: createThrottledGetRpcServiceOptions(
+ *     (rpcEndpointUrl) => ({ fetch, btoa }),
+ *     (rpcEndpointUrl) => '0x1', // Get chainId from your config
+ *   ),
+ *   // ... other options
+ * });
+ * ```
+ */
+export declare function createThrottledGetRpcServiceOptions(originalGetRpcServiceOptions: (rpcEndpointUrl: string) => {
+    fetch: typeof fetch;
+    btoa: typeof btoa;
+    [key: string]: unknown;
+}, getChainIdForUrl: (rpcEndpointUrl: string) => string | undefined, throttleConfig?: Record<string, number>): typeof originalGetRpcServiceOptions;
+//# sourceMappingURL=throttled-fetch.d.mts.map
\ No newline at end of file
diff --git a/dist/throttled-fetch.d.mts.map b/dist/throttled-fetch.d.mts.map
new file mode 100644
index 0000000000000000000000000000000000000000..5a07c71519d6ef2f0370c0da0b57bdb249371978
--- /dev/null
+++ b/dist/throttled-fetch.d.mts.map
@@ -0,0 +1 @@
+{"version":3,"file":"throttled-fetch.d.mts","sourceRoot":"","sources":["../src/throttled-fetch.ts"],"names":[],"mappings":"AAAA;;;GAGG;AACH,eAAO,MAAM,uBAAuB,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,CAM1D,CAAC;AAEF;;;;;;;GAOG;AACH,wBAAgB,oBAAoB,CAClC,OAAO,EAAE,MAAM,EACf,aAAa,EAAE,OAAO,KAAK,GAC1B,OAAO,KAAK,CAad;AAED;;;;;;;;;GASG;AACH,wBAAgB,8BAA8B,CAC5C,cAAc,EAAE,MAAM,EACtB,OAAO,EAAE,MAAM,EACf,aAAa,EAAE,OAAO,KAAK,EAC3B,cAAc,GAAE,MAAM,CAAC,MAAM,EAAE,MAAM,CAA2B,GAC/D,OAAO,KAAK,CAYd;AAED;;;;;;;;;;;;;;;;;;;GAmBG;AACH,wBAAgB,mCAAmC,CACjD,4BAA4B,EAAE,CAAC,cAAc,EAAE,MAAM,KAAK;IACxD,KAAK,EAAE,OAAO,KAAK,CAAC;IACpB,IAAI,EAAE,OAAO,IAAI,CAAC;IAClB,CAAC,GAAG,EAAE,MAAM,GAAG,OAAO,CAAC;CACxB,EACD,gBAAgB,EAAE,CAAC,cAAc,EAAE,MAAM,KAAK,MAAM,GAAG,SAAS,EAChE,cAAc,GAAE,MAAM,CAAC,MAAM,EAAE,MAAM,CAA2B,GAC/D,OAAO,4BAA4B,CAqBrC"}
\ No newline at end of file
diff --git a/dist/throttled-fetch.mjs b/dist/throttled-fetch.mjs
new file mode 100644
index 0000000000000000000000000000000000000000..d246879699e9c894e002f52fb60f306b4ed23055
--- /dev/null
+++ b/dist/throttled-fetch.mjs
@@ -0,0 +1,82 @@
+/**
+ * Configuration for network throttling by chain ID.
+ * Maps chain IDs (in hex format) to delay in milliseconds.
+ */
+export const NETWORK_THROTTLE_CONFIG = {
+    // '0x2019': 2000, // Klaytn - 2s delay
+    // '0x504': 1000, // Moonbeam - 1s delay
+    // '0x505': 1000, // Moonriver - 1s delay
+    // '0x4e454152': 1500, // Aurora - 1.5s delay
+    '0x1': 10000, // Ethereum Mainnet - 10s delay
+};
+/**
+ * Creates a throttled fetch function that adds artificial delays before making requests.
+ * Useful for testing slow network conditions.
+ *
+ * @param delayMs - The delay in milliseconds to add before each request
+ * @param originalFetch - The original fetch function to wrap
+ * @returns A throttled fetch function
+ */
+export function createThrottledFetch(delayMs, originalFetch) {
+    if (delayMs <= 0) {
+        return originalFetch;
+    }
+    return async (input, init) => {
+        // Add artificial delay before making the request
+        await new Promise((resolve) => setTimeout(resolve, delayMs));
+        return originalFetch(input, init);
+    };
+}
+/**
+ * Creates a fetch function that applies throttling based on the chain ID.
+ * Extracts chain ID from the RPC endpoint URL to determine the appropriate delay.
+ *
+ * @param rpcEndpointUrl - The RPC endpoint URL (may contain chain ID context)
+ * @param chainId - The chain ID in hex format (e.g., '0x2019')
+ * @param originalFetch - The original fetch function to wrap
+ * @param throttleConfig - Optional custom throttle configuration map
+ * @returns A throttled fetch function if configured for this chain, otherwise the original
+ */
+export function createThrottledFetchForChainId(rpcEndpointUrl, chainId, originalFetch, throttleConfig = NETWORK_THROTTLE_CONFIG) {
+    const delayMs = throttleConfig[chainId] || 0;
+    if (delayMs === 0) {
+        return originalFetch;
+    }
+    console.log(`[NetworkThrottle] Applying ${delayMs}ms delay to chain ${chainId} (${rpcEndpointUrl})`);
+    return createThrottledFetch(delayMs, originalFetch);
+}
+/**
+ * Creates a wrapped getRpcServiceOptions function that applies network throttling
+ * based on chain ID. This is meant to be used in NetworkController initialization.
+ *
+ * @param originalGetRpcServiceOptions - The original getRpcServiceOptions function
+ * @param getChainIdForUrl - Function to get the chain ID for a given RPC endpoint URL
+ * @param throttleConfig - Optional custom throttle configuration map
+ * @returns A wrapped getRpcServiceOptions function that applies throttling
+ *
+ * @example
+ * ```typescript
+ * const networkController = new NetworkController({
+ *   getRpcServiceOptions: createThrottledGetRpcServiceOptions(
+ *     (rpcEndpointUrl) => ({ fetch, btoa }),
+ *     (rpcEndpointUrl) => '0x1', // Get chainId from your config
+ *   ),
+ *   // ... other options
+ * });
+ * ```
+ */
+export function createThrottledGetRpcServiceOptions(originalGetRpcServiceOptions, getChainIdForUrl, throttleConfig = NETWORK_THROTTLE_CONFIG) {
+    return (rpcEndpointUrl) => {
+        const options = originalGetRpcServiceOptions(rpcEndpointUrl);
+        const chainId = getChainIdForUrl(rpcEndpointUrl);
+        if (!chainId) {
+            return options;
+        }
+        const throttledFetch = createThrottledFetchForChainId(rpcEndpointUrl, chainId, options.fetch, throttleConfig);
+        return {
+            ...options,
+            fetch: throttledFetch,
+        };
+    };
+}
+//# sourceMappingURL=throttled-fetch.mjs.map
\ No newline at end of file
diff --git a/dist/throttled-fetch.mjs.map b/dist/throttled-fetch.mjs.map
new file mode 100644
index 0000000000000000000000000000000000000000..4403cf96e8e7a5b7e76322fd239b5d9327c34599
--- /dev/null
+++ b/dist/throttled-fetch.mjs.map
@@ -0,0 +1 @@
+{"version":3,"file":"throttled-fetch.mjs","sourceRoot":"","sources":["../src/throttled-fetch.ts"],"names":[],"mappings":"AAAA;;;GAGG;AACH,MAAM,CAAC,MAAM,uBAAuB,GAA2B;IAC7D,uCAAuC;IACvC,wCAAwC;IACxC,yCAAyC;IACzC,6CAA6C;IAC7C,KAAK,EAAE,KAAK,EAAE,+BAA+B;CAC9C,CAAC;AAEF;;;;;;;GAOG;AACH,MAAM,UAAU,oBAAoB,CAClC,OAAe,EACf,aAA2B;IAE3B,IAAI,OAAO,IAAI,CAAC,EAAE,CAAC;QACjB,OAAO,aAAa,CAAC;IACvB,CAAC;IAED,OAAO,KAAK,EACV,KAAwB,EACxB,IAAkB,EACC,EAAE;QACrB,iDAAiD;QACjD,MAAM,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,UAAU,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC,CAAC;QAC7D,OAAO,aAAa,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;IACpC,CAAC,CAAC;AACJ,CAAC;AAED;;;;;;;;;GASG;AACH,MAAM,UAAU,8BAA8B,CAC5C,cAAsB,EACtB,OAAe,EACf,aAA2B,EAC3B,iBAAyC,uBAAuB;IAEhE,MAAM,OAAO,GAAG,cAAc,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;IAE7C,IAAI,OAAO,KAAK,CAAC,EAAE,CAAC;QAClB,OAAO,aAAa,CAAC;IACvB,CAAC;IAED,OAAO,CAAC,GAAG,CACT,8BAA8B,OAAO,qBAAqB,OAAO,KAAK,cAAc,GAAG,CACxF,CAAC;IAEF,OAAO,oBAAoB,CAAC,OAAO,EAAE,aAAa,CAAC,CAAC;AACtD,CAAC;AAED;;;;;;;;;;;;;;;;;;;GAmBG;AACH,MAAM,UAAU,mCAAmC,CACjD,4BAIC,EACD,gBAAgE,EAChE,iBAAyC,uBAAuB;IAEhE,OAAO,CAAC,cAAsB,EAAE,EAAE;QAChC,MAAM,OAAO,GAAG,4BAA4B,CAAC,cAAc,CAAC,CAAC;QAC7D,MAAM,OAAO,GAAG,gBAAgB,CAAC,cAAc,CAAC,CAAC;QAEjD,IAAI,CAAC,OAAO,EAAE,CAAC;YACb,OAAO,OAAO,CAAC;QACjB,CAAC;QAED,MAAM,cAAc,GAAG,8BAA8B,CACnD,cAAc,EACd,OAAO,EACP,OAAO,CAAC,KAAK,EACb,cAAc,CACf,CAAC;QAEF,OAAO;YACL,GAAG,OAAO;YACV,KAAK,EAAE,cAAc;SACtB,CAAC;IACJ,CAAC,CAAC;AACJ,CAAC","sourcesContent":["/**\n * Configuration for network throttling by chain ID.\n * Maps chain IDs (in hex format) to delay in milliseconds.\n */\nexport const NETWORK_THROTTLE_CONFIG: Record<string, number> = {\n  // '0x2019': 2000, // Klaytn - 2s delay\n  // '0x504': 1000, // Moonbeam - 1s delay\n  // '0x505': 1000, // Moonriver - 1s delay\n  // '0x4e454152': 1500, // Aurora - 1.5s delay\n  '0x1': 10000, // Ethereum Mainnet - 10s delay\n};\n\n/**\n * Creates a throttled fetch function that adds artificial delays before making requests.\n * Useful for testing slow network conditions.\n *\n * @param delayMs - The delay in milliseconds to add before each request\n * @param originalFetch - The original fetch function to wrap\n * @returns A throttled fetch function\n */\nexport function createThrottledFetch(\n  delayMs: number,\n  originalFetch: typeof fetch,\n): typeof fetch {\n  if (delayMs <= 0) {\n    return originalFetch;\n  }\n\n  return async (\n    input: RequestInfo | URL,\n    init?: RequestInit,\n  ): Promise<Response> => {\n    // Add artificial delay before making the request\n    await new Promise((resolve) => setTimeout(resolve, delayMs));\n    return originalFetch(input, init);\n  };\n}\n\n/**\n * Creates a fetch function that applies throttling based on the chain ID.\n * Extracts chain ID from the RPC endpoint URL to determine the appropriate delay.\n *\n * @param rpcEndpointUrl - The RPC endpoint URL (may contain chain ID context)\n * @param chainId - The chain ID in hex format (e.g., '0x2019')\n * @param originalFetch - The original fetch function to wrap\n * @param throttleConfig - Optional custom throttle configuration map\n * @returns A throttled fetch function if configured for this chain, otherwise the original\n */\nexport function createThrottledFetchForChainId(\n  rpcEndpointUrl: string,\n  chainId: string,\n  originalFetch: typeof fetch,\n  throttleConfig: Record<string, number> = NETWORK_THROTTLE_CONFIG,\n): typeof fetch {\n  const delayMs = throttleConfig[chainId] || 0;\n\n  if (delayMs === 0) {\n    return originalFetch;\n  }\n\n  console.log(\n    `[NetworkThrottle] Applying ${delayMs}ms delay to chain ${chainId} (${rpcEndpointUrl})`,\n  );\n\n  return createThrottledFetch(delayMs, originalFetch);\n}\n\n/**\n * Creates a wrapped getRpcServiceOptions function that applies network throttling\n * based on chain ID. This is meant to be used in NetworkController initialization.\n *\n * @param originalGetRpcServiceOptions - The original getRpcServiceOptions function\n * @param getChainIdForUrl - Function to get the chain ID for a given RPC endpoint URL\n * @param throttleConfig - Optional custom throttle configuration map\n * @returns A wrapped getRpcServiceOptions function that applies throttling\n *\n * @example\n * ```typescript\n * const networkController = new NetworkController({\n *   getRpcServiceOptions: createThrottledGetRpcServiceOptions(\n *     (rpcEndpointUrl) => ({ fetch, btoa }),\n *     (rpcEndpointUrl) => '0x1', // Get chainId from your config\n *   ),\n *   // ... other options\n * });\n * ```\n */\nexport function createThrottledGetRpcServiceOptions(\n  originalGetRpcServiceOptions: (rpcEndpointUrl: string) => {\n    fetch: typeof fetch;\n    btoa: typeof btoa;\n    [key: string]: unknown;\n  },\n  getChainIdForUrl: (rpcEndpointUrl: string) => string | undefined,\n  throttleConfig: Record<string, number> = NETWORK_THROTTLE_CONFIG,\n): typeof originalGetRpcServiceOptions {\n  return (rpcEndpointUrl: string) => {\n    const options = originalGetRpcServiceOptions(rpcEndpointUrl);\n    const chainId = getChainIdForUrl(rpcEndpointUrl);\n\n    if (!chainId) {\n      return options;\n    }\n\n    const throttledFetch = createThrottledFetchForChainId(\n      rpcEndpointUrl,\n      chainId,\n      options.fetch,\n      throttleConfig,\n    );\n\n    return {\n      ...options,\n      fetch: throttledFetch,\n    };\n  };\n}\n"]}
\ No newline at end of file
