diff --git a/dist/TransactionPayController.cjs b/dist/TransactionPayController.cjs
index 839ae4b..24a5ad0 100644
--- a/dist/TransactionPayController.cjs
+++ b/dist/TransactionPayController.cjs
@@ -53,9 +53,15 @@ class TransactionPayController extends base_controller_1.BaseController {
             updateTransactionData: __classPrivateFieldGet(this, _TransactionPayController_instances, "m", _TransactionPayController_updateTransactionData).bind(this),
         });
     }
-    setIsMaxAmount(transactionId, isMaxAmount) {
+    setTransactionConfig(transactionId, callback) {
         __classPrivateFieldGet(this, _TransactionPayController_instances, "m", _TransactionPayController_updateTransactionData).call(this, transactionId, (transactionData) => {
-            transactionData.isMaxAmount = isMaxAmount;
+            const config = {
+                isMaxAmount: transactionData.isMaxAmount,
+                isPostQuote: transactionData.isPostQuote,
+            };
+            callback(config);
+            transactionData.isMaxAmount = config.isMaxAmount;
+            transactionData.isPostQuote = config.isPostQuote;
         });
     }
     updatePaymentToken(request) {
@@ -78,6 +84,7 @@ _TransactionPayController_getDelegationTransaction = new WeakMap(), _Transaction
         const originalPaymentToken = current?.paymentToken;
         const originalTokens = current?.tokens;
         const originalIsMaxAmount = current?.isMaxAmount;
+        const originalIsPostQuote = current?.isPostQuote;
         if (!current) {
             transactionData[transactionId] = {
                 isLoading: false,
@@ -89,7 +96,11 @@ _TransactionPayController_getDelegationTransaction = new WeakMap(), _Transaction
         const isPaymentTokenUpdated = current.paymentToken !== originalPaymentToken;
         const isTokensUpdated = current.tokens !== originalTokens;
         const isIsMaxUpdated = current.isMaxAmount !== originalIsMaxAmount;
-        if (isPaymentTokenUpdated || isIsMaxUpdated || isTokensUpdated) {
+        const isPostQuoteUpdated = current.isPostQuote !== originalIsPostQuote;
+        if (isPaymentTokenUpdated ||
+            isIsMaxUpdated ||
+            isTokensUpdated ||
+            isPostQuoteUpdated) {
             (0, source_amounts_1.updateSourceAmounts)(transactionId, current, this.messenger);
             shouldUpdateQuotes = true;
         }
@@ -106,7 +117,7 @@ _TransactionPayController_getDelegationTransaction = new WeakMap(), _Transaction
     this.messenger.registerActionHandler('TransactionPayController:getDelegationTransaction', __classPrivateFieldGet(this, _TransactionPayController_getDelegationTransaction, "f").bind(this));
     this.messenger.registerActionHandler('TransactionPayController:getStrategy', __classPrivateFieldGet(this, _TransactionPayController_getStrategy, "f") ??
         (() => constants_1.TransactionPayStrategy.Relay));
-    this.messenger.registerActionHandler('TransactionPayController:setIsMaxAmount', this.setIsMaxAmount.bind(this));
+    this.messenger.registerActionHandler('TransactionPayController:setTransactionConfig', this.setTransactionConfig.bind(this));
     this.messenger.registerActionHandler('TransactionPayController:updatePaymentToken', this.updatePaymentToken.bind(this));
 };
 //# sourceMappingURL=TransactionPayController.cjs.map
\ No newline at end of file
diff --git a/dist/TransactionPayController.d.cts b/dist/TransactionPayController.d.cts
index 0035692..682d168 100644
--- a/dist/TransactionPayController.d.cts
+++ b/dist/TransactionPayController.d.cts
@@ -1,10 +1,10 @@
 import { BaseController } from "@metamask/base-controller";
 import { CONTROLLER_NAME } from "./constants.cjs";
-import type { TransactionPayControllerMessenger, TransactionPayControllerOptions, TransactionPayControllerState, UpdatePaymentTokenRequest } from "./types.cjs";
+import type { TransactionConfigCallback, TransactionPayControllerMessenger, TransactionPayControllerOptions, TransactionPayControllerState, UpdatePaymentTokenRequest } from "./types.cjs";
 export declare class TransactionPayController extends BaseController<typeof CONTROLLER_NAME, TransactionPayControllerState, TransactionPayControllerMessenger> {
     #private;
     constructor({ getDelegationTransaction, getStrategy, messenger, state, }: TransactionPayControllerOptions);
-    setIsMaxAmount(transactionId: string, isMaxAmount: boolean): void;
+    setTransactionConfig(transactionId: string, callback: TransactionConfigCallback): void;
     updatePaymentToken(request: UpdatePaymentTokenRequest): void;
 }
 //# sourceMappingURL=TransactionPayController.d.cts.map
\ No newline at end of file
diff --git a/dist/TransactionPayController.d.mts b/dist/TransactionPayController.d.mts
index 0774ce7..6890d56 100644
--- a/dist/TransactionPayController.d.mts
+++ b/dist/TransactionPayController.d.mts
@@ -1,10 +1,10 @@
 import { BaseController } from "@metamask/base-controller";
 import { CONTROLLER_NAME } from "./constants.mjs";
-import type { TransactionPayControllerMessenger, TransactionPayControllerOptions, TransactionPayControllerState, UpdatePaymentTokenRequest } from "./types.mjs";
+import type { TransactionConfigCallback, TransactionPayControllerMessenger, TransactionPayControllerOptions, TransactionPayControllerState, UpdatePaymentTokenRequest } from "./types.mjs";
 export declare class TransactionPayController extends BaseController<typeof CONTROLLER_NAME, TransactionPayControllerState, TransactionPayControllerMessenger> {
     #private;
     constructor({ getDelegationTransaction, getStrategy, messenger, state, }: TransactionPayControllerOptions);
-    setIsMaxAmount(transactionId: string, isMaxAmount: boolean): void;
+    setTransactionConfig(transactionId: string, callback: TransactionConfigCallback): void;
     updatePaymentToken(request: UpdatePaymentTokenRequest): void;
 }
 //# sourceMappingURL=TransactionPayController.d.mts.map
\ No newline at end of file
diff --git a/dist/TransactionPayController.mjs b/dist/TransactionPayController.mjs
index 991aa73..f45ea26 100644
--- a/dist/TransactionPayController.mjs
+++ b/dist/TransactionPayController.mjs
@@ -51,9 +51,15 @@ export class TransactionPayController extends BaseController {
             updateTransactionData: __classPrivateFieldGet(this, _TransactionPayController_instances, "m", _TransactionPayController_updateTransactionData).bind(this),
         });
     }
-    setIsMaxAmount(transactionId, isMaxAmount) {
+    setTransactionConfig(transactionId, callback) {
         __classPrivateFieldGet(this, _TransactionPayController_instances, "m", _TransactionPayController_updateTransactionData).call(this, transactionId, (transactionData) => {
-            transactionData.isMaxAmount = isMaxAmount;
+            const config = {
+                isMaxAmount: transactionData.isMaxAmount,
+                isPostQuote: transactionData.isPostQuote,
+            };
+            callback(config);
+            transactionData.isMaxAmount = config.isMaxAmount;
+            transactionData.isPostQuote = config.isPostQuote;
         });
     }
     updatePaymentToken(request) {
@@ -75,6 +81,7 @@ _TransactionPayController_getDelegationTransaction = new WeakMap(), _Transaction
         const originalPaymentToken = current?.paymentToken;
         const originalTokens = current?.tokens;
         const originalIsMaxAmount = current?.isMaxAmount;
+        const originalIsPostQuote = current?.isPostQuote;
         if (!current) {
             transactionData[transactionId] = {
                 isLoading: false,
@@ -86,7 +93,11 @@ _TransactionPayController_getDelegationTransaction = new WeakMap(), _Transaction
         const isPaymentTokenUpdated = current.paymentToken !== originalPaymentToken;
         const isTokensUpdated = current.tokens !== originalTokens;
         const isIsMaxUpdated = current.isMaxAmount !== originalIsMaxAmount;
-        if (isPaymentTokenUpdated || isIsMaxUpdated || isTokensUpdated) {
+        const isPostQuoteUpdated = current.isPostQuote !== originalIsPostQuote;
+        if (isPaymentTokenUpdated ||
+            isIsMaxUpdated ||
+            isTokensUpdated ||
+            isPostQuoteUpdated) {
             updateSourceAmounts(transactionId, current, this.messenger);
             shouldUpdateQuotes = true;
         }
@@ -103,7 +114,7 @@ _TransactionPayController_getDelegationTransaction = new WeakMap(), _Transaction
     this.messenger.registerActionHandler('TransactionPayController:getDelegationTransaction', __classPrivateFieldGet(this, _TransactionPayController_getDelegationTransaction, "f").bind(this));
     this.messenger.registerActionHandler('TransactionPayController:getStrategy', __classPrivateFieldGet(this, _TransactionPayController_getStrategy, "f") ??
         (() => TransactionPayStrategy.Relay));
-    this.messenger.registerActionHandler('TransactionPayController:setIsMaxAmount', this.setIsMaxAmount.bind(this));
+    this.messenger.registerActionHandler('TransactionPayController:setTransactionConfig', this.setTransactionConfig.bind(this));
     this.messenger.registerActionHandler('TransactionPayController:updatePaymentToken', this.updatePaymentToken.bind(this));
 };
 //# sourceMappingURL=TransactionPayController.mjs.map
\ No newline at end of file
diff --git a/dist/actions/update-payment-token.cjs b/dist/actions/update-payment-token.cjs
index 080bb1e..0f59bce 100644
--- a/dist/actions/update-payment-token.cjs
+++ b/dist/actions/update-payment-token.cjs
@@ -10,7 +10,7 @@ const log = (0, utils_1.createModuleLogger)(logger_1.projectLogger, 'update-paym
 /**
  * Update the payment token for a specific transaction.
  *
- * @param request  - Request parameters.
+ * @param request - Request parameters.
  * @param options - Options bag.
  */
 function updatePaymentToken(request, options) {
diff --git a/dist/actions/update-payment-token.d.cts b/dist/actions/update-payment-token.d.cts
index 8546442..aa7922b 100644
--- a/dist/actions/update-payment-token.d.cts
+++ b/dist/actions/update-payment-token.d.cts
@@ -7,7 +7,7 @@ export type UpdatePaymentTokenOptions = {
 /**
  * Update the payment token for a specific transaction.
  *
- * @param request  - Request parameters.
+ * @param request - Request parameters.
  * @param options - Options bag.
  */
 export declare function updatePaymentToken(request: UpdatePaymentTokenRequest, options: UpdatePaymentTokenOptions): void;
diff --git a/dist/actions/update-payment-token.d.mts b/dist/actions/update-payment-token.d.mts
index d6d9c2c..2f7ba39 100644
--- a/dist/actions/update-payment-token.d.mts
+++ b/dist/actions/update-payment-token.d.mts
@@ -7,7 +7,7 @@ export type UpdatePaymentTokenOptions = {
 /**
  * Update the payment token for a specific transaction.
  *
- * @param request  - Request parameters.
+ * @param request - Request parameters.
  * @param options - Options bag.
  */
 export declare function updatePaymentToken(request: UpdatePaymentTokenRequest, options: UpdatePaymentTokenOptions): void;
diff --git a/dist/actions/update-payment-token.mjs b/dist/actions/update-payment-token.mjs
index fad321a..d850cd8 100644
--- a/dist/actions/update-payment-token.mjs
+++ b/dist/actions/update-payment-token.mjs
@@ -7,7 +7,7 @@ const log = createModuleLogger(projectLogger, 'update-payment-token');
 /**
  * Update the payment token for a specific transaction.
  *
- * @param request  - Request parameters.
+ * @param request - Request parameters.
  * @param options - Options bag.
  */
 export function updatePaymentToken(request, options) {
diff --git a/dist/index.d.cts b/dist/index.d.cts
index db64fe1..ac8e01e 100644
--- a/dist/index.d.cts
+++ b/dist/index.d.cts
@@ -1,4 +1,4 @@
-export type { TransactionPayControllerActions, TransactionPayControllerEvents, TransactionPayControllerGetDelegationTransactionAction, TransactionPayControllerGetStateAction, TransactionPayControllerGetStrategyAction, TransactionPayControllerMessenger, TransactionPayControllerOptions, TransactionPayControllerSetIsMaxAmountAction, TransactionPayControllerState, TransactionPayControllerStateChangeEvent, TransactionPayControllerUpdatePaymentTokenAction, TransactionPaymentToken, TransactionPayQuote, TransactionPayRequiredToken, TransactionPaySourceAmount, TransactionPayTotals, UpdatePaymentTokenRequest, } from "./types.cjs";
+export type { TransactionConfig, TransactionConfigCallback, TransactionPayControllerActions, TransactionPayControllerEvents, TransactionPayControllerGetDelegationTransactionAction, TransactionPayControllerGetStateAction, TransactionPayControllerGetStrategyAction, TransactionPayControllerMessenger, TransactionPayControllerOptions, TransactionPayControllerSetTransactionConfigAction, TransactionPayControllerState, TransactionPayControllerStateChangeEvent, TransactionPayControllerUpdatePaymentTokenAction, TransactionPaymentToken, TransactionPayQuote, TransactionPayRequiredToken, TransactionPaySourceAmount, TransactionPayTotals, UpdatePaymentTokenRequest, } from "./types.cjs";
 export { TransactionPayStrategy } from "./constants.cjs";
 export { TransactionPayController } from "./TransactionPayController.cjs";
 export { TransactionPayPublishHook } from "./helpers/TransactionPayPublishHook.cjs";
diff --git a/dist/index.d.mts b/dist/index.d.mts
index 8cb5dc7..dea3c41 100644
--- a/dist/index.d.mts
+++ b/dist/index.d.mts
@@ -1,4 +1,4 @@
-export type { TransactionPayControllerActions, TransactionPayControllerEvents, TransactionPayControllerGetDelegationTransactionAction, TransactionPayControllerGetStateAction, TransactionPayControllerGetStrategyAction, TransactionPayControllerMessenger, TransactionPayControllerOptions, TransactionPayControllerSetIsMaxAmountAction, TransactionPayControllerState, TransactionPayControllerStateChangeEvent, TransactionPayControllerUpdatePaymentTokenAction, TransactionPaymentToken, TransactionPayQuote, TransactionPayRequiredToken, TransactionPaySourceAmount, TransactionPayTotals, UpdatePaymentTokenRequest, } from "./types.mjs";
+export type { TransactionConfig, TransactionConfigCallback, TransactionPayControllerActions, TransactionPayControllerEvents, TransactionPayControllerGetDelegationTransactionAction, TransactionPayControllerGetStateAction, TransactionPayControllerGetStrategyAction, TransactionPayControllerMessenger, TransactionPayControllerOptions, TransactionPayControllerSetTransactionConfigAction, TransactionPayControllerState, TransactionPayControllerStateChangeEvent, TransactionPayControllerUpdatePaymentTokenAction, TransactionPaymentToken, TransactionPayQuote, TransactionPayRequiredToken, TransactionPaySourceAmount, TransactionPayTotals, UpdatePaymentTokenRequest, } from "./types.mjs";
 export { TransactionPayStrategy } from "./constants.mjs";
 export { TransactionPayController } from "./TransactionPayController.mjs";
 export { TransactionPayPublishHook } from "./helpers/TransactionPayPublishHook.mjs";
diff --git a/dist/strategy/relay/relay-quotes.cjs b/dist/strategy/relay/relay-quotes.cjs
index 3414da5..e4129f7 100644
--- a/dist/strategy/relay/relay-quotes.cjs
+++ b/dist/strategy/relay/relay-quotes.cjs
@@ -25,8 +25,10 @@ async function getRelayQuotes(request) {
     log('Fetching quotes', requests);
     try {
         const normalizedRequests = requests
-            // Ignore gas fee token requests
-            .filter((singleRequest) => singleRequest.targetAmountMinimum !== '0')
+            // Ignore gas fee token requests (which have both target=0 and source=0)
+            // but keep post-quote requests (identified by isPostQuote flag)
+            .filter((singleRequest) => singleRequest.targetAmountMinimum !== '0' ||
+            singleRequest.isPostQuote)
             .map((singleRequest) => normalizeRequest(singleRequest));
         log('Normalized requests', normalizedRequests);
         return await Promise.all(normalizedRequests.map((singleRequest) => getSingleQuote(singleRequest, request)));
@@ -50,18 +52,26 @@ async function getSingleQuote(request, fullRequest) {
     const slippageDecimal = (0, feature_flags_1.getSlippage)(messenger, sourceChainId, sourceTokenAddress);
     const slippageTolerance = new bignumber_js_1.BigNumber(slippageDecimal * 100 * 100).toFixed(0);
     try {
+        // For post-quote or max amount flows, use EXACT_INPUT - user specifies how much to send,
+        // and we show them how much they'll receive after fees.
+        // For regular flows with a target amount, use EXPECTED_OUTPUT.
+        const useExactInput = isMaxAmount === true || request.isPostQuote === true;
         const body = {
-            amount: isMaxAmount ? sourceTokenAmount : targetAmountMinimum,
+            amount: useExactInput ? sourceTokenAmount : targetAmountMinimum,
             destinationChainId: Number(targetChainId),
             destinationCurrency: targetTokenAddress,
             originChainId: Number(sourceChainId),
             originCurrency: sourceTokenAddress,
             recipient: from,
             slippageTolerance,
-            tradeType: isMaxAmount ? 'EXACT_INPUT' : 'EXPECTED_OUTPUT',
+            tradeType: useExactInput ? 'EXACT_INPUT' : 'EXPECTED_OUTPUT',
             user: from,
         };
-        await processTransactions(transaction, request, body, messenger);
+        // Skip transaction processing for post-quote flows - the original transaction
+        // will be included in the batch separately, not as part of the quote
+        if (!request.isPostQuote) {
+            await processTransactions(transaction, request, body, messenger);
+        }
         const url = (0, feature_flags_1.getFeatureFlags)(messenger).relayQuoteUrl;
         log('Request body', { body, url });
         const response = await (0, controller_utils_1.successfulFetch)(url, {
@@ -72,7 +82,7 @@ async function getSingleQuote(request, fullRequest) {
         const quote = (await response.json());
         quote.request = body;
         log('Fetched relay quote', quote);
-        return normalizeQuote(quote, request, fullRequest);
+        return await normalizeQuote(quote, request, fullRequest);
     }
     catch (error) {
         log('Error fetching relay quote', error);
diff --git a/dist/strategy/relay/relay-quotes.mjs b/dist/strategy/relay/relay-quotes.mjs
index e6275ec..4f32918 100644
--- a/dist/strategy/relay/relay-quotes.mjs
+++ b/dist/strategy/relay/relay-quotes.mjs
@@ -22,8 +22,10 @@ export async function getRelayQuotes(request) {
     log('Fetching quotes', requests);
     try {
         const normalizedRequests = requests
-            // Ignore gas fee token requests
-            .filter((singleRequest) => singleRequest.targetAmountMinimum !== '0')
+            // Ignore gas fee token requests (which have both target=0 and source=0)
+            // but keep post-quote requests (identified by isPostQuote flag)
+            .filter((singleRequest) => singleRequest.targetAmountMinimum !== '0' ||
+            singleRequest.isPostQuote)
             .map((singleRequest) => normalizeRequest(singleRequest));
         log('Normalized requests', normalizedRequests);
         return await Promise.all(normalizedRequests.map((singleRequest) => getSingleQuote(singleRequest, request)));
@@ -46,18 +48,26 @@ async function getSingleQuote(request, fullRequest) {
     const slippageDecimal = getSlippage(messenger, sourceChainId, sourceTokenAddress);
     const slippageTolerance = new BigNumber(slippageDecimal * 100 * 100).toFixed(0);
     try {
+        // For post-quote or max amount flows, use EXACT_INPUT - user specifies how much to send,
+        // and we show them how much they'll receive after fees.
+        // For regular flows with a target amount, use EXPECTED_OUTPUT.
+        const useExactInput = isMaxAmount === true || request.isPostQuote === true;
         const body = {
-            amount: isMaxAmount ? sourceTokenAmount : targetAmountMinimum,
+            amount: useExactInput ? sourceTokenAmount : targetAmountMinimum,
             destinationChainId: Number(targetChainId),
             destinationCurrency: targetTokenAddress,
             originChainId: Number(sourceChainId),
             originCurrency: sourceTokenAddress,
             recipient: from,
             slippageTolerance,
-            tradeType: isMaxAmount ? 'EXACT_INPUT' : 'EXPECTED_OUTPUT',
+            tradeType: useExactInput ? 'EXACT_INPUT' : 'EXPECTED_OUTPUT',
             user: from,
         };
-        await processTransactions(transaction, request, body, messenger);
+        // Skip transaction processing for post-quote flows - the original transaction
+        // will be included in the batch separately, not as part of the quote
+        if (!request.isPostQuote) {
+            await processTransactions(transaction, request, body, messenger);
+        }
         const url = getFeatureFlags(messenger).relayQuoteUrl;
         log('Request body', { body, url });
         const response = await successfulFetch(url, {
@@ -68,7 +78,7 @@ async function getSingleQuote(request, fullRequest) {
         const quote = (await response.json());
         quote.request = body;
         log('Fetched relay quote', quote);
-        return normalizeQuote(quote, request, fullRequest);
+        return await normalizeQuote(quote, request, fullRequest);
     }
     catch (error) {
         log('Error fetching relay quote', error);
diff --git a/dist/strategy/relay/relay-submit.cjs b/dist/strategy/relay/relay-submit.cjs
index d21e3e5..b0e3fb8 100644
--- a/dist/strategy/relay/relay-submit.cjs
+++ b/dist/strategy/relay/relay-submit.cjs
@@ -10,6 +10,63 @@ const feature_flags_1 = require("../../utils/feature-flags.cjs");
 const transaction_1 = require("../../utils/transaction.cjs");
 const FALLBACK_HASH = '0x0';
 const log = (0, utils_1.createModuleLogger)(logger_1.projectLogger, 'relay-strategy');
+/**
+ * Extract and validate relay params from a quote.
+ *
+ * @param quote - Relay quote.
+ * @param messenger - Controller messenger.
+ * @returns Submit context with normalized params and metadata.
+ */
+function getSubmitContext(quote, messenger) {
+    const { steps } = quote.original;
+    const params = steps.flatMap((step) => step.items).map((item) => item.data);
+    const invalidKind = steps.find((step) => step.kind !== 'transaction')?.kind;
+    if (invalidKind) {
+        throw new Error(`Unsupported step kind: ${invalidKind}`);
+    }
+    const normalizedParams = params.map((singleParams) => normalizeParams(singleParams, messenger));
+    const { from, sourceChainId, sourceTokenAddress } = quote.request;
+    const { gasLimits } = quote.original.metamask;
+    const networkClientId = messenger.call('NetworkController:findNetworkClientIdByChainId', sourceChainId);
+    const gasFeeToken = quote.fees.isSourceGasFeeToken
+        ? sourceTokenAddress
+        : undefined;
+    return {
+        from,
+        gasFeeToken,
+        gasLimits,
+        networkClientId,
+        normalizedParams,
+        sourceChainId,
+        sourceTokenAddress,
+    };
+}
+/**
+ * Setup transaction ID collection with parent transaction updates.
+ *
+ * @param options - Options object.
+ * @param options.sourceChainId - Source chain ID.
+ * @param options.from - From address.
+ * @param options.messenger - Controller messenger.
+ * @param options.parentTransactionId - Parent transaction ID to update.
+ * @param options.note - Note for the transaction update.
+ * @returns Object with transactionIds array and end function.
+ */
+function setupTransactionCollection({ sourceChainId, from, messenger, parentTransactionId, note, }) {
+    const transactionIds = [];
+    const { end } = (0, transaction_1.collectTransactionIds)(sourceChainId, from, messenger, (transactionId) => {
+        transactionIds.push(transactionId);
+        (0, transaction_1.updateTransaction)({
+            transactionId: parentTransactionId,
+            messenger,
+            note,
+        }, (tx) => {
+            tx.requiredTransactionIds ?? (tx.requiredTransactionIds = []);
+            tx.requiredTransactionIds.push(transactionId);
+        });
+    });
+    return { transactionIds, end };
+}
 /**
  * Submits Relay quotes.
  *
@@ -36,6 +93,7 @@ exports.submitRelayQuotes = submitRelayQuotes;
  */
 async function executeSingleQuote(quote, messenger, transaction) {
     log('Executing single quote', quote);
+    const { isPostQuote } = quote.request;
     (0, transaction_1.updateTransaction)({
         transactionId: transaction.id,
         messenger,
@@ -43,7 +101,7 @@ async function executeSingleQuote(quote, messenger, transaction) {
     }, (tx) => {
         tx.txParams.nonce = undefined;
     });
-    await submitTransactions(quote, transaction.id, messenger);
+    await submitTransactions(quote, transaction, messenger, isPostQuote);
     const targetHash = await waitForRelayCompletion(quote.original);
     log('Relay request completed', targetHash);
     (0, transaction_1.updateTransaction)({
@@ -108,42 +166,28 @@ function normalizeParams(params, messenger) {
  * Submit transactions for a relay quote.
  *
  * @param quote - Relay quote.
- * @param parentTransactionId - ID of the parent transaction.
+ * @param transaction - Original transaction meta.
  * @param messenger - Controller messenger.
+ * @param isPostQuote - Whether this is a post-quote flow.
  * @returns Hash of the last submitted transaction.
  */
-async function submitTransactions(quote, parentTransactionId, messenger) {
-    const { steps } = quote.original;
-    const params = steps.flatMap((step) => step.items).map((item) => item.data);
-    const invalidKind = steps.find((step) => step.kind !== 'transaction')?.kind;
-    if (invalidKind) {
-        throw new Error(`Unsupported step kind: ${invalidKind}`);
-    }
-    const normalizedParams = params.map((singleParams) => normalizeParams(singleParams, messenger));
-    const transactionIds = [];
-    const { from, sourceChainId, sourceTokenAddress } = quote.request;
-    const networkClientId = messenger.call('NetworkController:findNetworkClientIdByChainId', sourceChainId);
+async function submitTransactions(quote, transaction, messenger, isPostQuote) {
+    const { from, gasFeeToken, gasLimits, networkClientId, normalizedParams, sourceChainId, } = getSubmitContext(quote, messenger);
     log('Adding transactions', {
         normalizedParams,
         sourceChainId,
         from,
         networkClientId,
+        isPostQuote,
     });
-    const { end } = (0, transaction_1.collectTransactionIds)(sourceChainId, from, messenger, (transactionId) => {
-        transactionIds.push(transactionId);
-        (0, transaction_1.updateTransaction)({
-            transactionId: parentTransactionId,
-            messenger,
-            note: 'Add required transaction ID from Relay submission',
-        }, (tx) => {
-            tx.requiredTransactionIds ?? (tx.requiredTransactionIds = []);
-            tx.requiredTransactionIds.push(transactionId);
-        });
+    const { transactionIds, end } = setupTransactionCollection({
+        sourceChainId,
+        from,
+        messenger,
+        parentTransactionId: transaction.id,
+        note: 'Add required transaction ID from Relay submission',
     });
     let result;
-    const gasFeeToken = quote.fees.isSourceGasFeeToken
-        ? sourceTokenAddress
-        : undefined;
     const isSameChain = quote.original.details.currencyIn.currency.chainId ===
         quote.original.details.currencyOut.currency.chainId;
     const authorizationList = isSameChain && quote.original.request.authorizationList?.length
@@ -152,8 +196,47 @@ async function submitTransactions(quote, parentTransactionId, messenger) {
             chainId: (0, controller_utils_1.toHex)(a.chainId),
         }))
         : undefined;
-    const { gasLimits } = quote.original.metamask;
-    if (params.length === 1) {
+    // For post-quote flows, always use batch with original transaction prepended
+    if (isPostQuote) {
+        const { txParams, type: originalType } = transaction;
+        const transactions = [];
+        // Add original transaction as first entry
+        if (txParams.to) {
+            transactions.push({
+                params: {
+                    data: txParams.data,
+                    to: txParams.to,
+                    value: txParams.value,
+                },
+                type: originalType,
+            });
+        }
+        // Add relay deposit transaction(s)
+        for (let i = 0; i < normalizedParams.length; i++) {
+            const relayParams = normalizedParams[i];
+            transactions.push({
+                params: {
+                    data: relayParams.data,
+                    gas: gasLimits[i] ? (0, controller_utils_1.toHex)(gasLimits[i]) : undefined,
+                    maxFeePerGas: relayParams.maxFeePerGas,
+                    maxPriorityFeePerGas: relayParams.maxPriorityFeePerGas,
+                    to: relayParams.to,
+                    value: relayParams.value,
+                },
+                type: transaction_controller_1.TransactionType.relayDeposit,
+            });
+        }
+        await messenger.call('TransactionController:addTransactionBatch', {
+            from,
+            gasFeeToken,
+            networkClientId,
+            origin: controller_utils_1.ORIGIN_METAMASK,
+            overwriteUpgrade: true,
+            requireApproval: false,
+            transactions,
+        });
+    }
+    else if (normalizedParams.length === 1) {
         const transactionParams = {
             ...normalizedParams[0],
             authorizationList,
@@ -197,6 +280,16 @@ async function submitTransactions(quote, parentTransactionId, messenger) {
         });
     }
     end();
+    // For post-quote flows, mark original transaction as handled by nested batch
+    if (isPostQuote) {
+        (0, transaction_1.updateTransaction)({
+            transactionId: transaction.id,
+            messenger,
+            note: 'Mark as dummy - handled by post-quote batch',
+        }, (tx) => {
+            tx.isIntentComplete = true;
+        });
+    }
     log('Added transactions', transactionIds);
     if (result) {
         const txHash = await result.result;
diff --git a/dist/strategy/relay/relay-submit.mjs b/dist/strategy/relay/relay-submit.mjs
index c2352f6..d62e7f8 100644
--- a/dist/strategy/relay/relay-submit.mjs
+++ b/dist/strategy/relay/relay-submit.mjs
@@ -7,6 +7,63 @@ import { getFeatureFlags } from "../../utils/feature-flags.mjs";
 import { collectTransactionIds, getTransaction, updateTransaction, waitForTransactionConfirmed } from "../../utils/transaction.mjs";
 const FALLBACK_HASH = '0x0';
 const log = createModuleLogger(projectLogger, 'relay-strategy');
+/**
+ * Extract and validate relay params from a quote.
+ *
+ * @param quote - Relay quote.
+ * @param messenger - Controller messenger.
+ * @returns Submit context with normalized params and metadata.
+ */
+function getSubmitContext(quote, messenger) {
+    const { steps } = quote.original;
+    const params = steps.flatMap((step) => step.items).map((item) => item.data);
+    const invalidKind = steps.find((step) => step.kind !== 'transaction')?.kind;
+    if (invalidKind) {
+        throw new Error(`Unsupported step kind: ${invalidKind}`);
+    }
+    const normalizedParams = params.map((singleParams) => normalizeParams(singleParams, messenger));
+    const { from, sourceChainId, sourceTokenAddress } = quote.request;
+    const { gasLimits } = quote.original.metamask;
+    const networkClientId = messenger.call('NetworkController:findNetworkClientIdByChainId', sourceChainId);
+    const gasFeeToken = quote.fees.isSourceGasFeeToken
+        ? sourceTokenAddress
+        : undefined;
+    return {
+        from,
+        gasFeeToken,
+        gasLimits,
+        networkClientId,
+        normalizedParams,
+        sourceChainId,
+        sourceTokenAddress,
+    };
+}
+/**
+ * Setup transaction ID collection with parent transaction updates.
+ *
+ * @param options - Options object.
+ * @param options.sourceChainId - Source chain ID.
+ * @param options.from - From address.
+ * @param options.messenger - Controller messenger.
+ * @param options.parentTransactionId - Parent transaction ID to update.
+ * @param options.note - Note for the transaction update.
+ * @returns Object with transactionIds array and end function.
+ */
+function setupTransactionCollection({ sourceChainId, from, messenger, parentTransactionId, note, }) {
+    const transactionIds = [];
+    const { end } = collectTransactionIds(sourceChainId, from, messenger, (transactionId) => {
+        transactionIds.push(transactionId);
+        updateTransaction({
+            transactionId: parentTransactionId,
+            messenger,
+            note,
+        }, (tx) => {
+            tx.requiredTransactionIds ?? (tx.requiredTransactionIds = []);
+            tx.requiredTransactionIds.push(transactionId);
+        });
+    });
+    return { transactionIds, end };
+}
 /**
  * Submits Relay quotes.
  *
@@ -32,6 +89,7 @@ export async function submitRelayQuotes(request) {
  */
 async function executeSingleQuote(quote, messenger, transaction) {
     log('Executing single quote', quote);
+    const { isPostQuote } = quote.request;
     updateTransaction({
         transactionId: transaction.id,
         messenger,
@@ -39,7 +97,7 @@ async function executeSingleQuote(quote, messenger, transaction) {
     }, (tx) => {
         tx.txParams.nonce = undefined;
     });
-    await submitTransactions(quote, transaction.id, messenger);
+    await submitTransactions(quote, transaction, messenger, isPostQuote);
     const targetHash = await waitForRelayCompletion(quote.original);
     log('Relay request completed', targetHash);
     updateTransaction({
@@ -104,42 +162,28 @@ function normalizeParams(params, messenger) {
  * Submit transactions for a relay quote.
  *
  * @param quote - Relay quote.
- * @param parentTransactionId - ID of the parent transaction.
+ * @param transaction - Original transaction meta.
  * @param messenger - Controller messenger.
+ * @param isPostQuote - Whether this is a post-quote flow.
  * @returns Hash of the last submitted transaction.
  */
-async function submitTransactions(quote, parentTransactionId, messenger) {
-    const { steps } = quote.original;
-    const params = steps.flatMap((step) => step.items).map((item) => item.data);
-    const invalidKind = steps.find((step) => step.kind !== 'transaction')?.kind;
-    if (invalidKind) {
-        throw new Error(`Unsupported step kind: ${invalidKind}`);
-    }
-    const normalizedParams = params.map((singleParams) => normalizeParams(singleParams, messenger));
-    const transactionIds = [];
-    const { from, sourceChainId, sourceTokenAddress } = quote.request;
-    const networkClientId = messenger.call('NetworkController:findNetworkClientIdByChainId', sourceChainId);
+async function submitTransactions(quote, transaction, messenger, isPostQuote) {
+    const { from, gasFeeToken, gasLimits, networkClientId, normalizedParams, sourceChainId, } = getSubmitContext(quote, messenger);
     log('Adding transactions', {
         normalizedParams,
         sourceChainId,
         from,
         networkClientId,
+        isPostQuote,
     });
-    const { end } = collectTransactionIds(sourceChainId, from, messenger, (transactionId) => {
-        transactionIds.push(transactionId);
-        updateTransaction({
-            transactionId: parentTransactionId,
-            messenger,
-            note: 'Add required transaction ID from Relay submission',
-        }, (tx) => {
-            tx.requiredTransactionIds ?? (tx.requiredTransactionIds = []);
-            tx.requiredTransactionIds.push(transactionId);
-        });
+    const { transactionIds, end } = setupTransactionCollection({
+        sourceChainId,
+        from,
+        messenger,
+        parentTransactionId: transaction.id,
+        note: 'Add required transaction ID from Relay submission',
     });
     let result;
-    const gasFeeToken = quote.fees.isSourceGasFeeToken
-        ? sourceTokenAddress
-        : undefined;
     const isSameChain = quote.original.details.currencyIn.currency.chainId ===
         quote.original.details.currencyOut.currency.chainId;
     const authorizationList = isSameChain && quote.original.request.authorizationList?.length
@@ -148,8 +192,47 @@ async function submitTransactions(quote, parentTransactionId, messenger) {
             chainId: toHex(a.chainId),
         }))
         : undefined;
-    const { gasLimits } = quote.original.metamask;
-    if (params.length === 1) {
+    // For post-quote flows, always use batch with original transaction prepended
+    if (isPostQuote) {
+        const { txParams, type: originalType } = transaction;
+        const transactions = [];
+        // Add original transaction as first entry
+        if (txParams.to) {
+            transactions.push({
+                params: {
+                    data: txParams.data,
+                    to: txParams.to,
+                    value: txParams.value,
+                },
+                type: originalType,
+            });
+        }
+        // Add relay deposit transaction(s)
+        for (let i = 0; i < normalizedParams.length; i++) {
+            const relayParams = normalizedParams[i];
+            transactions.push({
+                params: {
+                    data: relayParams.data,
+                    gas: gasLimits[i] ? toHex(gasLimits[i]) : undefined,
+                    maxFeePerGas: relayParams.maxFeePerGas,
+                    maxPriorityFeePerGas: relayParams.maxPriorityFeePerGas,
+                    to: relayParams.to,
+                    value: relayParams.value,
+                },
+                type: TransactionType.relayDeposit,
+            });
+        }
+        await messenger.call('TransactionController:addTransactionBatch', {
+            from,
+            gasFeeToken,
+            networkClientId,
+            origin: ORIGIN_METAMASK,
+            overwriteUpgrade: true,
+            requireApproval: false,
+            transactions,
+        });
+    }
+    else if (normalizedParams.length === 1) {
         const transactionParams = {
             ...normalizedParams[0],
             authorizationList,
@@ -193,6 +276,16 @@ async function submitTransactions(quote, parentTransactionId, messenger) {
         });
     }
     end();
+    // For post-quote flows, mark original transaction as handled by nested batch
+    if (isPostQuote) {
+        updateTransaction({
+            transactionId: transaction.id,
+            messenger,
+            note: 'Mark as dummy - handled by post-quote batch',
+        }, (tx) => {
+            tx.isIntentComplete = true;
+        });
+    }
     log('Added transactions', transactionIds);
     if (result) {
         const txHash = await result.result;
diff --git a/dist/types.d.cts b/dist/types.d.cts
index f5dc2ae..30ca7bb 100644
--- a/dist/types.d.cts
+++ b/dist/types.d.cts
@@ -1,5 +1,4 @@
 import type { CurrencyRateControllerActions, TokenBalancesControllerGetStateAction } from "@metamask/assets-controllers";
-import type { TokenListControllerActions } from "@metamask/assets-controllers";
 import type { TokenRatesControllerGetStateAction } from "@metamask/assets-controllers";
 import type { TokensControllerGetStateAction } from "@metamask/assets-controllers";
 import type { AccountTrackerControllerGetStateAction } from "@metamask/assets-controllers";
@@ -18,7 +17,7 @@ import type { BatchTransaction, TransactionControllerAddTransactionAction, Trans
 import type { Hex, Json } from "@metamask/utils";
 import type { Draft } from "immer";
 import type { CONTROLLER_NAME, TransactionPayStrategy } from "./constants.cjs";
-export type AllowedActions = AccountTrackerControllerGetStateAction | BridgeControllerActions | BridgeStatusControllerActions | CurrencyRateControllerActions | GasFeeControllerActions | NetworkControllerFindNetworkClientIdByChainIdAction | NetworkControllerGetNetworkClientByIdAction | RemoteFeatureFlagControllerGetStateAction | TokenBalancesControllerGetStateAction | TokenListControllerActions | TokenRatesControllerGetStateAction | TokensControllerGetStateAction | TransactionControllerAddTransactionAction | TransactionControllerAddTransactionBatchAction | TransactionControllerEstimateGasAction | TransactionControllerEstimateGasBatchAction | TransactionControllerGetGasFeeTokensAction | TransactionControllerGetStateAction | TransactionControllerUpdateTransactionAction;
+export type AllowedActions = AccountTrackerControllerGetStateAction | BridgeControllerActions | BridgeStatusControllerActions | CurrencyRateControllerActions | GasFeeControllerActions | NetworkControllerFindNetworkClientIdByChainIdAction | NetworkControllerGetNetworkClientByIdAction | RemoteFeatureFlagControllerGetStateAction | TokenBalancesControllerGetStateAction | TokenRatesControllerGetStateAction | TokensControllerGetStateAction | TransactionControllerAddTransactionAction | TransactionControllerAddTransactionBatchAction | TransactionControllerEstimateGasAction | TransactionControllerEstimateGasBatchAction | TransactionControllerGetGasFeeTokensAction | TransactionControllerGetStateAction | TransactionControllerUpdateTransactionAction;
 export type AllowedEvents = BridgeStatusControllerStateChangeEvent | TransactionControllerStateChangeEvent | TransactionControllerUnapprovedTransactionAddedEvent;
 export type TransactionPayControllerGetStateAction = ControllerGetStateAction<typeof CONTROLLER_NAME, TransactionPayControllerState>;
 export type TransactionPayControllerGetDelegationTransactionAction = {
@@ -35,13 +34,26 @@ export type TransactionPayControllerUpdatePaymentTokenAction = {
     type: `${typeof CONTROLLER_NAME}:updatePaymentToken`;
     handler: (request: UpdatePaymentTokenRequest) => void;
 };
-/** Action to set the max amount flag for a transaction. */
-export type TransactionPayControllerSetIsMaxAmountAction = {
-    type: `${typeof CONTROLLER_NAME}:setIsMaxAmount`;
-    handler: (transactionId: string, isMaxAmount: boolean) => void;
+/** Configurable properties of a transaction. */
+export type TransactionConfig = {
+    /** Whether the user has selected the maximum amount. */
+    isMaxAmount?: boolean;
+    /**
+     * Whether this is a post-quote transaction.
+     * When true, the paymentToken represents the destination token,
+     * and the quote source is derived from the transaction's output token.
+     */
+    isPostQuote?: boolean;
+};
+/** Callback to update transaction config. */
+export type TransactionConfigCallback = (config: TransactionConfig) => void;
+/** Action to update transaction configuration using a callback. */
+export type TransactionPayControllerSetTransactionConfigAction = {
+    type: `${typeof CONTROLLER_NAME}:setTransactionConfig`;
+    handler: (transactionId: string, callback: TransactionConfigCallback) => void;
 };
 export type TransactionPayControllerStateChangeEvent = ControllerStateChangeEvent<typeof CONTROLLER_NAME, TransactionPayControllerState>;
-export type TransactionPayControllerActions = TransactionPayControllerGetDelegationTransactionAction | TransactionPayControllerGetStateAction | TransactionPayControllerGetStrategyAction | TransactionPayControllerSetIsMaxAmountAction | TransactionPayControllerUpdatePaymentTokenAction;
+export type TransactionPayControllerActions = TransactionPayControllerGetDelegationTransactionAction | TransactionPayControllerGetStateAction | TransactionPayControllerGetStrategyAction | TransactionPayControllerSetTransactionConfigAction | TransactionPayControllerUpdatePaymentTokenAction;
 export type TransactionPayControllerEvents = TransactionPayControllerStateChangeEvent;
 export type TransactionPayControllerMessenger = Messenger<typeof CONTROLLER_NAME, TransactionPayControllerActions | AllowedActions, TransactionPayControllerEvents | AllowedEvents>;
 /** Options for the TransactionPayController. */
@@ -66,7 +78,19 @@ export type TransactionData = {
     isLoading: boolean;
     /** Whether the user has selected the maximum amount. */
     isMaxAmount?: boolean;
-    /** Source token selected for the transaction. */
+    /**
+     * Whether this is a post-quote transaction.
+     * When true, the paymentToken represents the destination token,
+     * and the quote source is derived from the transaction's output token.
+     * Used when funds need to be moved after a transaction completes
+     * (e.g., bridging output to a different token/chain).
+     */
+    isPostQuote?: boolean;
+    /**
+     * Token selected for the transaction.
+     * - For standard flows (isPostQuote=false): This is the SOURCE/payment token
+     * - For post-quote flows (isPostQuote=true): This is the DESTINATION token
+     */
     paymentToken?: TransactionPaymentToken;
     /** Quotes retrieved for the transaction. */
     quotes?: TransactionPayQuote<Json>[];
@@ -116,7 +140,13 @@ export type TransactionPaySourceAmount = {
     sourceAmountHuman: string;
     /** Amount of payment token required in atomic format without factoring token decimals. */
     sourceAmountRaw: string;
-    /** Address of the required token. */
+    /** Balance of the source token in atomic format (for post-quote flows). */
+    sourceBalanceRaw?: string;
+    /** Chain ID of the source token (for post-quote flows). */
+    sourceChainId?: Hex;
+    /** Address of the source token (for post-quote flows). */
+    sourceTokenAddress?: Hex;
+    /** Address of the target token. */
     targetTokenAddress: Hex;
 };
 /** Source token used to pay for required tokens. */
@@ -157,6 +187,8 @@ export type QuoteRequest = {
     from: Hex;
     /** Whether the transaction is a maximum amount transaction. */
     isMaxAmount?: boolean;
+    /** Whether this is a post-quote flow. */
+    isPostQuote?: boolean;
     /** Balance of the source token in atomic format without factoring token decimals. */
     sourceBalanceRaw: string;
     /** Chain ID of the source token. */
diff --git a/dist/types.d.mts b/dist/types.d.mts
index 458f58d..ccd4fb5 100644
--- a/dist/types.d.mts
+++ b/dist/types.d.mts
@@ -1,5 +1,4 @@
 import type { CurrencyRateControllerActions, TokenBalancesControllerGetStateAction } from "@metamask/assets-controllers";
-import type { TokenListControllerActions } from "@metamask/assets-controllers";
 import type { TokenRatesControllerGetStateAction } from "@metamask/assets-controllers";
 import type { TokensControllerGetStateAction } from "@metamask/assets-controllers";
 import type { AccountTrackerControllerGetStateAction } from "@metamask/assets-controllers";
@@ -18,7 +17,7 @@ import type { BatchTransaction, TransactionControllerAddTransactionAction, Trans
 import type { Hex, Json } from "@metamask/utils";
 import type { Draft } from "immer";
 import type { CONTROLLER_NAME, TransactionPayStrategy } from "./constants.mjs";
-export type AllowedActions = AccountTrackerControllerGetStateAction | BridgeControllerActions | BridgeStatusControllerActions | CurrencyRateControllerActions | GasFeeControllerActions | NetworkControllerFindNetworkClientIdByChainIdAction | NetworkControllerGetNetworkClientByIdAction | RemoteFeatureFlagControllerGetStateAction | TokenBalancesControllerGetStateAction | TokenListControllerActions | TokenRatesControllerGetStateAction | TokensControllerGetStateAction | TransactionControllerAddTransactionAction | TransactionControllerAddTransactionBatchAction | TransactionControllerEstimateGasAction | TransactionControllerEstimateGasBatchAction | TransactionControllerGetGasFeeTokensAction | TransactionControllerGetStateAction | TransactionControllerUpdateTransactionAction;
+export type AllowedActions = AccountTrackerControllerGetStateAction | BridgeControllerActions | BridgeStatusControllerActions | CurrencyRateControllerActions | GasFeeControllerActions | NetworkControllerFindNetworkClientIdByChainIdAction | NetworkControllerGetNetworkClientByIdAction | RemoteFeatureFlagControllerGetStateAction | TokenBalancesControllerGetStateAction | TokenRatesControllerGetStateAction | TokensControllerGetStateAction | TransactionControllerAddTransactionAction | TransactionControllerAddTransactionBatchAction | TransactionControllerEstimateGasAction | TransactionControllerEstimateGasBatchAction | TransactionControllerGetGasFeeTokensAction | TransactionControllerGetStateAction | TransactionControllerUpdateTransactionAction;
 export type AllowedEvents = BridgeStatusControllerStateChangeEvent | TransactionControllerStateChangeEvent | TransactionControllerUnapprovedTransactionAddedEvent;
 export type TransactionPayControllerGetStateAction = ControllerGetStateAction<typeof CONTROLLER_NAME, TransactionPayControllerState>;
 export type TransactionPayControllerGetDelegationTransactionAction = {
@@ -35,13 +34,26 @@ export type TransactionPayControllerUpdatePaymentTokenAction = {
     type: `${typeof CONTROLLER_NAME}:updatePaymentToken`;
     handler: (request: UpdatePaymentTokenRequest) => void;
 };
-/** Action to set the max amount flag for a transaction. */
-export type TransactionPayControllerSetIsMaxAmountAction = {
-    type: `${typeof CONTROLLER_NAME}:setIsMaxAmount`;
-    handler: (transactionId: string, isMaxAmount: boolean) => void;
+/** Configurable properties of a transaction. */
+export type TransactionConfig = {
+    /** Whether the user has selected the maximum amount. */
+    isMaxAmount?: boolean;
+    /**
+     * Whether this is a post-quote transaction.
+     * When true, the paymentToken represents the destination token,
+     * and the quote source is derived from the transaction's output token.
+     */
+    isPostQuote?: boolean;
+};
+/** Callback to update transaction config. */
+export type TransactionConfigCallback = (config: TransactionConfig) => void;
+/** Action to update transaction configuration using a callback. */
+export type TransactionPayControllerSetTransactionConfigAction = {
+    type: `${typeof CONTROLLER_NAME}:setTransactionConfig`;
+    handler: (transactionId: string, callback: TransactionConfigCallback) => void;
 };
 export type TransactionPayControllerStateChangeEvent = ControllerStateChangeEvent<typeof CONTROLLER_NAME, TransactionPayControllerState>;
-export type TransactionPayControllerActions = TransactionPayControllerGetDelegationTransactionAction | TransactionPayControllerGetStateAction | TransactionPayControllerGetStrategyAction | TransactionPayControllerSetIsMaxAmountAction | TransactionPayControllerUpdatePaymentTokenAction;
+export type TransactionPayControllerActions = TransactionPayControllerGetDelegationTransactionAction | TransactionPayControllerGetStateAction | TransactionPayControllerGetStrategyAction | TransactionPayControllerSetTransactionConfigAction | TransactionPayControllerUpdatePaymentTokenAction;
 export type TransactionPayControllerEvents = TransactionPayControllerStateChangeEvent;
 export type TransactionPayControllerMessenger = Messenger<typeof CONTROLLER_NAME, TransactionPayControllerActions | AllowedActions, TransactionPayControllerEvents | AllowedEvents>;
 /** Options for the TransactionPayController. */
@@ -66,7 +78,19 @@ export type TransactionData = {
     isLoading: boolean;
     /** Whether the user has selected the maximum amount. */
     isMaxAmount?: boolean;
-    /** Source token selected for the transaction. */
+    /**
+     * Whether this is a post-quote transaction.
+     * When true, the paymentToken represents the destination token,
+     * and the quote source is derived from the transaction's output token.
+     * Used when funds need to be moved after a transaction completes
+     * (e.g., bridging output to a different token/chain).
+     */
+    isPostQuote?: boolean;
+    /**
+     * Token selected for the transaction.
+     * - For standard flows (isPostQuote=false): This is the SOURCE/payment token
+     * - For post-quote flows (isPostQuote=true): This is the DESTINATION token
+     */
     paymentToken?: TransactionPaymentToken;
     /** Quotes retrieved for the transaction. */
     quotes?: TransactionPayQuote<Json>[];
@@ -116,7 +140,13 @@ export type TransactionPaySourceAmount = {
     sourceAmountHuman: string;
     /** Amount of payment token required in atomic format without factoring token decimals. */
     sourceAmountRaw: string;
-    /** Address of the required token. */
+    /** Balance of the source token in atomic format (for post-quote flows). */
+    sourceBalanceRaw?: string;
+    /** Chain ID of the source token (for post-quote flows). */
+    sourceChainId?: Hex;
+    /** Address of the source token (for post-quote flows). */
+    sourceTokenAddress?: Hex;
+    /** Address of the target token. */
     targetTokenAddress: Hex;
 };
 /** Source token used to pay for required tokens. */
@@ -157,6 +187,8 @@ export type QuoteRequest = {
     from: Hex;
     /** Whether the transaction is a maximum amount transaction. */
     isMaxAmount?: boolean;
+    /** Whether this is a post-quote flow. */
+    isPostQuote?: boolean;
     /** Balance of the source token in atomic format without factoring token decimals. */
     sourceBalanceRaw: string;
     /** Chain ID of the source token. */
diff --git a/dist/utils/quotes.cjs b/dist/utils/quotes.cjs
index 5c4cc79..809ced5 100644
--- a/dist/utils/quotes.cjs
+++ b/dist/utils/quotes.cjs
@@ -25,10 +25,11 @@ async function updateQuotes(request) {
         return false;
     }
     log('Updating quotes', { transactionId });
-    const { isMaxAmount, paymentToken, sourceAmounts, tokens } = transactionData;
+    const { isMaxAmount, isPostQuote, paymentToken, sourceAmounts, tokens } = transactionData;
     const requests = buildQuoteRequests({
         from: transaction.txParams.from,
         isMaxAmount: isMaxAmount ?? false,
+        isPostQuote,
         paymentToken,
         sourceAmounts,
         tokens,
@@ -49,6 +50,7 @@ async function updateQuotes(request) {
         log('Calculated totals', { transactionId, totals });
         syncTransaction({
             batchTransactions,
+            isPostQuote,
             messenger: messenger,
             paymentToken,
             totals,
@@ -73,12 +75,13 @@ exports.updateQuotes = updateQuotes;
  *
  * @param request - Request object.
  * @param request.batchTransactions - Batch transactions to sync.
+ * @param request.isPostQuote - Whether this is a post-quote flow.
  * @param request.messenger - Messenger instance.
- * @param request.paymentToken - Payment token used.
+ * @param request.paymentToken - Payment token (source for standard flows, destination for post-quote).
  * @param request.totals - Calculated totals.
  * @param request.transactionId - ID of the transaction to sync.
  */
-function syncTransaction({ batchTransactions, messenger, paymentToken, totals, transactionId, }) {
+function syncTransaction({ batchTransactions, isPostQuote, messenger, paymentToken, totals, transactionId, }) {
     if (!paymentToken) {
         return;
     }
@@ -92,6 +95,7 @@ function syncTransaction({ batchTransactions, messenger, paymentToken, totals, t
         tx.metamaskPay = {
             bridgeFeeFiat: totals.fees.provider.usd,
             chainId: paymentToken.chainId,
+            isPostQuote,
             networkFeeFiat: totals.fees.sourceNetwork.estimate.usd,
             targetFiat: totals.targetAmount.usd,
             tokenAddress: paymentToken.address,
@@ -142,16 +146,29 @@ exports.refreshQuotes = refreshQuotes;
  * @param request - Request parameters.
  * @param request.from - Address from which the transaction is sent.
  * @param request.isMaxAmount - Whether the transaction is a maximum amount transaction.
- * @param request.paymentToken - Payment token used for the transaction.
+ * @param request.isPostQuote - Whether this is a post-quote flow.
+ * @param request.paymentToken - Payment token (source for standard flows, destination for post-quote).
  * @param request.sourceAmounts - Source amounts for the transaction.
  * @param request.tokens - Required tokens for the transaction.
  * @param request.transactionId - ID of the transaction.
  * @returns Array of quote requests.
  */
-function buildQuoteRequests({ from, isMaxAmount, paymentToken, sourceAmounts, tokens, transactionId, }) {
+function buildQuoteRequests({ from, isMaxAmount, isPostQuote, paymentToken, sourceAmounts, tokens, transactionId, }) {
     if (!paymentToken) {
         return [];
     }
+    if (isPostQuote) {
+        // Post-quote flow: source = transaction's required token, target = paymentToken (destination)
+        // The user wants to receive the transaction output in paymentToken
+        return buildPostQuoteRequests({
+            from,
+            isMaxAmount,
+            destinationToken: paymentToken,
+            sourceAmounts,
+            transactionId,
+        });
+    }
+    // Standard flow: source = paymentToken, target = required tokens
     const requests = (sourceAmounts ?? []).map((sourceAmount) => {
         const token = tokens.find((singleToken) => singleToken.address === sourceAmount.targetTokenAddress);
         return {
@@ -171,6 +188,49 @@ function buildQuoteRequests({ from, isMaxAmount, paymentToken, sourceAmounts, to
     }
     return requests;
 }
+/**
+ * Build quote requests for post-quote flows.
+ * In this flow, the source is the transaction's required token,
+ * and the target is the user's selected destination token (paymentToken).
+ *
+ * @param request - Request parameters.
+ * @param request.from - Address from which the transaction is sent.
+ * @param request.isMaxAmount - Whether the transaction is a maximum amount transaction.
+ * @param request.destinationToken - Destination token (paymentToken in post-quote mode).
+ * @param request.sourceAmounts - Source amounts for the transaction (includes source token info).
+ * @param request.transactionId - ID of the transaction.
+ * @returns Array of quote requests for post-quote flow.
+ */
+function buildPostQuoteRequests({ from, isMaxAmount, destinationToken, sourceAmounts, transactionId, }) {
+    // Find the source amount where targetTokenAddress matches the destination token
+    const sourceAmount = sourceAmounts?.find((amount) => amount.targetTokenAddress.toLowerCase() ===
+        destinationToken.address.toLowerCase());
+    // Same-token-same-chain cases are already filtered in source-amounts.ts
+    if (!sourceAmount?.sourceTokenAddress ||
+        !sourceAmount.sourceChainId ||
+        !sourceAmount.sourceBalanceRaw) {
+        log('No source amount found for post-quote request', { transactionId });
+        return [];
+    }
+    const request = {
+        from,
+        isMaxAmount,
+        isPostQuote: true,
+        sourceBalanceRaw: sourceAmount.sourceBalanceRaw,
+        sourceTokenAmount: sourceAmount.sourceAmountRaw,
+        sourceChainId: sourceAmount.sourceChainId,
+        sourceTokenAddress: sourceAmount.sourceTokenAddress,
+        // For post-quote flows, use EXACT_INPUT - user specifies how much to send,
+        // and we show them how much they'll receive after fees
+        targetAmountMinimum: '0',
+        targetChainId: destinationToken.chainId,
+        targetTokenAddress: destinationToken.address,
+    };
+    log('Post-quote request built', { transactionId, request });
+    // Currently only single token post-quote flows are supported.
+    // Multiple token support would require multiple quotes for each required token.
+    return [request];
+}
 /**
  * Retrieve quotes for a transaction.
  *
diff --git a/dist/utils/quotes.mjs b/dist/utils/quotes.mjs
index 934473b..7b92c5d 100644
--- a/dist/utils/quotes.mjs
+++ b/dist/utils/quotes.mjs
@@ -22,10 +22,11 @@ export async function updateQuotes(request) {
         return false;
     }
     log('Updating quotes', { transactionId });
-    const { isMaxAmount, paymentToken, sourceAmounts, tokens } = transactionData;
+    const { isMaxAmount, isPostQuote, paymentToken, sourceAmounts, tokens } = transactionData;
     const requests = buildQuoteRequests({
         from: transaction.txParams.from,
         isMaxAmount: isMaxAmount ?? false,
+        isPostQuote,
         paymentToken,
         sourceAmounts,
         tokens,
@@ -46,6 +47,7 @@ export async function updateQuotes(request) {
         log('Calculated totals', { transactionId, totals });
         syncTransaction({
             batchTransactions,
+            isPostQuote,
             messenger: messenger,
             paymentToken,
             totals,
@@ -69,12 +71,13 @@ export async function updateQuotes(request) {
  *
  * @param request - Request object.
  * @param request.batchTransactions - Batch transactions to sync.
+ * @param request.isPostQuote - Whether this is a post-quote flow.
  * @param request.messenger - Messenger instance.
- * @param request.paymentToken - Payment token used.
+ * @param request.paymentToken - Payment token (source for standard flows, destination for post-quote).
  * @param request.totals - Calculated totals.
  * @param request.transactionId - ID of the transaction to sync.
  */
-function syncTransaction({ batchTransactions, messenger, paymentToken, totals, transactionId, }) {
+function syncTransaction({ batchTransactions, isPostQuote, messenger, paymentToken, totals, transactionId, }) {
     if (!paymentToken) {
         return;
     }
@@ -88,6 +91,7 @@ function syncTransaction({ batchTransactions, messenger, paymentToken, totals, t
         tx.metamaskPay = {
             bridgeFeeFiat: totals.fees.provider.usd,
             chainId: paymentToken.chainId,
+            isPostQuote,
             networkFeeFiat: totals.fees.sourceNetwork.estimate.usd,
             targetFiat: totals.targetAmount.usd,
             tokenAddress: paymentToken.address,
@@ -137,16 +141,29 @@ export async function refreshQuotes(messenger, updateTransactionData) {
  * @param request - Request parameters.
  * @param request.from - Address from which the transaction is sent.
  * @param request.isMaxAmount - Whether the transaction is a maximum amount transaction.
- * @param request.paymentToken - Payment token used for the transaction.
+ * @param request.isPostQuote - Whether this is a post-quote flow.
+ * @param request.paymentToken - Payment token (source for standard flows, destination for post-quote).
  * @param request.sourceAmounts - Source amounts for the transaction.
  * @param request.tokens - Required tokens for the transaction.
  * @param request.transactionId - ID of the transaction.
  * @returns Array of quote requests.
  */
-function buildQuoteRequests({ from, isMaxAmount, paymentToken, sourceAmounts, tokens, transactionId, }) {
+function buildQuoteRequests({ from, isMaxAmount, isPostQuote, paymentToken, sourceAmounts, tokens, transactionId, }) {
     if (!paymentToken) {
         return [];
     }
+    if (isPostQuote) {
+        // Post-quote flow: source = transaction's required token, target = paymentToken (destination)
+        // The user wants to receive the transaction output in paymentToken
+        return buildPostQuoteRequests({
+            from,
+            isMaxAmount,
+            destinationToken: paymentToken,
+            sourceAmounts,
+            transactionId,
+        });
+    }
+    // Standard flow: source = paymentToken, target = required tokens
     const requests = (sourceAmounts ?? []).map((sourceAmount) => {
         const token = tokens.find((singleToken) => singleToken.address === sourceAmount.targetTokenAddress);
         return {
@@ -166,6 +183,49 @@ function buildQuoteRequests({ from, isMaxAmount, paymentToken, sourceAmounts, to
     }
     return requests;
 }
+/**
+ * Build quote requests for post-quote flows.
+ * In this flow, the source is the transaction's required token,
+ * and the target is the user's selected destination token (paymentToken).
+ *
+ * @param request - Request parameters.
+ * @param request.from - Address from which the transaction is sent.
+ * @param request.isMaxAmount - Whether the transaction is a maximum amount transaction.
+ * @param request.destinationToken - Destination token (paymentToken in post-quote mode).
+ * @param request.sourceAmounts - Source amounts for the transaction (includes source token info).
+ * @param request.transactionId - ID of the transaction.
+ * @returns Array of quote requests for post-quote flow.
+ */
+function buildPostQuoteRequests({ from, isMaxAmount, destinationToken, sourceAmounts, transactionId, }) {
+    // Find the source amount where targetTokenAddress matches the destination token
+    const sourceAmount = sourceAmounts?.find((amount) => amount.targetTokenAddress.toLowerCase() ===
+        destinationToken.address.toLowerCase());
+    // Same-token-same-chain cases are already filtered in source-amounts.ts
+    if (!sourceAmount?.sourceTokenAddress ||
+        !sourceAmount.sourceChainId ||
+        !sourceAmount.sourceBalanceRaw) {
+        log('No source amount found for post-quote request', { transactionId });
+        return [];
+    }
+    const request = {
+        from,
+        isMaxAmount,
+        isPostQuote: true,
+        sourceBalanceRaw: sourceAmount.sourceBalanceRaw,
+        sourceTokenAmount: sourceAmount.sourceAmountRaw,
+        sourceChainId: sourceAmount.sourceChainId,
+        sourceTokenAddress: sourceAmount.sourceTokenAddress,
+        // For post-quote flows, use EXACT_INPUT - user specifies how much to send,
+        // and we show them how much they'll receive after fees
+        targetAmountMinimum: '0',
+        targetChainId: destinationToken.chainId,
+        targetTokenAddress: destinationToken.address,
+    };
+    log('Post-quote request built', { transactionId, request });
+    // Currently only single token post-quote flows are supported.
+    // Multiple token support would require multiple quotes for each required token.
+    return [request];
+}
 /**
  * Retrieve quotes for a transaction.
  *
diff --git a/dist/utils/required-tokens.cjs b/dist/utils/required-tokens.cjs
index ecaff50..3e37e99 100644
--- a/dist/utils/required-tokens.cjs
+++ b/dist/utils/required-tokens.cjs
@@ -11,11 +11,21 @@ const FOUR_BYTE_TOKEN_TRANSFER = '0xa9059cbb';
 /**
  * Parse required tokens from a transaction.
  *
+ * If the transaction has `requiredAssets`, those are used to determine required tokens.
+ * Otherwise, falls back to parsing the transaction data for token transfers.
+ *
  * @param transaction - Transaction metadata.
  * @param messenger - Controller messenger.
  * @returns An array of required tokens.
  */
 function parseRequiredTokens(transaction, messenger) {
+    const { requiredAssets } = transaction;
+    if (requiredAssets?.length) {
+        const assetTokens = requiredAssets
+            .map((asset) => buildRequiredToken(transaction, asset.address, asset.amount, messenger))
+            .filter(Boolean);
+        return assetTokens;
+    }
     return [
         getTokenTransferToken(transaction, messenger),
         getGasFeeToken(transaction, messenger),
@@ -164,7 +174,7 @@ function getTokenTransferData(transactionMeta) {
         return { data: singleData, to: singleTo, index: undefined };
     }
     const nestedCallIndex = nestedTransactions?.findIndex((call) => call.data?.startsWith(FOUR_BYTE_TOKEN_TRANSFER));
-    const nestedCall = nestedCallIndex === undefined
+    const nestedCall = nestedCallIndex === undefined || nestedCallIndex === -1
         ? undefined
         : nestedTransactions?.[nestedCallIndex];
     if (nestedCall?.data && nestedCall.to) {
diff --git a/dist/utils/required-tokens.d.cts b/dist/utils/required-tokens.d.cts
index 169c299..9936374 100644
--- a/dist/utils/required-tokens.d.cts
+++ b/dist/utils/required-tokens.d.cts
@@ -3,6 +3,9 @@ import type { TransactionPayControllerMessenger, TransactionPayRequiredToken } f
 /**
  * Parse required tokens from a transaction.
  *
+ * If the transaction has `requiredAssets`, those are used to determine required tokens.
+ * Otherwise, falls back to parsing the transaction data for token transfers.
+ *
  * @param transaction - Transaction metadata.
  * @param messenger - Controller messenger.
  * @returns An array of required tokens.
diff --git a/dist/utils/required-tokens.d.mts b/dist/utils/required-tokens.d.mts
index f5977c5..0c61b79 100644
--- a/dist/utils/required-tokens.d.mts
+++ b/dist/utils/required-tokens.d.mts
@@ -3,6 +3,9 @@ import type { TransactionPayControllerMessenger, TransactionPayRequiredToken } f
 /**
  * Parse required tokens from a transaction.
  *
+ * If the transaction has `requiredAssets`, those are used to determine required tokens.
+ * Otherwise, falls back to parsing the transaction data for token transfers.
+ *
  * @param transaction - Transaction metadata.
  * @param messenger - Controller messenger.
  * @returns An array of required tokens.
diff --git a/dist/utils/required-tokens.mjs b/dist/utils/required-tokens.mjs
index 6e0bc63..ce199a7 100644
--- a/dist/utils/required-tokens.mjs
+++ b/dist/utils/required-tokens.mjs
@@ -8,11 +8,21 @@ const FOUR_BYTE_TOKEN_TRANSFER = '0xa9059cbb';
 /**
  * Parse required tokens from a transaction.
  *
+ * If the transaction has `requiredAssets`, those are used to determine required tokens.
+ * Otherwise, falls back to parsing the transaction data for token transfers.
+ *
  * @param transaction - Transaction metadata.
  * @param messenger - Controller messenger.
  * @returns An array of required tokens.
  */
 export function parseRequiredTokens(transaction, messenger) {
+    const { requiredAssets } = transaction;
+    if (requiredAssets?.length) {
+        const assetTokens = requiredAssets
+            .map((asset) => buildRequiredToken(transaction, asset.address, asset.amount, messenger))
+            .filter(Boolean);
+        return assetTokens;
+    }
     return [
         getTokenTransferToken(transaction, messenger),
         getGasFeeToken(transaction, messenger),
@@ -160,7 +170,7 @@ function getTokenTransferData(transactionMeta) {
         return { data: singleData, to: singleTo, index: undefined };
     }
     const nestedCallIndex = nestedTransactions?.findIndex((call) => call.data?.startsWith(FOUR_BYTE_TOKEN_TRANSFER));
-    const nestedCall = nestedCallIndex === undefined
+    const nestedCall = nestedCallIndex === undefined || nestedCallIndex === -1
         ? undefined
         : nestedTransactions?.[nestedCallIndex];
     if (nestedCall?.data && nestedCall.to) {
diff --git a/dist/utils/source-amounts.cjs b/dist/utils/source-amounts.cjs
index 8beae39..872fb21 100644
--- a/dist/utils/source-amounts.cjs
+++ b/dist/utils/source-amounts.cjs
@@ -20,10 +20,18 @@ function updateSourceAmounts(transactionId, transactionData, messenger) {
     if (!transactionData) {
         return;
     }
-    const { isMaxAmount, paymentToken, tokens } = transactionData;
+    const { isMaxAmount, isPostQuote, paymentToken, tokens } = transactionData;
     if (!tokens.length || !paymentToken) {
         return;
     }
+    // For post-quote flows, source amounts are calculated differently
+    // The source is the transaction's required token, not the selected token
+    if (isPostQuote) {
+        const sourceAmounts = calculatePostQuoteSourceAmounts(tokens, paymentToken, isMaxAmount ?? false);
+        log('Updated post-quote source amounts', { transactionId, sourceAmounts });
+        transactionData.sourceAmounts = sourceAmounts;
+        return;
+    }
     const sourceAmounts = tokens
         .map((singleToken) => calculateSourceAmount(paymentToken, singleToken, messenger, transactionId, isMaxAmount ?? false))
         .filter(Boolean);
@@ -31,6 +39,43 @@ function updateSourceAmounts(transactionId, transactionData, messenger) {
     transactionData.sourceAmounts = sourceAmounts;
 }
 exports.updateSourceAmounts = updateSourceAmounts;
+/**
+ * Calculate source amounts for post-quote flows.
+ * In this flow, the required tokens ARE the source tokens,
+ * and the payment token is the target (destination).
+ *
+ * @param tokens - Required tokens from the transaction.
+ * @param paymentToken - Selected payment/destination token.
+ * @param isMaxAmount - Whether the transaction is a maximum amount transaction.
+ * @returns Array of source amounts.
+ */
+function calculatePostQuoteSourceAmounts(tokens, paymentToken, isMaxAmount) {
+    return tokens
+        .filter((token) => {
+        if (token.skipIfBalance) {
+            return false;
+        }
+        // Skip zero amounts (unless max amount, where we use balance)
+        if (token.amountRaw === '0' && !isMaxAmount) {
+            log('Skipping token as zero amount', { tokenAddress: token.address });
+            return false;
+        }
+        // Skip same token on same chain
+        if ((0, token_1.isSameToken)(token, paymentToken)) {
+            log('Skipping token as same as destination token');
+            return false;
+        }
+        return true;
+    })
+        .map((token) => ({
+        sourceAmountHuman: isMaxAmount ? token.balanceHuman : token.amountHuman,
+        sourceAmountRaw: isMaxAmount ? token.balanceRaw : token.amountRaw,
+        sourceBalanceRaw: token.balanceRaw,
+        sourceChainId: token.chainId,
+        sourceTokenAddress: token.address,
+        targetTokenAddress: paymentToken.address,
+    }));
+}
 /**
  * Calculate the required source amount for a payment token to cover a target token.
  *
@@ -54,10 +99,8 @@ function calculateSourceAmount(paymentToken, token, messenger, transactionId, is
         return undefined;
     }
     const strategy = getStrategyType(transactionId, messenger);
-    const isSameTokenSelected = token.address.toLowerCase() === paymentToken.address.toLowerCase() &&
-        token.chainId === paymentToken.chainId;
     const isAlwaysRequired = isQuoteAlwaysRequired(token, strategy);
-    if (isSameTokenSelected && !isAlwaysRequired) {
+    if ((0, token_1.isSameToken)(token, paymentToken) && !isAlwaysRequired) {
         log('Skipping token as same as payment token');
         return undefined;
     }
diff --git a/dist/utils/source-amounts.mjs b/dist/utils/source-amounts.mjs
index 9267ab2..1b23212 100644
--- a/dist/utils/source-amounts.mjs
+++ b/dist/utils/source-amounts.mjs
@@ -1,6 +1,6 @@
 import { createModuleLogger } from "@metamask/utils";
 import { BigNumber } from "bignumber.js";
-import { getTokenFiatRate } from "./token.mjs";
+import { getTokenFiatRate, isSameToken } from "./token.mjs";
 import { getTransaction } from "./transaction.mjs";
 import { TransactionPayStrategy } from "../index.mjs";
 import { ARBITRUM_USDC_ADDRESS, CHAIN_ID_ARBITRUM } from "../constants.mjs";
@@ -17,16 +17,61 @@ export function updateSourceAmounts(transactionId, transactionData, messenger) {
     if (!transactionData) {
         return;
     }
-    const { isMaxAmount, paymentToken, tokens } = transactionData;
+    const { isMaxAmount, isPostQuote, paymentToken, tokens } = transactionData;
     if (!tokens.length || !paymentToken) {
         return;
     }
+    // For post-quote flows, source amounts are calculated differently
+    // The source is the transaction's required token, not the selected token
+    if (isPostQuote) {
+        const sourceAmounts = calculatePostQuoteSourceAmounts(tokens, paymentToken, isMaxAmount ?? false);
+        log('Updated post-quote source amounts', { transactionId, sourceAmounts });
+        transactionData.sourceAmounts = sourceAmounts;
+        return;
+    }
     const sourceAmounts = tokens
         .map((singleToken) => calculateSourceAmount(paymentToken, singleToken, messenger, transactionId, isMaxAmount ?? false))
         .filter(Boolean);
     log('Updated source amounts', { transactionId, sourceAmounts });
     transactionData.sourceAmounts = sourceAmounts;
 }
+/**
+ * Calculate source amounts for post-quote flows.
+ * In this flow, the required tokens ARE the source tokens,
+ * and the payment token is the target (destination).
+ *
+ * @param tokens - Required tokens from the transaction.
+ * @param paymentToken - Selected payment/destination token.
+ * @param isMaxAmount - Whether the transaction is a maximum amount transaction.
+ * @returns Array of source amounts.
+ */
+function calculatePostQuoteSourceAmounts(tokens, paymentToken, isMaxAmount) {
+    return tokens
+        .filter((token) => {
+        if (token.skipIfBalance) {
+            return false;
+        }
+        // Skip zero amounts (unless max amount, where we use balance)
+        if (token.amountRaw === '0' && !isMaxAmount) {
+            log('Skipping token as zero amount', { tokenAddress: token.address });
+            return false;
+        }
+        // Skip same token on same chain
+        if (isSameToken(token, paymentToken)) {
+            log('Skipping token as same as destination token');
+            return false;
+        }
+        return true;
+    })
+        .map((token) => ({
+        sourceAmountHuman: isMaxAmount ? token.balanceHuman : token.amountHuman,
+        sourceAmountRaw: isMaxAmount ? token.balanceRaw : token.amountRaw,
+        sourceBalanceRaw: token.balanceRaw,
+        sourceChainId: token.chainId,
+        sourceTokenAddress: token.address,
+        targetTokenAddress: paymentToken.address,
+    }));
+}
 /**
  * Calculate the required source amount for a payment token to cover a target token.
  *
@@ -50,10 +95,8 @@ function calculateSourceAmount(paymentToken, token, messenger, transactionId, is
         return undefined;
     }
     const strategy = getStrategyType(transactionId, messenger);
-    const isSameTokenSelected = token.address.toLowerCase() === paymentToken.address.toLowerCase() &&
-        token.chainId === paymentToken.chainId;
     const isAlwaysRequired = isQuoteAlwaysRequired(token, strategy);
-    if (isSameTokenSelected && !isAlwaysRequired) {
+    if (isSameToken(token, paymentToken) && !isAlwaysRequired) {
         log('Skipping token as same as payment token');
         return undefined;
     }
diff --git a/dist/utils/token.cjs b/dist/utils/token.cjs
index 68cd5af..7cbe214 100644
--- a/dist/utils/token.cjs
+++ b/dist/utils/token.cjs
@@ -1,6 +1,6 @@
 "use strict";
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.getNativeToken = exports.getTokenFiatRate = exports.getTokenInfo = exports.getAllTokenBalances = exports.getTokenBalance = void 0;
+exports.getNativeToken = exports.getTokenFiatRate = exports.getTokenInfo = exports.getAllTokenBalances = exports.getTokenBalance = exports.isSameToken = void 0;
 const controller_utils_1 = require("@metamask/controller-utils");
 const bignumber_js_1 = require("bignumber.js");
 const lodash_1 = require("lodash");
@@ -9,6 +9,22 @@ const STABLECOINS = {
     [constants_1.CHAIN_ID_ARBITRUM]: [constants_1.ARBITRUM_USDC_ADDRESS.toLowerCase()],
     [constants_1.CHAIN_ID_POLYGON]: [constants_1.POLYGON_USDCE_ADDRESS.toLowerCase()],
 };
+/**
+ * Check if two tokens are the same (same address and chain).
+ *
+ * @param token1 - First token identifier.
+ * @param token1.address - Token address.
+ * @param token1.chainId - Token chain ID.
+ * @param token2 - Second token identifier.
+ * @param token2.address - Token address.
+ * @param token2.chainId - Token chain ID.
+ * @returns True if tokens are the same, false otherwise.
+ */
+function isSameToken(token1, token2) {
+    return (token1.address.toLowerCase() === token2.address.toLowerCase() &&
+        token1.chainId === token2.chainId);
+}
+exports.isSameToken = isSameToken;
 /**
  * Get the token balance for a specific account and token.
  *
diff --git a/dist/utils/token.d.cts b/dist/utils/token.d.cts
index ac78861..681c149 100644
--- a/dist/utils/token.d.cts
+++ b/dist/utils/token.d.cts
@@ -1,5 +1,23 @@
 import type { Hex } from "@metamask/utils";
 import type { FiatRates, TransactionPayControllerMessenger } from "../types.cjs";
+/**
+ * Check if two tokens are the same (same address and chain).
+ *
+ * @param token1 - First token identifier.
+ * @param token1.address - Token address.
+ * @param token1.chainId - Token chain ID.
+ * @param token2 - Second token identifier.
+ * @param token2.address - Token address.
+ * @param token2.chainId - Token chain ID.
+ * @returns True if tokens are the same, false otherwise.
+ */
+export declare function isSameToken(token1: {
+    address: Hex;
+    chainId: Hex;
+}, token2: {
+    address: Hex;
+    chainId: Hex;
+}): boolean;
 /**
  * Get the token balance for a specific account and token.
  *
diff --git a/dist/utils/token.d.mts b/dist/utils/token.d.mts
index 8b4d061..6e40d46 100644
--- a/dist/utils/token.d.mts
+++ b/dist/utils/token.d.mts
@@ -1,5 +1,23 @@
 import type { Hex } from "@metamask/utils";
 import type { FiatRates, TransactionPayControllerMessenger } from "../types.mjs";
+/**
+ * Check if two tokens are the same (same address and chain).
+ *
+ * @param token1 - First token identifier.
+ * @param token1.address - Token address.
+ * @param token1.chainId - Token chain ID.
+ * @param token2 - Second token identifier.
+ * @param token2.address - Token address.
+ * @param token2.chainId - Token chain ID.
+ * @returns True if tokens are the same, false otherwise.
+ */
+export declare function isSameToken(token1: {
+    address: Hex;
+    chainId: Hex;
+}, token2: {
+    address: Hex;
+    chainId: Hex;
+}): boolean;
 /**
  * Get the token balance for a specific account and token.
  *
diff --git a/dist/utils/token.mjs b/dist/utils/token.mjs
index bf1527b..cba10c6 100644
--- a/dist/utils/token.mjs
+++ b/dist/utils/token.mjs
@@ -7,6 +7,21 @@ const STABLECOINS = {
     [CHAIN_ID_ARBITRUM]: [ARBITRUM_USDC_ADDRESS.toLowerCase()],
     [CHAIN_ID_POLYGON]: [POLYGON_USDCE_ADDRESS.toLowerCase()],
 };
+/**
+ * Check if two tokens are the same (same address and chain).
+ *
+ * @param token1 - First token identifier.
+ * @param token1.address - Token address.
+ * @param token1.chainId - Token chain ID.
+ * @param token2 - Second token identifier.
+ * @param token2.address - Token address.
+ * @param token2.chainId - Token chain ID.
+ * @returns True if tokens are the same, false otherwise.
+ */
+export function isSameToken(token1, token2) {
+    return (token1.address.toLowerCase() === token2.address.toLowerCase() &&
+        token1.chainId === token2.chainId);
+}
 /**
  * Get the token balance for a specific account and token.
  *
