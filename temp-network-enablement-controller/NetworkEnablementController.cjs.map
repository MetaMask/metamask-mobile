{"version":3,"file":"NetworkEnablementController.cjs","sourceRoot":"","sources":["../src/NetworkEnablementController.ts"],"names":[],"mappings":"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","sourcesContent":["import { BaseController } from '@metamask/base-controller';\nimport type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n  RestrictedMessenger,\n} from '@metamask/base-controller';\nimport { BuiltInNetworkName, ChainId, toHex } from '@metamask/controller-utils';\nimport { SolScope } from '@metamask/keyring-api';\nimport type { MultichainNetworkControllerGetStateAction } from '@metamask/multichain-network-controller';\nimport { toEvmCaipChainId } from '@metamask/multichain-network-controller';\nimport type {\n  NetworkControllerGetStateAction,\n  NetworkControllerNetworkAddedEvent,\n  NetworkControllerNetworkRemovedEvent,\n  NetworkControllerStateChangeEvent,\n} from '@metamask/network-controller';\nimport type { CaipChainId, CaipNamespace, Hex } from '@metamask/utils';\nimport {\n  isCaipChainId,\n  isHexString,\n  KnownCaipNamespace,\n  parseCaipChainId,\n} from '@metamask/utils';\n\nimport { POPULAR_NETWORKS } from './constants';\nimport { selectAllEnabledNetworks } from './selectors';\n\n// Unique name for the controller\nconst controllerName = 'NetworkEnablementController';\n\n/**\n * Information about an ordered network.\n */\nexport type NetworksInfo = {\n  /**\n   * The network's chain id\n   */\n  networkId: CaipChainId;\n};\n\n/**\n * A map of enabled networks by namespace and chain id.\n */\ntype EnabledMap = Record<CaipNamespace, Record<string, boolean>>;\n\n// State shape for NetworkEnablementController\nexport type NetworkEnablementControllerState = {\n  enabledNetworkMap: EnabledMap;\n};\n\nexport type NetworkEnablementControllerGetStateAction =\n  ControllerGetStateAction<\n    typeof controllerName,\n    NetworkEnablementControllerState\n  >;\n\nexport type NetworkEnablementControllerSetEnabledNetworksAction = {\n  type: `${typeof controllerName}:setEnabledNetworks`;\n  handler: NetworkEnablementController['setEnabledNetwork'];\n};\n\nexport type NetworkEnablementControllerDisableNetworkAction = {\n  type: `${typeof controllerName}:disableNetwork`;\n  handler: NetworkEnablementController['setDisabledNetwork'];\n};\n\nexport type NetworkEnablementControllerIsNetworkEnabledAction = {\n  type: `${typeof controllerName}:isNetworkEnabled`;\n  handler: NetworkEnablementController['isNetworkEnabled'];\n};\n\n/**\n * All actions that {@link NetworkEnablementController} calls internally.\n */\ntype AllowedActions =\n  | NetworkControllerGetStateAction\n  | MultichainNetworkControllerGetStateAction;\n\nexport type NetworkEnablementControllerActions =\n  | NetworkEnablementControllerGetStateAction\n  | NetworkEnablementControllerSetEnabledNetworksAction\n  | NetworkEnablementControllerDisableNetworkAction\n  | NetworkEnablementControllerIsNetworkEnabledAction;\n\nexport type NetworkEnablementControllerStateChangeEvent =\n  ControllerStateChangeEvent<\n    typeof controllerName,\n    NetworkEnablementControllerState\n  >;\n\nexport type NetworkEnablementControllerEvents =\n  NetworkEnablementControllerStateChangeEvent;\n\n/**\n * All events that {@link NetworkEnablementController} subscribes to internally.\n */\ntype AllowedEvents =\n  | NetworkControllerNetworkAddedEvent\n  | NetworkControllerNetworkRemovedEvent\n  | NetworkControllerStateChangeEvent;\n\nexport type NetworkEnablementControllerMessenger = RestrictedMessenger<\n  typeof controllerName,\n  NetworkEnablementControllerActions | AllowedActions,\n  NetworkEnablementControllerEvents | AllowedEvents,\n  AllowedActions['type'],\n  AllowedEvents['type']\n>;\n\n/**\n * Gets the default state for the NetworkEnablementController.\n *\n * @returns The default state with pre-enabled networks.\n */\nconst getDefaultNetworkEnablementControllerState =\n  (): NetworkEnablementControllerState => ({\n    enabledNetworkMap: {\n      [KnownCaipNamespace.Eip155]: {\n        [ChainId[BuiltInNetworkName.Mainnet]]: true,\n        [ChainId[BuiltInNetworkName.LineaMainnet]]: true,\n        [ChainId[BuiltInNetworkName.BaseMainnet]]: true,\n      },\n      [KnownCaipNamespace.Solana]: {\n        [SolScope.Mainnet]: true,\n      },\n    },\n  });\n\n// Metadata for the controller state\nconst metadata = {\n  enabledNetworkMap: {\n    persist: true,\n    anonymous: true,\n  },\n};\n\n/**\n * Controller responsible for managing network enablement state across different blockchain networks.\n *\n * This controller tracks which networks are enabled/disabled for the user and provides methods\n * to toggle network states. It supports both EVM (EIP-155) and non-EVM networks like Solana.\n *\n * The controller maintains a map of enabled networks organized by namespace (e.g., 'eip155', 'solana')\n * and provides methods to query and modify network enablement states.\n */\nexport class NetworkEnablementController extends BaseController<\n  typeof controllerName,\n  NetworkEnablementControllerState,\n  NetworkEnablementControllerMessenger\n> {\n  /**\n   * Creates a NetworkEnablementController instance.\n   *\n   * @param args - The arguments to this function.\n   * @param args.messenger - Messenger used to communicate with BaseV2 controller.\n   * @param args.state - Initial state to set on this controller.\n   */\n  constructor({\n    messenger,\n    state,\n  }: {\n    messenger: NetworkEnablementControllerMessenger;\n    state?: Partial<NetworkEnablementControllerState>;\n  }) {\n    super({\n      messenger,\n      metadata,\n      name: controllerName,\n      state: {\n        ...getDefaultNetworkEnablementControllerState(),\n        ...state,\n      },\n    });\n\n    this.messagingSystem = messenger;\n\n    messenger.subscribe('NetworkController:networkAdded', ({ chainId }) => {\n      this.#ensureNetworkEntry(chainId, false);\n      this.#toggleNetwork(chainId, true);\n    });\n\n    messenger.subscribe('NetworkController:networkRemoved', ({ chainId }) => {\n      this.#removeNetworkEntry(chainId);\n    });\n  }\n\n  /**\n   * Enables a network for the user.\n   *\n   * This method accepts either a Hex chain ID (for EVM networks) or a CAIP-2 chain ID\n   * (for any blockchain network). The method will automatically convert Hex chain IDs\n   * to CAIP-2 format internally. This dual parameter support allows for backward\n   * compatibility with existing EVM chain ID formats while supporting newer\n   * multi-chain standards.\n   *\n   * When enabling a non-popular network, this method will disable all other networks\n   * to ensure only one network is active at a time (exclusive mode).\n   *\n   * @param chainId - The chain ID of the network to enable. Can be either:\n   * - A Hex string (e.g., '0x1' for Ethereum mainnet) for EVM networks\n   * - A CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet, 'solana:mainnet' for Solana)\n   */\n  setEnabledNetwork(chainId: Hex | CaipChainId): void {\n    this.#toggleNetwork(chainId, true);\n  }\n\n  /**\n   * Disables a network for the user.\n   *\n   * This method accepts either a Hex chain ID (for EVM networks) or a CAIP-2 chain ID\n   * (for any blockchain network). The method will automatically convert Hex chain IDs\n   * to CAIP-2 format internally.\n   *\n   * Note: This method will prevent disabling the last remaining enabled network\n   * to ensure at least one network is always available.\n   *\n   * @param chainId - The chain ID of the network to disable. Can be either:\n   * - A Hex string (e.g., '0x1' for Ethereum mainnet) for EVM networks\n   * - A CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet, 'solana:mainnet' for Solana)\n   */\n  setDisabledNetwork(chainId: Hex | CaipChainId): void {\n    this.#toggleNetwork(chainId, false);\n  }\n\n  /**\n   * Checks if a network is currently enabled for the user.\n   *\n   * This method accepts either a Hex chain ID (for EVM networks) or a CAIP-2 chain ID\n   * (for any blockchain network). It returns false for unknown networks or if there's\n   * an error parsing the chain ID.\n   *\n   * @param chainId - The chain ID of the network to check. Can be either:\n   * - A Hex string (e.g., '0x1' for Ethereum mainnet) for EVM networks\n   * - A CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet, 'solana:mainnet' for Solana)\n   * @returns True if the network is enabled, false otherwise.\n   */\n  isNetworkEnabled(chainId: Hex | CaipChainId): boolean {\n    try {\n      const { namespace, storageKey } = this.#deriveKeys(chainId);\n      return (\n        namespace in this.state.enabledNetworkMap &&\n        Boolean(this.state.enabledNetworkMap[namespace][storageKey])\n      );\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Derives the namespace, storage key, and CAIP chain ID from a given chain ID.\n   *\n   * This internal method handles the conversion between different chain ID formats.\n   * For EVM networks, it converts Hex chain IDs to CAIP-2 format and determines\n   * the appropriate storage key. For non-EVM networks, it parses the CAIP-2 chain ID\n   * and uses the full chain ID as the storage key.\n   *\n   * @param chainId - The chain ID to derive keys from (Hex or CAIP-2 format)\n   * @returns An object containing namespace, storageKey, and caipId\n   * @throws Error if the chain ID cannot be parsed\n   */\n  #deriveKeys(chainId: Hex | CaipChainId) {\n    const caipId: CaipChainId = isCaipChainId(chainId)\n      ? chainId\n      : toEvmCaipChainId(chainId);\n    const { namespace, reference } = parseCaipChainId(caipId);\n    let storageKey: string;\n    if (namespace === (KnownCaipNamespace.Eip155 as string)) {\n      storageKey = isHexString(chainId) ? chainId : toHex(reference);\n    } else {\n      storageKey = caipId;\n    }\n    return { namespace, storageKey, caipId };\n  }\n\n  /**\n   * Ensures that a namespace bucket exists in the state.\n   *\n   * This method creates the namespace entry in the enabledNetworkMap if it doesn't\n   * already exist. This is used to prepare the state structure before adding\n   * network entries.\n   *\n   * @param state - The current controller state\n   * @param ns - The CAIP namespace to ensure exists\n   */\n  #ensureNamespaceBucket(\n    state: NetworkEnablementControllerState,\n    ns: CaipNamespace,\n  ) {\n    if (!state.enabledNetworkMap[ns]) {\n      state.enabledNetworkMap[ns] = {};\n    }\n  }\n\n  /**\n   * Ensures that a network entry exists in the state.\n   *\n   * This method creates a network entry in the enabledNetworkMap if it doesn't\n   * already exist. It's called when a new network is added to ensure the\n   * state structure is properly initialized.\n   *\n   * @param chainId - The chain ID to ensure has an entry (Hex or CAIP-2 format)\n   * @param enable - Whether to enable the network by default (defaults to false)\n   */\n  #ensureNetworkEntry(chainId: Hex | CaipChainId, enable = false): void {\n    const { namespace, storageKey } = this.#deriveKeys(chainId);\n    this.update((s) => {\n      this.#ensureNamespaceBucket(s, namespace);\n      if (!(storageKey in s.enabledNetworkMap[namespace])) {\n        s.enabledNetworkMap[namespace][storageKey] = enable;\n      }\n    });\n  }\n\n  /**\n   * Removes a network entry from the state.\n   *\n   * This method is called when a network is removed from the system. It cleans up\n   * the network entry and ensures that at least one network remains enabled.\n   *\n   * @param chainId - The chain ID to remove (Hex or CAIP-2 format)\n   */\n  #removeNetworkEntry(chainId: Hex | CaipChainId): void {\n    const { namespace, storageKey } = this.#deriveKeys(chainId);\n    if (this.#hasOneEnabled(this.state, namespace, chainId)) {\n      return;\n    }\n\n    this.update((s) => {\n      if (namespace in s.enabledNetworkMap) {\n        delete s.enabledNetworkMap[namespace][storageKey];\n        if (Object.keys(s.enabledNetworkMap[namespace]).length === 0) {\n          delete s.enabledNetworkMap[namespace];\n        }\n      }\n    });\n  }\n\n  /**\n   * Checks if the specified network is the only enabled network in its namespace.\n   *\n   * This method is used to prevent unnecessary state updates when trying to enable\n   * a network that is already the only enabled network in its namespace.\n   *\n   * @param state - The current controller state\n   * @param namespace - The namespace to check\n   * @param chainIdToCheck - The chain ID to check if it's the only enabled network\n   * @returns True if the network is the only enabled network in the namespace, false otherwise\n   */\n  #hasOneEnabled(\n    state: NetworkEnablementControllerState,\n    namespace: CaipNamespace,\n    chainIdToCheck: Hex | CaipChainId,\n  ): boolean {\n    // Early return if namespace doesn't exist\n    if (!state.enabledNetworkMap[namespace]) {\n      return false;\n    }\n\n    // Parse the chain ID to get the storage key\n    const caipId = isCaipChainId(chainIdToCheck)\n      ? chainIdToCheck\n      : toEvmCaipChainId(chainIdToCheck);\n\n    const { namespace: parsedNamespace, storageKey: targetStorageKey } =\n      this.#deriveKeys(caipId);\n\n    // Early return if namespaces don't match\n    if (parsedNamespace !== namespace) {\n      return false;\n    }\n\n    const networks = state.enabledNetworkMap[namespace];\n\n    // Get all enabled networks in this namespace\n    const enabledNetworks = Object.entries(networks).filter(\n      ([_, enabled]) => enabled,\n    );\n\n    // Check if there's exactly one enabled network and it matches our target\n    if (enabledNetworks.length === 1) {\n      const [onlyEnabledKey] = enabledNetworks[0];\n      return onlyEnabledKey === targetStorageKey;\n    }\n\n    // Return false if there are zero or multiple enabled networks\n    return false;\n  }\n\n  /**\n   * Checks if a network is known to the system.\n   *\n   * This method verifies whether a network exists in the NetworkController or\n   * MultichainNetworkController configurations. It's used to prevent enabling\n   * unknown networks.\n   *\n   * @param caipId - The CAIP-2 chain ID to check\n   * @returns True if the network is known, false otherwise\n   */\n  #isKnownNetwork(caipId: CaipChainId): boolean {\n    const { namespace, reference } = parseCaipChainId(caipId);\n    if (namespace === (KnownCaipNamespace.Eip155 as string)) {\n      const { networkConfigurationsByChainId } = this.messagingSystem.call(\n        'NetworkController:getState',\n      );\n      return toHex(reference) in networkConfigurationsByChainId;\n    }\n    if (namespace === (KnownCaipNamespace.Solana as string)) {\n      const { multichainNetworkConfigurationsByChainId } =\n        this.messagingSystem.call('MultichainNetworkController:getState');\n      return caipId in multichainNetworkConfigurationsByChainId;\n    }\n    return false;\n  }\n\n  /**\n   * Checks if a network is considered a popular network.\n   *\n   * Popular networks are predefined networks that are commonly used and trusted.\n   * When enabling a non-popular network, the system switches to exclusive mode\n   * (only one network enabled at a time).\n   *\n   * @param caipId - The chain ID to check (can be Hex or CAIP-2 format)\n   * @returns True if the network is popular, false otherwise\n   */\n  #isPopularNetwork(caipId: CaipChainId | string): boolean {\n    if (isHexString(caipId)) {\n      return POPULAR_NETWORKS.includes(caipId);\n    }\n    const { namespace, reference } = parseCaipChainId(caipId);\n    if (namespace === (KnownCaipNamespace.Eip155 as string)) {\n      return POPULAR_NETWORKS.includes(toHex(reference));\n    }\n    return false;\n  }\n\n  /**\n   * Toggles the enabled state of a network.\n   *\n   * This is the core method that handles enabling and disabling networks. It includes\n   * several safety checks and business logic:\n   * - Prevents enabling unknown networks\n   * - Prevents disabling the last remaining enabled network\n   * - Implements exclusive mode for non-popular networks\n   * - Ensures at least one network remains enabled\n   *\n   * The method accepts either Hex or CAIP-2 chain IDs for flexibility and\n   * backward compatibility.\n   *\n   * @param chainId - The chain ID to toggle (Hex or CAIP-2 format)\n   * @param enable - True to enable the network, false to disable it\n   */\n  #toggleNetwork(chainId: Hex | CaipChainId, enable: boolean): void {\n    const { namespace, storageKey, caipId } = this.#deriveKeys(chainId);\n\n    // Ignore unknown networks\n    if (!this.#isKnownNetwork(caipId)) {\n      return;\n    }\n\n    // Don't disable the last remaining enabled network\n    if (\n      !enable &&\n      Object.values(selectAllEnabledNetworks(this.state)).flat().length <= 1\n    ) {\n      return;\n    }\n\n    this.update((s) => {\n      // Ensure entry exists first\n      this.#ensureNetworkEntry(chainId);\n\n      if (this.#hasOneEnabled(s, namespace, chainId)) {\n        return;\n      }\n\n      // If enabling a non-popular network, disable all networks in the same namespace\n      if (enable && !this.#isPopularNetwork(caipId)) {\n        Object.keys(s.enabledNetworkMap[namespace]).forEach((key) => {\n          s.enabledNetworkMap[namespace][key] = false;\n        });\n      }\n\n      s.enabledNetworkMap[namespace][storageKey] = enable;\n    });\n  }\n}\n"]}