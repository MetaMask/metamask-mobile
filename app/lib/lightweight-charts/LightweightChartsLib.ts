// Lightweight Charts Library Content
// To update: Replace the string below with new library version from:
// https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js
/*!
 * @license
 * TradingView Lightweight Charts™ v5.0.8
 * Copyright (c) 2025 TradingView, Inc.
 * Licensed under Apache License 2.0 https://www.apache.org/licenses/LICENSE-2.0
 */
/**
 * Lightweight Charts Library v5.0.8
 * Bundled for local use in WebView
 * Source: https://unpkg.com/lightweight-charts@5.0.8/dist/lightweight-charts.standalone.production.js
 */
export const LIGHTWEIGHT_CHARTS_LIBRARY =
  "/* eslint-disable object-shorthand */\n/* eslint-disable prefer-rest-params */\n/* eslint-disable no-prototype-builtins */\n/* eslint-disable no-var */\n/*!\n * @license\n * TradingView Lightweight Charts™ v5.0.8\n * Copyright (c) 2025 TradingView, Inc.\n * Licensed under Apache License 2.0 https://www.apache.org/licenses/LICENSE-2.0\n */\n!(function () {\n  'use strict';\n  const t = {\n    title: '',\n    visible: !0,\n    lastValueVisible: !0,\n    priceLineVisible: !0,\n    priceLineSource: 0,\n    priceLineWidth: 1,\n    priceLineColor: '',\n    priceLineStyle: 2,\n    baseLineVisible: !0,\n    baseLineWidth: 1,\n    baseLineColor: '#B2B5BE',\n    baseLineStyle: 0,\n    priceFormat: { type: 'price', precision: 2, minMove: 0.01 },\n  };\n  var i, s;\n  function n(t, i) {\n    const s = {\n      0: [],\n      1: [t.lineWidth, t.lineWidth],\n      2: [2 * t.lineWidth, 2 * t.lineWidth],\n      3: [6 * t.lineWidth, 6 * t.lineWidth],\n      4: [t.lineWidth, 4 * t.lineWidth],\n    }[i];\n    t.setLineDash(s);\n  }\n  function e(t, i, s, n) {\n    t.beginPath();\n    const e = t.lineWidth % 2 ? 0.5 : 0;\n    t.moveTo(s, i + e), t.lineTo(n, i + e), t.stroke();\n  }\n  function r(t, i) {\n    if (!t) throw new Error('Assertion failed' + (i ? ': ' + i : ''));\n  }\n  function h(t) {\n    if (void 0 === t) throw new Error('Value is undefined');\n    return t;\n  }\n  function a(t) {\n    if (null === t) throw new Error('Value is null');\n    return t;\n  }\n  function l(t) {\n    return a(h(t));\n  }\n  !(function (t) {\n    (t[(t.Simple = 0)] = 'Simple'),\n      (t[(t.WithSteps = 1)] = 'WithSteps'),\n      (t[(t.Curved = 2)] = 'Curved');\n  })(i || (i = {})),\n    (function (t) {\n      (t[(t.Solid = 0)] = 'Solid'),\n        (t[(t.Dotted = 1)] = 'Dotted'),\n        (t[(t.Dashed = 2)] = 'Dashed'),\n        (t[(t.LargeDashed = 3)] = 'LargeDashed'),\n        (t[(t.SparseDotted = 4)] = 'SparseDotted');\n    })(s || (s = {}));\n  class o {\n    constructor() {\n      this.t = [];\n    }\n    i(t, i, s) {\n      const n = { h: t, l: i, o: !0 === s };\n      this.t.push(n);\n    }\n    _(t) {\n      const i = this.t.findIndex((i) => t === i.h);\n      i > -1 && this.t.splice(i, 1);\n    }\n    u(t) {\n      this.t = this.t.filter((i) => i.l !== t);\n    }\n    p(t, i, s) {\n      const n = [...this.t];\n      (this.t = this.t.filter((t) => !t.o)), n.forEach((n) => n.h(t, i, s));\n    }\n    v() {\n      return this.t.length > 0;\n    }\n    m() {\n      this.t = [];\n    }\n  }\n  function _(t, ...i) {\n    for (const s of i)\n      for (const i in s)\n        void 0 !== s[i] &&\n          Object.prototype.hasOwnProperty.call(s, i) &&\n          !['__proto__', 'constructor', 'prototype'].includes(i) &&\n          ('object' != typeof s[i] || void 0 === t[i] || Array.isArray(s[i])\n            ? (t[i] = s[i])\n            : _(t[i], s[i]));\n    return t;\n  }\n  function u(t) {\n    return 'number' == typeof t && isFinite(t);\n  }\n  function c(t) {\n    return 'number' == typeof t && t % 1 == 0;\n  }\n  function d(t) {\n    return 'string' == typeof t;\n  }\n  function f(t) {\n    return 'boolean' == typeof t;\n  }\n  function p(t) {\n    const i = t;\n    if (!i || 'object' != typeof i) return i;\n    let s, n, e;\n    for (n in ((s = Array.isArray(i) ? [] : {}), i))\n      i.hasOwnProperty(n) &&\n        ((e = i[n]), (s[n] = e && 'object' == typeof e ? p(e) : e));\n    return s;\n  }\n  function v(t) {\n    return null !== t;\n  }\n  function m(t) {\n    return null === t ? void 0 : t;\n  }\n  const w =\n    \"-apple-system, BlinkMacSystemFont, 'Trebuchet MS', Roboto, Ubuntu, sans-serif\";\n  function g(t, i, s) {\n    return (\n      void 0 === i && (i = w), `${(s = void 0 !== s ? `${s} ` : '')}${t}px ${i}`\n    );\n  }\n  class M {\n    constructor(t) {\n      (this.M = {\n        S: 1,\n        C: 5,\n        P: NaN,\n        k: '',\n        T: '',\n        R: '',\n        D: '',\n        V: 0,\n        B: 0,\n        I: 0,\n        A: 0,\n        O: 0,\n      }),\n        (this.L = t);\n    }\n    N() {\n      const t = this.M,\n        i = this.W(),\n        s = this.F();\n      return (\n        (t.P === i && t.T === s) ||\n          ((t.P = i),\n          (t.T = s),\n          (t.k = g(i, s)),\n          (t.A = (2.5 / 12) * i),\n          (t.V = t.A),\n          (t.B = (i / 12) * t.C),\n          (t.I = (i / 12) * t.C),\n          (t.O = 0)),\n        (t.R = this.H()),\n        (t.D = this.U()),\n        this.M\n      );\n    }\n    H() {\n      return this.L.N().layout.textColor;\n    }\n    U() {\n      return this.L.$();\n    }\n    W() {\n      return this.L.N().layout.fontSize;\n    }\n    F() {\n      return this.L.N().layout.fontFamily;\n    }\n  }\n  function b(t) {\n    return t < 0 ? 0 : t > 255 ? 255 : Math.round(t) || 0;\n  }\n  function x(t) {\n    return 0.199 * t[0] + 0.687 * t[1] + 0.114 * t[2];\n  }\n  class S {\n    constructor(t, i) {\n      (this.j = new Map()), (this.q = t), i && (this.j = i);\n    }\n    Y(t, i) {\n      if ('transparent' === t) return t;\n      const s = this.K(t),\n        n = s[3];\n      return `rgba(${s[0]}, ${s[1]}, ${s[2]}, ${i * n})`;\n    }\n    X(t) {\n      const i = this.K(t);\n      return {\n        Z: `rgb(${i[0]}, ${i[1]}, ${i[2]})`,\n        G: x(i) > 160 ? 'black' : 'white',\n      };\n    }\n    J(t) {\n      return x(this.K(t));\n    }\n    tt(t, i, s) {\n      const [n, e, r, h] = this.K(t),\n        [a, l, o, _] = this.K(i),\n        u = [\n          b(n + s * (a - n)),\n          b(e + s * (l - e)),\n          b(r + s * (o - r)),\n          ((c = h + s * (_ - h)),\n          c <= 0 || c > 1\n            ? Math.min(Math.max(c, 0), 1)\n            : Math.round(1e4 * c) / 1e4),\n        ];\n      var c;\n      return `rgba(${u[0]}, ${u[1]}, ${u[2]}, ${u[3]})`;\n    }\n    K(t) {\n      const i = this.j.get(t);\n      if (i) return i;\n      const s = (function (t) {\n          const i = document.createElement('div');\n          (i.style.display = 'none'),\n            document.body.appendChild(i),\n            (i.style.color = t);\n          const s = window.getComputedStyle(i).color;\n          return document.body.removeChild(i), s;\n        })(t),\n        n = s.match(\n          /^rgba?\\s*\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*(\\d*\\.?\\d+))?\\)$/,\n        );\n      if (!n) {\n        if (this.q.length)\n          for (const i of this.q) {\n            const s = i(t);\n            if (s) return this.j.set(t, s), s;\n          }\n        throw new Error(`Failed to parse color: ${t}`);\n      }\n      const e = [\n        parseInt(n[1], 10),\n        parseInt(n[2], 10),\n        parseInt(n[3], 10),\n        n[4] ? parseFloat(n[4]) : 1,\n      ];\n      return this.j.set(t, e), e;\n    }\n  }\n  class C {\n    constructor() {\n      this.it = [];\n    }\n    st(t) {\n      this.it = t;\n    }\n    nt(t, i, s) {\n      this.it.forEach((n) => {\n        n.nt(t, i, s);\n      });\n    }\n  }\n  class P {\n    nt(t, i, s) {\n      t.useBitmapCoordinateSpace((t) => this.et(t, i, s));\n    }\n  }\n  class y extends P {\n    constructor() {\n      super(...arguments), (this.rt = null);\n    }\n    ht(t) {\n      this.rt = t;\n    }\n    et({ context: t, horizontalPixelRatio: i, verticalPixelRatio: s }) {\n      if (null === this.rt || null === this.rt.lt) return;\n      const n = this.rt.lt,\n        e = this.rt,\n        r = (Math.max(1, Math.floor(i)) % 2) / 2,\n        h = (h) => {\n          t.beginPath();\n          for (let a = n.to - 1; a >= n.from; --a) {\n            const n = e.ot[a],\n              l = Math.round(n._t * i) + r,\n              o = n.ut * s,\n              _ = h * s + r;\n            t.moveTo(l, o), t.arc(l, o, _, 0, 2 * Math.PI);\n          }\n          t.fill();\n        };\n      e.ct > 0 && ((t.fillStyle = e.dt), h(e.ft + e.ct)),\n        (t.fillStyle = e.vt),\n        h(e.ft);\n    }\n  }\n  function k() {\n    return {\n      ot: [{ _t: 0, ut: 0, wt: 0, gt: 0 }],\n      vt: '',\n      dt: '',\n      ft: 0,\n      ct: 0,\n      lt: null,\n    };\n  }\n  const T = { from: 0, to: 1 };\n  class R {\n    constructor(t, i, s) {\n      (this.Mt = new C()),\n        (this.bt = []),\n        (this.xt = []),\n        (this.St = !0),\n        (this.L = t),\n        (this.Ct = i),\n        (this.Pt = s),\n        this.Mt.st(this.bt);\n    }\n    yt(t) {\n      this.kt(), (this.St = !0);\n    }\n    Tt() {\n      return this.St && (this.Rt(), (this.St = !1)), this.Mt;\n    }\n    kt() {\n      const t = this.Pt.Dt();\n      t.length !== this.bt.length &&\n        ((this.xt = t.map(k)),\n        (this.bt = this.xt.map((t) => {\n          const i = new y();\n          return i.ht(t), i;\n        })),\n        this.Mt.st(this.bt));\n    }\n    Rt() {\n      const t = 2 === this.Ct.N().mode || !this.Ct.Et(),\n        i = this.Pt.Vt(),\n        s = this.Ct.Bt(),\n        n = this.L.It();\n      this.kt(),\n        i.forEach((i, e) => {\n          const r = this.xt[e],\n            h = i.At(s),\n            a = i.zt();\n          !t && null !== h && i.Et() && null !== a\n            ? ((r.vt = h.Ot),\n              (r.ft = h.ft),\n              (r.ct = h.Lt),\n              (r.ot[0].gt = h.gt),\n              (r.ot[0].ut = i.Wt().Nt(h.gt, a.Ft)),\n              (r.dt = h.Ht ?? this.L.Ut(r.ot[0].ut / i.Wt().$t())),\n              (r.ot[0].wt = s),\n              (r.ot[0]._t = n.jt(s)),\n              (r.lt = T))\n            : (r.lt = null);\n        });\n    }\n  }\n  class D extends P {\n    constructor(t) {\n      super(), (this.qt = t);\n    }\n    et({\n      context: t,\n      bitmapSize: i,\n      horizontalPixelRatio: s,\n      verticalPixelRatio: r,\n    }) {\n      if (null === this.qt) return;\n      const h = this.qt.Yt.Et,\n        a = this.qt.Kt.Et;\n      if (!h && !a) return;\n      const l = Math.round(this.qt._t * s),\n        o = Math.round(this.qt.ut * r);\n      (t.lineCap = 'butt'),\n        h &&\n          l >= 0 &&\n          ((t.lineWidth = Math.floor(this.qt.Yt.ct * s)),\n          (t.strokeStyle = this.qt.Yt.R),\n          (t.fillStyle = this.qt.Yt.R),\n          n(t, this.qt.Yt.Xt),\n          (function (t, i, s, n) {\n            t.beginPath();\n            const e = t.lineWidth % 2 ? 0.5 : 0;\n            t.moveTo(i + e, s), t.lineTo(i + e, n), t.stroke();\n          })(t, l, 0, i.height)),\n        a &&\n          o >= 0 &&\n          ((t.lineWidth = Math.floor(this.qt.Kt.ct * r)),\n          (t.strokeStyle = this.qt.Kt.R),\n          (t.fillStyle = this.qt.Kt.R),\n          n(t, this.qt.Kt.Xt),\n          e(t, o, 0, i.width));\n    }\n  }\n  class E {\n    constructor(t, i) {\n      (this.St = !0),\n        (this.Zt = {\n          Yt: { ct: 1, Xt: 0, R: '', Et: !1 },\n          Kt: { ct: 1, Xt: 0, R: '', Et: !1 },\n          _t: 0,\n          ut: 0,\n        }),\n        (this.Gt = new D(this.Zt)),\n        (this.Jt = t),\n        (this.Pt = i);\n    }\n    yt() {\n      this.St = !0;\n    }\n    Tt(t) {\n      return this.St && (this.Rt(), (this.St = !1)), this.Gt;\n    }\n    Rt() {\n      const t = this.Jt.Et(),\n        i = this.Pt.Qt().N().crosshair,\n        s = this.Zt;\n      if (2 === i.mode) return (s.Kt.Et = !1), void (s.Yt.Et = !1);\n      (s.Kt.Et = t && this.Jt.ti(this.Pt)),\n        (s.Yt.Et = t && this.Jt.ii()),\n        (s.Kt.ct = i.horzLine.width),\n        (s.Kt.Xt = i.horzLine.style),\n        (s.Kt.R = i.horzLine.color),\n        (s.Yt.ct = i.vertLine.width),\n        (s.Yt.Xt = i.vertLine.style),\n        (s.Yt.R = i.vertLine.color),\n        (s._t = this.Jt.si()),\n        (s.ut = this.Jt.ni());\n    }\n  }\n  function V(t, i, s, n, e, r) {\n    t.fillRect(i + r, s, n - 2 * r, r),\n      t.fillRect(i + r, s + e - r, n - 2 * r, r),\n      t.fillRect(i, s, r, e),\n      t.fillRect(i + n - r, s, r, e);\n  }\n  function B(t, i, s, n, e, r) {\n    t.save(),\n      (t.globalCompositeOperation = 'copy'),\n      (t.fillStyle = r),\n      t.fillRect(i, s, n, e),\n      t.restore();\n  }\n  function I(t, i, s, n, e, r) {\n    t.beginPath(),\n      t.roundRect\n        ? t.roundRect(i, s, n, e, r)\n        : (t.lineTo(i + n - r[1], s),\n          0 !== r[1] && t.arcTo(i + n, s, i + n, s + r[1], r[1]),\n          t.lineTo(i + n, s + e - r[2]),\n          0 !== r[2] && t.arcTo(i + n, s + e, i + n - r[2], s + e, r[2]),\n          t.lineTo(i + r[3], s + e),\n          0 !== r[3] && t.arcTo(i, s + e, i, s + e - r[3], r[3]),\n          t.lineTo(i, s + r[0]),\n          0 !== r[0] && t.arcTo(i, s, i + r[0], s, r[0]));\n  }\n  function A(t, i, s, n, e, r, h = 0, a = [0, 0, 0, 0], l = '') {\n    if ((t.save(), !h || !l || l === r))\n      return I(t, i, s, n, e, a), (t.fillStyle = r), t.fill(), void t.restore();\n    const o = h / 2;\n    var _;\n    I(\n      t,\n      i + o,\n      s + o,\n      n - h,\n      e - h,\n      ((_ = -o), a.map((t) => (0 === t ? t : t + _))),\n    ),\n      'transparent' !== r && ((t.fillStyle = r), t.fill()),\n      'transparent' !== l &&\n        ((t.lineWidth = h), (t.strokeStyle = l), t.closePath(), t.stroke()),\n      t.restore();\n  }\n  function z(t, i, s, n, e, r, h) {\n    t.save(), (t.globalCompositeOperation = 'copy');\n    const a = t.createLinearGradient(0, 0, 0, e);\n    a.addColorStop(0, r),\n      a.addColorStop(1, h),\n      (t.fillStyle = a),\n      t.fillRect(i, s, n, e),\n      t.restore();\n  }\n  class O {\n    constructor(t, i) {\n      this.ht(t, i);\n    }\n    ht(t, i) {\n      (this.qt = t), (this.ei = i);\n    }\n    $t(t, i) {\n      return this.qt.Et ? t.P + t.A + t.V : 0;\n    }\n    nt(t, i, s, n) {\n      if (!this.qt.Et || 0 === this.qt.ri.length) return;\n      const e = this.qt.R,\n        r = this.ei.Z,\n        h = t.useBitmapCoordinateSpace((t) => {\n          const h = t.context;\n          h.font = i.k;\n          const a = this.hi(t, i, s, n),\n            l = a.ai;\n          return (\n            a.li\n              ? A(h, l.oi, l._i, l.ui, l.ci, r, l.di, [l.ft, 0, 0, l.ft], r)\n              : A(h, l.fi, l._i, l.ui, l.ci, r, l.di, [0, l.ft, l.ft, 0], r),\n            this.qt.pi &&\n              ((h.fillStyle = e), h.fillRect(l.fi, l.mi, l.wi - l.fi, l.gi)),\n            this.qt.Mi &&\n              ((h.fillStyle = i.D),\n              h.fillRect(a.li ? l.bi - l.di : 0, l._i, l.di, l.xi - l._i)),\n            a\n          );\n        });\n      t.useMediaCoordinateSpace(({ context: t }) => {\n        const s = h.Si;\n        (t.font = i.k),\n          (t.textAlign = h.li ? 'right' : 'left'),\n          (t.textBaseline = 'middle'),\n          (t.fillStyle = e),\n          t.fillText(this.qt.ri, s.Ci, (s._i + s.xi) / 2 + s.Pi);\n      });\n    }\n    hi(t, i, s, n) {\n      const {\n          context: e,\n          bitmapSize: r,\n          mediaSize: h,\n          horizontalPixelRatio: a,\n          verticalPixelRatio: l,\n        } = t,\n        o = this.qt.pi || !this.qt.yi ? i.C : 0,\n        _ = this.qt.ki ? i.S : 0,\n        u = i.A + this.ei.Ti,\n        c = i.V + this.ei.Ri,\n        d = i.B,\n        f = i.I,\n        p = this.qt.ri,\n        v = i.P,\n        m = s.Di(e, p),\n        w = Math.ceil(s.Ei(e, p)),\n        g = v + u + c,\n        M = i.S + d + f + w + o,\n        b = Math.max(1, Math.floor(l));\n      let x = Math.round(g * l);\n      x % 2 != b % 2 && (x += 1);\n      const S = _ > 0 ? Math.max(1, Math.floor(_ * a)) : 0,\n        C = Math.round(M * a),\n        P = Math.round(o * a),\n        y = this.ei.Vi ?? this.ei.Bi,\n        k = Math.round(y * l) - Math.floor(0.5 * l),\n        T = Math.floor(k + b / 2 - x / 2),\n        R = T + x,\n        D = 'right' === n,\n        E = D ? h.width - _ : _,\n        V = D ? r.width - S : S;\n      let B, I, A;\n      return (\n        D\n          ? ((B = V - C), (I = V - P), (A = E - o - d - _))\n          : ((B = V + C), (I = V + P), (A = E + o + d)),\n        {\n          li: D,\n          ai: {\n            _i: T,\n            mi: k,\n            xi: R,\n            ui: C,\n            ci: x,\n            ft: 2 * a,\n            di: S,\n            oi: B,\n            fi: V,\n            wi: I,\n            gi: b,\n            bi: r.width,\n          },\n          Si: { _i: T / l, xi: R / l, Ci: A, Pi: m },\n        }\n      );\n    }\n  }\n  class L {\n    constructor(t) {\n      (this.Ii = { Bi: 0, Z: '#000', Ri: 0, Ti: 0 }),\n        (this.Ai = {\n          ri: '',\n          Et: !1,\n          pi: !0,\n          yi: !1,\n          Ht: '',\n          R: '#FFF',\n          Mi: !1,\n          ki: !1,\n        }),\n        (this.zi = {\n          ri: '',\n          Et: !1,\n          pi: !1,\n          yi: !0,\n          Ht: '',\n          R: '#FFF',\n          Mi: !0,\n          ki: !0,\n        }),\n        (this.St = !0),\n        (this.Oi = new (t || O)(this.Ai, this.Ii)),\n        (this.Li = new (t || O)(this.zi, this.Ii));\n    }\n    ri() {\n      return this.Ni(), this.Ai.ri;\n    }\n    Bi() {\n      return this.Ni(), this.Ii.Bi;\n    }\n    yt() {\n      this.St = !0;\n    }\n    $t(t, i = !1) {\n      return Math.max(this.Oi.$t(t, i), this.Li.$t(t, i));\n    }\n    Wi() {\n      return this.Ii.Vi || 0;\n    }\n    Fi(t) {\n      this.Ii.Vi = t;\n    }\n    Hi() {\n      return this.Ni(), this.Ai.Et || this.zi.Et;\n    }\n    Ui() {\n      return this.Ni(), this.Ai.Et;\n    }\n    Tt(t) {\n      return (\n        this.Ni(),\n        (this.Ai.pi = this.Ai.pi && t.N().ticksVisible),\n        (this.zi.pi = this.zi.pi && t.N().ticksVisible),\n        this.Oi.ht(this.Ai, this.Ii),\n        this.Li.ht(this.zi, this.Ii),\n        this.Oi\n      );\n    }\n    $i() {\n      return (\n        this.Ni(),\n        this.Oi.ht(this.Ai, this.Ii),\n        this.Li.ht(this.zi, this.Ii),\n        this.Li\n      );\n    }\n    Ni() {\n      this.St &&\n        ((this.Ai.pi = !0),\n        (this.zi.pi = !1),\n        this.ji(this.Ai, this.zi, this.Ii));\n    }\n  }\n  class N extends L {\n    constructor(t, i, s) {\n      super(), (this.Jt = t), (this.qi = i), (this.Yi = s);\n    }\n    ji(t, i, s) {\n      if (((t.Et = !1), 2 === this.Jt.N().mode)) return;\n      const n = this.Jt.N().horzLine;\n      if (!n.labelVisible) return;\n      const e = this.qi.zt();\n      if (!this.Jt.Et() || this.qi.Ki() || null === e) return;\n      const r = this.qi.Xi().X(n.labelBackgroundColor);\n      (s.Z = r.Z), (t.R = r.G);\n      const h = (2 / 12) * this.qi.P();\n      (s.Ti = h), (s.Ri = h);\n      const a = this.Yi(this.qi);\n      (s.Bi = a.Bi), (t.ri = this.qi.Zi(a.gt, e)), (t.Et = !0);\n    }\n  }\n  const W = /[1-9]/g;\n  class F {\n    constructor() {\n      this.qt = null;\n    }\n    ht(t) {\n      this.qt = t;\n    }\n    nt(t, i) {\n      if (null === this.qt || !1 === this.qt.Et || 0 === this.qt.ri.length)\n        return;\n      const s = t.useMediaCoordinateSpace(\n        ({ context: t }) => (\n          (t.font = i.k), Math.round(i.Gi.Ei(t, a(this.qt).ri, W))\n        ),\n      );\n      if (s <= 0) return;\n      const n = i.Ji,\n        e = s + 2 * n,\n        r = e / 2,\n        h = this.qt.Qi;\n      let l = this.qt.Bi,\n        o = Math.floor(l - r) + 0.5;\n      o < 0\n        ? ((l += Math.abs(0 - o)), (o = Math.floor(l - r) + 0.5))\n        : o + e > h &&\n          ((l -= Math.abs(h - (o + e))), (o = Math.floor(l - r) + 0.5));\n      const _ = o + e,\n        u = Math.ceil(0 + i.S + i.C + i.A + i.P + i.V);\n      t.useBitmapCoordinateSpace(\n        ({ context: t, horizontalPixelRatio: s, verticalPixelRatio: n }) => {\n          const e = a(this.qt);\n          t.fillStyle = e.Z;\n          const r = Math.round(o * s),\n            h = Math.round(0 * n),\n            l = Math.round(_ * s),\n            c = Math.round(u * n),\n            d = Math.round(2 * s);\n          if (\n            (t.beginPath(),\n            t.moveTo(r, h),\n            t.lineTo(r, c - d),\n            t.arcTo(r, c, r + d, c, d),\n            t.lineTo(l - d, c),\n            t.arcTo(l, c, l, c - d, d),\n            t.lineTo(l, h),\n            t.fill(),\n            e.pi)\n          ) {\n            const r = Math.round(e.Bi * s),\n              a = h,\n              l = Math.round((a + i.C) * n);\n            t.fillStyle = e.R;\n            const o = Math.max(1, Math.floor(s)),\n              _ = Math.floor(0.5 * s);\n            t.fillRect(r - _, a, o, l - a);\n          }\n        },\n      ),\n        t.useMediaCoordinateSpace(({ context: t }) => {\n          const s = a(this.qt),\n            e = 0 + i.S + i.C + i.A + i.P / 2;\n          (t.font = i.k),\n            (t.textAlign = 'left'),\n            (t.textBaseline = 'middle'),\n            (t.fillStyle = s.R);\n          const r = i.Gi.Di(t, 'Apr0');\n          t.translate(o + n, e + r), t.fillText(s.ri, 0, 0);\n        });\n    }\n  }\n  class H {\n    constructor(t, i, s) {\n      (this.St = !0),\n        (this.Gt = new F()),\n        (this.Zt = {\n          Et: !1,\n          Z: '#4c525e',\n          R: 'white',\n          ri: '',\n          Qi: 0,\n          Bi: NaN,\n          pi: !0,\n        }),\n        (this.Ct = t),\n        (this.ts = i),\n        (this.Yi = s);\n    }\n    yt() {\n      this.St = !0;\n    }\n    Tt() {\n      return (\n        this.St && (this.Rt(), (this.St = !1)), this.Gt.ht(this.Zt), this.Gt\n      );\n    }\n    Rt() {\n      const t = this.Zt;\n      if (((t.Et = !1), 2 === this.Ct.N().mode)) return;\n      const i = this.Ct.N().vertLine;\n      if (!i.labelVisible) return;\n      const s = this.ts.It();\n      if (s.Ki()) return;\n      t.Qi = s.Qi();\n      const n = this.Yi();\n      if (null === n) return;\n      t.Bi = n.Bi;\n      const e = s.ss(this.Ct.Bt());\n      (t.ri = s.ns(a(e))), (t.Et = !0);\n      const r = this.ts.Xi().X(i.labelBackgroundColor);\n      (t.Z = r.Z), (t.R = r.G), (t.pi = s.N().ticksVisible);\n    }\n  }\n  class U {\n    constructor() {\n      (this.es = null), (this.rs = 0);\n    }\n    hs() {\n      return this.rs;\n    }\n    ls(t) {\n      this.rs = t;\n    }\n    Wt() {\n      return this.es;\n    }\n    _s(t) {\n      this.es = t;\n    }\n    us(t) {\n      return [];\n    }\n    cs() {\n      return [];\n    }\n    Et() {\n      return !0;\n    }\n  }\n  var $;\n  !(function (t) {\n    (t[(t.Normal = 0)] = 'Normal'),\n      (t[(t.Magnet = 1)] = 'Magnet'),\n      (t[(t.Hidden = 2)] = 'Hidden'),\n      (t[(t.MagnetOHLC = 3)] = 'MagnetOHLC');\n  })($ || ($ = {}));\n  class j extends U {\n    constructor(t, i) {\n      super(),\n        (this.Pt = null),\n        (this.ds = NaN),\n        (this.fs = 0),\n        (this.ps = !1),\n        (this.vs = new Map()),\n        (this.ws = !1),\n        (this.gs = new WeakMap()),\n        (this.Ms = new WeakMap()),\n        (this.bs = NaN),\n        (this.xs = NaN),\n        (this.Ss = NaN),\n        (this.Cs = NaN),\n        (this.ts = t),\n        (this.Ps = i);\n      this.ys = ((t, i) => (s) => {\n        const n = i(),\n          e = t();\n        if (s === a(this.Pt).ks()) return { gt: e, Bi: n };\n        {\n          const t = a(s.zt());\n          return { gt: s.Ts(n, t), Bi: n };\n        }\n      })(\n        () => this.ds,\n        () => this.xs,\n      );\n      const s = ((t, i) => () => {\n        const s = this.ts.It().Rs(t()),\n          n = i();\n        return s && Number.isFinite(n) ? { wt: s, Bi: n } : null;\n      })(\n        () => this.fs,\n        () => this.si(),\n      );\n      this.Ds = new H(this, t, s);\n    }\n    N() {\n      return this.Ps;\n    }\n    Es(t, i) {\n      (this.Ss = t), (this.Cs = i);\n    }\n    Vs() {\n      (this.Ss = NaN), (this.Cs = NaN);\n    }\n    Bs() {\n      return this.Ss;\n    }\n    Is() {\n      return this.Cs;\n    }\n    As(t, i, s) {\n      this.ws || (this.ws = !0), (this.ps = !0), this.zs(t, i, s);\n    }\n    Bt() {\n      return this.fs;\n    }\n    si() {\n      return this.bs;\n    }\n    ni() {\n      return this.xs;\n    }\n    Et() {\n      return this.ps;\n    }\n    Os() {\n      (this.ps = !1),\n        this.Ls(),\n        (this.ds = NaN),\n        (this.bs = NaN),\n        (this.xs = NaN),\n        (this.Pt = null),\n        this.Vs(),\n        this.Ns();\n    }\n    Ws(t) {\n      let i = this.gs.get(t);\n      i || ((i = new E(this, t)), this.gs.set(t, i));\n      let s = this.Ms.get(t);\n      return s || ((s = new R(this.ts, this, t)), this.Ms.set(t, s)), [i, s];\n    }\n    ti(t) {\n      return t === this.Pt && this.Ps.horzLine.visible;\n    }\n    ii() {\n      return this.Ps.vertLine.visible;\n    }\n    Fs(t, i) {\n      (this.ps && this.Pt === t) || this.vs.clear();\n      const s = [];\n      return this.Pt === t && s.push(this.Hs(this.vs, i, this.ys)), s;\n    }\n    cs() {\n      return this.ps ? [this.Ds] : [];\n    }\n    Us() {\n      return this.Pt;\n    }\n    Ns() {\n      this.ts.$s().forEach((t) => {\n        this.gs.get(t)?.yt(), this.Ms.get(t)?.yt();\n      }),\n        this.vs.forEach((t) => t.yt()),\n        this.Ds.yt();\n    }\n    js(t) {\n      return t && !t.ks().Ki() ? t.ks() : null;\n    }\n    zs(t, i, s) {\n      this.qs(t, i, s) && this.Ns();\n    }\n    qs(t, i, s) {\n      const n = this.bs,\n        e = this.xs,\n        r = this.ds,\n        h = this.fs,\n        a = this.Pt,\n        l = this.js(s);\n      (this.fs = t),\n        (this.bs = isNaN(t) ? NaN : this.ts.It().jt(t)),\n        (this.Pt = s);\n      const o = null !== l ? l.zt() : null;\n      return (\n        null !== l && null !== o\n          ? ((this.ds = i), (this.xs = l.Nt(i, o)))\n          : ((this.ds = NaN), (this.xs = NaN)),\n        n !== this.bs ||\n          e !== this.xs ||\n          h !== this.fs ||\n          r !== this.ds ||\n          a !== this.Pt\n      );\n    }\n    Ls() {\n      const t = this.ts\n          .Ys()\n          .map((t) => t.Xs().Ks())\n          .filter(v),\n        i = 0 === t.length ? null : Math.max(...t);\n      this.fs = null !== i ? i : NaN;\n    }\n    Hs(t, i, s) {\n      let n = t.get(i);\n      return void 0 === n && ((n = new N(this, i, s)), t.set(i, n)), n;\n    }\n  }\n  function q(t) {\n    return 'left' === t || 'right' === t;\n  }\n  class Y {\n    constructor(t) {\n      (this.Zs = new Map()), (this.Gs = []), (this.Js = t);\n    }\n    Qs(t, i) {\n      const s = (function (t, i) {\n        return void 0 === t\n          ? i\n          : { tn: Math.max(t.tn, i.tn), sn: t.sn || i.sn };\n      })(this.Zs.get(t), i);\n      this.Zs.set(t, s);\n    }\n    nn() {\n      return this.Js;\n    }\n    en(t) {\n      const i = this.Zs.get(t);\n      return void 0 === i\n        ? { tn: this.Js }\n        : { tn: Math.max(this.Js, i.tn), sn: i.sn };\n    }\n    rn() {\n      this.hn(), (this.Gs = [{ an: 0 }]);\n    }\n    ln(t) {\n      this.hn(), (this.Gs = [{ an: 1, Ft: t }]);\n    }\n    _n(t) {\n      this.un(), this.Gs.push({ an: 5, Ft: t });\n    }\n    hn() {\n      this.un(), this.Gs.push({ an: 6 });\n    }\n    cn() {\n      this.hn(), (this.Gs = [{ an: 4 }]);\n    }\n    dn(t) {\n      this.hn(), this.Gs.push({ an: 2, Ft: t });\n    }\n    fn(t) {\n      this.hn(), this.Gs.push({ an: 3, Ft: t });\n    }\n    pn() {\n      return this.Gs;\n    }\n    vn(t) {\n      for (const i of t.Gs) this.mn(i);\n      (this.Js = Math.max(this.Js, t.Js)),\n        t.Zs.forEach((t, i) => {\n          this.Qs(i, t);\n        });\n    }\n    static wn() {\n      return new Y(2);\n    }\n    static gn() {\n      return new Y(3);\n    }\n    mn(t) {\n      switch (t.an) {\n        case 0:\n          this.rn();\n          break;\n        case 1:\n          this.ln(t.Ft);\n          break;\n        case 2:\n          this.dn(t.Ft);\n          break;\n        case 3:\n          this.fn(t.Ft);\n          break;\n        case 4:\n          this.cn();\n          break;\n        case 5:\n          this._n(t.Ft);\n          break;\n        case 6:\n          this.un();\n      }\n    }\n    un() {\n      const t = this.Gs.findIndex((t) => 5 === t.an);\n      -1 !== t && this.Gs.splice(t, 1);\n    }\n  }\n  class K {\n    formatTickmarks(t) {\n      return t.map((t) => this.format(t));\n    }\n  }\n  const X = '.';\n  function Z(t, i) {\n    if (!u(t)) return 'n/a';\n    if (!c(i)) throw new TypeError('invalid length');\n    if (i < 0 || i > 16) throw new TypeError('invalid length');\n    if (0 === i) return t.toString();\n    return ('0000000000000000' + t.toString()).slice(-i);\n  }\n  class G extends K {\n    constructor(t, i) {\n      if ((super(), i || (i = 1), (u(t) && c(t)) || (t = 100), t < 0))\n        throw new TypeError('invalid base');\n      (this.qi = t), (this.Mn = i), this.bn();\n    }\n    format(t) {\n      const i = t < 0 ? '−' : '';\n      return (t = Math.abs(t)), i + this.xn(t);\n    }\n    bn() {\n      if (((this.Sn = 0), this.qi > 0 && this.Mn > 0)) {\n        let t = this.qi;\n        for (; t > 1; ) (t /= 10), this.Sn++;\n      }\n    }\n    xn(t) {\n      const i = this.qi / this.Mn;\n      let s = Math.floor(t),\n        n = '';\n      const e = void 0 !== this.Sn ? this.Sn : NaN;\n      if (i > 1) {\n        let r = +(Math.round(t * i) - s * i).toFixed(this.Sn);\n        r >= i && ((r -= i), (s += 1)),\n          (n = X + Z(+r.toFixed(this.Sn) * this.Mn, e));\n      } else (s = Math.round(s * i) / i), e > 0 && (n = X + Z(0, e));\n      return s.toFixed(0) + n;\n    }\n  }\n  class J extends G {\n    constructor(t = 100) {\n      super(t);\n    }\n    format(t) {\n      return `${super.format(t)}%`;\n    }\n  }\n  class Q extends K {\n    constructor(t) {\n      super(), (this.Cn = t);\n    }\n    format(t) {\n      let i = '';\n      return (\n        t < 0 && ((i = '-'), (t = -t)),\n        t < 995\n          ? i + this.Pn(t)\n          : t < 999995\n          ? i + this.Pn(t / 1e3) + 'K'\n          : t < 999999995\n          ? ((t = 1e3 * Math.round(t / 1e3)), i + this.Pn(t / 1e6) + 'M')\n          : ((t = 1e6 * Math.round(t / 1e6)), i + this.Pn(t / 1e9) + 'B')\n      );\n    }\n    Pn(t) {\n      let i;\n      const s = Math.pow(10, this.Cn);\n      return (\n        (i =\n          (t = Math.round(t * s) / s) >= 1e-15 && t < 1\n            ? t.toFixed(this.Cn).replace(/\\.?0+$/, '')\n            : String(t)),\n        i.replace(/(\\.[1-9]*)0+$/, (t, i) => i)\n      );\n    }\n  }\n  const tt = /[2-9]/g;\n  class it {\n    constructor(t = 50) {\n      (this.yn = 0),\n        (this.kn = 1),\n        (this.Tn = 1),\n        (this.Rn = {}),\n        (this.Dn = new Map()),\n        (this.En = t);\n    }\n    Vn() {\n      (this.yn = 0),\n        this.Dn.clear(),\n        (this.kn = 1),\n        (this.Tn = 1),\n        (this.Rn = {});\n    }\n    Ei(t, i, s) {\n      return this.Bn(t, i, s).width;\n    }\n    Di(t, i, s) {\n      const n = this.Bn(t, i, s);\n      return (\n        ((n.actualBoundingBoxAscent || 0) - (n.actualBoundingBoxDescent || 0)) /\n        2\n      );\n    }\n    Bn(t, i, s) {\n      const n = s || tt,\n        e = String(i).replace(n, '0');\n      if (this.Dn.has(e)) return h(this.Dn.get(e)).In;\n      if (this.yn === this.En) {\n        const t = this.Rn[this.Tn];\n        delete this.Rn[this.Tn], this.Dn.delete(t), this.Tn++, this.yn--;\n      }\n      t.save(), (t.textBaseline = 'middle');\n      const r = t.measureText(e);\n      return (\n        t.restore(),\n        (0 === r.width && i.length) ||\n          (this.Dn.set(e, { In: r, An: this.kn }),\n          (this.Rn[this.kn] = e),\n          this.yn++,\n          this.kn++),\n        r\n      );\n    }\n  }\n  class st {\n    constructor(t) {\n      (this.zn = null), (this.M = null), (this.On = 'right'), (this.Ln = t);\n    }\n    Nn(t, i, s) {\n      (this.zn = t), (this.M = i), (this.On = s);\n    }\n    nt(t) {\n      null !== this.M &&\n        null !== this.zn &&\n        this.zn.nt(t, this.M, this.Ln, this.On);\n    }\n  }\n  class nt {\n    constructor(t, i, s) {\n      (this.Wn = t),\n        (this.Ln = new it(50)),\n        (this.Fn = i),\n        (this.L = s),\n        (this.W = -1),\n        (this.Gt = new st(this.Ln));\n    }\n    Tt() {\n      const t = this.L.Hn(this.Fn);\n      if (null === t) return null;\n      const i = t.Un(this.Fn) ? t.$n() : this.Fn.Wt();\n      if (null === i) return null;\n      const s = t.jn(i);\n      if ('overlay' === s) return null;\n      const n = this.L.qn();\n      return (\n        n.P !== this.W && ((this.W = n.P), this.Ln.Vn()),\n        this.Gt.Nn(this.Wn.$i(), n, s),\n        this.Gt\n      );\n    }\n  }\n  class et extends P {\n    constructor() {\n      super(...arguments), (this.qt = null);\n    }\n    ht(t) {\n      this.qt = t;\n    }\n    Yn(t, i) {\n      if (!this.qt?.Et) return null;\n      const { ut: s, ct: n, Kn: e } = this.qt;\n      return i >= s - n - 7 && i <= s + n + 7 ? { Xn: this.qt, Kn: e } : null;\n    }\n    et({\n      context: t,\n      bitmapSize: i,\n      horizontalPixelRatio: s,\n      verticalPixelRatio: r,\n    }) {\n      if (null === this.qt) return;\n      if (!1 === this.qt.Et) return;\n      const h = Math.round(this.qt.ut * r);\n      h < 0 ||\n        h > i.height ||\n        ((t.lineCap = 'butt'),\n        (t.strokeStyle = this.qt.R),\n        (t.lineWidth = Math.floor(this.qt.ct * s)),\n        n(t, this.qt.Xt),\n        e(t, h, 0, i.width));\n    }\n  }\n  class rt {\n    constructor(t) {\n      (this.Zn = { ut: 0, R: 'rgba(0, 0, 0, 0)', ct: 1, Xt: 0, Et: !1 }),\n        (this.Gn = new et()),\n        (this.St = !0),\n        (this.Jn = t),\n        (this.Qn = t.Qt()),\n        this.Gn.ht(this.Zn);\n    }\n    yt() {\n      this.St = !0;\n    }\n    Tt() {\n      return this.Jn.Et()\n        ? (this.St && (this.te(), (this.St = !1)), this.Gn)\n        : null;\n    }\n  }\n  class ht extends rt {\n    constructor(t) {\n      super(t);\n    }\n    te() {\n      this.Zn.Et = !1;\n      const t = this.Jn.Wt(),\n        i = t.ie().ie;\n      if (2 !== i && 3 !== i) return;\n      const s = this.Jn.N();\n      if (!s.baseLineVisible || !this.Jn.Et()) return;\n      const n = this.Jn.zt();\n      null !== n &&\n        ((this.Zn.Et = !0),\n        (this.Zn.ut = t.Nt(n.Ft, n.Ft)),\n        (this.Zn.R = s.baseLineColor),\n        (this.Zn.ct = s.baseLineWidth),\n        (this.Zn.Xt = s.baseLineStyle));\n    }\n  }\n  class at extends P {\n    constructor() {\n      super(...arguments), (this.qt = null);\n    }\n    ht(t) {\n      this.qt = t;\n    }\n    se() {\n      return this.qt;\n    }\n    et({ context: t, horizontalPixelRatio: i, verticalPixelRatio: s }) {\n      const n = this.qt;\n      if (null === n) return;\n      const e = Math.max(1, Math.floor(i)),\n        r = (e % 2) / 2,\n        h = Math.round(n.ne.x * i) + r,\n        a = n.ne.y * s;\n      (t.fillStyle = n.ee), t.beginPath();\n      const l = Math.max(2, 1.5 * n.re) * i;\n      t.arc(h, a, l, 0, 2 * Math.PI, !1),\n        t.fill(),\n        (t.fillStyle = n.he),\n        t.beginPath(),\n        t.arc(h, a, n.ft * i, 0, 2 * Math.PI, !1),\n        t.fill(),\n        (t.lineWidth = e),\n        (t.strokeStyle = n.ae),\n        t.beginPath(),\n        t.arc(h, a, n.ft * i + e / 2, 0, 2 * Math.PI, !1),\n        t.stroke();\n    }\n  }\n  const lt = [\n    { le: 0, oe: 0.25, _e: 4, ue: 10, ce: 0.25, de: 0, fe: 0.4, pe: 0.8 },\n    { le: 0.25, oe: 0.525, _e: 10, ue: 14, ce: 0, de: 0, fe: 0.8, pe: 0 },\n    { le: 0.525, oe: 1, _e: 14, ue: 14, ce: 0, de: 0, fe: 0, pe: 0 },\n  ];\n  class ot {\n    constructor(t) {\n      (this.Gt = new at()),\n        (this.St = !0),\n        (this.ve = !0),\n        (this.me = performance.now()),\n        (this.we = this.me - 1),\n        (this.ge = t);\n    }\n    Me() {\n      (this.we = this.me - 1), this.yt();\n    }\n    be() {\n      if ((this.yt(), 2 === this.ge.N().lastPriceAnimation)) {\n        const t = performance.now(),\n          i = this.we - t;\n        if (i > 0) return void (i < 650 && (this.we += 2600));\n        (this.me = t), (this.we = t + 2600);\n      }\n    }\n    yt() {\n      this.St = !0;\n    }\n    xe() {\n      this.ve = !0;\n    }\n    Et() {\n      return 0 !== this.ge.N().lastPriceAnimation;\n    }\n    Se() {\n      switch (this.ge.N().lastPriceAnimation) {\n        case 0:\n          return !1;\n        case 1:\n          return !0;\n        case 2:\n          return performance.now() <= this.we;\n      }\n    }\n    Tt() {\n      return (\n        this.St\n          ? (this.Rt(), (this.St = !1), (this.ve = !1))\n          : this.ve && (this.Ce(), (this.ve = !1)),\n        this.Gt\n      );\n    }\n    Rt() {\n      this.Gt.ht(null);\n      const t = this.ge.Qt().It(),\n        i = t.Pe(),\n        s = this.ge.zt();\n      if (null === i || null === s) return;\n      const n = this.ge.ye(!0);\n      if (n.ke || !i.Te(n.Re)) return;\n      const e = { x: t.jt(n.Re), y: this.ge.Wt().Nt(n.gt, s.Ft) },\n        r = n.R,\n        h = this.ge.N().lineWidth,\n        a = this.De(this.Ee(), r);\n      this.Gt.ht({ ee: r, re: h, he: a.he, ae: a.ae, ft: a.ft, ne: e });\n    }\n    Ce() {\n      const t = this.Gt.se();\n      if (null !== t) {\n        const i = this.De(this.Ee(), t.ee);\n        (t.he = i.he), (t.ae = i.ae), (t.ft = i.ft);\n      }\n    }\n    Ee() {\n      return this.Se() ? performance.now() - this.me : 2599;\n    }\n    Ve(t, i, s, n) {\n      const e = s + (n - s) * i;\n      return this.ge.Qt().Xi().Y(t, e);\n    }\n    De(t, i) {\n      const s = (t % 2600) / 2600;\n      let n;\n      for (const t of lt)\n        if (s >= t.le && s <= t.oe) {\n          n = t;\n          break;\n        }\n      r(void 0 !== n, 'Last price animation internal logic error');\n      const e = (s - n.le) / (n.oe - n.le);\n      return {\n        he: this.Ve(i, e, n.ce, n.de),\n        ae: this.Ve(i, e, n.fe, n.pe),\n        ft: ((h = e), (a = n._e), (l = n.ue), a + (l - a) * h),\n      };\n      var h, a, l;\n    }\n  }\n  class _t extends rt {\n    constructor(t) {\n      super(t);\n    }\n    te() {\n      const t = this.Zn;\n      t.Et = !1;\n      const i = this.Jn.N();\n      if (!i.priceLineVisible || !this.Jn.Et()) return;\n      const s = this.Jn.ye(0 === i.priceLineSource);\n      s.ke ||\n        ((t.Et = !0),\n        (t.ut = s.Bi),\n        (t.R = this.Jn.Be(s.R)),\n        (t.ct = i.priceLineWidth),\n        (t.Xt = i.priceLineStyle));\n    }\n  }\n  class ut extends L {\n    constructor(t) {\n      super(), (this.Jt = t);\n    }\n    ji(t, i, s) {\n      (t.Et = !1), (i.Et = !1);\n      const n = this.Jt;\n      if (!n.Et()) return;\n      const e = n.N(),\n        r = e.lastValueVisible,\n        h = '' !== n.Ie(),\n        a = 0 === e.seriesLastValueMode,\n        l = n.ye(!1);\n      if (l.ke) return;\n      r && ((t.ri = this.Ae(l, r, a)), (t.Et = 0 !== t.ri.length)),\n        (h || a) && ((i.ri = this.ze(l, r, h, a)), (i.Et = i.ri.length > 0));\n      const o = n.Be(l.R),\n        _ = this.Jt.Qt().Xi().X(o);\n      (s.Z = _.Z),\n        (s.Bi = l.Bi),\n        (i.Ht = n.Qt().Ut(l.Bi / n.Wt().$t())),\n        (t.Ht = o),\n        (t.R = _.G),\n        (i.R = _.G);\n    }\n    ze(t, i, s, n) {\n      let e = '';\n      const r = this.Jt.Ie();\n      return (\n        s && 0 !== r.length && (e += `${r} `),\n        i && n && (e += this.Jt.Wt().Oe() ? t.Le : t.Ne),\n        e.trim()\n      );\n    }\n    Ae(t, i, s) {\n      return i ? (s ? (this.Jt.Wt().Oe() ? t.Ne : t.Le) : t.ri) : '';\n    }\n  }\n  function ct(t, i, s, n) {\n    const e = Number.isFinite(i),\n      r = Number.isFinite(s);\n    return e && r ? t(i, s) : e || r ? (e ? i : s) : n;\n  }\n  class dt {\n    constructor(t, i) {\n      (this.We = t), (this.Fe = i);\n    }\n    He(t) {\n      return null !== t && this.We === t.We && this.Fe === t.Fe;\n    }\n    Ue() {\n      return new dt(this.We, this.Fe);\n    }\n    $e() {\n      return this.We;\n    }\n    je() {\n      return this.Fe;\n    }\n    qe() {\n      return this.Fe - this.We;\n    }\n    Ki() {\n      return (\n        this.Fe === this.We || Number.isNaN(this.Fe) || Number.isNaN(this.We)\n      );\n    }\n    vn(t) {\n      return null === t\n        ? this\n        : new dt(\n            ct(Math.min, this.$e(), t.$e(), -1 / 0),\n            ct(Math.max, this.je(), t.je(), 1 / 0),\n          );\n    }\n    Ye(t) {\n      if (!u(t)) return;\n      if (0 === this.Fe - this.We) return;\n      const i = 0.5 * (this.Fe + this.We);\n      let s = this.Fe - i,\n        n = this.We - i;\n      (s *= t), (n *= t), (this.Fe = i + s), (this.We = i + n);\n    }\n    Ke(t) {\n      u(t) && ((this.Fe += t), (this.We += t));\n    }\n    Xe() {\n      return { minValue: this.We, maxValue: this.Fe };\n    }\n    static Ze(t) {\n      return null === t ? null : new dt(t.minValue, t.maxValue);\n    }\n  }\n  class ft {\n    constructor(t, i) {\n      (this.Ge = t), (this.Je = i || null);\n    }\n    Qe() {\n      return this.Ge;\n    }\n    tr() {\n      return this.Je;\n    }\n    Xe() {\n      return {\n        priceRange: null === this.Ge ? null : this.Ge.Xe(),\n        margins: this.Je || void 0,\n      };\n    }\n    static Ze(t) {\n      return null === t ? null : new ft(dt.Ze(t.priceRange), t.margins);\n    }\n  }\n  class pt extends rt {\n    constructor(t, i) {\n      super(t), (this.ir = i);\n    }\n    te() {\n      const t = this.Zn;\n      t.Et = !1;\n      const i = this.ir.N();\n      if (!this.Jn.Et() || !i.lineVisible) return;\n      const s = this.ir.sr();\n      null !== s &&\n        ((t.Et = !0),\n        (t.ut = s),\n        (t.R = i.color),\n        (t.ct = i.lineWidth),\n        (t.Xt = i.lineStyle),\n        (t.Kn = this.ir.N().id));\n    }\n  }\n  class vt extends L {\n    constructor(t, i) {\n      super(), (this.ge = t), (this.ir = i);\n    }\n    ji(t, i, s) {\n      (t.Et = !1), (i.Et = !1);\n      const n = this.ir.N(),\n        e = n.axisLabelVisible,\n        r = '' !== n.title,\n        h = this.ge;\n      if (!e || !h.Et()) return;\n      const a = this.ir.sr();\n      if (null === a) return;\n      r && ((i.ri = n.title), (i.Et = !0)),\n        (i.Ht = h.Qt().Ut(a / h.Wt().$t())),\n        (t.ri = this.nr(n.price)),\n        (t.Et = !0);\n      const l = this.ge\n        .Qt()\n        .Xi()\n        .X(n.axisLabelColor || n.color);\n      s.Z = l.Z;\n      const o = n.axisLabelTextColor || l.G;\n      (t.R = o), (i.R = o), (s.Bi = a);\n    }\n    nr(t) {\n      const i = this.ge.zt();\n      return null === i ? '' : this.ge.Wt().Zi(t, i.Ft);\n    }\n  }\n  class mt {\n    constructor(t, i) {\n      (this.ge = t),\n        (this.Ps = i),\n        (this.er = new pt(t, this)),\n        (this.Wn = new vt(t, this)),\n        (this.rr = new nt(this.Wn, t, t.Qt()));\n    }\n    hr(t) {\n      _(this.Ps, t), this.yt(), this.ge.Qt().ar();\n    }\n    N() {\n      return this.Ps;\n    }\n    lr() {\n      return this.er;\n    }\n    _r() {\n      return this.rr;\n    }\n    ur() {\n      return this.Wn;\n    }\n    yt() {\n      this.er.yt(), this.Wn.yt();\n    }\n    sr() {\n      const t = this.ge,\n        i = t.Wt();\n      if (t.Qt().It().Ki() || i.Ki()) return null;\n      const s = t.zt();\n      return null === s ? null : i.Nt(this.Ps.price, s.Ft);\n    }\n  }\n  class wt extends U {\n    constructor(t) {\n      super(), (this.ts = t);\n    }\n    Qt() {\n      return this.ts;\n    }\n  }\n  const gt = {\n    Bar: (t, i, s, n) => {\n      const e = i.upColor,\n        r = i.downColor,\n        h = a(t(s, n)),\n        o = l(h.Ft[0]) <= l(h.Ft[3]);\n      return { cr: h.R ?? (o ? e : r) };\n    },\n    Candlestick: (t, i, s, n) => {\n      const e = i.upColor,\n        r = i.downColor,\n        h = i.borderUpColor,\n        o = i.borderDownColor,\n        _ = i.wickUpColor,\n        u = i.wickDownColor,\n        c = a(t(s, n)),\n        d = l(c.Ft[0]) <= l(c.Ft[3]);\n      return {\n        cr: c.R ?? (d ? e : r),\n        dr: c.Ht ?? (d ? h : o),\n        pr: c.vr ?? (d ? _ : u),\n      };\n    },\n    Custom: (t, i, s, n) => ({ cr: a(t(s, n)).R ?? i.color }),\n    Area: (t, i, s, n) => {\n      const e = a(t(s, n));\n      return {\n        cr: e.vt ?? i.lineColor,\n        vt: e.vt ?? i.lineColor,\n        mr: e.mr ?? i.topColor,\n        wr: e.wr ?? i.bottomColor,\n      };\n    },\n    Baseline: (t, i, s, n) => {\n      const e = a(t(s, n));\n      return {\n        cr: e.Ft[3] >= i.baseValue.price ? i.topLineColor : i.bottomLineColor,\n        gr: e.gr ?? i.topLineColor,\n        Mr: e.Mr ?? i.bottomLineColor,\n        br: e.br ?? i.topFillColor1,\n        Sr: e.Sr ?? i.topFillColor2,\n        Cr: e.Cr ?? i.bottomFillColor1,\n        Pr: e.Pr ?? i.bottomFillColor2,\n      };\n    },\n    Line: (t, i, s, n) => {\n      const e = a(t(s, n));\n      return { cr: e.R ?? i.color, vt: e.R ?? i.color };\n    },\n    Histogram: (t, i, s, n) => ({ cr: a(t(s, n)).R ?? i.color }),\n  };\n  class Mt {\n    constructor(t) {\n      (this.yr = (t, i) => (void 0 !== i ? i.Ft : this.ge.Xs().kr(t))),\n        (this.ge = t),\n        (this.Tr = gt[t.Rr()]);\n    }\n    Dr(t, i) {\n      return this.Tr(this.yr, this.ge.N(), t, i);\n    }\n  }\n  function bt(t, i, s, n, e = 0, r = i.length) {\n    let h = r - e;\n    for (; 0 < h; ) {\n      const r = h >> 1,\n        a = e + r;\n      n(i[a], s) === t ? ((e = a + 1), (h -= r + 1)) : (h = r);\n    }\n    return e;\n  }\n  const xt = bt.bind(null, !0),\n    St = bt.bind(null, !1);\n  var Ct;\n  !(function (t) {\n    (t[(t.NearestLeft = -1)] = 'NearestLeft'),\n      (t[(t.None = 0)] = 'None'),\n      (t[(t.NearestRight = 1)] = 'NearestRight');\n  })(Ct || (Ct = {}));\n  const Pt = 30;\n  class yt {\n    constructor() {\n      (this.Er = []),\n        (this.Vr = new Map()),\n        (this.Br = new Map()),\n        (this.Ir = []);\n    }\n    Ar() {\n      return this.zr() > 0 ? this.Er[this.Er.length - 1] : null;\n    }\n    Or() {\n      return this.zr() > 0 ? this.Lr(0) : null;\n    }\n    Ks() {\n      return this.zr() > 0 ? this.Lr(this.Er.length - 1) : null;\n    }\n    zr() {\n      return this.Er.length;\n    }\n    Ki() {\n      return 0 === this.zr();\n    }\n    Te(t) {\n      return null !== this.Nr(t, 0);\n    }\n    kr(t) {\n      return this.Wr(t);\n    }\n    Wr(t, i = 0) {\n      const s = this.Nr(t, i);\n      return null === s ? null : { ...this.Fr(s), Re: this.Lr(s) };\n    }\n    Hr() {\n      return this.Er;\n    }\n    Ur(t, i, s) {\n      if (this.Ki()) return null;\n      let n = null;\n      for (const e of s) {\n        n = kt(n, this.$r(t, i, e));\n      }\n      return n;\n    }\n    ht(t) {\n      this.Br.clear(),\n        this.Vr.clear(),\n        (this.Er = t),\n        (this.Ir = t.map((t) => t.Re));\n    }\n    jr() {\n      return this.Ir;\n    }\n    Lr(t) {\n      return this.Er[t].Re;\n    }\n    Fr(t) {\n      return this.Er[t];\n    }\n    Nr(t, i) {\n      const s = this.qr(t);\n      if (null === s && 0 !== i)\n        switch (i) {\n          case -1:\n            return this.Yr(t);\n          case 1:\n            return this.Kr(t);\n          default:\n            throw new TypeError('Unknown search mode');\n        }\n      return s;\n    }\n    Yr(t) {\n      let i = this.Xr(t);\n      return (\n        i > 0 && (i -= 1), i !== this.Er.length && this.Lr(i) < t ? i : null\n      );\n    }\n    Kr(t) {\n      const i = this.Zr(t);\n      return i !== this.Er.length && t < this.Lr(i) ? i : null;\n    }\n    qr(t) {\n      const i = this.Xr(t);\n      return i === this.Er.length || t < this.Er[i].Re ? null : i;\n    }\n    Xr(t) {\n      return xt(this.Er, t, (t, i) => t.Re < i);\n    }\n    Zr(t) {\n      return St(this.Er, t, (t, i) => t.Re > i);\n    }\n    Gr(t, i, s) {\n      let n = null;\n      for (let e = t; e < i; e++) {\n        const t = this.Er[e].Ft[s];\n        Number.isNaN(t) ||\n          (null === n\n            ? (n = { Jr: t, Qr: t })\n            : (t < n.Jr && (n.Jr = t), t > n.Qr && (n.Qr = t)));\n      }\n      return n;\n    }\n    $r(t, i, s) {\n      if (this.Ki()) return null;\n      let n = null;\n      const e = a(this.Or()),\n        r = a(this.Ks()),\n        h = Math.max(t, e),\n        l = Math.min(i, r),\n        o = Math.ceil(h / Pt) * Pt,\n        _ = Math.max(o, Math.floor(l / Pt) * Pt);\n      {\n        const t = this.Xr(h),\n          e = this.Zr(Math.min(l, o, i));\n        n = kt(n, this.Gr(t, e, s));\n      }\n      let u = this.Vr.get(s);\n      void 0 === u && ((u = new Map()), this.Vr.set(s, u));\n      for (let t = Math.max(o + 1, h); t < _; t += Pt) {\n        const i = Math.floor(t / Pt);\n        let e = u.get(i);\n        if (void 0 === e) {\n          const t = this.Xr(i * Pt),\n            n = this.Zr((i + 1) * Pt - 1);\n          (e = this.Gr(t, n, s)), u.set(i, e);\n        }\n        n = kt(n, e);\n      }\n      {\n        const t = this.Xr(_),\n          i = this.Zr(l);\n        n = kt(n, this.Gr(t, i, s));\n      }\n      return n;\n    }\n  }\n  function kt(t, i) {\n    if (null === t) return i;\n    if (null === i) return t;\n    return { Jr: Math.min(t.Jr, i.Jr), Qr: Math.max(t.Qr, i.Qr) };\n  }\n  class Tt {\n    constructor(t) {\n      this.th = t;\n    }\n    nt(t, i, s) {\n      this.th.draw(t);\n    }\n    ih(t, i, s) {\n      this.th.drawBackground?.(t);\n    }\n  }\n  class Rt {\n    constructor(t) {\n      (this.Dn = null), (this.sh = t);\n    }\n    Tt() {\n      const t = this.sh.renderer();\n      if (null === t) return null;\n      if (this.Dn?.nh === t) return this.Dn.eh;\n      const i = new Tt(t);\n      return (this.Dn = { nh: t, eh: i }), i;\n    }\n    rh() {\n      return this.sh.zOrder?.() ?? 'normal';\n    }\n  }\n  class Dt {\n    constructor(t) {\n      (this.hh = null), (this.ah = t);\n    }\n    oh() {\n      return this.ah;\n    }\n    Ns() {\n      this.ah.updateAllViews?.();\n    }\n    Ws() {\n      const t = this.ah.paneViews?.() ?? [];\n      if (this.hh?.nh === t) return this.hh.eh;\n      const i = t.map((t) => new Rt(t));\n      return (this.hh = { nh: t, eh: i }), i;\n    }\n    Yn(t, i) {\n      return this.ah.hitTest?.(t, i) ?? null;\n    }\n  }\n  let Et = class extends Dt {\n    us() {\n      return [];\n    }\n  };\n  class Vt {\n    constructor(t) {\n      this.th = t;\n    }\n    nt(t, i, s) {\n      this.th.draw(t);\n    }\n    ih(t, i, s) {\n      this.th.drawBackground?.(t);\n    }\n  }\n  class Bt {\n    constructor(t) {\n      (this.Dn = null), (this.sh = t);\n    }\n    Tt() {\n      const t = this.sh.renderer();\n      if (null === t) return null;\n      if (this.Dn?.nh === t) return this.Dn.eh;\n      const i = new Vt(t);\n      return (this.Dn = { nh: t, eh: i }), i;\n    }\n    rh() {\n      return this.sh.zOrder?.() ?? 'normal';\n    }\n  }\n  function It(t) {\n    return {\n      ri: t.text(),\n      Bi: t.coordinate(),\n      Vi: t.fixedCoordinate?.(),\n      R: t.textColor(),\n      Z: t.backColor(),\n      Et: t.visible?.() ?? !0,\n      pi: t.tickVisible?.() ?? !0,\n    };\n  }\n  class At {\n    constructor(t, i) {\n      (this.Gt = new F()), (this._h = t), (this.uh = i);\n    }\n    Tt() {\n      return this.Gt.ht({ Qi: this.uh.Qi(), ...It(this._h) }), this.Gt;\n    }\n  }\n  class zt extends L {\n    constructor(t, i) {\n      super(), (this._h = t), (this.qi = i);\n    }\n    ji(t, i, s) {\n      const n = It(this._h);\n      (s.Z = n.Z), (t.R = n.R);\n      const e = (2 / 12) * this.qi.P();\n      (s.Ti = e),\n        (s.Ri = e),\n        (s.Bi = n.Bi),\n        (s.Vi = n.Vi),\n        (t.ri = n.ri),\n        (t.Et = n.Et),\n        (t.pi = n.pi);\n    }\n  }\n  class Ot extends Dt {\n    constructor(t, i) {\n      super(t),\n        (this.dh = null),\n        (this.fh = null),\n        (this.ph = null),\n        (this.mh = null),\n        (this.ge = i);\n    }\n    cs() {\n      const t = this.ah.timeAxisViews?.() ?? [];\n      if (this.dh?.nh === t) return this.dh.eh;\n      const i = this.ge.Qt().It(),\n        s = t.map((t) => new At(t, i));\n      return (this.dh = { nh: t, eh: s }), s;\n    }\n    Fs() {\n      const t = this.ah.priceAxisViews?.() ?? [];\n      if (this.fh?.nh === t) return this.fh.eh;\n      const i = this.ge.Wt(),\n        s = t.map((t) => new zt(t, i));\n      return (this.fh = { nh: t, eh: s }), s;\n    }\n    wh() {\n      const t = this.ah.priceAxisPaneViews?.() ?? [];\n      if (this.ph?.nh === t) return this.ph.eh;\n      const i = t.map((t) => new Bt(t));\n      return (this.ph = { nh: t, eh: i }), i;\n    }\n    gh() {\n      const t = this.ah.timeAxisPaneViews?.() ?? [];\n      if (this.mh?.nh === t) return this.mh.eh;\n      const i = t.map((t) => new Bt(t));\n      return (this.mh = { nh: t, eh: i }), i;\n    }\n    Mh(t, i) {\n      return this.ah.autoscaleInfo?.(t, i) ?? null;\n    }\n  }\n  function Lt(t, i, s, n) {\n    t.forEach((t) => {\n      i(t).forEach((t) => {\n        t.rh() === s && n.push(t);\n      });\n    });\n  }\n  function Nt(t) {\n    return t.Ws();\n  }\n  function Wt(t) {\n    return t.wh();\n  }\n  function Ft(t) {\n    return t.gh();\n  }\n  const Ht = ['Area', 'Line', 'Baseline'];\n  class Ut extends wt {\n    constructor(t, i, s, n, e) {\n      super(t),\n        (this.qt = new yt()),\n        (this.er = new _t(this)),\n        (this.bh = []),\n        (this.xh = new ht(this)),\n        (this.Sh = null),\n        (this.Ch = null),\n        (this.Ph = null),\n        (this.yh = []),\n        (this.Ps = s),\n        (this.kh = i);\n      const r = new ut(this);\n      (this.vs = [r]),\n        (this.rr = new nt(r, this, t)),\n        Ht.includes(this.kh) && (this.Sh = new ot(this)),\n        this.Th(),\n        (this.sh = n(this, this.Qt(), e));\n    }\n    m() {\n      null !== this.Ph && clearTimeout(this.Ph);\n    }\n    Be(t) {\n      return this.Ps.priceLineColor || t;\n    }\n    ye(t) {\n      const i = { ke: !0 },\n        s = this.Wt();\n      if (this.Qt().It().Ki() || s.Ki() || this.qt.Ki()) return i;\n      const n = this.Qt().It().Pe(),\n        e = this.zt();\n      if (null === n || null === e) return i;\n      let r, h;\n      if (t) {\n        const t = this.qt.Ar();\n        if (null === t) return i;\n        (r = t), (h = t.Re);\n      } else {\n        const t = this.qt.Wr(n.bi(), -1);\n        if (null === t) return i;\n        if (((r = this.qt.kr(t.Re)), null === r)) return i;\n        h = t.Re;\n      }\n      const a = r.Ft[3],\n        l = this.Rh().Dr(h, { Ft: r }),\n        o = s.Nt(a, e.Ft);\n      return {\n        ke: !1,\n        gt: a,\n        ri: s.Zi(a, e.Ft),\n        Le: s.Dh(a),\n        Ne: s.Eh(a, e.Ft),\n        R: l.cr,\n        Bi: o,\n        Re: h,\n      };\n    }\n    Rh() {\n      return null !== this.Ch || (this.Ch = new Mt(this)), this.Ch;\n    }\n    N() {\n      return this.Ps;\n    }\n    hr(t) {\n      const i = t.priceScaleId;\n      void 0 !== i && i !== this.Ps.priceScaleId && this.Qt().Vh(this, i),\n        _(this.Ps, t),\n        void 0 !== t.priceFormat && (this.Th(), this.Qt().Bh()),\n        this.Qt().Ih(this),\n        this.Qt().Ah(),\n        this.sh.yt('options');\n    }\n    ht(t, i) {\n      this.qt.ht(t),\n        this.sh.yt('data'),\n        null !== this.Sh &&\n          (i && i.zh ? this.Sh.be() : 0 === t.length && this.Sh.Me());\n      const s = this.Qt().Hn(this);\n      this.Qt().Oh(s), this.Qt().Ih(this), this.Qt().Ah(), this.Qt().ar();\n    }\n    Lh(t) {\n      const i = new mt(this, t);\n      return this.bh.push(i), this.Qt().Ih(this), i;\n    }\n    Nh(t) {\n      const i = this.bh.indexOf(t);\n      -1 !== i && this.bh.splice(i, 1), this.Qt().Ih(this);\n    }\n    Wh() {\n      return this.bh;\n    }\n    Rr() {\n      return this.kh;\n    }\n    zt() {\n      const t = this.Fh();\n      return null === t ? null : { Ft: t.Ft[3], Hh: t.wt };\n    }\n    Fh() {\n      const t = this.Qt().It().Pe();\n      if (null === t) return null;\n      const i = t.Uh();\n      return this.qt.Wr(i, 1);\n    }\n    Xs() {\n      return this.qt;\n    }\n    $h(t) {\n      const i = this.qt.kr(t);\n      return null === i\n        ? null\n        : 'Bar' === this.kh || 'Candlestick' === this.kh || 'Custom' === this.kh\n        ? { jh: i.Ft[0], qh: i.Ft[1], Yh: i.Ft[2], Kh: i.Ft[3] }\n        : i.Ft[3];\n    }\n    Xh(t) {\n      const i = [];\n      Lt(this.yh, Nt, 'top', i);\n      const s = this.Sh;\n      return null !== s && s.Et()\n        ? (null === this.Ph &&\n            s.Se() &&\n            (this.Ph = setTimeout(() => {\n              (this.Ph = null), this.Qt().Zh();\n            }, 0)),\n          s.xe(),\n          i.unshift(s),\n          i)\n        : i;\n    }\n    Ws() {\n      const t = [];\n      this.Gh() || t.push(this.xh), t.push(this.sh, this.er);\n      const i = this.bh.map((t) => t.lr());\n      return t.push(...i), Lt(this.yh, Nt, 'normal', t), t;\n    }\n    Jh() {\n      return this.Qh(Nt, 'bottom');\n    }\n    ta(t) {\n      return this.Qh(Wt, t);\n    }\n    ia(t) {\n      return this.Qh(Ft, t);\n    }\n    sa(t, i) {\n      return this.yh.map((s) => s.Yn(t, i)).filter((t) => null !== t);\n    }\n    us() {\n      return [this.rr, ...this.bh.map((t) => t._r())];\n    }\n    Fs(t, i) {\n      if (i !== this.es && !this.Gh()) return [];\n      const s = [...this.vs];\n      for (const t of this.bh) s.push(t.ur());\n      return (\n        this.yh.forEach((t) => {\n          s.push(...t.Fs());\n        }),\n        s\n      );\n    }\n    cs() {\n      const t = [];\n      return (\n        this.yh.forEach((i) => {\n          t.push(...i.cs());\n        }),\n        t\n      );\n    }\n    Mh(t, i) {\n      if (void 0 !== this.Ps.autoscaleInfoProvider) {\n        const s = this.Ps.autoscaleInfoProvider(() => {\n          const s = this.na(t, i);\n          return null === s ? null : s.Xe();\n        });\n        return ft.Ze(s);\n      }\n      return this.na(t, i);\n    }\n    ea() {\n      return this.Ps.priceFormat.minMove;\n    }\n    ra() {\n      return this.ha;\n    }\n    Ns() {\n      this.sh.yt();\n      for (const t of this.vs) t.yt();\n      for (const t of this.bh) t.yt();\n      this.er.yt(), this.xh.yt(), this.Sh?.yt(), this.yh.forEach((t) => t.Ns());\n    }\n    Wt() {\n      return a(super.Wt());\n    }\n    At(t) {\n      if (\n        !(\n          ('Line' === this.kh ||\n            'Area' === this.kh ||\n            'Baseline' === this.kh) &&\n          this.Ps.crosshairMarkerVisible\n        )\n      )\n        return null;\n      const i = this.qt.kr(t);\n      if (null === i) return null;\n      return {\n        gt: i.Ft[3],\n        ft: this.aa(),\n        Ht: this.la(),\n        Lt: this.oa(),\n        Ot: this._a(t),\n      };\n    }\n    Ie() {\n      return this.Ps.title;\n    }\n    Et() {\n      return this.Ps.visible;\n    }\n    ua(t) {\n      this.yh.push(new Ot(t, this));\n    }\n    ca(t) {\n      this.yh = this.yh.filter((i) => i.oh() !== t);\n    }\n    da() {\n      if ('Custom' === this.kh) return (t) => this.sh.fa(t);\n    }\n    pa() {\n      if ('Custom' === this.kh) return (t) => this.sh.va(t);\n    }\n    ma() {\n      return this.qt.jr();\n    }\n    Gh() {\n      return !q(this.Wt().wa());\n    }\n    na(t, i) {\n      if (!c(t) || !c(i) || this.qt.Ki()) return null;\n      const s =\n          'Line' === this.kh ||\n          'Area' === this.kh ||\n          'Baseline' === this.kh ||\n          'Histogram' === this.kh\n            ? [3]\n            : [2, 1],\n        n = this.qt.Ur(t, i, s);\n      let e = null !== n ? new dt(n.Jr, n.Qr) : null,\n        r = null;\n      if ('Histogram' === this.Rr()) {\n        const t = this.Ps.base,\n          i = new dt(t, t);\n        e = null !== e ? e.vn(i) : i;\n      }\n      return (\n        this.yh.forEach((s) => {\n          const n = s.Mh(t, i);\n          if (n?.priceRange) {\n            const t = new dt(n.priceRange.minValue, n.priceRange.maxValue);\n            e = null !== e ? e.vn(t) : t;\n          }\n          n?.margins && (r = n.margins);\n        }),\n        new ft(e, r)\n      );\n    }\n    aa() {\n      switch (this.kh) {\n        case 'Line':\n        case 'Area':\n        case 'Baseline':\n          return this.Ps.crosshairMarkerRadius;\n      }\n      return 0;\n    }\n    la() {\n      switch (this.kh) {\n        case 'Line':\n        case 'Area':\n        case 'Baseline': {\n          const t = this.Ps.crosshairMarkerBorderColor;\n          if (0 !== t.length) return t;\n        }\n      }\n      return null;\n    }\n    oa() {\n      switch (this.kh) {\n        case 'Line':\n        case 'Area':\n        case 'Baseline':\n          return this.Ps.crosshairMarkerBorderWidth;\n      }\n      return 0;\n    }\n    _a(t) {\n      switch (this.kh) {\n        case 'Line':\n        case 'Area':\n        case 'Baseline': {\n          const t = this.Ps.crosshairMarkerBackgroundColor;\n          if (0 !== t.length) return t;\n        }\n      }\n      return this.Rh().Dr(t).cr;\n    }\n    Th() {\n      switch (this.Ps.priceFormat.type) {\n        case 'custom': {\n          const t = this.Ps.priceFormat.formatter;\n          this.ha = {\n            format: t,\n            formatTickmarks:\n              this.Ps.priceFormat.tickmarksFormatter ?? ((i) => i.map(t)),\n          };\n          break;\n        }\n        case 'volume':\n          this.ha = new Q(this.Ps.priceFormat.precision);\n          break;\n        case 'percent':\n          this.ha = new J(this.Ps.priceFormat.precision);\n          break;\n        default: {\n          const t = Math.pow(10, this.Ps.priceFormat.precision);\n          this.ha = new G(t, this.Ps.priceFormat.minMove * t);\n        }\n      }\n      null !== this.es && this.es.ga();\n    }\n    Qh(t, i) {\n      const s = [];\n      return Lt(this.yh, t, i, s), s;\n    }\n  }\n  const $t = [3],\n    jt = [0, 1, 2, 3];\n  class qt {\n    constructor(t) {\n      this.Ps = t;\n    }\n    Ma(t, i, s) {\n      let n = t;\n      if (0 === this.Ps.mode) return n;\n      const e = s.ks(),\n        r = e.zt();\n      if (null === r) return n;\n      const h = e.Nt(t, r),\n        a = s\n          .ba()\n          .filter((t) => t instanceof Ut)\n          .reduce((t, n) => {\n            if (s.Un(n) || !n.Et()) return t;\n            const e = n.Wt(),\n              r = n.Xs();\n            if (e.Ki() || !r.Te(i)) return t;\n            const h = r.kr(i);\n            if (null === h) return t;\n            const a = l(n.zt()),\n              o = 3 === this.Ps.mode ? jt : $t;\n            return t.concat(o.map((t) => e.Nt(h.Ft[t], a.Ft)));\n          }, []);\n      if (0 === a.length) return n;\n      a.sort((t, i) => Math.abs(t - h) - Math.abs(i - h));\n      const o = a[0];\n      return (n = e.Ts(o, r)), n;\n    }\n  }\n  function Yt(t, i, s) {\n    return Math.min(Math.max(t, i), s);\n  }\n  function Kt(t, i, s) {\n    return i - t <= s;\n  }\n  function Xt(t) {\n    const i = Math.ceil(t);\n    return i % 2 == 0 ? i - 1 : i;\n  }\n  class Zt extends P {\n    constructor() {\n      super(...arguments), (this.qt = null);\n    }\n    ht(t) {\n      this.qt = t;\n    }\n    et({\n      context: t,\n      bitmapSize: i,\n      horizontalPixelRatio: s,\n      verticalPixelRatio: e,\n    }) {\n      if (null === this.qt) return;\n      const r = Math.max(1, Math.floor(s));\n      (t.lineWidth = r),\n        (function (t, i) {\n          t.save(), t.lineWidth % 2 && t.translate(0.5, 0.5), i(), t.restore();\n        })(t, () => {\n          const h = a(this.qt);\n          if (h.xa) {\n            (t.strokeStyle = h.Sa), n(t, h.Ca), t.beginPath();\n            for (const n of h.Pa) {\n              const e = Math.round(n.ya * s);\n              t.moveTo(e, -r), t.lineTo(e, i.height + r);\n            }\n            t.stroke();\n          }\n          if (h.ka) {\n            (t.strokeStyle = h.Ta), n(t, h.Ra), t.beginPath();\n            for (const s of h.Da) {\n              const n = Math.round(s.ya * e);\n              t.moveTo(-r, n), t.lineTo(i.width + r, n);\n            }\n            t.stroke();\n          }\n        });\n    }\n  }\n  class Gt {\n    constructor(t) {\n      (this.Gt = new Zt()), (this.St = !0), (this.Pt = t);\n    }\n    yt() {\n      this.St = !0;\n    }\n    Tt() {\n      if (this.St) {\n        const t = this.Pt.Qt().N().grid,\n          i = {\n            ka: t.horzLines.visible,\n            xa: t.vertLines.visible,\n            Ta: t.horzLines.color,\n            Sa: t.vertLines.color,\n            Ra: t.horzLines.style,\n            Ca: t.vertLines.style,\n            Da: this.Pt.ks().Ea(),\n            Pa: (this.Pt.Qt().It().Ea() || []).map((t) => ({ ya: t.coord })),\n          };\n        this.Gt.ht(i), (this.St = !1);\n      }\n      return this.Gt;\n    }\n  }\n  class Jt {\n    constructor(t) {\n      this.sh = new Gt(t);\n    }\n    lr() {\n      return this.sh;\n    }\n  }\n  const Qt = { Va: 4, Ba: 1e-4 };\n  function ti(t, i) {\n    const s = (100 * (t - i)) / i;\n    return i < 0 ? -s : s;\n  }\n  function ii(t, i) {\n    const s = ti(t.$e(), i),\n      n = ti(t.je(), i);\n    return new dt(s, n);\n  }\n  function si(t, i) {\n    const s = (100 * (t - i)) / i + 100;\n    return i < 0 ? -s : s;\n  }\n  function ni(t, i) {\n    const s = si(t.$e(), i),\n      n = si(t.je(), i);\n    return new dt(s, n);\n  }\n  function ei(t, i) {\n    const s = Math.abs(t);\n    if (s < 1e-15) return 0;\n    const n = Math.log10(s + i.Ba) + i.Va;\n    return t < 0 ? -n : n;\n  }\n  function ri(t, i) {\n    const s = Math.abs(t);\n    if (s < 1e-15) return 0;\n    const n = Math.pow(10, s - i.Va) - i.Ba;\n    return t < 0 ? -n : n;\n  }\n  function hi(t, i) {\n    if (null === t) return null;\n    const s = ei(t.$e(), i),\n      n = ei(t.je(), i);\n    return new dt(s, n);\n  }\n  function ai(t, i) {\n    if (null === t) return null;\n    const s = ri(t.$e(), i),\n      n = ri(t.je(), i);\n    return new dt(s, n);\n  }\n  function li(t) {\n    if (null === t) return Qt;\n    const i = Math.abs(t.je() - t.$e());\n    if (i >= 1 || i < 1e-15) return Qt;\n    const s = Math.ceil(Math.abs(Math.log10(i))),\n      n = Qt.Va + s;\n    return { Va: n, Ba: 1 / Math.pow(10, n) };\n  }\n  class oi {\n    constructor(t, i) {\n      if (\n        ((this.Ia = t),\n        (this.Aa = i),\n        (function (t) {\n          if (t < 0) return !1;\n          for (let i = t; i > 1; i /= 10) if (i % 10 != 0) return !1;\n          return !0;\n        })(this.Ia))\n      )\n        this.za = [2, 2.5, 2];\n      else {\n        this.za = [];\n        for (let t = this.Ia; 1 !== t; ) {\n          if (t % 2 == 0) this.za.push(2), (t /= 2);\n          else {\n            if (t % 5 != 0) throw new Error('unexpected base');\n            this.za.push(2, 2.5), (t /= 5);\n          }\n          if (this.za.length > 100)\n            throw new Error('something wrong with base');\n        }\n      }\n    }\n    Oa(t, i, s) {\n      const n = 0 === this.Ia ? 0 : 1 / this.Ia;\n      let e = Math.pow(10, Math.max(0, Math.ceil(Math.log10(t - i)))),\n        r = 0,\n        h = this.Aa[0];\n      for (;;) {\n        const t = Kt(e, n, 1e-14) && e > n + 1e-14,\n          i = Kt(e, s * h, 1e-14),\n          a = Kt(e, 1, 1e-14);\n        if (!(t && i && a)) break;\n        (e /= h), (h = this.Aa[++r % this.Aa.length]);\n      }\n      if (\n        (e <= n + 1e-14 && (e = n),\n        (e = Math.max(1, e)),\n        this.za.length > 0 &&\n          ((a = e), (l = 1), (o = 1e-14), Math.abs(a - l) < o))\n      )\n        for (r = 0, h = this.za[0]; Kt(e, s * h, 1e-14) && e > n + 1e-14; )\n          (e /= h), (h = this.za[++r % this.za.length]);\n      var a, l, o;\n      return e;\n    }\n  }\n  class _i {\n    constructor(t, i, s, n) {\n      (this.La = []),\n        (this.qi = t),\n        (this.Ia = i),\n        (this.Na = s),\n        (this.Wa = n);\n    }\n    Oa(t, i) {\n      if (t < i) throw new Error('high < low');\n      const s = this.qi.$t(),\n        n = ((t - i) * this.Fa()) / s,\n        e = new oi(this.Ia, [2, 2.5, 2]),\n        r = new oi(this.Ia, [2, 2, 2.5]),\n        h = new oi(this.Ia, [2.5, 2, 2]),\n        a = [];\n      return (\n        a.push(e.Oa(t, i, n), r.Oa(t, i, n), h.Oa(t, i, n)),\n        (function (t) {\n          if (t.length < 1) throw Error('array is empty');\n          let i = t[0];\n          for (let s = 1; s < t.length; ++s) t[s] < i && (i = t[s]);\n          return i;\n        })(a)\n      );\n    }\n    Ha() {\n      const t = this.qi,\n        i = t.zt();\n      if (null === i) return void (this.La = []);\n      const s = t.$t(),\n        n = this.Na(s - 1, i),\n        e = this.Na(0, i),\n        r = this.qi.N().entireTextOnly ? this.Ua() / 2 : 0,\n        h = r,\n        a = s - 1 - r,\n        l = Math.max(n, e),\n        o = Math.min(n, e);\n      if (l === o) return void (this.La = []);\n      const _ = this.Oa(l, o);\n      if ((this.$a(i, _, l, o, h, a), t.ja() && this.qa(_, o, l))) {\n        const t = this.qi.Ya();\n        this.Ka(i, _, h, a, t, 2 * t);\n      }\n      const u = this.La.map((t) => t.Xa),\n        c = this.qi.Za(u);\n      for (let t = 0; t < this.La.length; t++) this.La[t].Ga = c[t];\n    }\n    Ea() {\n      return this.La;\n    }\n    Ua() {\n      return this.qi.P();\n    }\n    Fa() {\n      return Math.ceil(2.5 * this.Ua());\n    }\n    $a(t, i, s, n, e, r) {\n      const h = this.La,\n        a = this.qi;\n      let l = s % i;\n      l += l < 0 ? i : 0;\n      const o = s >= n ? 1 : -1;\n      let _ = null,\n        u = 0;\n      for (let c = s - l; c > n; c -= i) {\n        const s = this.Wa(c, t, !0);\n        (null !== _ && Math.abs(s - _) < this.Fa()) ||\n          s < e ||\n          s > r ||\n          (u < h.length\n            ? ((h[u].ya = s), (h[u].Ga = a.Ja(c)), (h[u].Xa = c))\n            : h.push({ ya: s, Ga: a.Ja(c), Xa: c }),\n          u++,\n          (_ = s),\n          a.Qa() && (i = this.Oa(c * o, n)));\n      }\n      h.length = u;\n    }\n    Ka(t, i, s, n, e, r) {\n      const h = this.La,\n        a = this.tl(t, s, e, r),\n        l = this.tl(t, n, -r, -e),\n        o = this.Wa(0, t, !0) - this.Wa(i, t, !0);\n      h.length > 0 && h[0].ya - a.ya < o / 2 && h.shift(),\n        h.length > 0 && l.ya - h[h.length - 1].ya < o / 2 && h.pop(),\n        h.unshift(a),\n        h.push(l);\n    }\n    tl(t, i, s, n) {\n      const e = (s + n) / 2,\n        r = this.Na(i + s, t),\n        h = this.Na(i + n, t),\n        a = Math.min(r, h),\n        l = Math.max(r, h),\n        o = Math.max(0.1, this.Oa(l, a)),\n        _ = this.Na(i + e, t),\n        u = _ - (_ % o),\n        c = this.Wa(u, t, !0);\n      return { Ga: this.qi.Ja(u), ya: c, Xa: u };\n    }\n    qa(t, i, s) {\n      let n = l(this.qi.Qe());\n      return (\n        this.qi.Qa() && (n = ai(n, this.qi.il())),\n        n.$e() - i < t && s - n.je() < t\n      );\n    }\n  }\n  function ui(t) {\n    return t.slice().sort((t, i) => a(t.hs()) - a(i.hs()));\n  }\n  var ci;\n  !(function (t) {\n    (t[(t.Normal = 0)] = 'Normal'),\n      (t[(t.Logarithmic = 1)] = 'Logarithmic'),\n      (t[(t.Percentage = 2)] = 'Percentage'),\n      (t[(t.IndexedTo100 = 3)] = 'IndexedTo100');\n  })(ci || (ci = {}));\n  const di = new J(),\n    fi = new G(100, 1);\n  class pi {\n    constructor(t, i, s, n, e) {\n      (this.sl = 0),\n        (this.nl = null),\n        (this.Ge = null),\n        (this.el = null),\n        (this.rl = { hl: !1, al: null }),\n        (this.ll = !1),\n        (this.ol = 0),\n        (this._l = 0),\n        (this.ul = new o()),\n        (this.cl = new o()),\n        (this.dl = []),\n        (this.fl = null),\n        (this.pl = null),\n        (this.vl = null),\n        (this.ml = null),\n        (this.wl = null),\n        (this.ha = fi),\n        (this.gl = li(null)),\n        (this.Ml = t),\n        (this.Ps = i),\n        (this.bl = s),\n        (this.xl = n),\n        (this.Sl = e),\n        (this.Cl = new _i(this, 100, this.Pl.bind(this), this.yl.bind(this)));\n    }\n    wa() {\n      return this.Ml;\n    }\n    N() {\n      return this.Ps;\n    }\n    hr(t) {\n      if (\n        (_(this.Ps, t),\n        this.ga(),\n        void 0 !== t.mode && this.kl({ ie: t.mode }),\n        void 0 !== t.scaleMargins)\n      ) {\n        const i = h(t.scaleMargins.top),\n          s = h(t.scaleMargins.bottom);\n        if (i < 0 || i > 1)\n          throw new Error(\n            `Invalid top margin - expect value between 0 and 1, given=${i}`,\n          );\n        if (s < 0 || s > 1)\n          throw new Error(\n            `Invalid bottom margin - expect value between 0 and 1, given=${s}`,\n          );\n        if (i + s > 1)\n          throw new Error(\n            `Invalid margins - sum of margins must be less than 1, given=${\n              i + s\n            }`,\n          );\n        this.Tl(), (this.vl = null);\n      }\n    }\n    Rl() {\n      return this.Ps.autoScale;\n    }\n    Dl() {\n      return this.ll;\n    }\n    Qa() {\n      return 1 === this.Ps.mode;\n    }\n    Oe() {\n      return 2 === this.Ps.mode;\n    }\n    El() {\n      return 3 === this.Ps.mode;\n    }\n    il() {\n      return this.gl;\n    }\n    ie() {\n      return {\n        sn: this.Ps.autoScale,\n        Vl: this.Ps.invertScale,\n        ie: this.Ps.mode,\n      };\n    }\n    kl(t) {\n      const i = this.ie();\n      let s = null;\n      void 0 !== t.sn && (this.Ps.autoScale = t.sn),\n        void 0 !== t.ie &&\n          ((this.Ps.mode = t.ie),\n          (2 !== t.ie && 3 !== t.ie) || (this.Ps.autoScale = !0),\n          (this.rl.hl = !1)),\n        1 === i.ie &&\n          t.ie !== i.ie &&\n          (!(function (t, i) {\n            if (null === t) return !1;\n            const s = ri(t.$e(), i),\n              n = ri(t.je(), i);\n            return isFinite(s) && isFinite(n);\n          })(this.Ge, this.gl)\n            ? (this.Ps.autoScale = !0)\n            : ((s = ai(this.Ge, this.gl)), null !== s && this.Bl(s))),\n        1 === t.ie &&\n          t.ie !== i.ie &&\n          ((s = hi(this.Ge, this.gl)), null !== s && this.Bl(s));\n      const n = i.ie !== this.Ps.mode;\n      n && (2 === i.ie || this.Oe()) && this.ga(),\n        n && (3 === i.ie || this.El()) && this.ga(),\n        void 0 !== t.Vl &&\n          i.Vl !== t.Vl &&\n          ((this.Ps.invertScale = t.Vl), this.Il()),\n        this.cl.p(i, this.ie());\n    }\n    Al() {\n      return this.cl;\n    }\n    P() {\n      return this.bl.fontSize;\n    }\n    $t() {\n      return this.sl;\n    }\n    zl(t) {\n      this.sl !== t && ((this.sl = t), this.Tl(), (this.vl = null));\n    }\n    Ol() {\n      if (this.nl) return this.nl;\n      const t = this.$t() - this.Ll() - this.Nl();\n      return (this.nl = t), t;\n    }\n    Qe() {\n      return this.Wl(), this.Ge;\n    }\n    Bl(t, i) {\n      const s = this.Ge;\n      (i || (null === s && null !== t) || (null !== s && !s.He(t))) &&\n        ((this.vl = null), (this.Ge = t));\n    }\n    Fl(t) {\n      this.Bl(t), this.Hl(null !== t);\n    }\n    Ki() {\n      return this.Wl(), 0 === this.sl || !this.Ge || this.Ge.Ki();\n    }\n    Ul(t) {\n      return this.Vl() ? t : this.$t() - 1 - t;\n    }\n    Nt(t, i) {\n      return (\n        this.Oe() ? (t = ti(t, i)) : this.El() && (t = si(t, i)), this.yl(t, i)\n      );\n    }\n    $l(t, i, s) {\n      this.Wl();\n      const n = this.Nl(),\n        e = a(this.Qe()),\n        r = e.$e(),\n        h = e.je(),\n        l = this.Ol() - 1,\n        o = this.Vl(),\n        _ = l / (h - r),\n        u = void 0 === s ? 0 : s.from,\n        c = void 0 === s ? t.length : s.to,\n        d = this.jl();\n      for (let s = u; s < c; s++) {\n        const e = t[s],\n          h = e.gt;\n        if (isNaN(h)) continue;\n        let a = h;\n        null !== d && (a = d(e.gt, i));\n        const l = n + _ * (a - r),\n          u = o ? l : this.sl - 1 - l;\n        e.ut = u;\n      }\n    }\n    ql(t, i, s) {\n      this.Wl();\n      const n = this.Nl(),\n        e = a(this.Qe()),\n        r = e.$e(),\n        h = e.je(),\n        l = this.Ol() - 1,\n        o = this.Vl(),\n        _ = l / (h - r),\n        u = void 0 === s ? 0 : s.from,\n        c = void 0 === s ? t.length : s.to,\n        d = this.jl();\n      for (let s = u; s < c; s++) {\n        const e = t[s];\n        let h = e.jh,\n          a = e.qh,\n          l = e.Yh,\n          u = e.Kh;\n        null !== d &&\n          ((h = d(e.jh, i)),\n          (a = d(e.qh, i)),\n          (l = d(e.Yh, i)),\n          (u = d(e.Kh, i)));\n        let c = n + _ * (h - r),\n          f = o ? c : this.sl - 1 - c;\n        (e.Yl = f),\n          (c = n + _ * (a - r)),\n          (f = o ? c : this.sl - 1 - c),\n          (e.Kl = f),\n          (c = n + _ * (l - r)),\n          (f = o ? c : this.sl - 1 - c),\n          (e.Xl = f),\n          (c = n + _ * (u - r)),\n          (f = o ? c : this.sl - 1 - c),\n          (e.Zl = f);\n      }\n    }\n    Ts(t, i) {\n      const s = this.Pl(t, i);\n      return this.Gl(s, i);\n    }\n    Gl(t, i) {\n      let s = t;\n      return (\n        this.Oe()\n          ? (s = (function (t, i) {\n              return i < 0 && (t = -t), (t / 100) * i + i;\n            })(s, i))\n          : this.El() &&\n            (s = (function (t, i) {\n              return (t -= 100), i < 0 && (t = -t), (t / 100) * i + i;\n            })(s, i)),\n        s\n      );\n    }\n    ba() {\n      return this.dl;\n    }\n    Dt() {\n      return this.pl || (this.pl = ui(this.dl)), this.pl;\n    }\n    Jl(t) {\n      -1 === this.dl.indexOf(t) && (this.dl.push(t), this.ga(), this.Ql());\n    }\n    io(t) {\n      const i = this.dl.indexOf(t);\n      if (-1 === i) throw new Error('source is not attached to scale');\n      this.dl.splice(i, 1),\n        0 === this.dl.length && (this.kl({ sn: !0 }), this.Bl(null)),\n        this.ga(),\n        this.Ql();\n    }\n    zt() {\n      let t = null;\n      for (const i of this.dl) {\n        const s = i.zt();\n        null !== s && (null === t || s.Hh < t.Hh) && (t = s);\n      }\n      return null === t ? null : t.Ft;\n    }\n    Vl() {\n      return this.Ps.invertScale;\n    }\n    Ea() {\n      const t = null === this.zt();\n      if (null !== this.vl && (t || this.vl.so === t)) return this.vl.Ea;\n      this.Cl.Ha();\n      const i = this.Cl.Ea();\n      return (this.vl = { Ea: i, so: t }), this.ul.p(), i;\n    }\n    no() {\n      return this.ul;\n    }\n    eo(t) {\n      this.Oe() ||\n        this.El() ||\n        (null === this.ml &&\n          null === this.el &&\n          (this.Ki() ||\n            ((this.ml = this.sl - t), (this.el = a(this.Qe()).Ue()))));\n    }\n    ro(t) {\n      if (this.Oe() || this.El()) return;\n      if (null === this.ml) return;\n      this.kl({ sn: !1 }), (t = this.sl - t) < 0 && (t = 0);\n      let i = (this.ml + 0.2 * (this.sl - 1)) / (t + 0.2 * (this.sl - 1));\n      const s = a(this.el).Ue();\n      (i = Math.max(i, 0.1)), s.Ye(i), this.Bl(s);\n    }\n    ho() {\n      this.Oe() || this.El() || ((this.ml = null), (this.el = null));\n    }\n    ao(t) {\n      this.Rl() ||\n        (null === this.wl &&\n          null === this.el &&\n          (this.Ki() || ((this.wl = t), (this.el = a(this.Qe()).Ue()))));\n    }\n    lo(t) {\n      if (this.Rl()) return;\n      if (null === this.wl) return;\n      const i = a(this.Qe()).qe() / (this.Ol() - 1);\n      let s = t - this.wl;\n      this.Vl() && (s *= -1);\n      const n = s * i,\n        e = a(this.el).Ue();\n      e.Ke(n), this.Bl(e, !0), (this.vl = null);\n    }\n    oo() {\n      this.Rl() || (null !== this.wl && ((this.wl = null), (this.el = null)));\n    }\n    ra() {\n      return this.ha || this.ga(), this.ha;\n    }\n    Zi(t, i) {\n      switch (this.Ps.mode) {\n        case 2:\n          return this._o(ti(t, i));\n        case 3:\n          return this.ra().format(si(t, i));\n        default:\n          return this.nr(t);\n      }\n    }\n    Ja(t) {\n      switch (this.Ps.mode) {\n        case 2:\n          return this._o(t);\n        case 3:\n          return this.ra().format(t);\n        default:\n          return this.nr(t);\n      }\n    }\n    Za(t) {\n      switch (this.Ps.mode) {\n        case 2:\n          return this.uo(t);\n        case 3:\n          return this.ra().formatTickmarks(t);\n        default:\n          return this.co(t);\n      }\n    }\n    Dh(t) {\n      return this.nr(t, a(this.fl).ra());\n    }\n    Eh(t, i) {\n      return (t = ti(t, i)), this._o(t, di);\n    }\n    do() {\n      return this.dl;\n    }\n    fo(t) {\n      this.rl = { al: t, hl: !1 };\n    }\n    Ns() {\n      this.dl.forEach((t) => t.Ns());\n    }\n    ja() {\n      return this.Ps.ensureEdgeTickMarksVisible && this.Rl();\n    }\n    Ya() {\n      return this.P() / 2;\n    }\n    ga() {\n      this.vl = null;\n      let t = 1 / 0;\n      this.fl = null;\n      for (const i of this.dl) i.hs() < t && ((t = i.hs()), (this.fl = i));\n      let i = 100;\n      null !== this.fl && (i = Math.round(1 / this.fl.ea())),\n        (this.ha = fi),\n        this.Oe()\n          ? ((this.ha = di), (i = 100))\n          : this.El()\n          ? ((this.ha = new G(100, 1)), (i = 100))\n          : null !== this.fl && (this.ha = this.fl.ra()),\n        (this.Cl = new _i(this, i, this.Pl.bind(this), this.yl.bind(this))),\n        this.Cl.Ha();\n    }\n    Ql() {\n      this.pl = null;\n    }\n    Xi() {\n      return this.Sl;\n    }\n    Hl(t) {\n      this.ll = t;\n    }\n    Ll() {\n      return this.Vl()\n        ? this.Ps.scaleMargins.bottom * this.$t() + this._l\n        : this.Ps.scaleMargins.top * this.$t() + this.ol;\n    }\n    Nl() {\n      return this.Vl()\n        ? this.Ps.scaleMargins.top * this.$t() + this.ol\n        : this.Ps.scaleMargins.bottom * this.$t() + this._l;\n    }\n    Wl() {\n      this.rl.hl || ((this.rl.hl = !0), this.po());\n    }\n    Tl() {\n      this.nl = null;\n    }\n    yl(t, i) {\n      if ((this.Wl(), this.Ki())) return 0;\n      t = this.Qa() && t ? ei(t, this.gl) : t;\n      const s = a(this.Qe()),\n        n = this.Nl() + ((this.Ol() - 1) * (t - s.$e())) / s.qe();\n      return this.Ul(n);\n    }\n    Pl(t, i) {\n      if ((this.Wl(), this.Ki())) return 0;\n      const s = this.Ul(t),\n        n = a(this.Qe()),\n        e = n.$e() + n.qe() * ((s - this.Nl()) / (this.Ol() - 1));\n      return this.Qa() ? ri(e, this.gl) : e;\n    }\n    Il() {\n      (this.vl = null), this.Cl.Ha();\n    }\n    po() {\n      if (this.Dl() && !this.Rl()) return;\n      const t = this.rl.al;\n      if (null === t) return;\n      let i = null;\n      const s = this.do();\n      let n = 0,\n        e = 0;\n      for (const r of s) {\n        if (!r.Et()) continue;\n        const s = r.zt();\n        if (null === s) continue;\n        const h = r.Mh(t.Uh(), t.bi());\n        let l = h && h.Qe();\n        if (null !== l) {\n          switch (this.Ps.mode) {\n            case 1:\n              l = hi(l, this.gl);\n              break;\n            case 2:\n              l = ii(l, s.Ft);\n              break;\n            case 3:\n              l = ni(l, s.Ft);\n          }\n          if (((i = null === i ? l : i.vn(a(l))), null !== h)) {\n            const t = h.tr();\n            null !== t &&\n              ((n = Math.max(n, t.above)), (e = Math.max(e, t.below)));\n          }\n        }\n      }\n      if (\n        (this.ja() &&\n          ((n = Math.max(n, this.Ya())), (e = Math.max(e, this.Ya()))),\n        (n === this.ol && e === this._l) ||\n          ((this.ol = n), (this._l = e), (this.vl = null), this.Tl()),\n        null !== i)\n      ) {\n        if (i.$e() === i.je()) {\n          const t = this.fl,\n            s = 5 * (null === t || this.Oe() || this.El() ? 1 : t.ea());\n          this.Qa() && (i = ai(i, this.gl)),\n            (i = new dt(i.$e() - s, i.je() + s)),\n            this.Qa() && (i = hi(i, this.gl));\n        }\n        if (this.Qa()) {\n          const t = ai(i, this.gl),\n            s = li(t);\n          if (((r = s), (h = this.gl), r.Va !== h.Va || r.Ba !== h.Ba)) {\n            const n = null !== this.el ? ai(this.el, this.gl) : null;\n            (this.gl = s), (i = hi(t, s)), null !== n && (this.el = hi(n, s));\n          }\n        }\n        this.Bl(i);\n      } else\n        null === this.Ge && (this.Bl(new dt(-0.5, 0.5)), (this.gl = li(null)));\n      var r, h;\n    }\n    jl() {\n      return this.Oe()\n        ? ti\n        : this.El()\n        ? si\n        : this.Qa()\n        ? (t) => ei(t, this.gl)\n        : null;\n    }\n    vo(t, i, s) {\n      return void 0 === i\n        ? (void 0 === s && (s = this.ra()), s.format(t))\n        : i(t);\n    }\n    mo(t, i, s) {\n      return void 0 === i\n        ? (void 0 === s && (s = this.ra()), s.formatTickmarks(t))\n        : i(t);\n    }\n    nr(t, i) {\n      return this.vo(t, this.xl.priceFormatter, i);\n    }\n    co(t, i) {\n      const s = this.xl.priceFormatter;\n      return this.mo(\n        t,\n        this.xl.tickmarksPriceFormatter ?? (s ? (t) => t.map(s) : void 0),\n        i,\n      );\n    }\n    _o(t, i) {\n      return this.vo(t, this.xl.percentageFormatter, i);\n    }\n    uo(t, i) {\n      const s = this.xl.percentageFormatter;\n      return this.mo(\n        t,\n        this.xl.tickmarksPercentageFormatter ?? (s ? (t) => t.map(s) : void 0),\n        i,\n      );\n    }\n  }\n  function vi(t) {\n    return t instanceof Ut;\n  }\n  class mi {\n    constructor(t, i) {\n      (this.dl = []),\n        (this.wo = new Map()),\n        (this.sl = 0),\n        (this.Mo = 0),\n        (this.bo = 1),\n        (this.pl = null),\n        (this.xo = !1),\n        (this.So = new o()),\n        (this.yh = []),\n        (this.uh = t),\n        (this.ts = i),\n        (this.Co = new Jt(this));\n      const s = i.N();\n      (this.Po = this.yo('left', s.leftPriceScale)),\n        (this.ko = this.yo('right', s.rightPriceScale)),\n        this.Po.Al().i(this.To.bind(this, this.Po), this),\n        this.ko.Al().i(this.To.bind(this, this.ko), this),\n        this.Ro(s);\n    }\n    Ro(t) {\n      if (\n        (t.leftPriceScale && this.Po.hr(t.leftPriceScale),\n        t.rightPriceScale && this.ko.hr(t.rightPriceScale),\n        t.localization && (this.Po.ga(), this.ko.ga()),\n        t.overlayPriceScales)\n      ) {\n        const i = Array.from(this.wo.values());\n        for (const s of i) {\n          const i = a(s[0].Wt());\n          i.hr(t.overlayPriceScales), t.localization && i.ga();\n        }\n      }\n    }\n    Do(t) {\n      switch (t) {\n        case 'left':\n          return this.Po;\n        case 'right':\n          return this.ko;\n      }\n      return this.wo.has(t) ? h(this.wo.get(t))[0].Wt() : null;\n    }\n    m() {\n      this.Qt().Eo().u(this),\n        this.Po.Al().u(this),\n        this.ko.Al().u(this),\n        this.dl.forEach((t) => {\n          t.m && t.m();\n        }),\n        (this.yh = this.yh.filter((t) => {\n          const i = t.oh();\n          return i.detached && i.detached(), !1;\n        })),\n        this.So.p();\n    }\n    Vo() {\n      return this.bo;\n    }\n    Bo(t) {\n      this.bo = t;\n    }\n    Qt() {\n      return this.ts;\n    }\n    Qi() {\n      return this.Mo;\n    }\n    $t() {\n      return this.sl;\n    }\n    Io(t) {\n      (this.Mo = t), this.Ao();\n    }\n    zl(t) {\n      (this.sl = t),\n        this.Po.zl(t),\n        this.ko.zl(t),\n        this.dl.forEach((i) => {\n          if (this.Un(i)) {\n            const s = i.Wt();\n            null !== s && s.zl(t);\n          }\n        }),\n        this.Ao();\n    }\n    zo(t) {\n      this.xo = t;\n    }\n    Oo() {\n      return this.xo;\n    }\n    Lo() {\n      return this.dl.filter(vi);\n    }\n    ba() {\n      return this.dl;\n    }\n    Un(t) {\n      const i = t.Wt();\n      return null === i || (this.Po !== i && this.ko !== i);\n    }\n    Jl(t, i, s) {\n      this.No(t, i, s ? t.hs() : this.dl.length);\n    }\n    io(t, i) {\n      const s = this.dl.indexOf(t);\n      r(-1 !== s, 'removeDataSource: invalid data source'),\n        this.dl.splice(s, 1),\n        i || this.dl.forEach((t, i) => t.ls(i));\n      const n = a(t.Wt()).wa();\n      if (this.wo.has(n)) {\n        const i = h(this.wo.get(n)),\n          s = i.indexOf(t);\n        -1 !== s && (i.splice(s, 1), 0 === i.length && this.wo.delete(n));\n      }\n      const e = t.Wt();\n      e && e.ba().indexOf(t) >= 0 && (e.io(t), this.Wo(e)), (this.pl = null);\n    }\n    jn(t) {\n      return t === this.Po ? 'left' : t === this.ko ? 'right' : 'overlay';\n    }\n    Fo() {\n      return this.Po;\n    }\n    Ho() {\n      return this.ko;\n    }\n    Uo(t, i) {\n      t.eo(i);\n    }\n    $o(t, i) {\n      t.ro(i), this.Ao();\n    }\n    jo(t) {\n      t.ho();\n    }\n    qo(t, i) {\n      t.ao(i);\n    }\n    Yo(t, i) {\n      t.lo(i), this.Ao();\n    }\n    Ko(t) {\n      t.oo();\n    }\n    Ao() {\n      this.dl.forEach((t) => {\n        t.Ns();\n      });\n    }\n    ks() {\n      let t = null;\n      return (\n        this.ts.N().rightPriceScale.visible && 0 !== this.ko.ba().length\n          ? (t = this.ko)\n          : this.ts.N().leftPriceScale.visible && 0 !== this.Po.ba().length\n          ? (t = this.Po)\n          : 0 !== this.dl.length && (t = this.dl[0].Wt()),\n        null === t && (t = this.ko),\n        t\n      );\n    }\n    $n() {\n      let t = null;\n      return (\n        this.ts.N().rightPriceScale.visible\n          ? (t = this.ko)\n          : this.ts.N().leftPriceScale.visible && (t = this.Po),\n        t\n      );\n    }\n    Wo(t) {\n      null !== t && t.Rl() && this.Xo(t);\n    }\n    Zo(t) {\n      const i = this.uh.Pe();\n      t.kl({ sn: !0 }), null !== i && t.fo(i), this.Ao();\n    }\n    Go() {\n      this.Xo(this.Po), this.Xo(this.ko);\n    }\n    Jo() {\n      this.Wo(this.Po),\n        this.Wo(this.ko),\n        this.dl.forEach((t) => {\n          this.Un(t) && this.Wo(t.Wt());\n        }),\n        this.Ao(),\n        this.ts.ar();\n    }\n    Dt() {\n      return null === this.pl && (this.pl = ui(this.dl)), this.pl;\n    }\n    Qo(t, i) {\n      i = Yt(i, 0, this.dl.length - 1);\n      const s = this.dl.indexOf(t);\n      r(-1 !== s, 'setSeriesOrder: invalid data source'),\n        this.dl.splice(s, 1),\n        this.dl.splice(i, 0, t),\n        this.dl.forEach((t, i) => t.ls(i)),\n        (this.pl = null);\n      for (const t of [this.Po, this.ko]) t.Ql(), t.ga();\n      this.ts.ar();\n    }\n    Vt() {\n      return this.Dt().filter(vi);\n    }\n    t_() {\n      return this.So;\n    }\n    i_() {\n      return this.Co;\n    }\n    ua(t) {\n      this.yh.push(new Et(t));\n    }\n    ca(t) {\n      (this.yh = this.yh.filter((i) => i.oh() !== t)),\n        t.detached && t.detached(),\n        this.ts.ar();\n    }\n    s_() {\n      return this.yh;\n    }\n    sa(t, i) {\n      return this.yh.map((s) => s.Yn(t, i)).filter((t) => null !== t);\n    }\n    Xo(t) {\n      const i = t.do();\n      if (i && i.length > 0 && !this.uh.Ki()) {\n        const i = this.uh.Pe();\n        null !== i && t.fo(i);\n      }\n      t.Ns();\n    }\n    No(t, i, s) {\n      let n = this.Do(i);\n      if (\n        (null === n && (n = this.yo(i, this.ts.N().overlayPriceScales)),\n        this.dl.splice(s, 0, t),\n        !q(i))\n      ) {\n        const s = this.wo.get(i) || [];\n        s.push(t), this.wo.set(i, s);\n      }\n      t.ls(s), n.Jl(t), t._s(n), this.Wo(n), (this.pl = null);\n    }\n    To(t, i, s) {\n      i.ie !== s.ie && this.Xo(t);\n    }\n    yo(t, i) {\n      const s = { visible: !0, autoScale: !0, ...p(i) },\n        n = new pi(\n          t,\n          s,\n          this.ts.N().layout,\n          this.ts.N().localization,\n          this.ts.Xi(),\n        );\n      return n.zl(this.$t()), n;\n    }\n  }\n  function wi(t) {\n    return { n_: t.n_, e_: { Kn: t.r_.externalId }, h_: t.r_.cursorStyle };\n  }\n  function gi(t, i, s, n) {\n    for (const e of t) {\n      const t = e.Tt(n);\n      if (null !== t && t.Yn) {\n        const n = t.Yn(i, s);\n        if (null !== n) return { a_: e, e_: n };\n      }\n    }\n    return null;\n  }\n  function Mi(t) {\n    return void 0 !== t.Ws;\n  }\n  function bi(t, i, s) {\n    const n = [t, ...t.Dt()],\n      e = (function (t, i, s) {\n        let n, e;\n        for (const a of t) {\n          const t = a.sa?.(i, s) ?? [];\n          for (const i of t)\n            (r = i.zOrder),\n              (h = n?.zOrder),\n              (!h ||\n                ('top' === r && 'top' !== h) ||\n                ('normal' === r && 'bottom' === h)) &&\n                ((n = i), (e = a));\n        }\n        var r, h;\n        return n && e ? { r_: n, n_: e } : null;\n      })(n, i, s);\n    if ('top' === e?.r_.zOrder) return wi(e);\n    for (const r of n) {\n      if (e && e.n_ === r && 'bottom' !== e.r_.zOrder && !e.r_.isBackground)\n        return wi(e);\n      if (Mi(r)) {\n        const n = gi(r.Ws(t), i, s, t);\n        if (null !== n) return { n_: r, a_: n.a_, e_: n.e_ };\n      }\n      if (e && e.n_ === r && 'bottom' !== e.r_.zOrder && e.r_.isBackground)\n        return wi(e);\n    }\n    return e?.r_ ? wi(e) : null;\n  }\n  class xi {\n    constructor(t, i, s = 50) {\n      (this.yn = 0),\n        (this.kn = 1),\n        (this.Tn = 1),\n        (this.Dn = new Map()),\n        (this.Rn = new Map()),\n        (this.l_ = t),\n        (this.o_ = i),\n        (this.En = s);\n    }\n    __(t) {\n      const i = t.time,\n        s = this.o_.cacheKey(i),\n        n = this.Dn.get(s);\n      if (void 0 !== n) return n.u_;\n      if (this.yn === this.En) {\n        const t = this.Rn.get(this.Tn);\n        this.Rn.delete(this.Tn), this.Dn.delete(h(t)), this.Tn++, this.yn--;\n      }\n      const e = this.l_(t);\n      return (\n        this.Dn.set(s, { u_: e, An: this.kn }),\n        this.Rn.set(this.kn, s),\n        this.yn++,\n        this.kn++,\n        e\n      );\n    }\n  }\n  class Si {\n    constructor(t, i) {\n      r(t <= i, 'right should be >= left'), (this.c_ = t), (this.d_ = i);\n    }\n    Uh() {\n      return this.c_;\n    }\n    bi() {\n      return this.d_;\n    }\n    f_() {\n      return this.d_ - this.c_ + 1;\n    }\n    Te(t) {\n      return this.c_ <= t && t <= this.d_;\n    }\n    He(t) {\n      return this.c_ === t.Uh() && this.d_ === t.bi();\n    }\n  }\n  function Ci(t, i) {\n    return null === t || null === i ? t === i : t.He(i);\n  }\n  class Pi {\n    constructor() {\n      (this.p_ = new Map()), (this.Dn = null), (this.v_ = !1);\n    }\n    m_(t) {\n      (this.v_ = t), (this.Dn = null);\n    }\n    w_(t, i) {\n      this.g_(i), (this.Dn = null);\n      for (let s = i; s < t.length; ++s) {\n        const i = t[s];\n        let n = this.p_.get(i.timeWeight);\n        void 0 === n && ((n = []), this.p_.set(i.timeWeight, n)),\n          n.push({\n            index: s,\n            time: i.time,\n            weight: i.timeWeight,\n            originalTime: i.originalTime,\n          });\n      }\n    }\n    M_(t, i, s, n, e) {\n      const r = Math.ceil(i / t);\n      return (\n        (null !== this.Dn &&\n          this.Dn.b_ === r &&\n          e === this.Dn.x_ &&\n          s === this.Dn.S_) ||\n          (this.Dn = { x_: e, S_: s, Ea: this.C_(r, s, n), b_: r }),\n        this.Dn.Ea\n      );\n    }\n    g_(t) {\n      if (0 === t) return void this.p_.clear();\n      const i = [];\n      this.p_.forEach((s, n) => {\n        t <= s[0].index\n          ? i.push(n)\n          : s.splice(\n              xt(s, t, (i) => i.index < t),\n              1 / 0,\n            );\n      });\n      for (const t of i) this.p_.delete(t);\n    }\n    C_(t, i, s) {\n      let n = [];\n      const e = (t) => !i || s.has(t.index);\n      for (const i of Array.from(this.p_.keys()).sort((t, i) => i - t)) {\n        if (!this.p_.get(i)) continue;\n        const s = n;\n        n = [];\n        const r = s.length;\n        let a = 0;\n        const l = h(this.p_.get(i)),\n          o = l.length;\n        let _ = 1 / 0,\n          u = -1 / 0;\n        for (let i = 0; i < o; i++) {\n          const h = l[i],\n            o = h.index;\n          for (; a < r; ) {\n            const t = s[a],\n              i = t.index;\n            if (!(i < o && e(t))) {\n              _ = i;\n              break;\n            }\n            a++, n.push(t), (u = i), (_ = 1 / 0);\n          }\n          if (_ - o >= t && o - u >= t && e(h)) n.push(h), (u = o);\n          else if (this.v_) return s;\n        }\n        for (; a < r; a++) e(s[a]) && n.push(s[a]);\n      }\n      return n;\n    }\n  }\n  class yi {\n    constructor(t) {\n      this.P_ = t;\n    }\n    y_() {\n      return null === this.P_\n        ? null\n        : new Si(Math.floor(this.P_.Uh()), Math.ceil(this.P_.bi()));\n    }\n    k_() {\n      return this.P_;\n    }\n    static T_() {\n      return new yi(null);\n    }\n  }\n  function ki(t, i) {\n    return t.weight > i.weight ? t : i;\n  }\n  class Ti {\n    constructor(t, i, s, n) {\n      (this.Mo = 0),\n        (this.R_ = null),\n        (this.D_ = []),\n        (this.wl = null),\n        (this.ml = null),\n        (this.E_ = new Pi()),\n        (this.V_ = new Map()),\n        (this.B_ = yi.T_()),\n        (this.I_ = !0),\n        (this.A_ = new o()),\n        (this.z_ = new o()),\n        (this.O_ = new o()),\n        (this.L_ = null),\n        (this.N_ = null),\n        (this.W_ = new Map()),\n        (this.F_ = -1),\n        (this.H_ = []),\n        (this.Ps = i),\n        (this.xl = s),\n        (this.U_ = i.rightOffset),\n        (this.j_ = i.barSpacing),\n        (this.ts = t),\n        (this.o_ = n),\n        this.q_(),\n        this.E_.m_(i.uniformDistribution),\n        this.Y_();\n    }\n    N() {\n      return this.Ps;\n    }\n    K_(t) {\n      _(this.xl, t), this.X_(), this.q_();\n    }\n    hr(t, i) {\n      _(this.Ps, t),\n        this.Ps.fixLeftEdge && this.Z_(),\n        this.Ps.fixRightEdge && this.G_(),\n        void 0 !== t.barSpacing && this.ts.dn(t.barSpacing),\n        void 0 !== t.rightOffset && this.ts.fn(t.rightOffset),\n        (void 0 === t.minBarSpacing && void 0 === t.maxBarSpacing) ||\n          this.ts.dn(t.barSpacing ?? this.j_),\n        void 0 !== t.ignoreWhitespaceIndices &&\n          t.ignoreWhitespaceIndices !== this.Ps.ignoreWhitespaceIndices &&\n          this.Y_(),\n        this.X_(),\n        this.q_(),\n        this.O_.p();\n    }\n    Rs(t) {\n      return this.D_[t]?.time ?? null;\n    }\n    ss(t) {\n      return this.D_[t] ?? null;\n    }\n    J_(t, i) {\n      if (this.D_.length < 1) return null;\n      if (this.o_.key(t) > this.o_.key(this.D_[this.D_.length - 1].time))\n        return i ? this.D_.length - 1 : null;\n      const s = xt(this.D_, this.o_.key(t), (t, i) => this.o_.key(t.time) < i);\n      return this.o_.key(t) < this.o_.key(this.D_[s].time) ? (i ? s : null) : s;\n    }\n    Ki() {\n      return 0 === this.Mo || 0 === this.D_.length || null === this.R_;\n    }\n    Q_() {\n      return this.D_.length > 0;\n    }\n    Pe() {\n      return this.tu(), this.B_.y_();\n    }\n    iu() {\n      return this.tu(), this.B_.k_();\n    }\n    su() {\n      const t = this.Pe();\n      if (null === t) return null;\n      const i = { from: t.Uh(), to: t.bi() };\n      return this.nu(i);\n    }\n    nu(t) {\n      const i = Math.round(t.from),\n        s = Math.round(t.to),\n        n = a(this.eu()),\n        e = a(this.ru());\n      return {\n        from: a(this.ss(Math.max(n, i))),\n        to: a(this.ss(Math.min(e, s))),\n      };\n    }\n    hu(t) {\n      return { from: a(this.J_(t.from, !0)), to: a(this.J_(t.to, !0)) };\n    }\n    Qi() {\n      return this.Mo;\n    }\n    Io(t) {\n      if (!isFinite(t) || t <= 0) return;\n      if (this.Mo === t) return;\n      const i = this.iu(),\n        s = this.Mo;\n      if (\n        ((this.Mo = t),\n        (this.I_ = !0),\n        this.Ps.lockVisibleTimeRangeOnResize && 0 !== s)\n      ) {\n        const i = (this.j_ * t) / s;\n        this.j_ = i;\n      }\n      if (this.Ps.fixLeftEdge && null !== i && i.Uh() <= 0) {\n        const i = s - t;\n        (this.U_ -= Math.round(i / this.j_) + 1), (this.I_ = !0);\n      }\n      this.au(), this.lu();\n    }\n    jt(t) {\n      if (this.Ki() || !c(t)) return 0;\n      const i = this.ou() + this.U_ - t;\n      return this.Mo - (i + 0.5) * this.j_ - 1;\n    }\n    _u(t, i) {\n      const s = this.ou(),\n        n = void 0 === i ? 0 : i.from,\n        e = void 0 === i ? t.length : i.to;\n      for (let i = n; i < e; i++) {\n        const n = t[i].wt,\n          e = s + this.U_ - n,\n          r = this.Mo - (e + 0.5) * this.j_ - 1;\n        t[i]._t = r;\n      }\n    }\n    uu(t, i) {\n      const s = Math.ceil(this.cu(t));\n      return i && this.Ps.ignoreWhitespaceIndices && !this.du(s)\n        ? this.fu(s)\n        : s;\n    }\n    fn(t) {\n      (this.I_ = !0), (this.U_ = t), this.lu(), this.ts.pu(), this.ts.ar();\n    }\n    vu() {\n      return this.j_;\n    }\n    dn(t) {\n      this.mu(t), this.lu(), this.ts.pu(), this.ts.ar();\n    }\n    wu() {\n      return this.U_;\n    }\n    Ea() {\n      if (this.Ki()) return null;\n      if (null !== this.N_) return this.N_;\n      const t = this.j_,\n        i =\n          ((5 * (this.ts.N().layout.fontSize + 4)) / 8) *\n          (this.Ps.tickMarkMaxCharacterLength || 8),\n        s = Math.round(i / t),\n        n = a(this.Pe()),\n        e = Math.max(n.Uh(), n.Uh() - s),\n        r = Math.max(n.bi(), n.bi() - s),\n        h = this.E_.M_(t, i, this.Ps.ignoreWhitespaceIndices, this.W_, this.F_),\n        l = this.eu() + s,\n        o = this.ru() - s,\n        _ = this.gu(),\n        u = this.Ps.fixLeftEdge || _,\n        c = this.Ps.fixRightEdge || _;\n      let d = 0;\n      for (const t of h) {\n        if (!(e <= t.index && t.index <= r)) continue;\n        let s;\n        d < this.H_.length\n          ? ((s = this.H_[d]),\n            (s.coord = this.jt(t.index)),\n            (s.label = this.Mu(t)),\n            (s.weight = t.weight))\n          : ((s = {\n              needAlignCoordinate: !1,\n              coord: this.jt(t.index),\n              label: this.Mu(t),\n              weight: t.weight,\n            }),\n            this.H_.push(s)),\n          this.j_ > i / 2 && !_\n            ? (s.needAlignCoordinate = !1)\n            : (s.needAlignCoordinate =\n                (u && t.index <= l) || (c && t.index >= o)),\n          d++;\n      }\n      return (this.H_.length = d), (this.N_ = this.H_), this.H_;\n    }\n    bu() {\n      (this.I_ = !0), this.dn(this.Ps.barSpacing), this.fn(this.Ps.rightOffset);\n    }\n    xu(t) {\n      (this.I_ = !0), (this.R_ = t), this.lu(), this.Z_();\n    }\n    Su(t, i) {\n      const s = this.cu(t),\n        n = this.vu(),\n        e = n + i * (n / 10);\n      this.dn(e),\n        this.Ps.rightBarStaysOnScroll || this.fn(this.wu() + (s - this.cu(t)));\n    }\n    eo(t) {\n      this.wl && this.oo(),\n        null === this.ml &&\n          null === this.L_ &&\n          (this.Ki() || ((this.ml = t), this.Cu()));\n    }\n    ro(t) {\n      if (null === this.L_) return;\n      const i = Yt(this.Mo - t, 0, this.Mo),\n        s = Yt(this.Mo - a(this.ml), 0, this.Mo);\n      0 !== i && 0 !== s && this.dn((this.L_.vu * i) / s);\n    }\n    ho() {\n      null !== this.ml && ((this.ml = null), this.Pu());\n    }\n    ao(t) {\n      null === this.wl &&\n        null === this.L_ &&\n        (this.Ki() || ((this.wl = t), this.Cu()));\n    }\n    lo(t) {\n      if (null === this.wl) return;\n      const i = (this.wl - t) / this.vu();\n      (this.U_ = a(this.L_).wu + i), (this.I_ = !0), this.lu();\n    }\n    oo() {\n      null !== this.wl && ((this.wl = null), this.Pu());\n    }\n    yu() {\n      this.ku(this.Ps.rightOffset);\n    }\n    ku(t, i = 400) {\n      if (!isFinite(t))\n        throw new RangeError('offset is required and must be finite number');\n      if (!isFinite(i) || i <= 0)\n        throw new RangeError(\n          'animationDuration (optional) must be finite positive number',\n        );\n      const s = this.U_,\n        n = performance.now();\n      this.ts._n({\n        Tu: (t) => (t - n) / i >= 1,\n        Ru: (e) => {\n          const r = (e - n) / i;\n          return r >= 1 ? t : s + (t - s) * r;\n        },\n      });\n    }\n    yt(t, i) {\n      (this.I_ = !0), (this.D_ = t), this.E_.w_(t, i), this.lu();\n    }\n    Du() {\n      return this.A_;\n    }\n    Eu() {\n      return this.z_;\n    }\n    Vu() {\n      return this.O_;\n    }\n    ou() {\n      return this.R_ || 0;\n    }\n    Bu(t) {\n      const i = t.f_();\n      this.mu(this.Mo / i),\n        (this.U_ = t.bi() - this.ou()),\n        this.lu(),\n        (this.I_ = !0),\n        this.ts.pu(),\n        this.ts.ar();\n    }\n    Iu() {\n      const t = this.eu(),\n        i = this.ru();\n      null !== t && null !== i && this.Bu(new Si(t, i + this.Ps.rightOffset));\n    }\n    Au(t) {\n      const i = new Si(t.from, t.to);\n      this.Bu(i);\n    }\n    ns(t) {\n      return void 0 !== this.xl.timeFormatter\n        ? this.xl.timeFormatter(t.originalTime)\n        : this.o_.formatHorzItem(t.time);\n    }\n    Y_() {\n      if (!this.Ps.ignoreWhitespaceIndices) return;\n      this.W_.clear();\n      const t = this.ts.Ys();\n      for (const i of t) for (const t of i.ma()) this.W_.set(t, !0);\n      this.F_++;\n    }\n    gu() {\n      const t = this.ts.N().handleScroll,\n        i = this.ts.N().handleScale;\n      return !(\n        t.horzTouchDrag ||\n        t.mouseWheel ||\n        t.pressedMouseMove ||\n        t.vertTouchDrag ||\n        i.axisDoubleClickReset.time ||\n        i.axisPressedMouseMove.time ||\n        i.mouseWheel ||\n        i.pinch\n      );\n    }\n    eu() {\n      return 0 === this.D_.length ? null : 0;\n    }\n    ru() {\n      return 0 === this.D_.length ? null : this.D_.length - 1;\n    }\n    zu(t) {\n      return (this.Mo - 1 - t) / this.j_;\n    }\n    cu(t) {\n      const i = this.zu(t),\n        s = this.ou() + this.U_ - i;\n      return Math.round(1e6 * s) / 1e6;\n    }\n    mu(t) {\n      const i = this.j_;\n      (this.j_ = t), this.au(), i !== this.j_ && ((this.I_ = !0), this.Ou());\n    }\n    tu() {\n      if (!this.I_) return;\n      if (((this.I_ = !1), this.Ki())) return void this.Lu(yi.T_());\n      const t = this.ou(),\n        i = this.Mo / this.j_,\n        s = this.U_ + t,\n        n = new Si(s - i + 1, s);\n      this.Lu(new yi(n));\n    }\n    au() {\n      const t = Yt(this.j_, this.Nu(), this.Wu());\n      this.j_ !== t && ((this.j_ = t), (this.I_ = !0));\n    }\n    Wu() {\n      return this.Ps.maxBarSpacing > 0 ? this.Ps.maxBarSpacing : 0.5 * this.Mo;\n    }\n    Nu() {\n      return this.Ps.fixLeftEdge && this.Ps.fixRightEdge && 0 !== this.D_.length\n        ? this.Mo / this.D_.length\n        : this.Ps.minBarSpacing;\n    }\n    lu() {\n      const t = this.Fu();\n      null !== t && this.U_ < t && ((this.U_ = t), (this.I_ = !0));\n      const i = this.Hu();\n      this.U_ > i && ((this.U_ = i), (this.I_ = !0));\n    }\n    Fu() {\n      const t = this.eu(),\n        i = this.R_;\n      if (null === t || null === i) return null;\n      return (\n        t -\n        i -\n        1 +\n        (this.Ps.fixLeftEdge ? this.Mo / this.j_ : Math.min(2, this.D_.length))\n      );\n    }\n    Hu() {\n      return this.Ps.fixRightEdge\n        ? 0\n        : this.Mo / this.j_ - Math.min(2, this.D_.length);\n    }\n    Cu() {\n      this.L_ = { vu: this.vu(), wu: this.wu() };\n    }\n    Pu() {\n      this.L_ = null;\n    }\n    Mu(t) {\n      let i = this.V_.get(t.weight);\n      return (\n        void 0 === i &&\n          ((i = new xi((t) => this.Uu(t), this.o_)), this.V_.set(t.weight, i)),\n        i.__(t)\n      );\n    }\n    Uu(t) {\n      return this.o_.formatTickmark(t, this.xl);\n    }\n    Lu(t) {\n      const i = this.B_;\n      (this.B_ = t),\n        Ci(i.y_(), this.B_.y_()) || this.A_.p(),\n        Ci(i.k_(), this.B_.k_()) || this.z_.p(),\n        this.Ou();\n    }\n    Ou() {\n      this.N_ = null;\n    }\n    X_() {\n      this.Ou(), this.V_.clear();\n    }\n    q_() {\n      this.o_.updateFormatter(this.xl);\n    }\n    Z_() {\n      if (!this.Ps.fixLeftEdge) return;\n      const t = this.eu();\n      if (null === t) return;\n      const i = this.Pe();\n      if (null === i) return;\n      const s = i.Uh() - t;\n      if (s < 0) {\n        const t = this.U_ - s - 1;\n        this.fn(t);\n      }\n      this.au();\n    }\n    G_() {\n      this.lu(), this.au();\n    }\n    du(t) {\n      return !this.Ps.ignoreWhitespaceIndices || this.W_.get(t) || !1;\n    }\n    fu(t) {\n      const i = (function* (t) {\n          const i = Math.round(t),\n            s = i < t;\n          let n = 1;\n          for (;;)\n            s ? (yield i + n, yield i - n) : (yield i - n, yield i + n), n++;\n        })(t),\n        s = this.ru();\n      for (; s; ) {\n        const t = i.next().value;\n        if (this.W_.get(t)) return t;\n        if (t < 0 || t > s) break;\n      }\n      return t;\n    }\n  }\n  var Ri, Di, Ei, Vi, Bi;\n  !(function (t) {\n    (t[(t.OnTouchEnd = 0)] = 'OnTouchEnd'),\n      (t[(t.OnNextTap = 1)] = 'OnNextTap');\n  })(Ri || (Ri = {}));\n  class Ii {\n    constructor(t, i, s) {\n      (this.$u = []),\n        (this.ju = []),\n        (this.Mo = 0),\n        (this.qu = null),\n        (this.Yu = new o()),\n        (this.Ku = new o()),\n        (this.Xu = null),\n        (this.Zu = t),\n        (this.Ps = i),\n        (this.o_ = s),\n        (this.Sl = new S(this.Ps.layout.colorParsers)),\n        (this.Gu = new M(this)),\n        (this.uh = new Ti(this, i.timeScale, this.Ps.localization, s)),\n        (this.Ct = new j(this, i.crosshair)),\n        (this.Ju = new qt(i.crosshair)),\n        i.addDefaultPane && (this.Qu(0), this.$u[0].Bo(2)),\n        (this.tc = this.sc(0)),\n        (this.nc = this.sc(1));\n    }\n    Bh() {\n      this.ec(Y.gn());\n    }\n    ar() {\n      this.ec(Y.wn());\n    }\n    Zh() {\n      this.ec(new Y(1));\n    }\n    Ih(t) {\n      const i = this.rc(t);\n      this.ec(i);\n    }\n    hc() {\n      return this.qu;\n    }\n    ac(t) {\n      if (this.qu?.n_ === t?.n_ && this.qu?.e_?.Kn === t?.e_?.Kn) return;\n      const i = this.qu;\n      (this.qu = t),\n        null !== i && this.Ih(i.n_),\n        null !== t && t.n_ !== i?.n_ && this.Ih(t.n_);\n    }\n    N() {\n      return this.Ps;\n    }\n    hr(t) {\n      _(this.Ps, t),\n        this.$u.forEach((i) => i.Ro(t)),\n        void 0 !== t.timeScale && this.uh.hr(t.timeScale),\n        void 0 !== t.localization && this.uh.K_(t.localization),\n        (t.leftPriceScale || t.rightPriceScale) && this.Yu.p(),\n        (this.tc = this.sc(0)),\n        (this.nc = this.sc(1)),\n        this.Bh();\n    }\n    lc(t, i, s = 0) {\n      const n = this.$u[s];\n      if (void 0 === n) return;\n      if ('left' === t)\n        return (\n          _(this.Ps, { leftPriceScale: i }),\n          n.Ro({ leftPriceScale: i }),\n          this.Yu.p(),\n          void this.Bh()\n        );\n      if ('right' === t)\n        return (\n          _(this.Ps, { rightPriceScale: i }),\n          n.Ro({ rightPriceScale: i }),\n          this.Yu.p(),\n          void this.Bh()\n        );\n      const e = this.oc(t, s);\n      null !== e && (e.Wt.hr(i), this.Yu.p());\n    }\n    oc(t, i) {\n      const s = this.$u[i];\n      if (void 0 === s) return null;\n      const n = s.Do(t);\n      return null !== n ? { Us: s, Wt: n } : null;\n    }\n    It() {\n      return this.uh;\n    }\n    $s() {\n      return this.$u;\n    }\n    _c() {\n      return this.Ct;\n    }\n    uc() {\n      return this.Ku;\n    }\n    cc(t, i) {\n      t.zl(i), this.pu();\n    }\n    Io(t) {\n      (this.Mo = t),\n        this.uh.Io(this.Mo),\n        this.$u.forEach((i) => i.Io(t)),\n        this.pu();\n    }\n    dc(t) {\n      1 !== this.$u.length &&\n        (r(t >= 0 && t < this.$u.length, 'Invalid pane index'),\n        this.$u.splice(t, 1),\n        this.Bh());\n    }\n    fc(t, i) {\n      if (this.$u.length < 2) return;\n      r(t >= 0 && t < this.$u.length, 'Invalid pane index');\n      const s = this.$u[t],\n        n = this.$u.reduce((t, i) => t + i.Vo(), 0),\n        e = this.$u.reduce((t, i) => t + i.$t(), 0),\n        h = e - 30 * (this.$u.length - 1);\n      i = Math.min(h, Math.max(30, i));\n      const a = n / e,\n        l = s.$t();\n      s.Bo(i * a);\n      let o = i - l,\n        _ = this.$u.length - 1;\n      for (const t of this.$u)\n        if (t !== s) {\n          const i = Math.min(h, Math.max(30, t.$t() - o / _));\n          (o -= t.$t() - i), (_ -= 1);\n          const s = i * a;\n          t.Bo(s);\n        }\n      this.Bh();\n    }\n    vc(t, i) {\n      r(\n        t >= 0 && t < this.$u.length && i >= 0 && i < this.$u.length,\n        'Invalid pane index',\n      );\n      const s = this.$u[t],\n        n = this.$u[i];\n      (this.$u[t] = n), (this.$u[i] = s), this.Bh();\n    }\n    mc(t, i) {\n      if (\n        (r(\n          t >= 0 && t < this.$u.length && i >= 0 && i < this.$u.length,\n          'Invalid pane index',\n        ),\n        t === i)\n      )\n        return;\n      const [s] = this.$u.splice(t, 1);\n      this.$u.splice(i, 0, s), this.Bh();\n    }\n    Uo(t, i, s) {\n      t.Uo(i, s);\n    }\n    $o(t, i, s) {\n      t.$o(i, s), this.Ah(), this.ec(this.wc(t, 2));\n    }\n    jo(t, i) {\n      t.jo(i), this.ec(this.wc(t, 2));\n    }\n    qo(t, i, s) {\n      i.Rl() || t.qo(i, s);\n    }\n    Yo(t, i, s) {\n      i.Rl() || (t.Yo(i, s), this.Ah(), this.ec(this.wc(t, 2)));\n    }\n    Ko(t, i) {\n      i.Rl() || (t.Ko(i), this.ec(this.wc(t, 2)));\n    }\n    Zo(t, i) {\n      t.Zo(i), this.ec(this.wc(t, 2));\n    }\n    gc(t) {\n      this.uh.eo(t);\n    }\n    Mc(t, i) {\n      const s = this.It();\n      if (s.Ki() || 0 === i) return;\n      const n = s.Qi();\n      (t = Math.max(1, Math.min(t, n))), s.Su(t, i), this.pu();\n    }\n    bc(t) {\n      this.xc(0), this.Sc(t), this.Cc();\n    }\n    Pc(t) {\n      this.uh.ro(t), this.pu();\n    }\n    yc() {\n      this.uh.ho(), this.ar();\n    }\n    xc(t) {\n      this.uh.ao(t);\n    }\n    Sc(t) {\n      this.uh.lo(t), this.pu();\n    }\n    Cc() {\n      this.uh.oo(), this.ar();\n    }\n    Ys() {\n      return this.ju;\n    }\n    kc(t, i, s, n, e) {\n      this.Ct.Es(t, i);\n      let r = NaN,\n        h = this.uh.uu(t, !0);\n      const a = this.uh.Pe();\n      null !== a && (h = Math.min(Math.max(a.Uh(), h), a.bi()));\n      const l = n.ks(),\n        o = l.zt();\n      if (\n        (null !== o && (r = l.Ts(i, o)),\n        (r = this.Ju.Ma(r, h, n)),\n        this.Ct.As(h, r, n),\n        this.Zh(),\n        !e)\n      ) {\n        const e = bi(n, t, i);\n        this.ac(e && { n_: e.n_, e_: e.e_, h_: e.h_ || null }),\n          this.Ku.p(this.Ct.Bt(), { x: t, y: i }, s);\n      }\n    }\n    Tc(t, i, s) {\n      const n = s.ks(),\n        e = n.zt(),\n        r = n.Nt(t, a(e)),\n        h = this.uh.J_(i, !0),\n        l = this.uh.jt(a(h));\n      this.kc(l, r, null, s, !0);\n    }\n    Rc(t) {\n      this._c().Os(), this.Zh(), t || this.Ku.p(null, null, null);\n    }\n    Ah() {\n      const t = this.Ct.Us();\n      if (null !== t) {\n        const i = this.Ct.Bs(),\n          s = this.Ct.Is();\n        this.kc(i, s, null, t);\n      }\n      this.Ct.Ns();\n    }\n    Dc(t, i, s) {\n      const n = this.uh.Rs(0);\n      void 0 !== i && void 0 !== s && this.uh.yt(i, s);\n      const e = this.uh.Rs(0),\n        r = this.uh.ou(),\n        h = this.uh.Pe();\n      if (null !== h && null !== n && null !== e) {\n        const i = h.Te(r),\n          a = this.o_.key(n) > this.o_.key(e),\n          l = null !== t && t > r && !a,\n          o = this.uh.N().allowShiftVisibleRangeOnWhitespaceReplacement,\n          _ =\n            i &&\n            (!(void 0 === s) || o) &&\n            this.uh.N().shiftVisibleRangeOnNewBar;\n        if (l && !_) {\n          const i = t - r;\n          this.uh.fn(this.uh.wu() - i);\n        }\n      }\n      this.uh.xu(t);\n    }\n    Oh(t) {\n      null !== t && t.Jo();\n    }\n    Hn(t) {\n      if (\n        (function (t) {\n          return t instanceof mi;\n        })(t)\n      )\n        return t;\n      const i = this.$u.find((i) => i.Dt().includes(t));\n      return void 0 === i ? null : i;\n    }\n    pu() {\n      this.$u.forEach((t) => t.Jo()), this.Ah();\n    }\n    m() {\n      this.$u.forEach((t) => t.m()),\n        (this.$u.length = 0),\n        (this.Ps.localization.priceFormatter = void 0),\n        (this.Ps.localization.percentageFormatter = void 0),\n        (this.Ps.localization.timeFormatter = void 0);\n    }\n    Ec() {\n      return this.Gu;\n    }\n    qn() {\n      return this.Gu.N();\n    }\n    Eo() {\n      return this.Yu;\n    }\n    Vc(t, i) {\n      const s = this.Qu(i);\n      this.Bc(t, s),\n        this.ju.push(t),\n        1 === this.ju.length ? this.Bh() : this.ar();\n    }\n    Ic(t) {\n      const i = this.Hn(t),\n        s = this.ju.indexOf(t);\n      r(-1 !== s, 'Series not found');\n      const n = a(i);\n      this.ju.splice(s, 1), n.io(t), t.m && t.m(), this.uh.Y_(), this.Ac(n);\n    }\n    Vh(t, i) {\n      const s = a(this.Hn(t));\n      s.io(t, !0), s.Jl(t, i, !0);\n    }\n    Iu() {\n      const t = Y.wn();\n      t.rn(), this.ec(t);\n    }\n    zc(t) {\n      const i = Y.wn();\n      i.ln(t), this.ec(i);\n    }\n    cn() {\n      const t = Y.wn();\n      t.cn(), this.ec(t);\n    }\n    dn(t) {\n      const i = Y.wn();\n      i.dn(t), this.ec(i);\n    }\n    fn(t) {\n      const i = Y.wn();\n      i.fn(t), this.ec(i);\n    }\n    _n(t) {\n      const i = Y.wn();\n      i._n(t), this.ec(i);\n    }\n    hn() {\n      const t = Y.wn();\n      t.hn(), this.ec(t);\n    }\n    Oc() {\n      return this.Ps.rightPriceScale.visible ? 'right' : 'left';\n    }\n    Lc(t, i) {\n      r(i >= 0, 'Index should be greater or equal to 0');\n      if (i === this.Nc(t)) return;\n      const s = a(this.Hn(t));\n      s.io(t);\n      const n = this.Qu(i);\n      this.Bc(t, n), 0 === s.ba().length && this.Ac(s), this.Bh();\n    }\n    Wc() {\n      return this.nc;\n    }\n    $() {\n      return this.tc;\n    }\n    Ut(t) {\n      const i = this.nc,\n        s = this.tc;\n      if (i === s) return i;\n      if (\n        ((t = Math.max(0, Math.min(100, Math.round(100 * t)))),\n        null === this.Xu || this.Xu.mr !== s || this.Xu.wr !== i)\n      )\n        this.Xu = { mr: s, wr: i, Fc: new Map() };\n      else {\n        const i = this.Xu.Fc.get(t);\n        if (void 0 !== i) return i;\n      }\n      const n = this.Sl.tt(s, i, t / 100);\n      return this.Xu.Fc.set(t, n), n;\n    }\n    Hc(t) {\n      return this.$u.indexOf(t);\n    }\n    Xi() {\n      return this.Sl;\n    }\n    Uc() {\n      return this.$c();\n    }\n    $c(t) {\n      const i = new mi(this.uh, this);\n      this.$u.push(i);\n      const s = t ?? this.$u.length - 1,\n        n = Y.gn();\n      return n.Qs(s, { tn: 0, sn: !0 }), this.ec(n), i;\n    }\n    Qu(t) {\n      return (\n        r(t >= 0, 'Index should be greater or equal to 0'),\n        (t = Math.min(this.$u.length, t)) < this.$u.length\n          ? this.$u[t]\n          : this.$c(t)\n      );\n    }\n    Nc(t) {\n      return this.$u.findIndex((i) => i.Lo().includes(t));\n    }\n    wc(t, i) {\n      const s = new Y(i);\n      if (null !== t) {\n        const n = this.$u.indexOf(t);\n        s.Qs(n, { tn: i });\n      }\n      return s;\n    }\n    rc(t, i) {\n      return void 0 === i && (i = 2), this.wc(this.Hn(t), i);\n    }\n    ec(t) {\n      this.Zu && this.Zu(t), this.$u.forEach((t) => t.i_().lr().yt());\n    }\n    Bc(t, i) {\n      const s = t.N().priceScaleId,\n        n = void 0 !== s ? s : this.Oc();\n      i.Jl(t, n), q(n) || t.hr(t.N());\n    }\n    sc(t) {\n      const i = this.Ps.layout;\n      return 'gradient' === i.background.type\n        ? 0 === t\n          ? i.background.topColor\n          : i.background.bottomColor\n        : i.background.color;\n    }\n    Ac(t) {\n      !t.Oo() &&\n        0 === t.ba().length &&\n        this.$u.length > 1 &&\n        this.$u.splice(this.Hc(t), 1);\n    }\n  }\n  function Ai(t) {\n    return !u(t) && !d(t);\n  }\n  function zi(t) {\n    return u(t);\n  }\n  !(function (t) {\n    (t[(t.Disabled = 0)] = 'Disabled'),\n      (t[(t.Continuous = 1)] = 'Continuous'),\n      (t[(t.OnDataUpdate = 2)] = 'OnDataUpdate');\n  })(Di || (Di = {})),\n    (function (t) {\n      (t[(t.LastBar = 0)] = 'LastBar'),\n        (t[(t.LastVisible = 1)] = 'LastVisible');\n    })(Ei || (Ei = {})),\n    (function (t) {\n      (t.Solid = 'solid'), (t.VerticalGradient = 'gradient');\n    })(Vi || (Vi = {})),\n    (function (t) {\n      (t[(t.Year = 0)] = 'Year'),\n        (t[(t.Month = 1)] = 'Month'),\n        (t[(t.DayOfMonth = 2)] = 'DayOfMonth'),\n        (t[(t.Time = 3)] = 'Time'),\n        (t[(t.TimeWithSeconds = 4)] = 'TimeWithSeconds');\n    })(Bi || (Bi = {}));\n  const Oi = (t) => t.getUTCFullYear();\n  function Li(t, i, s) {\n    return i\n      .replace(/yyyy/g, ((t) => Z(Oi(t), 4))(t))\n      .replace(/yy/g, ((t) => Z(Oi(t) % 100, 2))(t))\n      .replace(\n        /MMMM/g,\n        ((t, i) =>\n          new Date(t.getUTCFullYear(), t.getUTCMonth(), 1).toLocaleString(i, {\n            month: 'long',\n          }))(t, s),\n      )\n      .replace(\n        /MMM/g,\n        ((t, i) =>\n          new Date(t.getUTCFullYear(), t.getUTCMonth(), 1).toLocaleString(i, {\n            month: 'short',\n          }))(t, s),\n      )\n      .replace(/MM/g, ((t) => Z(((t) => t.getUTCMonth() + 1)(t), 2))(t))\n      .replace(/dd/g, ((t) => Z(((t) => t.getUTCDate())(t), 2))(t));\n  }\n  class Ni {\n    constructor(t = 'yyyy-MM-dd', i = 'default') {\n      (this.jc = t), (this.qc = i);\n    }\n    __(t) {\n      return Li(t, this.jc, this.qc);\n    }\n  }\n  class Wi {\n    constructor(t) {\n      this.Yc = t || '%h:%m:%s';\n    }\n    __(t) {\n      return this.Yc.replace('%h', Z(t.getUTCHours(), 2))\n        .replace('%m', Z(t.getUTCMinutes(), 2))\n        .replace('%s', Z(t.getUTCSeconds(), 2));\n    }\n  }\n  const Fi = { Kc: 'yyyy-MM-dd', Xc: '%h:%m:%s', Zc: ' ', Gc: 'default' };\n  class Hi {\n    constructor(t = {}) {\n      const i = { ...Fi, ...t };\n      (this.Jc = new Ni(i.Kc, i.Gc)),\n        (this.Qc = new Wi(i.Xc)),\n        (this.td = i.Zc);\n    }\n    __(t) {\n      return `${this.Jc.__(t)}${this.td}${this.Qc.__(t)}`;\n    }\n  }\n  function Ui(t) {\n    return 60 * t * 60 * 1e3;\n  }\n  function $i(t) {\n    return 60 * t * 1e3;\n  }\n  const ji = [\n    { sd: ((qi = 1), 1e3 * qi), nd: 10 },\n    { sd: $i(1), nd: 20 },\n    { sd: $i(5), nd: 21 },\n    { sd: $i(30), nd: 22 },\n    { sd: Ui(1), nd: 30 },\n    { sd: Ui(3), nd: 31 },\n    { sd: Ui(6), nd: 32 },\n    { sd: Ui(12), nd: 33 },\n  ];\n  var qi;\n  function Yi(t, i) {\n    if (t.getUTCFullYear() !== i.getUTCFullYear()) return 70;\n    if (t.getUTCMonth() !== i.getUTCMonth()) return 60;\n    if (t.getUTCDate() !== i.getUTCDate()) return 50;\n    for (let s = ji.length - 1; s >= 0; --s)\n      if (\n        Math.floor(i.getTime() / ji[s].sd) !==\n        Math.floor(t.getTime() / ji[s].sd)\n      )\n        return ji[s].nd;\n    return 0;\n  }\n  function Ki(t) {\n    let i = t;\n    if ((d(t) && (i = Zi(t)), !Ai(i)))\n      throw new Error('time must be of type BusinessDay');\n    const s = new Date(Date.UTC(i.year, i.month - 1, i.day, 0, 0, 0, 0));\n    return { ed: Math.round(s.getTime() / 1e3), rd: i };\n  }\n  function Xi(t) {\n    if (!zi(t)) throw new Error('time must be of type isUTCTimestamp');\n    return { ed: t };\n  }\n  function Zi(t) {\n    const i = new Date(t);\n    if (isNaN(i.getTime()))\n      throw new Error(`Invalid date string=${t}, expected format=yyyy-mm-dd`);\n    return {\n      day: i.getUTCDate(),\n      month: i.getUTCMonth() + 1,\n      year: i.getUTCFullYear(),\n    };\n  }\n  function Gi(t) {\n    d(t.time) && (t.time = Zi(t.time));\n  }\n  class Ji {\n    options() {\n      return this.Ps;\n    }\n    setOptions(t) {\n      (this.Ps = t), this.updateFormatter(t.localization);\n    }\n    preprocessData(t) {\n      Array.isArray(t)\n        ? (function (t) {\n            t.forEach(Gi);\n          })(t)\n        : Gi(t);\n    }\n    createConverterToInternalObj(t) {\n      return a(\n        (function (t) {\n          return 0 === t.length\n            ? null\n            : Ai(t[0].time) || d(t[0].time)\n            ? Ki\n            : Xi;\n        })(t),\n      );\n    }\n    key(t) {\n      return 'object' == typeof t && 'ed' in t\n        ? t.ed\n        : this.key(this.convertHorzItemToInternal(t));\n    }\n    cacheKey(t) {\n      const i = t;\n      return void 0 === i.rd\n        ? new Date(1e3 * i.ed).getTime()\n        : new Date(Date.UTC(i.rd.year, i.rd.month - 1, i.rd.day)).getTime();\n    }\n    convertHorzItemToInternal(t) {\n      return zi((i = t)) ? Xi(i) : Ai(i) ? Ki(i) : Ki(Zi(i));\n      var i;\n    }\n    updateFormatter(t) {\n      if (!this.Ps) return;\n      const i = t.dateFormat;\n      this.Ps.timeScale.timeVisible\n        ? (this.hd = new Hi({\n            Kc: i,\n            Xc: this.Ps.timeScale.secondsVisible ? '%h:%m:%s' : '%h:%m',\n            Zc: '   ',\n            Gc: t.locale,\n          }))\n        : (this.hd = new Ni(i, t.locale));\n    }\n    formatHorzItem(t) {\n      const i = t;\n      return this.hd.__(new Date(1e3 * i.ed));\n    }\n    formatTickmark(t, i) {\n      const s = (function (t, i, s) {\n          switch (t) {\n            case 0:\n            case 10:\n              return i ? (s ? 4 : 3) : 2;\n            case 20:\n            case 21:\n            case 22:\n            case 30:\n            case 31:\n            case 32:\n            case 33:\n              return i ? 3 : 2;\n            case 50:\n              return 2;\n            case 60:\n              return 1;\n            case 70:\n              return 0;\n          }\n        })(\n          t.weight,\n          this.Ps.timeScale.timeVisible,\n          this.Ps.timeScale.secondsVisible,\n        ),\n        n = this.Ps.timeScale;\n      if (void 0 !== n.tickMarkFormatter) {\n        const e = n.tickMarkFormatter(t.originalTime, s, i.locale);\n        if (null !== e) return e;\n      }\n      return (function (t, i, s) {\n        const n = {};\n        switch (i) {\n          case 0:\n            n.year = 'numeric';\n            break;\n          case 1:\n            n.month = 'short';\n            break;\n          case 2:\n            n.day = 'numeric';\n            break;\n          case 3:\n            (n.hour12 = !1), (n.hour = '2-digit'), (n.minute = '2-digit');\n            break;\n          case 4:\n            (n.hour12 = !1),\n              (n.hour = '2-digit'),\n              (n.minute = '2-digit'),\n              (n.second = '2-digit');\n        }\n        const e =\n          void 0 === t.rd\n            ? new Date(1e3 * t.ed)\n            : new Date(Date.UTC(t.rd.year, t.rd.month - 1, t.rd.day));\n        return new Date(\n          e.getUTCFullYear(),\n          e.getUTCMonth(),\n          e.getUTCDate(),\n          e.getUTCHours(),\n          e.getUTCMinutes(),\n          e.getUTCSeconds(),\n          e.getUTCMilliseconds(),\n        ).toLocaleString(s, n);\n      })(t.time, s, i.locale);\n    }\n    maxTickMarkWeight(t) {\n      let i = t.reduce(ki, t[0]).weight;\n      return i > 30 && i < 50 && (i = 30), i;\n    }\n    fillWeightsForPoints(t, i) {\n      !(function (t, i = 0) {\n        if (0 === t.length) return;\n        let s = 0 === i ? null : t[i - 1].time.ed,\n          n = null !== s ? new Date(1e3 * s) : null,\n          e = 0;\n        for (let r = i; r < t.length; ++r) {\n          const i = t[r],\n            h = new Date(1e3 * i.time.ed);\n          null !== n && (i.timeWeight = Yi(h, n)),\n            (e += i.time.ed - (s || i.time.ed)),\n            (s = i.time.ed),\n            (n = h);\n        }\n        if (0 === i && t.length > 1) {\n          const i = Math.ceil(e / (t.length - 1)),\n            s = new Date(1e3 * (t[0].time.ed - i));\n          t[0].timeWeight = Yi(new Date(1e3 * t[0].time.ed), s);\n        }\n      })(t, i);\n    }\n    static ad(t) {\n      return _({ localization: { dateFormat: \"dd MMM 'yy\" } }, t ?? {});\n    }\n  }\n  function Qi(t) {\n    var i = t.width,\n      s = t.height;\n    if (i < 0) throw new Error('Negative width is not allowed for Size');\n    if (s < 0) throw new Error('Negative height is not allowed for Size');\n    return { width: i, height: s };\n  }\n  function ts(t, i) {\n    return t.width === i.width && t.height === i.height;\n  }\n  var is = (function () {\n    function t(t) {\n      var i = this;\n      (this._resolutionListener = function () {\n        return i._onResolutionChanged();\n      }),\n        (this._resolutionMediaQueryList = null),\n        (this._observers = []),\n        (this._window = t),\n        this._installResolutionListener();\n    }\n    return (\n      (t.prototype.dispose = function () {\n        this._uninstallResolutionListener(), (this._window = null);\n      }),\n      Object.defineProperty(t.prototype, 'value', {\n        get: function () {\n          return this._window.devicePixelRatio;\n        },\n        enumerable: !1,\n        configurable: !0,\n      }),\n      (t.prototype.subscribe = function (t) {\n        var i = this,\n          s = { next: t };\n        return (\n          this._observers.push(s),\n          {\n            unsubscribe: function () {\n              i._observers = i._observers.filter(function (t) {\n                return t !== s;\n              });\n            },\n          }\n        );\n      }),\n      (t.prototype._installResolutionListener = function () {\n        if (null !== this._resolutionMediaQueryList)\n          throw new Error('Resolution listener is already installed');\n        var t = this._window.devicePixelRatio;\n        (this._resolutionMediaQueryList = this._window.matchMedia(\n          'all and (resolution: '.concat(t, 'dppx)'),\n        )),\n          this._resolutionMediaQueryList.addListener(this._resolutionListener);\n      }),\n      (t.prototype._uninstallResolutionListener = function () {\n        null !== this._resolutionMediaQueryList &&\n          (this._resolutionMediaQueryList.removeListener(\n            this._resolutionListener,\n          ),\n          (this._resolutionMediaQueryList = null));\n      }),\n      (t.prototype._reinstallResolutionListener = function () {\n        this._uninstallResolutionListener(), this._installResolutionListener();\n      }),\n      (t.prototype._onResolutionChanged = function () {\n        var t = this;\n        this._observers.forEach(function (i) {\n          return i.next(t._window.devicePixelRatio);\n        }),\n          this._reinstallResolutionListener();\n      }),\n      t\n    );\n  })();\n  var ss = (function () {\n    function t(t, i, s) {\n      var n;\n      (this._canvasElement = null),\n        (this._bitmapSizeChangedListeners = []),\n        (this._suggestedBitmapSize = null),\n        (this._suggestedBitmapSizeChangedListeners = []),\n        (this._devicePixelRatioObservable = null),\n        (this._canvasElementResizeObserver = null),\n        (this._canvasElement = t),\n        (this._canvasElementClientSize = Qi({\n          width: this._canvasElement.clientWidth,\n          height: this._canvasElement.clientHeight,\n        })),\n        (this._transformBitmapSize =\n          null != i\n            ? i\n            : function (t) {\n                return t;\n              }),\n        (this._allowResizeObserver =\n          null === (n = null == s ? void 0 : s.allowResizeObserver) ||\n          void 0 === n ||\n          n),\n        this._chooseAndInitObserver();\n    }\n    return (\n      (t.prototype.dispose = function () {\n        var t, i;\n        if (null === this._canvasElement) throw new Error('Object is disposed');\n        null === (t = this._canvasElementResizeObserver) ||\n          void 0 === t ||\n          t.disconnect(),\n          (this._canvasElementResizeObserver = null),\n          null === (i = this._devicePixelRatioObservable) ||\n            void 0 === i ||\n            i.dispose(),\n          (this._devicePixelRatioObservable = null),\n          (this._suggestedBitmapSizeChangedListeners.length = 0),\n          (this._bitmapSizeChangedListeners.length = 0),\n          (this._canvasElement = null);\n      }),\n      Object.defineProperty(t.prototype, 'canvasElement', {\n        get: function () {\n          if (null === this._canvasElement)\n            throw new Error('Object is disposed');\n          return this._canvasElement;\n        },\n        enumerable: !1,\n        configurable: !0,\n      }),\n      Object.defineProperty(t.prototype, 'canvasElementClientSize', {\n        get: function () {\n          return this._canvasElementClientSize;\n        },\n        enumerable: !1,\n        configurable: !0,\n      }),\n      Object.defineProperty(t.prototype, 'bitmapSize', {\n        get: function () {\n          return Qi({\n            width: this.canvasElement.width,\n            height: this.canvasElement.height,\n          });\n        },\n        enumerable: !1,\n        configurable: !0,\n      }),\n      (t.prototype.resizeCanvasElement = function (t) {\n        (this._canvasElementClientSize = Qi(t)),\n          (this.canvasElement.style.width = ''.concat(\n            this._canvasElementClientSize.width,\n            'px',\n          )),\n          (this.canvasElement.style.height = ''.concat(\n            this._canvasElementClientSize.height,\n            'px',\n          )),\n          this._invalidateBitmapSize();\n      }),\n      (t.prototype.subscribeBitmapSizeChanged = function (t) {\n        this._bitmapSizeChangedListeners.push(t);\n      }),\n      (t.prototype.unsubscribeBitmapSizeChanged = function (t) {\n        this._bitmapSizeChangedListeners =\n          this._bitmapSizeChangedListeners.filter(function (i) {\n            return i !== t;\n          });\n      }),\n      Object.defineProperty(t.prototype, 'suggestedBitmapSize', {\n        get: function () {\n          return this._suggestedBitmapSize;\n        },\n        enumerable: !1,\n        configurable: !0,\n      }),\n      (t.prototype.subscribeSuggestedBitmapSizeChanged = function (t) {\n        this._suggestedBitmapSizeChangedListeners.push(t);\n      }),\n      (t.prototype.unsubscribeSuggestedBitmapSizeChanged = function (t) {\n        this._suggestedBitmapSizeChangedListeners =\n          this._suggestedBitmapSizeChangedListeners.filter(function (i) {\n            return i !== t;\n          });\n      }),\n      (t.prototype.applySuggestedBitmapSize = function () {\n        if (null !== this._suggestedBitmapSize) {\n          var t = this._suggestedBitmapSize;\n          (this._suggestedBitmapSize = null),\n            this._resizeBitmap(t),\n            this._emitSuggestedBitmapSizeChanged(t, this._suggestedBitmapSize);\n        }\n      }),\n      (t.prototype._resizeBitmap = function (t) {\n        var i = this.bitmapSize;\n        ts(i, t) ||\n          ((this.canvasElement.width = t.width),\n          (this.canvasElement.height = t.height),\n          this._emitBitmapSizeChanged(i, t));\n      }),\n      (t.prototype._emitBitmapSizeChanged = function (t, i) {\n        var s = this;\n        this._bitmapSizeChangedListeners.forEach(function (n) {\n          return n.call(s, t, i);\n        });\n      }),\n      (t.prototype._suggestNewBitmapSize = function (t) {\n        var i = this._suggestedBitmapSize,\n          s = Qi(this._transformBitmapSize(t, this._canvasElementClientSize)),\n          n = ts(this.bitmapSize, s) ? null : s;\n        (null === i && null === n) ||\n          (null !== i && null !== n && ts(i, n)) ||\n          ((this._suggestedBitmapSize = n),\n          this._emitSuggestedBitmapSizeChanged(i, n));\n      }),\n      (t.prototype._emitSuggestedBitmapSizeChanged = function (t, i) {\n        var s = this;\n        this._suggestedBitmapSizeChangedListeners.forEach(function (n) {\n          return n.call(s, t, i);\n        });\n      }),\n      (t.prototype._chooseAndInitObserver = function () {\n        var t = this;\n        this._allowResizeObserver\n          ? new Promise(function (t) {\n              var i = new ResizeObserver(function (s) {\n                t(\n                  s.every(function (t) {\n                    return 'devicePixelContentBoxSize' in t;\n                  }),\n                ),\n                  i.disconnect();\n              });\n              i.observe(document.body, { box: 'device-pixel-content-box' });\n            })\n              .catch(function () {\n                return !1;\n              })\n              .then(function (i) {\n                return i\n                  ? t._initResizeObserver()\n                  : t._initDevicePixelRatioObservable();\n              })\n          : this._initDevicePixelRatioObservable();\n      }),\n      (t.prototype._initDevicePixelRatioObservable = function () {\n        var t = this;\n        if (null !== this._canvasElement) {\n          var i = ns(this._canvasElement);\n          if (null === i)\n            throw new Error('No window is associated with the canvas');\n          (this._devicePixelRatioObservable = (function (t) {\n            return new is(t);\n          })(i)),\n            this._devicePixelRatioObservable.subscribe(function () {\n              return t._invalidateBitmapSize();\n            }),\n            this._invalidateBitmapSize();\n        }\n      }),\n      (t.prototype._invalidateBitmapSize = function () {\n        var t, i;\n        if (null !== this._canvasElement) {\n          var s = ns(this._canvasElement);\n          if (null !== s) {\n            var n =\n                null !==\n                  (i =\n                    null === (t = this._devicePixelRatioObservable) ||\n                    void 0 === t\n                      ? void 0\n                      : t.value) && void 0 !== i\n                  ? i\n                  : s.devicePixelRatio,\n              e = this._canvasElement.getClientRects(),\n              r =\n                void 0 !== e[0]\n                  ? (function (t, i) {\n                      return Qi({\n                        width:\n                          Math.round(t.left * i + t.width * i) -\n                          Math.round(t.left * i),\n                        height:\n                          Math.round(t.top * i + t.height * i) -\n                          Math.round(t.top * i),\n                      });\n                    })(e[0], n)\n                  : Qi({\n                      width: this._canvasElementClientSize.width * n,\n                      height: this._canvasElementClientSize.height * n,\n                    });\n            this._suggestNewBitmapSize(r);\n          }\n        }\n      }),\n      (t.prototype._initResizeObserver = function () {\n        var t = this;\n        null !== this._canvasElement &&\n          ((this._canvasElementResizeObserver = new ResizeObserver(function (\n            i,\n          ) {\n            var s = i.find(function (i) {\n              return i.target === t._canvasElement;\n            });\n            if (\n              s &&\n              s.devicePixelContentBoxSize &&\n              s.devicePixelContentBoxSize[0]\n            ) {\n              var n = s.devicePixelContentBoxSize[0],\n                e = Qi({ width: n.inlineSize, height: n.blockSize });\n              t._suggestNewBitmapSize(e);\n            }\n          })),\n          this._canvasElementResizeObserver.observe(this._canvasElement, {\n            box: 'device-pixel-content-box',\n          }));\n      }),\n      t\n    );\n  })();\n  function ns(t) {\n    return t.ownerDocument.defaultView;\n  }\n  var es = (function () {\n    function t(t, i, s) {\n      if (0 === i.width || 0 === i.height)\n        throw new TypeError(\n          'Rendering target could only be created on a media with positive width and height',\n        );\n      if (((this._mediaSize = i), 0 === s.width || 0 === s.height))\n        throw new TypeError(\n          'Rendering target could only be created using a bitmap with positive integer width and height',\n        );\n      (this._bitmapSize = s), (this._context = t);\n    }\n    return (\n      (t.prototype.useMediaCoordinateSpace = function (t) {\n        try {\n          return (\n            this._context.save(),\n            this._context.setTransform(1, 0, 0, 1, 0, 0),\n            this._context.scale(\n              this._horizontalPixelRatio,\n              this._verticalPixelRatio,\n            ),\n            t({ context: this._context, mediaSize: this._mediaSize })\n          );\n        } finally {\n          this._context.restore();\n        }\n      }),\n      (t.prototype.useBitmapCoordinateSpace = function (t) {\n        try {\n          return (\n            this._context.save(),\n            this._context.setTransform(1, 0, 0, 1, 0, 0),\n            t({\n              context: this._context,\n              mediaSize: this._mediaSize,\n              bitmapSize: this._bitmapSize,\n              horizontalPixelRatio: this._horizontalPixelRatio,\n              verticalPixelRatio: this._verticalPixelRatio,\n            })\n          );\n        } finally {\n          this._context.restore();\n        }\n      }),\n      Object.defineProperty(t.prototype, '_horizontalPixelRatio', {\n        get: function () {\n          return this._bitmapSize.width / this._mediaSize.width;\n        },\n        enumerable: !1,\n        configurable: !0,\n      }),\n      Object.defineProperty(t.prototype, '_verticalPixelRatio', {\n        get: function () {\n          return this._bitmapSize.height / this._mediaSize.height;\n        },\n        enumerable: !1,\n        configurable: !0,\n      }),\n      t\n    );\n  })();\n  function rs(t, i) {\n    var s = t.canvasElementClientSize;\n    if (0 === s.width || 0 === s.height) return null;\n    var n = t.bitmapSize;\n    if (0 === n.width || 0 === n.height) return null;\n    var e = t.canvasElement.getContext('2d', i);\n    return null === e ? null : new es(e, s, n);\n  }\n  const hs = 'undefined' != typeof window;\n  function as() {\n    return (\n      !!hs && window.navigator.userAgent.toLowerCase().indexOf('firefox') > -1\n    );\n  }\n  function ls() {\n    return !!hs && /iPhone|iPad|iPod/.test(window.navigator.platform);\n  }\n  function os(t) {\n    return t + (t % 2);\n  }\n  function _s(t) {\n    hs &&\n      void 0 !== window.chrome &&\n      t.addEventListener('mousedown', (t) => {\n        if (1 === t.button) return t.preventDefault(), !1;\n      });\n  }\n  class us {\n    constructor(t, i, s) {\n      (this.ld = 0),\n        (this.od = null),\n        (this._d = {\n          _t: Number.NEGATIVE_INFINITY,\n          ut: Number.POSITIVE_INFINITY,\n        }),\n        (this.ud = 0),\n        (this.dd = null),\n        (this.fd = {\n          _t: Number.NEGATIVE_INFINITY,\n          ut: Number.POSITIVE_INFINITY,\n        }),\n        (this.pd = null),\n        (this.vd = !1),\n        (this.md = null),\n        (this.wd = null),\n        (this.gd = !1),\n        (this.Md = !1),\n        (this.bd = !1),\n        (this.xd = null),\n        (this.Sd = null),\n        (this.Cd = null),\n        (this.Pd = null),\n        (this.yd = null),\n        (this.kd = null),\n        (this.Td = null),\n        (this.Rd = 0),\n        (this.Dd = !1),\n        (this.Ed = !1),\n        (this.Vd = !1),\n        (this.Bd = 0),\n        (this.Id = null),\n        (this.Ad = !ls()),\n        (this.zd = (t) => {\n          this.Od(t);\n        }),\n        (this.Ld = (t) => {\n          if (this.Nd(t)) {\n            const i = this.Wd(t);\n            if ((++this.ud, this.dd && this.ud > 1)) {\n              const { Fd: s } = this.Hd(fs(t), this.fd);\n              s < 30 && !this.bd && this.Ud(i, this.jd.$d), this.qd();\n            }\n          } else {\n            const i = this.Wd(t);\n            if ((++this.ld, this.od && this.ld > 1)) {\n              const { Fd: s } = this.Hd(fs(t), this._d);\n              s < 5 && !this.Md && this.Yd(i, this.jd.Kd), this.Xd();\n            }\n          }\n        }),\n        (this.Zd = t),\n        (this.jd = i),\n        (this.Ps = s),\n        this.Gd();\n    }\n    m() {\n      null !== this.xd && (this.xd(), (this.xd = null)),\n        null !== this.Sd && (this.Sd(), (this.Sd = null)),\n        null !== this.Pd && (this.Pd(), (this.Pd = null)),\n        null !== this.yd && (this.yd(), (this.yd = null)),\n        null !== this.kd && (this.kd(), (this.kd = null)),\n        null !== this.Cd && (this.Cd(), (this.Cd = null)),\n        this.Jd(),\n        this.Xd();\n    }\n    Qd(t) {\n      this.Pd && this.Pd();\n      const i = this.tf.bind(this);\n      if (\n        ((this.Pd = () => {\n          this.Zd.removeEventListener('mousemove', i);\n        }),\n        this.Zd.addEventListener('mousemove', i),\n        this.Nd(t))\n      )\n        return;\n      const s = this.Wd(t);\n      this.Yd(s, this.jd.if), (this.Ad = !0);\n    }\n    Xd() {\n      null !== this.od && clearTimeout(this.od),\n        (this.ld = 0),\n        (this.od = null),\n        (this._d = {\n          _t: Number.NEGATIVE_INFINITY,\n          ut: Number.POSITIVE_INFINITY,\n        });\n    }\n    qd() {\n      null !== this.dd && clearTimeout(this.dd),\n        (this.ud = 0),\n        (this.dd = null),\n        (this.fd = {\n          _t: Number.NEGATIVE_INFINITY,\n          ut: Number.POSITIVE_INFINITY,\n        });\n    }\n    tf(t) {\n      if (this.Vd || null !== this.wd) return;\n      if (this.Nd(t)) return;\n      const i = this.Wd(t);\n      this.Yd(i, this.jd.sf), (this.Ad = !0);\n    }\n    nf(t) {\n      const i = vs(t.changedTouches, a(this.Id));\n      if (null === i) return;\n      if (((this.Bd = ps(t)), null !== this.Td)) return;\n      if (this.Ed) return;\n      this.Dd = !0;\n      const s = this.Hd(fs(i), a(this.wd)),\n        { ef: n, rf: e, Fd: r } = s;\n      if (this.gd || !(r < 5)) {\n        if (!this.gd) {\n          const t = 0.5 * n,\n            i = e >= t && !this.Ps.hf(),\n            s = t > e && !this.Ps.af();\n          i || s || (this.Ed = !0),\n            (this.gd = !0),\n            (this.bd = !0),\n            this.Jd(),\n            this.qd();\n        }\n        if (!this.Ed) {\n          const s = this.Wd(t, i);\n          this.Ud(s, this.jd.lf), ds(t);\n        }\n      }\n    }\n    _f(t) {\n      if (0 !== t.button) return;\n      const i = this.Hd(fs(t), a(this.md)),\n        { Fd: s } = i;\n      if ((s >= 5 && ((this.Md = !0), this.Xd()), this.Md)) {\n        const i = this.Wd(t);\n        this.Yd(i, this.jd.uf);\n      }\n    }\n    Hd(t, i) {\n      const s = Math.abs(i._t - t._t),\n        n = Math.abs(i.ut - t.ut);\n      return { ef: s, rf: n, Fd: s + n };\n    }\n    cf(t) {\n      let i = vs(t.changedTouches, a(this.Id));\n      if (\n        (null === i && 0 === t.touches.length && (i = t.changedTouches[0]),\n        null === i)\n      )\n        return;\n      (this.Id = null),\n        (this.Bd = ps(t)),\n        this.Jd(),\n        (this.wd = null),\n        this.kd && (this.kd(), (this.kd = null));\n      const s = this.Wd(t, i);\n      if ((this.Ud(s, this.jd.df), ++this.ud, this.dd && this.ud > 1)) {\n        const { Fd: t } = this.Hd(fs(i), this.fd);\n        t < 30 && !this.bd && this.Ud(s, this.jd.$d), this.qd();\n      } else this.bd || (this.Ud(s, this.jd.ff), this.jd.ff && ds(t));\n      0 === this.ud && ds(t),\n        0 === t.touches.length && this.vd && ((this.vd = !1), ds(t));\n    }\n    Od(t) {\n      if (0 !== t.button) return;\n      const i = this.Wd(t);\n      if (\n        ((this.md = null),\n        (this.Vd = !1),\n        this.yd && (this.yd(), (this.yd = null)),\n        as())\n      ) {\n        this.Zd.ownerDocument.documentElement.removeEventListener(\n          'mouseleave',\n          this.zd,\n        );\n      }\n      if (!this.Nd(t))\n        if ((this.Yd(i, this.jd.pf), ++this.ld, this.od && this.ld > 1)) {\n          const { Fd: s } = this.Hd(fs(t), this._d);\n          s < 5 && !this.Md && this.Yd(i, this.jd.Kd), this.Xd();\n        } else this.Md || this.Yd(i, this.jd.vf);\n    }\n    Jd() {\n      null !== this.pd && (clearTimeout(this.pd), (this.pd = null));\n    }\n    mf(t) {\n      if (null !== this.Id) return;\n      const i = t.changedTouches[0];\n      (this.Id = i.identifier), (this.Bd = ps(t));\n      const s = this.Zd.ownerDocument.documentElement;\n      (this.bd = !1),\n        (this.gd = !1),\n        (this.Ed = !1),\n        (this.wd = fs(i)),\n        this.kd && (this.kd(), (this.kd = null));\n      {\n        const i = this.nf.bind(this),\n          n = this.cf.bind(this);\n        (this.kd = () => {\n          s.removeEventListener('touchmove', i),\n            s.removeEventListener('touchend', n);\n        }),\n          s.addEventListener('touchmove', i, { passive: !1 }),\n          s.addEventListener('touchend', n, { passive: !1 }),\n          this.Jd(),\n          (this.pd = setTimeout(this.wf.bind(this, t), 240));\n      }\n      const n = this.Wd(t, i);\n      this.Ud(n, this.jd.gf),\n        this.dd ||\n          ((this.ud = 0),\n          (this.dd = setTimeout(this.qd.bind(this), 500)),\n          (this.fd = fs(i)));\n    }\n    Mf(t) {\n      if (0 !== t.button) return;\n      const i = this.Zd.ownerDocument.documentElement;\n      as() && i.addEventListener('mouseleave', this.zd),\n        (this.Md = !1),\n        (this.md = fs(t)),\n        this.yd && (this.yd(), (this.yd = null));\n      {\n        const t = this._f.bind(this),\n          s = this.Od.bind(this);\n        (this.yd = () => {\n          i.removeEventListener('mousemove', t),\n            i.removeEventListener('mouseup', s);\n        }),\n          i.addEventListener('mousemove', t),\n          i.addEventListener('mouseup', s);\n      }\n      if (((this.Vd = !0), this.Nd(t))) return;\n      const s = this.Wd(t);\n      this.Yd(s, this.jd.bf),\n        this.od ||\n          ((this.ld = 0),\n          (this.od = setTimeout(this.Xd.bind(this), 500)),\n          (this._d = fs(t)));\n    }\n    Gd() {\n      this.Zd.addEventListener('mouseenter', this.Qd.bind(this)),\n        this.Zd.addEventListener('touchcancel', this.Jd.bind(this));\n      {\n        const t = this.Zd.ownerDocument,\n          i = (t) => {\n            this.jd.xf &&\n              ((t.composed && this.Zd.contains(t.composedPath()[0])) ||\n                (t.target && this.Zd.contains(t.target)) ||\n                this.jd.xf());\n          };\n        (this.Sd = () => {\n          t.removeEventListener('touchstart', i);\n        }),\n          (this.xd = () => {\n            t.removeEventListener('mousedown', i);\n          }),\n          t.addEventListener('mousedown', i),\n          t.addEventListener('touchstart', i, { passive: !0 });\n      }\n      ls() &&\n        ((this.Cd = () => {\n          this.Zd.removeEventListener('dblclick', this.Ld);\n        }),\n        this.Zd.addEventListener('dblclick', this.Ld)),\n        this.Zd.addEventListener('mouseleave', this.Sf.bind(this)),\n        this.Zd.addEventListener('touchstart', this.mf.bind(this), {\n          passive: !0,\n        }),\n        _s(this.Zd),\n        this.Zd.addEventListener('mousedown', this.Mf.bind(this)),\n        this.Cf(),\n        this.Zd.addEventListener('touchmove', () => {}, { passive: !1 });\n    }\n    Cf() {\n      (void 0 === this.jd.Pf &&\n        void 0 === this.jd.yf &&\n        void 0 === this.jd.kf) ||\n        (this.Zd.addEventListener('touchstart', (t) => this.Tf(t.touches), {\n          passive: !0,\n        }),\n        this.Zd.addEventListener(\n          'touchmove',\n          (t) => {\n            if (\n              2 === t.touches.length &&\n              null !== this.Td &&\n              void 0 !== this.jd.yf\n            ) {\n              const i = cs(t.touches[0], t.touches[1]) / this.Rd;\n              this.jd.yf(this.Td, i), ds(t);\n            }\n          },\n          { passive: !1 },\n        ),\n        this.Zd.addEventListener('touchend', (t) => {\n          this.Tf(t.touches);\n        }));\n    }\n    Tf(t) {\n      1 === t.length && (this.Dd = !1),\n        2 !== t.length || this.Dd || this.vd ? this.Rf() : this.Df(t);\n    }\n    Df(t) {\n      const i = this.Zd.getBoundingClientRect() || { left: 0, top: 0 };\n      (this.Td = {\n        _t: (t[0].clientX - i.left + (t[1].clientX - i.left)) / 2,\n        ut: (t[0].clientY - i.top + (t[1].clientY - i.top)) / 2,\n      }),\n        (this.Rd = cs(t[0], t[1])),\n        void 0 !== this.jd.Pf && this.jd.Pf(),\n        this.Jd();\n    }\n    Rf() {\n      null !== this.Td &&\n        ((this.Td = null), void 0 !== this.jd.kf && this.jd.kf());\n    }\n    Sf(t) {\n      if ((this.Pd && this.Pd(), this.Nd(t))) return;\n      if (!this.Ad) return;\n      const i = this.Wd(t);\n      this.Yd(i, this.jd.Ef), (this.Ad = !ls());\n    }\n    wf(t) {\n      const i = vs(t.touches, a(this.Id));\n      if (null === i) return;\n      const s = this.Wd(t, i);\n      this.Ud(s, this.jd.Vf), (this.bd = !0), (this.vd = !0);\n    }\n    Nd(t) {\n      return t.sourceCapabilities &&\n        void 0 !== t.sourceCapabilities.firesTouchEvents\n        ? t.sourceCapabilities.firesTouchEvents\n        : ps(t) < this.Bd + 500;\n    }\n    Ud(t, i) {\n      i && i.call(this.jd, t);\n    }\n    Yd(t, i) {\n      i && i.call(this.jd, t);\n    }\n    Wd(t, i) {\n      const s = i || t,\n        n = this.Zd.getBoundingClientRect() || { left: 0, top: 0 };\n      return {\n        clientX: s.clientX,\n        clientY: s.clientY,\n        pageX: s.pageX,\n        pageY: s.pageY,\n        screenX: s.screenX,\n        screenY: s.screenY,\n        localX: s.clientX - n.left,\n        localY: s.clientY - n.top,\n        ctrlKey: t.ctrlKey,\n        altKey: t.altKey,\n        shiftKey: t.shiftKey,\n        metaKey: t.metaKey,\n        Bf:\n          !t.type.startsWith('mouse') &&\n          'contextmenu' !== t.type &&\n          'click' !== t.type,\n        If: t.type,\n        Af: s.target,\n        a_: t.view,\n        zf: () => {\n          'touchstart' !== t.type && ds(t);\n        },\n      };\n    }\n  }\n  function cs(t, i) {\n    const s = t.clientX - i.clientX,\n      n = t.clientY - i.clientY;\n    return Math.sqrt(s * s + n * n);\n  }\n  function ds(t) {\n    t.cancelable && t.preventDefault();\n  }\n  function fs(t) {\n    return { _t: t.pageX, ut: t.pageY };\n  }\n  function ps(t) {\n    return t.timeStamp || performance.now();\n  }\n  function vs(t, i) {\n    for (let s = 0; s < t.length; ++s) if (t[s].identifier === i) return t[s];\n    return null;\n  }\n  class ms {\n    constructor(t, i, s) {\n      (this.Of = null),\n        (this.Lf = null),\n        (this.Nf = !0),\n        (this.Wf = null),\n        (this.Ff = t),\n        (this.Hf = t.Uf()[i]),\n        (this.$f = t.Uf()[s]),\n        (this.jf = document.createElement('tr')),\n        (this.jf.style.height = '1px'),\n        (this.qf = document.createElement('td')),\n        (this.qf.style.position = 'relative'),\n        (this.qf.style.padding = '0'),\n        (this.qf.style.margin = '0'),\n        this.qf.setAttribute('colspan', '3'),\n        this.Yf(),\n        this.jf.appendChild(this.qf),\n        (this.Nf = this.Ff.N().layout.panes.enableResize),\n        this.Nf ? this.Kf() : ((this.Of = null), (this.Lf = null));\n    }\n    m() {\n      null !== this.Lf && this.Lf.m();\n    }\n    Xf() {\n      return this.jf;\n    }\n    Zf() {\n      return Qi({ width: this.Hf.Zf().width, height: 1 });\n    }\n    Gf() {\n      return Qi({\n        width: this.Hf.Gf().width,\n        height: 1 * window.devicePixelRatio,\n      });\n    }\n    Jf(t, i, s) {\n      const n = this.Gf();\n      (t.fillStyle = this.Ff.N().layout.panes.separatorColor),\n        t.fillRect(i, s, n.width, n.height);\n    }\n    yt() {\n      this.Yf(),\n        this.Ff.N().layout.panes.enableResize !== this.Nf &&\n          ((this.Nf = this.Ff.N().layout.panes.enableResize),\n          this.Nf\n            ? this.Kf()\n            : (null !== this.Of &&\n                (this.qf.removeChild(this.Of.Qf),\n                this.qf.removeChild(this.Of.tp),\n                (this.Of = null)),\n              null !== this.Lf && (this.Lf.m(), (this.Lf = null))));\n    }\n    Kf() {\n      const t = document.createElement('div'),\n        i = t.style;\n      (i.position = 'fixed'),\n        (i.display = 'none'),\n        (i.zIndex = '49'),\n        (i.top = '0'),\n        (i.left = '0'),\n        (i.width = '100%'),\n        (i.height = '100%'),\n        (i.cursor = 'row-resize'),\n        this.qf.appendChild(t);\n      const s = document.createElement('div'),\n        n = s.style;\n      (n.position = 'absolute'),\n        (n.zIndex = '50'),\n        (n.top = '-4px'),\n        (n.height = '9px'),\n        (n.width = '100%'),\n        (n.backgroundColor = ''),\n        (n.cursor = 'row-resize'),\n        this.qf.appendChild(s);\n      const e = {\n        if: this.ip.bind(this),\n        Ef: this.sp.bind(this),\n        bf: this.np.bind(this),\n        gf: this.np.bind(this),\n        uf: this.ep.bind(this),\n        lf: this.ep.bind(this),\n        pf: this.rp.bind(this),\n        df: this.rp.bind(this),\n      };\n      (this.Lf = new us(s, e, { hf: () => !1, af: () => !0 })),\n        (this.Of = { tp: s, Qf: t });\n    }\n    Yf() {\n      this.qf.style.background = this.Ff.N().layout.panes.separatorColor;\n    }\n    ip(t) {\n      null !== this.Of &&\n        (this.Of.tp.style.backgroundColor =\n          this.Ff.N().layout.panes.separatorHoverColor);\n    }\n    sp(t) {\n      null !== this.Of &&\n        null === this.Wf &&\n        (this.Of.tp.style.backgroundColor = '');\n    }\n    np(t) {\n      if (null === this.Of) return;\n      const i = this.Hf.hp().Vo() + this.$f.hp().Vo(),\n        s = i / (this.Hf.Zf().height + this.$f.Zf().height),\n        n = 30 * s;\n      i <= 2 * n ||\n        ((this.Wf = {\n          ap: t.pageY,\n          lp: this.Hf.hp().Vo(),\n          op: i - n,\n          _p: i,\n          up: s,\n          cp: n,\n        }),\n        (this.Of.Qf.style.display = 'block'));\n    }\n    ep(t) {\n      const i = this.Wf;\n      if (null === i) return;\n      const s = (t.pageY - i.ap) * i.up,\n        n = Yt(i.lp + s, i.cp, i.op);\n      this.Hf.hp().Bo(n), this.$f.hp().Bo(i._p - n), this.Ff.Qt().Bh();\n    }\n    rp(t) {\n      null !== this.Wf &&\n        null !== this.Of &&\n        ((this.Wf = null), (this.Of.Qf.style.display = 'none'));\n    }\n  }\n  function ws(t, i) {\n    return t.dp - i.dp;\n  }\n  function gs(t, i, s) {\n    const n = (t.dp - i.dp) / (t.wt - i.wt);\n    return Math.sign(n) * Math.min(Math.abs(n), s);\n  }\n  class Ms {\n    constructor(t, i, s, n) {\n      (this.fp = null),\n        (this.pp = null),\n        (this.vp = null),\n        (this.mp = null),\n        (this.wp = null),\n        (this.gp = 0),\n        (this.Mp = 0),\n        (this.bp = t),\n        (this.xp = i),\n        (this.Sp = s),\n        (this.Mn = n);\n    }\n    Cp(t, i) {\n      if (null !== this.fp) {\n        if (this.fp.wt === i) return void (this.fp.dp = t);\n        if (Math.abs(this.fp.dp - t) < this.Mn) return;\n      }\n      (this.mp = this.vp),\n        (this.vp = this.pp),\n        (this.pp = this.fp),\n        (this.fp = { wt: i, dp: t });\n    }\n    le(t, i) {\n      if (null === this.fp || null === this.pp) return;\n      if (i - this.fp.wt > 50) return;\n      let s = 0;\n      const n = gs(this.fp, this.pp, this.xp),\n        e = ws(this.fp, this.pp),\n        r = [n],\n        h = [e];\n      if (((s += e), null !== this.vp)) {\n        const t = gs(this.pp, this.vp, this.xp);\n        if (Math.sign(t) === Math.sign(n)) {\n          const i = ws(this.pp, this.vp);\n          if ((r.push(t), h.push(i), (s += i), null !== this.mp)) {\n            const t = gs(this.vp, this.mp, this.xp);\n            if (Math.sign(t) === Math.sign(n)) {\n              const i = ws(this.vp, this.mp);\n              r.push(t), h.push(i), (s += i);\n            }\n          }\n        }\n      }\n      let a = 0;\n      for (let t = 0; t < r.length; ++t) a += (h[t] / s) * r[t];\n      Math.abs(a) < this.bp ||\n        ((this.wp = { dp: t, wt: i }),\n        (this.Mp = a),\n        (this.gp = (function (t, i) {\n          const s = Math.log(i);\n          return Math.log((1 * s) / -t) / s;\n        })(Math.abs(a), this.Sp)));\n    }\n    Ru(t) {\n      const i = a(this.wp),\n        s = t - i.wt;\n      return i.dp + (this.Mp * (Math.pow(this.Sp, s) - 1)) / Math.log(this.Sp);\n    }\n    Tu(t) {\n      return null === this.wp || this.Pp(t) === this.gp;\n    }\n    Pp(t) {\n      const i = t - a(this.wp).wt;\n      return Math.min(i, this.gp);\n    }\n  }\n  class bs {\n    constructor(t, i) {\n      (this.yp = void 0),\n        (this.kp = void 0),\n        (this.Tp = void 0),\n        (this.ps = !1),\n        (this.Rp = t),\n        (this.Dp = i),\n        this.Ep();\n    }\n    yt() {\n      this.Ep();\n    }\n    Vp() {\n      this.yp && this.Rp.removeChild(this.yp),\n        this.kp && this.Rp.removeChild(this.kp),\n        (this.yp = void 0),\n        (this.kp = void 0);\n    }\n    Bp() {\n      return this.ps !== this.Ip() || this.Tp !== this.Ap();\n    }\n    Ap() {\n      return this.Dp.Qt().Xi().J(this.Dp.N().layout.textColor) > 160\n        ? 'dark'\n        : 'light';\n    }\n    Ip() {\n      return this.Dp.N().layout.attributionLogo;\n    }\n    zp() {\n      const t = new URL(location.href);\n      return t.hostname ? '&utm_source=' + t.hostname + t.pathname : '';\n    }\n    Ep() {\n      this.Bp() &&\n        (this.Vp(),\n        (this.ps = this.Ip()),\n        this.ps &&\n          ((this.Tp = this.Ap()),\n          (this.kp = document.createElement('style')),\n          (this.kp.innerText =\n            'a#tv-attr-logo{--fill:#131722;--stroke:#fff;position:absolute;left:10px;bottom:10px;height:19px;width:35px;margin:0;padding:0;border:0;z-index:3;}a#tv-attr-logo[data-dark]{--fill:#D1D4DC;--stroke:#131722;}'),\n          (this.yp = document.createElement('a')),\n          (this.yp.href = `https://www.tradingview.com/?utm_medium=lwc-link&utm_campaign=lwc-chart${this.zp()}`),\n          (this.yp.title = 'Charting by TradingView'),\n          (this.yp.id = 'tv-attr-logo'),\n          (this.yp.target = '_blank'),\n          (this.yp.innerHTML =\n            '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"35\" height=\"19\" fill=\"none\"><g fill-rule=\"evenodd\" clip-path=\"url(#a)\" clip-rule=\"evenodd\"><path fill=\"var(--stroke)\" d=\"M2 0H0v10h6v9h21.4l.5-1.3 6-15 1-2.7H23.7l-.5 1.3-.2.6a5 5 0 0 0-7-.9V0H2Zm20 17h4l5.2-13 .8-2h-7l-1 2.5-.2.5-1.5 3.8-.3.7V17Zm-.8-10a3 3 0 0 0 .7-2.7A3 3 0 1 0 16.8 7h4.4ZM14 7V2H2v6h6v9h4V7h2Z\"/><path fill=\"var(--fill)\" d=\"M14 2H2v6h6v9h6V2Zm12 15h-7l6-15h7l-6 15Zm-7-9a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z\"/></g><defs><clipPath id=\"a\"><path fill=\"var(--stroke)\" d=\"M0 0h35v19H0z\"/></clipPath></defs></svg>'),\n          this.yp.toggleAttribute('data-dark', 'dark' === this.Tp),\n          this.Rp.appendChild(this.kp),\n          this.Rp.appendChild(this.yp)));\n    }\n  }\n  function xs(t, i) {\n    const s = a(t.ownerDocument).createElement('canvas');\n    t.appendChild(s);\n    const n = new ss(\n      s,\n      (e = {\n        options: { allowResizeObserver: !0 },\n        transform: (t, i) => ({\n          width: Math.max(t.width, i.width),\n          height: Math.max(t.height, i.height),\n        }),\n      }).transform,\n      e.options,\n    );\n    var e;\n    return n.resizeCanvasElement(i), n;\n  }\n  function Ss(t) {\n    (t.width = 1), (t.height = 1), t.getContext('2d')?.clearRect(0, 0, 1, 1);\n  }\n  function Cs(t, i, s, n) {\n    t.ih && t.ih(i, s, n);\n  }\n  function Ps(t, i, s, n) {\n    t.nt(i, s, n);\n  }\n  function ys(t, i, s, n) {\n    const e = t(s, n);\n    for (const t of e) {\n      const s = t.Tt(n);\n      null !== s && i(s);\n    }\n  }\n  function ks(t, i) {\n    return (s) => {\n      if (\n        !(function (t) {\n          return void 0 !== t.Wt;\n        })(s)\n      )\n        return [];\n      return (s.Wt()?.wa() ?? '') !== i ? [] : s.ta?.(t) ?? [];\n    };\n  }\n  function Ts(t, i, s, n) {\n    if (!t.length) return;\n    let e = 0;\n    const r = t[0].$t(n, !0);\n    let h = 1 === i ? s / 2 - (t[0].Wi() - r / 2) : t[0].Wi() - r / 2 - s / 2;\n    h = Math.max(0, h);\n    for (let r = 1; r < t.length; r++) {\n      const a = t[r],\n        l = t[r - 1],\n        o = l.$t(n, !1),\n        _ = a.Wi(),\n        u = l.Wi();\n      if (1 === i ? _ > u - o : _ < u + o) {\n        const n = u - o * i;\n        a.Fi(n);\n        const r = n - (i * o) / 2;\n        if ((1 === i ? r < 0 : r > s) && h > 0) {\n          const n = 1 === i ? -1 - r : r - s,\n            a = Math.min(n, h);\n          for (let s = e; s < t.length; s++) t[s].Fi(t[s].Wi() + i * a);\n          h -= a;\n        }\n      } else (e = r), (h = 1 === i ? u - o - _ : _ - (u + o));\n    }\n  }\n  class Rs {\n    constructor(t, i, s, n) {\n      (this.qi = null),\n        (this.Op = null),\n        (this.Lp = !1),\n        (this.Np = new it(200)),\n        (this.Wp = null),\n        (this.Fp = 0),\n        (this.Hp = !1),\n        (this.Up = () => {\n          this.Hp || this.Pt.$p().Qt().ar();\n        }),\n        (this.jp = () => {\n          this.Hp || this.Pt.$p().Qt().ar();\n        }),\n        (this.Pt = t),\n        (this.Ps = i),\n        (this.bl = i.layout),\n        (this.Gu = s),\n        (this.qp = 'left' === n),\n        (this.Yp = ks('normal', n)),\n        (this.Kp = ks('top', n)),\n        (this.Xp = ks('bottom', n)),\n        (this.qf = document.createElement('div')),\n        (this.qf.style.height = '100%'),\n        (this.qf.style.overflow = 'hidden'),\n        (this.qf.style.width = '25px'),\n        (this.qf.style.left = '0'),\n        (this.qf.style.position = 'relative'),\n        (this.Zp = xs(this.qf, Qi({ width: 16, height: 16 }))),\n        this.Zp.subscribeSuggestedBitmapSizeChanged(this.Up);\n      const e = this.Zp.canvasElement;\n      (e.style.position = 'absolute'),\n        (e.style.zIndex = '1'),\n        (e.style.left = '0'),\n        (e.style.top = '0'),\n        (this.Gp = xs(this.qf, Qi({ width: 16, height: 16 }))),\n        this.Gp.subscribeSuggestedBitmapSizeChanged(this.jp);\n      const r = this.Gp.canvasElement;\n      (r.style.position = 'absolute'),\n        (r.style.zIndex = '2'),\n        (r.style.left = '0'),\n        (r.style.top = '0');\n      const h = {\n        bf: this.np.bind(this),\n        gf: this.np.bind(this),\n        uf: this.ep.bind(this),\n        lf: this.ep.bind(this),\n        xf: this.Jp.bind(this),\n        pf: this.rp.bind(this),\n        df: this.rp.bind(this),\n        Kd: this.Qp.bind(this),\n        $d: this.Qp.bind(this),\n        if: this.tv.bind(this),\n        Ef: this.sp.bind(this),\n      };\n      this.Lf = new us(this.Gp.canvasElement, h, {\n        hf: () => !this.Ps.handleScroll.vertTouchDrag,\n        af: () => !0,\n      });\n    }\n    m() {\n      this.Lf.m(),\n        this.Gp.unsubscribeSuggestedBitmapSizeChanged(this.jp),\n        Ss(this.Gp.canvasElement),\n        this.Gp.dispose(),\n        this.Zp.unsubscribeSuggestedBitmapSizeChanged(this.Up),\n        Ss(this.Zp.canvasElement),\n        this.Zp.dispose(),\n        null !== this.qi && this.qi.no().u(this),\n        (this.qi = null);\n    }\n    Xf() {\n      return this.qf;\n    }\n    P() {\n      return this.bl.fontSize;\n    }\n    iv() {\n      const t = this.Gu.N();\n      return this.Wp !== t.k && (this.Np.Vn(), (this.Wp = t.k)), t;\n    }\n    sv() {\n      if (null === this.qi) return 0;\n      let t = 0;\n      const i = this.iv(),\n        s = a(\n          this.Zp.canvasElement.getContext('2d', {\n            colorSpace: this.Pt.$p().N().layout.colorSpace,\n          }),\n        );\n      s.save();\n      const n = this.qi.Ea();\n      (s.font = this.nv()),\n        n.length > 0 &&\n          (t = Math.max(\n            this.Np.Ei(s, n[0].Ga),\n            this.Np.Ei(s, n[n.length - 1].Ga),\n          ));\n      const e = this.ev();\n      for (let i = e.length; i--; ) {\n        const n = this.Np.Ei(s, e[i].ri());\n        n > t && (t = n);\n      }\n      const r = this.qi.zt();\n      if (\n        null !== r &&\n        null !== this.Op &&\n        2 !== (h = this.Ps.crosshair).mode &&\n        h.horzLine.visible &&\n        h.horzLine.labelVisible\n      ) {\n        const i = this.qi.Ts(1, r),\n          n = this.qi.Ts(this.Op.height - 2, r);\n        t = Math.max(\n          t,\n          this.Np.Ei(\n            s,\n            this.qi.Zi(Math.floor(Math.min(i, n)) + 0.11111111111111, r),\n          ),\n          this.Np.Ei(\n            s,\n            this.qi.Zi(Math.ceil(Math.max(i, n)) - 0.11111111111111, r),\n          ),\n        );\n      }\n      var h;\n      s.restore();\n      const l = t || 34;\n      return os(Math.ceil(i.S + i.C + i.B + i.I + 5 + l));\n    }\n    rv(t) {\n      (null !== this.Op && ts(this.Op, t)) ||\n        ((this.Op = t),\n        (this.Hp = !0),\n        this.Zp.resizeCanvasElement(t),\n        this.Gp.resizeCanvasElement(t),\n        (this.Hp = !1),\n        (this.qf.style.width = `${t.width}px`),\n        (this.qf.style.height = `${t.height}px`));\n    }\n    hv() {\n      return a(this.Op).width;\n    }\n    _s(t) {\n      this.qi !== t &&\n        (null !== this.qi && this.qi.no().u(this),\n        (this.qi = t),\n        t.no().i(this.ul.bind(this), this));\n    }\n    Wt() {\n      return this.qi;\n    }\n    Vn() {\n      const t = this.Pt.hp();\n      this.Pt.$p().Qt().Zo(t, a(this.Wt()));\n    }\n    av(t) {\n      if (null === this.Op) return;\n      const i = { colorSpace: this.Pt.$p().N().layout.colorSpace };\n      if (1 !== t) {\n        this.lv(), this.Zp.applySuggestedBitmapSize();\n        const t = rs(this.Zp, i);\n        null !== t &&\n          (t.useBitmapCoordinateSpace((t) => {\n            this.ov(t), this._v(t);\n          }),\n          this.Pt.uv(t, this.Xp),\n          this.cv(t),\n          this.Pt.uv(t, this.Yp),\n          this.dv(t));\n      }\n      this.Gp.applySuggestedBitmapSize();\n      const s = rs(this.Gp, i);\n      null !== s &&\n        (s.useBitmapCoordinateSpace(({ context: t, bitmapSize: i }) => {\n          t.clearRect(0, 0, i.width, i.height);\n        }),\n        this.fv(s),\n        this.Pt.uv(s, this.Kp));\n    }\n    Gf() {\n      return this.Zp.bitmapSize;\n    }\n    Jf(t, i, s) {\n      const n = this.Gf();\n      n.width > 0 && n.height > 0 && t.drawImage(this.Zp.canvasElement, i, s);\n    }\n    yt() {\n      this.qi?.Ea();\n    }\n    np(t) {\n      if (\n        null === this.qi ||\n        this.qi.Ki() ||\n        !this.Ps.handleScale.axisPressedMouseMove.price\n      )\n        return;\n      const i = this.Pt.$p().Qt(),\n        s = this.Pt.hp();\n      (this.Lp = !0), i.Uo(s, this.qi, t.localY);\n    }\n    ep(t) {\n      if (null === this.qi || !this.Ps.handleScale.axisPressedMouseMove.price)\n        return;\n      const i = this.Pt.$p().Qt(),\n        s = this.Pt.hp(),\n        n = this.qi;\n      i.$o(s, n, t.localY);\n    }\n    Jp() {\n      if (null === this.qi || !this.Ps.handleScale.axisPressedMouseMove.price)\n        return;\n      const t = this.Pt.$p().Qt(),\n        i = this.Pt.hp(),\n        s = this.qi;\n      this.Lp && ((this.Lp = !1), t.jo(i, s));\n    }\n    rp(t) {\n      if (null === this.qi || !this.Ps.handleScale.axisPressedMouseMove.price)\n        return;\n      const i = this.Pt.$p().Qt(),\n        s = this.Pt.hp();\n      (this.Lp = !1), i.jo(s, this.qi);\n    }\n    Qp(t) {\n      this.Ps.handleScale.axisDoubleClickReset.price && this.Vn();\n    }\n    tv(t) {\n      if (null === this.qi) return;\n      !this.Pt.$p().Qt().N().handleScale.axisPressedMouseMove.price ||\n        this.qi.Oe() ||\n        this.qi.El() ||\n        this.pv(1);\n    }\n    sp(t) {\n      this.pv(0);\n    }\n    ev() {\n      const t = [],\n        i = null === this.qi ? void 0 : this.qi;\n      return (\n        ((s) => {\n          for (let n = 0; n < s.length; ++n) {\n            const e = s[n].Fs(this.Pt.hp(), i);\n            for (let i = 0; i < e.length; i++) t.push(e[i]);\n          }\n        })(this.Pt.hp().Dt()),\n        t\n      );\n    }\n    ov({ context: t, bitmapSize: i }) {\n      const { width: s, height: n } = i,\n        e = this.Pt.hp().Qt(),\n        r = e.$(),\n        h = e.Wc();\n      r === h ? B(t, 0, 0, s, n, r) : z(t, 0, 0, s, n, r, h);\n    }\n    _v({ context: t, bitmapSize: i, horizontalPixelRatio: s }) {\n      if (null === this.Op || null === this.qi || !this.qi.N().borderVisible)\n        return;\n      t.fillStyle = this.qi.N().borderColor;\n      const n = Math.max(1, Math.floor(this.iv().S * s));\n      let e;\n      (e = this.qp ? i.width - n : 0), t.fillRect(e, 0, n, i.height);\n    }\n    cv(t) {\n      if (null === this.Op || null === this.qi) return;\n      const i = this.qi.Ea(),\n        s = this.qi.N(),\n        n = this.iv(),\n        e = this.qp ? this.Op.width - n.C : 0;\n      s.borderVisible &&\n        s.ticksVisible &&\n        t.useBitmapCoordinateSpace(\n          ({ context: t, horizontalPixelRatio: r, verticalPixelRatio: h }) => {\n            t.fillStyle = s.borderColor;\n            const a = Math.max(1, Math.floor(h)),\n              l = Math.floor(0.5 * h),\n              o = Math.round(n.C * r);\n            t.beginPath();\n            for (const s of i)\n              t.rect(Math.floor(e * r), Math.round(s.ya * h) - l, o, a);\n            t.fill();\n          },\n        ),\n        t.useMediaCoordinateSpace(({ context: t }) => {\n          (t.font = this.nv()),\n            (t.fillStyle = s.textColor ?? this.bl.textColor),\n            (t.textAlign = this.qp ? 'right' : 'left'),\n            (t.textBaseline = 'middle');\n          const r = this.qp ? Math.round(e - n.B) : Math.round(e + n.C + n.B),\n            h = i.map((i) => this.Np.Di(t, i.Ga));\n          for (let s = i.length; s--; ) {\n            const n = i[s];\n            t.fillText(n.Ga, r, n.ya + h[s]);\n          }\n        });\n    }\n    lv() {\n      if (null === this.Op || null === this.qi) return;\n      let t = this.Op.height / 2;\n      const i = [],\n        s = this.qi.Dt().slice(),\n        n = this.Pt.hp(),\n        e = this.iv();\n      this.qi === n.$n() &&\n        this.Pt.hp()\n          .Dt()\n          .forEach((t) => {\n            n.Un(t) && s.push(t);\n          });\n      const r = this.qi.ba()[0],\n        h = this.qi;\n      s.forEach((s) => {\n        const e = s.Fs(n, h);\n        e.forEach((t) => {\n          t.Fi(null), t.Hi() && i.push(t);\n        }),\n          r === s && e.length > 0 && (t = e[0].Bi());\n      }),\n        i.forEach((t) => t.Fi(t.Bi()));\n      this.qi.N().alignLabels && this.vv(i, e, t);\n    }\n    vv(t, i, s) {\n      if (null === this.Op) return;\n      const n = t.filter((t) => t.Bi() <= s),\n        e = t.filter((t) => t.Bi() > s);\n      n.sort((t, i) => i.Bi() - t.Bi()),\n        n.length && e.length && e.push(n[0]),\n        e.sort((t, i) => t.Bi() - i.Bi());\n      for (const s of t) {\n        const t = Math.floor(s.$t(i) / 2),\n          n = s.Bi();\n        n > -t && n < t && s.Fi(t),\n          n > this.Op.height - t &&\n            n < this.Op.height + t &&\n            s.Fi(this.Op.height - t);\n      }\n      Ts(n, 1, this.Op.height, i), Ts(e, -1, this.Op.height, i);\n    }\n    dv(t) {\n      if (null === this.Op) return;\n      const i = this.ev(),\n        s = this.iv(),\n        n = this.qp ? 'right' : 'left';\n      i.forEach((i) => {\n        if (i.Ui()) {\n          i.Tt(a(this.qi)).nt(t, s, this.Np, n);\n        }\n      });\n    }\n    fv(t) {\n      if (null === this.Op || null === this.qi) return;\n      const i = this.Pt.$p().Qt(),\n        s = [],\n        n = this.Pt.hp(),\n        e = i._c().Fs(n, this.qi);\n      e.length && s.push(e);\n      const r = this.iv(),\n        h = this.qp ? 'right' : 'left';\n      s.forEach((i) => {\n        i.forEach((i) => {\n          i.Tt(a(this.qi)).nt(t, r, this.Np, h);\n        });\n      });\n    }\n    pv(t) {\n      this.qf.style.cursor = 1 === t ? 'ns-resize' : 'default';\n    }\n    ul() {\n      const t = this.sv();\n      this.Fp < t && this.Pt.$p().Qt().Bh(), (this.Fp = t);\n    }\n    nv() {\n      return g(this.bl.fontSize, this.bl.fontFamily);\n    }\n  }\n  function Ds(t, i) {\n    return t.Jh?.(i) ?? [];\n  }\n  function Es(t, i) {\n    return t.Ws?.(i) ?? [];\n  }\n  function Vs(t, i) {\n    return t.us?.(i) ?? [];\n  }\n  function Bs(t, i) {\n    return t.Xh?.(i) ?? [];\n  }\n  class Is {\n    constructor(t, i) {\n      (this.Op = Qi({ width: 0, height: 0 })),\n        (this.mv = null),\n        (this.wv = null),\n        (this.gv = null),\n        (this.Mv = null),\n        (this.bv = !1),\n        (this.xv = new o()),\n        (this.Sv = new o()),\n        (this.Cv = 0),\n        (this.Pv = !1),\n        (this.yv = null),\n        (this.kv = !1),\n        (this.Tv = null),\n        (this.Rv = null),\n        (this.Hp = !1),\n        (this.Up = () => {\n          this.Hp || null === this.Dv || this.ts().ar();\n        }),\n        (this.jp = () => {\n          this.Hp || null === this.Dv || this.ts().ar();\n        }),\n        (this.Dp = t),\n        (this.Dv = i),\n        this.Dv.t_().i(this.Ev.bind(this), this, !0),\n        (this.Vv = document.createElement('td')),\n        (this.Vv.style.padding = '0'),\n        (this.Vv.style.position = 'relative');\n      const s = document.createElement('div');\n      (s.style.width = '100%'),\n        (s.style.height = '100%'),\n        (s.style.position = 'relative'),\n        (s.style.overflow = 'hidden'),\n        (this.Bv = document.createElement('td')),\n        (this.Bv.style.padding = '0'),\n        (this.Iv = document.createElement('td')),\n        (this.Iv.style.padding = '0'),\n        this.Vv.appendChild(s),\n        (this.Zp = xs(s, Qi({ width: 16, height: 16 }))),\n        this.Zp.subscribeSuggestedBitmapSizeChanged(this.Up);\n      const n = this.Zp.canvasElement;\n      (n.style.position = 'absolute'),\n        (n.style.zIndex = '1'),\n        (n.style.left = '0'),\n        (n.style.top = '0'),\n        (this.Gp = xs(s, Qi({ width: 16, height: 16 }))),\n        this.Gp.subscribeSuggestedBitmapSizeChanged(this.jp);\n      const e = this.Gp.canvasElement;\n      (e.style.position = 'absolute'),\n        (e.style.zIndex = '2'),\n        (e.style.left = '0'),\n        (e.style.top = '0'),\n        (this.jf = document.createElement('tr')),\n        this.jf.appendChild(this.Bv),\n        this.jf.appendChild(this.Vv),\n        this.jf.appendChild(this.Iv),\n        this.Av(),\n        (this.Lf = new us(this.Gp.canvasElement, this, {\n          hf: () => null === this.yv && !this.Dp.N().handleScroll.vertTouchDrag,\n          af: () => null === this.yv && !this.Dp.N().handleScroll.horzTouchDrag,\n        }));\n    }\n    m() {\n      null !== this.mv && this.mv.m(),\n        null !== this.wv && this.wv.m(),\n        (this.gv = null),\n        this.Gp.unsubscribeSuggestedBitmapSizeChanged(this.jp),\n        Ss(this.Gp.canvasElement),\n        this.Gp.dispose(),\n        this.Zp.unsubscribeSuggestedBitmapSizeChanged(this.Up),\n        Ss(this.Zp.canvasElement),\n        this.Zp.dispose(),\n        null !== this.Dv && (this.Dv.t_().u(this), this.Dv.m()),\n        this.Lf.m();\n    }\n    hp() {\n      return a(this.Dv);\n    }\n    zv(t) {\n      null !== this.Dv && this.Dv.t_().u(this),\n        (this.Dv = t),\n        null !== this.Dv &&\n          this.Dv.t_().i(Is.prototype.Ev.bind(this), this, !0),\n        this.Av(),\n        this.Dp.Uf().indexOf(this) === this.Dp.Uf().length - 1\n          ? ((this.gv = this.gv ?? new bs(this.Vv, this.Dp)), this.gv.yt())\n          : (this.gv?.Vp(), (this.gv = null));\n    }\n    $p() {\n      return this.Dp;\n    }\n    Xf() {\n      return this.jf;\n    }\n    Av() {\n      if (null !== this.Dv && (this.Ov(), 0 !== this.ts().Ys().length)) {\n        if (null !== this.mv) {\n          const t = this.Dv.Fo();\n          this.mv._s(a(t));\n        }\n        if (null !== this.wv) {\n          const t = this.Dv.Ho();\n          this.wv._s(a(t));\n        }\n      }\n    }\n    Lv() {\n      null !== this.mv && this.mv.yt(), null !== this.wv && this.wv.yt();\n    }\n    Vo() {\n      return null !== this.Dv ? this.Dv.Vo() : 0;\n    }\n    Bo(t) {\n      this.Dv && this.Dv.Bo(t);\n    }\n    if(t) {\n      if (!this.Dv) return;\n      this.Nv();\n      const i = t.localX,\n        s = t.localY;\n      this.Wv(i, s, t);\n    }\n    bf(t) {\n      this.Nv(), this.Fv(), this.Wv(t.localX, t.localY, t);\n    }\n    sf(t) {\n      if (!this.Dv) return;\n      this.Nv();\n      const i = t.localX,\n        s = t.localY;\n      this.Wv(i, s, t);\n    }\n    vf(t) {\n      null !== this.Dv && (this.Nv(), this.Hv(t));\n    }\n    Kd(t) {\n      null !== this.Dv && this.Uv(this.Sv, t);\n    }\n    $d(t) {\n      this.Kd(t);\n    }\n    uf(t) {\n      this.Nv(), this.$v(t), this.Wv(t.localX, t.localY, t);\n    }\n    pf(t) {\n      null !== this.Dv && (this.Nv(), (this.Pv = !1), this.jv(t));\n    }\n    ff(t) {\n      null !== this.Dv && this.Hv(t);\n    }\n    Vf(t) {\n      if (((this.Pv = !0), null === this.yv)) {\n        const i = { x: t.localX, y: t.localY };\n        this.qv(i, i, t);\n      }\n    }\n    Ef(t) {\n      null !== this.Dv && (this.Nv(), this.Dv.Qt().ac(null), this.Yv());\n    }\n    Kv() {\n      return this.xv;\n    }\n    Xv() {\n      return this.Sv;\n    }\n    Pf() {\n      (this.Cv = 1), this.ts().hn();\n    }\n    yf(t, i) {\n      if (!this.Dp.N().handleScale.pinch) return;\n      const s = 5 * (i - this.Cv);\n      (this.Cv = i), this.ts().Mc(t._t, s);\n    }\n    gf(t) {\n      (this.Pv = !1), (this.kv = null !== this.yv), this.Fv();\n      const i = this.ts()._c();\n      null !== this.yv &&\n        i.Et() &&\n        ((this.Tv = { x: i.si(), y: i.ni() }),\n        (this.yv = { x: t.localX, y: t.localY }));\n    }\n    lf(t) {\n      if (null === this.Dv) return;\n      const i = t.localX,\n        s = t.localY;\n      if (null === this.yv) this.$v(t);\n      else {\n        this.kv = !1;\n        const n = a(this.Tv),\n          e = n.x + (i - this.yv.x),\n          r = n.y + (s - this.yv.y);\n        this.Wv(e, r, t);\n      }\n    }\n    df(t) {\n      0 === this.$p().N().trackingMode.exitMode && (this.kv = !0),\n        this.Zv(),\n        this.jv(t);\n    }\n    Yn(t, i) {\n      const s = this.Dv;\n      return null === s ? null : bi(s, t, i);\n    }\n    Gv(t, i) {\n      a('left' === i ? this.mv : this.wv).rv(\n        Qi({ width: t, height: this.Op.height }),\n      );\n    }\n    Zf() {\n      return this.Op;\n    }\n    rv(t) {\n      ts(this.Op, t) ||\n        ((this.Op = t),\n        (this.Hp = !0),\n        this.Zp.resizeCanvasElement(t),\n        this.Gp.resizeCanvasElement(t),\n        (this.Hp = !1),\n        (this.Vv.style.width = t.width + 'px'),\n        (this.Vv.style.height = t.height + 'px'));\n    }\n    Jv() {\n      const t = a(this.Dv);\n      t.Wo(t.Fo()), t.Wo(t.Ho());\n      for (const i of t.ba())\n        if (t.Un(i)) {\n          const s = i.Wt();\n          null !== s && t.Wo(s), i.Ns();\n        }\n      for (const i of t.s_()) i.Ns();\n    }\n    Gf() {\n      return this.Zp.bitmapSize;\n    }\n    Jf(t, i, s) {\n      const n = this.Gf();\n      n.width > 0 && n.height > 0 && t.drawImage(this.Zp.canvasElement, i, s);\n    }\n    av(t) {\n      if (0 === t) return;\n      if (null === this.Dv) return;\n      t > 1 && this.Jv(),\n        null !== this.mv && this.mv.av(t),\n        null !== this.wv && this.wv.av(t);\n      const i = { colorSpace: this.Dp.N().layout.colorSpace };\n      if (1 !== t) {\n        this.Zp.applySuggestedBitmapSize();\n        const t = rs(this.Zp, i);\n        null !== t &&\n          (t.useBitmapCoordinateSpace((t) => {\n            this.ov(t);\n          }),\n          this.Dv &&\n            (this.Qv(t, Ds), this.tm(t), this.Qv(t, Es), this.Qv(t, Vs)));\n      }\n      this.Gp.applySuggestedBitmapSize();\n      const s = rs(this.Gp, i);\n      null !== s &&\n        (s.useBitmapCoordinateSpace(({ context: t, bitmapSize: i }) => {\n          t.clearRect(0, 0, i.width, i.height);\n        }),\n        this.im(s),\n        this.Qv(s, Bs),\n        this.Qv(s, Vs));\n    }\n    sm() {\n      return this.mv;\n    }\n    nm() {\n      return this.wv;\n    }\n    uv(t, i) {\n      this.Qv(t, i);\n    }\n    Ev() {\n      null !== this.Dv && this.Dv.t_().u(this), (this.Dv = null);\n    }\n    Hv(t) {\n      this.Uv(this.xv, t);\n    }\n    Uv(t, i) {\n      const s = i.localX,\n        n = i.localY;\n      t.v() && t.p(this.ts().It().uu(s), { x: s, y: n }, i);\n    }\n    ov({ context: t, bitmapSize: i }) {\n      const { width: s, height: n } = i,\n        e = this.ts(),\n        r = e.$(),\n        h = e.Wc();\n      r === h ? B(t, 0, 0, s, n, h) : z(t, 0, 0, s, n, r, h);\n    }\n    tm(t) {\n      const i = a(this.Dv),\n        s = i.i_().lr().Tt(i);\n      null !== s && s.nt(t, !1);\n    }\n    im(t) {\n      this.rm(t, Es, Ps, this.ts()._c());\n    }\n    Qv(t, i) {\n      const s = a(this.Dv),\n        n = s.Dt(),\n        e = s.s_();\n      for (const s of e) this.rm(t, i, Cs, s);\n      for (const s of n) this.rm(t, i, Cs, s);\n      for (const s of e) this.rm(t, i, Ps, s);\n      for (const s of n) this.rm(t, i, Ps, s);\n    }\n    rm(t, i, s, n) {\n      const e = a(this.Dv),\n        r = e.Qt().hc(),\n        h = null !== r && r.n_ === n,\n        l = null !== r && h && void 0 !== r.e_ ? r.e_.Xn : void 0;\n      ys(i, (i) => s(i, t, h, l), n, e);\n    }\n    Ov() {\n      if (null === this.Dv) return;\n      const t = this.Dp,\n        i = this.Dv.Fo().N().visible,\n        s = this.Dv.Ho().N().visible;\n      i ||\n        null === this.mv ||\n        (this.Bv.removeChild(this.mv.Xf()), this.mv.m(), (this.mv = null)),\n        s ||\n          null === this.wv ||\n          (this.Iv.removeChild(this.wv.Xf()), this.wv.m(), (this.wv = null));\n      const n = t.Qt().Ec();\n      i &&\n        null === this.mv &&\n        ((this.mv = new Rs(this, t.N(), n, 'left')),\n        this.Bv.appendChild(this.mv.Xf())),\n        s &&\n          null === this.wv &&\n          ((this.wv = new Rs(this, t.N(), n, 'right')),\n          this.Iv.appendChild(this.wv.Xf()));\n    }\n    hm(t) {\n      return (t.Bf && this.Pv) || null !== this.yv;\n    }\n    am(t) {\n      return Math.max(0, Math.min(t, this.Op.width - 1));\n    }\n    lm(t) {\n      return Math.max(0, Math.min(t, this.Op.height - 1));\n    }\n    Wv(t, i, s) {\n      this.ts().kc(this.am(t), this.lm(i), s, a(this.Dv));\n    }\n    Yv() {\n      this.ts().Rc();\n    }\n    Zv() {\n      this.kv && ((this.yv = null), this.Yv());\n    }\n    qv(t, i, s) {\n      (this.yv = t), (this.kv = !1), this.Wv(i.x, i.y, s);\n      const n = this.ts()._c();\n      this.Tv = { x: n.si(), y: n.ni() };\n    }\n    ts() {\n      return this.Dp.Qt();\n    }\n    jv(t) {\n      if (!this.bv) return;\n      const i = this.ts(),\n        s = this.hp();\n      if (\n        (i.Ko(s, s.ks()),\n        (this.Mv = null),\n        (this.bv = !1),\n        i.Cc(),\n        null !== this.Rv)\n      ) {\n        const t = performance.now(),\n          s = i.It();\n        this.Rv.le(s.wu(), t), this.Rv.Tu(t) || i._n(this.Rv);\n      }\n    }\n    Nv() {\n      this.yv = null;\n    }\n    Fv() {\n      if (!this.Dv) return;\n      if (\n        (this.ts().hn(),\n        document.activeElement !== document.body &&\n          document.activeElement !== document.documentElement)\n      )\n        a(document.activeElement).blur();\n      else {\n        const t = document.getSelection();\n        null !== t && t.removeAllRanges();\n      }\n      !this.Dv.ks().Ki() && this.ts().It().Ki();\n    }\n    $v(t) {\n      if (null === this.Dv) return;\n      const i = this.ts(),\n        s = i.It();\n      if (s.Ki()) return;\n      const n = this.Dp.N(),\n        e = n.handleScroll,\n        r = n.kineticScroll;\n      if (\n        (!e.pressedMouseMove || t.Bf) &&\n        ((!e.horzTouchDrag && !e.vertTouchDrag) || !t.Bf)\n      )\n        return;\n      const h = this.Dv.ks(),\n        a = performance.now();\n      if (\n        (null !== this.Mv ||\n          this.hm(t) ||\n          (this.Mv = {\n            x: t.clientX,\n            y: t.clientY,\n            ed: a,\n            om: t.localX,\n            _m: t.localY,\n          }),\n        null !== this.Mv &&\n          !this.bv &&\n          (this.Mv.x !== t.clientX || this.Mv.y !== t.clientY))\n      ) {\n        if ((t.Bf && r.touch) || (!t.Bf && r.mouse)) {\n          const t = s.vu();\n          (this.Rv = new Ms(0.2 / t, 7 / t, 0.997, 15 / t)),\n            this.Rv.Cp(s.wu(), this.Mv.ed);\n        } else this.Rv = null;\n        h.Ki() || i.qo(this.Dv, h, t.localY), i.xc(t.localX), (this.bv = !0);\n      }\n      this.bv &&\n        (h.Ki() || i.Yo(this.Dv, h, t.localY),\n        i.Sc(t.localX),\n        null !== this.Rv && this.Rv.Cp(s.wu(), a));\n    }\n  }\n  class As {\n    constructor(t, i, s, n, e) {\n      (this.St = !0),\n        (this.Op = Qi({ width: 0, height: 0 })),\n        (this.Up = () => this.av(3)),\n        (this.qp = 'left' === t),\n        (this.Gu = s.Ec),\n        (this.Ps = i),\n        (this.um = n),\n        (this.dm = e),\n        (this.qf = document.createElement('div')),\n        (this.qf.style.width = '25px'),\n        (this.qf.style.height = '100%'),\n        (this.qf.style.overflow = 'hidden'),\n        (this.Zp = xs(this.qf, Qi({ width: 16, height: 16 }))),\n        this.Zp.subscribeSuggestedBitmapSizeChanged(this.Up);\n    }\n    m() {\n      this.Zp.unsubscribeSuggestedBitmapSizeChanged(this.Up),\n        Ss(this.Zp.canvasElement),\n        this.Zp.dispose();\n    }\n    Xf() {\n      return this.qf;\n    }\n    Zf() {\n      return this.Op;\n    }\n    rv(t) {\n      ts(this.Op, t) ||\n        ((this.Op = t),\n        this.Zp.resizeCanvasElement(t),\n        (this.qf.style.width = `${t.width}px`),\n        (this.qf.style.height = `${t.height}px`),\n        (this.St = !0));\n    }\n    av(t) {\n      if (t < 3 && !this.St) return;\n      if (0 === this.Op.width || 0 === this.Op.height) return;\n      (this.St = !1), this.Zp.applySuggestedBitmapSize();\n      const i = rs(this.Zp, { colorSpace: this.Ps.layout.colorSpace });\n      null !== i &&\n        i.useBitmapCoordinateSpace((t) => {\n          this.ov(t), this._v(t);\n        });\n    }\n    Gf() {\n      return this.Zp.bitmapSize;\n    }\n    Jf(t, i, s) {\n      const n = this.Gf();\n      n.width > 0 && n.height > 0 && t.drawImage(this.Zp.canvasElement, i, s);\n    }\n    _v({\n      context: t,\n      bitmapSize: i,\n      horizontalPixelRatio: s,\n      verticalPixelRatio: n,\n    }) {\n      if (!this.um()) return;\n      t.fillStyle = this.Ps.timeScale.borderColor;\n      const e = Math.floor(this.Gu.N().S * s),\n        r = Math.floor(this.Gu.N().S * n),\n        h = this.qp ? i.width - e : 0;\n      t.fillRect(h, 0, e, r);\n    }\n    ov({ context: t, bitmapSize: i }) {\n      B(t, 0, 0, i.width, i.height, this.dm());\n    }\n  }\n  function zs(t) {\n    return (i) => i.ia?.(t) ?? [];\n  }\n  const Os = zs('normal'),\n    Ls = zs('top'),\n    Ns = zs('bottom');\n  class Ws {\n    constructor(t, i) {\n      (this.fm = null),\n        (this.pm = null),\n        (this.M = null),\n        (this.vm = !1),\n        (this.Op = Qi({ width: 0, height: 0 })),\n        (this.wm = new o()),\n        (this.Np = new it(5)),\n        (this.Hp = !1),\n        (this.Up = () => {\n          this.Hp || this.Dp.Qt().ar();\n        }),\n        (this.jp = () => {\n          this.Hp || this.Dp.Qt().ar();\n        }),\n        (this.Dp = t),\n        (this.o_ = i),\n        (this.Ps = t.N().layout),\n        (this.yp = document.createElement('tr')),\n        (this.gm = document.createElement('td')),\n        (this.gm.style.padding = '0'),\n        (this.Mm = document.createElement('td')),\n        (this.Mm.style.padding = '0'),\n        (this.qf = document.createElement('td')),\n        (this.qf.style.height = '25px'),\n        (this.qf.style.padding = '0'),\n        (this.bm = document.createElement('div')),\n        (this.bm.style.width = '100%'),\n        (this.bm.style.height = '100%'),\n        (this.bm.style.position = 'relative'),\n        (this.bm.style.overflow = 'hidden'),\n        this.qf.appendChild(this.bm),\n        (this.Zp = xs(this.bm, Qi({ width: 16, height: 16 }))),\n        this.Zp.subscribeSuggestedBitmapSizeChanged(this.Up);\n      const s = this.Zp.canvasElement;\n      (s.style.position = 'absolute'),\n        (s.style.zIndex = '1'),\n        (s.style.left = '0'),\n        (s.style.top = '0'),\n        (this.Gp = xs(this.bm, Qi({ width: 16, height: 16 }))),\n        this.Gp.subscribeSuggestedBitmapSizeChanged(this.jp);\n      const n = this.Gp.canvasElement;\n      (n.style.position = 'absolute'),\n        (n.style.zIndex = '2'),\n        (n.style.left = '0'),\n        (n.style.top = '0'),\n        this.yp.appendChild(this.gm),\n        this.yp.appendChild(this.qf),\n        this.yp.appendChild(this.Mm),\n        this.xm(),\n        this.Dp.Qt().Eo().i(this.xm.bind(this), this),\n        (this.Lf = new us(this.Gp.canvasElement, this, {\n          hf: () => !0,\n          af: () => !this.Dp.N().handleScroll.horzTouchDrag,\n        }));\n    }\n    m() {\n      this.Lf.m(),\n        null !== this.fm && this.fm.m(),\n        null !== this.pm && this.pm.m(),\n        this.Gp.unsubscribeSuggestedBitmapSizeChanged(this.jp),\n        Ss(this.Gp.canvasElement),\n        this.Gp.dispose(),\n        this.Zp.unsubscribeSuggestedBitmapSizeChanged(this.Up),\n        Ss(this.Zp.canvasElement),\n        this.Zp.dispose();\n    }\n    Xf() {\n      return this.yp;\n    }\n    Sm() {\n      return this.fm;\n    }\n    Cm() {\n      return this.pm;\n    }\n    bf(t) {\n      if (this.vm) return;\n      this.vm = !0;\n      const i = this.Dp.Qt();\n      !i.It().Ki() &&\n        this.Dp.N().handleScale.axisPressedMouseMove.time &&\n        i.gc(t.localX);\n    }\n    gf(t) {\n      this.bf(t);\n    }\n    xf() {\n      const t = this.Dp.Qt();\n      !t.It().Ki() &&\n        this.vm &&\n        ((this.vm = !1),\n        this.Dp.N().handleScale.axisPressedMouseMove.time && t.yc());\n    }\n    uf(t) {\n      const i = this.Dp.Qt();\n      !i.It().Ki() &&\n        this.Dp.N().handleScale.axisPressedMouseMove.time &&\n        i.Pc(t.localX);\n    }\n    lf(t) {\n      this.uf(t);\n    }\n    pf() {\n      this.vm = !1;\n      const t = this.Dp.Qt();\n      (t.It().Ki() && !this.Dp.N().handleScale.axisPressedMouseMove.time) ||\n        t.yc();\n    }\n    df() {\n      this.pf();\n    }\n    Kd() {\n      this.Dp.N().handleScale.axisDoubleClickReset.time && this.Dp.Qt().cn();\n    }\n    $d() {\n      this.Kd();\n    }\n    if() {\n      this.Dp.Qt().N().handleScale.axisPressedMouseMove.time && this.pv(1);\n    }\n    Ef() {\n      this.pv(0);\n    }\n    Zf() {\n      return this.Op;\n    }\n    Pm() {\n      return this.wm;\n    }\n    ym(t, i, s) {\n      ts(this.Op, t) ||\n        ((this.Op = t),\n        (this.Hp = !0),\n        this.Zp.resizeCanvasElement(t),\n        this.Gp.resizeCanvasElement(t),\n        (this.Hp = !1),\n        (this.qf.style.width = `${t.width}px`),\n        (this.qf.style.height = `${t.height}px`),\n        this.wm.p(t)),\n        null !== this.fm && this.fm.rv(Qi({ width: i, height: t.height })),\n        null !== this.pm && this.pm.rv(Qi({ width: s, height: t.height }));\n    }\n    km() {\n      const t = this.Tm();\n      return Math.ceil(t.S + t.C + t.P + t.A + t.V + t.Rm);\n    }\n    yt() {\n      this.Dp.Qt().It().Ea();\n    }\n    Gf() {\n      return this.Zp.bitmapSize;\n    }\n    Jf(t, i, s) {\n      const n = this.Gf();\n      n.width > 0 && n.height > 0 && t.drawImage(this.Zp.canvasElement, i, s);\n    }\n    av(t) {\n      if (0 === t) return;\n      const i = { colorSpace: this.Ps.colorSpace };\n      if (1 !== t) {\n        this.Zp.applySuggestedBitmapSize();\n        const s = rs(this.Zp, i);\n        null !== s &&\n          (s.useBitmapCoordinateSpace((t) => {\n            this.ov(t), this._v(t), this.Dm(s, Ns);\n          }),\n          this.cv(s),\n          this.Dm(s, Os)),\n          null !== this.fm && this.fm.av(t),\n          null !== this.pm && this.pm.av(t);\n      }\n      this.Gp.applySuggestedBitmapSize();\n      const s = rs(this.Gp, i);\n      null !== s &&\n        (s.useBitmapCoordinateSpace(({ context: t, bitmapSize: i }) => {\n          t.clearRect(0, 0, i.width, i.height);\n        }),\n        this.Em([...this.Dp.Qt().Ys(), this.Dp.Qt()._c()], s),\n        this.Dm(s, Ls));\n    }\n    Dm(t, i) {\n      const s = this.Dp.Qt().Ys();\n      for (const n of s) ys(i, (i) => Cs(i, t, !1, void 0), n, void 0);\n      for (const n of s) ys(i, (i) => Ps(i, t, !1, void 0), n, void 0);\n    }\n    ov({ context: t, bitmapSize: i }) {\n      B(t, 0, 0, i.width, i.height, this.Dp.Qt().Wc());\n    }\n    _v({ context: t, bitmapSize: i, verticalPixelRatio: s }) {\n      if (this.Dp.N().timeScale.borderVisible) {\n        t.fillStyle = this.Vm();\n        const n = Math.max(1, Math.floor(this.Tm().S * s));\n        t.fillRect(0, 0, i.width, n);\n      }\n    }\n    cv(t) {\n      const i = this.Dp.Qt().It(),\n        s = i.Ea();\n      if (!s || 0 === s.length) return;\n      const n = this.o_.maxTickMarkWeight(s),\n        e = this.Tm(),\n        r = i.N();\n      r.borderVisible &&\n        r.ticksVisible &&\n        t.useBitmapCoordinateSpace(\n          ({ context: t, horizontalPixelRatio: i, verticalPixelRatio: n }) => {\n            (t.strokeStyle = this.Vm()), (t.fillStyle = this.Vm());\n            const r = Math.max(1, Math.floor(i)),\n              h = Math.floor(0.5 * i);\n            t.beginPath();\n            const a = Math.round(e.C * n);\n            for (let n = s.length; n--; ) {\n              const e = Math.round(s[n].coord * i);\n              t.rect(e - h, 0, r, a);\n            }\n            t.fill();\n          },\n        ),\n        t.useMediaCoordinateSpace(({ context: t }) => {\n          const i = e.S + e.C + e.A + e.P / 2;\n          (t.textAlign = 'center'),\n            (t.textBaseline = 'middle'),\n            (t.fillStyle = this.H()),\n            (t.font = this.nv());\n          for (const e of s)\n            if (e.weight < n) {\n              const s = e.needAlignCoordinate\n                ? this.Bm(t, e.coord, e.label)\n                : e.coord;\n              t.fillText(e.label, s, i);\n            }\n          this.Dp.N().timeScale.allowBoldLabels && (t.font = this.Im());\n          for (const e of s)\n            if (e.weight >= n) {\n              const s = e.needAlignCoordinate\n                ? this.Bm(t, e.coord, e.label)\n                : e.coord;\n              t.fillText(e.label, s, i);\n            }\n        });\n    }\n    Bm(t, i, s) {\n      const n = this.Np.Ei(t, s),\n        e = n / 2,\n        r = Math.floor(i - e) + 0.5;\n      return (\n        r < 0\n          ? (i += Math.abs(0 - r))\n          : r + n > this.Op.width && (i -= Math.abs(this.Op.width - (r + n))),\n        i\n      );\n    }\n    Em(t, i) {\n      const s = this.Tm();\n      for (const n of t) for (const t of n.cs()) t.Tt().nt(i, s);\n    }\n    Vm() {\n      return this.Dp.N().timeScale.borderColor;\n    }\n    H() {\n      return this.Ps.textColor;\n    }\n    W() {\n      return this.Ps.fontSize;\n    }\n    nv() {\n      return g(this.W(), this.Ps.fontFamily);\n    }\n    Im() {\n      return g(this.W(), this.Ps.fontFamily, 'bold');\n    }\n    Tm() {\n      null === this.M &&\n        (this.M = {\n          S: 1,\n          O: NaN,\n          A: NaN,\n          V: NaN,\n          Ji: NaN,\n          C: 5,\n          P: NaN,\n          k: '',\n          Gi: new it(),\n          Rm: 0,\n        });\n      const t = this.M,\n        i = this.nv();\n      if (t.k !== i) {\n        const s = this.W();\n        (t.P = s),\n          (t.k = i),\n          (t.A = (3 * s) / 12),\n          (t.V = (3 * s) / 12),\n          (t.Ji = (9 * s) / 12),\n          (t.O = 0),\n          (t.Rm = (4 * s) / 12),\n          t.Gi.Vn();\n      }\n      return this.M;\n    }\n    pv(t) {\n      this.qf.style.cursor = 1 === t ? 'ew-resize' : 'default';\n    }\n    xm() {\n      const t = this.Dp.Qt(),\n        i = t.N();\n      i.leftPriceScale.visible ||\n        null === this.fm ||\n        (this.gm.removeChild(this.fm.Xf()), this.fm.m(), (this.fm = null)),\n        i.rightPriceScale.visible ||\n          null === this.pm ||\n          (this.Mm.removeChild(this.pm.Xf()), this.pm.m(), (this.pm = null));\n      const s = { Ec: this.Dp.Qt().Ec() },\n        n = () => i.leftPriceScale.borderVisible && t.It().N().borderVisible,\n        e = () => t.Wc();\n      i.leftPriceScale.visible &&\n        null === this.fm &&\n        ((this.fm = new As('left', i, s, n, e)),\n        this.gm.appendChild(this.fm.Xf())),\n        i.rightPriceScale.visible &&\n          null === this.pm &&\n          ((this.pm = new As('right', i, s, n, e)),\n          this.Mm.appendChild(this.pm.Xf()));\n    }\n  }\n  const Fs =\n    !!hs &&\n    !!navigator.userAgentData &&\n    navigator.userAgentData.brands.some((t) => t.brand.includes('Chromium')) &&\n    !!hs &&\n    (navigator?.userAgentData?.platform\n      ? 'Windows' === navigator.userAgentData.platform\n      : navigator.userAgent.toLowerCase().indexOf('win') >= 0);\n  class Hs {\n    constructor(t, i, s) {\n      var n;\n      (this.Am = []),\n        (this.zm = []),\n        (this.Om = 0),\n        (this.sl = 0),\n        (this.Mo = 0),\n        (this.Lm = 0),\n        (this.Nm = 0),\n        (this.Wm = null),\n        (this.Fm = !1),\n        (this.xv = new o()),\n        (this.Sv = new o()),\n        (this.Ku = new o()),\n        (this.Hm = null),\n        (this.Um = null),\n        (this.Rp = t),\n        (this.Ps = i),\n        (this.o_ = s),\n        (this.yp = document.createElement('div')),\n        this.yp.classList.add('tv-lightweight-charts'),\n        (this.yp.style.overflow = 'hidden'),\n        (this.yp.style.direction = 'ltr'),\n        (this.yp.style.width = '100%'),\n        (this.yp.style.height = '100%'),\n        ((n = this.yp).style.userSelect = 'none'),\n        (n.style.webkitUserSelect = 'none'),\n        (n.style.msUserSelect = 'none'),\n        (n.style.MozUserSelect = 'none'),\n        (n.style.webkitTapHighlightColor = 'transparent'),\n        (this.$m = document.createElement('table')),\n        this.$m.setAttribute('cellspacing', '0'),\n        this.yp.appendChild(this.$m),\n        (this.jm = this.qm.bind(this)),\n        Us(this.Ps) && this.Ym(!0),\n        (this.ts = new Ii(this.Zu.bind(this), this.Ps, s)),\n        this.Qt().uc().i(this.Km.bind(this), this),\n        (this.Xm = new Ws(this, this.o_)),\n        this.$m.appendChild(this.Xm.Xf());\n      const e = i.autoSize && this.Zm();\n      let r = this.Ps.width,\n        h = this.Ps.height;\n      if (e || 0 === r || 0 === h) {\n        const i = t.getBoundingClientRect();\n        (r = r || i.width), (h = h || i.height);\n      }\n      this.Gm(r, h),\n        this.Jm(),\n        t.appendChild(this.yp),\n        this.Qm(),\n        this.ts.It().Vu().i(this.ts.Bh.bind(this.ts), this),\n        this.ts.Eo().i(this.ts.Bh.bind(this.ts), this);\n    }\n    Qt() {\n      return this.ts;\n    }\n    N() {\n      return this.Ps;\n    }\n    Uf() {\n      return this.Am;\n    }\n    tw() {\n      return this.Xm;\n    }\n    m() {\n      this.Ym(!1),\n        0 !== this.Om && window.cancelAnimationFrame(this.Om),\n        this.ts.uc().u(this),\n        this.ts.It().Vu().u(this),\n        this.ts.Eo().u(this),\n        this.ts.m();\n      for (const t of this.Am)\n        this.$m.removeChild(t.Xf()), t.Kv().u(this), t.Xv().u(this), t.m();\n      this.Am = [];\n      for (const t of this.zm) this.iw(t);\n      (this.zm = []),\n        a(this.Xm).m(),\n        null !== this.yp.parentElement &&\n          this.yp.parentElement.removeChild(this.yp),\n        this.Ku.m(),\n        this.xv.m(),\n        this.Sv.m(),\n        this.sw();\n    }\n    Gm(t, i, s = !1) {\n      if (this.sl === i && this.Mo === t) return;\n      const n = (function (t) {\n        const i = Math.floor(t.width),\n          s = Math.floor(t.height);\n        return Qi({ width: i - (i % 2), height: s - (s % 2) });\n      })(Qi({ width: t, height: i }));\n      (this.sl = n.height), (this.Mo = n.width);\n      const e = this.sl + 'px',\n        r = this.Mo + 'px';\n      (a(this.yp).style.height = e),\n        (a(this.yp).style.width = r),\n        (this.$m.style.height = e),\n        (this.$m.style.width = r),\n        s ? this.nw(Y.gn(), performance.now()) : this.ts.Bh();\n    }\n    av(t) {\n      void 0 === t && (t = Y.gn());\n      for (let i = 0; i < this.Am.length; i++) this.Am[i].av(t.en(i).tn);\n      this.Ps.timeScale.visible && this.Xm.av(t.nn());\n    }\n    hr(t) {\n      const i = Us(this.Ps);\n      this.ts.hr(t);\n      const s = Us(this.Ps);\n      s !== i && this.Ym(s),\n        t.layout?.panes && this.ew(),\n        this.Qm(),\n        this.rw(t);\n    }\n    Kv() {\n      return this.xv;\n    }\n    Xv() {\n      return this.Sv;\n    }\n    uc() {\n      return this.Ku;\n    }\n    hw() {\n      null !== this.Wm &&\n        (this.nw(this.Wm, performance.now()), (this.Wm = null));\n      const t = this.aw(null),\n        i = document.createElement('canvas');\n      (i.width = t.width), (i.height = t.height);\n      const s = a(i.getContext('2d'));\n      return this.aw(s), i;\n    }\n    lw(t) {\n      if ('left' === t && !this.ow()) return 0;\n      if ('right' === t && !this._w()) return 0;\n      if (0 === this.Am.length) return 0;\n      return a('left' === t ? this.Am[0].sm() : this.Am[0].nm()).hv();\n    }\n    uw() {\n      return this.Ps.autoSize && null !== this.Hm;\n    }\n    tp() {\n      return this.yp;\n    }\n    cw(t) {\n      (this.Um = t),\n        this.Um\n          ? this.tp().style.setProperty('cursor', t)\n          : this.tp().style.removeProperty('cursor');\n    }\n    dw() {\n      return this.Um;\n    }\n    fw(t) {\n      return h(this.Am[t]).Zf();\n    }\n    ew() {\n      this.zm.forEach((t) => {\n        t.yt();\n      });\n    }\n    rw(t) {\n      (void 0 !== t.autoSize ||\n        !this.Hm ||\n        (void 0 === t.width && void 0 === t.height)) &&\n        (t.autoSize && !this.Hm && this.Zm(),\n        !1 === t.autoSize && null !== this.Hm && this.sw(),\n        t.autoSize ||\n          (void 0 === t.width && void 0 === t.height) ||\n          this.Gm(t.width || this.Mo, t.height || this.sl));\n    }\n    aw(t) {\n      let i = 0,\n        s = 0;\n      const n = this.Am[0],\n        e = (i, s) => {\n          let n = 0;\n          for (let e = 0; e < this.Am.length; e++) {\n            const r = this.Am[e],\n              h = a('left' === i ? r.sm() : r.nm()),\n              l = h.Gf();\n            if (\n              (null !== t && h.Jf(t, s, n),\n              (n += l.height),\n              e < this.Am.length - 1)\n            ) {\n              const i = this.zm[e],\n                r = i.Gf();\n              null !== t && i.Jf(t, s, n), (n += r.height);\n            }\n          }\n        };\n      if (this.ow()) {\n        e('left', 0);\n        i += a(n.sm()).Gf().width;\n      }\n      for (let n = 0; n < this.Am.length; n++) {\n        const e = this.Am[n],\n          r = e.Gf();\n        if (\n          (null !== t && e.Jf(t, i, s), (s += r.height), n < this.Am.length - 1)\n        ) {\n          const e = this.zm[n],\n            r = e.Gf();\n          null !== t && e.Jf(t, i, s), (s += r.height);\n        }\n      }\n      if (((i += n.Gf().width), this._w())) {\n        e('right', i);\n        i += a(n.nm()).Gf().width;\n      }\n      const r = (i, s, n) => {\n        a('left' === i ? this.Xm.Sm() : this.Xm.Cm()).Jf(a(t), s, n);\n      };\n      if (this.Ps.timeScale.visible) {\n        const i = this.Xm.Gf();\n        if (null !== t) {\n          let e = 0;\n          this.ow() && (r('left', e, s), (e = a(n.sm()).Gf().width)),\n            this.Xm.Jf(t, e, s),\n            (e += i.width),\n            this._w() && r('right', e, s);\n        }\n        s += i.height;\n      }\n      return Qi({ width: i, height: s });\n    }\n    pw() {\n      let t = 0,\n        i = 0,\n        s = 0;\n      for (const n of this.Am)\n        this.ow() &&\n          (i = Math.max(\n            i,\n            a(n.sm()).sv(),\n            this.Ps.leftPriceScale.minimumWidth,\n          )),\n          this._w() &&\n            (s = Math.max(\n              s,\n              a(n.nm()).sv(),\n              this.Ps.rightPriceScale.minimumWidth,\n            )),\n          (t += n.Vo());\n      (i = os(i)), (s = os(s));\n      const n = this.Mo,\n        e = this.sl,\n        r = Math.max(n - i - s, 0),\n        h = 1 * this.zm.length,\n        l = this.Ps.timeScale.visible;\n      let o = l ? Math.max(this.Xm.km(), this.Ps.timeScale.minimumHeight) : 0;\n      var _;\n      o = (_ = o) + (_ % 2);\n      const u = h + o,\n        c = e < u ? 0 : e - u,\n        d = c / t;\n      let f = 0;\n      const p = window.devicePixelRatio || 1;\n      for (let t = 0; t < this.Am.length; ++t) {\n        const n = this.Am[t];\n        n.zv(this.ts.$s()[t]);\n        let e = 0,\n          h = 0;\n        (h =\n          t === this.Am.length - 1\n            ? Math.ceil((c - f) * p) / p\n            : Math.round(n.Vo() * d * p) / p),\n          (e = Math.max(h, 2)),\n          (f += e),\n          n.rv(Qi({ width: r, height: e })),\n          this.ow() && n.Gv(i, 'left'),\n          this._w() && n.Gv(s, 'right'),\n          n.hp() && this.ts.cc(n.hp(), e);\n      }\n      this.Xm.ym(Qi({ width: l ? r : 0, height: o }), l ? i : 0, l ? s : 0),\n        this.ts.Io(r),\n        this.Lm !== i && (this.Lm = i),\n        this.Nm !== s && (this.Nm = s);\n    }\n    Ym(t) {\n      t\n        ? this.yp.addEventListener('wheel', this.jm, { passive: !1 })\n        : this.yp.removeEventListener('wheel', this.jm);\n    }\n    mw(t) {\n      switch (t.deltaMode) {\n        case t.DOM_DELTA_PAGE:\n          return 120;\n        case t.DOM_DELTA_LINE:\n          return 32;\n      }\n      return Fs ? 1 / window.devicePixelRatio : 1;\n    }\n    qm(t) {\n      if (\n        !(\n          (0 !== t.deltaX && this.Ps.handleScroll.mouseWheel) ||\n          (0 !== t.deltaY && this.Ps.handleScale.mouseWheel)\n        )\n      )\n        return;\n      const i = this.mw(t),\n        s = (i * t.deltaX) / 100,\n        n = (-i * t.deltaY) / 100;\n      if (\n        (t.cancelable && t.preventDefault(),\n        0 !== n && this.Ps.handleScale.mouseWheel)\n      ) {\n        const i = Math.sign(n) * Math.min(1, Math.abs(n)),\n          s = t.clientX - this.yp.getBoundingClientRect().left;\n        this.Qt().Mc(s, i);\n      }\n      0 !== s && this.Ps.handleScroll.mouseWheel && this.Qt().bc(-80 * s);\n    }\n    nw(t, i) {\n      const s = t.nn();\n      3 === s && this.ww(),\n        (3 !== s && 2 !== s) ||\n          (this.gw(t),\n          this.Mw(t, i),\n          this.Xm.yt(),\n          this.Am.forEach((t) => {\n            t.Lv();\n          }),\n          3 === this.Wm?.nn() &&\n            (this.Wm.vn(t),\n            this.ww(),\n            this.gw(this.Wm),\n            this.Mw(this.Wm, i),\n            (t = this.Wm),\n            (this.Wm = null))),\n        this.av(t);\n    }\n    Mw(t, i) {\n      for (const s of t.pn()) this.mn(s, i);\n    }\n    gw(t) {\n      const i = this.ts.$s();\n      for (let s = 0; s < i.length; s++) t.en(s).sn && i[s].Go();\n    }\n    mn(t, i) {\n      const s = this.ts.It();\n      switch (t.an) {\n        case 0:\n          s.Iu();\n          break;\n        case 1:\n          s.Au(t.Ft);\n          break;\n        case 2:\n          s.dn(t.Ft);\n          break;\n        case 3:\n          s.fn(t.Ft);\n          break;\n        case 4:\n          s.bu();\n          break;\n        case 5:\n          t.Ft.Tu(i) || s.fn(t.Ft.Ru(i));\n      }\n    }\n    Zu(t) {\n      null !== this.Wm ? this.Wm.vn(t) : (this.Wm = t),\n        this.Fm ||\n          ((this.Fm = !0),\n          (this.Om = window.requestAnimationFrame((t) => {\n            if (((this.Fm = !1), (this.Om = 0), null !== this.Wm)) {\n              const i = this.Wm;\n              (this.Wm = null), this.nw(i, t);\n              for (const s of i.pn())\n                if (5 === s.an && !s.Ft.Tu(t)) {\n                  this.Qt()._n(s.Ft);\n                  break;\n                }\n            }\n          })));\n    }\n    ww() {\n      this.Jm();\n    }\n    iw(t) {\n      this.$m.removeChild(t.Xf()), t.m();\n    }\n    Jm() {\n      const t = this.ts.$s(),\n        i = t.length,\n        s = this.Am.length;\n      for (let t = i; t < s; t++) {\n        const t = h(this.Am.pop());\n        this.$m.removeChild(t.Xf()), t.Kv().u(this), t.Xv().u(this), t.m();\n        const i = this.zm.pop();\n        void 0 !== i && this.iw(i);\n      }\n      for (let n = s; n < i; n++) {\n        const i = new Is(this, t[n]);\n        if (\n          (i.Kv().i(this.bw.bind(this, i), this),\n          i.Xv().i(this.xw.bind(this, i), this),\n          this.Am.push(i),\n          n > 0)\n        ) {\n          const t = new ms(this, n - 1, n);\n          this.zm.push(t), this.$m.insertBefore(t.Xf(), this.Xm.Xf());\n        }\n        this.$m.insertBefore(i.Xf(), this.Xm.Xf());\n      }\n      for (let s = 0; s < i; s++) {\n        const i = t[s],\n          n = this.Am[s];\n        n.hp() !== i ? n.zv(i) : n.Av();\n      }\n      this.Qm(), this.pw();\n    }\n    Sw(t, i, s, n) {\n      const e = new Map();\n      if (null !== t) {\n        this.ts.Ys().forEach((i) => {\n          const s = i.Xs().Wr(t);\n          null !== s && e.set(i, s);\n        });\n      }\n      let r;\n      if (null !== t) {\n        const i = this.ts.It().ss(t)?.originalTime;\n        void 0 !== i && (r = i);\n      }\n      const h = this.Qt().hc(),\n        a = null !== h && h.n_ instanceof Ut ? h.n_ : void 0,\n        l = null !== h && void 0 !== h.e_ ? h.e_.Kn : void 0,\n        o = this.Cw(n);\n      return {\n        Pw: r,\n        Re: t ?? void 0,\n        yw: i ?? void 0,\n        kw: -1 !== o ? o : void 0,\n        Tw: a,\n        Rw: e,\n        Dw: l,\n        Ew: s ?? void 0,\n      };\n    }\n    Cw(t) {\n      let i = -1;\n      if (t) i = this.Am.indexOf(t);\n      else {\n        const t = this.Qt()._c().Us();\n        null !== t && (i = this.Qt().$s().indexOf(t));\n      }\n      return i;\n    }\n    bw(t, i, s, n) {\n      this.xv.p(() => this.Sw(i, s, n, t));\n    }\n    xw(t, i, s, n) {\n      this.Sv.p(() => this.Sw(i, s, n, t));\n    }\n    Km(t, i, s) {\n      this.cw(this.Qt().hc()?.h_ ?? null), this.Ku.p(() => this.Sw(t, i, s));\n    }\n    Qm() {\n      const t = this.Ps.timeScale.visible ? '' : 'none';\n      this.Xm.Xf().style.display = t;\n    }\n    ow() {\n      return this.Am[0].hp().Fo().N().visible;\n    }\n    _w() {\n      return this.Am[0].hp().Ho().N().visible;\n    }\n    Zm() {\n      return (\n        'ResizeObserver' in window &&\n        ((this.Hm = new ResizeObserver((t) => {\n          const i = t[t.length - 1];\n          i && this.Gm(i.contentRect.width, i.contentRect.height);\n        })),\n        this.Hm.observe(this.Rp, { box: 'border-box' }),\n        !0)\n      );\n    }\n    sw() {\n      null !== this.Hm && this.Hm.disconnect(), (this.Hm = null);\n    }\n  }\n  function Us(t) {\n    return Boolean(t.handleScroll.mouseWheel || t.handleScale.mouseWheel);\n  }\n  function $s(t) {\n    return void 0 === t.open && void 0 === t.value;\n  }\n  function js(t) {\n    return (\n      (function (t) {\n        return void 0 !== t.open;\n      })(t) ||\n      (function (t) {\n        return void 0 !== t.value;\n      })(t)\n    );\n  }\n  function qs(t, i, s, n) {\n    const e = s.value,\n      r = { Re: i, wt: t, Ft: [e, e, e, e], Pw: n };\n    return void 0 !== s.color && (r.R = s.color), r;\n  }\n  function Ys(t, i, s, n) {\n    const e = s.value,\n      r = { Re: i, wt: t, Ft: [e, e, e, e], Pw: n };\n    return (\n      void 0 !== s.lineColor && (r.vt = s.lineColor),\n      void 0 !== s.topColor && (r.mr = s.topColor),\n      void 0 !== s.bottomColor && (r.wr = s.bottomColor),\n      r\n    );\n  }\n  function Ks(t, i, s, n) {\n    const e = s.value,\n      r = { Re: i, wt: t, Ft: [e, e, e, e], Pw: n };\n    return (\n      void 0 !== s.topLineColor && (r.gr = s.topLineColor),\n      void 0 !== s.bottomLineColor && (r.Mr = s.bottomLineColor),\n      void 0 !== s.topFillColor1 && (r.br = s.topFillColor1),\n      void 0 !== s.topFillColor2 && (r.Sr = s.topFillColor2),\n      void 0 !== s.bottomFillColor1 && (r.Cr = s.bottomFillColor1),\n      void 0 !== s.bottomFillColor2 && (r.Pr = s.bottomFillColor2),\n      r\n    );\n  }\n  function Xs(t, i, s, n) {\n    const e = { Re: i, wt: t, Ft: [s.open, s.high, s.low, s.close], Pw: n };\n    return void 0 !== s.color && (e.R = s.color), e;\n  }\n  function Zs(t, i, s, n) {\n    const e = { Re: i, wt: t, Ft: [s.open, s.high, s.low, s.close], Pw: n };\n    return (\n      void 0 !== s.color && (e.R = s.color),\n      void 0 !== s.borderColor && (e.Ht = s.borderColor),\n      void 0 !== s.wickColor && (e.vr = s.wickColor),\n      e\n    );\n  }\n  function Gs(t, i, s, n, e) {\n    const r = h(e)(s),\n      a = Math.max(...r),\n      l = Math.min(...r),\n      o = r[r.length - 1],\n      _ = [o, a, l, o],\n      { time: u, color: c, ...d } = s;\n    return { Re: i, wt: t, Ft: _, Pw: n, se: d, R: c };\n  }\n  function Js(t) {\n    return void 0 !== t.Ft;\n  }\n  function Qs(t, i) {\n    return void 0 !== i.customValues && (t.Vw = i.customValues), t;\n  }\n  function tn(t) {\n    return (i, s, n, e, r, h) =>\n      (function (t, i) {\n        return i ? i(t) : $s(t);\n      })(n, h)\n        ? Qs({ wt: i, Re: s, Pw: e }, n)\n        : Qs(t(i, s, n, e, r), n);\n  }\n  function sn(t) {\n    return {\n      Candlestick: tn(Zs),\n      Bar: tn(Xs),\n      Area: tn(Ys),\n      Baseline: tn(Ks),\n      Histogram: tn(qs),\n      Line: tn(qs),\n      Custom: tn(Gs),\n    }[t];\n  }\n  function nn(t) {\n    return { Re: 0, Bw: new Map(), Hh: t };\n  }\n  function en(t, i) {\n    if (void 0 !== t && 0 !== t.length)\n      return { Iw: i.key(t[0].wt), Aw: i.key(t[t.length - 1].wt) };\n  }\n  function rn(t) {\n    let i;\n    return (\n      t.forEach((t) => {\n        void 0 === i && (i = t.Pw);\n      }),\n      h(i)\n    );\n  }\n  class hn {\n    constructor(t) {\n      (this.zw = new Map()),\n        (this.Ow = new Map()),\n        (this.Lw = new Map()),\n        (this.Nw = []),\n        (this.o_ = t);\n    }\n    m() {\n      this.zw.clear(), this.Ow.clear(), this.Lw.clear(), (this.Nw = []);\n    }\n    Ww(t, i) {\n      let s = 0 !== this.zw.size,\n        n = !1;\n      const e = this.Ow.get(t);\n      if (void 0 !== e)\n        if (1 === this.Ow.size) (s = !1), (n = !0), this.zw.clear();\n        else for (const i of this.Nw) i.pointData.Bw.delete(t) && (n = !0);\n      let r = [];\n      if (0 !== i.length) {\n        const s = i.map((t) => t.time),\n          e = this.o_.createConverterToInternalObj(i),\n          h = sn(t.Rr()),\n          a = t.da(),\n          l = t.pa();\n        r = i.map((i, r) => {\n          const o = e(i.time),\n            _ = this.o_.key(o);\n          let u = this.zw.get(_);\n          void 0 === u && ((u = nn(o)), this.zw.set(_, u), (n = !0));\n          const c = h(o, u.Re, i, s[r], a, l);\n          return u.Bw.set(t, c), c;\n        });\n      }\n      s && this.Fw(), this.Hw(t, r);\n      let h = -1;\n      if (n) {\n        const t = [];\n        this.zw.forEach((i) => {\n          t.push({\n            timeWeight: 0,\n            time: i.Hh,\n            pointData: i,\n            originalTime: rn(i.Bw),\n          });\n        }),\n          t.sort((t, i) => this.o_.key(t.time) - this.o_.key(i.time)),\n          (h = this.Uw(t));\n      }\n      return this.$w(\n        t,\n        h,\n        (function (t, i, s) {\n          const n = en(t, s),\n            e = en(i, s);\n          if (void 0 !== n && void 0 !== e)\n            return { jw: !1, zh: n.Aw >= e.Aw && n.Iw >= e.Iw };\n        })(this.Ow.get(t), e, this.o_),\n      );\n    }\n    Ic(t) {\n      return this.Ww(t, []);\n    }\n    qw(t, i, s) {\n      const n = i;\n      !(function (t) {\n        void 0 === t.Pw && (t.Pw = t.time);\n      })(n),\n        this.o_.preprocessData(i);\n      const e = this.o_.createConverterToInternalObj([i])(i.time),\n        r = this.Lw.get(t);\n      if (!s && void 0 !== r && this.o_.key(e) < this.o_.key(r))\n        throw new Error(\n          `Cannot update oldest data, last time=${r}, new time=${e}`,\n        );\n      let h = this.zw.get(this.o_.key(e));\n      if (s && void 0 === h)\n        throw new Error(\n          'Cannot update non-existing data point when historicalUpdate is true',\n        );\n      const a = void 0 === h;\n      void 0 === h && ((h = nn(e)), this.zw.set(this.o_.key(e), h));\n      const l = sn(t.Rr()),\n        o = t.da(),\n        _ = t.pa(),\n        u = l(e, h.Re, i, n.Pw, o, _);\n      h.Bw.set(t, u), s ? this.Yw(t, u, h.Re) : this.Kw(t, u);\n      const c = { zh: Js(u), jw: s };\n      if (!a) return this.$w(t, -1, c);\n      const d = {\n          timeWeight: 0,\n          time: h.Hh,\n          pointData: h,\n          originalTime: rn(h.Bw),\n        },\n        f = xt(this.Nw, this.o_.key(d.time), (t, i) => this.o_.key(t.time) < i);\n      this.Nw.splice(f, 0, d);\n      for (let t = f; t < this.Nw.length; ++t) an(this.Nw[t].pointData, t);\n      return this.o_.fillWeightsForPoints(this.Nw, f), this.$w(t, f, c);\n    }\n    Kw(t, i) {\n      let s = this.Ow.get(t);\n      void 0 === s && ((s = []), this.Ow.set(t, s));\n      const n = 0 !== s.length ? s[s.length - 1] : null;\n      null === n || this.o_.key(i.wt) > this.o_.key(n.wt)\n        ? Js(i) && s.push(i)\n        : Js(i)\n        ? (s[s.length - 1] = i)\n        : s.splice(-1, 1),\n        this.Lw.set(t, i.wt);\n    }\n    Yw(t, i, s) {\n      const n = this.Ow.get(t);\n      if (void 0 === n) return;\n      const e = xt(n, s, (t, i) => t.Re < i);\n      Js(i) ? (n[e] = i) : n.splice(e, 1);\n    }\n    Hw(t, i) {\n      0 !== i.length\n        ? (this.Ow.set(t, i.filter(Js)), this.Lw.set(t, i[i.length - 1].wt))\n        : (this.Ow.delete(t), this.Lw.delete(t));\n    }\n    Fw() {\n      for (const t of this.Nw)\n        0 === t.pointData.Bw.size && this.zw.delete(this.o_.key(t.time));\n    }\n    Uw(t) {\n      let i = -1;\n      for (let s = 0; s < this.Nw.length && s < t.length; ++s) {\n        const n = this.Nw[s],\n          e = t[s];\n        if (this.o_.key(n.time) !== this.o_.key(e.time)) {\n          i = s;\n          break;\n        }\n        (e.timeWeight = n.timeWeight), an(e.pointData, s);\n      }\n      if (\n        (-1 === i &&\n          this.Nw.length !== t.length &&\n          (i = Math.min(this.Nw.length, t.length)),\n        -1 === i)\n      )\n        return -1;\n      for (let s = i; s < t.length; ++s) an(t[s].pointData, s);\n      return this.o_.fillWeightsForPoints(t, i), (this.Nw = t), i;\n    }\n    Xw() {\n      if (0 === this.Ow.size) return null;\n      let t = 0;\n      return (\n        this.Ow.forEach((i) => {\n          0 !== i.length && (t = Math.max(t, i[i.length - 1].Re));\n        }),\n        t\n      );\n    }\n    $w(t, i, s) {\n      const n = { Lo: new Map(), It: { ou: this.Xw() } };\n      if (-1 !== i)\n        this.Ow.forEach((i, e) => {\n          n.Lo.set(e, { se: i, Zw: e === t ? s : void 0 });\n        }),\n          this.Ow.has(t) || n.Lo.set(t, { se: [], Zw: s }),\n          (n.It.Gw = this.Nw),\n          (n.It.Jw = i);\n      else {\n        const i = this.Ow.get(t);\n        n.Lo.set(t, { se: i || [], Zw: s });\n      }\n      return n;\n    }\n  }\n  function an(t, i) {\n    (t.Re = i),\n      t.Bw.forEach((t) => {\n        t.Re = i;\n      });\n  }\n  function ln(t, i) {\n    return t.wt < i;\n  }\n  function on(t, i) {\n    return i < t.wt;\n  }\n  function _n(t, i, s) {\n    const n = i.Uh(),\n      e = i.bi(),\n      r = xt(t, n, ln),\n      h = St(t, e, on);\n    if (!s) return { from: r, to: h };\n    let a = r,\n      l = h;\n    return (\n      r > 0 && r < t.length && t[r].wt >= n && (a = r - 1),\n      h > 0 && h < t.length && t[h - 1].wt <= e && (l = h + 1),\n      { from: a, to: l }\n    );\n  }\n  class un {\n    constructor(t, i, s) {\n      (this.Qw = !0),\n        (this.tg = !0),\n        (this.ig = !0),\n        (this.sg = []),\n        (this.ng = null),\n        (this.Jn = t),\n        (this.Qn = i),\n        (this.eg = s);\n    }\n    yt(t) {\n      (this.Qw = !0),\n        'data' === t && (this.tg = !0),\n        'options' === t && (this.ig = !0);\n    }\n    Tt() {\n      return this.Jn.Et()\n        ? (this.rg(), null === this.ng ? null : this.hg)\n        : null;\n    }\n    ag() {\n      this.sg = this.sg.map((t) => ({ ...t, ...this.Jn.Rh().Dr(t.wt) }));\n    }\n    lg() {\n      this.ng = null;\n    }\n    rg() {\n      this.tg && (this.og(), (this.tg = !1)),\n        this.ig && (this.ag(), (this.ig = !1)),\n        this.Qw && (this._g(), (this.Qw = !1));\n    }\n    _g() {\n      const t = this.Jn.Wt(),\n        i = this.Qn.It();\n      if ((this.lg(), i.Ki() || t.Ki())) return;\n      const s = i.Pe();\n      if (null === s) return;\n      if (0 === this.Jn.Xs().zr()) return;\n      const n = this.Jn.zt();\n      null !== n &&\n        ((this.ng = _n(this.sg, s, this.eg)), this.ug(t, i, n.Ft), this.cg());\n    }\n  }\n  class cn {\n    constructor(t, i) {\n      (this.dg = t), (this.qi = i);\n    }\n    nt(t, i, s) {\n      this.dg.draw(t, this.qi, i, s);\n    }\n  }\n  class dn extends un {\n    constructor(t, i, s) {\n      super(t, i, !1),\n        (this.sh = s),\n        (this.hg = new cn(this.sh.renderer(), (i) => {\n          const s = t.zt();\n          return null === s ? null : t.Wt().Nt(i, s.Ft);\n        }));\n    }\n    fa(t) {\n      return this.sh.priceValueBuilder(t);\n    }\n    va(t) {\n      return this.sh.isWhitespace(t);\n    }\n    og() {\n      const t = this.Jn.Rh();\n      this.sg = this.Jn.Xs()\n        .Hr()\n        .map((i) => ({ wt: i.Re, _t: NaN, ...t.Dr(i.Re), fg: i.se }));\n    }\n    ug(t, i) {\n      i._u(this.sg, m(this.ng));\n    }\n    cg() {\n      this.sh.update(\n        {\n          bars: this.sg.map(fn),\n          barSpacing: this.Qn.It().vu(),\n          visibleRange: this.ng,\n        },\n        this.Jn.N(),\n      );\n    }\n  }\n  function fn(t) {\n    return { x: t._t, time: t.wt, originalData: t.fg, barColor: t.cr };\n  }\n  const pn = { color: '#2196f3' },\n    vn = (t, i, s) => {\n      const n = l(s);\n      return new dn(t, i, n);\n    };\n  function mn(t) {\n    const i = { value: t.Ft[3], time: t.Pw };\n    return void 0 !== t.Vw && (i.customValues = t.Vw), i;\n  }\n  function wn(t) {\n    const i = mn(t);\n    return void 0 !== t.R && (i.color = t.R), i;\n  }\n  function gn(t) {\n    const i = mn(t);\n    return (\n      void 0 !== t.vt && (i.lineColor = t.vt),\n      void 0 !== t.mr && (i.topColor = t.mr),\n      void 0 !== t.wr && (i.bottomColor = t.wr),\n      i\n    );\n  }\n  function Mn(t) {\n    const i = mn(t);\n    return (\n      void 0 !== t.gr && (i.topLineColor = t.gr),\n      void 0 !== t.Mr && (i.bottomLineColor = t.Mr),\n      void 0 !== t.br && (i.topFillColor1 = t.br),\n      void 0 !== t.Sr && (i.topFillColor2 = t.Sr),\n      void 0 !== t.Cr && (i.bottomFillColor1 = t.Cr),\n      void 0 !== t.Pr && (i.bottomFillColor2 = t.Pr),\n      i\n    );\n  }\n  function bn(t) {\n    const i = {\n      open: t.Ft[0],\n      high: t.Ft[1],\n      low: t.Ft[2],\n      close: t.Ft[3],\n      time: t.Pw,\n    };\n    return void 0 !== t.Vw && (i.customValues = t.Vw), i;\n  }\n  function xn(t) {\n    const i = bn(t);\n    return void 0 !== t.R && (i.color = t.R), i;\n  }\n  function Sn(t) {\n    const i = bn(t),\n      { R: s, Ht: n, vr: e } = t;\n    return (\n      void 0 !== s && (i.color = s),\n      void 0 !== n && (i.borderColor = n),\n      void 0 !== e && (i.wickColor = e),\n      i\n    );\n  }\n  function Cn(t) {\n    return {\n      Area: gn,\n      Line: wn,\n      Baseline: Mn,\n      Histogram: wn,\n      Bar: xn,\n      Candlestick: Sn,\n      Custom: Pn,\n    }[t];\n  }\n  function Pn(t) {\n    const i = t.Pw;\n    return { ...t.se, time: i };\n  }\n  const yn = {\n      vertLine: {\n        color: '#9598A1',\n        width: 1,\n        style: 3,\n        visible: !0,\n        labelVisible: !0,\n        labelBackgroundColor: '#131722',\n      },\n      horzLine: {\n        color: '#9598A1',\n        width: 1,\n        style: 3,\n        visible: !0,\n        labelVisible: !0,\n        labelBackgroundColor: '#131722',\n      },\n      mode: 1,\n    },\n    kn = {\n      vertLines: { color: '#D6DCDE', style: 0, visible: !0 },\n      horzLines: { color: '#D6DCDE', style: 0, visible: !0 },\n    },\n    Tn = {\n      background: { type: 'solid', color: '#FFFFFF' },\n      textColor: '#191919',\n      fontSize: 12,\n      fontFamily: w,\n      panes: {\n        enableResize: !0,\n        separatorColor: '#E0E3EB',\n        separatorHoverColor: 'rgba(178, 181, 189, 0.2)',\n      },\n      attributionLogo: !0,\n      colorSpace: 'srgb',\n      colorParsers: [],\n    },\n    Rn = {\n      autoScale: !0,\n      mode: 0,\n      invertScale: !1,\n      alignLabels: !0,\n      borderVisible: !0,\n      borderColor: '#2B2B43',\n      entireTextOnly: !1,\n      visible: !1,\n      ticksVisible: !1,\n      scaleMargins: { bottom: 0.1, top: 0.2 },\n      minimumWidth: 0,\n      ensureEdgeTickMarksVisible: !1,\n    },\n    Dn = {\n      rightOffset: 0,\n      barSpacing: 6,\n      minBarSpacing: 0.5,\n      maxBarSpacing: 0,\n      fixLeftEdge: !1,\n      fixRightEdge: !1,\n      lockVisibleTimeRangeOnResize: !1,\n      rightBarStaysOnScroll: !1,\n      borderVisible: !0,\n      borderColor: '#2B2B43',\n      visible: !0,\n      timeVisible: !1,\n      secondsVisible: !0,\n      shiftVisibleRangeOnNewBar: !0,\n      allowShiftVisibleRangeOnWhitespaceReplacement: !1,\n      ticksVisible: !1,\n      uniformDistribution: !1,\n      minimumHeight: 0,\n      allowBoldLabels: !0,\n      ignoreWhitespaceIndices: !1,\n    };\n  function En() {\n    return {\n      addDefaultPane: !0,\n      width: 0,\n      height: 0,\n      autoSize: !1,\n      layout: Tn,\n      crosshair: yn,\n      grid: kn,\n      overlayPriceScales: { ...Rn },\n      leftPriceScale: { ...Rn, visible: !1 },\n      rightPriceScale: { ...Rn, visible: !0 },\n      timeScale: Dn,\n      localization: {\n        locale: hs ? navigator.language : '',\n        dateFormat: \"dd MMM 'yy\",\n      },\n      handleScroll: {\n        mouseWheel: !0,\n        pressedMouseMove: !0,\n        horzTouchDrag: !0,\n        vertTouchDrag: !0,\n      },\n      handleScale: {\n        axisPressedMouseMove: { time: !0, price: !0 },\n        axisDoubleClickReset: { time: !0, price: !0 },\n        mouseWheel: !0,\n        pinch: !0,\n      },\n      kineticScroll: { mouse: !1, touch: !0 },\n      trackingMode: { exitMode: 1 },\n    };\n  }\n  class Vn {\n    constructor(t, i, s) {\n      (this.Ff = t), (this.pg = i), (this.vg = s ?? 0);\n    }\n    applyOptions(t) {\n      this.Ff.Qt().lc(this.pg, t, this.vg);\n    }\n    options() {\n      return this.qi().N();\n    }\n    width() {\n      return q(this.pg) ? this.Ff.lw(this.pg) : 0;\n    }\n    setVisibleRange(t) {\n      this.setAutoScale(!1), this.qi().Fl(new dt(t.from, t.to));\n    }\n    getVisibleRange() {\n      const t = this.qi().Qe();\n      return null === t ? null : { from: t.$e(), to: t.je() };\n    }\n    setAutoScale(t) {\n      this.applyOptions({ autoScale: t });\n    }\n    qi() {\n      return a(this.Ff.Qt().oc(this.pg, this.vg)).Wt;\n    }\n  }\n  class Bn {\n    constructor(t, i, s, n) {\n      (this.Ff = t), (this.Pt = s), (this.mg = i), (this.wg = n);\n    }\n    getHeight() {\n      return this.Pt.$t();\n    }\n    setHeight(t) {\n      const i = this.Ff.Qt(),\n        s = i.Hc(this.Pt);\n      i.fc(s, t);\n    }\n    getStretchFactor() {\n      return this.Pt.Vo();\n    }\n    setStretchFactor(t) {\n      this.Pt.Bo(t), this.Ff.Qt().Bh();\n    }\n    paneIndex() {\n      return this.Ff.Qt().Hc(this.Pt);\n    }\n    moveTo(t) {\n      const i = this.paneIndex();\n      i !== t &&\n        (r(t >= 0 && t < this.Ff.Uf().length, 'Invalid pane index'),\n        this.Ff.Qt().mc(i, t));\n    }\n    getSeries() {\n      return this.Pt.Lo().map((t) => this.mg(t)) ?? [];\n    }\n    getHTMLElement() {\n      const t = this.Ff.Uf();\n      return t && 0 !== t.length && t[this.paneIndex()]\n        ? t[this.paneIndex()].Xf()\n        : null;\n    }\n    attachPrimitive(t) {\n      this.Pt.ua(t),\n        t.attached &&\n          t.attached({\n            chart: this.wg,\n            requestUpdate: () => this.Pt.Qt().Bh(),\n          });\n    }\n    detachPrimitive(t) {\n      this.Pt.ca(t);\n    }\n    priceScale(t) {\n      if (null === this.Pt.Do(t))\n        throw new Error(`Cannot find price scale with id: ${t}`);\n      return new Vn(this.Ff, t, this.paneIndex());\n    }\n    setPreserveEmptyPane(t) {\n      this.Pt.zo(t);\n    }\n    preserveEmptyPane() {\n      return this.Pt.Oo();\n    }\n    addCustomSeries(t, i = {}, s = 0) {\n      return this.wg.addCustomSeries(t, i, s);\n    }\n    addSeries(t, i = {}) {\n      return this.wg.addSeries(t, i, this.paneIndex());\n    }\n  }\n  const In = {\n    color: '#FF0000',\n    price: 0,\n    lineStyle: 2,\n    lineWidth: 1,\n    lineVisible: !0,\n    axisLabelVisible: !0,\n    title: '',\n    axisLabelColor: '',\n    axisLabelTextColor: '',\n  };\n  class An {\n    constructor(t) {\n      this.ir = t;\n    }\n    applyOptions(t) {\n      this.ir.hr(t);\n    }\n    options() {\n      return this.ir.N();\n    }\n    gg() {\n      return this.ir;\n    }\n  }\n  class zn {\n    constructor(t, i, s, n, e, r) {\n      (this.Mg = new o()),\n        (this.Jn = t),\n        (this.bg = i),\n        (this.xg = s),\n        (this.o_ = e),\n        (this.wg = n),\n        (this.Sg = r);\n    }\n    m() {\n      this.Mg.m();\n    }\n    priceFormatter() {\n      return this.Jn.ra();\n    }\n    priceToCoordinate(t) {\n      const i = this.Jn.zt();\n      return null === i ? null : this.Jn.Wt().Nt(t, i.Ft);\n    }\n    coordinateToPrice(t) {\n      const i = this.Jn.zt();\n      return null === i ? null : this.Jn.Wt().Ts(t, i.Ft);\n    }\n    barsInLogicalRange(t) {\n      if (null === t) return null;\n      const i = new yi(new Si(t.from, t.to)).y_(),\n        s = this.Jn.Xs();\n      if (s.Ki()) return null;\n      const n = s.Wr(i.Uh(), 1),\n        e = s.Wr(i.bi(), -1),\n        r = a(s.Or()),\n        h = a(s.Ks());\n      if (null !== n && null !== e && n.Re > e.Re)\n        return { barsBefore: t.from - r, barsAfter: h - t.to };\n      const l = {\n        barsBefore: null === n || n.Re === r ? t.from - r : n.Re - r,\n        barsAfter: null === e || e.Re === h ? h - t.to : h - e.Re,\n      };\n      return null !== n && null !== e && ((l.from = n.Pw), (l.to = e.Pw)), l;\n    }\n    setData(t) {\n      this.o_, this.Jn.Rr(), this.bg.Cg(this.Jn, t), this.Pg('full');\n    }\n    update(t, i = !1) {\n      this.Jn.Rr(), this.bg.yg(this.Jn, t, i), this.Pg('update');\n    }\n    dataByIndex(t, i) {\n      const s = this.Jn.Xs().Wr(t, i);\n      if (null === s) return null;\n      return Cn(this.seriesType())(s);\n    }\n    data() {\n      const t = Cn(this.seriesType());\n      return this.Jn.Xs()\n        .Hr()\n        .map((i) => t(i));\n    }\n    subscribeDataChanged(t) {\n      this.Mg.i(t);\n    }\n    unsubscribeDataChanged(t) {\n      this.Mg._(t);\n    }\n    applyOptions(t) {\n      this.Jn.hr(t);\n    }\n    options() {\n      return p(this.Jn.N());\n    }\n    priceScale() {\n      return this.xg.priceScale(this.Jn.Wt().wa(), this.getPane().paneIndex());\n    }\n    createPriceLine(t) {\n      const i = _(p(In), t),\n        s = this.Jn.Lh(i);\n      return new An(s);\n    }\n    removePriceLine(t) {\n      this.Jn.Nh(t.gg());\n    }\n    priceLines() {\n      return this.Jn.Wh().map((t) => new An(t));\n    }\n    seriesType() {\n      return this.Jn.Rr();\n    }\n    attachPrimitive(t) {\n      this.Jn.ua(t),\n        t.attached &&\n          t.attached({\n            chart: this.wg,\n            series: this,\n            requestUpdate: () => this.Jn.Qt().Bh(),\n            horzScaleBehavior: this.o_,\n          });\n    }\n    detachPrimitive(t) {\n      this.Jn.ca(t), t.detached && t.detached(), this.Jn.Qt().Bh();\n    }\n    getPane() {\n      const t = this.Jn,\n        i = a(this.Jn.Qt().Hn(t));\n      return this.Sg(i);\n    }\n    moveToPane(t) {\n      this.Jn.Qt().Lc(this.Jn, t);\n    }\n    seriesOrder() {\n      const t = this.Jn.Qt().Hn(this.Jn);\n      return null === t ? -1 : t.Lo().indexOf(this.Jn);\n    }\n    setSeriesOrder(t) {\n      const i = this.Jn.Qt().Hn(this.Jn);\n      null !== i && i.Qo(this.Jn, t);\n    }\n    Pg(t) {\n      this.Mg.v() && this.Mg.p(t);\n    }\n  }\n  class On {\n    constructor(t, i, s) {\n      (this.kg = new o()),\n        (this.z_ = new o()),\n        (this.wm = new o()),\n        (this.ts = t),\n        (this.uh = t.It()),\n        (this.Xm = i),\n        this.uh.Du().i(this.Tg.bind(this)),\n        this.uh.Eu().i(this.Rg.bind(this)),\n        this.Xm.Pm().i(this.Dg.bind(this)),\n        (this.o_ = s);\n    }\n    m() {\n      this.uh.Du().u(this),\n        this.uh.Eu().u(this),\n        this.Xm.Pm().u(this),\n        this.kg.m(),\n        this.z_.m(),\n        this.wm.m();\n    }\n    scrollPosition() {\n      return this.uh.wu();\n    }\n    scrollToPosition(t, i) {\n      i ? this.uh.ku(t, 1e3) : this.ts.fn(t);\n    }\n    scrollToRealTime() {\n      this.uh.yu();\n    }\n    getVisibleRange() {\n      const t = this.uh.su();\n      return null === t\n        ? null\n        : { from: t.from.originalTime, to: t.to.originalTime };\n    }\n    setVisibleRange(t) {\n      const i = {\n          from: this.o_.convertHorzItemToInternal(t.from),\n          to: this.o_.convertHorzItemToInternal(t.to),\n        },\n        s = this.uh.hu(i);\n      this.ts.zc(s);\n    }\n    getVisibleLogicalRange() {\n      const t = this.uh.iu();\n      return null === t ? null : { from: t.Uh(), to: t.bi() };\n    }\n    setVisibleLogicalRange(t) {\n      r(t.from <= t.to, 'The from index cannot be after the to index.'),\n        this.ts.zc(t);\n    }\n    resetTimeScale() {\n      this.ts.cn();\n    }\n    fitContent() {\n      this.ts.Iu();\n    }\n    logicalToCoordinate(t) {\n      const i = this.ts.It();\n      return i.Ki() ? null : i.jt(t);\n    }\n    coordinateToLogical(t) {\n      return this.uh.Ki() ? null : this.uh.uu(t);\n    }\n    timeToIndex(t, i) {\n      const s = this.o_.convertHorzItemToInternal(t);\n      return this.uh.J_(s, i);\n    }\n    timeToCoordinate(t) {\n      const i = this.timeToIndex(t, !1);\n      return null === i ? null : this.uh.jt(i);\n    }\n    coordinateToTime(t) {\n      const i = this.ts.It(),\n        s = i.uu(t),\n        n = i.ss(s);\n      return null === n ? null : n.originalTime;\n    }\n    width() {\n      return this.Xm.Zf().width;\n    }\n    height() {\n      return this.Xm.Zf().height;\n    }\n    subscribeVisibleTimeRangeChange(t) {\n      this.kg.i(t);\n    }\n    unsubscribeVisibleTimeRangeChange(t) {\n      this.kg._(t);\n    }\n    subscribeVisibleLogicalRangeChange(t) {\n      this.z_.i(t);\n    }\n    unsubscribeVisibleLogicalRangeChange(t) {\n      this.z_._(t);\n    }\n    subscribeSizeChange(t) {\n      this.wm.i(t);\n    }\n    unsubscribeSizeChange(t) {\n      this.wm._(t);\n    }\n    applyOptions(t) {\n      this.uh.hr(t);\n    }\n    options() {\n      return { ...p(this.uh.N()), barSpacing: this.uh.vu() };\n    }\n    Tg() {\n      this.kg.v() && this.kg.p(this.getVisibleRange());\n    }\n    Rg() {\n      this.z_.v() && this.z_.p(this.getVisibleLogicalRange());\n    }\n    Dg(t) {\n      this.wm.p(t.width, t.height);\n    }\n  }\n  function Ln(t) {\n    if (void 0 === t || 'custom' === t.type) return;\n    const i = t;\n    void 0 !== i.minMove &&\n      void 0 === i.precision &&\n      (i.precision = (function (t) {\n        if (t >= 1) return 0;\n        let i = 0;\n        for (; i < 8; i++) {\n          const s = Math.round(t);\n          if (Math.abs(s - t) < 1e-8) return i;\n          t *= 10;\n        }\n        return i;\n      })(i.minMove));\n  }\n  function Nn(t) {\n    return (\n      (function (t) {\n        if (f(t.handleScale)) {\n          const i = t.handleScale;\n          t.handleScale = {\n            axisDoubleClickReset: { time: i, price: i },\n            axisPressedMouseMove: { time: i, price: i },\n            mouseWheel: i,\n            pinch: i,\n          };\n        } else if (void 0 !== t.handleScale) {\n          const { axisPressedMouseMove: i, axisDoubleClickReset: s } =\n            t.handleScale;\n          f(i) && (t.handleScale.axisPressedMouseMove = { time: i, price: i }),\n            f(s) &&\n              (t.handleScale.axisDoubleClickReset = { time: s, price: s });\n        }\n        const i = t.handleScroll;\n        f(i) &&\n          (t.handleScroll = {\n            horzTouchDrag: i,\n            vertTouchDrag: i,\n            mouseWheel: i,\n            pressedMouseMove: i,\n          });\n      })(t),\n      t\n    );\n  }\n  class Wn {\n    constructor(t, i, s) {\n      (this.Eg = new Map()),\n        (this.Vg = new Map()),\n        (this.Bg = new o()),\n        (this.Ig = new o()),\n        (this.Ag = new o()),\n        (this.$u = new WeakMap()),\n        (this.zg = new hn(i));\n      const n = void 0 === s ? p(En()) : _(p(En()), Nn(s));\n      (this.Og = i),\n        (this.Ff = new Hs(t, n, i)),\n        this.Ff.Kv().i((t) => {\n          this.Bg.v() && this.Bg.p(this.Lg(t()));\n        }, this),\n        this.Ff.Xv().i((t) => {\n          this.Ig.v() && this.Ig.p(this.Lg(t()));\n        }, this),\n        this.Ff.uc().i((t) => {\n          this.Ag.v() && this.Ag.p(this.Lg(t()));\n        }, this);\n      const e = this.Ff.Qt();\n      this.Ng = new On(e, this.Ff.tw(), this.Og);\n    }\n    remove() {\n      this.Ff.Kv().u(this),\n        this.Ff.Xv().u(this),\n        this.Ff.uc().u(this),\n        this.Ng.m(),\n        this.Ff.m(),\n        this.Eg.clear(),\n        this.Vg.clear(),\n        this.Bg.m(),\n        this.Ig.m(),\n        this.Ag.m(),\n        this.zg.m();\n    }\n    resize(t, i, s) {\n      this.autoSizeActive() || this.Ff.Gm(t, i, s);\n    }\n    addCustomSeries(t, i = {}, s = 0) {\n      const n = ((t) => ({\n        type: 'Custom',\n        isBuiltIn: !1,\n        defaultOptions: { ...pn, ...t.defaultOptions() },\n        Wg: vn,\n        Fg: t,\n      }))(l(t));\n      return this.Hg(n, i, s);\n    }\n    addSeries(t, i = {}, s = 0) {\n      return this.Hg(t, i, s);\n    }\n    removeSeries(t) {\n      const i = h(this.Eg.get(t)),\n        s = this.zg.Ic(i);\n      this.Ff.Qt().Ic(i), this.Ug(s), this.Eg.delete(t), this.Vg.delete(i);\n    }\n    Cg(t, i) {\n      this.Ug(this.zg.Ww(t, i));\n    }\n    yg(t, i, s) {\n      this.Ug(this.zg.qw(t, i, s));\n    }\n    subscribeClick(t) {\n      this.Bg.i(t);\n    }\n    unsubscribeClick(t) {\n      this.Bg._(t);\n    }\n    subscribeCrosshairMove(t) {\n      this.Ag.i(t);\n    }\n    unsubscribeCrosshairMove(t) {\n      this.Ag._(t);\n    }\n    subscribeDblClick(t) {\n      this.Ig.i(t);\n    }\n    unsubscribeDblClick(t) {\n      this.Ig._(t);\n    }\n    priceScale(t, i = 0) {\n      return new Vn(this.Ff, t, i);\n    }\n    timeScale() {\n      return this.Ng;\n    }\n    applyOptions(t) {\n      this.Ff.hr(Nn(t));\n    }\n    options() {\n      return this.Ff.N();\n    }\n    takeScreenshot() {\n      return this.Ff.hw();\n    }\n    addPane(t = !1) {\n      const i = this.Ff.Qt().Uc();\n      return i.zo(t), this.$g(i);\n    }\n    removePane(t) {\n      this.Ff.Qt().dc(t);\n    }\n    swapPanes(t, i) {\n      this.Ff.Qt().vc(t, i);\n    }\n    autoSizeActive() {\n      return this.Ff.uw();\n    }\n    chartElement() {\n      return this.Ff.tp();\n    }\n    panes() {\n      return this.Ff.Qt()\n        .$s()\n        .map((t) => this.$g(t));\n    }\n    paneSize(t = 0) {\n      const i = this.Ff.fw(t);\n      return { height: i.height, width: i.width };\n    }\n    setCrosshairPosition(t, i, s) {\n      const n = this.Eg.get(s);\n      if (void 0 === n) return;\n      const e = this.Ff.Qt().Hn(n);\n      null !== e && this.Ff.Qt().Tc(t, i, e);\n    }\n    clearCrosshairPosition() {\n      this.Ff.Qt().Rc(!0);\n    }\n    horzBehaviour() {\n      return this.Og;\n    }\n    Hg(i, s = {}, n = 0) {\n      r(void 0 !== i.Wg),\n        Ln(s.priceFormat),\n        'Candlestick' === i.type &&\n          (function (t) {\n            void 0 !== t.borderColor &&\n              ((t.borderUpColor = t.borderColor),\n              (t.borderDownColor = t.borderColor)),\n              void 0 !== t.wickColor &&\n                ((t.wickUpColor = t.wickColor),\n                (t.wickDownColor = t.wickColor));\n          })(s);\n      const e = _(p(t), p(i.defaultOptions), s),\n        h = i.Wg,\n        a = new Ut(this.Ff.Qt(), i.type, e, h, i.Fg);\n      this.Ff.Qt().Vc(a, n);\n      const l = new zn(a, this, this, this, this.Og, (t) => this.$g(t));\n      return this.Eg.set(l, a), this.Vg.set(a, l), l;\n    }\n    Ug(t) {\n      const i = this.Ff.Qt();\n      i.Dc(t.It.ou, t.It.Gw, t.It.Jw),\n        t.Lo.forEach((t, i) => i.ht(t.se, t.Zw)),\n        i.It().Y_(),\n        i.pu();\n    }\n    jg(t) {\n      return h(this.Vg.get(t));\n    }\n    Lg(t) {\n      const i = new Map();\n      t.Rw.forEach((t, s) => {\n        const n = s.Rr(),\n          e = Cn(n)(t);\n        if ('Custom' !== n) r(js(e));\n        else {\n          const t = s.pa();\n          r(!t || !1 === t(e));\n        }\n        i.set(this.jg(s), e);\n      });\n      const s = void 0 !== t.Tw && this.Vg.has(t.Tw) ? this.jg(t.Tw) : void 0;\n      return {\n        time: t.Pw,\n        logical: t.Re,\n        point: t.yw,\n        paneIndex: t.kw,\n        hoveredSeries: s,\n        hoveredObjectId: t.Dw,\n        seriesData: i,\n        sourceEvent: t.Ew,\n      };\n    }\n    $g(t) {\n      let i = this.$u.get(t);\n      return (\n        i ||\n          ((i = new Bn(this.Ff, (t) => this.jg(t), t, this)),\n          this.$u.set(t, i)),\n        i\n      );\n    }\n  }\n  function Fn(t) {\n    if (d(t)) {\n      const i = document.getElementById(t);\n      return r(null !== i, `Cannot find element in DOM with id=${t}`), i;\n    }\n    return t;\n  }\n  function Hn(t, i, s) {\n    const n = Fn(t),\n      e = new Wn(n, i, s);\n    return i.setOptions(e.options()), e;\n  }\n  class Un extends un {\n    constructor(t, i) {\n      super(t, i, !0);\n    }\n    ug(t, i, s) {\n      i._u(this.sg, m(this.ng)), t.$l(this.sg, s, m(this.ng));\n    }\n    qg(t, i) {\n      return { wt: t, gt: i, _t: NaN, ut: NaN };\n    }\n    og() {\n      const t = this.Jn.Rh();\n      this.sg = this.Jn.Xs()\n        .Hr()\n        .map((i) => {\n          const s = i.Ft[3];\n          return this.Yg(i.Re, s, t);\n        });\n    }\n  }\n  function $n(t, i, s, n, e, r, h) {\n    if (0 === i.length || n.from >= i.length || n.to <= 0) return;\n    const { context: a, horizontalPixelRatio: l, verticalPixelRatio: o } = t,\n      _ = i[n.from];\n    let u = r(t, _),\n      c = _;\n    if (n.to - n.from < 2) {\n      const i = e / 2;\n      a.beginPath();\n      const s = { _t: _._t - i, ut: _.ut },\n        n = { _t: _._t + i, ut: _.ut };\n      a.moveTo(s._t * l, s.ut * o), a.lineTo(n._t * l, n.ut * o), h(t, u, s, n);\n    } else {\n      const e = (i, s) => {\n        h(t, u, c, s), a.beginPath(), (u = i), (c = s);\n      };\n      let d = c;\n      a.beginPath(), a.moveTo(_._t * l, _.ut * o);\n      for (let h = n.from + 1; h < n.to; ++h) {\n        d = i[h];\n        const n = r(t, d);\n        switch (s) {\n          case 0:\n            a.lineTo(d._t * l, d.ut * o);\n            break;\n          case 1:\n            a.lineTo(d._t * l, i[h - 1].ut * o),\n              n !== u && (e(n, d), a.lineTo(d._t * l, i[h - 1].ut * o)),\n              a.lineTo(d._t * l, d.ut * o);\n            break;\n          case 2: {\n            const [t, s] = Kn(i, h - 1, h);\n            a.bezierCurveTo(\n              t._t * l,\n              t.ut * o,\n              s._t * l,\n              s.ut * o,\n              d._t * l,\n              d.ut * o,\n            );\n            break;\n          }\n        }\n        1 !== s && n !== u && (e(n, d), a.moveTo(d._t * l, d.ut * o));\n      }\n      (c !== d || (c === d && 1 === s)) && h(t, u, c, d);\n    }\n  }\n  const jn = 6;\n  function qn(t, i) {\n    return { _t: t._t - i._t, ut: t.ut - i.ut };\n  }\n  function Yn(t, i) {\n    return { _t: t._t / i, ut: t.ut / i };\n  }\n  function Kn(t, i, s) {\n    const n = Math.max(0, i - 1),\n      e = Math.min(t.length - 1, s + 1);\n    var r, h;\n    return [\n      ((r = t[i]),\n      (h = Yn(qn(t[s], t[n]), jn)),\n      { _t: r._t + h._t, ut: r.ut + h.ut }),\n      qn(t[s], Yn(qn(t[e], t[i]), jn)),\n    ];\n  }\n  function Xn(t, i) {\n    const s = t.context;\n    (s.strokeStyle = i), s.stroke();\n  }\n  class Zn extends P {\n    constructor() {\n      super(...arguments), (this.rt = null);\n    }\n    ht(t) {\n      this.rt = t;\n    }\n    et(t) {\n      if (null === this.rt) return;\n      const { ot: i, lt: s, Kg: e, Xg: r, ct: h, Xt: a, Zg: l } = this.rt;\n      if (null === s) return;\n      const o = t.context;\n      (o.lineCap = 'butt'),\n        (o.lineWidth = h * t.verticalPixelRatio),\n        n(o, a),\n        (o.lineJoin = 'round');\n      const _ = this.Gg.bind(this);\n      void 0 !== r && $n(t, i, r, s, e, _, Xn),\n        l &&\n          (function (t, i, s, n, e) {\n            if (n.to - n.from <= 0) return;\n            const {\n              horizontalPixelRatio: r,\n              verticalPixelRatio: h,\n              context: a,\n            } = t;\n            let l = null;\n            const o = (Math.max(1, Math.floor(r)) % 2) / 2,\n              _ = s * h + o;\n            for (let s = n.to - 1; s >= n.from; --s) {\n              const n = i[s];\n              if (n) {\n                const i = e(t, n);\n                i !== l &&\n                  (a.beginPath(),\n                  null !== l && a.fill(),\n                  (a.fillStyle = i),\n                  (l = i));\n                const s = Math.round(n._t * r) + o,\n                  u = n.ut * h;\n                a.moveTo(s, u), a.arc(s, u, _, 0, 2 * Math.PI);\n              }\n            }\n            a.fill();\n          })(t, i, l, s, _);\n    }\n  }\n  class Gn extends Zn {\n    Gg(t, i) {\n      return i.vt;\n    }\n  }\n  class Jn extends Un {\n    constructor() {\n      super(...arguments), (this.hg = new Gn());\n    }\n    Yg(t, i, s) {\n      return { ...this.qg(t, i), ...s.Dr(t) };\n    }\n    cg() {\n      const t = this.Jn.N(),\n        i = {\n          ot: this.sg,\n          Xt: t.lineStyle,\n          Xg: t.lineVisible ? t.lineType : void 0,\n          ct: t.lineWidth,\n          Zg: t.pointMarkersVisible\n            ? t.pointMarkersRadius || t.lineWidth / 2 + 2\n            : void 0,\n          lt: this.ng,\n          Kg: this.Qn.It().vu(),\n        };\n      this.hg.ht(i);\n    }\n  }\n  const Qn = {\n    type: 'Line',\n    isBuiltIn: !0,\n    defaultOptions: {\n      color: '#2196f3',\n      lineStyle: 0,\n      lineWidth: 3,\n      lineType: 0,\n      lineVisible: !0,\n      crosshairMarkerVisible: !0,\n      crosshairMarkerRadius: 4,\n      crosshairMarkerBorderColor: '',\n      crosshairMarkerBorderWidth: 2,\n      crosshairMarkerBackgroundColor: '',\n      lastPriceAnimation: 0,\n      pointMarkersVisible: !1,\n    },\n    Wg: (t, i) => new Jn(t, i),\n  };\n  function te(t, i) {\n    return t.weight > i.weight ? t : i;\n  }\n  class ie {\n    constructor() {\n      (this.Jg = new o()),\n        (this.Qg = (function (t) {\n          let i = !1;\n          return function (...s) {\n            i ||\n              ((i = !0),\n              queueMicrotask(() => {\n                t(...s), (i = !1);\n              }));\n          };\n        })(() => this.Jg.p(this.tM))),\n        (this.tM = 0);\n    }\n    iM() {\n      return this.Jg;\n    }\n    m() {\n      this.Jg.m();\n    }\n    options() {\n      return this.Ps;\n    }\n    setOptions(t) {\n      this.Ps = t;\n    }\n    preprocessData(t) {}\n    updateFormatter(t) {\n      this.Ps && (this.Ps.localization = t);\n    }\n    createConverterToInternalObj(t) {\n      return this.Qg(), (t) => (t > this.tM && (this.tM = t), t);\n    }\n    key(t) {\n      return t;\n    }\n    cacheKey(t) {\n      return t;\n    }\n    convertHorzItemToInternal(t) {\n      return t;\n    }\n    formatHorzItem(t) {\n      return this.sM(t);\n    }\n    formatTickmark(t) {\n      return this.sM(t.time);\n    }\n    maxTickMarkWeight(t) {\n      return t.reduce(te, t[0]).weight;\n    }\n    fillWeightsForPoints(t, i) {\n      for (let n = i; n < t.length; ++n)\n        t[n].timeWeight =\n          (s = t[n].time) % 120 == 0\n            ? 10\n            : s % 60 == 0\n            ? 9\n            : s % 36 == 0\n            ? 8\n            : s % 12 == 0\n            ? 7\n            : s % 6 == 0\n            ? 6\n            : s % 3 == 0\n            ? 5\n            : s % 1 == 0\n            ? 4\n            : 0;\n      var s;\n      (this.tM = t[t.length - 1].time), this.Qg();\n    }\n    sM(t) {\n      if (this.Ps.localization?.timeFormatter)\n        return this.Ps.localization.timeFormatter(t);\n      if (t < 12) return `${t}M`;\n      const i = Math.floor(t / 12),\n        s = t % 12;\n      return 0 === s ? `${i}Y` : `${i}Y${s}M`;\n    }\n  }\n  const se = {\n      yieldCurve: {\n        baseResolution: 1,\n        minimumTimeRange: 120,\n        startTimeRange: 0,\n      },\n      timeScale: { ignoreWhitespaceIndices: !0 },\n      leftPriceScale: { visible: !0 },\n      rightPriceScale: { visible: !1 },\n      localization: { priceFormatter: (t) => t.toFixed(3) + '%' },\n    },\n    ne = { lastValueVisible: !1, priceLineVisible: !1 };\n  class ee extends Wn {\n    constructor(t, i) {\n      const s = _(se, i || {}),\n        n = new ie();\n      super(t, n, s),\n        n.setOptions(this.options()),\n        this._initWhitespaceSeries();\n    }\n    addSeries(t, i = {}, s = 0) {\n      if (t.isBuiltIn && !1 === ['Area', 'Line'].includes(t.type))\n        throw new Error('Yield curve only support Area and Line series');\n      const n = { ...ne, ...i };\n      return super.addSeries(t, n, s);\n    }\n    _initWhitespaceSeries() {\n      const t = this.horzBehaviour(),\n        i = this.addSeries(Qn);\n      let s;\n      function n(n) {\n        const e = (function (t, i) {\n            return {\n              le: Math.max(0, t.startTimeRange),\n              oe: Math.max(0, t.minimumTimeRange, i || 0),\n              nM: Math.max(1, t.baseResolution),\n            };\n          })(t.options().yieldCurve, n),\n          r = (({ le: t, oe: i, nM: s }) => `${t}~${i}~${s}`)(e);\n        r !== s &&\n          ((s = r),\n          i.setData(\n            (function ({ le: t, oe: i, nM: s }) {\n              return Array.from(\n                { length: Math.floor((i - t) / s) + 1 },\n                (i, n) => ({ time: t + n * s }),\n              );\n            })(e),\n          ));\n      }\n      n(0), t.iM().i(n);\n    }\n  }\n  function re(t, i) {\n    return t.weight > i.weight ? t : i;\n  }\n  class he {\n    options() {\n      return this.Ps;\n    }\n    setOptions(t) {\n      this.Ps = t;\n    }\n    preprocessData(t) {}\n    updateFormatter(t) {\n      this.Ps && (this.Ps.localization = t);\n    }\n    createConverterToInternalObj(t) {\n      return (t) => t;\n    }\n    key(t) {\n      return t;\n    }\n    cacheKey(t) {\n      return t;\n    }\n    convertHorzItemToInternal(t) {\n      return t;\n    }\n    formatHorzItem(t) {\n      return t.toFixed(this.Cn());\n    }\n    formatTickmark(t, i) {\n      return t.time.toFixed(this.Cn());\n    }\n    maxTickMarkWeight(t) {\n      return t.reduce(re, t[0]).weight;\n    }\n    fillWeightsForPoints(t, i) {\n      for (let n = i; n < t.length; ++n)\n        t[n].timeWeight =\n          (s = t[n].time) === 100 * Math.ceil(s / 100)\n            ? 8\n            : s === 50 * Math.ceil(s / 50)\n            ? 7\n            : s === 25 * Math.ceil(s / 25)\n            ? 6\n            : s === 10 * Math.ceil(s / 10)\n            ? 5\n            : s === 5 * Math.ceil(s / 5)\n            ? 4\n            : s === Math.ceil(s)\n            ? 3\n            : 2 * s === Math.ceil(2 * s)\n            ? 1\n            : 0;\n      var s;\n    }\n    Cn() {\n      return this.Ps.localization.precision;\n    }\n  }\n  function ae(t, i, s, n, e) {\n    const { context: r, horizontalPixelRatio: h, verticalPixelRatio: a } = i;\n    r.lineTo(e._t * h, t * a),\n      r.lineTo(n._t * h, t * a),\n      r.closePath(),\n      (r.fillStyle = s),\n      r.fill();\n  }\n  class le extends P {\n    constructor() {\n      super(...arguments), (this.rt = null);\n    }\n    ht(t) {\n      this.rt = t;\n    }\n    et(t) {\n      if (null === this.rt) return;\n      const { ot: i, lt: s, Kg: e, ct: r, Xt: h, Xg: a } = this.rt,\n        l = this.rt.eM ?? (this.rt.rM ? 0 : t.mediaSize.height);\n      if (null === s) return;\n      const o = t.context;\n      (o.lineCap = 'butt'),\n        (o.lineJoin = 'round'),\n        (o.lineWidth = r),\n        n(o, h),\n        (o.lineWidth = 1),\n        $n(t, i, a, s, e, this.hM.bind(this), ae.bind(null, l));\n    }\n  }\n  class oe {\n    aM(t, i) {\n      const s = this.lM,\n        { oM: n, _M: e, uM: r, cM: h, eM: a, dM: l, fM: o } = i;\n      if (\n        void 0 === this.pM ||\n        void 0 === s ||\n        s.oM !== n ||\n        s._M !== e ||\n        s.uM !== r ||\n        s.cM !== h ||\n        s.eM !== a ||\n        s.dM !== l ||\n        s.fM !== o\n      ) {\n        const { verticalPixelRatio: s } = t,\n          _ = a || l > 0 ? s : 1,\n          u = l * _,\n          c = o === t.bitmapSize.height ? o : o * _,\n          d = (a ?? 0) * _,\n          f = t.context.createLinearGradient(0, u, 0, c);\n        if ((f.addColorStop(0, n), null != a)) {\n          const t = Yt((d - u) / (c - u), 0, 1);\n          f.addColorStop(t, e), f.addColorStop(t, r);\n        }\n        f.addColorStop(1, h), (this.pM = f), (this.lM = i);\n      }\n      return this.pM;\n    }\n  }\n  class _e extends le {\n    constructor() {\n      super(...arguments), (this.vM = new oe());\n    }\n    hM(t, i) {\n      const s = this.rt;\n      return this.vM.aM(t, {\n        oM: i.br,\n        _M: i.Sr,\n        uM: i.Cr,\n        cM: i.Pr,\n        eM: s.eM,\n        dM: s.dM ?? 0,\n        fM: s.fM ?? t.bitmapSize.height,\n      });\n    }\n  }\n  class ue extends Zn {\n    constructor() {\n      super(...arguments), (this.mM = new oe());\n    }\n    Gg(t, i) {\n      const s = this.rt;\n      return this.mM.aM(t, {\n        oM: i.gr,\n        _M: i.gr,\n        uM: i.Mr,\n        cM: i.Mr,\n        eM: s.eM,\n        dM: s.dM ?? 0,\n        fM: s.fM ?? t.bitmapSize.height,\n      });\n    }\n  }\n  class ce extends Un {\n    constructor(t, i) {\n      super(t, i),\n        (this.hg = new C()),\n        (this.wM = new _e()),\n        (this.gM = new ue()),\n        this.hg.st([this.wM, this.gM]);\n    }\n    Yg(t, i, s) {\n      return { ...this.qg(t, i), ...s.Dr(t) };\n    }\n    cg() {\n      const t = this.Jn.zt();\n      if (null === t) return;\n      const i = this.Jn.N(),\n        s = this.Jn.Wt().Nt(i.baseValue.price, t.Ft),\n        n = this.Qn.It().vu();\n      if (null === this.ng || 0 === this.sg.length) return;\n      let e, r;\n      if (i.relativeGradient) {\n        (e = this.sg[this.ng.from].ut), (r = this.sg[this.ng.from].ut);\n        for (let t = this.ng.from; t < this.ng.to; t++) {\n          const i = this.sg[t];\n          i.ut < e && (e = i.ut), i.ut > r && (r = i.ut);\n        }\n      }\n      this.wM.ht({\n        ot: this.sg,\n        ct: i.lineWidth,\n        Xt: i.lineStyle,\n        Xg: i.lineType,\n        eM: s,\n        dM: e,\n        fM: r,\n        rM: !1,\n        lt: this.ng,\n        Kg: n,\n      }),\n        this.gM.ht({\n          ot: this.sg,\n          ct: i.lineWidth,\n          Xt: i.lineStyle,\n          Xg: i.lineVisible ? i.lineType : void 0,\n          Zg: i.pointMarkersVisible\n            ? i.pointMarkersRadius || i.lineWidth / 2 + 2\n            : void 0,\n          eM: s,\n          dM: e,\n          fM: r,\n          lt: this.ng,\n          Kg: n,\n        });\n    }\n  }\n  const de = {\n    type: 'Baseline',\n    isBuiltIn: !0,\n    defaultOptions: {\n      baseValue: { type: 'price', price: 0 },\n      relativeGradient: !1,\n      topFillColor1: 'rgba(38, 166, 154, 0.28)',\n      topFillColor2: 'rgba(38, 166, 154, 0.05)',\n      topLineColor: 'rgba(38, 166, 154, 1)',\n      bottomFillColor1: 'rgba(239, 83, 80, 0.05)',\n      bottomFillColor2: 'rgba(239, 83, 80, 0.28)',\n      bottomLineColor: 'rgba(239, 83, 80, 1)',\n      lineWidth: 3,\n      lineStyle: 0,\n      lineType: 0,\n      lineVisible: !0,\n      crosshairMarkerVisible: !0,\n      crosshairMarkerRadius: 4,\n      crosshairMarkerBorderColor: '',\n      crosshairMarkerBorderWidth: 2,\n      crosshairMarkerBackgroundColor: '',\n      lastPriceAnimation: 0,\n      pointMarkersVisible: !1,\n    },\n    Wg: (t, i) => new ce(t, i),\n  };\n  class fe extends le {\n    constructor() {\n      super(...arguments), (this.vM = new oe());\n    }\n    hM(t, i) {\n      return this.vM.aM(t, {\n        oM: i.mr,\n        _M: '',\n        uM: '',\n        cM: i.wr,\n        dM: this.rt?.dM ?? 0,\n        fM: t.bitmapSize.height,\n      });\n    }\n  }\n  class pe extends Un {\n    constructor(t, i) {\n      super(t, i),\n        (this.hg = new C()),\n        (this.MM = new fe()),\n        (this.bM = new Gn()),\n        this.hg.st([this.MM, this.bM]);\n    }\n    Yg(t, i, s) {\n      return { ...this.qg(t, i), ...s.Dr(t) };\n    }\n    cg() {\n      const t = this.Jn.N();\n      if (null === this.ng || 0 === this.sg.length) return;\n      let i;\n      if (t.relativeGradient) {\n        i = this.sg[this.ng.from].ut;\n        for (let t = this.ng.from; t < this.ng.to; t++) {\n          const s = this.sg[t];\n          s.ut < i && (i = s.ut);\n        }\n      }\n      this.MM.ht({\n        Xg: t.lineType,\n        ot: this.sg,\n        Xt: t.lineStyle,\n        ct: t.lineWidth,\n        eM: null,\n        dM: i,\n        rM: t.invertFilledArea,\n        lt: this.ng,\n        Kg: this.Qn.It().vu(),\n      }),\n        this.bM.ht({\n          Xg: t.lineVisible ? t.lineType : void 0,\n          ot: this.sg,\n          Xt: t.lineStyle,\n          ct: t.lineWidth,\n          lt: this.ng,\n          Kg: this.Qn.It().vu(),\n          Zg: t.pointMarkersVisible\n            ? t.pointMarkersRadius || t.lineWidth / 2 + 2\n            : void 0,\n        });\n    }\n  }\n  const ve = {\n    type: 'Area',\n    isBuiltIn: !0,\n    defaultOptions: {\n      topColor: 'rgba( 46, 220, 135, 0.4)',\n      bottomColor: 'rgba( 40, 221, 100, 0)',\n      invertFilledArea: !1,\n      relativeGradient: !1,\n      lineColor: '#33D778',\n      lineStyle: 0,\n      lineWidth: 3,\n      lineType: 0,\n      lineVisible: !0,\n      crosshairMarkerVisible: !0,\n      crosshairMarkerRadius: 4,\n      crosshairMarkerBorderColor: '',\n      crosshairMarkerBorderWidth: 2,\n      crosshairMarkerBackgroundColor: '',\n      lastPriceAnimation: 0,\n      pointMarkersVisible: !1,\n    },\n    Wg: (t, i) => new pe(t, i),\n  };\n  class me extends P {\n    constructor() {\n      super(...arguments), (this.qt = null), (this.xM = 0), (this.SM = 0);\n    }\n    ht(t) {\n      this.qt = t;\n    }\n    et({ context: t, horizontalPixelRatio: i, verticalPixelRatio: s }) {\n      if (null === this.qt || 0 === this.qt.Xs.length || null === this.qt.lt)\n        return;\n      if (((this.xM = this.CM(i)), this.xM >= 2)) {\n        Math.max(1, Math.floor(i)) % 2 != this.xM % 2 && this.xM--;\n      }\n      this.SM = this.qt.PM ? Math.min(this.xM, Math.floor(i)) : this.xM;\n      let n = null;\n      const e = this.SM <= this.xM && this.qt.vu >= Math.floor(1.5 * i);\n      for (let r = this.qt.lt.from; r < this.qt.lt.to; ++r) {\n        const h = this.qt.Xs[r];\n        n !== h.cr && ((t.fillStyle = h.cr), (n = h.cr));\n        const a = Math.floor(0.5 * this.SM),\n          l = Math.round(h._t * i),\n          o = l - a,\n          _ = this.SM,\n          u = o + _ - 1,\n          c = Math.min(h.Kl, h.Xl),\n          d = Math.max(h.Kl, h.Xl),\n          f = Math.round(c * s) - a,\n          p = Math.round(d * s) + a,\n          v = Math.max(p - f, this.SM);\n        t.fillRect(o, f, _, v);\n        const m = Math.ceil(1.5 * this.xM);\n        if (e) {\n          if (this.qt.yM) {\n            const i = l - m;\n            let n = Math.max(f, Math.round(h.Yl * s) - a),\n              e = n + _ - 1;\n            e > f + v - 1 && ((e = f + v - 1), (n = e - _ + 1)),\n              t.fillRect(i, n, o - i, e - n + 1);\n          }\n          const i = l + m;\n          let n = Math.max(f, Math.round(h.Zl * s) - a),\n            e = n + _ - 1;\n          e > f + v - 1 && ((e = f + v - 1), (n = e - _ + 1)),\n            t.fillRect(u + 1, n, i - u, e - n + 1);\n        }\n      }\n    }\n    CM(t) {\n      const i = Math.floor(t);\n      return Math.max(\n        i,\n        Math.floor(\n          (function (t, i) {\n            return Math.floor(0.3 * t * i);\n          })(a(this.qt).vu, t),\n        ),\n      );\n    }\n  }\n  class we extends un {\n    constructor(t, i) {\n      super(t, i, !1);\n    }\n    ug(t, i, s) {\n      i._u(this.sg, m(this.ng)), t.ql(this.sg, s, m(this.ng));\n    }\n    kM(t, i, s) {\n      return {\n        wt: t,\n        jh: i.Ft[0],\n        qh: i.Ft[1],\n        Yh: i.Ft[2],\n        Kh: i.Ft[3],\n        _t: NaN,\n        Yl: NaN,\n        Kl: NaN,\n        Xl: NaN,\n        Zl: NaN,\n      };\n    }\n    og() {\n      const t = this.Jn.Rh();\n      this.sg = this.Jn.Xs()\n        .Hr()\n        .map((i) => this.Yg(i.Re, i, t));\n    }\n  }\n  class ge extends we {\n    constructor() {\n      super(...arguments), (this.hg = new me());\n    }\n    Yg(t, i, s) {\n      return { ...this.kM(t, i, s), ...s.Dr(t) };\n    }\n    cg() {\n      const t = this.Jn.N();\n      this.hg.ht({\n        Xs: this.sg,\n        vu: this.Qn.It().vu(),\n        yM: t.openVisible,\n        PM: t.thinBars,\n        lt: this.ng,\n      });\n    }\n  }\n  const Me = {\n    type: 'Bar',\n    isBuiltIn: !0,\n    defaultOptions: {\n      upColor: '#26a69a',\n      downColor: '#ef5350',\n      openVisible: !0,\n      thinBars: !0,\n    },\n    Wg: (t, i) => new ge(t, i),\n  };\n  class be extends P {\n    constructor() {\n      super(...arguments), (this.qt = null), (this.xM = 0);\n    }\n    ht(t) {\n      this.qt = t;\n    }\n    et(t) {\n      if (null === this.qt || 0 === this.qt.Xs.length || null === this.qt.lt)\n        return;\n      const { horizontalPixelRatio: i } = t;\n      if (\n        ((this.xM = (function (t, i) {\n          if (t >= 2.5 && t <= 4) return Math.floor(3 * i);\n          const s = 1 - (0.2 * Math.atan(Math.max(4, t) - 4)) / (0.5 * Math.PI),\n            n = Math.floor(t * s * i),\n            e = Math.floor(t * i),\n            r = Math.min(n, e);\n          return Math.max(Math.floor(i), r);\n        })(this.qt.vu, i)),\n        this.xM >= 2)\n      ) {\n        Math.floor(i) % 2 != this.xM % 2 && this.xM--;\n      }\n      const s = this.qt.Xs;\n      this.qt.TM && this.RM(t, s, this.qt.lt),\n        this.qt.Mi && this._v(t, s, this.qt.lt);\n      const n = this.DM(i);\n      (!this.qt.Mi || this.xM > 2 * n) && this.EM(t, s, this.qt.lt);\n    }\n    RM(t, i, s) {\n      if (null === this.qt) return;\n      const { context: n, horizontalPixelRatio: e, verticalPixelRatio: r } = t;\n      let h = '',\n        a = Math.min(Math.floor(e), Math.floor(this.qt.vu * e));\n      a = Math.max(Math.floor(e), Math.min(a, this.xM));\n      const l = Math.floor(0.5 * a);\n      let o = null;\n      for (let t = s.from; t < s.to; t++) {\n        const s = i[t];\n        s.pr !== h && ((n.fillStyle = s.pr), (h = s.pr));\n        const _ = Math.round(Math.min(s.Yl, s.Zl) * r),\n          u = Math.round(Math.max(s.Yl, s.Zl) * r),\n          c = Math.round(s.Kl * r),\n          d = Math.round(s.Xl * r);\n        let f = Math.round(e * s._t) - l;\n        const p = f + a - 1;\n        null !== o && ((f = Math.max(o + 1, f)), (f = Math.min(f, p)));\n        const v = p - f + 1;\n        n.fillRect(f, c, v, _ - c), n.fillRect(f, u + 1, v, d - u), (o = p);\n      }\n    }\n    DM(t) {\n      let i = Math.floor(1 * t);\n      this.xM <= 2 * i && (i = Math.floor(0.5 * (this.xM - 1)));\n      const s = Math.max(Math.floor(t), i);\n      return this.xM <= 2 * s ? Math.max(Math.floor(t), Math.floor(1 * t)) : s;\n    }\n    _v(t, i, s) {\n      if (null === this.qt) return;\n      const { context: n, horizontalPixelRatio: e, verticalPixelRatio: r } = t;\n      let h = '';\n      const a = this.DM(e);\n      let l = null;\n      for (let t = s.from; t < s.to; t++) {\n        const s = i[t];\n        s.dr !== h && ((n.fillStyle = s.dr), (h = s.dr));\n        let o = Math.round(s._t * e) - Math.floor(0.5 * this.xM);\n        const _ = o + this.xM - 1,\n          u = Math.round(Math.min(s.Yl, s.Zl) * r),\n          c = Math.round(Math.max(s.Yl, s.Zl) * r);\n        if (\n          (null !== l && ((o = Math.max(l + 1, o)), (o = Math.min(o, _))),\n          this.qt.vu * e > 2 * a)\n        )\n          V(n, o, u, _ - o + 1, c - u + 1, a);\n        else {\n          const t = _ - o + 1;\n          n.fillRect(o, u, t, c - u + 1);\n        }\n        l = _;\n      }\n    }\n    EM(t, i, s) {\n      if (null === this.qt) return;\n      const { context: n, horizontalPixelRatio: e, verticalPixelRatio: r } = t;\n      let h = '';\n      const a = this.DM(e);\n      for (let t = s.from; t < s.to; t++) {\n        const s = i[t];\n        let l = Math.round(Math.min(s.Yl, s.Zl) * r),\n          o = Math.round(Math.max(s.Yl, s.Zl) * r),\n          _ = Math.round(s._t * e) - Math.floor(0.5 * this.xM),\n          u = _ + this.xM - 1;\n        if (s.cr !== h) {\n          const t = s.cr;\n          (n.fillStyle = t), (h = t);\n        }\n        this.qt.Mi && ((_ += a), (l += a), (u -= a), (o -= a)),\n          l > o || n.fillRect(_, l, u - _ + 1, o - l + 1);\n      }\n    }\n  }\n  class xe extends we {\n    constructor() {\n      super(...arguments), (this.hg = new be());\n    }\n    Yg(t, i, s) {\n      return { ...this.kM(t, i, s), ...s.Dr(t) };\n    }\n    cg() {\n      const t = this.Jn.N();\n      this.hg.ht({\n        Xs: this.sg,\n        vu: this.Qn.It().vu(),\n        TM: t.wickVisible,\n        Mi: t.borderVisible,\n        lt: this.ng,\n      });\n    }\n  }\n  const Se = {\n    type: 'Candlestick',\n    isBuiltIn: !0,\n    defaultOptions: {\n      upColor: '#26a69a',\n      downColor: '#ef5350',\n      wickVisible: !0,\n      borderVisible: !0,\n      borderColor: '#378658',\n      borderUpColor: '#26a69a',\n      borderDownColor: '#ef5350',\n      wickColor: '#737375',\n      wickUpColor: '#26a69a',\n      wickDownColor: '#ef5350',\n    },\n    Wg: (t, i) => new xe(t, i),\n  };\n  class Ce extends P {\n    constructor() {\n      super(...arguments), (this.qt = null), (this.VM = []);\n    }\n    ht(t) {\n      (this.qt = t), (this.VM = []);\n    }\n    et({ context: t, horizontalPixelRatio: i, verticalPixelRatio: s }) {\n      if (null === this.qt || 0 === this.qt.ot.length || null === this.qt.lt)\n        return;\n      this.VM.length || this.BM(i);\n      const n = Math.max(1, Math.floor(s)),\n        e = Math.round(this.qt.IM * s) - Math.floor(n / 2),\n        r = e + n;\n      for (let i = this.qt.lt.from; i < this.qt.lt.to; i++) {\n        const h = this.qt.ot[i],\n          a = this.VM[i - this.qt.lt.from],\n          l = Math.round(h.ut * s);\n        let o, _;\n        (t.fillStyle = h.cr),\n          l <= e\n            ? ((o = l), (_ = r))\n            : ((o = e), (_ = l - Math.floor(n / 2) + n)),\n          t.fillRect(a.Uh, o, a.bi - a.Uh + 1, _ - o);\n      }\n    }\n    BM(t) {\n      if (null === this.qt || 0 === this.qt.ot.length || null === this.qt.lt)\n        return void (this.VM = []);\n      const i = Math.ceil(this.qt.vu * t) <= 1 ? 0 : Math.max(1, Math.floor(t)),\n        s = Math.round(this.qt.vu * t) - i;\n      this.VM = new Array(this.qt.lt.to - this.qt.lt.from);\n      for (let i = this.qt.lt.from; i < this.qt.lt.to; i++) {\n        const n = this.qt.ot[i],\n          e = Math.round(n._t * t);\n        let r, h;\n        if (s % 2) {\n          const t = (s - 1) / 2;\n          (r = e - t), (h = e + t);\n        } else {\n          const t = s / 2;\n          (r = e - t), (h = e + t - 1);\n        }\n        this.VM[i - this.qt.lt.from] = {\n          Uh: r,\n          bi: h,\n          AM: e,\n          ne: n._t * t,\n          wt: n.wt,\n        };\n      }\n      for (let t = this.qt.lt.from + 1; t < this.qt.lt.to; t++) {\n        const s = this.VM[t - this.qt.lt.from],\n          n = this.VM[t - this.qt.lt.from - 1];\n        s.wt === n.wt + 1 &&\n          s.Uh - n.bi !== i + 1 &&\n          (n.AM > n.ne ? (n.bi = s.Uh - i - 1) : (s.Uh = n.bi + i + 1));\n      }\n      let n = Math.ceil(this.qt.vu * t);\n      for (let t = this.qt.lt.from; t < this.qt.lt.to; t++) {\n        const i = this.VM[t - this.qt.lt.from];\n        i.bi < i.Uh && (i.bi = i.Uh);\n        const s = i.bi - i.Uh + 1;\n        n = Math.min(s, n);\n      }\n      if (i > 0 && n < 4)\n        for (let t = this.qt.lt.from; t < this.qt.lt.to; t++) {\n          const i = this.VM[t - this.qt.lt.from];\n          i.bi - i.Uh + 1 > n && (i.AM > i.ne ? (i.bi -= 1) : (i.Uh += 1));\n        }\n    }\n  }\n  class Pe extends Un {\n    constructor() {\n      super(...arguments), (this.hg = new Ce());\n    }\n    Yg(t, i, s) {\n      return { ...this.qg(t, i), ...s.Dr(t) };\n    }\n    cg() {\n      const t = {\n        ot: this.sg,\n        vu: this.Qn.It().vu(),\n        lt: this.ng,\n        IM: this.Jn.Wt().Nt(this.Jn.N().base, a(this.Jn.zt()).Ft),\n      };\n      this.hg.ht(t);\n    }\n  }\n  const ye = {\n    type: 'Histogram',\n    isBuiltIn: !0,\n    defaultOptions: { color: '#26a69a', base: 0 },\n    Wg: (t, i) => new Pe(t, i),\n  };\n  class ke {\n    constructor(t, i) {\n      (this.Pt = t), (this.zM = i), this.OM();\n    }\n    detach() {\n      this.Pt.detachPrimitive(this.zM);\n    }\n    getPane() {\n      return this.Pt;\n    }\n    applyOptions(t) {\n      this.zM.hr?.(t);\n    }\n    OM() {\n      this.Pt.attachPrimitive(this.zM);\n    }\n  }\n  const Te = {\n      visible: !0,\n      horzAlign: 'center',\n      vertAlign: 'center',\n      lines: [],\n    },\n    Re = {\n      color: 'rgba(0, 0, 0, 0.5)',\n      fontSize: 48,\n      fontFamily: w,\n      fontStyle: '',\n      text: '',\n    };\n  class De {\n    constructor(t) {\n      (this.LM = new Map()), (this.qt = t);\n    }\n    draw(t) {\n      t.useMediaCoordinateSpace((t) => {\n        if (!this.qt.visible) return;\n        const { context: i, mediaSize: s } = t;\n        let n = 0;\n        for (const t of this.qt.lines) {\n          if (0 === t.text.length) continue;\n          i.font = t.k;\n          const e = this.NM(i, t.text);\n          e > s.width ? (t.Su = s.width / e) : (t.Su = 1),\n            (n += t.lineHeight * t.Su);\n        }\n        let e = 0;\n        switch (this.qt.vertAlign) {\n          case 'top':\n            e = 0;\n            break;\n          case 'center':\n            e = Math.max((s.height - n) / 2, 0);\n            break;\n          case 'bottom':\n            e = Math.max(s.height - n, 0);\n        }\n        for (const t of this.qt.lines) {\n          i.save(), (i.fillStyle = t.color);\n          let n = 0;\n          switch (this.qt.horzAlign) {\n            case 'left':\n              (i.textAlign = 'left'), (n = t.lineHeight / 2);\n              break;\n            case 'center':\n              (i.textAlign = 'center'), (n = s.width / 2);\n              break;\n            case 'right':\n              (i.textAlign = 'right'), (n = s.width - 1 - t.lineHeight / 2);\n          }\n          i.translate(n, e),\n            (i.textBaseline = 'top'),\n            (i.font = t.k),\n            i.scale(t.Su, t.Su),\n            i.fillText(t.text, 0, t.WM),\n            i.restore(),\n            (e += t.lineHeight * t.Su);\n        }\n      });\n    }\n    NM(t, i) {\n      const s = this.FM(t.font);\n      let n = s.get(i);\n      return void 0 === n && ((n = t.measureText(i).width), s.set(i, n)), n;\n    }\n    FM(t) {\n      let i = this.LM.get(t);\n      return void 0 === i && ((i = new Map()), this.LM.set(t, i)), i;\n    }\n  }\n  class Ee {\n    constructor(t) {\n      this.Ps = Be(t);\n    }\n    yt(t) {\n      this.Ps = Be(t);\n    }\n    renderer() {\n      return new De(this.Ps);\n    }\n  }\n  function Ve(t) {\n    return {\n      ...t,\n      k: g(t.fontSize, t.fontFamily, t.fontStyle),\n      lineHeight: t.lineHeight || 1.2 * t.fontSize,\n      WM: 0,\n      Su: 0,\n    };\n  }\n  function Be(t) {\n    return { ...t, lines: t.lines.map(Ve) };\n  }\n  function Ie(t) {\n    return { ...Re, ...t };\n  }\n  function Ae(t) {\n    return { ...Te, ...t, lines: t.lines?.map(Ie) ?? [] };\n  }\n  class ze {\n    constructor(t) {\n      (this.Ps = Ae(t)), (this.HM = [new Ee(this.Ps)]);\n    }\n    updateAllViews() {\n      this.HM.forEach((t) => t.yt(this.Ps));\n    }\n    paneViews() {\n      return this.HM;\n    }\n    attached({ requestUpdate: t }) {\n      this.UM = t;\n    }\n    detached() {\n      this.UM = void 0;\n    }\n    hr(t) {\n      (this.Ps = Ae({ ...this.Ps, ...t })), this.UM && this.UM();\n    }\n  }\n  const Oe = { alpha: 1, padding: 0 };\n  class Le {\n    constructor(t) {\n      this.qt = t;\n    }\n    draw(t) {\n      t.useMediaCoordinateSpace((t) => {\n        const i = t.context,\n          s = this.$M(this.qt, t.mediaSize);\n        s &&\n          this.qt.jM &&\n          ((i.globalAlpha = this.qt.alpha ?? 1),\n          i.drawImage(this.qt.jM, s._t, s.ut, s.Qi, s.$t));\n      });\n    }\n    $M(t, i) {\n      const { maxHeight: s, maxWidth: n, qM: e, YM: r, padding: h } = t,\n        a = Math.round(i.width / 2),\n        l = Math.round(i.height / 2),\n        o = h ?? 0;\n      let _ = i.width - 2 * o,\n        u = i.height - 2 * o;\n      s && (u = Math.min(u, s)), n && (_ = Math.min(_, n));\n      const c = _ / r,\n        d = u / e,\n        f = Math.min(c, d),\n        p = r * f,\n        v = e * f;\n      return { _t: a - 0.5 * p, ut: l - 0.5 * v, $t: v, Qi: p };\n    }\n  }\n  class Ne {\n    constructor(t) {\n      (this.KM = null),\n        (this.XM = 0),\n        (this.ZM = 0),\n        (this.Ps = t),\n        (this.M = We(this.Ps, this.KM, this.XM, this.ZM));\n    }\n    GM(t) {\n      void 0 !== t.JM && (this.XM = t.JM),\n        void 0 !== t.QM && (this.ZM = t.QM),\n        void 0 !== t.tb && (this.KM = t.tb),\n        this.yt();\n    }\n    ib(t) {\n      (this.Ps = t), this.yt();\n    }\n    zOrder() {\n      return 'bottom';\n    }\n    yt() {\n      this.M = We(this.Ps, this.KM, this.XM, this.ZM);\n    }\n    renderer() {\n      return new Le(this.M);\n    }\n  }\n  function We(t, i, s, n) {\n    return { ...t, jM: i, YM: s, qM: n };\n  }\n  function Fe(t) {\n    return { ...Oe, ...t };\n  }\n  class He {\n    constructor(t, i) {\n      (this.sb = null),\n        (this.nb = t),\n        (this.Ps = Fe(i)),\n        (this.HM = [new Ne(this.Ps)]);\n    }\n    updateAllViews() {\n      this.HM.forEach((t) => t.yt());\n    }\n    paneViews() {\n      return this.HM;\n    }\n    attached(t) {\n      const { requestUpdate: i } = t;\n      (this.eb = i),\n        (this.sb = new Image()),\n        (this.sb.onload = () => {\n          const t = this.sb?.naturalHeight ?? 1,\n            i = this.sb?.naturalWidth ?? 1;\n          this.HM.forEach((s) => s.GM({ QM: t, JM: i, tb: this.sb })),\n            this.eb && this.eb();\n        }),\n        (this.sb.src = this.nb);\n    }\n    detached() {\n      (this.eb = void 0), (this.sb = null);\n    }\n    hr(t) {\n      (this.Ps = Fe({ ...this.Ps, ...t })), this.rb(), this.UM && this.UM();\n    }\n    UM() {\n      this.eb && this.eb();\n    }\n    rb() {\n      this.HM.forEach((t) => t.ib(this.Ps));\n    }\n  }\n  class Ue {\n    constructor(t, i) {\n      (this.Jn = t), (this.ah = i), this.OM();\n    }\n    detach() {\n      this.Jn.detachPrimitive(this.ah);\n    }\n    getSeries() {\n      return this.Jn;\n    }\n    applyOptions(t) {\n      this.ah && this.ah.hr && this.ah.hr(t);\n    }\n    OM() {\n      this.Jn.attachPrimitive(this.ah);\n    }\n  }\n  const $e = { zOrder: 'normal' };\n  function je(t, i) {\n    return Xt(Math.min(Math.max(t, 12), 30) * i);\n  }\n  function qe(t, i) {\n    switch (t) {\n      case 'arrowDown':\n      case 'arrowUp':\n        return je(i, 1);\n      case 'circle':\n        return je(i, 0.8);\n      case 'square':\n        return je(i, 0.7);\n    }\n  }\n  function Ye(t) {\n    return (function (t) {\n      const i = Math.ceil(t);\n      return i % 2 != 0 ? i - 1 : i;\n    })(je(t, 1));\n  }\n  function Ke(t) {\n    return Math.max(je(t, 0.1), 3);\n  }\n  function Xe(t, i, s) {\n    return i ? t : s ? Math.ceil(t / 2) : 0;\n  }\n  function Ze(t, i, s, n) {\n    const e = ((qe('arrowUp', n) - 1) / 2) * s.hb,\n      r = ((Xt(n / 2) - 1) / 2) * s.hb;\n    i.beginPath(),\n      t\n        ? (i.moveTo(s._t - e, s.ut),\n          i.lineTo(s._t, s.ut - e),\n          i.lineTo(s._t + e, s.ut),\n          i.lineTo(s._t + r, s.ut),\n          i.lineTo(s._t + r, s.ut + e),\n          i.lineTo(s._t - r, s.ut + e),\n          i.lineTo(s._t - r, s.ut))\n        : (i.moveTo(s._t - e, s.ut),\n          i.lineTo(s._t, s.ut + e),\n          i.lineTo(s._t + e, s.ut),\n          i.lineTo(s._t + r, s.ut),\n          i.lineTo(s._t + r, s.ut - e),\n          i.lineTo(s._t - r, s.ut - e),\n          i.lineTo(s._t - r, s.ut)),\n      i.fill();\n  }\n  function Ge(t, i, s, n, e, r) {\n    const h = (qe('arrowUp', n) - 1) / 2,\n      a = (Xt(n / 2) - 1) / 2;\n    if (\n      e >= i - a - 2 &&\n      e <= i + a + 2 &&\n      r >= (t ? s : s - h) - 2 &&\n      r <= (t ? s + h : s) + 2\n    )\n      return !0;\n    return (() => {\n      if (\n        e < i - h - 3 ||\n        e > i + h + 3 ||\n        r < (t ? s - h - 3 : s) ||\n        r > (t ? s : s + h + 3)\n      )\n        return !1;\n      const n = Math.abs(e - i);\n      return Math.abs(r - s) + 3 >= n / 2;\n    })();\n  }\n  class Je {\n    constructor() {\n      (this.qt = null),\n        (this.Ln = new it()),\n        (this.W = -1),\n        (this.F = ''),\n        (this.Wp = ''),\n        (this.ab = 'normal');\n    }\n    ht(t) {\n      this.qt = t;\n    }\n    Nn(t, i, s) {\n      (this.W === t && this.F === i) ||\n        ((this.W = t), (this.F = i), (this.Wp = g(t, i)), this.Ln.Vn()),\n        (this.ab = s);\n    }\n    Yn(t, i) {\n      if (null === this.qt || null === this.qt.lt) return null;\n      for (let s = this.qt.lt.from; s < this.qt.lt.to; s++) {\n        const n = this.qt.ot[s];\n        if (n && tr(n, t, i))\n          return { zOrder: 'normal', externalId: n.Kn ?? '' };\n      }\n      return null;\n    }\n    draw(t) {\n      'aboveSeries' !== this.ab &&\n        t.useBitmapCoordinateSpace((t) => {\n          this.et(t);\n        });\n    }\n    drawBackground(t) {\n      'aboveSeries' === this.ab &&\n        t.useBitmapCoordinateSpace((t) => {\n          this.et(t);\n        });\n    }\n    et({ context: t, horizontalPixelRatio: i, verticalPixelRatio: s }) {\n      if (null !== this.qt && null !== this.qt.lt) {\n        (t.textBaseline = 'middle'), (t.font = this.Wp);\n        for (let n = this.qt.lt.from; n < this.qt.lt.to; n++) {\n          const e = this.qt.ot[n];\n          void 0 !== e.ri &&\n            ((e.ri.Qi = this.Ln.Ei(t, e.ri.lb)),\n            (e.ri.$t = this.W),\n            (e.ri._t = e._t - e.ri.Qi / 2)),\n            Qe(e, t, i, s);\n        }\n      }\n    }\n  }\n  function Qe(t, i, s, n) {\n    (i.fillStyle = t.R),\n      void 0 !== t.ri &&\n        (function (t, i, s, n, e, r) {\n          t.save(), t.scale(e, r), t.fillText(i, s, n), t.restore();\n        })(i, t.ri.lb, t.ri._t, t.ri.ut, s, n),\n      (function (t, i, s) {\n        if (0 === t.zr) return;\n        switch (t.ob) {\n          case 'arrowDown':\n            return void Ze(!1, i, s, t.zr);\n          case 'arrowUp':\n            return void Ze(!0, i, s, t.zr);\n          case 'circle':\n            return void (function (t, i, s) {\n              const n = (qe('circle', s) - 1) / 2;\n              t.beginPath(),\n                t.arc(i._t, i.ut, n * i.hb, 0, 2 * Math.PI, !1),\n                t.fill();\n            })(i, s, t.zr);\n          case 'square':\n            return void (function (t, i, s) {\n              const n = qe('square', s),\n                e = ((n - 1) * i.hb) / 2,\n                r = i._t - e,\n                h = i.ut - e;\n              t.fillRect(r, h, n * i.hb, n * i.hb);\n            })(i, s, t.zr);\n        }\n        t.ob;\n      })(\n        t,\n        i,\n        (function (t, i, s) {\n          const n = (Math.max(1, Math.floor(i)) % 2) / 2;\n          return { _t: Math.round(t._t * i) + n, ut: t.ut * s, hb: i };\n        })(t, s, n),\n      );\n  }\n  function tr(t, i, s) {\n    return (\n      !(\n        void 0 === t.ri ||\n        !(function (t, i, s, n, e, r) {\n          const h = n / 2;\n          return e >= t && e <= t + s && r >= i - h && r <= i + h;\n        })(t.ri._t, t.ri.ut, t.ri.Qi, t.ri.$t, i, s)\n      ) ||\n      (function (t, i, s) {\n        if (0 === t.zr) return !1;\n        switch (t.ob) {\n          case 'arrowDown':\n            return Ge(!0, t._t, t.ut, t.zr, i, s);\n          case 'arrowUp':\n            return Ge(!1, t._t, t.ut, t.zr, i, s);\n          case 'circle':\n            return (function (t, i, s, n, e) {\n              const r = 2 + qe('circle', s) / 2,\n                h = t - n,\n                a = i - e;\n              return Math.sqrt(h * h + a * a) <= r;\n            })(t._t, t.ut, t.zr, i, s);\n          case 'square':\n            return (function (t, i, s, n, e) {\n              const r = qe('square', s),\n                h = (r - 1) / 2,\n                a = t - h,\n                l = i - h;\n              return n >= a && n <= a + r && e >= l && e <= l + r;\n            })(t._t, t.ut, t.zr, i, s);\n        }\n      })(t, i, s)\n    );\n  }\n  function ir(t) {\n    return 'atPriceTop' === t || 'atPriceBottom' === t || 'atPriceMiddle' === t;\n  }\n  function sr(t, i, s, n, e, r, h, l) {\n    const o = (function (t, i) {\n      if (ir(i.position) && void 0 !== i.price) return i.price;\n      if ('value' in (s = t) && 'number' == typeof s.value) return t.value;\n      var s;\n      if (\n        (function (t) {\n          return 'open' in t && 'high' in t && 'low' in t && 'close' in t;\n        })(t)\n      ) {\n        if ('inBar' === i.position) return t.close;\n        if ('aboveBar' === i.position) return t.high;\n        if ('belowBar' === i.position) return t.low;\n      }\n    })(s, i);\n    if (void 0 === o) return;\n    const _ = ir(i.position),\n      c = l.timeScale(),\n      d = u(i.size) ? Math.max(i.size, 0) : 1,\n      f = Ye(c.options().barSpacing) * d,\n      p = f / 2;\n    t.zr = f;\n    switch (i.position) {\n      case 'inBar':\n      case 'atPriceMiddle':\n        return (\n          (t.ut = a(h.priceToCoordinate(o))),\n          void (void 0 !== t.ri && (t.ri.ut = t.ut + p + r + 0.6 * e))\n        );\n      case 'aboveBar':\n      case 'atPriceTop': {\n        const i = _ ? 0 : n._b;\n        return (\n          (t.ut = a(h.priceToCoordinate(o)) - p - i),\n          void 0 !== t.ri &&\n            ((t.ri.ut = t.ut - p - 0.6 * e), (n._b += 1.2 * e)),\n          void (_ || (n._b += f + r))\n        );\n      }\n      case 'belowBar':\n      case 'atPriceBottom': {\n        const i = _ ? 0 : n.ub;\n        return (\n          (t.ut = a(h.priceToCoordinate(o)) + p + i),\n          void 0 !== t.ri &&\n            ((t.ri.ut = t.ut + p + r + 0.6 * e), (n.ub += 1.2 * e)),\n          void (_ || (n.ub += f + r))\n        );\n      }\n    }\n  }\n  class nr {\n    constructor(t, i, s) {\n      (this.cb = []),\n        (this.St = !0),\n        (this.fb = !0),\n        (this.Gt = new Je()),\n        (this.ge = t),\n        (this.Dp = i),\n        (this.qt = { ot: [], lt: null }),\n        (this.Ps = s);\n    }\n    renderer() {\n      if (!this.ge.options().visible) return null;\n      this.St && this.pb();\n      const t = this.Dp.options().layout;\n      return (\n        this.Gt.Nn(t.fontSize, t.fontFamily, this.Ps.zOrder),\n        this.Gt.ht(this.qt),\n        this.Gt\n      );\n    }\n    mb(t) {\n      (this.cb = t), this.yt('data');\n    }\n    yt(t) {\n      (this.St = !0), 'data' === t && (this.fb = !0);\n    }\n    wb(t) {\n      (this.St = !0), (this.Ps = t);\n    }\n    zOrder() {\n      return 'aboveSeries' === this.Ps.zOrder ? 'top' : this.Ps.zOrder;\n    }\n    pb() {\n      const t = this.Dp.timeScale(),\n        i = this.cb;\n      this.fb &&\n        ((this.qt.ot = i.map((t) => ({\n          wt: t.time,\n          _t: 0,\n          ut: 0,\n          zr: 0,\n          ob: t.shape,\n          R: t.color,\n          Kn: t.id,\n          gb: t.gb,\n          ri: void 0,\n        }))),\n        (this.fb = !1));\n      const s = this.Dp.options().layout;\n      this.qt.lt = null;\n      const n = t.getVisibleLogicalRange();\n      if (null === n) return;\n      const e = new Si(Math.floor(n.from), Math.ceil(n.to));\n      if (null === this.ge.data()[0]) return;\n      if (0 === this.qt.ot.length) return;\n      let r = NaN;\n      const h = Ke(t.options().barSpacing),\n        l = { _b: h, ub: h };\n      this.qt.lt = _n(this.qt.ot, e, !0);\n      for (let n = this.qt.lt.from; n < this.qt.lt.to; n++) {\n        const e = i[n];\n        e.time !== r && ((l._b = h), (l.ub = h), (r = e.time));\n        const o = this.qt.ot[n];\n        (o._t = a(t.logicalToCoordinate(e.time))),\n          void 0 !== e.text &&\n            e.text.length > 0 &&\n            (o.ri = { lb: e.text, _t: 0, ut: 0, Qi: 0, $t: 0 });\n        const _ = this.ge.dataByIndex(e.time, 0);\n        null !== _ && sr(o, e, _, l, s.fontSize, h, this.ge, this.Dp);\n      }\n      this.St = !1;\n    }\n  }\n  function er(t) {\n    return { ...$e, ...t };\n  }\n  class rr {\n    constructor(t) {\n      (this.sh = null),\n        (this.cb = []),\n        (this.Mb = []),\n        (this.bb = null),\n        (this.ge = null),\n        (this.Dp = null),\n        (this.xb = !0),\n        (this.Sb = null),\n        (this.Cb = null),\n        (this.Pb = null),\n        (this.yb = !0),\n        (this.Ps = er(t));\n    }\n    attached(t) {\n      this.kb(),\n        (this.Dp = t.chart),\n        (this.ge = t.series),\n        (this.sh = new nr(this.ge, a(this.Dp), this.Ps)),\n        (this.eb = t.requestUpdate),\n        this.ge.subscribeDataChanged((t) => this.Pg(t)),\n        (this.yb = !0),\n        this.UM();\n    }\n    UM() {\n      this.eb && this.eb();\n    }\n    detached() {\n      this.ge && this.bb && this.ge.unsubscribeDataChanged(this.bb),\n        (this.Dp = null),\n        (this.ge = null),\n        (this.sh = null),\n        (this.bb = null);\n    }\n    mb(t) {\n      (this.yb = !0),\n        (this.cb = t),\n        this.kb(),\n        (this.xb = !0),\n        (this.Cb = null),\n        this.UM();\n    }\n    Tb() {\n      return this.cb;\n    }\n    paneViews() {\n      return this.sh ? [this.sh] : [];\n    }\n    updateAllViews() {\n      this.Rb();\n    }\n    hitTest(t, i) {\n      return this.sh ? this.sh.renderer()?.Yn(t, i) ?? null : null;\n    }\n    autoscaleInfo(t, i) {\n      if (this.sh) {\n        const t = this.Db();\n        if (t) return { priceRange: null, margins: t };\n      }\n      return null;\n    }\n    hr(t) {\n      (this.Ps = er({ ...this.Ps, ...t })), this.UM && this.UM();\n    }\n    Db() {\n      const t = a(this.Dp).timeScale().options().barSpacing;\n      if (this.xb || t !== this.Pb) {\n        if (((this.Pb = t), this.cb.length > 0)) {\n          const i = Ke(t),\n            s = 1.5 * Ye(t) + 2 * i,\n            n = this.Eb();\n          this.Sb = {\n            above: Xe(s, n.aboveBar, n.inBar),\n            below: Xe(s, n.belowBar, n.inBar),\n          };\n        } else this.Sb = null;\n        this.xb = !1;\n      }\n      return this.Sb;\n    }\n    Eb() {\n      return (\n        null === this.Cb &&\n          (this.Cb = this.cb.reduce(\n            (t, i) => (t[i.position] || (t[i.position] = !0), t),\n            {\n              inBar: !1,\n              aboveBar: !1,\n              belowBar: !1,\n              atPriceTop: !1,\n              atPriceBottom: !1,\n              atPriceMiddle: !1,\n            },\n          )),\n        this.Cb\n      );\n    }\n    kb() {\n      if (!this.yb || !this.Dp || !this.ge) return;\n      const t = this.Dp.timeScale(),\n        i = this.ge?.data();\n      if (null == t.getVisibleLogicalRange() || !this.ge || 0 === i.length)\n        return void (this.Mb = []);\n      const s = t.timeToIndex(a(i[0].time), !0);\n      (this.Mb = this.cb.map((i, n) => {\n        const e = t.timeToIndex(i.time, !0),\n          r = e < s ? 1 : -1,\n          h = a(this.ge).dataByIndex(e, r),\n          l = {\n            time: t.timeToIndex(a(h).time, !1),\n            position: i.position,\n            shape: i.shape,\n            color: i.color,\n            id: i.id,\n            gb: n,\n            text: i.text,\n            size: i.size,\n            price: i.price,\n            Pw: i.time,\n          };\n        if (\n          'atPriceTop' === i.position ||\n          'atPriceBottom' === i.position ||\n          'atPriceMiddle' === i.position\n        ) {\n          if (void 0 === i.price)\n            throw new Error(`Price is required for position ${i.position}`);\n          return { ...l, position: i.position, price: i.price };\n        }\n        return { ...l, position: i.position, price: i.price };\n      })),\n        (this.yb = !1);\n    }\n    Rb(t) {\n      this.sh &&\n        (this.kb(), this.sh.mb(this.Mb), this.sh.wb(this.Ps), this.sh.yt(t));\n    }\n    Pg(t) {\n      (this.yb = !0), this.UM();\n    }\n  }\n  class hr extends Ue {\n    constructor(t, i, s) {\n      super(t, i), s && this.setMarkers(s);\n    }\n    setMarkers(t) {\n      this.ah.mb(t);\n    }\n    markers() {\n      return this.ah.Tb();\n    }\n  }\n  class ar {\n    constructor(t) {\n      (this.cb = new Map()), (this.Vb = t);\n    }\n    Bb(t, i, s) {\n      if ((this.Ib(i), void 0 !== s)) {\n        const n = window.setTimeout(() => {\n            this.cb.delete(i), this.Ab();\n          }, s),\n          e = { ...t, zb: n, Ob: Date.now() + s };\n        this.cb.set(i, e);\n      } else this.cb.set(i, { ...t, zb: void 0, Ob: void 0 });\n      this.Ab();\n    }\n    Ib(t) {\n      const i = this.cb.get(t);\n      i && void 0 !== i.zb && window.clearTimeout(i.zb),\n        this.cb.delete(t),\n        this.Ab();\n    }\n    Lb() {\n      for (const [t] of this.cb) this.Ib(t);\n    }\n    Nb() {\n      const t = Date.now(),\n        i = [];\n      for (const [s, n] of this.cb)\n        !n.Ob || n.Ob > t\n          ? i.push({ time: n.time, sign: n.sign, value: n.value })\n          : this.Ib(s);\n      return i;\n    }\n    Wb(t) {\n      this.Vb = t;\n    }\n    Ab() {\n      this.Vb && this.Vb();\n    }\n  }\n  const lr = {\n    positiveColor: '#22AB94',\n    negativeColor: '#F7525F',\n    updateVisibilityDuration: 5e3,\n  };\n  class or {\n    constructor(t, i, s, n) {\n      (this.qt = t), (this.Fb = i), (this.Hb = s), (this.Ub = n);\n    }\n    draw(t) {\n      t.useBitmapCoordinateSpace((t) => {\n        const i = t.context,\n          s = (Math.max(1, Math.floor(t.horizontalPixelRatio)) % 2) / 2,\n          n = 4 * t.verticalPixelRatio + s;\n        this.qt.forEach((e) => {\n          const r = Math.round(e._t * t.horizontalPixelRatio) + s;\n          i.beginPath();\n          const h = this.$b(e.jb);\n          (i.fillStyle = h),\n            i.arc(r, e.ut * t.verticalPixelRatio, n, 0, 2 * Math.PI, !1),\n            i.fill(),\n            e.jb &&\n              ((i.strokeStyle = h),\n              (i.lineWidth = Math.floor(2 * t.horizontalPixelRatio)),\n              i.beginPath(),\n              i.moveTo(\n                (e._t - 4.7) * t.horizontalPixelRatio + s,\n                (e.ut - 7 * e.jb) * t.verticalPixelRatio,\n              ),\n              i.lineTo(\n                e._t * t.horizontalPixelRatio + s,\n                (e.ut - 7 * e.jb - 7 * e.jb * 0.5) * t.verticalPixelRatio,\n              ),\n              i.lineTo(\n                (e._t + 4.7) * t.horizontalPixelRatio + s,\n                (e.ut - 7 * e.jb) * t.verticalPixelRatio,\n              ),\n              i.stroke());\n        });\n      });\n    }\n    $b(t) {\n      return 0 === t ? this.Fb : t > 0 ? this.Ub : this.Hb;\n    }\n  }\n  class _r {\n    constructor(t, i, s) {\n      (this.qt = []), (this.ge = t), (this.uh = i), (this.Ps = s);\n    }\n    yt(t) {\n      this.qt = t\n        .map((t) => {\n          const i = this.ge.priceToCoordinate(t.value);\n          if (null === i) return null;\n          return { _t: a(this.uh.timeToCoordinate(t.time)), ut: i, jb: t.sign };\n        })\n        .filter(v);\n    }\n    renderer() {\n      const t = (function (t, i) {\n        return (function (t, i) {\n          return 'Area' === i;\n        })(0, i)\n          ? t.lineColor\n          : t.color;\n      })(this.ge.options(), this.ge.seriesType());\n      return new or(this.qt, t, this.Ps.negativeColor, this.Ps.positiveColor);\n    }\n  }\n  function ur(t, i) {\n    return 'Line' === i || 'Area' === i;\n  }\n  class cr {\n    constructor(t) {\n      (this.Dp = void 0),\n        (this.ge = void 0),\n        (this.HM = []),\n        (this.o_ = null),\n        (this.qb = new Map()),\n        (this.Yb = new ar(() => this.UM())),\n        (this.Ps = { ...lr, ...t });\n    }\n    hr(t) {\n      (this.Ps = { ...this.Ps, ...t }), this.UM();\n    }\n    mb(t) {\n      this.Yb.Lb();\n      const i = this.o_;\n      i &&\n        t.forEach((t) => {\n          this.Yb.Bb(t, i.key(t.time));\n        });\n    }\n    Tb() {\n      return this.Yb.Nb();\n    }\n    UM() {\n      this.eb?.();\n    }\n    attached(t) {\n      const { chart: i, series: s, requestUpdate: n, horzScaleBehavior: e } = t;\n      (this.Dp = i), (this.ge = s), (this.o_ = e);\n      const r = this.ge.seriesType();\n      if ('Area' !== r && 'Line' !== r)\n        throw new Error(\n          'UpDownMarkersPrimitive is only supported for Area and Line series types',\n        );\n      (this.HM = [new _r(this.ge, this.Dp.timeScale(), this.Ps)]),\n        (this.eb = n),\n        this.UM();\n    }\n    detached() {\n      (this.Dp = void 0), (this.ge = void 0), (this.eb = void 0);\n    }\n    $p() {\n      return h(this.Dp);\n    }\n    Lo() {\n      return h(this.ge);\n    }\n    updateAllViews() {\n      this.HM.forEach((t) => t.yt(this.Tb()));\n    }\n    paneViews() {\n      return this.HM;\n    }\n    ht(t) {\n      if (!this.ge) throw new Error('Primitive not attached to series');\n      const i = this.ge.seriesType();\n      this.qb.clear();\n      const s = this.o_;\n      s &&\n        t.forEach((t) => {\n          js(t) && ur(0, i) && this.qb.set(s.key(t.time), t.value);\n        }),\n        h(this.ge).setData(t);\n    }\n    yt(t, i) {\n      if (!this.ge || !this.o_)\n        throw new Error('Primitive not attached to series');\n      const s = this.ge.seriesType(),\n        n = this.o_.key(t.time);\n      if (($s(t) && this.qb.delete(n), js(t) && ur(0, s))) {\n        const i = this.qb.get(n);\n        i &&\n          this.Yb.Bb(\n            { time: t.time, value: t.value, sign: dr(t.value, i) },\n            n,\n            this.Ps.updateVisibilityDuration,\n          );\n      }\n      h(this.ge).update(t, i);\n    }\n    Kb() {\n      this.Yb.Lb();\n    }\n  }\n  function dr(t, i) {\n    return t === i ? 0 : t - i > 0 ? 1 : -1;\n  }\n  class fr extends Ue {\n    setData(t) {\n      return this.ah.ht(t);\n    }\n    update(t, i) {\n      return this.ah.yt(t, i);\n    }\n    markers() {\n      return this.ah.Tb();\n    }\n    setMarkers(t) {\n      return this.ah.mb(t);\n    }\n    clearMarkers() {\n      return this.ah.Kb();\n    }\n  }\n  const pr = { ...t, color: '#2196f3' };\n  var vr = Object.freeze({\n    __proto__: null,\n    AreaSeries: ve,\n    BarSeries: Me,\n    BaselineSeries: de,\n    CandlestickSeries: Se,\n    get ColorType() {\n      return Vi;\n    },\n    get CrosshairMode() {\n      return $;\n    },\n    HistogramSeries: ye,\n    get LastPriceAnimationMode() {\n      return Di;\n    },\n    LineSeries: Qn,\n    get LineStyle() {\n      return s;\n    },\n    get LineType() {\n      return i;\n    },\n    get MismatchDirection() {\n      return Ct;\n    },\n    get PriceLineSource() {\n      return Ei;\n    },\n    get PriceScaleMode() {\n      return ci;\n    },\n    get TickMarkType() {\n      return Bi;\n    },\n    get TrackingModeExitMode() {\n      return Ri;\n    },\n    createChart: function (t, i) {\n      return Hn(t, new Ji(), Ji.ad(i));\n    },\n    createChartEx: Hn,\n    createImageWatermark: function (t, i, s) {\n      return new ke(t, new He(i, s));\n    },\n    createOptionsChart: function (t, i) {\n      return Hn(t, new he(), i);\n    },\n    createSeriesMarkers: function (t, i, s) {\n      const n = new hr(t, new rr(s ?? {}));\n      return i && n.setMarkers(i), n;\n    },\n    createTextWatermark: function (t, i) {\n      return new ke(t, new ze(i));\n    },\n    createUpDownMarkers: function (t, i = {}) {\n      return new fr(t, new cr(i));\n    },\n    createYieldCurveChart: function (t, i) {\n      const s = Fn(t);\n      return new ee(s, i);\n    },\n    customSeriesDefaultOptions: pr,\n    defaultHorzScaleBehavior: function () {\n      return Ji;\n    },\n    isBusinessDay: Ai,\n    isUTCTimestamp: zi,\n    version: function () {\n      return '5.0.8';\n    },\n  });\n  window.LightweightCharts = vr;\n})();\n";
