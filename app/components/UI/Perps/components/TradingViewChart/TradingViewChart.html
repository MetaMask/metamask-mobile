<!--
ATTRIBUTION NOTICE:
TradingView Lightweight Charts™
Copyright (с) 2025 TradingView, Inc. https://www.tradingview.com/

TradingView Chart HTML Template
==============================

This HTML file serves as the source template for the TradingView chart WebView component.
It contains the complete HTML structure, CSS styling, and JavaScript logic needed to 
render interactive financial charts with TPSL (Take Profit/Stop Loss) lines.

DEVELOPMENT WORKFLOW:
1. Edit this HTML file for readability and testing
2. Run the update script: `./scripts/update-tradingview-template.sh`
   2a. You may need to make the script executable: `chmod +x scripts/update-tradingview-template.sh`
3. The script will automatically update TradingViewChartTemplate.tsx
4. Test the changes in the React Native app

FEATURES:
- Interactive pan/zoom capabilities
- Real-time candle data updates
- TPSL price line visualization (Entry, TP, SL, Liquidation)
- Theme integration via template literals
- Price formatting with comma separators
- Responsive design for mobile devices

THEME VARIABLES:
- ${theme.colors.background.default} - Main background color
- ${theme.colors.text.muted} - Text color for labels
- ${theme.colors.border.muted} - Grid line colors

TPSL LINE COLORS:
- Entry: #CCC (Light Gray)
- Take Profit: #BAF24A (Green)
- Stop Loss: #484848 (Dark Gray)  
- Liquidation: #FF7584 (Red)
- Candle Up: #BAF24A (Green)
- Candle Down: #FF7584 (Red)

MESSAGE TYPES:
- SET_CANDLESTICK_DATA: Updates chart with new candle data
- ADD_AUXILIARY_LINES: Updates TPSL price lines
- UPDATE_INTERVAL: Handles time duration/period changes
- CHART_READY: Notifies React Native when chart is initialized

SECURITY ENHANCEMENT:
The production app now bundles the Lightweight Charts library locally instead of
loading from CDN to eliminate external dependencies and security risks.

MAINTENANCE:
- Keep this file in sync with TradingViewChartTemplate.tsx
- Use the provided script for automatic synchronization
- Test both files after making changes
-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>TradingView Chart</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            font-family: Arial, sans-serif;
            background: ${theme.colors.background.default};
        }
        
        #container {
            width: 100%;
            height: 100vh;
            position: relative;
            background: ${theme.colors.background.default};
        }
    </style>
</head>
<body>
    <div id="container"></div>

    <!-- Load Lightweight Charts Library (Local) -->
    <script>
        ${lightweightChartsLib}
    </script>
    <script>
        // Global variables
        window.chart = null;
        window.candlestickSeries = null;
        window.isInitialDataLoad = true; // Track if this is the first data load
        window.lastDataKey = null; // Track the last dataset to avoid unnecessary autoscaling
        window.visibleCandleCount = 45; // Default visible candle count
        window.allCandleData = []; // Store all loaded data for zoom functionality
        
        // Zoom limits - consistent with chart configuration
        window.ZOOM_LIMITS = {
            MIN_CANDLES: 10,  // Minimum candles visible when zoomed in
            MAX_CANDLES: 250, // Maximum candles visible when zoomed out
            DEFAULT_CANDLES: 45 // Default visible candles
        };
        
        // Performance optimization variables
        window.lastRangeChangeTime = 0;
        window.isUserPanning = false;
        window.panStartTime = 0;
        window.panEndTimeout = null;
        window.lastLogicalRange = null;
        window.panVelocity = 0;
        window.panningDisableTime = 300; // ms to disable zoom restrictions after panning stops
        
        // Reset prevention variables
        window.hasUserInteracted = false; // Track if user has ever interacted with the chart
        window.lastDataLength = 0; // Track actual data changes vs rerenders
        
        // Step 2: Create chart
        function createChart() {
            if (!window.LightweightCharts) {
                console.error('TradingView: Library not available');
                return;
            }
            
            try {
                // Create chart with theme applied via template literals
                window.chart = LightweightCharts.createChart(document.getElementById('container'), {
                    width: window.innerWidth,
                    height: window.innerHeight,
                    layout: {
                        background: {
                            color: '${theme.colors.background.default}',
                        },
                        textColor: '${theme.colors.text.muted}',
                        attributionLogo: false, // Hide the TradingView logo
                        // Performance optimizations
                        fontFamily: 'system-ui, -apple-system, sans-serif',
                    },
                    // Add performance optimizations for aggressive panning
                    autoSize: false, // Disable auto-resize for better performance
                    handleScroll: true,
                    handleScale: true,
                    // Disable smooth scrolling conflicts
                    kinetic: {
                        mouse: true,
                        touch: true,
                    },
                    localization: {
                        priceFormatter: (price) => {
                            // Format price with comma separators
                            return new Intl.NumberFormat('en-US', {
                                minimumFractionDigits: 2,
                                maximumFractionDigits: 2
                            }).format(price);
                        }
                    },
                    grid: {
                        vertLines: { color: '${theme.colors.border.muted}' },
                        horzLines: { color: '${theme.colors.border.muted}' },
                    },
                    timeScale: {
                        timeVisible: true,
                        secondsVisible: false,
                        borderColor: 'transparent',
                        // Optimized scroll and zoom handling for smooth panning
                        handleScale: {
                            axisPressedMouseMove: {
                                time: true, // Enable time scale dragging for smooth panning
                                price: true, // Allow price scale dragging
                            },
                            mouseWheel: true, // Enable mouse wheel zoom
                            pinch: true, // Enable pinch zoom on mobile
                        },
                        handleScroll: {
                            mouseWheel: true, // Enable mouse wheel scroll
                            pressedMouseMove: true, // Enable drag scroll (important for smooth panning)
                            horzTouchDrag: true, // Enable horizontal touch drag
                            vertTouchDrag: false, // Disable vertical touch drag
                        },
                        // Aggressive panning optimizations
                        shiftVisibleRangeOnNewBar: false, // Prevent automatic shifting
                        allowShiftVisibleRangeOnWhitespaceReplacement: false, // Prevent unexpected jumps
                        fixLeftEdge: false, // Allow free scrolling
                        fixRightEdge: false, // Allow free scrolling  
                        lockVisibleTimeRangeOnResize: true, // Maintain position on resize
                        rightBarStaysOnScroll: false, // Don't auto-follow latest data during scroll
                        uniformDistribution: false, // Allow natural time distribution
                        tickMarkFormatter: (time) => {
                            // Ultra-lightweight tick formatting
                            return new Date(time * 1000).toLocaleTimeString('en-US', { 
                                hour12: false, 
                                hour: '2-digit', 
                                minute: '2-digit' 
                            });
                        },
                    },
                    rightPriceScale: {
                        borderColor: 'transparent',
                    },
                    leftPriceScale: {
                        borderColor: 'transparent',
                    }
                });

                // Add interaction event listeners for smooth panning detection
                const container = document.getElementById('container');
                
                // Mouse-based panning detection
                container.addEventListener('mousedown', () => {
                    window.isUserPanning = true;
                    window.panStartTime = performance.now();
                    clearTimeout(window.panEndTimeout);
                }, { passive: true });
                
                container.addEventListener('mouseup', () => {
                    window.isUserPanning = false;
                    window.panEndTimeout = setTimeout(() => {
                        // Apply zoom restrictions after momentum scrolling settles
                        if (!window.isUserPanning) {
                            window.applyZoomRestrictionsIfNeeded();
                        }
                    }, window.panningDisableTime);
                }, { passive: true });
                
                // Touch-based panning detection
                container.addEventListener('touchstart', () => {
                    window.isUserPanning = true;
                    window.panStartTime = performance.now();
                    clearTimeout(window.panEndTimeout);
                }, { passive: true });
                
                container.addEventListener('touchend', () => {
                    window.isUserPanning = false;
                    window.panEndTimeout = setTimeout(() => {
                        // Apply zoom restrictions after momentum scrolling settles
                        if (!window.isUserPanning) {
                            window.applyZoomRestrictionsIfNeeded();
                        }
                    }, window.panningDisableTime);
                }, { passive: true });
                
                // Wheel-based interaction detection
                container.addEventListener('wheel', (e) => {
                    if (Math.abs(e.deltaX) > Math.abs(e.deltaY)) {
                        // Horizontal wheel scroll = panning
                        window.isUserPanning = true;
                        window.panStartTime = performance.now();
                        clearTimeout(window.panEndTimeout);
                        
                        window.panEndTimeout = setTimeout(() => {
                            window.isUserPanning = false;
                            window.applyZoomRestrictionsIfNeeded();
                        }, window.panningDisableTime);
                    }
                }, { passive: true });

                // Zoom restriction function
                window.applyZoomRestrictionsIfNeeded = function() {
                    if (window.isUserPanning) return;
                    
                    const logicalRange = window.chart.timeScale().getVisibleLogicalRange();
                    if (!logicalRange || !window.allCandleData || window.allCandleData.length === 0) {
                        return;
                    }
                    
                    const visibleCandleCount = Math.ceil(logicalRange.to - logicalRange.from);
                    
                    // Apply strict zoom limits when user is not actively panning
                    if (visibleCandleCount > window.ZOOM_LIMITS.MAX_CANDLES) {
                        const maxRange = window.ZOOM_LIMITS.MAX_CANDLES;
                        const centerPoint = (logicalRange.from + logicalRange.to) / 2;
                        const halfRange = maxRange / 2;
                        
                        window.chart.timeScale().setVisibleLogicalRange({
                            from: centerPoint - halfRange,
                            to: centerPoint + halfRange,
                        });
                    } else if (visibleCandleCount < window.ZOOM_LIMITS.MIN_CANDLES) {
                        const minRange = window.ZOOM_LIMITS.MIN_CANDLES;
                        const centerPoint = (logicalRange.from + logicalRange.to) / 2;
                        const halfRange = minRange / 2;
                        
                        window.chart.timeScale().setVisibleLogicalRange({
                            from: centerPoint - halfRange,
                            to: centerPoint + halfRange,
                        });
                    }
                    
                    // Update stored visible candle count
                    window.visibleCandleCount = visibleCandleCount;
                };

                // Lightweight zoom tracking - NO interference during panning
                window.chart.timeScale().subscribeVisibleLogicalRangeChange((logicalRange) => {
                    if (!logicalRange) return;
                    
                    // Simply track the current range - apply restrictions only when NOT panning
                    window.lastLogicalRange = logicalRange;
                    
                    // If user is actively panning, do NOTHING - let the chart scroll smoothly
                    if (window.isUserPanning) {
                        return;
                    }
                    
                    // Very minimal processing during non-panning - only track visible count
                    const visibleCandleCount = Math.ceil(logicalRange.to - logicalRange.from);
                    window.visibleCandleCount = visibleCandleCount;
                    
                    // Only apply restrictions on intentional zoom (significant changes when not panning)
                    const now = performance.now();
                    const timeSinceLastPan = now - window.panStartTime;
                    
                    // If it's been a while since panning and this looks like a zoom operation
                    if (timeSinceLastPan > window.panningDisableTime) {
                        const prevCount = window.visibleCandleCount || window.ZOOM_LIMITS.DEFAULT_CANDLES;
                        const countChange = Math.abs(visibleCandleCount - prevCount);
                        
                        // Only restrict on significant zoom changes (not minor adjustments)
                        if (countChange > 10) {
                            // Use debounced restriction application
                            setTimeout(() => {
                                if (!window.isUserPanning) {
                                    window.applyZoomRestrictionsIfNeeded();
                                }
                            }, 50);
                        }
                    }
                });
                
                // Track user interaction to prevent unwanted resets
                const originalSetVisibleRange = window.chart.timeScale().setVisibleRange;
                const originalSetVisibleLogicalRange = window.chart.timeScale().setVisibleLogicalRange;
                
                window.chart.timeScale().setVisibleRange = function(...args) {
                    // Mark user interaction when someone programmatically changes the view
                    // (but not when it's our internal functions doing it)
                    const isInternalCall = Error().stack.includes('applyZoom') || 
                                         Error().stack.includes('applyZoomRestrictionsIfNeeded');
                    if (!isInternalCall) {
                        window.hasUserInteracted = true;
                    }
                    return originalSetVisibleRange.apply(this, args);
                };
                
                window.chart.timeScale().setVisibleLogicalRange = function(...args) {
                    const isInternalCall = Error().stack.includes('applyZoom') || 
                                         Error().stack.includes('applyZoomRestrictionsIfNeeded');
                    if (!isInternalCall) {
                        window.hasUserInteracted = true;
                    }
                    return originalSetVisibleLogicalRange.apply(this, args);
                };

                // Notify React Native that chart is ready
                if (window.ReactNativeWebView) {
                    window.ReactNativeWebView.postMessage(JSON.stringify({
                        type: 'CHART_READY',
                        timestamp: new Date().toISOString()
                    }));
                } 
            } catch (error) {
                console.error('TradingView: Error creating chart:', error);
            }
        }
        
        // Create candlestick series when data is received
        window.createCandlestickSeries = function() {
            if (!window.chart || !window.LightweightCharts?.CandlestickSeries) return null;
            
            // Remove existing series if it exists
            if (window.candlestickSeries) {
                window.chart.removeSeries(window.candlestickSeries);
            }
            
            // Create new candlestick series
            window.candlestickSeries = window.chart.addSeries(window.LightweightCharts.CandlestickSeries, {
                upColor: '#BAF24A',
                downColor: '#FF7584',
                borderVisible: false,
                wickUpColor: '#BAF24A',
                wickDownColor: '#FF7584',
                priceLineColor: '#FFF',
                priceLineWidth: 1,
                lastValueVisible: true,
                title: 'Current',
            });

            return window.candlestickSeries;
        };
        
        // Handle window resize
        window.addEventListener('resize', function() {
            if (window.chart) {
                window.chart.applyOptions({
                    width: window.innerWidth,
                    height: window.innerHeight
                });
            }
        });
        
        // Store price lines for management
        window.priceLines = {
            entryPrice: null,
            liquidationPrice: null, 
            takeProfitPrice: null,
            stopLossPrice: null,
            currentPrice: null
        };

        // Apply zoom to specific candle count
        window.applyZoom = function(candleCount, forceReset = false) {
            if (!window.chart || !window.allCandleData || window.allCandleData.length === 0) {
                return;
            }
            
            // CRITICAL: Don't disrupt user if they've interacted, unless explicitly forced
            if (window.hasUserInteracted && !forceReset) {
                // Just update the stored count, don't change the view
                window.visibleCandleCount = Math.max(
                    window.ZOOM_LIMITS.MIN_CANDLES, 
                    Math.min(window.ZOOM_LIMITS.MAX_CANDLES, candleCount)
                );
                return;
            }
            
            // Only apply visual changes on initial load or explicit reset
            const minCandles = window.ZOOM_LIMITS.MIN_CANDLES;
            const maxCandles = window.ZOOM_LIMITS.MAX_CANDLES;
            const actualCandleCount = Math.max(minCandles, Math.min(maxCandles, candleCount));
            
            // Get the last N candles to display (most recent data)
            const startIndex = Math.max(0, window.allCandleData.length - actualCandleCount);
            const visibleData = window.allCandleData.slice(startIndex);
            
            if (window.candlestickSeries && visibleData.length > 0) {
                const firstTime = visibleData[0].time;
                const lastTime = visibleData[visibleData.length - 1].time;
                
                try {
                    window.chart.timeScale().setVisibleRange({
                        from: firstTime,
                        to: lastTime,
                    });
                } catch (error) {
                    console.error('TradingView: Error setting visible range:', error);
                    // Fallback to fit content if setVisibleRange fails
                    window.chart.timeScale().fitContent();
                }
            }
            
            window.visibleCandleCount = actualCandleCount;
        };
        
        // Update TPSL price lines
        window.updatePriceLines = function(lines) {
            if (!window.candlestickSeries) {
                return;
            }
            
            // Remove existing entry line if it exists
            if (window.priceLines.entryPrice) {
                try {
                    window.candlestickSeries.removePriceLine(window.priceLines.entryPrice);
                } catch (error) {
                    // Silent error handling
                    console.error('TradingView: Error removing entry line:', error);
                }
                window.priceLines.entryPrice = null;
            }
            
            // Create new entry line if price is valid
            if (lines.entryPrice && !isNaN(parseFloat(lines.entryPrice))) {
                try {
                    const priceLine = window.candlestickSeries.createPriceLine({
                        price: parseFloat(lines.entryPrice),
                        color: '#CCC', // Light Gray
                        lineWidth: 1,
                        lineStyle: 2, // Dashed
                        axisLabelVisible: true,
                        title: 'Entry'
                    });
                    
                    // Store reference for future removal
                    window.priceLines.entryPrice = priceLine;
                } catch (error) {
                    // Silent error handling
                }
            }
            
            // Remove existing take profit line if it exists
            if (window.priceLines.takeProfitPrice) {
                try {
                    window.candlestickSeries.removePriceLine(window.priceLines.takeProfitPrice);
                } catch (error) {
                    // Silent error handling
                    console.error('TradingView: Error removing take profit line:', error);
                }
                window.priceLines.takeProfitPrice = null;
            }
            
            // Create new take profit line if price is valid
            if (lines.takeProfitPrice && !isNaN(parseFloat(lines.takeProfitPrice))) {
                try {
                    const priceLine = window.candlestickSeries.createPriceLine({
                        price: parseFloat(lines.takeProfitPrice),
                        color: '#BAF24A', // Light Green
                        lineWidth: 1,
                        lineStyle: 2, // Dashed
                        axisLabelVisible: true,
                        title: 'TP'
                    });
                    window.priceLines.takeProfitPrice = priceLine;
                } catch (error) {
                    // Silent error handling
                    console.error('TradingView: Error creating take profit line:', error);
                }
            }
            
            // Remove existing stop loss line if it exists
            if (window.priceLines.stopLossPrice) {
                try {
                    window.candlestickSeries.removePriceLine(window.priceLines.stopLossPrice);
                } catch (error) {
                    // Silent error handling
                    console.error('TradingView: Error removing stop loss line:', error);
                }
                window.priceLines.stopLossPrice = null;
            }
            
            // Create new stop loss line if price is valid
            if (lines.stopLossPrice && !isNaN(parseFloat(lines.stopLossPrice))) {
                try {
                    const priceLine = window.candlestickSeries.createPriceLine({
                        price: parseFloat(lines.stopLossPrice),
                        color: '#484848', // Dark Gray
                        lineWidth: 1,
                        lineStyle: 2, // Dashed
                        axisLabelVisible: true,
                        title: 'SL'
                    });
                    
                    // Store reference for future removal
                    window.priceLines.stopLossPrice = priceLine;
                } catch (error) {
                    // Silent error handling
                    console.error('TradingView: Error creating stop loss line:', error);
                }
            }
            
            // Remove existing liquidation line if it exists
            if (window.priceLines.liquidationPrice) {
                try {
                    window.candlestickSeries.removePriceLine(window.priceLines.liquidationPrice);
                } catch (error) {
                    // Silent error handling
                }
                window.priceLines.liquidationPrice = null;
            }
            
            // Create new liquidation line if price is valid
            if (lines.liquidationPrice && !isNaN(parseFloat(lines.liquidationPrice))) {
                try {
                    const priceLine = window.candlestickSeries.createPriceLine({
                        price: parseFloat(lines.liquidationPrice),
                        color: '#FF7584', // Red
                        lineWidth: 1,
                        lineStyle: 2, // Dashed
                        axisLabelVisible: true,
                        title: 'Liq'
                    });
                    
                    // Store reference for future removal
                    window.priceLines.liquidationPrice = priceLine;
                } catch (error) {
                    // Silent error handling
                    console.error('TradingView: Error creating liquidation line:', error);
                }
            }
        };

        // Message handling from React Native
        window.addEventListener('message', function(event) {
            try {
                const message = JSON.parse(event.data);
                
                switch (message.type) {
                    case 'SET_CANDLESTICK_DATA':
                        if (window.chart && message.data?.length > 0) {
                            // Store all data for zoom functionality
                            window.allCandleData = message.data;
                            
                            // Update visible candle count from message if provided
                            if (message.visibleCandleCount) {
                                window.visibleCandleCount = message.visibleCandleCount;
                            }
                            
                            // Create or get candlestick series
                            if (!window.candlestickSeries) {
                                window.createCandlestickSeries();
                            }
                            
                            if (window.candlestickSeries) {
                                // Always set the full data to the series
                                window.candlestickSeries.setData(message.data);
                                
                                // Track data changes
                                const currentDataLength = message.data?.length || 0;
                                const isActualNewData = currentDataLength !== window.lastDataLength;
                                window.lastDataLength = currentDataLength;
                                
                                // Ultra-simple auto-scale logic: ONLY on initial load
                                const shouldAutoscale = window.isInitialDataLoad;

                                if (shouldAutoscale) {
                                    // Apply zoom ONLY on first time opening chart
                                    window.applyZoom(window.visibleCandleCount, true);
                                    console.log('📊 TradingView: Applied initial zoom to', window.visibleCandleCount, 'candles');
                                }

                                // Mark initial load as complete
                                window.isInitialDataLoad = false;
                            } else {
                                console.error('📊 TradingView: Failed to create candlestick series');
                            }
                        }
                        break;
                        
                    case 'ADD_AUXILIARY_LINES':
                        if (window.chart && message.lines) {
                            window.updatePriceLines(message.lines);
                        }
                        break;

                    case 'RESET_TO_DEFAULT':
                        // Reset chart to default state (like initial navigation)
                        if (window.chart && window.allCandleData && window.allCandleData.length > 0) {
                            window.visibleCandleCount = window.ZOOM_LIMITS.DEFAULT_CANDLES;
                            window.applyZoom(window.ZOOM_LIMITS.DEFAULT_CANDLES, true); // Force reset
                            console.log('📊 TradingView: Reset to default state - 45 candles');
                        }
                        break;
                        
                    case 'UPDATE_INTERVAL':
                        // Send confirmation back to React Native
                        if (window.ReactNativeWebView) {
                            window.ReactNativeWebView.postMessage(JSON.stringify({
                                type: 'INTERVAL_UPDATED',
                                duration: message.duration,
                                candlePeriod: message.candlePeriod,
                                candleCount: message.candleCount,
                                timestamp: new Date().toISOString()
                            }));
                        }
                        break;
                }
            } catch (error) {
                console.error('📊 TradingView: Message handling error:', error);
            }
        });
        
        // Also listen for React Native WebView messages
        document.addEventListener('message', function(event) {
            window.dispatchEvent(new MessageEvent('message', event));
        });
        
        // Start loading after a small delay
        // Library is already loaded via script tag, so start creating chart
        createChart();
    </script>
</body>
</html>