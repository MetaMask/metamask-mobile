#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const readline = require('readline');

/**
 * E2E Performance Comparison Tool
 * 
 * This script compares performance metrics across different E2E test runs.
 * It analyzes JSON files generated by the E2E performance metrics system
 * and provides detailed comparisons between baseline and current runs.
 * 
 * USAGE:
 *   node scripts/compare-e2e-performance.js [test-name] [options]
 * 
 * COMMANDS:
 *   <test-name>           Compare performance for specific test
 *   list                  List all available test results
 *   -h, --help           Show this help message
 *   (no param)            Compare all available tests
 * 
 * EXAMPLES:
 *   node scripts/compare-e2e-performance.js SampleFeature-counter-feature-tests
 *   node scripts/compare-e2e-performance.js list
 *   node scripts/compare-e2e-performance.js --help
 *   node scripts/compare-e2e-performance.js
 * 
 * OUTPUT:
 *   The comparison shows:
 *   - Individual metric changes (improvements/regressions)
 *   - Summary statistics (total/average duration changes)
 *   - Overall performance assessment
 *   - Percentage changes for each metric
 * 
 * FILE LOCATION:
 *   Performance results are stored in: e2e-performance-results/
 *   Files follow pattern: e2e-performance-{suite}-{test}-{timestamp}.json
 * 
 * DATA STRUCTURE:
 *   Each JSON file contains:
 *   {
 *     "suiteName": "MyFeature",
 *     "testName": "my-feature-tests", 
 *     "timestamp": "2024-01-01T00:00:00.000Z",
 *     "metrics": [
 *       {
 *         "name": "some-action",
 *         "startTime": 1704067200000,
 *         "endTime": 1704067200010,
 *         "duration": 10
 *       }
 *     ],
 *     "summary": {
 *       "totalDuration": 10,
 *       "averageDuration": 10,
 *       "metricCount": 1
 *     }
 *   }
 */

const RESULTS_DIR = path.join(process.cwd(), 'e2e-performance-results');

function showHelp() {
  console.log(`
ðŸŽ¯ E2E Performance Comparison Tool
${'='.repeat(60)}

This script compares performance metrics across different E2E test runs.
It analyzes JSON files generated by the E2E performance metrics system
and provides detailed comparisons between baseline and current runs.

USAGE:
  node scripts/compare-e2e-performance.js [test-name] [options]

COMMANDS:
  <test-name>           Compare performance for specific test
  list                  List all available test results
  -h, --help           Show this help message
  (no param)            Compare all available tests

EXAMPLES:
  node scripts/compare-e2e-performance.js SampleFeature-counter-feature-tests
  node scripts/compare-e2e-performance.js list
  node scripts/compare-e2e-performance.js --help
  node scripts/compare-e2e-performance.js

OUTPUT:
  The comparison shows:
  - Individual metric changes (improvements/regressions)
  - Summary statistics (total/average duration changes)
  - Overall performance assessment
  - Percentage changes for each metric

FILE LOCATION:
  Performance results are stored in: e2e-performance-results/
  Files follow pattern: e2e-performance-{suite}-{test}-{timestamp}.json

DATA STRUCTURE:
  Each JSON file contains:
  {
    "suiteName": "MyFeature",
    "testName": "my-feature-tests", 
    "timestamp": "2024-01-01T00:00:00.000Z",
    "metrics": [
      {
        "name": "some-action",
        "startTime": 1704067200000,
        "endTime": 1704067200010,
        "duration": 10
      }
    ],
    "summary": {
      "totalDuration": 10,
      "averageDuration": 10,
      "metricCount": 1
    }
  }

WORKFLOW:
  1. Run E2E tests with performance metrics collection
  2. Run tests again after making changes
  3. Use this script to compare the two runs
  4. Analyze improvements/regressions in performance

TROUBLESHOOTING:
  - No results found: Ensure E2E tests are generating performance files
  - Missing test name: Use 'list' command to see available test names
  - Insufficient data: Need at least 2 runs to compare
`);
}

function loadPerformanceResults() {
  if (!fs.existsSync(RESULTS_DIR)) {
    console.log('âŒ No performance results directory found');
    return [];
  }

  const files = fs.readdirSync(RESULTS_DIR)
    .filter(file => file.endsWith('.json'))
    .map(file => {
      const filePath = path.join(RESULTS_DIR, file);
      const content = fs.readFileSync(filePath, 'utf8');
      return JSON.parse(content);
    })
    .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

  return files;
}

function groupResultsByTest(results) {
  const groups = {};
  
  results.forEach(result => {
    const key = `${result.suiteName}-${result.testName}`;
    if (!groups[key]) {
      groups[key] = [];
    }
    groups[key].push(result);
  });

  return groups;
}

function compareResults(baseline, current) {
  const comparison = {
    suiteName: current.suiteName,
    testName: current.testName,
    baselineTimestamp: baseline.timestamp,
    currentTimestamp: current.timestamp,
    metrics: {},
    summary: {
      totalDurationChange: current.summary.totalDuration - baseline.summary.totalDuration,
      totalDurationPercentChange: ((current.summary.totalDuration - baseline.summary.totalDuration) / baseline.summary.totalDuration) * 100,
      averageDurationChange: current.summary.averageDuration - baseline.summary.averageDuration,
      averageDurationPercentChange: ((current.summary.averageDuration - baseline.summary.averageDuration) / baseline.summary.averageDuration) * 100,
    }
  };

  // Compare individual metrics
  const baselineMetrics = new Map(baseline.metrics.map(m => [m.name, m]));
  const currentMetrics = new Map(current.metrics.map(m => [m.name, m]));

  const allMetricNames = new Set([...baselineMetrics.keys(), ...currentMetrics.keys()]);

  allMetricNames.forEach(metricName => {
    const baselineMetric = baselineMetrics.get(metricName);
    const currentMetric = currentMetrics.get(metricName);

    if (baselineMetric && currentMetric) {
      const durationChange = currentMetric.duration - baselineMetric.duration;
      const percentChange = (durationChange / baselineMetric.duration) * 100;

      comparison.metrics[metricName] = {
        baseline: baselineMetric.duration,
        current: currentMetric.duration,
        change: durationChange,
        percentChange,
        status: percentChange < 0 ? 'IMPROVED' : percentChange > 0 ? 'REGRESSED' : 'UNCHANGED'
      };
    } else if (baselineMetric) {
      comparison.metrics[metricName] = {
        baseline: baselineMetric.duration,
        current: 'NOT_MEASURED',
        change: 'N/A',
        percentChange: 'N/A',
        status: 'REMOVED'
      };
    } else {
      comparison.metrics[metricName] = {
        baseline: 'NOT_MEASURED',
        current: currentMetric.duration,
        change: 'N/A',
        percentChange: 'N/A',
        status: 'ADDED'
      };
    }
  });

  return comparison;
}

function printComparison(comparison) {
  console.log('\n' + '='.repeat(80));
  console.log('ðŸ“Š E2E PERFORMANCE COMPARISON');
  console.log('='.repeat(80));
  console.log(`Suite: ${comparison.suiteName}`);
  console.log(`Test: ${comparison.testName}`);
  console.log(`Baseline: ${comparison.baselineTimestamp}`);
  console.log(`Current:  ${comparison.currentTimestamp}`);
  
  console.log('\nðŸ“ˆ SUMMARY CHANGES:');
  const totalChange = comparison.summary.totalDurationChange;
  const totalPercent = comparison.summary.totalDurationPercentChange;
  const avgChange = comparison.summary.averageDurationChange;
  const avgPercent = comparison.summary.averageDurationPercentChange;
  
  console.log(`   Total Duration: ${totalChange > 0 ? '+' : ''}${Math.round(totalChange)}ms (${totalPercent > 0 ? '+' : ''}${totalPercent.toFixed(2)}%)`);
  console.log(`   Average Duration: ${avgChange > 0 ? '+' : ''}${Math.round(avgChange)}ms (${avgPercent > 0 ? '+' : ''}${avgPercent.toFixed(2)}%)`);

  console.log('\nðŸ“Š INDIVIDUAL METRICS:');
  Object.entries(comparison.metrics).forEach(([metricName, metric]) => {
    // Use new icons: âš ï¸ for regression, âœ… for improvement, ðŸ‘Œ for unchanged
    const statusIcon = metric.status === 'IMPROVED' ? 'âœ…' : 
                      metric.status === 'REGRESSED' ? 'âš ï¸' : 
                      metric.status === 'UNCHANGED' ? 'ðŸ‘Œ' : 'â“';
    
    console.log(`${statusIcon} ${metricName}:`);
    console.log(`   Baseline: ${metric.baseline}ms`);
    console.log(`   Current:  ${metric.current}ms`);
    if (metric.change !== 'N/A') {
      console.log(`   Change:   ${metric.change > 0 ? '+' : ''}${Math.round(metric.change)}ms (${metric.percentChange > 0 ? '+' : ''}${metric.percentChange.toFixed(2)}%)`);
    }
    
    // Add status icon to the status line
    const statusIconInline = metric.status === 'IMPROVED' ? 'âœ…' : 
                            metric.status === 'REGRESSED' ? 'âš ï¸' : 
                            metric.status === 'UNCHANGED' ? 'ðŸ‘Œ' : 'â“';
    console.log(`   Status:   ${statusIconInline} ${metric.status}`);
    console.log('');
  });

  // Overall assessment
  const improvements = Object.values(comparison.metrics).filter(m => m.status === 'IMPROVED').length;
  const regressions = Object.values(comparison.metrics).filter(m => m.status === 'REGRESSED').length;
  const unchanged = Object.values(comparison.metrics).filter(m => m.status === 'UNCHANGED').length;
  
  console.log('ðŸŽ¯ OVERALL ASSESSMENT:');
  if (improvements > regressions && improvements > unchanged) {
    console.log(`âœ… PERFORMANCE IMPROVED: ${improvements} improvements vs ${regressions} regressions, ${unchanged} unchanged`);
  } else if (regressions > improvements && regressions > unchanged) {
    console.log(`âš ï¸ PERFORMANCE REGRESSED: ${regressions} regressions vs ${improvements} improvements, ${unchanged} unchanged`);
  } else {
    console.log(`ðŸ‘Œ PERFORMANCE UNCHANGED: ${unchanged} unchanged, ${improvements} improvements, ${regressions} regressions`);
  }

  console.log('='.repeat(80) + '\n');
}

function printAllTestsSummary(allComparisons) {
  console.log('\n' + '='.repeat(80));
  console.log('ðŸŽ¯ ALL TESTS PERFORMANCE SUMMARY');
  console.log('='.repeat(80));
  
  let totalTests = 0;
  let improvedTests = 0;
  let regressedTests = 0;
  let unchangedTests = 0;
  let totalDurationChange = 0;
  let totalBaselineDuration = 0;
  
  allComparisons.forEach(comparison => {
    totalTests++;
    totalDurationChange += comparison.summary.totalDurationChange;
    
    // Use the baseline data we stored
    totalBaselineDuration += comparison.baselineData.summary.totalDuration;
    
    const improvements = Object.values(comparison.metrics).filter(m => m.status === 'IMPROVED').length;
    const regressions = Object.values(comparison.metrics).filter(m => m.status === 'REGRESSED').length;
    const unchanged = Object.values(comparison.metrics).filter(m => m.status === 'UNCHANGED').length;
    
    if (improvements > regressions && improvements > unchanged) {
      improvedTests++;
    } else if (regressions > improvements && regressions > unchanged) {
      regressedTests++;
    } else {
      unchangedTests++;
    }
  });
  
  const overallPercentChange = totalBaselineDuration > 0 ? (totalDurationChange / totalBaselineDuration) * 100 : 0;
  
  console.log(`ðŸ“Š OVERALL SUMMARY:`);
  console.log(`   Total Tests Analyzed: ${totalTests}`);
  console.log(`   Tests Improved: ${improvedTests} âœ…`);
  console.log(`   Tests Regressed: ${regressedTests} âš ï¸`);
  console.log(`   Tests Unchanged: ${unchangedTests} ðŸ‘Œ`);
  console.log(`   Total Duration Change: ${totalDurationChange > 0 ? '+' : ''}${Math.round(totalDurationChange)}ms (${overallPercentChange > 0 ? '+' : ''}${overallPercentChange.toFixed(2)}%)`);
  
  console.log('\nðŸ“‹ TEST BREAKDOWN:');
  allComparisons.forEach(comparison => {
    const improvements = Object.values(comparison.metrics).filter(m => m.status === 'IMPROVED').length;
    const regressions = Object.values(comparison.metrics).filter(m => m.status === 'REGRESSED').length;
    const unchanged = Object.values(comparison.metrics).filter(m => m.status === 'UNCHANGED').length;
    
    let statusIcon = 'ðŸ‘Œ';
    if (improvements > regressions && improvements > unchanged) {
      statusIcon = 'âœ…';
    } else if (regressions > improvements && regressions > unchanged) {
      statusIcon = 'âš ï¸';
    }
    
    const totalChange = comparison.summary.totalDurationChange;
    const totalPercent = comparison.summary.totalDurationPercentChange;
    
    console.log(`   ${statusIcon} ${comparison.suiteName}-${comparison.testName}: ${totalChange > 0 ? '+' : ''}${Math.round(totalChange)}ms (${totalPercent > 0 ? '+' : ''}${totalPercent.toFixed(2)}%)`);
  });
  
  console.log('='.repeat(80) + '\n');
}

function compareAllTests() {
  const results = loadPerformanceResults();
  const groups = groupResultsByTest(results);
  const allComparisons = [];
  
  Object.entries(groups).forEach(([testKey, testResults]) => {
    if (testResults.length >= 2) {
      const baseline = testResults[1]; // Second most recent
      const current = testResults[0];  // Most recent
      const comparison = compareResults(baseline, current);
      // Add baseline data to comparison for summary calculations
      comparison.baselineData = baseline;
      allComparisons.push(comparison);
    }
  });
  
  if (allComparisons.length === 0) {
    console.log('âŒ No tests with sufficient data for comparison found');
    console.log('Need at least 2 runs for each test to compare');
    return;
  }
  
  // Print summary first
  printAllTestsSummary(allComparisons);
  
  // Print detailed comparisons for each test
  allComparisons.forEach(comparison => {
    printComparison(comparison);
  });
}

function interactiveListSelection() {
  const allResults = loadPerformanceResults();
  const allGroups = groupResultsByTest(allResults);
  const testKeys = Object.keys(allGroups);
  
  if (testKeys.length === 0) {
    console.log('âŒ No test results found');
    return;
  }

  let selectedIndex = 0;
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });

  // Hide cursor and enable raw mode for arrow key detection
  process.stdout.write('\x1B[?25l'); // Hide cursor
  
  function displayList() {
    // Clear screen and move cursor to top
    process.stdout.write('\x1B[2J\x1B[H');
    
    console.log('â”Œ' + 'â”€'.repeat(62) + 'â”');
    console.log('â”‚ ðŸ“‹ Select a test to compare (use â†‘â†“ arrows, Enter to select) â”‚');
    console.log('â””' + 'â”€'.repeat(62) + 'â”˜');
    console.log('');
    
    // Add "Compare All Tests" option at the top
    const isAllSelected = selectedIndex === 0;
    const allIndicator = isAllSelected ? 'â¯ ' : '  ';
    const allHighlight = isAllSelected ? '\x1B[7m' : ''; // Reverse colors for selected
    const resetColor = '\x1B[0m';
    console.log(`${allIndicator}${allHighlight}Compare All Tests${resetColor}`);
    console.log('');
    
    testKeys.forEach((testKey, index) => {
      const results = allGroups[testKey];
      const isSelected = index + 1 === selectedIndex; // +1 because of "Compare All Tests" option
      const indicator = isSelected ? 'â¯ ' : '  ';
      const highlight = isSelected ? '\x1B[7m' : ''; // Reverse colors for selected
      
      console.log(`${indicator}${highlight}${testKey}${resetColor}:`);
      
      // Always show the first test as BASELINE
      console.log(`    ${results[0].timestamp} (${results[0].summary.totalDuration}ms total) - BASELINE`);
      // If there are more tests, show the last one as LATEST
      if (results.length > 1) {
        const latest = results[results.length - 1];
        console.log(`    ${latest.timestamp} (${latest.summary.totalDuration}ms total) - LATEST`);
      }
      console.log('');
    });
    
    // Add "Quit" option at the bottom
    const isQuitSelected = selectedIndex === testKeys.length + 1; // +1 for "Compare All Tests"
    const quitIndicator = isQuitSelected ? 'â¯ ' : '  ';
    const quitHighlight = isQuitSelected ? '\x1B[7m' : ''; // Reverse colors for selected
    console.log(`${quitIndicator}${quitHighlight}Quit (q)${resetColor}`);
  }

  function handleKeypress(str, key) {
    const totalOptions = testKeys.length + 2; // +1 for "Compare All Tests", +1 for "Quit"
    
    if (key.name === 'up' && selectedIndex > 0) {
      selectedIndex--;
      displayList();
    } else if (key.name === 'down' && selectedIndex < totalOptions - 1) {
      selectedIndex++;
      displayList();
    } else if (key.name === 'return' || key.name === 'enter') {
      if (selectedIndex === 0) {
        // "Compare All Tests" selected
        // Clean up temporarily
        process.stdout.write('\x1B[?25h'); // Show cursor
        process.stdin.setRawMode(false);
        process.stdin.pause();
        
        // Run comparison for all tests
        compareAllTests();
        
        // Wait for user to press any key to return to list
        console.log('\nPress any key to return to the list...');
        process.stdin.setRawMode(true);
        process.stdin.resume();
        process.stdin.once('data', () => {
          displayList();
          process.stdout.write('\x1B[?25l'); // Hide cursor again
        });
      } else if (selectedIndex === testKeys.length + 1) {
        // "Quit" selected
        process.stdout.write('\x1B[?25h'); // Show cursor
        process.stdin.setRawMode(false);
        process.stdin.pause();
        rl.close();
        process.exit(0);
      } else {
        // Specific test selected
        const testIndex = selectedIndex - 1; // -1 because of "Compare All Tests" option
        const selectedTestKey = testKeys[testIndex];
        const testResults = allGroups[selectedTestKey];
        
        if (testResults.length < 2) {
          // Clean up temporarily
          process.stdout.write('\x1B[?25h'); // Show cursor
          process.stdin.setRawMode(false);
          process.stdin.pause();
          
          // Display test values for single run
          console.log('\n' + '='.repeat(80));
          console.log('ðŸ“Š TEST VALUES (No comparison possible - only baseline available)');
          console.log('='.repeat(80));
          console.log(`Suite: ${testResults[0].suiteName}`);
          console.log(`Test: ${testResults[0].testName}`);
          console.log(`Timestamp: ${testResults[0].timestamp}`);
          
          console.log('\nðŸ“ˆ SUMMARY:');
          console.log(`   Total Duration: ${testResults[0].summary.totalDuration}ms`);
          console.log(`   Average Duration: ${testResults[0].summary.averageDuration}ms`);
          console.log(`   Metric Count: ${testResults[0].summary.metricCount}`);
          
          console.log('\nðŸ“Š INDIVIDUAL METRICS:');
          testResults[0].metrics.forEach(metric => {
            console.log(`   ${metric.name}: ${metric.duration}ms`);
          });
          
          console.log('='.repeat(80));
          
          // Wait for user to press any key to return to list
          console.log('\nPress any key to return to the list...');
          process.stdin.setRawMode(true);
          process.stdin.resume();
          process.stdin.once('data', () => {
            displayList();
            process.stdout.write('\x1B[?25l'); // Hide cursor again
          });
          return;
        }
        
        // Clean up temporarily
        process.stdout.write('\x1B[?25h'); // Show cursor
        process.stdin.setRawMode(false);
        process.stdin.pause();
        
        // Run comparison for selected test
        const baseline = testResults[1]; // Second most recent
        const current = testResults[0];  // Most recent
        const comparison = compareResults(baseline, current);
        printComparison(comparison);
        
        // Wait for user to press any key to return to list
        console.log('\nPress any key to return to the list...');
        process.stdin.setRawMode(true);
        process.stdin.resume();
        process.stdin.once('data', () => {
          displayList();
          process.stdout.write('\x1B[?25l'); // Hide cursor again
        });
      }
    } else if (key.ctrl && key.name === 'c') {
      // Clean up and exit
      process.stdout.write('\x1B[?25h'); // Show cursor
      process.stdin.setRawMode(false);
      process.stdin.pause();
      rl.close();
      process.exit(0);
    } else if (key.name === 'q' || key.name === 'Q') {
      // Quit with 'q' key
      process.stdout.write('\x1B[?25h'); // Show cursor
      process.stdin.setRawMode(false);
      process.stdin.pause();
      rl.close();
      process.exit(0);
    }
  }

  // Set up keypress handling
  process.stdin.setRawMode(true);
  process.stdin.resume();
  process.stdin.on('data', (data) => {
    const key = {
      name: '',
      ctrl: false
    };
    
    // Parse arrow keys and other special keys
    if (data[0] === 27 && data[1] === 91) {
      if (data[2] === 65) key.name = 'up';
      else if (data[2] === 66) key.name = 'down';
    } else if (data[0] === 13) {
      key.name = 'enter';
    } else if (data[0] === 3) {
      key.ctrl = true;
      key.name = 'c';
    } else if (data[0] === 113 || data[0] === 81) { // 'q' or 'Q'
      key.name = data[0] === 113 ? 'q' : 'Q';
    }
    
    handleKeypress(data.toString(), key);
  });

  // Initial display
  displayList();
}

function main() {
  const args = process.argv.slice(2);
  const command = args[0];

  // Handle help flags
  if (command === '-h' || command === '--help') {
    showHelp();
    return;
  }

  // If no command provided, compare all tests
  if (!command) {
    compareAllTests();
    return;
  }

  // Check if it's a known command
  if (command === 'list') {
    interactiveListSelection();
    return;
  }

  // If not a known command, treat as test name
  const testName = command;
  const results = loadPerformanceResults();
  const groups = groupResultsByTest(results);
  const testKey = Object.keys(groups).find(key => key.includes(testName));

  if (!testKey || groups[testKey].length < 2) {
    console.log(`âŒ Need at least 2 runs for test: ${testName}`);
    console.log(`Available tests: ${Object.keys(groups).join(', ')}`);
    console.log('Use "node scripts/compare-e2e-performance.js list" to see available test names');
    console.log('Or run "node scripts/compare-e2e-performance.js" to compare all tests');
    return;
  }

  const testResults = groups[testKey];
  const baseline = testResults[1]; // Second most recent
  const current = testResults[0];  // Most recent

  const comparison = compareResults(baseline, current);
  printComparison(comparison);
}

if (require.main === module) {
  main();
} 