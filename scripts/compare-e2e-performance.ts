#!/usr/bin/env node

import * as fs from 'fs';
import * as path from 'path';
import * as readline from 'readline';

/**
 * Represents a single performance measurement
 */
interface PerformanceMetric {
  eventName?: string;
  name?: string;
  startTime?: number;
  endTime?: number;
  duration?: number;
  timestamp?: number;
  metadata?: Record<string, unknown>;
}

/**
 * Summary statistics for a performance test run
 */
interface PerformanceSummary {
  totalDuration: number;
  averageDuration: number;
  metricCount: number;
}

/**
 * Complete performance test result from a single run
 */
interface PerformanceResult {
  suiteName: string;
  testName: string;
  timestamp: string;
  metrics: PerformanceMetric[];
  summary: PerformanceSummary;
  session?: {
    sessionId: string;
    startTime: number;
    environment: {
      branch: string;
      commitHash: string;
      platform: string;
      appVersion: string;
    };
  };
}

/**
 * Comparison result for a single metric
 */
interface MetricComparison {
  baseline: number | string;
  latest: number | string;
  change: number | string;
  percentChange: number | string;
  status: 'IMPROVED' | 'REGRESSED' | 'UNCHANGED' | 'ADDED' | 'REMOVED';
}

/**
 * Summary of changes across all metrics
 */
interface ComparisonSummary {
  totalDurationChange: number;
  totalDurationPercentChange: number;
  averageDurationChange: number;
  averageDurationPercentChange: number;
}

/**
 * Complete comparison between baseline and latest test runs
 */
interface PerformanceComparison {
  suiteName: string;
  testName: string;
  baselineTimestamp: string;
  latestTimestamp: string;
  metrics: Record<string, MetricComparison>;
  summary: ComparisonSummary;
  baselineData?: PerformanceResult;
}

/**
 * Aggregated metrics data for comparison
 */
interface AggregatedMetrics {
  totalDuration: number;
  averageDuration: number;
  count: number;
}

// Constants
const RESULTS_DIR = path.join(process.cwd(), 'e2e-performance-results');
const DECIMAL_PLACES = 3;
const SEPARATOR_LENGTH = 80;

/**
 * Display comprehensive help information
 */
function showHelp(): void {
  console.log(`
ðŸŽ¯ E2E Performance Comparison Tool
${'='.repeat(60)}

This script compares performance metrics across different E2E test runs.
It analyzes JSON files generated by the E2E performance metrics system
and provides detailed comparisons between baseline and current runs.

USAGE:
  node scripts/compare-e2e-performance.js [test-name] [options]

COMMANDS:
  (no param)            Compare all available tests results
  list                  List all available test results
  <test-name>           Compare performance for specific test
  -h, --help            Show this help message

EXAMPLES:
  node scripts/compare-e2e-performance.js
  node scripts/compare-e2e-performance.js list
  node scripts/compare-e2e-performance.js SampleFeature-counter-feature-tests
  node scripts/compare-e2e-performance.js --help

OUTPUT:
  The comparison shows:
  - Individual metric changes (improvements/regressions)
  - Summary statistics (total/average duration changes)
  - Overall performance assessment
  - Percentage changes for each metric

FILE LOCATION:
  Performance results are stored in: e2e-performance-results/
  Files follow pattern: e2e-performance-{suite}-{test}-{timestamp}.json

DATA STRUCTURE:
  Each JSON file contains:
  {
    "suiteName": "MyFeature",
    "testName": "my-feature-tests", 
    "timestamp": "2024-01-01T00:00:00.000Z",
    "metrics": [
      {
        "eventName": "some-action",
        "timestamp": 1704067200000,
        "duration": 10,
        "metadata": {}
      }
    ],
    "summary": {
      "totalDuration": 10,
      "averageDuration": 10,
      "metricCount": 1
    },
    "session": {
      "sessionId": "uuid",
      "startTime": 1704067200000,
      "environment": {
        "branch": "main",
        "commitHash": "abc123",
        "platform": "ios",
        "appVersion": "1.0.0"
      }
    }
  }

WORKFLOW:
  1. Run E2E tests with Redux performance metrics collection
  2. Run tests again after making changes
  3. Use this script to compare the two runs
  4. Analyze improvements/regressions in performance

TROUBLESHOOTING:
  - No results found: Ensure E2E tests are generating performance files
  - Missing test name: Use 'list' command to see available test names
  - Insufficient data: Need at least 2 runs to compare
`);
}

/**
 * Load and parse all performance result files from the results directory
 * @returns Array of parsed performance results, sorted by timestamp (newest first)
 */
function loadPerformanceResults(): PerformanceResult[] {
  if (!fs.existsSync(RESULTS_DIR)) {
    console.log('âŒ No performance results directory found');
    return [];
  }

  const files = fs.readdirSync(RESULTS_DIR)
    .filter(file => file.endsWith('.json'))
    .map(file => {
      const filePath = path.join(RESULTS_DIR, file);
      const content = fs.readFileSync(filePath, 'utf8');
      return JSON.parse(content) as PerformanceResult;
    })
    .sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());

  return files;
}

/**
 * Group performance results by test name
 * @param results Array of performance results
 * @returns Object mapping test keys to arrays of results
 */
function groupResultsByTest(results: PerformanceResult[]): Record<string, PerformanceResult[]> {
  const groups: Record<string, PerformanceResult[]> = {};
  
  results.forEach(result => {
    const key = `${result.suiteName}-${result.testName}`;
    if (!groups[key]) {
      groups[key] = [];
    }
    groups[key].push(result);
  });

  return groups;
}

/**
 * Group metrics by name and calculate aggregated statistics
 * @param metrics Array of performance metrics
 * @returns Map of metric names to aggregated data
 */
function aggregateMetricsByName(metrics: PerformanceMetric[]): Map<string, AggregatedMetrics> {
  const metricsByName = new Map<string, PerformanceMetric[]>();
  
  // Group metrics by name
  metrics.forEach(metric => {
    const name = metric.eventName || metric.name || 'unknown';
    if (!metricsByName.has(name)) {
      metricsByName.set(name, []);
    }
    metricsByName.get(name)!.push(metric);
  });

  // Calculate aggregated values
  const aggregated = new Map<string, AggregatedMetrics>();
  metricsByName.forEach((metricGroup, name) => {
    const totalDuration = metricGroup.reduce((sum, m) => sum + (m.duration || 0), 0);
    aggregated.set(name, {
      totalDuration,
      averageDuration: totalDuration / metricGroup.length,
      count: metricGroup.length
    });
  });

  return aggregated;
}

/**
 * Compare two performance test runs and generate detailed comparison
 * @param baseline The baseline (older) test result
 * @param latest The latest (newer) test result
 * @returns Detailed comparison between the two runs
 */
function compareResults(baseline: PerformanceResult, latest: PerformanceResult): PerformanceComparison {
  // Aggregate metrics by name for both runs
  const baselineAggregated = aggregateMetricsByName(baseline.metrics);
  const latestAggregated = aggregateMetricsByName(latest.metrics);

  // Calculate total aggregated values for summary
  const baselineTotalDuration = Array.from(baselineAggregated.values()).reduce((sum, agg) => sum + agg.totalDuration, 0);
  const latestTotalDuration = Array.from(latestAggregated.values()).reduce((sum, agg) => sum + agg.totalDuration, 0);
  const baselineTotalCount = Array.from(baselineAggregated.values()).reduce((sum, agg) => sum + agg.count, 0);
  const latestTotalCount = Array.from(latestAggregated.values()).reduce((sum, agg) => sum + agg.count, 0);
  const baselineAverageDuration = baselineTotalCount > 0 ? baselineTotalDuration / baselineTotalCount : 0;
  const latestAverageDuration = latestTotalCount > 0 ? latestTotalDuration / latestTotalCount : 0;

  const comparison: PerformanceComparison = {
    suiteName: latest.suiteName,
    testName: latest.testName,
    baselineTimestamp: baseline.timestamp,
    latestTimestamp: latest.timestamp,
    metrics: {},
    summary: {
      totalDurationChange: Number((latestTotalDuration - baselineTotalDuration).toFixed(DECIMAL_PLACES)),
      totalDurationPercentChange: Number((baselineTotalDuration > 0 ? ((latestTotalDuration - baselineTotalDuration) / baselineTotalDuration * 100) : 0).toFixed(DECIMAL_PLACES)),
      averageDurationChange: Number((latestAverageDuration - baselineAverageDuration).toFixed(DECIMAL_PLACES)),
      averageDurationPercentChange: Number((baselineAverageDuration > 0 ? ((latestAverageDuration - baselineAverageDuration) / baselineAverageDuration * 100) : 0).toFixed(DECIMAL_PLACES)),
    }
  };

  // Compare aggregated metrics
  const allMetricNames = new Set([...baselineAggregated.keys(), ...latestAggregated.keys()]);

  allMetricNames.forEach(metricName => {
    const baselineAgg = baselineAggregated.get(metricName);
    const latestAgg = latestAggregated.get(metricName);

    if (baselineAgg && latestAgg) {
      const durationChange = Number((latestAgg.totalDuration - baselineAgg.totalDuration).toFixed(DECIMAL_PLACES));
      const percentChange = Number((baselineAgg.totalDuration > 0 ? (durationChange / baselineAgg.totalDuration) * 100 : 0).toFixed(DECIMAL_PLACES));

      // Determine performance status
      let status: 'IMPROVED' | 'REGRESSED' | 'UNCHANGED';
      if (baselineAgg.totalDuration === 0 && latestAgg.totalDuration > 0) {
        status = 'REGRESSED'; // Going from 0 to some duration is a regression
      } else if (baselineAgg.totalDuration > 0 && latestAgg.totalDuration === 0) {
        status = 'IMPROVED'; // Going from some duration to 0 is an improvement
      } else if (percentChange < 0) {
        status = 'IMPROVED';
      } else if (percentChange > 0) {
        status = 'REGRESSED';
      } else {
        status = 'UNCHANGED';
      }

      comparison.metrics[metricName] = {
        baseline: baselineAgg.totalDuration,
        latest: latestAgg.totalDuration,
        change: durationChange,
        percentChange,
        status
      };
    } else if (baselineAgg) {
      comparison.metrics[metricName] = {
        baseline: baselineAgg.totalDuration,
        latest: 'NOT_MEASURED',
        change: 'N/A',
        percentChange: 'N/A',
        status: 'REMOVED'
      };
    } else {
      comparison.metrics[metricName] = {
        baseline: 'NOT_MEASURED',
        latest: latestAgg!.totalDuration,
        change: 'N/A',
        percentChange: 'N/A',
        status: 'REGRESSED'
      };
    }
  });

  return comparison;
}

/**
 * Format percentage change for display
 * @param percent The percentage value
 * @returns Formatted percentage string
 */
function formatPercentChange(percent: number): string {
  return isFinite(percent) ? `${percent > 0 ? '+' : ''}${percent.toFixed(DECIMAL_PLACES)}%` : 'N/A%';
}

/**
 * Get status icon for a metric
 * @param status The performance status
 * @returns Unicode icon representing the status
 */
function getStatusIcon(status: string): string {
  switch (status) {
    case 'IMPROVED': return 'âœ…';
    case 'REGRESSED': return 'âš ï¸';
    case 'UNCHANGED': return 'ðŸ‘Œ';
    default: return 'â“';
  }
}

/**
 * Print detailed comparison results for a single test
 * @param comparison The comparison data to display
 */
function printComparison(comparison: PerformanceComparison): void {
  console.log('\n' + '='.repeat(SEPARATOR_LENGTH));
  console.log('ðŸ“Š E2E PERFORMANCE COMPARISON');
  console.log('='.repeat(SEPARATOR_LENGTH));
  console.log(`Suite: ${comparison.suiteName}`);
  console.log(`Test: ${comparison.testName}`);
  console.log(`Baseline: ${comparison.baselineTimestamp}`);
  console.log(`Latest:   ${comparison.latestTimestamp}`);
  
  // Display summary changes
  console.log('\nðŸ“ˆ SUMMARY CHANGES:');
  const { totalDurationChange, totalDurationPercentChange, averageDurationChange, averageDurationPercentChange } = comparison.summary;
  
  console.log(`   Total Duration: ${totalDurationChange > 0 ? '+' : ''}${totalDurationChange.toFixed(DECIMAL_PLACES)}ms (${formatPercentChange(totalDurationPercentChange)})`);
  console.log(`   Average Duration: ${averageDurationChange > 0 ? '+' : ''}${averageDurationChange.toFixed(DECIMAL_PLACES)}ms (${formatPercentChange(averageDurationPercentChange)})`);

  // Display individual metrics
  console.log('\nðŸ“Š INDIVIDUAL METRICS:');
  Object.entries(comparison.metrics).forEach(([metricName, metric]) => {
    const statusIcon = getStatusIcon(metric.status);
    
    console.log(`${statusIcon} ${metricName}:`);
    console.log(`   Baseline: ${typeof metric.baseline === 'number' ? metric.baseline.toFixed(DECIMAL_PLACES) + 'ms' : 'Not measured'}`);
    console.log(`   Latest:   ${typeof metric.latest === 'number' ? metric.latest.toFixed(DECIMAL_PLACES) + 'ms' : 'Not measured'}`);
    
    if (metric.change !== 'N/A') {
      const change = metric.change as number;
      const percentChange = metric.percentChange as number;
      console.log(`   Change:   ${change > 0 ? '+' : ''}${change.toFixed(DECIMAL_PLACES)}ms (${formatPercentChange(percentChange)})`);
    }
    
    console.log(`   Status:   ${statusIcon} ${metric.status}`);
    console.log('');
  });

  // Overall assessment based on summary changes
  console.log('ðŸŽ¯ OVERALL ASSESSMENT:');
  if (totalDurationChange < 0 && averageDurationChange < 0) {
    console.log(`âœ… PERFORMANCE IMPROVED: Total duration decreased by ${Math.abs(totalDurationChange).toFixed(DECIMAL_PLACES)}ms, average decreased by ${Math.abs(averageDurationChange).toFixed(DECIMAL_PLACES)}ms`);
  } else if (totalDurationChange > 0 && averageDurationChange > 0) {
    console.log(`âš ï¸ PERFORMANCE REGRESSED: Total duration increased by ${totalDurationChange.toFixed(DECIMAL_PLACES)}ms, average increased by ${averageDurationChange.toFixed(DECIMAL_PLACES)}ms`);
  } else {
    console.log(`ðŸ‘Œ PERFORMANCE MIXED: Total duration ${totalDurationChange > 0 ? 'increased' : 'decreased'} by ${Math.abs(totalDurationChange).toFixed(DECIMAL_PLACES)}ms, average ${averageDurationChange > 0 ? 'increased' : 'decreased'} by ${Math.abs(averageDurationChange).toFixed(DECIMAL_PLACES)}ms`);
  }

  console.log('='.repeat(SEPARATOR_LENGTH) + '\n');
}

/**
 * Print summary of all test comparisons
 * @param allComparisons Array of all test comparisons
 */
function printAllTestsSummary(allComparisons: PerformanceComparison[]): void {
  console.log('\n' + '='.repeat(SEPARATOR_LENGTH));
  console.log('ðŸŽ¯ ALL TESTS PERFORMANCE SUMMARY');
  console.log('='.repeat(SEPARATOR_LENGTH));
  
  let totalTests = 0;
  let improvedTests = 0;
  let regressedTests = 0;
  let unchangedTests = 0;
  let totalDurationChange = 0;
  let totalBaselineDuration = 0;
  
  allComparisons.forEach(comparison => {
    totalTests++;
    totalDurationChange += comparison.summary.totalDurationChange;
    totalBaselineDuration += comparison.baselineData!.summary.totalDuration;
    
    // Determine test status based on summary changes
    const { totalDurationChange: testChange, averageDurationChange: avgChange } = comparison.summary;
    if (testChange < 0 && avgChange < 0) {
      improvedTests++;
    } else if (testChange > 0 && avgChange > 0) {
      regressedTests++;
    } else {
      unchangedTests++;
    }
  });
  
  const overallPercentChange = totalBaselineDuration > 0 ? (totalDurationChange / totalBaselineDuration) * 100 : 0;
  
  console.log(`ðŸ“Š OVERALL SUMMARY:`);
  console.log(`   Total Tests Analyzed: ${totalTests}`);
  console.log(`   Tests Improved: ${improvedTests} âœ…`);
  console.log(`   Tests Regressed: ${regressedTests} âš ï¸`);
  console.log(`   Tests Unchanged: ${unchangedTests} ðŸ‘Œ`);
  console.log(`   Total Duration Change: ${totalDurationChange > 0 ? '+' : ''}${totalDurationChange.toFixed(DECIMAL_PLACES)}ms (${formatPercentChange(overallPercentChange)})`);
  
  console.log('\nðŸ“‹ TEST BREAKDOWN:');
  allComparisons.forEach(comparison => {
    const { totalDurationChange: testChange, totalDurationPercentChange: testPercent } = comparison.summary;
    
    // Determine status icon based on summary changes
    let statusIcon = 'ðŸ‘Œ';
    if (testChange < 0) {
      statusIcon = 'âœ…';
    } else if (testChange > 0) {
      statusIcon = 'âš ï¸';
    }
    
    console.log(`   ${statusIcon} ${comparison.suiteName}-${comparison.testName}: ${testChange > 0 ? '+' : ''}${testChange.toFixed(DECIMAL_PLACES)}ms (${formatPercentChange(testPercent)})`);
  });
  
  console.log('='.repeat(SEPARATOR_LENGTH) + '\n');
}

/**
 * Compare all available tests and display results
 */
function compareAllTests(): void {
  const results = loadPerformanceResults();
  const groups = groupResultsByTest(results);
  const allComparisons: PerformanceComparison[] = [];
  
  Object.entries(groups).forEach(([testKey, testResults]) => {
    if (testResults.length >= 2) {
      const baseline = testResults[testResults.length - 1]; // Oldest result
      const latest = testResults[0];  // Newest result
      const comparison = compareResults(baseline, latest);
      comparison.baselineData = baseline;
      allComparisons.push(comparison);
    }
  });
  
  if (allComparisons.length === 0) {
    console.log('âŒ No tests with sufficient data for comparison found');
    console.log('Need at least 2 runs for each test to compare');
    return;
  }
  
  // Print summary first, then detailed comparisons
  printAllTestsSummary(allComparisons);
  allComparisons.forEach(comparison => {
    printComparison(comparison);
  });
}

/**
 * Display single test result when no comparison is possible
 * @param testResult The single test result to display
 */
function displaySingleTestResult(testResult: PerformanceResult): void {
  console.log('\n' + '='.repeat(SEPARATOR_LENGTH));
  console.log('ðŸ“Š TEST VALUES (No comparison possible - only baseline available)');
  console.log('='.repeat(SEPARATOR_LENGTH));
  console.log(`Suite: ${testResult.suiteName}`);
  console.log(`Test: ${testResult.testName}`);
  console.log(`Timestamp: ${testResult.timestamp}`);
  
  console.log('\nðŸ“ˆ SUMMARY:');
  console.log(`   Total Duration: ${testResult.summary.totalDuration.toFixed(DECIMAL_PLACES)}ms`);
  console.log(`   Average Duration: ${testResult.summary.averageDuration.toFixed(DECIMAL_PLACES)}ms`);
  console.log(`   Metric Count: ${testResult.summary.metricCount}`);
  
  console.log('\nðŸ“Š INDIVIDUAL METRICS:');
  testResult.metrics.forEach(metric => {
    const metricName = metric.eventName || metric.name;
    const duration = metric.duration || 0;
    console.log(`   ${metricName}: ${duration.toFixed(DECIMAL_PLACES)}ms`);
  });
  
  console.log('='.repeat(SEPARATOR_LENGTH));
}

/**
 * Interactive test selection interface
 */
function interactiveListSelection(): void {
  const allResults = loadPerformanceResults();
  const allGroups = groupResultsByTest(allResults);
  const testKeys = Object.keys(allGroups);
  
  if (testKeys.length === 0) {
    console.log('âŒ No test results found');
    return;
  }

  let selectedIndex = 0;
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });

  // Hide cursor for better UX
  process.stdout.write('\x1B[?25l');
  
  function displayList(): void {
    // Clear screen and move cursor to top
    process.stdout.write('\x1B[2J\x1B[H');
    
    console.log('â”Œ' + 'â”€'.repeat(62) + 'â”');
    console.log('â”‚ ðŸ“‹ Select a test to compare (use â†‘â†“ arrows, Enter to select) â”‚');
    console.log('â””' + 'â”€'.repeat(62) + 'â”˜');
    console.log('');
    
    // Add "Compare All Tests" option at the top
    const isAllSelected = selectedIndex === 0;
    const allIndicator = isAllSelected ? 'â¯ ' : '  ';
    const allHighlight = isAllSelected ? '\x1B[7m' : '';
    const resetColor = '\x1B[0m';
    console.log(`${allIndicator}${allHighlight}Compare All Tests${resetColor}`);
    console.log('');
    
    testKeys.forEach((testKey, index) => {
      const results = allGroups[testKey];
      const isSelected = index + 1 === selectedIndex;
      const indicator = isSelected ? 'â¯ ' : '  ';
      const highlight = isSelected ? '\x1B[7m' : '';
      
      console.log(`${indicator}${highlight}${testKey}${resetColor}:`);
      
      if (results.length > 1) {
        const oldest = results[results.length - 1];
        const newest = results[0];
        console.log(`    ${oldest.timestamp} (${oldest.summary.totalDuration.toFixed(DECIMAL_PLACES)}ms total) - BASELINE`);
        console.log(`    ${newest.timestamp} (${newest.summary.totalDuration.toFixed(DECIMAL_PLACES)}ms total) - LATEST`);
      } else {
        console.log(`    ${results[0].timestamp} (${results[0].summary.totalDuration.toFixed(DECIMAL_PLACES)}ms total) - BASELINE`);
      }
      console.log('');
    });
    
    // Add "Quit" option at the bottom
    const isQuitSelected = selectedIndex === testKeys.length + 1;
    const quitIndicator = isQuitSelected ? 'â¯ ' : '  ';
    const quitHighlight = isQuitSelected ? '\x1B[7m' : '';
    console.log(`${quitIndicator}${quitHighlight}Quit (q)${resetColor}`);
  }

  function cleanupAndExit(): void {
    process.stdout.write('\x1B[?25h'); // Show cursor
    process.stdin.setRawMode(false);
    process.stdin.pause();
    rl.close();
    process.exit(0);
  }

  function handleKeypress(str: string, key: { name: string; ctrl: boolean }): void {
    const totalOptions = testKeys.length + 2;
    
    if (key.name === 'up' && selectedIndex > 0) {
      selectedIndex--;
      displayList();
    } else if (key.name === 'down' && selectedIndex < totalOptions - 1) {
      selectedIndex++;
      displayList();
    } else if (key.name === 'return' || key.name === 'enter') {
      if (selectedIndex === 0) {
        // "Compare All Tests" selected
        process.stdout.write('\x1B[?25h');
        process.stdin.setRawMode(false);
        process.stdin.pause();
        
        compareAllTests();
        
        console.log('\nPress any key to return to the list...');
        process.stdin.setRawMode(true);
        process.stdin.resume();
        process.stdin.once('data', () => {
          displayList();
          process.stdout.write('\x1B[?25l');
        });
      } else if (selectedIndex === testKeys.length + 1) {
        // "Quit" selected
        cleanupAndExit();
      } else {
        // Specific test selected
        const testIndex = selectedIndex - 1;
        const selectedTestKey = testKeys[testIndex];
        const testResults = allGroups[selectedTestKey];
        
        process.stdout.write('\x1B[?25h');
        process.stdin.setRawMode(false);
        process.stdin.pause();
        
        if (testResults.length < 2) {
          displaySingleTestResult(testResults[0]);
        } else {
          const baseline = testResults[testResults.length - 1];
          const latest = testResults[0];
          const comparison = compareResults(baseline, latest);
          printComparison(comparison);
        }
        
        console.log('\nPress any key to return to the list...');
        process.stdin.setRawMode(true);
        process.stdin.resume();
        process.stdin.once('data', () => {
          displayList();
          process.stdout.write('\x1B[?25l');
        });
      }
    } else if (key.ctrl && key.name === 'c') {
      cleanupAndExit();
    } else if (key.name === 'q' || key.name === 'Q') {
      cleanupAndExit();
    }
  }

  // Set up keypress handling
  process.stdin.setRawMode(true);
  process.stdin.resume();
  process.stdin.on('data', (data: Buffer) => {
    const key: { name: string; ctrl: boolean } = { name: '', ctrl: false };
    
    // Parse arrow keys and other special keys
    if (data[0] === 27 && data[1] === 91) {
      if (data[2] === 65) key.name = 'up';
      else if (data[2] === 66) key.name = 'down';
    } else if (data[0] === 13) {
      key.name = 'enter';
    } else if (data[0] === 3) {
      key.ctrl = true;
      key.name = 'c';
    } else if (data[0] === 113 || data[0] === 81) {
      key.name = data[0] === 113 ? 'q' : 'Q';
    }
    
    handleKeypress(data.toString(), key);
  });

  displayList();
}

/**
 * Main entry point
 */
function main(): void {
  const args = process.argv.slice(2);
  const command = args[0];

  // Handle help flags
  if (command === '-h' || command === '--help') {
    showHelp();
    return;
  }

  // If no command provided, compare all tests
  if (!command) {
    compareAllTests();
    return;
  }

  // Check if it's a known command
  if (command === 'list') {
    interactiveListSelection();
    return;
  }

  // If not a known command, treat as test name
  const testName = command;
  const results = loadPerformanceResults();
  const groups = groupResultsByTest(results);
  const testKey = Object.keys(groups).find(key => key.includes(testName));

  if (!testKey || groups[testKey].length < 2) {
    console.log(`âŒ Need at least 2 runs for test: ${testName}`);
    console.log(`Available tests: ${Object.keys(groups).join(', ')}`);
    console.log('Use "node scripts/compare-e2e-performance.js list" to see available test names');
    console.log('Or run "node scripts/compare-e2e-performance.js" to compare all tests');
    return;
  }

  const testResults = groups[testKey];
  const baseline = testResults[testResults.length - 1];
  const latest = testResults[0];

  const comparison = compareResults(baseline, latest);
  printComparison(comparison);
}

if (require.main === module) {
  main();
} 