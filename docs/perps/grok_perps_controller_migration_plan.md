# Implementation Plan for PerpsController Refactor

**Based on Service Layer Extraction Strategy**  
**Generated by: Grok-4-0709**  
**Goal**: Achieve a modular PerpsController (~500 lines) by extracting business logic into stateless services, while maintaining 100% backward compatibility. The migration is designed to be gradual, with each step fully testable and deployable without breaking existing functionality. No public API changes—upper layers (e.g., PerpsConnectionManager) remain unaffected.

## Guiding Principles

- **Backward Compatibility**: Preserve all public methods (e.g., `placeOrder(params)`, `initializeProviders()`). Use delegation: Controller methods call services internally but return the same results.
- **No-Break Migration**:
  - Extract one service at a time.
  - Validate each change immediately through comprehensive testing before proceeding.
  - Test each step: Unit tests for new services, integration tests for Controller, end-to-end tests for the full stack.
  - Run performance checks on mobile simulators after each step.
- **Stateless Services**: Services receive an options object (e.g., `{ provider, params }`) and return results—no internal state.
- **Tools & Best Practices**: Use TypeScript for type safety. Mock providers in tests. Limit changes to 1-2 files per step to minimize risk.
- **Team Assumptions**: 2 developers, intermediate TypeScript skills—pair program complex steps.
- **Rollback**: Each step is additive; if issues arise, revert the commit via git and restore from backups.

## Prerequisites (Before Starting)

1. **Backup & Branch**: Create a feature branch (e.g., `feat/perps-controller-refactor`). Backup the original `PerpsController.ts` and tests.
2. **Setup Testing**: Ensure 80%+ coverage on current code.
3. **Directory Setup**: Create `app/core/perps/services/` and `app/core/perps/tests/services/`.
4. **Define Interfaces**: Add a simple `IPerpsService` interface for mocking (e.g., with `placeOrder(options)`).

## Step-by-Step Migration Plan

Follow the recommended order from the strategy. Each step includes:

- **Actions**: What to do.
- **Compatibility Checks**: How to ensure no breaks.
- **Testing**: Required tests.
- **Rollback**: Quick revert plan.

### Step 1: Extract Low-Risk Pure Logic (FeeCalculationService & EligibilityService)

- **Why First**: These are stateless, pure functions (e.g., math for fees, geo-checks)—easiest to extract and test independently. No provider dependency.
- **Actions**:
  1. Identify methods in PerpsController (e.g., `calculateOrderFee`, geo/eligibility checks).
  2. Create `FeeCalculationService.ts` and `EligibilityService.ts` in `services/`.
  3. Move logic to services with object params (e.g., `FeeCalculationService.calculateOrderFee(options: { order: Order })`).
  4. In PerpsController, directly replace original logic with calls to the new services.
- **Compatibility Checks**: Run full app—ensure fee calcs and eligibility return identical results (use snapshots).
- **Testing**:
  - Unit: 100% coverage for services (mock nothing—pure functions).
  - Integration: Update Controller tests to validate new delegation paths; assert same outputs as before.
  - E2E: Test UI flows involving fees/eligibility.
- **Rollback**: Revert the commit; restore original Controller logic from backup.
- **Expected Outcome**: Controller unchanged externally; services handle pure calcs.

### Step 2: Extract Data-Related Logic (MarketDataService)

- **Why Next**: Builds on Step 1; involves fetching/parsing (e.g., positions, markets) with provider delegation, but low complexity.
- **Actions**:
  1. Identify data methods (e.g., `getMarkets`, `getPositions`).
  2. Create `MarketDataService.ts`.
  3. Move fetching/parsing logic (e.g., `MarketDataService.getPositions(options: { provider: HyperLiquidProvider })`).
  4. In PerpsController, directly replace original logic with calls to the new service, passing `{ provider: this.hyperLiquidProvider }`.
- **Compatibility Checks**: Compare outputs from old/new paths (e.g., via API calls); ensure Redux updates match.
- **Testing**:
  - Unit: Mock provider in service tests (focus on parsing/adaptation).
  - Integration: Update Controller tests to validate new delegation paths; verify outputs match previous behavior.
  - E2E: Test data-displaying screens (e.g., market lists).
- **Rollback**: Revert the commit; restore original Controller logic from backup.
- **Expected Outcome**: Data ops offloaded; Controller slimmer.

### Step 3: Extract Core Operations (TradingService & AccountService)

- **Why Here**: Higher complexity (e.g., orders, deposits)—depends on previous services (e.g., uses FeeCalculationService).
- **Actions**:
  1. Identify ops (e.g., `placeOrder`, `withdraw` for TradingService/AccountService).
  2. Create services; move validation/formatting/execution (e.g., `TradingService.placeOrder(options: { provider, params })` calls provider's SDK).
  3. In PerpsController, directly replace original logic with calls to the new services; handle Redux/analytics post-call.
- **Compatibility Checks**: Compare results/errors from full flows; ensure identical behavior.
- **Testing**:
  - Unit: Mock provider; test edge cases (e.g., invalid params).
  - Integration: Update Controller tests to validate new delegation paths; compare with original outputs.
  - E2E: Critical paths (e.g., placing orders, withdrawals).
- **Rollback**: Revert the commit; restore original Controller logic from backup.
- **Expected Outcome**: Most bloat extracted; Controller ~500 lines.

### Step 4: Refactor WebSocket Subscriptions and Final Cleanup

- **Why Last**: Touches live data; depends on all services (e.g., update positions via MarketDataService).
- **Actions**:
  1. Move subscription logic (e.g., `subscribeToPositions`) to relevant services (e.g., MarketDataService).
  2. In PerpsController, directly replace original logic with calls to service methods for subscriptions.
  3. Delete any remaining old inline logic.
  4. Optimize: Tree-shake unused code; update docs.
- **Compatibility Checks**: Monitor live sessions; ensure no data loss/flickers.
- **Testing**:
  - Unit: Mock WS in services.
  - Integration: Simulate subscriptions in Controller tests.
  - E2E: Full app with real-time data.
- **Rollback**: Revert the commit; restore from backup.
- **Expected Outcome**: Fully refactored; tests migrated.

## Post-Migration

- **Validation**: Run full regression tests; monitor production metrics (e.g., latency, errors).
- **Documentation**: Update architecture docs with new services.
- **Future-Proofing**: Services use object params for easy extension.
